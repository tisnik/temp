<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Aritmetické operace s hodnotami uloženými binárně i v BCD</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Aritmetické operace s hodnotami uloženými binárně i v BCD</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Aritmetické operace s&nbsp;hodnotami uloženými binárně i v&nbsp;BCD</a></p>
<p><a href="#k02">*** 2. Podprogram pro tisk hexadecimální cifry i osmibitové hexadecimální hodnoty</a></p>
<p><a href="#k03">3. Demonstrační příklad, který vytiskne několik specifických hexadecimálních hodnot na obrazovku</a></p>
<p><a href="#k04">4. Optimalizace předchozího demonstračního příkladu</a></p>
<p><a href="#k05">*** 5. Rutina pro tisk tabulky s&nbsp;větším množstvím hexadecimálních hodnot</a></p>
<p><a href="#k06">*** 6. Úplný zdrojový kód dnešního třetího demonstračního příkladu</a></p>
<p><a href="#k07">*** 7. Součet osmibitových hodnot uložených ve standardním binárním kódu</a></p>
<p><a href="#k08">*** 8. Tisk tabulky se sčítanci i součty</a></p>
<p><a href="#k09">*** 9. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</a></p>
<p><a href="#k10">10. Uložení numerických hodnot ve formátu BCD a Packed BCD</a></p>
<p><a href="#k11">11. Podpora pro výpočty v&nbsp;BCD v&nbsp;instrukčních sadách mikroprocesorů</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. Realizace součtu dvou numerických hodnot uložených ve formátu Packed BCD</a></p>
<p><a href="#k14">*** 14. Tisk tabulky se sčítanci i součty</a></p>
<p><a href="#k15">15. Úplný zdrojový kód dnešního pátého demonstračního příkladu</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Aritmetické operace s&nbsp;hodnotami uloženými binárně i v&nbsp;BCD</h2>

<p>Na <a
href="https://www.root.cz/clanky/zobrazeni-cisel-a-zpracovani-priznaku-mikroprocesoru-zilog-z80/">předchozí
článek</a> o tvorbě aplikací pro slavný osmibitový mikropočítač ZX Spectrum
v&nbsp;assembleru dnes navážeme. Připomeňme si, že minule jsme si nejprve
ukázali, jakým způsobem lze využít rutinu pojmenovanou
<strong>OUT_NUM_1</strong> a uloženou v&nbsp;paměti ROM pro tisk dekadických
hodnot v&nbsp;rozsahu od 0 do 9999. Dále jsme si popsali funkce a vlastnosti
pěti základních příznaků (<i>flags</i>) mikroprocesoru Zilog Z80 &ndash;
<i>carry</i>, <i>zero</i>, <i>add/subtract</i>, <i>overflow</i> a
<i>sign</i>.</p>

<img src="https://i.iinfo.cz/images/259/devel-speccy-8-1.png" class="image-1085768" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 1: Výpis numerických hodnot na obrazovku podprogramem uloženým
v&nbsp;ROM. Konkrétně se jedná o minule popsanou subrutinu nazvanou
<strong>OUT_NUM_1</strong>.</i></p>

<p>Dnes se nejprve ukážeme, jak by mohla vypadat poměrně přímočaře
naprogramovaná subrutina určená pro tisk osmibitové hexadecimální hodnoty
v&nbsp;rozsahu od 0x00 do 0xff. Uvidíme, že se v&nbsp;této subrutině použije
podmíněný skok. Ovšem ve skutečnosti je možné využít určité triky a napsat tuto
subrutinu i bez skoku, a to konkrétně tak, že se využije doposud nepopsaný
příznak <i>half carry</i> a s&nbsp;ním související instrukce
<strong>DAA</strong>. Proto si nejprve ukážeme, jak probíhá součet (nebo i
rozdíl) hodnot uložených v&nbsp;binárním kódu i v&nbsp;kódu BCD
(<i>Binary-coded decimal</i>), protože jak příznak <i>half carry</i>, tak i
instrukce <strong>DAA</strong> původně s&nbsp;BCD velmi úzce souvisí
(resp.&nbsp;přesněji řečeno souvisí s&nbsp;variantou, která se nazývá <i>packed
BCD</i>).</p>

<img src="https://i.iinfo.cz/images/259/devel-speccy-8-4.png" class="image-1085771" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 2: Výsledek pokusu o vytištění záporného čísla standardní
subrutinou <strong>OUT_NUM_1</strong>.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podprogram pro tisk hexadecimální cifry i osmibitové hexadecimální hodnoty</h2>

<p>Ukažme si nejprve, jak by mohla vypadat prozatím dosti primitivně
naprogramovaná subrutina určená pro tisk jedné šestnáctkové (hexadecimální)
cifry. Tato subrutina předpokládá, že v&nbsp;pracovním registru
<strong>A</strong> (akumulátoru) bude uložena hodnota 0x00 až 0x0f, přičemž
spodní cifra 0x0 až 0xf se vytiskne k&nbsp;tomu určeným standardním
podprogramem z&nbsp;ROM. V&nbsp;podstatě nám pouze postačuje určit, zda se má
tisknout ASCII hodnota &bdquo;0&ldquo; až &bdquo;9&ldquo; či &bdquo;A&ldquo; až
&bdquo;F&ldquo;. Tyto hodnoty netvoří ucelenou řadu, takže musíme provést
podmíněný skok:</p>

<pre>
<strong>print_hex_digit</strong>:
        cp   0x0a           <i>; test, jestli je číslice menší než 10</i>
        jr c, print_0_to_9  <i>; ok, hodnota je menší než 10, budeme tedy tisknout desítkovou číslici</i>
        add  A, 65-10       <i>; ASCII kód znaku 'A', ovšem začínáme od desítky, ne od nuly</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
        ret                 <i>; návrat ze subrutiny</i>
<strong>print_0_to_9</strong>:
        add  A, 48          <i>; ASCII kód znaku '0'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
        ret                 <i>; návrat ze subrutiny</i>
</pre>

<p>Aby se vytiskla celá osmibitová hodnota 0x00 až 0xFF, je nutné provést tisk
vyšší cifry a poté cifry nižší. To lze realizovat velmi snadno s&nbsp;využitím
bitových posunů spojených s&nbsp;maskováním:</p>

<pre>
<strong>print_hex_number</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        rrca                <i>; rotace o čtyři bity doprava</i>
        rrca
        rrca
        rrca
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        call <strong>print_hex_digit</strong><i>; vytisknout hexa číslici</i>
&nbsp;
        pop  AF             <i>; obnovit A</i>
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        call <strong>print_hex_digit</strong><i>; vytisknout hexa číslici</i>
        ret                 <i>; a návrat z podprogramu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: alternativně lze maskování přesunout do
subrutiny <strong>print_hex_digit</strong>, což vede ke kratšímu
kódu.</div></p>

<p>Jak je to obvyklé prakticky ve všech instrukčních sadách, je možné dvojici
instrukcí <strong>CALL+RET</strong> nahradit za jedinou instrukci přímého
skoku. Podprogram pro tisk hexadecimální hodnoty tedy pozměníme takto:</p>

<pre>
<strong>print_hex_number</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        rrca                <i>; rotace o čtyři bity doprava</i>
        rrca
        rrca
        rrca
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        call <strong>print_hex_digit</strong><i>; vytisknout hexa číslici</i>
&nbsp;
        pop  AF             <i>; obnovit A</i>
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        jp   <strong>print_hex_digit</strong><i>; vytisknout hexa číslici</i>
                            <i>; a návrat z podprogramu</i>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstrační příklad, který vytiskne několik specifických hexadecimálních hodnot na obrazovku</h2>

<p>Výše uvedenou rutinu několikrát zavoláme a získáme na tak obrazovce několik
hexadecimálních hodnot:</p>

*** image ***
<p><i>Obrázek 3: Několik hexadecimálních hodnot vytištěných na obrazovku ZX
Spectra.</i></p>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu vypadá
následovně:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS        <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   A, 0x00        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0x01        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0x09        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0x99        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0x0a        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0xa0        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0xba        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0xff        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ret                 <i>; návrat z programu do BASICu</i>
&nbsp;
<strong>print_hex_number</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        rrca                <i>; rotace o čtyři bity doprava</i>
        rrca
        rrca
        rrca
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        call print_hex_digit; vytisknout hexa číslici
&nbsp;
        pop  AF             <i>; obnovit A</i>
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        call print_hex_digit<i>; vytisknout hexa číslici</i>
        ret                 <i>; a návrat z podprogramu</i>
&nbsp;
<strong>print_hex_digit</strong>:
        cp   0x0a           <i>; test, jestli je číslice menší než 10</i>
        jr c, print_0_to_9  <i>; ok, hodnota je menší než 10, budeme tedy tisknout desítkovou číslici</i>
        add  A, 65-10       <i>; ASCII kód znaku 'A', ovšem začínáme od desítky, ne od nuly</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
        ret                 <i>; návrat ze subrutiny</i>
print_0_to_9:
        add  A, 48          <i>; ASCII kód znaku '0'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
new_line:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>A podívejme se ještě na způsob překladu tohoto zdrojového kódu
z&nbsp;assembleru do strojového kódu:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:3E00       LD A, 00
8005:CD4480     CALL 8044
8008:CD6180     CALL 8061
800B:3E01       LD A, 01
800D:CD4480     CALL 8044
8010:CD6180     CALL 8061
8013:3E09       LD A, 09
8015:CD4480     CALL 8044
8018:CD6180     CALL 8061
801B:3E99       LD A, 99
801D:CD4480     CALL 8044
8020:CD6180     CALL 8061
8023:3E0A       LD A, 0A
8025:CD4480     CALL 8044
8028:CD6180     CALL 8061
802B:3EA0       LD A, A0
802D:CD4480     CALL 8044
8030:CD6180     CALL 8061
8033:3EBA       LD A, BA
8035:CD4480     CALL 8044
8038:CD6180     CALL 8061
803B:3EFF       LD A, FF
803D:CD4480     CALL 8044
8040:CD6180     CALL 8061
8043:C9         RET
8044:           label print_hex_number
8044:F5         PUSH AF
8045:0F         RRCA
8046:0F         RRCA
8047:0F         RRCA
8048:0F         RRCA
8049:E60F       AND 0F
804B:CD5580     CALL 8055
804E:F1         POP AF
804F:E60F       AND 0F
8051:CD5580     CALL 8055
8054:C9         RET
8055:           label print_hex_digit
8055:FE0A       CP 0A
8057:3804       JR C, 805D
8059:C637       ADD A, 37
805B:D7         RST 10
805C:C9         RET
805D:           label print_0_to_9
805D:C630       ADD A, 30
805F:D7         RST 10
8060:C9         RET
8061:           label new_line
8061:3E0D       LD A, 0D
8063:D7         RST 10
8064:C9         RET
8065:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8064
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Optimalizace předchozího demonstračního příkladu</h2>


<p>Již <a href="#k03">ve druhé kapitole</a> jsme si řekli, že kód je možné
velmi snadno (i když jen nepatrně) optimalizovat tak, že se dvojice za sebou
jdoucích instrukcí <strong>CALL+RET</strong> nahradí za přímý skok. Výsledkem
bude tento kód:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS        <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   A, 0x00        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0x01        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0x09        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0x99        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0x0a        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0xa0        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0xba        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ld   A, 0xff        <i>; vytisknout hexa hodnotu s přechodem na nový řádek</i>
        call print_hex_number
        call new_line
&nbsp;
        ret                 <i>; návrat z programu do BASICu</i>
&nbsp;
<strong>print_hex_number</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        rrca                <i>; rotace o čtyři bity doprava</i>
        rrca
        rrca
        rrca
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        call print_hex_digit; vytisknout hexa číslici
&nbsp;
        pop  AF             <i>; obnovit A</i>
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        jp print_hex_digit  <i>; vytisknout hexa číslici a návrat z podprogramu</i>
&nbsp;
<strong>print_hex_digit</strong>:
        cp   0x0a           <i>; test, jestli je číslice menší než 10</i>
        jr c, print_0_to_9  <i>; ok, hodnota je menší než 10, budeme tedy tisknout desítkovou číslici</i>
        add  A, 65-10-48    <i>; ASCII kód znaku 'A', ovšem začínáme od desítky, ne od nuly (+ update pro další ADD)</i>
print_0_to_9:
        add  A, 48          <i>; ASCII kód znaku '0'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
new_line:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Ještě si pro úplnost uveďme symbolicky popsanou podobu výsledného strojového
kódu, který je o tři bajty kratší, než kód originální:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:3E00       LD A, 00
8005:CD4480     CALL 8044
8008:CD5E80     CALL 805E
800B:3E01       LD A, 01
800D:CD4480     CALL 8044
8010:CD5E80     CALL 805E
8013:3E09       LD A, 09
8015:CD4480     CALL 8044
8018:CD5E80     CALL 805E
801B:3E99       LD A, 99
801D:CD4480     CALL 8044
8020:CD5E80     CALL 805E
8023:3E0A       LD A, 0A
8025:CD4480     CALL 8044
8028:CD5E80     CALL 805E
802B:3EA0       LD A, A0
802D:CD4480     CALL 8044
8030:CD5E80     CALL 805E
8033:3EBA       LD A, BA
8035:CD4480     CALL 8044
8038:CD5E80     CALL 805E
803B:3EFF       LD A, FF
803D:CD4480     CALL 8044
8040:CD5E80     CALL 805E
8043:C9         RET
8044:           label print_hex_number
8044:F5         PUSH AF
8045:0F         RRCA
8046:0F         RRCA
8047:0F         RRCA
8048:0F         RRCA
8049:E60F       AND 0F
804B:CD5480     CALL 8054
804E:F1         POP AF
804F:E60F       AND 0F
8051:C35480     JP 8054
8054:           label print_hex_digit
8054:FE0A       CP 0A
8056:3802       JR C, 805A
8058:C607       ADD A, 07
805A:           label print_0_to_9
805A:C630       ADD A, 30
805C:D7         RST 10
805D:C9         RET
805E:           label new_line
805E:3E0D       LD A, 0D
8060:D7         RST 10
8061:C9         RET
8062:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8061
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rutina pro tisk tabulky s&nbsp;větším množstvím hexadecimálních hodnot</h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. Úplný zdrojový kód dnešního třetího demonstračního příkladu</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Součet osmibitových hodnot uložených ve standardním binárním kódu</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Tisk tabulky se sčítanci i součty</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu popsaného
v&nbsp;předchozích dvou kapitolách je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/77-add-hex-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/77-add-hex-numbers.asm</a>:</p>

<pre>
</pre>

<p>Překlad do strojového kódu bude vypadat takto:</p>

<pre>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Uložení numerických hodnot ve formátu BCD a Packed BCD</h2>

<p>Ve druhé části dnešního článku se budeme zabývat uložením numerických hodnot
ve formátu BCD; konkrétně nás bude zajímat varianta nazývaná <i>Packed BCD</i>.
Zkratkou BCD neboli <i>Binary-coded decimal</i> se označuje skupina kódování
numerických hodnot založená na jednoduchém principu &ndash; každá desítková
číslice je uložena ve čtyřech bitech. Tyto čtyři bity jsou buď uloženy
v&nbsp;samostatném bajtu (co bajt, to jediná číslice) nebo jsou vždy
&bdquo;dvojice čtveřic&ldquo; bitů uloženy do jediného bajtu. Druhý zmíněný
formát se nazývá <i>Packed BCD</i> a v&nbsp;naprosté většině případů se jedná o
variantu <i>big endian</i> (a to nezávisle na procesorové architektuře).</p>

<p>V&nbsp;případě, že je nutné pracovat například s&nbsp;hodnotami
v&nbsp;rozsahu 0 až 99999, je nutné pro takové BCD hodnoty alokovat pro každou
číslici čtyři bity a celkem je tedy minimálně nutné použít 5&times;4=20 bitů.
Naproti tomu v&nbsp;případě použití binárního kódování je zapotřebí pouze
sedmnácti bitů, protože 2<sup>17</sup>=131072 &gt; 99999.</p>

<p>BCD se v&nbsp;nejjednodušším případě používá pro uložení celých čísel, a to
buď bez znaménka (jednotlivé cifry, jak již bylo naznačeno výše) nebo se
znaménkem (potom je znaménko typicky uloženo ve vlastním bitu, nebo se navíc
používá dvojkový doplněk, to ovšem méně často). Ovšem můžeme se setkat i
s&nbsp;takzvaným FX formátem (<i>fixed point</i>), v&nbsp;němž je desetinná
tečka umístěna za předem známou cifrou a je neměnná &ndash; počet cifer před
desetinnou tečkou a za ní je stále stejný. To znamená, že se v&nbsp;takovém
případě nemusí ukládat exponent, který u FP hodnot přímo či nepřímo určoval
pozici řádové čárky v&nbsp;uloženém číslu.</p>

<p><div class="rs-tip-major">Poznámka: i když by se mohlo zdát, že je BCD dnes
již překonaný, není tomu tak, protože se používá ve specifických oblastech,
v&nbsp;nichž záleží například na každém haléři (centu) atd.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Podpora pro výpočty v&nbsp;BCD v&nbsp;instrukčních sadách mikroprocesorů</h2>

<p>Výpočty s&nbsp;číselnými hodnotami uloženými v&nbsp;kódu BCD se ve výpočetní
technice používají již od první generace (elektronkových) mainframů, které
společnost IBM vyráběla v&nbsp;padesátých letech minulého století. Dnes se
s&nbsp;BCD setkáme například při programování mikrořadičů, protože některé
sedmisegmentové LCD, čipy s&nbsp;hodinami reálného času či malé numerické
klávesnice kód BCD používají. Ostatně i z&nbsp;tohoto důvodu výpočty v&nbsp;BCD
podporuje většina mikrořadičů, s&nbsp;výjimkou některých řad osmibitových
mikrořadičů PIC. Čipy podporující výpočty v&nbsp;BCD můžeme rozdělit do tří
kategorií:</p>

<ol>

<li>Registry přímo obsahují BCD (typicky dvě číslice 00-99) a ALU taktéž
produkuje výsledek v&nbsp;BCD. Typickým příkladem je slavný osmibitový
mikroprocesor <i>MOS 6502</i>, který lze přepnout do &bdquo;dekadického
režimu&ldquo; instrukcí <strong>SED</strong> (<i>Set Decimal Mode</i>) či se
přepnout zpátky instrukcí <strong>CLD</strong> (<i>Clear Decimal
Mode</i>).</li>

<li>ALU sice provádí výpočty v&nbsp;binárním kódu, ale po provedení výpočtu je
možné explicitně provést úpravu výsledku na BCD (na základě nastavených
příznaků přenosu a polovičního přenosu). Typickým příkladem jsou čipy <i>Intel
8048</i>, <i>Intel 8051</i>, <i>Motorola 6809</i>, <i>Motorola 68HC11</i> atd.
atd. s&nbsp;instrukcí <strong>DAA</strong> či <strong>DA A</strong> používanou
po operaci součtu a rozdílu. Podobná je instrukce <strong>A6AAC</strong> u
čtyřbitových mikrořadičů TMS-1000. S&nbsp;tímto konceptem se blíže seznámíme
v&nbsp;dalších kapitolách.</li>

<li>ALU provádí většinu operací v&nbsp;binárním režimu, ovšem některé instrukce
ji mohou přepnout do režimu BCD. Příkladem je <i>Motorola 68000</i>
s&nbsp;instrukcemi <strong>ABCD</strong> (Add Binary Coded Decimal),
<strong>NBCD</strong> (Negate Binary Coded Decimal) a <strong>SBCD</strong>
(Subtract Binary Coded Decimal).</li>

</ol>

<img src="https://i.iinfo.cz/images/208/tms1000-4.jpg" class="image-284545" alt="&#160;" width="236" height="261" />
<p><i>Obrázek XX: Jedna z&nbsp;typických nasazení čtyřbitových mikrořadičů
&ndash; nejjednodušší kalkulačky .</i></p>

<p>Některé mikroprocesory obsahují větší množství instrukcí pro úpravu výsledku
a/nebo vstupních operandů. Příkladem může být čip 8086 (s&nbsp;instrukční sadou
udržovanou dodnes), podporující jak &bdquo;packed BCD&ldquo; (dvě cifry
v&nbsp;bajtu), tak i &bdquo;unpacked BCD&ldquo; (jediná cifra v&nbsp;bajtu).
V&nbsp;instrukční sadě nalezneme hned šest relevantních instrukcí:</p>

<table>
<tr><th>Operace</th><th>Packed BCD</th><th>Unpacked BCD</th></tr>
<tr><td>součet</td><td>DAA</td><td>AAA</td></tr>
<tr><td>rozdíl</td><td>DAS</td><td>AAS</td></tr>
<tr><td>součin</td><td>&times;</td><td>AAM</td></tr>
<tr><td>podíl</td><td>&times;</td><td>AAD</td></tr>
</table>

<p>BCD používá i matematický koprocesor x86 (konkrétně čip 8087 a kvůli zpětné
kompatibilitě i dnešní CPU+FPU), který dokáže do osmdesáti bitového slova
uložit 18 BCD cifer + znaménko (necelé dva bajty se přitom nevyužijí).</p>

<p><div class="rs-tip-major">Poznámka: S&nbsp;kódem BCD poměrně úzce souvisí i
kódování znaků <strong>EBCDIC</strong> neboli <i>Extended Binary Coded Decimal
Interchange Code</i>. Firma IBM toto kódování vytvořila v&nbsp;letech
1963&ndash;1964 v&nbsp;návaznosti na šestibitový kód využívaný u děrných štítků
a použila ho u počítačů <i>System/360</i>. Vzhledem k&nbsp;velké popularitě
těchto počítačů se kódování <strong>EBCDIC</strong> i přes jeho mnohé nevýhody
(především v&nbsp;porovnání s&nbsp;kódováním <strong>ASCII</strong>) rozšířilo
i na další počítače a jejich operační systémy, například <i>OS/390</i>,
<i>z/OS</i>, <i>OS/400</i> i některé počítačové systémy firem HP či
Unisys.</div></p>

<a href="https://www.root.cz/obrazek/284548/"><img src="https://i.iinfo.cz/images/208/tms1000-7-prev.jpg" class="image-284548" alt="&#160;" width="370" height="191" /></a></p>
<p><i>Obrázek XX: Segmentem, v&nbsp;němž se BCD používá dodnes, jsou
kalkulačky.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Příznak <i>half carry</i> a instrukce <strong>DAA</strong></h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Realizace součtu dvou numerických hodnot uložených ve formátu Packed BCD</h2>

<p></p>

<pre>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Tisk tabulky se sčítanci i součty</h2>

<p></p>

<pre>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Úplný zdrojový kód dnešního pátého demonstračního příkladu</h2>

<p>Úplný zdrojový kód demonstračního příkladu popsaného v&nbsp;předchozích dvou
kapitolách je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/78-add-bcd-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/78-add-bcd-numbers.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS           <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   HL, array1        <i>; vytištění 11 hodnot z pole array1 v hexadecimálním formátu</i>
        ld   B, 11
        call print_numbers
&nbsp;
        ld   HL, array2        <i>; vytištění 11 hodnot z pole array2 v hexadecimálním formátu</i>
        ld   B, 11
        call print_numbers
&nbsp;
        call new_line          <i>; odřádkování</i>
        call new_line          <i>; (chyba v ROM subrutině nebo užitečná vlastnost?)</i>
&nbsp;
        ld   DE, array1        <i>; adresa pole s první řadou sčítanců</i>
        ld   HL, array2        <i>; adresa pole se druhou řadou sčítanců</i>
        ld   B, 11
next_add:
        ld   A, (DE)           <i>; načíst první sčítanec z pole</i>
        add  A, (HL)           <i>; načíst druhý sčítanec z pole</i>
        daa                    <i>; provést decimální korekci</i>
        inc  DE                <i>; posun ukazatele na další sčítanec</i>
        inc  HL                <i>; dtto</i>
        call print_hex_number  <i>; vytisknout hexa hodnotu výsledku</i>
        call space
        djnz next_add          <i>; kontrola počtu zobrazených výsledků</i>
        ret
&nbsp;
<i>; podprogram pro tisk sekvence numerických hodnot v hexadecimálním formátu</i>
<i>; vstupy:</i>
<i>;         HL - ukazatel na pole s hodnotami</i>
<i>;         B - počet hodnot (délka pole)</i>
<strong>print_numbers</strong>:
next_item:
        ld   A, (HL)           <i>; načíst hodnotu z pole</i>
        inc  HL                <i>; přechod na další prvek pole</i>
        call print_hex_number  <i>; vytisknout hexa hodnotu</i>
        ld   A, B
        cp   1                 <i>; za poslední hodnotou už nechceme tisknout mezeru</i>
        jr   Z, skip           <i>; přeskočení tisku mezery u poslední hodnoty</i>
        call space
skip:
        djnz next_item         <i>; zpracování dalšího prvku pole</i>
        ret
&nbsp;
array1:
        db 0x00, 0x01, 0x05, 0x09, 0x09, 0x09, 0x10, 0x10, 0xa0, 0xfe, 0xff
&nbsp;
array2:
        db 0x01, 0x02, 0x05, 0x01, 0x06, 0x07, 0x09, 0x10, 0x01, 0x01, 0x01
&nbsp;
&nbsp;
<strong>print_hex_number</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        rrca                <i>; rotace o čtyři bity doprava</i>
        rrca
        rrca
        rrca
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        call print_hex_digit; vytisknout hexa číslici
&nbsp;
        pop  AF             <i>; obnovit A</i>
        and  $0f            <i>; zamaskovat horní čtyři bity</i>
        jp print_hex_digit  <i>; vytisknout hexa číslici a návrat z podprogramu</i>
&nbsp;
<strong>print_hex_digit</strong>:
        cp   0x0a           <i>; test, jestli je číslice menší než 10</i>
        jr c, print_0_to_9  <i>; ok, hodnota je menší než 10, budeme tedy tisknout desítkovou číslici</i>
        add  A, 65-10-48    <i>; ASCII kód znaku 'A', ovšem začínáme od desítky, ne od nuly (+ update pro další ADD)</i>
print_0_to_9:
        add  A, 48          <i>; ASCII kód znaku '0'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
new_line:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
space:
        ld   A, 32          <i>; kód mezery</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Pro úplnost si ukažme způsob překladu tohoto demonstračního příkladu do
assembleru:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:213F80     LD HL, 803F
8006:060B       LD B, 0B
8008:CD2F80     CALL 802F
800B:214A80     LD HL, 804A
800E:060B       LD B, 0B
8010:CD2F80     CALL 802F
8013:CD6F80     CALL 806F
8016:CD6F80     CALL 806F
8019:113F80     LD DE, 803F
801C:214A80     LD HL, 804A
801F:060B       LD B, 0B
8021:           label next_add
8021:1A         LD A, (DE)
8022:86         ADD A, (HL)
8023:27         DAA
8024:13         INC DE
8025:23         INC HL
8026:CD5580     CALL 8055
8029:CD7380     CALL 8073
802C:10F3       DJNZ 8021
802E:C9         RET
802F:           label print_numbers
802F:           label next_item
802F:7E         LD A, (HL)
8030:23         INC HL
8031:CD5580     CALL 8055
8034:78         LD A, B
8035:FE01       CP 01
8037:2803       JR Z, 803C
8039:CD7380     CALL 8073
803C:           label skip
803C:10F1       DJNZ 802F
803E:C9         RET
803F:           label array1
803F:00010509   DEFB of 11 bytes
8043:09091010
8047:A0FEFF
804A:           label array2
804A:01020501   DEFB of 11 bytes
804E:06070910
8052:010101
8055:           label print_hex_number
8055:F5         PUSH AF
8056:0F         RRCA
8057:0F         RRCA
8058:0F         RRCA
8059:0F         RRCA
805A:E60F       AND 0F
805C:CD6580     CALL 8065
805F:F1         POP AF
8060:E60F       AND 0F
8062:C36580     JP 8065
8065:           label print_hex_digit
8065:FE0A       CP 0A
8067:3802       JR C, 806B
8069:C607       ADD A, 07
806B:           label print_0_to_9
806B:C630       ADD A, 30
806D:D7         RST 10
806E:C9         RET
806F:           label new_line
806F:3E0D       LD A, 0D
8071:D7         RST 10
8072:C9         RET
8073:           label space
8073:3E20       LD A, 20
8075:D7         RST 10
8076:C9         RET
8077:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8076
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<p>Výše uvedené demonstrační příklady i příklady, které již byly popsány
v&nbsp;předchozích osmi článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">3</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny/">4</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-podruhe/">5</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-potreti/">6</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-dokonceni-realizace-prikazu-plot/">7</a>],
[<a
href="https://www.root.cz/clanky/zobrazeni-cisel-a-zpracovani-priznaku-mikroprocesoru-zilog-z80/">8</a>],
je možné přeložit s&nbsp;využitím souboru Makefile, jehož aktuální verze vypadá
následovně (pro překlad a slinkování je použit assembler <i>Pasmo</i>):</p>

<pre>
ASSEMBLER := pasmo
&nbsp;
all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap \
    31.tap 32.tap 33.tap 34.tap 35.tap 36.tap 37.tap 38.tap 39.tap 40.tap \
    41.tap 42.tap 43.tap 44.tap 45.tap 46.tap 47.tap 48.tap 49.tap 50.tap \
    51.tap 52.tap 53.tap 54.tap 55.tap 56.tap 57.tap 58.tap 59.tap 60.tap \
    61.tap 62.tap 63.tap 64.tap 65.tap 66.tap 67.tap 68.tap 69.tap 70.tap \
    71.tap 72.tap 73.tap 74.tap 75.tap 76.tap 77.tap 78.tap
&nbsp;
clean:
        rm -f *.tap
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 01-color-attribute.lst
&nbsp;
02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 02-blinking-attribute.lst
&nbsp;
03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 03-symbolic-names.lst
&nbsp;
04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 04-operators.lst
&nbsp;
05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 05-better-symbols.lst
&nbsp;
06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 06-tapbas-v1.lst
&nbsp;
07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 07-tapbas-v2.lst
&nbsp;
08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 08-loop.lst
&nbsp;
09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 09-loop.lst
&nbsp;
10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 10-loop.lst
&nbsp;
11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 11-loop.lst
&nbsp;
12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 12-loop.lst
&nbsp;
13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 13-loop.lst
&nbsp;
14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 14-loop.lst
&nbsp;
15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 15-loop.lst
&nbsp;
16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 16-loop.lst
&nbsp;
17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 17-loop.lst
&nbsp;
18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 18-cls.lst
&nbsp;
19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 19-print-char-call.lst
&nbsp;
20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 20-print-char-rst.lst
&nbsp;
21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 21-print-char.lst
&nbsp;
22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 22-print-all-chars.lst
&nbsp;
23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 23-print-all-chars.lst
&nbsp;
24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 24-change-color.lst
&nbsp;
25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 25-change-flash.lst
&nbsp;
26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 26-print-at.lst
&nbsp;
27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 27-print-string.lst
&nbsp;
28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 28-print-string.lst
&nbsp;
29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 29-print-colorized-string.lst
&nbsp;
30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 30-print-string-ROM.lst
&nbsp;
31.tap: 31-attributes.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 31-attributes.lst
&nbsp;
32.tap: 32-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 32-fill-in-vram.lst
&nbsp;
33.tap: 33-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 33-fill-in-vram-no-ret.lst
&nbsp;
34.tap: 34-fill-in-vram-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 34-fill-in-vram-pattern.lst
&nbsp;
35.tap: 35-slow-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 35-slow-fill-in-vram.lst
&nbsp;
36.tap: 36-slow-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 36-slow-fill-in-vram-no-ret.lst
&nbsp;
37.tap: 37-fill-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 37-fill-block.lst
&nbsp;
38.tap: 38-fill-block-with-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 38-fill-block-with-pattern.lst
&nbsp;
39.tap: 39-fill-block-optimized.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 39-fill-block-optimized.lst
&nbsp;
40.tap: 40-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 40-draw-char.lst
&nbsp;
41.tap: 41-draw-any-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 41-draw-any-char.lst
&nbsp;
42.tap: 42-block-anywhere.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 42-block-anywhere.lst
&nbsp;
43.tap: 43-block-anywhere-rrca.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 43-block-anywhere-rrca.lst
&nbsp;
44.tap: 44-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 44-better-draw-char.lst
&nbsp;
45.tap: 45-even-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 45-even-better-draw-char.lst
&nbsp;
46.tap: 46-draw-char-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 46-draw-char-at.lst
&nbsp;
47.tap: 47-draw-char-at-unrolled.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 47-draw-char-at-unrolled.lst
&nbsp;
48.tap: 48-incorrect-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 48-incorrect-print-string.lst
&nbsp;
49.tap: 49-correct-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 49-correct-print-string.lst
&nbsp;
50.tap: 50-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 50-ascii-table.lst
&nbsp;
51.tap: 51-plot-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 51-plot-block.lst
&nbsp;
52.tap: 52-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 52-plot-pixel.lst
&nbsp;
53.tap: 53-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 53-plot-pixel.lst
&nbsp;
54.tap: 54-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 54-plot-pixel-on-background.lst
&nbsp;
55.tap: 55-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 55-plot-pixel-on-background.lst
&nbsp;
56.tap: 56-inverse-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 56-inverse-ascii-table.lst
&nbsp;
57.tap: 57-plot-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 57-plot-pixel-on-inverse-background.lst
&nbsp;
58.tap: 58-plot-inverse-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 58-plot-inverse-pixel-on-inverse-background.lst
&nbsp;
59.tap: 59-configurable-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 59-configurable-ascii-table.lst
&nbsp;
60.tap: 60-plot-over.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 60-plot-over.lst
&nbsp;
61.tap: 61-print-number-A.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 61-print-number-A.lst
&nbsp;
62.tap: 62-print-number-B.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 62-print-number-B.lst
&nbsp;
63.tap: 63-print-number-C.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 63-print-number-C.lst
&nbsp;
64.tap: 64-print-number-D.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 64-print-number-D.lst
&nbsp;
65.tap: 65-more-numbers-A.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 65-more-numbers-A.lst
&nbsp;
66.tap: 66-more-numbers-B.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 66-more-numbers-B.lst
&nbsp;
67.tap: 67-print-flags-1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 67-print-flags-1.lst
&nbsp;
68.tap: 68-print-flags-2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 68-print-flags-2.lst
&nbsp;
69.tap: 69-print-flags-3.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 69-print-flags-3.lst
&nbsp;
70.tap: 70-print-flags-4.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 70-print-flags-4.lst
&nbsp;
71.tap: 71-print-flags-5.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 71-print-flags-5.lst
&nbsp;
72.tap: 72-print-flags-6.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 72-print-flags-6.lst
&nbsp;
73.tap: 73-print-flags-7.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 73-print-flags-7.lst
&nbsp;
74.tap: 74-print-hex-number.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 74-print-hex-number.lst
&nbsp;
75.tap: 75-print-hex-number.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 75-print-hex-number.lst
&nbsp;
76.tap: 76-print-hex-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 76-print-hex-numbers.lst
&nbsp;
77.tap: 77-add-hex-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 77-add-hex-numbers.lst
&nbsp;
78.tap: 78-add-bcd-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 78-add-bcd-numbers.lst
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>31-attributes.asm</td><td>modifikace atributů pro tisk řetězce subrutinou uloženou v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a></td></tr>
<tr><td>32</td><td>32-fill-in-vram.asm</td><td>vyplnění celé bitmapy barvou popředí, návrat do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a></td></tr>
<tr><td>33</td><td>33-fill-in-vram-no-ret.asm</td><td>vyplnění celé bitmapy barvou popředí, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>34</td><td>34-fill-in-vram-pattern.asm</td><td>vyplnění celé bitmapy zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a></td></tr>
<tr><td>35</td><td>35-slow-fill-in-vram.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a></td></tr>
<tr><td>36</td><td>36-slow-fill-in-vram-no-ret.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>37</td><td>37-fill-block.asm</td><td>vykreslení bloku 8&times;8 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a></td></tr>
<tr><td>38</td><td>38-fill-block-with-pattern.asm</td><td>vykreslení bloku 8&times;8 pixelů zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a></td></tr>
<tr><td>39</td><td>39-fill-block-optimized.asm</td><td>optimalizace předchozího příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a></td></tr>
<tr><td>40</td><td>40-draw-char.asm</td><td>vykreslení znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a></td></tr>
<tr><td>41</td><td>41-draw-any-char.asm</td><td>podprogram pro vykreslení libovolně zvoleného znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a></td></tr>
<tr><td>42</td><td>42-block-anywhere.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>43-block-anywhere-rrca.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm</a></td></tr>
<tr><td>44</td><td>44-better-draw-char.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm</a></td></tr>
<tr><td>45</td><td>45-even-better-draw-char.asm</td><td>posun offsetu pro vykreslení dalšího znaku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm</a></td></tr>
<tr><td>46</td><td>46-draw-char-at.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm</a></td></tr>
<tr><td>47</td><td>47-draw-char-at-unrolled.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm</a></td></tr>
<tr><td>48</td><td>48-incorrect-print-string.asm</td><td>tisk řetězce, nekorektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm</a></td></tr>
<tr><td>49</td><td>49-correct-print-string.asm</td><td>tisk řetězce, korektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>50-ascii-table.asm</td><td>tisk několika bloků ASCII tabulky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm</a></td></tr>
<tr><td>51</td><td>51-plot-block.asm</td><td>vykreslení pixelu verze 1: zápis celého bajtu na pozici pixelu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm</a></td></tr>
<tr><td>52</td><td>52-plot-pixel.asm</td><td>vykreslení pixelu verze 2: korektní vykreslení jednoho pixelu, ovšem překreslení celého bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm</a></td></tr>
<tr><td>53</td><td>53-plot-pixel.asm</td><td>vykreslení pixelu verze 3: vylepšená verze předchozího demonstračního příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm</a></td></tr>
<tr><td>54</td><td>54-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (nekorektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm</a></td></tr>
<tr><td>55</td><td>55-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (korektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>56</td><td>56-inverse-ascii-table.asm</td><td>vykreslení ASCII tabulky inverzní barvou (inkoust vs. papír)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm</a></td></tr>
<tr><td>57</td><td>57-plot-pixel-on-inverse-background.asm</td><td>vykreslení pixelů barvou papíru proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm</a></td></tr>
<tr><td>58</td><td>58-plot-inverse-pixel-on-inverse-background.asm</td><td>vykreslení pixelů inverzní barvou proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/58-plot-inverse-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm58-plot-inverse-pixel-on-inverse-background.asm/</a></td></tr>
<tr><td>59</td><td>59-configurable-ascii-table.asm</td><td>vykreslení ASCII tabulky buď přímo inkoustem nebo inverzně</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm</a></td></tr>
<tr><td>60</td><td>60-plot-over.asm</td><td>přibližná implementace příkazu <strong>PLOT OVER</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>61-print-number-A.asm</td><td>ukázka použití podprogramu pro tisk celého čísla</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm</a></td></tr>
<tr><td>62</td><td>62-print-number-B.asm</td><td>pokus o vytištění záporných čísel</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm</a></td></tr>
<tr><td>63</td><td>63-print-number-C.asm</td><td>tisk maximální podporované hodnoty 9999</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm</a></td></tr>
<tr><td>64</td><td>64-print-number-D.asm</td><td>tisk vyšší než podporované hodnoty 10000</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm</a></td></tr>
<tr><td>65</td><td>65-more-numbers-A.asm</td><td>vytištění číselné řady</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm</a></td></tr>
<tr><td>66</td><td>66-more-numbers-B.asm</td><td>kombinace tisku celočíselných hodnot s&nbsp;dalšími subrutinami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm</a></td></tr>
<tr><td>67</td><td>67-print-flags-1.asm</td><td>příznakové bity po provedení celočíselné operace 1+2</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/67-print-flags-1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/67-print-flags-1.asm</a></td></tr>
<tr><td>68</td><td>68-print-flags-2.asm</td><td>příznakové bity po provedení celočíselné operace 0+0</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/68-print-flags-2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/68-print-flags-2.asm</a></td></tr>
<tr><td>69</td><td>69-print-flags-3.asm</td><td>příznakové bity po provedení operace 255+1</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/69-print-flags-3.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/69-print-flags-3.asm</a></td></tr>
<tr><td>70</td><td>70-print-flags-4.asm</td><td>příznakové bity po provedení operace 254+1</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/70-print-flags-4.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/70-print-flags-4.asm</a></td></tr>
<tr><td>71</td><td>71-print-flags-5.asm</td><td>příznakové bity po provedení operace 255+255</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/71-print-flags-5.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/71-print-flags-5.asm</a></td></tr>
<tr><td>72</td><td>72-print-flags-6.asm</td><td>výsledek operace 100+100, nastavení příznakových bitů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/72-print-flags-6.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/72-print-flags-6.asm</a></td></tr>
<tr><td>73</td><td>73-print-flags-7.asm</td><td>výsledek operace 128+128, nastavení příznakových bitů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/73-print-flags-7.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/73-print-flags-7.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>74</td><td>74-print-hex-number.asm</td><td>tisk hexadecimálního čísla v&nbsp;rozsahu 0x00 až 0xff (neoptimalizovaná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/74-print-hex-number.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/74-print-hex-number.asm</a></td></tr>
<tr><td>75</td><td>75-print-hex-number.asm</td><td>tisk hexadecimálního čísla v&nbsp;rozsahu 0x00 až 0xff (optimalizovaná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/75-print-hex-number.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/75-print-hex-number.asm</a></td></tr>
<tr><td>76</td><td>76-print-hex-numbers.asm</td><td>tisk několika hexadecimálních hodnot</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/76-print-hex-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/76-print-hex-numbers.asm</a></td></tr>
<tr><td>77</td><td>77-add-hex-numbers.asm</td><td>součet dvou osmibitových hexadecimálních hodnot s&nbsp;tiskem všech výsledků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/77-add-hex-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/77-add-hex-numbers.asm</a></td></tr>
<tr><td>78</td><td>78-add-bcd-numbers.asm</td><td>součet dvou osmibitových BCD hodnot s&nbsp;tiskem všech výsledků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/78-add-bcd-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/78-add-bcd-numbers.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>79</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech demonstračních příkladů do podoby obrazu magnetické pásky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>The system variables<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html</a>
</li>

<li>ZX Spectrum manual: chapter #17 Graphics<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html</a>
</li>

<li>Why does Sinclair BASIC have two formats for storing numbers in the same structure?<br />
<a href="https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu">https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu</a>
</li>

<li>Plovoucí řádová čárka na ZX Spectru<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

<li>1A1B: THE 'REPORT AND LINE NUMBER PRINTING' SUBROUTINE<br />
<a href="https://skoolkid.github.io/rom/asm/1A1B.html">https://skoolkid.github.io/rom/asm/1A1B.html</a>
</li>

<li>2DE3: THE 'PRINT A FLOATING-POINT NUMBER' SUBROUTINE<br />
<a href="https://skoolkid.github.io/rom/asm/2DE3.html">https://skoolkid.github.io/rom/asm/2DE3.html</a>
</li>

<li>5C63: STKBOT - Address of bottom of calculator stack<br />
<a href="https://skoolkid.github.io/rom/asm/5C63.html">https://skoolkid.github.io/rom/asm/5C63.html</a>
</li>

<li>5C65: STKEND - Address of start of spare space<br />
<a href="https://skoolkid.github.io/rom/asm/5C65.html">https://skoolkid.github.io/rom/asm/5C65.html</a>
</li>

<li>Why does Sinclair BASIC have two formats for storing numbers in the same structure?<br />
<a href="https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu">https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu</a>
</li>

<li>Chapter 24: The memory<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap24.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap24.html</a>
</li>

<li>Survey of Floating-Point Formats  <br />
<a href="https://mrob.com/pub/math/floatformats.html">https://mrob.com/pub/math/floatformats.html</a>
</li>

<li>Convert an 8bit number to hex in z80 assembler<br />
<a href="https://stackoverflow.com/questions/22838444/convert-an-8bit-number-to-hex-in-z80-assembler">https://stackoverflow.com/questions/22838444/convert-an-8bit-number-to-hex-in-z80-assembler</a>
</li>

<li>80 MICROPROCESSOR Instruction Set Summary<br />
<a href="http://www.textfiles.com/programming/CARDS/z80">http://www.textfiles.com/programming/CARDS/z80</a>
</li>

<li>Extended Binary Coded Decimal Interchange Code<br />
<a href="http://en.wikipedia.org/wiki/EBCDIC">http://en.wikipedia.org/wiki/EBCDIC</a>
</li>

<li>ASCII/EBCDIC Conversion Table<br />
<a href="http://docs.hp.com/en/32212-90008/apcs01.html">http://docs.hp.com/en/32212-90008/apcs01.html</a>
</li>

<li>EBCDIC<br />
<a href="http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php">http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php</a>
</li>

<li>EBCDIC tables<br />
<a href="http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm">http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm</a>
</li>

<li>The Mainframe Blog<br />
<a href="http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html">http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>BCD<br />
<a href="https://cs.wikipedia.org/wiki/BCD">https://cs.wikipedia.org/wiki/BCD</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

