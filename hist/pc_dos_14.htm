<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Skrytá síla karty VGA: čtecí a zápisové režimy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Skrytá síla karty VGA: čtecí a zápisové režimy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Grafické karty EGA a VGA byly postaveny na konceptu takzvaných bitových rovin, které byly z pohledu CPU mapovány do stejného adresového prostoru. To si vyžádalo podporu různých čtecích a zápisových režimů, jenž sice komplikovaly programování, ovšem přinesly výhodu velmi rychlých přenosů v rámci video RAM.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Skrytá síla karty VGA: čtecí a zápisové režimy</a></p>
<p><a href="#k02">2. Grafická operace typu <i>BitBLT</i></a></p>
<p><a href="#k03">3. První (naivní) implementace operace typu <i>BitBLT</i></a></p>
<p><a href="#k04">4. Úplný zdrojový kód dnešního prvního demonstračního příkladu</a></p>
<p><a href="#k05">5. Proč vypadá obrazovka po provedení blokového přenosu tak, jak vypadá?</a></p>
<p><a href="#k06">6. Operace <i>BitBLT</i> při povolení zápisu do různých kombinací bitových rovin</a></p>
<p><a href="#k07">7. Úplný zdrojový kód dnešního druhého demonstračního příkladu</a></p>
<p><a href="#k08">8. Stavy obrazovky v&nbsp;jednotlivých fázích druhého demonstračního příkladu</a></p>
<p><a href="#k09">9. Výběr bitové roviny pro čtení</a></p>
<p><a href="#k10">10. Postupné čtení obsahu jednotlivých bitových rovin operací typu <i>BitBLT</i></a></p>
<p><a href="#k11">11. Úplný zdrojový kód dnešního třetího demonstračního příkladu</a></p>
<p><a href="#k12">12. Stavy obrazovky v&nbsp;jednotlivých fázích třetího demonstračního příkladu</a></p>
<p><a href="#k13">13. Korektní (pomalá) realizace operace typu <i>BitBLT</i></a></p>
<p><a href="#k14">14. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</a></p>
<p><a href="#k15">15. Obrazovka před blokovým přenosem a po provedení blokového přenosu</a></p>
<p><a href="#k16">16. Realizace operace typu <i>BitBLT</i> podprogramem</a></p>
<p><a href="#k17">17. Úplný zdrojový kód dnešního pátého demonstračního příkladu</a></p>
<p><a href="#k18">18. Blokové přenosy s&nbsp;využitím 32bitového záchytného registru <i>latche</i></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Skrytá síla karty VGA: čtecí a zápisové režimy</h2>

<p>Grafické karty VGA (a nutno dodat, že vlastně i původní karty EGA) byly
postaveny, jak již dobře víme, na konceptu <i>bitových rovin</i>
(<i>bitplanes</i>). Nejlépe je toto členění grafické paměti patrné u režimů se
šestnácti barvami, takže se v&nbsp;dalším textu zaměříme především na tyto
režimy, i když všechny koncepty lze použít i v&nbsp;režimech s&nbsp;256 barvami
a <i>nezřetězenými</i> rovinami (pro standardní režim 13h to neplatí). Takže si
zopakujme základní koncepty EGA a VGA:</p>

<ul>

<li>K&nbsp;dispozici jsou čtyři bitové roviny, každá o velikosti 64kB (což
odpovídá virtuálnímu rozlišení 640&times;819 pixelů).</li>

<li>Z&nbsp;logického pohledu tyto roviny leží na sobě (tj.&nbsp;nulté bity na
sobě, první bity na sobě atd.)</li>

<li>Barvy pixelů jsou v&nbsp;16barevných režimech zapsány do čtyř bitů, přičemž
tyto bity jsou rozděleny do všech čtyř rovin (v&nbsp;každé rovině jediný
bit).</li>

<li>Fyzicky jsou všechny bitové roviny namapovány do stejného adresního
prostoru v&nbsp;segmentu 0xa000 a neexistuje zde tedy jednoznačný vztah
adresa==konkrétní osmice bitů.</li>

<li>Při čtení se přečte osm bitů z&nbsp;vybrané bitové roviny 0..3. Výběr
roviny se provádí přes I/O porty (viz další text).</li>

<li>Při zápisu se zapíše osm bitů do vybrané kombinace bitových rovin, tedy
například do roviny 1+2, do všech roviny atd. Výběr se opět provádí přes I/O
porty.</li>

<li>Při zápisu lze bity rotovat, maskovat je atd.</li>

<li>Navíc existuje několik čtecích a zápisových režimů popsaných v&nbsp;dalších
textech.</li>

<li>Při čtení se ve skutečnosti přečte osm bitů z&nbsp;každé bitové roviny
(8&times;4=32 bitů), které se uloží do záchytného registru (<i>latche</i>).
Existuje zápisový režim, který dokáže opět těchto 32bitů zapsat a přenést tak
vlastně 4 pixely jedinou strojovou instrukcí (i když se po sběrnici přenese jen
8 bitů). Toto byla velmi silná programátorská technika, ke které se
pochopitelně ještě vrátíme.</li>

</ul>



<p><a name="k02"></a></p>
<h2 id="k02">2. Grafická operace typu <i>BitBLT</i></h2>

<p>Většina historických i poměrně velká část soudobých počítačových her
s&nbsp;dvoudimenzionální (2D) grafikou je charakteristická tím, že objekty
v&nbsp;těchto hrách jsou reprezentovány s&nbsp;využitím rastrových obrázků
(bitmap) o různé velikosti, které se postupně vykreslují do vytvářené
dvoudimenzionální scény. Aby bylo přes některé části těchto rastrových obrázků
viditelné i pozadí, používají se tři metody pro zajištění úplné či částečné
průhlednosti. Buď je stanoveno, že určitá hodnota (tj.&nbsp;barva) pixelů má
být zcela průhledná (typicky se jedná o jasně fialovou barvu, která se
v&nbsp;typických scénách stejně nikde neobjevuje), dále je alternativně možné
jeden bit v&nbsp;hodnotě pixelu použít pro určení průhlednosti (typické pro
16bitovou hloubku), nebo se může stanovit průhlednost pixelů doplněním bitmapy
o takzvaný <i>alfa kanál (alpha channel)</i>.</p>

<a href="http://mojefedora.cz/wp-content/uploads/2015/12/061.png"><img class="alignnone size-medium wp-image-6211" src="http://mojefedora.cz/wp-content/uploads/2015/12/061-409x450.png" alt="06" width="409" height="450" /></a>
<p><i>Obrázek 1: Rastrové obrázky (zde zvětšené), které tvoří základ jedné RPG. Vykreslují se funkcí <strong>blit/BitBLT</strong>.</i></p>

<p>S&nbsp;využitím grafické operace <strong>blit</strong> neboli
<strong>BitBLT</strong> (<i>Bit Block Transfer</i>) lze provádět, jak ostatně
její název naznačuje, blokové přenosy bitmap nebo jejich výřezů,
popř.&nbsp;v&nbsp;rámci přenosu nad bitmapami provádět různé další operace,
například zpracování alfa kanálu. První implementace operace
<strong>BitBLT</strong> byla použita v&nbsp;roce 1975 ve <i>Smalltalku-72</i> a
od té doby ji najdeme prakticky v&nbsp;každé implementaci tohoto programovacího
jazyka, která obsahuje i knihovny pro práci s&nbsp;grafikou (mj.&nbsp;se jedná
i o <i>Squeak</i>). Pro <i>Smalltalk-74</i> vytvořil Daniel Ingalls
optimalizovanou variantu operace <strong>BitBLT</strong> implementovanou
v&nbsp;mikrokódu. Operace <strong>BitBLT</strong> se tak stala součástí
operačního systému a bylo ji možné volat jak z&nbsp;assembleru, tak i
z&nbsp;programů napsaných v&nbsp;jazyce <i>BCPL</i> a samozřejmě i ze
<i>Smalltalku</i> (právě tuto implementaci můžeme považovat za vůbec první
grafickou akceleraci). Posléze se díky své univerzalitě tato funkce rozšířila i
do mnoha dalších operačních systémů a grafických knihoven.</p>

<a href="http://mojefedora.cz/wp-content/uploads/2015/12/071.png"><img class="alignnone size-medium wp-image-6212" src="http://mojefedora.cz/wp-content/uploads/2015/12/071-450x338.png" alt="07" width="450" height="338" /></a>
<p><i>Obrázek 2: Hra Warcraft II také používá téměř výhradně bitmapy pro
zobrazení budov i postaviček.</i></p>

<p>Tuto operaci lze implementovat i na kartě VGA, a to hned několika různými
způsoby, které si postupně popíšeme.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První (naivní) implementace operace typu <i>BitBLT</i></h2>

<p>Naše první (a nutno dodat, že i hodně naivní) implementace <a
href="#k02">výše zmíněné</a> operace typu <i>BitBLT</i>
v&nbsp;šestnáctibarevném grafickém režimu karty VGA může vypadat následovně.
Budeme se snažit přenést horní polovinu obrazu (240 obrazových řádků) do
poloviny spodní, a to bajt po bajtu:</p>

<pre>
<i>; operace BitBLT z prvni poloviny obrazovky na druhou polovinu</i>
<strong>bitblt</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        mov ds, ax
        mov di, 640*240/8   <i>; nyni ES:DI obsahuje adresu pixelu ve video RAM na 240 radku</i>
        xor si, si          <i>; nyni DS:SI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 640*240/8   <i>; pocet prenesenych bajtu</i>
        rep movsb           <i>; blokovy prenos po bajtech</i>
        ret                 <i>; hotovo</i>
</pre>

<p>V&nbsp;příkladu nejdříve nastavíme grafický režim, vykreslíme sérii úseček a
počkáme na stisk klávesy:</p>

<pre>
        gfx_mode 0x12         <i>; nastaveni rezimu 640x480 se sestnacti barvami</i>
        call draw_color_lines
        wait_key              <i>; cekani na klavesu</i>
</pre>

<p>Dále nastavíme bitové roviny pro zápis a zavoláme výše uvedený podprogram
<strong>bitblt</strong>:</p>

<pre>
        select_bitplane 15    <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
</pre>

<p>Po stisku klávesy se program ukončí:</p>

<pre>
        wait_key              <i>; cekani na klavesu</i>
        exit                  <i>; navrat do DOSu</i>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Úplný zdrojový kód dnešního prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu, v&nbsp;němž je
volána naivní varianta operace <i>BitBLT</i>, vypadá takto:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 640x480 pixelu.</i>
<i>; Zmena barvovych rovin, do kterych se zapisuje.</i>
<i>; Vykresleni barevnych usecek.</i>
<i>; Prenos casti obrazu operaci typu BitBLT.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_bitblt_1.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_bitblt_1.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; I/O porty karty EGA/VGA</i>
SEQUENCER_INDEX      equ 0x3c4
SEQUENCER_DATA       equ 0x3c5
&nbsp;
<i>; registry karty EGA/VGA</i>
BITPLANE_SELECTOR    equ 0x02   <i>; sequencer</i>
&nbsp;
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; vyber bitove roviny</i>
%macro <strong>select_bitplane</strong> 1
        mov  al, %1         <i>; bitova rovina</i>
        mov  dx, SEQUENCER_INDEX
        mov  ah, BITPLANE_SELECTOR
        xchg ah, al
        out  dx, ax         <i>; vyber registru sekvenceru</i>
                            <i>; a zapis masky bitovych rovin</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x12         <i>; nastaveni rezimu 640x480 se sestnacti barvami</i>
        call draw_color_lines
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane 15    <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        exit                  <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; operace BitBLT z prvni poloviny obrazovky na druhou polovinu</i>
<strong>bitblt</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        mov ds, ax
        mov di, 640*240/8   <i>; nyni ES:DI obsahuje adresu pixelu ve video RAM na 240 radku</i>
        xor si, si          <i>; nyni DS:SI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 640*240/8   <i>; pocet prenesenych bajtu</i>
        rep movsb           <i>; blokovy prenos po bajtech</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<strong>draw_color_lines</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov ax, 0
<strong>.opak</strong>:
        mov bx, ax          <i>; y-ová souřadnice</i>
&nbsp;
        push ax
        mov cl, 15          <i>; barva</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  7          <i>; barva</i>
        add ax, 10          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  1          <i>; barva</i>
        add ax, 20          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  2          <i>; barva</i>
        add ax, 30          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  4          <i>; barva</i>
        add ax, 40          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        inc ax              <i>; pusun x+=1, y+=1</i>
        cmp ax, 480         <i>; hranice obrazovky?</i>
        jne .opak           <i>; ne-opakujeme</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<i>; Vykresleni pixelu</i>
<i>; AX - x-ova souradnice</i>
<i>; BX - y-ova souradnice</i>
<i>; CL - barva</i>
<strong>putpixel</strong>:
        push ax
        mov al, cl         <i>; vyber bitove roviny nebo bitovych rovin</i>
        select_bitplane al
        pop ax
&nbsp;
        mov dx, 0xa000     <i>; zacatek stranky video RAM</i>
        mov es, dx         <i>; nyni obsahuje ES stranku video RAM</i>
&nbsp;
        mov cl, al
        and cl, 7          <i>; pouze spodni 3 bity x-ove souradnice</i>
&nbsp;
        shr ax, 1
        shr ax, 1
        shr ax, 1          <i>; x/8</i>
        mov di, ax         <i>; horizontalni posun pocitany v bajtech</i>
&nbsp;
        mov ax, bx         <i>; y-ova souradnice</i>
        shl ax, 1          <i>; y*2</i>
        shl ax, 1          <i>; y*4</i>
        shl ax, 1          <i>; y*8</i>
        shl ax, 1          <i>; y*16</i>
        add di, ax         <i>; pricist cast y-oveho posunu</i>
        shl ax, 1          <i>; y*32</i>
        shl ax, 1          <i>; y*64</i>
        add di, ax         <i>; pricist zbytek y-oveho posunu</i>
                           <i>; -&gt; y*16 + y*64 = y*80</i>
&nbsp;
        mov al, 0x80       <i>; vypocitat masku pixelu</i>
        shr al, cl
        or [es:di], al     <i>; vlastni vykresleni pixelu</i>
&nbsp;
        ret                <i>; hotovo</i>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Proč vypadá obrazovka po provedení blokového přenosu tak, jak vypadá?</h2>

<p>Nyní zkusme prozkoumat obrazovku PC (nebo emulátoru) před a po provedení
naší operace typu <i>BitBLT</i>. První i druhá verze obrazovky budou vypadat
následovně:</p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-1.png">
<p><i>Obrázek 3: Obrazovka před provedením operace BitBLT.</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-2.png">
<p><i>Obrázek 4: Obrazovka po provedení operace BitBLT.</i></p>

<p>Ideálně by měl obrázek číslo 4 mít ve spodní polovině přesnou kopii horní
poloviny, což se však nestalo. Při bližším prozkoumání zjistíme, že bílé
úsečky, které <i>byly</i> zkopírovány, mají jednu vlastnost společnou &ndash;
všechny mají pixely nastavené na jedničku v&nbsp;první bitové rovině, zatímco
zbylé úsečky nikoli:</p>

<table>
<tr><th>Barva</th><th>Bitplane 0</th><th>Bitplane 1</th><th>Bitplane 2</th><th>Bitplane 3</th><th>Přeneseno?</th></tr>
<tr><td>bílá   </td><td>1</td><td>1</td><td>1</td><td>1</td><td>ano</td></tr>
<tr><td>šedá   </td><td>1</td><td>1</td><td>1</td><td>0</td><td>ano</td></tr>
<tr><td>modrá  </td><td>1</td><td>0</td><td>0</td><td>0</td><td>ano</td></tr>
<tr><td>zelená </td><td>0</td><td>1</td><td>0</td><td>0</td><td>ne</td></tr>
<tr><td>červená</td><td>0</td><td>0</td><td>1</td><td>0</td><td>ne</td></tr>
</table>

<p>Vše je tedy zřejmé &ndash; čtení bajtů (tedy osmic pixelů) probíhalo
z&nbsp;první bitové roviny s&nbsp;indexem 0, která obsahuje modrou barvovou
složku, pokud pochopitelně nezměníme barvovou paletu. Čtení ze všech bitových
rovin v&nbsp;tomto případě nemohlo nastat, protože čteme jeden bajt (osm
pixelů, každý pixel jeden bit) a nikoli čtyři bajty; ty se do registru
<strong>AL</strong> skutečně nevejdou.</p>

<p>A důvodem, proč je výsledkem trojice bílých úseček je fakt, že zápis (nikoli
čtení) se naopak provádí do všech čtyř bitových rovin, tj.&nbsp;onen bajt
v&nbsp;<strong>AL</strong> je interně rozkopírován na čtyři místa.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Operace <i>BitBLT</i> při povolení zápisu do různých kombinací bitových rovin</h2>

<p>V&nbsp;rámci dnešního druhého demonstračního příkladu se pokusme o nepatrnou
úpravu &ndash; budeme stále provádět naši operaci <i>BitBLT</i>, ale před jejím
provedením změníme kombinaci bitových rovin <i>pro zápis</i> (nikoli pro čtení
&ndash; to zatím neumíme). Budeme tedy řídit, jakým způsobem se zapíše celý
bajt (osm pixelů) &ndash; zda do jedné bitové roviny, více rovin, do všech čtyř
rovin či dokonce nikam:</p>

<table>
<tr><th>Makro</th><th>Význam po zavolání</th></tr>
<tr><td>select_bitplane 1</td><td>zápis do první bitové roviny (s&nbsp;indexem 0), obsahuje červenou složku</td></tr>
<tr><td>select_bitplane 2</td><td>zápis do druhé bitové roviny (s&nbsp;indexem 1), obsahuje zelenou složku</td></tr>
<tr><td>select_bitplane 7</td><td>zápis do rovin s&nbsp;indexy 0, 1 a 2, obsahuje RGB složky</td></tr>
<tr><td>select_bitplane 15</td><td>zápis do všech čtyř rovin, poslední rovina obsahuje intenzitu barvy</td></tr>
</table>

<p>Mezi jednotlivými operacemi typu <i>BibBLT</i> počkáme na stisk klávesy:</p>

<pre>
        select_bitplane 1     <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane 2     <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane 7     <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane 15    <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód dnešního druhého demonstračního příkladu</h2>

<p>Zdrojový kód dnešního druhého demonstračního příkladu, v&nbsp;němž se
operace typu <i>BitBLT</i> provádí s&nbsp;různými bitovými rovinami pro zápis,
vypadá následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 640x480 pixelu.</i>
<i>; Zmena barvovych rovin, do kterych se zapisuje.</i>
<i>; Vykresleni barevnych usecek.</i>
<i>; Prenos casti obrazu operaci typu BitBLT.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_bitblt_2.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_bitblt_2.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; I/O porty karty EGA/VGA</i>
SEQUENCER_INDEX      equ 0x3c4
SEQUENCER_DATA       equ 0x3c5
&nbsp;
<i>; registry karty EGA/VGA</i>
BITPLANE_SELECTOR    equ 0x02   <i>; sequencer</i>
&nbsp;
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; vyber bitove roviny</i>
%macro <strong>select_bitplane</strong> 1
        mov  al, %1         <i>; bitova rovina</i>
        mov  dx, SEQUENCER_INDEX
        mov  ah, BITPLANE_SELECTOR
        xchg ah, al
        out  dx, ax         <i>; vyber registru sekvenceru</i>
                            <i>; a zapis masky bitovych rovin</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x12         <i>; nastaveni rezimu 640x480 se sestnacti barvami</i>
        call draw_color_lines
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane 1     <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane 2     <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane 7     <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane 15    <i>; vyber bitove roviny nebo bitovych rovin</i>
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        exit                  <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; operace BitBLT z prvni poloviny obrazovky na druhou polovinu</i>
<strong>bitblt</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        mov ds, ax
        mov di, 640*240/8   <i>; nyni ES:DI obsahuje adresu pixelu ve video RAM na 240 radku</i>
        xor si, si          <i>; nyni DS:SI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 640*240/8   <i>; pocet prenesenych bajtu</i>
        rep movsb           <i>; blokovy prenos po bajtech</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<strong>draw_color_lines</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov ax, 0
<strong>.opak</strong>:
        mov bx, ax          <i>; y-ová souřadnice</i>
&nbsp;
        push ax
        mov cl, 15          <i>; barva</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  7          <i>; barva</i>
        add ax, 10          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  1          <i>; barva</i>
        add ax, 20          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  2          <i>; barva</i>
        add ax, 30          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  4          <i>; barva</i>
        add ax, 40          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        inc ax              <i>; pusun x+=1, y+=1</i>
        cmp ax, 480         <i>; hranice obrazovky?</i>
        jne .opak           <i>; ne-opakujeme</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<i>; Vykresleni pixelu</i>
<i>; AX - x-ova souradnice</i>
<i>; BX - y-ova souradnice</i>
<i>; CL - barva</i>
<strong>putpixel</strong>:
        push ax
        mov al, cl         <i>; vyber bitove roviny nebo bitovych rovin</i>
        select_bitplane al
        pop ax
&nbsp;
        mov dx, 0xa000     <i>; zacatek stranky video RAM</i>
        mov es, dx         <i>; nyni obsahuje ES stranku video RAM</i>
&nbsp;
        mov cl, al
        and cl, 7          <i>; pouze spodni 3 bity x-ove souradnice</i>
&nbsp;
        shr ax, 1
        shr ax, 1
        shr ax, 1          <i>; x/8</i>
        mov di, ax         <i>; horizontalni posun pocitany v bajtech</i>
&nbsp;
        mov ax, bx         <i>; y-ova souradnice</i>
        shl ax, 1          <i>; y*2</i>
        shl ax, 1          <i>; y*4</i>
        shl ax, 1          <i>; y*8</i>
        shl ax, 1          <i>; y*16</i>
        add di, ax         <i>; pricist cast y-oveho posunu</i>
        shl ax, 1          <i>; y*32</i>
        shl ax, 1          <i>; y*64</i>
        add di, ax         <i>; pricist zbytek y-oveho posunu</i>
                           <i>; -&gt; y*16 + y*64 = y*80</i>
&nbsp;
        mov al, 0x80       <i>; vypocitat masku pixelu</i>
        shr al, cl
        or [es:di], al     <i>; vlastni vykresleni pixelu</i>
&nbsp;
        ret                <i>; hotovo</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Stavy obrazovky v&nbsp;jednotlivých fázích druhého demonstračního příkladu</h2>

<p>Způsob činnosti našeho druhého příkladu, v&nbsp;němž se využívá operace typu
<i>BitBLT</i>, je poměrně dobře popsatelný při pohledu na obsahy obrazovky,
které získáme:</p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-3.png">
<p><i>Obrázek 6: Takto vypadá původní obsah obrazovky po vykreslení série
různobarevných úseček.</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-4.png">
<p><i>Obrázek 7: Výsledek čtení obsahu první bitové roviny (bitplane 0) se
zápisem do první bitové roviny. V&nbsp;tomto případě se přenese pouze modrá
barvová složka, která je součástí prvních tří úseček.</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-5.png">
<p><i>Obrázek 8: Výsledek čtení obsahu první bitové roviny (opět), ovšem nyní
se bajty zapisují do druhé roviny. Nastaví se tedy navíc ještě zelená složka, a
to pochopitelně u všech již zobrazených pixelů (obsah bitových rovin 0 a 1 bude
ve spodní části obrázku shodný).</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-6.png">
<p><i>Obrázek 9: Nyní zapisujeme do prvních tří bitových rovin obsah první
bitové roviny (bitplane 0). Z&nbsp;modré barvové složky se tedy nyní stane šedá
barva (R=1, G=1, B=1, intenzita=0).</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-7.png">
<p><i>Obrázek 10: A konečně zapisujeme do všech tří bitových rovin obsah první
roviny (tedy modré složky). Výsledkem jsou tři bílé úsečky (R=1, G=1, B=1,
intenzita=1).</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výběr bitové roviny pro čtení</h2>

<p>Aby bylo možné provést přenos celé části obrazu (tedy s&nbsp;věrnou kopií
barev), budeme muset přenést odpovídající data ze všech čtyř bitových rovin.
Nejdříve se podívejme na pomalý, ovšem dobře pochopitelný způsob: přenos vždy
jedné vybrané bitové roviny. Již víme, jakým způsobem se vybírají roviny (tedy
přesněji řečeno jejich libovolná kombinace) pro zápis &ndash; jedná se o
čtveřici bitů tvořících masku, v&nbsp;níž každý bit odpovídá jedné bitové
rovině. Pro volbu bitové roviny pro čtení však nepotřebujeme čtyři bity, ale
jen bity dva, protože (logicky) dokážeme osmibitovou operací čtení přečíst
pouze jeden vybraný bajt (tedy osmici pixelů) a nikoli 4&times;8 bitů. I
z&nbsp;tohoto důvodu je v&nbsp;řídicích registrech karty VGA dostupný i registr
nazvaný <i>Read Map Select Register</i>, v&nbsp;němž mají význam jen nejnižší
dva bity: obsahují index bitové roviny 0..3.</p>

<p>Tento registr je součástí grafického řadiče a jeho hodnotu (tedy bitovou
rovinu určenou pro čtení) specifikujeme pomocí makra:</p>

<pre>
<i>; vyber bitove roviny pro cteni</i>
%macro <strong>select_bitplane_for_read</strong> 1
        mov  dx, GRAPHICS_REGISTER
        mov  al, READ_MAP_SELECT
        out  dx, al         <i>; vyber VGA registru pro zapis</i>
        inc  dx,
        mov  al, %1         <i>; zmena VGA registru</i>
        out  dx, al
%endmacro
</pre>

<p>Toto makro využívá dvě nové konstanty &ndash; adresu I/O portu grafického
řadiče a indexu registru <i>Read Map Select Register</i>:</p>

<pre>
<i>; I/O porty karty EGA/VGA</i>
GRAPHICS_REGISTER    equ 0x3ce
&nbsp;
<i>; registry karty EGA/VGA</i>
READ_MAP_SELECT      equ 0x04   <i>; graphics register</i>
</pre>

<p>Současně přejmenujeme makro pro výběr roviny (rovin) pro zápis, aby jeho
název explicitně obsahoval i prováděnou operaci:</p>

<pre>
<i>; vyber bitove roviny nebo bitovych rovin pro zapis</i>
%macro <strong>select_bitplanes_for_write</strong> 1
        mov  al, %1         <i>; bitova rovina</i>
        mov  dx, SEQUENCER_INDEX
        mov  ah, BITPLANE_SELECTOR
        xchg ah, al
        out  dx, ax         <i>; vyber registru sekvenceru</i>
                            <i>; a zapis masky bitovych rovin</i>
%endmacro
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Postupné čtení obsahu jednotlivých bitových rovin operací typu <i>BitBLT</i></h2>

<p>Ukažme si nyní, jak bude vypadat výsledek operace typu <i>BitBLT</i> ve
chvíli, kdy budeme zapisovat do všech čtyř bitových rovin současně (a tedy
výsledkem bude vždy černá nebo bílá barva pixelů):</p>

<pre>
        select_bitplanes_for_write 15 <i>; vyber vsech bitovych rovin pro zapis</i>
</pre>

<p>Ovšem čtení z&nbsp;bitových rovin provedeme postupně &ndash; nejprve pro
první rovinu (0), dále pro rovinu druhou atd. A mezi jednotlivými operacemi
<i>BitBLT</i> bude program čekat na stisk klávesy:</p>

<pre>
        select_bitplane_for_read 0    <i>; vyber bitove roviny pro cteni</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane_for_read 1    <i>; vyber bitove roviny pro cteni</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane_for_read 2    <i>; vyber bitove roviny pro cteni</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane_for_read 3    <i>; vyber bitove roviny pro cteni</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Úplný zdrojový kód dnešního třetího demonstračního příkladu</h2>

<p>Dnešní třetí demonstrační příklad, jehož základní činnost byla popsána
v&nbsp;předchozích dvou kapitolách, vypadá následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 640x480 pixelu.</i>
<i>; Zmena barvovych rovin, do kterych se zapisuje.</i>
<i>; Vykresleni barevnych usecek.</i>
<i>; Prenos casti obrazu operaci typu BitBLT.</i>
<i>; Vyber bitovych rovin pro zapis.</i>
<i>; Vyber bitove roviny pro cteni.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_bitblt_3.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_bitblt_3.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; I/O porty karty EGA/VGA</i>
GRAPHICS_REGISTER    equ 0x3ce
SEQUENCER_INDEX      equ 0x3c4
SEQUENCER_DATA       equ 0x3c5
&nbsp;
<i>; registry karty EGA/VGA</i>
BITPLANE_SELECTOR    equ 0x02   <i>; sequencer</i>
READ_MAP_SELECT      equ 0x04   <i>; graphics register</i>
&nbsp;
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; vyber bitove roviny nebo bitovych rovin pro zapis</i>
%macro <strong>select_bitplanes_for_write</strong> 1
        mov  al, %1         <i>; bitova rovina</i>
        mov  dx, SEQUENCER_INDEX
        mov  ah, BITPLANE_SELECTOR
        xchg ah, al
        out  dx, ax         <i>; vyber registru sekvenceru</i>
                            <i>; a zapis masky bitovych rovin</i>
%endmacro
&nbsp;
<i>; vyber bitove roviny pro cteni</i>
%macro <strong>select_bitplane_for_read</strong> 1
        mov  dx, GRAPHICS_REGISTER
        mov  al, READ_MAP_SELECT
        out  dx, al         <i>; vyber VGA registru pro zapis</i>
        inc  dx,
        mov  al, %1         <i>; zmena VGA registru</i>
        out  dx, al
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x12         <i>; nastaveni rezimu 640x480 se sestnacti barvami</i>
        call draw_color_lines
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        select_bitplanes_for_write 15 <i>; vyber vsech bitovych rovin pro zapis</i>
&nbsp;
        select_bitplane_for_read 0    <i>; vyber bitove roviny pro cteni</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane_for_read 1    <i>; vyber bitove roviny pro cteni</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane_for_read 2    <i>; vyber bitove roviny pro cteni</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane_for_read 3    <i>; vyber bitove roviny pro cteni</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        exit                  <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; operace BitBLT z prvni poloviny obrazovky na druhou polovinu</i>
<strong>bitblt</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        mov ds, ax
        mov di, 640*240/8   <i>; nyni ES:DI obsahuje adresu pixelu ve video RAM na 240 radku</i>
        xor si, si          <i>; nyni DS:SI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 640*240/8   <i>; pocet prenesenych bajtu</i>
        rep movsb           <i>; blokovy prenos po bajtech</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<strong>draw_color_lines</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov ax, 0
<strong>.opak</strong>:
        mov bx, ax          <i>; y-ová souřadnice</i>
&nbsp;
        push ax
        mov cl, 15          <i>; barva</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  7          <i>; barva</i>
        add ax, 10          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  1          <i>; barva</i>
        add ax, 20          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  2          <i>; barva</i>
        add ax, 30          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  4          <i>; barva</i>
        add ax, 40          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        inc ax              <i>; pusun x+=1, y+=1</i>
        cmp ax, 480         <i>; hranice obrazovky?</i>
        jne .opak           <i>; ne-opakujeme</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<i>; Vykresleni pixelu</i>
<i>; AX - x-ova souradnice</i>
<i>; BX - y-ova souradnice</i>
<i>; CL - barva</i>
<strong>putpixel</strong>:
        push ax
        mov al, cl         <i>; vyber bitove roviny nebo bitovych rovin</i>
        select_bitplanes_for_write al
        pop ax
&nbsp;
        mov dx, 0xa000     <i>; zacatek stranky video RAM</i>
        mov es, dx         <i>; nyni obsahuje ES stranku video RAM</i>
&nbsp;
        mov cl, al
        and cl, 7          <i>; pouze spodni 3 bity x-ove souradnice</i>
&nbsp;
        shr ax, 1
        shr ax, 1
        shr ax, 1          <i>; x/8</i>
        mov di, ax         <i>; horizontalni posun pocitany v bajtech</i>
&nbsp;
        mov ax, bx         <i>; y-ova souradnice</i>
        shl ax, 1          <i>; y*2</i>
        shl ax, 1          <i>; y*4</i>
        shl ax, 1          <i>; y*8</i>
        shl ax, 1          <i>; y*16</i>
        add di, ax         <i>; pricist cast y-oveho posunu</i>
        shl ax, 1          <i>; y*32</i>
        shl ax, 1          <i>; y*64</i>
        add di, ax         <i>; pricist zbytek y-oveho posunu</i>
                           <i>; -> y*16 + y*64 = y*80</i>
&nbsp;
        mov al, 0x80       <i>; vypocitat masku pixelu</i>
        shr al, cl
        or [es:di], al     <i>; vlastni vykresleni pixelu</i>
&nbsp;
        ret                <i>; hotovo</i>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Stavy obrazovky v&nbsp;jednotlivých fázích třetího demonstračního příkladu</h2>

<p>Podobně, jako tomu bylo u druhého demonstračního příkladu, si i nyní ukážeme
obsahy obrazovek vykreslovaných třetím příkladem. Připomeňme si, že se
provádělo čtení z&nbsp;různých bitových rovin, ovšem zápis byl vždy proveden do
všech čtyř bitových rovin, takže výsledkem bude &ndash; nezávisle na zdroji
&ndash; nějaký černobílý obrazec (barvy &bdquo;zmizí&ldquo;):</p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-8.png">
<p><i>Obrázek 11: Původní obrázek s&nbsp;pěticí barevných úseček.</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-9.png">
<p><i>Obrázek 12: Čtení z&nbsp;první bitové roviny (bitplane 0) znamená, že se
přečetla jen modrá barvová složka (první tři úsečky) a převedla se na bílou
barvu (zápisem do všech čtyř bitových rovin).</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-10.png">
<p><i>Obrázek 13: Čtení ze druhé bitové roviny (bitplane 1) znamenalo přečtení
zelené barvové složky. Ta je nastavena pro první, druhou a čtvrtou
úsečku (viz obrázek číslo 10).</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-11.png">
<p><i>Obrázek 14: Čtení ze třetí bitové roviny (bitplane 2) znamenalo přečtení
červené barvové složky.</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-12.png">
<p><i>Obrázek 15: Čtení ze čtvrté barvové roviny (bitplane 3) znamenalo
přečtení intenzity. Ta je nastavena pouze pro pixely v&nbsp;první
úsečce.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Korektní (pomalá) realizace operace typu <i>BitBLT</i></h2>

<p>Jak by tedy měla vypadat korektně naprogramovaná operace typu <i>BitBLT</i>?
Protože prozatím neznáme další potřebné triky (využití latche atd.), budeme
muset přenos barev pixelů provést čtyřikrát &ndash; pro každou bitovou rovinu
zvlášť. Jedná se o tento postup:</p>

<ol>
<li>Čtení z&nbsp;roviny 0, zápis jen do roviny 0</li>
<li>Čtení z&nbsp;roviny 1, zápis jen do roviny 1</li>
<li>Čtení z&nbsp;roviny 2, zápis jen do roviny 2</li>
<li>Čtení z&nbsp;roviny 3, zápis jen do roviny 3</li>
</ol>

<p>Následuje neefektivní způsob zápisu těchto operací voláním příslušných
maker. V&nbsp;dalších kapitolách si uvedeme kratší a nepatrně rychlejší způsob
zápisu:</p>

<pre>
        select_bitplane_for_read 0    <i>; vyber prvni bitove roviny pro cteni</i>
        select_bitplanes_for_write 1  <i>; vyber prvni bitove roviny pro zapis</i>
        call bitblt                   <i>; prenos bloku</i>
&nbsp;
        select_bitplane_for_read 1    <i>; vyber druhe bitove roviny pro cteni</i>
        select_bitplanes_for_write 2  <i>; vyber druhe bitove roviny pro zapis</i>
        call bitblt                   <i>; prenos bloku</i>
&nbsp;
        select_bitplane_for_read 2    <i>; vyber treti bitove roviny pro cteni</i>
        select_bitplanes_for_write 4  <i>; vyber treti bitove roviny pro zapis</i>
        call bitblt                   <i>; prenos bloku</i>
&nbsp;
        select_bitplane_for_read 3    <i>; vyber ctvrte bitove roviny pro cteni</i>
        select_bitplanes_for_write 8  <i>; vyber ctvrte bitove roviny pro zapis</i>
        call bitblt                   <i>; prenos bloku</i>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</h2>

<p>Opět se podívejme na úplný zdrojový kód demonstračního příkladu, jenž byl
popsán v&nbsp;předchozích kapitolách. Tento příklad nyní vypadá následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 640x480 pixelu.</i>
<i>; Zmena barvovych rovin, do kterych se zapisuje.</i>
<i>; Vykresleni barevnych usecek.</i>
<i>; Prenos casti obrazu operaci typu BitBLT - nyni jiz korektni.</i>
<i>; Vyber bitovych rovin pro zapis.</i>
<i>; Vyber bitove roviny pro cteni.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_bitblt_4.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_bitblt_4.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; I/O porty karty EGA/VGA</i>
GRAPHICS_REGISTER    equ 0x3ce
SEQUENCER_INDEX      equ 0x3c4
SEQUENCER_DATA       equ 0x3c5
&nbsp;
<i>; registry karty EGA/VGA</i>
BITPLANE_SELECTOR    equ 0x02   <i>; sequencer</i>
READ_MAP_SELECT      equ 0x04   <i>; graphics register</i>
&nbsp;
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; vyber bitove roviny nebo bitovych rovin pro zapis</i>
%macro <strong>select_bitplanes_for_write</strong> 1
        mov  al, %1         <i>; bitova rovina</i>
        mov  dx, SEQUENCER_INDEX
        mov  ah, BITPLANE_SELECTOR
        xchg ah, al
        out  dx, ax         <i>; vyber registru sekvenceru</i>
                            <i>; a zapis masky bitovych rovin</i>
%endmacro
&nbsp;
<i>; vyber bitove roviny pro cteni</i>
%macro <strong>select_bitplane_for_read</strong> 1
        mov  dx, GRAPHICS_REGISTER
        mov  al, READ_MAP_SELECT
        out  dx, al         <i>; vyber VGA registru pro zapis</i>
        inc  dx,
        mov  al, %1         <i>; zmena VGA registru</i>
        out  dx, al
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x12         <i>; nastaveni rezimu 640x480 se sestnacti barvami</i>
        call draw_color_lines
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
&nbsp;
        select_bitplane_for_read 0    <i>; vyber prvni bitove roviny pro cteni</i>
        select_bitplanes_for_write 1  <i>; vyber prvni bitove roviny pro zapis</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane_for_read 1    <i>; vyber druhe bitove roviny pro cteni</i>
        select_bitplanes_for_write 2  <i>; vyber druhe bitove roviny pro zapis</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane_for_read 2    <i>; vyber treti bitove roviny pro cteni</i>
        select_bitplanes_for_write 4  <i>; vyber treti bitove roviny pro zapis</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        select_bitplane_for_read 3    <i>; vyber ctvrte bitove roviny pro cteni</i>
        select_bitplanes_for_write 8  <i>; vyber ctvrte bitove roviny pro zapis</i>
        call bitblt                   <i>; prenos bloku</i>
        wait_key                      <i>; cekani na klavesu</i>
&nbsp;
        exit                  <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; operace BitBLT z prvni poloviny obrazovky na druhou polovinu</i>
<strong>bitblt</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        mov ds, ax
        mov di, 640*240/8   <i>; nyni ES:DI obsahuje adresu pixelu ve video RAM na 240 radku</i>
        xor si, si          <i>; nyni DS:SI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 640*240/8   <i>; pocet prenesenych bajtu</i>
        rep movsb           <i>; blokovy prenos po bajtech</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<strong>draw_color_lines</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov ax, 0
<strong>.opak</strong>:
        mov bx, ax          <i>; y-ová souřadnice</i>
&nbsp;
        push ax
        mov cl, 15          <i>; barva</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  7          <i>; barva</i>
        add ax, 10          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  1          <i>; barva</i>
        add ax, 20          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  2          <i>; barva</i>
        add ax, 30          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  4          <i>; barva</i>
        add ax, 40          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        inc ax              <i>; pusun x+=1, y+=1</i>
        cmp ax, 480         <i>; hranice obrazovky?</i>
        jne .opak           <i>; ne-opakujeme</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<i>; Vykresleni pixelu</i>
<i>; AX - x-ova souradnice</i>
<i>; BX - y-ova souradnice</i>
<i>; CL - barva</i>
<strong>putpixel</strong>:
        push ax
        mov al, cl         <i>; vyber bitove roviny nebo bitovych rovin</i>
        select_bitplanes_for_write al
        pop ax
&nbsp;
        mov dx, 0xa000     <i>; zacatek stranky video RAM</i>
        mov es, dx         <i>; nyni obsahuje ES stranku video RAM</i>
&nbsp;
        mov cl, al
        and cl, 7          <i>; pouze spodni 3 bity x-ove souradnice</i>
&nbsp;
        shr ax, 1
        shr ax, 1
        shr ax, 1          <i>; x/8</i>
        mov di, ax         <i>; horizontalni posun pocitany v bajtech</i>
&nbsp;
        mov ax, bx         <i>; y-ova souradnice</i>
        shl ax, 1          <i>; y*2</i>
        shl ax, 1          <i>; y*4</i>
        shl ax, 1          <i>; y*8</i>
        shl ax, 1          <i>; y*16</i>
        add di, ax         <i>; pricist cast y-oveho posunu</i>
        shl ax, 1          <i>; y*32</i>
        shl ax, 1          <i>; y*64</i>
        add di, ax         <i>; pricist zbytek y-oveho posunu</i>
                           <i>; -> y*16 + y*64 = y*80</i>
&nbsp;
        mov al, 0x80       <i>; vypocitat masku pixelu</i>
        shr al, cl
        or [es:di], al     <i>; vlastni vykresleni pixelu</i>
&nbsp;
        ret                <i>; hotovo</i>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Obrazovka před blokovým přenosem a po provedení blokového přenosu</h2>

<p>Postupný přenos obsahu jednotlivých bitových rovin je zcela jednoduché si
vizualizovat &ndash; postačuje totiž mezi jednotlivé přenosy vložit expanzi
makra pro čekání na stisk klávesy: Můžeme tak sledovat, jak přesně jednotlivé
operace vypadají na obrazovce:</p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-13.png">
<p><i>Obrázek 16: Stav obrazovky ještě před zahájením blokových přenosů.</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-14.png">
<p><i>Obrázek 17: V&nbsp;prvním kroku se korektně přenesl obsah první bitové
roviny (bitplane 0) s&nbsp;modrou složkou (mezitím byla modrá
&bdquo;odebrána&ldquo; z&nbsp;pravé dolní části obrazu).</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-15.png">
<p><i>Obrázek 18: Ve druhém kroku se korektně přenesl obsah druhé bitové roviny
(bitplane 1) se zelenou složkou. Nyní tedy vidíme kombinace modré a
zelené.</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-16.png">
<p><i>Obrázek 19: Ve třetím kroku se korektně přenesl obsah třetí bitové roviny
(bitplane 2) s&nbsp;červenou složkou. Nyní tedy vidíme kombinace modré, zelené
a červené, ovšem vše s&nbsp;nízkou intenzitou. V&nbsp;pravé dolní části obrazu
zbyla pouze jediná šedá úsečka &ndash; černé pixely s&nbsp;vysokou
intenzitou.</i></p>

<img src="https://i.iinfo.cz/files/root/86/vga-bitblt-17.png">
<p><i>Obrázek 20: Dokončení přenosu obsahu čtvrté bitové roviny (bitplane 3).
Nyní je již vše zcela korektní.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Realizace operace typu <i>BitBLT</i> podprogramem</h2>

<p>Postupná expanze maker pro výběr bitových rovin pro čtení a zápis i postupné
volání &bdquo;naivní&ldquo; operace <i>BitBLT</i> ve skutečnosti vede ke
zbytečně dlouhému i relativně pomalému kódu. Proto si ukažme, jakým způsobem je
možné tento problém vyřešit poněkud lepším způsobem. Nejprve si nadefinujeme
pole osmi konstant typu <i>byte</i>. Tyto konstanty obsahují index roviny pro
čtení následovaný bitovým polem s&nbsp;rovinami pro zápis. To celé se opakuje
4x:</p>

<table>
<tr><th>Rovina pro čtení</th><th>Bitové pole s&nbsp;rovinami pro zápis</th></tr>
<tr><td>0</td><td>1 = 0b0001</td></tr>
<tr><td>1</td><td>2 = 0b0010</td></tr>
<tr><td>2</td><td>4 = 0b0100</td></tr>
<tr><td>3</td><td>8 = 0b1000</td></tr>
</table>

<p>V&nbsp;assembleru je zápis tohoto neměnného pole snadný:</p>

<pre>
.regs:  db 0, 1, 1, 2, 2, 4, 3, 8
</pre>

<p>Dále si nadefinujeme podprogram pro přenos části vybrané bitové roviny
blokovou operací typu <strong>rep movsb</strong> (nebo i po slovech). To již
velmi dobře známe:</p>

<pre>
<strong>bitblt_one_bitplane</strong>:
        mov di, 640*240/8   <i>; nyni ES:DI obsahuje adresu pixelu ve video RAM na 240 radku</i>
        xor si, si          <i>; nyni DS:SI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 640*240/8   <i>; pocet prenesenych bajtu</i>
        rep movsb           <i>; blokovy prenos po bajtech</i>
        ret                 <i>; hotovo</i>
</pre>

<p>Celá operace <i>BitBLT</i> nastaví (jedenkrát!) segmentové registry a
postupně provede čtyři blokové přenosy s&nbsp;využitím již výše nadefinovaného
pole <strong>.regs</strong>:</p>

<pre>
<i>; operace BitBLT z prvni poloviny obrazovky na druhou polovinu</i>
<strong>bitblt</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        mov ds, ax
&nbsp;
        mov  bx, .regs      <i>; tabulka s mapovanim cteni->zapis</i>
        mov  cx, 4          <i>; pocet bitovych rovin pro prenos</i>
&nbsp;
<strong>.all_bitplanes</strong>:
        mov  dx, GRAPHICS_REGISTER
        mov  al, READ_MAP_SELECT
        mov  ah, cs:[bx]    <i>; nacteni indexu bitove roviny</i>
        inc  bx             <i>; posun v tabulce</i>
        out  dx, ax         <i>; vyber bitove roviny pro cteni</i>
&nbsp;
        mov  dx, SEQUENCER_INDEX
        mov  al, BITPLANE_SELECTOR
        mov  ah, cs:[bx]    <i>; vyber bitovych rovin pro zapis</i>
        inc  bx             <i>; posun v tabulce</i>
        out  dx, ax         <i>; vyber registru sekvenceru</i>
                            <i>; a zapis masky bitovych rovin</i>
&nbsp;
        push cx
        call bitblt_one_bitplane
        pop cx
        loop .all_bitplanes
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: pro čtení z&nbsp;<strong>.regs</strong>
je nutné použít registr <strong>CS</strong>, protože další dva segmentové
registry <strong>DS</strong> a <strong>ES</strong> ukazují do video
paměti.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úplný zdrojový kód dnešního pátého demonstračního příkladu</h2>

<p>Dnešní pátý a současně i poslední demonstrační příklad vypadá
následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 640x480 pixelu.</i>
<i>; Zmena barvovych rovin, do kterych se zapisuje.</i>
<i>; Vykresleni barevnych usecek.</i>
<i>; Prenos casti obrazu operaci typu BitBLT - nyni jiz korektni.</i>
<i>; Vyber bitovych rovin pro zapis.</i>
<i>; Vyber bitove roviny pro cteni.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_bitblt_5.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_bitblt_5.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; I/O porty karty EGA/VGA</i>
GRAPHICS_REGISTER    equ 0x3ce
SEQUENCER_INDEX      equ 0x3c4
SEQUENCER_DATA       equ 0x3c5
&nbsp;
<i>; registry karty EGA/VGA</i>
BITPLANE_SELECTOR    equ 0x02   <i>; sequencer</i>
READ_MAP_SELECT      equ 0x04   <i>; graphics register</i>
&nbsp;
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; vyber bitove roviny nebo bitovych rovin pro zapis</i>
%macro <strong>select_bitplanes_for_write</strong> 1
        mov  al, %1         <i>; bitova rovina</i>
        mov  dx, SEQUENCER_INDEX
        mov  ah, BITPLANE_SELECTOR
        xchg ah, al
        out  dx, ax         <i>; vyber registru sekvenceru</i>
                            <i>; a zapis masky bitovych rovin</i>
%endmacro
&nbsp;
<i>; vyber bitove roviny pro cteni</i>
%macro <strong>select_bitplane_for_read</strong> 1
        mov  dx, GRAPHICS_REGISTER
        mov  al, READ_MAP_SELECT
        out  dx, al         <i>; vyber VGA registru pro zapis</i>
        inc  dx,
        mov  al, %1         <i>; zmena VGA registru</i>
        out  dx, al
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x12         <i>; nastaveni rezimu 640x480 se sestnacti barvami</i>
        call draw_color_lines
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        call bitblt           <i>; prenos bloku</i>
        wait_key              <i>; cekani na klavesu</i>
&nbsp;
        exit                  <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; operace BitBLT z prvni poloviny obrazovky na druhou polovinu</i>
<strong>bitblt</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        mov ds, ax
&nbsp;
        mov  bx, .regs      <i>; tabulka s mapovanim cteni->zapis</i>
        mov  cx, 4          <i>; pocet bitovych rovin pro prenos</i>
&nbsp;
<strong>.all_bitplanes</strong>:
        mov  dx, GRAPHICS_REGISTER
        mov  al, READ_MAP_SELECT
        mov  ah, cs:[bx]    <i>; nacteni indexu bitove roviny</i>
        inc  bx             <i>; posun v tabulce</i>
        out  dx, ax         <i>; vyber bitove roviny pro cteni</i>
&nbsp;
        mov  dx, SEQUENCER_INDEX
        mov  al, BITPLANE_SELECTOR
        mov  ah, cs:[bx]    <i>; vyber bitovych rovin pro zapis</i>
        inc  bx             <i>; posun v tabulce</i>
        out  dx, ax         <i>; vyber registru sekvenceru</i>
                            <i>; a zapis masky bitovych rovin</i>
&nbsp;
        push cx
        call bitblt_one_bitplane
        pop cx
        loop .all_bitplanes
        ret
&nbsp;
<strong>.regs</strong>:  db 0, 1, 1, 2, 2, 4, 3, 8
&nbsp;
<strong>bitblt_one_bitplane</strong>:
        mov di, 640*240/8   <i>; nyni ES:DI obsahuje adresu pixelu ve video RAM na 240 radku</i>
        xor si, si          <i>; nyni DS:SI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 640*240/8   <i>; pocet prenesenych bajtu</i>
        rep movsb           <i>; blokovy prenos po bajtech</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<strong>draw_color_lines</strong>:
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov ax, 0
<strong>.opak</strong>:
        mov bx, ax          <i>; y-ová souřadnice</i>
&nbsp;
        push ax
        mov cl, 15          <i>; barva</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  7          <i>; barva</i>
        add ax, 10          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  1          <i>; barva</i>
        add ax, 20          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  2          <i>; barva</i>
        add ax, 30          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        push ax
        mov cl,  4          <i>; barva</i>
        add ax, 40          <i>; horizontalni posun useky</i>
        call putpixel       <i>; vykreslení pixelu</i>
        pop ax
&nbsp;
        inc ax              <i>; pusun x+=1, y+=1</i>
        cmp ax, 480         <i>; hranice obrazovky?</i>
        jne .opak           <i>; ne-opakujeme</i>
        ret                 <i>; hotovo</i>
&nbsp;
&nbsp;
<i>; Vykresleni pixelu</i>
<i>; AX - x-ova souradnice</i>
<i>; BX - y-ova souradnice</i>
<i>; CL - barva</i>
<strong>putpixel</strong>:
        push ax
        mov al, cl         <i>; vyber bitove roviny nebo bitovych rovin</i>
        select_bitplanes_for_write al
        pop ax
&nbsp;
        mov dx, 0xa000     <i>; zacatek stranky video RAM</i>
        mov es, dx         <i>; nyni obsahuje ES stranku video RAM</i>
&nbsp;
        mov cl, al
        and cl, 7          <i>; pouze spodni 3 bity x-ove souradnice</i>
&nbsp;
        shr ax, 1
        shr ax, 1
        shr ax, 1          <i>; x/8</i>
        mov di, ax         <i>; horizontalni posun pocitany v bajtech</i>
&nbsp;
        mov ax, bx         <i>; y-ova souradnice</i>
        shl ax, 1          <i>; y*2</i>
        shl ax, 1          <i>; y*4</i>
        shl ax, 1          <i>; y*8</i>
        shl ax, 1          <i>; y*16</i>
        add di, ax         <i>; pricist cast y-oveho posunu</i>
        shl ax, 1          <i>; y*32</i>
        shl ax, 1          <i>; y*64</i>
        add di, ax         <i>; pricist zbytek y-oveho posunu</i>
                           <i>; -> y*16 + y*64 = y*80</i>
&nbsp;
        mov al, 0x80       <i>; vypocitat masku pixelu</i>
        shr al, cl
        or [es:di], al     <i>; vlastni vykresleni pixelu</i>
&nbsp;
        ret                <i>; hotovo</i>
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Blokové přenosy s&nbsp;využitím 32bitového záchytného registru <i>latche</i></h2>

<p>I přesto, že je <a href="#k16">výše uvedené řešení</a> blokového přenosu
efektivnější, než expanze mnoha maker, zdaleka se nejedná o rychlou operaci,
protože data se přenáší mezi videopamětí přes CPU a tedy i přes sběrnici. I při
využití 16bitového přenosu je tedy nutné vždy načíst data z&nbsp;video paměti,
přenést je do CPU a následně je zapsat zpět do video paměti.</p>

<p>I z&nbsp;tohoto důvodu je v&nbsp;grafické kartě VGA implementován takzvaný
<i>záchytný registr</i> neboli <i>latch</i>, který má šířku 32 bitů. Při čtení
z&nbsp;video RAM se &ndash; nezávisle na vybrané bitové rovině &ndash; do
latche přečte obsah všech čtyř bitových rovin, konkrétně z&nbsp;každé roviny
jeden bajt. A při zápisu lze zvolit takový režim, že se bude ignorovat bajt
poslaný z&nbsp;CPU a namísto něho se využije oněch 32 bitů z&nbsp;latche.
Výsledkem je, že i když se fyzicky bude přenášet jen jediný bajt, interně karta
VGA přenese 32 bitů a tedy zkopíruje osm pixelů (16barevné režimy) nebo čtyři
pixely (256barevné režimy). Tímto konceptem, jenž se uplatnil při vykreslování
spritů atd., se budeme zabývat příště.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>cga_text_mode_1.asm</td><td>standardní textový režim s&nbsp;rozlišením 40&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm</a></td></tr>
<tr><td>27</td><td>cga_text_mode_3.asm</td><td>standardní textový režim s&nbsp;rozlišením 80&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm</a></td></tr>
<tr><td>28</td><td>cga_text_mode_intensity.asm</td><td>změna významu nejvyššího bitu atributového bajtu: vyšší intenzita namísto blikání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm</a></td></tr>
<tr><td>29</td><td>cga_text_mode_cursor.asm</td><td>změna tvaru textového kurzoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm</a></td></tr>
<tr><td>30</td><td>cga_text_gfx_1.asm</td><td>zobrazení &bdquo;rastrové mřížky&ldquo;: pseudografický režim 160&times;25 pixelů (interně textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm</a></td></tr>
<tr><td>31</td><td>cga_text_mode_char_height.asm</td><td>změna výšky znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm</a></td></tr>
<tr><td>32</td><td>cga_text_160x100.asm</td><td>grafický režim 160&times;100 se šestnácti barvami (interně upravený textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>hercules_text_mode_1.asm</td><td>využití standardního textového režimu společně s&nbsp;kartou Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm</a></td></tr>
<tr><td>34</td><td>hercules_text_mode_2.asm</td><td>zákaz blikání v&nbsp;textových režimech</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm</a></td></tr>
<tr><td>35</td><td>hercules_turn_off.asm</td><td>vypnutí generování video signálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm</a></td></tr>
<tr><td>36</td><td>hercules_gfx_mode_1.asm</td><td>přepnutí karty Hercules do grafického režimu (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm</a></td></tr>
<tr><td>37</td><td>hercules_gfx_mode_2.asm</td><td>přepnutí karty Hercules do grafického režimu (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm</a></td></tr>
<tr><td>38</td><td>hercules_putpixel.asm</td><td>subrutina pro vykreslení jediného pixelu na kartě Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>ega_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm</a></td></tr>
<tr><td>40</td><td>ega_text_mode_80x43.asm</td><td>zobrazení 43 textových řádků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm</a></td></tr>
<tr><td>41</td><td>ega_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm</a></td></tr>
<tr><td>42</td><td>ega_gfx_mode_640x200.asm</td><td>přepnutí do grafického režimu 640&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm</a></td></tr>
<tr><td>43</td><td>ega_gfx_mode_640x350.asm</td><td>přepnutí do grafického režimu 640&times;350 pixelů se čtyřmi nebo šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm</a></td></tr>
<tr><td>44</td><td>ega_gfx_mode_bitplanes_1.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (základní způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm</a></td></tr>
<tr><td>45</td><td>ega_gfx_mode_bitplanes_2.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (rychlejší způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>ega_320x200_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm</a></td></tr>
<tr><td>47</td><td>ega_640x350_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 640&times;350 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>ega_standard_font.asm</td><td>použití standardního fontu grafické karty EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm</a></td></tr>
<tr><td>49</td><td>ega_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>ega_palette_1.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 320&times;200 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm</a></td></tr>
<tr><td>51</td><td>ega_palette_2.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 640&times;350 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm</a></td></tr>
<tr><td>52</td><td>ega_palette_3.asm</td><td>změna všech barev v&nbsp;barvové paletě s&nbsp;využitím programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm</a></td></tr>
<tr><td>53</td><td>ega_palette_4.asm</td><td>změna všech barev, včetně barvy okraje, v&nbsp;barvové paletě voláním funkce BIOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>vga_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm</a></td></tr>
<tr><td>55</td><td>vga_text_mode_80x50.asm</td><td>zobrazení 50 a taktéž 28 textových řádků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm</a></td></tr>
<tr><td>56</td><td>vga_text_mode_intensity_1.asm</td><td>změna chování atributového bitu pro blikání (nebezpečná varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm</a></td></tr>
<tr><td>57</td><td>vga_text_mode_intensity_2.asm</td><td>změna chování atributového bitu pro blikání (bezpečnější varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm</a></td></tr>
<tr><td>58</td><td>vga_text_mode_9th_column.asm</td><td>modifikace způsobu zobrazení devátého sloupce ve znakových režimech (720 pixelů na řádku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm</a></td></tr>
<tr><td>59</td><td>vga_text_mode_cursor_shape.asm</td><td>změna tvaru textového kurzoru na grafické kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm</a></td></tr>
<tr><td>60</td><td>vga_text_mode_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>vga_gfx_mode_640x480.asm</td><td>přepnutí do grafického režimu 640&times;480 pixelů se šestnácti barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm</a></td></tr>
<tr><td>62</td><td>vga_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů s&nbsp;256 barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm</a></td></tr>
<tr><td>63</td><td>vga_gfx_mode_palette.asm</td><td>změna všech barev v&nbsp;barvové paletě grafické karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm</a></td></tr>
<tr><td>64</td><td>vga_gfx_mode_dac_1.asm</td><td>využití DAC (neočekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm</a></td></tr>
<tr><td>65</td><td>vga_gfx_mode_dac_2.asm</td><td>využití DAC (očekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>66</td><td>vga_640x480_putpixel.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 640&times;480 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm</a></td></tr>
<tr><td>67</td><td>vga_320x200_putpixel_1.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm</a></td></tr>
<tr><td>68</td><td>vga_320x200_putpixel_2.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (rychlejší varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>vga_gfx_mode_dac_3.asm</td><td>přímé využití DAC v&nbsp;grafickém režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>70</td><td>vga_gfx_mode_unchained_step_1.asm</td><td>zobrazení barevných pruhů v&nbsp;režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm</a></td></tr>
<tr><td>71</td><td>vga_gfx_mode_unchained_step_2.asm</td><td>vypnutí zřetězení bitových rovin a změna způsobu adresování pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm</a></td></tr>
<tr><td>72</td><td>vga_gfx_mode_unchained_step_3.asm</td><td>vykreslení barevných pruhů do vybraných bitových rovin</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>73</td><td>vga_gfx_mode_320x400.asm</td><td>nestandardní grafický režim s&nbsp;rozlišením 320&times;400 pixelů a 256 barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm</a></td></tr>
<tr><td>74</td><td>vga_320x200_image.asm</td><td>zobrazení rastrového obrázku ve standardním grafickém režimu 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm</a></td></tr>
<tr><td>75</td><td>vga_320x200_unchained_image_1.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (nekorektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm</a></td></tr>
<tr><td>76</td><td>vga_320x200_unchained_image_2.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (korektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm</a></td></tr>
<tr><td>77</td><td>vga_320x400_unchained_image.asm</td><td>zobrazení rastrového obrázku v&nbsp;nestandardním režimu 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>78</td><td>vga_vertical_scroll_1.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm</a></td></tr>
<tr><td>79</td><td>vga_vertical_scroll_2.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm</a></td></tr>
<tr><td>80</td><td>vga_split_screen_1.asm</td><td>režim split-screen a scrolling, nefunční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm</a></td></tr>
<tr><td>81</td><td>vga_split_screen_2.asm</td><td>režim split-screen a scrolling, plně funkční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm</a></td></tr>
<tr><td>82</td><td>vga_horizontal_scroll_1.asm</td><td>horizontální scrolling bez rozšíření počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm</a></td></tr>
<tr><td>83</td><td>vga_horizontal_scroll_2.asm</td><td>horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm</a></td></tr>
<tr><td>84</td><td>vga_horizontal_scroll_3.asm</td><td>jemný horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>85</td><td>vga_320x240_image.asm</td><td>nastavení grafického režimu Mode-X, načtení a vykreslení obrázku, scrolling</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>86</td><td>io.asm</td><td>knihovna maker pro I/O operace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm</a></td></tr>
<tr><td>87</td><td>vga_lib.asm</td><td>knihovna maker a podprogramů pro programování karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm</a></td></tr>
<tr><td>88</td><td>vga_320x240_lib.asm</td><td>nastavení grafického režimu Mode-X, tentokrát knihovními funkcemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>89</td><td>vga_bitblt_1.asm</td><td>první (naivní) implementace operace <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm</a></td></tr>
<tr><td>90</td><td>vga_bitblt_2.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm</a></td></tr>
<tr><td>91</td><td>vga_bitblt_3.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro čtení i zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm</a></td></tr>
<tr><td>92</td><td>vga_bitblt_4.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace makry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm</a></td></tr>
<tr><td>93</td><td>vga_bitblt_5.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace podprogramem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>6845 - Motorola CRT Controller<br />
<a href="https://stanislavs.org/helppc/6845.html">https://stanislavs.org/helppc/6845.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

