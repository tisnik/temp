<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Výpočty v systému pevné řádové čárky na platformě IBM PC (2. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Výpočty v systému pevné řádové čárky na platformě IBM PC (2. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní článek o výpočtech prováděných s hodnotami s pevnou řádovou tečkou (čárkou) dnes navážeme. Ukážeme si některé limity tohoto způsobu reprezentace numerických hodnot a taktéž se seznámíme s algoritmem CORDIC, který je možné použít pro výpočet goniometrických funkcí, logaritmů atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Výpočty v&nbsp;systému pevné řádové čárky na platformě IBM PC (2. část)</a></p>
<p><a href="#k02">*** 2. Problémy, které nastávají při omezení výpočtů pouze na n-bitové hodnoty</a></p>
<p><a href="#k03">*** 3. Násobení příliš malých hodnot</a></p>
<p><a href="#k04">*** 4. Výpočty omezené na 2n-bitové hodnoty</a></p>
<p><a href="#k05">*** 5. Snížení počtu bitů reprezentujících numerické hodnoty při výpočtu Mandelbrotovy množiny</a></p>
<p><a href="#k06">*** 6. Původní výpočet s&nbsp;32 bitovými hodnotami</a></p>
<p><a href="#k07">*** 7. Výpočet Mandelbrotovy množiny omezený na 16bitové hodnoty</a></p>
<p><a href="#k08">*** 8. Rozdíly ve zdrojových kódech</a></p>
<p><a href="#k09">*** 9. Rozdíly ve vypočtených obrázcích</a></p>
<p><a href="#k10">*** 10. Výpočty složitějších funkcí</a></p>
<p><a href="#k11">11. Iterativní výpočet druhé odmocniny</a></p>
<p><a href="#k12">12. Demonstrační příklad na výpočet druhé odmocniny ve formátu plovoucí řádové tečky</a></p>
<p><a href="#k13">13. Demonstrační příklad na výpočet druhé odmocniny ve formátu pevné řádové tečky</a></p>
<p><a href="#k14">14. Překlad jedné iterace pro výpočet druhé odmocniny do assembleru</a></p>
<p><a href="#k15">15. Goniometrické funkce počítané pomocí číselných řad</a></p>
<p><a href="#k16">16. Demonstrační příklad: výpočet sinu s&nbsp;využitím Taylorova rozvoje</a></p>
<p><a href="#k17">17. Výsledky výpočtu hodnot funkce sin()</a></p>
<p><a href="#k18">18. Univerzální algoritmus <i>CORDIC</i></a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Výpočty v&nbsp;systému pevné řádové čárky na platformě IBM PC (2. část)</h2>

<p>Na <a
href="https://www.root.cz/clanky/vypocty-v-systemu-pevne-radove-carky-na-platforme-ibm-pc/">úvodní
článek o realizaci aritmetických výpočtů bez využití matematického
koprocesoru</a> dnes navážeme. Opět se budeme zabývat matematickými výpočty,
které využívají numerické hodnoty s&nbsp;pevnou řádovou binární tečkou (čárkou)
&ndash; <i>fixed point</i>. Nejprve si na několika demonstračních příkladech
ukážeme některé limity tohoto způsobu reprezentace numerických hodnot (pro
vizualizaci opět použijeme Mandelbrotovu množinu), dále budeme realizovat
výpočty některých často používaných funkcí (druhá odmocnina, goniometrické
funkce) iteračními algoritmy a v&nbsp;závěru dnešního článku se taktéž
seznámíme s&nbsp;univerzálním algoritmem nazvaným <i>CORDIC</i>
(<i><strong>CO</strong>ordinate <strong>RO</strong>tation
<strong>DI</strong>gital <strong>C</strong>omputer</i>), který je možné
relativně snadno použít pro výpočet goniometrických funkcí, logaritmů atd.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Problémy, které nastávají při omezení výpočtů pouze na n-bitové hodnoty</h2>

<p></p>

<pre>
;-----------------------------------------------------------------------------
org  0x100        ; zacatek kodu pro programy typu COM (vzdy se zacina na 256)

start:
        jmp main                   ; skok na zacatek kodu

%include "io.asm"                  ; nacist symboly, makra a podprogramy
%include "print.asm"               ; nacist symboly, makra a podprogramy

P       equ     65536              ; poloha desetinne tecky v FX-pointu

x       equ     2 * P              ; konstanty, ktere se budou nasobit
y       equ     P / 256

main:
        mov  eax, x
        print_hex eax              ; vytisknout hodnotu prvni konstanty

        mov  eax, y
        print_hex eax              ; vytisknout hodnotu druhe konstanty

        mov  eax, x
        mov  ebx, y
        shr  eax, 8                ; posun jeste pred nasobenim (ztrata presnosti)
        shr  ebx, 8                ; posun jeste pred nasobenim (ztrata presnosti)
        mul  ebx                   ; nasobeni v FX-pointu do EDX:EAX
        print_hex eax

finish:
        wait_key                   ; cekani na klavesu
        exit                       ; navrat do DOSu


; datova cast
section .data

section .bss
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Násobení příliš malých hodnot</h2>

<pre>
;-----------------------------------------------------------------------------
org  0x100        ; zacatek kodu pro programy typu COM (vzdy se zacina na 256)

start:
        jmp main                   ; skok na zacatek kodu

%include "io.asm"                  ; nacist symboly, makra a podprogramy
%include "print.asm"               ; nacist symboly, makra a podprogramy

P       equ     65536              ; poloha desetinne tecky v FX-pointu

x       equ     2 * P              ; konstanty, ktere se budou nasobit
y       equ     P / 512

main:
        mov  eax, x
        print_hex eax              ; vytisknout hodnotu prvni konstanty

        mov  eax, y
        print_hex eax              ; vytisknout hodnotu druhe konstanty

        mov  eax, x
        mov  ebx, y
        shr  eax, 8                ; posun jeste pred nasobenim (ztrata presnosti)
        shr  ebx, 8                ; posun jeste pred nasobenim (ztrata presnosti)
        mul  ebx                   ; nasobeni v FX-pointu do EDX:EAX
        print_hex eax

finish:
        wait_key                   ; cekani na klavesu
        exit                       ; navrat do DOSu


; datova cast
section .data

section .bss
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpočty omezené na 2n-bitové hodnoty</h2>

<pre>
;-----------------------------------------------------------------------------
org  0x100        ; zacatek kodu pro programy typu COM (vzdy se zacina na 256)

start:
        jmp main                   ; skok na zacatek kodu

%include "io.asm"                  ; nacist symboly, makra a podprogramy
%include "print.asm"               ; nacist symboly, makra a podprogramy

P       equ     65536              ; poloha desetinne tecky v FX-pointu

x       equ     2 * P              ; konstanty, ktere se budou nasobit
y       equ     P / 512

main:
        mov  eax, x
        print_hex eax              ; vytisknout hodnotu prvni konstanty

        mov  eax, y
        print_hex eax              ; vytisknout hodnotu druhe konstanty

        mov  eax, x
        mov  ebx, y
        mul  ebx                   ; nasobeni v FX-pointu do EDX:EAX
        mov  ax, dx                ; bity 16-32
        ror  eax, 16               ; prohodit horni a spodni polovinu registru
        print_hex eax

finish:
        wait_key                   ; cekani na klavesu
        exit                       ; navrat do DOSu


; datova cast
section .data

section .bss
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Snížení počtu bitů reprezentujících numerické hodnoty při výpočtu Mandelbrotovy množiny</h2>

<p></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Původní výpočet s&nbsp;32 bitovými hodnotami</h2>

<p></p>

<pre>
;-----------------------------------------------------------------------------
org  0x100        ; zacatek kodu pro programy typu COM (vzdy se zacina na 256)

; konstanty
P       equ     4096               ; poloha desetinne tecky v X-pointu
K       equ     4*P/256            ; vzdalenost mezi dvema body (krok smycky)
L       equ     4*P/192
MIN     equ     -2*P               ; minimalni a maximalni hodnota konstant fraktalu
                                   ; v komplexni rovine
MAXITER equ     40                 ; maximalni pocet iteraci
BAILOUT equ     4
SLOUPCU equ     320                ; pocet sloupcu na obrazovce

section .text

start:
        jmp main                   ; skok na zacatek kodu

%include "io.asm"                  ; nacist symboly, makra a podprogramy


main:
        mov     ax, 13h            ; graficky rezim 320x200x256
        int     10h

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;: MANDELBROTOVA MNOZINA                                                    ::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        push    0xa000
        pop     ES                 ; segment obrazove pameti karty VGA

        xor     DI, DI             ; zacatek vykreslovani na obrazovce
        mov     CL, 6              ; posun pro FX format

mforx:  mov     dword [cx_], MIN   ; od -2 (imaginarni osa)
        mov     SI, SLOUPCU        ; x
mfory:  mov     CH, MAXITER        ; pocet iteraci
        xor     EAX, EAX           ;
        mov     EBP, EAX           ; nastaveni real.casti zacatku
        mov     dword [zy1], EAX   ; nastaveni imag.casti zacatku
iter_loop:                         ; *** iteracni smycka ***
        mov     EAX, EBP           ;
        sar     EAX, CL            ;
        imul    EAX                ; zx2:=zx1^2 (v X-pointu)
        mov     dword [zx2], EAX   ;

        mov     EAX, dword [zy1]   ;
        sar     EAX, CL            ; 
        imul    EAX                ; zy2:=zy1^2 (v X-pointu)
        mov     dword [zy2], EAX   ;

        mov     EAX, EBP           ;
        sar     EAX, CL            ; zx1 div 256 (pro mul v X-pointu)

        mov     EBX, [zy1]         ;
        sar     EBX, 5             ; zy1 div 256 * 2 (pro mul v X-pointu)

        imul    EBX                ; zy1:=2*zx1*zy1
        add     EAX, [cy_]         ; zy1:=2*zx1*zy1+CY (u Mandelbrota poc.iter.)
        mov     [zy1], EAX         ; ulozit novou hodnotu zy1

        mov     EAX, [zx2]         ;
        sub     EAX, [zy2]         ; zx2:=zx2-zy2=zx1^2-zy1^2
        add     EAX, [cx_]         ;
        mov     EBP, EAX           ; zx1:=zx1^2-zy1^2+CX

        dec     CH                 ; pocitadlo iteraci
        jz      short mpokrac      ; konec iteraci ?
        mov     EAX, [zx2]         ;
        add     EAX, [zy2]         ; ==zx1^2+zy1^2
        cmp     EAX, BAILOUT*P     ; kontrola na bailout (abs[Z]&lt;4)
        jc      short iter_loop    ; abs[Z]&lt;4 =&gt;dalsi iterace
mpokrac:
        mov     AL, CH             ; pocet iteraci
        add     AL, 32             ; posun na vhodne barvy v palete
        stosb                      ; vykreslit pixel+posun na dalsi pixel
        add     dword [cx_], K     ; cy_:=cy_+K
        dec     si
        jnz     short mfory        ; Y!=0 -&gt;dalsi radek

        add     dword [cy_], L     ; cx_:=cx_+K
        cmp     di, 64000          ; konec obrazku ?
        jne     mforx

finish:
        wait_key                   ; cekani na klavesu
        exit                       ; navrat do DOSu


section .data

cy_     dd MIN                     ; poloha v komplexni rovine rovine

section .bss

cx_     resd 1                     ;
zy1     resd 1                     ; aktualni poloha v komplexni rovine
zx2     resd 1                     ; zx2=zx1^2 (aby se to nemuselo pocitat 2x)
zy2     resd 1                     ; zy2=zy1^2



; finito
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výpočet Mandelbrotovy množiny omezený na 16bitové hodnoty</h2>

<pre>
;-----------------------------------------------------------------------------
org  0x100        ; zacatek kodu pro programy typu COM (vzdy se zacina na 256)

; konstanty
P       equ     4096               ; poloha desetinne tecky v X-pointu
K       equ     4*P/256            ; vzdalenost mezi dvema body (krok smycky)
L       equ     4*P/192
MIN     equ     -2*P               ; minimalni a maximalni hodnota konstant fraktalu
                                   ; v komplexni rovine
MAXITER equ     40                 ; maximalni pocet iteraci
BAILOUT equ     4
SLOUPCU equ     320                ; pocet sloupcu na obrazovce

section .text

start:
        jmp main                   ; skok na zacatek kodu

%include "io.asm"                  ; nacist symboly, makra a podprogramy


main:
        mov     ax, 13h            ; graficky rezim 320x200x256
        int     10h

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;: MANDELBROTOVA MNOZINA                                                    ::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        push    0xa000
        pop     ES                 ; segment obrazove pameti karty VGA

        xor     DI, DI             ; zacatek vykreslovani na obrazovce
        mov     CL, 6              ; posun pro FX format

mforx:  mov     word [cx_], MIN    ; od -2 (imaginarni osa)
        mov     SI, SLOUPCU        ; x
mfory:  mov     CH, MAXITER        ; pocet iteraci
        xor     AX, AX             ;
        mov     BP, AX             ; nastaveni real.casti zacatku
        mov     word [zy1], AX     ; nastaveni imag.casti zacatku
iter_loop:                         ; *** iteracni smycka ***
        mov     AX, BP             ;
        sar     AX, CL             ;
        imul    AX                 ; zx2:=zx1^2 (v X-pointu)
        mov     word [zx2], AX     ;
        mov     AX, [zy1]          ;
        sar     AX,CL              ;
        imul    AX                 ; zy2:=zy1^2 (v X-pointu)
        mov     word [zy2], AX     ;

        mov     AX, BP             ;
        sar     AX,CL              ; zx1 div 256 (pro mul v X-pointu)
        mov     BX, [zy1]          ;
        sar     BX,5               ; zy1 div 256 * 2 (pro mul v X-pointu)
        imul    BX                 ; zy1:=2*zx1*zy1
        add     AX, [cy_]          ; zy1:=2*zx1*zy1+CY (u Mandelbrota poc.iter.)
        mov     [zy1], AX          ; ulozit

        mov     AX, [zx2]          ;
        sub     AX, [zy2]          ; zx2:=zx2-zy2=zx1^2-zy1^2
        add     AX, [cx_]          ;
        mov     BP, AX             ; zx1:=zx1^2-zy1^2+CX
        dec     CH                 ; pocitadlo iteraci
        jz      short mpokrac      ; konec iteraci ?
        mov     AX, [zx2]          ;
        add     AX, [zy2]          ; ==zx1^2+zy1^2
        cmp     AX, BAILOUT*P      ; kontrola na bailout (abs[Z]&lt;4)
        jc      short iter_loop    ; abs[Z]&lt;4 =&gt;dalsi iterace
mpokrac:
        mov     AL, CH             ; pocet iteraci
        add     AL, 32             ; posun na vhodne barvy v palete
        stosb                      ; vykreslit pixel+posun na dalsi pixel
        add     word [cx_], K      ; cy_:=cy_+K
        dec     si
        jnz     short mfory        ; Y!=0 -&gt;dalsi radek

        add     word [cy_], L      ; cx_:=cx_+L
        cmp     di, 64000          ; konec obrazku ?
        jne     short mforx

finish:
        wait_key                   ; cekani na klavesu
        exit                       ; navrat do DOSu


section .data

cy_     dw MIN                     ; poloha v komplexni rovine rovine

section .bss

cx_     resw 1                     ;
zy1     resw 1                     ; aktualni poloha v komplexni rovine
zx2     resw 1                     ; zx2=zx1^2 (aby se to nemuselo pocitat 2x)
zy2     resw 1                     ; zy2=zy1^2



; finito
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rozdíly ve zdrojových kódech</h2>

<pre>
--- fx_mandel_2.asm     2025-07-02 13:00:19.307893801 +0200
+++ fx_mandel_3.asm     2025-07-02 13:20:35.772896137 +0200
@@ -33,55 +33,51 @@
         xor     DI, DI             ; zacatek vykreslovani na obrazovce
         mov     CL, 6              ; posun pro FX format
 
-mforx:  mov     dword [cx_], MIN   ; od -2 (imaginarni osa)
+mforx:  mov     word [cx_], MIN    ; od -2 (imaginarni osa)
         mov     SI, SLOUPCU        ; x
 mfory:  mov     CH, MAXITER        ; pocet iteraci
-        xor     EAX, EAX           ;
-        mov     EBP, EAX           ; nastaveni real.casti zacatku
-        mov     dword [zy1], EAX   ; nastaveni imag.casti zacatku
+        xor     AX, AX             ;
+        mov     BP, AX             ; nastaveni real.casti zacatku
+        mov     word [zy1], AX     ; nastaveni imag.casti zacatku
 iter_loop:                         ; *** iteracni smycka ***
-        mov     EAX, EBP           ;
-        sar     EAX, CL            ;
-        imul    EAX                ; zx2:=zx1^2 (v X-pointu)
-        mov     dword [zx2], EAX   ;
-
-        mov     EAX, dword [zy1]   ;
-        sar     EAX, CL            ; 
-        imul    EAX                ; zy2:=zy1^2 (v X-pointu)
-        mov     dword [zy2], EAX   ;
-
-        mov     EAX, EBP           ;
-        sar     EAX, CL            ; zx1 div 256 (pro mul v X-pointu)
-
-        mov     EBX, [zy1]         ;
-        sar     EBX, 5             ; zy1 div 256 * 2 (pro mul v X-pointu)
-
-        imul    EBX                ; zy1:=2*zx1*zy1
-        add     EAX, [cy_]         ; zy1:=2*zx1*zy1+CY (u Mandelbrota poc.iter.)
-        mov     [zy1], EAX         ; ulozit novou hodnotu zy1
-
-        mov     EAX, [zx2]         ;
-        sub     EAX, [zy2]         ; zx2:=zx2-zy2=zx1^2-zy1^2
-        add     EAX, [cx_]         ;
-        mov     EBP, EAX           ; zx1:=zx1^2-zy1^2+CX
-
+        mov     AX, BP             ;
+        sar     AX, CL             ;
+        imul    AX                 ; zx2:=zx1^2 (v X-pointu)
+        mov     word [zx2], AX     ;
+        mov     AX, [zy1]          ;
+        sar     AX,CL              ;
+        imul    AX                 ; zy2:=zy1^2 (v X-pointu)
+        mov     word [zy2], AX     ;
+
+        mov     AX, BP             ;
+        sar     AX,CL              ; zx1 div 256 (pro mul v X-pointu)
+        mov     BX, [zy1]          ;
+        sar     BX,5               ; zy1 div 256 * 2 (pro mul v X-pointu)
+        imul    BX                 ; zy1:=2*zx1*zy1
+        add     AX, [cy_]          ; zy1:=2*zx1*zy1+CY (u Mandelbrota poc.iter.)
+        mov     [zy1], AX          ; ulozit
+
+        mov     AX, [zx2]          ;
+        sub     AX, [zy2]          ; zx2:=zx2-zy2=zx1^2-zy1^2
+        add     AX, [cx_]          ;
+        mov     BP, AX             ; zx1:=zx1^2-zy1^2+CX
         dec     CH                 ; pocitadlo iteraci
         jz      short mpokrac      ; konec iteraci ?
-        mov     EAX, [zx2]         ;
-        add     EAX, [zy2]         ; ==zx1^2+zy1^2
-        cmp     EAX, BAILOUT*P     ; kontrola na bailout (abs[Z]&lt;4)
+        mov     AX, [zx2]          ;
+        add     AX, [zy2]          ; ==zx1^2+zy1^2
+        cmp     AX, BAILOUT*P      ; kontrola na bailout (abs[Z]&lt;4)
         jc      short iter_loop    ; abs[Z]&lt;4 =&gt;dalsi iterace
 mpokrac:
         mov     AL, CH             ; pocet iteraci
         add     AL, 32             ; posun na vhodne barvy v palete
         stosb                      ; vykreslit pixel+posun na dalsi pixel
-        add     dword [cx_], K     ; cy_:=cy_+K
+        add     word [cx_], K      ; cy_:=cy_+K
         dec     si
         jnz     short mfory        ; Y!=0 -&gt;dalsi radek
 
-        add     dword [cy_], L     ; cx_:=cx_+K
+        add     word [cy_], L      ; cx_:=cx_+L
         cmp     di, 64000          ; konec obrazku ?
-        jne     mforx
+        jne     short mforx
 
 finish:
         wait_key                   ; cekani na klavesu
@@ -90,14 +86,14 @@
 
 section .data
 
-cy_     dd MIN                     ; poloha v komplexni rovine rovine
+cy_     dw MIN                     ; poloha v komplexni rovine rovine
 
 section .bss
 
-cx_     resd 1                     ;
-zy1     resd 1                     ; aktualni poloha v komplexni rovine
-zx2     resd 1                     ; zx2=zx1^2 (aby se to nemuselo pocitat 2x)
-zy2     resd 1                     ; zy2=zy1^2
+cx_     resw 1                     ;
+zy1     resw 1                     ; aktualni poloha v komplexni rovine
+zx2     resw 1                     ; zx2=zx1^2 (aby se to nemuselo pocitat 2x)
+zy2     resw 1                     ; zy2=zy1^2
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Rozdíly ve vypočtených obrázcích</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výpočty složitějších funkcí</h2>




<p><a name="k11"></a></p>
<h2 id="k11">11. Iterativní výpočet druhé odmocniny</h2>

<p>Výpočet druhé odmocniny (<i>square root</i>) je v&nbsp;praxi velmi často
používaný (počítačová grafika, dnes například zpracování přirozeného jazyka
atd.) a i z&nbsp;tohoto důvodu je implementován ve většině FPU, ale i GPU.  My
si v&nbsp;tomto článku ukážeme jednu z&nbsp;možností implementace, která
spočívá v&nbsp;iterativním zpřesňování odhadu výsledku. Nyní se tedy povězme,
jakým způsobem se může iterativní výpočet druhé odmocniny provádět. Vstupní
hodnotou algoritmu je původní číslo <strong>y</strong>, výstupem je (po
<strong>i</strong>-té iteraci) odhad výsledku <strong>x<sub>i</sub></strong>.
V&nbsp;každé iteraci se provádí poměrně jednoduchá operace vyžadující
dělení:</p>

<p><i>x<sub>i+1</sub>=1/2 (x<sub>i</sub>+y/x<sub>i</sub>)</i></p>

<p>Zbývá nám pouze nastavit počáteční odhad <i>x<sub>1</sub></i>. Většinou se
volí hodnota <i>x<sub>1</sub>=y/2</i>, protože je ji možné velmi jednoduše
spočítat prostým bitovým posunem mantisy nebo snížením hodnoty exponentu (a u
FX operací ještě jednodušeji pouhým bitovým posunem). Přesnější (a tím pádem i
rychlejší, jelikož se provede méně iterací) je však odhad vypočtený
z&nbsp;mantisy a exponentu vstupující hodnoty <i>y</i>, což lze ovšem provést
jen u FP hodnot:</p>

<p><i>x<sub>1</sub>=m&times;2<sup>e/2</sup></i></p>

<p>tj.&nbsp;hodnota exponentu se sníží na polovinu. Důkaz pro korektnost takto
vytvořeného prvního odhadu je poměrně přímočarý. Vstupní hodnota <i>y</i> může
být rozepsána na mantisu a exponent:</p>

<p><i>y=m&times;2<sup>e</sup></i></p>

<p>Znaménko můžeme ignorovat, protože odmocniny se počítají pouze pro kladné
hodnoty. Prvotní odhad vychází z&nbsp;aplikace odmocniny na výše uvedený
rozepsaný vztah:</p>

<p><i>y<sup>1/2</sup>=m<sup>1/2</sup>&times;2<sup>e/2</sup></i></p>

<p>Hodnotu mantisy je možné (resp.&nbsp;nutné) ignorovat, protože normalizovaná
mantisa představuje hodnoty z&nbsp;intervalu &lt;1, 2-&epsilon;&gt; a tento
interval se aplikací odmocniny nijak nemění.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Demonstrační příklad na výpočet druhé odmocniny ve formátu plovoucí řádové tečky</h2>

<p>Pro ilustraci iterativního výpočtu druhé odmocniny a zejména faktu, že
řešení poměrně rychle (jen po několika iteracích) spěje ke korektnímu výsledku,
si ukažme demonstrační příklad napsaný pro jednoduchost v&nbsp;programovacím
jazyku C. Po překladu a spuštění tohoto příkladu se zobrazí tabulka
s&nbsp;postupně zpřesňovaným výpočtem druhé odmocniny hodnoty 10&nbsp;000.
Kromě průběžných výsledků je zobrazována i absolutní a relativní chyba
výpočtu:</p>

<pre>
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* tato funkce provede jednu iteraci</i>
<i> * se zlepšeným odhadem výsledku x_i</i>
<i> */</i>
float <strong>sqrt_step</strong>(float xi, float y)
{
    return 1.0 / 2.0 * (xi + y / xi);
}
&nbsp;
int <strong>main</strong>(void) {
    <i>/* vstupní hodnota, ze které se počítá odmocnina */</i>
    double y = 10000;
&nbsp;
    <i>/* postupně zpřesňovaný odhad výsledku */</i>
    double xi = y;
&nbsp;
    <i>/* hodnota pro porovnání výsledků */</i>
    double sqr = sqrt(y);
&nbsp;
    <i>/* počitadlo iterací */</i>
    int i;
&nbsp;
    <i>/* iterativní výpočet */</i>
    for (i = 0; i &lt; 20; i++) {
        double abs_error, rel_error;
        xi = sqrt_step(xi, y);                      <i>/* zpřesnění odhadu */</i>
        abs_error = fabs(xi - sqr);                 <i>/* absolutní chyba */ </i>
        rel_error = 100.0f * fabs(xi - sqr) / sqr;  <i>/* relativní chyba */</i>
        printf("%d\t%11.5f\t%11.5f\t%10.2f%%\n", i + 1, xi, abs_error, rel_error);
    }
    return 0;
}
&nbsp;
<i>/* finito */</i>
</pre>

<p>Podívejme se nyní na výsledky vypočtené a vypsané tímto příkladem. Všimněte
si, že již po deseti iteracích klesá relativní chyba pod setinu procenta
(alespoň v&nbsp;rámci dané přesnosti FP formátu), takže iterační metoda je
zvolena vhodně, protože řešení konverguje velmi rychle:</p>

<pre>
iterace  mezivýsledek    absolutní chyba   relativní chyba
----------------------------------------------------------
1        5000.50000      4900.50000        4900.50%
2        2501.25000      2401.25000        2401.25%
3        1252.62402      1152.62402        1152.62%
4         630.30365       530.30365         530.30%
5         323.08450       223.08450         223.08%
6         177.01808        77.01808          77.02%
7         116.75475        16.75475          16.75%
8         101.20218         1.20218           1.20%
9         100.00714         0.00714           0.01%
10        100.00000         0.00000           0.00%
11        100.00000         0.00000           0.00%
12        100.00000         0.00000           0.00%
13        100.00000         0.00000           0.00%
14        100.00000         0.00000           0.00%
15        100.00000         0.00000           0.00%
16        100.00000         0.00000           0.00%
17        100.00000         0.00000           0.00%
18        100.00000         0.00000           0.00%
19        100.00000         0.00000           0.00%
20        100.00000         0.00000           0.00%
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Demonstrační příklad na výpočet druhé odmocniny ve formátu pevné řádové tečky</h2>

<p>Demonstrační příklad <a href="#k12">z&nbsp;předchozí kapitoly</a> si můžeme
relativně snadno přepsat do varianty používající formát pevné řádové tečky
(čárky). Namísto FP výpočtů tedy využijeme celočíselné operace a pouze
zajistíme, aby byla zachována pozice řádové tečky. Konkrétně budou všechny
výpočty probíhat s&nbsp;hodnotami <strong>int32_t</strong> (C99 a vyšší) a
pozice řádové tečky bude nastavena mezi bit s&nbsp;indexem 15 a 16:</p>

<pre>
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* počet míst před a za binární řádovou tečkou */</i>
#define A 16
#define B 16
&nbsp;
<i>/* datový typ, se kterým budeme pracovat */</i>
typedef int32_t fx;
&nbsp;
<i>/* hlavičky použitých funkcí */</i>
void fx_print(fx x);
fx fp2fx(double x);
double fx2fp(fx x);
&nbsp;
<i>/*</i>
<i> * Tisk numerické hodnoty uložené ve formátu pevné</i>
<i> * řádové binární čárky (FX)</i>
<i> */</i>
void <strong>fx_print</strong>(fx x)
{
    int i;
    int val = x;                /* pomocná proměnná pro převod do dvojkové soustavy */
    printf("bin: ");
    for (i = 0; i &lt; A + B; i++) {       /* převod na řetězec bitů (do dvojkové soustavy) */
        putchar(!!(val &amp; (1 &lt;&lt; (A + B - 1))) + '0');    /* výpis hodnoty aktuálně nejvyššího bitu */
        if (i == B - 1)
            putchar('.');       /* po řádové binární čárce vypsat značku */
        val = val &lt;&lt; 1;         /* posun na další (méně významný) bit */
    }
&nbsp;
    printf("   hex: %08x   fp: %+11.5f\n", x, fx2fp(x));
}
&nbsp;
<i>/*</i>
<i> * Převod z formátu plovoucí řádové binární čárky (FP)</i>
<i> * do formátu pevné řádové binární čárky (FX)</i>
<i> */</i>
fx <strong>fp2fx</strong>(double x)
{
    return (fx) (x * (2 &lt;&lt; (B - 1)));
}
&nbsp;
<i>/*</i>
<i> * Převod z celočíselného formátu (integer)</i>
<i> * do formátu pevné řádové binární čárky (FX)</i>
<i> */</i>
fx <strong>int2fx</strong>(int x)
{
    return (fx) (x &lt;&lt; B);
}
&nbsp;
<i>/*</i>
<i> * Převod z formátu pevné řádové binární čárky (FX)</i>
<i> * do formátu plovoucí řádové binární čárky (FP)</i>
<i> */</i>
double <strong>fx2fp</strong>(fx x)
{
    return (double) x / (2 &lt;&lt; (B - 1));
}
&nbsp;
<i>/*</i>
<i> * Součet dvou hodnot uložených ve shodném formátu</i>
<i> * pevné binární řádové čárky (FX)</i>
<i> */</i>
fx <strong>fx_add</strong>(fx x, fx y)
{
    return x + y;
}
&nbsp;
<i>/*</i>
<i> * Rozdíl dvou hodnot uložených ve shodném formátu</i>
<i> * pevné binární řádové čárky (FX)</i>
<i> */</i>
fx <strong>fx_sub</strong>(fx x, fx y)
{
    return x - y;
}
&nbsp;
<i>/*</i>
<i> * Součin dvou hodnot uložených ve shodném formátu</i>
<i> * pevné binární řádové čárky (FX)</i>
<i> */</i>
fx <strong>fx_mul</strong>(fx x, fx y)
{
    fx result = (x &gt;&gt; (B / 2)) * (y &gt;&gt; (B / 2));
    return result;
}
&nbsp;
<i>/*</i>
<i> * Podíl dvou hodnot uložených ve shodném formátu</i>
<i> * pevné binární řádové čárky (FX)</i>
<i> */</i>
fx <strong>fx_div</strong>(fx x, fx y)
{
    fx result = x / (y &gt;&gt; (B / 2));
    return result &lt;&lt; (B / 2);
}
&nbsp;
<i>/* jeden krok odhadu druhé odmocniny */</i>
fx <strong>sqrt_step_calc</strong>(fx f1, fx f2, fx xi, fx y)
{
    return fx_mul(fx_div(f1, f2), xi + fx_div(y, xi));
}
&nbsp;
<i>/* tato funkce provede jednu iteraci</i>
<i> * se zlepšeným odhadem výsledku x_i</i>
<i> */</i>
fx <strong>sqrt_step</strong>(fx xi, fx y)
{
    fx f1 = fp2fx(1.0);
    fx f2 = fp2fx(2.0);
    return sqrt_step_calc(f1, f2, xi, y);
}
&nbsp;
int <strong>main</strong>(void) {
    double orig_y = 10000.0;
&nbsp;
    <i>/* vstupní hodnota, ze které se počítá odmocnina */</i>
    fx y = fp2fx(orig_y);
&nbsp;
    <i>/* postupně zpřesňovaný odhad výsledku */</i>
    fx xi = y;
&nbsp;
    <i>/* hodnota pro porovnání výsledků */</i>
    double sqr = sqrt(orig_y);
&nbsp;
    <i>/* počitadlo iterací */</i>
    int i;
&nbsp;
    <i>/* iterativní výpočet */</i>
    for (i = 0; i &lt; 20; i++) {
        double abs_error, rel_error;
        double xf;
        xi = sqrt_step(xi, y);                      <i>/* zpřesnění odhadu */</i>
        xf = fx2fp(xi);                             <i>/* převést na FP pro výpočty a tisk */</i>
        abs_error = fabs(xf - sqr);                 <i>/* absolutní chyba */ </i>
        rel_error = 100.0f * fabs(xf - sqr) / sqr;  <i>/* relativní chyba */</i>
        printf("%d\t%11.5f\t%11.5f\t%10.2f%%\n", i + 1, xf, abs_error, rel_error);
    }
    return 0;
}
&nbsp;
<i>/* finito */</i>
</pre>

<p>Výsledky ukazují, že ke korektní hodnotě opět dospějeme relativně rychle; po
deseti iteracích:</p>

<pre>
iterace  mezivýsledek    absolutní chyba   relativní chyba
----------------------------------------------------------
1        5000.50000      4900.50000        4900.50%
2        2501.24805      2401.24805        2401.25%
3        1252.62109      1152.62109        1152.62%
4         630.30078       530.30078         530.30%
5         323.08203       223.08203         223.08%
6         177.01562        77.01562          77.02%
7         116.75391        16.75391          16.75%
8         101.20117         1.20117           1.20%
9         100.00586         0.00586           0.01%
10        100.00000         0.00000           0.00%
11        100.00000         0.00000           0.00%
12        100.00000         0.00000           0.00%
13        100.00000         0.00000           0.00%
14        100.00000         0.00000           0.00%
15        100.00000         0.00000           0.00%
16        100.00000         0.00000           0.00%
17        100.00000         0.00000           0.00%
18        100.00000         0.00000           0.00%
19        100.00000         0.00000           0.00%
20        100.00000         0.00000           0.00%
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Překlad jedné iterace pro výpočet druhé odmocniny do assembleru</h2>

<p>Výpočty jsme sice ve formátu FX realizovali relativně snadno, ovšem ještě se
musíme podívat na to, jak kvalitně nebo nekvalitně byl kód přeložen do
assembleru. Při vypnutí optimalizací (<strong>-O0</strong>) bude výsledkem
otrocký překlad původních příkazů zapsaných v&nbsp;jazyku C a výsledek bude
dlouhý a pomalý (ostatně přesně podle předpokladů):</p>

<pre>
<strong>sqrt_step_calc</strong>(int, int, int, int):
        push    rbp
        mov     rbp, rsp
        push    rbx
        sub     rsp, 16
        mov     DWORD PTR [rbp-12], edi
        mov     DWORD PTR [rbp-16], esi
        mov     DWORD PTR [rbp-20], edx
        mov     DWORD PTR [rbp-24], ecx
        mov     edx, DWORD PTR [rbp-20]
        mov     eax, DWORD PTR [rbp-24]
        mov     esi, edx
        mov     edi, eax
        call    fx_div(int, int)
        mov     edx, DWORD PTR [rbp-20]
        lea     ebx, [rax+rdx]
        mov     edx, DWORD PTR [rbp-16]
        mov     eax, DWORD PTR [rbp-12]
        mov     esi, edx
        mov     edi, eax
        call    fx_div(int, int)
        mov     esi, ebx
        mov     edi, eax
        call    fx_mul(int, int)
        mov     rbx, QWORD PTR [rbp-8]
        leave
        ret
</pre>

<p>Při použití optimalizací (<strong>-O9</strong>) bude výsledek nepatrně
lepší:</p>

<pre>
<strong>sqrt_step_calc</strong>(int, int, int, int):
        mov     eax, ecx
        mov     r9d, edx
        mov     r8d, edx
        sar     esi, 8
        sar     r9d, 8
        cdq
        idiv    r9d
        mov     ecx, eax
        mov     eax, edi
        cdq
        sal     ecx, 8
        idiv    esi
        add     ecx, r8d
        sar     ecx, 8
        mov     edi, eax
        mov     eax, ecx
        sal     edi, 8
        sar     edi, 8
        imul    eax, edi
        ret
</pre>

<p>I zde však máme prostor pro další optimalizace. Například není nutné
předávat konstanty 1 a 2 ve formátu FX. Ovšem důležitější je, že lze využít
odlišný algoritmus, který výsledek <i>odhadne</i> rychleji. Podrobnosti si
řekneme příště.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Goniometrické funkce počítané pomocí číselných řad</h2>

<p>Goniometrické funkce, které jsou velmi důležité například v&nbsp;počítačové
grafice, je možné počítat více způsoby. V&nbsp;navazující části tohoto seriálu
si ukážeme výpočet goniometrických funkcí pomocí algoritmu <i>CORDIC</i>, dnes
si pouze řekneme, jakým způsobem je možné použít číselné řady. Uvažujme
například funkci <i>sin()</i>, která je, jak víme už ze střední školy, funkcí
periodickou s&nbsp;periodou 2&pi; (pro další goniometrické funkce platí podobné
vztahy a závěry, tj.&nbsp;v&nbsp;dalším textu se jimi nebudu zabývat).</p>

<p>Na první pohled to vypadá, že se můžeme omezit pouze na výpočet této funkce
pro vstupní hodnoty z&nbsp;intervalu &lt;0, 2&pi;&gt;. Ve skutečnosti však
můžeme využít velké symetrie této funkce, a to dokonce dvakrát.
V&nbsp;intervalu &lt;&pi;, 2&pi;&gt; je funkce zrcadlově otočena vůči vzoru
z&nbsp;intervalu &lt;0, &pi;&gt;. Kromě toho je funkce na intervalu &lt;0,
&pi;/2&gt; vertikálně symetrická s&nbsp;intervalem &lt;&pi;/2, &pi;&gt;.
Z&nbsp;obou těchto symetrií vyplývá, že je zapotřebí přímým výpočtem zjistit
hodnoty funkce <i>sin()</i> pouze na intervalu &lt;0, &pi;/2&gt;, hodnoty
v&nbsp;ostatních intervalech se dopočítají buď změnou znaménka výsledku, nebo
změnou vstupní hodnoty. Daný interval jednoho &bdquo;kvadrantu&ldquo; má i
další přednost: funkce <i>sin()</i> je v&nbsp;něm neustále rostoucí bez
nežádoucích zákmitů a lokálních minim či maxim.</p>

<p>Všechny goniometrické funkce je možné na určitém intervalu (typicky
kvadrantu) rozepsat s&nbsp;využitím Taylorova rozvoje. V&nbsp;případě funkce
<i>sin()</i> dostaneme nekonečný rozvoj, který vypadá následovně:</p>

<p><strong>sin(x)=x<sup>1</sup>/1! - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + ...</strong></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Demonstrační příklad: výpočet sinu s&nbsp;využitím Taylorova rozvoje</h2>

<p>Taylorův rozvoj sice na první pohled vypadá výpočetně velmi náročně, ve
skutečnosti je však v&nbsp;praxi zapotřebí pro dosažení relativně dobré
přesnosti vypočítat poměrně malé množství jeho členů, o čemž nás přesvědčí
demonstrační příklad uvedený pod tímto odstavcem, který pro výpočet funkce
<i>sin()</i> na intervalu &lt;0, &pi;/2&gt; používá pouze první tři nenulové
členy posloupnosti (což se může zdát jako pouze velmi hrubé přiblížení):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
&nbsp;
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
&nbsp;
#define EPSILON 10.0e-20
&nbsp;
<i>/* tato funkce provede výpočet funkce</i>
<i> * sin() pomocí tří nenulových členů</i>
<i> * Taylorova rozvoje</i>
<i> */</i>
double <strong>compute_sin</strong>(double x)
{
    double t1=x/1.0;
    double t3=x*x*x/6.0;
    double t5=x*x*x*x*x/120.0;
    return t1-t3+t5;
}
&nbsp;
int <strong>main</strong>(void)
{
    <i>/* počitadlo iterací */</i>
    double alfa;
    for (alfa=0.0; alfa&lt;=M_PI/2.0; alfa+=M_PI/40.0) {
        <i>/* korektní výpočet */</i>
        double sin1=sin(alfa);
&nbsp;
        <i>/* náš odhad */</i>
        double sin2=compute_sin(alfa);
&nbsp;
        <i>/* absolutní chyba */ </i>
        double abs_error = fabs(sin2-sin1);
&nbsp;
        <i>/* relativní chyba */</i>
        double rel_error = fabs(sin1)&lt;EPSILON ? 0.0 : 100.0*fabs(sin2-sin1)/sin1;
&nbsp;
        <i>/* tisk řádku tabulky */</i>
        printf("%5.3f\t%8.6f\t%8.6f\t%8.6f\t%6.2f%%\n",
                alfa,
                sin1,
                sin2,
                abs_error,
                rel_error);
    }
    return 0;
}
&nbsp;
<i>/* finito */</i>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výsledky výpočtu hodnot funkce sin()</h2>

<p>Po překladu a spuštění příkladu <a href="#k16">z&nbsp;předchozí kapitoly</a>
se zobrazí následující tabulka (bez prvního řádku), s&nbsp;vyčíslenými
hodnotami funkce <i>sin()</i> pro 21 úhlů z&nbsp;prvního kvadrantu. Ve druhém
sloupci je výsledek standardní matematické operace <i>sin()</i>, třetí sloupec
obsahuje hodnoty vypočtené pomocí tří členů Taylorova rozvoje a
v&nbsp;posledních dvou sloupcích je spočtena a zobrazena absolutní a relativní
chyba. Všimněte si, že chyba postupně stoupá od prakticky nulové hodnoty
(přesný výsledek) až po cca 0,5%. To je jedna z&nbsp;vlastností Taylorova
rozvoje; při vzdalování se od počáteční hodnoty chyba obecně roste. Pokud by
bylo zapotřebí použít vyšší přesnosti, není nic jednoduššího, než přidat další
jeden či dva členy rozvoje.</p>

<pre>
úhel    sin()           Taylorův rozvoj absolutní chyba   relativní chyba
0.000   0.000000        0.000000        0.000000          0.00%
0.079   0.078459        0.078459        0.000000          0.00%
0.157   0.156434        0.156434        0.000000          0.00%
0.236   0.233445        0.233445        0.000000          0.00%
0.314   0.309017        0.309017        0.000000          0.00%
0.393   0.382683        0.382684        0.000000          0.00%
0.471   0.453990        0.453992        0.000001          0.00%
0.550   0.522499        0.522502        0.000003          0.00%
0.628   0.587785        0.587793        0.000008          0.00%
0.707   0.649448        0.649465        0.000017          0.00%
0.785   0.707107        0.707143        0.000036          0.01%
0.864   0.760406        0.760477        0.000071          0.01%
0.942   0.809017        0.809146        0.000129          0.02%
1.021   0.852640        0.852866        0.000226          0.03%
1.100   0.891007        0.891386        0.000379          0.04%
1.178   0.923880        0.924493        0.000613          0.07%
1.257   0.951057        0.952017        0.000961          0.10%
1.335   0.972370        0.973834        0.001464          0.15%
1.414   0.987688        0.989867        0.002178          0.22%
1.492   0.996917        1.000088        0.003170          0.32%
1.571   1.000000        1.004525        0.004525          0.45%
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Univerzální algoritmus <i>CORDIC</i></h2>

<p><strong>CORDIC</strong> neboli <i><strong>CO</strong>ordinate
<strong>RO</strong>tation <strong>DI</strong>gital
<strong>C</strong>omputer</i> je výpočetní metoda používající specializovaný
iterativní algoritmus, který slouží v&nbsp;první řadě k&nbsp;výpočtu
trigonometrických funkcí s&nbsp;předem známou přesností, tj.&nbsp;funkcí
<i>sin()</i>, <i>cos()</i>, <i>tan()</i> atd. Po malých úpravách je možné tento
algoritmus využít i pro další výpočty, například fáze (úhlu) a velikosti
komplexních čísel, vyčíslení logaritmických funkcí, hyperbolických funkcí
(<i>sinh()</i>, <i>cosh()</i>, <i>tanh()</i>) atd.</p>

<p>Jednou ze základních vlastností metody CORDIC, která se snad nejvíce
v&nbsp;minulosti postarala o jeho velké rozšíření, je jednoduchost operací,
které se v&nbsp;každé iteraci provádí &ndash; používá se zde totiž pouze
sečítání, odečítání a bitové posuny, žádné další operace nejsou zapotřebí;
dokonce není ani nutné implementovat násobičku (přesněji řečeno, u některých
&bdquo;odvozených&ldquo; funkcí, například <i>tan()</i> je zapotřebí dělička
k&nbsp;vydělení vypočtených hodnot <i>sin()</i> a <i>cos()</i>, viz další
článek). Díky této vlastnosti bylo možné CORDIC využít i ve velmi
(z&nbsp;pohledu moderních CPU) omezených zařízeních, například kalkulačkách či
osmibitových mikrořadičích (omezením zde mám na mysli relativně malý počet
logických členů i ALU bez násobiček a děliček). Podrobnější informace o této
velmi zajímavé metodě budou uvedeny v&nbsp;následujícím pokračování
tohoto seriálu.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>cga_text_mode_1.asm</td><td>standardní textový režim s&nbsp;rozlišením 40&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm</a></td></tr>
<tr><td>27</td><td>cga_text_mode_3.asm</td><td>standardní textový režim s&nbsp;rozlišením 80&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm</a></td></tr>
<tr><td>28</td><td>cga_text_mode_intensity.asm</td><td>změna významu nejvyššího bitu atributového bajtu: vyšší intenzita namísto blikání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm</a></td></tr>
<tr><td>29</td><td>cga_text_mode_cursor.asm</td><td>změna tvaru textového kurzoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm</a></td></tr>
<tr><td>30</td><td>cga_text_gfx_1.asm</td><td>zobrazení &bdquo;rastrové mřížky&ldquo;: pseudografický režim 160&times;25 pixelů (interně textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm</a></td></tr>
<tr><td>31</td><td>cga_text_mode_char_height.asm</td><td>změna výšky znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm</a></td></tr>
<tr><td>32</td><td>cga_text_160x100.asm</td><td>grafický režim 160&times;100 se šestnácti barvami (interně upravený textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>hercules_text_mode_1.asm</td><td>využití standardního textového režimu společně s&nbsp;kartou Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm</a></td></tr>
<tr><td>34</td><td>hercules_text_mode_2.asm</td><td>zákaz blikání v&nbsp;textových režimech</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm</a></td></tr>
<tr><td>35</td><td>hercules_turn_off.asm</td><td>vypnutí generování video signálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm</a></td></tr>
<tr><td>36</td><td>hercules_gfx_mode_1.asm</td><td>přepnutí karty Hercules do grafického režimu (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm</a></td></tr>
<tr><td>37</td><td>hercules_gfx_mode_2.asm</td><td>přepnutí karty Hercules do grafického režimu (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm</a></td></tr>
<tr><td>38</td><td>hercules_putpixel.asm</td><td>subrutina pro vykreslení jediného pixelu na kartě Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>ega_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm</a></td></tr>
<tr><td>40</td><td>ega_text_mode_80x43.asm</td><td>zobrazení 43 textových řádků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm</a></td></tr>
<tr><td>41</td><td>ega_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm</a></td></tr>
<tr><td>42</td><td>ega_gfx_mode_640x200.asm</td><td>přepnutí do grafického režimu 640&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm</a></td></tr>
<tr><td>43</td><td>ega_gfx_mode_640x350.asm</td><td>přepnutí do grafického režimu 640&times;350 pixelů se čtyřmi nebo šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm</a></td></tr>
<tr><td>44</td><td>ega_gfx_mode_bitplanes_1.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (základní způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm</a></td></tr>
<tr><td>45</td><td>ega_gfx_mode_bitplanes_2.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (rychlejší způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>ega_320x200_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm</a></td></tr>
<tr><td>47</td><td>ega_640x350_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 640&times;350 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>ega_standard_font.asm</td><td>použití standardního fontu grafické karty EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm</a></td></tr>
<tr><td>49</td><td>ega_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>ega_palette_1.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 320&times;200 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm</a></td></tr>
<tr><td>51</td><td>ega_palette_2.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 640&times;350 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm</a></td></tr>
<tr><td>52</td><td>ega_palette_3.asm</td><td>změna všech barev v&nbsp;barvové paletě s&nbsp;využitím programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm</a></td></tr>
<tr><td>53</td><td>ega_palette_4.asm</td><td>změna všech barev, včetně barvy okraje, v&nbsp;barvové paletě voláním funkce BIOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>vga_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm</a></td></tr>
<tr><td>55</td><td>vga_text_mode_80x50.asm</td><td>zobrazení 50 a taktéž 28 textových řádků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>VESA BIOS Extensions<br />
<a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions">https://en.wikipedia.org/wiki/VESA_BIOS_Extensions</a>
</li>

<li>Video Electronics Standards Association<br />
<a href="https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association">https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association</a>
</li>

<li>DJGPP (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/DJGPP">https://cs.wikipedia.org/wiki/DJGPP</a>
</li>

<li>DJGPP home page<br />
<a href="http://www.delorie.com/djgpp/">http://www.delorie.com/djgpp/</a>
</li>

<li>DJGPP Zip File Picker<br />
<a href="http://www.delorie.com/djgpp/zip-picker.html">http://www.delorie.com/djgpp/zip-picker.html</a>
</li>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

<li>Programmer's Guide to Yamaha YMF 262/OPL3 FM Music Synthesizer<br />
<a href="https://moddingwiki.shikadi.net/wiki/OPL_chip">https://moddingwiki.shikadi.net/wiki/OPL_chip</a>
</li>

<li>Does anybody understand how OPL2 percussion mode works?<br />
<a href="https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/">https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/</a>
</li>

<li>Yamaha YMF262 OPL3 music - MoonDriver for OPL3 DEMO [Oscilloscope View]<br />
<a href="https://www.youtube.com/watch?v=a7I-QmrkAak">https://www.youtube.com/watch?v=a7I-QmrkAak</a>
</li>

<li>Yamaha OPL vs OPL2 vs OPL3 comparison<br />
<a href="https://www.youtube.com/watch?v=5knetge5Gs0">https://www.youtube.com/watch?v=5knetge5Gs0</a>
</li>

<li>OPL3 Music Crockett's Theme<br />
<a href="https://www.youtube.com/watch?v=HXS008pkgSQ">https://www.youtube.com/watch?v=HXS008pkgSQ</a>
</li>

<li>Bad Apple (Adlib Tracker - OPL3)<br />
<a href="https://www.youtube.com/watch?v=2lEPH6Y3Luo">https://www.youtube.com/watch?v=2lEPH6Y3Luo</a>
</li>

<li>FM Synthesis Chips, Codecs and DACs<br />
<a href="https://www.dosdays.co.uk/topics/fm_synthesizers.php">https://www.dosdays.co.uk/topics/fm_synthesizers.php</a>
</li>

<li>The Zen Challenge - YMF262 OPL3 Original (For an upcoming game)<br />
<a href="https://www.youtube.com/watch?v=6JlFIFz1CFY">https://www.youtube.com/watch?v=6JlFIFz1CFY</a>
</li>

<li>[adlib tracker II techno music - opl3] orbit around alpha andromedae I<br />
<a href="https://www.youtube.com/watch?v=YqxJCu_WFuA">https://www.youtube.com/watch?v=YqxJCu_WFuA</a>
</li>

<li>[adlib tracker 2 music - opl3 techno] hybridisation process on procyon-ii<br />
<a href="https://www.youtube.com/watch?v=daSV5mN0sJ4">https://www.youtube.com/watch?v=daSV5mN0sJ4</a>
</li>

<li>Hyper Duel - Black Rain (YMF262 OPL3 Cover)<br />
<a href="https://www.youtube.com/watch?v=pu_mzRRq8Ho">https://www.youtube.com/watch?v=pu_mzRRq8Ho</a>
</li>

<li>IBM 5155-5160 Technical Reference<br />
<a href="https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf">https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf</a>
</li>

<li>a ymf262/opl3+pc speaker thing i made<br />
<a href="https://www.youtube.com/watch?v=E-Mx0lEmnZ0">https://www.youtube.com/watch?v=E-Mx0lEmnZ0</a>
</li>

<li>[OPL3] Like a Thunder<br />
<a href="https://www.youtube.com/watch?v=MHf06AGr8SU">https://www.youtube.com/watch?v=MHf06AGr8SU</a>
</li>

<li>(PC SPEAKER) bad apple<br />
<a href="https://www.youtube.com/watch?v=LezmKIIHyUg">https://www.youtube.com/watch?v=LezmKIIHyUg</a>
</li>

<li>Powering devices from PC parallel port<br />
<a href="http://www.epanorama.net/circuits/lptpower.html">http://www.epanorama.net/circuits/lptpower.html</a>
</li>

<li>Magic Mushroom (demo pro PC s DOSem)<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar">http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar</a>
</li>

<li>Píseň Magic Mushroom - originál<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3</a>
</li>

<li>Píseň Magic Mushroom - hráno na PC Speakeru<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3</a>
</li>

<li>Pulse Width Modulation (PWM) Simulation Example<br />
<a href="http://decibel.ni.com/content/docs/DOC-4599">http://decibel.ni.com/content/docs/DOC-4599</a>
</li>

<li>Resistor/Pulse Width Modulation DAC<br />
<a href="http://www.k9spud.com/traxmod/pwmdac.php">http://www.k9spud.com/traxmod/pwmdac.php</a>
</li>

<li>Class D Amplifier<br />
<a href="http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D">http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D</a>
</li>

<li>Covox Speech Thing / Disney Sound Source (1986)<br />
<a href="http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5">http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5</a>
</li>

<li>Covox Digital-Analog Converter (Rusky, obsahuje schémata)<br />
<a href="http://phantom.sannata.ru/konkurs/netskater002.shtml">http://phantom.sannata.ru/konkurs/netskater002.shtml</a>
</li>

<li>PC-GPE on the Web<br />
<a href="http://bespin.org/~qz/pc-gpe/">http://bespin.org/~qz/pc-gpe/</a>
</li>

<li>Keyboard Synthesizer<br />
<a href="http://www.solarnavigator.net/music/instruments/keyboards.htm">http://www.solarnavigator.net/music/instruments/keyboards.htm</a>
</li>

<li>FMS - Fully Modular Synthesizer<br />
<a href="http://fmsynth.sourceforge.net/">http://fmsynth.sourceforge.net/</a>
</li>

<li>Javasynth<br />
<a href="http://javasynth.sourceforge.net/">http://javasynth.sourceforge.net/</a>
</li>

<li>Software Sound Synthesis &amp; Music Composition Packages<br />
<a href="http://www.linux-sound.org/swss.html">http://www.linux-sound.org/swss.html</a>
</li>

<li>Mx44.1 Download Page (software synthesizer for linux)<br />
<a href="http://hem.passagen.se/ja_linux/">http://hem.passagen.se/ja_linux/</a>
</li>

<li>Software synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Software_synthesizer">http://en.wikipedia.org/wiki/Software_synthesizer</a>
</li>

<li>Frequency modulation synthesis<br />
<a href="http://en.wikipedia.org/wiki/Frequency_modulation_synthesis">http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</a>
</li>

<li>Yamaha DX7<br />
<a href="http://en.wikipedia.org/wiki/Yamaha_DX7">http://en.wikipedia.org/wiki/Yamaha_DX7</a>
</li>

<li>Wave of the Future<br />
<a href="http://www.wired.com/wired/archive/2.03/waveguides_pr.html">http://www.wired.com/wired/archive/2.03/waveguides_pr.html</a>
</li>

<li>Analog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Analog_synthesizer">http://en.wikipedia.org/wiki/Analog_synthesizer</a>
</li>

<li>Minimoog<br />
<a href="http://en.wikipedia.org/wiki/Minimoog">http://en.wikipedia.org/wiki/Minimoog</a>
</li>

<li>Moog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Moog_synthesizer">http://en.wikipedia.org/wiki/Moog_synthesizer</a>
</li>

<li>Tutorial for Frequency Modulation Synthesis<br />
<a href="http://www.sfu.ca/~truax/fmtut.html">http://www.sfu.ca/~truax/fmtut.html</a>
</li>

<li>An Introduction To FM<br />
<a href="http://ccrma.stanford.edu/software/snd/snd/fm.html">http://ccrma.stanford.edu/software/snd/snd/fm.html</a>
</li>

<li>John Chowning<br />
<a href="http://en.wikipedia.org/wiki/John_Chowning">http://en.wikipedia.org/wiki/John_Chowning</a>
</li>

<li>I'm Impressed, Adlib Music is AMAZING!<br />
<a href="https://www.youtube.com/watch?v=PJNjQYp1ras">https://www.youtube.com/watch?v=PJNjQYp1ras</a>
</li>

<li>Milinda- Diode Milliampere ( OPL3 )<br />
<a href="https://www.youtube.com/watch?v=oNhazT5HG0E">https://www.youtube.com/watch?v=oNhazT5HG0E</a>
</li>

<li>Dune 2 - Roland MT-32 Soundtrack <br />
<a href="https://www.youtube.com/watch?v=kQADZeB-z8M">https://www.youtube.com/watch?v=kQADZeB-z8M</a>
</li>

<li>Interrupts<br />
<a href="https://wiki.osdev.org/Interrupts#Types_of_Interrupts">https://wiki.osdev.org/Interrupts#Types_of_Interrupts</a>
</li>

<li>Assembly8086SoundBlasterDmaSingleCycleMode<br />
<a href="https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm">https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm</a>
</li>

<li>Interrupts in 8086 microprocessor<br />
<a href="https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/">https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/</a>
</li>

<li>Interrupt Structure of 8086<br />
<a href="https://www.eeeguide.com/interrupt-structure-of-8086/">https://www.eeeguide.com/interrupt-structure-of-8086/</a>
</li>

<li>A20 line<br />
<a href="https://en.wikipedia.org/wiki/A20_line">https://en.wikipedia.org/wiki/A20_line</a>
</li>

<li>Extended memory<br />
<a href="https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)">https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)</a>
</li>

<li>Expanded memory<br />
<a href="https://en.wikipedia.org/wiki/Expanded_memory">https://en.wikipedia.org/wiki/Expanded_memory</a>
</li>

<li>Protected mode<br />
<a href="https://en.wikipedia.org/wiki/Protected_mode">https://en.wikipedia.org/wiki/Protected_mode</a>
</li>

<li>Virtual 8086 mode<br />
<a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">https://en.wikipedia.org/wiki/Virtual_8086_mode</a>
</li>

<li>Unreal mode<br />
<a href="https://en.wikipedia.org/wiki/Unreal_mode">https://en.wikipedia.org/wiki/Unreal_mode</a>
</li>

<li>DOS memory management<br />
<a href="https://en.wikipedia.org/wiki/DOS_memory_management">https://en.wikipedia.org/wiki/DOS_memory_management</a>
</li>

<li>Upper memory area<br />
<a href="https://en.wikipedia.org/wiki/Upper_memory_area">https://en.wikipedia.org/wiki/Upper_memory_area</a>
</li>

<li>Removing the Mystery from SEGMENT : OFFSET Addressing<br />
<a href="https://thestarman.pcministry.com/asm/debug/Segments.html">https://thestarman.pcministry.com/asm/debug/Segments.html</a>
</li>

<li>Segment descriptor<br />
<a href="https://en.wikipedia.org/wiki/Segment_descriptor">https://en.wikipedia.org/wiki/Segment_descriptor</a>
</li>

<li>When using a 32-bit register to address memory in the real mode, contents of the register must never exceed 0000FFFFH. Why?<br />
<a href="https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the">https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the</a>
</li>

<li>A Brief History of Unreal Mode<br />
<a href="https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/">https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/</a>
</li>

<li>Segment Limits<br />
<a href="https://wiki.osdev.org/Segment_Limits">https://wiki.osdev.org/Segment_Limits</a>
</li>

<li>How do 32 bit addresses in real mode work?<br />
<a href="https://forum.osdev.org/viewtopic.php?t=30642">https://forum.osdev.org/viewtopic.php?t=30642</a>
</li>

<li>The LOADALL Instruction by Robert Collins<br />
<a href="https://www.rcollins.org/articles/loadall/tspec_a3_doc.html">https://www.rcollins.org/articles/loadall/tspec_a3_doc.html</a>
</li>

<li>How do you put a 286 in Protected Mode?<br />
<a href="https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode">https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode</a>
</li>

<li>Control register<br />
<a href="https://en.wikipedia.org/wiki/Control_register">https://en.wikipedia.org/wiki/Control_register</a>
</li>

<li>CPU Registers x86<br />
<a href="https://wiki.osdev.org/CPU_Registers_x86">https://wiki.osdev.org/CPU_Registers_x86</a>
</li>

<li>x86 Assembly/Protected Mode<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode">https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode</a>
</li>

<li>MSW: Machine Status Word<br />
<a href="https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html">https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html</a>
</li>

<li>80x87 Floating Point Opcodes<br />
<a href="http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html">http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html</a>
</li>

<li>Page Translation<br />
<a href="https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm">https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm</a>
</li>

<li>80386 Paging and Segmenation<br />
<a href="https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation">https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation</a>
</li>

<li>80386 Memory Management<br />
<a href="https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html">https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html</a>
</li>

<li>DOSEMU<br />
<a href="http://www.dosemu.org/">http://www.dosemu.org/</a>
</li>

<li>Intel 80386, a revolutionary CPU<br />
<a href="https://www.xtof.info/intel80386.html">https://www.xtof.info/intel80386.html</a>
</li>

<li>PAI Unit 3 Paging in 80386 Microporcessor<br />
<a href="https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor">https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor</a>
</li>

<li>64 Terabytes of virtual memory for 32-bit x86 using segmentation: how?<br />
<a href="https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how">https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how</a>
</li>

<li>Pi in the Pentium: reverse-engineering the constants in its floating-point unit<br />
<a href="http://www.righto.com/2025/01/pentium-floating-point-ROM.html">http://www.righto.com/2025/01/pentium-floating-point-ROM.html</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>8087 Numeric Data Processor<br />
<a href="https://www.eeeguide.com/8087-numeric-data-processor/">https://www.eeeguide.com/8087-numeric-data-processor/</a>
</li>

<li>Data Types and Instruction Set of 8087 co-processor<br />
<a href="https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/">https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/</a>
</li>

<li>8087 instruction set and examples<br />
<a href="https://studylib.net/doc/5625221/8087-instruction-set-and-examples">https://studylib.net/doc/5625221/8087-instruction-set-and-examples</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Grafické karty a grafické akcelerátory (14)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/</a>
</li>

<li>Grafické karty a grafické akcelerátory (15)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/</a>
</li>

<li>Grafické karty a grafické akcelerátory (16)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/</a>
</li>

<li>VESA Video Modes<br />
<a href="https://wiki.osdev.org/VESA_Video_Modes">https://wiki.osdev.org/VESA_Video_Modes</a>
</li>

<li>Introduction to VESA programming<br />
<a href="http://www.monstersoft.com/tutorial1/VESA_intro.html">http://www.monstersoft.com/tutorial1/VESA_intro.html</a>
</li>

<li>Guide: VBE 2.0 graphics modes<br />
<a href="https://delorie.com/djgpp/doc/ug/graphics/vbe20.html">https://delorie.com/djgpp/doc/ug/graphics/vbe20.html</a>
</li>

<li>NASM instruction list<br />
<a href="https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html">https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html</a>
</li>

<li>BitBlt function (wingdi.h)<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt">https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt</a>
</li>

<li>SetDIBitsToDevice function (wingdi.h)<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdibitstodevice">https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdibitstodevice</a>
</li>

<li>Why did line printers have 132 columns?<br />
<a href="https://retrocomputing.stackexchange.com/questions/7838/why-did-line-printers-have-132-columns">https://retrocomputing.stackexchange.com/questions/7838/why-did-line-printers-have-132-columns</a>
</li>

<li>Tabulating machine<br />
<a href="https://en.wikipedia.org/wiki/Tabulating_machine">https://en.wikipedia.org/wiki/Tabulating_machine</a>
</li>

<li>Why do printers print 132 columns on 14 7/8″ paper? It’s history<br />
<a href="https://blog.adafruit.com/2019/01/22/why-do-printers-print-132-columns-on-14-7-8-paper-its-history-vintagecomputing-kenshirriff-ibm/">https://blog.adafruit.com/2019/01/22/why-do-printers-print-132-columns-on-14-7-8-paper-its-history-vintagecomputing-kenshirriff-ibm/</a>
</li>

<li>IBM 1403 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_1403">https://en.wikipedia.org/wiki/IBM_1403</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

