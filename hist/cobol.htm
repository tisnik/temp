<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Článek o Turbo Pascalu se zabýval počítačovým středověkem (alespoň ze současného pohledu). Dnes se ovšem budeme zabývat skutečnou prehistorií, protože se seznámíme s programovacím jazykem, který letos slaví neuvěřitelné šedesátiny. Jedná se o opěvovaný i zatracovaný COBOL.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. The future's bright ... the future's Cobol</a></p>
<p><a href="#k02">2. Vznik vyšších programovacích jazyků</a></p>
<p><a href="#k03">3. Skuteční programátoři sice píšou svoje programy přímo ve strojovém kódu, ale kdo to zaplatí?</a></p>
<p><a href="#k04">4. Grace Hopper a její vliv na vývoj vyšších programovacích jazyků</a></p>
<p><a href="#k05">5. Programovací jazyky A-0, A-2 a MATH-MATIC</a></p>
<p><a href="#k06">6. Programovací jazyky B-0 a FLOW-MATIC</a></p>
<p><a href="#k07">7. Od FLOW-MATIC k&nbsp;COBOLu</a></p>
<p><a href="#k08">8. Minulost COBOLu: COBOL-60, COBOL-61, COBOL-64 a COBOL-65</a></p>
<p><a href="#k09">*** 9. COBOL-68, ANS COBOL, COBOL-85 a COBOL 2002</a></p>
<p><a href="#k10">*** 10. COBOL v&nbsp;současnosti</a></p>
<p><a href="#k11">11. COBOL v&nbsp;číslech</a></p>
<p><a href="#k12">*** 12. (Možná) budoucnost COBOLu</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Příloha: problematika výpočtů s&nbsp;numerickými hodnotami s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k19">*** 19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. The future's bright ... the future's Cobol</h2>

<p><i>&bdquo;Real Programmers don't write in COBOL. COBOL was designed to be
read, not run. Unfortunately it is often run anyway.&ldquo;</i></p>

<p><a
href="https://www.root.cz/clanky/tricet-let-od-vydani-revolucniho-turbo-pascalu-5-5/">V&nbsp;nedávno
vydaném článku</a> jsme oslavili jedno poměrně důležité výročí v&nbsp;oblasti
informatiky. Jednalo se o třicet let, které uběhly od vydání Turbo Pascalu
verze 5.5 určené pro osobní počítače PC a operační systém DOS. Z&nbsp;pohledu
dnešních vývojářů, kteří jsou vybaveni rozsáhlými integrovanými vývojovými
prostředími s&nbsp;plnohodnotným GUI a desítkami integrovaných nástrojů (do
nichž se pomalu ale jistě přidávají i technologie umělé inteligence) může Turbo
Pascal s&nbsp;textovým celoobrazovkovým rozhraním a poměrně minimalistickým
designem připadat jako skutečný dávnověk. Ve skutečnosti však i ve světě
informatiky existují a dokonce se stále používají i mnohem starší technologie.
Pravděpodobně nejtypičtějším zástupcem těchto starobylých a možná i
legendárních technologií je programovací jazyk COBOL, který letos oslaví
šedesát let od svého vzniku (to se již skutečně dostáváme do počítačového
dávnověku, konkrétně do období <s>dinosaurů</s> <i>mainframů</i>).</p>

<img src="http://i.iinfo.cz/images/558/ibm3-1.jpg" alt="ibm3_" height="376" width="381" />
<p><i>Obrázek 1: Zrekonstruovaný řídicí panel počítače IBM System/360 Model 30.
Na dlaždici před panelem (zhruba pod čtveřicí bílých tlačítek) je pro porovnání
velikostí umístěný současný mikrořadič PIC.</i></p>

<p>Jazyk <i>COBOL</i> neboli plným jménem <i>COmmon Business Oriented
Language</i> patří do skupiny vyšších programovacích jazyků, což je (ve
stručnosti) označení pro ty programovací jazyky, které se (zejména
z&nbsp;hlediska sémantiky) nachází nad strojovým kódem a assemblerem. Těchto
jazyků dnes existuje takřka nepřeberné množství, ovšem v&nbsp;době, kdy vznikal
COBOL (konec padesátých let minulého století, což je období prvních generací
<i>mainframů</i>), bylo těchto jazyků jen několik desítek a navíc se
v&nbsp;naprosté většině případů jednalo o jazyky specializované: jazyk FORTRAN
sloužil (a ostatně dodnes slouží) především pro numerické výpočty, COBOL pro
implementaci &bdquo;business&ldquo; aplikací, LISP pro symbolické výpočty a
zpracování složitějších datových struktur (původně i pro první pokusy
s&nbsp;umělou inteligencí) atd. Pravděpodobně prvním vážnějším pokusem o
univerzální programovací jazyk je ALGOL.</p>

<a href="http://i.iinfo.cz/images/558/ibm3-3.jpg"><img src="http://i.iinfo.cz/images/558/ibm3-3-prev.jpg" alt="ibm3_" height="238" width="370" /></a>
<p><i>Obrázek 2: Moduly počítačů řady IBM System/360. Zpočátku měl každý modul
podobu větší či menší skříně, později docházelo ke slučování některých funkcí
do menšího počtu modulů i k&nbsp;celkovému zmenšování jak obsazeného prostoru,
tak i spotřeby elektrické energie (to znamenalo i menší nároky na chlazení
&ndash; klimatizaci).</i></p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti se nepoužívaly pouze
specializované vyšší programovací jazyky, ale dokonce i celé tehdejší počítače
(mainframy) měly svůj hardware specializovaný pro určitý účel. Typicky se
rozlišovaly mainframy pro práci s&nbsp;celočíselnými daty, mainframy pro
numerické výpočty, dále počítače pro zpracování textů atd. Idea
&bdquo;univerzálního počítače&ldquo; byla při použití technologií dostupných
v&nbsp;padesátých letech minulého století jen těžko realizovatelná, a to
především z&nbsp;finančních důvodů (ostatně doba, kdy se i pro běžná PC
matematický koprocesor pořizoval jen když byl skutečně zapotřebí, není až tak
vzdálená).</div></p>

<a href="http://i.iinfo.cz/images/558/ibm3-4.jpg"><img src="http://i.iinfo.cz/images/558/ibm3-4-prev.jpg" alt="ibm3_" height="270" width="364" /></a>
<p><i>Obrázek 3: Ovládací panel počítače IBM System/360 Model 91 po levé straně
a terminál připojený pomocí modemu na straně pravé.</i></p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této kapitole jsou sice uvedeny
snímky mainframu IBM System/360, ovšem tyto počítače vznikly až později,
konkrétně v&nbsp;roce 1964, kdy již byl COBOL rozšířeným a ustáleným
programovacím jazykem.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vznik vyšších programovacích jazyků</h2>

<p><i>&bdquo;A computer without COBOL and FORTRAN is like a piece of chocolate
cake without ketchup or mustard.&ldquo;</i></p>

<p><a href="#k01">V&nbsp;úvodní kapitole</a> jsme si řekli, že jazyk COBOL
patří do skupiny vyšších programovacích jazyků. Ovšem původně se pro vývoj
aplikací pro mainframy vyšší programovací jazyky nepoužívaly, už jen
z&nbsp;toho prostého důvodu, že ani neexistovaly :-).</p>

<a href="http://i.iinfo.cz/images/503/ibm2-6.jpg"><img src="http://i.iinfo.cz/images/503/ibm2-6-prev.jpg" alt="ibm2" height="270" width="206" /></a>
<p><i>Obrázek 4: Úvodní stránka manuálu k&nbsp;assembleru počítačů
System/360.</i></p>

<p>Vývoj programů pro tyto počítače byl poměrně složitý a především zdlouhavý a
drahý, protože celý algoritmus se nejprve popsal vývojovým diagramem (kresleným
samozřejmě ručně na papíry) a po ručním přezkoumání, zda algoritmus skutečně
bude pracovat v&nbsp;pořádku, se provedl jeho přepis přímo do strojového kódu
&ndash; <i>assembler</i>, neboli automatický programový prostředek pro
transformaci zdrojového kódu využívajícího symbolické adresy a symbolické názvy
instrukcí do strojového kódu, nebyl k&nbsp;dispozici. Přepis do strojového kódu
se prováděl na papírové formuláře, které byly následně buď vyděrovány na děrné
štítky (přístup preferovaný z&nbsp;historických důvodů především firmou
<i>IBM</i>) nebo přepsány na magnetické pásky (přístup firmy <i>Remington
Rand</i>). Až poté operátoři program i s&nbsp;daty připravili jako dávkovou
úlohu, která musela počkat na své zpracování do doby, kdy byl k&nbsp;dispozici
potřebný výpočetní čas, což však také mohlo trvat i několik týdnů.</p>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-11.jpg" width="350" height="440" alt=" " />
<p><i>Obrázek 5: Hledání chyby v&nbsp;blocích počítače UNIVAC II bylo zajisté
dobrodružnou záležitostí.</i></p>

<p>V&nbsp;případě, že z&nbsp;nějakého důvodu došlo při návrhu programu nebo při
jeho přepisu k&nbsp;chybě, muselo se celé kolečko opakovat. Navíc se
v&nbsp;celém procesu od vytvoření programu až po jeho úspěšný běh vyskytovalo
velké množství lidí (analytici, programátoři, operátoři, technici, lidé
starající se o výměnu a archivaci magnetických pásek atd.), kteří mohli kvůli
nějakému opomenutí do procesu tvorby a spuštění programu vnést nějakou chybu,
která se projevila až následně při kontrole dat, nebo v&nbsp;horším případě až
při stížnostech zákazníků. Mimochodem: zajímavé bylo, že mnohdy byli operátoři
a technici většinou přímo zaměstnanci firmy dodávající mainframy a nikoli
zaměstnanci společnosti, která programy/aplikace používala. To se týkalo
například společnosti <i>Remington Rand</i>, která tyto pracovníky svým
zákazníkům pronajímala i s&nbsp;vlastním počítačem (<i>outsourcing</i> tedy
není ve světě IT vůbec nic nového, spíše naopak). I kvůli vysokému počtu
pracovníků byla každá chyba, která se v&nbsp;programu nebo v&nbsp;průběhu
zpracování objevila, velmi drahá.</p>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-12.jpg" width="400" height="441" alt=" " />
<p><i>Obrázek 6: Základní pomůcky programátorů počítače UNIVAC I a II před
vznikem vyšších programovacích jazyků &ndash; šablona pro tvorbu vývojových
diagramů a tabulka kódů znaků (třetí důležitou pomůckou byl kelímek
z&nbsp;automatu na kávu).</i></p>

<p>Pro ilustraci nároků na lidské zdroje je v&nbsp;následující tabulce vypsán
počet pracovníků doporučovaných pro obsluhu jednoho počítače <i>UNIVAC II</i>
v&nbsp;jednosměnném, dvousměnném a třísměnném provozu. Jedná se o doporučení
vydané samotnou firmou <i>Remington Rand</i>. Nejde přitom o zbytečnou
přezaměstnanost, protože počítač bylo žádoucí mít vzhledem k&nbsp;jeho vysoké
ceně (více než 1&nbsp;500&nbsp;000 dolarů, popř.&nbsp;měsíční pronájem za cca
30&nbsp;000 dolarů) neustále stoprocentně vytížený. Na tomto místě je možná
vhodné si připomenout, že <i>UNIVAC II</i> dokázal za jednu sekundu vykonat
pouze cca 3000 základních aritmetických operací nebo manipulací se symboly
(znaky), takže i rychlost zpracovávání dat byla z&nbsp;dnešního pohledu velmi
nízká (i ovladač klávesnice má o několik řádů vyšší výpočetní výkon):</p>

<table>
<tr><th>Profese</th><th>Jednosměnný provoz</th><th>Dvousměnný provoz</th><th>Třísměnný provoz</th></tr>
<tr><td>Supervisors  </td><td> 5</td><td></td><td></td></tr>
<tr><td>Analysts     </td><td> 8</td><td></td><td></td></tr>
<tr><td>Programmers  </td><td>20</td><td></td><td></td></tr>
<tr><td>Clerks       </td><td> 5</td><td></td><td></td></tr>
<tr><td>Librarians   </td><td> 1</td><td></td><td></td></tr>
<tr><td>Operators    </td><td> 2</td><td>4</td><td>6</td></tr>
<tr><td>Engineers    </td><td> 4</td><td>6</td><td>9</td></tr>
<tr><td>In-Out Oper  </td><td> 2</td><td>4</td><td>6</td></tr>
<tr><td>Tape Handlers</td><td> 1</td><td>2</td><td>3</td></tr>
</table>

<a href="http://i.iinfo.cz/images/503/ibm2-7.png"><img src="http://i.iinfo.cz/images/503/ibm2-7-prev.png" alt="ibm2" height="270" width="335" /></a>
<p><i>Obrázek 7: Architektura počítačů System/360.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Skuteční programátoři sice píšou svoje programy přímo ve strojovém kódu, ale kdo to zaplatí?</h2>

<p><i>&bdquo;Much of my work has come from being lazy. I didn't like writing
programs, and so, when I was working on the IBM 701, writing programs for
computing missile trajectories, I started work on a programming system to make
it easier to write programs.&ldquo;<br />
John W. Backus, tvůrce FORTRANu</i></p>

<p>A právě z&nbsp;toho důvodu, že vývoj programů výše uvedeným způsobem je až
přehnaně drahý, začaly vznikat aplikace, které nebyly určeny přímo pro koncové
uživatele (například banky, statistické úřady, americký IRS atd.), ale
&bdquo;pouze&ldquo; pro programátory. Svým způsobem se vlastně jedná o
přelomovou myšlenku: počítač má být pomocníkem mj.&nbsp;i pro vývoj programů
pro něj samý.</p>

<a href="http://i.iinfo.cz/images/38/ibm-5-3.jpg"><img src="http://i.iinfo.cz/images/38/ibm-5-3-prev.jpg" alt="ibm-5" height="270" width="211" /></a>
<p><i>Obrázek 8: Manuál k&nbsp;první verzi FORTRANu určeného pro mainframy IBM
704.</i></p>

<p>Postupně tak vznikly první primitivní assemblery, které byly postupně
vylepšovány o další funkce. Výsledkem byly takzvané makroassemblery (assembler
doplněný o systém maker) a později vznikly i <i>autokódy</i> (například
<i>AMRU</i> atd.). Autokód je nízkoúrovňový programovací jazyk ležící přibližně
v&nbsp;polovině cesty mezi assemblerem (jazykem symbolických instrukcí) a
vyššími programovacími jazyky (FORTRAN, ALGOL). V&nbsp;autokódu se mohou
používat jak přímo instrukce procesoru, tak i zapisovat jednoduché výrazy,
konstruovat podmíněné bloky kódu a tvořit základní programové smyčky (ovšem
deklarace vlastních datových typů, použití polí apod.&nbsp;většinou není
podporována). Programové konstrukce zapsané v&nbsp;autokódu se poměrně
přímočarým způsobem převádí do assembleru, který je potom přeložen přímo do
strojového kódu daného procesoru. Od autokódů již vede relativně přímá cesta
k&nbsp;plnohodnotným vyšším programovacím jazykům.</p>

<img src="http://i.iinfo.cz/images/38/ibm-5-5.png" alt="ibm-5" height="193" width="336" />
<p><i>Obrázek 9: Ukázka programu napsaného ve FORTRANu II, ve kterém můžeme
mj.&nbsp;vidět i použití aritmetického IF.</i></p>

<p><div class="rs-tip-major">Poznámka: samozřejmě nelze říci, že se assemblery
přestaly po vzniku vyšších programovacích jazyků používat. Používají se stále,
ovšem nika, kde má jejich praktické využití smysl, je dnes již relativně malá.
Dnes se typicky setkáme s&nbsp;nějakou formou makroassembleru a zajímavé je, že
autokódy se již prakticky nepoužívají, i když existují projekty, které se je
snaží znovuobjevit (HLL atd.). Je to i logické, protože ve chvíli, kdy by se
mohl použít autokód (výrazy, jednoduché podmínky a smyčky atd.) je již mnohdy
praktičtější přejít na programovací jazyk C, který se tak s&nbsp;trochou
nadsázky stal &bdquo;univerzálním assemblerem&ldquo;.</div></p>

<a href="http://i.iinfo.cz/images/38/ibm-5-4.jpg"><img src="http://i.iinfo.cz/images/38/ibm-5-4-prev.jpg" alt="ibm-5" height="270" width="191" /></a>
<p><i>Obrázek 10: Spolu s&nbsp;rozšiřováním Fortranu z&nbsp;mainframů firmy IBM
na další architektury se zvyšovala potřeba standardizace tohoto jazyka.
Postupně vzniklo několik norem, například ANSI norma FORTRAN 66, FORTRAN 77, či
ANSI/ISO standard Fortran 90 (názvy standardů jsou uvedeny správně &ndash;
jméno jazyka se skutečně postupem času změnilo z &bdquo;FORTRAN&ldquo; na
&bdquo;Fortran&ldquo;).</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Grace Hopper a její vliv na vývoj vyšších programovacích jazyků</h2>

<p><i>&bdquo;Very few [people involved in data processing] were symbol
oriented; very few of them were mathematically trained.&ldquo;<br />
Grace Hopper vysvětluje, proč je vhodné programovat počítače UNIVAC ve vyšším
programovacím jazyku.</i></p>

<p><div class="rs-tip-major">Poznámka k&nbsp;přechylování: čtenáři, kteří
dávají přednost přechylování cizích příjmení, nechť si v&nbsp;dalším textu
doplní chybějící -ová</div></p>

<p>Jedním z&nbsp;klíčových zaměstnanců firmy <i>Remington Rand</i> (což byla
jedna ze sedmi firem vyrábějících mainframy) byla od roku 1949 i slavná
<i>Grace Hopper</i> (). Tato programátorka dříve pracovala s&nbsp;reléovými
elektronickými počítači, například na počítači <i>Mark II</i>.  Právě při
hledání chyby v&nbsp;jednom programu, který byl provozován na tomto stroji
(programy byly &bdquo;zadrátovány&ldquo;, nikoli uloženy v&nbsp;paměti),
objevila Grace, že v&nbsp;kontaktu jednoho relé je chycená můra &ndash;
&bdquo;bug&ldquo;, kvůli níž kontakt korektně nespínal. Od té doby se
v&nbsp;jejím týmu všechny chyby v&nbsp;programu označovaly slovem
&bdquo;bug&ldquo; a Grace později začala používat nové slovo
&bdquo;debug&ldquo; pro proces odstraňování těchto chyb, což později vedlo ke
vzniku <i>debuggerů</i>, tedy utilit určených právě pro detekci a opravu
chyb.</p>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-14.png" width="450" height="550" alt=" " />
<p><i>Obrázek 11: Program napsaný ve strojovém kódu počítačů UNIVAC I a UNIVAC
II.</i></p>

<p>Ovšem vraťme se do doby, kdy <i>Grace Hopper</i> pracovala u firmy
<i>Remington Rand (Sperry Rand)</i>. V&nbsp;této době se jí totiž podařilo
vytvořit první skutečný překladač na světě nazvaný jednoduše
<strong>A-0</strong>, který dokázal transformovat symbolicky zapsané
matematické výrazy do strojového kódu počítačů <i>UNIVAC</i>.</p>

<a href="http://i.iinfo.cz/images/492/comp-hist-44-15.png"><img src="http://i.iinfo.cz/images/492/comp-hist-44-15-prev.png" width="370" height="225" alt=" " /></a>
<p><i>Obrázek 12: Velmi malá část vývojového diagramu složitějšího programu pro
počítače UNIVAC I a UNIVAC II. Povšimněte si především příkazů pro ovládání
páskových jednotek a taktéž zápisu absolutních adres 000-999 u některých stavů
diagramu.</i></p>

<p>Po první verzi překladače <strong>A-0</strong> vznikly i jeho vylepšené
verze, především překladač nazvaný <strong>A-2</strong>, který byl poměrně
intenzivně na <i>UNIVACu</i> používán. <i>Grace Hopper</i> vydala v&nbsp;roce
1952 článek o tomto překladači, což zajímavě koresponduje s&nbsp;rokem 1954,
kdy byl vytvořen a představen první překladač <i>Fortranu</i> (tento jazyk se
ovšem, na rozdíl od <strong>A-0</strong> a <strong>A-2</strong>, používá po
mnoha úpravách a vylepšeních <a
href="https://www.informationweek.com/software/enterprise-applications/fortran-7-reasons-why-its-not-dead/d/d-id/1321174">dodnes</a>).
Grace Hopper pokračovala v&nbsp;návrzích dalších programovacích jazyků,
především jazyka <strong>B-0</strong> a taktéž jeho pokračovatele
<i>FLOW-MATIC</i> a v&nbsp;neposlední řadě i <i>COBOLu</i>. Posléze se Grace
vrátila k&nbsp;práci pro námořnictvo USA, kde po mnoha letech služby získala
(jako první žena) hodnost kontradmirála v&nbsp;záloze.</p>

*** image ***
<p><i>Obrázek 13: Grace Hopper před ovládacím panelem UNIVACu.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Programovací jazyky A-0, A-2 a MATH-MATIC</h2>

<p>Programovací jazyk <strong>A-0</strong>, neboli <i>Arithmetic Language
version 0</i>, byl vytvořen v&nbsp;letech 1951 až 1952 pro počítač <i>UNIVAC
I</i> a později byl upraven pro použití na počítači <i>UNIVAC II</i>
(z&nbsp;tohoto důvodu je článek doplněn fotkami Univaců). Jednalo se o poměrně
přímočarý překladač (bez kontroly chyb a navíc bez pokusu o zotavení
z&nbsp;chyb), který transformoval aritmetické a relativně primitivní řídicí
příkazy do strojového kódu. Z&nbsp;tohoto překladače vycházela i jeho vylepšená
a výše zmíněná verze <strong>A-2</strong>, jejíž upravená varianta byla
nabízena pod názvem <i>MATH-MATIC</i>. V&nbsp;programech napsaných
v&nbsp;<i>MATH-MATICu</i> byly všechny programové řádky očíslovány, podobně
jako tomu bylo o mnoho let později v&nbsp;<i>BASICu</i>. Jak je pro
programovací jazyky, jejichž autorem je <i>Grace Hopper</i>, typické, používají
se namísto různých symbolů převážně klíčová slova a sekvence slov
s&nbsp;přesným významem (<strong>JUMP TO SENTENCE</strong> atd.). Jednotlivé
příkazy jsou ukončeny tečkou, podobně jako věty v&nbsp;běžném textu.</p>

<a href="http://i.iinfo.cz/images/492/comp-hist-44-16.jpg"><img src="http://i.iinfo.cz/images/492/comp-hist-44-16-prev.jpg" width="226" height="270" alt=" " /></a>
<p><i>Obrázek 14: Titulní stránka manuálu k&nbsp;programovacímu jazyku FLOW-MATIC.</i></p>

<p>Následuje ukázka čtyř vzájemně nesouvisejících programových řádků napsaných
v&nbsp;<i>MATH-MATICu</i> &ndash; jedná se postupně o příkaz pro načtení hodnot
tří proměnných, podmíněný příkaz, volání podprogramu umístěného na řádcích 4 až
8 (s&nbsp;implicitním návratem) a počítanou programovou smyčku
s&nbsp;počitadlem <strong>J</strong>, které se zvyšuje od jedničky do dvaceti
s&nbsp;krokem 1:</p>

<pre>
(1) READ A B C .
(20) IF X &gt; Y JUMP TO SENTENCE 8 .
(12) EXECUTE SENTENCE 4 THRU 8 .
(6) VARY J 1 (1) 20 SENTENCE 11 THRU 15 .
</pre>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-17.png" width="450" height="288" alt=" " />
<p><i>Obrázek 15: Zdrojový kód napsaný v&nbsp;programovacím jazyku
FLOW-MATIC.</i></p>

<p>Druhý demonstrační příklad je již plnohodnotným programem, který dokáže
vypočítat průměr a odchylku z&nbsp;deseti hodnot uložených v&nbsp;poli. Na
tomto příkladu je možná patrné, že již před více než šedesáti lety bylo možné
programovat na vcelku vysoké úrovni (a výsledný program je dokonce čitelnější,
než by tomu bylo v&nbsp;případě některých &bdquo;moderních&ldquo;
programovacích jazyků):</p>

<pre>
(1) READ-ITEM X(10) IF SENTINEL JUMP TO SENTENCE 11 .
(2) SUM = 0 .
(3) SUMSQUARES = 0 .
(4) VARY I 1 (1) 10 SENTENCE 5 THRU 6 .
(5) SUM = SUM + X(I)
(6) SUMSQUARES = SUMSQUARES + X(I)^2 .
(7) MEAN = SUM / 10 .
(8) VARIANCE = SUMSQUARES / 10 - MEAN ^ 2 .
(9) WRITE AND EDIT FOR UNIPRINTER MEAN VARIANCE .
(10) JUMP TO SENTENCE 1 .
(11) STOP .
</pre>

<p><div class="rs-tip-major">Poznámka: opět si povšimněte, že se programy,
resp.&nbsp;přesněji řečeno jednotlivé programové řádky s&nbsp;příkazy a
deklaracemi, podobají zápisu anglických vět, dokonce se i příkazy ukončují
tečkami. Podobný přístup je vidět i u COBOLu.</div></p>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-18.jpg" width="349" height="435" alt=" " />
<p><i>Obrázek 16: Grace Hopper s&nbsp;referenční příručkou jazyka COBOL stojící
u páskových jednotek UNISERVO.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Programovací jazyky B-0 a FLOW-MATIC</h2>

<p><i>&bdquo;Real Programmers don't write in PL/I. PL/I is for programmers who
can't decide whether to write in COBOL or FORTRAN.&ldquo;</i></p>

<p>Druhým programovacím jazykem, který <i>Grace Hopper</i> i přes určitý odpor
svých spolupracovníků (kteří předložený návrh považovali za příliš radikální)
vytvořila pro počítače <i>UNIVAC</i>, byl jazyk nazvaný <strong>B-0</strong>
neboli <i>Business Language version 0</i>. Tento programovací jazyk je však
známější pod svým komerčním názvem <i>FLOW-MATIC</i>. Jednalo o jazyk určený
převážně pro zpracování dat, provádění bankovních operací, fakturace či výpočty
mezd, což je velký rozdíl oproti výše popsaným jazykům <strong>A-0</strong> a
<i>MATH-MATIC</i>, které byly orientovány zejména na provádění numerických
výpočtů. <i>FLOW-MATIC</i> je s&nbsp;velkou pravděpodobností prvním
programovacím jazykem, v&nbsp;němž se používala anglická slova mající význam
klíčových slov i operátorů; navíc se jednotlivé příkazy (programové řádky)
velmi podobaly jednoduchým anglickým větám, a to i v&nbsp;případě zápisu
složitějších podmínek (jazyk původně rozeznával dvacet klíčových slov).
V&nbsp;tomto programovacím jazyku se vyskytovaly i příkazy, kterými se daly
přímo ovládat jednotlivé páskové jednotky, kterých mohlo být v&nbsp;případě
počítače <i>UNIVAC II</i> připojeno až 16. Existovala taktéž podpora pro tvorbu
tiskových sestav.</p>

<a href="http://i.iinfo.cz/images/118/ibm6-1.jpg"><img src="http://i.iinfo.cz/images/118/ibm6-1-prev.jpg" alt="ibm6" height="270" width="228" /></a>
<p><i>Obrázek 17: První zveřejněná publikace o programovacím jazyku
COBOL.</i></p>

<p>Následuje ukázka programu napsaného v&nbsp;programovacím jazyce
<i>FLOW-MATIC</i>. Povšimněte si především poměrně složité podmínky na řádku
číslo jedna a porovnání výsledku výpočtu s&nbsp;nulou se specifikovaným počtem
míst na řádku 14 (ZZZZ znamená porovnání na 4 místa/cifry, ZZZZZ na pět míst
atd., podobný koncept opět objevíme i v&nbsp;COBOLu):</p>

<pre>
 0) INPUT  INVENTORY FILE=A
           PRICE FILE=B,
    OUTPUT PRICED-INV FILE=C
           UNPRICED-INV FILE=D,
    HSP D.
 1) COMPARE PRODUCT-NO(A) WITH PRODUCT-NO(B)
    IF GREATER GO TO OPERATION 10;
    IF EQUAL GO TO OPERATION 5;
    OTHERWISE GO TO OPERATION 2.
 2) TRANSFER A TO D.
 3) WRITE ITEM D.
 4) JUMP TO OPERATION 8.
&nbsp;
 5) TRANSFER A TO C.
 6) MOVE UNIT-PRICE(B) TO UNIT-PRICE(C).
 7) WRITE ITEM C.
 8) READ ITEM A; IF END OF DATA GO TO OPERATION 14.
 9) JUMP TO OPERATION 1.
&nbsp;
10) READ ITEM B; IF END OF DATA GO TO OPERATION 12.
11) JUMP TO OPERATION 1.
&nbsp;
12) SET OPERATION 9 TO GO TO OPERATION 2.
13) JUMP TO OPERATION 2.
&nbsp;
14) TEST PRODUCT-NO(B) AGAINST ZZZZZZZZZZZZ;
    IF EQUAL GO TO OPERATION 16;
    OTHERWISE GO TO OPERATION 15.
15) REWIND B.
16) CLOSE-OUT FILES C, D.
17) STOP. (END)
</pre>

<a href="http://i.iinfo.cz/images/118/ibm6-5.png"><img src="http://i.iinfo.cz/images/118/ibm6-5-prev.png" alt="ibm6" height="265" width="370" /></a>
<p><i>Obrázek 18: Programátorský textový editor určený pro zápis COBOLovských
programů, na kterém je mj.&nbsp;patrné i rozdělení řádků na jednotlivé části
(číslo sekvence, sedmý sloupec, sekce A, sekce B) i omezení délky jednotlivých
textových řádků na 72 znaků na řádek.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Od FLOW-MATIC k&nbsp;COBOLu</h2>

<p><i>As taboo as COBOL might be in the ping pong rooms of modern
startup-driven culture today, its influence and irreplaceability will result in
a spotlight on the dinosaur language again.</i></p>

<p><i>Grace Hopper</i> se později podílela i na vzniku standardu jazyka
<i>COBOL</i>, kterému je dnešní článek věnován. Tento programovací jazyk
v&nbsp;mnoha ohledech vychází právě z&nbsp;jazyka <i>FLOW-MATIC</i>. O tom, že
oba zmíněné programovací jazyky mají hodně společného, se mohou čtenáři
přesvědčit sami porovnáním předchozího kódu s&nbsp;<i>COBOLovským</i>
programem, v&nbsp;němž taktéž můžeme narazit na anglické věty ukončené tečkou,
formátováním údajů na zadaný počet desetinných míst atd.:</p>

<pre>
       $ SET SOURCEFORMAT"FREE"
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  Multiplier.
       AUTHOR.  Michael Coughlan.
      * Example program using ACCEPT, DISPLAY and MULTIPLY to 
      * get two single digit numbers from the user and multiply them
      * together
&nbsp;
       DATA DIVISION.
&nbsp;
       WORKING-STORAGE SECTION.
       01  Num1                                PIC 9  VALUE ZEROS.
       01  Num2                                PIC 9  VALUE ZEROS.
       01  Result                              PIC 99 VALUE ZEROS.
&nbsp;
       PROCEDURE DIVISION.
       DISPLAY "Enter first number  (1 digit) : " WITH NO ADVANCING.
       ACCEPT Num1.
       DISPLAY "Enter second number (1 digit) : " WITH NO ADVANCING.
       ACCEPT Num2.
       MULTIPLY Num1 BY Num2 GIVING Result.
       DISPLAY "Result is = ", Result.
       STOP RUN.
</pre>

<a href="http://i.iinfo.cz/images/118/ibm6-6.png"><img src="http://i.iinfo.cz/images/118/ibm6-6-prev.png" alt="ibm6" height="249" width="370" /></a>
<p><i>Obrázek 19: Program typu &bdquo;Hello World!&ldquo; zapsaný
v&nbsp;COBOLu. Tento screenshot ukazuje obrazovku terminálu připojeného
k&nbsp;mainframu firmy IBM. Ostatně je zajímavé sledovat programátory
s&nbsp;mnohdy obrovskými monitory, jak píšou či upravují programy
v&nbsp;maličkém terminálku uprostřed pracovní plochy.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Minulost COBOLu: COBOL-60, COBOL-61, COBOL-64 a COBOL-65</h2>

<p>Skutečná historie programovacího jazyka <i>COBOL</i>
(<strong>CO</strong>mmon <strong>B</strong>usiness <strong>O</strong>riented
<strong>L</strong>anguage) se začala psát již na konci padesátých let minulého
století, jedná se tedy (vedle <i>Fortranu</i> a <i>LISPu</i>) o jeden
z&nbsp;nejstarších dodnes používaných programovacích jazyků (<i>Algog</i>
z&nbsp;této slevné skupiny pravděpodobně již odpadl). V&nbsp;roce 1959 (tedy
právě před šedesáti lety) se na konferenci pořádané v&nbsp;USA sešli zástupci
firem a některých vládních i nevládních organizací, aby se dohodli na vytvoření
standardu vysokoúrovňového programovacího jazyka vhodného pro zpracování
strukturovaných dat i pro řízení různých procesů ve firmách.</p>

<p>V&nbsp;průběhu této konference byly vytvořeny separátní komise vedené
výkonným výborem nazvaným <i>CODASYL (Conference on Data Systems
Languages)</i>. Výsledkem práce těchto komisí byla mj.&nbsp;i publikace
s&nbsp;předlouhým titulem <i>Initial Specification for a Common Business
Oriented Language (COBOL) for Programming Electronic Digital Computer</i>,
která byla vydána v&nbsp;roce 1960. Tato publikace se později stala mezi
odbornou veřejností známá pod zkráceným názvem <i>COBOL-60</i>, protože na
jejím základě vznikly i první implementace jazyka <i>COBOL</i>.</p>

<p>Na strukturu <i>COBOLu</i> popsaného v&nbsp;<i>COBOL-60</i> měly velký vliv
již tehdy existující systémy, v&nbsp;první řadě zejména <a href="#k06">výše
zmíněný jazyk</a> <i>FLOW-MATIC</i> firmy Sperry-Rand, <i>Commercial
Translator</i> firmy IBM a <i>AIMACO (Air Material Command)</i>. Způsob vzniku
tohoto programovacího jazyka, především to, že byl vytvořený relativně početnou
komisí na základě poměrně vágního zadání, nikoli menším týmem řešícím určitý
konkrétní problém (viz například historie vzniku céčka, Pythonu, jazyku Lua či
Go), se projevil i na jeho těžkopádné syntaxi a poměrně rigidní struktuře,
která navíc v&nbsp;prvních verzích odrážela způsob zápisu programů na děrné
štítky (viz další kapitoly s&nbsp;podrobnějším popisem některých konceptů).
Práce komisí zabývajících se návrhem jazyka <i>COBOL</i> pokračovala i
v&nbsp;následujících letech. Na základě připomínek uživatelů vznikla první
modifikace jazyka popsaná ve zprávě označované jako <i>COBOL-61</i> a doplňkem
nazvaným <i>Extended COBOL-61</i>. Následoval <i>COBOL-64</i>, <i>COBOL-65</i>,
a ANSI standardy v&nbsp;roce 1968, 1974 a 1985 (ty si přiblížíme
v&nbsp;navazující kapitole).</p>

<img src="http://i.iinfo.cz/images/118/ibm6-2.jpg" alt="ibm6" height="169" width="129" />
<p><i>Obrázek 20: Jedna z&nbsp;novějších publikací o programovacím jazyku
COBOL.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. COBOL-68, ANS COBOL, COBOL-85 a COBOL 2002</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. COBOL v&nbsp;současnosti</h2>

<p>Reálný příběh jednoho COBOLovského programátora: <i>“IT worker who’s on
oxygen. He’s 70 years old, he knows the keys to the kingdom, he knows where
everything is, it’s all sitting in his head. They send out a police car to pick
him up every morning and bring him into work in a vault-like room.”</i></p>

<p>Důležité je si uvědomit, že COBOL není rozšířen kvůli tomu, že by se jednalo o populární technologii (spíš je tomu přesně naopak). Je to důsledek šedesátileté historie tohoto jazyka a taktéž díky tomu, že že aplikace psané v&nbsp;<i>COBOLu</i> tvoří tzv.&nbsp;vertikální trh (malé množství instalací, velká cena ze jednu licenci a z&nbsp;toho vyplývající dlouhá doba provozu &ndash; někdy i více než 30 let), na rozdíl od běžných desktopových aplikací a systémů operujících na trhu horizontálním (cena za vývoj je zaplacena velkým množstvím relativně laciných licencí, takže nákupní cena za novou verzi aplikace, popř.&nbsp;cena za její instalaci a správu v&nbsp;případě free software, je pro mnohé uživatele velmi nízká, což vede k&nbsp;rychlejším upgradům). Extrémním příkladem jsou mobilní aplikace s&nbsp;životností mnohdy jen několik měsíců (čemuž musí odpovídat cena za toto &bdquo;spotřební zboží&ldquo;).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. COBOL v&nbsp;číslech</h2>

<p><i>&bdquo;I’m pretty much of the opinion that what we need to do is
understand the business rules and the business process that’s embedded in these
legacy systems and just rewrite.&ldquo;</i></p>

<p>Možná nebude na škodu si uvést několik zajímavých čísel, které se týkají jak
samotného programovacího jazyka COBOL, tak i jeho použití
v&nbsp;současnosti:</p>

<ul>

<li>V&nbsp;IRS (&bdquo;finančák&ldquo;, jedna z&nbsp;nejdůležitějších
institucí) se používají aplikace psané v&nbsp;COBOLu, celkově se jedná o
padesát milionů řádků.</li>

<li>V&nbsp;USA je každý den odbaveno na 60 milionů pacientů s&nbsp;využitím
programů napsaných právě v&nbsp;COBOLu.</li>

<li>V&nbsp;USA je COBOL použit ve 43% bankovních systémů. </li>

<li>Celých 80% bankovních transakcí prochází programy psanými
v&nbsp;COBOLu.</li>

<li>Dokonce 95% transakcí přes bankomaty (ATM) je řízeno COBOLem (pochopitelně
samotný operační systém ATM v&nbsp;COBOLu není, ovšem samotná transakce již
COBOLovskou aplikací řízena je).</li>

<li>Uvádí se, že v&nbsp;současnosti dosahuje počet vývojářů pracujících
s&nbsp;COBOLem hodnoty dva miliony (což je dost neuvěřitelné číslo, osobně si
myslím, že hodně nadsazené).</li>

<li>Celkově se každý den používají programy v&nbsp;COBOLu, jejichž celkový
rozsah dosahuje 220 miliard (!) programových řádků.</li>

<li>Existuje několik statistik o průměrném věku vývojářů používajících primárně
COBOL. Jeden zdroj tvrdí 57 let (což zhruba odpovídá stáří samotného jazyka a
jednalo by se tedy přibližně o druhou generaci programátorů), druhý zdroj
udává, že nejvíce COBOListů je ve věkové skupině 45-50 let.</li>

<li>GitHub při hledání repositářů s&nbsp;COBOLem hlásí: &bdquo;No public GitHub
repository available&ldquo;, což je pro tento programovací jazyk a jeho
ekosystém asi nejtypičtější vlastnost.</li>

</ul>

<p><div class="rs-tip-major">Poznámka: na tomto místě je vhodné poznamenat, že
v&nbsp;tuzemsku byla situace v&nbsp;mnoha směrech odlišná o USA, takže zde
COBOL neměl zdaleka tak široké zázemí.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. (Možná) budoucnost COBOLu</h2>

<p><i>&bdquo;In 1997 they estimated that there were about 300 billion lines of
computer code in use in the world. Of that they estimated that about 80% (240
billion lines) were in COBOL and 20% (60 billion lines) were written in all the
other computer languages combined.&ldquo;</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Základní vlastnosti programovacího jazyka COBOL</h2>

<p>Jedním z&nbsp;cílů návrhu nového programovacího jazyka výše zmíněnou komisí <i>CODASYL</i> bylo to, aby programy v&nbsp;něm napsané byly čitelné i pro uživatele&ndash;neprogramátory (například pro manažery). Z&nbsp;tohoto důvodu se způsob zápisu programů v&nbsp;<i>COBOLu</i> podobá běžnému anglickému textu strukturovanému do kapitol, odstavců, vět, frází a slov. Mnohé znaky se speciálním významem, které známe z&nbsp;jiných programovacích jazyků, byly v&nbsp;<i>COBOLu</i> nahrazeny klíčovými slovy, což se do jisté míry týká i aritmetických, logických a relačních výrazů. Důraz na možnost zpracování strukturovaných dat se projevil i v&nbsp;možnosti snadného zápisu jejich struktury (ve speciálním oddílu &ndash; viz další text) i možnosti poměrně jednoduché manipulace jak s&nbsp;celými záznamy (ZAMĚSTNANEC, ADRESA), tak i s&nbsp;jejich položkami (JMÉNO_ZAMĚSTNANCE, PSČ), včetně jejich načítání či zápisu na paměťová média, řazení záznamů apod. (zde se <i>COBOL</i> do jisté míry přibližuje pozdějším jazykům čtvrté generace <i>SEQUEL</i> a na něj navazujícímu <i>SQL</i>).</p>

<a href="http://i.iinfo.cz/images/118/ibm6-3.png"><img src="http://i.iinfo.cz/images/118/ibm6-3-prev.png" alt="ibm6" height="270" width="170" /></a>
<p><i>Obrázek xxx: S&nbsp;rozvojem relačních databází vybavených jazykem SQL se
v&nbsp;COBOLu začala objevovat podpora i pro tento typ databází.</i></p>

<a href="http://i.iinfo.cz/images/118/ibm6-4.jpg"><img src="http://i.iinfo.cz/images/118/ibm6-4-prev.jpg" alt="ibm6" height="270" width="221" /></a>
<p><i>Obrázek xx: Zatímco mnoho jiných programovacích jazyků se lze skutečně naučit za 21 dní (1 pracovní měsíc), u COBOLu to prakticky není možné, což je mj.&nbsp;dáno i poměrně komplikovanou sémantikou, množstvím různých kombinací klíčových slov (více než 300) a v&nbsp;neposlední řadě také tím, že je COBOL dosti odlišný od dnešních mainstreamových jazyků odvozených především od Algolu.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Pevná struktura programů zapisovaných v&nbsp;COBOLu</h2>

<p>Programy zapisované v&nbsp;programovacím jazyce <i>COBOL</i> se vyznačují strukturou připomínající text rozsáhlé knihy. Některé úrovně této struktury jsou povinné, u jiných je naopak jejich přítomnost v&nbsp;programu volitelná. Celý zdrojový text programu je rozdělen na několik pojmenovaných oddílů (<i>divisions</i>). Oddíly se dělí na kapitoly (sekce), kapitoly na odstavce, odstavce na věty (ukončené tečkou, jako v&nbsp;běžné anglické gramatice), věty na příkazy a fráze, příkazy na výrazy, výrazy na slova a slova jsou již (jako u jiných jazyků) složena z&nbsp;jednotlivých znaků. Pro kódování znaků může být použito jak kódování <i>EBCDIC</i>, tak i <i>ASCII</i>, protože jazyk <i>COBOL</i> využívá jen základní alfanumerické znaky a dalších 15 znaků společných pro obě kódování.</p>

<p><div class="rs-tip-major">Poznámka: může to být překvapivé, ale EBCDIC není mrtvým kódováním; stále se s&nbsp;ním můžeme ve světě IT setkat.</div></p>

<p>V&nbsp;&bdquo;klasickém&ldquo; <i>COBOLu</i> navíc existovala i přesná pravidla určující význam jednotlivých sloupců &ndash; prvních šest znaků na každém řádku mohlo obsahovat číslo sekvence (obdoba čísla řádku v&nbsp;<i>BASICu</i> či návěstí ve <i>FORTRANu</i>). Maximálně šestimístné číslo sekvence se většinou rozdělovalo na dvě části &ndash; první tři cifry udávaly číslo tiskové strany, druhé tři cifry řádek v&nbsp;rámci jedné tiskové strany. Tento způsob umožňoval rychlé vyhledání potřebné části kódu ve vytištěných výpisech programů. V&nbsp;sedmém sloupci se buď nacházela mezera (běžný programový řádek), znak pro pokračování (rozdělení dlouhého programového řádku) nebo hvězdička (&bdquo;*&ldquo;) v&nbsp;případě, že se na řádku nacházel komentář. Další sloupce (rozdělené navíc do sekcí A a B), tj.&nbsp;osmý až sedmdesátý druhý, sloužily pro zápis programového kódu. Programové řádky delší než 72 znaků bylo nutné rozdělit na více textových řádků pomocí znaku pro pokračování &ndash; toto omezení v&nbsp;<i>COBOLu</i> existovalo z&nbsp;důvodu jednoznačné interpretace vytištěných programů i programů uložených na děrným štítcích.</p>

<a href="http://i.iinfo.cz/images/118/ibm6-5.png"><img src="http://i.iinfo.cz/images/118/ibm6-5-prev.png" alt="ibm6" height="265" width="370" /></a>
<p><i>Obrázek xx: Editor pro zápis COBOLovských programů, na kterém je mj.&nbsp;patrné i rozdělení řádků na jednotlivé části (číslo sekvence, sedmý sloupec, sekce A, sekce B) i omezení délky jednotlivých textových řádků na 72 znaků na řádek.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Rozdělení COBOLovského programu na oddíly</h2>

<p><i>COBOL &ndash; Completely Obsolete Business Oriented Language.<br />
COBOL &ndash; Can't Obsolesce Because Of Legacy.<br />
Ruby on Rails? Don't forget COBOL ON COGS.<br />
Rumour has it that the object oriented specification for COBOL was code named
ADD 1 TO COBOL GIVING COBOL.</i></p>

<p>V&nbsp;předchozí kapitole jsme si řekli, že na nejvyšší úrovni je každá
aplikace naprogramovaná v&nbsp;<i>COBOLu</i> rozdělena na čtyři oddíly, jejichž
jednoznačná identifikace (jedná se o klíčová slova) a význam je uveden
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Název oddílu</th><th>Význam</th></tr>
<tr><td>IDENTIFICATION DIVISION</td><td>identifikace programu, jeho programátora, poznámek, informace o zabezpečení atd.</td></tr>
<tr><td>ENVIRONMENT DIVISION   </td><td>popis vybavení počítače především jeho datových médií, mapování dat do souborů atd.</td></tr>
<tr><td>DATA DIVISION          </td><td>oddíl dat (popis struktury, vlastní informace)</td></tr>
<tr><td>PROCEDURE DIVISION     </td><td>oddíl procedur, právě zde je popsána programová logika</td></tr>
</table>

<p>První dva oddíly, tj.&nbsp;<i>IDENTIFICATION DIVISION</i> a <i>ENVIRONMENT
DIVISION</i> jsou z&nbsp;hlediska studie struktury programovacího jazyka
relativně nezajímavé &ndash; jedná se v&nbsp;principu o metadata, která program
(aplikaci) přesněji popisují. Důležité však je, že prakticky všechny systémově
závislé vlastnosti aplikace, především způsob uložení dat v&nbsp;souborech (či
dříve na děrných štítcích a páskách), je &bdquo;izolován&ldquo; v&nbsp;oddílu
<i>ENVIRONMENT DIVISION</i>, takže přenos aplikace na zcela odlišnou platformu
spočívá v&nbsp;modifikaci údajů zapsaných v&nbsp;tomto oddílu &ndash; zbývající
(většinou mnohem rozsáhlejší) část aplikace by &ndash; alespoň teoreticky
&ndash; měla zůstat zachována beze změny. V&nbsp;následujících dvou kapitolách
se budeme zabývat spíše informacemi zapisovanými do oddílů <i>DATA DIVISION</i>
a <i>PROCEDURE DIVISION</i>, neboť jejich obsah nám bude mnohem lépe ilustrovat
významné vlastnosti programovacího jazyka <i>COBOL</i>.</p>

<a href="http://i.iinfo.cz/images/118/ibm6-6.png"><img src="http://i.iinfo.cz/images/118/ibm6-6-prev.png" alt="ibm6" height="249" width="370" /></a>
<p><i>Obrázek 6: Program typu &bdquo;Hello World!&ldquo; zapsaný v&nbsp;COBOLu.
Tento screenshot ukazuje obrazovku terminálu připojeného
k&nbsp;mainframu.</i></p>

<p>Příklad jednoduchého programu typu &bdquo;Hello world!&ldquo; zapsaného
v&nbsp;<i>COBOLu</i>. V&nbsp;tomto programu jsou použity pouze dva oddíly
<i>IDENTIFICATION DIVISION</i> a <i>PROCEDURE DIVISION</i>:</p>

<pre>
        IDENTIFICATION DIVISION.
        PROGRAM-ID. SmallestProgram.
        PROCEDURE DIVISION.
        DisplayGreeting.
           DISPLAY "Hello world".
           RUN.
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Oddíl <i>DATA DIVISION</i></h2>

<p><i>Je Java novým COBOLem? <a
href="http://stuffthathappens.com/blog/wp-content/uploads/2008/01/java-is-the-new-cobol.png">Autor
tohoto obrázku</a> si myslí, že zná odpověď :-)</i></p>

<p>V&nbsp;oddílu nazvaném <i>DATA DIVISION</i> se mohou nacházet tři typy údajů
&ndash; charakteristiky (struktury a metody uložení) souborů, struktury záznamů
(records) a konstanty (záznamem v&nbsp;tomto textu rozumíme datovou strukturu
obsahující libovolný počet dalších položek, včetně dalších záznamů;
v&nbsp;dnešních informačních systémech by záznam byl uložen například
v&nbsp;tabulkách relační databáze). Tyto typy údajů, jenž jsou z&nbsp;hlediska
gramatiky jazyka představovány sekcemi (<i>sections</i>), jsou od sebe odděleny
klíčovými slovy <i>FILE SECTION</i>, <i>WORKING-STORAGE SECTION</i> a
<i>CONSTANT SECTION</i>, které jsou sice nepovinné, ale pokud jsou
v&nbsp;programu použity, musí být uvedeny v&nbsp;pořadí naznačeném pod tímto
odstavcem:</p>

<pre>
        DATA DIVISION.
        FILE SECTION.
           ... popisy struktur a způsobu uložení souborů
        WORKING-STORAGE SECTION.
           ... popis záznamů uložených v operační paměti
        CONSTANT SECTION.
           ... konstanty
</pre>

<p>V&nbsp;části <i>FILE SECTION</i> s&nbsp;charakteristikami souborů lze pro
každý pojmenovaný soubor specifikovat jeho vnitřní strukturu, způsob uložení
souboru na paměťovém médiu i to, jakým způsobem se data do souboru fyzicky
ukládají. Oproti dnešním programovacím jazykům se tedy jedná o značně odlišný
přístup, který má své výhody (popis souboru se nachází na jednom místě, což
zjednodušuje modifikace programů; navíc je struktura souboru popsána
deklarativně a existuje přímé mapování mezi souborem a datovými záznamy), ale
samozřejmě i některé nevýhody (určité struktury souborů nelze
v&nbsp;<i>COBOLu</i> tímto způsobem uspokojivě popsat). U každého souboru lze
zadat způsob jeho uložení (fráze <i>RECORDING MODE</i>) na paměťovém médiu,
přibližný počet záznamů uložených v&nbsp;souboru (fráze <i>FILE CONTAINS x
RECORDS</i>), počet záznamů uložených v&nbsp;jednom bloku (fráze <i>BLOCK
CONTAINS x TO y RECORDS</i> &ndash; sdružení více záznamů do jednoho bloku může
vést k&nbsp;optimalizaci přístupu na paměťové médium), délku jednotlivých
záznamů (fráze <i>RECORD CONTAINS x CHARACTERS</i>) i samotnou strukturu
záznamů, přesněji řečeno jméno datové struktury (fráze <i>DATA RECORD IS
xxx</i> popř.&nbsp;<i>DATA RECORDS ARE yyy</i>). Specifikace každého souboru
začíná klíčovým slovem <i>FD</i> (file description) za nímž následují
jednotlivé fráze oddělené středníkem. Celý blok specifikace je ukončen
tečkou:</p>

<pre>
        FD SEZNAM-ZAMESTNANCU;
           RECORDING MODE IS BINARY LOW DENSITY;
           FILE CONTAINS ABOUT 100 RECORDS;
           BLOCK CONTAINS 2 TO 3 RECORDS;
           RECORD CONTAINS 75 CHARACTERS;
           LABEL RECORD IS STANDARD;
           DATA RECORD IS ZAMESTNANEC.
</pre>

<p>Struktura <i>ZAMESTNANEC</i>, která je do souboru <i>SEZNAM-ZAMESTNANCU</i>
uložena cca stokrát (viz výše uvedený příklad), je v&nbsp;<i>COBOLu</i> popsána
následovně:</p>

<pre>
        01 ZAMESTNANEC.
           02 OSOBNI-UDAJE.
              03 JMENO; SIZE IS 12 CHARACTERS.
              03 PRIJMENI; SIZE IS 20 CHARACTERS.
           02 ADRESA.
              03 OBEC; SIZE IS 20 CHARACTERS.
              03 ADRESA; SIZE IS 20 CHARACTERS.
              03 CISLO_DOMU; SIZE IS 3 DIGITS.
              03 PSC; SIZE IS 5 DIGITS.
</pre>

<p>Jak je z&nbsp;výše uvedeného příkladu patrné, obsahuje záznam
<i>ZAMESTNANEC</i> dvě podstruktury, které obsahují textové řetězce různé délky
či numerické hodnoty se zadaným počtem číslic. Formát záznamu je určen
dvoucifernou číslicí na začátku každé věty, nikoli odsazením (to je zde uvedeno
pouze pro větší přehlednost). Konstanty se v&nbsp;<i>COBOLu</i> zapisují jako
struktury se speciálním číslem 77, například:</p>

<pre>
        CONSTANT SECTION.
           77 PI; PICTURE 9V9999; VALUE 31415.
</pre>

<p>Povšimněte si použití fráze <i>PICTURE</i>, pomocí níž se určuje, jakým
způsobem se bude textový řetězec či číslice ukládat do paměti. Jedná se vlastně
o obdobu céčkových formátovacích řetězců &ndash; zápis 9V9999 znamená, že číslo
(viz fráze <i>VALUE</i>) bude obsahovat maximálně pět cifer, přičemž za první
cifru je vložena desetinná tečka. Pokud by se tímto způsobem specifikoval formát
delších čísel či řetězců, lze v&nbsp;závorce nastavit i počet opakování znaku
či číslice, například 9V9(4).</p>

<a href="http://i.iinfo.cz/images/118/ibm6-7.png"><img src="http://i.iinfo.cz/images/118/ibm6-7-prev.png" alt="ibm6" height="270" width="359" /></a>
<p><i>Obrázek 7: Pro COBOL existuje podpora například i ve známém vývojovém
prostředí Eclipse.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Oddíl <i>PROCEDURE DIVISION</i></h2>

<p><i>&bdquo;The use of COBOL cripples the mind; its teaching should,
therefore, be regarded as a criminal offence.&ldquo;<br />
E. W, Dijkstra</i></p>




<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: problematika výpočtů s&nbsp;numerickými hodnotami s&nbsp;plovoucí řádovou čárkou</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Ankrum,T. Scott<br />
COBOL &ndash; A Best Practice (Sept, 2001)<br />
COBOLReport.com
</li>

<li>Arranga,Edmund C.<br />
The Viagrazation of COBOL<br />
COBOLwebler.com
</li>

<li>Arranga, Edmund C. &amp; Price, Wilson<br />
Fresh from Y2K, What's next for COBOL? (March/April 2000)<br />
IEEE Software
</li>

<li>Arranga et al<br />
In COBOL's Defense : Roundtable Discussion (March/April 2000)<br />
IEEE Software
</li>

<li>Badower, Justin<br />
COBOL: Foundation of the future<br />
COBOLwebler.com
</li>

<li>Brown, Gary DeWard<br />
COBOL: The failure that wasn't<br />
COBOLReport.com
</li>

<li>Burger,Thomas Wolfgang<br />
COBOL in an open source future (May 2000)<br />
IBM developerWorks : Linux : Linux articles
</li>

<li>Carr, Donald and Kizior, Ronald J.<br />
The Case for Continued COBOL Education (March/April 2000)<br />
IEEE Software
</li>

<li>Feiman, J.<br />
The Gartner Programming Language Survey (October 2001)<br />
Gartner Advisory
</li>

<li>Glass, Robert L.<br />
Cobol &ndash; A Contradiction and an Enigma<br />
COMMUNICATIONS OF THE ACM September 1997/Vol. 40, No. 9
</li>

<li>Jones, Capers<br />
The global economic impact of the year 2000 software problem<br />
(Jan, 1997) 
</li>

<li>Kappelman, Leon A.<br />
Some Strategic Y2K Blessings (March/April 2000)<br />
IEEE Software
</li>

<li>Kizior, Dr. Ronald J. and Carr, Donald and Halpern, Dr. Paul<br />
What Professionals think of the Future of COBOL? 

<li>Murach, Mike<br />
Is COBOL Dying ... or Thriving? (February 2001)<br />
The Cobol Newswire 
</li>

<li>Pagnan, Martin<br />
Can A Java Programmer Be Transitioned To Cobol? (Feb, 2002)<br />
COBOLReport.com
</li>

<li>Reimann, Artur<br />
COBOL, Language of Choice &ndash; Then and Now (January, 2001)<br />
COBOLReport.com
</li>

<li>Sayles, Jonathan<br />
COBOL and the Enterprise Business Application Programming Legacy<br />
MicroFocus Ltd.
</li>

<li>Silverberg, Fred<br />
COBOL and the Business Programming Paradigm<br />
(1996)
</li>

<li>Sneed, Harry M.<br />
The Evolution of COBOL<br />
COBOLReport.com
</li>

<li>Wilkinson,Stephanie<br />
From the Dustbin, Cobol Rises (May, 2001)<br />
eWeek
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>COBOL blues<br />
<a href="http://fingfx.thomsonreuters.com/gfx/rngs/USA-BANKS-COBOL/010040KH18J/index.html">http://fingfx.thomsonreuters.com/gfx/rngs/USA-BANKS-COBOL/010040KH18J/index.html</a>
</li>

<li>COBOL Is Everywhere. Who Will Maintain It?<br />
<a href="https://thenewstack.io/cobol-everywhere-will-maintain/">https://thenewstack.io/cobol-everywhere-will-maintain/</a>
</li>

<li>The Inevitable Return of COBOL<br />
<a href="https://blog.hackerrank.com/the-inevitable-return-of-cobol/">https://blog.hackerrank.com/the-inevitable-return-of-cobol/</a>
</li>

<li>It’s COBOL all the way down<br />
<a href="https://increment.com/programming-languages/cobol-all-the-way-down/">https://increment.com/programming-languages/cobol-all-the-way-down/</a>
</li>

<li>Muller's Recurrence<br />
<a href="https://scipython.com/blog/mullers-recurrence/">https://scipython.com/blog/mullers-recurrence/</a>
</li>

<li>Muller's Recurrence - roundoff gone wrong<br />
<a href="https://latkin.org/blog/2014/11/22/mullers-recurrence-roundoff-gone-wrong/">https://latkin.org/blog/2014/11/22/mullers-recurrence-roundoff-gone-wrong/</a>
</li>

<li>Lisp, Floating Points and Muller's Recurrence<br />
<a href="https://breeko.github.io/post/2018-07-30_lisp-floating-points-and-muller-s-recurrence/">https://breeko.github.io/post/2018-07-30_lisp-floating-points-and-muller-s-recurrence/</a>
</li>

<li>Exactly what is COBOL and why is COBOL still a widely used language in IT?<br />
<a href="https://freedomafterthesharks.com/2016/06/27/exactly-what-is-cobol-and-why-is-cobol-still-a-widely-used-language-in-it/">https://freedomafterthesharks.com/2016/06/27/exactly-what-is-cobol-and-why-is-cobol-still-a-widely-used-language-in-it/</a>
</li>

<li>COBOL: 10 Reasons the Old Language Is Still Kicking<br />
<a href="https://www.eweek.com/development/cobol-10-reasons-the-old-language-is-still-kicking">https://www.eweek.com/development/cobol-10-reasons-the-old-language-is-still-kicking</a>
</li>

<li>Why COBOL Will Never Die<br />
<a href="https://www.techwell.com/2012/10/why-cobol-will-never-die">https://www.techwell.com/2012/10/why-cobol-will-never-die</a>
</li>

<li>The Inevitable Return of COBOL<br />
<a href="https://blog.hackerrank.com/the-inevitable-return-of-cobol/">https://blog.hackerrank.com/the-inevitable-return-of-cobol/</a>
</li>

<li>Ancient programming language COBOL can make you bank, literally<br />
<a href="https://thenextweb.com/finance/2017/04/10/ancient-programming-language-cobol-can-make-you-bank-literally/">https://thenextweb.com/finance/2017/04/10/ancient-programming-language-cobol-can-make-you-bank-literally/</a>
</li>

<li>COBOL vs Python<br />
<a href="https://stackshare.io/stackups/cobol-vs-python">https://stackshare.io/stackups/cobol-vs-python</a>
</li>

<li>Mainframes 360<br />
<a href="http://www.mainframes360.com/2009/04/cobol-tutorials.html">http://www.mainframes360.com/2009/04/cobol-tutorials.html</a>
</li>

<li>Rosetta Code &ndash; Category:COBOL<br />
<a href="http://rosettacode.org/wiki/Category:COBOL">http://rosettacode.org/wiki/Category:COBOL</a>
</li>

<li>COmmon Business Oriented Language<br />
<a href="http://foldoc.org/COBOL">http://foldoc.org/COBOL</a>
</li>

<li>COBOL Compilers<br />
<a href="http://www-01.ibm.com/software/awdtools/cobol/">http://www-01.ibm.com/software/awdtools/cobol/</a>
</li>

<li>Cobol: Not Dead Yet<br />
<a href="http://www.computerworld.com/s/article/266156/Cobol_Not_Dead_Yet?intsrc=kc_rfavs">http://www.computerworld.com/s/article/266156/Cobol_Not_Dead_Yet?intsrc=kc_rfavs</a>
</li>

<li>The future's bright ... the future's Cobol<br />
<a href="http://features.techworld.com/applications/3056/the-futures-bright--the-futures-cobol/">http://features.techworld.com/applications/3056/the-futures-bright--the-futures-cobol/</a>
</li>

<li>COBOL Example Programs<br />
<a href="http://www.csis.ul.ie/COBOL/examples/default.htm">http://www.csis.ul.ie/COBOL/examples/default.htm</a>
</li>

<li>Introduction to COBOL<br />
<a href="http://www.csis.ul.ie/COBOL/Course/COBOLIntro.htm">http://www.csis.ul.ie/COBOL/Course/COBOLIntro.htm</a>
</li>

<li>COBOL programming &ndash; tutorials, lectures, exercises, examples<br />
<a href="http://www.csis.ul.ie/COBOL/">http://www.csis.ul.ie/COBOL/</a>
</li>

<li>Wikipedia: COBOL<br />
<a href="http://en.wikipedia.org/wiki/COBOL">http://en.wikipedia.org/wiki/COBOL</a>
</li>

<li>Humor on Computers, Systems and Programming<br />
<a href="http://www-crypto.htw-saarland.de/weber/misc/programming.html">http://www-crypto.htw-saarland.de/weber/misc/programming.html</a>
</li>

<li>OpenCOBOL<br />
<a href="http://en.wikipedia.org/wiki/OpenCOBOL">http://en.wikipedia.org/wiki/OpenCOBOL</a>
</li>

<li>OpenCOBOL.org<br />
<a href="http://opencobol.org/">http://opencobol.org/</a>
</li>

<li>OpenCOBOL FAQ<br />
<a href="http://opencobol.add1tocobol.com/">http://opencobol.add1tocobol.com/</a>
</li>

<li>TinyCOBOL<br />
<a href="http://tiny-cobol.sourceforge.net/">http://tiny-cobol.sourceforge.net/</a>
</li>

<li>TinyCOBOL FAQ<br />
<a href="http://tiny-cobol.sourceforge.net/docs/faq/">http://tiny-cobol.sourceforge.net/docs/faq/</a>
</li>

<li>JTC1/SC22/WG4 &ndash; COBOL<br />
<a href="http://ra.dkuug.dk/jtc1/sc22/wg4/">http://ra.dkuug.dk/jtc1/sc22/wg4/</a>
</li>

<li>COBOL on COGS<br />
<a href="http://www.coboloncogs.org/INDEX.HTM">http://www.coboloncogs.org/INDEX.HTM</a>
</li>

<li>Cobol Coders: Going, Going, Gone?<br />
<a href="http://www.computerworld.com/s/article/266228/Cobol_Coders_Going_Going_Gone_">http://www.computerworld.com/s/article/266228/Cobol_Coders_Going_Going_Gone_</a>
</li>

<li>UNIVAC II - Universal Automatic Computer Model II<br />
<a href="http://ed-thelen.org/comp-hist/BRL61-u4.html">http://ed-thelen.org/comp-hist/BRL61-u4.html</a>
</li>

<li>UNIVAC I Computer System<br />
<a href="http://univac1.0catch.com/">http://univac1.0catch.com/</a>
</li>

<li>UNIVAC I Computer System<br />
<a href="http://univac1.0catch.com/yellowpage.htm">http://univac1.0catch.com/yellowpage.htm</a>
</li>

<li>UNIVAC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Univac">http://en.wikipedia.org/wiki/Univac</a>
</li>

<li>UNIVAC I (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/UNIVAC_I">http://en.wikipedia.org/wiki/UNIVAC_I</a>
</li>

<li>UNIVAC II (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/UNIVAC_II">http://en.wikipedia.org/wiki/UNIVAC_II</a>
</li>

<li>UNIVAC III (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/UNIVAC_III">http://en.wikipedia.org/wiki/UNIVAC_III</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

