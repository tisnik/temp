<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Článek o Turbo Pascalu se zabýval počítačovým středověkem (alespoň ze současného pohledu). Dnes se ovšem budeme zabývat skutečnou prehistorií, protože se seznámíme s programovacím jazykem, který letos slaví neuvěřitelné šedesátiny. Jedná se o opěvovaný i zatracovaný COBOL.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. The future's bright ... the future's Cobol</a></p>
<p><a href="#k02">*** 2. Vznik vyšších programovacích jazyků</a></p>
<p><a href="#k03">*** 3. Skuteční programátoři sice píšou svoje programy přímo ve strojovém kódu, ale kdo to zaplatí?</a></p>
<p><a href="#k04">*** 4. Grace Hopper a její vliv na vývoj vyšších programovacích jazyků</a></p>
<p><a href="#k05">*** 5. Programovací jazyky A-0, A-2 a MATH-MATIC</a></p>
<p><a href="#k06">*** 6. Programovací jazyky B-0 a FLOW-MATIC</a></p>
<p><a href="#k07">*** 7. Vznik prvního standardu COBOLu</a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Literatura</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. The future's bright ... the future's Cobol</h2>

<p><a href="">V&nbsp;nedávno vydaném článku</a> jsme oslavili jedno poměrně důležité výročí v&nbsp;oblasti informatiky. Jednalo se o třicet let, které uběhly od vydání Turbo Pascalu verze 5.5 určené pro osobní počítače PC a operační systém DOS. Z&nbsp;pohledu dnešních vývojářů, kteří jsou vybaveni rozsáhlými integrovanými vývojovými prostředími s&nbsp;plnohodnotným GUI a desítkami integrovaných nástrojů (do nichž se pomalu ale jistě přidávají i technologie umělé inteligence) může Turbo Pascal s&nbsp;textovým celoobrazovkovým rozhraním a poměrně minimalistickým designem připadat jako skutečný dávnověk. Ve skutečnosti však i ve světě informatiky existují a stále se používají i mnohem starší technologie. Pravděpodobně nejtypičtějším zástupcem těchto starobylých a možná i legendárních technologií je programovací jazyk COBOL, který letos oslaví šedesát let od svého vzniku (to se již skutečně dostáváme do počítačového dávnověku, konkrétně do období <s>dinosaurů</s> <i>mainframů</i>).</p>

*** image ***
<p><i>Obrázek 1: .</i></p>

<p>COBOL neboli plným jménem <i>COmmon Business Oriented Language</i> patří do skupiny vyšších programovacích jazyků, což je (ve stručnosti) označení pro ty programovací jazyky, které se (zejména z&nbsp;hlediska sémantiky) nachází na strojovým kódem a assemblerem. Těchto jazyků dnes existuje takřka nepřeberné množství, ovšem v&nbsp;době, kdy vznikal COBOL (konec padesátých let minulého století, což je období prvních generací <i>mainframů</i>), bylo těchto jazyků jen několik desítek a navíc se v&nbsp;naprosté většině případů jednalo o jazyky specializované: FORTRAN sloužil (a dodnes slouží) především pro numerické výpočty, COBOL pro implementaci &bdquo;business&ldquo; aplikací, LISP pro symbolické výpočty a zpracování složitějších datových struktur atd. Pravděpodobně prvním vážnějším pokusem o univerzální jazyk je ALGOL.</p>

*** image ***
<p><i>Obrázek 2: .</i></p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti se nepoužívaly pouze specializované vyšší programovací jazyky, ale dokonce i celé tehdejší počítače (mainframy) měly svůj hardware specializovaný pro určitý účel. Typicky se rozlišovaly mainframy pro práci s&nbsp;celočíselnými daty, mainframy pro numerické výpočty, dále počítače pro zpracování textů atd. Idea &bdquo;univerzálního počítače&ldquo; byla při použití technologií dostupných v&nbsp;padesátých letech minulého století jen těžko realizovatelná, a to především z&nbsp;finančních důvodů (ostatně doba, kdy se i pro běžné PC matematický koprocesor pořizoval jen když byl skutečně zapotřebí, není až tak vzdálená).</div></p>

*** image ***
<p><i>Obrázek 3: .</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vznik vyšších programovacích jazyků</h2>

<p><a href="#k01">V&nbsp;úvodní kapitole</a> jsme si řekli, že COBOL patří do skupiny vyšších programovacích jazyků. Ovšem původně se pro vývoj aplikací pro mainframy vyšší programovací jazyky nepoužívaly, už jen z&nbsp;toho prostého důvodu, že ani neexistovaly :-).</p>

*** image ***
<p><i>Obrázek 4: .</i></p>

<p>Vývoj programů pro tyto počítače byl poměrně složitý a především zdlouhavý a drahý, protože celý algoritmus se nejprve popsal vývojovým diagramem (kresleným samozřejmě ručně na papíry) a po ručním přezkoumání, zda algoritmus skutečně bude pracovat v&nbsp;pořádku, se provedl jeho přepis přímo do strojového kódu &ndash; <i>assembler</i>, neboli automatický programový prostředek pro transformaci zdrojového kódu využívajícího symbolické adresy a symbolické názvy instrukcí do strojového kódu, nebyl k&nbsp;dispozici. Přepis do strojového kódu se prováděl na papírové formuláře, které byly následně buď vyděrovány na děrné štítky (přístup preferovaný z&nbsp;historických důvodů především firmou <i>IBM</i>) nebo přepsány na magnetické pásky (přístup firmy <i>Remington Rand</i>). Až poté operátoři program i s&nbsp;daty připravili jako dávkovou úlohu, která musela počkat na své zpracování do doby, kdy byl k&nbsp;dispozici potřebný výpočetní čas, což však také mohlo trvat i několik týdnů.</p>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-11.jpg" width="350" height="440" alt=" " />
<p><i>Obrázek 5: Hledání chyby v&nbsp;blocích počítače UNIVAC II bylo zajisté
dobrodružnou záležitostí.</i></p>

<p>V&nbsp;případě, že z&nbsp;nějakého důvodu došlo při návrhu programu nebo při jeho přepisu k&nbsp;chybě, muselo se celé kolečko opakovat. Navíc se v&nbsp;celém procesu od vytvoření programu až po jeho úspěšný běh vyskytovalo velké množství lidí (analytici, programátoři, operátoři, technici, lidé starající se o výměnu a archivaci magnetických pásek atd.), kteří mohli kvůli nějakému opomenutí do procesu tvorby a spuštění programu vnést nějakou chybu, která se projevila až následně při kontrole dat, nebo v&nbsp;horším případě až při stížnostech zákazníků. Mimochodem: zajímavé bylo, že mnohdy byli operátoři a technici většinou přímo zaměstnanci firmy dodávající mainframy. To se týkalo například společnosti <i>Remington Rand</i>, která tyto pracovníky svým zákazníkům pronajímala i s&nbsp;vlastním počítačem (<i>outsourcing</i> tedy není ve světě IT vůbec nic nového, spíše naopak). I kvůli vysokému počtu pracovníků byla každá chyba, která se v&nbsp;programu nebo v&nbsp;průběhu zpracování objevila, velmi drahá.</p>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-12.jpg" width="400" height="441" alt=" " />
<p><i>Obrázek 6: Základní pomůcky programátorů počítače UNIVAC I a II před vznikem vyšších programovacích jazyků &ndash; šablona pro tvorbu vývojových diagramů a tabulka kódů znaků.</i></p>

<p>Pro ilustraci nároků na lidské zdroje je v&nbsp;následující tabulce vypsán počet pracovníků doporučovaných pro obsluhu jednoho počítače <i>UNIVAC II</i> v&nbsp;jednosměnném, dvousměnném a třísměnném provozu. Jedná se o doporučení vydané samotnou firmou <i>Remington Rand</i>. Nejde přitom o zbytečnou přezaměstnanost, protože počítač bylo žádoucí mít vzhledem k&nbsp;jeho vysoké ceně (více než 1&nbsp;500&nbsp;000 dolarů, popř.&nbsp;měsíční pronájem za cca 30&nbsp;000 dolarů) neustále vytížený. Na tomto místě je možná vhodné si připomenout, že <i>UNIVAC II</i> dokázal za jednu sekundu vykonat pouze cca 3000 základních aritmetických operací nebo manipulací se symboly (znaky), takže i rychlost zpracovávání dat byla z&nbsp;dnešního pohledu velmi nízká (i ovladač klávesnice má o několik řádů vyšší výpočetní výkon):</p>

<table>
<tr><th>Profese</th><th>Jednosměnný provoz</th><th>Dvousměnný provoz</th><th>Třísměnný provoz</th></tr>
<tr><td>Supervisors  </td><td> 5</td><td></td><td></td></tr>
<tr><td>Analysts     </td><td> 8</td><td></td><td></td></tr>
<tr><td>Programmers  </td><td>20</td><td></td><td></td></tr>
<tr><td>Clerks       </td><td> 5</td><td></td><td></td></tr>
<tr><td>Librarians   </td><td> 1</td><td></td><td></td></tr>
<tr><td>Operators    </td><td> 2</td><td>4</td><td>6</td></tr>
<tr><td>Engineers    </td><td> 4</td><td>6</td><td>9</td></tr>
<tr><td>In-Out Oper  </td><td> 2</td><td>4</td><td>6</td></tr>
<tr><td>Tape Handlers</td><td> 1</td><td>2</td><td>3</td></tr>
</table>

*** image ***
<p><i>Obrázek 7:</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Skuteční programátoři sice píšou svoje programy přímo ve strojovém kódu, ale kdo to zaplatí?</h2>

<p>A právě z&nbsp;toho důvodu, že vývoj programů výše uvedeným způsobem je až přehnaně drahý, začaly vznikat aplikace, které nebyly určeny přímo pro koncové uživatele (například banky, statistické úřady atd.), ale &bdquo;pouze&ldquo; pro programátory. Svým způsobem se jedná o přelomovou myšlenku: počítač má být pomocníkem mj.&nbsp;i pro vývoj programů pro něj samý.</p>

<p>Postupně tak vznikly první primitivní assemblery, které byly postupně vylepšovány o další funkce. Výsledkem byly takzvané makroassemblery (assembler doplněný o systém maker) a později vznikly i <i>autokódy</i> (například <i>AMRU</i> atd.). Autokód je nízkoúrovňový programovací jazyk ležící přibližně v&nbsp;polovině cesty mezi assemblerem (jazykem symbolických instrukcí) a vyššími programovacími jazyky (FORTRAN, ALGOL). V&nbsp;autokódu se mohou používat jak přímo instrukce procesoru, tak i zapisovat jednoduché výrazy, konstruovat podmíněné bloky kódu a tvořit základní programové smyčky (ovšem deklarace vlastních datových typů, použití polí apod.&nbsp;většinou není podporována). Programové konstrukce zapsané v&nbsp;autokódu se poměrně přímočarým způsobem převádí do assembleru, který je potom přeložen přímo do strojového kódu daného procesoru. Od autokódů již vede relativně přímá cesta k&nbsp;plnohodnotným vyšším programovacím jazykům.</p>

<img src="http://i.iinfo.cz/images/38/ibm-5-5.png" alt="ibm-5" height="193" width="336" />
<p><i>Obrázek XX: Ukázka programu napsaného ve FORTRANu II, ve kterém můžeme
mj.&nbsp;vidět i použití aritmetického IF.</i></p>

<p><div class="rs-tip-major">Poznámka: samozřejmě nelze říci, že se assemblery přestaly po vzniku vyšších programovacích jazyků používat. Používají se stále, ovšem nika, kde má jejich praktické využití smysl, je dnes již relativně malá. Dnes se typicky setkáme s&nbsp;nějakou formou makroassembleru a zajímavé je, že autokódy se již prakticky nepoužívají, i když existují projekty, které se je snaží znovuobjevit (HLL atd.). Je to i logické, protože ve chvíli, kdy by se mohl použít autokód (výrazy, jednoduché podmínky a smyčky atd.) je již mnohdy praktičtější přejít na programovací jazyk C, který se tak s&nbsp;trochou nadsázky stal &bdquo;univerzálním assemblerem&ldquo;.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Grace Hopper a její vliv na vývoj vyšších programovacích jazyků</h2>

<p><i>&bdquo;Very few [people involved in data processing] were symbol
oriented; very few of them were mathematically trained.&ldquo;<br />
Grace Hopper vysvětluje, proč je vhodné programovat počítače UNIVAC ve vyšším
programovacím jazyku.</i></p>

<p><div class="rs-tip-major">Poznámka k&nbsp;přechylování: čtenáři, kteří dávají přednost přechylování
cizích příjmení, nechť si v&nbsp;dalším textu doplní chybějící -ová</div></p>

<p>Jedním z&nbsp;klíčových zaměstnanců firmy <i>Remington Rand</i> byla od roku 1949 i slavná <i>Grace Hopper</i> (). Tato programátorka dříve pracovala s&nbsp;reléovými elektronickými počítači, například na počítači <i>Mark II</i>. Právě při hledání chyby v&nbsp;jednom programu, který byl provozován na tomto stroji (programy byly &bdquo;zadrátovány&ldquo;, nikoli uloženy v&nbsp;paměti), objevila Grace, že v&nbsp;kontaktu jednoho relé je chycená můra &ndash; &bdquo;bug&ldquo;, kvůli níž kontakt korektně nespínal. Od té doby se v&nbsp;jejím týmu všechny chyby v&nbsp;programu označovaly slovem &bdquo;bug&ldquo; a Grace později začala používat nové slovo &bdquo;debug&ldquo; pro proces odstraňování těchto chyb.</p>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-14.png" width="450" height="550" alt=" " />
<p><i>Obrázek xx: Program napsaný ve strojovém kódu počítačů UNIVAC I a UNIVAC
II.</i></p>

<p>Ovšem vraťme se do doby, kdy <i>Grace Hopper</i> pracovala u firmy <i>Remington Rand (Sperry Rand)</i>. V&nbsp;této době se jí totiž podařilo vytvořit první překladač na světě nazvaný jednoduše <strong>A-0</strong>, který dokázal transformovat symbolicky zapsané matematické výrazy do strojového kódu počítačů <i>UNIVAC</i>.</p>

<p>Po první verzi překladače <strong>A-0</strong> vznikly i jeho vylepšené verze, především překladač nazvaný <strong>A-2</strong>, který byl poměrně intenzivně na <i>UNIVACu</i> používán. <i>Grace Hopper</i> vydala v&nbsp;roce 1952 článek o tomto překladači, což zajímavě koresponduje s&nbsp;rokem 1954, kdy byl vytvořen a představen první překladač <i>Fortranu</i> (tento jazyk se ovšem, na rozdíl od <strong>A-0</strong> a <strong>A-2</strong>, používá po mnoha úpravách a vylepšeních <a href="">dodnes</a>). Grace Hopper pokračovala v&nbsp;návrzích dalších programovacích jazyků, především jazyka <strong>B-0</strong> a taktéž jeho pokračovatele <i>FLOW-MATIC</i> a v&nbsp;neposlední řadě i <i>COBOLu</i>. Posléze se Grace vrátila k&nbsp;práci pro námořnictvo USA, kde po mnoha letech služby získala (jako první žena) hodnost kontradmirála v&nbsp;záloze.</p>

<a href="http://i.iinfo.cz/images/492/comp-hist-44-15.png"><img src="http://i.iinfo.cz/images/492/comp-hist-44-15-prev.png" width="370" height="225" alt=" " /></a>
<p><i>Obrázek xx: Velmi malá část vývojového diagramu složitějšího programu pro
počítače UNIVAC I a UNIVAC II. Povšimněte si především příkazů pro ovládání
páskových jednotek a taktéž zápisu absolutních adres 000-999 u některých stavů
diagramu.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Programovací jazyky A-0, A-2 a MATH-MATIC</h2>

<p>Programovací jazyk <strong>A-0</strong>, neboli <i>Arithmetic Language version 0</i>, byl vytvořen v&nbsp;letech 1951 až 1952 pro počítač <i>UNIVAC I</i> a později byl upraven pro použití na počítači <i>UNIVAC II</i> (z&nbsp;tohoto důvodu je článek doplněn fotkami Univaců). Jednalo se o poměrně přímočarý překladač (bez kontroly chyb a navíc bez pokusu o zotavení z&nbsp;chyb), který transformoval aritmetické a relativně primitivní řídicí příkazy do strojového kódu. Z&nbsp;tohoto překladače vycházela i jeho vylepšená a výše zmíněná verze <strong>A-2</strong>, jejíž upravená varianta byla nabízena pod názvem <i>MATH-MATIC</i>. V&nbsp;programech napsaných v&nbsp;<i>MATH-MATICu</i> byly všechny programové řádky očíslovány, podobně jako tomu bylo o mnoho let později v&nbsp;<i>BASICu</i>. Jak je pro programovací jazyky, jejichž autorem je <i>Grace Hopper</i>, typické, používají se namísto různých symbolů převážně klíčová slova a sekvence slov s&nbsp;přesným významem (<strong>JUMP TO SENTENCE</strong> atd.). Jednotlivé příkazy jsou ukončeny tečkou, podobně jako věty v&nbsp;běžném textu.</p>

<a href="http://i.iinfo.cz/images/492/comp-hist-44-16.jpg"><img src="http://i.iinfo.cz/images/492/comp-hist-44-16-prev.jpg" width="226" height="270" alt=" " /></a>
<p><i>Obrázek 16: Titulní stránka manuálu k&nbsp;programovacímu jazyku FLOW-MATIC.</i></p>

<p>Následuje ukázka čtyř vzájemně nesouvisejících programových řádků napsaných v&nbsp;<i>MATH-MATICu</i> &ndash; jedná se postupně o příkaz pro načtení hodnot tří proměnných, podmíněný příkaz, volání podprogramu umístěného na řádcích 4 až 8 (s&nbsp;implicitním návratem) a počítanou programovou smyčku s&nbsp;počitadlem <strong>J</strong>, které se zvyšuje od jedničky do dvaceti s&nbsp;krokem 1:</p>

<pre>
(1) READ A B C .
(20) IF X &gt; Y JUMP TO SENTENCE 8 .
(12) EXECUTE SENTENCE 4 THRU 8 .
(6) VARY J 1 (1) 20 SENTENCE 11 THRU 15 .
</pre>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-17.png" width="450" height="288" alt=" " />
<p><i>Obrázek 17: Program napsaný v&nbsp;programovacím jazyku
FLOW-MATIC.</i></p>

<p>Druhý demonstrační příklad je již plnohodnotným programem, který dokáže vypočítat průměr a odchylku z&nbsp;deseti hodnot uložených v&nbsp;poli. Na tomto příkladu je možná patrné, že již před více než šedesáti lety bylo možné programovat na vcelku vysoké úrovni (a výsledný program je dokonce čitelnější, než by tomu bylo v&nbsp;případě některých &bdquo;moderních&ldquo; programovacích jazyků):</p>

<pre>
(1) READ-ITEM X(10) IF SENTINEL JUMP TO SENTENCE 11 .
(2) SUM = 0 .
(3) SUMSQUARES = 0 .
(4) VARY I 1 (1) 10 SENTENCE 5 THRU 6 .
(5) SUM = SUM + X(I)
(6) SUMSQUARES = SUMSQUARES + X(I)^2 .
(7) MEAN = SUM / 10 .
(8) VARIANCE = SUMSQUARES / 10 - MEAN ^ 2 .
(9) WRITE AND EDIT FOR UNIPRINTER MEAN VARIANCE .
(10) JUMP TO SENTENCE 1 .
(11) STOP .
</pre>

<img src="http://i.iinfo.cz/images/492/comp-hist-44-18.jpg" width="349" height="435" alt=" " />
<p><i>Obrázek 18: Grace Hopper s&nbsp;referenční příručkou jazyka COBOL stojící u páskových jednotek UNISERVO.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Programovací jazyky B-0 a FLOW-MATIC</h2>

<p><i>&bdquo;Real Programmers don't write in PL/I. PL/I is for programmers who
can't decide whether to write in COBOL or FORTRAN.&ldquo;</i></p>

<p>Druhým programovacím jazykem, který <i>Grace Hopper</i> i přes určitý odpor svých spolupracovníků (kteří předložený návrh považovali za příliš radikální) vytvořila pro počítače <i>UNIVAC</i>, byl jazyk nazvaný <strong>B-0</strong> neboli <i>Business Language version 0</i>. Tento programovací jazyk je však známější pod svým komerčním názvem <i>FLOW-MATIC</i>. Jednalo o jazyk určený převážně pro zpracování dat, provádění bankovních operací, fakturace či výpočty mezd, což je velký rozdíl oproti výše popsaným jazykům <strong>A-0</strong> a <i>MATH-MATIC</i>, které byly orientovány zejména na provádění numerických výpočtů. <i>FLOW-MATIC</i> je s&nbsp;velkou pravděpodobností prvním programovacím jazykem, v&nbsp;němž se používala anglická slova mající význam klíčových slov; navíc se jednotlivé příkazy (programové řádky) velmi podobaly jednoduchým anglickým větám, a to i v&nbsp;případě zápisu složitějších podmínek (jazyk původně rozeznával dvacet klíčových slov). V&nbsp;tomto programovacím jazyku se vyskytovaly i příkazy, kterými se daly přímo ovládat jednotlivé páskové jednotky, kterých mohlo být v&nbsp;případě počítače <i>UNIVAC II</i> připojeno až 16. Existovala taktéž podpora pro tvorbu tiskových sestav.</p>

<a href="http://i.iinfo.cz/images/118/ibm6-1.jpg"><img src="http://i.iinfo.cz/images/118/ibm6-1-prev.jpg" alt="ibm6" height="270" width="228" /></a>
<p><i>Obrázek 19: První zveřejněná publikace o programovacím jazyku
COBOL.</i></p>

<p>Následuje ukázka programu napsaného v&nbsp;programovacím jazyce <i>FLOW-MATIC</i>. Povšimněte si především poměrně složité podmínky na řádku číslo jedna a porovnání výsledku výpočtu s&nbsp;nulou se specifikovaným počtem míst na řádku 14 (ZZZZ znamená porovnání na 4 místa/cifry, ZZZZZ na pět míst atd.):</p>

<pre>
 0) INPUT  INVENTORY FILE=A
           PRICE FILE=B,
    OUTPUT PRICED-INV FILE=C
           UNPRICED-INV FILE=D,
    HSP D.
 1) COMPARE PRODUCT-NO(A) WITH PRODUCT-NO(B)
    IF GREATER GO TO OPERATION 10;
    IF EQUAL GO TO OPERATION 5;
    OTHERWISE GO TO OPERATION 2.
 2) TRANSFER A TO D.
 3) WRITE ITEM D.
 4) JUMP TO OPERATION 8.

 5) TRANSFER A TO C.
 6) MOVE UNIT-PRICE(B) TO UNIT-PRICE(C).
 7) WRITE ITEM C.
 8) READ ITEM A; IF END OF DATA GO TO OPERATION 14.
 9) JUMP TO OPERATION 1.

10) READ ITEM B; IF END OF DATA GO TO OPERATION 12.
11) JUMP TO OPERATION 1.

12) SET OPERATION 9 TO GO TO OPERATION 2.
13) JUMP TO OPERATION 2.

14) TEST PRODUCT-NO(B) AGAINST ZZZZZZZZZZZZ;
    IF EQUAL GO TO OPERATION 16;
    OTHERWISE GO TO OPERATION 15.
15) REWIND B.
16) CLOSE-OUT FILES C, D.
17) STOP. (END)
</pre>

<a href="http://i.iinfo.cz/images/118/ibm6-5.png"><img src="http://i.iinfo.cz/images/118/ibm6-5-prev.png" alt="ibm6" height="265" width="370" /></a>
<p><i>Obrázek xx: Editor pro zápis COBOLovských programů, na kterém je mj.&nbsp;patrné i rozdělení řádků na jednotlivé části (číslo sekvence, sedmý sloupec, sekce A, sekce B) i omezení délky jednotlivých textových řádků na 72 znaků na řádek.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vznik prvního standardu COBOLu</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Ankrum,T. Scott<br />
COBOL &ndash; A Best Practice (Sept, 2001)<br />
COBOLReport.com
</li>

<li>Arranga,Edmund C.<br />
The Viagrazation of COBOL<br />
COBOLwebler.com
</li>

<li>Arranga, Edmund C. &amp; Price, Wilson<br />
Fresh from Y2K, What's next for COBOL? (March/April 2000)<br />
IEEE Software
</li>

<li>Arranga et al<br />
In COBOL's Defense : Roundtable Discussion (March/April 2000)<br />
IEEE Software
</li>

<li>Badower, Justin<br />
COBOL: Foundation of the future<br />
COBOLwebler.com
</li>

<li>Brown, Gary DeWard<br />
COBOL: The failure that wasn't<br />
COBOLReport.com
</li>

<li>Burger,Thomas Wolfgang<br />
COBOL in an open source future (May 2000)<br />
IBM developerWorks : Linux : Linux articles
</li>

<li>Carr, Donald and Kizior, Ronald J.<br />
The Case for Continued COBOL Education (March/April 2000)<br />
IEEE Software
</li>

<li>Feiman, J.<br />
The Gartner Programming Language Survey (October 2001)<br />
Gartner Advisory
</li>

<li>Glass, Robert L.<br />
Cobol &ndash; A Contradiction and an Enigma<br />
COMMUNICATIONS OF THE ACM September 1997/Vol. 40, No. 9
</li>

<li>Jones, Capers<br />
The global economic impact of the year 2000 software problem<br />
(Jan, 1997) 
</li>

<li>Kappelman, Leon A.<br />
Some Strategic Y2K Blessings (March/April 2000)<br />
IEEE Software
</li>

<li>Kizior, Dr. Ronald J. and Carr, Donald and Halpern, Dr. Paul<br />
What Professionals think of the Future of COBOL? 

<li>Murach, Mike<br />
Is COBOL Dying ... or Thriving? (February 2001)<br />
The Cobol Newswire 
</li>

<li>Pagnan, Martin<br />
Can A Java Programmer Be Transitioned To Cobol? (Feb, 2002)<br />
COBOLReport.com
</li>

<li>Reimann, Artur<br />
COBOL, Language of Choice &ndash; Then and Now (January, 2001)<br />
COBOLReport.com
</li>

<li>Sayles, Jonathan<br />
COBOL and the Enterprise Business Application Programming Legacy<br />
MicroFocus Ltd.
</li>

<li>Silverberg, Fred<br />
COBOL and the Business Programming Paradigm<br />
(1996)
</li>

<li>Sneed, Harry M.<br />
The Evolution of COBOL<br />
COBOLReport.com
</li>

<li>Wilkinson,Stephanie<br />
From the Dustbin, Cobol Rises (May, 2001)<br />
eWeek
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Rosetta Code &ndash; Category:COBOL<br />
<a href="http://rosettacode.org/wiki/Category:COBOL">http://rosettacode.org/wiki/Category:COBOL</a>
</li>

<li>COmmon Business Oriented Language<br />
<a href="http://foldoc.org/COBOL">http://foldoc.org/COBOL</a>
</li>

<li>COBOL Compilers<br />
<a href="http://www-01.ibm.com/software/awdtools/cobol/">http://www-01.ibm.com/software/awdtools/cobol/</a>
</li>

<li>Cobol: Not Dead Yet<br />
<a href="http://www.computerworld.com/s/article/266156/Cobol_Not_Dead_Yet?intsrc=kc_rfavs">http://www.computerworld.com/s/article/266156/Cobol_Not_Dead_Yet?intsrc=kc_rfavs</a>
</li>

<li>The future's bright ... the future's Cobol<br />
<a href="http://features.techworld.com/applications/3056/the-futures-bright--the-futures-cobol/">http://features.techworld.com/applications/3056/the-futures-bright--the-futures-cobol/</a>
</li>

<li>COBOL Example Programs<br />
<a href="http://www.csis.ul.ie/COBOL/examples/default.htm">http://www.csis.ul.ie/COBOL/examples/default.htm</a>
</li>

<li>Introduction to COBOL<br />
<a href="http://www.csis.ul.ie/COBOL/Course/COBOLIntro.htm">http://www.csis.ul.ie/COBOL/Course/COBOLIntro.htm</a>
</li>

<li>COBOL programming &ndash; tutorials, lectures, exercises, examples<br />
<a href="http://www.csis.ul.ie/COBOL/">http://www.csis.ul.ie/COBOL/</a>
</li>

<li>Wikipedia: COBOL<br />
<a href="http://en.wikipedia.org/wiki/COBOL">http://en.wikipedia.org/wiki/COBOL</a>
</li>

<li>Humor on Computers, Systems and Programming<br />
<a href="http://www-crypto.htw-saarland.de/weber/misc/programming.html">http://www-crypto.htw-saarland.de/weber/misc/programming.html</a>
</li>

<li>OpenCOBOL<br />
<a href="http://en.wikipedia.org/wiki/OpenCOBOL">http://en.wikipedia.org/wiki/OpenCOBOL</a>
</li>

<li>OpenCOBOL.org<br />
<a href="http://opencobol.org/">http://opencobol.org/</a>
</li>

<li>OpenCOBOL FAQ<br />
<a href="http://opencobol.add1tocobol.com/">http://opencobol.add1tocobol.com/</a>
</li>

<li>TinyCOBOL<br />
<a href="http://tiny-cobol.sourceforge.net/">http://tiny-cobol.sourceforge.net/</a>
</li>

<li>TinyCOBOL FAQ<br />
<a href="http://tiny-cobol.sourceforge.net/docs/faq/">http://tiny-cobol.sourceforge.net/docs/faq/</a>
</li>

<li>JTC1/SC22/WG4 &ndash; COBOL<br />
<a href="http://ra.dkuug.dk/jtc1/sc22/wg4/">http://ra.dkuug.dk/jtc1/sc22/wg4/</a>
</li>

<li>COBOL on COGS<br />
<a href="http://www.coboloncogs.org/INDEX.HTM">http://www.coboloncogs.org/INDEX.HTM</a>
</li>

<li>Cobol Coders: Going, Going, Gone?<br />
<a href="http://www.computerworld.com/s/article/266228/Cobol_Coders_Going_Going_Gone_">http://www.computerworld.com/s/article/266228/Cobol_Coders_Going_Going_Gone_</a>
</li>

<li>UNIVAC II - Universal Automatic Computer Model II<br />
<a href="http://ed-thelen.org/comp-hist/BRL61-u4.html">http://ed-thelen.org/comp-hist/BRL61-u4.html</a>
</li>

<li>UNIVAC I Computer System<br />
<a href="http://univac1.0catch.com/">http://univac1.0catch.com/</a>
</li>

<li>UNIVAC I Computer System<br />
<a href="http://univac1.0catch.com/yellowpage.htm">http://univac1.0catch.com/yellowpage.htm</a>
</li>

<li>UNIVAC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Univac">http://en.wikipedia.org/wiki/Univac</a>
</li>

<li>UNIVAC I (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/UNIVAC_I">http://en.wikipedia.org/wiki/UNIVAC_I</a>
</li>

<li>UNIVAC II (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/UNIVAC_II">http://en.wikipedia.org/wiki/UNIVAC_II</a>
</li>

<li>UNIVAC III (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/UNIVAC_III">http://en.wikipedia.org/wiki/UNIVAC_III</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

