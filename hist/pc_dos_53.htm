<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Od grafické karty VGA k vyšším rozlišením i většímu množství barev (3. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Od grafické karty VGA k vyšším rozlišením i většímu množství barev (3. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Předminule a minule jsme se seznámili s tím, jakým způsobem lze zjistit informace o grafických režimech SVGA karet přes VBE a jak se přistupuje do video paměti. Ovšem právě zde dochází k mnoha problémům, které je nutné řešit. Týká se to i operace typu BitBLT používané pro přenos rastrových obrázků.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Od grafické karty VGA k&nbsp;vyšším rozlišením i většímu množství barev (3. část)</a></p>
<p><a href="#k02">2. Vykreslení rastrového obrázku v&nbsp;režimech s&nbsp;256 barvami</a></p>
<p><a href="#k03">3. Nastavení barvové palety přes DAC</a></p>
<p><a href="#k04">4. Blokový přenos celého obrázku do banky video paměti</a></p>
<p><a href="#k05">5. Úplný zdrojový kód dnešního prvního demonstračního příkladu</a></p>
<p><a href="#k06">6. Korektní vykreslení prvních 82 řádků rastrového obrázku</a></p>
<p><a href="#k07">7. Úplný zdrojový kód dnešního druhého demonstračního příkladu</a></p>
<p><a href="#k08">8. Operace typu BitBLT: &bdquo;bit block transfer&ldquo;</a></p>
<p><a href="#k09">9. Realizace operace BitBLT specifické pro konkrétní rastrový obrázek</a></p>
<p><a href="#k10">10. Úplný zdrojový kód dnešního třetího demonstračního příkladu</a></p>
<p><a href="#k11">11. Vykreslení rastrového obrázku přesahujícího hranice jednoho paměťového banku</a></p>
<p><a href="#k12">12. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</a></p>
<p><a href="#k13">13. Horizontální vycentrování obrázku</a></p>
<p><a href="#k14">14. Úplný zdrojový kód dnešního pátého demonstračního příkladu</a></p>
<p><a href="#k15">15. Nastavení délky logického obrazového řádku</a></p>
<p><a href="#k16">16. Úplný zdrojový kód dnešního šestého demonstračního příkladu</a></p>
<p><a href="#k17">17. Textové režimy SVGA karet</a></p>
<p><a href="#k18">18. Obsah navazující části seriálu</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Od grafické karty VGA k&nbsp;vyšším rozlišením i většímu množství barev (3. část)</h2>

<p>Jak již bylo napsáno v&nbsp;perexu dnešního článku, v&nbsp;rámci <a
href="https://www.root.cz/clanky/od-graficke-karty-vga-k-vyssim-rozlisenim-i-vetsimu-mnozstvi-barev/">předminulého</a>
a <a
href="https://www.root.cz/clanky/od-graficke-karty-vga-k-vyssim-rozlisenim-i-vetsimu-mnozstvi-barev-2-cast/">minulého</a>
článku jsme se (i když ve zjednodušené formě) seznámili s&nbsp;tím, jakým
způsobem je možné programově zjistit informace o grafických režimech SVGA karet
přes VBE a jak se přistupuje do video paměti. Ovšem právě zde dochází
k&nbsp;mnoha více či méně závažným problémům, které je nutné řešit. Týká se to
i operace typu BitBLT používané pro přenos rastrových obrázků. Již dopředu je
možné odhadnout, že je zapotřebí brát do úvahy formát uložení pixelů
(neexistují zde obecně používané standardy), délku obrazového řádku a počet
pixelů na jednom obrazovém řádku (což je odlišná informace, než délka řádku). A
aby toho nebylo málo, je navíc nutné, minimálně v&nbsp;reálném režimu,
realizovat přepínání paměťových banků, protože v&nbsp;jednom okamžiku je
přístupné pouze jeden segment, tj.&nbsp;64 kB, který reprezentuje pouze (velmi)
malý výřez obrazové paměti.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti dokážou SVGA karty
používat a zobrazovat i textové režimy s&nbsp;vyšším počtem znaků na řádku
a/nebo vyšším počtem textových řádků. Touto problematikou se budeme zabývat
příště &ndash; textové režimy jsou totiž (nikoli překvapivě) mnohem jednodušší
na použití.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vykreslení rastrového obrázku v&nbsp;režimech s&nbsp;256 barvami</h2>

<p>V&nbsp;předchozích demonstračních příkladech jsme po výběru vhodného SVGA
režimu pouze na obrazovku vykreslili barevné pruhy. To je sice velmi jednoduchá
operace, ale nijak nám neumožňuje si lépe uvědomit, jaká je vlastně organizace
video paměti, jaký vliv mají paměťové banky, různé logické délky obrazových
řádků atd. Z&nbsp;tohoto důvodu si dnes ukážeme poněkud sofistikovanější
postup, který spočívá v&nbsp;tom, že do obrazové paměti vykreslíme předem
připravený rastrový obrázek. Ten bude mít rozlišení přesně 320&times;200 pixelů
a využívá barvovou paletu se stupni šedi (což je opět zjednodušení, abychom
nemuseli barvovou paletu načítat z&nbsp;paměti, ale mohli ji přímo programově
vygenerovat). Samotný rastrový obrázek je v&nbsp;době překladu uložen
v&nbsp;binárním souboru <strong>image_320x200.bin</strong> a do programového
kódu ho přidáme nám již známou volbou:</p>

<pre>
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>

<p><div class="rs-tip-major">Poznámka: zde je vhodné upozornit na to, že celý
<a
href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/image_320x200.bin">rastrový
obrázek</a> s&nbsp;rozlišením 320&times;200 pixelů má velikost 64000 bajtů a do
kódového segmentu souborů COM lze uložit jen 65536 bajtů (prakticky vlastně
ještě o 256 bajtů méně kvůli tomu, kde začíná programový kód). To znamená, že
pro vlastní program nám přibližně zbývá &bdquo;pouhý&ldquo; jeden kilobajt;
ovšem jeden kilobajt pro assembler (strojový kód) znamená hodně velký prostor
&ndash; dokonce existují například šachové algoritmy, které se do něj vejdou (a
celá řada dem-inter s&nbsp;velikostí 128 bajtů, 256 bajtů nebo právě onen jeden
kilobajt). My sice tak sofistikované algoritmy pochopitelně dělat nebudeme, ale
bez problémů si s&nbsp;dostupnou pamětí vystačíme.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nastavení barvové palety přes DAC</h2>

<p>Další potenciální problém SVGA karet spočívá ve způsobu nastavení barvové
palety. Většina karet se snaží zachovat zpětnou kompatibilitu s&nbsp;kartou VGA
a umožňovat mapování barvové palety naprogramováním převodní tabulky používané
DAC blokem (na konci je totiž trojice D/A převodníků, z&nbsp;toho vyplývá i
jméno bloku).</p>

<p>Grafická karta VGA na výstupu (tedy pravděpodobně ještě před výstupními
zesilovači) obsahuje obvod DAC neboli číslicově-analogový převodník. Signály R,
G, B, které jsou posílány do monitoru, jsou totiž na VGA analogové, což
umožnilo i s&nbsp;využitím konektoru s&nbsp;relativně malým počtem pinů (DE-15)
posílat informace o 262144 barvových odstínech a později i plné <i>true
color</i> (samozřejmě je ale signál zašumněn, frekvenčně omezen atd., takže
například na 48bitovou barvovou hloubku a rozlišení QUXGA spíše zapomeňme).</p>

<p>DAC interně obsahuje paměť s&nbsp;organizací 256&times;18 bitů. Na vstupu je
tedy osmibitová hodnota (adresa), na výstupu pak 18 bitů &ndash; pro každou
barvovou složku 6 bitů. Z&nbsp;toho plyne právě oněch 262144 barvových odstínů:
2<sup>6</sup>&times;2<sup>6</sup>&times;2<sup>6</sup>=2<sup>18</sup>=262144.
Přeprogramováním této paměti je tedy možné zajistit toho, že VGA monitor
zobrazí libovolnou barvu z&nbsp;této škály.</p>

<p>Ukažme si, jak může vypadat nastavení barvové palety tak, aby obsahovala
pouze odstíny šedé barvy. Použitý přístup je plně kompatibilní s&nbsp;původní
grafickou kartou VGA:</p>

<pre>
<i>; paleta ve stupnich sedi</i>
<strong>grayscale_palette</strong>:
        mov ax, 0x1010             <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl                 <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl                 <i>; prvni barvova slozka</i>
        shr ch, 1                  <i>; posun o dva bity doprava</i>
        shr ch, 1
        mov cl, ch                 <i>; druha barvova slozka</i>
        mov dh, ch                 <i>; treti barvova slozka</i>
        int 0x10                   <i>; modifikace mapovani v DAC</i>
        inc bl                     <i>; zvysit index v DAC</i>
        jnz next_dac               <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
        ret                        <i>; navrat ze subrutiny</i>
</pre>

<p><div class="rs-tip-major">Poznámka: existují i lepší přístupy nabízené
rozšířením BIOSu VBE. Ještě se k&nbsp;nim vrátíme.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Blokový přenos celého obrázku do banky video paměti</h2>

<p>Po nastavení 256barevného grafického režimu (například s&nbsp;rozlišením
800&times;600 pixelů) by do segmentu A000 měl být namapován první paměťový bank
video RAM, tj.&nbsp;prvních 64 kilobajtů. Můžeme se tedy pokusit o přenos
celého rastrového obrázku, který má velikost 320&times;200=64000 bajtů, do
video RAM a zjistit, jaký vzorek se vlastně zobrazí i jakou část obrazovky jsme
vlastně vyplnili:</p>

<pre>
        mov ax, cs
        mov ds, ax
        mov si, image              <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000             <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di                 <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*200/2          <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos celeho obrazku</i>
</pre>

<p>V&nbsp;našem konkrétním případě nastavíme grafický režim s&nbsp;rozlišením
právě 800&times;600 pixelů a bitovou hloubkou 8 bitů na pixel. Výsledek by měl
vypadat zhruba následovně (ovšem může se lišit, pokud bude odlišný počet bajtů
na řádek):</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 700px"><a href="https://www.root.cz/obrazek/1203078/"><img src="https://i.iinfo.cz/images/289/svga-3-1-large.png" class="image-1203078" width="700" height="525" data-prev-filename="https://i.iinfo.cz/images/289/svga-3-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/289/svga-3-1-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/289/svga-3-1-large.png" data-large-filename-webp="https://i.iinfo.cz/images/289/svga-3-1-large.webp" data-large-width="700" data-large-height="525" alt="svga_3" data-description="svga_3" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 700px" /></a>
<p>Výsledek blokového přenosu rastrového obrázku s rozlišením 320x200 pixelů do grafického režimu karty SVGA.</p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k05"></a></p>
<h2 id="k05">5. Úplný zdrojový kód dnešního prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu, po jehož
překladu a spuštění se do obrazové paměti překopíruje obsah rastrového obrázku,
vypadá následovně:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
&nbsp;
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
<strong>success</strong>:
        call grayscale_palette     <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image              <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000             <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di                 <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*200/2          <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos celeho obrazku</i>
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<strong>set_video_window</strong>:
        <i>; ocekava se, ze DL je nastaven korektne!</i>
        mov ax, 0x4f05             <i>; nastaveni okna</i>
        mov bx, 0x0000             <i>; okno A</i>
        int     0x10               <i>; volani VBE</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<i>; paleta ve stupnich sedi</i>
<strong>grayscale_palette</strong>:
        mov ax, 0x1010             <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl                 <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl                 <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch                 <i>; druha barvova slozka</i>
        mov dh, ch                 <i>; treti barvova slozka</i>
        int 0x10                   <i>; modifikace mapovani v DAC</i>
        inc bl                     <i>; zvysit index v DAC</i>
        jnz next_dac               <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Korektní vykreslení prvních 82 řádků rastrového obrázku</h2>

<p>Pokusme se nyní náš rastrový obrázek vykreslit korektně, což ovšem není
zcela triviální. Nejprve se zaměříme na korektní zápis do jediného paměťového
banku. Ten má typicky velikost 64kB a zabírá celý segment A000. Pro rozlišení
800&times;600 pixelů a 256 barev má jeden obrazový řádek délku 800 bajtů a
celkem je tedy do segmentu namapováno 65536/800 neboli 81/82 obrazových řádků
(celých 81 řádků a prakticky celý 82. řádek bez posledních 64 bajtů &ndash; to
si snadno ověříte zpětným výpočtem). Náš rastrový obrázek má na každém řádku
jen 320 bajtů a proto budeme postupovat následovně:</p>

<ol>
<li>Vykreslíme (přeneseme) 320 bajtů z&nbsp;obrázku do obrazové paměti</li>
<li>Zvýšíme cílový ukazatel o 800-320 bajtů, tedy přeskočíme zbývající pixely na obrazovém řádku</li>
<li>Celý proces zopakujeme 82&times; a korektně tak vykreslíme prvních 82 řádků obrázku</li>
</ol>

<p>Nejprve zapíšeme do registrů <strong>DS:SI</strong> adresu prvního bajtu
zdrojového obrázku:</p>

<pre>
        mov ax, cs
        mov ds, ax
        mov si, image              <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
</pre>

<p>Následně do registrů <strong>ES:DI</strong> zapíšeme adresu prvního bajtu
v&nbsp;obrazové paměti:</p>

<pre>
        mov ax, 0xa000             <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di                 <i>; offset na zacatek video RAM</i>
</pre>

<p>A konečně budeme 82&times; opakovat přenos 320 bajtů (160 slov)
s&nbsp;úpravou registru <strong>DI</strong> tak, aby se ukazatel posunul na
začátek dalšího obrazového řádku:</p>

<pre>
        mov al, 82                 <i>; počitadlo obrazových řádků</i>
<strong>next_line</strong>:
        mov cx, 320/2              <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos jednoho obrazoveho radku</i>
        add di, 800-320            <i>; preskocit zbytek obrazoveho radku</i>
        dec al                     <i>; snizit pocitadlo radku</i>
        jnz next_line
</pre>

<p>Výsledek již bude vypadat korektně, ovšem stále se bude jednat pouze o 82
obrazových řádků:</p>

*** image ***



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód dnešního druhého demonstračního příkladu</h2>

<p>Úplný zdrojový kód příkladu, který po svém překladu a spuštění vykreslí
obrázek uvedený <a href="#k06">v&nbsp;předchozí kapitole</a>, vypadá
následovně:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
&nbsp;
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
<strong>success</strong>:
        call grayscale_palette     <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image              <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000             <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di                 <i>; offset na zacatek video RAM</i>
&nbsp;
        mov al, 82
<strong>next_line</strong>:
        mov cx, 320/2              <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos jednoho obrazoveho radku</i>
        add di, 800-320            <i>; preskocit zbytek obrazoveho radku</i>
        dec al                     <i>; snizit pocitadlo radku</i>
        jnz next_line
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<strong>set_video_window</strong>:
        <i>; ocekava se, ze DL je nastaven korektne!</i>
        mov ax, 0x4f05             <i>; nastaveni okna</i>
        mov bx, 0x0000             <i>; okno A</i>
        int     0x10               <i>; volani VBE</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<i>; paleta ve stupnich sedi</i>
<strong>grayscale_palette</strong>:
        mov ax, 0x1010             <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl                 <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl                 <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch                 <i>; druha barvova slozka</i>
        mov dh, ch                 <i>; treti barvova slozka</i>
        int 0x10                   <i>; modifikace mapovani v DAC</i>
        inc bl                     <i>; zvysit index v DAC</i>
        jnz next_dac               <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Operace typu BitBLT: &bdquo;bit block transfer&ldquo;</h2>

<p>Většina historických i poměrně velká část soudobých počítačových her
s&nbsp;dvoudimenzionální (2D) grafikou je charakteristická tím, že objekty
v&nbsp;těchto hrách jsou reprezentovány s&nbsp;využitím rastrových obrázků
(bitmap) o různé velikosti, které se postupně vykreslují do vytvářené
dvoudimenzionální scény. Aby bylo přes některé části těchto rastrových obrázků
viditelné i pozadí, používají se tři metody pro zajištění úplné či částečné
průhlednosti. Buď je stanoveno, že určitá hodnota (tj.&nbsp;barva) pixelů má
být zcela průhledná (typicky se jedná o jasně fialovou barvu, která se
v&nbsp;běžných scénách stejně nikde neobjevuje), dále je alternativně možné
jeden bit v&nbsp;hodnotě pixelu použít pro určení průhlednosti (typické pro
16bitovou hloubku), nebo se může stanovit průhlednost pixelů doplněním bitmapy
o takzvaný <i>alfa kanál (alpha channel)</i>.</p>

<p>S&nbsp;využitím grafické operace <strong>blit</strong> neboli
<strong>BitBLT</strong> (<i>Bit Block Transfer</i>) lze provádět, jak ostatně
její název naznačuje, blokové přenosy bitmap nebo jejich výřezů,
popř.&nbsp;v&nbsp;rámci přenosu nad bitmapami provádět různé další operace,
například zpracování alfa kanálu. První implementace operace
<strong>BitBLT</strong> byla použita už v&nbsp;roce 1975 ve
<i>Smalltalku-72</i> a od té doby ji najdeme prakticky v&nbsp;každé
implementaci tohoto programovacího jazyka, která obsahuje i knihovny pro práci
s&nbsp;grafikou (mj.&nbsp;se jedná i o <i>Squeak</i>).</p>

<p>Pro <i>Smalltalk-74</i> vytvořil Daniel Ingalls optimalizovanou variantu
operace <strong>BitBLT</strong> implementovanou v&nbsp;mikrokódu. Operace
<strong>BitBLT</strong> se tak stala součástí operačního systému a bylo ji
možné volat jak z&nbsp;assembleru, tak i z&nbsp;programů napsaných
v&nbsp;jazyce <i>BCPL</i> a samozřejmě i ze <i>Smalltalku</i> (právě tuto
implementaci můžeme považovat za vůbec první grafickou akceleraci). Posléze se
díky své univerzalitě tato funkce rozšířila i do mnoha dalších operačních
systémů a grafických knihoven.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Realizace operace BitBLT specifické pro konkrétní rastrový obrázek</h2>

<p>Můžeme se pokusit o realizaci vlastní operace typu BitBLT. Tato realizace
zahrnuje (v&nbsp;tom nejjednodušším případě) přenos celého obrazového řádku na
obrazovku a korektní &bdquo;přeskok&ldquo; na další řádek. Jedná se o operace,
které jsme již použili ve druhém demonstračním příkladu, takže nám pouze zbývá
jejich realizace formou subrutiny (podprogramu). V&nbsp;tom nejjednodušším
případě bude subrutina vyžadovat předání parametrů v&nbsp;pracovních
registrech:</p>

<table>
<tr><th>Registr(y)</th><th>Význam</th></tr>
<tr><td>DS:SI</td><td>adresa prvního pixelu zdrojového obrázku</td></tr>
<tr><td>DI</td><td>adresa pixelu v&nbsp;rámci segmentu A000 (bank video paměti)</td></tr>
<tr><td>AL</td><td>počet řádků, které se mají přenést</td></tr>
</table>

<p>V&nbsp;tom nejjednodušším případě je offset, o který je nutné přeskočit
v&nbsp;obrazové paměti, přímo součástí těla subrutiny &ndash; viz řádek
s&nbsp;instrukcí <strong>ADD DI, 800-320</strong>. Pochopitelně je však možné
tuto hodnotu (typu <i>slovo</i>) předat v&nbsp;dalším pracovním registru,
například v&nbsp;registru <strong>DX</strong>, který není v&nbsp;subrutině
použit:</p>

<pre>
<strong>bitblt</strong>:
        push 0xa000                <i>; video RAM v textovem rezimu</i>
        pop  es
<strong>next_line</strong>:
        mov cx, 320/2              <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos jednoho obrazoveho radku</i>
        add di, 800-320            <i>; preskocit zbytek obrazoveho radku</i>
        dec al                     <i>; snizit pocitadlo radku</i>
        jnz next_line
        ret                        <i>; navrat ze subrutiny</i>
</pre>

<p><div class="rs-tip-major">Poznámka: jak jste si mohli všimnout, subrutina
&bdquo;ničí&ldquo; obsah několika registrů. Pokud tomu budeme chtít zabránit,
bude nutné použít instrukce <strong>PUSH</strong> a <strong>POP</strong>.
Obecně však budeme vyžadovat (viz další text), aby se obsah registrů
<strong>SI</strong> a <strong>DI</strong> skutečně <i>změnil</i> (a tedy není
možné použít <strong>PUSHALL</strong> a <strong>POPALL</strong>).</div></p>

<p>Způsob volání subrutiny <strong>BitBLT</strong> pro vykreslení prvních 82
řádků obrázku:</p>

<pre>
        eov ax, cs
        mov ds, ax
        mov si, image              <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        xor di, di                 <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úplný zdrojový kód dnešního třetího demonstračního příkladu</h2>

<p>Způsob začlenění <a href="#k09">výše uvedené</a> subrutiny do uceleného
demonstračního příkladu vypadá takto:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
start:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
&nbsp;
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
<strong>success</strong>:
        call grayscale_palette     <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image              <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        xor di, di                 <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<strong>bitblt</strong>:
        push 0xa000                <i>; video RAM v textovem rezimu</i>
        pop  es
<strong>next_line</strong>:
        mov cx, 320/2              <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos jednoho obrazoveho radku</i>
        add di, 800-320            <i>; preskocit zbytek obrazoveho radku</i>
        dec al                     <i>; snizit pocitadlo radku</i>
        jnz next_line
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<strong>set_video_window</strong>:
        <i>; ocekava se, ze DL je nastaven korektne!</i>
        mov ax, 0x4f05             <i>; nastaveni okna</i>
        mov bx, 0x0000             <i>; okno A</i>
        int     0x10               <i>; volani VBE</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<i>; paleta ve stupnich sedi</i>
<strong>grayscale_palette</strong>:
        mov ax, 0x1010             <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl                 <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl                 <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch                 <i>; druha barvova slozka</i>
        mov dh, ch                 <i>; treti barvova slozka</i>
        int 0x10                   <i>; modifikace mapovani v DAC</i>
        inc bl                     <i>; zvysit index v DAC</i>
        jnz next_dac               <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vykreslení rastrového obrázku přesahujícího hranice jednoho paměťového banku</h2>

<p>Vraťme se nyní k&nbsp;první verzi subrutiny <strong>bitblt</strong>. Tato
subrutina je schválně napsaná takovým způsobem, aby vhodným způsobem upravila
hodnoty registrů <strong>SI</strong> (zdrojový obrázek) a <strong>DI</strong>
(video RAM). Současně se provede přenos <strong>AL</strong> řádků:</p>

<pre>
<strong>bitblt</strong>:
        push 0xa000                <i>; video RAM v textovem rezimu</i>
        pop  es
<strong>next_line</strong>:
        mov cx, 320/2              <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos jednoho obrazoveho radku</i>
        add di, 800-320            <i>; preskocit zbytek obrazoveho radku</i>
        dec al                     <i>; snizit pocitadlo radku</i>
        jnz next_line
        ret                        <i>; navrat ze subrutiny</i>
</pre>

<p>To znamená, že pokud budeme korektně přepínat paměťové banky video RAM
(počítejme s&nbsp;velikostí 64kB), bude možné postupně vykreslit celý obrázek.
Přenést (vykreslit) prvních 82 řádků již umíme, takže pro jistotu přidejme kód
pro přepnutí banku (segment A000) na hodnotu 0:</p>

<pre>
        mov  dx, 0                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
&nbsp;
        xor di, di                 <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
</pre>

<p>Současně s&nbsp;návratem ze subrutiny <strong>bitblt</strong> došlo
k&nbsp;úpravě registrů <strong>SI</strong> a <strong>DI</strong>, takže se
můžeme pokusit o vykreslení dalších 82 řádků. Registr <strong>SI</strong> bude
obsahovat korektní hodnotu, ovšem hodnotu <strong>DI</strong> je nutné vhodným
způsobem upravit, protože obecně paměťové banky video RAM <i>nekončí</i> na
konci/začátku obrazových řádků. Přepnutím paměťového banku na dalších 64kB je
nutné provést přesun na 82&times;800 (o tolik se registr změnil při přenosu
prvních 82 řádků) a od této hodnoty odečteme 65536. Nevadí, že dochází
k&nbsp;přenosům/přetečení, protože výsledek bude korektní &ndash; posun o 64
bajtů (v&nbsp;rámci paměťového banku &ndash; nejedná se o horizontální
pozici!).</p>

<p>Následující sekvence instrukcí vykreslí dalších 82 obrazových řádků:</p>

<pre>
        mov  dx, 1                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
&nbsp;
        mov di, 82*800-65536       <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
</pre>

<p>Naprosto stejným postupem vykreslíme zbytek obrázku. Jeho výška je rovna 200
pixelům a už jsme v&nbsp;předchozích dvou krocích vykreslili 2&times;82 řádků,
takže výpočet bude vypadat takto (posun o 128 bajtů + vykreslení 36 řádků):</p>

<pre>
        mov  dx, 2                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
&nbsp;
        mov di, 2*82*800-65536*2   <i>; offset na zacatek video RAM</i>
        mov al, 200-82*2           <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
</pre>

<p>Nyní by se na obrazovce měl nacházet celý obrázek:</p>

*** image ***

<p><div class="rs-tip-major">Poznámka: ve skutečnosti nejsou tyto výpočty
korektní ve všech situacích, protože záleží na tom, kde přesně (na řádku) končí
paměťový bank.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</h2>

<p>Zdrojový kód dnešního čtvrtého demonstračního příkladu, který po svém
spuštění vykreslil předchozí obrázek, vypadá následovně:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
&nbsp;
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
<strong>success</strong>:
        call grayscale_palette     <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image              <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov  dx, 0                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
&nbsp;
        xor di, di                 <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        mov  dx, 1                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
        mov di, 82*800-65536       <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        mov  dx, 2                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
        mov di, 2*82*800-65536*2   <i>; offset na zacatek video RAM</i>
        mov al, 200-82*2           <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<strong>bitblt</strong>:
        push 0xa000                <i>; video RAM v textovem rezimu</i>
        pop  es
<strong>next_line</strong>:
        mov cx, 320/2              <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos jednoho obrazoveho radku</i>
        add di, 800-320            <i>; preskocit zbytek obrazoveho radku</i>
        dec al                     <i>; snizit pocitadlo radku</i>
        jnz next_line
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<strong>set_video_window</strong>:
        <i>; ocekava se, ze DL je nastaven korektne!</i>
        mov ax, 0x4f05             <i>; nastaveni okna</i>
        mov bx, 0x0000             <i>; okno A</i>
        int     0x10               <i>; volani VBE</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<i>; paleta ve stupnich sedi</i>
<strong>grayscale_palette</strong>:
        mov ax, 0x1010             <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl                 <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl                 <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch                 <i>; druha barvova slozka</i>
        mov dh, ch                 <i>; treti barvova slozka</i>
        int 0x10                   <i>; modifikace mapovani v DAC</i>
        inc bl                     <i>; zvysit index v DAC</i>
        jnz next_dac               <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Horizontální vycentrování obrázku</h2>

<p>Rastrový obrázek se prozatím vykreslil do levého horního rohu obrazovky. Jak
je nutné postupovat v&nbsp;případě, kdy například budeme vyžadovat jeho
vycentrování? Ve skutečnosti to nemusí být nic složitého, protože pouze
potřebujeme posunout počáteční hodnotu registru <strong>DI</strong> tak, aby se
celý obrázek (320 pixelů na šířku) vykreslil doprostřed obrazovky, která má na
šířku 800 pixelů. To je snadné, protože pro nultý bank se pozice
(v&nbsp;pixelech resp.&nbsp;bajtech) vypočte takto:</p>

<pre>
        xcenter equ 800/2-320/2
</pre>

<p>Tedy konkrétně pro prvních 82 řádků:</p>

<pre>
        mov  dx, 0                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
&nbsp;
        xcenter equ 800/2-320/2
&nbsp;
        mov di, xcenter            <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
</pre>

<p>Posun je ovšem nutné připočítat i pro další paměťové banky (a nezáleží
přitom na tom, že dochází k&nbsp;přetečení mezivýsledků):</p>

<pre>
        mov  dx, 1                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
        mov di, xcenter+82*800-65536       <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
</pre>

<p>Dtto pro třetí banku (banku s&nbsp;indexem 2):</p>

<pre>
        mov  dx, 2                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
        mov di, xcenter+2*82*800-65536*2   <i>; offset na zacatek video RAM</i>
        mov al, 200-82*2           <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
</pre>

<p>Opět se podívejme na výsledek, který tímto postupem získáme:</p>

*** image ***



<p><a name="k14"></a></p>
<h2 id="k14">14. Úplný zdrojový kód dnešního pátého demonstračního příkladu</h2>

<p>Již popáté si ukážeme, jak vypadá úplný zdrojový kód demonstračního
příkladu, kterým byl vykreslen obrázek <a href="#k13">z&nbsp;předchozí
kapitoly</a>:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
&nbsp;
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
<strong>success</strong>:
        call grayscale_palette     <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image              <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov  dx, 0                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
&nbsp;
        xcenter equ 800/2-320/2
&nbsp;
        mov di, xcenter            <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        mov  dx, 1                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
        mov di, xcenter+82*800-65536       <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        mov  dx, 2                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
        mov di, xcenter+2*82*800-65536*2   <i>; offset na zacatek video RAM</i>
        mov al, 200-82*2           <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<strong>bitblt</strong>:
        push 0xa000                <i>; video RAM v textovem rezimu</i>
        pop  es
<strong>next_line</strong>:
        mov cx, 320/2              <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos jednoho obrazoveho radku</i>
        add di, 800-320            <i>; preskocit zbytek obrazoveho radku</i>
        dec al                     <i>; snizit pocitadlo radku</i>
        jnz next_line
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<strong>set_video_window</strong>:
        <i>; ocekava se, ze DL je nastaven korektne!</i>
        mov ax, 0x4f05             <i>; nastaveni okna</i>
        mov bx, 0x0000             <i>; okno A</i>
        int     0x10               <i>; volani VBE</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<i>; paleta ve stupnich sedi</i>
<strong>grayscale_palette</strong>:
        mov ax, 0x1010             <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl                 <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl                 <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch                 <i>; druha barvova slozka</i>
        mov dh, ch                 <i>; treti barvova slozka</i>
        int 0x10                   <i>; modifikace mapovani v DAC</i>
        inc bl                     <i>; zvysit index v DAC</i>
        jnz next_dac               <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Nastavení délky logického obrazového řádku</h2>

<p>Prozatím jsme předpokládali, že délka obrazového řádku (v&nbsp;bajtech)
odpovídá horizontálnímu rozlišení obrazovky, samozřejmě za předpokladu, že se
jedná o 256barevné režimy. Ovšem ve skutečnosti tak tomu být nemusí a délka
řádku může být delší (například 1024 bajtů). Některé grafické karty byly
dokonce konfigurovatelné a bylo tak možné délku řádku změnit. Pro tento účel se
používala VBE služba 0x4f, s&nbsp;číslem podslužby 0x06. Tato služba vrátila
aktuálně nastavenou délku řádku popř.&nbsp;ji umožňovala změnit. Podívejme se
nyní na způsob volání:</p>

<pre>
Vstup:  AH = 4Fh        Služby SVGA
        AL = 06h        Podslužba pro přečtení či nastavení délky obrazového řádku
        BL = 01h        Požadavek na vrácení aktuální hodnoty
&nbsp;
Výstup: AL = 4Fh pokud je služba podporována, jinak odlišná hodnota
        AH = 00h pokud je volání úspěšné, jinak hodnota 01h
        BX = počet bajtů na obrazovém řádku
        CX = počet pixelů na obrazovém řádku
        DX = počet obrazových řádků
</pre>

<p>Nastavení se provádí takto:</p>

<pre>
Vstup:  AH = 4Fh        Služby SVGA
        AL = 06h        Podslužba pro přečtení či nastavení délky obrazového řádku
        BL = 00h        Požadavek na změnu délky obrazového řádku
        CX = ??         Požadovaná délka řádku v pixelech
&nbsp;
Výstup: AL = 4Fh pokud je služba podporována, jinak odlišná hodnota
        AH = 00h pokud je volání úspěšné, jinak hodnota 01h
        BX = počet bajtů na obrazovém řádku
        CX = počet pixelů na obrazovém řádku
        DX = počet obrazových řádků
</pre>

<p><div class="rs-tip-major">Poznámka: tato služba je sice potenciálně velmi
užitečná, protože umožňuje scrolling atd., ovšem ne vždy je
podporována.</div></p>

<p>V&nbsp;kódu by mohlo nastavení délky obrazového řádku vypadat takto:</p>

<pre>
        mov  ax, 0x4f06            <i>; nastaveni nebo precteni delky logickeho radku</i>
        mov  bl, 00                <i>; operace nastaveni</i>
        mov  cx, 1024              <i>; delka radku</i>
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Úplný zdrojový kód dnešního šestého demonstračního příkladu</h2>

<p>Podívejme se nyní na způsob změny délky obrazového řádku v&nbsp;praxi:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
&nbsp;
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
        mov  ax, 0x4f06            <i>; nastaveni nebo precteni delky logickeho radku</i>
        mov  bl, 00                <i>; operace nastaveni</i>
        mov  cx, 800               <i>; delka radku</i>
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
&nbsp;
<strong>success</strong>:
        call grayscale_palette     <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image              <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov  dx, 0                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
&nbsp;
        xcenter equ 800/2-320/2
&nbsp;
        mov di, xcenter            <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        mov  dx, 1                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
        mov di, xcenter+82*800-65536       <i>; offset na zacatek video RAM</i>
        mov al, 82                 <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        mov  dx, 2                 <i>; cislo pametoveho banku video pameti</i>
        call set_video_window      <i>; nastaveni pametoveho banku</i>
        mov di, xcenter+2*82*800-65536*2   <i>; offset na zacatek video RAM</i>
        mov al, 200-82*2           <i>; pocet prenesenych radku</i>
        call bitblt                <i>; zavolat subrutinu pro blokovy prenos</i>
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<strong>bitblt</strong>:
        push 0xa000                <i>; video RAM v textovem rezimu</i>
        pop  es
<strong>next_line</strong>:
        mov cx, 320/2              <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw                  <i>; prenos jednoho obrazoveho radku</i>
        add di, 800-320            <i>; preskocit zbytek obrazoveho radku</i>
        dec al                     <i>; snizit pocitadlo radku</i>
        jnz next_line
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<strong>set_video_window</strong>:
        <i>; ocekava se, ze DL je nastaven korektne!</i>
        mov ax, 0x4f05             <i>; nastaveni okna</i>
        mov bx, 0x0000             <i>; okno A</i>
        int     0x10               <i>; volani VBE</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<i>; paleta ve stupnich sedi</i>
<strong>grayscale_palette</strong>:
        mov ax, 0x1010             <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl                 <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl                 <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch                 <i>; druha barvova slozka</i>
        mov dh, ch                 <i>; treti barvova slozka</i>
        int 0x10                   <i>; modifikace mapovani v DAC</i>
        inc bl                     <i>; zvysit index v DAC</i>
        jnz next_dac               <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Textové režimy SVGA karet</h2>

<p>Prozatím jsme se zabývali především grafickými režimy, které byly nabízeny
SVGA kartami a které byly navíc podporovány rozšířením BIOSu (VBE). Ovšem
nesmíme zapomenout na to, že většina SVGA karet umožňovala využití textových
režimů, přičemž původní sada textových režimů (40&times;25 znaků, 80&times;25
znaků, 80&times;43 znaků a 80&times;50 znaků) byla rozšířena o režimy
s&nbsp;větším počtem textových řádků a/nebo i větším počtem sloupců. Typicky
bylo možné na jednom textovém řádku zobrazit až 132 znaků a počet textových
řádků se zvyšoval až na 60.</p>

<p>Zajímavé je, že i tyto (de facto nestandardní) textové režimy udržovaly
velmi dobrou zpětnou kompatibilitu, která v&nbsp;tomto případě nesahá pouze ke
kartě VGA, ale až ke kartám CGA a MDA. Typicky byly znaky a jejich atributy
ukládány do segmentu 0xb8000 a dokonce byly emulovány i některé řídicí registry
grafického řadiče, což například umožňovalo manipulace s&nbsp;textovým kurzorem
atd. Výsledkem bylo, že relativně velké množství aplikací tyto nové textové
režimy podporovalo, a přitom se z&nbsp;vývojářského hlediska nejednalo o větší
problém (na rozdíl, jak již víme, od grafických režimů).</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazující části seriálu</h2>

<p>V&nbsp;další části seriálu o tvorbě her a multimediálních aplikací pro
platformu IBM PC se zaměříme právě na textové režimy, které jsou podporovány
většinou SVGA karet. Ukážeme si i některé aplikace, které tyto režimy dokázaly
(více či méně úspěšně) využít. A pochopitelně se budeme zabývat i zpětnou
kompatibilitou s&nbsp;původní sérii grafických karet pro platformu IBM PC: od
CGA a MDA přes kartu EGA až k&nbsp;(relativně) dlouhodobému standardu VGA.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (v&nbsp;současnosti již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>cga_text_mode_1.asm</td><td>standardní textový režim s&nbsp;rozlišením 40&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm</a></td></tr>
<tr><td>27</td><td>cga_text_mode_3.asm</td><td>standardní textový režim s&nbsp;rozlišením 80&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm</a></td></tr>
<tr><td>28</td><td>cga_text_mode_intensity.asm</td><td>změna významu nejvyššího bitu atributového bajtu: vyšší intenzita namísto blikání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm</a></td></tr>
<tr><td>29</td><td>cga_text_mode_cursor.asm</td><td>změna tvaru textového kurzoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm</a></td></tr>
<tr><td>30</td><td>cga_text_gfx_1.asm</td><td>zobrazení &bdquo;rastrové mřížky&ldquo;: pseudografický režim 160&times;25 pixelů (interně textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm</a></td></tr>
<tr><td>31</td><td>cga_text_mode_char_height.asm</td><td>změna výšky znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm</a></td></tr>
<tr><td>32</td><td>cga_text_160x100.asm</td><td>grafický režim 160&times;100 se šestnácti barvami (interně upravený textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>hercules_text_mode_1.asm</td><td>využití standardního textového režimu společně s&nbsp;kartou Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm</a></td></tr>
<tr><td>34</td><td>hercules_text_mode_2.asm</td><td>zákaz blikání v&nbsp;textových režimech</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm</a></td></tr>
<tr><td>35</td><td>hercules_turn_off.asm</td><td>vypnutí generování video signálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm</a></td></tr>
<tr><td>36</td><td>hercules_gfx_mode_1.asm</td><td>přepnutí karty Hercules do grafického režimu (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm</a></td></tr>
<tr><td>37</td><td>hercules_gfx_mode_2.asm</td><td>přepnutí karty Hercules do grafického režimu (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm</a></td></tr>
<tr><td>38</td><td>hercules_putpixel.asm</td><td>subrutina pro vykreslení jediného pixelu na kartě Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>ega_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm</a></td></tr>
<tr><td>40</td><td>ega_text_mode_80x43.asm</td><td>zobrazení 43 textových řádků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm</a></td></tr>
<tr><td>41</td><td>ega_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm</a></td></tr>
<tr><td>42</td><td>ega_gfx_mode_640x200.asm</td><td>přepnutí do grafického režimu 640&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm</a></td></tr>
<tr><td>43</td><td>ega_gfx_mode_640x350.asm</td><td>přepnutí do grafického režimu 640&times;350 pixelů se čtyřmi nebo šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm</a></td></tr>
<tr><td>44</td><td>ega_gfx_mode_bitplanes_1.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (základní způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm</a></td></tr>
<tr><td>45</td><td>ega_gfx_mode_bitplanes_2.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (rychlejší způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>ega_320x200_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm</a></td></tr>
<tr><td>47</td><td>ega_640x350_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 640&times;350 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>ega_standard_font.asm</td><td>použití standardního fontu grafické karty EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm</a></td></tr>
<tr><td>49</td><td>ega_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>ega_palette_1.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 320&times;200 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm</a></td></tr>
<tr><td>51</td><td>ega_palette_2.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 640&times;350 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm</a></td></tr>
<tr><td>52</td><td>ega_palette_3.asm</td><td>změna všech barev v&nbsp;barvové paletě s&nbsp;využitím programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm</a></td></tr>
<tr><td>53</td><td>ega_palette_4.asm</td><td>změna všech barev, včetně barvy okraje, v&nbsp;barvové paletě voláním funkce BIOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>vga_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm</a></td></tr>
<tr><td>55</td><td>vga_text_mode_80x50.asm</td><td>zobrazení 50 a taktéž 28 textových řádků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm</a></td></tr>
<tr><td>56</td><td>vga_text_mode_intensity_1.asm</td><td>změna chování atributového bitu pro blikání (nebezpečná varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm</a></td></tr>
<tr><td>57</td><td>vga_text_mode_intensity_2.asm</td><td>změna chování atributového bitu pro blikání (bezpečnější varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm</a></td></tr>
<tr><td>58</td><td>vga_text_mode_9th_column.asm</td><td>modifikace způsobu zobrazení devátého sloupce ve znakových režimech (720 pixelů na řádku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm</a></td></tr>
<tr><td>59</td><td>vga_text_mode_cursor_shape.asm</td><td>změna tvaru textového kurzoru na grafické kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm</a></td></tr>
<tr><td>60</td><td>vga_text_mode_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>vga_gfx_mode_640x480.asm</td><td>přepnutí do grafického režimu 640&times;480 pixelů se šestnácti barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm</a></td></tr>
<tr><td>62</td><td>vga_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů s&nbsp;256 barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm</a></td></tr>
<tr><td>63</td><td>vga_gfx_mode_palette.asm</td><td>změna všech barev v&nbsp;barvové paletě grafické karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm</a></td></tr>
<tr><td>64</td><td>vga_gfx_mode_dac_1.asm</td><td>využití DAC (neočekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm</a></td></tr>
<tr><td>65</td><td>vga_gfx_mode_dac_2.asm</td><td>využití DAC (očekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>66</td><td>vga_640x480_putpixel.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 640&times;480 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm</a></td></tr>
<tr><td>67</td><td>vga_320x200_putpixel_1.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm</a></td></tr>
<tr><td>68</td><td>vga_320x200_putpixel_2.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (rychlejší varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>vga_gfx_mode_dac_3.asm</td><td>přímé využití DAC v&nbsp;grafickém režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>70</td><td>vga_gfx_mode_unchained_step_1.asm</td><td>zobrazení barevných pruhů v&nbsp;režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm</a></td></tr>
<tr><td>71</td><td>vga_gfx_mode_unchained_step_2.asm</td><td>vypnutí zřetězení bitových rovin a změna způsobu adresování pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm</a></td></tr>
<tr><td>72</td><td>vga_gfx_mode_unchained_step_3.asm</td><td>vykreslení barevných pruhů do vybraných bitových rovin</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>73</td><td>vga_gfx_mode_320x400.asm</td><td>nestandardní grafický režim s&nbsp;rozlišením 320&times;400 pixelů a 256 barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm</a></td></tr>
<tr><td>74</td><td>vga_320x200_image.asm</td><td>zobrazení rastrového obrázku ve standardním grafickém režimu 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm</a></td></tr>
<tr><td>75</td><td>vga_320x200_unchained_image_1.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (nekorektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm</a></td></tr>
<tr><td>76</td><td>vga_320x200_unchained_image_2.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (korektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm</a></td></tr>
<tr><td>77</td><td>vga_320x400_unchained_image.asm</td><td>zobrazení rastrového obrázku v&nbsp;nestandardním režimu 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>78</td><td>vga_vertical_scroll_1.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm</a></td></tr>
<tr><td>79</td><td>vga_vertical_scroll_2.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm</a></td></tr>
<tr><td>80</td><td>vga_split_screen_1.asm</td><td>režim split-screen a scrolling, nefunční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm</a></td></tr>
<tr><td>81</td><td>vga_split_screen_2.asm</td><td>režim split-screen a scrolling, plně funkční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm</a></td></tr>
<tr><td>82</td><td>vga_horizontal_scroll_1.asm</td><td>horizontální scrolling bez rozšíření počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm</a></td></tr>
<tr><td>83</td><td>vga_horizontal_scroll_2.asm</td><td>horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm</a></td></tr>
<tr><td>84</td><td>vga_horizontal_scroll_3.asm</td><td>jemný horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>85</td><td>vga_320x240_image.asm</td><td>nastavení grafického režimu Mode-X, načtení a vykreslení obrázku, scrolling</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>86</td><td>io.asm</td><td>knihovna maker pro I/O operace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm</a></td></tr>
<tr><td>87</td><td>vga_lib.asm</td><td>knihovna maker a podprogramů pro programování karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm</a></td></tr>
<tr><td>88</td><td>vga_320x240_lib.asm</td><td>nastavení grafického režimu Mode-X, tentokrát knihovními funkcemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>89</td><td>vga_bitblt_1.asm</td><td>první (naivní) implementace operace <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm</a></td></tr>
<tr><td>90</td><td>vga_bitblt_2.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm</a></td></tr>
<tr><td>91</td><td>vga_bitblt_3.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro čtení i zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm</a></td></tr>
<tr><td>92</td><td>vga_bitblt_4.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace makry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm</a></td></tr>
<tr><td>93</td><td>vga_bitblt_5.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace podprogramem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>94</td><td>vga_bitblt_rotate.asm</td><td>zápisový režim s&nbsp;rotací bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm</a></td></tr>
<tr><td>95</td><td>vga_bitblt_fast.asm</td><td>rychlá korektní 32bitová operace typu <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm</a></td></tr>
<tr><td>96</td><td>vga_320x400_bitblt_1.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (neúplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm</a></td></tr>
<tr><td>97</td><td>vga_320x400_bitblt_2.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (úplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm</a></td></tr>
<tr><td>98</td><td>vga_write_modes_1.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis bez úpravy latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm</a></td></tr>
<tr><td>99</td><td>vga_write_modes_2.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis s&nbsp;modifikací latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm</a></td></tr>
<tr><td>100</td><td>vga_write_modes_3.asm</td><td>volitelné zápisové režimy grafické karty VGA, cílená modifikace latche vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>101</td><td>instruction_jump.asm</td><td>použití instrukce <strong>JMP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jump.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jump.asm</a></td></tr>
<tr><td>102</td><td>instruction_jnz.asm</td><td>použití instrukce <strong>JNZ</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jnz.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jnz.asm</a></td></tr>
<tr><td>103</td><td>instruction_jz_jmp.asm</td><td>použití instrukcí <strong>JZ</strong> a <strong>JMP</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jz_jmp.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jz_jmp.asm</a></td></tr>
<tr><td>104</td><td>instruction_loop.asm</td><td>použití instrukce <strong>LOOP</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_loop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>105</td><td>instruction_template.asm</td><td>šablona všech následujících demonstračních příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_template.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_template.asm</a></td></tr>
<tr><td>106</td><td>instruction_print_hex.asm</td><td>tisk osmibitové hexadecimální hodnoty</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_print_hex.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_print_hex.asm</a></td></tr>
<tr><td>107</td><td>instruction_xlat.asm</td><td>využití instrukce <strong>XLAT</strong> pro získání tisknutelné hexadecimální cifry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_xlat.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_xlat.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>108</td><td>instruction_daa.asm</td><td>operace součtu s&nbsp;využitím binární i BCD aritmetiky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa.asm</a></td></tr>
<tr><td>109</td><td>instruction_daa_sub.asm</td><td>instrukce <strong>DAA</strong> po provedení operace rozdílu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa_sub.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa_sub.asm</a></td></tr>
<tr><td>110</td><td>instruction_das.asm</td><td>instrukce <strong>DAS</strong> po provedení operace rozdílu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_das.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_das.asm</a></td></tr>
<tr><td>111</td><td>instruction_aaa.asm</td><td>korekce výsledku na jedinou BCD cifru operací <strong>AAA</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aaa.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aaa.asm</a></td></tr>
<tr><td>112</td><td>instruction_mul.asm</td><td>ukázka výpočtu součinu dvou osmibitových hodnot</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_mul.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_mul.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>VESA BIOS Extensions<br />
<a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions">https://en.wikipedia.org/wiki/VESA_BIOS_Extensions</a>
</li>

<li>Video Electronics Standards Association<br />
<a href="https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association">https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association</a>
</li>

<li>DJGPP (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/DJGPP">https://cs.wikipedia.org/wiki/DJGPP</a>
</li>

<li>DJGPP home page<br />
<a href="http://www.delorie.com/djgpp/">http://www.delorie.com/djgpp/</a>
</li>

<li>DJGPP Zip File Picker<br />
<a href="http://www.delorie.com/djgpp/zip-picker.html">http://www.delorie.com/djgpp/zip-picker.html</a>
</li>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

<li>Programmer's Guide to Yamaha YMF 262/OPL3 FM Music Synthesizer<br />
<a href="https://moddingwiki.shikadi.net/wiki/OPL_chip">https://moddingwiki.shikadi.net/wiki/OPL_chip</a>
</li>

<li>Does anybody understand how OPL2 percussion mode works?<br />
<a href="https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/">https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/</a>
</li>

<li>Yamaha YMF262 OPL3 music - MoonDriver for OPL3 DEMO [Oscilloscope View]<br />
<a href="https://www.youtube.com/watch?v=a7I-QmrkAak">https://www.youtube.com/watch?v=a7I-QmrkAak</a>
</li>

<li>Yamaha OPL vs OPL2 vs OPL3 comparison<br />
<a href="https://www.youtube.com/watch?v=5knetge5Gs0">https://www.youtube.com/watch?v=5knetge5Gs0</a>
</li>

<li>OPL3 Music Crockett's Theme<br />
<a href="https://www.youtube.com/watch?v=HXS008pkgSQ">https://www.youtube.com/watch?v=HXS008pkgSQ</a>
</li>

<li>Bad Apple (Adlib Tracker - OPL3)<br />
<a href="https://www.youtube.com/watch?v=2lEPH6Y3Luo">https://www.youtube.com/watch?v=2lEPH6Y3Luo</a>
</li>

<li>FM Synthesis Chips, Codecs and DACs<br />
<a href="https://www.dosdays.co.uk/topics/fm_synthesizers.php">https://www.dosdays.co.uk/topics/fm_synthesizers.php</a>
</li>

<li>The Zen Challenge - YMF262 OPL3 Original (For an upcoming game)<br />
<a href="https://www.youtube.com/watch?v=6JlFIFz1CFY">https://www.youtube.com/watch?v=6JlFIFz1CFY</a>
</li>

<li>[adlib tracker II techno music - opl3] orbit around alpha andromedae I<br />
<a href="https://www.youtube.com/watch?v=YqxJCu_WFuA">https://www.youtube.com/watch?v=YqxJCu_WFuA</a>
</li>

<li>[adlib tracker 2 music - opl3 techno] hybridisation process on procyon-ii<br />
<a href="https://www.youtube.com/watch?v=daSV5mN0sJ4">https://www.youtube.com/watch?v=daSV5mN0sJ4</a>
</li>

<li>Hyper Duel - Black Rain (YMF262 OPL3 Cover)<br />
<a href="https://www.youtube.com/watch?v=pu_mzRRq8Ho">https://www.youtube.com/watch?v=pu_mzRRq8Ho</a>
</li>

<li>IBM 5155-5160 Technical Reference<br />
<a href="https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf">https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf</a>
</li>

<li>a ymf262/opl3+pc speaker thing i made<br />
<a href="https://www.youtube.com/watch?v=E-Mx0lEmnZ0">https://www.youtube.com/watch?v=E-Mx0lEmnZ0</a>
</li>

<li>[OPL3] Like a Thunder<br />
<a href="https://www.youtube.com/watch?v=MHf06AGr8SU">https://www.youtube.com/watch?v=MHf06AGr8SU</a>
</li>

<li>(PC SPEAKER) bad apple<br />
<a href="https://www.youtube.com/watch?v=LezmKIIHyUg">https://www.youtube.com/watch?v=LezmKIIHyUg</a>
</li>

<li>Powering devices from PC parallel port<br />
<a href="http://www.epanorama.net/circuits/lptpower.html">http://www.epanorama.net/circuits/lptpower.html</a>
</li>

<li>Magic Mushroom (demo pro PC s DOSem)<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar">http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar</a>
</li>

<li>Píseň Magic Mushroom - originál<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3</a>
</li>

<li>Píseň Magic Mushroom - hráno na PC Speakeru<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3</a>
</li>

<li>Pulse Width Modulation (PWM) Simulation Example<br />
<a href="http://decibel.ni.com/content/docs/DOC-4599">http://decibel.ni.com/content/docs/DOC-4599</a>
</li>

<li>Resistor/Pulse Width Modulation DAC<br />
<a href="http://www.k9spud.com/traxmod/pwmdac.php">http://www.k9spud.com/traxmod/pwmdac.php</a>
</li>

<li>Class D Amplifier<br />
<a href="http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D">http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D</a>
</li>

<li>Covox Speech Thing / Disney Sound Source (1986)<br />
<a href="http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5">http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5</a>
</li>

<li>Covox Digital-Analog Converter (Rusky, obsahuje schémata)<br />
<a href="http://phantom.sannata.ru/konkurs/netskater002.shtml">http://phantom.sannata.ru/konkurs/netskater002.shtml</a>
</li>

<li>PC-GPE on the Web<br />
<a href="http://bespin.org/~qz/pc-gpe/">http://bespin.org/~qz/pc-gpe/</a>
</li>

<li>Keyboard Synthesizer<br />
<a href="http://www.solarnavigator.net/music/instruments/keyboards.htm">http://www.solarnavigator.net/music/instruments/keyboards.htm</a>
</li>

<li>FMS - Fully Modular Synthesizer<br />
<a href="http://fmsynth.sourceforge.net/">http://fmsynth.sourceforge.net/</a>
</li>

<li>Javasynth<br />
<a href="http://javasynth.sourceforge.net/">http://javasynth.sourceforge.net/</a>
</li>

<li>Software Sound Synthesis &amp; Music Composition Packages<br />
<a href="http://www.linux-sound.org/swss.html">http://www.linux-sound.org/swss.html</a>
</li>

<li>Mx44.1 Download Page (software synthesizer for linux)<br />
<a href="http://hem.passagen.se/ja_linux/">http://hem.passagen.se/ja_linux/</a>
</li>

<li>Software synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Software_synthesizer">http://en.wikipedia.org/wiki/Software_synthesizer</a>
</li>

<li>Frequency modulation synthesis<br />
<a href="http://en.wikipedia.org/wiki/Frequency_modulation_synthesis">http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</a>
</li>

<li>Yamaha DX7<br />
<a href="http://en.wikipedia.org/wiki/Yamaha_DX7">http://en.wikipedia.org/wiki/Yamaha_DX7</a>
</li>

<li>Wave of the Future<br />
<a href="http://www.wired.com/wired/archive/2.03/waveguides_pr.html">http://www.wired.com/wired/archive/2.03/waveguides_pr.html</a>
</li>

<li>Analog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Analog_synthesizer">http://en.wikipedia.org/wiki/Analog_synthesizer</a>
</li>

<li>Minimoog<br />
<a href="http://en.wikipedia.org/wiki/Minimoog">http://en.wikipedia.org/wiki/Minimoog</a>
</li>

<li>Moog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Moog_synthesizer">http://en.wikipedia.org/wiki/Moog_synthesizer</a>
</li>

<li>Tutorial for Frequency Modulation Synthesis<br />
<a href="http://www.sfu.ca/~truax/fmtut.html">http://www.sfu.ca/~truax/fmtut.html</a>
</li>

<li>An Introduction To FM<br />
<a href="http://ccrma.stanford.edu/software/snd/snd/fm.html">http://ccrma.stanford.edu/software/snd/snd/fm.html</a>
</li>

<li>John Chowning<br />
<a href="http://en.wikipedia.org/wiki/John_Chowning">http://en.wikipedia.org/wiki/John_Chowning</a>
</li>

<li>I'm Impressed, Adlib Music is AMAZING!<br />
<a href="https://www.youtube.com/watch?v=PJNjQYp1ras">https://www.youtube.com/watch?v=PJNjQYp1ras</a>
</li>

<li>Milinda- Diode Milliampere ( OPL3 )<br />
<a href="https://www.youtube.com/watch?v=oNhazT5HG0E">https://www.youtube.com/watch?v=oNhazT5HG0E</a>
</li>

<li>Dune 2 - Roland MT-32 Soundtrack <br />
<a href="https://www.youtube.com/watch?v=kQADZeB-z8M">https://www.youtube.com/watch?v=kQADZeB-z8M</a>
</li>

<li>Interrupts<br />
<a href="https://wiki.osdev.org/Interrupts#Types_of_Interrupts">https://wiki.osdev.org/Interrupts#Types_of_Interrupts</a>
</li>

<li>Assembly8086SoundBlasterDmaSingleCycleMode<br />
<a href="https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm">https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm</a>
</li>

<li>Interrupts in 8086 microprocessor<br />
<a href="https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/">https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/</a>
</li>

<li>Interrupt Structure of 8086<br />
<a href="https://www.eeeguide.com/interrupt-structure-of-8086/">https://www.eeeguide.com/interrupt-structure-of-8086/</a>
</li>

<li>A20 line<br />
<a href="https://en.wikipedia.org/wiki/A20_line">https://en.wikipedia.org/wiki/A20_line</a>
</li>

<li>Extended memory<br />
<a href="https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)">https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)</a>
</li>

<li>Expanded memory<br />
<a href="https://en.wikipedia.org/wiki/Expanded_memory">https://en.wikipedia.org/wiki/Expanded_memory</a>
</li>

<li>Protected mode<br />
<a href="https://en.wikipedia.org/wiki/Protected_mode">https://en.wikipedia.org/wiki/Protected_mode</a>
</li>

<li>Virtual 8086 mode<br />
<a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">https://en.wikipedia.org/wiki/Virtual_8086_mode</a>
</li>

<li>Unreal mode<br />
<a href="https://en.wikipedia.org/wiki/Unreal_mode">https://en.wikipedia.org/wiki/Unreal_mode</a>
</li>

<li>DOS memory management<br />
<a href="https://en.wikipedia.org/wiki/DOS_memory_management">https://en.wikipedia.org/wiki/DOS_memory_management</a>
</li>

<li>Upper memory area<br />
<a href="https://en.wikipedia.org/wiki/Upper_memory_area">https://en.wikipedia.org/wiki/Upper_memory_area</a>
</li>

<li>Removing the Mystery from SEGMENT : OFFSET Addressing<br />
<a href="https://thestarman.pcministry.com/asm/debug/Segments.html">https://thestarman.pcministry.com/asm/debug/Segments.html</a>
</li>

<li>Segment descriptor<br />
<a href="https://en.wikipedia.org/wiki/Segment_descriptor">https://en.wikipedia.org/wiki/Segment_descriptor</a>
</li>

<li>When using a 32-bit register to address memory in the real mode, contents of the register must never exceed 0000FFFFH. Why?<br />
<a href="https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the">https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the</a>
</li>

<li>A Brief History of Unreal Mode<br />
<a href="https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/">https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/</a>
</li>

<li>Segment Limits<br />
<a href="https://wiki.osdev.org/Segment_Limits">https://wiki.osdev.org/Segment_Limits</a>
</li>

<li>How do 32 bit addresses in real mode work?<br />
<a href="https://forum.osdev.org/viewtopic.php?t=30642">https://forum.osdev.org/viewtopic.php?t=30642</a>
</li>

<li>The LOADALL Instruction by Robert Collins<br />
<a href="https://www.rcollins.org/articles/loadall/tspec_a3_doc.html">https://www.rcollins.org/articles/loadall/tspec_a3_doc.html</a>
</li>

<li>How do you put a 286 in Protected Mode?<br />
<a href="https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode">https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode</a>
</li>

<li>Control register<br />
<a href="https://en.wikipedia.org/wiki/Control_register">https://en.wikipedia.org/wiki/Control_register</a>
</li>

<li>CPU Registers x86<br />
<a href="https://wiki.osdev.org/CPU_Registers_x86">https://wiki.osdev.org/CPU_Registers_x86</a>
</li>

<li>x86 Assembly/Protected Mode<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode">https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode</a>
</li>

<li>MSW: Machine Status Word<br />
<a href="https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html">https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html</a>
</li>

<li>80x87 Floating Point Opcodes<br />
<a href="http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html">http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html</a>
</li>

<li>Page Translation<br />
<a href="https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm">https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm</a>
</li>

<li>80386 Paging and Segmenation<br />
<a href="https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation">https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation</a>
</li>

<li>80386 Memory Management<br />
<a href="https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html">https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html</a>
</li>

<li>DOSEMU<br />
<a href="http://www.dosemu.org/">http://www.dosemu.org/</a>
</li>

<li>Intel 80386, a revolutionary CPU<br />
<a href="https://www.xtof.info/intel80386.html">https://www.xtof.info/intel80386.html</a>
</li>

<li>PAI Unit 3 Paging in 80386 Microporcessor<br />
<a href="https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor">https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor</a>
</li>

<li>64 Terabytes of virtual memory for 32-bit x86 using segmentation: how?<br />
<a href="https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how">https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how</a>
</li>

<li>Pi in the Pentium: reverse-engineering the constants in its floating-point unit<br />
<a href="http://www.righto.com/2025/01/pentium-floating-point-ROM.html">http://www.righto.com/2025/01/pentium-floating-point-ROM.html</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>8087 Numeric Data Processor<br />
<a href="https://www.eeeguide.com/8087-numeric-data-processor/">https://www.eeeguide.com/8087-numeric-data-processor/</a>
</li>

<li>Data Types and Instruction Set of 8087 co-processor<br />
<a href="https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/">https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/</a>
</li>

<li>8087 instruction set and examples<br />
<a href="https://studylib.net/doc/5625221/8087-instruction-set-and-examples">https://studylib.net/doc/5625221/8087-instruction-set-and-examples</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Grafické karty a grafické akcelerátory (14)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/</a>
</li>

<li>Grafické karty a grafické akcelerátory (15)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/</a>
</li>

<li>Grafické karty a grafické akcelerátory (16)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/</a>
</li>

<li>VESA Video Modes<br />
<a href="https://wiki.osdev.org/VESA_Video_Modes">https://wiki.osdev.org/VESA_Video_Modes</a>
</li>

<li>Introduction to VESA programming<br />
<a href="http://www.monstersoft.com/tutorial1/VESA_intro.html">http://www.monstersoft.com/tutorial1/VESA_intro.html</a>
</li>

<li>Guide: VBE 2.0 graphics modes<br />
<a href="https://delorie.com/djgpp/doc/ug/graphics/vbe20.html">https://delorie.com/djgpp/doc/ug/graphics/vbe20.html</a>
</li>

<li>NASM instruction list<br />
<a href="https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html">https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html</a>
</li>

<li>BitBlt function (wingdi.h)<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt">https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt</a>
</li>

<li>SetDIBitsToDevice function (wingdi.h)<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdibitstodevice">https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdibitstodevice</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

