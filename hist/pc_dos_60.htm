<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">2. Detekce podpory instrukce <strong>RDRAND</strong> mikroprocesorem</a></p>
<p><a href="#k03">3. První demonstrační příklad: zjištění, zda mikroprocesor podporuje instrukci RDRAND</a></p>
<p><a href="#k04">4. Výsledky získané pro čip Intel Core i7-1270P</a></p>
<p><a href="#k05">*** 5. Přečtení náhodné hodnoty instrukcí <strong>RDRAND</strong></a></p>
<p><a href="#k06">*** 6. Druhý demonstrační příklad &ndash; realizace volání instrukce <strong>RDRAND</strong> v&nbsp;assembleru</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">9. Vestavěné funkce v&nbsp;GCC umožňující volání instrukce <strong>RDRAND</strong></a></p>
<p><a href="#k10">10. Demonstrační příklad &ndash; přečtení a výpis sekvence deseti náhodných 32bitových hodnot</a></p>
<p><a href="#k11">*** 11. Způsob překladu demonstračního příkladu do assembleru</a></p>
<p><a href="#k12">*** 12. Jak kvalitní je sekvence náhodných čísel získaná opakovaným voláním <strong>RDRND</strong>?</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Detekce podpory instrukce <strong>RDRAND</strong> mikroprocesorem</h2>

<p>Společně s&nbsp;přidáváním dalších rozšiřujících instrukčních sad pro
platformu 80x86 se objevila nutnost zjištění, zda daný mikroprocesor nějakou
rozšiřující instrukční sadu podporuje či nikoli. Pro tento účel se používá
instrukce <strong>CPUID</strong>, s&nbsp;níž jsme se již v&nbsp;tomto seriálu
několikrát setkali. Tuto instrukci použijeme pro získání informací kategorie
číslo 0 a 1. O kterou kategorii se má jednat zadáme v&nbsp;registru
<strong>EAX</strong> před zavoláním <strong>CPUID</strong>:</p>

<pre>
        mov eax, kategorie
        cpuid                        <i>; naplneni EDX, ECX a EBX</i>
</pre>

<p>Pro kategorii 0 se ve trojici registrů <strong>EBX</strong>,
<strong>EDX</strong> a <strong>ECX</strong> (v&nbsp;tomto pořadí) vrátí
dvanáctiznakový řetězec s&nbsp;identifikací mikroprocesoru. Současně se
v&nbsp;registru <strong>EAX</strong> vrátí číslo nejvyšší dostupné
kategorie.</p>

<p>Z&nbsp;pohledu podpory či nepodpory instrukce <strong>RDRAND</strong> je
důležitá první kategorie. V&nbsp;registru <strong>ECX</strong> se vrátí bitová
pole, z&nbsp;nichž je možné vyčíst, která instrukční sada je podporována a
která naopak nikoli. Konkrétně podpora instrukce <strong>RDRAND</strong> je
uložena v&nbsp;bitu číslo 30. Následuje příklad použití <strong>CPUID</strong>
pro rozeskok na základě (ne)podpory instrukce <strong>RDRAND</strong>:</p>

<pre>
        mov eax, 1                   <i>; prvni kategorie</i>
        cpuid                        <i>; naplneni EDX a ECX</i>
        bt ecx, 30                   <i>; test bitu cislo 30: podpora RDRAND</i>
        jnc rdrand_not_supported
        print_string  rdrand_supported, rdrand_supported_length
<strong>rdrand_not_supported</strong>:
        ...
        ...
        ...
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad: zjištění, zda mikroprocesor podporuje instrukci RDRAND</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu si ověříme, jestli
mikroprocesor skutečně podporuje instrukci RDRAND.  Použijeme k&nbsp;tomu
postup popsaný <a href="#k02">v&nbsp;předchozí kapitole</a>, tj.&nbsp;analýzu
bitových polí vracených instrukcí <strong>CPUID</strong>. Nejdříve se podívejme
na zdrojový kód příkladu a posléze si ukážeme výsledky pro konkrétní
mikroprocesor:</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp; 
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db ' '
         hex_message_length equ $ - hex_message
&nbsp;
<strong>rdrand_supported</strong>:
         db 10, "RDRAND supported"
         rdrand_supported_length equ $ - rdrand_supported
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
id_string: resb 8
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        <i>; ziskani indexu nejvyssi volatelne funkce CPUID</i>
        xor eax, eax                 <i>; nulta kategorie</i>
        cpuid
        mov     edx, eax             <i>; hodnota, ktera se ma vytisknout</i>
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        <i>; test podpory RDRAND</i>
        mov eax, 1                   <i>; prvni kategorie</i>
        cpuid
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        <i>; vypis CPU ID</i>
        xor eax, eax                 <i>; nulta kategorie</i>
        cpuid
        mov [id_string], ebx         <i>; prvni ctyri znaky ID</i>
        mov [id_string+4], edx       <i>; dalsi ctyri znaky ID</i>
        mov [id_string+8], ecx       <i>; posledni ctyri znaky ID</i>
        print_string id_string, 12   <i>; tisk 12 znaku CPU ID</i>
&nbsp;
        mov eax, 1                   <i>; prvni kategorie</i>
        cpuid                        <i>; naplneni EDX a ECX</i>
        bt ecx, 30                   <i>; test bitu cislo 30: podpora RDRAND</i>
        jnc rdrand_not_supported
        print_string  rdrand_supported, rdrand_supported_length
<strong>rdrand_not_supported</strong>:
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výsledky získané pro čip Intel Core i7-1270P</h2>

<p>V&nbsp;mém konkrétním případě (Intel Core i7-1270P) se po překladu a
spuštění tohoto demonstračního příkladu vypíšou následující dva řádky:</p>

<pre>
00000020 BFEBFBFF GenuineIntel
RDRAND supported
</pre>

<p>Na prvním řádku je hexadecimálně zobrazen nejvyšší index volatelné funkce
CPU ID (0x20), dále bitové pole s&nbsp;první kategorií podporovaných vlastností
a poté již obsah registrů EBX, EDX a ECX s&nbsp;dvanáctiznakovou identifikací
výrobce a (zhruba) modelu. Na druhém řádku se zobrazí informace o tom, že
instrukce <strong>RDRAND</strong> je skutečně podporována.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Přečtení náhodné hodnoty instrukcí <strong>RDRAND</strong></h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý demonstrační příklad &ndash; realizace volání instrukce <strong>RDRAND</strong> v&nbsp;assembleru</h2>

<p></p>

<pre>
[bits 32]
&nbsp;
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp; 
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        rdrand  edx                  <i>; ziskat pseudonahodnou hodnotu</i>
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp; 
&nbsp; 
%include "hex2string.asm"
</pre>

<pre>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
[bits 32]
&nbsp;
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        mov     ecx, 10              <i>; pocitadlo smycky</i>
<strong>rand</strong>:
        push    ecx                  <i>; uchovat hodnotu pocitadla</i>
&nbsp;
        rdrand  edx                  <i>; ziskat pseudonahodnou hodnotu</i>
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        pop     ecx                  <i>; obnovit hodnotu pocitadla</i>
        loop    rand                 <i>; opakovat smycku</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p></p>

<pre>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vestavěné funkce v&nbsp;GCC umožňující volání instrukce <strong>RDRAND</strong></h2>

<p>Překladač GCC (a ovšem i některé další překladače céčka) podporují zápis
programů, které interně volají instrukci <strong>RDRAND</strong>, a to bez
toho, aby bylo nutné používat assembler. Konkrétně v&nbsp;GCC je dostupná
trojice vestavěných funkcí, které po svém zavolání naplní obsah paměťového
místa, jehož adresa je uvedena v&nbsp;jediné parametru funkci.
&bdquo;Pravou&ldquo; návratovou hodnotou je informace o tom, zda se volání
podařilo či nikoli:</p>

<table>
<tr><th>#</th><th>Typ návratové hodnoty</th><th>Jméno vestavěné funkce</th><th>Parametr</th></tr>
<tr><td>1</td><td>unsigned int</td><td>__builtin_ia32_rdrand16_step</td><td>unsigned short *</td></tr>
<tr><td>2</td><td>unsigned int</td><td>__builtin_ia32_rdrand32_step</td><td>unsigned int *</td></tr>
<tr><td>3</td><td>unsigned int</td><td>__builtin_ia32_rdrand64_step</td><td>unsigned long long *</td></tr>
</table>

<p>Pozor si ovšem musíme dát na to, že výše uvedenou trojici funkcí je možné
volat pouze v&nbsp;případě, že při překladu (nikoli až při linkinku) použijeme
přepínač <strong>-mrdrnd</strong>. V&nbsp;případě, že bude tento přepínač
použit, povede volání libovolné z&nbsp;těchto funkcí k&nbsp;vygenerování
strojového kódu s&nbsp;instrukcí <strong>RDRAND</strong>:</p>

<pre>
$ <strong>gcc --target-help |grep mrdrnd</strong>
&nbsp;
-mrdrnd                     Support RDRND built-in functions and code generation.
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Demonstrační příklad &ndash; přečtení a výpis sekvence deseti náhodných 32bitových hodnot</h2>

<p>Zatímco demonstrační příklady z&nbsp;první poloviny článku byly psané
v&nbsp;assembleru mikroprocesorů s&nbsp;architekturou x86-64, budou další
příklad psány v&nbsp;céčku (konkrétně v&nbsp;ANSI C, ale to je již detail).
Následující příklad se po svém překladu a spuštění pokusí přečíst deset
náhodných 32bitových hodnot a ty následně vypíše na terminál. Současně vypíše i
příznak úspěšnosti či naopak neúspěšnosti přečtení těchto hodnot. Pokud je
instrukce <strong>RDRND</strong> podporována, mělo by být její volání úspěšné
(nevyžaduje žádná privilegia):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
int <strong>main</strong>(void) {
    int success;
    uint32_t int random_value;
    int i;
&nbsp;
    for (i=0; i&lt;10; i++) {
        success = <u>__builtin_ia32_rdrand32_step(&amp;random_value)</u>;
        printf("%d %x\n", success, random_value);
    }
    return 0;
}
</pre>

<p>V&nbsp;případě, že při překladu neuvedeme přepínač <strong>-mrdrnd</strong>,
vypíše překladač chybu, protože nebude vestavěnou funkci
<strong>__builtin_ia32_rdrand32_step</strong> podporovat (viz předchozí
kapitolu). Toto chování si můžeme velmi snadno ověřit:</p>

<pre>
$ <strong>gcc rnrand_read.c</strong>
</pre>

<p>Výsledek pokusu o překlad našeho demonstračního příkladu dopadne
neslavně:</p>

<pre>
rnrand_read.c: In function ‘main’:
rnrand_read.c:9:19: error: implicit declaration of function ‘__builtin_ia32_rdrand32_step’; did you mean ‘__builtin_ia32_rdtscp’? [-Wimplicit-function-declaration]
    9 |         success = __builtin_ia32_rdrand32_step(&amp;random_value);
      |                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                   __builtin_ia32_rdtscp
</pre>

<p>Korektní překlad bude realizován pouze po použití přepínače
<strong>-mrdrnd</strong>. Vestavěné funkce budou dostupné v&nbsp;libovolné
verze jazyka C, a to včetně ANSI C/C89:</p>

<pre>
$ <strong>gcc -mrdrnd -ansi -Wall -Werror rnrand_read.c</strong>
</pre>

<p>Výsledek by mohl vypadat následovně:</p>

<pre>
1 d49a35f7
1 563c3fd0
1 9c3fe577
1 34ee6930
1 68c498ee
1 1d38cc2f
1 244349d6
1 50f16a09
1 1324b913
1 af34d82c
</pre>

<p><div class="rs-tip-major">Poznámka: díky tomu, že je generátor náhodných
čísel vždy znovu inicializován, je prakticky jisté, že nikdy nezískáte výše
uvedenou sekvenci hodnot.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Způsob překladu demonstračního příkladu do assembleru</h2>

<p>Ověřme si ještě, zda překladač GCC skutečně převedl volání vestavěných
funkcí <strong>__builtin_ia32_rdrandXX_step</strong> na instrukci
<strong>RDRND</strong>. Toto ověření je vhodné provést v&nbsp;případě, že se
náhodné hodnoty budou využívat v&nbsp;kryptografických algoritmech,
v&nbsp;online hrách (kasinech) atd. Provedeme překlad do assembleru a pro větší
čitelnost si vynutíme vygenerování assemblerovského zdrojového kódu založeného
na syntaxi používané firmou Intel:</p>

<pre>
$ <strong>gcc -mrdrnd -S -masm=intel -Og rdrand_read.c</strong>
</pre>

<p>Ve výsledném kódu je volání instrukce <strong>RDRND</strong> podtrženo:</p>

<pre>
        .file   "rdrand_read.c"
        .intel_syntax noprefix
        .text
        .section        .rodata.str1.1,"aMS",@progbits,1
.LC0:
        .string "%d %x\n"
        .text
        .globl  main
        .type   main, @function
<strong>main</strong>:
.LFB11:
        .cfi_startproc
        push    rbx
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        sub     rsp, 16
        .cfi_def_cfa_offset 32
        mov     ebx, 0
        jmp     .L2
.L3:
        <u>rdrand  esi</u>
        mov     DWORD PTR [rsp+12], esi
        mov     eax, 1
        cmovc   esi, eax
        mov     edx, DWORD PTR [rsp+12]
        mov     edi, OFFSET FLAT:.LC0
        mov     eax, 0
        call    printf
        add     ebx, 1
.L2:
        cmp     ebx, 9
        jle     .L3
        mov     eax, 0
        add     rsp, 16
        .cfi_def_cfa_offset 16
        pop     rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE11:
        .size   main, .-main
        .ident  "GCC: (GNU) 14.2.1 20240912 (Red Hat 14.2.1-3)"
        .section        .note.GNU-stack,"",@progbits
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Jak kvalitní je sekvence náhodných čísel získaná opakovaným voláním <strong>RDRND</strong>?</h2>

<p></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
int <strong>main</strong>(void) {
    FILE *fout;
&nbsp;
    int success;
    uint32_t random_value;
    int i;
&nbsp;
    fout = fopen("random.bin", "wb");
    if (fout == NULL) {
        perror("fopen");
        return 1;
    }
&nbsp;
    for (i=0; i&lt;10; i++) {
        success = __builtin_ia32_rdrand32_step(&amp;random_value);
        if (success != 1) {
            perror("rdrand32");
            return 2;
        }
        fwrite(&amp;random_value, sizeof(uint32_t), 1, fout);
        if (ferror(fout)) {
            perror("fwrite");
            return 1;
        }
    }
&nbsp;
    fclose(fout);
&nbsp;
    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
    ...
    ...
    ...
    for (i=0; i<1000000; i++) {
        ...
        ...
        ...
    }
    ...
    ...
    ...
</pre>

<pre>
$ <strong>ls -l random.bin</strong>
&nbsp;
-rw-r--r--. 1 ptisnovs ptisnovs 4000000 Aug  8 18:47 random.bin
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
$ <strong>git clone git@github.com:dj-on-github/sp800_22_tests.git</strong>
</pre>

<pre>
$ <strong>./sp800_22_tests.py --help</strong>
</pre>

<pre>
usage: sp800_22_tests.py [-h] [--be] [-t TESTNAME] [--list_tests] [filename]
&nbsp;
Test data for distinguishability form random, using NIST SP800-22Rev1a algorithms.
&nbsp;
positional arguments:
  filename              Filename of binary file to test
&nbsp;
options:
  -h, --help            show this help message and exit
  --be                  Treat data as big endian bits within bytes. Defaults to little endian
  -t TESTNAME, --testname TESTNAME
                        Select the test to run. Defaults to running all tests. Use --list_tests to see the list
  --list_tests          Display the list of tests
</pre>

<pre>
$ <strong>./sp800_22_tests.py --list_tests</strong>
</pre>

<pre>
Tests of Distinguishability from Random
1   : monobit_test
2   : frequency_within_block_test
3   : runs_test
4   : longest_run_ones_in_a_block_test
5   : binary_matrix_rank_test
6   : dft_test
7   : non_overlapping_template_matching_test
8   : overlapping_template_matching_test
9   : maurers_universal_test
10  : linear_complexity_test
11  : serial_test
12  : approximate_entropy_test
13  : cumulative_sums_test
14  : random_excursion_test
15  : random_excursion_variant_test
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<pre>
Tests of Distinguishability from Random
TEST: monobit_test
  Ones count   = 16002474
  Zeroes count = 15997526
  PASS
  P=0.381742010349456
TEST: frequency_within_block_test
  n = 32000000
  N = 99
  M = 323232
  PASS
  P=0.016363453060209376
TEST: runs_test
  prop  0.5000773125
  tau  0.00035355339059327376
  vobs  15997442.0
  PASS
  P=0.36586054912558746
TEST: longest_run_ones_in_a_block_test
  n = 32000000
  K = 6
  M = 10000
  N = 75
  chi_sq = 7.062112789716308
  PASS
  P=0.3151412465525687
TEST: binary_matrix_rank_test
  Number of blocks 31250
  Data bits used: 32000000
  Data bits discarded: 0
  Full Rank Count  =  9002
  Full Rank -1 Count =  18103
  Remainder Count =  4145
  Chi-Square =  0.4486112659932162
  PASS
  P=0.7990708746184348
TEST: dft_test
  N0 = 15200000.000000
  N1 = 15200124.000000
  PASS
  P=0.8405777193396355
TEST: non_overlapping_template_matching_test
  PASS
  P=0.9099065451579921
TEST: overlapping_template_matching_test
  B =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  m =  10
  M =  1062
  N =  968
  K =  5
  model =  [352, 179, 134, 97, 68, 135]
  v[j] =   [580, 141, 101, 56, 47, 43]
  chisq =  6.780899397146134
  PASS
  P=0.23745168802495786
TEST: maurers_universal_test
  sum = 29375620.88424485
  fn = 10.16946589683095
  PASS
  P=0.41030644109319797
TEST: linear_complexity_test
  M =  512
  N =  62500
  K =  6
  chisq =  2.2519091978212007
  P =  0.8951344431090033
  PASS
  P=0.8951344431090033
TEST: serial_test
  psi_sq_m   =  17.469030998647213
  psi_sq_mm1 =  7.197106998413801
  psi_sq_mm2 =  2.348089501261711
  delta1     =  10.271924000233412
  delta2     =  5.422906503081322
  P1         =  0.24645678090722536
  P2         =  0.24658963035192114
  PASS
P=0.24645678090722536
P=0.24658963035192114
TEST: approximate_entropy_test
  n         =  32000000
  m         =  3
  Pattern 1 of 8, count = 3998217
  Pattern 2 of 8, count = 4000588
  Pattern 3 of 8, count = 3999448
  Pattern 4 of 8, count = 3999273
  Pattern 5 of 8, count = 4000588
  Pattern 6 of 8, count = 3998133
  Pattern 7 of 8, count = 3999273
  Pattern 8 of 8, count = 4004480
  phi(3)    = -4.382027
  Pattern 1 of 16, count = 2000148
  Pattern 2 of 16, count = 1998069
  Pattern 3 of 16, count = 2000528
  Pattern 4 of 16, count = 2000060
  Pattern 5 of 16, count = 2000285
  Pattern 6 of 16, count = 1999163
  Pattern 7 of 16, count = 1998244
  Pattern 8 of 16, count = 2001029
  Pattern 9 of 16, count = 1998069
  Pattern 10 of 16, count = 2002519
  Pattern 11 of 16, count = 1998920
  Pattern 12 of 16, count = 1999213
  Pattern 13 of 16, count = 2000303
  Pattern 14 of 16, count = 1998970
  Pattern 15 of 16, count = 2001029
  Pattern 16 of 16, count = 2003451
  phi(3)    = -5.075174
  AppEn(3)  = 0.693147
  ChiSquare =  10.270517456945072
  PASS
  P=0.24655018820637375
TEST: cumulative_sums_test
PASS
  PASS
P=0.30009060907640817
P=0.3654675300008945
TEST: random_excursion_test
J=3795
x = -4  chisq = 2.277509        p = 0.809564 
x = -3  chisq = 21.315877       p = 0.000706  Not Random
x = -2  chisq = 8.381990        p = 0.136402 
x = -1  chisq = 9.269424        p = 0.098788 
x = 1   chisq = 7.581427        p = 0.180863 
x = 2   chisq = 17.648646       p = 0.003421  Not Random
x = 3   chisq = 3.632979        p = 0.603369 
x = 4   chisq = 2.222378        p = 0.817597 
FAIL: Data not random
  FAIL
P=0.8095643977803422
P=0.0007059586033140604
P=0.13640211952704734
P=0.0987883878164268
P=0.18086283358054378
P=0.0034205664260353688
P=0.603368571138448
P=0.8175970567482853
TEST: random_excursion_variant_test
J= 3795
x = -9   count=4344     p = 0.126422 
x = -8   count=4095     p = 0.373945 
x = -7   count=3898     p = 0.742985 
x = -6   count=3822     p = 0.925552 
x = -5   count=3733     p = 0.812487 
x = -4   count=3750     p = 0.845214 
x = -3   count=3918     p = 0.527784 
x = -2   count=4057     p = 0.082514 
x = -1   count=4002     p = 0.017501 
x = 1    count=3696     p = 0.255808 
x = 2    count=3836     p = 0.785847 
x = 3    count=3893     p = 0.614922 
x = 4    count=3778     p = 0.941207 
x = 5    count=3683     p = 0.668269 
x = 6    count=3563     p = 0.422023 
x = 7    count=3464     p = 0.292000 
x = 8    count=3503     p = 0.386820 
x = 9    count=3547     p = 0.489937 
PASS
  PASS
P=0.12642201640045245
P=0.3739447986092539
P=0.7429854218086411
P=0.925551671800892
P=0.812486864855873
P=0.8452142837803289
P=0.5277841063848452
P=0.08251432838963278
P=0.017500678846047855
P=0.25580771506589667
P=0.7858465900792965
P=0.6149217634548362
P=0.9412070171775442
P=0.6682691399315276
P=0.42202260140624953
P=0.2919997884594155
P=0.38681988986649096
P=0.4899371303964931

SUMMARY
-------
monobit_test                             0.381742010349456  PASS
frequency_within_block_test              0.016363453060209376 PASS
runs_test                                0.36586054912558746 PASS
longest_run_ones_in_a_block_test         0.3151412465525687 PASS
binary_matrix_rank_test                  0.7990708746184348 PASS
dft_test                                 0.8405777193396355 PASS
non_overlapping_template_matching_test   0.9099065451579921 PASS
overlapping_template_matching_test       0.23745168802495786 PASS
maurers_universal_test                   0.41030644109319797 PASS
linear_complexity_test                   0.8951344431090033 PASS
serial_test                              0.24645678090722536 PASS
approximate_entropy_test                 0.24655018820637375 PASS
cumulative_sums_test                     0.30009060907640817 PASS
random_excursion_test                    0.0007059586033140604 FAIL
random_excursion_variant_test            0.017500678846047855 PASS
</pre>


<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<pre>
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<pre>
Tests of Distinguishability from Random
TEST: monobit_test
  Ones count   = 16000000
  Zeroes count = 16000000
  PASS
  P=1.0
TEST: frequency_within_block_test
  n = 32000000
  N = 99
  M = 323232
  FAIL
  P=-0.0
TEST: runs_test
  prop  0.5
  tau  0.00035355339059327376
  vobs  2000000.0
  FAIL
  P=0.0
TEST: longest_run_ones_in_a_block_test
  n = 32000000
  K = 6
  M = 10000
  N = 75
  chi_sq = 956.636863823934
  FAIL
  P=2.1338534155678214e-203
TEST: binary_matrix_rank_test
  Number of blocks 31250
  Data bits used: 32000000
  Data bits discarded: 0
  Full Rank Count  =  0
  Full Rank -1 Count =  0
  Remainder Count =  31250
  Chi-Square =  202594.67300884268
  FAIL
  P=0.0
TEST: dft_test
  N0 = 15200000.000000
  N1 = 15999992.000000
  FAIL
  P=0.0
TEST: non_overlapping_template_matching_test
  PASS
  P=0.3400393286365188
TEST: overlapping_template_matching_test
  B =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  m =  10
  M =  1062
  N =  968
  K =  5
  model =  [352, 179, 134, 97, 68, 135]
  v[j] =   [0, 0, 0, 0, 0, 968]
  chisq =  16612.851774452305
  FAIL
  P=0.0
TEST: maurers_universal_test
  sum = 11195581.253397802
  fn = 3.875767671439828
  FAIL
  P=0.0
TEST: linear_complexity_test
  M =  512
  N =  62500
  K =  6
  chisq =  5937308.006143804
  P =  0.0
  FAIL
  P=0.0
TEST: serial_test
  psi_sq_m   =  140000000.0
  psi_sq_mm1 =  67000000.0
  psi_sq_mm2 =  24500000.0
  delta1     =  73000000.0
  delta2     =  30500000.0
  P1         =  0.0
  P2         =  0.0
  FAIL
P=0.0
P=0.0
TEST: approximate_entropy_test
  n         =  32000000
  m         =  3
  Pattern 1 of 8, count = 14000000
  Pattern 2 of 8, count = 1000000
  Pattern 3 of 8, count = 0
  Pattern 4 of 8, count = 1000000
  Pattern 5 of 8, count = 1000000
  Pattern 6 of 8, count = 0
  Pattern 7 of 8, count = 1000000
  Pattern 8 of 8, count = 14000000
  phi(3)    = -3.459146
  Pattern 1 of 16, count = 13000000
  Pattern 2 of 16, count = 1000000
  Pattern 3 of 16, count = 0
  Pattern 4 of 16, count = 1000000
  Pattern 5 of 16, count = 0
  Pattern 6 of 16, count = 0
  Pattern 7 of 16, count = 0
  Pattern 8 of 16, count = 1000000
  Pattern 9 of 16, count = 1000000
  Pattern 10 of 16, count = 0
  Pattern 11 of 16, count = 0
  Pattern 12 of 16, count = 0
  Pattern 13 of 16, count = 1000000
  Pattern 14 of 16, count = 0
  Pattern 15 of 16, count = 1000000
  Pattern 16 of 16, count = 13000000
  phi(3)    = -3.684300
  AppEn(3)  = 0.225154
  ChiSquare =  29951575.685381945
  FAIL
  P=0.0
TEST: cumulative_sums_test
PASS
  PASS
P=1.0000000000000062
P=1.0000000000000062
TEST: random_excursion_test
J=1000001
x = -4  chisq = 142957.285814   p = 0.000000  Not Random
x = -3  chisq = 200048.201968   p = 0.000000  Not Random
x = -2  chisq = 333433.666767   p = 0.000000  Not Random
x = -1  chisq = 999900.999900   p = 0.000000  Not Random
x = 1   chisq = 6999890.999910  p = 0.000000  Not Random
x = 2   chisq = 20322039.298630 p = 0.000000  Not Random
x = 3   chisq = 42289999.000044 p = 0.000000  Not Random
x = 4   chisq = 71992726.737400 p = 0.000000  Not Random
FAIL: Data not random
  FAIL
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
TEST: random_excursion_variant_test
J= 1000001
x = -9   count=0        p = 0.000000  Not Random
x = -8   count=0        p = 0.000000  Not Random
x = -7   count=0        p = 0.000000  Not Random
x = -6   count=0        p = 0.000000  Not Random
x = -5   count=0        p = 0.000000  Not Random
x = -4   count=0        p = 0.000000  Not Random
x = -3   count=0        p = 0.000000  Not Random
x = -2   count=0        p = 0.000000  Not Random
x = -1   count=0        p = 0.000000  Not Random
x = 1    count=2000000  p = 0.000000  Not Random
x = 2    count=2000000  p = 0.000000  Not Random
x = 3    count=2000000  p = 0.000000  Not Random
x = 4    count=2000000  p = 0.000000  Not Random
x = 5    count=2000000  p = 0.000000  Not Random
x = 6    count=2000000  p = 0.000000  Not Random
x = 7    count=2000000  p = 0.000000  Not Random
x = 8    count=2000000  p = 0.000000  Not Random
x = 9    count=2000000  p = 0.000000  Not Random
FAIL: Data not random
  FAIL
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0
P=0.0

SUMMARY
-------
monobit_test                             1.0                PASS
frequency_within_block_test              -0.0               FAIL
runs_test                                0.0                FAIL
longest_run_ones_in_a_block_test         2.1338534155678214e-203 FAIL
binary_matrix_rank_test                  0.0                FAIL
dft_test                                 0.0                FAIL
non_overlapping_template_matching_test   0.3400393286365188 PASS
overlapping_template_matching_test       0.0                FAIL
maurers_universal_test                   0.0                FAIL
linear_complexity_test                   0.0                FAIL
serial_test                              0.0                FAIL
approximate_entropy_test                 0.0                FAIL
cumulative_sums_test                     1.0000000000000062 PASS
random_excursion_test                    0.0                FAIL
random_excursion_variant_test            0.0                FAIL
</pre>


<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C i v&nbsp;assembleru
mikroprocesorů s&nbsp;architekturou x86-64, byly uloženy do Git repositáře,
který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>rdrand_support.asm</td><td>test, jestli je instrukce <strong>RDRAND</strong> mikroprocesorem podporována</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm</a></td></tr>
<tr><td>2</td><td>rdrand_read.asm</td><td>přečtení jedné 32bitové hodnoty instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm</a></td></tr>
<tr><td>3</td><td>rdrand_read_loop.asm</td><td>přečtení sekvence 32bitových hodnot instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>rdrand_read.c</td><td>přečtení náhodné 32bitové hodnoty, realizace s&nbsp;využitím vestavěné funkce GCC</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c</a></td></tr>
<tr><td>5</td><td>rdrand_read.asm</td><td>výsledek překladu předchozího zdrojového kódu do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>rand_gen.c</td><td>vygenerování binárního souboru s&nbsp;pseudonáhodnými 32bitovými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c</a></td></tr>
<tr><td>7</td><td>rdrand_gen.c</td><td>vygenerování binárního souboru s&nbsp;hodnotami vrácenými instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>RDRAND (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RDRAND">https://en.wikipedia.org/wiki/RDRAND</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Other Built-in Functions Provided by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>
</li>

<li>GCC: 6.60 Built-in Functions Specific to Particular Target Machines<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins">https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins</a>
</li>

<li>Stránka projektu Compiler Explorer<br />
<a href="https://godbolt.org/">https://godbolt.org/</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://llvm.org/">https://llvm.org/</a>
</li>

<li>GCC, the GNU Compiler Collection<br />
<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>
</li>

<li>Clang<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Clang: Assembling a Complete Toolchain<br />
<a href="https://clang.llvm.org/docs/Toolchain.html">https://clang.llvm.org/docs/Toolchain.html</a>
</li>

<li>Integer overflow<br />
<a href="https://en.wikipedia.org/wiki/Integer_overflow">https://en.wikipedia.org/wiki/Integer_overflow</a>
</li>

<li>SETcc — Set Byte on Condition<br />
<a href="https://www.felixcloutier.com/x86/setcc">https://www.felixcloutier.com/x86/setcc</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>Undefined behavior (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Undefined_behavior">https://en.wikipedia.org/wiki/Undefined_behavior</a>
</li>

<li>Is signed integer overflow still undefined behavior in C++?<br />
<a href="https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c">https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c</a>
</li>

<li>Allowing signed integer overflows in C/C++<br />
<a href="https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c">https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c</a>
</li>

<li>SXTB, SXTH, SXTW<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html">https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html</a>
</li>

<li>Is there any legitimate use for Intel's RDRAND?<br />
<a href="https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand">https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand</a>
</li>

<li>Intel® Digital Random Number Generator (DRNG) Software Implementation Guide<br />
<a href="https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html">https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html</a>
</li>

<li>Hardware random number generator<br />
<a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">https://en.wikipedia.org/wiki/Hardware_random_number_generator</a>
</li>

<li>Random number generator attack<br />
<a href="https://en.wikipedia.org/wiki/Random_number_generator_attack">https://en.wikipedia.org/wiki/Random_number_generator_attack</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

