<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Generátor náhodných čísel založený na instrukcích RDSEED a RDRAND</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Generátor náhodných čísel založený na instrukcích RDSEED a RDRAND</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V informatice existuje několik oblastí, ve kterých je nutné používat generátory náhodných nebo alespoň pseudonáhodných hodnot. Moderní procesory s architekturou x86-64 pro tento účel nabízí instrukce RDRAND a RDSEED. Dnes si otestujeme vlastnosti první z těchto instrukcí.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Generátor náhodných čísel založený na instrukcích RDSEED a RDRAND</a></p>
<p><a href="#k02">2. Detekce podpory instrukce <strong>RDRAND</strong> mikroprocesorem</a></p>
<p><a href="#k03">3. První demonstrační příklad: zjištění, zda mikroprocesor podporuje instrukci RDRAND</a></p>
<p><a href="#k04">4. Výsledky získané pro čip Intel Core i7-1270P</a></p>
<p><a href="#k05">5. Přečtení náhodné hodnoty instrukcí <strong>RDRAND</strong></a></p>
<p><a href="#k06">6. Druhý demonstrační příklad &ndash; realizace volání instrukce <strong>RDRAND</strong> v&nbsp;assembleru</a></p>
<p><a href="#k07">7. Otestování, že instrukce <strong>RDRAND</strong> pokaždé vrátí odlišnou hodnotu</a></p>
<p><a href="#k08">8. Instrukce <strong>RDRAND</strong> ve vyšších programovacích jazycích</a></p>
<p><a href="#k09">9. Vestavěné funkce v&nbsp;GCC umožňující volání instrukce <strong>RDRAND</strong></a></p>
<p><a href="#k10">10. Demonstrační příklad &ndash; přečtení a výpis sekvence deseti náhodných 32bitových hodnot</a></p>
<p><a href="#k11">11. Způsob překladu demonstračního příkladu do assembleru</a></p>
<p><a href="#k12">12. Jak kvalitní je sekvence náhodných čísel získaná opakovaným voláním <strong>RDRAND</strong>?</a></p>
<p><a href="#k13">13. Program pro vygenerování binárního souboru s&nbsp;(pseudo)náhodným obsahem</a></p>
<p><a href="#k14">14. Vygenerování binárního souboru s&nbsp;jedním milionem 32bitových pseudonáhodných hodnot</a></p>
<p><a href="#k15">15. Projekt s&nbsp;implementací metrik pro otestování (pseudo)náhodných hodnot</a></p>
<p><a href="#k16">16. Otestování hodnot vygenerovaných instrukcí <strong>RDRAND</strong></a></p>
<p><a href="#k17">17. Porovnání výsledků s&nbsp;výsledky deterministického generátoru pseudonáhodných hodnot</a></p>
<p><a href="#k18">18. Příloha: pomocné soubory s&nbsp;makry a subrutinami použitými v&nbsp;příkladech napsaných v&nbsp;assembleru</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Generátor náhodných čísel založený na instrukcích <strong>RDSEED</strong> a <strong>RDRAND</strong></h2>

<p>V&nbsp;informatice existuje hned několik oblastí, ve kterých je nutné
používat generátory náhodných nebo alespoň pseudonáhodných hodnot. Jedná se
například o kryptografii (šifrování, generování klíčů atd.), ale taktéž o
online kasina (nebo podobné hry pro velké množství hráčů založené na náhodě
&ndash; zde kvalitní generátor náhodných čísel pomáhá kasinu, ne hráčům). A
právě zda narážíme na poněkud kuriózní situaci: i když se to nemusí při
každodenní práci s&nbsp;počítači zdát, tato zařízení jsou deterministická a je
tedy relativně složité vypočítat (resp.&nbsp;získat) skutečně náhodné hodnoty.
Proto se velmi často používají deterministické generátory pseudonáhodných
hodnot, což však nemusí být dostatečně silné řešení.</p>

<p>Samozřejmě je možné i v&nbsp;běžném počítači například přečíst šum
z&nbsp;mikrofonního vstupu (apod.), ovšem není úplně snadné dokázat, že
výsledkem budou náhodné hodnoty a ne například výsledek deterministické
činnosti A/D převodníku (existuje hned několik možností zkreslení). Navíc se
jedná o dosti pomalé operace. I z&nbsp;těchto důvodů se do moderních PC
přidávají obvody určené pro získání skutečně náhodných hodnot. Buď se jedná o
různé přídavné karty (s&nbsp;příslušnými ovladači), nebo je možné využít nové
instrukce nazvané <strong>RDSEED</strong> a <strong>RDRAND</strong>, kde prefix
<strong>RD</strong> značí &bdquo;read&ldquo;.</p>

<p>Instrukce <strong>RDSEED</strong> slouží k&nbsp;přečtení skutečně náhodné
sekvence bitů z&nbsp;nějakého vhodného zdroje náhodnosti, který může být
umístěn přímo v&nbsp;mikroprocesoru nebo v&nbsp;čipové sadě. Kvůli přímému
čtení ze zdroje náhodnosti (typicky se využívá senzor tepelného šumu) může být
tato instrukce relativně pomalá; na druhou stranu se však jedná o skutečně
náhodné hodnoty. Vzhledem k&nbsp;tomu, že je k&nbsp;dispozici pouze jediný
senzor tepelného šumu, musí se sdílet mezi všemi jádry mikroprocesoru. To ještě
více přispívá k&nbsp;tomu, že je tato instrukce relativně pomalá.</p>

<p>Druhá instrukce se jmenuje <strong>RDRAND</strong>. Ta přečte &ndash; a to
obecně velmi rychle &ndash; hodnotu vrácenou generátorem <i>pseudonáhodných</i>
hodnot. To se může zdát jako cesta zpět k&nbsp;deterministickým algoritmům, ale
tento generátor je vždy po maximálně 511 cyklech restartován, přičemž je do něj
předáno nové <i>semínko</i> (<i>seed</i>) získané podobně jako u instrukce
<strong>RDSEED</strong> ze specializovaného obvodu. Interně použitý generátor
pseudonáhodných hodnot je poměrně sofistikovaný, takže (společně s&nbsp;tím, že
je periodicky nastavován) splňuje například NIST SP 800-90A.</p>

<p>Dnes se zaměříme na instrukci <strong>RDRAND</strong>, kterou lze zavolat
jak přímo z&nbsp;assembleru, tak i z&nbsp;vyšších programovacích jazyků.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Detekce podpory instrukce <strong>RDRAND</strong> mikroprocesorem</h2>

<p>Společně s&nbsp;přidáváním dalších rozšiřujících instrukčních sad pro
platformu 80x86 se objevila nutnost zjištění, zda daný mikroprocesor nějakou
rozšiřující instrukční sadu podporuje či nikoli. Pro tento účel se používá
instrukce <strong>CPUID</strong>, s&nbsp;níž jsme se již v&nbsp;tomto seriálu
několikrát setkali. Tuto instrukci použijeme pro získání informací kategorie
číslo 0 a 1. O kterou kategorii se má jednat zadáme v&nbsp;registru
<strong>EAX</strong> před zavoláním <strong>CPUID</strong>:</p>

<pre>
        mov eax, kategorie
        cpuid                        <i>; naplneni EDX, ECX a EBX</i>
</pre>

<p>Pro kategorii 0 se ve trojici registrů <strong>EBX</strong>,
<strong>EDX</strong> a <strong>ECX</strong> (v&nbsp;tomto pořadí) vrátí
dvanáctiznakový řetězec s&nbsp;identifikací mikroprocesoru. Současně se
v&nbsp;registru <strong>EAX</strong> vrátí číslo nejvyšší dostupné
kategorie.</p>

<p>Z&nbsp;pohledu podpory či nepodpory instrukce <strong>RDRAND</strong> je
důležitá první kategorie. V&nbsp;registru <strong>ECX</strong> se vrátí bitová
pole, z&nbsp;nichž je možné vyčíst, která instrukční sada je podporována a
která naopak nikoli. Konkrétně podpora instrukce <strong>RDRAND</strong> je
uložena v&nbsp;bitu číslo 30. Následuje příklad použití <strong>CPUID</strong>
pro rozeskok na základě (ne)podpory instrukce <strong>RDRAND</strong>:</p>

<pre>
        mov eax, 1                   <i>; prvni kategorie</i>
        cpuid                        <i>; naplneni EDX a ECX</i>
        bt ecx, 30                   <i>; test bitu cislo 30: podpora RDRAND</i>
        jnc rdrand_not_supported
        print_string  rdrand_supported, rdrand_supported_length
<strong>rdrand_not_supported</strong>:
        ...
        ...
        ...
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad: zjištění, zda mikroprocesor podporuje instrukci RDRAND</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu si ověříme, jestli
mikroprocesor skutečně podporuje instrukci RDRAND.  Použijeme k&nbsp;tomu
postup popsaný <a href="#k02">v&nbsp;předchozí kapitole</a>, tj.&nbsp;analýzu
bitových polí vracených instrukcí <strong>CPUID</strong>. Nejdříve se podívejme
na zdrojový kód příkladu a posléze si ukážeme výsledky pro konkrétní
mikroprocesor:</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp; 
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db ' '
         hex_message_length equ $ - hex_message
&nbsp;
<strong>rdrand_supported</strong>:
         db 10, "RDRAND supported"
         rdrand_supported_length equ $ - rdrand_supported
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
id_string: resb 8
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        <i>; ziskani indexu nejvyssi volatelne funkce CPUID</i>
        xor eax, eax                 <i>; nulta kategorie</i>
        cpuid
        mov     edx, eax             <i>; hodnota, ktera se ma vytisknout</i>
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        <i>; test podpory RDRAND</i>
        mov eax, 1                   <i>; prvni kategorie</i>
        cpuid
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        <i>; vypis CPU ID</i>
        xor eax, eax                 <i>; nulta kategorie</i>
        cpuid
        mov [id_string], ebx         <i>; prvni ctyri znaky ID</i>
        mov [id_string+4], edx       <i>; dalsi ctyri znaky ID</i>
        mov [id_string+8], ecx       <i>; posledni ctyri znaky ID</i>
        print_string id_string, 12   <i>; tisk 12 znaku CPU ID</i>
&nbsp;
        mov eax, 1                   <i>; prvni kategorie</i>
        cpuid                        <i>; naplneni EDX a ECX</i>
        bt ecx, 30                   <i>; test bitu cislo 30: podpora RDRAND</i>
        jnc rdrand_not_supported
        print_string  rdrand_supported, rdrand_supported_length
<strong>rdrand_not_supported</strong>:
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p><div class="rs-tip-major">Poznámka: pro překlad a slinkování se použijí
příkazy:</div></p>

<pre>
$ <strong>nasm -felf rdrand_support.asm -o rdrand_support.o</strong>
&nbsp;
$ <strong>ld -melf_i386 rdrand_support.o -o rdrand_support</strong>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výsledky získané pro čip Intel Core i7-1270P</h2>

<p>V&nbsp;mém konkrétním případě (Intel Core i7-1270P) se po překladu a
spuštění tohoto demonstračního příkladu vypíšou následující dva řádky:</p>

<pre>
00000020 BFEBFBFF GenuineIntel
RDRAND supported
</pre>

<p>Na prvním řádku je hexadecimálně zobrazen nejvyšší index volatelné funkce
CPU ID (0x20), dále bitové pole s&nbsp;první kategorií podporovaných vlastností
a poté již obsah registrů EBX, EDX a ECX s&nbsp;dvanáctiznakovou identifikací
výrobce a (zhruba) modelu. Na druhém řádku se zobrazí informace o tom, že
instrukce <strong>RDRAND</strong> je skutečně podporována.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Přečtení náhodné hodnoty instrukcí <strong>RDRAND</strong></h2>

<p>Samotná instrukce <strong>RDRAND</strong> &ndash; pochopitelně pokud je
podporována &ndash; má tři různé operační kódy, které se odlišují podle toho,
jestli se má vracet šestnáctibitová, 32bitová či dokonce 64bitová hodnota do
zvoleného pracovního registru <strong>r16</strong>, <strong>r32</strong> nebo
<strong>r64</strong>:</p>

<table>
<tr><th>Operační kód</th><th>64bit režim</th><th>32bit režim</th><th>Stručný popis</th></tr>
<tr><td>NFx 0F C7 /6 RDRAND r16        </td><td>ano</td><td>ano</td><td>vrací se šestnáctibitová náhodná hodnota</td></tr>
<tr><td>NFx 0F C7 /6 RDRAND r32        </td><td>ano</td><td>ano</td><td>vrací se 32bitová náhodná hodnota</td></tr>
<tr><td>NFx REX.W + 0F C7 /6 RDRAND r64</td><td>ano</td><td>ne </td><td>vrací se 64bitová náhodná hodnota</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: pokud instrukce proběhne v&nbsp;pořádku
(tedy v&nbsp;případě, že je podporována), nastaví se příznak přetečení
<strong>CF</strong> na jedničku. V&nbsp;opačném případě je registr vynulován a
příznak přetečení se nastaví na nulu. Ostatní příznakové bity
<strong>OF</strong>, <strong>SF</strong>, <strong>ZF</strong>,
<strong>AF</strong> a <strong>PF</strong> jsou vynulovány.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý demonstrační příklad &ndash; realizace volání instrukce <strong>RDRAND</strong> v&nbsp;assembleru</h2>

<p>Základní způsob použití instrukce <strong>RDRAND</strong> je ukázán
v&nbsp;dnešním druhém demonstračním příkladu. Po jeho překladu a spuštění se
instrukcí <strong>RDRAND</strong> vygeneruje 32bitová náhodná hodnota, která se
zapíše do pracovního registru <strong>EDX</strong>. Následně je obsah tohoto
registru vypsán v&nbsp;hexadecimální podobě (maximálně se bude jednat o osm
hexadecimálních cifer) na standardní výstup. Realizace pro operační systém
Linux může vypadat následovně:</p>

<pre>
[bits 32]
&nbsp;
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp; 
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        rdrand  edx                  <i>; ziskat pseudonahodnou hodnotu</i>
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp; 
&nbsp; 
%include "hex2string.asm"
</pre>

<p>Příklad výstupu:</p>

<pre>
E570968D
</pre>

<p><div class="rs-tip-major">Poznámka: pro překlad a slinkování se použijí
příkazy:</div></p>

<pre>
$ <strong>nasm -felf rdrand_read.asm -o rdrand_read.o</strong>
&nbsp;
$ <strong>ld -melf_i386 rdrand_read.o -o rdrand_read</strong>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Otestování, že instrukce <strong>RDRAND</strong> pokaždé vrátí odlišnou hodnotu</h2>

<p><a href="#k01">V&nbsp;úvodní kapitole</a> jsme si řekli, že instrukce
<strong>RDRAND</strong> při každém zavolání vrátí nějakou pseudonáhodnou
hodnotu. Ověřme si tedy, že skutečně nedostáváme konstantní hodnoty. Pro tento
účel zavoláme <strong>RDRAND</strong> v&nbsp;počítané programové smyčce, kterou
založíme na čítači uloženém v&nbsp;registru <strong>ECX</strong> a instrukci
<strong>LOOP</strong>, která sníží hodnotu v&nbsp;čítači a dokud se nedosáhne
nuly, provede se další iterace:</p>

<pre>
        mov     ecx, 10              <i>; pocitadlo smycky</i>
<strong>rand</strong>:
        ... volání RDRAND ...
        ... výpis hexadecimální hodnoty ...
        loop    rand                 <i>; opakovat smycku</i>
</pre>

<p>V&nbsp;praxi bude nutné hodnotu čítače uložit před výpisem hexadecimální
hodnoty, protože tento kód modifikuje obsah registru <strong>ECX</strong>.
Samozřejmě můžeme <strong>ECX</strong> uložit na zásobník a poté ho
obnovit:</p>

<pre>
        mov     ecx, 10              <i>; pocitadlo smycky</i>
<strong>rand</strong>:
        push    ecx                  <i>; uchovat hodnotu pocitadla</i>
        ... volání RDRAND ...
        ... výpis hexadecimální hodnoty ...
        pop     ecx                  <i>; obnovit hodnotu pocitadla</i>
        loop    rand                 <i>; opakovat smycku</i>
</pre>

<p>Úplný zdrojový kód takto upraveného demonstračního příkladu vypadá
následovně:</p>

<pre>
[bits 32]
&nbsp;
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        mov     ecx, 10              <i>; pocitadlo smycky</i>
<strong>rand</strong>:
        push    ecx                  <i>; uchovat hodnotu pocitadla</i>
&nbsp;
        rdrand  edx                  <i>; ziskat pseudonahodnou hodnotu</i>
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        pop     ecx                  <i>; obnovit hodnotu pocitadla</i>
        loop    rand                 <i>; opakovat smycku</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p>Příklad výstupu:</p>

<pre>
B2FF885E
C07C2AA4
61B3E170
FA24F24B
57B51A51
9640F86D
180239A6
9B045C83
E039159D
E01952DD
</pre>

<p><div class="rs-tip-major">Poznámka: při každém spuštění pochopitelně
dostaneme zcela odlišnou sekvenci.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukce <strong>RDRAND</strong> ve vyšších programovacích jazycích</h2>

<p>Prozatím jsme si ukázali, jakým způsobem je možné instrukci
<strong>RDRAND</strong> volat z&nbsp;programů psaných v&nbsp;assembleru.  Jedná
se o neprivilegovanou instrukci, takže její volání je vlastně velmi jednoduché.
Ovšem v&nbsp;assembleru se v&nbsp;současnosti píše jen relativně malé množství
kódu, takže bude zajímavé zjistit, zda a jak lze <strong>RDRAND</strong>
zavolat z&nbsp;vyšších programovacích jazyků, zejména z&nbsp;céčka. Pokud totiž
bude volání z&nbsp;jazyka C podporováno, je tím prakticky zajištěna i podpora
v&nbsp;dalších vyšších programovacích jazycích, které většinou dokážou
s&nbsp;jazykem C poměrně dobře kooperovat (Rust, Python, Go, do jisté míry i
Java atd.). Dále uvedené ukázky jsou odladěny pro GNU C Compiler, ovšem zcela
stejný postup lze aplikovat i v&nbsp;dalších překladačích, zejména
v&nbsp;Clangu.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vestavěné funkce v&nbsp;GCC umožňující volání instrukce <strong>RDRAND</strong></h2>

<p>Překladač GCC (a ovšem i některé další překladače céčka) podporují zápis
programů, které interně volají instrukci <strong>RDRAND</strong>, a to bez
toho, aby bylo nutné používat assembler. Konkrétně v&nbsp;GCC je dostupná
trojice vestavěných funkcí, které po svém zavolání naplní obsah paměťového
místa, jehož adresa je uvedena v&nbsp;jediné parametru funkci.
&bdquo;Pravou&ldquo; návratovou hodnotou je informace o tom, zda se volání
podařilo či nikoli:</p>

<table>
<tr><th>#</th><th>Typ návratové hodnoty</th><th>Jméno vestavěné funkce</th><th>Parametr</th></tr>
<tr><td>1</td><td>unsigned int</td><td>__builtin_ia32_rdrand16_step</td><td>unsigned short *</td></tr>
<tr><td>2</td><td>unsigned int</td><td>__builtin_ia32_rdrand32_step</td><td>unsigned int *</td></tr>
<tr><td>3</td><td>unsigned int</td><td>__builtin_ia32_rdrand64_step</td><td>unsigned long long *</td></tr>
</table>

<p>Pozor si ovšem musíme dát na to, že výše uvedenou trojici funkcí je možné
volat pouze v&nbsp;případě, že při překladu (nikoli až při linkinku) použijeme
přepínač <strong>-mrdrnd</strong>. V&nbsp;případě, že bude tento přepínač
použit, povede volání libovolné z&nbsp;těchto funkcí k&nbsp;vygenerování
strojového kódu s&nbsp;instrukcí <strong>RDRAND</strong>:</p>

<pre>
$ <strong>gcc --target-help |grep mrdrnd</strong>
&nbsp;
-mrdrnd                     Support RDRND built-in functions and code generation.
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Demonstrační příklad &ndash; přečtení a výpis sekvence deseti náhodných 32bitových hodnot</h2>

<p>Zatímco demonstrační příklady z&nbsp;první poloviny článku byly psané
v&nbsp;assembleru mikroprocesorů s&nbsp;architekturou x86-64, budou další
příklad psány v&nbsp;céčku (konkrétně v&nbsp;ANSI C, ale to je již detail).
Následující příklad se po svém překladu a spuštění pokusí přečíst deset
náhodných 32bitových hodnot a ty následně vypíše na terminál. Současně vypíše i
příznak úspěšnosti či naopak neúspěšnosti přečtení těchto hodnot. Pokud je
instrukce <strong>RDRAND</strong> podporována, mělo by být její volání úspěšné
(nevyžaduje žádná privilegia):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
int <strong>main</strong>(void) {
    int success;
    uint32_t int random_value;
    int i;
&nbsp;
    for (i=0; i&lt;10; i++) {
        success = <u>__builtin_ia32_rdrand32_step(&amp;random_value)</u>;
        printf("%d %x\n", success, random_value);
    }
    return 0;
}
</pre>

<p>V&nbsp;případě, že při překladu neuvedeme přepínač <strong>-mrdrnd</strong>,
vypíše překladač chybu, protože nebude vestavěnou funkci
<strong>__builtin_ia32_rdrand32_step</strong> podporovat (viz předchozí
kapitolu). Toto chování si můžeme velmi snadno ověřit:</p>

<pre>
$ <strong>gcc rnrand_read.c</strong>
</pre>

<p>Výsledek pokusu o překlad našeho demonstračního příkladu dopadne
neslavně:</p>

<pre>
rnrand_read.c: In function ‘main’:
rnrand_read.c:9:19: error: implicit declaration of function ‘__builtin_ia32_rdrand32_step’; did you mean ‘__builtin_ia32_rdtscp’? [-Wimplicit-function-declaration]
    9 |         success = __builtin_ia32_rdrand32_step(&amp;random_value);
      |                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                   __builtin_ia32_rdtscp
</pre>

<p>Korektní překlad bude realizován pouze po použití přepínače
<strong>-mrdrnd</strong>. Vestavěné funkce budou dostupné v&nbsp;libovolné
verze jazyka C, a to včetně ANSI C/C89:</p>

<pre>
$ <strong>gcc -mrdrnd -ansi -Wall -Werror rnrand_read.c</strong>
</pre>

<p>Výsledek by mohl vypadat následovně:</p>

<pre>
1 d49a35f7
1 563c3fd0
1 9c3fe577
1 34ee6930
1 68c498ee
1 1d38cc2f
1 244349d6
1 50f16a09
1 1324b913
1 af34d82c
</pre>

<p><div class="rs-tip-major">Poznámka: díky tomu, že je generátor náhodných
čísel vždy znovu inicializován, je prakticky jisté, že nikdy nezískáte výše
uvedenou sekvenci hodnot.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Způsob překladu demonstračního příkladu do assembleru</h2>

<p>Ověřme si ještě, zda překladač GCC skutečně převedl volání vestavěných
funkcí <strong>__builtin_ia32_rdrandXX_step</strong> na instrukci
<strong>RDRND</strong>. Toto ověření je vhodné provést v&nbsp;případě, že se
náhodné hodnoty budou využívat v&nbsp;kryptografických algoritmech,
v&nbsp;online hrách (kasinech) atd. Provedeme překlad do assembleru a pro větší
čitelnost si vynutíme vygenerování assemblerovského zdrojového kódu založeného
na syntaxi používané firmou Intel:</p>

<pre>
$ <strong>gcc -mrdrnd -S -masm=intel -Og rdrand_read.c</strong>
</pre>

<p>Ve výsledném kódu je volání instrukce <strong>RDRAND</strong> podtrženo:</p>

<pre>
        .file   "rdrand_read.c"
        .intel_syntax noprefix
        .text
        .section        .rodata.str1.1,"aMS",@progbits,1
.LC0:
        .string "%d %x\n"
        .text
        .globl  main
        .type   main, @function
<strong>main</strong>:
.LFB11:
        .cfi_startproc
        push    rbx
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        sub     rsp, 16
        .cfi_def_cfa_offset 32
        mov     ebx, 0
        jmp     .L2
.L3:
        <u>rdrand  esi</u>
        mov     DWORD PTR [rsp+12], esi
        mov     eax, 1
        cmovc   esi, eax
        mov     edx, DWORD PTR [rsp+12]
        mov     edi, OFFSET FLAT:.LC0
        mov     eax, 0
        call    printf
        add     ebx, 1
.L2:
        cmp     ebx, 9
        jle     .L3
        mov     eax, 0
        add     rsp, 16
        .cfi_def_cfa_offset 16
        pop     rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE11:
        .size   main, .-main
        .ident  "GCC: (GNU) 14.2.1 20240912 (Red Hat 14.2.1-3)"
        .section        .note.GNU-stack,"",@progbits
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Jak kvalitní je sekvence náhodných čísel získaná opakovaným voláním <strong>RDRAND</strong>?</h2>

<p>Jak jsme si již naznačili v&nbsp;úvodní kapitole, negeneruje instrukce
<strong>RDRAND</strong> skutečné náhodné hodnoty, ale &bdquo;jen&ldquo; hodnoty
pseudonáhodné, i když samotné <i>semínko</i> je přečteno z&nbsp;generátoru
skutečně náhodných čísel (tato situace ovšem nastane až po vrácení 511 hodnot).
Musíme si tedy ověřit, jak náhodná je ve skutečnosti sekvence čísel, která je
opakovaným voláním instrukce <strong>RDRAND</strong> získána. Pro tento účel
existuje poměrně velké množství metrik, jejichž podrobný popis přesahuje rámec
dnešního článku (ovšem jedná se o velmi zajímavou problematiku). Proto
využijeme existující nástroj, který přečte obsah binárního souboru
s&nbsp;(pseudo)náhodnými daty a s&nbsp;využitím většího množství metrik ověří,
do jaké míry jsou tato data náhodná. Pro zajímavost porovnáme hodnoty vytvářené
instrukcí <strong>RDRAND</strong> s&nbsp;hodnotami získanými klasickým
deterministickým generátorem pseudonáhodných hodnot (ovšem nevyužijeme funkci
rand ze základní knihovny).</p>



<p><a name="k13"></a></p> <h2 id="k13">13.  Program pro  vygenerování  binárního
souboru s&nbsp;(pseudo)náhodným obsahem</h2>

<p>Abychom si ověřili, do jaké míry jsou hodnoty vrácené instrukcí
<strong>RDRAND</strong> náhodné, necháme si vygenerovat binární soubor
s&nbsp;(pseudo)náhodným obsahem, který budeme posléze analyzovat. Pro
jednoduchost při implementaci zůstaneme u jazyka C, i když naprosto stejný
program je pochopitelně možné vytvořit i v&nbsp;assmebleru (i když nebude
přenositelný):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
int <strong>main</strong>(void) {
    FILE *fout;
&nbsp;
    int success;
    uint32_t random_value;
    int i;
&nbsp;
    fout = fopen("random.bin", "wb");
    if (fout == NULL) {
        perror("fopen");
        return 1;
    }
&nbsp;
    for (i=0; i&lt;10; i++) {
        success = <strong>__builtin_ia32_rdrand32_step(&amp;random_value)</strong>;
        if (success != 1) {
            perror("rdrand32");
            return 2;
        }
        fwrite(&amp;random_value, sizeof(uint32_t), 1, fout);
        if (ferror(fout)) {
            perror("fwrite");
            return 1;
        }
    }
&nbsp;
    fclose(fout);
&nbsp;
    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vygenerování binárního souboru s&nbsp;jedním milionem 32bitových pseudonáhodných hodnot</h2>

<p>Předchozí příklad vygeneroval pouze 40 náhodných bajtů. Upravme si ho proto
do podoby, kdy se vygeneruje 1000000 třiceti dvoubitových hodnot:</p>

<pre>
    ...
    ...
    ...
    for (i=0; i&lt;1000000; i++) {
        ...
        ...
        ...
    }
    ...
    ...
    ...
</pre>

<p>Po překladu a spuštění bychom měli získat soubor <strong>random.bit</strong>
s&nbsp;délkou přesně 4000000 bajtů:</p>

<pre>
$ <strong>ls -l random.bin</strong>
&nbsp;
-rw-r--r--. 1 ptisnovs ptisnovs 4000000 Aug  8 18:47 random.bin
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Projekt s&nbsp;implementací metrik pro otestování (pseudo)náhodných hodnot</h2>

<p>Pro otestování, jak kvalitní jsou hodnoty získané instrukcí
<strong>RDRAND</strong>, použijeme projekt s&nbsp;implementací testovací sady
SP800-22 Rev 1a PRNG. Tento projekt je naprogramován v&nbsp;Pythonu, takže
testy budou poměrně zdlouhavé.</p>

<p>Projekt s&nbsp;testy naklonujeme do nového adresáře:</p>

<pre>
$ <strong>git clone git@github.com:dj-on-github/sp800_22_tests.git</strong>
</pre>

<p>Zjistíme, zda je testovací sada spustitelná:</p>
<pre>
$ <strong>./sp800_22_tests.py --help</strong>
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
usage: sp800_22_tests.py [-h] [--be] [-t TESTNAME] [--list_tests] [filename]
&nbsp;
Test data for distinguishability form random, using NIST SP800-22Rev1a algorithms.
&nbsp;
positional arguments:
  filename              Filename of binary file to test
&nbsp;
options:
  -h, --help            show this help message and exit
  --be                  Treat data as big endian bits within bytes. Defaults to little endian
  -t TESTNAME, --testname TESTNAME
                        Select the test to run. Defaults to running all tests. Use --list_tests to see the list
  --list_tests          Display the list of tests
</pre>

<p>Můžeme si vypsat i testy, které jsou implementovány:</p>

<pre>
$ <strong>./sp800_22_tests.py --list_tests</strong>
</pre>

<pre>
Tests of Distinguishability from Random
1   : monobit_test
2   : frequency_within_block_test
3   : runs_test
4   : longest_run_ones_in_a_block_test
5   : binary_matrix_rank_test
6   : dft_test
7   : non_overlapping_template_matching_test
8   : overlapping_template_matching_test
9   : maurers_universal_test
10  : linear_complexity_test
11  : serial_test
12  : approximate_entropy_test
13  : cumulative_sums_test
14  : random_excursion_test
15  : random_excursion_variant_test
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Otestování hodnot vygenerovaných instrukcí <strong>RDRAND</strong></h2>

<p>Nyní testy spustíme oproti souboru <strong>random.bit</strong>, který byl
vytvořen v&nbsp;rámci <a href="#k14">čtrnácté kapitoly</a>. Výsledné metriky se
pochopitelně mohou nepatrně odlišovat, nicméně celkové výsledky by se měnit
neměly:</p>

<pre>
Tests of Distinguishability from Random
TEST: monobit_test
  Ones count   = 16002474
  Zeroes count = 15997526
  PASS
  P=0.381742010349456
TEST: frequency_within_block_test
  n = 32000000
  N = 99
  M = 323232
  PASS
  P=0.016363453060209376
TEST: runs_test
  prop  0.5000773125
  tau  0.00035355339059327376
  vobs  15997442.0
  PASS
  P=0.36586054912558746
TEST: longest_run_ones_in_a_block_test
  n = 32000000
  K = 6
  M = 10000
  N = 75
  chi_sq = 7.062112789716308
  PASS
  P=0.3151412465525687
TEST: binary_matrix_rank_test
  Number of blocks 31250
  Data bits used: 32000000
  Data bits discarded: 0
  Full Rank Count  =  9002
  Full Rank -1 Count =  18103
  Remainder Count =  4145
  Chi-Square =  0.4486112659932162
  PASS
  P=0.7990708746184348
TEST: dft_test
  N0 = 15200000.000000
  N1 = 15200124.000000
  PASS
  P=0.8405777193396355
TEST: non_overlapping_template_matching_test
  PASS
  P=0.9099065451579921
TEST: overlapping_template_matching_test
  B =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  m =  10
  M =  1062
  N =  968
  K =  5
  model =  [352, 179, 134, 97, 68, 135]
  v[j] =   [580, 141, 101, 56, 47, 43]
  chisq =  6.780899397146134
  PASS
  P=0.23745168802495786
TEST: maurers_universal_test
  sum = 29375620.88424485
  fn = 10.16946589683095
  PASS
  P=0.41030644109319797
TEST: linear_complexity_test
  M =  512
  N =  62500
  K =  6
  chisq =  2.2519091978212007
  P =  0.8951344431090033
  PASS
  P=0.8951344431090033
TEST: serial_test
  psi_sq_m   =  17.469030998647213
  psi_sq_mm1 =  7.197106998413801
  psi_sq_mm2 =  2.348089501261711
  delta1     =  10.271924000233412
  delta2     =  5.422906503081322
  P1         =  0.24645678090722536
  P2         =  0.24658963035192114
  PASS
P=0.24645678090722536
P=0.24658963035192114
TEST: approximate_entropy_test
  n         =  32000000
  m         =  3
  Pattern 1 of 8, count = 3998217
  Pattern 2 of 8, count = 4000588
  Pattern 3 of 8, count = 3999448
  Pattern 4 of 8, count = 3999273
  Pattern 5 of 8, count = 4000588
  Pattern 6 of 8, count = 3998133
  Pattern 7 of 8, count = 3999273
  Pattern 8 of 8, count = 4004480
  phi(3)    = -4.382027
  Pattern 1 of 16, count = 2000148
  Pattern 2 of 16, count = 1998069
  Pattern 3 of 16, count = 2000528
  Pattern 4 of 16, count = 2000060
  Pattern 5 of 16, count = 2000285
  Pattern 6 of 16, count = 1999163
  Pattern 7 of 16, count = 1998244
  Pattern 8 of 16, count = 2001029
  Pattern 9 of 16, count = 1998069
  Pattern 10 of 16, count = 2002519
  Pattern 11 of 16, count = 1998920
  Pattern 12 of 16, count = 1999213
  Pattern 13 of 16, count = 2000303
  Pattern 14 of 16, count = 1998970
  Pattern 15 of 16, count = 2001029
  Pattern 16 of 16, count = 2003451
  phi(3)    = -5.075174
  AppEn(3)  = 0.693147
  ChiSquare =  10.270517456945072
  PASS
  P=0.24655018820637375
TEST: cumulative_sums_test
PASS
  PASS
P=0.30009060907640817
P=0.3654675300008945
TEST: random_excursion_test
J=3795
x = -4  chisq = 2.277509        p = 0.809564 
x = -3  chisq = 21.315877       p = 0.000706  Not Random
x = -2  chisq = 8.381990        p = 0.136402 
x = -1  chisq = 9.269424        p = 0.098788 
x = 1   chisq = 7.581427        p = 0.180863 
x = 2   chisq = 17.648646       p = 0.003421  Not Random
x = 3   chisq = 3.632979        p = 0.603369 
x = 4   chisq = 2.222378        p = 0.817597 
FAIL: Data not random
  FAIL
P=0.8095643977803422
P=0.0007059586033140604
P=0.13640211952704734
P=0.0987883878164268
P=0.18086283358054378
P=0.0034205664260353688
P=0.603368571138448
P=0.8175970567482853
TEST: random_excursion_variant_test
J= 3795
x = -9   count=4344     p = 0.126422 
x = -8   count=4095     p = 0.373945 
x = -7   count=3898     p = 0.742985 
x = -6   count=3822     p = 0.925552 
x = -5   count=3733     p = 0.812487 
x = -4   count=3750     p = 0.845214 
x = -3   count=3918     p = 0.527784 
x = -2   count=4057     p = 0.082514 
x = -1   count=4002     p = 0.017501 
x = 1    count=3696     p = 0.255808 
x = 2    count=3836     p = 0.785847 
x = 3    count=3893     p = 0.614922 
x = 4    count=3778     p = 0.941207 
x = 5    count=3683     p = 0.668269 
x = 6    count=3563     p = 0.422023 
x = 7    count=3464     p = 0.292000 
x = 8    count=3503     p = 0.386820 
x = 9    count=3547     p = 0.489937 
PASS
  PASS
P=0.12642201640045245
P=0.3739447986092539
P=0.7429854218086411
P=0.925551671800892
P=0.812486864855873
P=0.8452142837803289
P=0.5277841063848452
P=0.08251432838963278
P=0.017500678846047855
P=0.25580771506589667
P=0.7858465900792965
P=0.6149217634548362
P=0.9412070171775442
P=0.6682691399315276
P=0.42202260140624953
P=0.2919997884594155
P=0.38681988986649096
P=0.4899371303964931
</pre>

<p>Nejdůležitější je závěrečná tabulka:</p>

<pre>
SUMMARY
-------
monobit_test                             0.381742010349456  PASS
frequency_within_block_test              0.016363453060209376 PASS
runs_test                                0.36586054912558746 PASS
longest_run_ones_in_a_block_test         0.3151412465525687 PASS
binary_matrix_rank_test                  0.7990708746184348 PASS
dft_test                                 0.8405777193396355 PASS
non_overlapping_template_matching_test   0.9099065451579921 PASS
overlapping_template_matching_test       0.23745168802495786 PASS
maurers_universal_test                   0.41030644109319797 PASS
linear_complexity_test                   0.8951344431090033 PASS
serial_test                              0.24645678090722536 PASS
approximate_entropy_test                 0.24655018820637375 PASS
cumulative_sums_test                     0.30009060907640817 PASS
random_excursion_test                    0.0007059586033140604 FAIL
random_excursion_variant_test            0.017500678846047855 PASS
</pre>

<p>Z&nbsp;této tabulky je patrné, že &bdquo;neprošel&ldquo; pouze jediný test
<strong>random_excursion_test</strong>. Podrobnosti si řekneme příště.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Porovnání výsledků s&nbsp;výsledky deterministického generátoru pseudonáhodných hodnot</h2>

<p>Bude zajímavé si porovnat výsledky otestování pseudonáhodných hodnot
vygenerovaných instrukcí <strong>RDRAND</strong> se softwarově implementovaným
generátorem pseudonáhodných hodnot (PRNG). Klasickou funkci
<strong>rand</strong> (viz <a
href="https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341">https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341</a>)
použít přímo nelze, protože ořezává nejvyšší bit. Pokusme se tedy inspirovat
některými existujícími PRNG: buď na posuvném registru se zpětnovazebními
smyčkami (LFSR) nebo založeným na známém algoritmu XorShift (což je jedna
z&nbsp;možných implementací LFSR, která je velmi rychlá a lze ji snadno
implementovat i na osmibitových CPU). Konkrétní implementace byla inspirována
<a href="https://en.wikipedia.org/wiki/Xorshift">tímto kódem</a>:

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
&nbsp;
uint32_t <strong>xorshift32</strong>(void) {
    const uint32_t start_state = 0xACE1u;
    static uint32_t state = start_state;
&nbsp;
    uint32_t x = state;
    x ^= x &lt;&lt; 13;
    x ^= x &gt;&gt; 17;
    x ^= x &lt;&lt;  5;
    return state = x;
}
&nbsp;
int <strong>main</strong>(void) {
    FILE *fout;
&nbsp;
    uint32_t random_value;
    int i;
&nbsp;
    fout = fopen("random.bin", "wb");
    if (fout == NULL) {
        perror("fopen");
        return 1;
    }
&nbsp;
    for (i=0; i&lt;1000000; i++) {
        random_value = xorshift32();
        fwrite(&amp;random_value, sizeof(uint32_t), 1, fout);
        if (ferror(fout)) {
            perror("fwrite");
            return 1;
        }
    }
&nbsp;
    fclose(fout);
&nbsp;
    return 0;
}
</pre>

<p>Výsledky testu pseudonáhodných hodnot nyní budou vypadat následovně:</p>

<pre>
Tests of Distinguishability from Random
TEST: monobit_test
  Ones count   = 16003561
  Zeroes count = 15996439
  PASS
  P=0.2080290229323611
TEST: frequency_within_block_test
  n = 32000000
  N = 99
  M = 323232
  PASS
  P=0.8614428497587631
TEST: runs_test
  prop  0.50011128125
  tau  0.00035355339059327376
  vobs  16002865.0
  PASS
  P=0.3109595205564162
TEST: longest_run_ones_in_a_block_test
  n = 32000000
  K = 6
  M = 10000
  N = 75
  chi_sq = 22.941016541697515
  FAIL
  P=0.0008164762821414863
TEST: binary_matrix_rank_test
  Number of blocks 31250
  Data bits used: 32000000
  Data bits discarded: 0
  Full Rank Count  =  31250
  Full Rank -1 Count =  0
  Remainder Count =  0
  Chi-Square =  76960.83183277596
  FAIL
  P=0.0
TEST: dft_test
  N0 = 15200000.000000
  N1 = 15201888.000000
  FAIL
  P=0.002193202101438405
TEST: non_overlapping_template_matching_test
  PASS
  P=0.9993894628376528
TEST: overlapping_template_matching_test
  B =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  m =  10
  M =  1062
  N =  968
  K =  5
  model =  [352, 179, 134, 97, 68, 135]
  v[j] =   [595, 150, 99, 48, 32, 44]
  chisq =  4.462951491364795
  PASS
  P=0.48485565251215446
TEST: maurers_universal_test
  sum = 29377040.220677454
  fn = 10.169957253030853
  PASS
  P=0.9134294606289255
TEST: linear_complexity_test
  M =  512
  N =  62500
  K =  6
  chisq =  8.824348198476159
  P =  0.18370025599170844
  PASS
  P=0.18370025599170844
TEST: serial_test
  psi_sq_m   =  15.084697999060154
  psi_sq_mm1 =  7.5235175006091595
  psi_sq_mm2 =  4.195492248982191
  delta1     =  7.5611804984509945
  delta2     =  4.233155246824026
  P1         =  0.47746392082023353
  P2         =  0.3753703504323772
  PASS
P=0.47746392082023353
P=0.3753703504323772
TEST: approximate_entropy_test
  n         =  32000000
  m         =  3
  Pattern 1 of 8, count = 3996493
  Pattern 2 of 8, count = 3998514
  Pattern 3 of 8, count = 4001144
  Pattern 4 of 8, count = 4000288
  Pattern 5 of 8, count = 3998514
  Pattern 6 of 8, count = 4002918
  Pattern 7 of 8, count = 4000288
  Pattern 8 of 8, count = 4001841
  phi(3)    = -4.382027
  Pattern 1 of 16, count = 1997631
  Pattern 2 of 16, count = 1998862
  Pattern 3 of 16, count = 2000811
  Pattern 4 of 16, count = 1997703
  Pattern 5 of 16, count = 1999985
  Pattern 6 of 16, count = 2001159
  Pattern 7 of 16, count = 1999967
  Pattern 8 of 16, count = 2000321
  Pattern 9 of 16, count = 1998862
  Pattern 10 of 16, count = 1999652
  Pattern 11 of 16, count = 2000333
  Pattern 12 of 16, count = 2002585
  Pattern 13 of 16, count = 1998529
  Pattern 14 of 16, count = 2001759
  Pattern 15 of 16, count = 2000321
  Pattern 16 of 16, count = 2001520
  phi(3)    = -5.075174
  AppEn(3)  = 0.693147
  ChiSquare =  7.561090846763818
  PASS
  P=0.4774731288894847
TEST: cumulative_sums_test
PASS
  PASS
P=0.33602422186921377
P=0.24415913425280134
TEST: random_excursion_test
J=7693
x = -4  chisq = 8.002090        p = 0.156121 
x = -3  chisq = 1.777649        p = 0.878976 
x = -2  chisq = 1.259272        p = 0.939066 
x = -1  chisq = 8.128416        p = 0.149299 
x = 1   chisq = 4.735801        p = 0.448966 
x = 2   chisq = 1.803213        p = 0.875649 
x = 3   chisq = 2.294887        p = 0.807018 
x = 4   chisq = 2.816422        p = 0.728263 
PASS
  PASS
P=0.15612050457353127
P=0.8789756760269307
P=0.9390662428576048
P=0.14929894014192574
P=0.44896643380466994
P=0.8756486991836885
P=0.8070175988774235
P=0.7282626872703772
TEST: random_excursion_variant_test
J= 7693
x = -9   count=8004     p = 0.543123 
x = -8   count=7917     p = 0.641021 
x = -7   count=7920     p = 0.611759 
x = -6   count=7834     p = 0.731797 
x = -5   count=7753     p = 0.871906 
x = -4   count=7851     p = 0.630201 
x = -3   count=7931     p = 0.390847 
x = -2   count=7910     p = 0.312479 
x = -1   count=7839     p = 0.239181 
x = 1    count=7527     p = 0.180807 
x = 2    count=7491     p = 0.347107 
x = 3    count=7433     p = 0.348552 
x = 4    count=7135     p = 0.089077 
x = 5    count=6962     p = 0.049482 
x = 6    count=6988     p = 0.086587 
x = 7    count=7161     p = 0.234229 
x = 8    count=7269     p = 0.377460 
x = 9    count=7229     p = 0.364271 
PASS
  PASS
P=0.5431229529294412
P=0.6410206735453066
P=0.6117587281384658
P=0.7317969690295173
P=0.8719060321940433
P=0.6302014247555671
P=0.39084685974524846
P=0.3124787233136639
P=0.23918087197125792
P=0.18080694993165813
P=0.34710650922851455
P=0.34855224987536226
P=0.08907689521634357
P=0.04948197607007566
P=0.0865873799112578
P=0.23422934975621235
P=0.3774596342564739
P=0.36427054513505974
</pre>

<p>Hodnoty jsou nepatrně horší (podle očekávání):</p>

<pre>
SUMMARY
-------
monobit_test                             0.2080290229323611 PASS
frequency_within_block_test              0.8614428497587631 PASS
runs_test                                0.3109595205564162 PASS
longest_run_ones_in_a_block_test         0.0008164762821414863 FAIL
binary_matrix_rank_test                  0.0                FAIL
dft_test                                 0.002193202101438405 FAIL
non_overlapping_template_matching_test   0.9993894628376528 PASS
overlapping_template_matching_test       0.48485565251215446 PASS
maurers_universal_test                   0.9134294606289255 PASS
linear_complexity_test                   0.18370025599170844 PASS
serial_test                              0.3753703504323772 PASS
approximate_entropy_test                 0.4774731288894847 PASS
cumulative_sums_test                     0.24415913425280134 PASS
random_excursion_test                    0.14929894014192574 PASS
random_excursion_variant_test            0.04948197607007566 PASS
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: pomocné soubory s&nbsp;makry a subrutinami použitými v&nbsp;příkladech napsaných v&nbsp;assembleru</h2>

<p>Soubor <strong>linux_macros.asm</strong> obsahuje základní makra používaná
v&nbsp;programech, které mají být spouštěny v&nbsp;Linuxu, tj.&nbsp;které mají
volat funkce jádra (kernelu):</p>

<pre>
%ifndef LINUX_MACROS_LIB
%define LINUX_MACROS_LIB
&nbsp;
<i>; Linux kernel system call table</i>
<strong>sys_exit</strong>  equ 1
<strong>sys_write</strong> equ 4
&nbsp;
&nbsp;
<i>; makro pro tisk retezce na obrazovku</i>
%macro <strong>print_string</strong> 2
        mov   eax, sys_write      <i>; cislo syscallu pro funkci "write"</i>
        mov   ebx, 1              <i>; standardni vystup</i>
        mov   ecx, %1             <i>; adresa retezce, ktery se ma vytisknout</i>
        mov   edx, %2             <i>; delka retezce</i>
        int   80h                 <i>; volani Linuxoveho kernelu</i>
%endmacro
&nbsp;
&nbsp;
<i>; makro pro tisk 32bitove hexadecimalni hodnoty</i>
<i>; na standardni vystup</i>
%macro <strong>print_hex</strong> 2
        push ebx                  <i>; uschovat EBX pro dalsi pouziti</i>
        mov     edx, %1           <i>; zapamatovat si hodnotu pro tisk</i>
        mov     ebx, hex_message  <i>; buffer, ktery se zaplni hexa cislicemi</i>
        mov     byte [ebx+8], %2  <i>; oddelovac, konec radku, atd.</i>
        call    hex2string        <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length  <i>; tisk hexadecimalni hodnoty</i>
        pop ebx                   <i>; obnovit EBX</i>
%endmacro
&nbsp;
&nbsp;
<i>; makro pro vypis obsahu MMX vektoru</i>
%macro <strong>print_mmx_reg_as_hex</strong> 1
        mov  ebx, mmx_tmp         <i>; adresa bufferu</i>
        movq [ebx], %1            <i>; ulozeni do pameti (8 bajtu)</i>
        mov  eax, [ebx+4]         <i>; nacteni casti MMX vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx]           <i>; nacteni casti MMX vektoru do celociselneho registru</i>
        print_hex eax, 0x0a       <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
%endmacro
&nbsp;
&nbsp;
<i>; makro pro vypis obsahu SSE vektoru</i>
%macro <strong>print_sse_reg_as_hex</strong> 1
        mov  ebx, sse_tmp         <i>; adresa bufferu</i>
        movups [ebx], %1          <i>; ulozeni do pameti (16 bajtu)</i>
        mov  eax, [ebx+12]        <i>; nacteni casti SSE vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx+8]         <i>; nacteni casti SSE vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx+4]         <i>; nacteni casti SSE vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx]           <i>; nacteni casti SSE vektoru do celociselneho registru</i>
        print_hex eax, 0x0a       <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
%endmacro
&nbsp;
&nbsp;
<i>; makro pro vypis obsahu AVX vektoru</i>
%macro <strong>print_avx_reg_as_hex</strong> 1
        mov  ebx, avx_tmp         <i>; adresa bufferu</i>
        vmovdqu [ebx], %1         <i>; ulozeni do pameti (32 bajtu)</i>
        mov  eax, [ebx+28]        <i>; nacteni casti AVX vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx+24]        <i>; nacteni casti AVX vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx+20]        <i>; nacteni casti AVX vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx+16]        <i>; nacteni casti AVX vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx+12]        <i>; nacteni casti AVX vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx+8]         <i>; nacteni casti AVX vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx+4]         <i>; nacteni casti AVX vektoru do celociselneho registru</i>
        print_hex eax, ' '        <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
        mov  eax, [ebx]           <i>; nacteni casti AVX vektoru do celociselneho registru</i>
        print_hex eax, 0x0a       <i>; zobrazeni obsahu tohoto registru v hexadecimalnim tvaru</i>
%endmacro
&nbsp;
&nbsp;
<i>; makro pro ukonceni procesu </i>
%macro <strong>exit</strong> 0
        mov   eax,sys_exit        <i>; cislo sycallu pro funkci "exit"</i>
        mov   ebx,0               <i>; exit code = 0</i>
        int   80h                 <i>; volani Linuxoveho kernelu</i>
%endmacro
&nbsp;
&nbsp;
%endif
</pre>

<p>Soubor <strong>hex2string.asm</strong> obsahuje subrutinu nazvanou taktéž
<strong>hex2string</strong>, která převede vstupní 32bitovou hodnotu uloženou
v&nbsp;registru <strong>EDX</strong> do řetězce:</p>

<pre>
%ifndef HEX_2_STRING_LIB
%define HEX_2_STRING_LIB
&nbsp;
<i>; subrutina urcena pro prevod 32bitove hexadecimalni hodnoty na retezec</i>
<i>; Vstup: EDX - hodnota, ktera se ma prevest na retezec</i>
<i>;        EBX - adresa jiz drive alokovaneho retezce (resp. osmice bajtu)</i>
<strong>hex2string</strong>:
                  mov ecx,  8             <i>; pocet opakovani smycky</i>
&nbsp;
.print_one_digit: rol edx, 4              <i>; rotace doleva znamena, ze se do spodnich 4 bitu nasune dalsi cifra</i>
                  mov al, dl              <i>; nechceme porusit obsah vstupni hodnoty v EDX, proto pouzijeme AL</i>
                  and al, 0x0f            <i>; maskovani, potrebujeme pracovat jen s jednou cifrou</i>
                  cmp al, 10              <i>; je cifra vetsi nebo rovna 10?</i>
                  jl  .store_digit        <i>; neni, pouze prevest 0..9 na ASCII hodnotu '0'..'9'</i>
&nbsp;
.alpha_digit:     add al, 'A'-10-'0'      <i>; prevod hodnoty 10..15 na znaky 'A'..'F'</i>
&nbsp;
.store_digit:     add al, '0'
                  mov [ebx], al           <i>; ulozeni cifry do retezce</i>
                  inc ebx                 <i>; dalsi cifra</i>
                  loop .print_one_digit   <i>; a opakovani smycky, dokud se nedosahlo nuly</i>
&nbsp;
                  ret                     <i>; navrat ze subrutiny</i>
&nbsp;
%endif
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C i v&nbsp;assembleru
mikroprocesorů s&nbsp;architekturou x86-64, byly uloženy do Git repositáře,
který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>rdrand_support.asm</td><td>test, jestli je instrukce <strong>RDRAND</strong> mikroprocesorem podporována</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm</a></td></tr>
<tr><td>2</td><td>rdrand_read.asm</td><td>přečtení jedné 32bitové hodnoty instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm</a></td></tr>
<tr><td>3</td><td>rdrand_read_loop.asm</td><td>přečtení sekvence 32bitových hodnot instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>rdrand_read.c</td><td>přečtení náhodné 32bitové hodnoty, realizace s&nbsp;využitím vestavěné funkce GCC</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c</a></td></tr>
<tr><td>5</td><td>rdrand_read.asm</td><td>výsledek překladu předchozího zdrojového kódu do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>rand_gen.c</td><td>vygenerování binárního souboru s&nbsp;pseudonáhodnými 32bitovými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c</a></td></tr>
<tr><td>7</td><td>rdrand_gen.c</td><td>vygenerování binárního souboru s&nbsp;hodnotami vrácenými instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>RDRAND (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RDRAND">https://en.wikipedia.org/wiki/RDRAND</a>
</li>

<li>RDRAND instruction<br />
<a href="https://www.felixcloutier.com/x86/rdrand">https://www.felixcloutier.com/x86/rdrand</a>
</li>

<li>Random Number Generator<br />
<a href="https://wiki.osdev.org/Random_Number_Generator">https://wiki.osdev.org/Random_Number_Generator</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Other Built-in Functions Provided by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>
</li>

<li>GCC: 6.60 Built-in Functions Specific to Particular Target Machines<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins">https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins</a>
</li>

<li>Stránka projektu Compiler Explorer<br />
<a href="https://godbolt.org/">https://godbolt.org/</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://llvm.org/">https://llvm.org/</a>
</li>

<li>GCC, the GNU Compiler Collection<br />
<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>
</li>

<li>Clang<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Clang: Assembling a Complete Toolchain<br />
<a href="https://clang.llvm.org/docs/Toolchain.html">https://clang.llvm.org/docs/Toolchain.html</a>
</li>

<li>Integer overflow<br />
<a href="https://en.wikipedia.org/wiki/Integer_overflow">https://en.wikipedia.org/wiki/Integer_overflow</a>
</li>

<li>SETcc — Set Byte on Condition<br />
<a href="https://www.felixcloutier.com/x86/setcc">https://www.felixcloutier.com/x86/setcc</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>Undefined behavior (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Undefined_behavior">https://en.wikipedia.org/wiki/Undefined_behavior</a>
</li>

<li>Is signed integer overflow still undefined behavior in C++?<br />
<a href="https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c">https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c</a>
</li>

<li>Allowing signed integer overflows in C/C++<br />
<a href="https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c">https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c</a>
</li>

<li>SXTB, SXTH, SXTW<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html">https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html</a>
</li>

<li>Is there any legitimate use for Intel's RDRAND?<br />
<a href="https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand">https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand</a>
</li>

<li>Intel® Digital Random Number Generator (DRNG) Software Implementation Guide<br />
<a href="https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html">https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html</a>
</li>

<li>Hardware random number generator<br />
<a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">https://en.wikipedia.org/wiki/Hardware_random_number_generator</a>
</li>

<li>Random number generator attack<br />
<a href="https://en.wikipedia.org/wiki/Random_number_generator_attack">https://en.wikipedia.org/wiki/Random_number_generator_attack</a>
</li>

<li>random_r.c (Glibc)<br />
<a href="https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341">https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341</a>
</li>

<li>Xorshift<br />
<a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

