<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Funkce vestavěné v GCC pro provádění nízkoúrovňových bitových operací a rotací</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Funkce vestavěné v GCC pro provádění nízkoúrovňových bitových operací a rotací</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Funkce vestavěné v&nbsp;GCC pro provádění nízkoúrovňových bitových operací a rotací</a></p>
<p><a href="#k02">2. Bitová rotace doprava i doleva</a></p>
<p><a href="#k03">3. Způsob překladu operace rotace doleva do strojového kódu</a></p>
<p><a href="#k04">4. Překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro platformu x86-64</a></p>
<p><a href="#k05">5. Analýza vygenerovaného strojového kódu pro platformu x86-64</a></p>
<p><a href="#k06">6. Překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 32bitové ARMy</a></p>
<p><a href="#k07">7. Analýza vygenerovaného strojového kódu pro platformu ARM32</a></p>
<p><a href="#k08">8. Překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 64bitové ARMy (AArch64)</a></p>
<p><a href="#k09">9. Analýza vygenerovaného strojového kódu pro platformu AArch64</a></p>
<p><a href="#k10">10. Rozdíl mezi operací rotace doleva a doprava</a></p>
<p><a href="#k11">11. Překlad operace rotace doprava pro všechny analyzované platformy</a></p>
<p><a href="#k12">12. Funkce pro výpočet parity v&nbsp;bajtu či vícebajtovém slovu</a></p>
<p><a href="#k13">13. Volání vestavěných funkcí <strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong> a <strong>__builtin_parityll</strong></a></p>
<p><a href="#k14">14. Realizace výpočtu parity na platformě x86-64</a></p>
<p><a href="#k15">15. Realizace výpočtu parity na platformě ARM32</a></p>
<p><a href="#k16">*** 16. Realizace výpočtu parity na platformě ARM64 (AArch64)</a></p>
<p><a href="#k17">17. Výpočet parity a celočíselné datové typy se znaménkem</a></p>
<p><a href="#k18">*** 18. Další bitové operace podporované vestavěnými funkcemi GCC</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Funkce vestavěné v&nbsp;GCC pro provádění nízkoúrovňových bitových operací a rotací</h2>

<p>Na předchozí dvojici článků o funkcích vestavěných do GCC, které slouží
k&nbsp;provádění nízkoúrovňových operací [<a
href="https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/">1</a>]
[<a
href="https://www.root.cz/clanky/generator-nahodnych-cisel-zalozeny-na-instrukcich-rdseed-a-rdrand/">2</a>]
dnes navážeme. Prozatím jsme si popsali realizace operace součtů
s&nbsp;přenosem (<i>carry</i>), které jsou relativně často používány
v&nbsp;praxi. Ve druhém článku jsme se zmínili o funkcích, které interně volají
instrukce <strong>RDSEED</strong> a <strong>RDRAND</strong>, jež přistupují
k&nbsp;vestavěnému generátoru náhodných čísel (což je specifikum platformy
x86-64). Ovšem podobných nízkoúrovňových operací existuje celá řada. Dnes se
zaměříme na dvě skupiny takových operací. V&nbsp;první skupině se nachází
operace pro provedení bitové <i>rotace</i> (nikoli <i>posunu</i>) doleva či
doprava o specifikovaný počet bitů. A ve skupině druhé nalezneme operace pro
výpočet parity předaného bajtu či vícebajtového slova.</p>

<p>Přitom nás nebude zajímat pouze způsob volání těchto operací (to je ve
skutečnosti triviální), ale i to, jak jsou tyto operace přeloženy do strojového
kódu. Zaměříme se na platformu x86-64, ARM32 (tedy původní ARMy) a AArch64
(64bitová architektura). Zajímavé bude například zjištění, že pro výpočet
parity se na architektuře AArch64 musí volat &bdquo;vektorové&ldquo; (SIMD)
operace a na platformě ARM32 se namísto volání specializované instrukce volá
systémová subrutina. A taktéž bude zajímavé zjistit způsob realizace bitových
rotací pro &bdquo;nenativní&ldquo; bitové šířky u architektur ARM32 i AArch64
(jedná se o rotace bajtů, šestnáctibitových slov a u ARM32 i rotace 64bitových
slov).</p>

<p><div class="rs-tip-major">Poznámka: používat budeme překladač GCC C verze
15; některé operace jsou definovány až v&nbsp;této nové verzi.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Bitová rotace doprava i doleva</h2>

<p>Pro realizaci některých nízkoúrovňových operací, ale i například
v&nbsp;oblasti kryptografie nebo při generování pseudonáhodných hodnot, se
setkáme s&nbsp;nutností provedení bitové rotace doprava nebo doleva. Od běžných
bitových posunů se rotace liší tím, že bity, které z&nbsp;rotovaného bajtu nebo
slova vysouváme ven, jsou přidány na druhou stranu rotovaného operandu. Na
některých platformách jsou ještě k&nbsp;dispozici operace pro bitovou rotaci
s&nbsp;přidaným bitem, který je typicky ukládán do příznaku přenosu
<i>carry</i>, takže výsledkem je vlastně jakýsi hybrid mezi skutečnou bitovou
rotací a bitovým posunem. Nicméně se vraťme k&nbsp;operaci rotace. Na rozdíl od
logických bitových posunů, které jsou v&nbsp;jazyku C dobře podporovány
operátory &lt;&lt; a &gt;&gt;, neexistují ve standardním jazyku C operátory pro
rotace (ale ani pro aritmetický posun či pro posuny hodnot se znaménkem).</p>

<p>GCC ale i některé další překladače jazyka C, namísto toho nabízí vestavěné
(<i>builtin</i>) funkce, které rotace umožňují provést. Jedná se o generické
funkce, protože za <strong>type1</strong> nebo <strong>type2</strong> lze
dosadit libovolný celočíselný typ (ovšem druhá hodnota musí být nezáporná,
jinak není chování definováno):</p>

<pre>
type1 <strong>__builtin_stdc_rotate_left</strong>(type1 arg1, type2 arg2)
type1 <strong>__builtin_stdc_rotate_right</strong>(type1 arg1, type2 arg2)
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o relativně nové funkce;
přidány byly do GCC 15.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Způsob překladu operace rotace doleva do strojového kódu</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu je volána vestavěná funkce
nazvaná <strong>__builtin_stdc_rotate_left</strong>, která je určena pro rotaci
svého prvního parametru doleva o takový počet bitů, který je uložen ve druhém
parametru.  První parametr musí být typu celé číslo bez znaménka
(<i>unsigned</i>), druhý parametr může být i typu celé číslo se znaménkem
(<i>signed</i>) i bez znaménka. Ovšem chování této funkce není definováno pro
záporné hodnoty druhého parametru!  V&nbsp;demonstračním příkladu postupně
provádíme rotaci bajtu, 16bitového slova, 32bitového slova i 64bitového
slova:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
uint8_t <strong>rotate_left_8bit</strong>(uint8_t x, uint8_t y) {
    uint8_t z;
    z = <u>__builtin_stdc_rotate_left(x, y)</u>;
    return z;
}
&nbsp;
uint16_t <strong>rotate_left_16bit</strong>(uint16_t x, uint16_t y) {
    uint16_t z;
    z = <u>__builtin_stdc_rotate_left(x, y)</u>;
    return z;
}
&nbsp;
uint32_t <strong>rotate_left_32bit</strong>(uint32_t x, uint32_t y) {
    uint32_t z;
    z = <u>__builtin_stdc_rotate_left(x, y)</u>;
    return z;
}
&nbsp;
uint64_t <strong>rotate_left_64bit</strong>(uint64_t x, uint64_t y) {
    uint64_t z;
    z = <u>__builtin_stdc_rotate_left(x, y)</u>;
    return z;
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro platformu x86-64</h2>

<p>Překlad <a href="#k03">výše uvedeného</a> příkladu pro platformu x86-64 bez
povolení optimalizací dopadne následovně (<a
href="https://godbolt.org/z/7cnnj63Yx">projekt v&nbsp;Compiler
Exploreru</a>):</p>

<pre>
<strong>rotate_left_8bit</strong>:
        push    rbp
        mov     rbp, rsp
        mov     edx, edi
        mov     eax, esi
        mov     BYTE PTR [rbp-20], dl
        mov     BYTE PTR [rbp-24], al
        movzx   edx, BYTE PTR [rbp-20]
        movzx   eax, BYTE PTR [rbp-24]
        movzx   eax, al
        and     eax, 7
        mov     ecx, eax
        rol     dl, cl
        mov     eax, edx
        mov     BYTE PTR [rbp-1], al
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
        ret
&nbsp;
<strong>rotate_left_16bit</strong>:
        push    rbp
        mov     rbp, rsp
        mov     edx, edi
        mov     eax, esi
        mov     WORD PTR [rbp-20], dx
        mov     WORD PTR [rbp-24], ax
        movzx   edx, WORD PTR [rbp-20]
        movzx   eax, WORD PTR [rbp-24]
        movzx   eax, ax
        and     eax, 15
        mov     ecx, eax
        rol     dx, cl
        mov     eax, edx
        mov     WORD PTR [rbp-2], ax
        movzx   eax, WORD PTR [rbp-2]
        pop     rbp
        ret
&nbsp;
<strong>rotate_left_32bit</strong>:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-20], edi
        mov     DWORD PTR [rbp-24], esi
        mov     edx, DWORD PTR [rbp-20]
        mov     eax, DWORD PTR [rbp-24]
        and     eax, 31
        mov     ecx, eax
        rol     edx, cl
        mov     eax, edx
        mov     DWORD PTR [rbp-4], eax
        mov     eax, DWORD PTR [rbp-4]
        pop     rbp
        ret
&nbsp;
<strong>rotate_left_64bit</strong>:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-24], rdi
        mov     QWORD PTR [rbp-32], rsi
        mov     rdx, QWORD PTR [rbp-24]
        mov     rax, QWORD PTR [rbp-32]
        and     eax, 63
        mov     ecx, eax
        rol     rdx, cl
        mov     rax, rdx
        mov     QWORD PTR [rbp-8], rax
        mov     rax, QWORD PTR [rbp-8]
        pop     rbp
        ret
</pre>

<p>Naopak, pokud při překladu povolíme plné optimalizace, dosáhneme <a
href="https://godbolt.org/z/aYc34feqd">následujícího výsledku</a>, který je již
velmi dobře čitelný a pochopitelný:</p>

<pre>
<strong>rotate_left_8bit</strong>:
        mov     eax, edi
        mov     ecx, esi
        rol     al, cl
        ret
&nbsp;
<strong>rotate_left_16bit</strong>:
        mov     eax, edi
        mov     ecx, esi
        rol     ax, cl
        ret
&nbsp;
<strong>rotate_left_32bit</strong>:
        mov     eax, edi
        mov     ecx, esi
        rol     eax, cl
        ret
&nbsp;
<strong>rotate_left_64bit</strong>:
        mov     rax, rdi
        mov     ecx, esi
        rol     rax, cl
        ret
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Analýza vygenerovaného strojového kódu pro platformu x86-64</h2>

<p>Již od začátku existence platformy x86 byly v&nbsp;její instrukční sadě
realizovány instrukce určené pro bitové rotace a posuny. Jedná se konkrétně o
následujících osm instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam mnemotechnické zkratky instrukce</th></tr>
<tr><td>1</td><td>ROL</td><td>ROtate Left</td></tr>
<tr><td>2</td><td>ROR</td><td>ROtate Right</td></tr>
<tr><td>3</td><td>RCL</td><td>ROtate Left with Carry</td></tr>
<tr><td>4</td><td>RCR</td><td>ROtate Right with Carry</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>SAL</td><td>Shift Arithmetically Left</td></tr>
<tr><td>6</td><td>SAR</td><td>Shift Arithmetically Right</td></tr>
<tr><td>7</td><td>SHL</td><td>SHift Left (stejná jako SAL)</td></tr>
<tr><td>8</td><td>SHR</td><td>SHift Rigth</td></tr>
</table>

<p>Bitové posuny (<i>shift</i>) jsou využity při realizaci céčkovských
operátorů &lt;&lt; a &gt;&gt;, a to (opět na platformě x86 a x86-64) i pro
posun operandu se znaménkem (<i>signed</i>), což je obecně v&nbsp;jazyku C
nedefinovaná operace.</p>

<p>Nás však budou nyní zajímat pouze první čtyři instrukce, tj.&nbsp;rotace a
nikoli posuny. Instrukce <strong>ROL</strong> a <strong>ROR</strong> provádí
rotaci celého operandu (8, 16, 32, 64bitů) doleva resp.&nbsp;doprava, a to buď
o jeden bit, o <strong>CL</strong> bitů nebo o počet bitů zadaný
v&nbsp;instrukčním kódu (konstanta). A instrukce <strong>RCL</strong> a
<strong>RCR</strong> provádí rotaci operandu+jednoho bitu navíc (jeden bit je
získán z&nbsp;příznaku <strong>CF</strong> a jiný uložen do tohoto příznaku),
tj.&nbsp;jedná se o rotace 9, 17, 33 nebo 65 bitů.</p>

<p>Jak je z&nbsp;demonstračního příkladu <a href="#k04">přeloženého do
assembleru</a> zřejmé, díky tomu, že je počet bitů, které se mají rotovat,
proměnný (předaný v&nbsp;parametru), použila se instrukce <strong>ROL</strong>,
přičemž druhým operandem je vždy registr <strong>CL</strong>. To je logické,
protože vlastně vyšší bity rotace nemají žádný význam. Zvyšuje se pouze bitová
šířka prvního (rotovaného) operandu a samozřejmě i bitová šířka výsledku:</p>

<pre>
rol     al, cl
&nbsp;
rol     ax, cl
&nbsp;
rol     eax, cl
&nbsp;
rol     rax, cl
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 32bitové ARMy</h2>

<p>Nyní se podívejme na způsob překladu stejného céčkovského zdrojového kódu se
stejnou funkcí <strong>__builtin_stdc_rotate_left</strong> (<a
href="#k03">třetí kapitola</a>), nyní ovšem pro 32bitovou architekturu ARM
(minimálně ARMv7, což je dnes již naprostý standard). Při povolení optimalizací
<a href="https://godbolt.org/z/6oGW1vaWo">bude výsledek vypadat takto</a>:</p>

<pre>
<strong>rotate_left_8bit</strong>:
        and     r1, r1, #7
        rsb     r3, r1, #0
        and     r3, r3, #7
        lsr     r3, r0, r3
        orr     r0, r3, r0, lsl r1
        and     r0, r0, #255
        bx      lr
&nbsp;
<strong>rotate_left_16bit</strong>:
        and     r1, r1, #15
        rsb     r3, r1, #0
        and     r3, r3, #15
        lsr     r3, r0, r3
        orr     r0, r3, r0, lsl r1
        lsl     r0, r0, #16
        lsr     r0, r0, #16
        bx      lr
&nbsp;
<strong>rotate_left_32bit</strong>:
        and     r1, r1, #31
        rsb     r1, r1, #32
        ror     r0, r0, r1
        bx      lr
&nbsp;
<strong>rotate_left_64bit</strong>:
        push    {r4, lr}
        mov     lr, r1
        and     r2, r2, #63
        sub     r4, r2, #32
        rsb     r3, r2, #0
        lsl     r1, r1, r2
        and     r3, r3, #63
        orr     r1, r1, r0, lsl r4
        rsb     ip, r2, #32
        orr     r1, r1, r0, lsr ip
        rsb     r4, r3, #32
        lsr     ip, r0, r3
        orr     r1, r1, lr, lsr r3
        orr     ip, ip, lr, lsl r4
        sub     r3, r3, #32
        orr     ip, ip, lr, lsr r3
        orr     r0, ip, r0, lsl r2
        pop     {r4, lr}
        bx      lr
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Analýza vygenerovaného strojového kódu pro platformu ARM32</h2>

<p>Podívejme se nyní na způsob překladu realizace operace rotace doleva na
32bitových platformách ARM. Na této platformě je k&nbsp;dispozici jediná
instrukce rotace, a to konkrétně instrukce <strong>ROR</strong> provádějící
rotaci <i>doprava</i>. Do této skupiny instrukcí navíc spadají i logické posuny
<strong>LSL</strong> a <strong>LSR</strong> i instrukce pro aritmetický posun
<strong>ASR</strong>. Bitovou rotaci instrukcí <strong>ROR</strong> lze
provádět buď o počet bitů stanovený konstantou (ovšem s&nbsp;omezeními), nebo o
počet bitů uložených v&nbsp;jiném pracovním registru.</p>

<p>Jak se ovšem provede rotace <i>doleva</i>, kterou vyžadujeme? Je to
jednoduché &ndash; postačuje provést rotaci doprava, ovšem počet bitů bude
vypočten tak, aby výsledkem byla hodnota odpovídající rotaci doleva. Přesně
takto je rotace implementována pro 32bitové hodnoty (<strong>RSB</strong>
znamená <i>reverse subtract</i>, tj.&nbsp;v&nbsp;tomto případě odečtení obsahu
registru <strong>R1</strong> od konstanty 32):</p>

<pre>
and     r1, r1, #31
rsb     r1, r1, #32
ror     r0, r0, r1
</pre>

<p>Při rotaci osmibitové hodnoty se ovšem postupuje odlišně. Provede se bitový
posun a následně se do nejnižších bitů výsledku přidají ty bity, který sem byly
přesunuty v&nbsp;případě skutečné rotace. Ilustrujme si celý postup při rotaci
osmibitové hodnoty o jeden bit doleva:</p>

<pre>
                           <i>; R0    R1    R3</i>
                           <i>; x     1     ?</i>
and     r1, r1, #7         <i>; x     1     ?</i>
rsb     r3, r1, #0         <i>; x     1     -1 (0b11111111)</i>
and     r3, r3, #7         <i>; x     1     7  (0b111)</i>
lsr     r3, r0, r3         <i>; x     1     x&gt;&gt;7 (bitový posun doprava, získáme nejnižší bit výsledku)</i>
orr     r0, r3, r0, lsl r1 <i>; x&gt;&gt;7 || x&lt;&lt;1 (přidali jsme nejvyšších sedm bitů výsledku)</i>
and     r0, r0, #255
</pre>

<p>Podobným způsobem je realizována rotace šestnáctibitové hodnoty. U hodnoty
64bitové je rotace taktéž nahrazena instrukcemi pro bitový posun, protože na
32bitových ARMech nejsou přímo podporovány 64bitové operace. Rotaci tedy musíme
nasimulovat posunem obsahu dvou 32bitových hodnot a přenesením nejnižších bitů
do výsledku.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 64bitové ARMy (AArch64)</h2>

<p>Pro mikroprocesory a mikrořadiče s&nbsp;architekturou AArch64 je překlad
proveden zcela odlišným způsobem, než je tomu u 32bitových ARMů. Je to ostatně
patrné i při pohledu na výsledek překladu, který bude (v&nbsp;případě povolení
optimalizací) <a href="https://godbolt.org/z/bfxh93YnG">vypadat
následovně</a>:</p>

<pre>
<strong>rotate_left_8bit</strong>:
        and     w1, w1, 7
        and     w0, w0, 255
        neg     w2, w1
        and     w2, w2, 7
        lsl     w1, w0, w1
        lsr     w0, w0, w2
        orr     w0, w1, w0
        ret
&nbsp;
<strong>rotate_left_16bit</strong>:
        and     w1, w1, 15
        and     w0, w0, 65535
        neg     w2, w1
        and     w2, w2, 15
        lsl     w1, w0, w1
        lsr     w0, w0, w2
        orr     w0, w1, w0
        ret
&nbsp;
<strong>rotate_left_32bit</strong>:
        neg     w1, w1
        ror     w0, w0, w1
        ret
&nbsp;
<strong>rotate_left_64bit</strong>:
        neg     w1, w1
        ror     x0, x0, x1
        ret
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Analýza vygenerovaného strojového kódu pro platformu AArch64</h2>

<p>Množina instrukcí navržených pro provedení operací aritmetického či bitového
(logického) posunu a rotace je na architektuře AArch64 celkem přehledná.
Povšimněte si navíc poslední instrukce <strong>ROR</strong> určené pro bitovou
rotaci &ndash; ta nás vlastně zajímá nejvíc. Neexistuje zde rotace vlevo,
protože ta samozřejmě odpovídá rotaci vpravo, ovšem o odlišnou hodnotu
(odečtenou od 63 či 31, resp.&nbsp;postačí změna znaménka):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ASR</td><td>aritmetický posun doprava až o 31/63 bitů</td></tr>
<tr><td>2</td><td>LSL</td><td>logický posun doleva až o 31/63 bitů</td></tr>
<tr><td>3</td><td>LSR</td><td>logický posun doprava až o 31/63 bitů</td></tr>
<tr><td>4</td><td>ROR</td><td>rotace doprava až o 31/63 bitů</td></tr>
</table>

<p>U všech předchozích instrukcí byl posun specifikován konstantou, zatímco u
dalších čtyř instrukcí je posun uložen v&nbsp;registru (druhý vstupní operand).
Hodnota tohoto registru však není použita přímo, protože se v&nbsp;úvahu bere
jen posledních pět či šest bitů podle toho, zda se jedná o 32bitovou či
64bitovou operaci:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ASRV</td><td>aritmetický posun doprava až o 31/63 bitů</td></tr>
<tr><td>2</td><td>LSLV</td><td>logický posun doleva až o 31/63 bitů</td></tr>
<tr><td>3</td><td>LSRV</td><td>logický posun doprava až o 31/63 bitů</td></tr>
<tr><td>4</td><td>RORV</td><td>rotace doprava až o 31/63 bitů</td></tr>
</table>

<p>Jak to vypadá v&nbsp;našich konkrétních příkladech? Nejjednodušší je situace
u rotace 32bitového a 64bitového operandu. Zde se používá instrukce
<strong>ROR</strong> (nikoli neexistující <strong>ROL</strong>), ovšem počet
bitů, o které se má rotace provést, je nejdříve znegován:</p>

<pre>
<strong>rotate_left_32bit            rotate_left_64bit</strong>:
        neg     w1, w1             neg     w1, w1
        ror     w0, w0, w1         ror     x0, x0, x1
        ret                        ret
</pre>

<p>U rotace osmibitového nebo šestnáctibitového operandu je tomu jinak. Nejprve
je s&nbsp;využitím operace <strong>AND</strong> zaručeno, že rotace bude
provedena o maximálně sedm resp.&nbsp;patnáct bitů. Následně se zajistí, že
velikost rotovaného operandu nepřesáhne rozsah jednoho bajtu resp.&nbsp;dvou
bajtů. Poté je do registru <strong>W2</strong> uložena vypočtená hodnota počtu
bitů pro rotaci <i>doprava</i>, kterou získáme nejnižší bit. Samotná rotace
doleva, která se má provést, je simulována posunem doleva (do nejnižšího bitu
je nasunuta nula) následovaná přidáním korektní hodnoty nejnižšího bitu (nebo
bitů) operací <strong>OR</strong>:</p>

<pre>
<strong>rotate_left_8bit             rotate_left_16bit</strong>:
        and     w1, w1, 7          and     w1, w1, 15
        and     w0, w0, 255        and     w0, w0, 65535
        neg     w2, w1             neg     w2, w1
        and     w2, w2, 7          and     w2, w2, 15
        lsl     w1, w0, w1         lsl     w1, w0, w1
        lsr     w0, w0, w2         lsr     w0, w0, w2
        orr     w0, w1, w0         orr     w0, w1, w0
        ret                        ret
</pre>

<p>Ilustrujme si to na rotaci osmibitové hodnoty o jeden bit doleva:</p>

<pre>
                        <i>; W0    W1    W2</i>
                        <i>; x     1     ?</i>
and     w1, w1, 7       <i>; x     1     ?</i>
and     w0, w0, 255     <i>; x     1     ?</i>
neg     w2, w1          <i>; x     1     -1 (0b11111111)</i>
and     w2, w2, 7       <i>; x     1     7  (0b111)</i>
lsl     w1, w0, w1      <i>; x     x&lt;&lt;1  7  (bitový posun doleva)</i>
lsr     w0, w0, w2      <i>; x&gt;&gt;7  x&lt;&lt;1  ?  (ve W0 bude jen nejnižší bit odpovídající původnímu sedmému bitu)</i>
orr     w0, w1, w0      <i>; x&gt;&gt;7 || x&lt;&lt;1   (W1 a W2 nás již nezajímá)</i>
</pre>

<p><div class="rs-tip-major">Poznámka: u AArch64 již nemáme k&nbsp;dispozici
bitové posuny prováděné &bdquo;zadarmo&ldquo; v&nbsp;rámci operace přesunu dat,
takže se vygenerovaný strojový kód v&nbsp;tomto ohledu odlišuje od 32bitové
varianty.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Rozdíl mezi operací rotace doleva a doprava</h2>

<p>Prozatím jsme si ukázali, jakým způsobem je přeložena vestavěná funkce
<strong>__builtin_stdc_rotate_left</strong>. Jen pro úplnost se podívejme na
prakticky totožný příklad, který ovšem nyní bude volat vestavěnou funkci
určenou pro rotaci doprava, tedy funkci
<strong>__builtin_stdc_rotate_right</strong>. Tuto funkci opět budeme volat
s&nbsp;celočíselnými operandy bez znaménka s&nbsp;různou bitovou šířkou:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
uint8_t <strong>rotate_right_8bit</strong>(uint8_t x, uint8_t y) {
    uint8_t z;
    z = <u>__builtin_stdc_rotate_right</u>(x, y);
    return z;
}
&nbsp;
uint16_t <strong>rotate_right_16bit</strong>(uint16_t x, uint16_t y) {
    uint16_t z;
    z = <u>__builtin_stdc_rotate_right</u>(x, y);
    return z;
}
&nbsp;
uint32_t <strong>rotate_right_32bit</strong>(uint32_t x, uint32_t y) {
    uint32_t z;
    z = <u>__builtin_stdc_rotate_right</u>(x, y);
    return z;
}
&nbsp;
uint64_t <strong>rotate_right_64bit</strong>(uint64_t x, uint64_t y) {
    uint64_t z;
    z = <u>__builtin_stdc_rotate_right</u>(x, y);
    return z;
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Překlad operace rotace doprava pro všechny analyzované platformy</h2>

<p>Rotace doprava přeložená pro platformu x86-64 bez povolení optimalizací.
Výsledné kódy sice nejsou příliš přehledné, ale vždy zde nalezneme instrukci
<strong>ROR</strong>:</p>

<pre>
<strong>rotate_right_8bit</strong>:
        push    rbp
        mov     rbp, rsp
        mov     edx, edi
        mov     eax, esi
        mov     BYTE PTR [rbp-20], dl
        mov     BYTE PTR [rbp-24], al
        movzx   edx, BYTE PTR [rbp-20]
        movzx   eax, BYTE PTR [rbp-24]
        movzx   eax, al
        and     eax, 7
        mov     ecx, eax
        ror     dl, cl
        mov     eax, edx
        mov     BYTE PTR [rbp-1], al
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
        ret
&nbsp;
<strong>rotate_right_16bit</strong>:
        push    rbp
        mov     rbp, rsp
        mov     edx, edi
        mov     eax, esi
        mov     WORD PTR [rbp-20], dx
        mov     WORD PTR [rbp-24], ax
        movzx   edx, WORD PTR [rbp-20]
        movzx   eax, WORD PTR [rbp-24]
        movzx   eax, ax
        and     eax, 15
        mov     ecx, eax
        ror     dx, cl
        mov     eax, edx
        mov     WORD PTR [rbp-2], ax
        movzx   eax, WORD PTR [rbp-2]
        pop     rbp
        ret
&nbsp;
<strong>rotate_right_32bit</strong>:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-20], edi
        mov     DWORD PTR [rbp-24], esi
        mov     edx, DWORD PTR [rbp-20]
        mov     eax, DWORD PTR [rbp-24]
        and     eax, 31
        mov     ecx, eax
        ror     edx, cl
        mov     eax, edx
        mov     DWORD PTR [rbp-4], eax
        mov     eax, DWORD PTR [rbp-4]
        pop     rbp
        ret
&nbsp;
<strong>rotate_right_64bit</strong>:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-24], rdi
        mov     QWORD PTR [rbp-32], rsi
        mov     rdx, QWORD PTR [rbp-24]
        mov     rax, QWORD PTR [rbp-32]
        and     eax, 63
        mov     ecx, eax
        ror     rdx, cl
        mov     rax, rdx
        mov     QWORD PTR [rbp-8], rax
        mov     rax, QWORD PTR [rbp-8]
        pop     rbp
        ret
</pre>

<p>Po povolení optimalizací je již prováděný postup zcela zřejmý &ndash; ve
všech případech je provedena rotace doprava instrukcí <strong>ROR</strong> o
počet bitů uložených v&nbsp;registru <strong>CL</strong> (nezávisle na bitové
šířce prvního operandu):</p>

<pre>
<strong>rotate_right_8bit</strong>:
        mov     eax, edi
        mov     ecx, esi
        ror     al, cl
        ret
&nbsp;
<strong>rotate_right_16bit</strong>:
        mov     eax, edi
        mov     ecx, esi
        ror     ax, cl
        ret
&nbsp;
<strong>rotate_right_32bit</strong>:
        mov     eax, edi
        mov     ecx, esi
        ror     eax, cl
        ret
&nbsp;
<strong>rotate_right_64bit</strong>:
        mov     rax, rdi
        mov     ecx, esi
        ror     rax, cl
        ret
</pre>

<p>Na 32bitové platformě ARM je instrukce <strong>ROR</strong> použita jen u
32bitové rotace. Pro rotace osmibitových bajtů nebo šestnáctibitových slov je
nutné rotaci simulovat dvojicí bitových posunů se složením výsledku pomocí
<strong>OR</strong>, což je postup, který jsme si vysvětlili u rotace
doleva:</p>

<pre>
<strong>rotate_right_8bit</strong>:
        and     r1, r1, #7
        rsb     r3, r1, #0
        and     r3, r3, #7
        lsl     r3, r0, r3
        orr     r0, r3, r0, lsr r1
        and     r0, r0, #255
        bx      lr
&nbsp;
<strong>rotate_right_16bit</strong>:
        and     r1, r1, #15
        rsb     r3, r1, #0
        and     r3, r3, #15
        lsl     r3, r0, r3
        orr     r0, r3, r0, lsr r1
        lsl     r0, r0, #16
        lsr     r0, r0, #16
        bx      lr
&nbsp;
<strong>rotate_right_32bit</strong>:
        and     r1, r1, #31
        ror     r0, r0, r1
        bx      lr
&nbsp;
<strong>rotate_right_64bit</strong>:
        push    {r4, lr}
        mov     lr, r0
        and     r2, r2, #63
        rsb     r4, r2, #32
        rsb     r3, r2, #0
        lsr     r0, r0, r2
        and     r3, r3, #63
        orr     r0, r0, r1, lsl r4
        sub     ip, r2, #32
        orr     r0, r0, r1, lsr ip
        sub     r4, r3, #32
        lsl     ip, r1, r3
        orr     r0, r0, lr, lsl r3
        orr     ip, ip, lr, lsl r4
        rsb     r3, r3, #32
        orr     ip, ip, lr, lsr r3
        orr     r1, ip, r1, lsr r2
        pop     {r4, lr}
        bx      lr
</pre>

<p>A konečně se podívejme na způsob překladu pro 64bitovou platformu AArch64.
Zde je &bdquo;nativní&ldquo; instrukce <strong>ROR</strong> volána pouze
v&nbsp;případě 32bitových a 64bitových rotací. Pro kratší operandy je opět
nutná simulace rotace bitovými posuny:</p>

<pre>
<strong>rotate_right_8bit</strong>:
        and     w1, w1, 7
        and     w0, w0, 255
        neg     w2, w1
        and     w2, w2, 7
        lsr     w1, w0, w1
        lsl     w0, w0, w2
        orr     w0, w1, w0
        ret
&nbsp;
<strong>rotate_right_16bit</strong>:
        and     w1, w1, 15
        and     w0, w0, 65535
        neg     w2, w1
        and     w2, w2, 15
        lsr     w1, w0, w1
        lsl     w0, w0, w2
        orr     w0, w1, w0
        ret
&nbsp;
<strong>rotate_right_32bit</strong>:
        ror     w0, w0, w1
        ret
&nbsp;
<strong>rotate_right_64bit</strong>:
        ror     x0, x0, x1
        ret
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Funkce pro výpočet parity v&nbsp;bajtu či vícebajtovém slovu</h2>

<p>Ve druhé polovině dnešního článku se budeme zabývat vestavěnými funkcemi
sloužícími pro výpočet parity, tj.&nbsp;počtu jedničkových bitů v&nbsp;bajtu či
vícebajtovém slovu. I s&nbsp;tímto výpočtem se lze relativně často setkat,
ovšem programovací jazyk C nenabízí pro výpočet parity žádné speciální
operátory. Namísto toho můžeme volat vestavěné funkce, které mají následující
hlavičku:</p>

<pre>
int <strong>__builtin_parity</strong>(unsigned int x)
int <strong>__builtin_parityl</strong>(unsigned long)
int <strong>__builtin_parityll</strong>(unsigned long long)
</pre>

<p>V&nbsp;novějších verzích překladače GCC je nabízena ještě generická varianta
výše uvedených funkcí, která má tuto hlavičku (za ... lze dosadit libovolný
celočíselný typ bez znaménka):</p>

<pre>
int <strong>__builtin_parityg</strong>(...)
</pre>

<p>A jak je parita spočítána interně? Nejjednodušší je to na platformě x86-64,
protože zde existuje paritní bit <strong>PF</strong>. Ten je (po příslušné
testovací či aritmetické operaci) nastaven na jedničku v&nbsp;případě, že má
výsledek sudou paritu (a pochopitelně je vynulován při liché paritě). A navíc
platforma x86-64 obsahuje instrukce <strong>SETcc</strong>, které dokážou
nastavit hodnotu ve zvoleném pracovním registru na nulu, pokud je splněna
podmínka specifikovaná v&nbsp;<strong>cc</strong>. A touto podmínkou může být
test paritního bitu <strong>PF</strong> na nulu nebo na jedničku:</p>

<pre>
SETP  cílový_registr
SETNP cílový_registr
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Volání vestavěných funkcí <strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong> a <strong>__builtin_parityll</strong></h2>

<p>V&nbsp;dalším demonstračním příkladu, který si posléze přeložíme pro všechny
sledované platformy, jsou volány vestavěné funkce
<strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong> a
<strong>__builtin_parityll</strong>. Na rozdíl od bitových rotací, v&nbsp;nichž
jsem použil datové typy <strong>uint??_t</strong> a <strong>int??_t</strong>,
nyní použiji původní označení typů v&nbsp;jazyku C, protože i vestavěné funkce
pro výpočet parity tyto datové typy mají ve své signatuře (a mapování mezi
těmito dvěma skupinami typů je platformově závislé):</p>

<pre>
int <strong>parity_char</strong>(unsigned char x) {
    return <u>__builtin_parity(x)</u>;
}

int <strong>parity_int</strong>(unsigned int x) {
    return <u>__builtin_parity(x)</u>;
}

int <strong>parity_long</strong>(unsigned long x) {
    return <u>__builtin_parityl(x)</u>;
}

int <strong>parity_long_long</strong>(unsigned long long x) {
    return <u>__builtin_parityll(x)</u>;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Realizace výpočtu parity na platformě x86-64</h2>

<p>Překlad <a href="#k13">výše uvedeného</a> příkladu pro platformu x86-64 bez
povolení optimalizací dopadne následovně (<a
href="https://godbolt.org/z/6n3rj8hKj">projekt v&nbsp;Compiler
Exploreru</a>):</p>

<pre>
<strong>parity_char</strong>:
        push    rbp
        mov     rbp, rsp
        mov     eax, edi
        mov     BYTE PTR [rbp-4], al
        movzx   eax, BYTE PTR [rbp-4]
        mov     edx, eax
        shr     edx, 16
        xor     eax, edx
        xor     al, ah
        setnp   al
        movzx   eax, al
        pop     rbp
        ret
&nbsp;
<strong>parity_int</strong>:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     eax, DWORD PTR [rbp-4]
        mov     edx, eax
        shr     edx, 16
        xor     eax, edx
        xor     al, ah
        setnp   al
        movzx   eax, al
        pop     rbp
        ret
&nbsp;
<strong>parity_long</strong>:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        mov     rax, QWORD PTR [rbp-8]
        mov     rdx, rax
        shr     rdx, 32
        xor     eax, edx
        mov     edx, eax
        shr     edx, 16
        xor     eax, edx
        xor     al, ah
        setnp   al
        movzx   eax, al
        pop     rbp
        ret
&nbsp;
<strong>parity_long_long</strong>:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        mov     rax, QWORD PTR [rbp-8]
        mov     rdx, rax
        shr     rdx, 32
        xor     eax, edx
        mov     edx, eax
        shr     edx, 16
        xor     eax, edx
        xor     al, ah
        setnp   al
        movzx   eax, al
        pop     rbp
        ret
</pre>

<p>Výsledek získaný po povolení všech optimalizací <a
href="https://godbolt.org/z/an8enWGTW">vypadá následovně</a>. Zde je již
patrné, že se skutečně využívá instrukce <strong>setnp</strong>. U 16bitových,
32bitových a 64bitových operandů jsou jednotlivé části nejdříve smíchány
instrukcí <strong>XOR</strong>, která nemá na výsledek výpočtu parity žádný
vliv. Postupně tedy získáme pouze osmibitový mezivýsledek, na který je již
možné instrukci <strong>setnp</strong> aplikovat:</p>

<pre>
<strong>parity_char</strong>:
        xor     eax, eax
        test    dil, dil
        setnp   al
        ret
&nbsp;
<strong>parity_int</strong>:
        mov     eax, edi
        shr     eax, 16
        xor     eax, edi
        xor     al, ah
        setnp   al
        movzx   eax, al
        ret
&nbsp;
<strong>parity_long</strong>:
        mov     rax, rdi
        shr     rax, 32
        xor     eax, edi
        mov     edx, eax
        shr     edx, 16
        xor     eax, edx
        xor     al, ah
        setnp   al
        movzx   eax, al
        ret
&nbsp;
<strong>parity_long_long</strong>:
        mov     rax, rdi
        shr     rax, 32
        xor     eax, edi
        mov     edx, eax
        shr     edx, 16
        xor     eax, edx
        xor     al, ah
        setnp   al
        movzx   eax, al
        ret
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Realizace výpočtu parity na platformě ARM32</h2>

<p>Na 32bitové platformě ARM není výpočet parity realizován jednou instrukcí,
ale podprogramem (subrutinou). Zde tedy můžeme předpokládat relativně pomalé
výpočty této operace:</p>

<pre>
<strong>parity_char</strong>:
        push    {r4, lr}
        bl      __paritysi2
        pop     {r4, lr}
        bx      lr
&nbsp;
<strong>parity_int</strong>:
        push    {r4, lr}
        bl      __paritysi2
        pop     {r4, lr}
        bx      lr
&nbsp;
<strong>parity_long</strong>:
        push    {r4, lr}
        bl      __paritysi2
        pop     {r4, lr}
        bx      lr
&nbsp;
<strong>parity_long_long</strong>:
        push    {r4, lr}
        bl      __paritydi2
        pop     {r4, lr}
        bx      lr
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;tohoto pohledu je na tom
platforma ARM32 vlastně nejhůře.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Realizace výpočtu parity na platformě ARM64 (AArch64)</h2>

<p>Nejzajímavější je způsob překladu výpočtu parity na platformě AArch64. Zde
se totiž využívá instrukce <strong>cnt</strong>, která zjistí počet
jedničkových bitů. Ovšem zajímavé je, že tato instrukce pracuje
s&nbsp;&bdquo;vektorovými&ldquo; registry <strong>Vxx</strong> a nikoli
s&nbsp;běžnými celočíselnými pracovními registry. Takže si nejdříve uveďme,
s&nbsp;jakými registry se vlastně na této platformě pracuje.</p>

<p>Původních patnáct pracovních registrů pojmenovaných <strong>R0</strong> až
<strong>R14</strong>, které známe z&nbsp;32bitových procesorů ARM, bylo
rozšířeno na 31 registrů, z&nbsp;nichž každý má šířku 64 bitů. Z&nbsp;tohoto
důvodu muselo dojít k&nbsp;úpravě pojmenování registrů způsobem, který je
naznačený v&nbsp;následující tabulce:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>r0..r30</td><td>použito například v&nbsp;dokumentaci, popisu ABI atd.</td></tr>
<tr><td>x0..x30</td><td>celý 64bitový registr použitý jako zdroj či cíl</td></tr>
<tr><td>w0..w30</td><td>spodních 32 bitů registru (horních 32 bitů výsledku je buď vynulováno nebo znaménkově rozšířeno)</td></tr>
</table>

<p>Další sada registrů je používána při operacích s&nbsp;typy
<i>single/float</i> a <i>double</i> (tedy s&nbsp;operandy reprezentovanými
v&nbsp;systému plovoucí řádové čárky), u SIMD operací a taktéž kryptografickým
modulem:</p>

<p>Povšimněte si, že &ndash; na rozdíl od mnoha jiných architektur &ndash;
nedochází k&nbsp;tomu, že by se například dva single registry mapovaly do
jednoho double registru atd.</p>

<pre>
<strong>parity_char</strong>:
        and     x0, x0, 255
        fmov    d31, x0
        cnt     v31.8b, v31.8b
        addv    b31, v31.8b
        fmov    w0, s31
        and     w0, w0, 1
        ret
&nbsp;
<strong>parity_int</strong>:
        fmov    s31, w0
        cnt     v31.8b, v31.8b
        addv    b31, v31.8b
        fmov    w0, s31
        and     w0, w0, 1
        ret
&nbsp;
<strong>parity_long</strong>:
        fmov    d31, x0
        cnt     v31.8b, v31.8b
        addv    b31, v31.8b
        fmov    x0, d31
        and     w0, w0, 1
        ret
&nbsp;
<strong>parity_long_long</strong>:
        fmov    d31, x0
        cnt     v31.8b, v31.8b
        addv    b31, v31.8b
        fmov    x0, d31
        and     w0, w0, 1
        ret
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výpočet parity a celočíselné datové typy se znaménkem</h2>

<p>Vestavěné funkce <strong>__builtin_parity</strong>,
<strong>__builtin_parityl</strong> a <strong>__builtin_parityll</strong> jsou
definovány pro parametry typu celé číslo bez znaménka (<i>unsigned</i>),
protože pro typy se znaménkem je výpočet poněkud nejasný především ze
<i>sémantického</i> pohledu (operace pracují s&nbsp;vektorem bitů, zatímco
záporné hodnoty mají různé způsoby vyjádření). Teoreticky by nás tedy měl
překladač jazyka C varovat, pokud se pokusíme o překlad tohoto kódu:</p>

<pre>
int <strong>parity_char</strong>(signed char x) {
    return <u>__builtin_parity</u>(x);
}
&nbsp;
int <strong>parity_int</strong>(signed int x) {
    return <u>__builtin_parity</u>(x);
}
&nbsp;
int <strong>parity_long</strong>(signed long x) {
    return <u>__builtin_parityl</u>(x);
}
&nbsp;
int <strong>parity_long_long</strong>(signed long long x) {
    return <u>__builtin_parityll</u>(x);
}
</pre>

<p>V&nbsp;případě, že překlad provedeme například s&nbsp;následujícími
přepínači, překladač žádné varování ani chyby nevypíše:</p>

<pre>
$ <strong>gcc -Wall -Werror parity_signed.c</strong>
</pre>

<p>Aby se potenciální problémy s&nbsp;hodnotami se znaménkem detekovaly, je nutné </p>

<pre>
$ <strong>gcc -Wall -Werror -Wconversion parity_signed.c</strong>
</pre>

<p>V&nbsp;tomto případě bude skutečně detekován problém při konverzi hodnot
z&nbsp;typu se znaménkem na typ bez znaménka:</p>

<pre>
parity_signed.c: In function ‘parity_char’:
parity_signed.c:2:29: error: conversion to ‘unsigned int’ from ‘signed char’ may change the sign of the result [-Werror=sign-conversion]
    2 |     return __builtin_parity(x);
      |                             ^
parity_signed.c: In function ‘parity_int’:
parity_signed.c:6:29: error: conversion to ‘unsigned int’ from ‘int’ may change the sign of the result [-Werror=sign-conversion]
    6 |     return __builtin_parity(x);
      |                             ^
parity_signed.c: In function ‘parity_long’:
parity_signed.c:10:30: error: conversion to ‘long unsigned int’ from ‘long int’ may change the sign of the result [-Werror=sign-conversion]
   10 |     return __builtin_parityl(x);
      |                              ^
parity_signed.c: In function ‘parity_long_long’:
parity_signed.c:14:31: error: conversion to ‘long long unsigned int’ from ‘long long int’ may change the sign of the result [-Werror=sign-conversion]
   14 |     return __builtin_parityll(x);
      |                               ^
cc1: all warnings being treated as errors
</pre>

<p>V&nbsp;případě, že budeme volat modernější vestavěnou funkci
<strong>__builtin_parityg</strong>, budou se problémy hlásit i v&nbsp;případě,
že přepínač <strong>-Wconversion</strong> nepoužijeme. Ověřit si to opět můžeme
velmi jednoduchým pokusem:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
int <strong>parity_8bit</strong>(int8_t x) {
    return <u>__builtin_parityg</u>(x);
}
&nbsp;
int <strong>parity_16bit</strong>(int16_t x) {
    return <u>__builtin_parityg</u>(x);
}
&nbsp;
int <strong>parity_32bit</strong>(int32_t x) {
    return <u>__builtin_parityg</u>(x);
}
&nbsp;
int <strong>parity_64bit</strong>(int64_t x) {
    return <u>__builtin_parityg</u>(x);
}
</pre>

<p>Chybová hlášení vypsaná překladačem GCC by měla vypadat následovně:</p>

<pre>
parityg_signed.c: In function ‘parity_8bit’:
parityg_signed.c:4:30: error: argument 1 in call to function ‘__builtin_parityg’ has signed type
    4 |     return __builtin_parityg(x);
      |                              ^
parityg_signed.c: In function ‘parity_16bit’:
parityg_signed.c:8:30: error: argument 1 in call to function ‘__builtin_parityg’ has signed type
    8 |     return __builtin_parityg(x);
      |                              ^
parityg_signed.c: In function ‘parity_32bit’:
parityg_signed.c:12:30: error: argument 1 in call to function ‘__builtin_parityg’ has signed type
   12 |     return __builtin_parityg(x);
      |                              ^
parityg_signed.c: In function ‘parity_64bit’:
parityg_signed.c:16:30: error: argument 1 in call to function ‘__builtin_parityg’ has signed type
   16 |     return __builtin_parityg(x);
      |                              ^
parityg_signed.c: In function ‘parity_8bit’:
parityg_signed.c:5:1: error: control reaches end of non-void function [-Werror=return-type]
    5 | }
      | ^
parityg_signed.c: In function ‘parity_16bit’:
parityg_signed.c:9:1: error: control reaches end of non-void function [-Werror=return-type]
    9 | }
      | ^
parityg_signed.c: In function ‘parity_32bit’:
parityg_signed.c:13:1: error: control reaches end of non-void function [-Werror=return-type]
   13 | }
      | ^
parityg_signed.c: In function ‘parity_64bit’:
parityg_signed.c:17:1: error: control reaches end of non-void function [-Werror=return-type]
   17 | }
      | ^
cc1: all warnings being treated as errors
</pre>

<p><div class="rs-tip-major">Poznámka: to znamená, že je většinou výhodnější
volat vestavěnou funkci <strong>__builtin_parityg</strong> a nikoli její starší
varianty <strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong>
či <strong>__builtin_parityll</strong>.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Další bitové operace podporované vestavěnými funkcemi GCC</h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
s&nbsp;využitím překladače <strong>gcc</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>rotate_left.c</td><td>volání vestavěné funkce v&nbsp;C (GCC) realizující rotaci doleva</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left.c</a></td></tr>
<tr><td> 2</td><td>rotate_left_x86_00.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_00.asm</a></td></tr>
<tr><td> 3</td><td>rotate_left_x86_09.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_09.asm</a></td></tr>
<tr><td> 4</td><td>rotate_left_arm32.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm32.asm</a></td></tr>
<tr><td> 5</td><td>rotate_left_arm64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>rotate_right.c</td><td>volání vestavěné funkce v&nbsp;C (GCC) realizující rotaci doleva</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right.c</a></td></tr>
<tr><td> 7</td><td>rotate_right_x86_00.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_00.asm</a></td></tr>
<tr><td> 8</td><td>rotate_right_x86_09.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_09.asm</a></td></tr>
<tr><td> 9</td><td>rotate_right_arm32.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm32.asm</a></td></tr>
<tr><td>10</td><td>rotate_right_arm64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>parity_unsigned.c</td><td>volání vestavěných funkcí <strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong> a <strong>__builtin_parityll</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned.c</a></td></tr>
<tr><td>12</td><td>parity_unsigned_x86_00.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_00.asm</a></td></tr>
<tr><td>13</td><td>parity_unsigned_x86_09.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_09.asm</a></td></tr>
<tr><td>14</td><td>parity_unsigned_arm32.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm32.asm</a></td></tr>
<tr><td>15</td><td>parity_unsigned_arm64.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>parityg_unsigned.c</td><td>volání vestavěné funkce <strong>__builtin_parityg</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned.c</a></td></tr>
<tr><td>17</td><td>parityg_unsigned_arm32.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm32.asm</a></td></tr>
<tr><td>18</td><td>parityg_unsigned_arm64.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm64.asm</a></td></tr>
<tr><td>19</td><td>parityg_unsigned_x86_00.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_00.asm</a></td></tr>
<tr><td>20</td><td>parityg_unsigned_x86_09.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_09.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>parity_signed.c</td><td>výpočet parity celočíselných hodnot se znaménkem: realizace pomocí vestavěných funkcí <strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong> a <strong>__builtin_parityll</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_signed.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_signed.c</a></td></tr>
<tr><td>22</td><td>parityg_signed.c</td><td>výpočet parity celočíselných hodnot se znaménkem: realizace pomocí vestavěné funkce <strong>__builtin_parityg</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_signed.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_signed.c</a></td></tr>
</table>

<p>Všechny demonstrační příklady z&nbsp;článku <a
href="https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/">Funkce
vestavěné v&nbsp;GCC pro provádění nízkoúrovňových aritmetických operací</a>
jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add_overflow.c</td><td>volání vestavěné funkce <strong>__builtin_add_overflow</strong> s&nbsp;předáním operandů různých typů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow.c</a></td></tr>
<tr><td> 2</td><td>add_overflow_x86_64_O0.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_O0.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_O0.asm</a></td></tr>
<tr><td> 3</td><td>add_overflow_x86_64_Os.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_Os.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_Os.asm</a></td></tr>
<tr><td> 4</td><td>add_overflow_arm_32.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_32.asm</a></td></tr>
<tr><td> 5</td><td>add_overflow_arm_64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>add_diff_types.c</td><td>součet s&nbsp;využitím různých kombinací hodnot typu <strong>char</strong> a <strong>int</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types.c</a></td></tr>
<tr><td> 7</td><td>add_diff_types_x86_64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_x86_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_x86_64.asm</a></td></tr>
<tr><td> 8</td><td>add_diff_types_arm32.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm32.asm</a></td></tr>
<tr><td> 9</td><td>add_diff_types_arm64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>sub_overflow.c</td><td>operace rozdílu s&nbsp;využitím funkce <strong>__builtin_sub_overflow</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.c</a></td></tr>
<tr><td>11</td><td>sub_overflow.asm</td><td>překlad volání funkce <strong>__builtin_sub_overflow</strong> na platformě x86-64</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>addc_subc.c</td><td>operace součtu tří hodnot a operace rozdílu: s&nbsp;výpůjčkou nebo s&nbsp;přetečením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/addc_subc.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/addc_subc.asm</a></td></tr>
</table>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>rdrand_support.asm</td><td>test, jestli je instrukce <strong>RDRAND</strong> mikroprocesorem podporována</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm</a></td></tr>
<tr><td>2</td><td>rdrand_read.asm</td><td>přečtení jedné 32bitové hodnoty instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm</a></td></tr>
<tr><td>3</td><td>rdrand_read_loop.asm</td><td>přečtení sekvence 32bitových hodnot instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>rdrand_read.c</td><td>přečtení náhodné 32bitové hodnoty, realizace s&nbsp;využitím vestavěné funkce GCC</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c</a></td></tr>
<tr><td>5</td><td>rdrand_read.asm</td><td>výsledek překladu předchozího zdrojového kódu do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>rand_gen.c</td><td>vygenerování binárního souboru s&nbsp;pseudonáhodnými 32bitovými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c</a></td></tr>
<tr><td>7</td><td>rdrand_gen.c</td><td>vygenerování binárního souboru s&nbsp;hodnotami vrácenými instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Funkce vestavěné v&nbsp;GCC pro provádění nízkoúrovňových aritmetických operací<br />
<a href="https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/">https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/</a>
</li>

<li>Generátor náhodných čísel založený na instrukcích RDSEED a RDRAND<br />
<a href="https://www.root.cz/clanky/generator-nahodnych-cisel-zalozeny-na-instrukcich-rdseed-a-rdrand/">https://www.root.cz/clanky/generator-nahodnych-cisel-zalozeny-na-instrukcich-rdseed-a-rdrand/</a>
</li>

<li>Circular shift (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Bitwise_operation#Circular_shift">https://en.wikipedia.org/wiki/Bitwise_operation#Circular_shift</a>
</li>

<li>Parity bit (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Parity_bit">https://en.wikipedia.org/wiki/Parity_bit</a>
</li>

<li>Parity function (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Parity_function">https://en.wikipedia.org/wiki/Parity_function</a>
</li>

<li>RDRAND (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RDRAND">https://en.wikipedia.org/wiki/RDRAND</a>
</li>

<li>RDRAND instruction<br />
<a href="https://www.felixcloutier.com/x86/rdrand">https://www.felixcloutier.com/x86/rdrand</a>
</li>

<li>Random Number Generator<br />
<a href="https://wiki.osdev.org/Random_Number_Generator">https://wiki.osdev.org/Random_Number_Generator</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Other Built-in Functions Provided by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>
</li>

<li>GCC: 6.60 Built-in Functions Specific to Particular Target Machines<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins">https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins</a>
</li>

<li>Additional Builtins for Numeric Operations<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Numeric-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Numeric-Builtins.html</a>
</li>

<li>Bit Operation Builtins<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Bit-Operation-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Bit-Operation-Builtins.html</a>
</li>

<li>Stránka projektu Compiler Explorer<br />
<a href="https://godbolt.org/">https://godbolt.org/</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://llvm.org/">https://llvm.org/</a>
</li>

<li>GCC, the GNU Compiler Collection<br />
<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>
</li>

<li>Clang<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Clang: Assembling a Complete Toolchain<br />
<a href="https://clang.llvm.org/docs/Toolchain.html">https://clang.llvm.org/docs/Toolchain.html</a>
</li>

<li>Integer overflow<br />
<a href="https://en.wikipedia.org/wiki/Integer_overflow">https://en.wikipedia.org/wiki/Integer_overflow</a>
</li>

<li>SETcc — Set Byte on Condition<br />
<a href="https://www.felixcloutier.com/x86/setcc">https://www.felixcloutier.com/x86/setcc</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>Undefined behavior (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Undefined_behavior">https://en.wikipedia.org/wiki/Undefined_behavior</a>
</li>

<li>Is signed integer overflow still undefined behavior in C++?<br />
<a href="https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c">https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c</a>
</li>

<li>Allowing signed integer overflows in C/C++<br />
<a href="https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c">https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c</a>
</li>

<li>SXTB, SXTH, SXTW<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html">https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html</a>
</li>

<li>BX, BXNS<br />
<a href="https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions/bx--bxns?lang=en">https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions/bx--bxns?lang=en</a>
</li>

<li>Carry and Borrow Principles<br />
<a href="https://www.tpub.com/neets/book13/53a.htm">https://www.tpub.com/neets/book13/53a.htm</a>
</li>

<li>In binary subtraction, how do you handle a borrow when there are no bits left to borrow form<br />
<a href="https://stackoverflow.com/questions/68629408/in-binary-subtraction-how-do-you-handle-a-borrow-when-there-are-no-bits-left-to">https://stackoverflow.com/questions/68629408/in-binary-subtraction-how-do-you-handle-a-borrow-when-there-are-no-bits-left-to</a>
</li>

<li>Is there any legitimate use for Intel's RDRAND?<br />
<a href="https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand">https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand</a>
</li>

<li>Intel® Digital Random Number Generator (DRNG) Software Implementation Guide<br />
<a href="https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html">https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html</a>
</li>

<li>Hardware random number generator<br />
<a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">https://en.wikipedia.org/wiki/Hardware_random_number_generator</a>
</li>

<li>Random number generator attack<br />
<a href="https://en.wikipedia.org/wiki/Random_number_generator_attack">https://en.wikipedia.org/wiki/Random_number_generator_attack</a>
</li>

<li>random_r.c (Glibc)<br />
<a href="https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341">https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341</a>
</li>

<li>Xorshift<br />
<a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

