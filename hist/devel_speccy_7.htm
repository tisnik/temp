<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Dokončení realizace příkazu <strong>PLOT</strong></a></p>
<p><a href="#k02">2. Vyplnění obrazovky inverzními znaky z&nbsp;ASCII tabulky</a></p>
<p><a href="#k03">3. Úplný zdrojový kód demonstračního příkladu pro tisk inverzních ASCII tabulek</a></p>
<p><a href="#k04">4. Původní rutina pro vykreslení pixelu použitá společně s&nbsp;inverzní ASCII tabulkou</a></p>
<p><a href="#k05">5. Úplný zdrojový kód dnešního druhého demonstračního příkladu</a></p>
<p><a href="#k06">6. Vykreslení jediného pixelu barvou papíru</a></p>
<p><a href="#k07">7. Úprava vykreslovací rutiny <strong>PLOT</strong> pro korektní kreslení barvou papíru</a></p>
<p><a href="#k08">8. Úplný zdrojový kód dnešního třetího demonstračního příkladu</a></p>
<p><a href="#k09">9. Jak vytvořit subrutinu pro tisk normální i inverzní ASCII tabulky?</a></p>
<p><a href="#k10">*** 10. Samomodifikující se kód na mikroprocesoru Zilog Z80</a></p>
<p><a href="#k11">11. Úprava subrutiny pro vykreslení znaku</a></p>
<p><a href="#k12">*** 12. Řízená modifikace předchozí subrutiny v&nbsp;čase běhu programu</a></p>
<p><a href="#k13">13. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</a></p>
<p><a href="#k14">*** 14. Vykreslení pixelu metodou <strong>PLOT OVER</strong> (inverze)</a></p>
<p><a href="#k15">*** 15. Inverze celé obrazovky tím nejpomalejším způsobem &ndash; pixel po pixelu</a></p>
<p><a href="#k16">*** 16. Úplný zdrojový kód dnešního posledního demonstračního příkladu</a></p>
<p><a href="#k17">*** 17. Obsah navazujícího článku</a></p>
<p><a href="#k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Dokončení realizace příkazu <strong>PLOT</strong></h2>

<p>V pořadí již sedmé části <a
href="https://www.root.cz/serialy/vyvoj-pro-slavne-zx-spectrum/">seriálu o
vývoji programů pro legendární osmibitový domácí mikropočítač ZX Spectrum</a>
dokončíme až kupodivu velmi rozsáhlé a netriviální téma, kterému jsme se
věnovali <a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-podruhe/">předminule</a>
i <a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-potreti/">minule</a>.
Jedná se o vlastní implementaci podprogramu (neboli <i>subrutiny</i>)
naprogramované v&nbsp;assembleru osmibitového mikroprocesoru Zilog Z80, přičemž
tato subrutina bude napodobovat příkaz <strong>PLOT</strong> ze Sinclair
BASICu. Tento příkaz slouží pro vykreslení jediného pixelu na obrazovku;
programátor přitom může určit, zda se vykreslení provede barvou inkoustu
(v&nbsp;BASICu se používá jméno <i>ink</i>), barvou papíru (<i>paper</i>) nebo
zda se má již nakreslený pixel invertovat (z&nbsp;barvy inkoustu na barvu
papíru či naopak).</p>

<img src="https://i.iinfo.cz/images/81/devel-speccy-6-3.png" class="image-1083887" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 1: První verze programu realizujícího rutinu
<strong>PLOT</strong>: postupné vykreslování úsečky z&nbsp;&bdquo;blokových
pixelů&ldquo;.</i></p>

<p>V&nbsp;závěru předchozího článku, konkrétně <a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-potreti/#k17">v&nbsp;sedmnácté
kapitole</a>, je uveden výpis demonstračního příkladu, jenž dokáže vykreslit
pixel (resp.&nbsp;pixely) barvou inkoustu a přitom nepřemazat pixely
v&nbsp;okolí. Úspěšně jsme tedy realizovali první krok k&nbsp;implementaci
plnohodnotného příkazu <strong>PLOT</strong>. Dnes si ukážeme další dvě možné
varianty příkazu <strong>PLOT</strong>, a to konkrétně vykreslení pixelu barvou
papíru a inverzi pixelu.</p>

<img src="https://i.iinfo.cz/images/81/devel-speccy-6-14.png" class="image-1083891" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 2: Druhá verze programu realizujícího rutinu
<strong>PLOT</strong>: postupné vykreslování úsečky z&nbsp;&bdquo;úzkých
pixelů&ldquo;, ovšem s&nbsp;přepisem pozadí (ostatních sedmi pixelů
v&nbsp;bloku).</i></p>

<p>Budeme se zabývat i tvorbou takzvaného <i>samomodifikujícího se kódu</i>.
Jedná se o zajímavou techniku, v&nbsp;níž běžící program přepíše část sebe
samého takovým způsobem, aby se dosáhlo kýženého efektu. Tato technika kromě
optimalizace na velikost programu popř.&nbsp;na rychlost jeho běhu navíc
umožňuje, aby se minimalizoval počet parametrů vstupujících do složitěji
strukturovaného kódu, protože obecně platí, že předávání většího množství
parametrů je na (vlastně všech) typech mikroprocesorů relativně
problematické.</p>

<img src="https://i.iinfo.cz/images/81/devel-speccy-6-17.png" class="image-1083901" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 3: Třetí verze programu realizujícího rutinu
<strong>PLOT</strong>: postupné vykreslování úsečky z&nbsp;&bdquo;úzkých
pixelů&ldquo;.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vyplnění obrazovky inverzními znaky z&nbsp;ASCII tabulky</h2>

<p>Ještě předtím, než se budeme zabývat úpravou podprogramu (<i>subrutiny</i>)
určené pro vykreslení pixelu, si, ostatně podobně jako <a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-potreti/">v&nbsp;předchozím
článku</a>, ukážeme program, který po svém spuštění vykreslí na obrazovku ZX
Spectra několik ASCII tabulek, ovšem inverzně &ndash; to konkrétně znamená, že
text (znak) bude vykreslen barvou papíru a okolí textu barvou inkoustu. Tento
podprogram budeme potřebovat z&nbsp;toho prostého důvodu, abychom zaplnili
plochu pozadí nějakým vzorkem, na němž bude patrné, zda vykreslovací rutina
<strong>PLOT</strong> pracuje korektně či nikoli. Výsledná obrazovka vykreslená
novou subrutinou by přitom měla vypadat následovně:</p>

*** image ***
<p><i>Obrázek 4: Inverzní znaky z&nbsp;ASCII tabulky.</i></p>

<p>Úprava podprogramu pro tisk znaků tak, aby se znaky vytiskly inverzně, je
velmi jednoduchá, protože postačuje přidat strojovou instrukci pro negaci
celého bajtu, který je zapisován na obrazovku (jak uvidíme dále, je tato
operace pro znaky jednodušší, než pro jednotlivé pixely). Původní podprogram
vypadal takto:</p>

<pre>
<strong>draw_char</strong>:
        <i>; Vytištění jednoho znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop2</strong>:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop2               <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
</pre>

<p>Po výše zmíněné úpravě získáme následující subrutinu (viz podtržená část
kódu, která byla modifikována):</p>

<pre>
<strong>draw_char_inv</strong>:
        <i>; Vytištění jednoho inverzního znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop</strong>:
        <u>ld   a,(hl)</u>              <i>; načtení jednoho bajtu z masky</i>
        <u>cpl</u>                      <i>; negace hodnoty v akumulátoru</i>
        <u>ld   (de),a</u>              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Úplný zdrojový kód demonstračního příkladu pro tisk inverzních ASCII tabulek</h2>

<p>Úplný zdrojový kód demonstračního příkladu popsaného <a href="#k02">ve druhé
kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm</a>:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call fill_in_screen      <i>; vyplnění obrazovky ASCII tabulkami</i>
<strong>finito</strong>:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR         <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        ret                       <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_ascii_table_inv</strong>:
        <i>; Vytištění ASCII tabulky inverzně (barva inkoustu je barvou pozadí a naopak)</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char_inv       <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char_inv       <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_char_inv</strong>:
        <i>; Vytištění jednoho inverzního znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop</strong>:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        cpl                      <i>; negace hodnoty v akumulátoru</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledek překladu tohoto programu do strojového kódu vypadá takto:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:CD0580     CALL 8005
8003:           label finito
8003:18FE       JR 8003
8005:           label fill_in_screen
8005:110040     LD DE, 4000
8008:CD1580     CALL 8015
800B:CD1580     CALL 8015
800E:CD1580     CALL 8015
8011:CD1580     CALL 8015
8014:C9         RET
8015:           label draw_ascii_table_inv
8015:3E20       LD A, 20
8017:           label next_char
8017:F5         PUSH AF
8018:CD2780     CALL 8027
801B:3E20       LD A, 20
801D:CD2780     CALL 8027
8020:F1         POP AF
8021:3C         INC A
8022:FE80       CP 80
8024:20F1       JR NZ, 8017
8026:C9         RET
8027:           label draw_char_inv
8027:01003C     LD BC, 3C00
802A:61         LD H, C
802B:6F         LD L, A
802C:29         ADD HL, HL
802D:29         ADD HL, HL
802E:29         ADD HL, HL
802F:09         ADD HL, BC
8030:0608       LD B, 08
8032:4A         LD C, D
8033:           label loop
8033:7E         LD A, (HL)
8034:2F         CPL
8035:12         LD (DE), A
8036:2C         INC L
8037:14         INC D
8038:10F9       DJNZ 8033
803A:1C         INC E
803B:C8         RET Z
803C:51         LD D, C
803D:C9         RET
803E:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 803D
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Původní rutina pro vykreslení pixelu použitá společně s&nbsp;inverzní ASCII tabulkou</h2>

<p>Jen pro úplnost si ukažme, jak bude vypadat obrazovka ZX Spectra, pokud na
ní nejdříve vykreslíme sadu inverzních ASCII tabulek a následně do této scény
vykreslíme diagonální úsečku s&nbsp;černými pixely resp.&nbsp;přesněji řečeno
s&nbsp;pixely vykreslenými inkoustem (<i>ink</i>). Výsledná úsečka nebude
(zcela podle očekávání) příliš viditelná:</p>

*** image ***
<p><i>Obrázek 5: Úsečka vytvořená černými pixely vykreslenými nad (převážně) tmavým pozadím.</i></p>

<p><div class="rs-tip-major">Poznámka: tento příklad v&nbsp;rámci navazujícího
textu upravíme takovým způsobem, že úsečka bude vykreslena z&nbsp;pixelů
s&nbsp;barvou papíru (<i>paper</i>).</div></p>

<p>Samotné tělo programu se nebude příliš lišit od příkladů ukázaných
v&nbsp;předchozím článku. Jeho základní kostra (<strong>main</strong>) zůstane
zcela zachována:</p>

<pre>
<strong>start</strong>:
        call <strong>fill_in_screen</strong>      <i>; vyplnění obrazovky ASCII tabulkami</i>
&nbsp;
        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
<strong>loop</strong>:
        call <strong>plot</strong>                <i>; vykreslení pixelu</i>
        call <strong>dela</strong>y
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, loop              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
<strong>finito</strong>:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
</pre>

<p>Rozdíl spočívá v&nbsp;poněkud odlišně realizované rutině
<strong>fill_in_screen</strong>, která bude vykreslovat inverzní ASCII
tabulky:</p>

<pre>
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR         <i>; adresa pro vykreslení prvního bloku znaků</i>
        call <strong>draw_ascii_table_inv</strong> <i>; vykreslení 96 znaků</i>
        call <strong>draw_ascii_table_inv</strong> <i>; vykreslení 96 znaků</i>
        call <strong>draw_ascii_table_inv</strong> <i>; vykreslení 96 znaků</i>
        call <strong>draw_ascii_table_inv</strong> <i>; vykreslení 96 znaků</i>
        ret                       <i>; návrat z podprogramu</i>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Úplný zdrojový kód dnešního druhého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm</a>
a vypadá následovně:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call fill_in_screen      <i>; vyplnění obrazovky ASCII tabulkami</i>
&nbsp;
        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
<strong>loop</strong>:
        call plot                <i>; vykreslení pixelu</i>
        call delay
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, loop              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
<strong>finito</strong>:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>delay</strong>:
        <i>; zpožďovací rutina</i>
        <i>; nemění žádné registry</i>
        push bc                  <i>; uschovat hodnoty registrů, které se používají ve smyčkách</i>
        ld   b, 20               <i>; počitadlo vnější zpožďovací smyčky</i>
<strong>outer_loop</strong>:
        ld   c, 0                <i>; počitadlo vnitřní zpožďovací smyčky</i>
<strong>inner_loop</strong>:
        dec  c                   <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr   NZ, inner_loop      <i>; opakovat, dokud není dosaženo nuly</i>
        djnz outer_loop          <i>; opakovat vnější smyčku, nyní s počitadlem v B</i>
        pop  bc                  <i>; obnovit hodnoty registrů změněných smyčkami</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>plot</strong>:
        <i>; třetí varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld d, (hl)               <i>; přečíst původní hodnotu osmice pixelů</i>
        or d                     <i>; použít vypočtenou masku pro nastavení jediného bitu</i>
        ld (hl), a               <i>; zápis hodnoty pixelu (ostatních sedm pixelů se nezmění)</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>calc_pixel_value</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; A - hodnota pixelu</i>
        push bc                  <i>; zapamatovat si hodnotu v registru B</i>
        ld   a, b                <i>; A: X7 X6 X5 X4 X3 X2 X1 X0 </i>
        and  %00000111           <i>; A: 0  0  0  0  0  X2 X1 X0</i>
        ld b, a                  <i>; počitadlo smyčky (neměníme příznaky)</i>
        ld a, %10000000          <i>; výchozí maska (neměníme příznaky)</i>
        jr z, end_calc           <i>; pokud je nyní souřadnice nulová, zapíšeme výchozí masku + konec</i>
&nbsp;
<strong>next_shift</strong>:
        srl a                    <i>; posunout masku doprava</i>
        djnz next_shift          <i>; 1x až 7x</i>
<strong>end_calc</strong>:
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>calc_pixel_address</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis pixelu</i>
        <i>;</i>
        <i>; pozměněné registry:</i>
        <i>; A</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y7 Y6 Y2 Y1 Y0 | Y5 Y4 Y3 X4 X3 X2 X1 X0</i>
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (Y2 Y1 Y0)</i>
                              <i>; A: 0 0 0 0 0 Y2 Y1 Y0</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; část horního bajtu adresy je vypočtena</i>
                              <i>; H: 0 1 0 0 0 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> Y1 Y0 xx Y7 Y6 Y5 Y4 Y3</i>
        and %00011000         <i>; zamaskovat</i>
                              <i>; A: 0  0  0 Y7 Y6  0  0  0</i>
        or  h                 <i>; a přidat k vypočtenému mezivýsledku</i>
        ld  h, a              <i>; H: 0  1  0 Y7 Y6 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rla
        rla                   <i>; A:  Y5 Y4 Y3 Y2 Y1 Y0 xx xx</i>
        and %11100000         <i>; A:  Y5 Y4 Y3 0  0  0  0  0</i>
        ld  l, a              <i>; část spodního bajtu adresy je vypočtena</i>
&nbsp;
        ld  a, b              <i>; všech osm bitů X-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> 0  0  0  X7 X6 X5 X4</i>
        and %00011111         <i>; A: 0  0  0  X7 X6 X5 X4 X3</i>
        or  l                 <i>; A: Y5 Y3 Y3 X7 X6 X5 X4 X3</i>
        ld  l, a              <i>; spodní bajt adresy je vypočten</i>
&nbsp;
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR         <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        ret                       <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_ascii_table_inv</strong>:
        <i>; Vytištění ASCII tabulky inverzně (barva inkoustu je barvou pozadí a naopak)</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char_inv       <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char_inv       <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_char_inv</strong>:
        <i>; Vytištění jednoho inverzního znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
loop2:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        cpl                      <i>; negace hodnoty v akumulátoru</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop2               <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Pochopitelně si opět pro úplnost ukážeme, jakým způsobem byl proveden
překlad do strojového kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:CD5880     CALL 8058
8003:0600       LD B, 00
8005:0E00       LD C, 00
8007:           label loop
8007:CD2280     CALL 8022
800A:CD1680     CALL 8016
800D:04         INC B
800E:0C         INC C
800F:78         LD A, B
8010:FEC0       CP C0
8012:20F3       JR NZ, 8007
8014:           label finito
8014:18FE       JR 8014
8016:           label delay
8016:C5         PUSH BC
8017:0614       LD B, 14
8019:           label outer_loop
8019:0E00       LD C, 00
801B:           label inner_loop
801B:0D         DEC C
801C:20FD       JR NZ, 801B
801E:10F9       DJNZ 8019
8020:C1         POP BC
8021:C9         RET
8022:           label plot
8022:CD3B80     CALL 803B
8025:CD2C80     CALL 802C
8028:56         LD D, (HL)
8029:B2         OR D
802A:77         LD (HL), A
802B:C9         RET
802C:           label calc_pixel_value
802C:C5         PUSH BC
802D:78         LD A, B
802E:E607       AND 07
8030:47         LD B, A
8031:3E80       LD A, 80
8033:2804       JR Z, 8039
8035:           label next_shift
8035:CB3F       SRL A
8037:10FC       DJNZ 8035
8039:           label end_calc
8039:C1         POP BC
803A:C9         RET
803B:           label calc_pixel_address
803B:79         LD A, C
803C:E607       AND 07
803E:F640       OR 40
8040:67         LD H, A
8041:79         LD A, C
8042:1F         RRA
8043:1F         RRA
8044:1F         RRA
8045:E618       AND 18
8047:B4         OR H
8048:67         LD H, A
8049:79         LD A, C
804A:17         RLA
804B:17         RLA
804C:E6E0       AND E0
804E:6F         LD L, A
804F:78         LD A, B
8050:1F         RRA
8051:1F         RRA
8052:1F         RRA
8053:E61F       AND 1F
8055:B5         OR L
8056:6F         LD L, A
8057:C9         RET
8058:           label fill_in_screen
8058:110040     LD DE, 4000
805B:CD6880     CALL 8068
805E:CD6880     CALL 8068
8061:CD6880     CALL 8068
8064:CD6880     CALL 8068
8067:C9         RET
8068:           label draw_ascii_table_inv
8068:3E20       LD A, 20
806A:           label next_char
806A:F5         PUSH AF
806B:CD7A80     CALL 807A
806E:3E20       LD A, 20
8070:CD7A80     CALL 807A
8073:F1         POP AF
8074:3C         INC A
8075:FE80       CP 80
8077:20F1       JR NZ, 806A
8079:C9         RET
807A:           label draw_char_inv
807A:01003C     LD BC, 3C00
807D:61         LD H, C
807E:6F         LD L, A
807F:29         ADD HL, HL
8080:29         ADD HL, HL
8081:29         ADD HL, HL
8082:09         ADD HL, BC
8083:0608       LD B, 08
8085:4A         LD C, D
8086:           label loop2
8086:7E         LD A, (HL)
8087:2F         CPL
8088:12         LD (DE), A
8089:2C         INC L
808A:14         INC D
808B:10F9       DJNZ 8086
808D:1C         INC E
808E:C8         RET Z
808F:51         LD D, C
8090:C9         RET
8091:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8090
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vykreslení jediného pixelu barvou papíru</h2>

<p>Nyní se již konečně můžeme zabývat problémem, který budeme chtít
v&nbsp;dnešním článku vyřešit &ndash; jakým způsobem se zajistí realizace
příkazu <strong>PLOT INVERSE</strong>, tedy vykreslení jediného pixelu barvou
papíru (<i>paper</i>)? Teoreticky můžeme postupovat stejným způsobem, jako při
tisku pixelu barvou inkoustu:</p>

<ol>
<li>Výpočet adresy v&nbsp;obrazové paměti, kde je uložen vykreslovaný pixel i sedm dalších sousedních pixelů</li>
<li>Výpočet masky, tj.&nbsp;osmibitové hodnoty, která se bude aplikovat na původní bajt přečtený z&nbsp;obrazové paměti</li>
<li>Aplikace masky, tj.&nbsp;kombinace původní hodnoty přečtené z&nbsp;obrazové paměti s&nbsp;vypočtenou maskou</li>
<li>Zápis výsledku na (stejnou) adresu v&nbsp;obrazové paměti</li>
</ol>

<p>Obecný postup tedy již známe a máme ho realizován pro pixel v&nbsp;barvě
inkoustu. Jak se však tento postup bude konkrétně implementovat v&nbsp;našem
&bdquo;inverzním&ldquo; případě? Evidentně nebudeme měnit první bod, protože
adresa pro čtení/zápis bajtu z/do obrazové paměti zůstane stejná. Podobně
nebudeme měnit ani bod poslední, protože i ten musí zůstat zachován. Změnit
tedy budeme muset výpočet masky a aplikaci této masky.</p>

<p>Pro vykreslení pixelu barvou inkoustu je nutné <i>nastavit</i> vybraný bit
na jedničku. K&nbsp;tomu slouží instrukce <strong>or</strong> a maska, která má
jeden bit nastavený na jedničku a ostatní bity nulové:</p>

<pre>
původní hodnota   x x x x x x x x
maska             0 0 0 1 0 0 0 0
=================================
hodnota OR maska  x x x 1 x x x x
</pre>

<p>Naproti tomu pro vykreslení pixelu barvou papíru je nutné <i>vynulovat</i>
vybraný bit. K&nbsp;tomu slouží instrukce <strong>and</strong> a maska, která
má jeden bit nastavený na nulu o ostatní bity jedničkové:</p>

<pre>
původní hodnota   x x x x x x x x
maska             1 1 1 0 1 1 1 1
=================================
hodnota AND maska x x x 0 x x x x
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úprava vykreslovací rutiny <strong>PLOT</strong> pro korektní kreslení barvou papíru</h2>

<p>Pro vykreslení pixelu barvou inkoustu vypadala realizace výše uvedeného
postupu následovně:</p>

<pre>
<strong>plot</strong>:
        <i>; třetí varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld d, (hl)               <i>; přečíst původní hodnotu osmice pixelů</i>
        or d                     <i>; použít vypočtenou masku pro nastavení jediného bitu</i>
        ld (hl), a               <i>; zápis hodnoty pixelu (ostatních sedm pixelů se nezmění)</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p>V&nbsp;upravené variantě jsme přidali instrukci <strong>cpl</strong> určenou
pro negaci obsahu akumulátoru (<i>complement</i>, tím je myšlen jedničkový
doplněk) a instrukce <strong>or d</strong> byla nahrazena za instrukci
<strong>and d</strong>:</p>

<pre>
<strong>plot_inverse</strong>:
        <i>; varianta podprogramu pro vykreslení pixelu barvou papíru</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld d, (hl)               <i>; přečíst původní hodnotu osmice pixelů</i>
        cpl                      <i>; inverze masky</i>
        and d                    <i>; použít vypočtenou masku pro vynulování jediného bitu</i>
        ld (hl), a               <i>; zápis hodnoty pixelu (ostatních sedm pixelů se nezmění)</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: zbytek programu mohl zůstat stejný; týká
se to i výpočtu adresy pixelu i výpočtu masky.</div></p>

*** image ***
<p><i>Obrázek 6: Úsečka vykreslená z&nbsp;pixelů s&nbsp;barvou papíru, nikoli
inkoustu.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Úplný zdrojový kód dnešního třetího demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního v&nbsp;pořadí již třetího demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/58-plot-inverse-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/58-plot-inverse-pixel-on-inverse-background.asm</a>
a vypadá následovně:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call fill_in_screen      <i>; vyplnění obrazovky ASCII tabulkami</i>
&nbsp;
        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
<strong>loop</strong>:
        call plot_inverse        <i>; vykreslení pixelu barvou papíru</i>
        call delay
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, loop              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
<strong>finito</strong>:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>delay</strong>:
        <i>; zpožďovací rutina</i>
        <i>; nemění žádné registry</i>
        push bc                  <i>; uschovat hodnoty registrů, které se používají ve smyčkách</i>
        ld   b, 20               <i>; počitadlo vnější zpožďovací smyčky</i>
<strong>outer_loop</strong>:
        ld   c, 0                <i>; počitadlo vnitřní zpožďovací smyčky</i>
<strong>inner_loop</strong>:
        dec  c                   <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr   NZ, inner_loop      <i>; opakovat, dokud není dosaženo nuly</i>
        djnz outer_loop          <i>; opakovat vnější smyčku, nyní s počitadlem v B</i>
        pop  bc                  <i>; obnovit hodnoty registrů změněných smyčkami</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>plot_inverse</strong>:
        <i>; varianta podprogramu pro vykreslení pixelu barvou papíru</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld d, (hl)               <i>; přečíst původní hodnotu osmice pixelů</i>
        cpl                      <i>; inverze masky</i>
        and d                    <i>; použít vypočtenou masku pro vynulování jediného bitu</i>
        ld (hl), a               <i>; zápis hodnoty pixelu (ostatních sedm pixelů se nezmění)</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>calc_pixel_value</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; A - hodnota pixelu</i>
        push bc                  <i>; zapamatovat si hodnotu v registru B</i>
        ld   a, b                <i>; A: X7 X6 X5 X4 X3 X2 X1 X0 </i>
        and  %00000111           <i>; A: 0  0  0  0  0  X2 X1 X0</i>
        ld b, a                  <i>; počitadlo smyčky (neměníme příznaky)</i>
        ld a, %10000000          <i>; výchozí maska (neměníme příznaky)</i>
        jr z, end_calc           <i>; pokud je nyní souřadnice nulová, zapíšeme výchozí masku + konec</i>
&nbsp;
<strong>next_shift</strong>:
        srl a                    <i>; posunout masku doprava</i>
        djnz next_shift          <i>; 1x až 7x</i>
<strong>end_calc</strong>:
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>calc_pixel_address</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis pixelu</i>
        <i>;</i>
        <i>; pozměněné registry:</i>
        <i>; A</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y7 Y6 Y2 Y1 Y0 | Y5 Y4 Y3 X4 X3 X2 X1 X0</i>
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (Y2 Y1 Y0)</i>
                              <i>; A: 0 0 0 0 0 Y2 Y1 Y0</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; část horního bajtu adresy je vypočtena</i>
                              <i>; H: 0 1 0 0 0 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> Y1 Y0 xx Y7 Y6 Y5 Y4 Y3</i>
        and %00011000         <i>; zamaskovat</i>
                              <i>; A: 0  0  0 Y7 Y6  0  0  0</i>
        or  h                 <i>; a přidat k vypočtenému mezivýsledku</i>
        ld  h, a              <i>; H: 0  1  0 Y7 Y6 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rla
        rla                   <i>; A:  Y5 Y4 Y3 Y2 Y1 Y0 xx xx</i>
        and %11100000         <i>; A:  Y5 Y4 Y3 0  0  0  0  0</i>
        ld  l, a              <i>; část spodního bajtu adresy je vypočtena</i>
&nbsp;
        ld  a, b              <i>; všech osm bitů X-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> 0  0  0  X7 X6 X5 X4</i>
        and %00011111         <i>; A: 0  0  0  X7 X6 X5 X4 X3</i>
        or  l                 <i>; A: Y5 Y3 Y3 X7 X6 X5 X4 X3</i>
        ld  l, a              <i>; spodní bajt adresy je vypočten</i>
&nbsp;
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR         <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        call draw_ascii_table_inv <i>; vykreslení 96 znaků</i>
        ret                       <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_ascii_table_inv</strong>:
        <i>; Vytištění ASCII tabulky inverzně (barva inkoustu je barvou pozadí a naopak)</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char_inv       <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char_inv       <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_char_inv</strong>:
        <i>; Vytištění jednoho inverzního znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
loop2:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        cpl                      <i>; negace hodnoty v akumulátoru</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop2               <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Způsob překladu tohoto příkladu do strojového kódu je následující:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:CD5980     CALL 8059
8003:0600       LD B, 00
8005:0E00       LD C, 00
8007:           label loop
8007:CD2280     CALL 8022
800A:CD1680     CALL 8016
800D:04         INC B
800E:0C         INC C
800F:78         LD A, B
8010:FEC0       CP C0
8012:20F3       JR NZ, 8007
8014:           label finito
8014:18FE       JR 8014
8016:           label delay
8016:C5         PUSH BC
8017:0614       LD B, 14
8019:           label outer_loop
8019:0E00       LD C, 00
801B:           label inner_loop
801B:0D         DEC C
801C:20FD       JR NZ, 801B
801E:10F9       DJNZ 8019
8020:C1         POP BC
8021:C9         RET
8022:           label plot_inverse
8022:CD3C80     CALL 803C
8025:CD2D80     CALL 802D
8028:56         LD D, (HL)
8029:2F         CPL
802A:A2         AND D
802B:77         LD (HL), A
802C:C9         RET
802D:           label calc_pixel_value
802D:C5         PUSH BC
802E:78         LD A, B
802F:E607       AND 07
8031:47         LD B, A
8032:3E80       LD A, 80
8034:2804       JR Z, 803A
8036:           label next_shift
8036:CB3F       SRL A
8038:10FC       DJNZ 8036
803A:           label end_calc
803A:C1         POP BC
803B:C9         RET
803C:           label calc_pixel_address
803C:79         LD A, C
803D:E607       AND 07
803F:F640       OR 40
8041:67         LD H, A
8042:79         LD A, C
8043:1F         RRA
8044:1F         RRA
8045:1F         RRA
8046:E618       AND 18
8048:B4         OR H
8049:67         LD H, A
804A:79         LD A, C
804B:17         RLA
804C:17         RLA
804D:E6E0       AND E0
804F:6F         LD L, A
8050:78         LD A, B
8051:1F         RRA
8052:1F         RRA
8053:1F         RRA
8054:E61F       AND 1F
8056:B5         OR L
8057:6F         LD L, A
8058:C9         RET
8059:           label fill_in_screen
8059:110040     LD DE, 4000
805C:CD6980     CALL 8069
805F:CD6980     CALL 8069
8062:CD6980     CALL 8069
8065:CD6980     CALL 8069
8068:C9         RET
8069:           label draw_ascii_table_inv
8069:3E20       LD A, 20
806B:           label next_char
806B:F5         PUSH AF
806C:CD7B80     CALL 807B
806F:3E20       LD A, 20
8071:CD7B80     CALL 807B
8074:F1         POP AF
8075:3C         INC A
8076:FE80       CP 80
8078:20F1       JR NZ, 806B
807A:C9         RET
807B:           label draw_char_inv
807B:01003C     LD BC, 3C00
807E:61         LD H, C
807F:6F         LD L, A
8080:29         ADD HL, HL
8081:29         ADD HL, HL
8082:29         ADD HL, HL
8083:09         ADD HL, BC
8084:0608       LD B, 08
8086:4A         LD C, D
8087:           label loop2
8087:7E         LD A, (HL)
8088:2F         CPL
8089:12         LD (DE), A
808A:2C         INC L
808B:14         INC D
808C:10F9       DJNZ 8087
808E:1C         INC E
808F:C8         RET Z
8090:51         LD D, C
8091:C9         RET
8092:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8091
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Jak vytvořit subrutinu pro tisk normální i inverzní ASCII tabulky?</h2>

<p>V&nbsp;dalších kapitolách si mj.&nbsp;ukážeme způsob vykreslování
&bdquo;inverzních pixelů&ldquo;, což je vlastně další varianta BASICovského
příkazu <strong>PLOT</strong>. Pixel, který měl původně barvu inkoustu se změní
na barvu pozadí a naopak. Aby byla tato operace dobře viditelná, pozměníme
nejprve nepatrně pozadí celé scény zobrazené na obrazovce. Opět vykreslíme
několik sad ASCII znaků, tentokrát však bude první polovina obrazovky vyplněna
inverzními ASCII tabulky a druhá polovina původními (neinverzními)
tabulkami:</p>

*** image ***
<p><i>Obrázek 7: Obrazovka ZX Spectra vykreslená jak neinverzní ASCII tabulkou,
tak i její inverzní variantou.</i></p>

<p>Jak lze tohoto efektu dosáhnout? Nejprimitivnější by pochopitelně bylo
ponechat v&nbsp;programovém kódu obě subrutiny pro tisk ASCII tabulek, tedy jak
subrutinu pro tisk neinverzní tabulky, tak i tabulky inverzní:</p>

<pre>
<strong>draw_ascii_table</strong>:
        <i>; Vytištění ASCII tabulky</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p>a:</p>

<pre>
<strong>draw_ascii_table_inv</strong>:
        <i>; Vytištění ASCII tabulky inverzně (barva inkoustu je barvou pozadí a naopak)</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char_inv       <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char_inv       <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p>Jenže když se podíváte na obě subrutiny, je ihned patrné, že se neliší
jejich &bdquo;vlastní&ldquo; instrukce (to by nebyl největší problém, protože
se jedná pouze o několik instrukcí), ale že se volají i odlišné subrutiny pro
tisk znaků resp.&nbsp;inverzních znaků. A tyto subrutiny jsou již dosti
rozsáhlé a asi není nejlepší nápad zaplňovat omezený prostor RAM (48 kB včetně
obrazové paměti) několika kopiemi prakticky totožného programového kódu:</p>

<p>Samozřejmě by bylo možné nějakým způsobem do těchto subrutin předat další
parametr typu &bdquo;vykresluj znaky normálně&ldquo; nebo &bdquo;vykresluj
znaky inverzně&ldquo;. Problém spočívá v&nbsp;omezeném počtu volných registrů
(takové registry neexistují) a taktéž v&nbsp;tom, že by se uvnitř subrutin
musel tento parametr neustále testovat a tím pádem by došlo ke zpomalení celého
kódu.</p>

<pre>
<strong>draw_char</strong>:
        <i>; Vytištění jednoho znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop2</strong>:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop2               <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
</pre>

<p>a:</p>

<pre>
<strong>draw_char_inv</strong>:
        <i>; Vytištění jednoho inverzního znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop</strong>:
        <u>ld   a,(hl)</u>              <i>; načtení jednoho bajtu z masky</i>
        <u>cpl</u>                      <i>; negace hodnoty v akumulátoru</i>
        <u>ld   (de),a</u>              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Samomodifikující se kód na mikroprocesoru Zilog Z80</h2>

<p>Zkusme použít odlišný přístup. Nejprve si obě subrutiny porovnejme instrukci po instrukci:</p>

<pre>
</pre>

<p>Z&nbsp;výše uvedeného porovnání je zřejmé, že se subrutiny odlišují pouze v&nbsp;jediné instrukci, která byla přidána do subrutiny pro tisk inverzního znaku. A takový problém umíme na osmibitových mikropočítačích s&nbsp;mikroprocesory bez ochrany paměti snadno řešit, a to konkrétně použitím samomodifikujícího se kódu. Jedná se o takový kód, jehož instrukce se mění v&nbsp;čase běhu programu (tedy v&nbsp;<i>runtime</i>) cílenou změnou operačních kódů instrukcí a/nebo dalších bajtů, v&nbsp;nichž jsou uloženy adresy nebo jiné operandy instrukcí.</p>

<p>Aby bylo možné tuto modifikaci provést, musíme znát <a href="https://clrhome.org/table/">operační kódy instrukcí</a>, protože mnoho assemblerů neumožňuje použít mnemotechnický název instrukce jako operand jiné instrukce (pro assembler tvoří mnemotechnické kódy instrukcí samostatný jmenný prostor). To však nevadí, protože si mapování mezi mnemotechnickým názvem instrukce a číselným kódem instrukce můžeme do programu přidat sami formou pojmenovaných symbolů.</p>

<p>Z&nbsp;tabulky operačních kódů instrukcí tedy můžeme zjistit, jakou <i>hodnotu</i> máme zapsat, ovšem ještě je nutné zajistit, aby se tato hodnota zapsala na správné místo. To je v&nbsp;assembleru až směšně jednoduché (a prakticky nemožné dosáhnout ve vyšších programovacích jazycích), protože před každou instrukci můžeme vložit návěští (<i>label</i>). Měněný program může vypadat takto:</p>

<pre>
        ld a, 10
menena_instrukce:
        inc a
        ld b, a
</pre>

<p>Po vykonání této části kódu by měla být v&nbsp;registrech <strong>A</strong> a <strong>B</strong> zapsána hodnota 11. Pokud ovšem spustíme tuto část kódu:</p>

<pre>
        ld hl, menena_instrukce
        ld (hl), 0
</pre>

<p>popř.&nbsp;můžeme použít čitelnější podobu se symbolem:</p>

<pre>
</pre>

<p>Změní se původní program (v&nbsp;runtime) takto:</p>

<pre>
        ld a, 10
menena_instrukce:
        nop
        ld b, a
</pre>

<p>Proč tomu tak je? Hodnota 0 odpovídá kódu instrukce <strong>NOP</strong>, což snadno přečteme z&nbsp;již <a href="https://clrhome.org/table/#nop">výše linkované tabulky</a>.</p>

<p>Podobným způsobem například můžeme nahradit programovou smyčku, v&nbsp;níž se postupně zvyšuje hodnota počitadla instrukcí <strong>inc</strong> za smyčku, kde se hodnota naopak snižuje atd. atd.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Úprava subrutiny pro vykreslení znaku</h2>

<p>Z&nbsp;předchozího textu již víme, jakým způsobem je možné modifikovat část
programového kódu, takže se vraťme k&nbsp;řešení našeho problému &ndash; jak
zajistit vytištění běžné ASCII tabulky a též tabulky, ovšem s&nbsp;inverzními
znaky? Použijeme samomodifikující se kód, přičemž rutinu pro vykreslení
jediného znaku nepatrně změníme. Ona změna spočívá v&nbsp;přidání návěští
<strong>inv_instruction_adr</strong> před instrukci, kterou budeme chtít
modifikovat. Jedná se o instrukci pro negaci obsahu akumulátoru
<strong>A</strong>, což je instrukce <a
href="https://clrhome.org/table/#cpl">CPL</a> s&nbsp;délkou jednoho bajtu (to
je důležité):</p>

<pre>
<strong>draw_char</strong>:
        <i>; Vytištění jednoho inverzního znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop</strong>:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
<strong>inv_instruction_adr</strong>:
        <u>cpl</u>                      <i>; negace hodnoty v akumulátoru</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Řízená modifikace předchozí subrutiny v&nbsp;čase běhu programu</h2>

<p></p>

<pre>
NOP_INSTRUCTION equ 0
</pre>

<pre>
        call draw_ascii_table     <i>; vykreslení 96 znaků</i>
</pre>

<pre>
        ld hl, inv_instruction_adr; adresa bajtu v paměti, který budeme modifikovat
        ld (hl), NOP_INSTRUCTION  <i>; zápis instrukce NOP namísto instrukce CPL</i>
&nbsp;
        call draw_ascii_table     <i>; vykreslení 96 znaků</i>
</pre>

<pre>
        ld hl, inv_instruction_adr; adresa bajtu v paměti, který budeme modifikovat
        ld (hl), CPL_INSTRUCTION  <i>; zápis instrukce NOP namísto instrukce CPL</i>
&nbsp;
        call draw_ascii_table     <i>; vykreslení 96 znaků</i>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního v&nbsp;pořadí již čtvrtého demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm</a>
a vypadá následovně:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
NOP_INSTRUCTION equ 0
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call fill_in_screen      <i>; vyplnění obrazovky ASCII tabulkami</i>
<strong>finito</strong>:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR         <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table     <i>; vykreslení 96 znaků</i>
        call draw_ascii_table     <i>; vykreslení 96 znaků</i>
&nbsp;
        ld hl, inv_instruction_adr; adresa bajtu v paměti, který budeme modifikovat
        ld (hl), NOP_INSTRUCTION  <i>; zápis instrukce NOP namísto instrukce CPL</i>
&nbsp;
        call draw_ascii_table     <i>; vykreslení 96 znaků</i>
        call draw_ascii_table     <i>; vykreslení 96 znaků</i>
        ret                       <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_ascii_table</strong>:
        <i>; Vytištění ASCII tabulky inverzně (barva inkoustu je barvou pozadí a naopak)</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
draw_char    :
        <i>; Vytištění jednoho inverzního znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop</strong>:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
<strong>inv_instruction_adr</strong>:
        cpl                      <i>; negace hodnoty v akumulátoru</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Překlad do strojového kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
NOP_INSTRUCTION EQU 0000
                ORG 8000
8000:           label start
8000:CD0580     CALL 8005
8003:           label finito
8003:18FE       JR 8003
8005:           label fill_in_screen
8005:110040     LD DE, 4000
8008:CD1A80     CALL 801A
800B:CD1A80     CALL 801A
800E:213980     LD HL, 8039
8011:3600       LD (HL), 00
8013:CD1A80     CALL 801A
8016:CD1A80     CALL 801A
8019:C9         RET
801A:           label draw_ascii_table
801A:3E20       LD A, 20
801C:           label next_char
801C:F5         PUSH AF
801D:CD2C80     CALL 802C
8020:3E20       LD A, 20
8022:CD2C80     CALL 802C
8025:F1         POP AF
8026:3C         INC A
8027:FE80       CP 80
8029:20F1       JR NZ, 801C
802B:C9         RET
802C:           label draw_char
802C:01003C     LD BC, 3C00
802F:61         LD H, C
8030:6F         LD L, A
8031:29         ADD HL, HL
8032:29         ADD HL, HL
8033:29         ADD HL, HL
8034:09         ADD HL, BC
8035:0608       LD B, 08
8037:4A         LD C, D
8038:           label loop
8038:7E         LD A, (HL)
8039:           label inv_instruction_adr
8039:2F         CPL
803A:12         LD (DE), A
803B:2C         INC L
803C:14         INC D
803D:10F9       DJNZ 8038
803F:1C         INC E
8040:C8         RET Z
8041:51         LD D, C
8042:C9         RET
8043:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8042
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vykreslení pixelu metodou <strong>PLOT OVER</strong> (inverze)</h2>

<p></p>

<pre>
<strong>plot_over</strong>:
        <i>; varianta podprogramu pro vykreslení pixelu inverzní barvou</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld d, (hl)               <i>; přečíst původní hodnotu osmice pixelů</i>
        xor d                    <i>; použít vypočtenou masku pro vynulování jediného bitu</i>
        ld (hl), a               <i>; zápis hodnoty pixelu (ostatních sedm pixelů se nezmění)</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Inverze celé obrazovky tím nejpomalejším způsobem &ndash; pixel po pixelu</h2>

<p></p>

<pre>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Úplný zdrojový kód dnešního posledního demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního v&nbsp;pořadí již pátého a současně i posledního
demonstračního příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm</a>
a vypadá následovně:</p>

<pre>
</pre>

<p>Překlad tohoto demonstračního příkladu do strojového kódu (mimochodem
&ndash; délka je rovna 148 bajtům; žádný příklad se tedy prozatím ani
nepřiblížil jednomu kilobajtu):</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
NOP_INSTRUCTION EQU 0000
                ORG 8000
8000:           label start
8000:CD5780     CALL 8057
8003:0600       LD B, 00
8005:0E00       LD C, 00
8007:           label loop
8007:CD2180     CALL 8021
800A:04         INC B
800B:20FA       JR NZ, 8007
800D:0C         INC C
800E:79         LD A, C
800F:FEC0       CP C0
8011:20F4       JR NZ, 8007
8013:           label finito
8013:18FE       JR 8013
8015:           label delay
8015:C5         PUSH BC
8016:0614       LD B, 14
8018:           label outer_loop
8018:0E00       LD C, 00
801A:           label inner_loop
801A:0D         DEC C
801B:20FD       JR NZ, 801A
801D:10F9       DJNZ 8018
801F:C1         POP BC
8020:C9         RET
8021:           label plot_over
8021:CD3A80     CALL 803A
8024:CD2B80     CALL 802B
8027:56         LD D, (HL)
8028:AA         XOR D
8029:77         LD (HL), A
802A:C9         RET
802B:           label calc_pixel_value
802B:C5         PUSH BC
802C:78         LD A, B
802D:E607       AND 07
802F:47         LD B, A
8030:3E80       LD A, 80
8032:2804       JR Z, 8038
8034:           label next_shift
8034:CB3F       SRL A
8036:10FC       DJNZ 8034
8038:           label end_calc
8038:C1         POP BC
8039:C9         RET
803A:           label calc_pixel_address
803A:79         LD A, C
803B:E607       AND 07
803D:F640       OR 40
803F:67         LD H, A
8040:79         LD A, C
8041:1F         RRA
8042:1F         RRA
8043:1F         RRA
8044:E618       AND 18
8046:B4         OR H
8047:67         LD H, A
8048:79         LD A, C
8049:17         RLA
804A:17         RLA
804B:E6E0       AND E0
804D:6F         LD L, A
804E:78         LD A, B
804F:1F         RRA
8050:1F         RRA
8051:1F         RRA
8052:E61F       AND 1F
8054:B5         OR L
8055:6F         LD L, A
8056:C9         RET
8057:           label fill_in_screen
8057:110040     LD DE, 4000
805A:CD6C80     CALL 806C
805D:CD6C80     CALL 806C
8060:218B80     LD HL, 808B
8063:3600       LD (HL), 00
8065:CD6C80     CALL 806C
8068:CD6C80     CALL 806C
806B:C9         RET
806C:           label draw_ascii_table
806C:3E20       LD A, 20
806E:           label next_char
806E:F5         PUSH AF
806F:CD7E80     CALL 807E
8072:3E20       LD A, 20
8074:CD7E80     CALL 807E
8077:F1         POP AF
8078:3C         INC A
8079:FE80       CP 80
807B:20F1       JR NZ, 806E
807D:C9         RET
807E:           label draw_char
807E:01003C     LD BC, 3C00
8081:61         LD H, C
8082:6F         LD L, A
8083:29         ADD HL, HL
8084:29         ADD HL, HL
8085:29         ADD HL, HL
8086:09         ADD HL, BC
8087:0608       LD B, 08
8089:4A         LD C, D
808A:           label loop2
808A:7E         LD A, (HL)
808B:           label inv_instruction_adr
808B:2F         CPL
808C:12         LD (DE), A
808D:2C         INC L
808E:14         INC D
808F:10F9       DJNZ 808A
8091:1C         INC E
8092:C8         RET Z
8093:51         LD D, C
8094:C9         RET
8095:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8094
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah navazujícího článku</h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<p>Výše uvedené demonstrační příklady i příklady, které již byly popsány
v&nbsp;předchozích šesti článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">3</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny/">4</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-podruhe/">5</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-potreti/">6</a>],
je možné přeložit s&nbsp;využitím souboru Makefile, jehož aktuální verze vypadá
následovně (pro překlad a slinkování je použit assembler <i>Pasmo</i>):</p>

<pre>
ASSEMBLER := pasmo
&nbsp;
all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap \
    31.tap 32.tap 33.tap 34.tap 35.tap 36.tap 37.tap 38.tap 39.tap 40.tap \
    41.tap 42.tap 43.tap 44.tap 45.tap 46.tap 47.tap 48.tap 49.tap 50.tap \
    51.tap 52.tap 53.tap 54.tap 55.tap 56.tap 57.tap 58.tap 59.tap 60.tap
&nbsp;
clean:
        rm -f *.tap
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 01-color-attribute.lst
&nbsp;
02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 02-blinking-attribute.lst
&nbsp;
03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 03-symbolic-names.lst
&nbsp;
04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 04-operators.lst
&nbsp;
05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 05-better-symbols.lst
&nbsp;
06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 06-tapbas-v1.lst
&nbsp;
07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 07-tapbas-v2.lst
&nbsp;
08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 08-loop.lst
&nbsp;
09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 09-loop.lst
&nbsp;
10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 10-loop.lst
&nbsp;
11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 11-loop.lst
&nbsp;
12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 12-loop.lst
&nbsp;
13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 13-loop.lst
&nbsp;
14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 14-loop.lst
&nbsp;
15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 15-loop.lst
&nbsp;
16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 16-loop.lst
&nbsp;
17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 17-loop.lst
&nbsp;
18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 18-cls.lst
&nbsp;
19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 19-print-char-call.lst
&nbsp;
20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 20-print-char-rst.lst
&nbsp;
21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 21-print-char.lst
&nbsp;
22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 22-print-all-chars.lst
&nbsp;
23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 23-print-all-chars.lst
&nbsp;
24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 24-change-color.lst
&nbsp;
25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 25-change-flash.lst
&nbsp;
26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 26-print-at.lst
&nbsp;
27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 27-print-string.lst
&nbsp;
28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 28-print-string.lst
&nbsp;
29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 29-print-colorized-string.lst
&nbsp;
30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 30-print-string-ROM.lst
&nbsp;
31.tap: 31-attributes.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 31-attributes.lst
&nbsp;
32.tap: 32-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 32-fill-in-vram.lst
&nbsp;
33.tap: 33-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 33-fill-in-vram-no-ret.lst
&nbsp;
34.tap: 34-fill-in-vram-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 34-fill-in-vram-pattern.lst
&nbsp;
35.tap: 35-slow-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 35-slow-fill-in-vram.lst
&nbsp;
36.tap: 36-slow-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 36-slow-fill-in-vram-no-ret.lst
&nbsp;
37.tap: 37-fill-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 37-fill-block.lst
&nbsp;
38.tap: 38-fill-block-with-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 38-fill-block-with-pattern.lst
&nbsp;
39.tap: 39-fill-block-optimized.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 39-fill-block-optimized.lst
&nbsp;
40.tap: 40-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 40-draw-char.lst
&nbsp;
41.tap: 41-draw-any-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 41-draw-any-char.lst
&nbsp;
42.tap: 42-block-anywhere.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 42-block-anywhere.lst
&nbsp;
43.tap: 43-block-anywhere-rrca.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 43-block-anywhere-rrca.lst
&nbsp;
44.tap: 44-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 44-better-draw-char.lst
&nbsp;
45.tap: 45-even-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 45-even-better-draw-char.lst
&nbsp;
46.tap: 46-draw-char-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 46-draw-char-at.lst
&nbsp;
47.tap: 47-draw-char-at-unrolled.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 47-draw-char-at-unrolled.lst
&nbsp;
48.tap: 48-incorrect-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 48-incorrect-print-string.lst
&nbsp;
49.tap: 49-correct-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 49-correct-print-string.lst
&nbsp;
50.tap: 50-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 50-ascii-table.lst
&nbsp;
51.tap: 51-plot-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 51-plot-block.lst
&nbsp;
52.tap: 52-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 52-plot-pixel.lst
&nbsp;
53.tap: 53-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 53-plot-pixel.lst
&nbsp;
54.tap: 54-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 54-plot-pixel-on-background.lst
&nbsp;
55.tap: 55-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 55-plot-pixel-on-background.lst
&nbsp;
56.tap: 56-inverse-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 56-inverse-ascii-table.lst
&nbsp;
57.tap: 57-plot-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 57-plot-pixel-on-inverse-background.lst
&nbsp;
58.tap: 58-plot-inverse-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 58-plot-inverse-pixel-on-inverse-background.lst
&nbsp;
59.tap: 59-configurable-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 59-configurable-ascii-table.lst
&nbsp;
60.tap: 60-plot-over.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 60-plot-over.lst
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>31-attributes.asm</td><td>modifikace atributů pro tisk řetězce subrutinou uloženou v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a></td></tr>
<tr><td>32</td><td>32-fill-in-vram.asm</td><td>vyplnění celé bitmapy barvou popředí, návrat do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a></td></tr>
<tr><td>33</td><td>33-fill-in-vram-no-ret.asm</td><td>vyplnění celé bitmapy barvou popředí, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>34</td><td>34-fill-in-vram-pattern.asm</td><td>vyplnění celé bitmapy zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a></td></tr>
<tr><td>35</td><td>35-slow-fill-in-vram.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a></td></tr>
<tr><td>36</td><td>36-slow-fill-in-vram-no-ret.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>37</td><td>37-fill-block.asm</td><td>vykreslení bloku 8&times;8 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a></td></tr>
<tr><td>38</td><td>38-fill-block-with-pattern.asm</td><td>vykreslení bloku 8&times;8 pixelů zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a></td></tr>
<tr><td>39</td><td>39-fill-block-optimized.asm</td><td>optimalizace předchozího příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a></td></tr>
<tr><td>40</td><td>40-draw-char.asm</td><td>vykreslení znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a></td></tr>
<tr><td>41</td><td>41-draw-any-char.asm</td><td>podprogram pro vykreslení libovolně zvoleného znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a></td></tr>
<tr><td>42</td><td>42-block-anywhere.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>43-block-anywhere-rrca.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm</a></td></tr>
<tr><td>44</td><td>44-better-draw-char.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm</a></td></tr>
<tr><td>45</td><td>45-even-better-draw-char.asm</td><td>posun offsetu pro vykreslení dalšího znaku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm</a></td></tr>
<tr><td>46</td><td>46-draw-char-at.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm</a></td></tr>
<tr><td>47</td><td>47-draw-char-at-unrolled.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm</a></td></tr>
<tr><td>48</td><td>48-incorrect-print-string.asm</td><td>tisk řetězce, nekorektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm</a></td></tr>
<tr><td>49</td><td>49-correct-print-string.asm</td><td>tisk řetězce, korektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>50-ascii-table.asm</td><td>tisk několika bloků ASCII tabulky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm</a></td></tr>
<tr><td>51</td><td>51-plot-block.asm</td><td>vykreslení pixelu verze 1: zápis celého bajtu na pozici pixelu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm</a></td></tr>
<tr><td>52</td><td>52-plot-pixel.asm</td><td>vykreslení pixelu verze 2: korektní vykreslení jednoho pixelu, ovšem překreslení celého bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm</a></td></tr>
<tr><td>53</td><td>53-plot-pixel.asm</td><td>vykreslení pixelu verze 3: vylepšená verze předchozího demonstračního příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm</a></td></tr>
<tr><td>54</td><td>54-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (nekorektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm</a></td></tr>
<tr><td>55</td><td>55-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (korektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>56</td><td>56-inverse-ascii-table.asm</td><td>vykreslení ASCII tabulky inverzní barvou (inkoust vs. papír)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm</a></td></tr>
<tr><td>57</td><td>57-plot-pixel-on-inverse-background.asm</td><td>vykreslení pixelů barvou papíru proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm</a></td></tr>
<tr><td>58</td><td>58-plot-inverse-pixel-on-inverse-background.asm</td><td>vykreslení pixelů inverzní barvou proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/58-plot-inverse-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm58-plot-inverse-pixel-on-inverse-background.asm/</a></td></tr>
<tr><td>59</td><td>59-configurable-ascii-table.asm</td><td>vykreslení ASCII tabulky buď přímo inkoustem nebo inverzně</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm</a></td></tr>
<tr><td>60</td><td>60-plot-over.asm</td><td>přibližná implementace příkazu <strong>PLOT OVER</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech demonstračních příkladů do podoby obrazu magnetické pásky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>The system variables<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html</a>
</li>

<li>ZX Spectrum manual: chapter #17 Graphics<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html</a>
</li>

<li>Why does Sinclair BASIC have two formats for storing numbers in the same structure?<br />
<a href="https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu">https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu</a>
</li>

<li>Plovoucí řádová čárka na ZX Spectru<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

