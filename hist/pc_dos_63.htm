<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Funkce vestavěné v GCC pro provádění nízkoúrovňových bitových operací a rotací (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Funkce vestavěné v GCC pro provádění nízkoúrovňových bitových operací a rotací (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Funkce vestavěné v GCC pro provádění nízkoúrovňových bitových operací a rotací (dokončení)</a></p>
<p><a href="#k02">*** 2. Zjištění minimálního počtu bitů nutných pro uložení hodnoty</a></p>
<p><a href="#k03">3. Překlad vestavěné funkce <strong>__builtin_stdc_bit_width</strong> do strojového kódu</a></p>
<p><a href="#k04">4. Překlad volání funkce <strong>__builtin_stdc_bit_width</strong> pro platformu x86-64</a></p>
<p><a href="#k05">5. Překlad volání funkce <strong>__builtin_stdc_bit_width</strong> pro 32bitové ARMy</a></p>
<p><a href="#k06">*** 6. Překlad volání funkce <strong>__builtin_stdc_bit_width</strong> pro 64bitové ARMy (AArch64)</a></p>
<p><a href="#k07">7. Bitová šířka pro hodnoty se znaménkem</a></p>
<p><a href="#k08">*** 8. Funkce <strong>__builtin_stdc_bit_floor</strong></a></p>
<p><a href="#k09">9. Překlad vestavěné funkce <strong>__builtin_stdc_bit_floor</strong> do strojového kódu</a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. Funkce <strong>__builtin_stdc_bit_ceil</strong></a></p>
<p><a href="#k14">14. Překlad vestavěné funkce <strong>__builtin_stdc_bit_ceil</strong> do strojového kódu</a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Funkce vestavěné v GCC pro provádění nízkoúrovňových bitových operací a rotací (dokončení)</h2>

<pre>
int <strong>__builtin_ffs</strong>(int x)
int <strong>__builtin_clz</strong>(unsigned int x)
int <strong>__builtin_ctz</strong>(unsigned int x)
int <strong>__builtin_clrsb</strong>(int x)
int <strong>__builtin_popcount</strong>(unsigned int x)
int <strong>__builtin_ffsl</strong>(long)
int <strong>__builtin_clzl</strong>(unsigned long)
int <strong>__builtin_ctzl</strong>(unsigned long)
int <strong>__builtin_clrsbl</strong>(long)
int <strong>__builtin_popcountl</strong>(unsigned long)
int <strong>__builtin_ffsll</strong>(long long)
int <strong>__builtin_clzll</strong>(unsigned long long)
int <strong>__builtin_ctzll</strong>(unsigned long long)
int <strong>__builtin_clrsbll</strong>(long long)
int <strong>__builtin_popcountll</strong>(unsigned long long)
int <strong>__builtin_ffsg</strong>(...)
int <strong>__builtin_clzg</strong>(...)
int <strong>__builtin_ctzg</strong>(...)
int <strong>__builtin_clrsbg</strong>(...)
int <strong>__builtin_popcountg</strong>(...)
type <strong>__builtin_stdc_bit_ceil</strong>(type arg)
type <strong>__builtin_stdc_bit_floor</strong>(type arg)
unsigned int <strong>__builtin_stdc_bit_width</strong>(type arg)
unsigned int <strong>__builtin_stdc_count_ones</strong>(type arg)
unsigned int <strong>__builtin_stdc_count_zeros</strong>(type arg)
unsigned int <strong>__builtin_stdc_first_leading_one</strong>(type arg)
unsigned int <strong>__builtin_stdc_first_leading_zero</strong>(type arg)
unsigned int <strong>__builtin_stdc_first_trailing_one</strong>(type arg)
unsigned int <strong>__builtin_stdc_first_trailing_zero</strong>(type arg)
unsigned int <strong>__builtin_stdc_has_single_bit</strong>(type arg)
unsigned int <strong>__builtin_stdc_leading_ones</strong>(type arg)
unsigned int <strong>__builtin_stdc_leading_zeros</strong>(type arg)
unsigned int <strong>__builtin_stdc_trailing_ones</strong>(type arg)
unsigned int <strong>__builtin_stdc_trailing_zeros</strong>(type arg)
type1 <strong>__builtin_stdc_rotate_left</strong>(type1 arg1, type2 arg2)
type1 <strong>__builtin_stdc_rotate_right</strong>(type1 arg1, type2 arg2)
</pre>

<p></p>

<pre>
int <strong>__builtin_clrsb</strong>(int x)
int <strong>__builtin_popcount</strong>(unsigned int x)
int <strong>__builtin_clrsbl</strong>(long)
int <strong>__builtin_popcountl</strong>(unsigned long)
int <strong>__builtin_clrsbll</strong>(long long)
int <strong>__builtin_popcountll</strong>(unsigned long long)
int <strong>__builtin_clrsbg</strong>(...)
int <strong>__builtin_popcountg</strong>(...)
type <strong>__builtin_stdc_bit_ceil</strong>(type arg)
type <strong>__builtin_stdc_bit_floor</strong>(type arg)
unsigned int <strong>__builtin_stdc_bit_width</strong>(type arg)
unsigned int <strong>__builtin_stdc_count_ones</strong>(type arg)
unsigned int <strong>__builtin_stdc_count_zeros</strong>(type arg)
unsigned int <strong>__builtin_stdc_has_single_bit</strong>(type arg)
</pre>

https://en.cppreference.com/w/c/header/stdbit



<p><a name="k02"></a></p>
<h2 id="k02">2. Zjištění minimálního počtu bitů nutných pro uložení hodnoty</h2>

<p></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
uint8_t <strong>bit_width_8bit</strong>(uint8_t x) {
    uint8_t z;
    z = <u>__builtin_stdc_bit_width</u>(x);
    return z;
}
&nbsp;
void <strong>print_bin</strong>(uint8_t x) {
    int i;
&nbsp;
    for (i = 7; i &gt;= 0; i--) {
        printf("%d", (x &gt;&gt; i) &amp; 1);
    }
}
&nbsp;
void <strong>test_bit_width</strong>(uint8_t x) {
    printf("%u \t", x);
    print_bin(x);
    printf("\t%d\n", bit_width_8bit(x));
}
&nbsp;
int main(void) {
    uint8_t i;
&nbsp;
    for (i=0; i&lt;=17; i++) {
        test_bit_width(i);
    }
&nbsp;
    test_bit_width(0xff);
}
</pre>

<pre>
0       00000000        0
1       00000001        1
2       00000010        2
3       00000011        2
4       00000100        3
5       00000101        3
6       00000110        3
7       00000111        3
8       00001000        4
9       00001001        4
10      00001010        4
11      00001011        4
12      00001100        4
13      00001101        4
14      00001110        4
15      00001111        4
16      00010000        5
17      00010001        5
255     11111111        8
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad vestavěné funkce <strong>__builtin_stdc_bit_width</strong> do strojového kódu</h2>

<p>V&nbsp;první třetině dnešního článku si ukážeme, jakým způsobem se vlastně
vestavěná funkce <strong>__builtin_stdc_bit_width</strong> přeloží do
strojového kódu sledovaných mikroprocesorových platforem, tj.&nbsp;x86-64,
ARM32 (ARMv7) a AArch64. Překládat budeme následující jednoduchý zdrojový kód,
ve kterém se vestavěná funkce volá s&nbsp;různými typy operandů; ovšem vždy se
jedná o bezznaménkové (<i>unsigned</i>) typy:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
int <strong>bit_width_8bit</strong>(uint8_t x) {
    return <u>__builtin_stdc_bit_width</u>(x);
}
&nbsp;
int <strong>bit_width_16bit</strong>(uint16_t x) {
    return <u>__builtin_stdc_bit_width</u>(x);
}
&nbsp;
int <strong>bit_width_32bit</strong>(uint32_t x) {
    return <u>__builtin_stdc_bit_width</u>(x);
}
&nbsp;
int <strong>bit_width_64bit</strong>(uint64_t x) {
    return <u>__builtin_stdc_bit_width</u>(x);
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad volání funkce <strong>__builtin_stdc_bit_width</strong> pro platformu x86-64</h2>

<p>Na platformě x86-64 je výpočet prováděný vestavěnou funkcí
<strong>__builtin_stdc_bit_width</strong> postaven na instrukci
<strong>BSR</strong> (<i>Bit Scan Reverse</i>), se kterou jsme se již seznámili
v&nbsp;předchozích článcích. Připomeňme si, že tato instrukce nalezne index
nejvyššího nenulového bitu. V&nbsp;případě, že takový bit neexistuje,
tj.&nbsp;když jsou všechny bity nulové, nastaví se příznak <strong>Zero
Flag</strong>, který je možné testovat. A z&nbsp;indexu nejvyššího nenulového
bitu lze přímo odvodit bitovou šířku operandu.</p>

<p>Pro osmibitové a šestnáctibitové hodnoty je nejdříve provedeno maskování na
nejvyšší možnou osmibitovou resp.&nbsp;šestnáctibitovou hodnotu (bez znaménka).
Následně je otestováno, jestli je vstup nulový. Pokud tomu tak je, vrátí se
přímo nula (registr <strong>EAX</strong>), jinak se vrátí výsledek volání výše
zmíněné instrukce <strong>BSR</strong> zvýšený o jedničku:</p>

<pre>
<strong>bit_width_8bit</strong>:
        xor     eax, eax
        and     edi, 255
        je      .L1
        bsr     edi, edi
        lea     eax, [rdi+1]
.L1:
        ret
&nbsp;
<strong>bit_width_16bit</strong>:
        xor     eax, eax
        and     edi, 65535
        je      .L6
        bsr     edi, edi
        lea     eax, [rdi+1]
.L6:
        ret
</pre>

<p>Pro 32bitové a 64bitové vstupy je výpočet nepatrně odlišný, protože se
neprovádí maskování, ale ihned se zavolá instrukce <strong>BSR</strong>.
K&nbsp;vypočtené hodnotě je přičtena jednička, ovšem pokud je vstup nulový,
vrátí se vždy nula (<strong>TEST</strong> následovaný <strong>CMOVE</strong>).
Jedná se tedy pouze o stejný, ovšem jinak strukturovaný výpočet:</p>

<pre>
<strong>bit_width_32bit</strong>:
        bsr     eax, edi
        xor     edx, edx
        add     eax, 1
        test    edi, edi
        cmove   eax, edx
        ret
&nbsp;
<strong>bit_width_64bit</strong>:
        bsr     rax, rdi
        xor     edx, edx
        add     eax, 1
        test    rdi, rdi
        cmove   eax, edx
        ret
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad volání funkce <strong>__builtin_stdc_bit_width</strong> pro 32bitové ARMy</h2>

<p>Na 32bitových ARMech (v7) se namísto specializované instrukce volá subrutina
nazvaná <strong>__clzsi2</strong>. Výsledek se odečte od konstanty 32 nebo 64
(podle bitové šířky) a rozdíl je z&nbsp;kódu vrácen zpět volající funkci.
Všechny důležité výpočty jsou tedy v&nbsp;tomto případě &bdquo;schovány&ldquo;
ve zmíněné subrutině <strong>__clzsi2</strong>:</p>

<pre>
<strong>bit_width_8bit</strong>:
        subs    r3, r0, #0
        beq     .L3
        push    {r4, lr}
        bl      __clzsi2
        pop     {r4, lr}
        rsb     r0, r0, #32
        bx      lr
.L3:
        mov     r0, r3
        bx      lr
&nbsp;
<strong>bit_width_16bit</strong>:
        subs    r3, r0, #0
        beq     .L11
        push    {r4, lr}
        bl      __clzsi2
        pop     {r4, lr}
        rsb     r0, r0, #32
        bx      lr
.L11:
        mov     r0, r3
        bx      lr
&nbsp;
<strong>bit_width_32bit</strong>:
        subs    r3, r0, #0
        beq     .L18
        push    {r4, lr}
        bl      __clzsi2
        pop     {r4, lr}
        rsb     r0, r0, #32
        bx      lr
.L18:
        mov     r0, r3
        bx      lr
&nbsp;
<strong>bit_width_64bit</strong>:
        orrs    r3, r0, r1
        beq     .L25
        push    {r4, lr}
        bl      __clzdi2
        pop     {r4, lr}
        rsb     r0, r0, #64
        bx      lr
.L25:
        mov     r0, #0
        bx      lr
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překlad volání funkce <strong>__builtin_stdc_bit_width</strong> pro 64bitové ARMy (AArch64)</h2>

<pre>
bit_width_8bit:
        ands    w0, w0, 255
        mov     w1, 32
        clz     w2, w0
        sub     w0, w1, w2
        csel    w0, w0, wzr, ne
        ret

bit_width_16bit:
        ands    w0, w0, 65535
        mov     w1, 32
        clz     w2, w0
        sub     w0, w1, w2
        csel    w0, w0, wzr, ne
        ret

bit_width_32bit:
        clz     w0, w0
        mov     w1, 32
        sub     w0, w1, w0
        ret

bit_width_64bit:
        clz     x0, x0
        mov     w1, 64
        sub     w0, w1, w0
        ret
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Bitová šířka pro hodnoty se znaménkem</h2>

<p>Vzhledem k&nbsp;poněkud složité (resp.&nbsp;spíše nejasné) sémantice není
možné vestavěné funkci <strong>__builtin_stdc_bit_width</strong> předat hodnotu
se znaménkem. To si ostatně můžeme velmi snadno otestovat pokusem o překlad
tohoto zdrojového kódu:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
int <strong>bit_width_8bit</strong>(int8_t x) {
    return <u>__builtin_stdc_bit_width</u>(x);
}
&nbsp;
int <strong>bit_width_16bit</strong>(int16_t x) {
    return <u>__builtin_stdc_bit_width</u>(x);
}
&nbsp;
int <strong>bit_width_32bit</strong>(int32_t x) {
    return <u>__builtin_stdc_bit_width</u>(x);
}
&nbsp;
int <strong>bit_width_64bit</strong>(int64_t x) {
    return <u>__builtin_stdc_bit_width</u>(x);
}
</pre>

<p>Překladač GCC v&nbsp;takovém případě bude detekovat chyby, protože předávané
hodnoty musí být bez znaménka (<i>unsigned</i>):</p>

<pre>
bit_width_signed.c: In function ‘bit_width_8bit’:
bit_width_signed.c:4:12: error: argument 1 in call to function ‘__builtin_stdc_bit_width’ has signed type
    4 |     return __builtin_stdc_bit_width(x);
      |            ^~~~~~~~~~~~~~~~~~~~~~~~
bit_width_signed.c: In function ‘bit_width_16bit’:
bit_width_signed.c:8:12: error: argument 1 in call to function ‘__builtin_stdc_bit_width’ has signed type
    8 |     return __builtin_stdc_bit_width(x);
      |            ^~~~~~~~~~~~~~~~~~~~~~~~
bit_width_signed.c: In function ‘bit_width_32bit’:
bit_width_signed.c:12:12: error: argument 1 in call to function ‘__builtin_stdc_bit_width’ has signed type
   12 |     return __builtin_stdc_bit_width(x);
      |            ^~~~~~~~~~~~~~~~~~~~~~~~
bit_width_signed.c: In function ‘bit_width_64bit’:
bit_width_signed.c:16:12: error: argument 1 in call to function ‘__builtin_stdc_bit_width’ has signed type
   16 |     return __builtin_stdc_bit_width(x);
      |            ^~~~~~~~~~~~~~~~~~~~~~~~
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Funkce <strong>__builtin_stdc_bit_floor</strong></h2>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

uint8_t bit_floor_8bit(uint8_t x) {
    uint8_t z;
    z = __builtin_stdc_bit_floor(x);
    return z;
}

void print_bin(uint8_t x) {
    int i;

    for (i = 7; i &gt;= 0; i--) {
        printf("%d", (x &gt;&gt; i) &amp; 1);
    }
}

void test_bit_floor(uint8_t x) {
    printf("%u \t", x);
    print_bin(x);
    printf("\t%d\n", bit_floor_8bit(x));
}

int main(void) {
    uint8_t i;

    for (i=0; i&lt;=17; i++) {
        test_bit_floor(i);
    }

    test_bit_floor(0xff);
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Překlad vestavěné funkce <strong>__builtin_stdc_bit_floor</strong> do strojového kódu</h2>

<p>Opět se podíváme na to, jakým způsobem je vestavěná funkce nazvaná
<strong>__builtin_stdc_bit_floor</strong> přeložena do strojového kódu, a to na
platformách x86-64, ARM 32 (v7) i AArch64. Tuto funkci budeme opět volat
s&nbsp;předáním operandů (bez znaménka) různých typů. Překládaný zdrojový kód
vypadá následovně:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
int <strong>bit_floor_8bit</strong>(uint8_t x) {
    return <u>__builtin_stdc_bit_floor</u>(x);
}
&nbsp;
int <strong>bit_floor_16bit</strong>(uint16_t x) {
    return <u>__builtin_stdc_bit_floor</u>(x);
}
&nbsp;
int <strong>bit_floor_32bit</strong>(uint32_t x) {
    return <u>__builtin_stdc_bit_floor</u>(x);
}
&nbsp;
int <strong>bit_floor_64bit</strong>(uint64_t x) {
    return <u>__builtin_stdc_bit_floor</u>(x);
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
bit_floor_8bit:
        xor     eax, eax
        test    dil, dil
        je      .L1
        movzx   edi, dil
        mov     eax, 1
        bsr     ecx, edi
        sal     eax, cl
        movzx   eax, al
.L1:
        ret

bit_floor_16bit:
        xor     eax, eax
        test    di, di
        je      .L5
        movzx   edi, di
        mov     eax, 1
        bsr     ecx, edi
        sal     eax, cl
        movzx   eax, ax
.L5:
        ret

bit_floor_32bit:
        mov     eax, edi
        test    edi, edi
        je      .L9
        bsr     ecx, edi
        mov     eax, -2147483648
        xor     ecx, 31
        shr     eax, cl
.L9:
        ret

bit_floor_64bit:
        xor     eax, eax
        test    rdi, rdi
        je      .L13
        movabs  rax, -9223372036854775808
        bsr     rcx, rdi
        xor     rcx, 63
        shr     rax, cl
.L13:
        ret
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
bit_floor_8bit:
        subs    r3, r0, #0
        beq     .L3
        push    {r4, lr}
        bl      __clzsi2
        mov     r3, #1
        rsb     r0, r0, #31
        lsl     r0, r3, r0
        and     r0, r0, #255
        pop     {r4, lr}
        bx      lr
.L3:
        mov     r0, r3
        bx      lr

bit_floor_16bit:
        subs    r3, r0, #0
        beq     .L11
        push    {r4, lr}
        bl      __clzsi2
        mov     r3, #65536
        rsb     r0, r0, #31
        lsl     r0, r3, r0
        lsr     r0, r0, #16
        pop     {r4, lr}
        bx      lr
.L11:
        mov     r0, r3
        bx      lr

bit_floor_32bit:
        subs    r3, r0, #0
        beq     .L22
        push    {r4, lr}
        bl      __clzsi2
        mov     r3, #-2147483648
        lsr     r3, r3, r0
        mov     r0, r3
        pop     {r4, lr}
        bx      lr
.L22:
        mov     r0, r3
        bx      lr

bit_floor_64bit:
        orrs    r3, r0, r1
        beq     .L27
        push    {r4, lr}
        bl      __clzdi2
        mov     r1, #-2147483648
        rsb     r3, r0, #32
        sub     r2, r0, #32
        lsl     r0, r1, r3
        orr     r0, r0, r1, lsr r2
        pop     {r4, lr}
        bx      lr
.L27:
        mov     r0, #0
        bx      lr
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
bit_floor_8bit:
        ands    w0, w0, 255
        mov     w2, 31
        clz     w3, w0
        mov     w1, 1
        sub     w2, w2, w3
        lsl     w0, w1, w2
        and     w0, w0, 255
        csel    w0, w0, wzr, ne
        ret

bit_floor_16bit:
        ands    w0, w0, 65535
        mov     w2, 31
        clz     w3, w0
        mov     w1, 1
        sub     w2, w2, w3
        lsl     w0, w1, w2
        and     w0, w0, 65535
        csel    w0, w0, wzr, ne
        ret

bit_floor_32bit:
        clz     w2, w0
        cmp     w0, 0
        mov     w1, -2147483648
        lsr     w1, w1, w2
        csel    w0, w1, w0, ne
        ret

bit_floor_64bit:
        clz     x2, x0
        cmp     x0, 0
        mov     x1, -9223372036854775808
        lsr     x0, x1, x2
        csel    w0, w0, wzr, ne
        ret
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce <strong>__builtin_stdc_bit_ceil</strong></h2>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

uint8_t bit_ceil_8bit(uint8_t x) {
    uint8_t z;
    z = __builtin_stdc_bit_ceil(x);
    return z;
}

void print_bin(uint8_t x) {
    int i;

    for (i = 7; i &gt;= 0; i--) {
        printf("%d", (x &gt;&gt; i) &amp; 1);
    }
}

void test_bit_ceil(uint8_t x) {
    printf("%u \t", x);
    print_bin(x);
    printf("\t%d\n", bit_ceil_8bit(x));
}

int main(void) {
    uint8_t i;

    for (i=0; i&lt;=17; i++) {
        test_bit_ceil(i);
    }

    test_bit_ceil(0xff);
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Překlad vestavěné funkce <strong>__builtin_stdc_bit_ceil</strong> do strojového kódu</h2>

<p>Pro otestování způsobu překladu vestavěné funkce
<strong>__builtin_stdc_bit_ceil</strong> do strojového kódu testovaných
platforem použijeme následující demonstrační příklad, který se (až na odlišnou
volanou funkci) podobá příkladu, který jsme používali pro funkci
<strong>__builtin_stdc_bit_floor</strong>:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
int <strong>bit_ceil_8bit</strong>(uint8_t x) {
    return <u>__builtin_stdc_bit_ceil</u>(x);
}
&nbsp;
int <strong>bit_ceil_16bit</strong>(uint16_t x) {
    return <u>__builtin_stdc_bit_ceil</u>(x);
}
&nbsp;
int <strong>bit_ceil_32bit</strong>(uint32_t x) {
    return <u>__builtin_stdc_bit_ceil</u>(x);
}
&nbsp;
int <strong>bit_ceil_64bit</strong>(uint64_t x) {
    return <u>__builtin_stdc_bit_ceil</u>(x);
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
bit_ceil_8bit:
        mov     eax, 1
        cmp     dil, 1
        jbe     .L1
        lea     ecx, [rdi-1]
        mov     eax, 2
        movzx   ecx, cl
        bsr     ecx, ecx
        sal     eax, cl
        movzx   eax, al
.L1:
        ret

bit_ceil_16bit:
        mov     eax, 1
        cmp     di, 1
        jbe     .L5
        lea     ecx, [rdi-1]
        mov     eax, 2
        movzx   ecx, cx
        bsr     ecx, ecx
        sal     eax, cl
        movzx   eax, ax
.L5:
        ret

bit_ceil_32bit:
        mov     eax, 1
        cmp     edi, 1
        jbe     .L9
        sub     edi, 1
        mov     eax, 2
        bsr     ecx, edi
        sal     eax, cl
.L9:
        ret

bit_ceil_64bit:
        mov     eax, 1
        cmp     rdi, 1
        jbe     .L11
        sub     rdi, 1
        mov     eax, 2
        bsr     rcx, rdi
        sal     rax, cl
.L11:
        ret
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Minule jsme si ukazovali některé příklady naprogramované v&nbsp;assembleru,
konkrétně v&nbsp;NASMu pro Linux. Odkazy na tyto příklady naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>bsf1.asm</td><td>základní použití instrukce <strong>BSF</strong> pro jeden vstup</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf1.asm</a></td></tr>
<tr><td> 2</td><td>bsf1_lst.asm</td>kontrolní výpis výsledku překladu: instrukční kód instrukce <strong>BSF</strong><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf1_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf1_lst.asm</a></td></tr>
<tr><td> 3</td><td>bsf2.asm</td><td>základní použití instrukce <strong>BSF</strong> pro hodnoty 0 až 16</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf2.asm</a></td></tr>
<tr><td> 4</td><td>bsf3.asm</td><td>chování instrukce <strong>BSF</strong> v&nbsp;případě, že je vstup nulový</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>bsr1.asm</td><td>základní použití instrukce <strong>BSR</strong> pro jeden vstup</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr1.asm</a></td></tr>
<tr><td> 6</td><td>bsr1_lst.asm</td><td>kontrolní výpis výsledku překladu: instrukční kód instrukce <strong>BSR</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr1_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr1_lst.asm</a></td></tr>
<tr><td> 7</td><td>bsr2.asm</td><td>základní použití instrukce <strong>BSR</strong> pro hodnoty 0 až 16</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr2.asm</a></td></tr>
<tr><td> 8</td><td>bsr3.asm</td><td>chování instrukce <strong>BSR</strong> v&nbsp;případě, že je vstup nulový</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>lzcnt1.asm</td><td>základní použití instrukce <strong>LZCNT</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt1.asm</a></td></tr>
<tr><td>10</td><td>lzcnt1_lst.asm</td><td>kontrolní výpis výsledku překladu: instrukční kód instrukce <strong>LZCNT</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt1_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt1_lst.asm</a></td></tr>
<tr><td>11</td><td>lzcnt2.asm</td><td>alternativní zápis instrukce <strong>LZCNT</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt2.asm</a></td></tr>
<tr><td>12</td><td>lzcnt2_lst.asm</td><td>kontrolní výpis výsledku překladu: instrukční kód instrukce <strong>REP BSF</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt2_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt2_lst.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>tzcnt1.asm</td><td>základní použití instrukce <strong>TZCNT</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt1.asm</a></td></tr>
<tr><td>14</td><td>tzcnt1_lst.asm</td><td>kontrolní výpis výsledku překladu: instrukční kód instrukce <strong>TZCNT</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt1_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt1_lst.asm</a></td></tr>
<tr><td>15</td><td>tzcnt2.asm</td><td>alternativní zápis instrukce <strong>TZCNT</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt2.asm</a></td></tr>
<tr><td>16</td><td>tzcnt2_lst.asm</td><td>kontrolní výpis výsledku překladu: instrukční kód instrukce <strong>REP BSR</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt2_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt2_lst.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>hex2string.asm</td><td>pomocná makra pro převod hexadecimální hodnoty na řetězec</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/hex2string.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/hex2string.asm</a></td></tr>
<tr><td>18</td><td>linux_macros.asm</td><td>pomocná makra použitá v&nbsp;programech psaných pro Linux v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/linux_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/linux_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>Makefile</td><td>Makefile určený pro překlad všech výše uvedených demonstračních příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/Makefile">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/Makefile</a></td></tr>
</table>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
s&nbsp;využitím překladače <strong>gcc</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>rotate_left.c</td><td>volání vestavěné funkce v&nbsp;C (GCC) realizující rotaci doleva</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left.c</a></td></tr>
<tr><td> 2</td><td>rotate_left_x86_00.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_00.asm</a></td></tr>
<tr><td> 3</td><td>rotate_left_x86_09.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_09.asm</a></td></tr>
<tr><td> 4</td><td>rotate_left_arm32.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm32.asm</a></td></tr>
<tr><td> 5</td><td>rotate_left_arm64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>rotate_right.c</td><td>volání vestavěné funkce v&nbsp;C (GCC) realizující rotaci doleva</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right.c</a></td></tr>
<tr><td> 7</td><td>rotate_right_x86_00.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_00.asm</a></td></tr>
<tr><td> 8</td><td>rotate_right_x86_09.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_09.asm</a></td></tr>
<tr><td> 9</td><td>rotate_right_arm32.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm32.asm</a></td></tr>
<tr><td>10</td><td>rotate_right_arm64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>parity_unsigned.c</td><td>volání vestavěných funkcí <strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong> a <strong>__builtin_parityll</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned.c</a></td></tr>
<tr><td>12</td><td>parity_unsigned_x86_00.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_00.asm</a></td></tr>
<tr><td>13</td><td>parity_unsigned_x86_09.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_09.asm</a></td></tr>
<tr><td>14</td><td>parity_unsigned_arm32.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm32.asm</a></td></tr>
<tr><td>15</td><td>parity_unsigned_arm64.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>parityg_unsigned.c</td><td>volání vestavěné funkce <strong>__builtin_parityg</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned.c</a></td></tr>
<tr><td>17</td><td>parityg_unsigned_arm32.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm32.asm</a></td></tr>
<tr><td>18</td><td>parityg_unsigned_arm64.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm64.asm</a></td></tr>
<tr><td>19</td><td>parityg_unsigned_x86_00.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_00.asm</a></td></tr>
<tr><td>20</td><td>parityg_unsigned_x86_09.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_09.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>parity_signed.c</td><td>výpočet parity celočíselných hodnot se znaménkem: realizace pomocí vestavěných funkcí <strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong> a <strong>__builtin_parityll</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_signed.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_signed.c</a></td></tr>
<tr><td>22</td><td>parityg_signed.c</td><td>výpočet parity celočíselných hodnot se znaménkem: realizace pomocí vestavěné funkce <strong>__builtin_parityg</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_signed.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_signed.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>bit_width.c</td><td>volání vestavěné funkce <strong>__builtin_stdc_bit_width</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width.c</a></td></tr>
<tr><td>24</td><td>bit_width_x86_64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_bit_width</strong> na platformě x86-64</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_x86_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_x86_64.asm</a></td></tr>
<tr><td>25</td><td>bit_width_arm_32.asm</td><td>překlad volání funkce <strong>__builtin_stdc_bit_width</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_arm_32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_arm_32.asm</a></td></tr>
<tr><td>26</td><td>bit_width_arm_64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_bit_width</strong> pro 64bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_arm_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_arm_64.asm</a></td></tr>
<tr><td>27</td><td>bit_width_test.c</td><td>test návratových hodnot vypočtených funkcí <strong>__builtin_stdc_bit_width</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_test.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_test.c</a></td></tr>
<tr><td>28</td><td>bit_width_signed.c</td><td>vestavěná funkce <strong>__builtin_stdc_bit_width</strong> a hodnoty se znaménkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_signed.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_width_signed.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>bit_floor.c</td><td>volání vestavěné funkce <strong>__builtin_stdc_bit_floor</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor.c</a></td></tr>
<tr><td>30</td><td>bit_floor_x86_64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_bit_floor</strong> na platformě x86-64</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor_x86_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor_x86_64.asm</a></td></tr>
<tr><td>31</td><td>bit_floor_arm_32.asm</td><td>překlad volání funkce <strong>__builtin_stdc_bit_floor</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor_arm_32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor_arm_32.asm</a></td></tr>
<tr><td>32</td><td>bit_floor_arm_64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_bit_floor</strong> pro 64bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor_arm_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor_arm_64.asm</a></td></tr>
<tr><td>33</td><td>bit_floor_test.c</td><td>test návratových hodnot vypočtených funkcí <strong>__builtin_stdc_bit_floor</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor_test.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_floor_test.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>34</td><td>bit_ceil.c</td><td>volání vestavěné funkce <strong>__builtin_stdc_bit_ceil</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil.c</a></td></tr>
<tr><td>35</td><td>bit_ceil_x86_64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_bit_ceil</strong> na platformě x86-64</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil_x86_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil_x86_64.asm</a></td></tr>
<tr><td>36</td><td>bit_ceil_arm_32.asm</td><td>překlad volání funkce <strong>__builtin_stdc_bit_ceil</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil_arm_32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil_arm_32.asm</a></td></tr>
<tr><td>37</td><td>bit_ceil_arm_64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_bit_ceil</strong> pro 64bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil_arm_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil_arm_64.asm</a></td></tr>
<tr><td>38</td><td>bit_ceil_test.c</td><td>test návratových hodnot vypočtených funkcí <strong>__builtin_stdc_bit_ceil</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil_test.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_ceil_test.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>bit_scan_forward_one_test.c</td><td>test vestavěné funkce <strong>__builtin_stdc_first_trailing_one</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_scan_forward_one_test.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_scan_forward_one_test.c</a></td></tr>
<tr><td>40</td><td>bit_scan_forward_zero_test.c</td><td>test vestavěné funkce <strong>__builtin_stdc_first_trailing_zero</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_scan_forward_zero_test.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/bit_scan_forward_zero_test.c</a></td></tr>
</table>

<p>Všechny demonstrační příklady z&nbsp;článku <a
href="https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/">Funkce
vestavěné v&nbsp;GCC pro provádění nízkoúrovňových aritmetických operací</a>
jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add_overflow.c</td><td>volání vestavěné funkce <strong>__builtin_add_overflow</strong> s&nbsp;předáním operandů různých typů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow.c</a></td></tr>
<tr><td> 2</td><td>add_overflow_x86_64_O0.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_O0.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_O0.asm</a></td></tr>
<tr><td> 3</td><td>add_overflow_x86_64_Os.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_Os.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_Os.asm</a></td></tr>
<tr><td> 4</td><td>add_overflow_arm_32.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_32.asm</a></td></tr>
<tr><td> 5</td><td>add_overflow_arm_64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>add_diff_types.c</td><td>součet s&nbsp;využitím různých kombinací hodnot typu <strong>char</strong> a <strong>int</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types.c</a></td></tr>
<tr><td> 7</td><td>add_diff_types_x86_64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_x86_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_x86_64.asm</a></td></tr>
<tr><td> 8</td><td>add_diff_types_arm32.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm32.asm</a></td></tr>
<tr><td> 9</td><td>add_diff_types_arm64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>sub_overflow.c</td><td>operace rozdílu s&nbsp;využitím funkce <strong>__builtin_sub_overflow</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.c</a></td></tr>
<tr><td>11</td><td>sub_overflow.asm</td><td>překlad volání funkce <strong>__builtin_sub_overflow</strong> na platformě x86-64</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>addc_subc.c</td><td>operace součtu tří hodnot a operace rozdílu: s&nbsp;výpůjčkou nebo s&nbsp;přetečením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/addc_subc.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/addc_subc.asm</a></td></tr>
</table>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>rdrand_support.asm</td><td>test, jestli je instrukce <strong>RDRAND</strong> mikroprocesorem podporována</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm</a></td></tr>
<tr><td>2</td><td>rdrand_read.asm</td><td>přečtení jedné 32bitové hodnoty instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm</a></td></tr>
<tr><td>3</td><td>rdrand_read_loop.asm</td><td>přečtení sekvence 32bitových hodnot instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>rdrand_read.c</td><td>přečtení náhodné 32bitové hodnoty, realizace s&nbsp;využitím vestavěné funkce GCC</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c</a></td></tr>
<tr><td>5</td><td>rdrand_read.asm</td><td>výsledek překladu předchozího zdrojového kódu do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>rand_gen.c</td><td>vygenerování binárního souboru s&nbsp;pseudonáhodnými 32bitovými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c</a></td></tr>
<tr><td>7</td><td>rdrand_gen.c</td><td>vygenerování binárního souboru s&nbsp;hodnotami vrácenými instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Funkce vestavěné v&nbsp;GCC pro provádění nízkoúrovňových aritmetických operací<br />
<a href="https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/">https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/</a>
</li>

<li>Generátor náhodných čísel založený na instrukcích RDSEED a RDRAND<br />
<a href="https://www.root.cz/clanky/generator-nahodnych-cisel-zalozeny-na-instrukcich-rdseed-a-rdrand/">https://www.root.cz/clanky/generator-nahodnych-cisel-zalozeny-na-instrukcich-rdseed-a-rdrand/</a>
</li>

<li>Circular shift (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Bitwise_operation#Circular_shift">https://en.wikipedia.org/wiki/Bitwise_operation#Circular_shift</a>
</li>

<li>Parity bit (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Parity_bit">https://en.wikipedia.org/wiki/Parity_bit</a>
</li>

<li>Parity function (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Parity_function">https://en.wikipedia.org/wiki/Parity_function</a>
</li>

<li>RDRAND (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RDRAND">https://en.wikipedia.org/wiki/RDRAND</a>
</li>

<li>RDRAND instruction<br />
<a href="https://www.felixcloutier.com/x86/rdrand">https://www.felixcloutier.com/x86/rdrand</a>
</li>

<li>Random Number Generator<br />
<a href="https://wiki.osdev.org/Random_Number_Generator">https://wiki.osdev.org/Random_Number_Generator</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Other Built-in Functions Provided by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>
</li>

<li>GCC: 6.60 Built-in Functions Specific to Particular Target Machines<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins">https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins</a>
</li>

<li>Additional Builtins for Numeric Operations<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Numeric-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Numeric-Builtins.html</a>
</li>

<li>Bit Operation Builtins<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Bit-Operation-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Bit-Operation-Builtins.html</a>
</li>

<li>Stránka projektu Compiler Explorer<br />
<a href="https://godbolt.org/">https://godbolt.org/</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://llvm.org/">https://llvm.org/</a>
</li>

<li>GCC, the GNU Compiler Collection<br />
<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>
</li>

<li>Clang<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Clang: Assembling a Complete Toolchain<br />
<a href="https://clang.llvm.org/docs/Toolchain.html">https://clang.llvm.org/docs/Toolchain.html</a>
</li>

<li>Integer overflow<br />
<a href="https://en.wikipedia.org/wiki/Integer_overflow">https://en.wikipedia.org/wiki/Integer_overflow</a>
</li>

<li>SETcc — Set Byte on Condition<br />
<a href="https://www.felixcloutier.com/x86/setcc">https://www.felixcloutier.com/x86/setcc</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>Undefined behavior (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Undefined_behavior">https://en.wikipedia.org/wiki/Undefined_behavior</a>
</li>

<li>Is signed integer overflow still undefined behavior in C++?<br />
<a href="https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c">https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c</a>
</li>

<li>Allowing signed integer overflows in C/C++<br />
<a href="https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c">https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c</a>
</li>

<li>SXTB, SXTH, SXTW<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html">https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html</a>
</li>

<li>BX, BXNS<br />
<a href="https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions/bx--bxns?lang=en">https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions/bx--bxns?lang=en</a>
</li>

<li>Carry and Borrow Principles<br />
<a href="https://www.tpub.com/neets/book13/53a.htm">https://www.tpub.com/neets/book13/53a.htm</a>
</li>

<li>In binary subtraction, how do you handle a borrow when there are no bits left to borrow form<br />
<a href="https://stackoverflow.com/questions/68629408/in-binary-subtraction-how-do-you-handle-a-borrow-when-there-are-no-bits-left-to">https://stackoverflow.com/questions/68629408/in-binary-subtraction-how-do-you-handle-a-borrow-when-there-are-no-bits-left-to</a>
</li>

<li>Is there any legitimate use for Intel's RDRAND?<br />
<a href="https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand">https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand</a>
</li>

<li>Intel® Digital Random Number Generator (DRNG) Software Implementation Guide<br />
<a href="https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html">https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html</a>
</li>

<li>Hardware random number generator<br />
<a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">https://en.wikipedia.org/wiki/Hardware_random_number_generator</a>
</li>

<li>Random number generator attack<br />
<a href="https://en.wikipedia.org/wiki/Random_number_generator_attack">https://en.wikipedia.org/wiki/Random_number_generator_attack</a>
</li>

<li>random_r.c (Glibc)<br />
<a href="https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341">https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341</a>
</li>

<li>Xorshift<br />
<a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>
</li>

<li>x86 instruction listings<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>Odd inline asm code generation with pointless memory operand<br />
<a href="https://github.com/llvm/llvm-project/issues/56789">https://github.com/llvm/llvm-project/issues/56789</a>
</li>

<li>Bit scanning equivalencies<br />
<a href="https://fgiesen.wordpress.com/2013/10/18/bit-scanning-equivalencies/">https://fgiesen.wordpress.com/2013/10/18/bit-scanning-equivalencies/</a>
</li>

<li>BSF — Bit Scan Forward<br />
<a href="https://www.felixcloutier.com/x86/bsf">https://www.felixcloutier.com/x86/bsf</a>
</li>

<li>BSR — Bit Scan Reverse<br />
<a href="https://www.felixcloutier.com/x86/bsr">https://www.felixcloutier.com/x86/bsr</a>
</li>

<li>TZCNT — Count the Number of Trailing Zero Bits<br />
<a href="https://www.felixcloutier.com/x86/tzcnt">https://www.felixcloutier.com/x86/tzcnt</a>
</li>

<li>LZCNT — Count the Number of Leading Zero Bits<br />
<a href="https://www.felixcloutier.com/x86/lzcnt">https://www.felixcloutier.com/x86/lzcnt</a>
</li>

<li>Standard library header &lt;stdbit.h&gt; (C23)<br />
<a href="https://en.cppreference.com/w/c/header/stdbit">https://en.cppreference.com/w/c/header/stdbit</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

