<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Specifika instrukční sady mikroprocesorů Intel 8086/8088</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Specifika instrukční sady mikroprocesorů Intel 8086/8088</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Specifika instrukční sady mikroprocesorů Intel 8086/8088</a></p>
<p><a href="#k02">2. Architektura CISC</a></p>
<p><a href="#k03">3. Programátorský model mikroprocesoru Intel 8086</a></p>
<p><a href="#k04">4. Dostupné adresovací režimy</a></p>
<p><a href="#k05">5. Instrukční sada mikroprocesorů Intel 8088 a Intel 8086</a></p>
<p><a href="#k06">6. Registr s&nbsp;příznaky (<i>FLAGS</i>)</a></p>
<p><a href="#k07">7. Aritmetické instrukce</a></p>
<p><a href="#k08">8. Logické instrukce, bitové posuny a rotace</a></p>
<p><a href="#k09">9. Strojové instrukce určené pro provedení skoku</a></p>
<p><a href="#k10">10. Nepodmíněné skoky</a></p>
<p><a href="#k11">11. Příznaky a podmíněné skoky</a></p>
<p><a href="#k12">12. Vybrané instrukce pro podmíněné skoky založené na testování příznakových bitů</a></p>
<p><a href="#k13">13. Použití instrukcí <strong>DEC</strong> a <strong>JZN</strong> pro implementaci počítané programové smyčky</a></p>
<p><a href="#k14">14. Odlišná realizace počítané smyčky s&nbsp;instrukcemi <strong>DEC</strong>, <strong>JZ</strong> a <strong>JMP</strong></a></p>
<p><a href="#k15">*** 15. Počítané programové smyčky realizované instrukcí <strong>LOOP</strong></a></p>
<p><a href="#k16">16. Použití instrukce <strong>CMP</strong> v&nbsp;součinnosti s&nbsp;podmíněným skokem</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Seznam již popsaných instrukcí</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Specifika instrukční sady mikroprocesorů Intel 8086/8088</h2>

<p>Programátorský model mikroprocesoru Intel 8086 do určité míry vychází z&nbsp;jeho předchůdců, tedy z&nbsp;čipů 8080 a 8085. Došlo ovšem k&nbsp;rozšíření sady registrů, k&nbsp;určité unifikaci jejich role (což zjednodušilo instrukční sadu) a k&nbsp;rozšíření pracovních registrů na šířku šestnácti bitů. Navíc se rozšířily adresovací režimy a při adresování se kromě základní 16bitové adresy počítá i adresa segmentu získaná z&nbsp;registrů CS, DS, ES či SS. Oproti 8080 je zde tedy výrazný skok vpřed, ovšem v&nbsp;porovnání s&nbsp;dalšími mikroprocesory této éry patří 8086 spíše mezi jednodušší mikroprocesory (což ovšem nemusí být vždy špatně).</p>

<p>Mikroprocesory řady Intel 8086 jsou naprosto typickými zástupci CISC
architektury, takže se nejprve zmiňme, o co se vlastně jedná. <i>CISC</i>
znamená <i>Complex Instruction Set Computer</i>, tj.&nbsp;počítač (ale spíše
mikroprocesor) s&nbsp;relativně složitými instrukcemi s&nbsp;vyšší úrovní
abstrakce, než instrukce <i>RISC</i> (<i>Reduced Instruction Set
Computer</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Architektura CISC</h2>

<p>CISC je založen na relativně starých myšlenkách. Již v&nbsp;roce 1962 se
firma IBM rozhodla navrhnout do značné míry univerzální architekturu počítačů,
která by pokrývala jak nároky jednodušších úloh (pro které stačily méně výkonné
a tím pádem i levnější počítače), tak i nároky mnohem větší. Předností této
architektury mělo být to, že systém &bdquo;rostl&ldquo; současně
s&nbsp;rostoucími požadavky zákazníka, a to bez nutnosti měnit programové
vybavení (co nám to připomíná?). Výsledkem těchto snah firmy IBM byla platforma
nazvaná <i>System/360</i>, resp.&nbsp;zkráceně <i>S/360</i>. Pro tuto platformu
byla vytvořena poměrně rozsáhlá a složitá instrukční sada (ISA), která mimo
běžné binární aritmetiky obsahovala i instrukce pro práci s&nbsp;textem, různé
numerické formáty dat známé například z&nbsp;kalkulaček, ale i podporu BCD
aritmetiky, která se dodnes používá například při výpočtech s&nbsp;měnou.
V&nbsp;té době totiž vládlo přesvědčení, že bohatší instrukční sada ulehčí
práci překladačům z&nbsp;vyšších programovacích jazyků, vyplní takzvanou
<i>sémantickou mezeru</i> mezi assemblerem a vyššími programovacími jazyky
atd.</p>

<p>Vzhledem ke složitosti instrukční sady System/360 se v&nbsp;praxi používaly
<i>mikroprogramy</i>, tj.&nbsp;jednodušší procesory s&nbsp;touto architekturou
kompatibilní mnoho instrukcí přímo nevykonávaly, ale vlastně emulovaly na
základě takzvaného mikrokódu (mikroinstrukcí uložených v&nbsp;mikrořadiči)
&ndash; jednalo se tedy o obdobu dnes populárních bytekódů, které také mohou
být emulovány přímo v&nbsp;mikroprocesorech (mikroprogramem), nikoli
uživatelským programem. Teprve mnohem později byly podobně koncipované
instrukční sady a mikroprocesory nazvány CISC neboli Complex Instruction Set
Code (v&nbsp;některých případech byly i mikroinstrukce pro přímé vykonání
zbytečně složité, a proto byly rozkládány do takzvaných nanoinstrukcí, což
vedlo ke snížení potřebné kapacity paměti v&nbsp;mikrořadiči i zjednodušení
návrhu samotného mikroprocesoru).</p>

<p>Procesory s&nbsp;architekturou CISC se většinou vyznačují velmi obsáhlou
instrukční sadou, mnohdy do značné míry ortogonální (tj.&nbsp;většina instrukcí
může být použita se všemi adresními režimy). To ovšem vede k&nbsp;nutnosti
použití složitého řadiče, instrukce trvají i několik desítek či stovek taktů a
celková složitost mikroprocesoru obecně roste. Před cca 10-15 lety se zdálo, že
celá architektura CISC bude opuštěna a nahrazena architekturou RISC. Ve
skutečnosti však vznikly jakési hybridní architektury &ndash; dnes
nejpopulárnější mikroprocesory jsou sice interně vytvořeny jako RISCové, ale
jejich instrukční sada je CISCová. V&nbsp;této kombinaci se ukazují výhody obou
architektur: velká rychlost a interní jednoduchost RISCů a současně kratší kód
instrukcí u CISC procesorů (snižují se nároky na vyrovnávací paměti). Pro
příklad nemusíme chodit daleko, protože do tohoto stavu došla i platforma x86
(a před ní VAX či Motorola 68060). I populární 32bitové RISCové procesory ARM
obsahují instrukční sadu nazvanou Thumb, která umožňuje snížení velikosti
programů o cca 30–40 %.</p>

<p>Pro ilustraci &bdquo;komplexnosti&ldquo; instrukční sady následuje příklad
části programu napsaného v&nbsp;assembleru CISCové architektury x86. Všimněte
si různých adresních režimů, implicitně zadaných operandů u instrukce
<strong>imul</strong>, segmentového adresování pomocí segmentového registru
<strong>es</strong>, i toho, že u aritmetických instrukcí je možné používat
operandy přímo načítané z&nbsp;operační paměti (<strong>mov es, ax</strong>,
<strong>add ax,[zy1]</strong>), což je pro CISCové architektury typické a
naopak netypické pro architekturu RISC:</p>

<pre>
mov     ax,bp
sar     ax,cl
imul    ax          <i>; implicitní operandy: dx:ax=ax*ax</i>
push    ax
&nbsp;
mov     ax,bx
sar     ax,cl       <i>; při bitovém posunu se musí použít registr cl</i>
imul    ax
mov     es:[di],ax  <i>; uložení obsahu registru do paměti</i>
&nbsp;
mov     ax,bp
sar     ax,cl
sar     bx,5
imul    bx          <i>; implicitní operandy: dx:ax=ax*bx</i>
add     ax,[zy1]    <i>; jeden z operandů je načten z operační paměti</i>
xchg    ax,bx
&nbsp;
pop     ax
push    ax
sub     ax,es:[di]
add     ax,[zx1]
mov     bp, ax
pop     ax
add     ax,es:[di]
dec     ch
jz      short pokrac
cmp     ax,4*P
jc      short opak
stosb               <i>; další instrukce s implicitními operandy (porušení ortogonality)</i>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;některých případech se i díky
CISC podařila konstruktérům procesorů vytvořit instrukční sada s&nbsp;velmi
&bdquo;hustým&ldquo; instrukčním kódem, kdy se využívaly instrukce
s&nbsp;proměnnou délkou. Týkalo se to především použití sofistikovanějších
adresních režimů, například při současném použití bázového registru, indexového
registru násobeného konstantou a offsetu (příkladem může být instrukční sada
procesorů řady i386, v&nbsp;níž je možné adresovací režimy využít i pro
relativně složité výpočty prováděné například instrukcí <strong>LEA</strong>
&ndash; <i>Load Effective Address</i>). K&nbsp;této problematice se
pochopitelně ještě vrátíme.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Programátorský model mikroprocesoru Intel 8086</h2>

<p>Nejprve si vysvětlíme takzvaný <i>programátorský model</i> mikroprocesorů
řady Intel 8086, tedy i včetně čipu Intel 8088 použitého v&nbsp;první generaci
IBM PC. Stručně řečeno popisuje programátorský model dostupné registry,
adresovací režimy a skupinu použitelných instrukcí. Začněme s&nbsp;popisem
registrů. Celkově je možné pracovat s&nbsp;těmito čtrnácti registry, které mají
všechny šířku šestnácti bitů (u dalších modelů x86 to už tak jednoduché ani
zdaleka nebude, protože některé registry jsou rozšířeny na 32bitů atd.):</p>

<table>
<tr><th>#</th><th>Typ registrů</th><th>Počet registrů</th><th>Bitová šířka registru</th><th>Názvy registrů</th></tr>
<tr><td>1</td><td>Univerzální registry</td><td>4</td><td>16 bitů</td><td>AX, BX, CX, DX</td></tr>
<tr><td>2</td><td>Indexové registry</td><td>2</td><td>16 bitů</td><td>SI, DI</td></tr>
<tr><td>3</td><td>Bázové registry</td><td>2</td><td>16 bitů</td><td>BP, SP (ale logicky sem spadá i BX)</td></tr>
<tr><td>4</td><td>Segmentové registry</td><td>4</td><td>16 bitů</td><td>CS, DS, ES, SS</td></tr>
<tr><td>5</td><td>Příznakový registr</td><td>1</td><td>16 bitů</td><td>FLAGS</td></tr>
<tr><td>6</td><td>Programový čítač</td><td>1</td><td>16 bitů</td><td>IP</td></tr>
</table>

<p>První čtyři registry jsou sice nazvány <i>univerzální</i>, ovšem jejich role
není zcela zaměnitelná. Každý z&nbsp;těchto registrů má totiž kromě své
základní role ještě další roli/role a vystupuje jako implicitní operand u mnoha
specifických instrukcí (instrukční sada není v&nbsp;žádném případě ortogonální,
naopak se jedná o snad nejméně ortogonální sadu v&nbsp;oblasti 16bitových
čipů). Navíc se tyto registry rozdělují na &bdquo;horní&ldquo; a
&bdquo;dolní&ldquo; osmibitové registry (tj.&nbsp;změna <strong>AL</strong>
modifikuje spodních osm bitů registru <strong>AX</strong> a naopak):</p>

<table>
<tr><th>Registr</th><th>Rozdělení</th><th>Význam</th></tr>
<tr><td>AX</td><td>AH/AL</td><td>akumulátor</td></tr>
<tr><td>BX</td><td>BH/BL</td><td>bázová adresa</td></tr>
<tr><td>CX</td><td>CH/CL</td><td>čítač (counter)</td></tr>
<tr><td>DX</td><td>DH/DL</td><td>data, rozšíření akumulátoru pro 32bitové operace atd.</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: jak uvidíme dále, tak pro mnoho
instrukcí existuje kratší operační kód v&nbsp;případě, že se jako první (nebo
jediný) operand využije akumulátor. Stále je zde patrný odkaz na dobu
mikroprocesorů 8008 a 8080.</div></p>

<p>Jména registrů <strong>SI</strong> a <strong>DI</strong> vznikla ze sousloví
<i>Source Index</i> a <i>Destination Index</i> a jméno registru
<strong>BP</strong> znamená <i>Base Pointer</i>.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Dostupné adresovací režimy</h2>

<p>U procesorů Intel 8086/8088 je dostupných hned několik adresovacích režimů,
které jsou dokonce pojmenovány (i když v&nbsp;praxi se většinou toto
pojmenování nepoužívá). Podívejme se nyní, které režimy jsou podporovány:</p>

<table>
<tr><th>Název režimu</th><th>Stručný popis</th><th>Ukázka instrukce</th></tr>
<tr><td>register</td><td>operandem je přímo zapsaný registr</td><td>add AX, BX</td></tr>
<tr><td>immediate</td><td>operandem je konstanta (8bit, 16bit)</td><td>mov AL, 3; mov BX, 42</td></tr>
<tr><td>displacement/direct</td><td>operandem je přímá adresa</td><td>inc byte [123], inc word [123]</td></tr>
<tr><td>register indirect</td><td>operandem je adresa uložená v&nbsp;SI, DI nebo BX</td><td>mov AX, [DI]</td></tr>
<tr><td>based indexed mode</td><td>operandem je bázová adresa (BX, BP) zvýšená o offset (SI, DI)</td><td>mov AX, [BX+DI]</td></tr>
<tr><td>indexed mode</td><td>operandem je bázová adresa (SI, DI) zvýšená o offset (konstanta)</td><td>mov AX, [SI+1000]</td></tr>
<tr><td>based mode</td><td>dtto, ale pro bázový registr a offset</td><td>mov AX, [BP+1000]</td></tr>
<tr><td>based indexed displacement</td><td>adresa je vypočtena z&nbsp;indexového registru, bázového registru a offsetu</td><td>mov AX, [SI+BP+offset]</td></tr>
<tr><td>string</td><td>pro adresování se implicitně použije ES:DI nebo DS:SI</td><td>movs, stosb, loadsw</td></tr>
</table>

<p>Všechny možné kombinace zápisu adres (tedy ne přímo konstant či registrů
v&nbsp;roli operandů) jsou vypsány v&nbsp;následující tabulce. Více kombinací
už pro 8086/8088 neexistuje (vynecháno je adresování řetězců, to je totiž
implicitní):</p>

<table>
<tr><th>Použitý zápis v&nbsp;assembleru</th><th>Adresovací režim</th></tr>
<tr><td>přímá adresa (16bit) </td><td>displacement/direct</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX]</td><td>register indirect</td></tr>
<tr><td>[SI]</td><td>register indirect</td></tr>
<tr><td>[DI]</td><td>register indirect</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX+SI]</td><td>based indexed mode</td></tr>
<tr><td>[BX+DI]</td><td>based indexed mode</td></tr>
<tr><td>[BP+SI]</td><td>based indexed mode</td></tr>
<tr><td>[BP+DI]</td><td>based indexed mode</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BP+offset_8_bit]</td><td>based mode</td></tr>
<tr><td>[BX+offset_8_bit]</td><td>based mode</td></tr>
<tr><td>[SI+offset_8_bit]</td><td>indexed mode</td></tr>
<tr><td>[DI+offset_8_bit]</td><td>indexed mode</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BP+offset_16_bit]</td><td>based mode</td></tr>
<tr><td>[BX+offset_16_bit]</td><td>based mode</td></tr>
<tr><td>[SI+offset_16_bit]</td><td>indexed mode</td></tr>
<tr><td>[DI+offset_16_bit]</td><td>indexed mode</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX+SI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BX+DI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+SI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+DI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX+SI+offset_16_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BX+DI+offset_16_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+SI+offset_16_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+DI+offset_16_bit]</td><td>based indexed displacement</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: chybějící adresovací režim [BP] je
assemblery nahrazen za variantu [BP+0], která je o bajt delší.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukční sada mikroprocesorů Intel 8088 a Intel 8086</h2>

<p>Poměrně rozsáhlá sada instrukcí mikroprocesorů Intel 8088 a Intel 8086 je
vypsána v&nbsp;následující tabulce. K&nbsp;jednotlivým instrukcím se ještě
vrátíme při jejich podrobnějším popisu:</p>

<table>
<tr><td>AAA</td><td>ASCII adjust AL after addition</td></tr>
<tr><td>AAD</td><td>ASCII adjust AX before division</td></tr>
<tr><td>AAM</td><td>ASCII adjust AX after multiplication</td></tr>
<tr><td>AAS</td><td>ASCII adjust AL after subtraction</td></tr>
<tr><td>ADC</td><td>Add with carry</td></tr>
<tr><td>ADD</td><td>Add</td></tr>
<tr><td>AND</td><td>Logical AND</td></tr>
<tr><td>CALL</td><td>Call procedure</td></tr>
<tr><td>CBW</td><td>Convert byte to word</td></tr>
<tr><td>CLC</td><td>Clear carry flag</td></tr>
<tr><td>CLD</td><td>Clear direction flag</td></tr>
<tr><td>CLI</td><td>Clear interrupt flag</td></tr>
<tr><td>CMC</td><td>Complement carry flag</td></tr>
<tr><td>CMP</td><td>Compare operands</td></tr>
<tr><td>CMPSB</td><td>Compare bytes in memory</td></tr>
<tr><td>CMPSW</td><td>Compare words</td></tr>
<tr><td>CWD</td><td>Convert word to doubleword</td></tr>
<tr><td>DAA</td><td>Decimal adjust AL after addition</td></tr>
<tr><td>DAS</td><td>Decimal adjust AL after subtraction</td></tr>
<tr><td>DEC</td><td>Decrement by 1</td></tr>
<tr><td>DIV</td><td>Unsigned divide</td></tr>
<tr><td>ESC</td><td>Used with floating-point unit</td></tr>
<tr><td>HLT</td><td>Enter halt state</td></tr>
<tr><td>IDIV</td><td>Signed divide</td></tr>
<tr><td>IMUL</td><td>Signed multiply in One-operand form</td></tr>
<tr><td>IN</td><td>Input from port</td></tr>
<tr><td>INC</td><td>Increment by 1</td></tr>
<tr><td>INT</td><td>Call to interrupt</td></tr>
<tr><td>INTO</td><td>Call to interrupt if overflow</td></tr>
<tr><td>IRET</td><td>Return from interrupt</td></tr>
<tr><td>Jcc</td><td>Jump if condition</td></tr>
<tr><td>JCXZ</td><td>Jump if CX is zero</td></tr>
<tr><td>JMP</td><td>Jump</td></tr>
<tr><td>LAHF</td><td>Load FLAGS into AH register</td></tr>
<tr><td>LDS</td><td>Load DS:r with far pointer</td></tr>
<tr><td>LEA</td><td>Load Effective Address</td></tr>
<tr><td>LES</td><td>Load ES:r with far pointer</td></tr>
<tr><td>LOCK</td><td>Assert BUS LOCK# signal</td></tr>
<tr><td>LODSB</td><td>Load string byte</td></tr>
<tr><td>LODSW</td><td>Load string word</td></tr>
<tr><td>LOOP/LOOPx</td><td>Loop control</td></tr>
<tr><td>MOV</td><td>Move</td></tr>
<tr><td>MOVSB</td><td>Move byte from string to string</td></tr>
<tr><td>MOVSW</td><td>Move word from string to string</td></tr>
<tr><td>MUL</td><td>Unsigned multiply</td></tr>
<tr><td>NEG</td><td>Two's complement negation</td></tr>
<tr><td>NOP</td><td>No operation</td></tr>
<tr><td>NOT</td><td>Negate the operand, logical NOT</td></tr>
<tr><td>OR</td><td>Logical OR</td></tr>
<tr><td>OUT</td><td>Output to port</td></tr>
<tr><td>POP</td><td>Pop data from stack</td></tr>
<tr><td>POPF</td><td>Pop FLAGS register from stack</td></tr>
<tr><td>PUSH</td><td>Push data onto stack</td></tr>
<tr><td>PUSHF</td><td>Push FLAGS onto stack</td></tr>
<tr><td>RCL</td><td>Rotate left (with carry)</td></tr>
<tr><td>RCR</td><td>Rotate right (with carry)</td></tr>
<tr><td>REPxx</td><td>Repeat MOVS/STOS/CMPS/LODS/SCAS</td></tr>
<tr><td>RET</td><td>Return from procedure</td></tr>
<tr><td>RETN</td><td>Return from near procedure</td></tr>
<tr><td>RETF</td><td>Return from far procedure</td></tr>
<tr><td>ROL</td><td>Rotate left</td></tr>
<tr><td>ROR</td><td>Rotate right</td></tr>
<tr><td>SAHF</td><td>Store AH into FLAGS</td></tr>
<tr><td>SAL</td><td>Shift Arithmetically left (signed shift left)</td></tr>
<tr><td>SAR</td><td>Shift Arithmetically right (signed shift right)</td></tr>
<tr><td>SBB</td><td>Subtraction with borrow</td></tr>
<tr><td>SCASB</td><td>Compare byte string</td></tr>
<tr><td>SCASW</td><td>Compare word string</td></tr>
<tr><td>SHL</td><td>Shift left (unsigned shift left)</td></tr>
<tr><td>SHR</td><td>Shift right (unsigned shift right)</td></tr>
<tr><td>STC</td><td>Set carry flag</td></tr>
<tr><td>STD</td><td>Set direction flag</td></tr>
<tr><td>STI</td><td>Set interrupt flag</td></tr>
<tr><td>STOSB</td><td>Store byte in string</td></tr>
<tr><td>STOSW</td><td>Store word in string</td></tr>
<tr><td>SUB</td><td>Subtraction</td></tr>
<tr><td>TEST</td><td>Logical compare (AND)</td></tr>
<tr><td>WAIT</td><td>Wait until not busy</td></tr>
<tr><td>XCHG</td><td>Exchange data</td></tr>
<tr><td>XLAT</td><td>Table look-up translation</td></tr>
<tr><td>XOR</td><td>Exclusive OR</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Registr s&nbsp;příznaky (<i>FLAGS</i>)</h2>

<table>
<tr><th>Bit</th><th>Příznak</th><th>Stručný popis příznaku</th></tr>
<tr><td> 0</td><td>CF</td><td>příznak přenosu (<i>carry</i>)</td></tr>
<tr><td> 1</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td> 2</td><td>PF</td><td>příznak (bitové) parity</td></tr>
<tr><td> 3</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td> 4</td><td>AF</td><td>příznak přenosu ze třetího do čtvrtého bitu (<i>auxiliary carry</i>)</td></tr>
<tr><td> 5</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td> 6</td><td>ZF</td><td>příznak nulovosti (<i>zero</i>)</td></tr>
<tr><td> 7</td><td>SF</td><td>příznak znaménka (<i>sign</i>)</td></tr>
<tr><td> 8</td><td>TF</td><td>příznak nastavený při krokování</td></tr>
<tr><td> 9</td><td>IF</td><td>povolení či zákaz reakce na přerušení</td></tr>
<tr><td>10</td><td>DF</td><td>směr změny adres při blokových (řetězcových) operacích</td></tr>
<tr><td>11</td><td>OF</td><td>příznak přetečení (<i>overflow</i>)</td></tr>
<tr><td>12</td><td>&times;</td><td>na 8086 rezervováno, použito až v&nbsp;286</td></tr>
<tr><td>13</td><td>&times;</td><td>na 8086 rezervováno, použito až v&nbsp;286</td></tr>
<tr><td>14</td><td>&times;</td><td>na 8086 rezervováno, použito až v&nbsp;286</td></tr>
<tr><td>15</td><td>&times;</td><td>na 8086 rezervováno, použito až v&nbsp;286</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povolení a zákaz přerušení se provádí
instrukcemi <strong>EI</strong> (<i>Enable Interrupt</i>) a <strong>DI</strong>
(<i>Disable Interrupt</i>).</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Aritmetické instrukce</h2>

<p>První skupinou instrukcí, se kterou se v&nbsp;dnešním článku seznámíme, jsou
aritmetické instrukce. Na platformě Intel 8086 nalezneme všechny základní
aritmetické instrukce, a to včetně násobení a dělení se znaménkem i bez
znaménka. Tyto instrukce jsou však relativně pomalé. Počty cyklů nutných pro
dokončení jednotlivých operací jsou naznačeny v&nbsp;tabulce (pro ten
nejrychlejší způsob, tedy pro operace typu registr+registr):</p>

<table>
<tr><th>Instrukce</th><th>Cyklů</th><th>Stručný popis instrukce</th></tr>
<tr><td>ADD</td><td>3</td><td>součet</td></tr>
<tr><td>ADC</td><td>3</td><td>součet se započtením předchozího přenosu (<i>carry</i>)</td></tr>
<tr><td>SUB</td><td>3</td><td>rozdíl</td></tr>
<tr><td>SBB</td><td>3</td><td>rozdíl se započtením předchozí výpůjčky (<i>borrow</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CMP</td><td>3</td><td>porovnání s&nbsp;nastavením příznaků</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>INC</td><td>3</td><td>zvýšení operandu o jedničku </td></tr>
<tr><td>DEC</td><td>3</td><td>snížení operandu o jedničku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>MUL</td><td>70-77 (8bit), 118-133 (16bit)</td><td>násobení bez znaménka, výsledek v&nbsp;AX nebo DX:AX</td></tr>
<tr><td>DIV</td><td>80-90 (8bit), 144-162 (16bit)</td><td>dělení a výpočet zbytku po dělení bez znaménka</td></tr>
<tr><td>IMUL</td><td>80-98 (8bit), 128-154 (16bit)</td><td>násobení se znaménkem</td></tr>
<tr><td>IDIV</td><td>101-112 (8bit), 165-184 (16bit)</td><td>dělení se znaménkem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>NEG</td><td>3</td><td>negace (otočení znaménka)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: kvůli pomalosti operací pro násobení a
dělení se vyplatí (resp.&nbsp;vyplatilo) investovat čas do tvorby
optimalizovaných algoritmů založených na logických posunech.</div></p>

<p>Kvůli dlouhým časům násobení není divu, že se pro zpracování signálu
používaly <a
href="https://www.root.cz/clanky/od-mikroradicu-k-digitalnim-signalovym-procesorum-dsp/">specializované
DSP</a> s&nbsp;velmi rychlou násobičkou.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Logické instrukce, bitové posuny a rotace</h2>

<p>Mikroprocesor Intel 8086 pochopitelně obsahuje prakticky úplnou sadu
logických instrukcí a instrukcí určených pro provedení bitových posunů a
rotací. U instrukcí posunů a rotací je zajímavé, že operace posunu/rotace o
jeden bit je velmi rychlá, ale posun o <strong>CL</strong> bitů naopak velmi
pomalá, takže se (většinou) na Intel 8086 vyplatí si rozepsat například
násobení osmi na tři posuny a nikoli na posun o tři bity:</p>

<table>
<tr><th>Instrukce</th><th>Cyklů</th><th>Stručný popis instrukce</th></tr>
<tr><td>AND</td><td>3</td><td>bitová operace logického součinu</td></tr>
<tr><td>OR</td><td>3</td><td>bitová operace logického součtu</td></tr>
<tr><td>XOR</td><td>3</td><td>bitová operace nonekvivalence</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>NOT</td><td>3</td><td>negace všech bitů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>TEST</td><td>3</td><td>provedení logického součinu bez uložení výsledku (mění se jen příznaky)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>RCL</td><td>2 (rotace o bit) nebo 8+4n</td><td>rotace (9 nebo 17 bitů) přes příznak <strong>CF</strong> doleva</td></tr>
<tr><td>RCR</td><td>2 (rotace o bit) nebo 8+4n</td><td>rotace (9 nebo 17 bitů) přes příznak <strong>CF</strong> doprava</td></tr>
<tr><td>ROL</td><td>2 (rotace o bit) nebo 8+4n</td><td>rotace osmi či šestnácti bitů doleva</td></tr>
<tr><td>ROR</td><td>2 (rotace o bit) nebo 8+4n</td><td>rotace osmi či šestnácti bitů doprava</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SAL</td><td>2 (posun o bit) nebo 8+4n</td><td>aritmetický posun doleva (stejné jako <strong>SHL</strong>)</td></tr>
<tr><td>SHL</td><td>2 (posun o bit) nebo 8+4n</td><td>bitový posun doleva (stejné jako <strong>SAL</strong>)</td></tr>
<tr><td>SAR</td><td>2 (posun o bit) nebo 8+4n</td><td>aritmetický posun doprava (zleva se nasunuje příznak <strong>SF</strong>)</td></tr>
<tr><td>SHR</td><td>2 (posun o bit) nebo 8+4n</td><td>bitový posun doprava (zleva se nasunuje nula)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: u aritmetických i bitových posunů se
bit, který se z&nbsp;registru &bdquo;ztrácí&ldquo;, přesouvá do příznaku
<strong>CF</strong>. U rotací přes <strong>CF</strong> je rotace provedeno pro
devět bitů a pro <strong>ROR/ROL</strong> se bit, který rotuje, kopíruje do
<strong>CF</strong>.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Strojové instrukce určené pro provedení skoku</h2>

<p>Velmi důležitým typem strojových instrukcí, které v&nbsp;různé podobě
najdeme prakticky u všech modelů mikroprocesorů (resp.&nbsp;přesněji řečeno u
mikroprocesorů všech dnes rozšířených mikroprocesorových architektur), jsou
instrukce provádějící skoky na nějakou adresu v&nbsp;operační paměti.
Implementace skoku není, alespoň na první pohled a u jednodušších architektur
bez instrukční pipeline, vlastně nijak složitá, protože se v&nbsp;případě
použití <i>absolutní adresy</i> dosadí hodnota z&nbsp;operačního kódu instrukce
do registru <i>IP</i> a v&nbsp;případě použití <i>relativní adresy</i> se tato
hodnota (nazývaná někdy poněkud nepřesně <i>offset</i>) přičte k&nbsp;aktuální
hodnotě registru <i>PC</i>. Relativní adresa je v&nbsp;tomto případě
v&nbsp;kódu instrukce uložena se znaménkem, proto se skok může provést dozadu i
dopředu (ostatně právě použití relativní adresy uvidíme v&nbsp;dále
popisovaných demonstračních příkladech).</p>

<p>Skoky většinou dělíme podle jednoho kritéria (formy zápisu adresy) na
<i>absolutní</i> a <i>relativní</i> a podle kritéria druhého (za jakým
okolností se skok provede) na skoky <i>podmíněné</i> a <i>nepodmíněné</i>.
V&nbsp;závislosti na použité instrukční sadě jsou možné různé kombinace,
typicky však u většiny mikroprocesorů nalezneme kombinace nepodmíněný absolutní
skok, nepodmíněný relativní skok a podmíněný relativní skok. Skoky nepodmíněné
jsou jednodušší a svou podstatou odpovídají příkazu <strong>goto</strong>
známého z&nbsp;některých programovacích jazyků a také z&nbsp;mnoha článků, ve
kterých autoři mnohdy bez hlubšího zamyšlení se nad původní myšlenkou opakují,
že by se <strong>goto</strong> nemělo při strukturovaném programování používat
:-). V&nbsp;assembleru se však skoky vesele používají, neboť právě pomocí nich
se vytváří základní konstrukce strukturovaného programování &ndash; podmínky a
programové smyčky (navíc relativní a tudíž i <i>lokální</i> skok není ta
nejhorší možná abstrakce).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nepodmíněné skoky</h2>

<p>U architektury mikroprocesorů Intel 8086 je základní strojovou instrukcí
určenou pro provedení <i>nepodmíněného skoku</i> instrukce nazvaná jednoduše a
přímočaře <strong>JMP</strong> (což je, jak jste zajisté zjistili,
mnemotechnická zkratka slova <i>jump</i>). V&nbsp;assembleru většinou za
mnemotechnickou zkratkou jména instrukce následuje návěští (<i>label</i>),
z&nbsp;něhož assembler odvodí reálnou adresu. Ukažme si typický špagetový kód
vznikající nadbytečným použitím této instrukce:</p>

<pre>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
start:
        jmp     cil1
&nbsp;
<strong>zpet</strong>:
        <i>; tisk retezce na obrazovku</i>
        mov     dx, message
        mov     ah, 9
        int     0x21
&nbsp;
        <i>; ukonceni procesu a navrat do DOSu</i>
        mov     ah, 0x4c
        int     0x21
&nbsp;
<strong>cil2</strong>:   jmp cil3
<strong>cil1</strong>:   jmp cil2
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db "Hello, world!", 0x0d, 0x0a, "$"
&nbsp;
<strong>cil3</strong>:   jmp zpet
</pre>

<p>Podívejme se, jak se vlastně instrukce <strong>JMP</strong> přeloží &ndash;
kolik má bajtů, zda obsahuje relativní nebo absolutní adresu atd.:</p>

<pre>
     1
     2                                  org  0x100        ; zacatek kodu pro programy typu COM (vzdy se zacina na 256)
     3                                  
     4                                  start:
     5 00000000 EB0D                            jmp     cil1
     6                                  
     7                                  zpet:
     8                                          ; tisk retezce na obrazovku
     9 00000002 BA[1100]                        mov     dx, message
    10 00000005 B409                            mov     ah, 9
    11 00000007 CD21                            int     0x21
    12                                  
    13                                          ; ukonceni procesu a navrat do DOSu
    14 00000009 B44C                            mov     ah, 0x4c
    15 0000000B CD21                            int     0x21
    16                                  
    17 0000000D EB12                    cil2:   jmp cil3
    18 0000000F EBFC                    cil1:   jmp cil2
    19                                  
    20                                          ; retezec ukonceny znakem $
    21                                          ; (tato data jsou soucasti vysledneho souboru typu COM)
    22 00000011 48656C6C6F2C20776F-     message db "Hello, world!", 0x0d, 0x0a, "$"
    22 0000001A 726C64210D0A24     
    23                                  
    24 00000021 EBDF                    cil3:   jmp zpet
</pre>

<p><div class="rs-tip-major">Poznámka: zde konkrétně se používá takzvaná
<i>short</i> varianta skoku s&nbsp;osmibitovou relativní adresou &ndash; celá
instrukce tak má délku 2 bajty.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příznaky a podmíněné skoky</h2>

<p>Alternativně je možné použít i další způsoby adresování, čímž se například
implementuje tabulka skoků (jedna z&nbsp;možných realizací stavového automatu)
atd., ovšem tyto techniky pro účely dnešního článku prozatím nepotřebujeme
znát. Mnohem zajímavější jsou <i>podmíněné skoky</i>, které se při programování
v&nbsp;assembleru či ve strojovém kódu používají pro implementaci programových
smyček <strong>while</strong>, <strong>do-while</strong>, <strong>for</strong>
a taktéž konstrukcí typu <strong>if-then-else</strong> atd. Podmíněný skok je
proveden či naopak neproveden na základě nějaké podmínky. Vzhledem k&nbsp;tomu,
že pracujeme na té nejnižší programové úrovni, tj.&nbsp;na úrovni strojových
instrukcí, není samozřejmě možné podmínku definovat nějakým složitým a
sofistikovaným způsobem &ndash; musí se jednat o operaci, kterou mikroprocesor
dokáže jednoduše a především dostatečně rychle zpracovat (i přesto představují
skoky úzké místo v&nbsp;programech).</p>

<p>Z&nbsp;tohoto prostého důvodu &ndash; podmínky musí být realizovány
dostatečně jednoduchým způsobem pro snadnou implementaci na čipu &ndash; jsou
na mikroprocesorových architekturách Intel 8086 podmínky založeny na testování
jednoho z&nbsp;takzvaných příznakových bitů, negací těchto bitů či dokonce
jejich kombinací. Pokud z&nbsp;důvodu zjednodušení výkladu celé relativně
rozsáhlé problematiky budeme ignorovat některé speciálnější příznaky a
především pak rozdíly mezi hodnotami bez znaménka (<i>unsigned</i>) a se
znaménkem (<i>signed</i>), můžeme zpočátku použít především příznaky nazvané
<strong>Carry flag</strong>, <strong>Sign flag</strong> a <strong>Zero
flag</strong>, tj.&nbsp;<i>příznak přenosu</i>, <i>příznak záporného
výsledku</i> a <i>příznak nulovosti</i>. Význam těchto příznakových bitů je
shrnut v&nbsp;následující tabulce:</p>

<table>
<tr><th>Příznak</th><th>Význam zkratky</th><th>Poznámka</th></tr>
<tr><td>ZF</td><td>zero flag</td><td>výsledek předchozí operace je nulový</td></tr>
<tr><td>CF</td><td>carry flag</td><td>přenos (bezznaménková aritmetika)</td></tr>
<tr><td>SF</td><td>sign flag</td><td>výsledek je záporný (nastaven nejvyšší bit bajtu či slova)</td></tr>
</table>

<p>V&nbsp;případě, že alespoň prozatím nebudeme brát v&nbsp;úvahu další
příznakové bity, existuje šest základních variant podmíněného skoku, které jsou
vypsány v&nbsp;tabulce <a href="#k12">v&nbsp;navazující kapitole</a>. Ve
chvíli, kdy podmínka není splněna (tj.&nbsp;testovaný příznakový bit má opačnou
hodnotu než očekávanou), není skok proveden, tj.&nbsp;mikroprocesor instrukci
skoku v&nbsp;podstatě ignoruje a pokračuje v&nbsp;načtení instrukce uvedené
ihned za skokem (to, že mikroprocesor instrukci skoku ignoruje samozřejmě platí
jen z&nbsp;pohledu logiky vytvářeného programu; samotné provedení instrukce
muselo proběhnout a tudíž se program o několik strojových taktů pozdržel
&ndash; i neprovedení podmíněného kroku si tedy vyžádalo svou cenu).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vybrané instrukce pro podmíněné skoky založené na testování příznakových bitů</h2>

<p>Strojové instrukce určené pro provedení podmíněných skoků jsou ve své
základní variantě (existují pro ně totiž i jmenné aliasy) pojmenovány jednoduše
a přímočaře &ndash; jejich jména začínají znakem <strong>J</strong>
(<i>jump</i>), za nímž následuje volitelné písmeno <strong>N</strong>
(<i>negace</i>) a jednoznaková zkratka příznaku. Instrukce <strong>JNC</strong>
tedy znamená &bdquo;proveď skok, pokud příznak Carry není nastaven&ldquo;,
zatímco instrukce <strong>JZ</strong> znamená &bdquo;proveď skok pouze při
nastavení příznaku Zero&ldquo;:</p>

<table>
<tr><th>Mnemotechnická zkratka instrukce</th><th>Význam instrukce podmíněného skoku</th></tr>
<tr><td>JC </td><td>podmíněný skok za předpokladu, že je nastaven příznak přenosu (<strong>Carry flag</strong>)</td></tr>
<tr><td>JNC</td><td>podmíněný skok za předpokladu, že je vynulován příznak přenosu (<strong>Carry flag</strong>)</td></tr>
<tr><td>JZ </td><td>podmíněný skok za předpokladu, že je nastaven příznak nulovosti (<strong>Zero flag</strong>)</td></tr>
<tr><td>JNZ</td><td>podmíněný skok za předpokladu, že je vynulován příznak nulovosti (<strong>Zero flag</strong>)</td></tr>
<tr><td>JS </td><td>podmíněný skok za předpokladu, že je nastaven příznak záporného výsledku (<strong>Sign flag</strong>)</td></tr>
<tr><td>JNS</td><td>podmíněný skok za předpokladu, že je vynulován příznak záporného výsledku (<strong>Sign flag</strong>)</td></tr>
</table>

<p>Jmenné aliasy:</p>

<table>
<tr><th>Instrukce</th><th>Alias</th></tr>
<tr><td>JZ </td><td>JE </td></tr>
<tr><td>JNZ</td><td>JNE</td></tr>
<tr><td>JC </td><td>JB, JNAE</td></tr>
<tr><td>JNC</td><td>JNB, JAE</td></tr>
<tr><td>JS </td><td>nemá alias</td></tr>
<tr><td>JNS</td><td>nemá alias</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použití instrukcí <strong>DEC</strong> a <strong>JZN</strong> pro implementaci počítané programové smyčky</h2>

<p><a href="#k12">V&nbsp;předchozí kapitole</a> jsme si řekli, že podmíněné
relativní skoky jsou použity pro implementaci programových smyček a podmínek.
K&nbsp;tomuto účelu se podmíněné skoky prakticky vždy vhodně kombinují
s&nbsp;některou instrukcí, která modifikuje jeden příznakový bit či dokonce
větší množství příznakových bitů. Například jednoduchou počítanou programovou
smyčku by bylo možné implementovat s&nbsp;využitím kombinace strojových
instrukcí <strong>DEC</strong> a <strong>JNZ</strong>. Instrukce nazvaná
<strong>DEC</strong> snižuje obsah specifikovaného pracovního registru o
jedničku a současně nastavuje příznak nuly, tj.&nbsp;<strong>Zero flag
(ZF)</strong>, samozřejmě ovšem pouze za předpokladu, že ten pracovní registr,
jehož hodnota se snižuje, skutečně dosáhl nulové hodnoty. Instrukce
<strong>JNZ</strong> znamená podmíněný skok, který je proveden pouze tehdy,
pokud příznak nuly <i>není</i> nastaven (&bdquo;jump if not zero&ldquo;, viz
též předchozí kapitolu).</p>

<p>Před samotným začátkem programové smyčky je samozřejmě nutné do pracovního
registru nastavit potřebný počet opakování, který by měl být ideálně odlišný od
nuly. Ostatně zkuste si sami odpovědět na otázku, co by se stalo
v&nbsp;případě, kdy by pracovní registr použitý jako počitadlo, byl před
vstupem do smyčky vynulovaný. Podívejme se nyní na způsob použití 16bitového
registru <strong>AX</strong> (akumulátory) ve funkci počitadla. Vzhledem
k&nbsp;tomu, že se testuje pouze nulovost registru po snížení jeho hodnoty o
jedničku, může tato smyčka být provedena 0&times; až 2<sup>16</sup>-1&times;
(ignoruje se znaménko):</p>

<pre>
        MOV AX, počet_opakování <i>; počet opakování smyčky</i>
<strong>SMYCKA</strong>: příkaz 1                 <i>; libovolné instrukce, jejichž celková</i>
        příkaz 2                 <i>; celková délka bloku musí být menší než cca 120 bytů</i>
        ...                      <i>; (kvůli omezení relativního skoku, pokud se délka překročí, použije se delší instrukce)</i>
        ...
        ...
        příkaz X
        DEC EAX                  <i>; snížení čítače smyčky o jedničku</i>
        JNZ SMYCKA               <i>; přeloží se jako relativní skok</i>
</pre>

<p>Praktický příklad &ndash; výpis zprávy 10&times;, jako počitadlo je použit
registr <strong>CX</strong>:</p>

<pre>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        mov     cx, 10       <i>; pocatecni hodnota pocitadla</i>
<strong>opak</strong>:
        <i>; tisk retezce na obrazovku</i>
        mov     dx, message
        mov     ah, 9
        int     0x21
&nbsp;        
        dec     cx            <i>; snizeni pocitadla o jednicku</i>
        jnz     opak          <i>; skok, dokud se nedosahne nuly</i>
&nbsp;
        <i>; ukonceni procesu a navrat do DOSu</i>
        mov     ah, 0x4c
        int     0x21
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db "Hello, world!", 0x0d, 0x0a, "$"
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odlišná realizace počítané smyčky s&nbsp;instrukcemi <strong>DEC</strong>, <strong>JZ</strong> a <strong>JMP</strong></h2>

<p>Podmínku ovšem můžeme naopak přesunout i na samotný začátek smyčky. Nyní se
ovšem namísto instrukce pro podmíněný skok <strong>JNZ</strong> použije
instrukce <strong>JZ</strong> (tedy opačná podmínka) v&nbsp;kombinaci
s&nbsp;instrukcí nepodmíněného skoku <strong>JMP</strong>:</p>

<pre>
        MOV AX, počet_opakování  <i>; počet opakování smyčky</i>
<strong>SMYCKA</strong>: DEC AX                   <i>; snížení čítače smyčky o jedničku</i>
        JZ  KONEC                <i>; přeloží se jako relativní skok</i>
        příkaz 1                 <i>; libovolné instrukce, jejichž celková</i>
        příkaz 2                 <i>; celková délka bloku musí být menší než cca 120 bytů</i>
        ...                      <i>; (kvůli omezení relativního skoku, pokud se délka překročí, použije se delší instrukce)</i>
        ...
        ...
        příkaz X
        JMP SMYCKA               <i>; nepodmíněný skok na začátek smyčky</i>
</pre>

<p>Opět si to ukažme v&nbsp;praxi na realizaci výpisu zprávy několikrát na
obrazovku:</p>

<pre>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        mov     cx, 10       <i>; pocatecni hodnota pocitadla</i>
<strong>opak</strong>:
        <i>; tisk retezce na obrazovku</i>
        mov     dx, message
        mov     ah, 9
        int     0x21
&nbsp;        
        dec     cx            <i>; snizeni pocitadla o jednicku</i>
        jz      konec         <i>; skok, pokus se dosahne nuly</i>
&nbsp;
        jmp     opak          <i>; opakujeme smycku</i>
<strong>konec</strong>:
        <i>; ukonceni procesu a navrat do DOSu</i>
        mov     ah, 0x4c
        int     0x21
&nbsp;
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db "Hello, world!", 0x0d, 0x0a, "$"
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Počítané programové smyčky realizované instrukcí <strong>LOOP</strong></h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Použití instrukce <strong>CMP</strong> v&nbsp;součinnosti s&nbsp;podmíněným skokem</h2>

<p>Společně s&nbsp;podmíněnými skoky se velmi často používá doposud nepopsaná
instrukce nazvaná <strong>CMP</strong> (mnemotechnická zkratka od slova
<i>compare</i>). V&nbsp;podstatě se jedná o běžné celočíselné odečítání,
tj.&nbsp;o instrukci nazvanou <strong>SUB</strong>, ovšem s&nbsp;tím důležitým
rozdílem, že výsledek, tj.&nbsp;samotný rozdíl, není nikam zapsán, což znamená,
že se obsah běžných pracovních registrů provedením této instrukce nezmění. Na
první pohled může vypadat tato instrukce nesmyslně &ndash; proč se vůbec mají
odečítat dvě hodnoty, když se výsledek hned zapomene? Ovšem samotný výsledek
není ve skutečnosti vše, protože při odečítání si mikroprocesor
v&nbsp;příznakových registrech zapamatuje i to, zda byla odečítaná čísla shodná
(tehdy se nastaví <strong>Zero flag</strong> na jedničku) či zda byla druhá
hodnota větší než hodnota první (příznak <strong>Carry flag</strong> bude
v&nbsp;tomto případě roven jedné). Navíc se nastaví i další příznaky používané
při práci s&nbsp;hodnotami se znaménkem.</p>

<p>Instrukce <strong>CMP</strong> akceptuje různé typy operandů; může se jednat
o běžné pracovní registry, ovšem použít lze i konstanty či obsah získaný ze
zvolené adresy operační paměti (platí zde tedy všechny výše zmíněné adresovací
režimy). V&nbsp;následující tabulce si ukážeme, jaké základní příznaky se
nastaví při provedení různých variant funkce <strong>CMP</strong>:</p>

<table>
<tr><th>První operand</th><th>Druhý operand</th><th>Zero flag</th><th>Carry flag</th><th>Význam</th></tr>
<tr><td>00</td><td>00</td><td>1</td><td>0</td><td>obě hodnoty jsou shodné</td></tr>
<tr><td>42</td><td>42</td><td>1</td><td>0</td><td>obě hodnoty jsou shodné</td></tr>
<tr><td>20</td><td>10</td><td>0</td><td>0</td><td>první hodnota je větší (nedošlo k&nbsp;přenosu)</td></tr>
<tr><td>10</td><td>20</td><td>0</td><td>1</td><td>druhá hodnota je větší (došlo k&nbsp;přenosu)</td></tr>
</table>

<p>Poznámka: ve skutečnosti by v&nbsp;tomto případě (odečítání a porovnávání)
bylo korektnější mluvit o takzvané <i>výpůjčce (borrow)</i> a nikoli o
<i>přenosu (carry)</i>.</p>

<p>Z&nbsp;těchto příkladů současně nepřímo vyplývá i to, jak můžeme příznakové
bity použít. Jestliže je zapotřebí testovat dvě hodnoty na rovnost, postačí
zjistit, zda je <strong>Zero flag</strong> nastavený na jedničku (ostatně i
z&nbsp;tohoto důvodu má podmíněný skok <strong>JZ</strong> alias
<strong>JE</strong> &ndash; jump if equal). Pokud potřebujeme otestovat, jestli
je první hodnota menší než druhá, lze zjistit hodnotu příznaku <strong>Carry
flag</strong> atd. Test na nulovou hodnotu lze provést odečtením nuly &ndash;
výsledek bude uložen v&nbsp;<strong>Zero flagu</strong> (ve skutečnosti se
ovšem tento test většinou neprovádí, protože i některé další instrukce dokážou
nastavit tento příznak automaticky a vlastně &bdquo;mimochodem&ldquo;). Podobně
je tomu u testování, zda je hodnota kladná či záporná. Podívejme se na několik
možností použití:</p>


<pre>
<i>; test na rovnost dvou hodnot</i>
MOV AX, hodnota 1
MOV BX, hodnota 2
CMP AX, BX
JZ  JE_ROVNO    <i>; skok na kód provedený v případě rovnosti</i>
JNZ NENI_ROVNO  <i>; skok na kód provedený v případě nerovnosti</i>
</pre>

<pre>
<i>; zjištění relace dvou čísel</i>
MOV AX, hodnota 1
MOV BX, hodnota 2
CMP AX, BX
JNC AX_JE_VETSI_NEBO_ROVNO_BX
JC  AX_JE_MENSI_NEZ_BX
</pre>

<pre>
<i>; test na nulovost</i>
MOV AX, hodnota
SUB BX, BX       <i>; vynulování registru BX (lze i XOR BX,BX)</i>
CMP AX, BX
JZ  AX_JE_NULOVE
</pre>

<pre>
<i>; test na nulovost</i>
MOV AX, hodnota
CMP AX, 0
JZ  AX_JE_NULOVE
</pre>

<pre>
<i>; test na kladnou či zápornou hodnou</i>
MOV AX, hodnota
CMP AX, 0
JS  AX_JE_ZAPORNE
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Seznam již popsaných instrukcí</h2>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>cga_text_mode_1.asm</td><td>standardní textový režim s&nbsp;rozlišením 40&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm</a></td></tr>
<tr><td>27</td><td>cga_text_mode_3.asm</td><td>standardní textový režim s&nbsp;rozlišením 80&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm</a></td></tr>
<tr><td>28</td><td>cga_text_mode_intensity.asm</td><td>změna významu nejvyššího bitu atributového bajtu: vyšší intenzita namísto blikání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm</a></td></tr>
<tr><td>29</td><td>cga_text_mode_cursor.asm</td><td>změna tvaru textového kurzoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm</a></td></tr>
<tr><td>30</td><td>cga_text_gfx_1.asm</td><td>zobrazení &bdquo;rastrové mřížky&ldquo;: pseudografický režim 160&times;25 pixelů (interně textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm</a></td></tr>
<tr><td>31</td><td>cga_text_mode_char_height.asm</td><td>změna výšky znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm</a></td></tr>
<tr><td>32</td><td>cga_text_160x100.asm</td><td>grafický režim 160&times;100 se šestnácti barvami (interně upravený textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>hercules_text_mode_1.asm</td><td>využití standardního textového režimu společně s&nbsp;kartou Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm</a></td></tr>
<tr><td>34</td><td>hercules_text_mode_2.asm</td><td>zákaz blikání v&nbsp;textových režimech</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm</a></td></tr>
<tr><td>35</td><td>hercules_turn_off.asm</td><td>vypnutí generování video signálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm</a></td></tr>
<tr><td>36</td><td>hercules_gfx_mode_1.asm</td><td>přepnutí karty Hercules do grafického režimu (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm</a></td></tr>
<tr><td>37</td><td>hercules_gfx_mode_2.asm</td><td>přepnutí karty Hercules do grafického režimu (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm</a></td></tr>
<tr><td>38</td><td>hercules_putpixel.asm</td><td>subrutina pro vykreslení jediného pixelu na kartě Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>ega_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm</a></td></tr>
<tr><td>40</td><td>ega_text_mode_80x43.asm</td><td>zobrazení 43 textových řádků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm</a></td></tr>
<tr><td>41</td><td>ega_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm</a></td></tr>
<tr><td>42</td><td>ega_gfx_mode_640x200.asm</td><td>přepnutí do grafického režimu 640&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm</a></td></tr>
<tr><td>43</td><td>ega_gfx_mode_640x350.asm</td><td>přepnutí do grafického režimu 640&times;350 pixelů se čtyřmi nebo šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm</a></td></tr>
<tr><td>44</td><td>ega_gfx_mode_bitplanes_1.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (základní způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm</a></td></tr>
<tr><td>45</td><td>ega_gfx_mode_bitplanes_2.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (rychlejší způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>ega_320x200_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm</a></td></tr>
<tr><td>47</td><td>ega_640x350_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 640&times;350 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>ega_standard_font.asm</td><td>použití standardního fontu grafické karty EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm</a></td></tr>
<tr><td>49</td><td>ega_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>ega_palette_1.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 320&times;200 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm</a></td></tr>
<tr><td>51</td><td>ega_palette_2.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 640&times;350 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm</a></td></tr>
<tr><td>52</td><td>ega_palette_3.asm</td><td>změna všech barev v&nbsp;barvové paletě s&nbsp;využitím programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm</a></td></tr>
<tr><td>53</td><td>ega_palette_4.asm</td><td>změna všech barev, včetně barvy okraje, v&nbsp;barvové paletě voláním funkce BIOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>vga_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm</a></td></tr>
<tr><td>55</td><td>vga_text_mode_80x50.asm</td><td>zobrazení 50 a taktéž 28 textových řádků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm</a></td></tr>
<tr><td>56</td><td>vga_text_mode_intensity_1.asm</td><td>změna chování atributového bitu pro blikání (nebezpečná varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm</a></td></tr>
<tr><td>57</td><td>vga_text_mode_intensity_2.asm</td><td>změna chování atributového bitu pro blikání (bezpečnější varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm</a></td></tr>
<tr><td>58</td><td>vga_text_mode_9th_column.asm</td><td>modifikace způsobu zobrazení devátého sloupce ve znakových režimech (720 pixelů na řádku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm</a></td></tr>
<tr><td>59</td><td>vga_text_mode_cursor_shape.asm</td><td>změna tvaru textového kurzoru na grafické kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm</a></td></tr>
<tr><td>60</td><td>vga_text_mode_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>vga_gfx_mode_640x480.asm</td><td>přepnutí do grafického režimu 640&times;480 pixelů se šestnácti barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm</a></td></tr>
<tr><td>62</td><td>vga_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů s&nbsp;256 barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm</a></td></tr>
<tr><td>63</td><td>vga_gfx_mode_palette.asm</td><td>změna všech barev v&nbsp;barvové paletě grafické karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm</a></td></tr>
<tr><td>64</td><td>vga_gfx_mode_dac_1.asm</td><td>využití DAC (neočekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm</a></td></tr>
<tr><td>65</td><td>vga_gfx_mode_dac_2.asm</td><td>využití DAC (očekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>66</td><td>vga_640x480_putpixel.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 640&times;480 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm</a></td></tr>
<tr><td>67</td><td>vga_320x200_putpixel_1.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm</a></td></tr>
<tr><td>68</td><td>vga_320x200_putpixel_2.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (rychlejší varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>vga_gfx_mode_dac_3.asm</td><td>přímé využití DAC v&nbsp;grafickém režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>70</td><td>vga_gfx_mode_unchained_step_1.asm</td><td>zobrazení barevných pruhů v&nbsp;režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm</a></td></tr>
<tr><td>71</td><td>vga_gfx_mode_unchained_step_2.asm</td><td>vypnutí zřetězení bitových rovin a změna způsobu adresování pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm</a></td></tr>
<tr><td>72</td><td>vga_gfx_mode_unchained_step_3.asm</td><td>vykreslení barevných pruhů do vybraných bitových rovin</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>73</td><td>vga_gfx_mode_320x400.asm</td><td>nestandardní grafický režim s&nbsp;rozlišením 320&times;400 pixelů a 256 barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm</a></td></tr>
<tr><td>74</td><td>vga_320x200_image.asm</td><td>zobrazení rastrového obrázku ve standardním grafickém režimu 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm</a></td></tr>
<tr><td>75</td><td>vga_320x200_unchained_image_1.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (nekorektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm</a></td></tr>
<tr><td>76</td><td>vga_320x200_unchained_image_2.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (korektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm</a></td></tr>
<tr><td>77</td><td>vga_320x400_unchained_image.asm</td><td>zobrazení rastrového obrázku v&nbsp;nestandardním režimu 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>78</td><td>vga_vertical_scroll_1.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm</a></td></tr>
<tr><td>79</td><td>vga_vertical_scroll_2.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm</a></td></tr>
<tr><td>80</td><td>vga_split_screen_1.asm</td><td>režim split-screen a scrolling, nefunční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm</a></td></tr>
<tr><td>81</td><td>vga_split_screen_2.asm</td><td>režim split-screen a scrolling, plně funkční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm</a></td></tr>
<tr><td>82</td><td>vga_horizontal_scroll_1.asm</td><td>horizontální scrolling bez rozšíření počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm</a></td></tr>
<tr><td>83</td><td>vga_horizontal_scroll_2.asm</td><td>horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm</a></td></tr>
<tr><td>84</td><td>vga_horizontal_scroll_3.asm</td><td>jemný horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>85</td><td>vga_320x240_image.asm</td><td>nastavení grafického režimu Mode-X, načtení a vykreslení obrázku, scrolling</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>86</td><td>io.asm</td><td>knihovna maker pro I/O operace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm</a></td></tr>
<tr><td>87</td><td>vga_lib.asm</td><td>knihovna maker a podprogramů pro programování karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm</a></td></tr>
<tr><td>88</td><td>vga_320x240_lib.asm</td><td>nastavení grafického režimu Mode-X, tentokrát knihovními funkcemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>89</td><td>vga_bitblt_1.asm</td><td>první (naivní) implementace operace <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm</a></td></tr>
<tr><td>90</td><td>vga_bitblt_2.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm</a></td></tr>
<tr><td>91</td><td>vga_bitblt_3.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro čtení i zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm</a></td></tr>
<tr><td>92</td><td>vga_bitblt_4.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace makry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm</a></td></tr>
<tr><td>93</td><td>vga_bitblt_5.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace podprogramem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>94</td><td>vga_bitblt_rotate.asm</td><td>zápisový režim s&nbsp;rotací bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm</a></td></tr>
<tr><td>95</td><td>vga_bitblt_fast.asm</td><td>rychlá korektní 32bitová operace typu <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm</a></td></tr>
<tr><td>96</td><td>vga_320x400_bitblt_1.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (neúplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm</a></td></tr>
<tr><td>97</td><td>vga_320x400_bitblt_2.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (úplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm</a></td></tr>
<tr><td>98</td><td>vga_write_modes_1.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis bez úpravy latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm</a></td></tr>
<tr><td>99</td><td>vga_write_modes_2.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis s&nbsp;modifikací latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm</a></td></tr>
<tr><td>100</td><td>vga_write_modes_3.asm</td><td>volitelné zápisové režimy grafické karty VGA, cílená modifikace latche vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>101</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>6845 - Motorola CRT Controller<br />
<a href="https://stanislavs.org/helppc/6845.html">https://stanislavs.org/helppc/6845.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

<li>Programmer's Guide to Yamaha YMF 262/OPL3 FM Music Synthesizer<br />
<a href="https://moddingwiki.shikadi.net/wiki/OPL_chip">https://moddingwiki.shikadi.net/wiki/OPL_chip</a>
</li>

<li>Does anybody understand how OPL2 percussion mode works?<br />
<a href="https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/">https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/</a>
</li>

<li>Yamaha YMF262 OPL3 music - MoonDriver for OPL3 DEMO [Oscilloscope View]<br />
<a href="https://www.youtube.com/watch?v=a7I-QmrkAak">https://www.youtube.com/watch?v=a7I-QmrkAak</a>
</li>

<li>Yamaha OPL vs OPL2 vs OPL3 comparison<br />
<a href="https://www.youtube.com/watch?v=5knetge5Gs0">https://www.youtube.com/watch?v=5knetge5Gs0</a>
</li>

<li>OPL3 Music Crockett's Theme<br />
<a href="https://www.youtube.com/watch?v=HXS008pkgSQ">https://www.youtube.com/watch?v=HXS008pkgSQ</a>
</li>

<li>Bad Apple (Adlib Tracker - OPL3)<br />
<a href="https://www.youtube.com/watch?v=2lEPH6Y3Luo">https://www.youtube.com/watch?v=2lEPH6Y3Luo</a>
</li>

<li>FM Synthesis Chips, Codecs and DACs<br />
<a href="https://www.dosdays.co.uk/topics/fm_synthesizers.php">https://www.dosdays.co.uk/topics/fm_synthesizers.php</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

