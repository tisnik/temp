<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Problematika ukazatelů v překladačích jazyka C pro systém DOS</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Problematika ukazatelů v překladačích jazyka C pro systém DOS</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Je těžké rozhodnout, jaký byl největší problém systému DOS. Zda neexistence pokročilejších funkcí, nutnost explicitní konfigurace HW atd. Z pohledu programátorů se však jednalo o práci s pamětí, která byla organizována systémem segment:offset. To do značné míry ovlivnilo i způsob práce s ukazateli v céčku.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Problematika ukazatelů v&nbsp;překladačích jazyka C pro systém DOS</a></p>
<p><a href="#k02">*** 2. Adresování stylem segment:offset</a></p>
<p><a href="#k03">3. Rozsah paměti IBM PC s&nbsp;mikroprocesorem 8086 či 8088</a></p>
<p><a href="#k04">4. Rozsah adresovatelné paměti mikroprocesoru 80286</a></p>
<p><a href="#k05">5. Může offset přesáhnout hranici jednoho segmentu?</a></p>
<p><a href="#k06">*** 6. Paměťové modely překladačů jazyka C v&nbsp;reálném režimu</a></p>
<p><a href="#k07">*** 7. Praktická část: paměťové modely překladače Borland C++ 3.0</a></p>
<p><a href="#k08">*** 8. Velikosti ukazatelů, základní aritmetika s&nbsp;ukazateli</a></p>
<p><a href="#k09">9. Funkce vracející větší z&nbsp;hodnot předaných přes ukazatel</a></p>
<p><a href="#k10">*** 10. Překlad pro paměťové modely s&nbsp;krátkými ukazateli pro data</a></p>
<p><a href="#k11">*** 11. Překlad pro paměťové modely s&nbsp;dlouhými ukazateli pro data</a></p>
<p><a href="#k12">*** 12. Alokace a přístup k&nbsp;prvkům pole přesahujícího velikost jednoho segmentu</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Problematika ukazatelů v&nbsp;překladačích jazyka C pro systém DOS</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Adresování stylem segment:offset</h2>

<pre>
adresa = segment &times; 16 + offset
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozsah paměti IBM PC s&nbsp;mikroprocesorem 8086 či 8088</h2>

<p>Vraťme se na chvíli k&nbsp;prapůvodním mikroprocesorům Intel 8086/8088, se
kterými byla další řada mikroprocesorů do značné míry kompatibilní. Připomeňme
si, že tyto čipy měly fyzicky vyvedených pouze dvacet adresových vodičů a
dokázaly tak adresovat přesně 1MB paměti (ani o bajt více &ndash; nedokázaly
tedy přistoupit k&nbsp;HMA!). Výpočet adresy probíhal na základě kombinace
<i>segmentu</i> a <i>offsetu</i> přesně takovým způsobem, jak bylo popsáno <a
href="#k02">v&nbsp;předchozí kapitole</a>.</p>

<p>Teoreticky tedy může adresa (říkejme jí logická adresa) přesáhnout přes 1MB
v&nbsp;případě, že použijeme vysoké číslo segmentu (0xf000 a výše) i offsetu.
Ovšem jak bude vypadat fyzická adresa (přenesená na adresovou sběrnici) na
mikroprocesorech 8086/8088? Napoví nám obrázky jejich pinů, v&nbsp;nichž
nalezneme i adresové vodiče:</p>

<img src="https://i.iinfo.cz/images/202/80286-pins-1.webp" class="image-1159800" width="312" height="407" alt="&#160;" title="Autor:    Intel, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 1: Piny mikroprocesoru Intel 8086.</i></p>

<img src="https://i.iinfo.cz/images/202/80286-pins-2.gif" class="image-1159803" width="230" height="385" alt="&#160;" title="Autor:     Intel, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 1: Piny mikroprocesoru Intel 8088.</i></p>

<p>U mikroprocesoru Intel 8086 nalezneme mj.&nbsp;i piny <strong>AD0</strong>
až <strong>AD15</strong> a taktéž piny <strong>A16</strong> až
<strong>A19</strong>. Naproti tomu u čipu Intel 8088 se jedná o piny
<strong>AD0</strong> až <strong>AD7</strong> následované piny
<strong>A8</strong> až <strong>A19</strong>. Žádné jiné rozdíly mezi oběma čipy
přitom z&nbsp;externího HW pohledu neexistují. Piny začínající znaky
<strong>AD</strong> se přitom používají pro adresovou i datovou sběrnici (data
jsou multiplexována, což byl velmi často používaný způsob &ndash; nejprve se
jedním směrem přenesla adresa a poté se provedlo čtení či zápis dat), zatímco
piny začínající jen znakem <strong>A</strong> značí vodiče pouze adresové
sběrnice. Co to znamená? Intel 8086 má externí datovou sběrnici se šestnácti
vodiči a adresovou sběrnici s&nbsp;dvaceti vodiči. Naproti tomu Intel 8088 má
pouze osmibitovou externí datovou sběrnici (zlevnění celého systému na úkor
rychlosti), ovšem adresová sběrnice má pořád dvacet vodičů.</p>

<p>To ovšem v&nbsp;důsledku znamená, že fyzická adresa nepřesáhne rozsah
jednoho megabajtu, ale &bdquo;přeteče&ldquo; do nultého segmentu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rozsah adresovatelné paměti mikroprocesoru 80286</h2>

<p>Mikroprocesor Intel 80286, který představuje druhou generaci čipů
z&nbsp;rodiny 80x86, má oproti mikroprocesorům Intel 8086/8088 odlišně
koncipované piny, což je dobře patrné z&nbsp;následujícího obrázku:</p>

<a href="https://www.root.cz/obrazek/1159806/"><img src="https://i.iinfo.cz/images/202/80286-pins-3-prev.webp" class="image-1159806" width="274" height="270" data-prev-filename="https://i.iinfo.cz/images/202/80286-pins-3-prev.webp" data-prev-width="274" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/202/80286-pins-3-large.webp" data-large-width="532" data-large-height="525" alt="&#160;" title="Autor: Intel, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 3: Piny mikroprocesoru Intel 80286.</i></p>

<p>Vidíme zde dva důležité rozdíly. Prvním rozdílem je oddělení datové sběrnice
(která je mimochodem stále šestnáctibitová) od sběrnice adresové. To znamená,
že jsou vyvedeny samostatné vodiče <strong>D0</strong> až <strong>D15</strong>
pro obousměrné přenosy dat a není zapotřebí řešit multiplexing dat a adres. Pro
nás je ovšem dnes důležitější fakt, že adresových vodičů je nyní více;
konkrétně se jedná o piny <strong>A0</strong> až <strong>A23</strong>. To tedy
znamená, že lze adresovat 2<sup>24</sup> bajtů, protože lze opět pracovat
s&nbsp;jednotlivými bajty a nikoli jen s&nbsp;celými šestnáctibitovými slovy.
Fyzický paměťový rozsah mikroprocesorů Intel 80286 je tedy 16MB &ndash; o mnoho
více, než tomu bylo v&nbsp;případě původní první generace čipů z&nbsp;rodiny
80x86.</p>

<p>Aby bylo možné využít celý paměťový rozsah, podporují mikroprocesory 80286
takzvaný <i>chráněný režim</i>, v&nbsp;němž lze navíc (jak již jeho název
napovídá) na HW úrovni zajistit například to, že se nepřekročí nastavená
velikost zásobníku, že se nebude (například virem) modifikovat programový kód
atd. Ke konceptu chráněného režimu se ještě vrátíme. Jednalo se o důležitou
technologii, která však v&nbsp;případě 80286 nebyla plně využívána (a to hned
&nbsp;několika důvodů).</p>

<p>Co se však stane na počítači vybaveném mikroprocesorem 80286
(s&nbsp;adresovým rozsahem 2<sup>24</sup> bajtů) v&nbsp;případě, že výpočet
přesáhne přes hranici jednoho megabajtu? To je totiž docela dobře možné, což
naznačuje i další tabulka:</p>

<table>
<tr><th>Segment (16b)</th><th>Offset (16b)</th><th>Fyzická adresa (24b)</th><th>Poznámka</th></tr>
<tr><td>ffff</td><td>0000</td><td>ffff0</td><td>jsme stále v&nbsp;rozsahu 1MB</td></tr>
<tr><td>ffff</td><td>000f</td><td>fffff</td><td>jsme stále v&nbsp;rozsahu 1MB</td></tr>
<tr><td>f000</td><td>ffff</td><td>fffff</td><td>jsme stále v&nbsp;rozsahu 1MB</td></tr>
<tr><td>ffff</td><td>0010</td><td>100000</td><td>první adresa, která se již nevejde do rozsahu 1MB</td></tr>
<tr><td>f001</td><td>ffff</td><td>100000</td><td>odlišná reprezentace stejné adresy</td></tr>
<tr><td>ffff</td><td>ffff</td><td>10ffef</td><td>přesáhli jsme rozsah 1MB &ndash; nejvyšší možná adresa</td></tr>
</table>

<p>Z&nbsp;této tabulky je patrné, že fyzická adresa skutečně může přesáhnout
rozsah 1MB, což na původních čipech 8086/8088 nebylo možné, už jen z&nbsp;toho
důvodu, že neexistovat adresový vodič A20 (tedy dvacátý první vodič, protože je
indexujeme od nuly).</p>

<p>O kolik bajtů (či adres) přesáhneme onu mýtickou hranici jednoho megabajtu
si můžeme snadno vypočítat:</p>

<pre>
0xffff0 + 0xffff - 0xfffff = 65520 bajtů/adres
</pre>

<p>K&nbsp;dispozici tedy máme prakticky celých 64kB navíc (kromě šestnácti
bajtů na konci). Dnes se to sice může zdát jako zanedbatelná hodnota, ale právě
kvůli oněm šedesáti čtyřem kilobajtů se komplikoval návrh PC i BIOSu až do cca
roku 2009.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Může offset přesáhnout hranici jednoho segmentu?</h2>

<p>Víme již, že výpočet adresy probíhá na základě kombinace <i>segmentu</i> a
<i>offsetu</i>. Jak segment, tak i offset jsou šestnáctibitové hodnoty, které
se kombinují způsobem naznačeným výše:</p>

<pre>
adresa = segment &times; 16 + offset
</pre>

<p>Jenže to není přesná (resp.&nbsp;ucelená) informace. Je nutno dodat, jakým
způsobem byl vypočítán <i>offset</i>. Mikroprocesory řady Intel 8086/8088 totiž
podporovaly tyto adresovací režimy:</p>

<table>
<tr><th>Použitý zápis v&nbsp;assembleru</th><th>Adresovací režim</th></tr>
<tr><td>přímá adresa (16bit) </td><td>displacement/direct</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX]</td><td>register indirect</td></tr>
<tr><td>[SI]</td><td>register indirect</td></tr>
<tr><td>[DI]</td><td>register indirect</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX+SI]</td><td>based indexed mode</td></tr>
<tr><td>[BX+DI]</td><td>based indexed mode</td></tr>
<tr><td>[BP+SI]</td><td>based indexed mode</td></tr>
<tr><td>[BP+DI]</td><td>based indexed mode</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BP+offset_8_bit]</td><td>based mode</td></tr>
<tr><td>[BX+offset_8_bit]</td><td>based mode</td></tr>
<tr><td>[SI+offset_8_bit]</td><td>indexed mode</td></tr>
<tr><td>[DI+offset_8_bit]</td><td>indexed mode</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BP+offset_16_bit]</td><td>based mode</td></tr>
<tr><td>[BX+offset_16_bit]</td><td>based mode</td></tr>
<tr><td>[SI+offset_16_bit]</td><td>indexed mode</td></tr>
<tr><td>[DI+offset_16_bit]</td><td>indexed mode</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX+SI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BX+DI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+SI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+DI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX+SI+offset_16_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BX+DI+offset_16_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+SI+offset_16_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+DI+offset_16_bit]</td><td>based indexed displacement</td></tr>
</table>

<p>Co to znamená v&nbsp;praxi? Řekněme, že v&nbsp;segmentovém registru
<strong>DS</strong> (<i>data segment</i>) bude uložena nula a v&nbsp;registru
<strong>BX</strong> bude uložena hodnota 0x8000. Následně použijeme
instrukci:</p>

<pre>
mov DS:[BX+0x8001], AL
</pre>

<p>Otázka zní, do jaké fyzické buňky RAM se uloží obsah registru
<strong>AL</strong>? Máme přitom k&nbsp;dispozici dvě varianty výpočtu.
Triviální dosazení do vzorce pro výpočet adresy by vedlo k&nbsp;výpočtu:</p>

<pre>
0x0000 &times; 16 + 0x8000 + 0x8000 = 0x10000
</pre>

<p>Ovšem můžeme si také uvědomit, že sčítačka pro offsety je realizována
v&nbsp;šestnáctibitové aritmeticko-logické jednotce a ve skutečnosti tedy
proběhne spíše něco takového:</p>

<pre>
0x0000 &times; 16 + (0x8000 + 0x8000) &amp; 0xffff = 0x00000
</pre>

<p>Ve skutečnosti je správný druhý výpočet, protože <i>offset</i> je na čipech
Intel 8086/8088 vždy šestnáctibitový. To znamená, že veškeré výpočty offsetu
uvedené v&nbsp;předchozí tabulce za všech předpokladů vedou k&nbsp;hodnotám
v&nbsp;rozsahu 0x0000 až 0xffff a nikdy tedy nepřekročíme velikost
segmentu.</p>

<p><div class="rs-tip-major">Poznámka: tato vlastnost sice přímo vychází
s&nbsp;interní realizace výpočtů adresy na čipech 8086/8088, ovšem později
musela být emulována &ndash; přesněji řečeno emulována v&nbsp;reálném
režimu.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Paměťové modely překladačů jazyka C v&nbsp;reálném režimu</h2>

<p></p>

<table>
<tr><th colspan="2" rowspan="2">Model</th><th colspan="2">Ukazatel na data</th></tr>
<tr><th>krátký</th><th>dlouhý</th></tr>
<tr><th rowspan="2">Ukazatel na<br />kód</th><th>krátký</th><td>Small</td><td>Compact</td></tr>
<tr><th>dlouhý</th><td>Medium</td><td>Large</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Praktická část: paměťové modely překladače Borland C++ 3.0</h2>

<p>Překladač programovacího jazyka C a C++ nazvaný Borland C++ 3.0 podporuje v&nbsp;operačním systému DOS celkem šest různých paměťových modelů. Tyto modely jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Paměťový model</th><th>Ukazatele</th><th>Stručný popis modelu</th></tr>
<tr><td>1</td><td>Tiny</td><td>krátké</td><td>64kB pro program i data, všechny čtyři segmentové registry jsou totožné</td></tr>
<tr><td>2</td><td>Small</td><td>krátké</td><td>64kB programový kód, 64kB pro data</td></tr>
<tr><td>3</td><td>Medium</td><td>dlouhé pro program, krátké pro data</td><td>1MB programový kód, 64kB pro data</td></tr>
<tr><td>4</td><td>Compact</td><td>krátké pro program, dlouhé pro data</td><td>64kB programový kód, 1MB pro data</td></tr>
<tr><td>5</td><td>Large</td><td>dlouhé</td><td>1MB programový kód, 1MB pro data</td></tr>
<tr><td>6</td><td>Huge</td><td>dlouhé</td><td>1MB pro programový kód, 1MB pro data</td></tr>
</table>

<p>Paměťový model <strong>Huge</strong> jako jediný neomezuje délku paměťových struktur na 64kB. Týká se to většinou polí, které tuto délku mohou překročit.</p>

<p><div class="rs-tip-major">Poznámka: </div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Velikosti ukazatelů, základní aritmetika s&nbsp;ukazateli</h2>

<p></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Funkce vracející větší z&nbsp;hodnot předaných přes ukazatel</h2>

<p>Vliv různých paměťových modelů je nejvíce patrný u funkcí, které jako svůj
argument (nebo argumenty) akceptují ukazatel a popřípadě taktéž ukazatel vrací.
Proto si pro prozkoumání vlastností jednotlivých modelů naprogramujeme funkci
pro nalezení větší hodnoty z&nbsp;dvojice, přičemž tato dvojice hodnot je
předána nepřímo &ndash; přes ukazatele. A i návratovou hodnotou nebude přímo
větší prvek, ale pouze ukazatel na něj. V&nbsp;jazyku C by implementace takové
funkce mohla vypadat následovně:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned int uint;
&nbsp;
uint* <strong>larger_value</strong>(uint *x, uint *y) {
    if (*x &gt; *y) {
        return x;
    } else {
        return y;
    }
}
</pre>

<p>Otestujeme základní funkcionalitu:</p>

<pre>
int <strong>main</strong>(void) {
    uint a = 1;
    uint b = 2;
&nbsp;
    printf("%d\n", *larger_value(&amp;a, &amp;b));
    printf("%d\n", *larger_value(&amp;b, &amp;a));
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;praxi by bylo vhodné připsat
podmínku pro test NULLových hodnot ukazatelů. Nyní by nám to ovšem komplikovalo
výslednou sekvenci instrukcí.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Překlad pro paměťové modely s&nbsp;krátkými ukazateli pro data</h2>

<pre>
   <i>;    </i>
   <i>;    uint* larger_value(uint *x, uint *y) {</i>
   <i>;    </i>
        assume  cs:_TEXT
_larger_value   proc    near
        push    bp
        mov     bp,sp
        push    si
        push    di
        mov     si,word ptr [bp+4]
        mov     di,word ptr [bp+6]
   <i>;    </i>
   <i>;        if (*x &gt; *y) {</i>
   <i>;    </i>
        mov     ax,word ptr [si]
        cmp     ax,word ptr [di]
        jbe     short @1@86
   <i>;    </i>
   <i>;            return x;</i>
   <i>;    </i>
        mov     ax,si
        pop     di
        pop     si
        pop     bp
        ret     
@1@86:
   <i>;    </i>
   <i>;        } else {</i>
   <i>;            return y;</i>
   <i>;    </i>
        mov     ax,di
   <i>;    </i>
   <i>;        }</i>
   <i>;    }</i>
   <i>;    </i>
        pop     di
        pop     si
        pop     bp
        ret     
_larger_value   endp
</pre>

<pre>
   <i>;    </i>
   <i>;    uint* larger_value(uint *x, uint *y) {</i>
   <i>;    </i>
        assume  cs:_TEXT
_larger_value   proc    near
        push    bp
        mov     bp,sp
        push    si
        push    di
        mov     si,word ptr [bp+4]
        mov     di,word ptr [bp+6]
   <i>;    </i>
   <i>;        if (*x &gt; *y) {</i>
   <i>;    </i>
        mov     ax,word ptr [si]
        cmp     ax,word ptr [di]
        jbe     short @1@86
   <i>;    </i>
   <i>;            return x;</i>
   <i>;    </i>
        mov     ax,si
        pop     di
        pop     si
        pop     bp
        ret     
@1@86:
   <i>;    </i>
   <i>;        } else {</i>
   <i>;            return y;</i>
   <i>;    </i>
        mov     ax,di
   <i>;    </i>
   <i>;        }</i>
   <i>;    }</i>
   <i>;    </i>
        pop     di
        pop     si
        pop     bp
        ret     
_larger_value   endp
</pre>

<pre>
   <i>;    </i>
   <i>;    uint* larger_value(uint *x, uint *y) {</i>
   <i>;    </i>
        assume  cs:LARGER_TEXT
_larger_value   proc    far
        push    bp
        mov     bp,sp
        push    si
        push    di
        mov     si,word ptr [bp+6]
        mov     di,word ptr [bp+8]
   <i>;    </i>
   <i>;        if (*x &gt; *y) {</i>
   <i>;    </i>
        mov     ax,word ptr [si]
        cmp     ax,word ptr [di]
        jbe     short @1@86
   <i>;    </i>
   <i>;            return x;</i>
   <i>;    </i>
        mov     ax,si
        pop     di
        pop     si
        pop     bp
        ret     
@1@86:
   <i>;    </i>
   <i>;        } else {</i>
   <i>;            return y;</i>
   <i>;    </i>
        mov     ax,di
   <i>;    </i>
   <i>;        }</i>
   <i>;    }</i>
   <i>;    </i>
        pop     di
        pop     si
        pop     bp
        ret     
_larger_value   endp
</pre>

<p></p>

<pre>
; TINY                                ; SMALL                              ; MEDIUM
_larger_value   proc    near          _larger_value   proc    near         _larger_value   proc    far
        push    bp                            push    bp                           push    bp
        mov     bp,sp                         mov     bp,sp                        mov     bp,sp
        push    si                            push    si                           push    si
        push    di                            push    di                           push    di
        mov     si,word ptr [bp+4]            mov     si,word ptr [bp+4]           mov     si,word ptr [bp+6]
        mov     di,word ptr [bp+6]            mov     di,word ptr [bp+6]           mov     di,word ptr [bp+8]
        mov     ax,word ptr [si]              mov     ax,word ptr [si]             mov     ax,word ptr [si]
        cmp     ax,word ptr [di]              cmp     ax,word ptr [di]             cmp     ax,word ptr [di]
        jbe     short @1@86                   jbe     short @1@86                  jbe     short @1@86
        mov     ax,si                         mov     ax,si                        mov     ax,si
        pop     di                            pop     di                           pop     di
        pop     si                            pop     si                           pop     si
        pop     bp                            pop     bp                           pop     bp
        ret                                   ret                                  ret     
@1@86:                                @1@86:                               @1@86:
        mov     ax,di                         mov     ax,di                        mov     ax,di
        pop     di                            pop     di                           pop     di
        pop     si                            pop     si                           pop     si
        pop     bp                            pop     bp                           pop     bp
        ret                                   ret                                  ret     
_larger_value   endp                  _larger_value   endp                 _larger_value   endp
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Překlad pro paměťové modely s&nbsp;dlouhými ukazateli pro data</h2>

<pre>
   <i>;    </i>
   <i>;    uint* larger_value(uint *x, uint *y) {</i>
   <i>;    </i>
        assume  cs:_TEXT
_larger_value   proc    near
        push    bp
        mov     bp,sp
   <i>;    </i>
   <i>;        if (*x &gt; *y) {</i>
   <i>;    </i>
        les     bx,dword ptr [bp+4]
        mov     ax,word ptr es:[bx]
        les     bx,dword ptr [bp+8]
        cmp     ax,word ptr es:[bx]
        jbe     short @1@86
   <i>;    </i>
   <i>;            return x;</i>
   <i>;    </i>
        mov     dx,word ptr [bp+6]
        mov     ax,word ptr [bp+4]
        pop     bp
        ret     
@1@86:
   <i>;    </i>
   <i>;        } else {</i>
   <i>;            return y;</i>
   <i>;    </i>
        mov     dx,word ptr [bp+10]
        mov     ax,word ptr [bp+8]
   <i>;    </i>
   <i>;        }</i>
   <i>;    }</i>
   <i>;    </i>
        pop     bp
        ret     
_larger_value   endp
</pre>

<pre>
   <i>;    </i>
   <i>;    uint* larger_value(uint *x, uint *y) {</i>
   <i>;    </i>
        assume  cs:LARGER_TEXT
_larger_value   proc    far
        push    bp
        mov     bp,sp
   <i>;    </i>
   <i>;        if (*x &gt; *y) {</i>
   <i>;    </i>
        les     bx,dword ptr [bp+6]
        mov     ax,word ptr es:[bx]
        les     bx,dword ptr [bp+10]
        cmp     ax,word ptr es:[bx]
        jbe     short @1@86
   <i>;    </i>
   <i>;            return x;</i>
   <i>;    </i>
        mov     dx,word ptr [bp+8]
        mov     ax,word ptr [bp+6]
        pop     bp
        ret     
@1@86:
   <i>;    </i>
   <i>;        } else {</i>
   <i>;            return y;</i>
   <i>;    </i>
        mov     dx,word ptr [bp+12]
        mov     ax,word ptr [bp+10]
   <i>;    </i>
   <i>;        }</i>
   <i>;    }</i>
   <i>;    </i>
        pop     bp
        ret     
_larger_value   endp
</pre>

<pre>
   <i>;    </i>
   <i>;    uint* larger_value(uint *x, uint *y) {</i>
   <i>;    </i>
        assume  cs:LARGER_TEXT
_larger_value   proc    far
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,LARGER_DATA
        mov     ds,ax
   <i>;    </i>
   <i>;        if (*x &gt; *y) {</i>
   <i>;    </i>
        les     bx,dword ptr [bp+6]
        mov     ax,word ptr es:[bx]
        les     bx,dword ptr [bp+10]
        cmp     ax,word ptr es:[bx]
        jbe     short @1@86
   <i>;    </i>
   <i>;            return x;</i>
   <i>;    </i>
        mov     dx,word ptr [bp+8]
        mov     ax,word ptr [bp+6]
        pop     ds
        pop     bp
        ret     
@1@86:
   <i>;    </i>
   <i>;        } else {</i>
   <i>;            return y;</i>
   <i>;    </i>
        mov     dx,word ptr [bp+12]
        mov     ax,word ptr [bp+10]
   <i>;    </i>
   <i>;        }</i>
   <i>;    }</i>
   <i>;    </i>
        pop     ds
        pop     bp
        ret     
_larger_value   endp
</pre>

<pre>
; COMPACT                              ; LARGE                                 ; HUGE
_larger_value   proc    near           _larger_value   proc    far             _larger_value   proc    far
        push    bp                             push    bp                              push    bp
        mov     bp,sp                          mov     bp,sp                           mov     bp,sp
                                                                                       push    ds
                                                                                       mov     ax,LARGER_DATA
                                                                                       mov     ds,ax
        les     bx,dword ptr [bp+4]            les     bx,dword ptr [bp+6]             les     bx,dword ptr [bp+6]
        mov     ax,word ptr es:[bx]            mov     ax,word ptr es:[bx]             mov     ax,word ptr es:[bx]
        les     bx,dword ptr [bp+8]            les     bx,dword ptr [bp+10]            les     bx,dword ptr [bp+10]
        cmp     ax,word ptr es:[bx]            cmp     ax,word ptr es:[bx]             cmp     ax,word ptr es:[bx]
        jbe     short @1@86                    jbe     short @1@86                     jbe     short @1@86
        mov     dx,word ptr [bp+6]             mov     dx,word ptr [bp+8]              mov     dx,word ptr [bp+8]
        mov     ax,word ptr [bp+4]             mov     ax,word ptr [bp+6]              mov     ax,word ptr [bp+6]
                                                                                       pop     ds
        pop     bp                             pop     bp                              pop     bp
        ret                                    ret                                     ret     
@1@86:                                 @1@86:                                  @1@86:
        mov     dx,word ptr [bp+10]            mov     dx,word ptr [bp+12]             mov     dx,word ptr [bp+12]
        mov     ax,word ptr [bp+8]             mov     ax,word ptr [bp+10]             mov     ax,word ptr [bp+10]
                                                                                       pop     ds
        pop     bp                             pop     bp                              pop     bp
        ret                                    ret                                     ret     
_larger_value   endp                   _larger_value   endp                    _larger_value   endp
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Alokace a přístup k&nbsp;prvkům pole přesahujícího velikost jednoho segmentu</h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyce C, které jsou primárně určené
pro překlad s&nbsp;využitím překladačů <i>Turbo C</i> a <i>(Open)Watcom C)</i>,
byly uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<p>Borland C:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add.c</a></td></tr>
<tr><td> 2</td><td>add1.asm</td><td>překlad přes assembler, externí symboly začínají pomlčkou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add1.asm</a></td></tr>
<tr><td> 3</td><td>add2.asm</td><td>překlad přes assembler, externí symboly nejsou přejmenovány</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add2.asm</a></td></tr>
<tr><td> 4</td><td>add3.asm</td><td>výsledek překladu se zákazem optimalizací (externí symboly s&nbsp;pomlčkou)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add3.asm</a></td></tr>
<tr><td> 5</td><td>add4.asm</td><td>výsledek překladu se zákazem optimalizací (externí symboly nejsou přejmenovány)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add4.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add4.asm</a></td></tr>
<tr><td> 6</td><td>add5.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add5.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add5.asm</a></td></tr>
<tr><td> 7</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset.c</a></td></tr>
<tr><td> 8</td><td>memset_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_1.asm</a></td></tr>
<tr><td> 9</td><td>memset_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_2.asm</a></td></tr>
<tr><td>10</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max.c</a></td></tr>
<tr><td>11</td><td>find_max_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_1.asm</a></td></tr>
<tr><td>12</td><td>find_max_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_2.asm</a></td></tr>
<tr><td>13</td><td>find_max_3.asm</td><td>výsledek překladu s&nbsp;povolením instrukcí procesorů 80286</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>fill_a.c</td><td>funkce pro vyplnění pole konstantou naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/fill_a.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/fill_a.c</a></td></tr>
<tr><td>15</td><td>fill_a_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/fill_a_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/fill_a_1.asm</a></td></tr>
<tr><td>16</td><td>fill_a_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/fill_a_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/fill_a_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>add_f.c</td><td>funkce pro součet dvou čísel s&nbsp;plovoucí řádovou čárkou naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f.c</a></td></tr>
<tr><td>18</td><td>add_f_1.asm</td><td>překlad přes assembler</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f_1.asm</a></td></tr>
<tr><td>19</td><td>add_f_2.asm</td><td>překlad přes assembler s&nbsp;eliminací skoků a dalšími optimalizacemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
<tr><td>21</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
<tr><td>22</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
<tr><td>23</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
<tr><td>24</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
<tr><td>25</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
<tr><td>26</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
<tr><td>27</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
<tr><td>28</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
<tr><td>29</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/</a></td></tr>
</table>

pointers_n.c
pointers_f.c
pointers_h.c

find_max_ptr.c
larger.c
larger_c.asm
larger_h.asm
larger_l.asm
larger_m.asm
larger_s.asm
larger_t.asm


<p>(Open)Watcom pro platformu IBM PC:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add.c</a></td></tr>
<tr><td> 2</td><td>add1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add1.asm</a></td></tr>
<tr><td> 3</td><td>add2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add2.asm</a></td></tr>
<tr><td> 4</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset.c</a></td></tr>
<tr><td> 5</td><td>memset1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset1.asm</a></td></tr>
<tr><td> 6</td><td>memset2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset2.asm</a></td></tr>
<tr><td> 7</td><td>memset3.asm</td><td>výsledek překladu do 32bitového kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset3.asm</a></td></tr>
<tr><td> 8</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max.c</a></td></tr>
<tr><td> 9</td><td>find_max_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_1.asm</a></td></tr>
<tr><td>10</td><td>find_max_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_2.asm</a></td></tr>
<tr><td>11</td><td>find_max_3.asm</td><td>výsledek překladu do 32bitového kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>fill_a.c</td><td>funkce pro vyplnění pole konstantou naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a.c</a></td></tr>
<tr><td>13</td><td>fill_a_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a_1.asm</a></td></tr>
<tr><td>14</td><td>fill_a_2.asm</td><td>výsledek překladu s&nbsp;povolením některých optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a_2.asm</a></td></tr>
<tr><td>15</td><td>fill_a_3.asm</td><td>výsledek překladu s&nbsp;povolením všech optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a_3.asm</a></td></tr>
<tr><td>16</td><td>fill_a_4.asm</td><td>výsledek překladu do 32bitového kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a_4.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/fill_a_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>add_f.c</td><td>funkce pro součet dvou čísel s&nbsp;plovoucí řádovou čárkou naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f.c</a></td></tr>
<tr><td>18</td><td>add_f_1.asm</td><td>překlad přes assembler</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_1.asm</a></td></tr>
<tr><td>19</td><td>add_f_2.asm</td><td>překlad přes assembler s&nbsp;optimalizacemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_2.asm</a></td></tr>
<tr><td>20</td><td>add_f_3.asm</td><td>překlad přes assembler s&nbsp;využitím FP knihovny</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_3.asm</a></td></tr>
</table>



<p>GCC pro platformu x86-64:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.c</a></td></tr>
<tr><td> 2</td><td>add.asm</td><td>výsledek překladu do assembleru s&nbsp;použitím optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.asm</a></td></tr>
<tr><td> 3</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset.c</a></td></tr>
<tr><td> 4</td><td>memset_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_1.asm</a></td></tr>
<tr><td> 5</td><td>memset_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_2.asm</a></td></tr>
<tr><td> 6</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max.c</a></td></tr>
<tr><td> 7</td><td>find_max_default.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_default.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_default.asm</a></td></tr>
<tr><td> 8</td><td>find_max_smallest.asm</td><td>výsledek překladu s&nbsp;optimalizací na velikost kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_smallest.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_smallest.asm</a></td></tr>
<tr><td> 9</td><td>find_max_vector.asm</td><td>výsledek překladu s&nbsp;optimalizací na rychlost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_vector.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_vector.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>fill_a.c</td><td>funkce pro vyplnění pole konstantou naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a.c</a></td></tr>
<tr><td>11</td><td>fill_a_default.s</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a_default.s">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a_default.s</a></td></tr>
<tr><td>12</td><td>fill_a_O2.s</td><td>výsledek překladu s&nbsp;přepínačem <strong>-O2</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a_O2.s">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a_O2.s</a></td></tr>
<tr><td>13</td><td>fill_a_O9.s</td><td>výsledek překladu s&nbsp;přepínačem <strong>-O9</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a_O9.s">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a_O9.s</a></td></tr>
<tr><td>14</td><td>fill_a_smallest.s</td><td>výsledek překladu při snaze o vytvoření nejkratšího kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a_smallest.s">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/fill_a_smallest.s</a></td></tr>
</table>



<p>DGJPP pro platformu IBM PC + DOS:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add.c</a></td></tr>
<tr><td> 2</td><td>add_1.asm</td><td>výsledek překladu do assembleru se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_1.asm</a></td></tr>
<tr><td> 3</td><td>add_2.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením optimalizací na rychlost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_2.asm</a></td></tr>
<tr><td> 4</td><td>add_3.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením optimalizací na velikost kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_3.asm</a></td></tr>
<tr><td> 5</td><td>add_4.asm</td><td>explicitní specifikace, že se nemusí vytvářet standardní zásobníkové rámce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_4.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset.c</a></td></tr>
<tr><td> 7</td><td>memset_1.asm</td><td>výsledek překladu do assembleru se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_1.asm</a></td></tr>
<tr><td> 8</td><td>memset_2.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením optimalizací na rychlost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_2.asm</a></td></tr>
<tr><td> 9</td><td>memset_3.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením optimalizací na velikost kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/find_max.c</a></td></tr>
<tr><td>11</td><td>findmax1.asm</td><td>překlad bez povolení optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax1.asm</a></td></tr>
<tr><td>12</td><td>findmax2.asm</td><td>překlad s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax2.asm</a></td></tr>
<tr><td>13</td><td>findmax3.asm</td><td>překlad s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>fill_a.c</td><td>funkce pro vyplnění pole konstantou naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a.c</a></td></tr>
<tr><td>15</td><td>fill_a_1.asm</td><td>překlad bez povolení optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_1.asm</a></td></tr>
<tr><td>16</td><td>fill_a_2.asm</td><td>překlad s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_2.asm</a></td></tr>
<tr><td>17</td><td>fill_a_3.asm</td><td>optimalizace na velikost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_3.asm</a></td></tr>
<tr><td>18</td><td>fill_a_4.asm</td><td>nejkratší možný kód</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_4.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>add_f.c</td><td>funkce pro součet dvou čísel s&nbsp;plovoucí řádovou čárkou naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_f.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_f.c</a></td></tr>
<tr><td>20</td><td>add_f_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_f_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_f_1.asm</a></td></tr>
<tr><td>21</td><td>add_f_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_f_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_f_2.asm</a></td></tr>
<tr><td>22</td><td>add_f_3.asm</td><td>výsledek překladu s&nbsp;povolením volání FPU knihovny</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_f_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_f_3.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>DJGPP (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/DJGPP">https://cs.wikipedia.org/wiki/DJGPP</a>
</li>

<li>DJGPP home page<br />
<a href="http://www.delorie.com/djgpp/">http://www.delorie.com/djgpp/</a>
</li>

<li>DJGPP Zip File Picker<br />
<a href="http://www.delorie.com/djgpp/zip-picker.html">http://www.delorie.com/djgpp/zip-picker.html</a>
</li>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Warnings Are Your Friend - A Code Quality Primer<br />
<a href="https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/">https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/</a>
</li>

<li>Defending Against Compiler-Based Backdoors<br />
<a href="https://blog.regehr.org/archives/1241">https://blog.regehr.org/archives/1241</a>
</li>

<li>Reflections on Trusting Trust<br />
<a href="https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html">https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html</a>
</li>

<li>Coding Machines (povídka)<br />
<a href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>
</li>

<li>Stage0<br />
<a href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>
</li>

<li>Projekt stage0 na GitHubu<br />
<a href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>
</li>

<li>Bootstraping wiki<br />
<a href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>
</li>

<li>Bootstrapped 6502 Assembler<br />
<a href="https://github.com/robinluckey/bootstrap-6502">https://github.com/robinluckey/bootstrap-6502</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>What is a coder's worst nightmare?<br />
<a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute</a>
</li>

<li>Tiny C Compiler<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Welcome to C--<br />
<a href="https://www.cs.tufts.edu/~nr/c--/index.html">https://www.cs.tufts.edu/~nr/c--/index.html</a>
</li>

<li>c4 - C in four functions<br />
<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>Lattice C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Lattice_C">https://en.wikipedia.org/wiki/Lattice_C</a>
</li>

<li>Aztec C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Aztec_C">https://en.wikipedia.org/wiki/Aztec_C</a>
</li>

<li>Digital Mars (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Digital_Mars">https://en.wikipedia.org/wiki/Digital_Mars</a>
</li>

<li>Stránky projektu Open Watcom<br />
<a href="https://openwatcom.org/">https://openwatcom.org/</a>
</li>

<li>Repositář Open Watcom<br />
<a href="https://github.com/open-watcom/open-watcom-v2">https://github.com/open-watcom/open-watcom-v2</a>
</li>

<li>Watcom C/C++ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B">https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B</a>
</li>

<li>Turbo C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_C">https://en.wikipedia.org/wiki/Turbo_C</a>
</li>

<li>Borland C++ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Borland_C%2B%2B">https://en.wikipedia.org/wiki/Borland_C%2B%2B</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

