<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Překladače programovacího jazyka C pro historické osmibitové mikroprocesory</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Překladače programovacího jazyka C pro historické osmibitové mikroprocesory</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>O programovacím jazyku C se někdy s nadsázkou říká, že je to &bdquo;přenositelný assembler&ldquo;. Programy psané v C skutečně mohou být velmi efektivní, ovšem do značné míry záleží na kvalitě céčkového překladače. Dnes si ve stručnosti řekneme, jak je tomu v případě osmibitového CPU MOS 6502.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Překladače programovacího jazyka C pro historické osmibitové mikroprocesory</a></p>
<p><a href="#k02">2. Překladače a cross překladače pro mikroprocesory MOS 6502</a></p>
<p><a href="#k03">3. cc65</a></p>
<p><a href="#k04">4. vbcc</a></p>
<p><a href="#k05">5. 6502-gcc</a></p>
<p><a href="#k06">6. Instalace <strong>ca65</strong> a <strong>cc65</strong></a></p>
<p><a href="#k07">7. Překlad funkce bez parametrů a bez návratových hodnot</a></p>
<p><a href="#k08">8. Překlad do assembleru s&nbsp;odkazy na původní zdrojový kód</a></p>
<p><a href="#k09">9. Statické lokální proměnné</a></p>
<p><a href="#k10">10. Zapnutí optimalizací společně s&nbsp;využitím statických lokálních proměnných, proměnných v&nbsp;registrech atd.</a></p>
<p><a href="#k11">11. Funkce pro vyplnění bloku paměti specifikovanou hodnotou</a></p>
<p><a href="#k12">*** 12. Assembler vygenerovaný pro základní verzi funkce <strong>memset</strong></a></p>
<p><a href="#k13">13. Lokální proměnná (počitadlo smyčky) s&nbsp;modifikátorem <strong>register</strong></a></p>
<p><a href="#k14">*** 14. Assembler vygenerovaný pro upravenou verzi funkce <strong>memset</strong></a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Obsah navazujícího článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Překladače programovacího jazyka C pro historické osmibitové mikroprocesory</h2>

<p>O programovacím jazyku C se někdy s&nbsp;nadsázkou říká, že je to
&bdquo;přenositelný assembler&ldquo; [<a
href="https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler">1</a>].
Programy napsané v&nbsp;jazyce C skutečně mohou být velmi efektivní, ovšem do
značné míry záleží na kvalitě céčkového překladače. Dnes si ve stručnosti
řekneme, jak je tomu v&nbsp;případě slavného osmibitového mikroprocesoru MOS
6502, jehož instrukční kód jsme si do jisté míry přiblížili <a
href="https://www.root.cz/serialy/vyvoj-her-pro-herni-konzoli-nes/">v&nbsp;seriálu
o vývoji her a grafických dem pro herní konzoli NES</a>.</p>

*** image ***
<p><i>Obrázek 1: Přebal druhého vydání slavné knihy &bdquo;The C Programming
Language&ldquo; (Kerningan, Ritchie)</i></p>

<p>Překladače jazyka C existují pro prakticky každou počítačovou platformu i
pro prakticky každý typ mikroprocesoru. Výjimkou není ani MOS 6502, ovšem na
tomto místě je nutné poznamenat, že právě u podobných typů mikroprocesorů, jako
je MOS 6502, stojí tvůrci překladačů před nelehkým úkolem, protože
programátorský model MOS 6502 se v&nbsp;mnoha ohledech odlišuje od
&bdquo;ideálního céčkového mikroprocesoru&ldquo; A jak by vlastně měl takový
ideální procesor vypadat? Měl by mít velký počet pracovních registrů, obsahovat
instrukce pro snadnou manipulaci s&nbsp;obsahem zásobníku, pracovní registry by
mohly být použity při adresování, měl by podporovat adresování s&nbsp;offsetem
(násobeným &times;1, &times;2, &times;4 apod.) a ideálně by se při adresování
mohla provádět inkrementace či dekrementace offsetu, opět o hodnotu 1, 2, 4
apod. Navíc by paměť měla být viditelná jako lineární prostor s&nbsp;buňkami
s&nbsp;postupně rostoucími adresami(&bdquo;flat model&ldquo;). Tomuto ideálu se
kdysi přiblížil čip Motorola 68000 a dále RISCové procesory, z&nbsp;nichž mnohé
byly navrženy právě s&nbsp;ohledem na <i>sémantické</i> možnosti jazyka C.</p>

<img src="http://i.iinfo.cz/images/365/gamesc3.jpg" class="image-161781" width="450" height="259" alt="&#160;" />
<p><i>Obrázek 2: Logo překladačů Aztec C.</i></p>

<p>Z&nbsp;programátorského hlediska se mikroprocesor MOS 6502 dosti podstatným
způsobem odlišuje jak od konkurenčního Intelu 8080 (i od později vydaného
Zilogu Z80), tak i od čipu RCA-1802. Zatímco procesor Intel 8080 obsahoval
poměrně rozsáhlou sadu obecně použitelných osmibitových registrů (A, B, C, D,
E, H a L), které se u některých instrukcí kombinovaly do 16bitových
registrových párů, měl 6502 pouze jeden osmibitový akumulátor (registr A) a dva
taktéž osmibitové index-registry pojmenované X a Y. Oba zmíněné typy procesorů
samozřejmě obsahovaly další speciální registry, jako ukazatel na vrchol
zásobníku (SP), programový čítač (PC) a příznakový registr (F).</p>

<p>Na první pohled by se mohlo zdát, že počet registrů mikroprocesoru MOS 6502
je zcela nedostatečný pro provádění většiny aritmetických či logických operací.
Ve skutečnosti tomu tak není, protože tento procesor podporuje načtení druhého
operandu z&nbsp;operační paměti (rychlost RAM nebyla tak limitujícím faktorem,
jako je tomu dnes &ndash; ve skutečnosti byl přístup do RAM dvojnásobně rychlý
v&nbsp;porovnání s&nbsp;mikroprocesorem). U mnoha instrukcí je podporován větší
počet adresovacích režimů, celkově je možné operandy strojových instrukcí
adresovat třinácti navzájem odlišnými způsoby. Při adresování se často
používají oba index-registry, které je možné inkrementovat a dekrementovat
&ndash; tím je umožněno provádění blokových přenosů dat, mazání souvislé
oblasti paměti atd.</p>

<p><div class="rs-tip-major">Poznámka: tyto zvláštnosti MOS 6502 dosti
podstatným způsobem ovlivňují i backend céčkovského překladače.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Překladače a cross překladače pro mikroprocesory MOS 6502</h2>

<p>Některé překladače programovacího jazyka C pro MOS 6502 byly navrženy přímo
pro běh na strojích osazených tímto čipem. To je dnes zcela normální situace
(aplikace pro PC se překládají na PC), ovšem v&nbsp;případě MOS 6502 se museli
tvůrci překladačů vypořádat s&nbsp;pomalým čipem, velmi malou kapacitou paměti
a navíc i relativně pomalým externím paměťovým médiem (typicky disketa, protože
kazetové verze C by byly ještě problematičtější). V&nbsp;důsledku těchto
omezení se jednalo spíše o projekty určené pro amatérské použití, zatímco
profesionální software stále vznikal v&nbsp;assembleru. Jednou z&nbsp;prvních
implementací překladače C pro MOS 6502 je C/65 od slavné firmy <a
href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/#k02">Optimized
Systems Software (OSS)</a>.</p>

*** image ***
<p><i>Obrázek 3: C/65 od společnosti Optimized Systems Software (OSS).</i></p>

<p>Taktéž se na tomto místě musíme zmínit o známém překladači <i>Aztec C</i>,
jenž byl portovaný na velké množství různých typů mikropočítačů, zapomenout
nesmíme ani na <i>Deep Blue C</i> (viz též <a
href="https://en.wikipedia.org/wiki/Deep_Blue_C">https://en.wikipedia.org/wiki/Deep_Blue_C</a>)
pro osmibitové počítače Atari. Zde se autoři museli vyrovnat s&nbsp;faktem, že
znaková sada neobsahovala složené závorky, takže zápis vypadal například
takto:</p>

<pre>
main()
$(
    printf("Hello World!");
$)
</pre>

<p><div class="rs-tip-major">Poznámka: což připomíná <a
href="https://riptutorial.com/c/example/23858/trigraphs">trigraphy
C</a>.</div></p>

*** image ***
<p><i>Obrázek 4: Dobová reklama na nástroje společnosti OSS.</i></p>

<p>Zajímavější jsou z&nbsp;dnešního pohledu cross compilery a cross assemblery
(viz poznámka o českém překladu tohoto názvu). Tyto typy nástrojů jsou velmi
často používané i dnes, zejména v&nbsp;oblasti mikrořadičů, digitálních
signálových procesorů nebo mobilních telefonů (viz například <a
href="http://scratchbox.org/">Scratchbox</a>). Ovšem tato technologie se
používala již na začátku osmibitové éry. Například vývoj her pro herní konzoli
Atari 2600 (Atari Video Computer System neboli Atari VCS) byl prováděn na
minipočítači. Ovšem i později některé firmy vyvíjely profesionální software pro
Atari, C64 i další osmibitové mikropočítače na výkonnějších strojích, kde se
prováděl i překlad.</p>

<p><div class="rs-tip-major">Poznámka: existuje i český termín <i>křížový
překladač</i>, ale musím se přiznat, že mi připadá jako výsledek otrockého
překladu a navíc se slovo &bdquo;cross&ldquo; přeložilo ve špatném
kontextu.</div></p>

<img src="http://i.iinfo.cz/images/15/gamesc4.jpg" class="image-161782" width="450" height="265" alt="&#160;" />
<p><i>Obrázek 5: Jeden z&nbsp;konkurenčních překladačů k&nbsp;Aztec C byl
Lattice C (ovšem až v&nbsp;pozdější době).</i></p>

<p>Dobrým a možná i typickým příkladem jsou právě cross překladače
programovacího jazyka C. Tvorbou těchto cross překladačů se zabývala například
společnost <i>Manx Software Systems</i>, jejíž překladače céčka (Aztec C)
určené pro <a
href="https://www.root.cz/clanky/ctyricet-let-existence-oslavovane-i-nenavidene-platformy-pc/">IBM
PC</a> s&nbsp;DOSem i pro osobní mikropočítače Macintosh dokázaly provádět
cross překlad na osmibitové mikropočítače Commodore C64 a Apple II. Na chvíli
se u Aztec C zastavme, i když přímo nesouvisí s&nbsp;osmibitovými Atari.</p>

<p><i>Aztec C</i> totiž byl ve své době velmi úspěšný překladač, jenž existoval
jak ve verzi pro osmibitové mikroprocesory (MOS 6502, Zilog Z-80), tak i pro
mikroprocesory 16bitové a 32bitové. Tento překladač byl velmi úspěšný právě na
Amize, kde byl používán, společně s&nbsp;<i>Lattice C</i>, prakticky až do
faktického zániku této platformy. Ovšem na IBM PC jeho sláva netrvala dlouho,
především z&nbsp;toho důvodu, že firma Microsoft považovala segment překladačů
za poměrně důležitý a snažila se vytlačit jakoukoli konkurenci z&nbsp;trhu (i
když ve skutečnosti v&nbsp;té době ještě neměla vlastní céčkový překladač).
Společnosti <i>Manx Software Systems</i> se postupně zmenšoval počet platforem,
na něž bylo možné překladač prodávat a přechod na podporu vestavěných systémů
již přišel dosti pozdě. A právě pro cross překlad se Aztec C může používat
dodnes (běží v&nbsp;DOSu, takže dnes vlastně taktéž v&nbsp;emulovaném
prostředí).</p>

<p><div class="rs-tip-major">Poznámka: další informace o překladačích i cross
překladačích Aztec C lze najít na stránce <a
href="http://aztecmuseum.ca/compilers.htm">http://aztecmuseum.ca/compilers.htm</a>.</div></p>

<p>Podobným stylem byl řešen i Microsoft C původně vytvořený společností, která
stála za slavným Lattice C. Ostatně Lattice C byl s&nbsp;velkou
pravděpodobností vůbec prvním překladačem céčka pro IBM PC (pochází z&nbsp;roku
1982). Ten byl později převeden i na Amigu, dále se rozšířil i na minipočítače
a mainframy společnosti IBM. Firma Microsoft překladač <i>Lattice C</i>
nabízela pod svým názvem <i>MSC (Microsoft C)</i> a teprve verze <i>MSC 4.0</i>
byla skutečně vytvořena přímo programátory z&nbsp;Microsoftu. <i>Lattice C</i>
byl používán i při portaci aplikací z&nbsp;operačního systému <i>CP/M</i> na
DOS (dnes je však možné pouze odhadnout, kolik kódu bylo skutečně napsáno
v&nbsp;céčku a kolik kódu vzniklo transformací assembleru).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. cc65</h2>

<p>Prvním cross překladačem, s&nbsp;nímž se v&nbsp;dnešním článku seznámíme (a
současně i překladačem nejznámějším), je překladač programovacího jazyka C,
který se jmenuje <i>cc65</i>. Ve skutečnosti se však nejedná pouze o čistý
překladač céčka, ale o sadu dalších vývojářských nástrojů, mezi něž patří i <a
href="#k10">výše zmíněný</a> cross assembler <i>ca65</i>, dále linker
<i>ld65</i>, disassembler <i>da65</i>, simulátor procesorů 6502 <i>sim65</i>
atd. Tento překladač je možné použít nejenom pro tvorbu aplikací pro osmibitové
mikropočítače Atari, ale i pro osmibitové stroje firmy Commodore (VIC20, C64,
C128 atd.), osmibitové mikropočítače řady Apple II, herní konzoli NES, konzoli
TurboGrafx-16 atd.</p>

<p>Jazyk akceptovaný překladačem <i>cc65</i> do určité míry odpovídá ISO
standardu jazyka C (a tím pádem i původnímu ANSI standardu, dokonce je
podporováno několik vlastností z&nbsp;C99); standard je vnucen přepínačem
<strong>--standard</strong>.  Existuje však několik dosti podstatných rozdílů a
nedostatků <i>cc65</i>, mezi něž patří neexistence datových typů <i>float</i> a
<i>double</i> (a tím pádem i celá část céčka, která předepisuje konverze
s&nbsp;těmito typy atd.). Dále existuje omezení při definicích funkcí &ndash;
funkce nemohou vracet struktury ani unie; struktury dokonce není možné předávat
hodnotou (což ale většinou nevadí, právě naopak). Kromě toho je sice možné
použít modifikátor <strong>volatile</strong>, ovšem ten nemá žádný podstatný
význam (což je v&nbsp;případě mikroprocesorů MOS 6502 a jejich možností
pochopitelné). Naproti tomu má či může mít velký vliv modifikátor
<strong>register</strong>, který naopak mnoho moderních překladačů již
nepotřebuje či dokonce zcela ignoruje.</p>

<p>Naopak mezi rozšíření <i>cc65</i> oproti standardu jazyka C (jak ANSI, tak i
ISO normy) patří podpora bloků psaných v&nbsp;assembleru, podpora
pseudoproměnných <strong>A</strong> a <strong>AX</strong> (což je primární
registr mikroprocesoru, tedy akumulátor, v&nbsp;případě <strong>AX</strong>
rozšířený na šestnáct bitů přes registr <strong>X</strong>). Podporovány jsou
konstanty zapsané ve dvojkové soustavě (0b101) a použít lze i počítaná
<strong>goto</strong> (což je částečně převzato z&nbsp;GCC).</p>

<p><div class="rs-tip-major">Poznámka: současně <i>cc65</i> negeneruje
optimální kód, což si ostatně ukážeme v&nbsp;navazujících kapitolách.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. vbcc</h2>

<p>Dalším transpřekladačem programovacího jazyka C určeného mj.&nbsp;i pro
překlad zdrojových kódů do strojového kódu osmibitových mikroprocesorů MOS
6502, je překladač nazvaný <i>vbcc</i> &ndash; <i>portable ISO C compiler</i>.
Tento překladač, jehož stránky lze nalézt na adrese <a
href="http://www.compilers.de/vbcc.html">http://www.compilers.de/vbcc.html</a>,
podporuje generování kódu pro různé architektury mikroprocesorů a mikrořadičů,
od mikroprocesorů osmibitových přes šestnáctibitové čipy až po moderní
mikroprocesory 32bitové a 64bitové. <i>vbcc</i> taktéž umožňuje provádět různé
optimalizace, a to ve většině případů <a
href="https://sgadrat.itch.io/super-tilt-bro/devlog/219534/benchmark-c-compilers-for-the-6502-cpu">mnohem
kvalitněji</a>, než výše zmíněný <i>cc65</i> (jenž je však známější a
používanější). Tímto zajímavým překladačem se budeme dále zabývat
v&nbsp;samostatném článku.</p>

<p>Podporované mikroprocesory, včetně na nich postavených počítačů:</p>

<table>
<tr><th>Čip</th><th>Počítače/konzole/systém</th></tr>
<tr><td>Motorola 6800/6801/6803/6808/68hc11</td><td>(jen vasm, bare systémy)</td></tr>
<tr><td>Motorola 6809/6309/68hc12</td><td>OS-9/NitrOS-9 (tbc), Vectrex (tbc)</td></tr>
<tr><td>Motorola 68000</td><td>AmigaOS, Atari TOS, MINT, Atari Jaguar, Linux</td></tr>
<tr><td>Coldfire</td><td>MINT, Arnewsh 5206</td></tr>
<tr><td>PowerPC</td><td>AmigaOS, PowerUp, WarpOS, MorphOS, Linux, NetBSD, OpenFirmware</td></tr>
<tr><td><strong>6502/65C02</strong></td><td>C64, C128, PET, Atari 8bit, BBC Micro/Master, NES, MEGA65, Commander X16</td></tr>
<tr><td>i386</td><td>PC, Linux, NetBSD, DOS</td></tr>
<tr><td>VideoCore IV (RasperryPi GPU)</td><td>Linux, RPi</td></tr>
<tr><td>C16X/ST10</td><td>MM167</td></tr>
<tr><td>DEC Alpha</td><td>Linux</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. 6502-gcc</h2>

<p>Třetím transpřekladačem jazyka C do strojového kódu mikroprocesorů MOS 6502,
o kterém se v&nbsp;dnešním článku alespoň ve stručnosti zmíníme, je překladač
nazvaný <i>6502-gcc</i>. Název tohoto překladače naznačuje, že je založen na
známém projektu <i>GCC (GNU Compiler Collection)</i>, do kterého byl přidán
nový back-end. Díky standardnímu front-endu GCC je zajištěna prakticky
stoprocentní kompatibilita s&nbsp;programovacím jazykem C (na rozdíl od
některých nekompatibilních rysů <i>cc65</i>, o nichž jsme se ostatně již krátce
zmínili). Nevýhodou je, že je tento projekt prakticky neudržovaný a taktéž je
méně známý (takže existuje jen velmi malá podpora od ostatních vývojářů).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace <strong>ca65</strong> a <strong>cc65</strong></h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalším textu se budeme téměř
výhradně zabývat překladačem <i>cc65</i>, což je nejznámější, avšak nikoli
nejkvalitnější překladač céčka pro osmibitové mikroprocesory MOS
6502.</div></p>

<p>Instalace assembleru <strong>ca65</strong> i céčkového překladače
<strong>cc65</strong> je na většině distribucí Linuxu velmi snadná, neboť se
jedná o balíčky (typicky) umístěné přímo v&nbsp;repositářích dané distribuce.
Dobrým příkladem může být Linux Mint, v&nbsp;níž instalace vypadá
následovně:</p>

<pre>
$ <strong>sudo apt-get install cc65</strong>
&nbsp;
Reading package lists... Done
Building dependency tree
Reading state information... Done
Suggested packages:
  cc65-doc
The following NEW packages will be installed:
  cc65
0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.
Need to get 2 162 kB of archives.
After this operation, 31,8 MB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu focal/universe amd64 cc65 amd64 2.18-1 [2 162 kB]
Fetched 2 162 kB in 5s (423 kB/s)
Selecting previously unselected package cc65.
(Reading database ... 291820 files and directories currently installed.)
Preparing to unpack .../archives/cc65_2.18-1_amd64.deb ...
Unpacking cc65 (2.18-1) ...
Setting up cc65 (2.18-1) ...
</pre>

<p>Po dokončení instalace budou k&nbsp;dispozici tři nové nástroje (a několik
podpůrných nástrojů).</p>

<p>V&nbsp;první řadě se jedná o assembler:</p>

<pre>
$ <strong>cc65 --version</strong>
cc65 V2.18 - Ubuntu 2.18-1
</pre>

<p>Dále o překladač céčka:</p>

<pre>
$ <strong>ca65 --version</strong>
ca65 V2.18 - Ubuntu 2.18-1
</pre>

<p>A využijeme i samostatný linker:</p>

<pre>
$ <strong>ld65 --version</strong>
ld65 V2.18 - Ubuntu 2.18-1
</pre>

<p><div class="rs-tip-major">Poznámka: nainstalován je ale například i
disassembler a dokonce i simulátor mikroprocesoru MOS 6502 atd.</div></p>

<p>Instalace céčkového překladače <i>cc65</i> na Fedoře 36 je taktéž velmi
snadná:</p>

<pre>
# <strong>dnf install cc65</strong>
&nbsp;
Last metadata expiration check: 0:21:57 ago on Sat 10 Sep 2022 04:10:12 AM EDT.
Dependencies resolved.
================================================================================
 Package           Architecture  Version             Repository            Size
================================================================================
Installing:
 cc65              x86_64        2.19-3.fc36         beaker-Fedora        421 k
Installing dependencies:
 cc65-devel        noarch        2.19-3.fc36         beaker-Fedora        1.8 M
Installing weak dependencies:
 cc65-doc          noarch        2.19-3.fc36         beaker-Fedora        623 k
 cc65-utils        x86_64        2.19-3.fc36         beaker-Fedora         29 k
&nbsp;
Transaction Summary
================================================================================
Install  4 Packages
&nbsp;
Total download size: 2.8 M
Installed size: 33 M
Is this ok [y/N]:
</pre>

<p>Kontrola nainstalované verze:</p>

<pre>
$ <strong>cc65 --version</strong>
&nbsp;
cc65 V2.18 - Fedora 2.19-3.fc36
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad funkce bez parametrů a bez návratových hodnot</h2>

<p>Struktura kódu generovaného překladačem <i>ca65</i> do značné míry závisí na
tom, jaké přepínače jsou při překladu použity. Ukážeme si to na příkladu
jednoduché funkce, která je bez parametrů a taktéž nemá žádné návratové
hodnoty. Ve funkci se pouze používá trojice lokálních proměnných a tři
přiřazovací příkazy (takže teoreticky lze funkci přeložit do jediné instrukce
<strong>jsr</strong> &ndash; návrat z&nbsp;podprogramu, či ji zcela
odstranit):</p>

<pre>
void <strong>main</strong>(void)
{
    register unsigned char a;
    register unsigned char b;
    register unsigned char c;
    a = 10;
    b = 20;
    c = a + b;
}
</pre>

<p><div class="rs-tip-major">Poznámka: tento zdrojový kód je uložen na adrese
<a
href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c</a>.</div></p>

<p>Vyzkoušíme si překlad pouze zadáním příkazu:</p>

<pre>
$ <strong>cc65 local_add.c</strong>
</pre>

<p>Výsledkem nebude objektový kód, jak je to běžné na platformě PC (i jinde),
ale <a
href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add_1.asm">kód
v&nbsp;assembleru</a> určený pro další zpracování assemblerem
<strong>ca65</strong>. Tento kód vypadá následovně:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
        jsr     decsp3
        ldx     #$00
        lda     #$0A
        ldy     #$02
        sta     (sp),y
        ldx     #$00
        lda     #$14
        ldy     #$01
        sta     (sp),y
        ldy     #$02
        ldx     #$00
        lda     (sp),y
        jsr     pushax
        ldy     #$03
        ldx     #$00
        lda     (sp),y
        jsr     tosaddax
        ldx     #$00
        ldy     #$00
        sta     (sp),y
        jsr     incsp3
        rts
&nbsp;
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: I při letmém pohledu je zřejmé, že se
v&nbsp;žádném případě nejedná o příliš optimalizovaný kód. V&nbsp;dalších
kapitolách si proto ukážeme vliv přepínačů překladače na strukturu
vygenerovaného kódu.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Překlad do assembleru s&nbsp;odkazy na původní zdrojový kód</h2>

<p>Zejména při zkoumání delšího přeloženého kódu může být výhodné, pokud jsou
v&nbsp;assembleru uvedeny odkazy na původní céčkový zdrojový kód. V&nbsp;praxi
to vypadá tak, že je nejdříve v&nbsp;poznámce zapsán (typicky) jeden programový
řádek v&nbsp;céčku, za nímž následuje sekvence instrukcí, do kterých je tento
řádek přeložen.</p>

<p><div class="rs-tip-major">Poznámka: teoreticky ne vždy je možné tuto
jednoznačnou vazbu zajistit, zejména při aplikaci složitých optimalizací, kdy
dochází k&nbsp;promíchávání různých částí kódu. Takových optimalizací však
stejně <i>cc65</i> není schopen.</p></div></p>

<p>Odkazy na původní zdrojový kód jsou do assembleru přidány po použití
přepínače <strong>-T</strong>:</p>

<pre>
$ <strong>cc65 -T local_add.c</strong>
</pre>

<p>Nyní bude výsledek <a
href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add_2.asm">vypadat
takto</a>:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        jsr     decsp3
        ldx     #$00
        lda     #$0A
        ldy     #$02
        sta     (sp),y
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        ldx     #$00
        lda     #$14
        ldy     #$01
        sta     (sp),y
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        ldy     #$02
        ldx     #$00
        lda     (sp),y
        jsr     pushax
        ldy     #$03
        ldx     #$00
        lda     (sp),y
        jsr     tosaddax
        ldx     #$00
        ldy     #$00
        sta     (sp),y
<i>;</i>
<i>; }</i>
<i>;</i>
        jsr     incsp3
        rts
&nbsp;
.endproc
</pre>

<p>Nyní již máme určitou představu o způsobu překladu. Zejména je patrné, jak
jsou lokální proměnné uloženy na zásobníku. Pro adresování se používá adresa
uložená na adrese <strong>sp</strong> (to není registr, ale skutečně adresa
operační paměti). Jako offset k&nbsp;tomuto uměle vytvořenému zásobníku slouží
registr <strong>y</strong>.</p>

<p>Uložení hodnoty 10 do zásobníku:</p>

<pre>
        lda     #$0A         <i>; ukládaná konstanta</i>
        ldy     #$02         <i>; offset od vrcholu zásobníku</i>
        sta     (sp),y       <i>; vlastní uložení hodnoty</i>
</pre>

<p>Součet je proveden nepřímo &ndash; zavoláním subrutin (viz zvýrazněný
kód):</p>

<pre>
        ldy     #$02         <i>; načtení hodnoty proměnné a do akumulátoru</i>
        lda     (sp),y
        jsr     pushax       <i>; volaná subrutina</i>
        ldy     #$03
        lda     (sp),y       <i>; načtení hodnoty proměnné b do akumulátoru</i>
        jsr     tosaddax     <i>; volaná subrutina</i>
        ldy     #$00
        sta     (sp),y       <i>; uložení výsledku na zásobník</i>
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Statické lokální proměnné</h2>

<p>Prakticky všechny moderní mikroprocesorové architektury ukládají parametry
funkcí i lokální proměnné do zásobníkových rámců (<i>stack frame</i>). Pokud se
o podobný přístup pokusíme na architektuře MOS 6502, je nutné zásobníkový rámec
simulovat přes adresu (uloženou v&nbsp;operační paměti), která simuluje registr
SP, jenž na MOS 6502 neexistuje (zásobník zde má jen 256 adres a navíc není
umožněno relativní adresování přes offset &ndash; což je možná největší
nedostatek MOS 6502).</p>

<p>Alternativně je možné používat statické lokální proměnné, což jsou vlastně
globální proměnné, které jsou ovšem z&nbsp;pohledu programátora dostupné pouze
v&nbsp;jedné funkci. Generovaný kód by měl být nepatrně menší i rychlejší.
Přepínačem <strong>-Cl</strong> lze použití statických lokálních proměnných
vynutit, a to i tehdy, pokud není použito klíčové slovo
<strong>static</strong>:</p>

<pre>
$ <strong>cc65 -T -Cl local_add.c</strong>
</pre>

<p>Nyní bude výsledný <a
href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add_3.asm">vygenerovaný
assembler</a> opět odlišný:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        ldx     #$00
        lda     #$0A
        sta     L0002
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        ldx     #$00
        lda     #$14
        sta     L0003
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        ldx     #$00
        lda     L0002
        jsr     pushax
        ldx     #$00
        lda     L0003
        jsr     tosaddax
        ldx     #$00
        sta     L0004
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Nyní jsou lokální proměnné uloženy v&nbsp;paměti rezervované v&nbsp;segmentu
BSS (není součástí objektového kódu). Příkladem je uložení hodnoty 10 do
lokální (statické) proměnné <strong>a</strong>:</p>

<pre>
        ldx     #$00
        lda     #$0A
        sta     L0002
</pre>

<p><div class="rs-tip-major">Poznámka: neustálé ukládání nuly do index registru
X je zcela zbytečné, což ostatně platí i pro předchozí příklad.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zapnutí optimalizací společně s&nbsp;využitím statických lokálních proměnných, proměnných v&nbsp;registrech atd.</h2>

<p>V&nbsp;předchozích dvou kapitolách jsme mohli vidět, že generovaný kód není
v&nbsp;žádném případě dokonalý. Překladač <i>cc65</i> nabízí přepínač -O pro
zapnutí základních optimalizací (ovšem nečekejme žádné zázraky, nejedná se o
clang/LLVM ani o gcc):</p>

<pre>
$ <strong>cc65 -T -Cl -O local_add.c</strong>
</pre>

<p>Opět se podívejme na vygenerovaný kód v&nbsp;assembleru:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        lda     #$0A
        sta     L0002
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        lda     #$14
        sta     L0003
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        lda     L0002
        clc
        adc     L0003
        sta     L0004
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Stále se používají statické proměnné (což je v&nbsp;pořádku), ovšem navíc se
odstranilo neustálé nulování index registru X a namísto volání podprogramů pro
součet je nyní vlastní výpočet zcela přímočarý:</p>

<pre>
<i>; c = a + b;</i>
<i>;</i>
        lda     L0002
        clc
        adc     L0003
        sta     L0004
</pre>

<p>Přepínačem -Or navíc můžeme vynutit další optimalizaci &ndash; uložení
hodnot na adresy umístěné v&nbsp;nulté stránce paměti (<i>zero page</i>), což
umožňuje použití kratších a rychlejších instrukcí:</p>

<pre>
$ <strong>cc65 -T -Cl -Or local_add.c</strong>
</pre>

<p>Výsledek překladu:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned char a;</i>
<i>;</i>
        lda     regbank+5
        jsr     pusha
<i>;</i>
<i>; register unsigned char b;</i>
<i>;</i>
        lda     regbank+4
        jsr     pusha
<i>;</i>
<i>; register unsigned char c;</i>
<i>;</i>
        lda     regbank+3
        jsr     pusha
<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        lda     #$0A
        sta     regbank+5
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        lda     #$14
        sta     regbank+4
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        lda     regbank+5
        clc
        adc     regbank+4
        sta     regbank+3
<i>;</i>
<i>; }</i>
<i>;</i>
        ldy     #$00
L0008:  lda     (sp),y
        sta     regbank+3,y
        iny
        cpy     #$03
        bne     L0008
        jmp     incsp3
&nbsp;
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;takto reprezentovaného kódu to
není zřejmé, ovšem <strong>regbank</strong> je adresa do nulté stránky paměti,
takže instrukce <strong>lda</strong>, <strong>sta</strong> atd. mohou být
optimalizovány do kratší a rychlejší verze (ušetří se vždy jeden bajt a jeden
strojový cyklus).</div></p>

<p>Další optimalizace lze zapnout přepínačem -Oi, který vynutí inlining kódu
(mnohé funkce se tedy nebudou volat, ale jejich kód se přímo vloží na místo
jejich volání):</p>

<pre>
$ <strong>cc65 -T -Cl -Oi local_add.c</strong>
</pre>

<p>Výsledek bude vypadat podobně, jako v&nbsp;předminulém příkladu:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        lda     #$0A
        sta     L0002
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        lda     #$14
        sta     L0003
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        lda     L0002
        clc
        adc     L0003
        sta     L0004
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Nakonec povolíme všechny optimalizace, což ostatně dělá většina autorů:</p>

<pre>
$ <strong>cc65 -T -Cl -Osir local_add.c</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned char a;</i>
<i>;</i>
        lda     regbank+5
        jsr     pusha
<i>;</i>
<i>; register unsigned char b;</i>
<i>;</i>
        lda     regbank+4
        jsr     pusha
<i>;</i>
<i>; register unsigned char c;</i>
<i>;</i>
        lda     regbank+3
        jsr     pusha
<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        lda     #$0A
        sta     regbank+5
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        lda     #$14
        sta     regbank+4
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        lda     regbank+5
        clc
        adc     regbank+4
        sta     regbank+3
<i>;</i>
<i>; }</i>
<i>;</i>
        ldy     #$00
        lda     (sp),y
        sta     regbank+3
        iny
        lda     (sp),y
        sta     regbank+4
        iny
        lda     (sp),y
        sta     regbank+5
        jmp     incsp3
&nbsp;
.endproc
</pre>

<p>V&nbsp;tomto případě je výsledek již poměrně dobrý: používají se proměnné
uložené do nulté stránky paměti a i samotný součet je triviální:</p>

<pre>
<i>; c = a + b;</i>
<i>;</i>
        lda     regbank+5
        clc
        adc     regbank+4
        sta     regbank+3
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Funkce pro vyplnění bloku paměti specifikovanou hodnotou</h2>

<p>V&nbsp;navazujících kapitolách se budeme zabývat způsobem překladu funkce
<strong>memset</strong>, která má vyplnit zadaný blok paměti specifikovanou
hodnotou (omezíme se však na blok o velikosti maximálně 256 bajtů). Obecný
zápis, který nebere do úvahy specifika překladače ani mikroprocesoru, může
vypadat takto:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
void <strong>memset8</strong>(uint8_t * dest, uint8_t c, uint8_t n)
{
    int i;
&nbsp;
    for (i = 0; i &lt; n; i++) {
        dest[i] = c;
    }
}
&nbsp;
int <strong>main</strong>(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód této funkce naleznete na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Assembler vygenerovaný pro základní verzi funkce <strong>memset</strong></h2>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _memset8
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ memset8 (__near__ unsigned char *, unsigned char, unsigned char)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _memset8: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    2,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; {</i>
<i>;</i>
        jsr     pusha
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        lda     #$00
        sta     L0002
        sta     L0002+1
L0003:  lda     L0002
        ldy     #$00
        cmp     (sp),y
        lda     L0002+1
        sbc     #$00
        bcs     L0004
<i>;</i>
<i>; dest[i] = c;</i>
<i>;</i>
        ldy     #$03
        jsr     ldaxysp
        clc
        adc     L0002
        sta     ptr1
        txa
        adc     L0002+1
        sta     ptr1+1
        ldy     #$01
        lda     (sp),y
        dey
        sta     (ptr1),y
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        lda     L0002
        ldx     L0002+1
        jsr     incax1
        sta     L0002
        stx     L0002+1
        jmp     L0003
<i>;</i>
<i>; }</i>
<i>;</i>
L0004:  jmp     incsp4
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; int __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L000F:
        .res    2,$00
L0011:
        .res    1,$00
L0013:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; uint8_t *dest = (uint8_t *) 0x0600;</i>
<i>;</i>
        ldx     #$06
        lda     #$00
        sta     L000F
        stx     L000F+1
<i>;</i>
<i>; uint8_t bytes = 0xff;</i>
<i>;</i>
        lda     #$FF
        sta     L0011
<i>;</i>
<i>; uint8_t fill = 0x00;</i>
<i>;</i>
        lda     #$00
        sta     L0013
<i>;</i>
<i>; memset8(dest, fill, bytes);</i>
<i>;</i>
        lda     L000F
        ldx     L000F+1
        jsr     pushax
        lda     L0013
        jsr     pusha
        lda     L0011
        jsr     _memset8
<i>;</i>
<i>; return 0;</i>
<i>;</i>
        ldx     #$00
        txa
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Lokální proměnná (počitadlo smyčky) s&nbsp;modifikátorem <strong>register</strong></h2>

<p>Mnoha překladačům programovacího jazyka C lze při optimalizacích do větší či
menší míry &bdquo;pomoci&ldquo; použitím modifikátoru
<strong>register</strong>, kterým se označí ty proměnné, které by &ndash;
alespoň podle názoru programátora &ndash; mohly být umístěny přímo do
pracovního registru. V&nbsp;našem konkrétním příkladu máme jen jedinou takovou
proměnnou, a to počitadlo smyčky <strong>i</strong>:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
void <strong>memset8</strong>(uint8_t * dest, uint8_t c, uint8_t n)
{
    <u>register uint8_t i;</u>
&nbsp;
    for (i = 0; i &lt; n; i++) {
        dest[i] = c;
    }
}
&nbsp;
int <strong>main</strong>(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód této funkce naleznete na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c</a>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Assembler vygenerovaný pro upravenou verzi funkce <strong>memset</strong></h2>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _memset8
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ memset8 (__near__ unsigned char *, unsigned char, unsigned char)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _memset8: near

.segment        "BSS"

L0002:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; {</i>
<i>;</i>
        jsr     pusha
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        lda     #$00
        sta     L0002
L001B:  lda     L0002
        ldy     #$00
        cmp     (sp),y
        bcs     L0004
<i>;</i>
<i>; dest[i] = c;</i>
<i>;</i>
        ldy     #$03
        jsr     ldaxysp
        clc
        adc     L0002
        bcc     L001A
        inx
L001A:  sta     ptr1
        stx     ptr1+1
        ldy     #$01
        lda     (sp),y
        dey
        sta     (ptr1),y
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        inc     L0002
        jmp     L001B
<i>;</i>
<i>; }</i>
<i>;</i>
L0004:  jmp     incsp4

.endproc

<i>; ---------------------------------------------------------------</i>
<i>; int __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L000F:
        .res    2,$00
L0011:
        .res    1,$00
L0013:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; uint8_t *dest = (uint8_t *) 0x0600;</i>
<i>;</i>
        ldx     #$06
        lda     #$00
        sta     L000F
        stx     L000F+1
<i>;</i>
<i>; uint8_t bytes = 0xff;</i>
<i>;</i>
        lda     #$FF
        sta     L0011
<i>;</i>
<i>; uint8_t fill = 0x00;</i>
<i>;</i>
        lda     #$00
        sta     L0013
<i>;</i>
<i>; memset8(dest, fill, bytes);</i>
<i>;</i>
        lda     L000F
        ldx     L000F+1
        jsr     pushax
        lda     L0013
        jsr     pusha
        lda     L0011
        jsr     _memset8
<i>;</i>
<i>; return 0;</i>
<i>;</i>
        ldx     #$00
        txa
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc

</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
#include &lt;stdint.h&gt;

void memset8(uint8_t * dest, const uint8_t c, const uint8_t n)
{
    register uint8_t i;

    for (i = 0; i &lt; n; i++) {
        dest[i] = c;
    }
}

int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);

    return 0;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _memset8
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ memset8 (__near__ unsigned char *, const unsigned char, const unsigned char)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _memset8: near

.segment        "BSS"

L0002:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; {</i>
<i>;</i>
        jsr     pusha
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        lda     #$00
        sta     L0002
L001B:  lda     L0002
        ldy     #$00
        cmp     (sp),y
        bcs     L0004
<i>;</i>
<i>; dest[i] = c;</i>
<i>;</i>
        ldy     #$03
        jsr     ldaxysp
        clc
        adc     L0002
        bcc     L001A
        inx
L001A:  sta     ptr1
        stx     ptr1+1
        ldy     #$01
        lda     (sp),y
        dey
        sta     (ptr1),y
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        inc     L0002
        jmp     L001B
<i>;</i>
<i>; }</i>
<i>;</i>
L0004:  jmp     incsp4

.endproc

<i>; ---------------------------------------------------------------</i>
<i>; int __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L000F:
        .res    2,$00
L0011:
        .res    1,$00
L0013:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; uint8_t *dest = (uint8_t *) 0x0600;</i>
<i>;</i>
        ldx     #$06
        lda     #$00
        sta     L000F
        stx     L000F+1
<i>;</i>
<i>; uint8_t bytes = 0xff;</i>
<i>;</i>
        lda     #$FF
        sta     L0011
<i>;</i>
<i>; uint8_t fill = 0x00;</i>
<i>;</i>
        lda     #$00
        sta     L0013
<i>;</i>
<i>; memset8(dest, fill, bytes);</i>
<i>;</i>
        lda     L000F
        ldx     L000F+1
        jsr     pushax
        lda     L0013
        jsr     pusha
        lda     L0011
        jsr     _memset8
<i>;</i>
<i>; return 0;</i>
<i>;</i>
        ldx     #$00
        txa
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<pre>
#include &lt;stdint.h&gt;

void memset8(uint8_t * dest, const uint8_t c, uint8_t n)
{
    while (n &gt; 0) {
        *dest++ = c;
        n--;
    }
}

int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);

    return 0;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _memset8
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ memset8 (__near__ unsigned char *, const unsigned char, unsigned char)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _memset8: near

.segment        "CODE"

<i>;</i>
<i>; {</i>
<i>;</i>
        jsr     pusha
<i>;</i>
<i>; while (n &gt; 0) {</i>
<i>;</i>
        jmp     L0004
<i>;</i>
<i>; *dest++ = c;</i>
<i>;</i>
L0002:  ldy     #$03
        jsr     ldaxysp
        sta     regsave
        stx     regsave+1
        jsr     incax1
        ldy     #$02
        jsr     staxysp
        ldy     #$01
        lda     (sp),y
        dey
        sta     (regsave),y
<i>;</i>
<i>; n--;</i>
<i>;</i>
        lda     (sp),y
        sec
        sbc     #$01
        sta     (sp),y
<i>;</i>
<i>; while (n &gt; 0) {</i>
<i>;</i>
L0004:  ldy     #$00
        lda     (sp),y
        bne     L0002
<i>;</i>
<i>; }</i>
<i>;</i>
        jmp     incsp4

.endproc

<i>; ---------------------------------------------------------------</i>
<i>; int __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L000A:
        .res    2,$00
L000C:
        .res    1,$00
L000E:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; uint8_t *dest = (uint8_t *) 0x0600;</i>
<i>;</i>
        ldx     #$06
        lda     #$00
        sta     L000A
        stx     L000A+1
<i>;</i>
<i>; uint8_t bytes = 0xff;</i>
<i>;</i>
        lda     #$FF
        sta     L000C
<i>;</i>
<i>; uint8_t fill = 0x00;</i>
<i>;</i>
        lda     #$00
        sta     L000E
<i>;</i>
<i>; memset8(dest, fill, bytes);</i>
<i>;</i>
        lda     L000A
        ldx     L000A+1
        jsr     pushax
        lda     L000E
        jsr     pusha
        lda     L000C
        jsr     _memset8
<i>;</i>
<i>; return 0;</i>
<i>;</i>
        ldx     #$00
        txa
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<pre>
#include &lt;stdint.h&gt;

void memset8(uint8_t * dest, const uint8_t c, uint8_t n)
{
    /* pozor na hodnotu n=0! */
    do {
        *dest++ = c;
        n--;
    } while (n &gt; 0);
}

int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);

    return 0;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _memset8
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ memset8 (__near__ unsigned char *, const unsigned char, unsigned char)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _memset8: near

.segment        "CODE"

<i>;</i>
<i>; {</i>
<i>;</i>
        jsr     pusha
<i>;</i>
<i>; *dest++ = c;</i>
<i>;</i>
L0002:  ldy     #$03
        jsr     ldaxysp
        sta     regsave
        stx     regsave+1
        jsr     incax1
        ldy     #$02
        jsr     staxysp
        ldy     #$01
        lda     (sp),y
        dey
        sta     (regsave),y
<i>;</i>
<i>; n--;</i>
<i>;</i>
        lda     (sp),y
        sec
        sbc     #$01
        sta     (sp),y
<i>;</i>
<i>; } while (n &gt; 0);</i>
<i>;</i>
        lda     (sp),y
        bne     L0002
<i>;</i>
<i>; }</i>
<i>;</i>
        jmp     incsp4

.endproc

<i>; ---------------------------------------------------------------</i>
<i>; int __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L000A:
        .res    2,$00
L000C:
        .res    1,$00
L000E:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; uint8_t *dest = (uint8_t *) 0x0600;</i>
<i>;</i>
        ldx     #$06
        lda     #$00
        sta     L000A
        stx     L000A+1
<i>;</i>
<i>; uint8_t bytes = 0xff;</i>
<i>;</i>
        lda     #$FF
        sta     L000C
<i>;</i>
<i>; uint8_t fill = 0x00;</i>
<i>;</i>
        lda     #$00
        sta     L000E
<i>;</i>
<i>; memset8(dest, fill, bytes);</i>
<i>;</i>
        lda     L000A
        ldx     L000A+1
        jsr     pushax
        lda     L000E
        jsr     pusha
        lda     L000C
        jsr     _memset8
<i>;</i>
<i>; return 0;</i>
<i>;</i>
        ldx     #$00
        txa
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujícího článku</h2>

<p>V&nbsp;dnešním článku jsme si popsali pouze základní vlastnosti překladače
<i>cc65</i>. Ve druhé a současně i závěrečné části článku si řekneme, jakým
způsobem můžeme využít některé jeho speciální vlastnosti, například možnost
mixovat kód psaný v&nbsp;jazyku C s&nbsp;assemblerem (na úrovni zdrojového
kódu) nebo použití pseudoproměnných <strong>A</strong>, <strong>AX</strong>
atd. Taktéž se zmíníme o některých vlastnostech standardního jazyka C, které
nejsou v&nbsp;<i>cc65</i> plně podporovány.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
pomocí překladače <strong>cc65</strong>, byly uložen do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>local_add.c</td><td>funkce pro součet dvou celých čísel</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c</a></td></tr>
<tr><td>2</td><td>memset1.c</td><td>vyplnění bloku paměti zadanou hodnotou, základní verze</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c</a></td></tr>
<tr><td>3</td><td>memset2.c</td><td>vyplnění bloku paměti zadanou hodnotou, použití klíčového slova <strong>register</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c</a></td></tr>
<tr><td>4</td><td>memset3.c</td><td>vyplnění bloku paměti zadanou hodnotou, použití konstantních parametrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset3.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset3.c</a></td></tr>
<tr><td>5</td><td>memset4.c</td><td>vyplnění bloku paměti zadanou hodnotou, přepis na smyčku <strong>while</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset4.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset4.c</a></td></tr>
<tr><td>6</td><td>memset5.c</td><td>vyplnění bloku paměti zadanou hodnotou, přepis na smyčku <strong>do-while</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset5.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset5.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>Makefile</td><td>překlad všech demonstračních příkladů do assembleru s&nbsp;různými volbami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/Makefile">https://github.com/tisnik/8bit-fame/blob/master/cc65/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>When did people first start thinking 'C is portable assembler'?<br />
<a href="https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler">https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler</a>
</li>

<li>The Thirty Million Line Problem<br />
<a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">https://www.youtube.com/watch?v=kZRE7HIO3vk</a>
</li>

<li>NesDev.org<br />
<a href="https://www.nesdev.org/">https://www.nesdev.org/</a>
</li>

<li>How to Program an NES game in C<br />
<a href="https://nesdoug.com/">https://nesdoug.com/</a>
</li>

<li>Cycle reference chart<br />
<a href="https://www.nesdev.org/wiki/Cycle_reference_chart">https://www.nesdev.org/wiki/Cycle_reference_chart</a>
</li>

<li>Getting Started Programming in C: Coding a Retro Game with C Part 2<br />
<a href="https://retrogamecoders.com/getting-started-with-c-cc65/">https://retrogamecoders.com/getting-started-with-c-cc65/</a>
</li>

<li>NES game development in 6502 assembly - Part 1<br />
<a href="https://kibrit.tech/en/blog/nes-game-development-part-1">https://kibrit.tech/en/blog/nes-game-development-part-1</a>
</li>

<li>NES 6502 Programming Tutorial - Part 1: Getting Started<br />
<a href="https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/">https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/</a>
</li>

<li>List of 6502-based Computers and Consoles<br />
<a href="https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/">https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/</a>
</li>

<li>6502 - the first RISC &micro;P<br />
<a href="http://ericclever.com/6500/">http://ericclever.com/6500/</a>
</li>

<li>ca65 Users Guide<br />
<a href="https://cc65.github.io/doc/ca65.html">https://cc65.github.io/doc/ca65.html</a>
</li>

<li>cc65 Users Guide<br />
<a href="https://cc65.github.io/doc/cc65.html">https://cc65.github.io/doc/cc65.html</a>
</li>

<li>ld65 Users Guide<br />
<a href="https://cc65.github.io/doc/ld65.html">https://cc65.github.io/doc/ld65.html</a>
</li>

<li>da65 Users Guide<br />
<a href="https://cc65.github.io/doc/da65.html">https://cc65.github.io/doc/da65.html</a>
</li>

<li>“Hello, world” from scratch on a 6502 — Part 1<br />
<a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">https://www.youtube.com/watch?v=LnzuMJLZRdU</a>
</li>

<li>A Tour of 6502 Cross-Assemblers<br />
<a href="https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/">https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer<br />
<a href="http://wilsonminesco.com/6502primer/">http://wilsonminesco.com/6502primer/</a>
</li>

<li>6502 Instruction Set<br />
<a href="https://www.masswerk.at/6502/6502_instruction_set.html">https://www.masswerk.at/6502/6502_instruction_set.html</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Single-board computer<br />
<a href="https://en.wikipedia.org/wiki/Single-board_computer">https://en.wikipedia.org/wiki/Single-board_computer</a>
</li>

<li>www.6502.org<br />
<a href="http://www.6502­.org/">http://www.6502­.org/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer &ndash; clock generator<br />
<a href="http://wilsonminesco.com/6502primer/ClkGen.html">http://wilsonminesco.com/6502primer/ClkGen.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://www.cpushack.com/CPU/cpu.html">http://www.cpushack.com/CPU/cpu.html</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Osmibitové mikroprocesory a mikrořadiče firmy Motorola (1)<br />
<a href="https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/">https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/</a>
</li>

<li>Mikrořadiče a jejich použití v jednoduchých mikropočítačích<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/">https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/</a>
</li>

<li>Mikrořadiče a jejich aplikace v jednoduchých mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/">https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Comparison of instruction set architectures<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures">https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</a>
</li>

<li>Vývojové nástroje používané v dobách osmibitových mikropočítačů<br />
<a href="https://www.root.cz/clanky/vyvojove-nastroje-pouzivane-v-dobach-osmibitovych-mikropocitacu/">https://www.root.cz/clanky/vyvojove-nastroje-pouzivane-v-dobach-osmibitovych-mikropocitacu/</a>
</li>

<li>Historie vývoje počítačových her (112. část – vývojové nástroje pro herní konzole)<br />
<a href="https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-112-cast-vyvojove-nastroje-pro-herni-konzole/">https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-112-cast-vyvojove-nastroje-pro-herni-konzole/</a>
</li>

<li>Programovací jazyky a vývojové nástroje pro mikropočítače společnosti Sinclair Research<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-a-vyvojove-nastroje-pro-mikropocitace-spolecnosti-sinclair-research/">https://www.root.cz/clanky/programovaci-jazyky-a-vyvojove-nastroje-pro-mikropocitace-spolecnosti-sinclair-research/</a>
</li>

<li>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari/</a>
</li>

<li>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/</a>
</li>

<li>Cross assemblery a cross překladače pro platformu osmibitových domácích mikropočítačů Atari<br />
<a href="https://www.root.cz/clanky/cross-assemblery-a-cross-prekladace-pro-platformu-osmibitovych-domacich-mikropocitacu-atari/">https://www.root.cz/clanky/cross-assemblery-a-cross-prekladace-pro-platformu-osmibitovych-domacich-mikropocitacu-atari/</a>
</li>

<li>C Isn't A Programming Language Anymore<br />
<a href="https://faultlore.com/blah/c-isnt-a-language/">https://faultlore.com/blah/c-isnt-a-language/</a>
</li>

<li>Why the C Language Will Never Stop You from Making Mistakes<br />
<a href="https://thephd.dev/your-c-compiler-and-standard-library-will-not-help-you">https://thephd.dev/your-c-compiler-and-standard-library-will-not-help-you</a>
</li>

<li>Benchmark: C compilers for the 6502 CPU<br />
<a href="https://sgadrat.itch.io/super-tilt-bro/devlog/219534/benchmark-c-compilers-for-the-6502-cpu">https://sgadrat.itch.io/super-tilt-bro/devlog/219534/benchmark-c-compilers-for-the-6502-cpu</a>
</li>

<li>Advanced optimizations in CC65<br />
<a href="https://github.com/ilmenit/CC65-Advanced-Optimizations">https://github.com/ilmenit/CC65-Advanced-Optimizations</a>
</li>

<li>The 6502/65C02/65C816 Instruction Set Decoded<br />
<a href="https://llx.com/Neil/a2/opcodes.html">https://llx.com/Neil/a2/opcodes.html</a>
</li>

<li>6502 C Compilers Comparison<br />
<a href="https://gglabs.us/node/2293">https://gglabs.us/node/2293</a>
</li>

<li>6502 C compilers benchmark<br />
<a href="https://github.com/sgadrat/6502-compilers-bench">https://github.com/sgadrat/6502-compilers-bench</a>
</li>

<li>cc65: Differences to the ISO standard<br />
<a href="https://cc65.github.io/doc/cc65.html#s4">https://cc65.github.io/doc/cc65.html#s4</a>
</li>

<li>Compilers<br />
<a href="http://www.6502.org/tools/lang/">http://www.6502.org/tools/lang/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

