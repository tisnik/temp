<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Překladače programovacího jazyka C pro historické osmibitové mikroprocesory</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Překladače programovacího jazyka C pro historické osmibitové mikroprocesory</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>O programovacím jazyku C se někdy s nadsázkou říká, že je to &bdquo;přenositelný assembler&ldquo;. Programy psané v C skutečně mohou být velmi efektivní, ovšem do značné míry záleží na kvalitě céčkového překladače. Dnes si ve stručnosti řekneme, jak je tomu v případě osmibitového CPU MOS 6502.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Překladače programovacího jazyka C pro historické osmibitové mikroprocesory</a></p>
<p><a href="#k02">2. Překladače a cross překladače pro mikroprocesory MOS 6502</a></p>
<p><a href="#k03">3. cc65</a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. Instalace <strong>ca65</strong> a <strong>cc65</strong></a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Obsah navazujícího článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Překladače programovacího jazyka C pro historické osmibitové mikroprocesory</h2>

<p>O programovacím jazyku C se někdy s&nbsp;nadsázkou říká, že je to
&bdquo;přenositelný assembler&ldquo; [<a
href="https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler">1</a>].
Programy napsané v&nbsp;jazyce C skutečně mohou být velmi efektivní, ovšem do
značné míry záleží na kvalitě céčkového překladače. Dnes si ve stručnosti
řekneme, jak je tomu v&nbsp;případě slavného osmibitového mikroprocesoru MOS
6502, jehož instrukční kód jsme si do jisté míry přiblížili <a
href="https://www.root.cz/serialy/vyvoj-her-pro-herni-konzoli-nes/">v&nbsp;seriálu
o vývoji her a grafických dem pro herní konzoli NES</a>.</p>

*** image ***
<p><i>Obrázek 1: Přebal druhého vydání slavné knihy &bdquo;The C Programming
Language&ldquo; (Kerningan, Ritchie)</i></p>

<p>Překladače jazyka C existují pro prakticky každou počítačovou platformu i
pro prakticky každý typ mikroprocesoru. Výjimkou není ani MOS 6502, ovšem na
tomto místě je nutné poznamenat, že právě u podobných typů mikroprocesorů, jako
je MOS 6502, stojí tvůrci překladačů před nelehkým úkolem, protože
programátorský model MOS 6502 se v&nbsp;mnoha ohledech odlišuje od
&bdquo;ideálního céčkového mikroprocesoru&ldquo; A jak by vlastně měl takový
ideální procesor vypadat? Měl by mít velký počet pracovních registrů, obsahovat
instrukce pro snadnou manipulaci s&nbsp;obsahem zásobníku, pracovní registry by
mohly být použity při adresování, měl by podporovat adresování s&nbsp;offsetem
(násobeným &times;1, &times;2, &times;4 apod.) a ideálně by se při adresování
mohla provádět inkrementace či dekrementace offsetu, opět o hodnotu 1, 2, 4
apod. Navíc by paměť měla být viditelná jako lineární prostor s&nbsp;buňkami
s&nbsp;postupně rostoucími adresami(&bdquo;flat model&ldquo;). Tomuto ideálu se
kdysi přiblížil čip Motorola 68000 a dále RISCové procesory, z&nbsp;nichž mnohé
byly navrženy právě s&nbsp;ohledem na <i>sémantické</i> možnosti jazyka C.</p>

<img src="http://i.iinfo.cz/images/365/gamesc3.jpg" class="image-161781" width="450" height="259" alt="&#160;" />
<p><i>Obrázek 2: Logo překladačů Aztec C.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Překladače a cross překladače pro mikroprocesory MOS 6502</h2>

<p>Některé překladače programovacího jazyka C pro MOS 6502 byly navrženy přímo
pro běh na strojích osazených tímto čipem. To je dnes zcela normální situace
(aplikace pro PC se překládají na PC), ovšem v&nbsp;případě MOS 6502 se museli
tvůrci překladačů vypořádat s&nbsp;pomalým čipem, velmi malou kapacitou paměti
a navíc i relativně pomalým externím paměťovým médiem (typicky disketa, protože
kazetové verze C by byly ještě problematičtější). V&nbsp;důsledku těchto
omezení se jednalo spíše o projekty určené pro amatérské použití, zatímco
profesionální software stále vznikal v&nbsp;assembleru. Jednou z&nbsp;prvních
implementací překladače C pro MOS 6502 je C/65 od slavné firmy <a
href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/#k02">Optimized
Systems Software (OSS)</a>.</p>

*** image ***
<p><i>Obrázek 3: C/65 od společnosti Optimized Systems Software (OSS).</i></p>

<p>Taktéž se na tomto místě musíme zmínit o známém překladači <i>Aztec C</i>,
jenž byl portovaný na velké množství různých typů mikropočítačů, zapomenout
nesmíme ani na <i>Deep Blue C</i> (viz též <a
href="https://en.wikipedia.org/wiki/Deep_Blue_C">https://en.wikipedia.org/wiki/Deep_Blue_C</a>)
pro osmibitové počítače Atari. Zde se autoři museli vyrovnat s&nbsp;faktem, že
znaková sada neobsahovala složené závorky, takže zápis vypadal například
takto:</p>

<pre>
main()
$(
    printf("Hello World!");
$)
</pre>

<p><div class="rs-tip-major">Poznámka: což připomíná <a
href="https://riptutorial.com/c/example/23858/trigraphs">trigraphy
C</a>.</div></p>

*** image ***
<p><i>Obrázek 4: Dobová reklama na nástroje společnosti OSS.</i></p>

<p>Zajímavější jsou z&nbsp;dnešního pohledu cross compilery a cross assemblery
(viz poznámka o českém překladu tohoto názvu). Tyto typy nástrojů jsou velmi
často používané i dnes, zejména v&nbsp;oblasti mikrořadičů, digitálních
signálových procesorů nebo mobilních telefonů (viz například <a
href="http://scratchbox.org/">Scratchbox</a>). Ovšem tato technologie se
používala již na začátku osmibitové éry. Například vývoj her pro herní konzoli
Atari 2600 (Atari Video Computer System neboli Atari VCS) byl prováděn na
minipočítači. Ovšem i později některé firmy vyvíjely profesionální software pro
Atari, C64 i další osmibitové mikropočítače na výkonnějších strojích, kde se
prováděl i překlad.</p>

<p><div class="rs-tip-major">Poznámka: existuje i český termín <i>křížový
překladač</i>, ale musím se přiznat, že mi připadá jako výsledek otrockého
překladu a navíc se slovo &bdquo;cross&ldquo; přeložilo ve špatném
kontextu.</div></p>

<img src="http://i.iinfo.cz/images/15/gamesc4.jpg" class="image-161782" width="450" height="265" alt="&#160;" />
<p><i>Obrázek 5: Jeden z&nbsp;konkurenčních překladačů k&nbsp;Aztec C byl
Lattice C (ovšem až v&nbsp;pozdější době).</i></p>

<p>Dobrým a možná i typickým příkladem jsou právě cross překladače
programovacího jazyka C. Tvorbou těchto cross překladačů se zabývala například
společnost <i>Manx Software Systems</i>, jejíž překladače céčka (Aztec C)
určené pro <a
href="https://www.root.cz/clanky/ctyricet-let-existence-oslavovane-i-nenavidene-platformy-pc/">IBM
PC</a> s&nbsp;DOSem i pro osobní mikropočítače Macintosh dokázaly provádět
cross překlad na osmibitové mikropočítače Commodore C64 a Apple II. Na chvíli
se u Aztec C zastavme, i když přímo nesouvisí s&nbsp;osmibitovými Atari.</p>

<p><i>Aztec C</i> totiž byl ve své době velmi úspěšný překladač, jenž existoval
jak ve verzi pro osmibitové mikroprocesory (MOS 6502, Zilog Z-80), tak i pro
mikroprocesory 16bitové a 32bitové. Tento překladač byl velmi úspěšný právě na
Amize, kde byl používán, společně s&nbsp;<i>Lattice C</i>, prakticky až do
faktického zániku této platformy. Ovšem na IBM PC jeho sláva netrvala dlouho,
především z&nbsp;toho důvodu, že firma Microsoft považovala segment překladačů
za poměrně důležitý a snažila se vytlačit jakoukoli konkurenci z&nbsp;trhu (i
když ve skutečnosti v&nbsp;té době ještě neměla vlastní céčkový překladač).
Společnosti <i>Manx Software Systems</i> se postupně zmenšoval počet platforem,
na něž bylo možné překladač prodávat a přechod na podporu vestavěných systémů
již přišel dosti pozdě. A právě pro cross překlad se Aztec C může používat
dodnes (běží v&nbsp;DOSu, takže dnes vlastně taktéž v&nbsp;emulovaném
prostředí).</p>

<p><div class="rs-tip-major">Poznámka: další informace o překladačích i cross
překladačích Aztec C lze najít na stránce <a
href="http://aztecmuseum.ca/compilers.htm">http://aztecmuseum.ca/compilers.htm</a>.</div></p>

<p>Podobným stylem byl řešen i Microsoft C původně vytvořený společností, která
stála za slavným Lattice C. Ostatně Lattice C byl s&nbsp;velkou
pravděpodobností vůbec prvním překladačem céčka pro IBM PC (pochází z&nbsp;roku
1982). Ten byl později převeden i na Amigu, dále se rozšířil i na minipočítače
a mainframy společnosti IBM. Firma Microsoft překladač <i>Lattice C</i>
nabízela pod svým názvem <i>MSC (Microsoft C)</i> a teprve verze <i>MSC 4.0</i>
byla skutečně vytvořena přímo programátory z&nbsp;Microsoftu. <i>Lattice C</i>
byl používán i při portaci aplikací z&nbsp;operačního systému <i>CP/M</i> na
DOS (dnes je však možné pouze odhadnout, kolik kódu bylo skutečně napsáno
v&nbsp;céčku a kolik kódu vzniklo transformací assembleru).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. cc65</h2>

<p>Prvním cross překladačem, s&nbsp;nímž se v&nbsp;dnešním článku seznámíme (a
současně i překladačem nejznámějším), je překladač programovacího jazyka C,
který se jmenuje <i>cc65</i>. Ve skutečnosti se však nejedná pouze o čistý
překladač céčka, ale o sadu dalších vývojářských nástrojů, mezi něž patří i <a
href="#k10">výše zmíněný</a> cross assembler <i>ca65</i>, dále linker
<i>ld65</i>, disassembler <i>da65</i>, simulátor procesorů 6502 <i>sim65</i>
atd. Tento překladač je možné použít nejenom pro tvorbu aplikací pro osmibitové
mikropočítače Atari, ale i pro osmibitové stroje firmy Commodore (VIC20, C64,
C128 atd.), osmibitové mikropočítače řady Apple II, herní konzoli NES, konzoli
TurboGrafx-16 atd.</p>

<p>Jazyk akceptovaný překladačem <i>cc65</i> do určité míry odpovídá ISO
standardu jazyka C (a tím pádem i původnímu ANSI standardu, dokonce je
podporováno několik vlastností z&nbsp;C99); standard je vnucen přepínačem
<strong>--standard</strong>.  Existuje však několik dosti podstatných rozdílů a
nedostatků <i>cc65</i>, mezi něž patří neexistence datových typů <i>float</i> a
<i>double</i> (a tím pádem i celá část céčka, která předepisuje konverze
s&nbsp;těmito typy atd.). Dále existuje omezení při definicích funkcí &ndash;
funkce nemohou vracet struktury ani unie; struktury dokonce není možné předávat
hodnotou (což ale většinou nevadí, právě naopak). Kromě toho je sice možné
použít modifikátor <strong>volatile</strong>, ovšem ten nemá žádný podstatný
význam (což je v&nbsp;případě mikroprocesorů MOS 6502 a jejich možností
pochopitelné). Naproti tomu má či může mít velký vliv modifikátor
<strong>register</strong>, který naopak mnoho moderních překladačů již
nepotřebuje či dokonce zcela ignoruje.</p>

<p>Naopak mezi rozšíření <i>cc65</i> oproti standardu jazyka C (jak ANSI, tak i
ISO normy) patří podpora bloků psaných v&nbsp;assembleru, podpora
pseudoproměnných <strong>A</strong> a <strong>AX</strong> (což je primární
registr mikroprocesoru, tedy akumulátor, v&nbsp;případě <strong>AX</strong>
rozšířený na šestnáct bitů přes registr <strong>X</strong>). Podporovány jsou
konstanty zapsané ve dvojkové soustavě (0b101) a použít lze i počítaná
<strong>goto</strong> (což je částečně převzato z&nbsp;GCC).</p>

<p><div class="rs-tip-major">Poznámka: současně <i>cc65</i> negeneruje
optimální kód, což si ostatně ukážeme v&nbsp;navazujících kapitolách.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. vbcc</h2>

<p>Dalším transpřekladačem jazyka C určeným pro překlad do strojového kódu mikroprocesorů MOS 6502, je překladač nazvaný <i>vbcc</i>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. 6502-gcc</h2>

<p>Třetím transpřekladačem jazyka C do strojového kódu mikroprocesorů MOS 6502, o kterém se dnes zmíníme, je překladač nazvaný <i>6502-gcc</i>. Název tohoto projektu naznačuje, že je založen na <i>GCC (GNU Compiler Collection)</i>. Díky front-endu GCC je zajištěna prakticky stoprocentní kompatibilita s&nbsp;programovacím jazykem C (na rozdíl od některých nekompatibilních rysů cc65).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace <strong>ca65</strong> a <strong>cc65</strong></h2>

<p>Instalace assembleru <strong>ca65</strong> i céčkového překladače <strong>cc65</strong> je na většině distribucí Linuxu snadná, neboť se jedná o balíčky umístěné přímo v&nbsp;repositářích dané distribuce. Příkladem může být Linux Mint:</p>

<pre>
$ <strong>sudo apt-get install cc65</strong>
&nbsp;
Reading package lists... Done
Building dependency tree
Reading state information... Done
Suggested packages:
  cc65-doc
The following NEW packages will be installed:
  cc65
0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.
Need to get 2 162 kB of archives.
After this operation, 31,8 MB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu focal/universe amd64 cc65 amd64 2.18-1 [2 162 kB]
Fetched 2 162 kB in 5s (423 kB/s)
Selecting previously unselected package cc65.
(Reading database ... 291820 files and directories currently installed.)
Preparing to unpack .../archives/cc65_2.18-1_amd64.deb ...
Unpacking cc65 (2.18-1) ...
Setting up cc65 (2.18-1) ...
</pre>

<p>Po dokončení instalace budou k&nbsp;dispozici tři nové nástroje (a několik podpůrných nástrojů).</p>

<p>V&nbsp;první řadě se jedná o assembler:</p>

<pre>
$ <strong>cc65 --version</strong>
cc65 V2.18 - Ubuntu 2.18-1
</pre>

<p>Dále o překladač céčka:</p>

<pre>
$ <strong>ca65 --version</strong>
ca65 V2.18 - Ubuntu 2.18-1
</pre>

<p>A využijeme i samostatný linker:</p>

<pre>
$ <strong>ld65 --version</strong>
ld65 V2.18 - Ubuntu 2.18-1
</pre>

<p><div class="rs-tip-major">Poznámka: nainstalován je ale například i disassembler atd.</div></p>

<pre>
# <strong>dnf install cc65</strong>
&nbsp;
Last metadata expiration check: 0:21:57 ago on Sat 10 Sep 2022 04:10:12 AM EDT.
Dependencies resolved.
================================================================================
 Package           Architecture  Version             Repository            Size
================================================================================
Installing:
 cc65              x86_64        2.19-3.fc36         beaker-Fedora        421 k
Installing dependencies:
 cc65-devel        noarch        2.19-3.fc36         beaker-Fedora        1.8 M
Installing weak dependencies:
 cc65-doc          noarch        2.19-3.fc36         beaker-Fedora        623 k
 cc65-utils        x86_64        2.19-3.fc36         beaker-Fedora         29 k
&nbsp;
Transaction Summary
================================================================================
Install  4 Packages
&nbsp;
Total download size: 2.8 M
Installed size: 33 M
Is this ok [y/N]:
</pre>

<pre>
$ <strong>cc65 --version</strong>
&nbsp;
cc65 V2.18 - Fedora 2.19-3.fc36
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
void <strong>main</strong>(void)
{
    register unsigned char a;
    register unsigned char b;
    register unsigned char c;
    a = 10;
    b = 20;
    c = a + b;
}
</pre>

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
        jsr     decsp3
        ldx     #$00
        lda     #$0A
        ldy     #$02
        sta     (sp),y
        ldx     #$00
        lda     #$14
        ldy     #$01
        sta     (sp),y
        ldy     #$02
        ldx     #$00
        lda     (sp),y
        jsr     pushax
        ldy     #$03
        ldx     #$00
        lda     (sp),y
        jsr     tosaddax
        ldx     #$00
        ldy     #$00
        sta     (sp),y
        jsr     incsp3
        rts
&nbsp;
.endproc
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
cc65 -T local_add.c
</pre>

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
;
; a = 10;
;
        jsr     decsp3
        ldx     #$00
        lda     #$0A
        ldy     #$02
        sta     (sp),y
;
; b = 20;
;
        ldx     #$00
        lda     #$14
        ldy     #$01
        sta     (sp),y
;
; c = a + b;
;
        ldy     #$02
        ldx     #$00
        lda     (sp),y
        jsr     pushax
        ldy     #$03
        ldx     #$00
        lda     (sp),y
        jsr     tosaddax
        ldx     #$00
        ldy     #$00
        sta     (sp),y
;
; }
;
        jsr     incsp3
        rts
&nbsp;
.endproc
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
cc65 -T -Cl local_add.c
</pre>

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
;
; a = 10;
;
        ldx     #$00
        lda     #$0A
        sta     L0002
;
; b = 20;
;
        ldx     #$00
        lda     #$14
        sta     L0003
;
; c = a + b;
;
        ldx     #$00
        lda     L0002
        jsr     pushax
        ldx     #$00
        lda     L0003
        jsr     tosaddax
        ldx     #$00
        sta     L0004
;
; }
;
        rts
&nbsp;
.endproc
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
-Cl -O
</pre>

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
;
; a = 10;
;
        lda     #$0A
        sta     L0002
;
; b = 20;
;
        lda     #$14
        sta     L0003
;
; c = a + b;
;
        lda     L0002
        clc
        adc     L0003
        sta     L0004
;
; }
;
        rts
&nbsp;
.endproc
</pre>

-Or

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
;
; register unsigned char a;
;
        lda     regbank+5
        jsr     pusha
;
; register unsigned char b;
;
        lda     regbank+4
        jsr     pusha
;
; register unsigned char c;
;
        lda     regbank+3
        jsr     pusha
;
; a = 10;
;
        lda     #$0A
        sta     regbank+5
;
; b = 20;
;
        lda     #$14
        sta     regbank+4
;
; c = a + b;
;
        lda     regbank+5
        clc
        adc     regbank+4
        sta     regbank+3
;
; }
;
        ldy     #$00
L0008:  lda     (sp),y
        sta     regbank+3,y
        iny
        cpy     #$03
        bne     L0008
        jmp     incsp3
&nbsp;
.endproc
</pre>

-Oi

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
;
; a = 10;
;
        lda     #$0A
        sta     L0002
;
; b = 20;
;
        lda     #$14
        sta     L0003
;
; c = a + b;
;
        lda     L0002
        clc
        adc     L0003
        sta     L0004
;
; }
;
        rts
&nbsp;
.endproc
</pre>

cc65 -T -Cl -Osir local_add.c

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
;
; register unsigned char a;
;
        lda     regbank+5
        jsr     pusha
;
; register unsigned char b;
;
        lda     regbank+4
        jsr     pusha
;
; register unsigned char c;
;
        lda     regbank+3
        jsr     pusha
;
; a = 10;
;
        lda     #$0A
        sta     regbank+5
;
; b = 20;
;
        lda     #$14
        sta     regbank+4
;
; c = a + b;
;
        lda     regbank+5
        clc
        adc     regbank+4
        sta     regbank+3
;
; }
;
        ldy     #$00
        lda     (sp),y
        sta     regbank+3
        iny
        lda     (sp),y
        sta     regbank+4
        iny
        lda     (sp),y
        sta     regbank+5
        jmp     incsp3
&nbsp;
.endproc
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
void memset8(uint8_t * dest, uint8_t c, uint8_t n)
{
    int i;
&nbsp;
    for (i = 0; i &lt; n; i++) {
        dest[i] = c;
    }
}
&nbsp;
int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);
&nbsp;
    return 0;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
	.fopt		compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_memset8
	.export		_main
&nbsp;
; ---------------------------------------------------------------
; void __near__ memset8 (__near__ unsigned char *, unsigned char, unsigned char)
; ---------------------------------------------------------------
&nbsp;
.segment	"CODE"
&nbsp;
.proc	_memset8: near
&nbsp;
.segment	"BSS"
&nbsp;
L0002:
	.res	2,$00
&nbsp;
.segment	"CODE"
&nbsp;
;
; {
;
	jsr     pusha
;
; for (i = 0; i &lt; n; i++) {
;
	lda     #$00
	sta     L0002
	sta     L0002+1
L0003:	lda     L0002
	ldy     #$00
	cmp     (sp),y
	lda     L0002+1
	sbc     #$00
	bcs     L0004
;
; dest[i] = c;
;
	ldy     #$03
	jsr     ldaxysp
	clc
	adc     L0002
	sta     ptr1
	txa
	adc     L0002+1
	sta     ptr1+1
	ldy     #$01
	lda     (sp),y
	dey
	sta     (ptr1),y
;
; for (i = 0; i &lt; n; i++) {
;
	lda     L0002
	ldx     L0002+1
	jsr     incax1
	sta     L0002
	stx     L0002+1
	jmp     L0003
;
; }
;
L0004:	jmp     incsp4
&nbsp;
.endproc
&nbsp;
; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------
&nbsp;
.segment	"CODE"
&nbsp;
.proc	_main: near
&nbsp;
.segment	"BSS"
&nbsp;
L000F:
	.res	2,$00
L0011:
	.res	1,$00
L0013:
	.res	1,$00
&nbsp;
.segment	"CODE"
&nbsp;
;
; uint8_t *dest = (uint8_t *) 0x0600;
;
	ldx     #$06
	lda     #$00
	sta     L000F
	stx     L000F+1
;
; uint8_t bytes = 0xff;
;
	lda     #$FF
	sta     L0011
;
; uint8_t fill = 0x00;
;
	lda     #$00
	sta     L0013
;
; memset8(dest, fill, bytes);
;
	lda     L000F
	ldx     L000F+1
	jsr     pushax
	lda     L0013
	jsr     pusha
	lda     L0011
	jsr     _memset8
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts
&nbsp;
.endproc
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
#include &lt;stdint.h&gt;

void memset8(uint8_t * dest, uint8_t c, uint8_t n)
{
    register uint8_t i;

    for (i = 0; i &lt; n; i++) {
        dest[i] = c;
    }
}

int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);

    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
	.fopt		compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_memset8
	.export		_main

; ---------------------------------------------------------------
; void __near__ memset8 (__near__ unsigned char *, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_memset8: near

.segment	"BSS"

L0002:
	.res	1,$00

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; for (i = 0; i &lt; n; i++) {
;
	lda     #$00
	sta     L0002
L001B:	lda     L0002
	ldy     #$00
	cmp     (sp),y
	bcs     L0004
;
; dest[i] = c;
;
	ldy     #$03
	jsr     ldaxysp
	clc
	adc     L0002
	bcc     L001A
	inx
L001A:	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (sp),y
	dey
	sta     (ptr1),y
;
; for (i = 0; i &lt; n; i++) {
;
	inc     L0002
	jmp     L001B
;
; }
;
L0004:	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"BSS"

L000F:
	.res	2,$00
L0011:
	.res	1,$00
L0013:
	.res	1,$00

.segment	"CODE"

;
; uint8_t *dest = (uint8_t *) 0x0600;
;
	ldx     #$06
	lda     #$00
	sta     L000F
	stx     L000F+1
;
; uint8_t bytes = 0xff;
;
	lda     #$FF
	sta     L0011
;
; uint8_t fill = 0x00;
;
	lda     #$00
	sta     L0013
;
; memset8(dest, fill, bytes);
;
	lda     L000F
	ldx     L000F+1
	jsr     pushax
	lda     L0013
	jsr     pusha
	lda     L0011
	jsr     _memset8
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc

</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
#include &lt;stdint.h&gt;

void memset8(uint8_t * dest, const uint8_t c, const uint8_t n)
{
    register uint8_t i;

    for (i = 0; i &lt; n; i++) {
        dest[i] = c;
    }
}

int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);

    return 0;
}
</pre>

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
	.fopt		compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_memset8
	.export		_main

; ---------------------------------------------------------------
; void __near__ memset8 (__near__ unsigned char *, const unsigned char, const unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_memset8: near

.segment	"BSS"

L0002:
	.res	1,$00

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; for (i = 0; i &lt; n; i++) {
;
	lda     #$00
	sta     L0002
L001B:	lda     L0002
	ldy     #$00
	cmp     (sp),y
	bcs     L0004
;
; dest[i] = c;
;
	ldy     #$03
	jsr     ldaxysp
	clc
	adc     L0002
	bcc     L001A
	inx
L001A:	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (sp),y
	dey
	sta     (ptr1),y
;
; for (i = 0; i &lt; n; i++) {
;
	inc     L0002
	jmp     L001B
;
; }
;
L0004:	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"BSS"

L000F:
	.res	2,$00
L0011:
	.res	1,$00
L0013:
	.res	1,$00

.segment	"CODE"

;
; uint8_t *dest = (uint8_t *) 0x0600;
;
	ldx     #$06
	lda     #$00
	sta     L000F
	stx     L000F+1
;
; uint8_t bytes = 0xff;
;
	lda     #$FF
	sta     L0011
;
; uint8_t fill = 0x00;
;
	lda     #$00
	sta     L0013
;
; memset8(dest, fill, bytes);
;
	lda     L000F
	ldx     L000F+1
	jsr     pushax
	lda     L0013
	jsr     pusha
	lda     L0011
	jsr     _memset8
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<pre>
#include &lt;stdint.h&gt;

void memset8(uint8_t * dest, const uint8_t c, uint8_t n)
{
    while (n &gt; 0) {
        *dest++ = c;
        n--;
    }
}

int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);

    return 0;
}
</pre>

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
	.fopt		compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_memset8
	.export		_main

; ---------------------------------------------------------------
; void __near__ memset8 (__near__ unsigned char *, const unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_memset8: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; while (n &gt; 0) {
;
	jmp     L0004
;
; *dest++ = c;
;
L0002:	ldy     #$03
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$02
	jsr     staxysp
	ldy     #$01
	lda     (sp),y
	dey
	sta     (regsave),y
;
; n--;
;
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
;
; while (n &gt; 0) {
;
L0004:	ldy     #$00
	lda     (sp),y
	bne     L0002
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"BSS"

L000A:
	.res	2,$00
L000C:
	.res	1,$00
L000E:
	.res	1,$00

.segment	"CODE"

;
; uint8_t *dest = (uint8_t *) 0x0600;
;
	ldx     #$06
	lda     #$00
	sta     L000A
	stx     L000A+1
;
; uint8_t bytes = 0xff;
;
	lda     #$FF
	sta     L000C
;
; uint8_t fill = 0x00;
;
	lda     #$00
	sta     L000E
;
; memset8(dest, fill, bytes);
;
	lda     L000A
	ldx     L000A+1
	jsr     pushax
	lda     L000E
	jsr     pusha
	lda     L000C
	jsr     _memset8
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<pre>
#include &lt;stdint.h&gt;

void memset8(uint8_t * dest, const uint8_t c, uint8_t n)
{
    /* pozor na hodnotu n=0! */
    do {
        *dest++ = c;
        n--;
    } while (n &gt; 0);
}

int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);

    return 0;
}
</pre>

<pre>
;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
	.fopt		compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_memset8
	.export		_main

; ---------------------------------------------------------------
; void __near__ memset8 (__near__ unsigned char *, const unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_memset8: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; *dest++ = c;
;
L0002:	ldy     #$03
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$02
	jsr     staxysp
	ldy     #$01
	lda     (sp),y
	dey
	sta     (regsave),y
;
; n--;
;
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
;
; } while (n &gt; 0);
;
	lda     (sp),y
	bne     L0002
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"BSS"

L000A:
	.res	2,$00
L000C:
	.res	1,$00
L000E:
	.res	1,$00

.segment	"CODE"

;
; uint8_t *dest = (uint8_t *) 0x0600;
;
	ldx     #$06
	lda     #$00
	sta     L000A
	stx     L000A+1
;
; uint8_t bytes = 0xff;
;
	lda     #$FF
	sta     L000C
;
; uint8_t fill = 0x00;
;
	lda     #$00
	sta     L000E
;
; memset8(dest, fill, bytes);
;
	lda     L000A
	ldx     L000A+1
	jsr     pushax
	lda     L000E
	jsr     pusha
	lda     L000C
	jsr     _memset8
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujícího článku</h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
pomocí překladače <strong>cc65</strong>, byly uložen do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>local_add.c</td><td>funkce pro součet dvou celých čísel</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c</a></td></tr>
<tr><td>2</td><td>memset1.c</td><td>vyplnění bloku paměti zadanou hodnotou, základní verze</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c</a></td></tr>
<tr><td>3</td><td>memset2.c</td><td>vyplnění bloku paměti zadanou hodnotou, použití klíčového slova <strong>register</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c</a></td></tr>
<tr><td>4</td><td>memset3.c</td><td>vyplnění bloku paměti zadanou hodnotou, použití konstantních parametrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset3.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset3.c</a></td></tr>
<tr><td>5</td><td>memset4.c</td><td>vyplnění bloku paměti zadanou hodnotou, přepis na smyčku <strong>while</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset4.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset4.c</a></td></tr>
<tr><td>6</td><td>memset5.c</td><td>vyplnění bloku paměti zadanou hodnotou, přepis na smyčku <strong>do-while</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset5.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset5.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>Makefile</td><td>překlad všech demonstračních příkladů do assembleru s&nbsp;různými volbami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/Makefile">https://github.com/tisnik/8bit-fame/blob/master/cc65/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>When did people first start thinking 'C is portable assembler'?<br />
<a href="https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler">https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler</a>
</li>

<li>The Thirty Million Line Problem<br />
<a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">https://www.youtube.com/watch?v=kZRE7HIO3vk</a>
</li>

<li>NesDev.org<br />
<a href="https://www.nesdev.org/">https://www.nesdev.org/</a>
</li>

<li>How to Program an NES game in C<br />
<a href="https://nesdoug.com/">https://nesdoug.com/</a>
</li>

<li>Cycle reference chart<br />
<a href="https://www.nesdev.org/wiki/Cycle_reference_chart">https://www.nesdev.org/wiki/Cycle_reference_chart</a>
</li>

<li>Getting Started Programming in C: Coding a Retro Game with C Part 2<br />
<a href="https://retrogamecoders.com/getting-started-with-c-cc65/">https://retrogamecoders.com/getting-started-with-c-cc65/</a>
</li>

<li>NES game development in 6502 assembly - Part 1<br />
<a href="https://kibrit.tech/en/blog/nes-game-development-part-1">https://kibrit.tech/en/blog/nes-game-development-part-1</a>
</li>

<li>NES 6502 Programming Tutorial - Part 1: Getting Started<br />
<a href="https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/">https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/</a>
</li>

<li>List of 6502-based Computers and Consoles<br />
<a href="https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/">https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/</a>
</li>

<li>6502 - the first RISC &micro;P<br />
<a href="http://ericclever.com/6500/">http://ericclever.com/6500/</a>
</li>

<li>ca65 Users Guide<br />
<a href="https://cc65.github.io/doc/ca65.html">https://cc65.github.io/doc/ca65.html</a>
</li>

<li>cc65 Users Guide<br />
<a href="https://cc65.github.io/doc/cc65.html">https://cc65.github.io/doc/cc65.html</a>
</li>

<li>ld65 Users Guide<br />
<a href="https://cc65.github.io/doc/ld65.html">https://cc65.github.io/doc/ld65.html</a>
</li>

<li>da65 Users Guide<br />
<a href="https://cc65.github.io/doc/da65.html">https://cc65.github.io/doc/da65.html</a>
</li>

<li>“Hello, world” from scratch on a 6502 — Part 1<br />
<a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">https://www.youtube.com/watch?v=LnzuMJLZRdU</a>
</li>

<li>A Tour of 6502 Cross-Assemblers<br />
<a href="https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/">https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer<br />
<a href="http://wilsonminesco.com/6502primer/">http://wilsonminesco.com/6502primer/</a>
</li>

<li>6502 Instruction Set<br />
<a href="https://www.masswerk.at/6502/6502_instruction_set.html">https://www.masswerk.at/6502/6502_instruction_set.html</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Single-board computer<br />
<a href="https://en.wikipedia.org/wiki/Single-board_computer">https://en.wikipedia.org/wiki/Single-board_computer</a>
</li>

<li>www.6502.org<br />
<a href="http://www.6502­.org/">http://www.6502­.org/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer &ndash; clock generator<br />
<a href="http://wilsonminesco.com/6502primer/ClkGen.html">http://wilsonminesco.com/6502primer/ClkGen.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://www.cpushack.com/CPU/cpu.html">http://www.cpushack.com/CPU/cpu.html</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Osmibitové mikroprocesory a mikrořadiče firmy Motorola (1)<br />
<a href="https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/">https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/</a>
</li>

<li>Mikrořadiče a jejich použití v jednoduchých mikropočítačích<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/">https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/</a>
</li>

<li>Mikrořadiče a jejich aplikace v jednoduchých mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/">https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Comparison of instruction set architectures<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures">https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</a>
</li>

<li>Vývojové nástroje používané v dobách osmibitových mikropočítačů<br />
<a href="https://www.root.cz/clanky/vyvojove-nastroje-pouzivane-v-dobach-osmibitovych-mikropocitacu/">https://www.root.cz/clanky/vyvojove-nastroje-pouzivane-v-dobach-osmibitovych-mikropocitacu/</a>
</li>

<li>Historie vývoje počítačových her (112. část – vývojové nástroje pro herní konzole)<br />
<a href="https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-112-cast-vyvojove-nastroje-pro-herni-konzole/">https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-112-cast-vyvojove-nastroje-pro-herni-konzole/</a>
</li>

<li>Programovací jazyky a vývojové nástroje pro mikropočítače společnosti Sinclair Research<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-a-vyvojove-nastroje-pro-mikropocitace-spolecnosti-sinclair-research/">https://www.root.cz/clanky/programovaci-jazyky-a-vyvojove-nastroje-pro-mikropocitace-spolecnosti-sinclair-research/</a>
</li>

<li>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari/</a>
</li>

<li>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/</a>
</li>

<li>Cross assemblery a cross překladače pro platformu osmibitových domácích mikropočítačů Atari<br />
<a href="https://www.root.cz/clanky/cross-assemblery-a-cross-prekladace-pro-platformu-osmibitovych-domacich-mikropocitacu-atari/">https://www.root.cz/clanky/cross-assemblery-a-cross-prekladace-pro-platformu-osmibitovych-domacich-mikropocitacu-atari/</a>
</li>

<li>C Isn't A Programming Language Anymore<br />
<a href="https://faultlore.com/blah/c-isnt-a-language/">https://faultlore.com/blah/c-isnt-a-language/</a>
</li>

<li>Why the C Language Will Never Stop You from Making Mistakes<br />
<a href="https://thephd.dev/your-c-compiler-and-standard-library-will-not-help-you">https://thephd.dev/your-c-compiler-and-standard-library-will-not-help-you</a>
</li>

<li>Benchmark: C compilers for the 6502 CPU<br />
<a href="https://sgadrat.itch.io/super-tilt-bro/devlog/219534/benchmark-c-compilers-for-the-6502-cpu">https://sgadrat.itch.io/super-tilt-bro/devlog/219534/benchmark-c-compilers-for-the-6502-cpu</a>
</li>

<li>Advanced optimizations in CC65<br />
<a href="https://github.com/ilmenit/CC65-Advanced-Optimizations">https://github.com/ilmenit/CC65-Advanced-Optimizations</a>
</li>

<li>The 6502/65C02/65C816 Instruction Set Decoded<br />
<a href="https://llx.com/Neil/a2/opcodes.html">https://llx.com/Neil/a2/opcodes.html</a>
</li>

<li>6502 C Compilers Comparison<br />
<a href="https://gglabs.us/node/2293">https://gglabs.us/node/2293</a>
</li>

<li>6502 C compilers benchmark<br />
<a href="https://github.com/sgadrat/6502-compilers-bench">https://github.com/sgadrat/6502-compilers-bench</a>
</li>

<li>cc65: Differences to the ISO standard<br />
<a href="https://cc65.github.io/doc/cc65.html#s4">https://cc65.github.io/doc/cc65.html#s4</a>
</li>

<li>Compilers<br />
<a href="http://www.6502.org/tools/lang/">http://www.6502.org/tools/lang/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

