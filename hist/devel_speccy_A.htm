<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Tisk hexadecimálních hodnot podruhé</a></p>
<p><a href="#k02">2. Úplný zdrojový kód dnešního prvního demonstračního příkladu</a></p>
<p><a href="#k03">3. Malá odbočka: přetečení hodnoty cifry</a></p>
<p><a href="#k04">4. Úplný zdrojový kód dnešního druhého demonstračního příkladu</a></p>
<p><a href="#k05">*** 5. Využití instrukce <strong>DAA</strong> namísto podmíněného skoku</a></p>
<p><a href="#k06">*** 6. Podrobný popis operací prováděných při převodu hexadecimální cifry na ASCII znak</a></p>
<p><a href="#k07">7. Úplný zdrojový kód dnešního třetího demonstračního příkladu</a></p>
<p><a href="#k08">*** 8. Vylepšené vytištění osmibitové hexadecimální hodnoty</a></p>
<p><a href="#k09">9. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</a></p>
<p><a href="#k10">10. Reprezentace numerických hodnot ve formátu pevné a plovoucí řádové (binární) tečky</a></p>
<p><a href="#k11">*** 11. Vybrané způsoby reprezentace numerických hodnot v&nbsp;operační paměti počítače</a></p>
<p><a href="#k12">*** 12. Uložení numerických hodnot ve formátu pevné řádové binární tečky</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">17. Úplný zdrojový kód dnešního pátého demonstračního příkladu</a></p>
<p><a href="#k18">*** 18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Tisk hexadecimálních hodnot podruhé</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Úplný zdrojový kód dnešního prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód demonstračního příkladu popsaného <a
href="#k01">v&nbsp;úvodní kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/79-print-hex-digit-jmp.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/79-print-hex-digit-jmp.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS        <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        xor  A              <i>; hodnota cifry, která se má vytisknout</i>
        ld   B, 16          <i>; počitadlo smyčky</i>
loop:                       <i>; vytisknout hexa cifru s přechodem na nový řádek</i>
        call print_hex_digit_nl
        inc  A              <i>; zvýšit hodnotu tištěné cifry</i>
        djnz loop           <i>; opakování smyčky se snížením hodnoty počitadla</i>
&nbsp;
        ret                 <i>; návrat z programu do BASICu</i>
&nbsp;
<strong>print_hex_digit_nl</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
&nbsp;
        cp   0x0a           <i>; test, jestli je číslice menší než 10</i>
        jr c, print_0_to_9  <i>; ok, hodnota je menší než 10, budeme tedy tisknout desítkovou číslici</i>
        add  A, 65-10-48    <i>; ASCII kód znaku 'A', ovšem začínáme od desítky, ne od nuly (+ update pro další ADD)</i>
<strong>print_0_to_9</strong>:
        add  A, 48          <i>; ASCII kód znaku '0'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
&nbsp;
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        pop  AF             <i>; obnovit A</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Samozřejmě si opět pro úplnost ukážeme, jak byl tento zdrojový text přeložen
do strojového kódu:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:AF         XOR A
8004:0610       LD B, 10
8006:           label loop
8006:CD0D80     CALL 800D
8009:3C         INC A
800A:10FA       DJNZ 8006
800C:C9         RET
800D:           label print_hex_digit_nl
800D:F5         PUSH AF
800E:FE0A       CP 0A
8010:3802       JR C, 8014
8012:C607       ADD A, 07
8014:           label print_0_to_9
8014:C630       ADD A, 30
8016:D7         RST 10
8017:           label new_line
8017:3E0D       LD A, 0D
8019:D7         RST 10
801A:F1         POP AF
801B:C9         RET
801C:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 801B
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Malá odbočka: přetečení hodnoty cifry</h2>

<p>Zajímavé bude si vyzkoušet, co se stane ve chvíli, kdy se pokusíme o převod
a vytištění dekadické hodnoty větší než 15. Velmi snadno si můžeme upravit
počítanou programovou smyčku v&nbsp;předchozím příkladu takovým způsobem, aby
se smyčka nezastavila na hodnotě 15, ale až na hodnotě 19 (více řádků se již
nevytiskne, protože se ROM rutina zastaví a čeká na vstup od uživatele):</p>

<pre>
        xor  A              <i>; hodnota cifry, která se má vytisknout</i>
        ld   B, <strong>20</strong>          <i>; počitadlo smyčky</i>
loop:                       <i>; vytisknout hexa cifru s přechodem na nový řádek</i>
        call print_hex_digit_nl
        inc  A              <i>; zvýšit hodnotu tištěné cifry</i>
        djnz loop           <i>; opakování smyčky se snížením hodnoty počitadla</i>
</pre>

<p>Z&nbsp;výsledků je patrné, že se vypisují další cifry &bdquo;G&ldquo; atd.
až do &bdquo;Z&ldquo;, což vlastně znamená, že máme k&nbsp;dispozici rutinu
platnou pro třiceti šestkovou číselnou soustavu (10 numerických znaků + 26
znaků anglické abecedy):</p>

*** image ***
<p><i>Obrázek 4: Tisk &bdquo;hexadecimálních&ldquo; hodnot odpovídajících
dekadickým hodnotám od 0 do 19. Povšimněte si, že ve skutečnosti máme
k&nbsp;dispozici celou 36 číselnou soustavu.</i></p>

<p><div class="rs-tip-major">Poznámka: řešení představené v&nbsp;dalším textu
již bude jiné a bude skutečně platné pouze pro hexadecimální
soustavu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Úplný zdrojový kód dnešního druhého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/80-print-hex-digit-overflow.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/80-print-hex-digit-overflow.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS        <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        xor  A              <i>; hodnota cifry, která se má vytisknout</i>
        ld   B, 20          <i>; počitadlo smyčky</i>
loop:                       <i>; vytisknout hexa cifru s přechodem na nový řádek</i>
        call print_hex_digit_nl
        inc  A              <i>; zvýšit hodnotu tištěné cifry</i>
        djnz loop           <i>; opakování smyčky se snížením hodnoty počitadla</i>
&nbsp;
        ret                 <i>; návrat z programu do BASICu</i>
&nbsp;
<strong>print_hex_digit_nl</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
&nbsp;
        cp   0x0a           <i>; test, jestli je číslice menší než 10</i>
        jr c, print_0_to_9  <i>; ok, hodnota je menší než 10, budeme tedy tisknout desítkovou číslici</i>
        add  A, 65-10-48    <i>; ASCII kód znaku 'A', ovšem začínáme od desítky, ne od nuly (+ update pro další ADD)</i>
<strong>print_0_to_9</strong>:
        add  A, 48          <i>; ASCII kód znaku '0'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
&nbsp;
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        pop  AF             <i>; obnovit A</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Způsob překladu do strojového kódu je prakticky totožný s&nbsp;příkladem
prvním (a to zcela podle očekávání):</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:AF         XOR A
8004:0614       LD B, 14
8006:           label loop
8006:CD0D80     CALL 800D
8009:3C         INC A
800A:10FA       DJNZ 8006
800C:C9         RET
800D:           label print_hex_digit_nl
800D:F5         PUSH AF
800E:FE0A       CP 0A
8010:3802       JR C, 8014
8012:C607       ADD A, 07
8014:           label print_0_to_9
8014:C630       ADD A, 30
8016:D7         RST 10
8017:           label new_line
8017:3E0D       LD A, 0D
8019:D7         RST 10
801A:F1         POP AF
801B:C9         RET
801C:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 801B
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Využití instrukce <strong>DAA</strong> namísto podmíněného skoku</h2>

<p></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Podrobný popis operací prováděných při převodu hexadecimální cifry na ASCII znak</h2>

<p></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód dnešního třetího demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního třetího demonstračního příkladu je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/81-print-hex-digit-daa.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/81-print-hex-digit-daa.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS        <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        xor  A              <i>; hodnota cifry, která se má vytisknout</i>
        ld   B, 16          <i>; počitadlo smyčky</i>
<strong>loop</strong>:                       <i>; vytisknout hexa cifru s přechodem na nový řádek</i>
        call print_hex_digit_nl
        inc  A              <i>; zvýšit hodnotu tištěné cifry</i>
        djnz loop           <i>; opakování smyčky se snížením hodnoty počitadla</i>
&nbsp;
        ret                 <i>; návrat z programu do BASICu</i>
&nbsp;
<strong>print_hex_digit_nl</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        or   $f0            <i>; nastavit horní čtyři bity + příznaky</i>
                            <i>; nyní je v A jedna z hodnot:</i>
                            <i>;    0xf0 0xf1 0xf2 ... 0xf9 0xfa 0xfb 0xfc 0xfd 0xfe 0xff</i>
        daa                 <i>; desítková korekce pro původní hodnoty A-F</i>
                            <i>; +  0x60 0x60 0x60 ... 0x60 0x66 0x66 0x66 0x66 0x66 0x66</i>
                            <i>; nyní je v A jedna z hodnot:</i>
                            <i>;    0x50 0x51 0x52 ... 0x59 0x60 0x61 0x62 0x63 0x64 0x65</i>
        add A, $a0          <i>; přičtení konstanty</i>
                            <i>; nyní je v A jedna z hodnot:</i>
                            <i>;    0xf0 0xf1 0xf2 ... 0xf9 0x00 0x01 0x02 0x03 0x04 0x05</i>
                            <i>; C    0    0    0        0    1    1    1    1    1    1</i>
        adc A, $40          <i>; přičtení konstanty a navíc i příznaku carry</i>
                            <i>;    0x30 0x31 0x31 ... 0x39 0x41 0x42 0x43 0x44 0x45 0x46</i>
                            <i>; >   '0'  '1'  '2'      '9'  'A'  'B'  'C'  'D'  'E'  'F'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
&nbsp;
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        pop  AF             <i>; obnovit A</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>A pro úplnost se podívejme na způsob překladu výše uvedeného zdrojového kódu
do assembleru:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:AF         XOR A
8004:0610       LD B, 10
8006:           label loop
8006:CD0D80     CALL 800D
8009:3C         INC A
800A:10FA       DJNZ 8006
800C:C9         RET
800D:           label print_hex_digit_nl
800D:F5         PUSH AF
800E:F6F0       OR F0
8010:27         DAA
8011:C6A0       ADD A, A0
8013:CE40       ADC A, 40
8015:D7         RST 10
8016:           label new_line
8016:3E0D       LD A, 0D
8018:D7         RST 10
8019:F1         POP AF
801A:C9         RET
801B:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 801A
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vylepšené vytištění osmibitové hexadecimální hodnoty</h2>

<p></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/82-print-hex-numbers-daa.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/82-print-hex-numbers-daa.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS           <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   HL, numbers       <i>; statické pole s hodnotami, které se mají vytisknout + zarážkou</i>
<strong>loop</strong>:
        ld   A, (HL)           <i>; načíst další hodnotu ze statického pole</i>
        or   A                 <i>; test na nulu</i>
        ret  z                 <i>; návrat z programu do BASICU</i>
        inc  HL                <i>; adresa dalšího prvku v poli</i>
        call print_hex_number  <i>; tisk hexadecimální hodnoty</i>
        call new_line          <i>; s přechodem na nový řádek</i>
        jp   loop              <i>; zpracování další hodnoty</i>
&nbsp;
<strong>numbers</strong>:
        db 0x01, 0x02, 0x09, 0x0a, 0x10, 0x99, 0xa0, 0xaa, 0xaf, 0xf0, 0xff, 0x00
&nbsp;
<strong>print_hex_number</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        rrca                <i>; rotace o čtyři bity doprava</i>
        rrca
        rrca
        rrca
        call print_hex_digit; vytisknout první hexa cifru
&nbsp;
        pop  AF             <i>; obnovit A</i>
                            <i>; vytisknout druhou hexa cifru</i>
&nbsp;
<strong>print_hex_digit</strong>:
        or   $f0            <i>; nastavit horní čtyři bity + příznaky</i>
        daa                 <i>; desítková korekce pro původní hodnoty A-F</i>
        add A, $a0          <i>; přičtení konstanty</i>
        adc A, $40          <i>; přičtení konstanty a navíc i příznaku carry</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>A pro úplnost se opět podívejme na způsob překladu výše uvedeného zdrojového
kódu do assembleru:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:211380     LD HL, 8013
8006:           label loop
8006:7E         LD A, (HL)
8007:B7         OR A
8008:C8         RET Z
8009:23         INC HL
800A:CD1F80     CALL 801F
800D:CD3180     CALL 8031
8010:C30680     JP 8006
8013:           label numbers
8013:0102090A   DEFB of 12 bytes
8017:1099A0AA
801B:AFF0FF00
801F:           label print_hex_number
801F:F5         PUSH AF
8020:0F         RRCA
8021:0F         RRCA
8022:0F         RRCA
8023:0F         RRCA
8024:CD2880     CALL 8028
8027:F1         POP AF
8028:           label print_hex_digit
8028:F6F0       OR F0
802A:27         DAA
802B:C6A0       ADD A, A0
802D:CE40       ADC A, 40
802F:D7         RST 10
8030:C9         RET
8031:           label new_line
8031:3E0D       LD A, 0D
8033:D7         RST 10
8034:C9         RET
8035:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8034
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Reprezentace numerických hodnot ve formátu pevné a plovoucí řádové (binární) tečky</h2>

<p>Ve druhé části dnešního článku si ve stručnosti popíšeme některé ze způsobů
reprezentace (resp.&nbsp;přesněji řečeno způsobu uložení) podmnožiny
racionálních numerických hodnot (zkráceně čísel) v&nbsp;operační paměti
počítače a/nebo v&nbsp;registrech jeho mikroprocesoru (CPU) či matematického
koprocesoru (FPU). Jedná se o uložení vybrané množiny numerických hodnot
v&nbsp;takzvaném systému <i>pevné řádové</i> (typicky binární nebo desetinné)
<i>tečky</i> popř.&nbsp;naopak v&nbsp;systému <i>plovoucí řádové tečky</i>.</p>

<p><div class="rs-tip-major">Poznámka: V&nbsp;tomto textu se ovšem budeme
záměrně dopouštět drobného prohřešku oproti stávající normě českého jazyka,
protože budeme neustále psát o řádové, desetinné a binární <i>tečce</i> a
nikoli o <i>čárce</i> &ndash; z&nbsp;hlediska anglické terminologie to bude
více konzistentní, i když z&nbsp;češtinářského hlediska by bylo zcela jistě
korektnější psát o řádové čárce, protože se v&nbsp;češtině celá část čísla od
části desetinné odděluje právě čárkou a nikoli tečkou, jak je tomu zvykem
v&nbsp;anglosaských zemích (na druhou stranu programátoři, kterým je tento
článek určen především, však tuto skutečnost zcela jistě znají). </div></p>

<p>V&nbsp;anglické literatuře se první zmíněná forma reprezentace číselných
hodnot označuje zkratkou <i>FX</i> nebo <i>FXP</i> (tato zkratka je odvozena od
<i>fixed point</i>), zatímco dnes častěji používaná reprezentace v&nbsp;systému
<i>plovoucí řádové tečky</i> se všeobecně označuje zkratkou <i>FP</i> (odvozeno
od <i>floating point</i>).</p>

<p><div class="rs-tip-major">Poznámka: V&nbsp;jednom článku jsem mimochodem
dokonce místo zkratky <i>FX</i> viděl i zkratku <i>XP</i>, ale to bylo před
mnoha lety, ještě v&nbsp;době Windows 95 :-).</div></p>

<p>Nejprve si vysvětlíme princip obou metod použitých pro ukládání podmnožiny
racionálních čísel a posléze si také řekneme, jaké výhody a nevýhody jednotlivé
principy přináší v&nbsp;každodenní programátorské praxi a ve kterých situacích
je vhodnější použít pevnou řádovou čárku. V&nbsp;dalším textu budeme formát
pevné binární řádové tečky zkracovat na FX formát a formát používající plovoucí
řádovou tečku budeme zapisovat jako FP formát.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vybrané způsoby reprezentace numerických hodnot v&nbsp;operační paměti počítače</h2>

Při ukládání číselných hodnot do operační paměti počítače záhy narazíme na některé problémy, z nichž některé souvisí s konečným počtem bitů, které pro uložení dané hodnoty „obětujeme“, a další vycházejí ze způsobu zpracování hodnot mikroprocesorem či matematickým koprocesorem. V konečném počtu bitů je totiž možné uložit pouze konečné množství různých hodnot a je plně v rukou programátora, jak efektivně daný počet bitů využije či naopak promrhá ukládáním nepodstatných informací. Poměrně často se totiž stává, že i program využívající dvojitou či dokonce rozšířenou přesnost čísel při FP operacích (tj. datové typy double a extended/temporary) dává nesprávné výsledky dané nepochopením principu práce FP aritmetiky a přitom je možné se přesnějších výsledků dobrat i při použití pouhých 32 bitů, ale s pečlivě vyváženými aritmetickými a bitovými operacemi.

Na druhou stranu nejsou dnes používané mikroprocesory tak univerzálními zařízeními, jak by se na první pohled mohlo zdát. Mikroprocesory jsou totiž (většinou) navrženy tak, aby účinně, například v rámci jedné operace či instrukce, zpracovávaly pouze konstantní počet bitů. Příkladem mohou být dnes velmi rozšířené procesory řady x86, které jsou velmi dobré při práci s 32 bitovými hodnotami, ale při požadavku na aritmetické výpočty probíhající na (řekněme) 21 bitech se veškerá jejich efektivita ztrácí a procesor se širokými vnitřními sběrnicemi, matematickým koprocesorem atd. se potýká s prohazováním jednotlivých bitů. Mnohem lepší situace nastane v případě, že se nějaká operace implementuje na programovatelném poli FPGA – zde je možné vytvořit obvody provádějící matematické a logické operace s libovolným počtem bitů, čímž se oproti univerzálním řešením (např. konstantní bitová šířka sběrnice a/nebo registrů) ušetří mnoho plochy těchto velmi zajímavých obvodů (FPGA mohou mimochodem znamenat i velkou šanci pro hnutí open source – pomocí nich by mohlo vznikat, a někde už vzniká open hardware, které by mohlo odstranit závislost na „uzavřených“ síťových a grafických kartách apod.).

Vraťme se však ke způsobům reprezentace číselných hodnot v operační paměti. Nejprve předpokládejme, že pro reprezentaci vlastností určitého objektu či stavu z reálného světa použijeme N binárních číslic (bitů), tj. základních jednotek informace, která může nabývat pouze jedné ze dvou povolených hodnot (ty se značí například symboly yes/no nebo true/false, ale my se budeme spíše držet označení 0 a 1). Pomocí této uspořádané N-tice je možné popsat celkem:

2<sub>0</sub>×2<sub>1</sub>×2<sub>2</sub> … 2<sub>N-1</sub>=2<sup></sup>N

jednoznačných, tj. navzájem odlišných, stavů. Množina těchto stavů může reprezentovat prakticky jakýkoliv abstraktní či reálný objekt. Přitom si musíme uvědomit, že u této množiny není implicitně řečeno ani myšleno, že se jedná například o celá kladná čísla, to je pouze jedna z mnoha možných interpretací zvolené N-tice (my programátoři máme tendenci považovat celá kladná čísla za přirozenou interpretaci bitové N-tice, to však vychází pouze z našeho pohledu na svět a z našich zkušeností). Reprezentaci momentálního stavu abstraktního či reálného objektu si můžeme představit jako zobrazení z množiny binárních stavů na elementy vzorové (a obecně neuspořádané) množiny. Nejčastěji používanými zobrazeními jsou zobrazení množiny binárních stavů na interval celých kladných čísel (Unsigned Integers), popřípadě na interval celých čísel (Signed Integers).



<p><a name="k12"></a></p>
<h2 id="k12">12. Uložení numerických hodnot ve formátu pevné řádové binární tečky</h2>

Numerické hodnoty zapsané ve formátu pevné řádové binární tečky se chápou jako podmnožina racionálních čísel, což jsou taková čísla, jejichž hodnoty lze vyjádřit vztahem:

x<sub>FX</sub>=a/b    a,b leží v Z, b ≠ 0

Číselné hodnoty z uvažované podmnožiny jsou navíc omezeny podmínkou:

b=2<sup>k</sup>    b leží v Z, k leží v Z<sup></sup>+

Protože b je celočíselnou mocninou dvojky (a ne desítky či jiného základu), určuje jeho hodnota n polohu binární tečky v uloženém čísle. Další podmínkou, která má však spíše implementační charakter, je zachování stejného počtu binárních cifer v každém reprezentovaném čísle, což mimo jiné znamená, že všechna čísla mají řádovou binární tečku umístěnou na stejném místě – z této podmínky ostatně plyne i název popisovaného způsobu reprezentace vybrané podmnožiny racionálních čísel. Tak jako i v jiných reprezentacích čísel jsou nulové číslice před první nenulovou cifrou a za poslední nenulovou cifrou nevýznamné, proto je není zapotřebí uvádět.

Prakticky může být číselná hodnota v systému pevné řádové tečky uložena na osmi bitech například následujícím způsobem (uvažujeme pouze kladné hodnoty):

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>

Pozice bitu     8       7       6       5       4       3       2       1
Váha bitu       2<sup>4</sup>   2<sup>3</sup>   2<sup>2</sup>   2<sup>1</sup>   2<sup>0</sup>   2<sup>-1</sup>  2<sup>-2</sup>  2<sup>-</sup>3
Desítková váha bitu     16      8       4       2       1       0,5     0,25    0,12

<p><div class="rs-tip-major">Poznámka: pochopitelně se jedná pouze o jednu konkrétní vybranou reprezentaci, protože je to programátor, který určuje, na kterém místě se řádová tečka nachází. Její pozice totiž není součástí vlastní hodnoty, ale je &bdquo;zadrátována&ldquo; v&nbsp;algoritmech, které numerické hodnoty zpracovávají (součet, součin, CORDIC atd. atd.). Výběr pozice řádové tečky závisí především na tom, které hodnoty je zapotřebí reprezentovat a jaké ztráty přesnosti jsme ochotni akceptovat.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úplný zdrojový kód dnešního pátého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního pátého a současně i posledního demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/83-print-fp-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/83-print-fp-numbers.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
PRINT_FP      equ $2DE3
STK_STORE     equ $2AB6
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS           <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld IX, fp0             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp1             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp2             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp3             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp4             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp5             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp6             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ret
&nbsp;
<i>;         mantisa+128  s  exponent</i>
<strong>fp0</strong>:    db %00000000, %00000000, %00000000, %00000000, %00000000
<strong>fp1</strong>:    db %10000000, %00000000, %00000000, %00000000, %00000000
<strong>fp2</strong>:    db %10000000, %10000000, %00000000, %00000000, %00000000
<strong>fp3</strong>:    db %10000000, %01000000, %00000000, %00000000, %00000000
<strong>fp4</strong>:    db %10000001, %01000000, %00000000, %00000000, %00000000
<strong>fp5</strong>:    db %10000001, %01000000, %00000000, %00000001, %00000000
<strong>fp6</strong>:    db %10000001, %00111111, %11111111, %11111111, %00000000
&nbsp;
&nbsp;
<strong>print_fp_number</strong>:
        <i>; A  první bajt</i>
        <i>; B  pátý byte</i>
        <i>; C  čtvrtý byte</i>
        <i>; D  třetí byte</i>
        <i>; E  druhý bajt</i>
        ld   A, (IX)
        ld   E, (IX+1)
        ld   D, (IX+2)
        ld   C, (IX+3)
        ld   B, (IX+4)
        call STK_STORE      <i>; uložit FP hodnotu na zásobník</i>
        call PRINT_FP       <i>; vytisknout FP hodnotu uloženou na vrcholu zásobníku</i>
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Překlad do assembleru:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
PRINT_FP        EQU 2DE3
STK_STORE       EQU 2AB6
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:DD213580   LD IX, 8035
8007:CD5880     CALL 8058
800A:DD213A80   LD IX, 803A
800E:CD5880     CALL 8058
8011:DD213F80   LD IX, 803F
8015:CD5880     CALL 8058
8018:DD214480   LD IX, 8044
801C:CD5880     CALL 8058
801F:DD214980   LD IX, 8049
8023:CD5880     CALL 8058
8026:DD214E80   LD IX, 804E
802A:CD5880     CALL 8058
802D:DD215380   LD IX, 8053
8031:CD5880     CALL 8058
8034:C9         RET
8035:           label fp0
8035:00000000   DEFB of 5 bytes
8039:00
803A:           label fp1
803A:80000000   DEFB of 5 bytes
803E:00
803F:           label fp2
803F:80800000   DEFB of 5 bytes
8043:00
8044:           label fp3
8044:80400000   DEFB of 5 bytes
8048:00
8049:           label fp4
8049:81400000   DEFB of 5 bytes
804D:00
804E:           label fp5
804E:81400001   DEFB of 5 bytes
8052:00
8053:           label fp6
8053:813FFFFF   DEFB of 5 bytes
8057:00
8058:           label print_fp_number
8058:DD7E00     LD A, (IX+00)
805B:DD5E01     LD E, (IX+01)
805E:DD5602     LD D, (IX+02)
8061:DD4E03     LD C, (IX+03)
8064:DD4604     LD B, (IX+04)
8067:CDB62A     CALL 2AB6
806A:CDE32D     CALL 2DE3
806D:           label new_line
806D:3E0D       LD A, 0D
806F:D7         RST 10
8070:C9         RET
8071:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8070
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<pre>
ASSEMBLER := pasmo

all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap \
    31.tap 32.tap 33.tap 34.tap 35.tap 36.tap 37.tap 38.tap 39.tap 40.tap \
    41.tap 42.tap 43.tap 44.tap 45.tap 46.tap 47.tap 48.tap 49.tap 50.tap \
    51.tap 52.tap 53.tap 54.tap 55.tap 56.tap 57.tap 58.tap 59.tap 60.tap \
    61.tap 62.tap 63.tap 64.tap 65.tap 66.tap 67.tap 68.tap 69.tap 70.tap \
    71.tap 72.tap 73.tap 74.tap 75.tap 76.tap 77.tap 78.tap 79.tap 80.tap \
    81.tap 82.tap 83.tap

clean:
        rm -f *.tap

.PHONY: all clean


01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $< $@ > 01-color-attribute.lst

02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $< $@ > 02-blinking-attribute.lst

03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $< $@ > 03-symbolic-names.lst

04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $< $@ > 04-operators.lst

05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $< $@ > 05-better-symbols.lst

06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 06-tapbas-v1.lst

07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 07-tapbas-v2.lst

08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 08-loop.lst

09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 09-loop.lst

10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 10-loop.lst

11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 11-loop.lst

12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 12-loop.lst

13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 13-loop.lst

14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 14-loop.lst

15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 15-loop.lst

16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 16-loop.lst

17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 17-loop.lst

18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 18-cls.lst

19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 19-print-char-call.lst

20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 20-print-char-rst.lst

21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 21-print-char.lst

22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 22-print-all-chars.lst

23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 23-print-all-chars.lst

24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 24-change-color.lst

25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 25-change-flash.lst

26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 26-print-at.lst

27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 27-print-string.lst

28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 28-print-string.lst

29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 29-print-colorized-string.lst

30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 30-print-string-ROM.lst

31.tap: 31-attributes.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 31-attributes.lst

32.tap: 32-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 32-fill-in-vram.lst

33.tap: 33-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 33-fill-in-vram-no-ret.lst

34.tap: 34-fill-in-vram-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 34-fill-in-vram-pattern.lst

35.tap: 35-slow-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 35-slow-fill-in-vram.lst

36.tap: 36-slow-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 36-slow-fill-in-vram-no-ret.lst

37.tap: 37-fill-block.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 37-fill-block.lst

38.tap: 38-fill-block-with-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 38-fill-block-with-pattern.lst

39.tap: 39-fill-block-optimized.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 39-fill-block-optimized.lst

40.tap: 40-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 40-draw-char.lst

41.tap: 41-draw-any-char.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 41-draw-any-char.lst

42.tap: 42-block-anywhere.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 42-block-anywhere.lst

43.tap: 43-block-anywhere-rrca.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 43-block-anywhere-rrca.lst

44.tap: 44-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 44-better-draw-char.lst

45.tap: 45-even-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 45-even-better-draw-char.lst

46.tap: 46-draw-char-at.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 46-draw-char-at.lst

47.tap: 47-draw-char-at-unrolled.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 47-draw-char-at-unrolled.lst

48.tap: 48-incorrect-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 48-incorrect-print-string.lst

49.tap: 49-correct-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 49-correct-print-string.lst

50.tap: 50-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 50-ascii-table.lst

51.tap: 51-plot-block.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 51-plot-block.lst

52.tap: 52-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 52-plot-pixel.lst

53.tap: 53-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 53-plot-pixel.lst

54.tap: 54-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 54-plot-pixel-on-background.lst

55.tap: 55-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 55-plot-pixel-on-background.lst

56.tap: 56-inverse-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 56-inverse-ascii-table.lst

57.tap: 57-plot-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 57-plot-pixel-on-inverse-background.lst

58.tap: 58-plot-inverse-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 58-plot-inverse-pixel-on-inverse-background.lst

59.tap: 59-configurable-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 59-configurable-ascii-table.lst

60.tap: 60-plot-over.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 60-plot-over.lst

61.tap: 61-print-number-A.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 61-print-number-A.lst

62.tap: 62-print-number-B.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 62-print-number-B.lst

63.tap: 63-print-number-C.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 63-print-number-C.lst

64.tap: 64-print-number-D.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 64-print-number-D.lst

65.tap: 65-more-numbers-A.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 65-more-numbers-A.lst

66.tap: 66-more-numbers-B.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 66-more-numbers-B.lst

67.tap: 67-print-flags-1.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 67-print-flags-1.lst

68.tap: 68-print-flags-2.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 68-print-flags-2.lst

69.tap: 69-print-flags-3.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 69-print-flags-3.lst

70.tap: 70-print-flags-4.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 70-print-flags-4.lst

71.tap: 71-print-flags-5.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 71-print-flags-5.lst

72.tap: 72-print-flags-6.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 72-print-flags-6.lst

73.tap: 73-print-flags-7.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 73-print-flags-7.lst

74.tap: 74-print-hex-number.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 74-print-hex-number.lst

75.tap: 75-print-hex-number.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 75-print-hex-number.lst

76.tap: 76-print-hex-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 76-print-hex-numbers.lst

77.tap: 77-add-hex-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 77-add-hex-numbers.lst

78.tap: 78-add-bcd-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 78-add-bcd-numbers.lst

79.tap: 79-print-hex-digit-jmp.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 79-print-hex-digit-jmp.lst

80.tap: 80-print-hex-digit-overflow.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 80-print-hex-digit-overflow.lst

81.tap: 81-print-hex-digit-daa.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 81-print-hex-digit-daa.lst

82.tap: 82-print-hex-numbers-daa.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 82-print-hex-numbers-daa.lst

83.tap: 83-print-fp-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $< $@ > 83-print-fp-numbers.lst
</pre>


<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>31-attributes.asm</td><td>modifikace atributů pro tisk řetězce subrutinou uloženou v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a></td></tr>
<tr><td>32</td><td>32-fill-in-vram.asm</td><td>vyplnění celé bitmapy barvou popředí, návrat do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a></td></tr>
<tr><td>33</td><td>33-fill-in-vram-no-ret.asm</td><td>vyplnění celé bitmapy barvou popředí, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>34</td><td>34-fill-in-vram-pattern.asm</td><td>vyplnění celé bitmapy zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a></td></tr>
<tr><td>35</td><td>35-slow-fill-in-vram.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a></td></tr>
<tr><td>36</td><td>36-slow-fill-in-vram-no-ret.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>37</td><td>37-fill-block.asm</td><td>vykreslení bloku 8&times;8 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a></td></tr>
<tr><td>38</td><td>38-fill-block-with-pattern.asm</td><td>vykreslení bloku 8&times;8 pixelů zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a></td></tr>
<tr><td>39</td><td>39-fill-block-optimized.asm</td><td>optimalizace předchozího příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a></td></tr>
<tr><td>40</td><td>40-draw-char.asm</td><td>vykreslení znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a></td></tr>
<tr><td>41</td><td>41-draw-any-char.asm</td><td>podprogram pro vykreslení libovolně zvoleného znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a></td></tr>
<tr><td>42</td><td>42-block-anywhere.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>43-block-anywhere-rrca.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm</a></td></tr>
<tr><td>44</td><td>44-better-draw-char.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm</a></td></tr>
<tr><td>45</td><td>45-even-better-draw-char.asm</td><td>posun offsetu pro vykreslení dalšího znaku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm</a></td></tr>
<tr><td>46</td><td>46-draw-char-at.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm</a></td></tr>
<tr><td>47</td><td>47-draw-char-at-unrolled.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm</a></td></tr>
<tr><td>48</td><td>48-incorrect-print-string.asm</td><td>tisk řetězce, nekorektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm</a></td></tr>
<tr><td>49</td><td>49-correct-print-string.asm</td><td>tisk řetězce, korektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>50-ascii-table.asm</td><td>tisk několika bloků ASCII tabulky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm</a></td></tr>
<tr><td>51</td><td>51-plot-block.asm</td><td>vykreslení pixelu verze 1: zápis celého bajtu na pozici pixelu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm</a></td></tr>
<tr><td>52</td><td>52-plot-pixel.asm</td><td>vykreslení pixelu verze 2: korektní vykreslení jednoho pixelu, ovšem překreslení celého bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Survey of Floating-Point Formats  <br />
<a href="http://mrob.com/pub/math/floatformats.html">http://mrob.com/pub/math/floatformats.html</a>
</li>

<li>Z80 heaven: Floating Point<br />
<a href="http://z80-heaven.wikidot.com/floating-point">http://z80-heaven.wikidot.com/floating-point</a>
</li>

<li>Z80, the 8-bit Number Cruncher<br />
<a href="http://www.andreadrian.de/oldcpu/Z80_number_cruncher.html">http://www.andreadrian.de/oldcpu/Z80_number_cruncher.html</a>
</li>

<li>Floating-point library for Z80<br />
<a href="https://github.com/DW0RKiN/Floating-point-Library-for-Z80">https://github.com/DW0RKiN/Floating-point-Library-for-Z80</a>
</li>

<li>z80float<br />
<a href="https://github.com/Zeda/z80float">https://github.com/Zeda/z80float</a>
</li>

<li>Fixed point arithmetic<br />
<a href="https://www.root.cz/clanky/fixed-point-arithmetic/">https://www.root.cz/clanky/fixed-point-arithmetic/</a>
</li>

<li>ZX Spectrum BASIC Programming - 2nd Edition<br />
<a href="https://archive.org/details/zx-spectrum-basic-programming/page/n167/mode/2up">https://archive.org/details/zx-spectrum-basic-programming/page/n167/mode/2up</a>
</li>

<li>ZX Spectrum BASIC Programming - 2nd Edition<br />
<a href="https://archive.org/details/zx-spectrum-basic-programming/page/n169/mode/2up">https://archive.org/details/zx-spectrum-basic-programming/page/n169/mode/2up</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

