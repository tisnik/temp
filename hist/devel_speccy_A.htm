<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Tisk hexadecimálních hodnot s využitím instrukce DAA, hodnoty s plovoucí řádovou čárkou na ZX Spectru</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Tisk hexadecimálních hodnot s využitím instrukce DAA, hodnoty s plovoucí řádovou čárkou na ZX Spectru</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnešní článek o vývoji programů pro legendární osmibitový domácí mikropočítač ZX Spectrum je rozdělen na dvě části. V úvodní části si ukážeme využití instrukce DAA při tisku hexadecimálních hodnot a v části druhé se seznámíme se základy zpracování hodnot s plovoucí řádovou čárkou.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Tisk hexadecimálních hodnot podruhé</a></p>
<p><a href="#k02">2. Úplný zdrojový kód dnešního prvního demonstračního příkladu</a></p>
<p><a href="#k03">3. Malá odbočka: přetečení hodnoty cifry</a></p>
<p><a href="#k04">4. Úplný zdrojový kód dnešního druhého demonstračního příkladu</a></p>
<p><a href="#k05">5. Využití instrukce <strong>DAA</strong> namísto podmíněného skoku</a></p>
<p><a href="#k06">6. Podrobný popis operací prováděných při převodu hexadecimální cifry na ASCII znak</a></p>
<p><a href="#k07">7. Úplný zdrojový kód dnešního třetího demonstračního příkladu</a></p>
<p><a href="#k08">8. Vylepšené vytištění osmibitové hexadecimální hodnoty</a></p>
<p><a href="#k09">9. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</a></p>
<p><a href="#k10">10. Reprezentace numerických hodnot ve formátu pevné a plovoucí řádové (binární) tečky</a></p>
<p><a href="#k11">11. Vybrané způsoby reprezentace numerických hodnot v&nbsp;operační paměti počítače</a></p>
<p><a href="#k12">12. Uložení numerických hodnot ve formátu pevné řádové binární tečky</a></p>
<p><a href="#k13">13. Přednosti a zápory formátu pevné řádové tečky</a></p>
<p><a href="#k14">14. Uložení čísel ve formátu plovoucí řádové (binární) tečky</a></p>
<p><a href="#k15">15. Formát uložení FP hodnot na ZX Spectru</a></p>
<p><a href="#k16">16. Zásobník FP hodnot na ZX Spectru, subrutina pro tisk FP hodnot</a></p>
<p><a href="#k17">17. Úplný zdrojový kód dnešního pátého demonstračního příkladu</a></p>
<p><a href="#k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Tisk hexadecimálních hodnot podruhé</h2>

<p>V&nbsp;dnešním článku si nejprve ukážeme trik pro tisk hexadecimálních
hodnot. Tento trik je založen na instrukci <strong>DAA</strong> a osmibitové
aritmetice. A posléze se zaměříme na zcela odlišnou oblast &ndash; jak se dá
pracovat s&nbsp;numerickými hodnotami reprezentovanými v&nbsp;systému pevné i
plovoucí řádové tečky (<i>fixed point, floating point</i>).</p>

<p>Zaměřme se nyní na způsob zobrazení jediné hexadecimální cifry,
tj.&nbsp;znaku &bdquo;0&ldquo;, &bdquo;1&ldquo;,... &bdquo;9&ldquo;,
&bdquo;A&ldquo; ... &bdquo;F&ldquo;. Úloha je to vlastně velmi snadná: na
vstupu budeme mít hodnotu 0 až 15 uloženou v&nbsp;akumulátoru
<strong>A</strong> a výsledkem má být jeden z&nbsp;výše zmíněných znaků
vytisknutých na obrazovku ZX Spectra. Znaky pro tisk se přitom pochopitelně
vybírají z&nbsp;ASCII tabulky resp.&nbsp;přesněji řečeno z&nbsp;její
&bdquo;spektrácké&ldquo; verze, která vypadá následovně:</p>

*** image ***
<p><i>Obrázek 1: &bdquo;Spektrácká&ldquo; verze ASCII tabulky (zobrazeny jsou
jen tisknutelné znaky).</i></p>

<p>Jediný problém spočívá v&nbsp;tom, že převod hodnoty 0 až 15 na kód znaku
není zcela přímočarý, protože znaky jsou <a
href="https://en.wikipedia.org/wiki/ASCII#/media/File:USASCII_code_chart.png">v&nbsp;ASCII
kódu</a> uspořádány takovým způsobem, že se mezi znakem &bdquo;9&ldquo; a
znakem &bdquo;A&ldquo; nachází sedm jiných znaků, konkrétně znaky
&bdquo;:&ldquo;, &bdquo;;&ldquo;, &bdquo;&lt;&ldquo;, &bdquo;=&ldquo;,
&bdquo;&gt;&ldquo;, &bdquo;?&ldquo; a &bdquo;@&ldquo;:</p>

*** image ***
<p><i>Obrázek 2: Hexadecimální cifry nejsou v&nbsp;ASCII umístěny za
sebou.</i></p>

<p>K&nbsp;dispozici jsou tři rozumná řešení:</p>

<ol>
<li>Použití převodní tabulky (ovšem ztratíme šestnáct bajtů RAM + další bajty pro kód)</li>
<li>Použití podmínky + skoku, který řeší &bdquo;mezeru&ldquo;</li>
<li>Aritmetické triky zajišťující, že se pro hodnoty vyšší než 9 provede operace +7</li>
</ol>

<p>Druhý způsob už jsme si ukázali minule, ale pro jistotu si ho ještě
zopakujme. Princip je jednoduchý &ndash; vypočteme ASCII hodnotu znaku tak,
jakoby byly všechny cifry umístěny za sebou a posléze provedeme úpravu +7 pro
cifry s&nbsp;hodnotou vyšší než 9:</p>

<pre>
<strong>print_hex_digit_nl</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
&nbsp;
        cp   0x0a           <i>; test, jestli je číslice menší než 10</i>
        jr c, print_0_to_9  <i>; ok, hodnota je menší než 10, budeme tedy tisknout desítkovou číslici</i>
        add  A, 65-10-48    <i>; ASCII kód znaku 'A', ovšem začínáme od desítky, ne od nuly (+ update pro další ADD)</i>
<strong>print_0_to_9</strong>:
        add  A, 48          <i>; ASCII kód znaku '0'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
&nbsp;
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        pop  AF             <i>; obnovit A</i>
        ret                 <i>; návrat ze subrutiny</i>
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Úplný zdrojový kód dnešního prvního demonstračního příkladu</h2>

<p>Výše uvedený kód je použit pro tisk těchto hodnot:</p>

*** image ***
<p><i>Obrázek 3: Hexadecimální cifry vypočtené a zobrazené dnešním prvním
demonstračním příkladem.</i></p>

<p>Úplný zdrojový kód demonstračního příkladu popsaného <a
href="#k01">v&nbsp;úvodní kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/79-print-hex-digit-jmp.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/79-print-hex-digit-jmp.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS        <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        xor  A              <i>; hodnota cifry, která se má vytisknout</i>
        ld   B, 16          <i>; počitadlo smyčky</i>
loop:                       <i>; vytisknout hexa cifru s přechodem na nový řádek</i>
        call print_hex_digit_nl
        inc  A              <i>; zvýšit hodnotu tištěné cifry</i>
        djnz loop           <i>; opakování smyčky se snížením hodnoty počitadla</i>
&nbsp;
        ret                 <i>; návrat z programu do BASICu</i>
&nbsp;
<strong>print_hex_digit_nl</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
&nbsp;
        cp   0x0a           <i>; test, jestli je číslice menší než 10</i>
        jr c, print_0_to_9  <i>; ok, hodnota je menší než 10, budeme tedy tisknout desítkovou číslici</i>
        add  A, 65-10-48    <i>; ASCII kód znaku 'A', ovšem začínáme od desítky, ne od nuly (+ update pro další ADD)</i>
<strong>print_0_to_9</strong>:
        add  A, 48          <i>; ASCII kód znaku '0'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
&nbsp;
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        pop  AF             <i>; obnovit A</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Samozřejmě si opět pro úplnost ukážeme, jak byl tento zdrojový text přeložen
do strojového kódu:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:AF         XOR A
8004:0610       LD B, 10
8006:           label loop
8006:CD0D80     CALL 800D
8009:3C         INC A
800A:10FA       DJNZ 8006
800C:C9         RET
800D:           label print_hex_digit_nl
800D:F5         PUSH AF
800E:FE0A       CP 0A
8010:3802       JR C, 8014
8012:C607       ADD A, 07
8014:           label print_0_to_9
8014:C630       ADD A, 30
8016:D7         RST 10
8017:           label new_line
8017:3E0D       LD A, 0D
8019:D7         RST 10
801A:F1         POP AF
801B:C9         RET
801C:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 801B
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Malá odbočka: přetečení hodnoty cifry</h2>

<p>Zajímavé bude si vyzkoušet, co se stane ve chvíli, kdy se pokusíme o převod
a vytištění dekadické hodnoty větší než 15. Velmi snadno si můžeme upravit
počítanou programovou smyčku v&nbsp;předchozím příkladu takovým způsobem, aby
se smyčka nezastavila na hodnotě 15, ale až na hodnotě 19 (více řádků se již
nevytiskne, protože se ROM rutina zastaví a čeká na vstup od uživatele):</p>

<pre>
        xor  A              <i>; hodnota cifry, která se má vytisknout</i>
        ld   B, <strong>20</strong>          <i>; počitadlo smyčky</i>
loop:                       <i>; vytisknout hexa cifru s přechodem na nový řádek</i>
        call print_hex_digit_nl
        inc  A              <i>; zvýšit hodnotu tištěné cifry</i>
        djnz loop           <i>; opakování smyčky se snížením hodnoty počitadla</i>
</pre>

<p>Z&nbsp;výsledků je patrné, že se vypisují další cifry &bdquo;G&ldquo; atd.
až do &bdquo;Z&ldquo;, což vlastně znamená, že máme k&nbsp;dispozici rutinu
platnou pro třiceti šestkovou číselnou soustavu (10 numerických znaků + 26
znaků anglické abecedy):</p>

*** image ***
<p><i>Obrázek 4: Tisk &bdquo;hexadecimálních&ldquo; hodnot odpovídajících
dekadickým hodnotám od 0 do 19. Povšimněte si, že ve skutečnosti máme
k&nbsp;dispozici celou 36 číselnou soustavu.</i></p>

<p><div class="rs-tip-major">Poznámka: řešení představené v&nbsp;dalším textu
již bude jiné a bude skutečně platné pouze pro hexadecimální
soustavu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Úplný zdrojový kód dnešního druhého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/80-print-hex-digit-overflow.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/80-print-hex-digit-overflow.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS        <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        xor  A              <i>; hodnota cifry, která se má vytisknout</i>
        ld   B, 20          <i>; počitadlo smyčky</i>
loop:                       <i>; vytisknout hexa cifru s přechodem na nový řádek</i>
        call print_hex_digit_nl
        inc  A              <i>; zvýšit hodnotu tištěné cifry</i>
        djnz loop           <i>; opakování smyčky se snížením hodnoty počitadla</i>
&nbsp;
        ret                 <i>; návrat z programu do BASICu</i>
&nbsp;
<strong>print_hex_digit_nl</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
&nbsp;
        cp   0x0a           <i>; test, jestli je číslice menší než 10</i>
        jr c, print_0_to_9  <i>; ok, hodnota je menší než 10, budeme tedy tisknout desítkovou číslici</i>
        add  A, 65-10-48    <i>; ASCII kód znaku 'A', ovšem začínáme od desítky, ne od nuly (+ update pro další ADD)</i>
<strong>print_0_to_9</strong>:
        add  A, 48          <i>; ASCII kód znaku '0'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
&nbsp;
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        pop  AF             <i>; obnovit A</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Způsob překladu do strojového kódu je prakticky totožný s&nbsp;příkladem
prvním (a to zcela podle očekávání):</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:AF         XOR A
8004:0614       LD B, 14
8006:           label loop
8006:CD0D80     CALL 800D
8009:3C         INC A
800A:10FA       DJNZ 8006
800C:C9         RET
800D:           label print_hex_digit_nl
800D:F5         PUSH AF
800E:FE0A       CP 0A
8010:3802       JR C, 8014
8012:C607       ADD A, 07
8014:           label print_0_to_9
8014:C630       ADD A, 30
8016:D7         RST 10
8017:           label new_line
8017:3E0D       LD A, 0D
8019:D7         RST 10
801A:F1         POP AF
801B:C9         RET
801C:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 801B
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Využití instrukce <strong>DAA</strong> namísto podmíněného skoku</h2>

<p>Víme již, že problém, který řešíme, je následující: pro hodnoty větší než 9
musíme ASCII hodnotu příslušného znaku vypočítat posunutou o sedm pozic,
protože takovým způsobem je uspořádána ASCII tabulka. Řešení spočívá
v&nbsp;&bdquo;chytrém&ldquo; použití instrukce <strong>DAA</strong>, která nám
umožní automaticky (bez nutnosti použití podmíněného skoku) zvýšit hodnotu o 6.
Zbývá nám pouze zajistit přičtení jedničky. K&nbsp;tomu slouží instrukce
<strong>ADC</strong>, pro přičtení konstanty a případného přenosu
(<i>carry</i>):</p>

<pre>
<strong>print_hex_digit_nl</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        or   $f0            <i>; nastavit horní čtyři bity + příznaky</i>
                            <i>; nyní je v A jedna z hodnot:</i>
                            <i>;    0xf0 0xf1 0xf2 ... 0xf9 0xfa 0xfb 0xfc 0xfd 0xfe 0xff</i>
        daa                 <i>; desítková korekce pro původní hodnoty A-F</i>
                            <i>; +  0x60 0x60 0x60 ... 0x60 0x66 0x66 0x66 0x66 0x66 0x66</i>
                            <i>; nyní je v A jedna z hodnot:</i>
                            <i>;    0x50 0x51 0x52 ... 0x59 0x60 0x61 0x62 0x63 0x64 0x65</i>
        add A, $a0          <i>; přičtení konstanty</i>
                            <i>; nyní je v A jedna z hodnot:</i>
                            <i>;    0xf0 0xf1 0xf2 ... 0xf9 0x00 0x01 0x02 0x03 0x04 0x05</i>
                            <i>; C    0    0    0        0    1    1    1    1    1    1</i>
        adc A, $40          <i>; přičtení konstanty a navíc i příznaku carry</i>
                            <i>;    0x30 0x31 0x31 ... 0x39 0x41 0x42 0x43 0x44 0x45 0x46</i>
                            <i>; >   '0'  '1'  '2'      '9'  'A'  'B'  'C'  'D'  'E'  'F'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Podrobný popis operací prováděných při převodu hexadecimální cifry na ASCII znak</h2>

<p>Výše uvedený kód provádí jak převod cifry na ASCII znak, tak i úpravu +7,
tedy přeskočení těchto znaků:</p>

*** image ***
<p><i>Obrázek 5: Sedmice znaků v&nbsp;ASCII tabulce, které je nutné
přeskočit.</i></p>

<p>Pojďme si nyní podrobněji popsat jednotlivé fáze výpočtu. Nejprve se
pokusíme o převod hodnoty (cifry) 0, ovšem naprosto stejný popis bude platný i
pro cifry od 1 do 9 (hodnoty jsou vždy uložené v&nbsp;akumulátoru a znak dolaru
značí hexadecimální hodnotu):</p>

<table>
<tr><th>Hodnota před instrukcí</th><th>Instrukce</th><th>Provedená operace</th><th>Hodnota po instrukci</th><th>Carry</th><th>Stručný popis</th></tr>
<tr><td>$00</td><td>or $f0</td><td>or $f0</td><td>$f0</td><td>0</td><td>nastavit horní čtyři bity</td></tr>
<tr><td>$f0</td><td>daa</td><td>$f0+$60</td><td>$50</td><td>1</td><td>desítková korekce pro horní čtyři bity (dolní jsou stále nulové)</td></tr>
<tr><td>$50</td><td>add A, $a0</td><td>$50+$a0</td><td>$f0</td><td>0</td><td>přičtení takové hodnoty, aby se <strong>nenastavil</strong> <i>carry</i></td></tr>
<tr><td>$f0</td><td>adc A, $40</td><td>$f0+$40+0</td><td>$30</td><td>1</td><td>hodnota $30 skutečně odpovídá znaku &bdquo;0&ldquo;</td></tr>
</table>

<p>Naproti tomu výpočet pro cifry A až F bude naprosto odlišný. Ukažme si to na
hodnotě 0x0a (resp.&nbsp;kvůli větší konzistenci $0a):</p>

<table>
<tr><th>Hodnota před instrukcí</th><th>Instrukce</th><th>Provedená operace</th><th>Hodnota po instrukci</th><th>Carry</th><th>Stručný popis</th></tr>
<tr><td>$0a</td><td>or $f0</td><td>or $f0</td><td>$fa</td><td>0</td><td>nastavit horní čtyři bity</td></tr>
<tr><td>$fa</td><td>daa</td><td>$fa+$66</td><td>$60</td><td>1</td><td>desítková korekce pro horní i dolní čtyři bity (kýžené přičtení +6)</td></tr>
<tr><td>$60</td><td>add A, $a0</td><td>$60+$a0</td><td>$00</td><td>1</td><td>přičtení takové hodnoty, aby se <strong>nastavil</strong> <i>carry</i> (kýžené přičtení +1)</td></tr>
<tr><td>$00</td><td>adc A, $40</td><td>$00+$40+1</td><td>$41</td><td>0</td><td>hodnota $41 skutečně odpovídá znaku &bdquo;A&ldquo;</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: a pak že programování v&nbsp;assembleru
není krásné a elegantní.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód dnešního třetího demonstračního příkladu</h2>

<p>Výše uvedený kód můžeme bez dalších úprav použít pro tisk hexadecimálních
cifer 0 až F:</p>

*** image ***
<p><i>Obrázek 6: Cifry 0 až F vytištěné demonstračním příkladem.</i></p>

<p>Úplný zdrojový kód dnešního třetího demonstračního příkladu je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/81-print-hex-digit-daa.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/81-print-hex-digit-daa.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS        <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        xor  A              <i>; hodnota cifry, která se má vytisknout</i>
        ld   B, 16          <i>; počitadlo smyčky</i>
<strong>loop</strong>:                       <i>; vytisknout hexa cifru s přechodem na nový řádek</i>
        call print_hex_digit_nl
        inc  A              <i>; zvýšit hodnotu tištěné cifry</i>
        djnz loop           <i>; opakování smyčky se snížením hodnoty počitadla</i>
&nbsp;
        ret                 <i>; návrat z programu do BASICu</i>
&nbsp;
<strong>print_hex_digit_nl</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        or   $f0            <i>; nastavit horní čtyři bity + příznaky</i>
                            <i>; nyní je v A jedna z hodnot:</i>
                            <i>;    0xf0 0xf1 0xf2 ... 0xf9 0xfa 0xfb 0xfc 0xfd 0xfe 0xff</i>
        daa                 <i>; desítková korekce pro původní hodnoty A-F</i>
                            <i>; +  0x60 0x60 0x60 ... 0x60 0x66 0x66 0x66 0x66 0x66 0x66</i>
                            <i>; nyní je v A jedna z hodnot:</i>
                            <i>;    0x50 0x51 0x52 ... 0x59 0x60 0x61 0x62 0x63 0x64 0x65</i>
        add A, $a0          <i>; přičtení konstanty</i>
                            <i>; nyní je v A jedna z hodnot:</i>
                            <i>;    0xf0 0xf1 0xf2 ... 0xf9 0x00 0x01 0x02 0x03 0x04 0x05</i>
                            <i>; C    0    0    0        0    1    1    1    1    1    1</i>
        adc A, $40          <i>; přičtení konstanty a navíc i příznaku carry</i>
                            <i>;    0x30 0x31 0x31 ... 0x39 0x41 0x42 0x43 0x44 0x45 0x46</i>
                            <i>; >   '0'  '1'  '2'      '9'  'A'  'B'  'C'  'D'  'E'  'F'</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
&nbsp;
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        pop  AF             <i>; obnovit A</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>A pro úplnost se podívejme na způsob překladu výše uvedeného zdrojového kódu
do assembleru:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:AF         XOR A
8004:0610       LD B, 10
8006:           label loop
8006:CD0D80     CALL 800D
8009:3C         INC A
800A:10FA       DJNZ 8006
800C:C9         RET
800D:           label print_hex_digit_nl
800D:F5         PUSH AF
800E:F6F0       OR F0
8010:27         DAA
8011:C6A0       ADD A, A0
8013:CE40       ADC A, 40
8015:D7         RST 10
8016:           label new_line
8016:3E0D       LD A, 0D
8018:D7         RST 10
8019:F1         POP AF
801A:C9         RET
801B:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 801A
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vylepšené vytištění osmibitové hexadecimální hodnoty</h2>

<p>Nyní, když již známe způsob efektivního převodu jedné hexadecimální cifry na
ASCII znak, můžeme upravit původní demonstrační příklad, který tiskne
osmibitovou hexadecimální hodnotu na obrazovku (a tedy dvě cifry). Nejprve se
vytiskne vyšší cifra, poté cifra nižší. Povšimněte si, že podprogram
<strong>print_hex_digit</strong> se volá jen jedenkrát &ndash; a to pro vyšší
cifru. Pro nižší cifru není volání implementováno, protože podprogram
<strong>print_hex_digit</strong> je umístěn přímo za
<strong>print_hex_number</strong>, jak správně <a
href="https://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ulozenymi-binarne-i-ve-formatu-bcd/nazory/1114171/">upozornil
kolega <strong>_dw</strong></a>:</p>

<pre>
<strong>print_hex_number</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        rrca                <i>; rotace o čtyři bity doprava</i>
        rrca
        rrca
        rrca
        call print_hex_digit<i>; vytisknout první hexa cifru</i>
&nbsp;
        pop  AF             <i>; obnovit A</i>
                            <i>; vytisknout druhou hexa cifru</i>
&nbsp;
<strong>print_hex_digit</strong>:
        or   $f0            <i>; nastavit horní čtyři bity + příznaky</i>
        daa                 <i>; desítková korekce pro původní hodnoty A-F</i>
        add A, $a0          <i>; přičtení konstanty</i>
        adc A, $40          <i>; přičtení konstanty a navíc i příznaku carry</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
        ret                 <i>; návrat ze subrutiny</i>
</pre>

<p>Výsledek bude vypadat následovně:</p>

*** image ***
<p><i>Obrázek 7: Několik osmibitových hexadecimálních hodnot vytištěných touto
subrutinou.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/82-print-hex-numbers-daa.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/82-print-hex-numbers-daa.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS           <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   HL, numbers       <i>; statické pole s hodnotami, které se mají vytisknout + zarážkou</i>
<strong>loop</strong>:
        ld   A, (HL)           <i>; načíst další hodnotu ze statického pole</i>
        or   A                 <i>; test na nulu</i>
        ret  z                 <i>; návrat z programu do BASICU</i>
        inc  HL                <i>; adresa dalšího prvku v poli</i>
        call print_hex_number  <i>; tisk hexadecimální hodnoty</i>
        call new_line          <i>; s přechodem na nový řádek</i>
        jp   loop              <i>; zpracování další hodnoty</i>
&nbsp;
<strong>numbers</strong>:
        db 0x01, 0x02, 0x09, 0x0a, 0x10, 0x99, 0xa0, 0xaa, 0xaf, 0xf0, 0xff, 0x00
&nbsp;
<strong>print_hex_number</strong>:
        push AF             <i>; uschovat A pro pozdější využití</i>
        rrca                <i>; rotace o čtyři bity doprava</i>
        rrca
        rrca
        rrca
        call print_hex_digit<i>; vytisknout první hexa cifru</i>
&nbsp;
        pop  AF             <i>; obnovit A</i>
                            <i>; vytisknout druhou hexa cifru</i>
&nbsp;
<strong>print_hex_digit</strong>:
        or   $f0            <i>; nastavit horní čtyři bity + příznaky</i>
        daa                 <i>; desítková korekce pro původní hodnoty A-F</i>
        add A, $a0          <i>; přičtení konstanty</i>
        adc A, $40          <i>; přičtení konstanty a navíc i příznaku carry</i>
        rst  0x10           <i>; zavolání rutiny v ROM pro tisk jednoho znaku</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>A pro úplnost se opět podívejme na způsob překladu výše uvedeného zdrojového
kódu do assembleru:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:211380     LD HL, 8013
8006:           label loop
8006:7E         LD A, (HL)
8007:B7         OR A
8008:C8         RET Z
8009:23         INC HL
800A:CD1F80     CALL 801F
800D:CD3180     CALL 8031
8010:C30680     JP 8006
8013:           label numbers
8013:0102090A   DEFB of 12 bytes
8017:1099A0AA
801B:AFF0FF00
801F:           label print_hex_number
801F:F5         PUSH AF
8020:0F         RRCA
8021:0F         RRCA
8022:0F         RRCA
8023:0F         RRCA
8024:CD2880     CALL 8028
8027:F1         POP AF
8028:           label print_hex_digit
8028:F6F0       OR F0
802A:27         DAA
802B:C6A0       ADD A, A0
802D:CE40       ADC A, 40
802F:D7         RST 10
8030:C9         RET
8031:           label new_line
8031:3E0D       LD A, 0D
8033:D7         RST 10
8034:C9         RET
8035:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8034
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Reprezentace numerických hodnot ve formátu pevné a plovoucí řádové (binární) tečky</h2>

<p>Ve druhé části dnešního článku si ve stručnosti popíšeme některé ze způsobů
reprezentace (resp.&nbsp;přesněji řečeno způsobu uložení) podmnožiny
racionálních numerických hodnot (zkráceně čísel) v&nbsp;operační paměti
počítače a/nebo v&nbsp;registrech jeho mikroprocesoru (CPU) či matematického
koprocesoru (FPU). Jedná se o uložení vybrané množiny numerických hodnot
v&nbsp;takzvaném systému <i>pevné řádové</i> (typicky binární nebo desetinné)
<i>tečky</i> popř.&nbsp;naopak v&nbsp;systému <i>plovoucí řádové tečky</i>.</p>

<p><div class="rs-tip-major">Poznámka: V&nbsp;tomto textu se ovšem budeme
záměrně dopouštět drobného prohřešku oproti stávající normě českého jazyka,
protože budeme neustále psát o řádové, desetinné a binární <i>tečce</i> a
nikoli o <i>čárce</i> &ndash; z&nbsp;hlediska anglické terminologie to bude
více konzistentní, i když z&nbsp;češtinářského hlediska by bylo zcela jistě
korektnější psát o řádové čárce, protože se v&nbsp;češtině celá část čísla od
části desetinné odděluje právě čárkou a nikoli tečkou, jak je tomu zvykem
v&nbsp;anglosaských zemích (na druhou stranu programátoři, kterým je tento
článek určen především, však tuto skutečnost zcela jistě znají). </div></p>

<p>V&nbsp;anglické literatuře se první zmíněná forma reprezentace číselných
hodnot označuje zkratkou <i>FX</i> nebo <i>FXP</i> (tato zkratka je odvozena od
<i>fixed point</i>), zatímco dnes častěji používaná reprezentace v&nbsp;systému
<i>plovoucí řádové tečky</i> se všeobecně označuje zkratkou <i>FP</i> (odvozeno
od <i>floating point</i>).</p>

<p><div class="rs-tip-major">Poznámka: V&nbsp;jednom článku jsem mimochodem
dokonce místo zkratky <i>FX</i> viděl i zkratku <i>XP</i>, ale to bylo před
mnoha lety, ještě v&nbsp;době Windows 95 :-).</div></p>

<p>Nejprve si vysvětlíme princip obou metod použitých pro ukládání podmnožiny
racionálních čísel a posléze si také řekneme, jaké výhody a nevýhody jednotlivé
principy přináší v&nbsp;každodenní programátorské praxi a ve kterých situacích
je vhodnější použít pevnou řádovou čárku. V&nbsp;dalším textu budeme formát
pevné binární řádové tečky zkracovat na FX formát a formát používající plovoucí
řádovou tečku budeme zapisovat jako FP formát.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vybrané způsoby reprezentace numerických hodnot v&nbsp;operační paměti počítače</h2>

<p>Při ukládání numerických hodnot do operační paměti počítače záhy narazíme na
některé problémy, z&nbsp;nichž některé souvisí s&nbsp;konečným počtem bitů,
které pro uložení dané hodnoty &bdquo;obětujeme&ldquo; a další vycházejí ze
způsobu zpracování hodnot mikroprocesorem či matematickým koprocesorem (což
není případ Z80). V&nbsp;konečném počtu bitů je totiž možné uložit pouze
<strong>konečné</strong> množství různých hodnot a je plně v&nbsp;rukou
programátora, jak efektivně daný počet bitů využije či naopak promrhá ukládáním
nepodstatných informací. Poměrně často se totiž stává, že i program využívající
dvojitou či dokonce rozšířenou přesnost čísel při <strong>FP</strong> operacích
(tj.&nbsp;datové typy <i>double</i> a <i>extended/temporary</i>) dává nesprávné
výsledky dané nepochopením principu práce <strong>FP</strong> aritmetiky a
přitom je možné se přesnějších výsledků dobrat i při použití pouhých 32 bitů,
ale s&nbsp;pečlivě vyváženými aritmetickými a bitovými operacemi.</p>

<p>Na druhou stranu nejsou dnes používané mikroprocesory tak univerzálními
zařízeními, jak by se na první pohled mohlo zdát. Mikroprocesory jsou totiž
(většinou) navrženy tak, aby účinně, například v&nbsp;rámci jedné operace či
instrukce, zpracovávaly pouze konstantní počet bitů. Příkladem mohou být dnes
velmi rozšířené procesory řady x86, které jsou velmi dobré při práci s&nbsp;32
bitovými hodnotami, ale při požadavku na aritmetické výpočty probíhající na
(řekněme) 21 bitech se veškerá jejich efektivita ztrácí a procesor se širokými
vnitřními sběrnicemi, matematickým koprocesorem atd. se potýká
s&nbsp;prohazováním jednotlivých bitů.</p>

<p>Mnohem lepší situace nastane v&nbsp;případě, že se nějaká operace
implementuje na programovatelném poli FPGA &ndash; zde je možné vytvořit obvody
provádějící matematické a logické operace s&nbsp;libovolným počtem bitů, čímž
se oproti univerzálním řešením (např.&nbsp;konstantní bitová šířka sběrnice
a/nebo registrů) ušetří mnoho plochy těchto velmi zajímavých obvodů (FPGA mohou
mimochodem znamenat i velkou šanci pro hnutí open source &ndash; pomocí nich by
mohlo vznikat, a někde už vzniká <strong>open hardware</strong>, které by mohlo
odstranit závislost na &bdquo;uzavřených&ldquo; síťových a grafických kartách
apod.).</p>

<p><div class="rs-tip-major">Poznámka: mnohé FPGA však již mají své vlastní ALU
a dokonce i násobičky, takže se z&nbsp;tohoto pohledu již nejedná o zcela
univerzální obvody připravené pro jakékoli reprezentace numerických
hodnot.</div></p>

<p>Vraťme se však ke způsobům reprezentace číselných hodnot v&nbsp;operační
paměti. Nejprve předpokládejme, že pro reprezentaci vlastností určitého objektu
či stavu z&nbsp;reálného světa použijeme <i>N</i> binárních číslic (bitů),
tj.&nbsp;základních jednotek informace, která může nabývat pouze jedné ze dvou
povolených hodnot (ty se značí například symboly <i>yes/no</i> nebo
<i>true</i>/<i>false</i>, ale my se budeme spíše držet označení <i>0</i> a
<i>1</i>). Pomocí této uspořádané <i>N</i>-tice je možné popsat celkem:</p>

<p><i>2<sub>0</sub>&times;2<sub>1</sub>&times;2<sub>2</sub> ... 2<sub>N-1</sub>=2<sup>N</sup></i></p>

<p>jednoznačných, tj.&nbsp;navzájem odlišných, stavů. Množina těchto stavů může
reprezentovat prakticky jakýkoliv abstraktní či reálný objekt. Přitom si musíme
uvědomit, že u této množiny není implicitně řečeno ani myšleno, že se jedná
například o celá kladná čísla, to je pouze jedna z&nbsp;mnoha možných
interpretací zvolené <i>N</i>-tice (my programátoři máme tendenci považovat
celá kladná čísla za přirozenou interpretaci bitové <i>N</i>-tice, to však
vychází pouze z&nbsp;našeho pohledu na svět a z&nbsp;našich zkušeností).
Reprezentaci momentálního stavu abstraktního či reálného objektu si můžeme
představit jako zobrazení z&nbsp;množiny binárních stavů na elementy vzorové (a
obecně neuspořádané) množiny. Nejčastěji používanými zobrazeními jsou zobrazení
množiny binárních stavů na interval celých kladných čísel (<i>Unsigned
Integers</i>), popřípadě na interval celých čísel (<i>Signed Integers</i>).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Uložení numerických hodnot ve formátu pevné řádové binární tečky</h2>

<p>Numerické hodnoty zapsané ve&nbsp;formátu <i>pevné řádové binární tečky</i>
se chápou jako podmnožina racionálních čísel, což jsou taková čísla, jejichž
hodnoty je možné vyjádřit vztahem:</p>

<p><i>x<sub>FX</sub>=a/b &nbsp;&nbsp; a,b leží v Z, b &ne; 0</i></p>

<p>Číselné hodnoty z&nbsp;uvažované podmnožiny jsou navíc omezeny
podmínkou:</p>

<p><i>b=2<sup>k</sup> &nbsp;&nbsp; b leží v Z, k leží v Z<sup>+</sup></i></p>

<p>Protože <i>b</i> je celočíselnou mocninou dvojky (a ne desítky či jiného
základu), určuje jeho hodnota <i>n</i> polohu <i>binární tečky</i>
v&nbsp;uloženém čísle. Další podmínkou, která má však spíše implementační
charakter, je zachování stejného počtu binárních cifer v&nbsp;každém
reprezentovaném čísle, což mimo jiné znamená, že všechna čísla mají řádovou
binární tečku umístěnou na stejném místě &ndash; z&nbsp;této podmínky ostatně
plyne i název popisovaného způsobu reprezentace vybrané podmnožiny racionálních
čísel. Tak jako i v&nbsp;jiných reprezentacích čísel, jsou nulové číslice před
první nenulovou cifrou a za poslední nenulovou cifrou nevýznamné, proto je není
zapotřebí uvádět.</p>

<p>Prakticky může být číselná hodnota v&nbsp;systému pevné řádové tečky uložena
na osmi bitech například následujícím způsobem (uvažujeme pouze kladné
hodnoty):</p>

<table>
<tr><td>Pozice bitu</td><td>8&nbsp;&nbsp;&nbsp;&nbsp;</td><td>7&nbsp;&nbsp;&nbsp;&nbsp;</td><td>6&nbsp;&nbsp;&nbsp;&nbsp;</td><td>5&nbsp;&nbsp;&nbsp;&nbsp;</td><td>4&nbsp;&nbsp;&nbsp;&nbsp;</td><td>3&nbsp;&nbsp;&nbsp;&nbsp;</td><td>2&nbsp;&nbsp;&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>Váha bitu</td><td>2<sup>4</sup></td><td>2<sup>3</sup></td><td>2<sup>2</sup></td><td>2<sup>1</sup></td><td>2<sup>0</sup></td><td>2<sup>-1</sup></td><td>2<sup>-2</sup></td><td>2<sup>-3</sup></td></tr>
<tr><td>Desítková váha bitu</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0,5</td><td>0,25</td><td>0,125</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: pochopitelně se jedná pouze o jednu
konkrétní vybranou reprezentaci, protože je to programátor, který určuje, na
kterém místě se řádová tečka nachází. Její pozice totiž není součástí vlastní
hodnoty, ale je &bdquo;zadrátována&ldquo; v&nbsp;algoritmech, které numerické
hodnoty zpracovávají (součet, součin, CORDIC atd. atd.). Výběr pozice řádové
tečky závisí především na tom, které hodnoty je zapotřebí reprezentovat a jaké
ztráty přesnosti jsme ochotni akceptovat.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přednosti a zápory formátu pevné řádové tečky</h2>

<p>Ve výše uvedeném příkladu je binární řádová tečka umístěna vždy mezi třetím
a čtvrtým bitem. Vzhledem k&nbsp;tomu, že je tato skutečnost dopředu známá
algoritmu, který provádí zpracování čísel, není zapotřebí spolu s&nbsp;číslem
uchovávat i pozici binární tečky, což výrazně snižuje počet bitů, které je
zapotřebí rezervovat pro čísla ze zadaného rozsahu. To je tedy první přednost
systému pevné řádové tečky &ndash; pokud programátor dopředu zná rozsah všech
zpracovávaných hodnot a požadovanou přesnost, může být výhodné tento systém
použít. Programátor také díky explicitním určení polohy řádové tečky může
určit, ve kterém místě programu se musí přesnost či rozsah zvýšit a kdy naopak
snížit. Lépe se tak využije počet bitů, které můžeme pro uložení jednoho čísla
obětovat (typicky je tento počet bitů roven délce slova mikroprocesoru,
popř.&nbsp;jeho celočíselnému násobku či naopak podílu).</p>

<p>Navíc je možné základní matematické operace (sčítání, odčítání, násobení a
dělení) poměrně jednoduše implementovat i při použití formátu pevné řádové
tečky. V&nbsp;případě, že není k&nbsp;dispozici specializovaný (a současně
velmi komplikovaný) matematický koprocesor, je mnohdy mnohem jednodušší a
rychlejší implementovat matematické operace v&nbsp;FX formátu. To je případ
mnoha jednočipových mikroprocesorů (mikrořadičů), našeho oblíbeného čipu Zilog
Z80, signálových procesorů, ale i specializovaných zařízení obsahujících
programovatelné obvody CPLD či FPGA. Dnes sice mají komplikovanější (a dražší)
FPGA implementovanou i jednotku FPU, ale mnohdy je výhodnější použít FPGA bez
této jednotky a potřebné operace si do tohoto obvodu &bdquo;vypálit&ldquo; po
svém.</p>

<p>Třetí výhodou je fakt, že u FX formátu může programátor navrhnout a posléze
také dodržet požadovanou přesnost všech prováděných výpočtů. To je velký rozdíl
oproti FP formátu (resp.&nbsp;jeho podmnožinám, které se nejčastěji používají).
Není vzácností narazit na programy, které používají datové typy <i>float</i> či
<i>double</i> a přitom jsou výpočty prováděné v&nbsp;těchto programech zatíženy
velkou chybou, protože si programátoři plně neuvědomují některé limity FP
formátu. Kritické jsou například výpočty s&nbsp;peněžními hodnotami, ale i
pouhé sčítání čísel, jež se od sebe o mnoho řádů liší, vede k&nbsp;velkým
chybám, které dokonce mohou zapříčinit vznik nekonečných smyček, populární
dělení nulou atd.</p>

<p>FX formát má však i některé nevýhody. První nevýhoda spočívá v&nbsp;tom, že
tento formát není příliš podporován, a to ani po programové stránce (podpora
v&nbsp;programovacích jazycích), ani výrobci mikroprocesorů pro počítače PC.
Situace je však odlišná v&nbsp;oblasti jednočipových mikropočítačů, signálových
procesorů (DSP), řídicích systémů, nebo například u IBM RS 6000, který kromě
jednotky FPU obsahuje i FXU &ndash; jednotku pro provádění výpočtů v&nbsp;pevné
řádové binární čárce. Na platformě x86 je možné pro FX formát použít instrukce
<strong>MMX</strong>.</p>

<p>Dále může být použití FX formátu nevýhodné v&nbsp;případě, že se mají
zpracovávat numerické hodnoty, které mají velkou dynamiku, tj.&nbsp;poměr mezi
nejvyšší a nejnižší absolutní hodnotou. V&nbsp;takovém případě by se mohlo
stát, že by se při použití FX formátu muselo pro každé číslo alokovat velké
množství bitů, které by mohlo dokonce překročit počet bitů nutných pro FP
formát. Také v&nbsp;případě, kdy dopředu nevíme, jaké hodnoty se budou
zpracovávat, může být výhodnější použití FP formátu. Zde se však nabízí otázka,
ve kterých případech nevíme, jaké hodnoty můžeme na vstupu získat: většinou je
již z&nbsp;podstaty úlohy dopředu známé, s&nbsp;čím je možné počítat a které
hodnoty jsou naprosto nesmyslné. Je však pravdou, že takovou analýzu málokdo
dělá a když při výpočtech ve <i>floatech</i> dochází k&nbsp;chybám, tak se bez
přemýšlení program přepíše na <i>doubly</i> a problém se tak buď odstraní, nebo
alespoň odsune na pozdější dobu, například do chvíle, kdy jsou programu
předložena reálná data a ne &bdquo;pouze&ldquo; data testovací.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Uložení čísel ve formátu plovoucí řádové (binární) tečky</h2>

<p>Uložení racionálních čísel ve formátu plovoucí řádové tečky (FP formát) se
od FX formátu odlišuje především v&nbsp;tom, že si každá numerická hodnota sama
v&nbsp;sobě nese polohu řádové tečky. Z&nbsp;tohoto důvodu je kromě bitů, které
jsou rezervovány pro uložení významných číslic numerické hodnoty, nutné pro
každou numerickou hodnotu rezervovat i další bity, pomocí nichž je určena
mocnina o nějakém základu (typicky 2, 8, 10 či 16), kterou musí být významné
číslice vynásobeny resp.&nbsp;vyděleny. První část čísla uloženého v&nbsp;FP
formátu se nazývá <strong>mantisa</strong>, druhá část
<strong>exponent</strong>. Obecný formát uložení a způsob získání původního
čísla je následující:</p>

<p><i>x<sub>FP</sub>=b<sup>e</sup>&times;m</i></p>

<p>kde:</p>

<ol>
<li><i>x<sub>FX</sub></i> značí reprezentovanou numerickou hodnotu z&nbsp;podmnožiny reálných čísel</li>
<li><i>b</i> je báze, někdy také nazývaná <i>radix</i></li>
<li><i>e</i> je hodnota exponentu (může být i záporná)</li>
<li><i>m</i> je mantisa, která může být i záporná</li>
</ol>

<p>Konkrétní formát numerických hodnot reprezentovaných v&nbsp;systému plovoucí
řádové tečky závisí především na volbě báze (<strong>radixu</strong>) a také na
počtu bitů rezervovaných pro uložení mantisy a exponentu. V&nbsp;minulosti
existovalo mnoho různých formátů plovoucí řádové tečky (vzpomíná si někdo na
<strong>Turbo Pascal</strong> s&nbsp;jeho šestibytovým datovým typem
<i>real</i>?), dnes se však, ustálilo použití formátů specifikovaných
v&nbsp;normě IEEE 754. Ovšem to není případ ZX Spectra, které má svůj vlastní
formát, jenž si popíšeme v&nbsp;dalším textu.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Formát uložení FP hodnot na ZX Spectru</h2>

<p>Při volbě konkrétního formátu uložení FP hodnot mají programátoři poměrně
dosti volné ruce. Musí především zvolit:</p>

<ol>
<li>Celkovou šířku slova s&nbsp;FP hodnotou</li>
<li>Zda bude mantisa a exponent uložena v&nbsp;binárním či BCD formátu (pro Z80 se BCD naprosto nehodí, na rozdíl od 6502)</li>
<li>Bitová šířka mantisy</li>
<li>Zda je první bit mantisy pevně nastaven na jedničku (a tudíž se nemusí ukládat)</li>
<li>Základ exponentu (typicky 2, 10 či 16)</li>
<li>Bitová šířka exponentu</li>
<li>Formát uložení, tj.&nbsp;kde bude uloženo znaménko, kde mantisa a kde exponent (FP hodnota je vlastně bitové pole)</li>
</ol>

<p>Existuje mnoho formátů, z&nbsp;nichž nejzajímavější či nejpoužívanější
vypadají následovně:</p>

<pre>
IBM 1130, IBM 1800 32 Bit single precision floating point
&nbsp;
 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+-+---------------------------------------------+---------------+
|S|                mantissa                     |exp. with bias |
+-+---------------------------------------------+---------------+
&nbsp;
&nbsp;
GE-635 36 Bit single precision floating point
&nbsp;
 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3
+-+-------------+-+-----------------------------------------------------+
|S|  Two's exp. |S|            Two's complement mantissa                |
+-+-------------+-+-----------------------------------------------------+
&nbsp;
&nbsp;
Intel 8008, 8080 floating point UCRL-51940
&nbsp;
 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
+-+-------------+-----------------------------------------------+
|S|  Two's exp. |                 positive mantissa             |
+-+-------------+-----------------------------------------------+
&nbsp;
&nbsp;
Altair BASIC 8080 floating point
&nbsp;
 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
+---------------+-+---------------------------------------------+
|exp. with bias |S|       positive mantissa, MSB = 2^-1         |
+---------------+-+---------------------------------------------+
&nbsp;
&nbsp;
Z80 40 Bit floating point
&nbsp;
 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
+-+-------------+-+-------------------------------------------------------------+
|S|  Two's exp. |S|            Two's complement mantissa, MSB = 2^1             |
+-+-------------+-+-------------------------------------------------------------+
&nbsp;
&nbsp;
IEEE 754 single precision
&nbsp;
 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
+-+---------------+---------------------------------------------+
|S| exp. with bias|       positive mantissa, MSB = 2^-1         |
+-+---------------+---------------------------------------------+
</pre>

<p>Na ZX Spectru je použit 40bitový formát, přičemž 40 bitů bylo pravděpodobně
zvoleno z&nbsp;toho důvodu, že všech pět univerzálních pracovních registrů má
dohromady přesně tuto šířku (ale to může být jen spekulace):</p>

<pre>
 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
+-+-------------+-+-------------------------------------------------------------+
|exp. with bias |S|            Two's complement mantissa                        |
+-+-------------+-+-------------------------------------------------------------+
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o formát používaný subrutinami
v&nbsp;ROM a taktéž BASICem. Není však problém (je to pouze hodně pracné) si
navrhnout formát vlastní.</div></p>

<p>Předpokládá se, že první bit mantisy je roven jedničce (což dává smysl),
proto tento první bit není uložen a na jeho místě je znaménko mantisy. Exponent
je posunutý o hodnotu 128 (viz další příklady).</div></p>

<p>Navíc tento formát obsahuje výjimku pro celočíselné hodnoty v&nbsp;rozsahu
od -65535 až +65535. Tyto hodnoty jsou uloženy takovým způsobem, že první bajt
(posunutý exponent) je nulový, druhý bajt obsahuje samé nuly pro kladná čísla a
samé jedničky pro čísla záporná a teprve třetí a čtvrtý bajt obsahuje 16bitovou
hodnotu bez znaménka. Poslední bajt je opět nulový. Tuto výjimku si podrobněji
ukážeme příště.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Zásobník FP hodnot na ZX Spectru, subrutina pro tisk FP hodnot</h2>

<p>V&nbsp;ROM ZX Spectra je uloženo několik subrutin určených pro zpracování FP
hodnot. Z&nbsp;těchto subrutin nás dnes budou zajímat pouze dvě:</p>

<pre>
2DE3: THE 'PRINT A FLOATING-POINT NUMBER' SUBROUTINE
This subroutine prints x, the 'last value' on the calculator stack. The print format never occupies more than 14 spaces.
&nbsp;
2AB1: THE 'STK-STORE' SUBROUTINE
This subroutine passes the values held in the A, B, C, D and E
A 	First byte (when entering at STK_STO or STK_STORE)
B 	Fifth byte
C 	Fourth byte
D 	Third byte
E 	Second byte
</pre>

<p><div class="rs-tip-major">Poznámka: dejte si pozor na druhou subrutinu,
protože její ústřední část začíná až na adrese 0x2AB6 a nikoli na adrese
0x2AB1. Proto v&nbsp;demonstračním příkladu použijeme první adresu:</div></p>

<pre>
PRINT_FP      equ $2DE3
STK_STORE     equ $2AB6
</pre>

<p>Subrutina <strong>STK_STORE</strong> uloží FP hodnotu předanou ve všech pěti
pracovních registrech (kromě HL) na zásobník (<i>stack</i>) používaný při FP
výpočtech. Podrobnosti si řekneme příště, protože dnes nám postačuje vědět,
jaké registry a v&nbsp;jakém pořadí jsou použity pro předání FP hodnoty:</p>

<pre>
        <i>; A  první bajt</i>
        <i>; B  pátý byte</i>
        <i>; C  čtvrtý byte</i>
        <i>; D  třetí byte</i>
        <i>; E  druhý bajt</i>
        ld   A, ...
        ld   E, ...
        ld   D, ...
        ld   C, ...
        ld   B, ...
        call STK_STORE      <i>; uložit FP hodnotu na zásobník</i>
</pre>

<p>Subrutina <strong>PRINT_FP</strong> přečte hodnotu z&nbsp;výše zmíněného
zásobníku a vytiskne ji na obrazovku. Přitom se správně rozpoznají všechny
speciální případy, tj.&nbsp;nuly, celočíselné hodnoty -65535..+65535 atd.</p>

<pre>
        call PRINT_FP       <i>; vytisknout FP hodnotu uloženou na vrcholu zásobníku</i>
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
</pre>

<p>Můžeme si tedy otestovat, jaké FP hodnoty jsou reprezentovány následujícími
sekvencemi čtyřiceti bitů. Otestování bude snadné &ndash; pětici bajtů (40
bitů) uložíme do &bdquo;FP zásobníku&ldquo; subrutinou
<strong>STK_STORE</strong> a následně hodnotu vytiskneme zavoláním subrutiny
<strong>PRINT_FP</strong>. Této subrutině se nepředávají žádné parametry
&ndash; ty jsou na &bdquo;FP zásobníku&ldquo;:</p>

<pre>
        ld IX, fp0             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
</pre>

<p>Tisknout budeme FP hodnoty reprezentované těmito sekvencemi bitů:</p>

<pre>
<i>;         mantisa+128  s  exponent</i>
<strong>fp0</strong>:    db %00000000, %00000000, %00000000, %00000000, %00000000
<strong>fp1</strong>:    db %10000000, %00000000, %00000000, %00000000, %00000000
<strong>fp2</strong>:    db %10000000, %10000000, %00000000, %00000000, %00000000
<strong>fp3</strong>:    db %10000000, %01000000, %00000000, %00000000, %00000000
<strong>fp4</strong>:    db %10000001, %01000000, %00000000, %00000000, %00000000
<strong>fp5</strong>:    db %10000001, %01000000, %00000000, %00000001, %00000000
<strong>fp6</strong>:    db %10000001, %00111111, %11111111, %11111111, %00000000
</pre>

<p>Výsledek by měl vypadat následovně:</p>

*** image ***
<p><i>Obrázek 8: Sedm FP hodnot vypsaných na obrazovce ZX Spectra.</i></p>

<p>Proč hodnoty vypadají tak, jak vypadají:</p>

<ol>
<li>První hodnota je 16bitovým číslem se znaménkem</li>
<li>Druhá hodnota obsahuje exponent=0 a mantisa má nastaven pouze nejvyšší bit za binární tečkou (ten se, jak víme, neukládá)</li>
<li>Třetí hodnota je totožná, jako hodnota druhá, ovšem je nastaven znaménkový bit</li>
<li>Čtvrtá hodnota obsahuje exponent=0 a mantisa je rovna 0.11 (binárně), tedy 0,5+0,25=0,75 dekadicky</li>
<li>Pátá hodnota má exponent=1 (&times;2) a mantisu stejnou, jako hodnota předchozí, tedy 2&times;0,75=1,5</li>
<li>Šestá hodnota je nepatrně vyšší, než hodnota pátá (viz v&nbsp;pořadí devátý bit zprava)</li>
<li>Sedmá hodnota je naopak nepatrně menší, než hodnota pátá</li>
</ol>

<p>Pro tisk FP hodnoty je použita tato subrutina:</p>

<pre>
<strong>print_fp_number</strong>:
        <i>; A  první bajt</i>
        <i>; B  pátý byte</i>
        <i>; C  čtvrtý byte</i>
        <i>; D  třetí byte</i>
        <i>; E  druhý bajt</i>
        ld   A, (IX)
        ld   E, (IX+1)
        ld   D, (IX+2)
        ld   C, (IX+3)
        ld   B, (IX+4)
        call STK_STORE      <i>; uložit FP hodnotu na zásobník</i>
        call PRINT_FP       <i>; vytisknout FP hodnotu uloženou na vrcholu zásobníku</i>
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        ret                 <i>; návrat ze subrutiny</i>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úplný zdrojový kód dnešního pátého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního pátého a současně i posledního demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/83-print-fp-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/83-print-fp-numbers.asm</a>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
PRINT_FP      equ $2DE3
STK_STORE     equ $2AB6
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS           <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld IX, fp0             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp1             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp2             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp3             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp4             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp5             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ld IX, fp6             <i>; adresa s pěticí bajtů FP hodnoty</i>
        call print_fp_number   <i>; tisk FP hodnoty na obrazovku s odřádkováním</i>
&nbsp;
        ret
&nbsp;
<i>;         mantisa+128  s  exponent</i>
<strong>fp0</strong>:    db %00000000, %00000000, %00000000, %00000000, %00000000
<strong>fp1</strong>:    db %10000000, %00000000, %00000000, %00000000, %00000000
<strong>fp2</strong>:    db %10000000, %10000000, %00000000, %00000000, %00000000
<strong>fp3</strong>:    db %10000000, %01000000, %00000000, %00000000, %00000000
<strong>fp4</strong>:    db %10000001, %01000000, %00000000, %00000000, %00000000
<strong>fp5</strong>:    db %10000001, %01000000, %00000000, %00000001, %00000000
<strong>fp6</strong>:    db %10000001, %00111111, %11111111, %11111111, %00000000
&nbsp;
&nbsp;
<strong>print_fp_number</strong>:
        <i>; A  první bajt</i>
        <i>; B  pátý byte</i>
        <i>; C  čtvrtý byte</i>
        <i>; D  třetí byte</i>
        <i>; E  druhý bajt</i>
        ld   A, (IX)
        ld   E, (IX+1)
        ld   D, (IX+2)
        ld   C, (IX+3)
        ld   B, (IX+4)
        call STK_STORE      <i>; uložit FP hodnotu na zásobník</i>
        call PRINT_FP       <i>; vytisknout FP hodnotu uloženou na vrcholu zásobníku</i>
<strong>new_line</strong>:
        ld   A, 0x0d        <i>; kód znaku pro odřádkování</i>
        rst  0x10           <i>; zavolání rutiny v ROM</i>
        ret                 <i>; návrat ze subrutiny</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Překlad do assembleru:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
PRINT_FP        EQU 2DE3
STK_STORE       EQU 2AB6
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:DD213580   LD IX, 8035
8007:CD5880     CALL 8058
800A:DD213A80   LD IX, 803A
800E:CD5880     CALL 8058
8011:DD213F80   LD IX, 803F
8015:CD5880     CALL 8058
8018:DD214480   LD IX, 8044
801C:CD5880     CALL 8058
801F:DD214980   LD IX, 8049
8023:CD5880     CALL 8058
8026:DD214E80   LD IX, 804E
802A:CD5880     CALL 8058
802D:DD215380   LD IX, 8053
8031:CD5880     CALL 8058
8034:C9         RET
8035:           label fp0
8035:00000000   DEFB of 5 bytes
8039:00
803A:           label fp1
803A:80000000   DEFB of 5 bytes
803E:00
803F:           label fp2
803F:80800000   DEFB of 5 bytes
8043:00
8044:           label fp3
8044:80400000   DEFB of 5 bytes
8048:00
8049:           label fp4
8049:81400000   DEFB of 5 bytes
804D:00
804E:           label fp5
804E:81400001   DEFB of 5 bytes
8052:00
8053:           label fp6
8053:813FFFFF   DEFB of 5 bytes
8057:00
8058:           label print_fp_number
8058:DD7E00     LD A, (IX+00)
805B:DD5E01     LD E, (IX+01)
805E:DD5602     LD D, (IX+02)
8061:DD4E03     LD C, (IX+03)
8064:DD4604     LD B, (IX+04)
8067:CDB62A     CALL 2AB6
806A:CDE32D     CALL 2DE3
806D:           label new_line
806D:3E0D       LD A, 0D
806F:D7         RST 10
8070:C9         RET
8071:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8070
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<p>Výše uvedené demonstrační příklady i příklady, které již byly popsány
v&nbsp;předchozích devíti článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">3</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny/">4</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-podruhe/">5</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-potreti/">6</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-dokonceni-realizace-prikazu-plot/">7</a>],
[<a
href="https://www.root.cz/clanky/zobrazeni-cisel-a-zpracovani-priznaku-mikroprocesoru-zilog-z80/">8</a>],
[<a href="https://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ulozenymi-binarne-i-ve-formatu-bcd/">9</a>],
je možné přeložit s&nbsp;využitím souboru Makefile, jehož aktuální verze vypadá
následovně (pro překlad a slinkování je použit assembler <i>Pasmo</i>):</p>

<pre>
ASSEMBLER := pasmo
&nbsp;
all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap \
    31.tap 32.tap 33.tap 34.tap 35.tap 36.tap 37.tap 38.tap 39.tap 40.tap \
    41.tap 42.tap 43.tap 44.tap 45.tap 46.tap 47.tap 48.tap 49.tap 50.tap \
    51.tap 52.tap 53.tap 54.tap 55.tap 56.tap 57.tap 58.tap 59.tap 60.tap \
    61.tap 62.tap 63.tap 64.tap 65.tap 66.tap 67.tap 68.tap 69.tap 70.tap \
    71.tap 72.tap 73.tap 74.tap 75.tap 76.tap 77.tap 78.tap 79.tap 80.tap \
    81.tap 82.tap 83.tap
&nbsp;
clean:
        rm -f *.tap
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 01-color-attribute.lst
&nbsp;
02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 02-blinking-attribute.lst
&nbsp;
03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 03-symbolic-names.lst
&nbsp;
04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 04-operators.lst
&nbsp;
05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 05-better-symbols.lst
&nbsp;
06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 06-tapbas-v1.lst
&nbsp;
07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 07-tapbas-v2.lst
&nbsp;
08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 08-loop.lst
&nbsp;
09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 09-loop.lst
&nbsp;
10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 10-loop.lst
&nbsp;
11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 11-loop.lst
&nbsp;
12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 12-loop.lst
&nbsp;
13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 13-loop.lst
&nbsp;
14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 14-loop.lst
&nbsp;
15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 15-loop.lst
&nbsp;
16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 16-loop.lst
&nbsp;
17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 17-loop.lst
&nbsp;
18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 18-cls.lst
&nbsp;
19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 19-print-char-call.lst
&nbsp;
20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 20-print-char-rst.lst
&nbsp;
21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 21-print-char.lst
&nbsp;
22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 22-print-all-chars.lst
&nbsp;
23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 23-print-all-chars.lst
&nbsp;
24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 24-change-color.lst
&nbsp;
25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 25-change-flash.lst
&nbsp;
26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 26-print-at.lst
&nbsp;
27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 27-print-string.lst
&nbsp;
28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 28-print-string.lst
&nbsp;
29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 29-print-colorized-string.lst
&nbsp;
30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 30-print-string-ROM.lst
&nbsp;
31.tap: 31-attributes.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 31-attributes.lst
&nbsp;
32.tap: 32-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 32-fill-in-vram.lst
&nbsp;
33.tap: 33-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 33-fill-in-vram-no-ret.lst
&nbsp;
34.tap: 34-fill-in-vram-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 34-fill-in-vram-pattern.lst
&nbsp;
35.tap: 35-slow-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 35-slow-fill-in-vram.lst
&nbsp;
36.tap: 36-slow-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 36-slow-fill-in-vram-no-ret.lst
&nbsp;
37.tap: 37-fill-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 37-fill-block.lst
&nbsp;
38.tap: 38-fill-block-with-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 38-fill-block-with-pattern.lst
&nbsp;
39.tap: 39-fill-block-optimized.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 39-fill-block-optimized.lst
&nbsp;
40.tap: 40-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 40-draw-char.lst
&nbsp;
41.tap: 41-draw-any-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 41-draw-any-char.lst
&nbsp;
42.tap: 42-block-anywhere.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 42-block-anywhere.lst
&nbsp;
43.tap: 43-block-anywhere-rrca.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 43-block-anywhere-rrca.lst
&nbsp;
44.tap: 44-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 44-better-draw-char.lst
&nbsp;
45.tap: 45-even-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 45-even-better-draw-char.lst
&nbsp;
46.tap: 46-draw-char-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 46-draw-char-at.lst
&nbsp;
47.tap: 47-draw-char-at-unrolled.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 47-draw-char-at-unrolled.lst
&nbsp;
48.tap: 48-incorrect-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 48-incorrect-print-string.lst
&nbsp;
49.tap: 49-correct-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 49-correct-print-string.lst
&nbsp;
50.tap: 50-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 50-ascii-table.lst
&nbsp;
51.tap: 51-plot-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 51-plot-block.lst
&nbsp;
52.tap: 52-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 52-plot-pixel.lst
&nbsp;
53.tap: 53-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 53-plot-pixel.lst
&nbsp;
54.tap: 54-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 54-plot-pixel-on-background.lst
&nbsp;
55.tap: 55-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 55-plot-pixel-on-background.lst
&nbsp;
56.tap: 56-inverse-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 56-inverse-ascii-table.lst
&nbsp;
57.tap: 57-plot-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 57-plot-pixel-on-inverse-background.lst
&nbsp;
58.tap: 58-plot-inverse-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 58-plot-inverse-pixel-on-inverse-background.lst
&nbsp;
59.tap: 59-configurable-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 59-configurable-ascii-table.lst
&nbsp;
60.tap: 60-plot-over.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 60-plot-over.lst
&nbsp;
61.tap: 61-print-number-A.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 61-print-number-A.lst
&nbsp;
62.tap: 62-print-number-B.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 62-print-number-B.lst
&nbsp;
63.tap: 63-print-number-C.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 63-print-number-C.lst
&nbsp;
64.tap: 64-print-number-D.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 64-print-number-D.lst
&nbsp;
65.tap: 65-more-numbers-A.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 65-more-numbers-A.lst
&nbsp;
66.tap: 66-more-numbers-B.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 66-more-numbers-B.lst
&nbsp;
67.tap: 67-print-flags-1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 67-print-flags-1.lst
&nbsp;
68.tap: 68-print-flags-2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 68-print-flags-2.lst
&nbsp;
69.tap: 69-print-flags-3.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 69-print-flags-3.lst
&nbsp;
70.tap: 70-print-flags-4.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 70-print-flags-4.lst
&nbsp;
71.tap: 71-print-flags-5.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 71-print-flags-5.lst
&nbsp;
72.tap: 72-print-flags-6.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 72-print-flags-6.lst
&nbsp;
73.tap: 73-print-flags-7.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 73-print-flags-7.lst
&nbsp;
74.tap: 74-print-hex-number.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 74-print-hex-number.lst
&nbsp;
75.tap: 75-print-hex-number.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 75-print-hex-number.lst
&nbsp;
76.tap: 76-print-hex-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 76-print-hex-numbers.lst
&nbsp;
77.tap: 77-add-hex-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 77-add-hex-numbers.lst
&nbsp;
78.tap: 78-add-bcd-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 78-add-bcd-numbers.lst
&nbsp;
79.tap: 79-print-hex-digit-jmp.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 79-print-hex-digit-jmp.lst
&nbsp;
80.tap: 80-print-hex-digit-overflow.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 80-print-hex-digit-overflow.lst
&nbsp;
81.tap: 81-print-hex-digit-daa.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 81-print-hex-digit-daa.lst
&nbsp;
82.tap: 82-print-hex-numbers-daa.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 82-print-hex-numbers-daa.lst
&nbsp;
83.tap: 83-print-fp-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 83-print-fp-numbers.lst
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>31-attributes.asm</td><td>modifikace atributů pro tisk řetězce subrutinou uloženou v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a></td></tr>
<tr><td>32</td><td>32-fill-in-vram.asm</td><td>vyplnění celé bitmapy barvou popředí, návrat do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a></td></tr>
<tr><td>33</td><td>33-fill-in-vram-no-ret.asm</td><td>vyplnění celé bitmapy barvou popředí, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>34</td><td>34-fill-in-vram-pattern.asm</td><td>vyplnění celé bitmapy zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a></td></tr>
<tr><td>35</td><td>35-slow-fill-in-vram.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a></td></tr>
<tr><td>36</td><td>36-slow-fill-in-vram-no-ret.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>37</td><td>37-fill-block.asm</td><td>vykreslení bloku 8&times;8 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a></td></tr>
<tr><td>38</td><td>38-fill-block-with-pattern.asm</td><td>vykreslení bloku 8&times;8 pixelů zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a></td></tr>
<tr><td>39</td><td>39-fill-block-optimized.asm</td><td>optimalizace předchozího příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a></td></tr>
<tr><td>40</td><td>40-draw-char.asm</td><td>vykreslení znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a></td></tr>
<tr><td>41</td><td>41-draw-any-char.asm</td><td>podprogram pro vykreslení libovolně zvoleného znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a></td></tr>
<tr><td>42</td><td>42-block-anywhere.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>43-block-anywhere-rrca.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm</a></td></tr>
<tr><td>44</td><td>44-better-draw-char.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm</a></td></tr>
<tr><td>45</td><td>45-even-better-draw-char.asm</td><td>posun offsetu pro vykreslení dalšího znaku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm</a></td></tr>
<tr><td>46</td><td>46-draw-char-at.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm</a></td></tr>
<tr><td>47</td><td>47-draw-char-at-unrolled.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm</a></td></tr>
<tr><td>48</td><td>48-incorrect-print-string.asm</td><td>tisk řetězce, nekorektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm</a></td></tr>
<tr><td>49</td><td>49-correct-print-string.asm</td><td>tisk řetězce, korektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>50-ascii-table.asm</td><td>tisk několika bloků ASCII tabulky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm</a></td></tr>
<tr><td>51</td><td>51-plot-block.asm</td><td>vykreslení pixelu verze 1: zápis celého bajtu na pozici pixelu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm</a></td></tr>
<tr><td>52</td><td>52-plot-pixel.asm</td><td>vykreslení pixelu verze 2: korektní vykreslení jednoho pixelu, ovšem překreslení celého bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm</a></td></tr>
<tr><td>53</td><td>53-plot-pixel.asm</td><td>vykreslení pixelu verze 3: vylepšená verze předchozího demonstračního příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm</a></td></tr>
<tr><td>54</td><td>54-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (nekorektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm</a></td></tr>
<tr><td>55</td><td>55-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (korektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>56</td><td>56-inverse-ascii-table.asm</td><td>vykreslení ASCII tabulky inverzní barvou (inkoust vs. papír)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm</a></td></tr>
<tr><td>57</td><td>57-plot-pixel-on-inverse-background.asm</td><td>vykreslení pixelů barvou papíru proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm</a></td></tr>
<tr><td>58</td><td>58-plot-inverse-pixel-on-inverse-background.asm</td><td>vykreslení pixelů inverzní barvou proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/58-plot-inverse-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm58-plot-inverse-pixel-on-inverse-background.asm/</a></td></tr>
<tr><td>59</td><td>59-configurable-ascii-table.asm</td><td>vykreslení ASCII tabulky buď přímo inkoustem nebo inverzně</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm</a></td></tr>
<tr><td>60</td><td>60-plot-over.asm</td><td>přibližná implementace příkazu <strong>PLOT OVER</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>61-print-number-A.asm</td><td>ukázka použití podprogramu pro tisk celého čísla</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm</a></td></tr>
<tr><td>62</td><td>62-print-number-B.asm</td><td>pokus o vytištění záporných čísel</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm</a></td></tr>
<tr><td>63</td><td>63-print-number-C.asm</td><td>tisk maximální podporované hodnoty 9999</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm</a></td></tr>
<tr><td>64</td><td>64-print-number-D.asm</td><td>tisk vyšší než podporované hodnoty 10000</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm</a></td></tr>
<tr><td>65</td><td>65-more-numbers-A.asm</td><td>vytištění číselné řady</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm</a></td></tr>
<tr><td>66</td><td>66-more-numbers-B.asm</td><td>kombinace tisku celočíselných hodnot s&nbsp;dalšími subrutinami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm</a></td></tr>
<tr><td>67</td><td>67-print-flags-1.asm</td><td>příznakové bity po provedení celočíselné operace 1+2</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/67-print-flags-1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/67-print-flags-1.asm</a></td></tr>
<tr><td>68</td><td>68-print-flags-2.asm</td><td>příznakové bity po provedení celočíselné operace 0+0</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/68-print-flags-2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/68-print-flags-2.asm</a></td></tr>
<tr><td>69</td><td>69-print-flags-3.asm</td><td>příznakové bity po provedení operace 255+1</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/69-print-flags-3.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/69-print-flags-3.asm</a></td></tr>
<tr><td>70</td><td>70-print-flags-4.asm</td><td>příznakové bity po provedení operace 254+1</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/70-print-flags-4.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/70-print-flags-4.asm</a></td></tr>
<tr><td>71</td><td>71-print-flags-5.asm</td><td>příznakové bity po provedení operace 255+255</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/71-print-flags-5.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/71-print-flags-5.asm</a></td></tr>
<tr><td>72</td><td>72-print-flags-6.asm</td><td>výsledek operace 100+100, nastavení příznakových bitů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/72-print-flags-6.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/72-print-flags-6.asm</a></td></tr>
<tr><td>73</td><td>73-print-flags-7.asm</td><td>výsledek operace 128+128, nastavení příznakových bitů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/73-print-flags-7.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/73-print-flags-7.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>74</td><td>74-print-hex-number.asm</td><td>tisk hexadecimálního čísla v&nbsp;rozsahu 0x00 až 0xff (neoptimalizovaná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/74-print-hex-number.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/74-print-hex-number.asm</a></td></tr>
<tr><td>75</td><td>75-print-hex-number.asm</td><td>tisk hexadecimálního čísla v&nbsp;rozsahu 0x00 až 0xff (optimalizovaná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/75-print-hex-number.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/75-print-hex-number.asm</a></td></tr>
<tr><td>76</td><td>76-print-hex-numbers.asm</td><td>tisk několika hexadecimálních hodnot</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/76-print-hex-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/76-print-hex-numbers.asm</a></td></tr>
<tr><td>77</td><td>77-add-hex-numbers.asm</td><td>součet dvou osmibitových hexadecimálních hodnot s&nbsp;tiskem všech výsledků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/77-add-hex-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/77-add-hex-numbers.asm</a></td></tr>
<tr><td>78</td><td>78-add-bcd-numbers.asm</td><td>součet dvou osmibitových BCD hodnot s&nbsp;tiskem všech výsledků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/78-add-bcd-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/78-add-bcd-numbers.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>79</td><td>79-print-hex-digit-jmp.asm</td><td>tisk jedné hexadecimální cifry s&nbsp;využitím podmíněného skoku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/79-print-hex-digit-jmp.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/79-print-hex-digit-jmp.asm</a></td></tr>
<tr><td>80</td><td>80-print-hex-digit-overflow.asm</td><td>otestování, jaký znak je vytištěn pro hodnoty větší než 15</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/80-print-hex-digit-overflow.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/80-print-hex-digit-overflow.asm</a></td></tr>
<tr><td>81</td><td>81-print-hex-digit-daa.asm</td><td>tisk jedné hexadecimální cifry s&nbsp;využitím instrukce DAA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/81-print-hex-digit-daa.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/81-print-hex-digit-daa.asm</a></td></tr>
<tr><td>82</td><td>82-print-hex-numbers-daa.asm</td><td>tisk série hexadecimálních hodnot s&nbsp;využitím instrukce DAA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/82-print-hex-numbers-daa.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/82-print-hex-numbers-daa.asm</a></td></tr>
<tr><td>83</td><td>83-print-fp-numbers.asm</td><td>tisk numerických hodnot reprezentovaných v&nbsp;systému plovoucí řádové tečky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/83-print-fp-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/83-print-fp-numbers.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>84</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech demonstračních příkladů do podoby obrazu magnetické pásky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>The system variables<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html</a>
</li>

<li>ZX Spectrum manual: chapter #17 Graphics<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html</a>
</li>

<li>Why does Sinclair BASIC have two formats for storing numbers in the same structure?<br />
<a href="https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu">https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu</a>
</li>

<li>Plovoucí řádová čárka na ZX Spectru<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

<li>1A1B: THE 'REPORT AND LINE NUMBER PRINTING' SUBROUTINE<br />
<a href="https://skoolkid.github.io/rom/asm/1A1B.html">https://skoolkid.github.io/rom/asm/1A1B.html</a>
</li>

<li>2DE3: THE 'PRINT A FLOATING-POINT NUMBER' SUBROUTINE<br />
<a href="https://skoolkid.github.io/rom/asm/2DE3.html">https://skoolkid.github.io/rom/asm/2DE3.html</a>
</li>

<li>5C63: STKBOT - Address of bottom of calculator stack<br />
<a href="https://skoolkid.github.io/rom/asm/5C63.html">https://skoolkid.github.io/rom/asm/5C63.html</a>
</li>

<li>5C65: STKEND - Address of start of spare space<br />
<a href="https://skoolkid.github.io/rom/asm/5C65.html">https://skoolkid.github.io/rom/asm/5C65.html</a>
</li>

<li>Why does Sinclair BASIC have two formats for storing numbers in the same structure?<br />
<a href="https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu">https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu</a>
</li>

<li>Chapter 24: The memory<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap24.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap24.html</a>
</li>

<li>Survey of Floating-Point Formats  <br />
<a href="https://mrob.com/pub/math/floatformats.html">https://mrob.com/pub/math/floatformats.html</a>
</li>

<li>Convert an 8bit number to hex in z80 assembler<br />
<a href="https://stackoverflow.com/questions/22838444/convert-an-8bit-number-to-hex-in-z80-assembler">https://stackoverflow.com/questions/22838444/convert-an-8bit-number-to-hex-in-z80-assembler</a>
</li>

<li>80 MICROPROCESSOR Instruction Set Summary<br />
<a href="http://www.textfiles.com/programming/CARDS/z80">http://www.textfiles.com/programming/CARDS/z80</a>
</li>

<li>Extended Binary Coded Decimal Interchange Code<br />
<a href="http://en.wikipedia.org/wiki/EBCDIC">http://en.wikipedia.org/wiki/EBCDIC</a>
</li>

<li>ASCII/EBCDIC Conversion Table<br />
<a href="http://docs.hp.com/en/32212-90008/apcs01.html">http://docs.hp.com/en/32212-90008/apcs01.html</a>
</li>

<li>EBCDIC<br />
<a href="http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php">http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php</a>
</li>

<li>EBCDIC tables<br />
<a href="http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm">http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm</a>
</li>

<li>The Mainframe Blog<br />
<a href="http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html">http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>BCD<br />
<a href="https://cs.wikipedia.org/wiki/BCD">https://cs.wikipedia.org/wiki/BCD</a>
</li>

<li>Z80 heaven: Floating Point<br />
<a href="http://z80-heaven.wikidot.com/floating-point">http://z80-heaven.wikidot.com/floating-point</a>
</li>

<li>Z80, the 8-bit Number Cruncher<br />
<a href="http://www.andreadrian.de/oldcpu/Z80_number_cruncher.html">http://www.andreadrian.de/oldcpu/Z80_number_cruncher.html</a>
</li>

<li>Floating-point library for Z80<br />
<a href="https://github.com/DW0RKiN/Floating-point-Library-for-Z80">https://github.com/DW0RKiN/Floating-point-Library-for-Z80</a>
</li>

<li>z80float<br />
<a href="https://github.com/Zeda/z80float">https://github.com/Zeda/z80float</a>
</li>

<li>ZX Spectrum BASIC Programming - 2nd Edition<br />
<a href="https://archive.org/details/zx-spectrum-basic-programming/page/n167/mode/2up">https://archive.org/details/zx-spectrum-basic-programming/page/n167/mode/2up</a>
</li>

<li>ZX Spectrum BASIC Programming - 2nd Edition<br />
<a href="https://archive.org/details/zx-spectrum-basic-programming/page/n169/mode/2up">https://archive.org/details/zx-spectrum-basic-programming/page/n169/mode/2up</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

