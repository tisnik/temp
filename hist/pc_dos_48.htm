<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Překladače na platformě IBM PC: od assembleru k C</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Překladače na platformě IBM PC: od assembleru k C</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V seriálu o vývoji her a grafických dem pro platformu PC jsme se prozatím zaměřili na assembler. Proč se však více nepoužívaly překladače vyšších programovacích jazyků? Dnes se na tuto otázku pokusíme částečně odpovědět otestováním několika dobových překladačů jazyka C.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Překladače na platformě IBM PC: od assembleru k&nbsp;C</a></p>
<p><a href="#k02">2. Programovací jazyk C</a></p>
<p><a href="#k03">3. Lattice C</a></p>
<p><a href="#k04">4. Aztec C</a></p>
<p><a href="#k05">5. Zortech C</a></p>
<p><a href="#k06">6. Turbo C</a></p>
<p><a href="#k07">7. Borland C++</a></p>
<p><a href="#k08">8. Watcom C/C++</a></p>
<p><a href="#k09">9. Jak kvalitní byly překladače céčka pro IBM PC?</a></p>
<p><a href="#k10">10. Příklad první: funkce pro součet dvou celých čísel</a></p>
<p><a href="#k11">11. Výsledky vygenerované překladačem Borland C++</a></p>
<p><a href="#k12">12. Výsledky vygenerované překladačem Watcom C/C++</a></p>
<p><a href="#k13">13. Příklad druhý: vyplnění paměťového bloku</a></p>
<p><a href="#k14">14. Výsledky vygenerované překladačem Borland C++</a></p>
<p><a href="#k15">15. Výsledky vygenerované překladačem Watcom C/C++</a></p>
<p><a href="#k16">16. Příklad třetí: nalezení prvku v&nbsp;poli s&nbsp;maximální hodnotou</a></p>
<p><a href="#k17">17. Výsledky vygenerované překladačem Borland C++</a></p>
<p><a href="#k18">18. Výsledky vygenerované překladačem Watcom C/C++</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Překladače na platformě IBM PC: od assembleru k&nbsp;C</h2>

<p>V&nbsp;seriálu o <a
href="https://www.root.cz/serialy/vyvoj-her-a-grafickych-dem-pro-platformu-pc/">vývoji
her a grafických dem pro platformu PC</a> jsme prozatím pro tvorbu příkladů
používali assembler. V&nbsp;prvních přibližně deseti letech existence platformy
IBM PC se skutečně jednalo o primární jazyk využívaný pro tvorbu
profesionálních aplikací. Příkladem takové aplikace může být textový procesor
<i>WordStar</i> nebo tabulkový procesor <i>VisiCalc</i> (předchůdce Lotusu
1-2-3 a vlastně i Excelu). A v&nbsp;assembleru byla vytvořena i celá řada her.
Proč se však nepoužívaly překladače vyšších programovacích jazyků? Takové
překladače pochopitelně existovaly, ostatně první překladač céčka byl na IBM PC
portován již rok po vzniku této platformy. Ovšem kvalita výsledného strojového
kódu nebyla příliš dobrá, protože tyto překladače většinou neprováděly velké
optimalizace. A nutno říci, že i samotná mikroprocesorová architektura 80x86
tvůrcům překladačů nebyla příliš nápomocná (na rozdíl od RISCových
architektur).</p>

<img src="http://i.iinfo.cz/images/640/d4-2.png" class="image-215143" width="441" height="479" alt="&#160;" />
<p><i>Obrázek 1: Dobová reklama na textový editor WordStar.</i></p>

<p>V&nbsp;dnešním článku se nejdříve zmíníme o některých překladačích jazyka C,
které byly dostupné pro platformu IBM PC a posléze si na trojici příkladů
vyzkoušíme, jak kvalitní nebo nekvalitní vlastně překlad ve skutečnosti byl a
proč programátoři poměrně dlouhou dobu zůstávali u assembleru.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programovací jazyk C</h2>

<p>Jedním <a
href="https://www.tiobe.com/tiobe-index/">z&nbsp;nejpopulárnějších</a>
v&nbsp;současnosti používaných programovacích jazyků je stále (což je
mimochodem zajímavé a hodně to vypovídá o realitě v&nbsp;IT) programovací jazyk
C navržený <i>Dennisem Ritchiem</i>. Historie céčka je dobře známá: jazyk C se
postupně vyvinul z&nbsp;programovacích jazyků BPCL (autor <i>Martin
Richards</i>, 1966) a B (autor <i>Ken Thompson</i>, 1970) až do současné
podoby, která byla standardizována v&nbsp;několika normách, z&nbsp;nichž
nejznámější je pravděpodobně stále ještě ISO/IEC 9899:1999 známá pod zkráceným
označením <i>C99</i>. Následovala specifikace <i>C11</i> neboli ISO/IEC
9899:2011, <i>C17</i> neboli ISO/IEC 9899:2018 a konečně <i>C23</i> neboli
ISO/IEC 9899:2024. Starší, dodnes v&nbsp;některých případech stále ještě
používaný standard, se jmenuje ISO 9899:1990. Tento starší standard je
prakticky shodný (až na jiné číslování jednotlivých paragrafů) s&nbsp;normou
ANSI C (ANSI X3.159-1989 &bdquo;Programming Language C&ldquo;) a zkráceně se
označuje <i>C89</i> či méně často <i>C90</i> (taktéž jen ANSI/ISO C).</p>

<img src="https://i.iinfo.cz/images/571/c-mos-6502-1.png" class="image-661833" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="309" height="400" />
<p><i>Obrázek 2: Přebal druhého vydání slavné knihy &bdquo;The C Programming
Language&ldquo; (Kerningan, Ritchie)</i></p>

<p>Programovací jazyk C je i přes absenci některých důležitých vlastností
(například mu chybí automatický správce paměti či podpora silného typování a
práce s&nbsp;objekty, výjimkami, uzávěry, pattern matchingem atd.) využívaný
jak pro tvorbu open source aplikací, tak i v&nbsp;čistě komerční oblasti
&ndash; nejedná se jen o vývoj aplikací pro desktopy a servery, ale i pro
mikrořadiče či digitální signálové procesory (DSP). Céčko je mnohdy využíváno i
ve funkci cílového jazyka, do něhož se překládají (<i>transpilují</i>) programy
zapsané v&nbsp;některých vyšších programovacích jazycích &ndash; vývojáři,
kteří překladače těchto jazyků vytváří, se tak nemusí starat například o
nízkoúrovňové optimalizace, protože je za ně již naprogramovali vývojáři
překladače céčka. Z&nbsp;historického hlediska, které nás dnes do jisté míry
zajímá, je poměrně typické, že právě tímto způsobem vznikla první verze jazyka
C++ (nástroj Cpre), i když moderní překladače C++ jsou již řešeny od C
odděleně.</p>

<p>To však není zdaleka vše, protože programovací jazyk C je dodnes důležitý i
z&nbsp;toho důvodu, že jak rozhraní jader některých operačních systémů (Linux,
Microsoft Windows i dalších systémů), tak rozhraní systémových knihoven bylo
navrženo s&nbsp;ohledem na jmenné konvence céčka i s&nbsp;ohledem na možnosti
jeho linkeru (a ostatní jazyky toto rozhraní s&nbsp;většími či menšími problémy
dodržují).</p>

<p>Nás však dnes budou zajímat především starší překladače určené pro operační
systém (MS) DOS a tedy pro platformu IBM PC. Těchto překladačů vznikla celá
řada a zajímavé je, že některé z&nbsp;nich vlastně vznikly portací překladače
z&nbsp;jiných platforem, ať již se jednalo o osmibitové mikroprocesory na
straně jedné či o Unixové systémy na druhé straně výkonnostního spektra.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Lattice C</h2>

<p>Pravděpodobně prvním překladačem programovacího jazyka C, který byl vytvořen
pro platformu IBM PC, byl <i>Lattice C</i> pocházející z&nbsp;roku 1982
(samotné PC přitom začalo být nabízeno jen o rok dříve). Tento překladač byl
později převeden i na Amigu (a byl zde poměrně populární) a dále se rozšířil i
na minipočítače a mainframy společnosti IBM. Jeho hardwarové nároky byly
dnešním pohledem směšně nízké: PC s&nbsp;původním mikroprocesorem Intel 8088
taktovaným na 4,77 MHz, paměť RAM o kapacitě 256kB (původní PC ovšem mohlo mít
i jen 16kB RAM!) a disketová mechanika.</p>

<p>Zajímavé bylo, že společnost Microsoft překladač <i>Lattice C</i> nabízela
pod svým názvem <i>MSC (Microsoft C)</i> (i když autorem byla firma <i>Lifeboat
Associates</i>) a teprve verze <i>MSC 4.0</i> byla skutečně vytvořena přímo
programátory z&nbsp;Microsoftu. <i>Lattice C</i> byl využíván i při portaci
aplikací z&nbsp;operačního systému <i>CP/M</i> na systém DOS. Dnes je však
poměrně těžké odhadnout, kolik zdrojového kódu bylo skutečně napsáno
v&nbsp;céčku a kolik kódu vzniklo transformací assembleru. Jedním
z&nbsp;nedostatků Lattice C byla jeho vysoká cena 500 dolarů. To později
zjednodušilo přístup na trh s&nbsp;překladači takovým firmám, jako je Borland
apod., jejichž cenová politika byla zcela opačná.</p>

<img src="http://i.iinfo.cz/images/15/gamesc4.jpg" class="image-161782" width="450" height="265" alt="&#160;" />
<p><i>Obrázek 3: Lattice C.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Aztec C</h2>

<p>Dalším kdysi známým překladačem programovacího jazyka C, který byl kromě
platformy IBM PC dostupný mj.&nbsp;i pro osobní mikropočítače <i>Amiga</i>, byl
překladač nazvaný <i>Aztec C</i> společnosti <i>Manx Software Systems</i>.
Jednalo se o ve své době velmi úspěšný překladač, jenž existoval jak ve verzi
pro osmibitové mikroprocesory (MOS 6502, Zilog Z-80), tak i pro mikroprocesory
16bitové (včetně Intelu 8088) a 32bitové (řada Motorola 68000). Tento překladač
byl velmi úspěšný právě na Amize, kde byl používán, společně s&nbsp;výše
zmíněným <i>Lattice C</i>, prakticky až do faktického zániku této
platformy.</p>

<p>Ovšem na druhé straně na platformě IBM PC jeho sláva netrvala dlouho,
především z&nbsp;toho důvodu, že firma Microsoft považovala segment překladačů
za poměrně důležitý a snažila se vytlačit jakoukoli konkurenci z&nbsp;trhu (i
když ve skutečnosti v&nbsp;té době ještě stále neměla vlastní céčkový
překladač). Autorem Aztec C, jímž byla společnost <i>Manx Software Systems</i>,
se navíc postupně zmenšoval počet platforem, na něž bylo možné překladač
prodávat a přechod na podporu vestavěných systémů již přišel dosti pozdě.</p>

<img src="http://i.iinfo.cz/images/365/gamesc3.jpg" class="image-161781" width="450" height="259" alt="&#160;" />
<p><i>Obrázek 4: Logo překladačů Aztec C.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zortech C</h2>

<p>Za vývojem překladače <i>Zortech C</i> stála společnost <i>Digital Mars</i>.
Tato firma vytvořila a prodávala (a vlastně i doposud prodává) překladače
jazyků C, C++ a D. V&nbsp;dnešním článku se ovšem zaměříme pouze na klasické
céčko, resp.&nbsp;překladače dostupné pro platformu IBM PC. Původní překladač
jazyka C od společnosti Digial Mars se jmenoval <i>Small-C</i>, ovšem
nepokrýval všechny vlastnosti jazyka C. První překladač skutečného céčka vznikl
až v&nbsp;roce 1987 a jmenoval se <i>Datalight C</i>. Poté postupným vývojem
vznikly další varianty překladače céčka a zajímavé je, že se měnil i jejich
název. Po <i>Datalight C</i> začal být nabízen <i>Zorland C</i> (reference na
konkurenční Borland?), <i>Zortech C</i> a <i>Digital Mars C/C++</i>.
Pravděpodobně nejvíce rozšířený a nejznámější byla právě varianta nazvaná
<i>Zortech C</i> (existoval i <i>Zortech C++</i>). Ten v&nbsp;benchmarcích
porážel konkurenci &ndash; Microsoft C 5.1 i Watcom C 6.5 (a pochopitelně i
překladač Turbo C a Borland C++).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Turbo C</h2>

<p>Dalším známým překladačem programovacího jazyka C pro platformu IBM PC je
překladač, nad kterým bylo postaveno integrované vývojové prostředí <i>Turbo
C</i>. Tento produkt společnosti Borland (která je známá především díky svému
Turbo Pascalu a později Delphi) byl vydán v&nbsp;roce 1987. Zajímavé je, že
tato první verze vyžadovala ke svému běhu pouze 384kB RAM a obsahovala podporu
pro zápis subrutin (podprogramů) v&nbsp;assembleru, který měl navíc přístup ke
všem céčkovským symbolům. Navíc díky tomu, že překladač neprováděl prakticky
žádné optimalizace, byla tvorba subrutin v&nbsp;assembleru snadná (to dnes již
není možné &ndash; je totiž nutné překladači napovídat).</p>

<a href="https://www.root.cz/obrazek/368430/"><img src="https://i.iinfo.cz/images/579/tp02-3-prev.png" class="image-368430" alt="&#160;" width="370" height="231" /></a></p>
<p><i>Obrázek 5: Uživatelské rozhraní Turbo Pascalu 5.5. Vidíme zde klasické
&bdquo;modré&ldquo; IDE.</i></p>

<p>O rok později, tj.&nbsp;v&nbsp;roce 1988, byla vydána verze Turbo C 1.5. Ta
již poněkud nabobtnala &ndash; byla dodávána na pěti disketách s&nbsp;kapacitou
360kB (což je ovšem z&nbsp;dnešního pohledu prakticky &bdquo;nic&ldquo;). A
konečně taktéž v&nbsp;roce 1988 byla ještě vydána verze 2.0, která byla
vybavena známým &bdquo;modrým IDE&ldquo;, které se stalo pro produkty
společnosti Borland typické. Tato verze obsahovala i podporu pro <i>Turbo
Debugger</i> a <i>Turbo Assembler</i>.</p>

<a href="http://www.root.cz/obrazek/229450/"><img src="http://i.iinfo.cz/images/386/tp01-prev.png" class="image-229450" alt="&#160;" height="231" width="370" /></a>
<p><i>Obrázek 6: Dialog se základními informacemi o IDE Turbo Pascal
7.0.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Borland C++</h2>

<p>V&nbsp;roce 1990 byl vydán <i>Turbo C++</i>, čímž vlastně skončila historie
<i>Turbo C</i> zmíněného <a href="#k06">v&nbsp;předchozí kapitole</a>. Jak již
název napovídá, jednalo se o IDE s&nbsp;překladačem jazyka C++, který ovšem
dokázal pracovat i s&nbsp;čistým céčkem. I tento produkt se postupně vyvíjel.
Verze 2.0 se již jmenovala <i>Borland C++</i>; právě tuto verzi z&nbsp;roku
1991 použijeme v&nbsp;demonstračních příkladech.</p>

<a href="https://www.root.cz/obrazek/1193290/"><img src="https://i.iinfo.cz/images/52/pc-compilers-1-1-prev.png" class="image-1193290" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/52/pc-compilers-1-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-1-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/52/pc-compilers-1-1-large.png" data-large-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-1-large.webp" data-large-width="700" data-large-height="525" alt="Prekladace pro IBM PC a DOS" data-description="&nbsp;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 7: Integrované vývojové prostředí Borland C++ verze 2.0.</i></p>

<p>Zajímavá je verze 3.0 (taktéž z&nbsp;roku 1991), která podporovala překlad
aplikací pro Microsoft Windows.  V&nbsp;roce 1992 byla vydána verze 3.1
s&nbsp;podporou dvou frameworků pro tvorbu aplikací s&nbsp;grafickým
uživatelským rozhraním: <i>OWL</i> (Windows) a <i>Turbovision</i> (DOS).
Historie Borland C++ pro operační systém DOS se tímto uzavírá, protože verze
4.0 z&nbsp;roku 1993 je již určena pro Windows 3.x.</p>

<a href="https://www.root.cz/obrazek/1193293/"><img src="https://i.iinfo.cz/images/52/pc-compilers-1-2-prev.png" class="image-1193293" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/52/pc-compilers-1-2-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-2-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/52/pc-compilers-1-2-large.png" data-large-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-2-large.webp" data-large-width="700" data-large-height="525" alt="Prekladace pro IBM PC a DOS" data-description="&nbsp;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 8: Dialog s&nbsp;nastavením optimalizací překladače je poměrně
jednoduchý. Tento překladač ostatně více optimalizací ani nepodporoval.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Watcom C/C++</h2>

<p>Dalším důležitým překladačem jazyka C pro platformu IBM PC je <i>Watcom
C/C++</i>, který byl v&nbsp;roce 1988 vydán kanadskou společností <i>Watcom
International Corporation</i>. I tato společnost, podobně jako výše zmíněný
Borland nebo Digital Mars, produkovala různá vývojové nástroje. Prvním
z&nbsp;nich byl <i>Waterloo BASIC</i>, jenž byl portován na různé počítače (IBM
370, IBM 4300 atd.). Později byly vydány i další vývojové nástroje, například
<i>Watcom APL</i>, <i>Watcom GKS</i>, <i>Watcom COBOL</i>, <i>Watcom
FORTRAN</i>, <i>Watcom Pascal</i> a <i>Waterloo 6809 Assembler</i> (zde je
zřejmé, pro jaké mikroprocesory byl určen). Ovšem nás nejvíce zajímá právě
<i>Watcom C/C++</i>, protože tento překladač je známý podporou různých
optimalizací výsledného kódu. V&nbsp;benchmarcích bez problémů porážel
překladače od Borlandu a většinou i od Microsoftu.</p>

<a href="https://www.root.cz/obrazek/1193296/"><img src="https://i.iinfo.cz/images/52/pc-compilers-1-3-prev.png" class="image-1193296" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/52/pc-compilers-1-3-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-3-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/52/pc-compilers-1-3-large.png" data-large-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-3-large.webp" data-large-width="700" data-large-height="525" alt="Prekladace pro IBM PC a DOS" data-description="&nbsp;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 9: Integrované vývojové prostředí Open Watcomu.</i></p>

<p>Watcom C/C++ sice již není vyvíjen komerčně, ovšem existuje <i>Open Watcon
C/C++</i>, který je možné si nainstalovat a vyzkoušet; kromě moderních systémů
i v&nbsp;emulátorech PC a DOSu.</p>

<a href="https://www.root.cz/obrazek/1193299/"><img src="https://i.iinfo.cz/images/52/pc-compilers-1-4-prev.png" class="image-1193299" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/52/pc-compilers-1-4-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-4-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/52/pc-compilers-1-4-large.png" data-large-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-4-large.webp" data-large-width="700" data-large-height="525" alt="Prekladace pro IBM PC a DOS" data-description="&nbsp;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 10: Watcom nezapře své kořeny v&nbsp;prostředí odlišném od IBM
PC. Programy se v&nbsp;něm tvořily v&nbsp;editoru <strong>vi</strong>,
resp.&nbsp;v&nbsp;jeho upravené variantě.</i></p>

<a href="https://www.root.cz/obrazek/1193302/"><img src="https://i.iinfo.cz/images/52/pc-compilers-1-5-prev.png" class="image-1193302" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/52/pc-compilers-1-5-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-5-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/52/pc-compilers-1-5-large.png" data-large-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-5-large.webp" data-large-width="700" data-large-height="525" alt="Prekladace pro IBM PC a DOS" data-description="&nbsp;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 11: Nastavení editoru <strong>vi</strong> pro Watcom.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Jak kvalitní byly překladače céčka pro IBM PC?</h2>

<p>Jak již bylo napsáno v&nbsp;úvodu dnešního článku, používal se na platformě
IBM PC pro tvorbu profesionálního software poměrně dlouho assembler (tedy jazyk
symbolických instrukcí). Bylo tomu tak z&nbsp;toho důvodu, že překladače jazyka
C zpočátku nebyly příliš kvalitní, minimálně ne z&nbsp;pohledu optimalizací (a
některé překladače byly navíc chybové nebo neodpovídaly normě C, to je však
jiné téma). Jak uvidíme v&nbsp;demonstračních příkladech uvedených
v&nbsp;navazujících kapitolách, prováděly některé céčkové překladače poněkud
šablonovitý překlad; ostatně se o programovacím jazyku C někdy s&nbsp;nadsázkou
říká, že je to &bdquo;přenositelný assembler&ldquo; [<a
href="https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler">1</a>].</p>

<a href="https://www.root.cz/obrazek/1193308/"><img src="https://i.iinfo.cz/images/52/pc-compilers-1-7-prev.png" class="image-1193308" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/52/pc-compilers-1-7-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-7-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/52/pc-compilers-1-7-large.png" data-large-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-7-large.webp" data-large-width="700" data-large-height="525" alt="Prekladace pro IBM PC a DOS" data-description="&nbsp;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 12: Přepínače překladače Watcom C/C++, mezi nimiž
nalezneme i několik přepínačů ovlivňujících optimalizace.</i></p>

<p>Teprve později začaly být překladače céčka vybavovány více či méně
kvalitními optimalizacemi výsledného strojového kódu. To však vyžadovalo větší
nároky na operační paměť, delší dobu překladu a horší podporu pro ladění
(resp.&nbsp;krokování). Proto je optimalizaci prakticky nutné explicitně
povolit a nastavit její vlastnosti.</p>




<p><a name="k10"></a></p>
<h2 id="k10">10. Příklad první: funkce pro součet dvou celých čísel</h2>

<p>První demonstrační příklad, na kterém si ověříme kvalitu nebo naopak
nekvalitu překladačů jazyka C, je vlastně triviální. Jedná se o funkci se dvěma
parametry typu &bdquo;celé číslo&ldquo; (ať to znamená cokoli), která vrací
součet hodnot těchto dvou parametrů. Implementace takové funkce je
jednoduchá:</p>

<pre>
int <strong>add</strong>(int a, int b) {
    return a+b;
}
</pre>

<p>Jen pro zajímavost se podívejme, jak dopadne výsledek překladu na moderní
architektuře x86-64 s&nbsp;využitím překladačů GCC a Clang.</p>

<p>Překlad s&nbsp;využitím GCC nebo Clang s&nbsp;vypnutými optimalizacemi
(výsledky jsou totožné):</p>

<pre>
<strong>add</strong>:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     edx, DWORD PTR [rbp-4]
        mov     eax, DWORD PTR [rbp-8]
        add     eax, edx
        pop     rbp
        ret
</pre>

<p>Překlad s&nbsp;využitím GCC nebo Clang se zapnutými maximálními
optimalizacemi (výsledky jsou opět totožné):</p>

<pre>
<strong>add</strong>:
        lea     eax, [rdi+rsi]
        ret
</pre>

<p>Zde stojí za zmínku, že platforma x86-64 má svá specifika. Prvním
z&nbsp;nich je, že typ <strong>int</strong> je 64bitový a druhým je možnost
NEpoužívat předávání parametrů přes zásobníkový rámec. Celočíselné hodnoty jsou
totiž předávány v&nbsp;registrech RDI, RSI, RDX, RCX, R8 a R9 (v&nbsp;tomto
pořadí). Viz AMD64 ABI.</p>

<a href="https://www.root.cz/obrazek/1193311/"><img src="https://i.iinfo.cz/images/52/pc-compilers-1-8-prev.png" class="image-1193311" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/52/pc-compilers-1-8-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-8-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/52/pc-compilers-1-8-large.png" data-large-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-8-large.webp" data-large-width="700" data-large-height="525" alt="Prekladace pro IBM PC a DOS" data-description="&nbsp;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 13: Nainstalovaný překladač Borland C++ 2.0.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výsledky vygenerované překladačem Borland C++</h2>

<p>Překladač Borland C++ nabízí volbu <strong>-B</strong>, která zajistí, že se
zdrojový kód z&nbsp;jazyka C přeloží do assembleru a ve druhé fázi dojde
k&nbsp;překladu z&nbsp;assembleru do strojového kódu. Pokud tuto volbu
použijeme, bude assemblerovský zdrojový kód obsahovat mj.&nbsp;i naši funkci
<strong>add</strong>, která má ovšem externí symbol <strong>_add</strong>:</p>

<pre>
_TEXT   segment byte public 'CODE'
        assume  cs:_TEXT
_add    proc    near
        push    bp
        mov     bp,sp
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
        jmp     short @1@50
@1@50:
        pop     bp
        ret     
_add    endp
        ?debug  C E9
_TEXT   ends
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si typického
&bdquo;prologu&ldquo; a &bdquo;epilogu&ldquo; funkce, který slouží
k&nbsp;vytvoření a zrušení zásobníkového rámce:</div></p>

<pre>
        <i>; prolog</i>
        push    bp
        mov     bp,sp
</pre>

<p>a:</p>

<pre>
        <i>; epilog</i>
        pop     bp
        ret     
</pre>

<p>Taktéž stojí za povšimnutí zbytečné skoky, které překladač do kódu vkládá a
které lze odstranit zapnutím optimalizací:</p>

<pre>
        jmp     short @1@50
@1@50:
</pre>

<p>Pro snadnější čtení vygenerovaného assembleru můžeme snadno překladač
nastavit tak, aby k&nbsp;externím symbolům nepřidával na začátek podtržítko.
Výsledek bude prakticky totožný s&nbsp;předchozím příkladem, ovšem bude se
lišit návěští <strong>_add</strong> od <strong>add</strong>:</p>

<pre>
_TEXT   segment byte public 'CODE'
        assume  cs:_TEXT
add     proc    near
        push    bp
        mov     bp,sp
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
        jmp     short @1@50
@1@50:
        pop     bp
        ret     
add     endp
        ?debug  C E9
_TEXT   ends
</pre>

<p>Zajímavější je však přepínač <strong>-S</strong>, jenž povolí překlad přímo
do assembleru (nic dalšího). Nyní bude výsledný kód zkombinován
s&nbsp;poznámkami obsahujícími původní céčkovskou funkci:</p>

<pre>
   ;    
   ;    int add(int a, int b) {
   ;    
        assume  cs:_TEXT
_add    proc    near
        push    bp
        mov     bp,sp
   ;    
   ;        return a+b;
   ;    
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
        jmp     short @1@50
@1@50:
   ;    
   ;    }
   ;    
        pop     bp
        ret     
_add    endp
</pre>

<p>Popř.&nbsp;se zákazem vložení podtržítka do jmen externích symbolů:</p>

<pre>
   ;    
   ;    int add(int a, int b) {
   ;    
        assume  cs:_TEXT
add     proc    near
        push    bp
        mov     bp,sp
   ;    
   ;        return a+b;
   ;    
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
        jmp     short @1@50
@1@50:
   ;    
   ;    }
   ;    
        pop     bp
        ret     
add     endp
</pre>

<p>Z&nbsp;výsledků je patrné, že hodnoty typu <strong>int</strong> jsou
šestnáctibitové (což v&nbsp;DOSu není překvapující) a taktéž to, že se
parametry předávají přes zásobník, tvoří se standardní zásobníkový rámec
(<i>stack frame</i>) a návratová hodnota je předána v&nbsp;registur
<strong>AX</strong>. Typická je zejména tvorba zásobníkového rámce kombinací
instrukcí:</p>

<pre>
        push    bp
        mov     bp,sp
</pre>

<p>s&nbsp;jeho odstraněním na konci:</p>

<pre>
        pop     bp
        ret     
</pre>

<p>Překladače Borland navíc často generují zbytečné skoky (na další pozici
v&nbsp;paměti):</p>

<pre>
        jmp     short @1@50
@1@50:
</pre>

<p>Tyto skoky lze ze strojového kódu snadno odstranit &ndash; ostatně jedná se
o jednu z&nbsp;pouhých tří optimalizací, které tento překladač umožňuje:</p>

<pre>
   ;    
   ;    int add(int a, int b) {
   ;    
        assume  cs:_TEXT
add     proc    near
        push    bp
        mov     bp,sp
   ;    
   ;        return a+b;
   ;    
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
   ;    
   ;    }
   ;    
        pop     bp
        ret     
add     endp
</pre>

<p><div class="rs-tip-major">Poznámka: prozatím tedy překladač Borland C++
příliš neoslnil.</div></p>

<a href="https://www.root.cz/obrazek/1193314/"><img src="https://i.iinfo.cz/images/52/pc-compilers-1-9-prev.png" class="image-1193314" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/52/pc-compilers-1-9-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-9-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/52/pc-compilers-1-9-large.png" data-large-filename-webp="https://i.iinfo.cz/images/52/pc-compilers-1-9-large.webp" data-large-width="700" data-large-height="525" alt="Prekladace pro IBM PC a DOS" data-description="&nbsp;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 14: Překlad provedený přímo v&nbsp;integrovaném vývojovém
prostředí.</i></p>


<p><i>Obrázek 15: Nastavení optimalizací při překladu.</i></p>




<p><a name="k12"></a></p>
<h2 id="k12">12. Výsledky vygenerované překladačem Watcom C</h2>

<p>Podívejme se, jak se s&nbsp;překladem funkce <strong>add</strong> vypořádal
známý Watcom C, který byl dlouho považován za nejlépe optimalizující překladač
pro platformu IBM PC. Nejdřív si uvedeme výsledek překladu s&nbsp;vypnutými
optimalizacemi:</p>

<pre>
Module: C:\add.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 0000000B bytes
0000                          add_:
0000    50                        push        ax 
0001    B8 02 00                  mov         ax,0x0002 
0004    E8 00 00                  call        __STK 
0007    58                        pop         ax 
0008    01 D0                     add         ax,dx 
000A    C3                        ret         
&nbsp;
Routine Size: 11 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p>Z&nbsp;výsledků je patrné, že typ <strong>int</strong> je
v&nbsp;šestnáctibitovém DOSu taktéž šestnáctibitový. Parametry jsou předávány
v&nbsp;registrech <strong>AX</strong> a <strong>DX</strong>, výsledek se vrací
v&nbsp;registru <strong>AX</strong>. Navíc se zde explicitně volá subrutina
<strong>__STK</strong>, která kontroluje přetečení zásobníku v&nbsp;závislosti
na jeho velikosti předané v&nbsp;registru <strong>AX</strong>. Výsledný kód
tedy není zcela ideální, ale není ani nejhorší možný.</p>

<p>Po zapnutí všech optimalizací ovšem získáme mnohem lepší výsledek. Celá
funkce se zkrátila na jediný součet a návrat ze subrutiny:</p>

<pre>
Module: C:\add.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 00000003 bytes
0000                          add_:
0000    01 D0                     add         ax,dx 
0002    C3                        ret         
&nbsp;
Routine Size: 3 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p><div class="rs-tip-major">Poznámka: překlad do objektového kódu byl proveden
s&nbsp;využitím <strong>WCC</strong>, zpětnou transformaci do assembleru
zajistila utilita <strong>WDIS</strong>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příklad druhý: vyplnění paměťového bloku</h2>

<p>Druhý testovací příklad naprogramovaný v&nbsp;jazyku C obsahuje definici
funkce, která dokáže vyplnit paměťový blok začínající na zadané adrese a mající
určitou (opět zadanou) délku. Tento příklad je upraven do podoby, která by měla
do značné míry pomoci překladačům &ndash; využívá se zde přístup přes ukazatel
(ne přes index), programová smyčka má ten nejjednodušší možný tvar atd. A
zápisy se provádí po bajtech:</p>

<pre>
#include &lt;mem.h&gt;
&nbsp;
void * <strong>memset</strong>(void *dest, register int val, register size_t len) {
    register unsigned char *ptr = (unsigned char*)dest;
    while (len-- &gt; 0)
        *ptr++ = val;
    return dest;
}
</pre>

<p><div class="rs-tip-major">Poznámka: zde překladačům do jisté míry pomáháme,
protože namísto přístupu do paměti přes index (pole) využíváme přímý přístup
přes ukazatel.</div></p>

<p>Ještě než se podíváme na způsob překladu staršími překladači céčka pro IBM
PC, podívejme se na překlad s&nbsp;využitím moderních překladačů. Nejdříve GCC
bez povolených optimalizací:</p>

<pre>
<strong>memset</strong>:
        push    rbp
        mov     rbp, rsp
        push    rbx
        mov     QWORD PTR [rbp-16], rdi
        mov     ecx, esi
        mov     eax, edx
        mov     rbx, QWORD PTR [rbp-16]
        jmp     .L2
.L3:
        mov     rdx, rbx
        lea     rbx, [rdx+1]
        mov     esi, ecx
        mov     BYTE PTR [rdx], sil
.L2:
        mov     edx, eax
        lea     eax, [rdx-1]
        test    edx, edx
        jne     .L3
        mov     rax, QWORD PTR [rbp-16]
        mov     rbx, QWORD PTR [rbp-8]
        leave
        ret
</pre>

<p>Zde je patrné, že se programová smyčka transformovala poměrně otrockým způsobem.</p>

<p>Překlad s&nbsp;využitím optimalizací je odlišný. Povšimněte si zde registru
<strong>SIL</strong> (dolních osm bitů registru <strong>ESI</strong>, výchozí
registr pro parametr funkce) a instrukce <strong>MOVZX</strong>, která provádí
rozšíření operandu s&nbsp;menší bitovou šířkou do výsledku s&nbsp;větší bitovou
šířkou:</p>

<pre>
<strong>memset</strong>:
        test    edx, edx
        je      .L2
        mov     edx, edx
        movzx   esi, sil
        jmp     memset
.L2:
        mov     rax, rdi
        ret
</pre>

<p>Ovšem možná je i &bdquo;vektorizace&ldquo; kódu, která využívá toho, že u
delších paměťových bloků lze využít zápis širšího (zarovnaného) slova. Právě
zde se ukazuje význam překladačů oproti assembleru, protože ruční tvorba
takového kódu je sice možná, ale pracná:</p>

<pre>
<strong>memset</strong>:
        mov     rax, rdi
        test    rdx, rdx
        je      .LBB0_8
        cmp     rdx, 4
        jae     .LBB0_3
        mov     r8, rax
.LBB0_14:
        mov     r9, rdx
        jmp     .LBB0_15
.LBB0_3:
        movzx   edi, sil
        cmp     rdx, 32
        jae     .LBB0_9
        xor     ecx, ecx
        jmp     .LBB0_5
.LBB0_9:
        mov     rcx, rdx
        and     rcx, -32
        movd    xmm0, edi
        punpcklbw       xmm0, xmm0
        pshuflw xmm0, xmm0, 0
        pshufd  xmm0, xmm0, 68
        xor     r8d, r8d
.LBB0_10:
        movdqu  xmmword ptr [rax + r8], xmm0
        movdqu  xmmword ptr [rax + r8 + 16], xmm0
        add     r8, 32
        cmp     rcx, r8
        jne     .LBB0_10
        cmp     rdx, rcx
        je      .LBB0_8
        test    dl, 28
        je      .LBB0_13
.LBB0_5:
        mov     r10, rdx
        and     r10, -4
        lea     r8, [rax + r10]
        mov     r9d, edx
        and     r9d, 3
        movd    xmm0, edi
        punpcklbw       xmm0, xmm0
        pshuflw xmm0, xmm0, 0
.LBB0_6:
        movd    dword ptr [rax + rcx], xmm0
        add     rcx, 4
        cmp     r10, rcx
        jne     .LBB0_6
        cmp     rdx, r10
        je      .LBB0_8
.LBB0_15:
        xor     ecx, ecx
.LBB0_16:
        mov     byte ptr [r8 + rcx], sil
        inc     rcx
        cmp     r9, rcx
        jne     .LBB0_16
.LBB0_8:
        ret
.LBB0_13:
        add     rcx, rax
        and     edx, 31
        mov     r8, rcx
        jmp     .LBB0_14
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;DOSu budou výsledky jiné, protože
se bude jednat o šestnáctibitový kód.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výsledky vygenerované překladačem Borland C++</h2>

<p>Podívejme se nyní na způsob překladu funkce <strong>memset</strong>
překladačem Borland C++ 2.0. V&nbsp;případě, že nejsou povoleny optimalizace,
je výsledkem kód, který sice není z&nbsp;dnešního pohledu optimální, ovšem
alespoň ve vnitřní smyčce využívá pracovní registry (samozřejmě se zápisem
hodnoty prvku do paměti):</p>

<pre>
@1@50:
        mov     al,dl
        mov     byte ptr [si],al
        inc     si
@1@74:
        mov     ax,di
        dec     di
        or      ax,ax
        ja      short @1@50
</pre>

<p>Nejedná se o ideální kód, protože se zde registr AX/AL používá ve dvou
významech, což je zbytečné, protože by namísto toho bylo možné využít další
pracovní registr. I test na ukončení počítané smyčky lze napsat jednodušeji.
Celý kód přeložené funkce <strong>memset</strong> vypadá takto:</p>

<pre>
_TEXT   segment byte public 'CODE'
   ;    
   ;    void * memset(void *dest, register int val, register size_t len) {
   ;    
        assume  cs:_TEXT
memset  proc    near
        push    bp
        mov     bp,sp
        push    si
        push    di
        mov     bx,word ptr [bp+4]
        mov     dx,word ptr [bp+6]
        mov     di,word ptr [bp+8]
   ;    
   ;        register unsigned char *ptr = (unsigned char*)dest;
   ;    
        mov     si,bx
        jmp     short @1@74
@1@50:
   ;    
   ;        while (len-- &gt; 0)
   ;            *ptr++ = val;
   ;    
        mov     al,dl
        mov     byte ptr [si],al
        inc     si
@1@74:
        mov     ax,di
        dec     di
        or      ax,ax
        ja      short @1@50
   ;    
   ;        return dest;
   ;    
        mov     ax,bx
        jmp     short @1@122
@1@122:
   ;    
   ;    }
   ;    
        pop     di
        pop     si
        pop     bp
        ret     
memset  endp
        ?debug  C E9
_TEXT   ends
_DATA   segment word public 'DATA'
s@      label   byte
_DATA   ends
_TEXT   segment byte public 'CODE'
_TEXT   ends
        public  memset
        end
</pre>

<p>Jedinou optimalizaci, kterou dovede překladač provést, je odstranění
zbytečného skoku (což ale vlastně není optimalizace kódu, ale optimalizace
&bdquo;smetí&ldquo; vložených samotným překladačem):</p>

<pre>
        jmp     short @1@122
@1@122:
</pre>

<p>A takto vypadá &bdquo;optimalizovaná&ldquo; varianta přeložené funkce
<strong>memset</strong>:</p>

<pre>
_TEXT   segment byte public 'CODE'
   ;    
   ;    void * memset(void *dest, register int val, register size_t len) {
   ;    
        assume  cs:_TEXT
memset  proc    near
        push    bp
        mov     bp,sp
        push    si
        push    di
        mov     bx,word ptr [bp+4]
        mov     dx,word ptr [bp+6]
        mov     di,word ptr [bp+8]
   ;    
   ;        register unsigned char *ptr = (unsigned char*)dest;
   ;    
        mov     si,bx
        jmp     short @1@74
@1@50:
   ;    
   ;        while (len-- &gt; 0)
   ;            *ptr++ = val;
   ;    
        mov     al,dl
        mov     byte ptr [si],al
        inc     si
@1@74:
        mov     ax,di
        dec     di
        or      ax,ax
        ja      short @1@50
   ;    
   ;        return dest;
   ;    
        mov     ax,bx
   ;    
   ;    }
   ;    
        pop     di
        pop     si
        pop     bp
        ret     
memset  endp
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výsledky vygenerované překladačem Watcom C</h2>

<p>Překladač Watcom dokázal vnitřní smyčku přeložit s&nbsp;testem na začátku.
Konkrétně se zde testuje podtečení hodnoty přes nulu (což je samo o sobě
zajímavé):</p>

<pre>
L$1:
    dec         ax 
    cmp         ax,0xffff 
    je          L$2 
    mov         byte ptr [bx],dl 
    inc         bx 
    jmp         L$1 
L$2:
</pre>

<p>Takto vypadá celý kód vygenerovaný Watcom C a zpětně přeložený přes jeho
disassembler při vypnutých optimalizacích:</p>

<pre>
Module: C:\memset.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 0000001E bytes
0000                          memset_:
0000    50                        push        ax 
0001    B8 04 00                  mov         ax,0x0004 
0004    E8 00 00                  call        __STK 
0007    58                        pop         ax 
0008    51                        push        cx 
0009    89 C1                     mov         cx,ax 
000B    89 D8                     mov         ax,bx 
000D    89 CB                     mov         bx,cx 
000F                          L$1:
000F    48                        dec         ax 
0010    3D FF FF                  cmp         ax,0xffff 
0013    74 05                     je          L$2 
0015    88 17                     mov         byte ptr [bx],dl 
0017    43                        inc         bx 
0018    EB F5                     jmp         L$1 
001A                          L$2:
001A    89 C8                     mov         ax,cx 
001C    59                        pop         cx 
001D    C3                        ret         
&nbsp;
Routine Size: 30 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p>V&nbsp;případě, že optimalizace povolíme, nedojde (kupodivu) k&nbsp;další
optimalizaci vnitřní smyčky, ale pouze se odstraní kontrola přetečení zásobníku
na začátku funkce. Tím pádem se nemusí ukládat registr AX na zásobník &ndash;
to se provede jen s&nbsp;registrem CX. Prolog a epilog funkce je tedy
zjednodušen:</p>

<pre>
Module: c:\memset.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 00000016 bytes
0000                          memset_:
0000    51                        push        cx 
0001    89 C1                     mov         cx,ax 
0003    89 D8                     mov         ax,bx 
0005    89 CB                     mov         bx,cx 
0007                          L$1:
0007    48                        dec         ax 
0008    3D FF FF                  cmp         ax,0xffff 
000B    74 05                     je          L$2 
000D    88 17                     mov         byte ptr [bx],dl 
000F    43                        inc         bx 
0010    EB F5                     jmp         L$1 
0012                          L$2:
0012    89 C8                     mov         ax,cx 
0014    59                        pop         cx 
0015    C3                        ret         
&nbsp;
Routine Size: 22 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p>Pro zajímavost se podívejme, k&nbsp;jakým změnám dojde v&nbsp;případě, že
použijeme překlad do 32bitového kódu. Kód se kupodivu <i>zjednodušil</i>,
protože nyní se pro adresaci používá přímo registru EAX, zatímco
v&nbsp;předchozím kódu se musel používat registr BX (možnosti adresování jsou
v&nbsp;šestnáctibitovém režimu omezenější):</p>

<pre>Module: c:\memset.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE32 00000012 bytes
0000                          memset_:
0000    51                        push        ecx 
0001    89 C1                     mov         ecx,eax 
0003                          L$1:
0003    4B                        dec         ebx 
0004    83 FB FF                  cmp         ebx,0xffffffff 
0007    74 05                     je          L$2 
0009    88 10                     mov         byte ptr [eax],dl 
000B    40                        inc         eax 
000C    EB F5                     jmp         L$1 
000E                          L$2:
000E    89 C8                     mov         eax,ecx 
0010    59                        pop         ecx 
0011    C3                        ret         
&nbsp;
Routine Size: 18 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST DWORD USE32 00000000 bytes
&nbsp;
Segment: CONST2 DWORD USE32 00000000 bytes
&nbsp;
Segment: _DATA DWORD USE32 00000000 bytes
</pre>




<h2 id="k16">16. Příklad třetí: nalezení prvku v&nbsp;poli s&nbsp;maximální hodnotou</h2>

<p>Třetí demonstrační příklad naprogramovaný v&nbsp;jazyku C bude nepatrně
složitější, než předchozí dvojice příkladů. Je v&nbsp;něm implementována funkce
nazvaná <strong>find_max</strong>, které se předá pole a jeho délka. Funkce
nalezne prvek s&nbsp;maximální hodnotou a tu vrátí. Pokud je pole prázdné,
vrátí se implicitní hodnota 0, protože (schválně z&nbsp;tohoto důvodu) jsou
prvky pole typu <strong>unsigned int</strong>:</p>

<pre>#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned int uint;
&nbsp;
uint <strong>find_max</strong>(uint *array, uint length) {
    uint max = 0;
    uint i;
    uint *item = array;
&nbsp;
    for (i=0; i &lt; length; i++) {
        if (max &lt; *item) {
            max = *item;
        }
        item++;
    }
    return max;
}
&nbsp;
int <strong>main</strong>(void) {
#define LENGTH 10
&nbsp;
    uint array[LENGTH] = {5, 6, 7, 8, 9, 0, 1, 2, 3, 4};
    uint max = find_max(array, LENGTH);
    printf("%d\n", max);
    return 0;
}
</pre>

<div class="rs-tip-major">Poznámka: opět překladačům pomáháme, protože
k&nbsp;prvkům pole přistupujeme přes ukazatel.</div>

<p>Překlad této funkce překladačem GCC pro moderní platformu x86-64 dopadne
takto:</p>

<pre>find_max:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-24], rdi
        mov     DWORD PTR [rbp-28], esi
        mov     DWORD PTR [rbp-4], 0
        mov     rax, QWORD PTR [rbp-24]
        mov     QWORD PTR [rbp-16], rax
        mov     DWORD PTR [rbp-8], 0
        jmp     .L2
.L4:
        mov     rax, QWORD PTR [rbp-16]
        mov     eax, DWORD PTR [rax]
        cmp     DWORD PTR [rbp-4], eax
        jnb     .L3
        mov     rax, QWORD PTR [rbp-16]
        mov     eax, DWORD PTR [rax]
        mov     DWORD PTR [rbp-4], eax
.L3:
        add     QWORD PTR [rbp-16], 4
        add     DWORD PTR [rbp-8], 1
.L2:
        mov     eax, DWORD PTR [rbp-8]
        cmp     eax, DWORD PTR [rbp-28]
        jb      .L4
        mov     eax, DWORD PTR [rbp-4]
        pop     rbp
        ret
</pre>

<p>Jedná se o dosti otrocký a neoptimální kód, protože se přímo pracuje
s&nbsp;proměnnými uloženými na zásobníkovém rámci a registru
<strong>RAX</strong> či <strong>EAX</strong> je používán jen dočasně.</p>

<p>Zajímavý je výsledek překladu se snahou o vytvoření co nejkratšího kódu
(<strong>-Os</strong>). Využívá se zde instrukce <strong>CMOVB</strong>, kterou
jsme si ještě nepopsali, ale její funkce je zřejmá – přenos při splnění
podmínky (zde podmínky <i>below</i>):</p>

<pre>find_max:
        xor     edx, edx
        xor     eax, eax
.L2:
        cmp     edx, esi
        jnb     .L5
        mov     ecx, DWORD PTR [rdi+rdx*4]
        cmp     eax, ecx
        cmovb   eax, ecx
        inc     rdx
        jmp     .L2
.L5:
        ret
</pre>

<p>A konečně vektorizovaná varianta, která by měla být pro delší pole
nejrychlejší. Takto rozbalený kód by pravděpodobně lidský vývojář nikdy
nenapsal:</p>

<pre>find_max:
        mov     rcx, rdi
        test    esi, esi
        je      .L7
        lea     eax, [rsi-1]
        cmp     eax, 5
        jbe     .L8
        mov     edx, esi
        pcmpeqd xmm3, xmm3
        pxor    xmm2, xmm2
        mov     rax, rdi
        shr     edx, 2
        pslld   xmm3, 31
        sal     rdx, 4
        add     rdx, rdi
.L4:
        movdqu  xmm1, XMMWORD PTR [rax]
        movdqa  xmm4, xmm2
        add     rax, 16
        psubd   xmm4, xmm3
        movdqa  xmm0, xmm1
        psubd   xmm0, xmm3
        pcmpgtd xmm0, xmm4
        pand    xmm1, xmm0
        pandn   xmm0, xmm2
        movdqa  xmm2, xmm0
        por     xmm2, xmm1
        cmp     rax, rdx
        jne     .L4
        movdqa  xmm1, xmm2
        movdqa  xmm4, xmm2
        psrldq  xmm1, 8
        psubd   xmm4, xmm3
        movdqa  xmm0, xmm1
        psubd   xmm0, xmm3
        pcmpgtd xmm0, xmm4
        pand    xmm1, xmm0
        pandn   xmm0, xmm2
        por     xmm0, xmm1
        movdqa  xmm2, xmm0
        movdqa  xmm4, xmm0
        psrldq  xmm2, 4
        psubd   xmm4, xmm3
        movdqa  xmm1, xmm2
        psubd   xmm1, xmm3
        pcmpgtd xmm1, xmm4
        pand    xmm2, xmm1
        pandn   xmm1, xmm0
        por     xmm1, xmm2
        movd    eax, xmm1
        test    sil, 3
        je      .L1
        mov     edx, esi
        and     edx, -4
        mov     edi, edx
        lea     rcx, [rcx+rdi*4]
.L3:
        mov     edi, DWORD PTR [rcx]
        cmp     eax, edi
        cmovb   eax, edi
        lea     edi, [rdx+1]
        cmp     edi, esi
        jnb     .L1
        mov     edi, DWORD PTR [rcx+4]
        cmp     eax, edi
        cmovb   eax, edi
        lea     edi, [rdx+2]
        cmp     edi, esi
        jnb     .L1
        mov     edi, DWORD PTR [rcx+8]
        cmp     eax, edi
        cmovb   eax, edi
        lea     edi, [rdx+3]
        cmp     edi, esi
        jnb     .L1
        mov     edi, DWORD PTR [rcx+12]
        cmp     eax, edi
        cmovb   eax, edi
        lea     edi, [rdx+4]
        cmp     edi, esi
        jnb     .L1
        mov     edi, DWORD PTR [rcx+16]
        cmp     eax, edi
        cmovb   eax, edi
        add     edx, 5
        cmp     edx, esi
        jnb     .L1
        mov     edx, DWORD PTR [rcx+20]
        cmp     eax, edx
        cmovb   eax, edx
        ret
.L7:
        xor     eax, eax
.L1:
        ret
.L8:
        xor     edx, edx
        xor     eax, eax
        jmp     .L3
</pre>




<h2 id="k17">17. Výsledky vygenerované překladačem Borland C++</h2>

<p>Nyní se vraťme do doby šestnáctibitových mikroprocesorů a operačního systému
DOS. Podíváme se, jak byla funkce <strong>find_max</strong> přeložena
překladačem Borland C++. Výsledkem sice není dobře optimalizovaný kód, ale
minimálně se do značné míry používají pracovní registry a nikoli pomocné
proměnné uložené na zásobníkovém rámci (například maximální hodnota je uložena
v&nbsp;<strong>DI</strong> atd.). Ovšem s&nbsp;jednou výjimkou – testem
na konec smyčky, který je realizován takto:</p>

<pre>        mov     ax,dx
        cmp     ax,word ptr [bp+6]
        jb      short @1@50
</pre>

<p>Přičemž je zřejmé, že první instrukce je zbytečná.</p>

<p>Taktéž v&nbsp;kódu nalezneme zbytečný skok:</p>

<pre>        jmp     short @1@194
@1@194:
</pre>

<p>A kvůli tomu, že jsou prvky adresovány přes registr <strong>SI</strong>, je
zvýšení ukazatele realizováno opakovanou instrukcí <strong>INC</strong>:</p>

<pre>        inc     si
        inc     si
</pre>

<p>Celý výsledný kód vypadá následovně:</p>

<pre>find_max        proc    near
        push    bp
        mov     bp,sp
        push    si
        push    di
   ;    
   ;        uint max = 0;
   ;    
        xor     di,di
   ;    
   ;        uint i;
   ;        uint *item = array;
   ;    
        mov     si,word ptr [bp+4]
   ;    
   ;    
   ;        for (i=0; i&lt;length; i++) {
   ;    
        xor     dx,dx
        jmp     short @1@146
@1@50:
   ;    
   ;            if (max &lt; *item) {
   ;    
        cmp     word ptr [si],di
        jbe     short @1@98
   ;    
   ;                max = *item;
   ;    
        mov     di,word ptr [si]
@1@98:
   ;    
   ;            }
   ;            item++;
   ;    
        inc     si
        inc     si
        inc     dx
@1@146:
        mov     ax,dx
        cmp     ax,word ptr [bp+6]
        jb      short @1@50
   ;    
   ;        }
   ;        return max;
   ;    
        mov     ax,di
        jmp     short @1@194
@1@194:
   ;    
   ;    }
   ;    
        pop     di
        pop     si
        pop     bp
        ret     
find_max        endp
</pre>

<div class="rs-tip-major">Poznámka: povšimněte si, že pokud je nalezen větší
prvek, bude se v&nbsp;této iteraci z&nbsp;pole číst dvakrát – což není
pro seřazené pole vůbec optimální:</div>

<pre>        cmp     word ptr [si],di
        ...
        ...
        ...
        mov     di,word ptr [si]
</pre>

<p>Po zapnutí optimalizací dokáže překladač změnit jedinou věc –
odstranit nepodmíněný skok na následující adresu, který je zcela zbytečný:</p>

<pre>find_max        proc    near
        push    bp
        mov     bp,sp
        push    si
        push    di
   ;    
   ;        uint max = 0;
   ;    
        xor     di,di
   ;    
   ;        uint i;
   ;        uint *item = array;
   ;    
        mov     si,word ptr [bp+4]
   ;    
   ;    
   ;        for (i=0; i&lt;length; i++) {
   ;    
        xor     dx,dx
        jmp     short @1@146
@1@50:
   ;    
   ;            if (max &lt; *item) {
   ;    
        cmp     word ptr [si],di
        jbe     short @1@98
   ;    
   ;                max = *item;
   ;    
        mov     di,word ptr [si]
@1@98:
   ;    
   ;            }
   ;            item++;
   ;    
        inc     si
        inc     si
        inc     dx
@1@146:
        mov     ax,dx
        cmp     ax,word ptr [bp+6]
        jb      short @1@50
   ;    
   ;        }
   ;        return max;
   ;    
        mov     ax,di
   ;    
   ;    }
   ;    
        pop     di
        pop     si
        pop     bp
        ret     
find_max        endp
</pre>

<p>Teoreticky by bylo možné dosáhnout odlišných výsledků povolením instrukcí
procesoru Intel 80828. To sice změnilo kód funkce <strong>main</strong>, ovšem
naše funkce <strong>find_max</strong> se nijak nezměnila:</p>

<pre>find_max        proc    near
        push    bp
        mov     bp,sp
        push    si
        push    di
   ;    
   ;        uint max = 0;
   ;    
        xor     di,di
   ;    
   ;        uint i;
   ;        uint *item = array;
   ;    
        mov     si,word ptr [bp+4]
   ;    
   ;    
   ;        for (i=0; i&lt;length; i++) {
   ;    
        xor     dx,dx
        jmp     short @1@146
@1@50:
   ;    
   ;            if (max &lt; *item) {
   ;    
        cmp     word ptr [si],di
        jbe     short @1@98
   ;    
   ;                max = *item;
   ;    
        mov     di,word ptr [si]
@1@98:
   ;    
   ;            }
   ;            item++;
   ;    
        inc     si
        inc     si
        inc     dx
@1@146:
        mov     ax,dx
        cmp     ax,word ptr [bp+6]
        jb      short @1@50
   ;    
   ;        }
   ;        return max;
   ;    
        mov     ax,di
   ;    
   ;    }
   ;    
        pop     di
        pop     si
        pop     bp
        ret     
find_max        endp
</pre>




<h2 id="k18">18. Výsledky vygenerované překladačem Watcom C/C++</h2>

<p>Nyní nám již zbývá prozkoumat, jak byla funkce <strong>find_max</strong>
přeložena pomocí Watcom C/C++. Pro přístup k&nbsp;prvkům pole se nyní používá
registr <strong>BX</strong> a nikoli <strong>SI</strong>. Počitadlo smyčky je
uloženo v&nbsp;registru <strong>AX</strong> a maximální hodnota v&nbsp;registru
<strong>DX</strong>, takže celá smyčka je realizována následovně:</p>

<pre>L$1:
    cmp         ax,cx 
    jae         L$3 
    cmp         dx,word ptr [bx] 
    jae         L$2 
    mov         dx,word ptr [bx] 
L$2:
    add         bx,0x0002 
    inc         ax 
    jmp         L$1 
L$3:
</pre>

<p>Kód v&nbsp;assembleru, který není optimalizován, vypadá takto:</p>

<pre>Module: C:\find_max.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 00000027 bytes
0000                          find_max_:
0000    50                        push        ax 
0001    B8 06 00                  mov         ax,0x0006 
0004    E8 00 00                  call        __STK 
0007    58                        pop         ax 
0008    53                        push        bx 
0009    51                        push        cx 
000A    89 D1                     mov         cx,dx 
000C    31 D2                     xor         dx,dx 
000E    89 C3                     mov         bx,ax 
0010    31 C0                     xor         ax,ax 
0012                          L$1:
0012    39 C8                     cmp         ax,cx 
0014    73 0C                     jae         L$3 
0016    3B 17                     cmp         dx,word ptr [bx] 
0018    73 02                     jae         L$2 
001A    8B 17                     mov         dx,word ptr [bx] 
001C                          L$2:
001C    83 C3 02                  add         bx,0x0002 
001F    40                        inc         ax 
0020    EB F0                     jmp         L$1 
0022                          L$3:
0022    89 D0                     mov         ax,dx 
0024    59                        pop         cx 
0025    5B                        pop         bx 
0026    C3                        ret         
&nbsp;
Routine Size: 39 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p>Po zapnutí optimalizací je odstraněna kontrola přetečení zásobníku a smyčka
je přeorganizována do této podoby (s&nbsp;kontrolou ukončení smyčky na
konci):</p>

<pre>L$1:
    cmp         dx,word ptr [bx] 
    jae         L$2 
    mov         dx,word ptr [bx] 
L$2:
    inc         ax 
    add         bx,0x0002 
    cmp         ax,cx 
    jb          L$1 
L$3:
</pre>

<p>Celý kód je kratší – 33 bajtů oproti původním 39 bajtům:</p>

<pre>Module: C:\find_max.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT PARA USE16 00000021 bytes
0000                          find_max_:
0000    53                        push        bx 
0001    51                        push        cx 
0002    89 D1                     mov         cx,dx 
0004    89 C3                     mov         bx,ax 
0006    31 D2                     xor         dx,dx 
0008    31 C0                     xor         ax,ax 
000A    85 C9                     test        cx,cx 
000C    76 0E                     jbe         L$3 
000E                          L$1:
000E    3B 17                     cmp         dx,word ptr [bx] 
0010    73 02                     jae         L$2 
0012    8B 17                     mov         dx,word ptr [bx] 
0014                          L$2:
0014    40                        inc         ax 
0015    83 C3 02                  add         bx,0x0002 
0018    39 C8                     cmp         ax,cx 
001A    72 F2                     jb          L$1 
001C                          L$3:
001C    89 D0                     mov         ax,dx 
001E    59                        pop         cx 
001F    5B                        pop         bx 
0020    C3                        ret         
&nbsp;
Routine Size: 33 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p>Pro zajímavost se podívejme na 32bitovou variantu, která je ještě kratší, a
to díky lepším možnostem adresování v&nbsp;32bitovém režimu. Samotná smyčka
nyní vypadá takto (<strong>ECX</strong> obsahuje maximální hodnotu,
<strong>EAX</strong> je použit při adresování):</p>

<pre>L$1:
    mov         esi,dword ptr [eax] 
    cmp         ecx,esi 
    jae         L$2 
    mov         ecx,esi 
L$2:
    inc         edx 
    add         eax,0x00000004 
    cmp         edx,ebx 
    jb          L$1 
L$3:
</pre>

<div class="rs-tip-major">Poznámka: zajímavé je, že nyní překladač kód
upravil tak, aby se v&nbsp;každé iteraci do pole přistoupilo pouze jedenkrát,
kdežto u předchozího kódu to mohlo být 2× při nalezení většího
prvku.</div>

<p>Celý výsledný kód má nyní délku 35 bajtů:</p>

<pre>Module: C:\find_max.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT PARA USE32 00000023 bytes
0000                          find_max_:
0000    53                        push        ebx 
0001    51                        push        ecx 
0002    56                        push        esi 
0003    89 D3                     mov         ebx,edx 
0005    31 C9                     xor         ecx,ecx 
0007    31 D2                     xor         edx,edx 
0009    85 DB                     test        ebx,ebx 
000B    76 10                     jbe         L$3 
000D                          L$1:
000D    8B 30                     mov         esi,dword ptr [eax] 
000F    39 F1                     cmp         ecx,esi 
0011    73 02                     jae         L$2 
0013    89 F1                     mov         ecx,esi 
0015                          L$2:
0015    42                        inc         edx 
0016    83 C0 04                  add         eax,0x00000004 
0019    39 DA                     cmp         edx,ebx 
001B    72 F0                     jb          L$1 
001D                          L$3:
001D    89 C8                     mov         eax,ecx 
001F    5E                        pop         esi 
0020    59                        pop         ecx 
0021    5B                        pop         ebx 
0022    C3                        ret         
&nbsp;
Routine Size: 35 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST DWORD USE32 00000000 bytes
&nbsp;
Segment: CONST2 DWORD USE32 00000000 bytes
&nbsp;
Segment: _DATA DWORD USE32 00000000 bytes
</pre>




<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyce C, které jsou primárně určené
pro překlad s&nbsp;využitím překladačů <i>Turbo C</i> a <i>(Open)Watcom C)</i>,
byly uloženy do Git repositáře, který je dostupný na adrese <a href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<p>Borland C:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add.c</a></td></tr>
<tr><td> 2</td><td>add1.asm</td><td>překlad přes assembler, externí symboly začínají pomlčkou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add1.asm</a></td></tr>
<tr><td> 3</td><td>add2.asm</td><td>překlad přes assembler, externí symboly nejsou přejmenovány</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add2.asm</a></td></tr>
<tr><td> 4</td><td>add3.asm</td><td>výsledek překladu se zákazem optimalizací (externí symboly s&nbsp;pomlčkou)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add3.asm</a></td></tr>
<tr><td> 5</td><td>add4.asm</td><td>výsledek překladu se zákazem optimalizací (externí symboly nejsou přejmenovány)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add4.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add4.asm</a></td></tr>
<tr><td> 6</td><td>add5.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add5.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add5.asm</a></td></tr>
<tr><td> 7</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset.c</a></td></tr>
<tr><td> 8</td><td>memset_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_1.asm</a></td></tr>
<tr><td> 9</td><td>memset_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_2.asm</a></td></tr>
<tr><td>10</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max.c</a></td></tr>
<tr><td>11</td><td>find_max_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_1.asm</a></td></tr>
<tr><td>12</td><td>find_max_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_2.asm</a></td></tr>
<tr><td>13</td><td>find_max_3.asm</td><td>výsledek překladu s&nbsp;povolením instrukcí procesorů 80286</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_3.asm</a></td></tr>
</table>

<p>(Open)Watcom pro platformu IBM PC:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add.c</a></td></tr>
<tr><td> 2</td><td>add1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add1.asm</a></td></tr>
<tr><td> 3</td><td>add2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add2.asm</a></td></tr>
<tr><td> 4</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset.c</a></td></tr>
<tr><td> 5</td><td>memset1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset1.asm</a></td></tr>
<tr><td> 6</td><td>memset2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset2.asm</a></td></tr>
<tr><td> 7</td><td>memset3.asm</td><td>výsledek překladu do 32bitového kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset3.asm</a></td></tr>
<tr><td> 8</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max.c</a></td></tr>
<tr><td> 9</td><td>find_max_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_1.asm</a></td></tr>
<tr><td>10</td><td>find_max_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_2.asm</a></td></tr>
<tr><td>11</td><td>find_max_3.asm</td><td>výsledek překladu do 32bitového kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_3.asm</a></td></tr>
</table>

<p>GCC pro platformu x86-64:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.c</a></td></tr>
<tr><td> 2</td><td>add.asm</td><td>výsledek překladu do assembleru s&nbsp;použitím optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.asm</a></td></tr>
<tr><td> 3</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset.c</a></td></tr>
<tr><td> 4</td><td>memset_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_1.asm</a></td></tr>
<tr><td> 5</td><td>memset_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_2.asm</a></td></tr>
<tr><td> 6</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max.c</a></td></tr>
<tr><td> 7</td><td>find_max_default.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_default.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_default.asm</a></td></tr>
<tr><td> 8</td><td>find_max_smallest.asm</td><td>výsledek překladu s&nbsp;optimalizací na velikost kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_smallest.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_smallest.asm</a></td></tr>
<tr><td> 9</td><td>find_max_vector.asm</td><td>výsledek překladu s&nbsp;optimalizací na rychlost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_vector.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_vector.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Warnings Are Your Friend - A Code Quality Primer<br />
<a href="https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/">https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/</a>
</li>

<li>Defending Against Compiler-Based Backdoors<br />
<a href="https://blog.regehr.org/archives/1241">https://blog.regehr.org/archives/1241</a>
</li>

<li>Reflections on Trusting Trust<br />
<a href="https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html">https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html</a>
</li>

<li>Coding Machines (povídka)<br />
<a href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>
</li>

<li>Stage0<br />
<a href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>
</li>

<li>Projekt stage0 na GitHubu<br />
<a href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>
</li>

<li>Bootstraping wiki<br />
<a href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>
</li>

<li>Bootstrapped 6502 Assembler<br />
<a href="https://github.com/robinluckey/bootstrap-6502">https://github.com/robinluckey/bootstrap-6502</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>What is a coder's worst nightmare?<br />
<a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute</a>
</li>

<li>Tiny C Compiler<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Welcome to C--<br />
<a href="https://www.cs.tufts.edu/~nr/c--/index.html">https://www.cs.tufts.edu/~nr/c--/index.html</a>
</li>

<li>c4 - C in four functions<br />
<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>Lattice C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Lattice_C">https://en.wikipedia.org/wiki/Lattice_C</a>
</li>

<li>Aztec C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Aztec_C">https://en.wikipedia.org/wiki/Aztec_C</a>
</li>

<li>Digital Mars (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Digital_Mars">https://en.wikipedia.org/wiki/Digital_Mars</a>
</li>

<li>Stránky projektu Open Watcom<br />
<a href="https://openwatcom.org/">https://openwatcom.org/</a>
</li>

<li>Repositář Open Watcom<br />
<a href="https://github.com/open-watcom/open-watcom-v2">https://github.com/open-watcom/open-watcom-v2</a>
</li>

<li>Watcom C/C++ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B">https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B</a>
</li>

<li>Turbo C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_C">https://en.wikipedia.org/wiki/Turbo_C</a>
</li>

<li>Borland C++ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Borland_C%2B%2B">https://en.wikipedia.org/wiki/Borland_C%2B%2B</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

