<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Překladače na platformě IBM PC: od assembleru k C</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Překladače na platformě IBM PC: od assembleru k C</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Překladače na platformě IBM PC: od assembleru k&nbsp;C</a></p>
<p><a href="#k02">2. Programovací jazyk C</a></p>
<p><a href="#k03">3. Lattice C</a></p>
<p><a href="#k04">4. Aztec C</a></p>
<p><a href="#k05">5. Zortech C</a></p>
<p><a href="#k06">*** 6. Turbo C</a></p>
<p><a href="#k07">*** 7. Borland C++</a></p>
<p><a href="#k08">*** 8. Watcom C</a></p>
<p><a href="#k09">9. Jak kvalitní byly překladače céčka pro IBM PC?</a></p>
<p><a href="#k10">10. Příklad první: funkce pro součet dvou celých čísel</a></p>
<p><a href="#k11">*** 11. Výsledky vygenerované překladačem Borland C++</a></p>
<p><a href="#k12">12. Výsledky vygenerované překladačem Watcom C</a></p>
<p><a href="#k13">13. Příklad druhý: vyplnění paměťového bloku</a></p>
<p><a href="#k14">*** 14. Výsledky vygenerované překladačem Borland C++</a></p>
<p><a href="#k15">*** 15. Výsledky vygenerované překladačem Watcom C</a></p>
<p><a href="#k16">*** 16. Příklad třetí: nalezení prvku v&nbsp;poli s&nbsp;maximální hodnotou</a></p>
<p><a href="#k17">*** 17. Výsledky vygenerované překladačem Borland C++</a></p>
<p><a href="#k18">*** 18. Výsledky vygenerované překladačem Watcom C</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Překladače na platformě IBM PC: od assembleru k&nbsp;C</h2>

<p>V&nbsp;seriálu o <a
href="https://www.root.cz/serialy/vyvoj-her-a-grafickych-dem-pro-platformu-pc/">vývoji
her a grafických dem pro platformu PC</a> jsme prozatím pro tvorbu příkladů
používali assembler. V&nbsp;prvních přibližně deseti letech existence platformy
IBM PC se skutečně jednalo o primární jazyk využívaný pro tvorbu
profesionálních aplikací. Příkladem takové aplikace může být textový procesor
<i>WordStar</i> nebo tabulkový procesor <i>VisiCalc</i> (předchůdce Lotusu
1-2-3 a vlastně i Excelu). A v&nbsp;assembleru byla vytvořena i celá řada her.
Proč se však nepoužívaly překladače vyšších programovacích jazyků? Takové
překladače pochopitelně existovaly, ostatně první překladač céčka byl na IBM PC
portován již rok po vzniku této platformy. Ovšem kvalita výsledného strojového
kódu nebyla příliš dobrá, protože tyto překladače většinou neprováděly velké
optimalizace. A nutno říci, že i samotná mikroprocesorová architektura 80x86
tvůrcům překladačů nebyla příliš nápomocná (na rozdíl od RISCových
architektur).</p>

<img src="http://i.iinfo.cz/images/640/d4-2.png" class="image-215143" width="441" height="479" alt="&#160;" />
<p><i>Obrázek 1: Dobová reklama na textový editor WordStar.</i></p>

<p>V&nbsp;dnešním článku se nejdříve zmíníme o některých překladačích jazyka C,
které byly dostupné pro platformu IBM PC a posléze si na trojici příkladů
vyzkoušíme, jak kvalitní nebo nekvalitní vlastně překlad ve skutečnosti byl a
proč programátoři poměrně dlouhou dobu zůstávali u assembleru.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programovací jazyk C</h2>

<p>Jedním <a
href="https://www.tiobe.com/tiobe-index/">z&nbsp;nejpopulárnějších</a>
v&nbsp;současnosti používaných programovacích jazyků je stále (což je
mimochodem zajímavé a hodně to vypovídá o realitě v&nbsp;IT) programovací jazyk
C navržený <i>Dennisem Ritchiem</i>. Historie céčka je dobře známá: jazyk C se
postupně vyvinul z&nbsp;programovacích jazyků BPCL (autor <i>Martin
Richards</i>, 1966) a B (autor <i>Ken Thompson</i>, 1970) až do současné
podoby, která byla standardizována v&nbsp;několika normách, z&nbsp;nichž
nejznámější je pravděpodobně stále ještě ISO/IEC 9899:1999 známá pod zkráceným
označením <i>C99</i>. Následovala specifikace <i>C11</i> neboli ISO/IEC
9899:2011, <i>C17</i> neboli ISO/IEC 9899:2018 a konečně <i>C23</i> neboli
ISO/IEC 9899:2024. Starší, dodnes v&nbsp;některých případech stále ještě
používaný standard, se jmenuje ISO 9899:1990. Tento starší standard je
prakticky shodný (až na jiné číslování jednotlivých paragrafů) s&nbsp;normou
ANSI C (ANSI X3.159-1989 &bdquo;Programming Language C&ldquo;) a zkráceně se
označuje <i>C89</i> či méně často <i>C90</i> (taktéž jen ANSI/ISO C).</p>

<img src="https://i.iinfo.cz/images/571/c-mos-6502-1.png" class="image-661833" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="309" height="400" />
<p><i>Obrázek 2: Přebal druhého vydání slavné knihy &bdquo;The C Programming
Language&ldquo; (Kerningan, Ritchie)</i></p>

<p>Programovací jazyk C je i přes absenci některých důležitých vlastností
(například mu chybí automatický správce paměti či podpora silného typování a
práce s&nbsp;objekty, výjimkami, uzávěry, pattern matchingem atd.) využívaný
jak pro tvorbu open source aplikací, tak i v&nbsp;čistě komerční oblasti
&ndash; nejedná se jen o vývoj aplikací pro desktopy a servery, ale i pro
mikrořadiče či digitální signálové procesory (DSP). Céčko je mnohdy využíváno i
ve funkci cílového jazyka, do něhož se překládají (<i>transpilují</i>) programy
zapsané v&nbsp;některých vyšších programovacích jazycích &ndash; vývojáři,
kteří překladače těchto jazyků vytváří, se tak nemusí starat například o
nízkoúrovňové optimalizace, protože je za ně již naprogramovali vývojáři
překladače céčka. Z&nbsp;historického hlediska, které nás dnes do jisté míry
zajímá, je poměrně typické, že právě tímto způsobem vznikla první verze jazyka
C++ (nástroj Cpre), i když moderní překladače C++ jsou již řešeny od C
odděleně.</p>

<p>To však není zdaleka vše, protože programovací jazyk C je dodnes důležitý i
z&nbsp;toho důvodu, že jak rozhraní jader některých operačních systémů (Linux,
Microsoft Windows i dalších systémů), tak rozhraní systémových knihoven bylo
navrženo s&nbsp;ohledem na jmenné konvence céčka i s&nbsp;ohledem na možnosti
jeho linkeru (a ostatní jazyky toto rozhraní s&nbsp;většími či menšími problémy
dodržují).</p>

<p>Nás však dnes budou zajímat především starší překladače určené pro operační
systém (MS) DOS a tedy pro platformu IBM PC. Těchto překladačů vznikla celá
řada a zajímavé je, že některé z&nbsp;nich vlastně vznikly portací překladače
z&nbsp;jiných platforem, ať již se jednalo o osmibitové mikroprocesory na
straně jedné či o Unixové systémy na druhé straně výkonnostního spektra.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Lattice C</h2>

<p>Pravděpodobně prvním překladačem programovacího jazyka C, který byl vytvořen
pro platformu IBM PC, byl <i>Lattice C</i> pocházející z&nbsp;roku 1982
(samotné PC přitom začalo být nabízeno jen o rok dříve). Tento překladač byl
později převeden i na Amigu (a byl zde poměrně populární) a dále se rozšířil i
na minipočítače a mainframy společnosti IBM. Jeho hardwarové nároky byly
dnešním pohledem směšně nízké: PC s&nbsp;původním mikroprocesorem Intel 8088
taktovaným na 4,77 MHz, paměť RAM o kapacitě 256kB (původní PC ovšem mohlo mít
i jen 16kB RAM!) a disketová mechanika.</p>

<p>Zajímavé bylo, že společnost Microsoft překladač <i>Lattice C</i> nabízela
pod svým názvem <i>MSC (Microsoft C)</i> (i když autorem byla firma <i>Lifeboat
Associates</i>) a teprve verze <i>MSC 4.0</i> byla skutečně vytvořena přímo
programátory z&nbsp;Microsoftu. <i>Lattice C</i> byl využíván i při portaci
aplikací z&nbsp;operačního systému <i>CP/M</i> na systém DOS. Dnes je však
poměrně těžké odhadnout, kolik zdrojového kódu bylo skutečně napsáno
v&nbsp;céčku a kolik kódu vzniklo transformací assembleru. Jedním
z&nbsp;nedostatků Lattice C byla jeho vysoká cena 500 dolarů. To později
zjednodušilo přístup na trh s&nbsp;překladači takovým firmám, jako je Borland
apod., jejichž cenová politika byla zcela opačná.</p>

<img src="http://i.iinfo.cz/images/15/gamesc4.jpg" class="image-161782" width="450" height="265" alt="&#160;" />
<p><i>Obrázek 3: Lattice C.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Aztec C</h2>

<p>Dalším kdysi známým překladačem programovacího jazyka C, který byl kromě
platformy IBM PC dostupný mj.&nbsp;i pro osobní mikropočítače <i>Amiga</i>, byl
překladač nazvaný <i>Aztec C</i> společnosti <i>Manx Software Systems</i>.
Jednalo se o ve své době velmi úspěšný překladač, jenž existoval jak ve verzi
pro osmibitové mikroprocesory (MOS 6502, Zilog Z-80), tak i pro mikroprocesory
16bitové (včetně Intelu 8088) a 32bitové (řada Motorola 68000). Tento překladač
byl velmi úspěšný právě na Amize, kde byl používán, společně s&nbsp;výše
zmíněným <i>Lattice C</i>, prakticky až do faktického zániku této
platformy.</p>

<p>Ovšem na druhé straně na platformě IBM PC jeho sláva netrvala dlouho,
především z&nbsp;toho důvodu, že firma Microsoft považovala segment překladačů
za poměrně důležitý a snažila se vytlačit jakoukoli konkurenci z&nbsp;trhu (i
když ve skutečnosti v&nbsp;té době ještě stále neměla vlastní céčkový
překladač). Autorem Aztec C, jímž byla společnost <i>Manx Software Systems</i>,
se navíc postupně zmenšoval počet platforem, na něž bylo možné překladač
prodávat a přechod na podporu vestavěných systémů již přišel dosti pozdě.</p>

<img src="http://i.iinfo.cz/images/365/gamesc3.jpg" class="image-161781" width="450" height="259" alt="&#160;" />
<p><i>Obrázek 4: Logo překladačů Aztec C.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zortech C</h2>

<p>Za vývojem překladače <i>Zortech C</i> stála společnost <i>Digital Mars</i>.
Tato firma vytvořila a prodávala (a vlastně i doposud prodává) překladače
jazyků C, C++ a D. V&nbsp;dnešním článku se ovšem zaměříme pouze na klasické
céčko, resp.&nbsp;překladače dostupné pro platformu IBM PC. Původní překladač
jazyka C od společnosti Digial Mars se jmenoval <i>Small-C</i>, ovšem
nepokrýval všechny vlastnosti jazyka C. První překladač skutečného céčka vznikl
až v&nbsp;roce 1987 a jmenoval se <i>Datalight C</i>. Poté postupným vývojem
vznikly další varianty překladače céčka a zajímavé je, že se měnil i jejich
název. Po <i>Datalight C</i> začal být nabízen <i>Zorland C</i> (reference na
konkurenční Borland?), <i>Zortech C</i> a <i>Digital Mars C/C++</i>.
Pravděpodobně nejvíce rozšířený a nejznámější byla právě varianta nazvaná
<i>Zortech C</i> (existoval i <i>Zortech C++</i>). Ten v&nbsp;benchmarcích
porážel konkurenci &ndash; Microsoft C 5.1 i Watcom C 6.5 (a pochopitelně i
překladač Turbo C a Borland C).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Jak kvalitní byly překladače céčka pro IBM PC?</h2>

<p>Jak již bylo napsáno v&nbsp;úvodu dnešního článku, používal se na platformě
IBM PC pro tvorbu profesionálního software poměrně dlouho assembler (tedy jazyk
symbolických instrukcí). Bylo tomu tak z&nbsp;toho důvodu, že překladače jazyka
C zpočátku nebyly příliš kvalitní, minimálně ne z&nbsp;pohledu optimalizací (a
některé překladače byly navíc chybové nebo neodpovídaly normě C, to je však
jiné téma). Jak uvidíme v&nbsp;demonstračních příkladech uvedených
v&nbsp;navazujících kapitolách, prováděly některé céčkové překladače poněkud
šablonovitý překlad; ostatně se o programovacím jazyku C někdy s&nbsp;nadsázkou
říká, že je to &bdquo;přenositelný assembler&ldquo; [<a
href="https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler">1</a>].</p>

<p>Teprve později začaly být překladače céčka vybavovány více či méně
kvalitními optimalizacemi výsledného strojového kódu. To však vyžadovalo větší
nároky na operační paměť, delší dobu překladu a horší podporu pro ladění
(resp.&nbsp;krokování). Proto je optimalizaci prakticky nutné explicitně
povolit a nastavit její vlastnosti.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Příklad první: funkce pro součet dvou celých čísel</h2>

<p>První demonstrační příklad, na kterém si ověříme kvalitu nebo naopak
nekvalitu překladačů jazyka C, je vlastně triviální. Jedná se o funkci se dvěma
parametry typu &bdquo;celé číslo&ldquo; (ať to znamená cokoli), která vrací
součet hodnot těchto dvou parametrů. Implementace takové funkce je
jednoduchá:</p>

<pre>
int <strong>add</strong>(int a, int b) {
    return a+b;
}
</pre>

<p>Jen pro zajímavost se podívejme, jak dopadne výsledek překladu na moderní
architektuře x86-64 s&nbsp;využitím překladačů GCC a Clang.</p>

<p>Překlad s&nbsp;využitím GCC nebo Clang s&nbsp;vypnutými optimalizacemi
(výsledky jsou totožné):</p>

<pre>
<strong>add</strong>:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     edx, DWORD PTR [rbp-4]
        mov     eax, DWORD PTR [rbp-8]
        add     eax, edx
        pop     rbp
        ret
</pre>

<p>Překlad s&nbsp;využitím GCC nebo Clang se zapnutými maximálními
optimalizacemi (výsledky jsou opět totožné):</p>

<pre>
<strong>add</strong>:
        lea     eax, [rdi+rsi]
        ret
</pre>

<p>Zde stojí za zmínku, že platforma x86-64 má svá specifika. Prvním
z&nbsp;nich je, že typ <strong>int</strong> je 64bitový a druhým je možnost
NEpoužívat předávání parametrů přes zásobníkový rámec. Celočíselné hodnoty jsou
totiž předávány v&nbsp;registrech RDI, RSI, RDX, RCX, R8 a R9 (v&nbsp;tomto
pořadí). Viz AMD64 ABI.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výsledky vygenerované překladačem Borland C++</h2>

<pre>
_TEXT   segment byte public 'CODE'
        assume  cs:_TEXT
_add    proc    near
        push    bp
        mov     bp,sp
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
        jmp     short @1@50
@1@50:
        pop     bp
        ret     
_add    endp
        ?debug  C E9
_TEXT   ends
</pre>

<pre>
_TEXT   segment byte public 'CODE'
        assume  cs:_TEXT
add     proc    near
        push    bp
        mov     bp,sp
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
        jmp     short @1@50
@1@50:
        pop     bp
        ret     
add     endp
        ?debug  C E9
_TEXT   ends
</pre>

<pre>
   ;    
   ;    int add(int a, int b) {
   ;    
        assume  cs:_TEXT
_add    proc    near
        push    bp
        mov     bp,sp
   ;    
   ;        return a+b;
   ;    
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
        jmp     short @1@50
@1@50:
   ;    
   ;    }
   ;    
        pop     bp
        ret     
_add    endp
</pre>

<pre>
   ;    
   ;    int add(int a, int b) {
   ;    
        assume  cs:_TEXT
add     proc    near
        push    bp
        mov     bp,sp
   ;    
   ;        return a+b;
   ;    
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
        jmp     short @1@50
@1@50:
   ;    
   ;    }
   ;    
        pop     bp
        ret     
add     endp
</pre>

<pre>
   ;    
   ;    int add(int a, int b) {
   ;    
        assume  cs:_TEXT
add     proc    near
        push    bp
        mov     bp,sp
   ;    
   ;        return a+b;
   ;    
        mov     ax,word ptr [bp+4]
        add     ax,word ptr [bp+6]
   ;    
   ;    }
   ;    
        pop     bp
        ret     
add     endp
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výsledky vygenerované překladačem Watcom C</h2>

<p>Podívejme se, jak se s&nbsp;překladem funkce <strong>add</strong> vypořádal
známý Watcom C, který byl dlouho považován za nejlépe optimalizující překladač
pro platformu IBM PC. Nejdřív si uvedeme výsledek překladu s&nbsp;vypnutými
optimalizacemi:</p>

<pre>
Module: C:\add.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 0000000B bytes
0000                          add_:
0000    50                        push        ax 
0001    B8 02 00                  mov         ax,0x0002 
0004    E8 00 00                  call        __STK 
0007    58                        pop         ax 
0008    01 D0                     add         ax,dx 
000A    C3                        ret         
&nbsp;
Routine Size: 11 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p>Z&nbsp;výsledků je patrné, že typ <strong>int</strong> je
v&nbsp;šestnáctibitovém DOSu taktéž šestnáctibitový. Parametry jsou předávány
v&nbsp;registrech <strong>AX</strong> a <strong>DX</strong>, výsledek se vrací
v&nbsp;registru <strong>AX</strong>. Navíc se zde explicitně volá subrutina
<strong>__STK</strong>, která kontroluje přetečení zásobníku v&nbsp;závislosti
na jeho velikosti předané v&nbsp;registru <strong>AX</strong>. Výsledný kód
tedy není zcela ideální, ale není ani nejhorší možný.</p>

<p>Po zapnutí všech optimalizací ovšem získáme mnohem lepší výsledek. Celá
funkce se zkrátila na jediný součet a návrat ze subrutiny:</p>

<pre>
Module: C:\add.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 00000003 bytes
0000                          add_:
0000    01 D0                     add         ax,dx 
0002    C3                        ret         
&nbsp;
Routine Size: 3 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p><div class="rs-tip-major">Poznámka: překlad do objektového kódu byl proveden
s&nbsp;využitím <strong>WCC</strong>, zpětnou transformaci do assembleru
zajistila utilita <strong>WDIS</strong>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příklad druhý: vyplnění paměťového bloku</h2>

<p>Druhý testovací příklad naprogramovaný v&nbsp;jazyku C obsahuje definici
funkce, která dokáže vyplnit paměťový blok začínající na zadané adrese a mající
určitou (opět zadanou) délku. Tento příklad je upraven do podoby, která by měla
do značné míry pomoci překladačům &ndash; využívá se zde přístup přes ukazatel
(ne přes index), programová smyčka má ten nejjednodušší možný tvar atd. A
zápisy se provádí po bajtech:</p>

<pre>
#include &lt;mem.h&gt;
&nbsp;
void * <strong>memset</strong>(void *dest, register int val, register size_t len) {
    register unsigned char *ptr = (unsigned char*)dest;
    while (len-- &gt; 0)
        *ptr++ = val;
    return dest;
}
</pre>

<p>Ještě než se podíváme na způsob překladu staršími překladači céčka pro IBM
PC, podívejme se na překlad s&nbsp;využitím moderních překladačů. Nejdříve GCC
bez povolených optimalizací:</p>

<pre>
<strong>memset</strong>:
        push    rbp
        mov     rbp, rsp
        push    rbx
        mov     QWORD PTR [rbp-16], rdi
        mov     ecx, esi
        mov     eax, edx
        mov     rbx, QWORD PTR [rbp-16]
        jmp     .L2
.L3:
        mov     rdx, rbx
        lea     rbx, [rdx+1]
        mov     esi, ecx
        mov     BYTE PTR [rdx], sil
.L2:
        mov     edx, eax
        lea     eax, [rdx-1]
        test    edx, edx
        jne     .L3
        mov     rax, QWORD PTR [rbp-16]
        mov     rbx, QWORD PTR [rbp-8]
        leave
        ret
</pre>

<p>Zde je patrné, že se programová smyčka transformovala poměrně otrockým způsobem.</p>

<p>Překlad s&nbsp;využitím optimalizací je odlišný. Povšimněte si zde registru
<strong>SIL</strong> (dolních osm bitů registru <strong>ESI</strong>, výchozí
registr pro parametr funkce) a instrukce <strong>MOVZX</strong>, která provádí
rozšíření operandu s&nbsp;menší bitovou šířkou do výsledku s&nbsp;větší bitovou
šířkou:</p>

<pre>
<strong>memset</strong>:
        test    edx, edx
        je      .L2
        mov     edx, edx
        movzx   esi, sil
        jmp     memset
.L2:
        mov     rax, rdi
        ret
</pre>

<p>Ovšem možná je i &bdquo;vektorizace&ldquo; kódu, která využívá toho, že u
delších paměťových bloků lze využít zápis širšího (zarovnaného) slova. Právě
zde se ukazuje význam překladačů oproti assembleru, protože ruční tvorba
takového kódu je sice možná, ale pracná:</p>

<pre>
<strong>memset</strong>:
        mov     rax, rdi
        test    rdx, rdx
        je      .LBB0_8
        cmp     rdx, 4
        jae     .LBB0_3
        mov     r8, rax
.LBB0_14:
        mov     r9, rdx
        jmp     .LBB0_15
.LBB0_3:
        movzx   edi, sil
        cmp     rdx, 32
        jae     .LBB0_9
        xor     ecx, ecx
        jmp     .LBB0_5
.LBB0_9:
        mov     rcx, rdx
        and     rcx, -32
        movd    xmm0, edi
        punpcklbw       xmm0, xmm0
        pshuflw xmm0, xmm0, 0
        pshufd  xmm0, xmm0, 68
        xor     r8d, r8d
.LBB0_10:
        movdqu  xmmword ptr [rax + r8], xmm0
        movdqu  xmmword ptr [rax + r8 + 16], xmm0
        add     r8, 32
        cmp     rcx, r8
        jne     .LBB0_10
        cmp     rdx, rcx
        je      .LBB0_8
        test    dl, 28
        je      .LBB0_13
.LBB0_5:
        mov     r10, rdx
        and     r10, -4
        lea     r8, [rax + r10]
        mov     r9d, edx
        and     r9d, 3
        movd    xmm0, edi
        punpcklbw       xmm0, xmm0
        pshuflw xmm0, xmm0, 0
.LBB0_6:
        movd    dword ptr [rax + rcx], xmm0
        add     rcx, 4
        cmp     r10, rcx
        jne     .LBB0_6
        cmp     rdx, r10
        je      .LBB0_8
.LBB0_15:
        xor     ecx, ecx
.LBB0_16:
        mov     byte ptr [r8 + rcx], sil
        inc     rcx
        cmp     r9, rcx
        jne     .LBB0_16
.LBB0_8:
        ret
.LBB0_13:
        add     rcx, rax
        and     edx, 31
        mov     r8, rcx
        jmp     .LBB0_14
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned int uint;
&nbsp;
uint <strong>find_max</strong>(uint *array, uint length) {
    uint max = 0;
    uint i;
    uint *item = array;
&nbsp;
    for (i=0; i &lt; length; i++) {
        if (max &lt; *item) {
            max = *item;
        }
        item++;
    }
    return max;
}
&nbsp;
int <strong>main</strong>(void) {
#define LENGTH 10
&nbsp;
    uint array[LENGTH] = {5, 6, 7, 8, 9, 0, 1, 2, 3, 4};
    uint max = find_max(array, LENGTH);
    printf("%d\n", max);
    return 0;
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyce C, které jsou primárně určené
pro překlad s&nbsp;využitím překladačů <i>Turbo C</i> a <i>(Open)Watcom C)</i>,
byly uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<p>Borland C:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add.c</a></td></tr>
<tr><td> 2</td><td>add1.asm</td><td>překlad přes assembler, externí symboly začínají pomlčkou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add1.asm</a></td></tr>
<tr><td> 3</td><td>add2.asm</td><td>překlad přes assembler, externí symboly nejsou přejmenovány</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add2.asm</a></td></tr>
<tr><td> 4</td><td>add3.asm</td><td>výsledek překladu se zákazem optimalizací (externí symboly s&nbsp;pomlčkou)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add3.asm</a></td></tr>
<tr><td> 5</td><td>add4.asm</td><td>výsledek překladu se zákazem optimalizací (externí symboly nejsou přejmenovány)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add4.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add4.asm</a></td></tr>
<tr><td> 6</td><td>add5.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add5.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add5.asm</a></td></tr>
<tr><td> 7</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset.c</a></td></tr>
<tr><td> 8</td><td>memset_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_1.asm</a></td></tr>
<tr><td> 9</td><td>memset_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_2.asm</a></td></tr>
<tr><td>10</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max.c</a></td></tr>
<tr><td>11</td><td>find_max_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_1.asm</a></td></tr>
<tr><td>12</td><td>find_max_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_2.asm</a></td></tr>
<tr><td>13</td><td>find_max_3.asm</td><td>výsledek překladu s&nbsp;povolením instrukcí procesorů 80286</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_3.asm</a></td></tr>
</table>

<p>(Open)Watcom pro platformu IBM PC:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add.c</a></td></tr>
<tr><td> 2</td><td>add1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add1.asm</a></td></tr>
<tr><td> 3</td><td>add2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add2.asm</a></td></tr>
<tr><td> 4</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset.c</a></td></tr>
<tr><td> 5</td><td>memset1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset1.asm</a></td></tr>
<tr><td> 6</td><td>memset2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset2.asm</a></td></tr>
<tr><td> 7</td><td>memset3.asm</td><td>výsledek překladu do 32bitového kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset3.asm</a></td></tr>
<tr><td> 8</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max.c</a></td></tr>
<tr><td> 9</td><td>find_max_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_1.asm</a></td></tr>
<tr><td>10</td><td>find_max_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_2.asm</a></td></tr>
<tr><td>11</td><td>find_max_3.asm</td><td>výsledek překladu do 32bitového kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_3.asm</a></td></tr>
</table>

<p>GCC pro platformu x86-64:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.c</a></td></tr>
<tr><td> 2</td><td>add.asm</td><td>výsledek překladu do assembleru s&nbsp;použitím optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.asm</a></td></tr>
<tr><td> 3</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset.c</a></td></tr>
<tr><td> 4</td><td>memset_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_1.asm</a></td></tr>
<tr><td> 5</td><td>memset_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_2.asm</a></td></tr>
<tr><td> 6</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max.c</a></td></tr>
<tr><td> 7</td><td>find_max_default.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_default.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_default.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Warnings Are Your Friend - A Code Quality Primer<br />
<a href="https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/">https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/</a>
</li>

<li>Defending Against Compiler-Based Backdoors<br />
<a href="https://blog.regehr.org/archives/1241">https://blog.regehr.org/archives/1241</a>
</li>

<li>Reflections on Trusting Trust<br />
<a href="https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html">https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html</a>
</li>

<li>Coding Machines (povídka)<br />
<a href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>
</li>

<li>Stage0<br />
<a href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>
</li>

<li>Projekt stage0 na GitHubu<br />
<a href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>
</li>

<li>Bootstraping wiki<br />
<a href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>
</li>

<li>Bootstrapped 6502 Assembler<br />
<a href="https://github.com/robinluckey/bootstrap-6502">https://github.com/robinluckey/bootstrap-6502</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>What is a coder's worst nightmare?<br />
<a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute</a>
</li>

<li>Tiny C Compiler<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Welcome to C--<br />
<a href="https://www.cs.tufts.edu/~nr/c--/index.html">https://www.cs.tufts.edu/~nr/c--/index.html</a>
</li>

<li>c4 - C in four functions<br />
<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>Lattice C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Lattice_C">https://en.wikipedia.org/wiki/Lattice_C</a>
</li>

<li>Aztec C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Aztec_C">https://en.wikipedia.org/wiki/Aztec_C</a>
</li>

<li>Digital Mars (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Digital_Mars">https://en.wikipedia.org/wiki/Digital_Mars</a>
</li>

<li>Stránky projektu Open Watcom<br />
<a href="https://openwatcom.org/">https://openwatcom.org/</a>
</li>

<li>Repositář Open Watcom<br />
<a href="https://github.com/open-watcom/open-watcom-v2">https://github.com/open-watcom/open-watcom-v2</a>
</li>

<li>Watcom C/C++ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B">https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B</a>
</li>

<li>Turbo C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_C">https://en.wikipedia.org/wiki/Turbo_C</a>
</li>

<li>Borland C++ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Borland_C%2B%2B">https://en.wikipedia.org/wiki/Borland_C%2B%2B</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

