<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vývoj her a grafických i zvukových dem pro ZX Spectrum: výpis informací na obrazovku</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vývoj her a grafických i zvukových dem pro ZX Spectrum: výpis informací na obrazovku</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o vývoji programů pro legendární osmibitový domácí mikropočítač ZX Spectrum si ukážeme, jak lze zajistit výpis nějakých informací (znaků, řetězců atd.) na obrazovku. Využít přitom můžeme dvou přístupů: zavolat podprogramy dostupné v ROM ZX Spectra či si všechny potřebné rutiny napsat od začátku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vývoj her a grafických i zvukových dem pro ZX Spectrum: výpis informací na obrazovku</a></p>
<p><a href="#k02">2. Smazání obrazovky a otevření kanálu číslo 2 (<i>screen</i>)</a></p>
<p><a href="#k03">3. Tisk jednoho znaku na obrazovku přes rutinu uloženou v&nbsp;ROM</a></p>
<p><a href="#k04">4. Náhrada instrukce <strong>CALL</strong> za instrukci <strong>RST</strong></a></p>
<p><a href="#k05">5. Tisk znaku bez předchozího smazání obrazovky</a></p>
<p><a href="#k06">6. Tisk celé znakové sady (nekorektní varianta)</a></p>
<p><a href="#k07">7. Oprava předchozího demonstračního příkladu</a></p>
<p><a href="#k08">8. Řídicí znaky a sekvence řídicích znaků</a></p>
<p><a href="#k09">9. Modifikace barvy popředí a pozadí vypisovaných znaků</a></p>
<p><a href="#k10">10. Povolení blikání, vysoké intenzity popředí atd.</a></p>
<p><a href="#k11">11. Tisk na určité místo na obrazovce příkazem <strong>AT</strong></a></p>
<p><a href="#k12">12. Tisk celého řetězce</a></p>
<p><a href="#k13">13. Programová smyčka pro tisk řetězce znak po znaku</a></p>
<p><a href="#k14">14. Urychlení testu konce řetězce</a></p>
<p><a href="#k15">15. Tisk řetězce obsahujícího řídicí znaky</a></p>
<p><a href="#k16">16. Tisk celého řetězce s&nbsp;využitím subrutiny v&nbsp;ROM</a></p>
<p><a href="#k17">17. Obsah následujícího článku</a></p>
<p><a href="#k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vývoj her a grafických i zvukových dem pro ZX Spectrum: výpis informací na obrazovku</h2>

<p>Ve třetím článku o vývoji programů pro legendární osmibitový domácí
mikropočítač <i>ZX Spectrum</i> si ukážeme, jakým způsobem je možné zajistit
výpis nějakých informací (znaků, řetězců atd.) na obrazovku. Využít přitom
můžeme dvou přístupů. První přístup spočívá v&nbsp;zavolání již připravených
podprogramů uložených v&nbsp;ROM ZX Spectra, druhý přístup vyžaduje, abychom si
všechny potřebné rutiny napsali od začátku. Oba přístupy přitom mají své
opodstatnění. Subrutiny uložené v&nbsp;ROM jsou pro mnoho účelů dostatečně
rychlé a jejich nespornou výhodou je, že jejich reimplementaci nemusíme ukládat
do operační paměti, jejíž kapacita je omezena (něco jiného platí například pro
osmibitová Atari, kde lze ROM &bdquo;odklopit&ldquo; a využít tak téměř celých
64kB operační paměti). A pokud si subrutiny pro vykreslení znaku, řetězce,
změnu atributů (barvy atd.) napíšeme sami, můžeme realizovat například různé
nestandardní šířky a/nebo výšky znaků (více znaků na řádek atd.)
popř.&nbsp;dokonce vypisovat neproporcionální text.</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-1.png" class="image-825979" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="512" height="384" />
<p><i>Obrázek 1: Standardní znaková sada. ZX Spectrum sice nepodporuje klasické
textové režimy, ovšem tato znaková sada je uložena v&nbsp;ROM a používá ji
mnoho programů, včetně našich dnešních příkladů (text 32&times;24
znaků).</i></p>

<p>Tak daleko však dnes ještě nejsme, takže si ukážeme způsob volání subrutin,
které jsou připraveny v&nbsp;ROM ZX Spectra, a to jak v&nbsp;originální
licensované ROM, tak i v&nbsp;OpenSE BASICu (což je alternativní ROM, viz též
<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>).</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-2.png" class="image-825980" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="512" height="384" />
<p><i>Obrázek 2: Ukázka nestandardní znakové sady vykreslované vlastními
subrutinami (horní část obrazovky s&nbsp;výpisem programového kódu) kombinovaná
se standardní znakovou sadou (vstup textu ve spodní části obrazovky).</i></p>

<p>V&nbsp;demonstračních příkladech uvedených v&nbsp;následujících kapitolách
je použito pouze několik instrukcí, které postupně rozšiřují repertoár nám již
známých instrukcí z&nbsp;předchozích dvou článků. Tyto instrukce jsou, společně
s&nbsp;jejich stručným popisem, vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>Strojový kód</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis instrukce</th></tr>
<tr><td>3Exx</td><td>LD</td><td>A, xx</td><td>načtení osmibitové konstanty <i>xx</i> do akumulátoru <strong>A</strong></td></tr>
<tr><td>06xx</td><td>LD</td><td>B, xx</td><td>načtení osmibitové konstanty <i>xx</i> do pracovního registru <strong>B</strong></td></tr>
<tr><td>0exx</td><td>LD</td><td>C, xx</td><td>načtení osmibitové konstanty <i>xx</i> do pracovního registru <strong>C</strong></td></tr>
<tr><td>79</td><td>LD</td><td>A, C</td><td>přesun dat z&nbsp;registru <strong>C</strong> do akumulátoru <strong>A</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3C</td><td>INC</td><td>A </td><td>zvýšení obsahu akumulátoru <strong>A</strong> o jedničku</td></tr>
<tr><td>0C</td><td>INC</td><td>C </td><td>zvýšení obsahu pracovního registru <strong>C</strong> o jedničku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10rr</td><td>DJNZ</td><td>rr</td><td>snížení hodnoty registru <strong>B</strong> a relativní skok za podmínky, že nová hodnota registru <strong>B</strong> není nulová</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>C9</td><td>RET</td><td>&nbsp;</td><td>návrat z&nbsp;podprogramu</td></tr>
<tr><td>CDxxxx</td><td>CALL</td><td>xxxx</td><td>skok do podprogramu na adrese <i>xxxx</i> s&nbsp;uložením návratové adresy na zásobník</td></tr>
<tr><td>D7</td><td>RST</td><td>10</td><td>kratší a rychlejší varianta <strong>CALL</strong> pro vybraných osm adres</td></tr>
</table>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-3.png" class="image-825981" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="512" height="384" />
<p><i>Obrázek 3: Další ukázka nestandardní znakové sady vykreslované vlastními
subrutinami. Zde se dokonce jedná o neproporcionální fonty.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Smazání obrazovky a otevření kanálu číslo 2 (<i>screen</i>)</h2>

<p>Dnešní první demonstrační příklad bude provádět jedinou operaci &ndash;
zavolá službu resp.&nbsp;subrutinu neboli podprogram, jenž je uložený
v&nbsp;paměti ROM a je tedy programátorům snadno dostupný a navíc i velmi dobře
zdokumentovaný. Tento podprogram zajistí smazání obrazovky a otevření kanálu
číslo 2 (což je právě zařízení typu &bdquo;obrazovka&ldquo; neboli
<i>screen</i>). Podprogram <strong>ROM_CLS</strong> (popř.&nbsp;jen
<strong>CLS</strong>, viz například <a
href="https://skoolkit.ca/disassemblies/rom/asm/3435.html">tento popis</a>) je
v&nbsp;paměti ROM umístěn na adrese 0x0DAF a nevyžaduje žádné parametry, které
by se jinak předávaly buď v&nbsp;pracovních registrech nebo s&nbsp;využitím
speciálním zásobníku numerických hodnot typu <i>float</i> (k&nbsp;čemuž se
ještě dostaneme) v&nbsp;některém z&nbsp;dalších částí tohoto seriálu.</p>

<p>Zavolání podprogramu zajišťuje u mikroprocesorů Zilog Z80 (a i na mnoha
dalších mikroprocesorových architekturách) instrukce <strong>CALL</strong>,
která uloží návratovou adresu na zásobník a následně provede skok. Náš program
se tedy bude skládat ze dvou instrukcí <strong>CALL</strong> +
<strong>RET</strong>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: možná vás již napadlo, že dvojici
<strong>CALL</strong>+<strong>RET</strong> lze nahradit prostým skokem
<strong>JP</strong>.</div></p>

<p>Překlad výše uvedeného zdrojového kódu do assembleru bude vypadat
následovně:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:C9         RET
8004:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8003
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a>.</div></p>

<p>Podívejme se nyní na to, jak budou vypadat výsledky po spuštění
v&nbsp;emulátoru s&nbsp;originální ROM i v&nbsp;emulátoru, v&nbsp;němž je tato
licensovaná ROM nahrazena za OpenSE BASIC (tím mj.&nbsp;ověříme kompatibilitu
obou ROM minimálně z&nbsp;pohledu služby <strong>ROM_CLS</strong>:</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-4.png" class="image-825982" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 4: Smazání obrazovky v&nbsp;emulátoru s&nbsp;originální ROM
(zprávy dole jsou vypsány až po ukončení programu).</i></p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-5.png" class="image-825983" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 5: Smazání obrazovky v&nbsp;emulátoru s&nbsp;OpenSE
BASICem (povšimněte si nepatrně odlišné odezvy interpretru).</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Tisk jednoho znaku na obrazovku přes rutinu uloženou v&nbsp;ROM</h2>

<p>Ve chvíli, kdy je po zavolání subrutiny <strong>ROM_CLS</strong> umožněn
tisk na obrazovku, je možné využít subrutinu, která je dostupná na adrese 0x10
a popsaná je například <a
href="https://skoolkid.github.io/rom/asm/0010.html">zde</a>. Tato subrutina na
obrazovku vypíše jeden znak a posune (neviditelný) kurzor, který ukazuje na
místo na obrazovce, kam bude proveden další tisk (obrazovka je tedy použita
jako terminál). A jelikož tato subrutina potřebuje znát ASCII kód tisknutého
znaku, je nutné nějakým způsobem tento parametr předat. V&nbsp;tomto konkrétním
případě je to jednoduché, protože se jedná o jediný osmibitový parametr. Předán
bude v&nbsp;akumulátoru, tedy v&nbsp;registru <strong>A</strong> (to, jak se
parametry předávají do konkrétních subrutin, zjistíme právě z&nbsp;jejich
dokumentace). Program, který na obrazovku vytiskne znak &bdquo;*&ldquo;, jehož
ASCII kód je roven 42, může vypadat následovně:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
        ld   A, 42      <i>; kód znaku '*' pro tisk</i>
        call 0x10       <i>; zavolání rutiny v ROM</i>
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: namísto hodnoty 42 můžete zapsat i
'*'.</div></p>

<p>Překlad výše uvedeného zdrojového kódu do assembleru bude vypadat
následovně. Povšimněte si, že celý program zabere v&nbsp;operační paměti
pouhých devět bajtů:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:3E2A       LD A, 2A
8005:CD1000     CALL 0010
8008:C9         RET
8009:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8008
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a>.</div></p>

<p>Opět se podívejme na to, jak bude vypadat výsledek při použití originální i
volně dostupné ROM. Tyto ROM se totiž odlišují mj.&nbsp;i jinou znakovou sadou
(v&nbsp;prvním případě má hvězdička šest cípů, ve druhém pouze pět):</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-6.png" class="image-825984" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 6: Znak &bdquo;*&ldquo; vytištěný v&nbsp;emulátoru
s&nbsp;originální ROM ZX Spectra.</i></p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-7.png" class="image-825985" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 7: Znak &bdquo;*&ldquo; vytištěný v&nbsp;emulátoru s&nbsp;OpenSE
BASICem.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Náhrada instrukce <strong>CALL</strong> za instrukci <strong>RST</strong></h2>

<p>Program uvedený <a href="#k03">v&nbsp;předchozí kapitole</a> je ve
skutečnosti možné zkrátit a současně i urychlit. Je tomu tak z&nbsp;toho
důvodu, že volání podprogramů uložených na adresách 0x00, 0x08, 0x10, 0x18,
0x20, 0x28, 0x30 a 0x38 není nutné realizovat instrukcemi typu
<strong>CALL</strong>, jejichž strojový kód zabírá tři bajty a doba provedení
je velmi dlouhá &ndash; celých sedmnáct hodinových cyklů. Namísto toho lze
použít instrukci <strong>RST</strong>, která má po přeložení délku jednoho
bajtu a doba jejího provedení je taktéž kratší: jedenáct cyklů namísto cyklů
sedmnácti. Způsob zápisu operandů instrukce <strong>RST</strong> je u Zilogu
Z80 odlišný od Intelu 8080, ovšem díky tomu, že se operandy vždy odlišují,
nedojde při převodu zdrojových textů programů ke zmatkům:</p>

<table>
<tr><th>Intel 8080</th><th>Zilog Z80</th><th>Operační kód</th><th>Provedená operace</th></tr>
<tr><td>RST 0</td><td>RST 0  </td><td>C7</td><td>CALL 0</td></tr>
<tr><td>RST 1</td><td>RST 8  </td><td>CF</td><td>CALL 8</td></tr>
<tr><td>RST 2</td><td>RST 10H</td><td>D7</td><td>CALL 10H</td></tr>
<tr><td>RST 3</td><td>RST 18H</td><td>DF</td><td>CALL 18H</td></tr>
<tr><td>RST 4</td><td>RST 20H</td><td>E7</td><td>CALL 20H</td></tr>
<tr><td>RST 5</td><td>RST 28H</td><td>EF</td><td>CALL 28H</td></tr>
<tr><td>RST 6</td><td>RST 30H</td><td>F7</td><td>CALL 30H</td></tr>
<tr><td>RST 7</td><td>RST 38H</td><td>FF</td><td>CALL 38H</td></tr>
</table>

<p>Program tedy upravíme do následující zkrácené a současně i rychlejší
podoby:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
        ld   A, 42      <i>; kód znaku '*' pro tisk</i>
        rst  0x10       <i>; zavolání rutiny v ROM</i>
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Po překladu získáme tento kód, který je zcela zřejmě kratší v&nbsp;porovnání
s&nbsp;kódem <a href="#k03">z&nbsp;předchozí kapitoly</a> (má pouze sedm bajtů
namísto bajtů devíti):</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:3E2A       LD A, 2A
8005:D7         RST 10
8006:C9         RET
8007:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8006
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tisk znaku bez předchozího smazání obrazovky</h2>

<p>V&nbsp;některých aplikacích je zapotřebí vypsat nějaký text bez předchozího
smazání obrazovky. V&nbsp;tomto případě již není možné volat subrutinu
<strong>ROM_CLS</strong>, ale potřebujeme &bdquo;pouze&ldquo; otevřít kanál
zařízení &bdquo;screen&ldquo; s&nbsp;číslem 2. To se provede subrutinou
dostupnou na adrese 0x1601, kterou si pojmenujeme
<strong>ROM_OPEN_CHANNEL</strong> a jejíž popis je dostupný na adrese <a
href="https://skoolkit.ca/disassemblies/rom/asm/5633.html">https://skoolkit.ca/disassemblies/rom/asm/5633.html</a>.
K&nbsp;samotnému <a
href="https://sinclair.wiki.zxnet.co.uk/wiki/Channels_and_streams">popisu
konceptu kanálů</a> se ještě vrátíme &ndash; jedná se o jeden z&nbsp;velmi
užitečných konceptů ZX Spectra. Program tedy upravíme do podoby:</p>

<pre>
ENTRY_POINT      equ $8000
ROM_OPEN_CHANNEL equ $1601
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld   A,2              <i>; číslo kanálu</i>
        call ROM_OPEN_CHANNEL <i>; otevření kanálu číslo 2 (screen)</i>
        ld   A, 42            <i>; kód znaku '*' pro tisk</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
        ret                   <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledek po překladu:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_OPEN_CHANNEL EQU 1601
                ORG 8000
8000:           label start
8000:3E02       LD A, 02
8002:CD0116     CALL 1601
8005:3E2A       LD A, 2A
8007:D7         RST 10
8008:C9         RET
8009:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8008
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Tisk celé znakové sady (nekorektní varianta)</h2>

<p>Nyní již máme k&nbsp;dispozici (alespoň zdánlivě) všechny informace potřebné
pro vytištění celé znakové sady, tedy konkrétně znaků s&nbsp;kódy 32 až 128
(ASCII), ke kterým je přidáno dalších <a
href="http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/zx-spectrum-character-set">šestnáct
znaků pro pseudografiku</a>. Pokusme se tedy pro tento účel použít programovou
smyčku s&nbsp;počitadlem uloženým v&nbsp;pracovním registru <strong>B</strong>
a kódem aktuálně tisknutého znaku uloženého v&nbsp;registru <strong>A</strong>
(tedy v&nbsp;akumulátoru). Samotná programová smyčka je triviální, protože jak
výpočet nové hodnoty počitadla, tak i podmíněný skok je implementován jedinou
instrukcí <strong>DJNZ</strong> (viz předchozí článek). Hodnota uložená
v&nbsp;registru <strong>A</strong> je předána na subrutiny pro tisk jednoho
znaku:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld  a, ' '      <i>; kód prvního zapisovaného znaku</i>
        ld  b, 96+16    <i>; počitadlo smyčky</i>
&nbsp;
loop:
        rst  0x10       <i>; zavolání rutiny v ROM</i>
&nbsp;
        inc a           <i>; zvýšení zapisované hodnoty (kódu znaku)</i>
        djnz loop       <i>; kombinace dec b + jp NZ, loop</i>
                        <i>; snížení hodnoty počitadla</i>
                        <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>A takto vypadá výsledek překladu. Program je (pochopitelně) nepatrně delší,
než tomu bylo u předchozích demonstračních příkladů:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:3E20       LD A, 20
8005:0670       LD B, 70
8007:           label loop
8007:D7         RST 10
8008:3C         INC A
8009:10FC       DJNZ 8007
800B:C9         RET
800C:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800B
</pre>

<p>Podívejme se však na výsledek:</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-8.png" class="image-825986" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 8: Obrazovka, kterou jsme získali po spuštění demonstračního
příkladu z&nbsp;této kapitoly.</i></p>

<p>Z&nbsp;výsledku je patrné, že program nepracuje přesně tak, jak jsme
očekávali, protože sice vytiskne počáteční mezeru (což je správně), ovšem
posléze je vytištěna jen sekvence devítek. Opravu provedeme v&nbsp;rámci
navazující kapitoly.</p>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Oprava předchozího demonstračního příkladu</h2>

<p>Chyba, která se &bdquo;vloudila&ldquo; do demonstračního příkladu uvedeného
<a href="#k06">v&nbsp;šesté kapitole</a>, nám ukazuje další vlastnost subrutin
uložených v&nbsp;paměti ROM &ndash; po zavolání subrutiny se mohou obsahy
některých pracovních registrů změnit, což je i náš případ, protože se změnil
obsah akumulátoru <strong>A</strong> na hodnotu, která odpovídá kódu znaku
&bdquo;8&ldquo;, což je decimálně 56 popř.&nbsp;hexadecimálně 0x38. Náprava je
v&nbsp;tomto případě velmi snadná &ndash; nebudeme akumulátor používat pro
uložení kódu vypisovaného znaku, ale použijeme namísto toho jiný pracovní
registr, například registr <strong>C</strong>. Samozřejmě bude nutné při volání
subrutiny na adrese 0x10 naplnit akumulátor kódem znaku, ale již nás nebude
zajímat, zda a proč se tato hodnota v&nbsp;subrutině změnila, protože původní
hodnota zůstane v&nbsp;<strong>C</strong>:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld  c, ' '      <i>; kód prvního zapisovaného znaku</i>
        ld  b, 96+16    <i>; počitadlo smyčky</i>
&nbsp;
loop:
        ld   a, c       <i>; kód zapisovaného znaku</i>
        rst  0x10       <i>; zavolání rutiny v ROM</i>
&nbsp;
        inc c           <i>; zvýšení zapisované hodnoty (kód znaku)</i>
        djnz loop       <i>; kombinace dec b + jp NZ, loop</i>
                        <i>; snížení hodnoty počitadla</i>
                        <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Překlad do strojového kódu vypadá v&nbsp;lidsky čitelné podobě
následovně:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:0E20       LD C, 20
8005:0670       LD B, 70
8007:           label loop
8007:79         LD A, C
8008:D7         RST 10
8009:0C         INC C
800A:10FB       DJNZ 8007
800C:C9         RET
800D:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800C
</pre>

<p>Nyní tento demonstrační příklad skutečně vypíše celou dostupnou znakovou
sadu ZX Spectra, což znamená podmnožinu odpovídající ASCII (až na několik
malých změn &ndash; například se týká znaku libry a &copy;), která je doplněna
o šestnáct pseudografických znaků využívaných například na mikropočítačích
ZX-80 a ZX-81 pro tvorbu (pseudo)grafiky:</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-9.png" class="image-825987" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 9: Znaková sada ZX Spectra s&nbsp;originální ROM.</i></p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-10.png" class="image-825988" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 10: Znaková sada ZX Spectra s&nbsp;volně dostupnou ROM
s&nbsp;OpenSE BASICem.</i></p>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Řídicí znaky a sekvence řídicích znaků</h2>

<p>V&nbsp;předchozím textu jsme si mj.&nbsp;uvedli odkaz na <a
href="http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/zx-spectrum-character-set">stránku
se znakovou sadou ZX Spectra</a>. Ovšem tato stránka obsahuje i další důležité
informace. Například ve druhém sloupci, který obsahuje kódy od 0x10 do 0x1f,
můžeme najít seznam <i>řídicích kódů</i>, které &ndash; pokud budou vytisknuty
&ndash; ovlivní znaky tisknuté později. Samotný řídicí kód není při tisku
viditelný, ale změní vnitřní stav subrutiny pro tisk znaku. Všechny řídicí kódy
navíc očekávají jeden či dva parametry, což jsou vlastně taktéž tisknuté
&bdquo;znaky&ldquo;, jak to ostatně uvidíme v&nbsp;příkladem uvedených
v&nbsp;navazujících kapitolách:</p>

<table>
<tr><th>Řídicí kód</th><th>Parametr #1</th><th>Parametr #2</th></tr>
<tr><td>Ink</td><td>index barvy</td><td>&nbsp;</th></tr>
<tr><td>Paper</td><td>index barvy</td><td>&nbsp;</td></tr>
<tr><td>Flash</td><td>0 nebo 1</td><td>&nbsp;</td></tr>
<tr><td>Bright</td><td>0 nebo 1</td><td>&nbsp;</td></tr>
<tr><td>Inverse</td><td>0 nebo 1</td><td>&nbsp;</td></tr>
<tr><td>Over</td><td>0 nebo 1</td><td>&nbsp;</td></tr>
<tr><td>At</td><td>řádek</td><td>sloupec</td></tr>
<tr><td>Tab</td><td>počet mezer</td><td>&nbsp;</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Modifikace barvy popředí a pozadí vypisovaných znaků</h2>

<p>V&nbsp;dalším demonstračním příkladu si ukážeme způsob využití řídicích kódů
určených pro změnu barvy inkoustu (<i>INK</i>) a modifikaci barvy papíru
(<i>PAPER</i>). Pokud budeme například chtít zobrazit barevnou hvězdičku na
modrém pozadí, budou se &bdquo;tisknout&ldquo; tyto znaky:</p>

<ol>
<li>řídicí kód pro změnu barvy inkoustu</li>
<li>index barvy inkoustu</li>
<li>řídicí kód pro změnu barvy pozadí</li>
<li>index barvy pozadí</li>
<li>a konečně vlastní hvězdička</li>
</ol>

<p>Vše lze zrealizovat takto přímočaře (i když nepříliš obecně):</p>

<pre>
ENTRY_POINT      equ $8000
ROM_OPEN_CHANNEL equ $1601
&nbsp;
INK              equ $10
PAPER            equ $11
FLASH            equ $12
BRIGHT           equ $13
INVERSE          equ $14
&nbsp;
BLACK_COLOR      equ %000
BLUE_COLOR       equ %001
RED_COLOR        equ %010
MAGENTA_COLOR    equ %011
GREEN_COLOR      equ %100
CYAN_COLOR       equ %101
YELLOW_COLOR     equ %110
WHITE_COLOR      equ %111
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld   A,2              <i>; číslo kanálu</i>
        call ROM_OPEN_CHANNEL <i>; otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   A, INK           <i>; řídicí kód pro specifikaci barvy inkoustu</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ld   A, YELLOW_COLOR  <i>; barva inkoustu</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ld   A, PAPER         <i>; řídicí kód pro specifikaci barvy papíru</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ld   A, BLUE_COLOR    <i>; barva papíru</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ld   A, 42            <i>; kód znaku '*' pro tisk</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ret                   <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Způsob překladu tohoto demonstračního příkladu do assembleru:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_OPEN_CHANNEL EQU 1601
INK             EQU 0010
PAPER           EQU 0011
FLASH           EQU 0012
BRIGHT          EQU 0013
INVERSE         EQU 0014
BLACK_COLOR     EQU 0000
BLUE_COLOR      EQU 0001
RED_COLOR       EQU 0002
MAGENTA_COLOR   EQU 0003
GREEN_COLOR     EQU 0004
CYAN_COLOR      EQU 0005
YELLOW_COLOR    EQU 0006
WHITE_COLOR     EQU 0007
                ORG 8000
8000:           label start
8000:3E02       LD A, 02
8002:CD0116     CALL 1601
8005:3E10       LD A, 10
8007:D7         RST 10
8008:3E06       LD A, 06
800A:D7         RST 10
800B:3E11       LD A, 11
800D:D7         RST 10
800E:3E01       LD A, 01
8010:D7         RST 10
8011:3E2A       LD A, 2A
8013:D7         RST 10
8014:C9         RET
8015:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8014
</pre>

<p>A konečně se podívejme na výsledek, který odpovídá popisu:</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-11.png" class="image-825989" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 11: Hvězdička je nyní zobrazena žlutou barvou a s&nbsp;modrým
pozadím.</i></p>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Povolení blikání, vysoké intenzity popředí atd.</h2>

<p>Mnohé řídicí kódy zmíněné <a href="#k08">v&nbsp;osmé kapitole</a> vyžadují,
aby se příslušná vlastnost (blikání, vysoká intenzita atd.) povolila či naopak
zakázala druhým řídicím kódem, tedy hodnotou 0 nebo 1. Ukažme si například, jak
lze vynutit blikání hvězdičky, a to s&nbsp;využitím řídicího znaku
<i>FLASH</i>:</p>

<pre>
ENTRY_POINT      equ $8000
ROM_OPEN_CHANNEL equ $1601
&nbsp;
INK              equ $10
PAPER            equ $11
FLASH            equ $12
BRIGHT           equ $13
INVERSE          equ $14
&nbsp;
ENABLE           equ 1
DISABLE          equ 0
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld   A,2              <i>; číslo kanálu</i>
        call ROM_OPEN_CHANNEL <i>; otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   A, FLASH         <i>; řídicí kód pro specifikaci blikání</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ld   A, ENABLE        <i>; povolení blikání</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ld   A, 42            <i>; kód znaku '*' pro tisk</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ret                   <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Takto vypadá lidsky čitelný výsledek překladu demonstračního příkladu
z&nbsp;této kapitoly:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_OPEN_CHANNEL EQU 1601
INK             EQU 0010
PAPER           EQU 0011
FLASH           EQU 0012
BRIGHT          EQU 0013
INVERSE         EQU 0014
ENABLE          EQU 0001
DISABLE         EQU 0000
                ORG 8000
8000:           label start
8000:3E02       LD A, 02
8002:CD0116     CALL 1601
8005:3E12       LD A, 12
8007:D7         RST 10
8008:3E01       LD A, 01
800A:D7         RST 10
800B:3E2A       LD A, 2A
800D:D7         RST 10
800E:C9         RET
800F:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800E
</pre>

<p>A výsledkem by po spuštění v&nbsp;emulátoru měla být skutečně blikající
hvězdička:</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-12.png" class="image-825990" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 12: Blikající hvězdička vytištěná demonstračním příkladem.</i></p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-13.png" class="image-825991" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 13: Blikající hvězdička vytištěná demonstračním příkladem.</i></p>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Tisk na určité místo na obrazovce příkazem <strong>AT</strong></h2>

<p>Posledním zajímavým řídicím znakem, s&nbsp;nímž se dnes setkáme, je řídicí
znak <i>AT</i> (jenž je interně použit v&nbsp;BASICovském příkazu <strong>PRINT
AT</strong>). Tento řídicí znak přesune neviditelný &bdquo;kurzor&ldquo; na
určený řádek a sloupec, i když na tomto místě je vhodné poznamenat, že koncept
kurzoru je na ZX Spectru pojat poněkud odlišně, než například na osmibitových
Atari s&nbsp;celoobrazovkovým editorem. Ovšem vraťme se k&nbsp;assembleru na ZX
Spectru. Necháme si opět vypsat hvězdičku, ovšem tentokrát na samotný konec
sedmnáctého řádku. Příkazu <i>AT</i> se tedy předá dvojice parametrů 16 (řádek)
a 31 (sloupec):</p>

<pre>
ENTRY_POINT      equ $8000
ROM_OPEN_CHANNEL equ $1601
&nbsp;
AT               equ 0x16
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld   A,2              <i>; číslo kanálu</i>
        call ROM_OPEN_CHANNEL <i>; otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   A, AT            <i>; řídicí kód pro specifikaci pozice psaní</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ld   A, 16            <i>; y-ová souřadnice</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ld   A, 31            <i>; x-ová souřadnice</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ld   A, 42            <i>; kód znaku '*' pro tisk</i>
        rst  0x10             <i>; zavolání rutiny v ROM</i>
&nbsp;
        ret                   <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Takto vypadá lidsky čitelný výsledek překladu demonstračního příkladu
z&nbsp;této kapitoly:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_OPEN_CHANNEL EQU 1601
AT              EQU 0016
                ORG 8000
8000:           label start
8000:3E02       LD A, 02
8002:CD0116     CALL 1601
8005:3E16       LD A, 16
8007:D7         RST 10
8008:3E10       LD A, 10
800A:D7         RST 10
800B:3E1F       LD A, 1F
800D:D7         RST 10
800E:3E2A       LD A, 2A
8010:D7         RST 10
8011:C9         RET
8012:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8011
</pre>

<p>Výsledkem by měla být obrazovka s&nbsp;tímto obsahem:</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-14.png" class="image-825992" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 14: Hvězdička vykreslená na samotném konci sedmnáctého
řádku.</i></p>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Tisk celého řetězce</h2>

<p>V&nbsp;dalších čtyřech kapitolách si ukážeme, jakým způsobem lze realizovat
tisk celého řetězce, a to jak řetězce se známou délkou (tu nám dokáže vypočítat
assembler), tak i céčkovského řetězce ukončeného nulou popř.&nbsp;jiným znakem
(někdy se používá znak dolaru atd.). Opět existuje několik variant realizace
tisku řetězce &ndash; buď budeme sami provádět tisk ve smyčce, tedy znak po
znaku nebo využijeme další subrutinu uloženou v&nbsp;paměti ROM, která tisk
provede za nás. Ve druhém případě budeme nepatrně omezeni tím, jaké tato
subrutina očekává parametry a jak se zadává konec řetězce.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Programová smyčka pro tisk řetězce znak po znaku</h2>

<p>Nejprve si ukažme tisk řetězce realizovaný programovou smyčkou. Až na způsob
deklarace řetězce (ukončeného nulou):</p>

<pre>
TEXT:   db "Hello, Speccy!", 0
</pre>

<p>vlastně tento příklad neobsahuje žádné komplikace, neboť programovou smyčku
již umíme vytvořit, stejně jako umíme otestovat obsah registru na nulu. Pro
adresování se používá dvojice registrů HL a výskok je uvnitř smyčky (ne na
konci):</p>

<pre>
ENTRY_POINT      equ $8000
ROM_OPEN_CHANNEL equ $1601
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld   A,2              <i>; číslo kanálu</i>
        call ROM_OPEN_CHANNEL <i>; otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   HL, TEXT         <i>; adresa prvního znaku v řetězci</i>
&nbsp;
LOOP:
        ld   A, (HL)          <i>; načíst kód znaku z řetězce</i>
        cp   0                <i>; test na kód znak s kódem 0</i>
        ret  Z                <i>; ukončit program na konci řetězce</i>
&nbsp;
        rst  0x10             <i>; zavolání rutiny v ROM</i>
        inc  HL               <i>; přechod na další znak</i>
        jr   LOOP
&nbsp;
<i>; nulou ukončený řetězec</i>
TEXT:   db "Hello, Speccy!", 0
&nbsp;
end ENTRY_POINT
</pre>

<p>Překlad tohoto příkladu do strojového kódu bude vypadat následovně:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_OPEN_CHANNEL EQU 1601
                ORG 8000
8000:           label start
8000:3E02       LD A, 02
8002:CD0116     CALL 1601
8005:211080     LD HL, 8010
8008:           label LOOP
8008:7E         LD A, (HL)
8009:FE00       CP 00
800B:C8         RET Z
800C:D7         RST 10
800D:23         INC HL
800E:18F8       JR 8008
8010:           label TEXT
8010:48656C6C   DEFB of 15 bytes
8014:6F2C2053
8018:70656363
801C:792100
801F:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 801E
</pre>

<p>A samozřejmě si ukážeme i výsledek:</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-15.png" class="image-825993" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 15: Řetězec vytištěný demonstračním příkladem.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Urychlení testu konce řetězce</h2>

<p>Nulou ukončené řetězce jsou masivně používány v&nbsp;céčku a tím pádem i
v&nbsp;mnoha knihovnách, které jsou v&nbsp;C psány či na C postaveny. Nejedná
se o náhodu, protože test na nulovou hodnotu lze na mnoha mikroprocesorových
architekturách realizovat snadněji a rychleji, než test na jinou hodnotu.
Ostatně podívejme se, jak je tomu v&nbsp;případě Zilogu Z80. Explicitní test na
nulu je instrukce s&nbsp;délkou dvou bajtů a dobou vykonání sedmi cyklů:</p>

<pre>
cp   0                <i>; test na kód znak s kódem 0</i>
</pre>

<p>Ovšem namísto toho můžeme použít například instrukci <strong>and a</strong>,
která má délku jen jeden bajt a doba jejího vykonání je čtyři takty (patří tedy
do skupiny nejrychlejších instrukcí). Tato instrukce nezmění obsah akumulátoru,
ale nastaví příznak <i>zero</i> ve chvíli, kdy akumulátor skutečně obsahuje
nulu:</p>

<pre>
and  a                <i>; test na kód znak s kódem 0</i>
</pre>

<p>Upravený zdrojový kód demonstračního příkladu může vypadat takto:</p>

<pre>
ENTRY_POINT      equ $8000
ROM_OPEN_CHANNEL equ $1601
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld   A,2              <i>; číslo kanálu</i>
        call ROM_OPEN_CHANNEL <i>; otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   HL, TEXT         <i>; adresa prvního znaku v řetězci</i>
&nbsp;
LOOP:
        ld   A, (HL)          <i>; načíst kód znaku z řetězce</i>
        and  a                <i>; test na kód znak s kódem 0</i>
        ret  Z                <i>; ukončit program na konci řetězce</i>
&nbsp;
        rst  0x10             <i>; zavolání rutiny v ROM</i>
        inc  HL               <i>; přechod na další znak</i>
        jr   LOOP
&nbsp;
<i>; nulou ukončený řetězec</i>
TEXT:   db "Hello, Speccy!", 0
&nbsp;
end ENTRY_POINT
</pre>

<p>Zpráva o překladu do strojového kódu skutečně ukazuje, že je výsledek o
jeden bajt kratší:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_OPEN_CHANNEL EQU 1601
                ORG 8000
8000:           label start
8000:3E02       LD A, 02
8002:CD0116     CALL 1601
8005:210F80     LD HL, 800F
8008:           label LOOP
8008:7E         LD A, (HL)
8009:A7         AND A
800A:C8         RET Z
800B:D7         RST 10
800C:23         INC HL
800D:18F9       JR 8008
800F:           label TEXT
800F:48656C6C   DEFB of 15 bytes
8013:6F2C2053
8017:70656363
801B:792100
801E:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 801D
</pre>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-16.png" class="image-825994" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 16: Řetězec vytištěný demonstračním příkladem (výstup je totožný
s&nbsp;předchozím příkladem).</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Tisk řetězce obsahujícího řídicí znaky</h2>

<p>Řetězec, který tiskneme s&nbsp;využitím explicitně zapsané programové
smyčky, může pochopitelně obsahovat i řídicí znaky atd. Samotný programový kód
nebude vyžadovat žádné úpravy, pouze se podívejme, jak vypadá deklarace řetězce
&bdquo;proloženého&ldquo; řídicími znaky:</p>

<pre>
TEXT:   db PAPER, RED_COLOR, "Hello", INK, WHITE_COLOR, "Speccy", FLASH, 1, "!", 0
</pre>

<p><div class="rs-tip-major">Poznámka: což je mimochodem přehlednější zápis,
než tomu je v&nbsp;mnoha vysokoúrovňových programovacích jazycích.</div></p>

<p>Celý zdrojový kód s&nbsp;takto deklarovaným řetězcem bude vypadat
následovně:</p>

<pre>
ENTRY_POINT      equ $8000
ROM_OPEN_CHANNEL equ $1601
&nbsp;
INK              equ $10
PAPER            equ $11
FLASH            equ $12
BRIGHT           equ $13
INVERSE          equ $14
&nbsp;
BLACK_COLOR      equ %000
BLUE_COLOR       equ %001
RED_COLOR        equ %010
MAGENTA_COLOR    equ %011
GREEN_COLOR      equ %100
CYAN_COLOR       equ %101
YELLOW_COLOR     equ %110
WHITE_COLOR      equ %111
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld   A,2              <i>; číslo kanálu</i>
        call ROM_OPEN_CHANNEL <i>; otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   HL, TEXT         <i>; adresa prvního znaku v řetězci</i>
&nbsp;
LOOP:
        ld   A, (HL)          <i>; načíst kód znaku z řetězce</i>
        and  a                <i>; test na kód znak s kódem 0</i>
        ret  Z                <i>; ukončit program na konci řetězce</i>
&nbsp;
        rst  0x10             <i>; zavolání rutiny v ROM</i>
        inc  HL               <i>; přechod na další znak</i>
        jr   LOOP
&nbsp;
<i>; nulou ukončený řetězec</i>
TEXT:   db PAPER, RED_COLOR, "Hello", INK, WHITE_COLOR, "Speccy", FLASH, 1, "!", 0
&nbsp;
end ENTRY_POINT
</pre>

<p>Překlad do strojového kódu:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_OPEN_CHANNEL EQU 1601
INK             EQU 0010
PAPER           EQU 0011
FLASH           EQU 0012
BRIGHT          EQU 0013
INVERSE         EQU 0014
BLACK_COLOR     EQU 0000
BLUE_COLOR      EQU 0001
RED_COLOR       EQU 0002
MAGENTA_COLOR   EQU 0003
GREEN_COLOR     EQU 0004
CYAN_COLOR      EQU 0005
YELLOW_COLOR    EQU 0006
WHITE_COLOR     EQU 0007
                ORG 8000
8000:           label start
8000:3E02       LD A, 02
8002:CD0116     CALL 1601
8005:210F80     LD HL, 800F
8008:           label LOOP
8008:7E         LD A, (HL)
8009:A7         AND A
800A:C8         RET Z
800B:D7         RST 10
800C:23         INC HL
800D:18F9       JR 8008
800F:           label TEXT
800F:11024865   DEFB of 19 bytes
8013:6C6C6F10
8017:07537065
801B:63637912
801F:012100
8022:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8021
</pre>

<p>A konečně se podívejme na výslednou obrazovku, která mj.&nbsp;obsahuje i
blikající vykřičník:</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-17.png" class="image-825995" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 17: Vícebarevný a částečně blikající text vytištěný demonstračním příkladem.</i></p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-18.png" class="image-825996" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 18: Vícebarevný a částečně blikající text vytištěný demonstračním příkladem.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Tisk celého řetězce s&nbsp;využitím subrutiny v&nbsp;ROM</h2>

<p>V&nbsp;dnešním posledním demonstračním příkladu využijeme pro tisk řetězce
subrutinu, která je uložena v&nbsp;paměti ROM od adresy
<strong>0x203C</strong>. Tato subrutina vyžaduje několik parametrů:</p>

<ol>
<li>V&nbsp;registrovém páru <strong>BC</strong> musí být uložena délka řetězce</li>
<li>V&nbsp;registrovém páru <strong>DE</strong> musí být uložena adresa prvního znaku v&nbsp;řetězci</li>
</ol>

<p>Kvůli tomu, že se pracuje s&nbsp;(předem známou) délkou řetězce, není nutné,
aby byl řetězec ukončen nulou. Jak se však délka řetězce získá? Pomůže nám
samotný assembler <i>Pasmo</i>, který v&nbsp;pseudoproměnné $ obsahuje aktuálně
zpracovávanou adresu. Postačuje tedy tuto adresu odečíst od počáteční adresy
řetězce (tu assembler zná, stejně jako ukazatelovou aritmetiku), vypočítat
délku a tu následně použít (v&nbsp;druhém průchodu se konstanta s&nbsp;délkou
doplní do kódu):</p>

<pre>
<i>; řetězec</i>
TEXT:   db PAPER, RED_COLOR, "Hello", INK, WHITE_COLOR, "Speccy", FLASH, 1, "!"
&nbsp;
TEXT_LENGTH: equ $ - TEXT
</pre>

<p>A takto vypadá výsledný programový kód, který je kratší, než kód
s&nbsp;explicitní smyčkou:</p>

<pre>
ENTRY_POINT      equ $8000
ROM_OPEN_CHANNEL equ $1601
ROM_PRINT        equ $203C
&nbsp;
INK              equ $10
PAPER            equ $11
FLASH            equ $12
BRIGHT           equ $13
INVERSE          equ $14
&nbsp;
BLACK_COLOR      equ %000
BLUE_COLOR       equ %001
RED_COLOR        equ %010
MAGENTA_COLOR    equ %011
GREEN_COLOR      equ %100
CYAN_COLOR       equ %101
YELLOW_COLOR     equ %110
WHITE_COLOR      equ %111
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld   A,2              <i>; číslo kanálu</i>
        call ROM_OPEN_CHANNEL <i>; otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   DE, TEXT         <i>; adresa prvního znaku v řetězci</i>
        ld   BC, TEXT_LENGTH  <i>; délka textu</i>
        call ROM_PRINT        <i>; volání subrutiny v ROM</i>
        ret                   <i>; ukončit program</i>
&nbsp;
<i>; řetězec</i>
TEXT:   db PAPER, RED_COLOR, "Hello", INK, WHITE_COLOR, "Speccy", FLASH, 1, "!"
&nbsp;
TEXT_LENGTH: equ $ - TEXT
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledek překladu do strojového kódu:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_OPEN_CHANNEL EQU 1601
ROM_PRINT       EQU 203C
INK             EQU 0010
PAPER           EQU 0011
FLASH           EQU 0012
BRIGHT          EQU 0013
INVERSE         EQU 0014
BLACK_COLOR     EQU 0000
BLUE_COLOR      EQU 0001
RED_COLOR       EQU 0002
MAGENTA_COLOR   EQU 0003
GREEN_COLOR     EQU 0004
CYAN_COLOR      EQU 0005
YELLOW_COLOR    EQU 0006
WHITE_COLOR     EQU 0007
                ORG 8000
8000:           label start
8000:3E02       LD A, 02
8002:CD0116     CALL 1601
8005:110F80     LD DE, 800F
8008:011200     LD BC, 0012
800B:CD3C20     CALL 203C
800E:C9         RET
800F:           label TEXT
800F:11024865   DEFB of 18 bytes
8013:6C6C6F10
8017:07537065
801B:63637912
801F:0121
TEXT_LENGTH     EQU 0012
8021:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8020
</pre>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-19.png" class="image-825997" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 19: Vícebarevný a částečně blikající text vytištěný demonstračním příkladem.</i></p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-20.png" class="image-825998" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 20: Vícebarevný a částečně blikající text vytištěný demonstračním příkladem.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah následujícího článku</h2>

<p>V&nbsp;pořadí již čtvrté části seriálu o vývoji programů pro legendární
osmibitový domácí mikropočítač ZX Spectrum si ukážeme různé způsoby přímé
manipulace s&nbsp;obrazovou pamětí, tedy konkrétně takové postupy, které se
obejdou bez využití podprogramů, které jsou uloženy v&nbsp;ROM. Popíšeme si
tedy jak strukturu obrazové paměti (prozatím jsme si v&nbsp;demonstračních
příkladech otestovali &bdquo;pouze&ldquo; strukturu paměti s&nbsp;barvovými
atributy, nikoli ovšem způsob uložení podkladové bitmapy), tak i některé
vlastní rutiny použitelné pro vykreslování různých obrazců, ale i běžného
textu. Věnovat se budeme i některým postupům, které se na ZX Spectru používají
pro vykreslení pohybujících se objektů (spritů). Nakonec se zmíníme o
problematice práce s&nbsp;okrajem obrazovky (<i>border</i>), protože i tato
část obrazu může být do jisté míry využita.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<p>Výše uvedené demonstrační příklady i příklady, které již byly popsány
v&nbsp;předchozích dvou článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
je možné přeložit s&nbsp;využitím souboru Makefile, jehož aktuální verze vypadá
následovně (pro překlad a slinkování je použit assembler <i>Pasmo</i>):</p>

<pre>
ASSEMBLER := pasmo
&nbsp;
all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap
&nbsp;
clean:
        rm -f *.tap
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 01-color-attribute.lst
&nbsp;
02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 02-blinking-attribute.lst
&nbsp;
03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 03-symbolic-names.lst
&nbsp;
04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 04-operators.lst
&nbsp;
05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 05-better-symbols.lst
&nbsp;
06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 06-tapbas-v1.lst
&nbsp;
07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 07-tapbas-v2.lst
&nbsp;
08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 08-loop.lst
&nbsp;
09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 09-loop.lst
&nbsp;
10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 10-loop.lst
&nbsp;
11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 11-loop.lst
&nbsp;
12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 12-loop.lst
&nbsp;
13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 13-loop.lst
&nbsp;
14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 14-loop.lst
&nbsp;
15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 15-loop.lst
&nbsp;
16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 16-loop.lst
&nbsp;
17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 17-loop.lst
&nbsp;
18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 18-cls.lst
&nbsp;
19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 19-print-char-call.lst
&nbsp;
20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 20-print-char-rst.lst
&nbsp;
21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 21-print-char.lst
&nbsp;
22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 22-print-all-chars.lst
&nbsp;
23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 23-print-all-chars.lst
&nbsp;
24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 24-change-color.lst
&nbsp;
25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 25-change-flash.lst
&nbsp;
26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 26-print-at.lst
&nbsp;
27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 27-print-string.lst
&nbsp;
28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 28-print-string.lst
&nbsp;
29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 29-print-colorized-string.lst
&nbsp;
30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 30-print-string-ROM.lst
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech demonstračních příkladů do podoby obrazu magnetické pásky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>Z80 Assembly Language for the ZX Spectrum Tutorial, Episode 1: The Basics<br />
<a href="https://www.youtube.com/watch?v=_J4ahkWtNYw">https://www.youtube.com/watch?v=_J4ahkWtNYw</a>
</li>

<li>Z80 assembly resources when starting programming in assembler<br />
<a href="https://www.youtube.com/watch?v=mjLHSnQmHV4">https://www.youtube.com/watch?v=mjLHSnQmHV4</a>
</li>

<li>Setting up Visual Studio Code with Pasmo, Sprite Example ZX Spectrum Next<br />
<a href="https://www.youtube.com/watch?v=lKDaFWPObLY">https://www.youtube.com/watch?v=lKDaFWPObLY</a>
</li>

<li>RetroCoder ZX Spectrum development (Z80 Assembly)- Day 1 - Hello World.asm<br />
<a href="https://www.youtube.com/watch?v=Xv6NAC--x24">https://www.youtube.com/watch?v=Xv6NAC--x24</a>
</li>

<li>Rozšíření paměti<br />
<a href="https://wiki.ilnx.cz/doku.php/lnxspectrum:memorymap">https://wiki.ilnx.cz/doku.php/lnxspectrum:memorymap</a>
</li>

<li>ZX-Spectrum 48K video memory map<br />
<a href="https://www.reddit.com/r/zxspectrum/comments/phi7lt/zxspectrum_48k_video_memory_map/">https://www.reddit.com/r/zxspectrum/comments/phi7lt/zxspectrum_48k_video_memory_map/</a>
</li>

<li>Memory Map: 48K Spectrum<br />
<a href="http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/memory-map">http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/memory-map</a>
</li>

<li>ZX Basic: Git repository<br />
<a href="https://github.com/boriel/zxbasic">https://github.com/boriel/zxbasic</a>
</li>

<li>ZX Basic Wiki<br />
<a href="https://zxbasic.readthedocs.io/en/docs/">https://zxbasic.readthedocs.io/en/docs/</a>
</li>

<li>ZX Spectrum Games: svět osmibitové herní legendy<br />
<a href="https://www.zx-spectrum.cz/">https://www.zx-spectrum.cz/</a>
</li>

<li>TAP format<br />
<a href="https://sinclair.wiki.zxnet.co.uk/wiki/TAP_format">https://sinclair.wiki.zxnet.co.uk/wiki/TAP_format</a>
</li>

<li>Contended memory<br />
<a href="https://worldofspectrum.org/faq/reference/48kreference.htm#Contention">https://worldofspectrum.org/faq/reference/48kreference.htm#Contention</a>
</li>

<li>Screen Memory Layout<br />
<a href="http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/screen-memory-layout">http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/screen-memory-layout</a>
</li>

<li>OpenSE BASIC<br />
<a href="https://zxdesign.itch.io/opense">https://zxdesign.itch.io/opense</a>
</li>

<li>Domácí a školní mikropočítače řady Didaktik<br />
<a href="https://www.root.cz/clanky/domaci-a-skolni-mikropocitace-rady-didaktik/">https://www.root.cz/clanky/domaci-a-skolni-mikropocitace-rady-didaktik/</a>
</li>

<li>Z80 Assembler for Dummies<br />
<a href="https://www.msx.org/wiki/Z80_Assembler_for_Dummies">https://www.msx.org/wiki/Z80_Assembler_for_Dummies</a>
</li>

<li>Z80 Resources<br />
<a href="https://www.assemblytutorial.com/z80/">https://www.assemblytutorial.com/z80/</a>
</li>

<li>How do Z80 Block Transfer instructions work?<br />
<a href="https://retrocomputing.stackexchange.com/questions/5416/how-do-z80-block-transfer-instructions-work">https://retrocomputing.stackexchange.com/questions/5416/how-do-z80-block-transfer-instructions-work</a>
</li>

<li>How fast is memcpy on the Z80?<br />
<a href="https://retrocomputing.stackexchange.com/questions/4744/how-fast-is-memcpy-on-the-z80">https://retrocomputing.stackexchange.com/questions/4744/how-fast-is-memcpy-on-the-z80</a>
</li>

<li>Comparing Datapoint 2200, 8008, 8080 and Z80 Instruction Sets<br />
<a href="https://bread80.com/comparing-datapoint-2200-8008-8080-and-z80-instruction-sets/">https://bread80.com/comparing-datapoint-2200-8008-8080-and-z80-instruction-sets/</a>
</li>

<li>8080/Z80 Instruction Set<br />
<a href="https://retroprogramming.it/2021/02/8080-z80-instruction-set/">https://retroprogramming.it/2021/02/8080-z80-instruction-set/</a>
</li>

<li>Zilog Z80A Technical Information<br />
<a href="https://worldofspectrum.org/faq/reference/z80reference.htm">https://worldofspectrum.org/faq/reference/z80reference.htm</a>
</li>

<li>Z80 programming techniques - Loops<br />
<a href="http://map.grauw.nl/articles/fast_loops.php">http://map.grauw.nl/articles/fast_loops.php</a>
</li>

<li>PRINT in Assembly Language<br />
<a href="http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/assembly-language/z80-tutorials/print-in-assembly-language">http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/assembly-language/z80-tutorials/print-in-assembly-language</a>
</li>

<li>Spectrum ROM Routines<br />
<a href="https://skoolkid.github.io/rom/maps/routines.html">https://skoolkid.github.io/rom/maps/routines.html</a>
</li>

<li>Spectrum ROM Routines<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/routines.html">https://skoolkit.ca/disassemblies/rom/maps/routines.html</a>
</li>

<li>Channels and streams<br />
<a href="https://sinclair.wiki.zxnet.co.uk/wiki/Channels_and_streams">https://sinclair.wiki.zxnet.co.uk/wiki/Channels_and_streams</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

