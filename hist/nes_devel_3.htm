<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Základy tvorby her pro herní konzoli NES: triky nabízené assemblerem, tvorba zvuků a grafiky</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Základy tvorby her pro herní konzoli NES: triky nabízené assemblerem, tvorba zvuků a grafiky</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetí části miniseriálu o tvorbě her a grafických či zvukových dem pro osmibitovou herní konzoli NES se nejprve seznámíme s některými triky nabízenými assemblerem ca65 a posléze si ukážeme tvorbu zvuků. Taktéž si (prozatím bez příkladu) řekneme, jak se na NESu pracuje s grafikou.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Kostra programu, kterou budeme v&nbsp;dalších kapitolách rozšiřovat</a></p>
<p><a href="#k02">2. Standardní nastavení segmentů definované v&nbsp;souborech ca65 (cc65)</a></p>
<p><a href="#k03">3. Zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k04">4. Definice symbolů pro pojmenování řídicích registrů PPU i APU</a></p>
<p><a href="#k05">5. Zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k06">6. Podpora lokálních automaticky generovaných návěští v&nbsp;ca65</a></p>
<p><a href="#k07">7. Zdrojový kód čtvrtého demonstračního příkladu</a></p>
<p><a href="#k08">8. Vygenerování jednoduchého zvuku &ndash; základní možnosti APU</a></p>
<p><a href="#k09">9. Zdrojový kód pátého demonstračního příkladu</a></p>
<p><a href="#k10">10. Makroassemblery</a></p>
<p><a href="#k11">11. Makra bez parametrů v&nbsp;<strong>ca65</strong></a></p>
<p><a href="#k12">12. Praktické použití maker bez parametrů</a></p>
<p><a href="#k13">13. Zobrazení kódu generovaného <strong>ca65</strong> společně s&nbsp;původním zdrojovým kódem</a></p>
<p><a href="#k14">14. Zdrojový kód šestého demonstračního příkladu</a></p>
<p><a href="#k15">15. Grafický subsystém NESu</a></p>
<p><a href="#k16">16. Datové struktury použité pro vytvoření pozadí</a></p>
<p><a href="#k17">17. Sprity</a></p>
<p><a href="#k18">18. Editory grafických objektů NESu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Kostra programu, kterou budeme v&nbsp;dalších kapitolách rozšiřovat</h2>

<p>V&nbsp;navazujících kapitolách se budeme odkazovat na následující kostru
programu, který provede inicializaci herní konzole NES (tedy inicializaci CPU,
PPU i APU &ndash; mikroprocesoru, grafického řadiče a zvukového čipu). Tento
příklad postupně upravíme do čitelnější a lépe pochopitelně a měnitelné
podoby:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Neoptimalizovaná kostra programu pro herní konzoli NES</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 1
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "INES"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
.code
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
.proc nmi
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
.proc irq
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
.proc reset
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx $2000               <i>; nastavení PPUCTRL = 0</i>
        stx $2001               <i>; nastavení PPUMASK = 0</i>
        stx $4015               <i>; nastavení APUSTATUS = 0</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
wait1:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait1               <i>; skok, pokud je příznak N nulový</i>
wait2:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait2               <i>; skok, pokud je příznak N nulový</i>
&nbsp;
        <i>; vymazání obsahu RAM</i>
        lda #$00                <i>; vynulování registru A</i>
loop:   sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne loop                <i>; po přetečení 0xff -&gt; 0x00 konec smyčky</i>
&nbsp;
        <i>; čekání na dokončení dalšího snímku, potom může začít herní smyčka</i>
wait3:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait3               <i>; skok, pokud je příznak N nulový</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTOR"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Standardní nastavení segmentů definované v&nbsp;souborech ca65 (cc65)</h2>

<p>Při instalaci <strong>cc65</strong> a <strong>ca65</strong> se
mj.&nbsp;nainstalovaly i konfigurační soubory pro linker <strong>cl65</strong>,
a to pro každou podporovanou platformu jeden unikátní soubor (protože každý
počítač či herní konzole založená na MOS 6502 má zcela odlišnou strukturu/mapu
paměti). Konkrétně pro osmibitovou herní konzoli NES se jedná o tento
soubor:</p>

<pre>
/usr/share/cc65/cfg/nes.cfg
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně na Windows/Mac bude
umístění odlišné a autorovi textu neznámé :-)</div></p>

<p>Obsah tohoto souboru vypadá na mém systému následovně:</p>

<pre>
SYMBOLS {
    __STACKSIZE__: type = weak, value = $0300; # 3 pages stack
}
MEMORY {
    ZP:     file = "", start = $0002, size = $001A, type = rw, define = yes;
&nbsp;
    # INES Cartridge Header
    HEADER: file = %O, start = $0000, size = $0010, fill = yes;
&nbsp;
    # 2 16K ROM Banks
    # - startup
    # - code
    # - rodata
    # - data (load)
    ROM0:   file = %O, start = $8000, size = $7FFA, fill = yes, define = yes;
&nbsp;
    # Hardware Vectors at End of 2nd 8K ROM
    ROMV:   file = %O, start = $FFFA, size = $0006, fill = yes;
&nbsp;
    # 1 8k CHR Bank
    ROM2:   file = %O, start = $0000, size = $2000, fill = yes;
&nbsp;
    # standard 2k SRAM (-zeropage)
    # $0100-$0200 cpu stack
    # $0200-$0500 3 pages for ppu memory write buffer
    # $0500-$0800 3 pages for cc65 parameter stack
    SRAM:   file = "", start = $0500, size = __STACKSIZE__, define = yes;
&nbsp;
    # additional 8K SRAM Bank
    # - data (run)
    # - bss
    # - heap
    RAM:    file = "", start = $6000, size = $2000, define = yes;
}
SEGMENTS {
    ZEROPAGE: load = ZP,              type = zp;
    HEADER:   load = HEADER,          type = ro;
    STARTUP:  load = ROM0,            type = ro,  define   = yes;
    LOWCODE:  load = ROM0,            type = ro,  optional = yes;
    ONCE:     load = ROM0,            type = ro,  optional = yes;
    CODE:     load = ROM0,            type = ro,  define   = yes;
    RODATA:   load = ROM0,            type = ro,  define   = yes;
    DATA:     load = ROM0, run = RAM, type = rw,  define   = yes;
    VECTORS:  load = ROMV,            type = rw;
    CHARS:    load = ROM2,            type = rw;
    BSS:      load = RAM,             type = bss, define   = yes;
}
FEATURES {
    CONDES: type    = constructor,
            label   = __CONSTRUCTOR_TABLE__,
            count   = __CONSTRUCTOR_COUNT__,
            segment = ONCE;
    CONDES: type    = destructor,
            label   = __DESTRUCTOR_TABLE__,
            count   = __DESTRUCTOR_COUNT__,
            segment = RODATA;
    CONDES: type    = interruptor,
            label   = __INTERRUPTOR_TABLE__,
            count   = __INTERRUPTOR_COUNT__,
            segment = RODATA,
            import  = __CALLIRQ__;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že některé segmenty jsou
pojmenovány mírně odlišně, ovšem ty hlavní &ndash; <strong>HEADER</strong>,
<strong>ZEROPAGE</strong>, <strong>VECTORS</strong> a <strong>CODE</strong>
můžeme ihned použít ve zdrojových kódech psaných v&nbsp;assembleru:</div></p>

<pre>
--- example01.asm       2022-06-12 16:36:17.851609148 +0200
+++ example02.asm       2022-06-12 16:36:25.591641357 +0200
@@ -1,5 +1,6 @@
 ; ---------------------------------------------------------------------
 ; Neoptimalizovaná kostra programu pro herní konzoli NES
+; Použití standardního nastavení segmentů podle ca65 (cc65)
 ;
 ; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01
 ; Viz též článek na https://www.moria.us/blog/2018/03/nes-development
@@ -33,8 +34,8 @@
 ; Blok paměti s definicí dlaždic 8x8 pixelů
 ; ---------------------------------------------------------------------
&nbsp;
-.segment "CHR0a"
-.segment "CHR0b"
+.segment "CHARS"
+
&nbsp;
&nbsp;
 .code
@@ -118,6 +119,8 @@
&nbsp;
&nbsp;
&nbsp;
+.segment "STARTUP"
+
 ; ---------------------------------------------------------------------
 ; Finito
 ; ---------------------------------------------------------------------
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o výstup příkazu <strong>diff
-u</strong>, tedy &bdquo;unifikovaný diff&ldquo;.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zdrojový kód druhého demonstračního příkladu</h2>

<p>Zdrojový kód dnešního druhého demonstračního příkladu popsaného <a
href="#k02">v&nbsp;předchozí kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm</a>
(pro překlad a slinkování tohoto demonstračního příkladu použijte <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">tento
Makefile</a>):</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Neoptimalizovaná kostra programu pro herní konzoli NES</i>
<i>; Použití standardního nastavení segmentů podle ca65 (cc65)</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 1
&nbsp; 
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp; 
<i>; INES mapper number.</i>
mapper = 0
&nbsp; 
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp; 
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.segment "CHARS"
&nbsp; 
&nbsp; 
&nbsp; 
.code
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp; 
.proc nmi
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp; 
.proc irq
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro RESET</i>
&nbsp; 
.proc reset
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp; 
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
&nbsp; 
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx $2000               <i>; nastavení PPUCTRL = 0</i>
        stx $2001               <i>; nastavení PPUMASK = 0</i>
        stx $4015               <i>; nastavení APUSTATUS = 0</i>
&nbsp; 
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
wait1:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait1               <i>; skok, pokud je příznak N nulový</i>
wait2:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait2               <i>; skok, pokud je příznak N nulový</i>
&nbsp; 
        <i>; vymazání obsahu RAM</i>
        lda #$00                <i>; vynulování registru A</i>
loop:   sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne loop                <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
&nbsp; 
        <i>; čekání na dokončení dalšího snímku, potom může začít herní smyčka</i>
wait3:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait3               <i>; skok, pokud je příznak N nulový</i>
&nbsp; 
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp; 
&nbsp; 
&nbsp; 
.segment "STARTUP"
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Definice symbolů pro pojmenování řídicích registrů PPU i APU</h2>

<p>Pokud se podíváme na následující úryvek zdrojového kódu s&nbsp;vymazanými
poznámkami, můžeme vidět, že se nejedná o příliš čitelný kód, protože se
v&nbsp;něm objevují přímo adresy řídicích registrů a nikoli jejich jména:</p>

<pre>
        ldx #$00
        stx $2000
        stx $2001
        stx $4015
&nbsp;
wait1:  bit $2002
        bpl wait1
</pre>

<p><div class="rs-tip-major">Poznámka: tento kód není nečitelný kvůli použití
assembleru, ale právě numerických adres.</div></p>

<p>Assembler však umožňuje (stejně jako jakýkoli vyšší programovací jazyk)
použít symbolická jména pro jakékoli hodnoty. Definice takových symbolických
jmen je v&nbsp;assembleru triviální:</p>

<pre>
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
&nbsp;
<i>; Řídicí registry APU</i>
APUSTATUS       = $4015
</pre>

<p>Předchozí kód se díky symbolickým jménům konstant stane mnohem čitelnější, a
to i bez použití poznámek:</p>

<pre>
        ldx #$00
        stx PPUCTRL
        stx PPUMASK
        stx APUSTATUS
&nbsp; 
wait1:  bit PPUSTATUS
        bpl wait1
</pre>

<p>Symbolická jména nyní použijeme v&nbsp;celém zdrojovém kódu.
V&nbsp;následujícím výpisu jsou zvýrazněny rozdíly mezi oběma verzemi &ndash;
kupodivu těchto změn není příliš mnoho:</p>

<pre>
--- example01.asm       2022-06-12 16:36:17.851609148 +0200
+++ example03.asm       2022-06-12 16:36:32.259669073 +0200
@@ -1,10 +1,20 @@
 ; ---------------------------------------------------------------------
-; Neoptimalizovaná kostra programu pro herní konzoli NES
+; Upravená kostra programu pro herní konzoli NES
+; Pojmenování všech řídicích registrů
 ;
 ; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01
 ; Viz též článek na https://www.moria.us/blog/2018/03/nes-development
 ; ---------------------------------------------------------------------
&nbsp;
+; Jména řídicích registrů použitých v kódu
+PPUCTRL         = $2000
+PPUMASK         = $2001
+PPUSTATUS       = $2002
+
+;;; Other IO registers.
+APUSTATUS       = $4015
+
+
 ; ---------------------------------------------------------------------
 ; Definice hlavičky obrazu ROM
 ; ---------------------------------------------------------------------
@@ -37,6 +47,7 @@
 .segment "CHR0b"
&nbsp;
&nbsp; 
+
 .code
&nbsp;
 ; ---------------------------------------------------------------------
@@ -73,14 +84,14 @@
&nbsp;
         <i>; nastavení řídicích registrů</i>
         ldx #$00
-        stx $2000               <i>; nastavení PPUCTRL = 0</i>
-        stx $2001               <i>; nastavení PPUMASK = 0</i>
-        stx $4015               <i>; nastavení APUSTATUS = 0</i>
+        stx PPUCTRL             <i>; nastavení PPUCTRL = 0</i>
+        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
+        stx APUSTATUS           <i>; nastavení APUSTATUS = 0</i>
&nbsp;
         <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
-wait1:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
+wait1:  bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
         bpl wait1               <i>; skok, pokud je příznak N nulový</i>
-wait2:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
+wait2:  bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
         bpl wait2               <i>; skok, pokud je příznak N nulový</i>
&nbsp;
         <i>; vymazání obsahu RAM</i>
@@ -97,7 +108,7 @@
         bne loop                <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
&nbsp;
         <i>; čekání na dokončení dalšího snímku, potom může začít herní smyčka</i>
-wait3:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
+wait3:  bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
         bpl wait3               <i>; skok, pokud je příznak N nulový</i>
&nbsp; 
         <i>; vlastní herní smyčka je prozatím prázdná</i>
</pre>

<p><div class="rs-tip-major">Poznámka: opět se jedná o výstup příkazu
<strong>diff -u</strong>, tedy &bdquo;unifikovaný diff&ldquo;.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zdrojový kód třetího demonstračního příkladu</h2>

<p>Zdrojový kód dnešního třetího demonstračního příkladu popsaného <a
href="#k04">v&nbsp;předchozí kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm</a>
(pro překlad a slinkování tohoto demonstračního příkladu použijte <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">tento
Makefile</a>):</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Upravená kostra programu pro herní konzoli NES</i>
<i>; Pojmenování všech řídicích registrů</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
&nbsp; 
<i>;;; Other IO registers.</i>
APUSTATUS       = $4015
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 1
&nbsp; 
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp; 
<i>; INES mapper number.</i>
mapper = 0
&nbsp; 
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp; 
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.segment "CHR0a"
.segment "CHR0b"
&nbsp; 
&nbsp; 
&nbsp; 
.code
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp; 
.proc nmi
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp; 
.proc irq
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro RESET</i>
&nbsp; 
.proc reset
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp; 
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
&nbsp; 
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx APUSTATUS           <i>; nastavení APUSTATUS = 0</i>
&nbsp; 
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
wait1:  bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
        bpl wait1               <i>; skok, pokud je příznak N nulový</i>
wait2:  bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
        bpl wait2               <i>; skok, pokud je příznak N nulový</i>
&nbsp; 
        <i>; vymazání obsahu RAM</i>
        lda #$00                <i>; vynulování registru A</i>
loop:   sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne loop                <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
&nbsp; 
        <i>; čekání na dokončení dalšího snímku, potom může začít herní smyčka</i>
wait3:  bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
        bpl wait3               <i>; skok, pokud je příznak N nulový</i>
&nbsp; 
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Podpora lokálních automaticky generovaných návěští v&nbsp;ca65</h2>

<p>Další velmi užitečnou (jak uvidíme dále) vlastností assembleru
<strong>ca65</strong> je podpora lokálních návěští, které jsou automaticky
generovány. Co to vlastně znamená? Podívejme se na následující kód získaný
z&nbsp;našeho demonstračního příkladu. Tento kód obsahuje trojici prakticky
stejných smyček, ovšem pro každou smyčku musíme vygenerovat unikátní návěští
&ndash; cíl skoku:</p>

<pre>
wait1:  bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
        bpl wait1               <i>; skok, pokud je příznak N nulový</i>
wait2:  bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
        bpl wait2               <i>; skok, pokud je příznak N nulový</i>
&nbsp;
        ...
        ...
        ...
&nbsp;
        <i>; čekání na dokončení dalšího snímku, potom může začít herní smyčka</i>
wait3:  bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
        bpl wait3               <i>; skok, pokud je příznak N nulový</i>
</pre>

<p>Takto strukturovaný kód se nejenom těžko udržuje, ale navíc je nutné si
pořád vymýšlet nová a nová unikátní jména návěští. Vzhledem k&nbsp;tomu, že se
v&nbsp;tomto případě jedná o lokální návěští (tedy ne například o adresy
procedur), můžeme využít malého triku:</p>

<pre>
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
</pre>

<p>Zde můžeme vidět, že návěští nemá jméno (druhý řádek) a že je referencováno
pomocí zápisu &bdquo;:-&ldquo;. Ten v&nbsp;assembleru <strong>ca65</strong>
znamená &bdquo;první lokální návěští, které nalezneš průchodem kódem směrem
nahoru&ldquo;. Pokud by se například použila dvojice vnořených smyček, vypadal
by skok na konci vnější smyčky &bdquo;:--&ldquo;, což znamená &bdquo;druhé
lokální návěští, které nalezneš průchodem kódem směrem nahoru&ldquo;</p>

<p><div class="rs-tip-major">Poznámka: navíc je možné použít i pojmenované
&bdquo;cheap local labels&ldquo;, které použijeme příště.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zdrojový kód čtvrtého demonstračního příkladu</h2>

<p>Zdrojový kód dnešního čtvrtého demonstračního příkladu popsaného <a
href="#k06">v&nbsp;předchozí kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm</a>
(pro překlad a slinkování tohoto demonstračního příkladu použijte <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">tento
Makefile</a>):</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Upravená kostra programu pro herní konzoli NES</i>
<i>; Lokální automaticky generovaná návěští</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
&nbsp; 
<i>;;; Other IO registers.</i>
APUSTATUS       = $4015
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 1
&nbsp; 
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp; 
<i>; INES mapper number.</i>
mapper = 0
&nbsp; 
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp; 
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.segment "CHR0a"
.segment "CHR0b"
&nbsp; 
&nbsp; 
.code
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp; 
.proc nmi
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp; 
.proc irq
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro RESET</i>
&nbsp; 
.proc reset
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp; 
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
&nbsp; 
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx APUSTATUS           <i>; nastavení APUSTATUS = 0</i>
&nbsp; 
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
&nbsp; 
        <i>; vymazání obsahu RAM</i>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
&nbsp; 
        <i>; čekání na dokončení dalšího snímku, potom může začít herní smyčka</i>
:       bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                  <i>; skok, pokud je příznak N nulový</i>
&nbsp; 
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vygenerování jednoduchého zvuku &ndash; základní možnosti APU</h2>

<p>Nyní se konečně začneme zabývat praktičtějšími problémy. Nejdříve si
ukážeme, jak lze vygenerovat jednoduchý zvuk. Použijeme přitom pochopitelně
modul APU jenž je ovládán s&nbsp;využitím řídicích registrů, které jsme si ve
stručnosti popsali <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-vyvoj-her-a-demo-programu-pro-herni-konzoli-nes/#k10">již
v&nbsp;prvním článku</a>. Prozatím si vystačíme s&nbsp;prvním kanálem &ndash;
generátorem obdélníkového signálu. Budou nám tedy postačovat čtyři řídicí
registry:</p>

<pre>
<i>; vybrané řídicí registry APU</i>
APUSTATUS       = $4015
SQ1_VOL         = $4000
SQ1_LO          = $4002
SQ1_HI          = $4003
</pre>

<p>První zvukový kanál povolíme nastavením nejnižšího bitu registru
<strong>APUSTATUS</strong>, tedy následovně:</p>

<pre>
lda #$01                <i>; povolení zvukového kanálu square1</i>
sta APUSTATUS
</pre>

<p>Následně nastavíme periodu signálu. Jedná se o jedenáctibitovou hodnotu
uloženou v&nbsp;registru <strong>SQ1_LO</strong> a ve spodních třech bitech
registru <strong>SQ1_HI</strong>:</p>

<pre>
lda #$08                <i>; perioda signálu</i>
sta SQ1_LO
lda #$02
sta SQ1_HI
</pre>

<p>Uložená hodnota je tedy rovna 2&times;256+8=520. Frekvence zvuku se vypočte
jako:</p>

<pre>
f = 1789773 / (16 * (520 + 1))
</pre>

<p>což zhruba odpovídá 215 Hz (blízko noty E3).</p>

<p>To ovšem není vše, protože musíme nastavit i registr
<strong>SQ1_VOL</strong>. Samotná hlasitost je uložena ve spodních čtyřech
bitech. První dva bity nastavují střídu (<i>duty cycle</i>), další bit zakáže
automatické ukončení zvuku po určité době (řízeno čítačem) a pátý bit zleva pak
zakáže automatické snižování hlasitosti zvuku (<i>decay</i>):</p>

<table>
<tr><th>Bity</th><th>Stručný popis</th></tr>
<tr><td>7-6</td><td>střída (<i>duty cycle</i>)</td></tr>
<tr><td>5</td><td>vypnutí automatického ukončení zvuku (<i>length counter</i>)</td></tr>
<tr><td>4</td><td>vypnutí snižování hlasitosti zvuku (<i>decay</i>)</td></tr>
<tr><td>0-3</td><td>hlasitost</td></tr>
</table>

<p>V&nbsp;našem konkrétním případě:</p>

<pre>
lda #%00111111          <i>; příznaky + hlasitost signálu</i>
sta SQ1_VOL
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že assembler
<strong>ca65</strong> podporuje zápis konstant v&nbsp;dvojkovém kódu.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojový kód pátého demonstračního příkladu</h2>

<p>Zdrojový kód dnešního pátého demonstračního příkladu popsaného <a
href="#k08">v&nbsp;předchozí kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm</a>
(pro překlad a slinkování tohoto demonstračního příkladu použijte <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">tento
Makefile</a>):</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Zvukový výstup z generátoru obdélníkových signálů</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
&nbsp; 
<i>; vybrané řídicí registry APU</i>
APUSTATUS       = $4015
SQ1_VOL         = $4000
SQ1_LO          = $4002
SQ1_HI          = $4003
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 1
&nbsp; 
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp; 
<i>; INES mapper number.</i>
mapper = 0
&nbsp; 
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp; 
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.segment "CHR0a"
.segment "CHR0b"
&nbsp; 
&nbsp; 
.code
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp; 
.proc nmi
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp; 
.proc irq
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro RESET</i>
&nbsp; 
.proc reset
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp; 
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
&nbsp; 
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx APUSTATUS           <i>; nastavení APUSTATUS = 0</i>
&nbsp; 
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
&nbsp; 
        <i>; vymazání obsahu RAM</i>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
&nbsp; 
        <i>; čekání na dokončení dalšího snímku, potom může začít herní smyčka</i>
:       bit PPUSTATUS           <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                  <i>; skok, pokud je příznak N nulový</i>
&nbsp; 
        <i>; zvukový výstup</i>
        lda #$01                <i>; povolení zvukového kanálu square1</i>
        sta APUSTATUS
        lda #$08                <i>; perioda signálu</i>
        sta SQ1_LO
        lda #$02
        sta SQ1_HI
        lda #%00111111          <i>; příznaky + hlasitost signálu</i>
        sta SQ1_VOL
&nbsp; 
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Makroassemblery</h2>

<p>Nástroje typu &bdquo;assembler&ldquo; (mezi něž patří i
<strong>ca65</strong>) je možné podle principu jejich práce rozdělit do
několika kategorií. Do první kategorie spadají assemblery interaktivní, které
uživateli nabízejí poměrně komfortní vývojové prostředí, v&nbsp;němž je
v&nbsp;případě potřeby možné zapisovat jednotlivé instrukce, spouštět programy,
krokovat je, vypisovat obsahy pracovních registrů mikroprocesoru, prohlížet si
obsah operační paměti, zásobníku atd. Výhodou byla nezávislost těchto
assemblerů na rychlém externím paměťovém médiu, proto jsme se s&nbsp;nimi mohli
setkat například na osmibitových domácích mikropočítačích či dnes na různých
zařízeních typu IoT (i když zde úlohu pouhého interaktivního assembleru mnohdy
přebírá interaktivní debugger). Ovšem pro NES nejsou vyvíjeny. Druhý typ
assemblerů je široce používán dodnes &ndash; jedná se vlastně o běžné
překladače, kterým se na vstupu předloží zdrojový kód a po překladu se výsledný
nativní kód taktéž uloží na paměťové médium (odkud ho lze přímo spustit, což se
dělo například v&nbsp;operačním systému DOS, popř.&nbsp;ho ještě před spuštěním
slinkovat, což je případ Linuxu a dalších moderních operačních systémů, ovšem i
NESu).</p>

<p>Assemblery spadající do druhé kategorie jsou mnohdy vybaveny více či méně
dokonalým systémem <i>maker</i>; odtud ostatně pochází i jejich často používané
označení <i>macroassembler</i>. Makra, která se většinou aplikují na zdrojový
kód v&nbsp;první fázi překladu, je možné použít pro různé činnosti, ať již se
jedná o zjednodušení zápisu kódu či o jeho zkrácení a zpřehlednění. Existují
například sady poměrně složitých maker, které do assembleru přidávají některé
konstrukce známé z&nbsp;vyšších programovacích jazyků &ndash; rozvětvení,
programové smyčky, deklaraci objektů atd. Všechny moderní assemblery práci
s&nbsp;makry podporují, i když se způsob zápisu maker i jejich základní
vlastnosti od sebe odlišují. Z&nbsp;tohoto důvodu se v&nbsp;dnešním článku
budeme věnovat (prozatím) pouze makrům v&nbsp;<strong>ca65</strong>.</p>

<p><div class="rs-tip-major">Poznámka: i přes podporu maker je
<strong>ca65</strong> jednoprůchodovým assemblerem.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Makra bez parametrů v&nbsp;<strong>ca65</strong></h2>

<p>Makra v&nbsp;assembleru, tedy i v&nbsp;<strong>ca65</strong>, provádí
textové substituce, což mj.&nbsp;znamená, že expanze maker je vykonána
v&nbsp;první fázi překladu. V&nbsp; <strong>ca65</strong> deklarace makra
začíná direktivou <strong>.macro</strong> a končí direktivou
<strong>.endmacro</strong> (obě direktivy se zapisují včetně teček na začátku).
Za direktivou <strong>.macro</strong> musí následovat jméno makra a popř. i
jeho parametry. Na dalších řádcích je pak vlastní text makra:</p>

<pre>
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
</pre>

<p>Použití makra je ještě jednodušší než jeho deklarace &ndash; kdekoli se
prostě uvede jméno makra s&nbsp;případnými parametry. Jakmile assembler zjistí,
že se ve zdrojovém kódu nachází jméno makra, provede jeho expanzi, takže se
vlastně případné instrukce, ze kterých se text makra skládá, přímo vloží do
kódu na místo volání makra:</p>

<pre>
.proc reset
        <i>; nastavení stavu CPU</i>
        <strong>setup_cpu</strong>
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: existují i standardní makra, které
z&nbsp;pohledu programátora rozšiřují instrukční soubor mikroprocesoru 6502
(interně se však makro expanduje obecně na větší množství instrukcí):</div></p>

<pre>
<i>; add - Add without carry</i>
.macro  add     Arg1, Arg2
        clc
        .if .paramcount = 2
                adc     Arg1, Arg2
        .else
                adc     Arg1
        .endif
.endmacro
&nbsp;
<i>; sub - subtract without borrow</i>
.macro  sub     Arg1, Arg2
        sec
        .if .paramcount = 2
                sbc     Arg1, Arg2
        .else
                sbc     Arg1
        .endif
.endmacro
&nbsp;
<i>; bgt - jump if unsigned greater</i>
.macro  bgt     Arg
        .local  L
        beq     L
        bcs     Arg
L:
.endmacro
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Praktické použití maker bez parametrů</h2>

<p>Podívejme se nyní na praktické použití maker podporovaných assemblerem
<strong>ca65</strong> při zjednodušení předchozího demonstračního příkladu.
Velmi jednoduché bude makro zajišťující inicializaci CPU po resetu:</p>

<pre>
.macro <strong>setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp; 
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
.endmacro
</pre>

<p>Poněkud složitější bude makro pro čekání na zobrazení snímku, a to
z&nbsp;toho důvodu, že obsahuje skok, resp.&nbsp;programovou smyčku. Právě
v&nbsp;tomto případě využijeme anonymní návěští, které zajistí, že nedojde
k&nbsp;pokusu o znovupoužití pojmenovaného návěští:</p>

<pre>
.macro <strong>wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
.endmacro
</pre>

<p>Podobným způsobem lze realizovat makro pro vymazání operační paměti:</p>

<pre>
.macro <strong>clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
.endmacro
</pre>

<p>Makra se použijí následovně:</p>

<pre>
<i>; Obslužná rutina pro RESET</i>
&nbsp; 
.proc reset
        <i>; nastavení stavu CPU</i>
        <strong>setup_cpu</strong>
&nbsp; 
        ...
        ...
        ...
&nbsp; 
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        <strong>wait_for_frame</strong>
        <strong>wait_for_frame</strong>
&nbsp; 
        <i>; vymazání obsahu RAM</i>
        <strong>clear_ram</strong>
&nbsp; 
        <i>; čekání na další snímek</i>
        <strong>wait_for_frame</strong>
&nbsp; 
        ...
        ...
        ...
&nbsp; 
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zobrazení kódu generovaného <strong>ca65</strong> společně s&nbsp;původním zdrojovým kódem</h2>

<p>Assembler <strong>ca65</strong> umožňuje (samozřejmě kromě vlastního
překladu) vytvoření souboru obsahujícího mix mezi původním zdrojovým kódem a
vygenerovanou sekvencí bajtů (tedy jak dat, tak i operačních kódů instrukcí).
Pro tento účel se používá přepínač <strong>-l</strong>, který je ovšem vhodné
doplnit přepínačem <strong>--list-bytes <i>větší_hodnota</i></strong>, aby se
kromě jména makra vypsaly i všechny operační kódy instrukcí (což v&nbsp;našem
případě platí zejména po delší makro pro smazání operační paměti):</p>

<pre>
$ <strong>ca65 example06.asm -o example06.o -l test.list --list-bytes 100</strong>
</pre>

<p>Výsledkem této operace bude mj.&nbsp;i soubor &bdquo;test.list&ldquo;
s&nbsp;následujícím obsahem:</p>

<pre>
ca65 V2.18 - Ubuntu 2.18-1
Main file   : example06.asm
Current file: example06.asm
&nbsp;
000000r 1               ; ---------------------------------------------------------------------
000000r 1               ; Kostra programu pro herní konzoli NES
000000r 1               ; Zvukový výstup z generátoru obdélníkových signálů
000000r 1               ;
000000r 1               ; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01
000000r 1               ; Viz též článek na https://www.moria.us/blog/2018/03/nes-development
000000r 1               ; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt
000000r 1               ; ---------------------------------------------------------------------
000000r 1               
000000r 1               ; Jména řídicích registrů použitých v kódu
000000r 1               PPUCTRL         = $2000
000000r 1               PPUMASK         = $2001
000000r 1               PPUSTATUS       = $2002
000000r 1               
000000r 1               ; vybrané řídicí registry APU
000000r 1               APUSTATUS       = $4015
000000r 1               SQ1_VOL         = $4000
000000r 1               SQ1_LO          = $4002
000000r 1               SQ1_HI          = $4003
000000r 1               
000000r 1               
000000r 1               ; ---------------------------------------------------------------------
000000r 1               ; Definice maker
000000r 1               ; ---------------------------------------------------------------------
000000r 1               
000000r 1               .macro setup_cpu
000000r 1                       ; nastavení stavu CPU
000000r 1                       sei                     ; zákaz přerušení
000000r 1                       cld                     ; vypnutí dekadického režimu (není podporován)
000000r 1               
000000r 1                       ldx #$ff
000000r 1                       txs                     ; vrchol zásobníku nastaven na 0xff (první stránka)
000000r 1               .endmacro
000000r 1               
000000r 1               .macro wait_for_frame
000000r 1               :       bit PPUSTATUS            ; test obsahu registru PPUSTATUS
000000r 1                       bpl :-                   ; skok, pokud je příznak N nulový
000000r 1               .endmacro
000000r 1               
000000r 1               .macro clear_ram
000000r 1                       lda #$00                ; vynulování registru A
000000r 1               :       sta $000, x             ; vynulování X-tého bajtu v nulté stránce
000000r 1                       sta $100, x
000000r 1                       sta $200, x
000000r 1                       sta $300, x
000000r 1                       sta $400, x
000000r 1                       sta $500, x
000000r 1                       sta $600, x
000000r 1                       sta $700, x             ; vynulování X-tého bajtu v sedmé stránce
000000r 1                       inx                     ; přechod na další bajt
000000r 1                       bne :-                  ; po přetečení 0xff -&gt; 0x00 konec smyčky
000000r 1               .endmacro
000000r 1               
000000r 1               
000000r 1               
000000r 1               ; ---------------------------------------------------------------------
000000r 1               ; Definice hlavičky obrazu ROM
000000r 1               ; ---------------------------------------------------------------------
000000r 1               
000000r 1               ; Size of PRG in units of 16 KiB.
000000r 1               prg_npage = 1
000000r 1               
000000r 1               ; Size of CHR in units of 8 KiB.
000000r 1               chr_npage = 1
000000r 1               
000000r 1               ; INES mapper number.
000000r 1               mapper = 0
000000r 1               
000000r 1               ; Mirroring (0 = horizontal, 1 = vertical)
000000r 1               mirroring = 1
000000r 1               
000000r 1               .segment "HEADER"
000000r 1  4E 45 53 1A          .byte $4e, $45, $53, $1a
000004r 1  01                   .byte prg_npage
000005r 1  01                   .byte chr_npage
000006r 1  01                   .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
000007r 1  00                   .byte mapper &amp; $f0
000008r 1               
000008r 1               
000008r 1               
000008r 1               ; ---------------------------------------------------------------------
000008r 1               ; Blok paměti s definicí dlaždic 8x8 pixelů
000008r 1               ; ---------------------------------------------------------------------
000008r 1               
000008r 1               .segment "CHR0a"
000000r 1               .segment "CHR0b"
000000r 1               
000000r 1               
000000r 1               .code
000000r 1               
000000r 1               ; ---------------------------------------------------------------------
000000r 1               ; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU
000000r 1               ;
000000r 1               ; viz též https://www.pagetable.com/?p=410
000000r 1               ; ---------------------------------------------------------------------
000000r 1               
000000r 1               ; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)
000000r 1               
000000r 1               .proc nmi
000000r 1  40                   rti                     ; návrat z přerušení
000001r 1               .endproc
000001r 1               
000001r 1               
000001r 1               
000001r 1               ; Obslužná rutina pro IRQ (maskovatelné přerušení)
000001r 1               
000001r 1               .proc irq
000001r 1  40                   rti                     ; návrat z přerušení
000002r 1               .endproc
000002r 1               
000002r 1               
000002r 1               
000002r 1               ; Obslužná rutina pro RESET
000002r 1               
000002r 1               .proc reset
000002r 1                       ; nastavení stavu CPU
000002r 1  78 D8 A2 FF          setup_cpu
000006r 1  9A           
000007r 1               
000007r 1                       ; nastavení řídicích registrů
000007r 1  A2 00                ldx #$00
000009r 1  8E 00 20             stx PPUCTRL             ; nastavení PPUCTRL = 0
00000Cr 1  8E 01 20             stx PPUMASK             ; nastavení PPUMASK = 0
00000Fr 1  8E 15 40             stx APUSTATUS           ; nastavení APUSTATUS = 0
000012r 1               
000012r 1                       ; čekání na vnitřní inicializaci PPU (dva snímky)
000012r 1  2C 02 20 10          wait_for_frame
000016r 1  FB           
000017r 1  2C 02 20 10          wait_for_frame
00001Br 1  FB           
00001Cr 1               
00001Cr 1                       ; vymazání obsahu RAM
00001Cr 1  A9 00 95 00          clear_ram
000020r 1  9D 00 01 9D  
000024r 1  00 02 9D 00  
000028r 1  03 9D 00 04  
00002Cr 1  9D 00 05 9D  
000030r 1  00 06 9D 00  
000034r 1  07 E8 D0 E6  
000038r 1               
000038r 1                       ; čekání na další snímek
000038r 1  2C 02 20 10          wait_for_frame
00003Cr 1  FB           
00003Dr 1               
00003Dr 1                       ; zvukový výstup
00003Dr 1  A9 01                lda #$01                ; povolení zvukového kanálu square1
00003Fr 1  8D 15 40             sta APUSTATUS
000042r 1  A9 08                lda #$08                ; perioda signálu
000044r 1  8D 02 40             sta SQ1_LO
000047r 1  A9 02                lda #$02
000049r 1  8D 03 40             sta SQ1_HI
00004Cr 1  A9 3F                lda #%00111111          ; příznaky + hlasitost signálu
00004Er 1  8D 00 40             sta SQ1_VOL
000051r 1               
000051r 1                       ; vlastní herní smyčka je prozatím prázdná
000051r 1               game_loop:
000051r 1  4C rr rr             jmp game_loop           ; nekonečná smyčka (později rozšíříme)
000054r 1               .endproc
000054r 1               
000054r 1               
000054r 1               
000054r 1               ; ---------------------------------------------------------------------
000054r 1               ; Tabulka vektorů CPU
000054r 1               ; ---------------------------------------------------------------------
000054r 1               
000054r 1               .segment "VECTORS"
000000r 1  rr rr        .addr nmi
000002r 1  rr rr        .addr reset
000004r 1  rr rr        .addr irq
000006r 1               
000006r 1               
000006r 1               
000006r 1               ; ---------------------------------------------------------------------
000006r 1               ; Finito
000006r 1               ; ---------------------------------------------------------------------
000006r 1               
</pre>

<p>Příklad zobrazení makra &ndash; ve druhém sloupci jsou zobrazeny operační
kódy instrukcí, ve třetím sloupci pak opis zdrojového kódu, tedy volání
makra:</p>

<pre>
000017r 1  2C 02 20 10          wait_for_frame
00001Br 1  FB           
</pre>

<p>Nejdelší je expanze makra <strong>clear_ram</strong>:</p>

<pre>
00001Cr 1  A9 00 95 00          clear_ram
000020r 1  9D 00 01 9D  
000024r 1  00 02 9D 00  
000028r 1  03 9D 00 04  
00002Cr 1  9D 00 05 9D  
000030r 1  00 06 9D 00  
000034r 1  07 E8 D0 E6  
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zdrojový kód šestého demonstračního příkladu</h2>

<p>Zdrojový kód dnešního šestého demonstračního příkladu popsaného <a
href="#k08">v&nbsp;předchozí kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm</a>
(pro překlad a slinkování tohoto demonstračního příkladu opět použijte <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">tento
Makefile</a>):</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Zvukový výstup z generátoru obdélníkových signálů</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
&nbsp; 
<i>; vybrané řídicí registry APU</i>
APUSTATUS       = $4015
SQ1_VOL         = $4000
SQ1_LO          = $4002
SQ1_HI          = $4003
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.macro <strong>setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp; 
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
.endmacro
&nbsp; 
.macro <strong>wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
.endmacro
&nbsp; 
.macro <strong>clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
.endmacro
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 1
&nbsp; 
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp; 
<i>; INES mapper number.</i>
mapper = 0
&nbsp; 
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp; 
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.segment "CHR0a"
.segment "CHR0b"
&nbsp; 
&nbsp; 
.code
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp; 
.proc nmi
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp; 
.proc irq
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; Obslužná rutina pro RESET</i>
&nbsp; 
.proc reset
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp; 
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx APUSTATUS           <i>; nastavení APUSTATUS = 0</i>
&nbsp; 
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp; 
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp; 
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp; 
        <i>; zvukový výstup</i>
        lda #$01                <i>; povolení zvukového kanálu square1</i>
        sta APUSTATUS
        lda #$08                <i>; perioda signálu</i>
        sta SQ1_LO
        lda #$02
        sta SQ1_HI
        lda #%00111111          <i>; příznaky + hlasitost signálu</i>
        sta SQ1_VOL
&nbsp; 
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp; 
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp; 
&nbsp; 
&nbsp; 
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Grafický subsystém NESu</h2>

<p>Grafický subsystém použitý v&nbsp;herní konzoli <i>Nintendo Entertainment
System</i> byl v&nbsp;mnoha ohledech ještě zajímavější než její zvukový
subsystém. Víme již, že herní konzole <i>NES</i> existovala ve variantě pro
televizní normu NTSC i pro normu PAL. Konzole určené pro televizní normu PAL
obsahovaly mikroprocesor <i>2A07</i> s&nbsp;hodinovou frekvencí 1,66 MHz,
zatímco pro normu NTSC byly určeny konzole s&nbsp;mikroprocesorem <i>2A03</i>
používající hodinovou frekvenci 1,79 MHz. I grafické čipy se lišily podle toho,
pro jakou televizní normu byly určeny. Pro normu NTSC se používal čip
<i>RP2C02</i> se vstupní hodinovou frekvencí 5,37 MHz, zatímco pro normu PAL
byl použit čip <i>RP2C07</i> s&nbsp;frekvencí 5,32 MHz. Tyto čipy, označované
taktéž zkratkou <i>PPU</i>, obsahovaly 256 interní paměti využívané systémem
pro zobrazení spritů. Kromě toho přistupoval <i>PPU</i> k&nbsp;samostatnému
čipu RAM o kapacitě dva kilobajty. V&nbsp;této paměti bylo uloženo větší
množství datových struktur nesoucích informace o pozadí scény, o barvové paletě
i o tvarech spritů. Ve skutečnosti však mohl <i>PPU</i> přistupovat i
k&nbsp;paměti ROM umístěné na paměťovém modulu se hrou.</p>

<img src="http://i.iinfo.cz/images/357/8417-1.png" width="256" height="76" alt="&#160;" />
<p><i>Obrázek 1: Barvová paleta používaná herní konzolí NES.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Datové struktury použité pro vytvoření pozadí</h2>

<p>U herní konzole <i>NES</i> se obraz posílaný na televizor skládal ze dvou
částí: pozadí a pohyblivých spritů. Nejprve si stručně popíšeme, jakým způsobem
se vytvářelo pozadí. Při použití televizní normy PAL bylo rozlišení obrazu
rovno 256&times;240 pixelům, zatímco u normy SECAM bylo horních osm řádků a
spodních osm řádků zatemněných, tj.&nbsp;rozlišení bylo sníženo na
256&times;224 pixelů. Teoreticky sice bylo možné vytvořit klasický framebuffer,
v&nbsp;němž by bylo celé pozadí uloženo, ale při šestnáctibarevném obrazu,
tj.&nbsp;při použití čtyř bitů na pixel, by musela být kapacita framebufferu
poměrně velká: 28 kilobajtů (navíc je 16 &bdquo;globálních&ldquo; barev
relativně malé množství). Konstruktéři čipu <i>PPU</i> tedy využili
technologii, s&nbsp;níž jsme se seznámili i u dalších typů herních konzolí:
namísto framebufferu byly v&nbsp;obrazové paměti uloženy vzorky o velikosti
8&times;8 pixelů, které byly skládány do mřížky 32&times;30 dlaždic, což přesně
odpovídá již zmíněnému rozlišení 256&times;240 pixelů (32&times;8=256,
30&times;8=240).</p>

<img src="http://i.iinfo.cz/images/194/8420-1.png" width="256" height="224" alt="&#160;" />
<p><i>Obrázek 2: Screenshot ze hry Kirby's Adventure.</i></p>

<p>Základní datovou strukturou byla struktura nazvaná <i>Name Table</i> o
velikosti 960 bajtů, která obsahovala indexy všech tvarů tvořících dlaždicovitý
obraz 32&times;30 dlaždic. Mohlo by se tedy zdát, že jedinou další potřebnou
strukturou je tabulka všech vzorků (bitmap), z&nbsp;nichž každá má velikost
8&times;8 pixelů. Situace je však poněkud složitější, protože na pozadí lze
vykreslit až šestnáct různých barev. V&nbsp;tabulce vzorků (<i>Pattern
Table</i>) jsou pro každý pixel vyhrazeny dva bity, tj.&nbsp;lze rozlišit čtyři
možnosti/barvy. Kromě toho existuje ještě tabulka atributů (<i>Attribute
Table</i>) o velikosti 64 bajtů, která obsahuje horní dva bity pro oblast o
velikosti 4&times;4 dlaždice, tj.&nbsp;32&times;32 pixelů. Díky existenci této
druhé tabulky je skutečně možné &ndash; i když s&nbsp;mnoha omezeními &ndash;
použít na pozadí šestnáct různých barev &ndash; a to při minimálních paměťových
nárocích. Důležité přitom je, že tabulka vzorků může být přemapována do ROM na
paměťovém modulu, takže je možné poměrně jednoduchým způsobem například
animovat celou scénu pouhou změnou &bdquo;ukazatele&ldquo; na tuto tabulku (což
mnohé hry skutečně dělaly).</p>

<img src="http://i.iinfo.cz/images/280/8421-1.png" width="256" height="224" alt="&#160;" />
<p><i>Obrázek 3: Další screenshot ze hry Kirby's Adventure.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Sprity</h2>

<p>Způsob vytváření pozadí, o němž jsme se zmínili <a
href="#k16">v&nbsp;předchozí kapitole</a>, je poměrně složitý (i když výhody
spočívající v&nbsp;relativně malém zatížení procesoru, většinou převažovaly).
Se sprity je však situace poněkud jednodušší. Základem při vykreslování spritů
je opět tabulka vzorků, ta je ovšem doplněna pomocnou pamětí o kapacitě 256
bajtů, která je umístěna přímo na čipu <i>PPU</i>. Programátor měl k&nbsp;této
paměti přístup buď přes řídicí registry <i>PPU</i>, alternativně pak přes DMA.
Ve zmíněných 256 bajtech jsou umístěny informace o 64 spritech, tj.&nbsp;pro
každý sprite jsou vyhrazeny čtyři bajty. V&nbsp;těchto bajtech se nachází
horizontální pozice spritu, vertikální pozice spritu, horní dva bity barvy
(spodní bity jsou přímo v&nbsp;tabulce vzorků), index do tabulky vzorků
(ukazuje na tvar spritu) a konečně taktéž bitové příznaky: horizontální
zrcadlení, vertikální zrcadlení a priorita spritu (před/za pozadím).</p>

<img src="http://i.iinfo.cz/images/282/8422-1.png" width="256" height="240" alt="&#160;" />
<p><i>Obrázek 4: Screenshot ze hry Donkey Kong.</i></p>

<p>Kvůli dalším technologickým omezením čipu <i>PPU</i> mohlo být na jednom
řádku (tj.&nbsp;vedle sebe) zobrazeno pouze omezené množství spritů,
tj.&nbsp;nebylo například možné všechny sprity umístit vedle sebe. Taktéž počet
celkově zobrazovaných barev nedosáhl hodnoty 32 (16 pro pozadí, 16 pro sprity),
ale pouze 25, přičemž barvová paleta obsahovala 48 barev a pět odstínů šedi
(konkrétní způsob zobrazení barev byl na obou televizních normách poněkud
odlišný).</p>

<p><div class="rs-tip-major">Poznámka: na originální konzoli lze zobrazit jen
osm spritů na obrazovém řádku, ovšem mnohé emulátory toto omezení
neobsahují.</div></p>

<img src="http://i.iinfo.cz/images/388/8423-1.png" width="256" height="240" alt="&#160;" />
<p><i>Obrázek 5: Další screenshot ze hry Donkey Kong.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Editory grafických objektů NESu</h2>

<p>V&nbsp;současnosti existuje několik editorů grafických objektů pro NES. Tyto
editory většinou dokážou provádět export dat přesně v&nbsp;takovém formátu, jak
jsou uloženy v&nbsp;reálném cartridge (ROM). Tato data dokáže
<strong>ca65</strong> (resp.&nbsp;přesněji řečeno <strong>cl65</strong>, tedy
linker) slinkovat se strojovým kódem do obrazu cartridge. Příště si ukážeme
práci s&nbsp;editorem nazvaným <i>Tilemolester</i>:</p>

<img src="https://i.iinfo.cz/images/130/nes-devel-3.png" class="image-576977" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" width="524" height="617" />
<p><i>Obrázek 6: Tilemolester &ndash; data pozadí (background).</i></p>

<img src="https://i.iinfo.cz/images/653/nes-devel-3-a.png" class="image-576979" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" width="524" height="617" />
<p><i>Obrázek 7: Tilemolester &ndash; data spritů.</i></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad pomocí assembleru <strong>ca65</strong> (jenž je součástí
<strong>cc65</strong>), byly uložen do Git repositáře, který je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již poměrně rozsáhlý) repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>example01.asm</td><td>zdrojový kód příkladu tvořeného kostrou aplikace pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm</a></td></tr>
<tr><td>2</td><td>example02.asm</td><td>použití standardní konfigurace linkeru pro konzoli NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm</a></td></tr>
<tr><td>3</td><td>example03.asm</td><td>symbolická jména řídicích registrů PPU</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm</a></td></tr>
<tr><td>4</td><td>example04.asm</td><td>zjednodušený zápis lokálních smyček v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm</a></td></tr>
<tr><td>5</td><td>example05.asm</td><td>zvukový výstup s&nbsp;využitím prvního &bdquo;square&ldquo; kanálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm</a></td></tr>
<tr><td>6</td><td>example06.asm</td><td>použití maker bez parametrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>link.cfg</td><td>konfigurace segmentů pro linker <strong>ld65</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg</a></td></tr>
<tr><td>8</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>NesDev.org<br />
<a href="https://www.nesdev.org/">https://www.nesdev.org/</a>
</li>

<li>How to Program an NES game in C<br />
<a href="https://nesdoug.com/">https://nesdoug.com/</a>
</li>

<li>Getting Started Programming in C: Coding a Retro Game with C Part 2<br />
<a href="https://retrogamecoders.com/getting-started-with-c-cc65/">https://retrogamecoders.com/getting-started-with-c-cc65/</a>
</li>

<li>NES game development in 6502 assembly - Part 1<br />
<a href="https://kibrit.tech/en/blog/nes-game-development-part-1">https://kibrit.tech/en/blog/nes-game-development-part-1</a>
</li>

<li>"Game Development in Eight Bits" by Kevin Zurawel<br />
<a href="https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4">https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4</a>
</li>

<li>Game Development for the 8-bit NES: A class by Bob Rost<br />
<a href="http://bobrost.com/nes/">http://bobrost.com/nes/</a>
</li>

<li>Game Development for the 8-bit NES: Lecture Notes<br />
<a href="http://bobrost.com/nes/lectures.php">http://bobrost.com/nes/lectures.php</a>
</li>

<li>NES Graphics Explained<br />
<a href="https://www.youtube.com/watch?v=7Co_8dC2zb8">https://www.youtube.com/watch?v=7Co_8dC2zb8</a>
</li>

<li>NES GAME PROGRAMMING PART 1<br />
<a href="https://rpgmaker.net/tutorials/227/?post=240020">https://rpgmaker.net/tutorials/227/?post=240020</a>
</li>

<li>NES 6502 Programming Tutorial - Part 1: Getting Started<br />
<a href="https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/">https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/</a>
</li>

<li>Minimal NES example using ca65<br />
<a href="https://github.com/bbbradsmith/NES-ca65-example">https://github.com/bbbradsmith/NES-ca65-example</a>
</li>

<li>List of 6502-based Computers and Consoles<br />
<a href="https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/">https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/</a>
</li>

<li>History of video game consoles (second generation): Wikipedia<br />
<a href="http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)">http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)</a>
</li>

<li>6502 - the first RISC &micro;P<br />
<a href="http://ericclever.com/6500/">http://ericclever.com/6500/</a>
</li>

<li>3 Generations of Game Machine Architecture<br />
<a href="http://www.atariarchives.org/dev/CGEXPO99.html">http://www.atariarchives.org/dev/CGEXPO99.html</a>
</li>

<li>bee - The Multi-Console Emulator<br />
<a href="http://www.thebeehive.ws/">http://www.thebeehive.ws/</a>
</li>

<li>Nerdy Nights Mirror<br />
<a href="https://nerdy-nights.nes.science/">https://nerdy-nights.nes.science/</a>
</li>

<li>The Nerdy Nights ca65 Remix<br />
<a href="https://github.com/ddribin/nerdy-nights">https://github.com/ddribin/nerdy-nights</a>
</li>

<li>NES Development Day 1: Creating a ROM<br />
<a href="https://www.moria.us/blog/2018/03/nes-development">https://www.moria.us/blog/2018/03/nes-development</a>
</li>

<li>How to Start Making NES Games<br />
<a href="https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/">https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/</a>
</li>

<li>ca65 Users Guide<br />
<a href="https://cc65.github.io/doc/ca65.html">https://cc65.github.io/doc/ca65.html</a>
</li>

<li>cc65 Users Guide<br />
<a href="https://cc65.github.io/doc/cc65.html">https://cc65.github.io/doc/cc65.html</a>
</li>

<li>ld65 Users Guide<br />
<a href="https://cc65.github.io/doc/ld65.html">https://cc65.github.io/doc/ld65.html</a>
</li>

<li>da65 Users Guide<br />
<a href="https://cc65.github.io/doc/da65.html">https://cc65.github.io/doc/da65.html</a>
</li>

<li>Nocash NES Specs<br />
<a href="http://nocash.emubase.de/everynes.htm">http://nocash.emubase.de/everynes.htm</a>
</li>

<li>Nintendo Entertainment System<br />
<a href="http://cs.wikipedia.org/wiki/NES">http://cs.wikipedia.org/wiki/NES</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>NesDev<br />
<a href="http://nesdev.parodius.com/">http://nesdev.parodius.com/</a>
</li>

<li>2A03 technical reference<br />
<a href="http://nesdev.parodius.com/2A03%20technical%20reference.txt">http://nesdev.parodius.com/2A03%20technical%20reference.txt</a>
</li>

<li>NES Dev wiki: 2A03<br />
<a href="http://wiki.nesdev.com/w/index.php/2A03">http://wiki.nesdev.com/w/index.php/2A03</a>
</li>

<li>Ricoh 2A03<br />
<a href="http://en.wikipedia.org/wiki/Ricoh_2A03">http://en.wikipedia.org/wiki/Ricoh_2A03</a>
</li>

<li>2A03 pinouts<br />
<a href="http://nesdev.parodius.com/2A03_pinout.txt">http://nesdev.parodius.com/2A03_pinout.txt</a>
</li>

<li>27c3: Reverse Engineering the MOS 6502 CPU (en)<br />
<a href="https://www.youtube.com/watch?v=fWqBmmPQP40">https://www.youtube.com/watch?v=fWqBmmPQP40</a>
</li>

<li>“Hello, world” from scratch on a 6502 — Part 1<br />
<a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">https://www.youtube.com/watch?v=LnzuMJLZRdU</a>
</li>

<li>A Tour of 6502 Cross-Assemblers<br />
<a href="https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/">https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/</a>
</li>

<li>Nintendo Entertainment System (NES)<br />
<a href="https://8bitworkshop.com/docs/platforms/nes/">https://8bitworkshop.com/docs/platforms/nes/</a>
</li>

<li>Question about NES vectors and PPU<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t4154.xhtml">https://archive.nes.science/nesdev-forums/f10/t4154.xhtml</a>
</li>

<li>How do mapper chips actually work?<br />
<a href="https://archive.nes.science/nesdev-forums/f9/t13125.xhtml">https://archive.nes.science/nesdev-forums/f9/t13125.xhtml</a>
</li>

<li>INES<br />
<a href="https://www.nesdev.org/wiki/INES">https://www.nesdev.org/wiki/INES</a>
</li>

<li>NES Basics and Our First Game<br />
<a href="http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html">http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html</a>
</li>

<li>Where is the reset vector in a .nes file?<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t17413.xhtml">https://archive.nes.science/nesdev-forums/f10/t17413.xhtml</a>
</li>

<li>CPU memory map<br />
<a href="https://www.nesdev.org/wiki/CPU_memory_map">https://www.nesdev.org/wiki/CPU_memory_map</a>
</li>

<li>How to make NES music<br />
<a href="http://blog.snugsound.com/2008/08/how-to-make-nes-music.html">http://blog.snugsound.com/2008/08/how-to-make-nes-music.html</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>MIDINES<br />
<a href="http://www.wayfar.net/0xf00000_overview.php">http://www.wayfar.net/0xf00000_overview.php</a>
</li>

<li>FamiTracker<br />
<a href="http://famitracker.com/">http://famitracker.com/</a>
</li>

<li>nerdTracker II<br />
<a href="http://nesdev.parodius.com/nt2/">http://nesdev.parodius.com/nt2/</a>
</li>

<li>How NES Graphics work<br />
<a href="http://nesdev.parodius.com/nesgfx.txt">http://nesdev.parodius.com/nesgfx.txt</a>
</li>

<li>NES Technical/Emulation/Development FAQ<br />
<a href="http://nesdev.parodius.com/NESTechFAQ.htm">http://nesdev.parodius.com/NESTechFAQ.htm</a>
</li>

<li>Adventures with ca65<br />
<a href="https://atariage.com/forums/topic/312451-adventures-with-ca65/">https://atariage.com/forums/topic/312451-adventures-with-ca65/</a>
</li>

<li>example ca65 startup code<br />
<a href="https://atariage.com/forums/topic/209776-example-ca65-startup-code/">https://atariage.com/forums/topic/209776-example-ca65-startup-code/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer<br />
<a href="http://wilsonminesco.com/6502primer/">http://wilsonminesco.com/6502primer/</a>
</li>

<li>6502 Instruction Set<br />
<a href="https://www.masswerk.at/6502/6502_instruction_set.html">https://www.masswerk.at/6502/6502_instruction_set.html</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Single-board computer<br />
<a href="https://en.wikipedia.org/wiki/Single-board_computer">https://en.wikipedia.org/wiki/Single-board_computer</a>
</li>

<li>www.6502.org<br />
<a href="http://www.6502­.org/">http://www.6502­.org/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer &ndash; clock generator<br />
<a href="http://wilsonminesco.com/6502primer/ClkGen.html">http://wilsonminesco.com/6502primer/ClkGen.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://www.cpushack.com/CPU/cpu.html">http://www.cpushack.com/CPU/cpu.html</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Osmibitové mikroprocesory a mikrořadiče firmy Motorola (1)<br />
<a href="https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/">https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/</a>
</li>

<li>Mikrořadiče a jejich použití v jednoduchých mikropočítačích<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/">https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/</a>
</li>

<li>Mikrořadiče a jejich aplikace v jednoduchých mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/">https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Comparison of instruction set architectures<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures">https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</a>
</li>

<li>Day 1 - Beginning NES Assembly<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-1/">https://www.patater.com/nes-asm-tutorials/day-1/</a>
</li>

<li>Day 2 - A Source Code File's Structure<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-2/">https://www.patater.com/nes-asm-tutorials/day-2/</a>
</li>

<li>Assembly Language Misconceptions<br />
<a href="https://www.youtube.com/watch?v=8_0tbkbSGRE">https://www.youtube.com/watch?v=8_0tbkbSGRE</a>
</li>

<li>How Machine Language Works<br />
<a href="https://www.youtube.com/watch?v=HWpi9n2H3kE">https://www.youtube.com/watch?v=HWpi9n2H3kE</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

