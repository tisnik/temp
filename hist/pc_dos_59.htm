<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Funkce vestavěné v GCC pro provádění nízkoúrovňových aritmetických operací</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Funkce vestavěné v GCC pro provádění nízkoúrovňových aritmetických operací</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Funkce vestavěné v&nbsp;GCC pro provádění nízkoúrovňových aritmetických operací</a></p>
<p><a href="#k02">2. Operace součtu s&nbsp;detekcí přetečení</a></p>
<p><a href="#k03">3. Způsob překladu operací součtu do strojového kódu</a></p>
<p><a href="#k04">4. Funkce <strong>__builtin_add_overflow</strong> se shodnými typy sčítanců i výsledku součtu</a></p>
<p><a href="#k05">5. Překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64</a></p>
<p><a href="#k06">6. Analýza vygenerovaného strojového kódu pro platformu x86-64</a></p>

<p><a href="#k07">*** 7. Překlad volání funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</a></p>
<p><a href="#k08">*** 8. Analýza vygenerovaného strojového kódu pro platformu ARM32</a></p>
<p><a href="#k09">*** 9. Překlad volání funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</a></p>
<p><a href="#k10">*** 10. Analýza vygenerovaného strojového kódu pro platformu AArch64</a></p>
<p><a href="#k11">*** 11. Chování funkce <strong>__builtin_add_overflow</strong>, pokud mají sčítance i výsledek součtu odlišné typy</a></p>
<p><a href="#k12">*** 12. Demonstrační příklad: součet s&nbsp;využitím různých kombinací hodnot typu <strong>char</strong> a <strong>int</strong></a></p>
<p><a href="#k13">*** 13. Operace rozdílu s&nbsp;detekcí přetečení</a></p>
<p><a href="#k11">*** 11. Demonstrační příklad: volání funkce <strong>__builtin_sub_overflow</strong></a></p>
<p><a href="#k12">*** 12. Operace součinu s&nbsp;detekcí přetečení</a></p>
<p><a href="#k13">*** 13. Kontrola, zda dojde k&nbsp;přetečení při součtu, rozdílu nebo součinu, ovšem bez uložení výsledků</a></p>
<p><a href="#k14">*** 14. Vestavěné funkce realizující součet tří hodnot s&nbsp;přetečením</a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Funkce vestavěné v&nbsp;GCC pro provádění nízkoúrovňových aritmetických operací</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Operace součtu s&nbsp;detekcí přetečení</h2>

<p>První skupinou funkcí vestavěných do překladače GCC, s&nbsp;níž se dnes
seznámíme, jsou funkce určené pro provedení operace součtu, ovšem s&nbsp;tím,
že je navíc korektně detekováno i přetečení výsledků, a to i pro hodnoty se
znaménkem. Těchto funkcí existuje celkem sedm: tři funkce pro součet hodnot bez
znaménka (<i>unsigned</i>), tři funkce pro součet hodnot se znaménkem
(<i>signed</i>) a &bdquo;univerzální&ldquo; funkce, jejíž parametry mohou být
různého typu. Povšimněte si, že všech sedm funkcí má stejný počet i význam
parametrů (které jsou ovšem různého typu) i stejný typ návratové hodnoty. Tato
návratová hodnota pouze signalizuje, že došlo k&nbsp;přetečení; samotný
výsledek součtu je vrácen (přes ukazatel, resp.&nbsp;referenci)
v&nbsp;posledním předaném parametru:</p>

<table>
<tr><th>#</th><th>Jméno funkce</th><th>Návratový typ</th><th>Parametry</th></tr>
<tr><td>1</td><td>__builtin_add_overflow</td><td>bool</td><td>typ1 a, typ2 b, typ3 *res</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>__builtin_sadd_overflow</td><td>bool</td><td>int a, int b, int *res</td></tr>
<tr><td>3</td><td>__builtin_saddl_overflow</td><td>bool</td><td>long int a, long int b, long int *res</td></tr>
<tr><td>4</td><td>__builtin_saddll_overflow</td><td>bool</td><td>long long int a, long long int b, long long int *res</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>__builtin_uadd_overflow</td><td>bool</td><td>unsigned int a, unsigned int b, unsigned int *res</td></tr>
<tr><td>6</td><td>__builtin_uaddl_overflow</td><td>bool</td><td>unsigned long int a, unsigned long int b, unsigned long int *res</td></tr>
<tr><td>7</td><td>__builtin_uaddll_overflow</td><td>bool</td><td>unsigned long long int a, unsigned long long int b, unsigned long long int *res</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: zdánlivě chybějící varianty vestavěných
funkcí pro datové typy <strong>signed char</strong>, <strong>unsigned
char</strong>, <strong>signed short</strong> a <strong>unsigned short</strong>
lze nahradit první funkcí z&nbsp;tabulky, což si ostatně dnes ukážeme na
demonstračních příkladech.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Způsob překladu operací součtu do strojového kódu</h2>

<p>V&nbsp;programovacím jazyce C je pochopitelně možné všechny funkce zmíněné
<a href="#k02">v&nbsp;předchozí kapitole</a> naprogramovat, i když
v&nbsp;případě celočíselných typů se znaménkem je implementace
(resp.&nbsp;přesněji řečeno <i>přenositelná</i> implementace) dosti
komplikovaná. Ovšem výhoda vestavěných funkcí by měla být v&nbsp;tom, že je
překladač jazyka C přeloží nebo by alespoň měl přeložit do optimálního a
rychlého strojového kódu, protože na většině mikroprocesorových platforem je
detekce přetečení většinou poměrně snadná až triviální (paradoxně v&nbsp;čistém
C se jedná o mnohem složitější úlohu, protože nám zde chybí příslušné
sémantické konstrukce). Typicky jsou vestavěné funkce přeloženy bez nutnosti
použití <strong>CALL</strong>+<strong>RETURN</strong>; výsledkem bývá sekvence
dvou až pěti strojových instrukcí. O tom, jakým způsobem je překlad prováděn,
se přesvědčíme v&nbsp;demonstračních příkladech popsaných v&nbsp;navazujících
kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce <strong>__builtin_add_overflow</strong> se shodnými typy sčítanců i výsledku součtu</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu je několikrát volána vestavěná
funkce nazvaná <strong>__builtin_add_overflow</strong>, které jsou předány
parametry různého typu, konkrétně typu <strong>char</strong>,
<strong>short</strong>, <strong>int</strong> a <strong>long</strong>, a to ve
variantách se znaménkem a bez znaménka. V&nbsp;dalších kapitolách si ukážeme
způsob překladu těchto funkcí:</p>

<pre>
#include &lt;stdbool.h&gt;
&nbsp;
bool <strong>add_overflow_signed_char</strong>(signed char x, signed char y) {
    signed char z;
    bool overflow = __builtin_add_overflow(x, y, &amp;z);
    return overflow;
}
&nbsp;
bool <strong>add_overflow_unsigned_char</strong>(unsigned char x, unsigned char y) {
    unsigned char z;
    bool overflow = __builtin_add_overflow(x, y, &amp;z);
    return overflow;
}
&nbsp;
bool <strong>add_overflow_signed_short</strong>(signed short x, signed short y) {
    signed short z;
    bool overflow = __builtin_add_overflow(x, y, &amp;z);
    return overflow;
}
&nbsp;
bool <strong>add_overflow_unsigned_short</strong>(unsigned short x, unsigned short y) {
    unsigned short z;
    bool overflow = __builtin_add_overflow(x, y, &amp;z);
    return overflow;
}
&nbsp;
bool <strong>add_overflow_signed_int</strong>(signed int x, signed int y) {
    signed int z;
    bool overflow = __builtin_add_overflow(x, y, &amp;z);
    return overflow;
}
&nbsp;
bool <strong>add_overflow_unsigned_int</strong>(unsigned int x, unsigned int y) {
    unsigned int z;
    bool overflow = __builtin_add_overflow(x, y, &amp;z);
    return overflow;
}
&nbsp;
bool <strong>add_overflow_signed_long</strong>(signed long x, signed long y) {
    signed long z;
    bool overflow = __builtin_add_overflow(x, y, &amp;z);
    return overflow;
}
&nbsp;
bool <strong>add_overflow_unsigned_long</strong>(unsigned long x, unsigned long y) {
    unsigned long z;
    bool overflow = __builtin_add_overflow(x, y, &amp;z);
    return overflow;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že musíme importovat
pouze hlavičkový soubor <strong>stdbool.h</strong> s&nbsp;definicí datového
typu <strong>bool</strong>. Ovšem hlavičky vestavěných funkcí není nutné
definovat &ndash; překladač je zná a může přímo použít. A navíc u funkce
<strong>__builtin_add_overflow</strong> by hlavička byla stejně zavádějící,
protože tato funkce je v&nbsp;určitém smyslu generická (pro celočíselné datové
typy).</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad obecné funkce <strong>__builtin_add_overflow</strong> na platformě x86-64</h2>

<p>Nejprve se pokusíme první demonstrační příklad přeložit pro platformu
x86-64. Zvolíme dvě strategie překladu: zcela bez optimalizací a naopak
s&nbsp;povolenými optimalizacemi:</p>

<pre>
$ <strong>gcc -S -O0 -masm=intel add_overflow.c</strong>
&nbsp;
$ <strong>gcc -S -O9 -masm=intel add_overflow.c</strong>
</pre>

<p>Kvůli použití přepínače <strong>-S</strong> bude výsledkem překladu nikoli
objektový kód, ale kód v&nbsp;assembleru, který byl navíc pro účely článku
očištěn od zbytečných informací a přepínačů.</p>

<p>V&nbsp;případě, že jsou optimalizace zakázány, budou funkce
z&nbsp;demonstračního příkladu přeloženy do této (skutečně neoptimální)
podoby:</p>

<pre>
<strong>add_overflow_signed_char</strong>:
        push    rbp
        mov     rbp, rsp
        mov     edx, edi
        mov     eax, esi
        mov     BYTE PTR [rbp-20], dl
        mov     BYTE PTR [rbp-24], al
        movsx   edx, BYTE PTR [rbp-20]
        movsx   eax, BYTE PTR [rbp-24]
        mov     ecx, 0
        add     al, dl
        jno     .L2
        mov     ecx, 1
.L2:
        mov     BYTE PTR [rbp-2], al
        mov     eax, ecx
        and     eax, 1
        mov     BYTE PTR [rbp-1], al
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
&nbsp;
        ret
&nbsp;
<strong>add_overflow_unsigned_char</strong>:
        push    rbp
        mov     rbp, rsp
        mov     edx, edi
        mov     eax, esi
        mov     BYTE PTR [rbp-20], dl
        mov     BYTE PTR [rbp-24], al
        movzx   eax, BYTE PTR [rbp-20]
        movzx   edx, BYTE PTR [rbp-24]
        mov     ecx, 0
        add     al, dl
        jnc     .L6
        mov     ecx, 1
.L6:
        mov     BYTE PTR [rbp-2], al
        mov     eax, ecx
        and     eax, 1
        mov     BYTE PTR [rbp-1], al
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
&nbsp;
        ret
&nbsp;
<strong>add_overflow_signed_short</strong>:
        push    rbp
        mov     rbp, rsp
        mov     edx, edi
        mov     eax, esi
        mov     WORD PTR [rbp-20], dx
        mov     WORD PTR [rbp-24], ax
        movsx   edx, WORD PTR [rbp-20]
        movsx   eax, WORD PTR [rbp-24]
        mov     ecx, 0
        add     ax, dx
        jno     .L10
        mov     ecx, 1
.L10:
        mov     WORD PTR [rbp-4], ax
        mov     eax, ecx
        mov     BYTE PTR [rbp-1], al
        and     BYTE PTR [rbp-1], 1
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
&nbsp;
        ret
&nbsp;
<strong>add_overflow_unsigned_short</strong>:
        push    rbp
        mov     rbp, rsp
        mov     edx, edi
        mov     eax, esi
        mov     WORD PTR [rbp-20], dx
        mov     WORD PTR [rbp-24], ax
        movzx   eax, WORD PTR [rbp-20]
        movzx   edx, WORD PTR [rbp-24]
        mov     ecx, 0
        add     ax, dx
        jnc     .L14
        mov     ecx, 1
.L14:
        mov     WORD PTR [rbp-4], ax
        mov     eax, ecx
        mov     BYTE PTR [rbp-1], al
        and     BYTE PTR [rbp-1], 1
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
&nbsp;
        ret
&nbsp;
<strong>add_overflow_signed_int</strong>:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-20], edi
        mov     DWORD PTR [rbp-24], esi
        mov     ecx, 0
        mov     edx, DWORD PTR [rbp-20]
        mov     eax, DWORD PTR [rbp-24]
        add     eax, edx
        jno     .L18
        mov     ecx, 1
.L18:
        mov     DWORD PTR [rbp-8], eax
        mov     eax, ecx
        mov     BYTE PTR [rbp-1], al
        and     BYTE PTR [rbp-1], 1
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
&nbsp;
        ret
&nbsp;
<strong>add_overflow_unsigned_int</strong>:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-20], edi
        mov     DWORD PTR [rbp-24], esi
        mov     ecx, 0
        mov     eax, DWORD PTR [rbp-20]
        mov     edx, DWORD PTR [rbp-24]
        add     eax, edx
        jnc     .L22
        mov     ecx, 1
.L22:
        mov     DWORD PTR [rbp-8], eax
        mov     eax, ecx
        mov     BYTE PTR [rbp-1], al
        and     BYTE PTR [rbp-1], 1
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
&nbsp;
        ret
&nbsp;
<strong>add_overflow_signed_long</strong>:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-24], rdi
        mov     QWORD PTR [rbp-32], rsi
        mov     ecx, 0
        mov     rdx, QWORD PTR [rbp-24]
        mov     rax, QWORD PTR [rbp-32]
        add     rax, rdx
        jno     .L26
        mov     ecx, 1
.L26:
        mov     QWORD PTR [rbp-16], rax
        mov     rax, rcx
        mov     BYTE PTR [rbp-1], al
        and     BYTE PTR [rbp-1], 1
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
&nbsp;
        ret
&nbsp;
<strong>add_overflow_unsigned_long</strong>:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-24], rdi
        mov     QWORD PTR [rbp-32], rsi
        mov     ecx, 0
        mov     rax, QWORD PTR [rbp-24]
        mov     rdx, QWORD PTR [rbp-32]
        add     rax, rdx
        jnc     .L30
        mov     ecx, 1
.L30:
        mov     QWORD PTR [rbp-16], rax
        mov     rax, rcx
        mov     BYTE PTR [rbp-1], al
        and     BYTE PTR [rbp-1], 1
        movzx   eax, BYTE PTR [rbp-1]
        pop     rbp
&nbsp;
        ret
</pre>

<p>Překlad s&nbsp;povolenými optimalizacemi dopadne o mnoho lépe:</p>

<pre>
<strong>add_overflow_signed_char</strong>:
        add     dil, sil
        seto    al
        ret
&nbsp;
<strong>add_overflow_unsigned_char</strong>:
        add     sil, dil
        setc    al
        ret
&nbsp;
<strong>add_overflow_signed_short</strong>:
        add     di, si
        seto    al
        ret
&nbsp;
<strong>add_overflow_unsigned_short</strong>:
        add     si, di
        setc    al
        ret
&nbsp;
<strong>add_overflow_signed_int</strong>:
        add     edi, esi
        seto    al
        ret
&nbsp;
<strong>add_overflow_unsigned_int</strong>:
        add     edi, esi
        setc    al
        ret
&nbsp;
<strong>add_overflow_signed_long</strong>:
        add     rdi, rsi
        seto    al
        ret
&nbsp;
<strong>add_overflow_unsigned_long</strong>:
        add     rdi, rsi
        setc    al
        ret
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Analýza vygenerovaného strojového kódu pro platformu x86-64</h2>

<p>Popišme si ve stručnosti, jaké instrukce jsou vlastně v&nbsp;přeloženém strojovém kódu použity. U neoptimalizovaného kódu nalezneme tuto sekvenci instrukcí:</p>

<pre>
<strong>add_overflow_signed_char</strong>:
        ...
        add     al, dl
        jno     .L2
        ...
&nbsp;
<strong>add_overflow_unsigned_char</strong>:
        ...
        add     al, dl
        jnc     .L6
        ...
&nbsp;
<strong>add_overflow_signed_short</strong>:
        ...
        add     ax, dx
        jno     .L10
        ...
&nbsp;
<strong>add_overflow_unsigned_short</strong>:
        ...
        add     ax, dx
        jnc     .L14
        ...
&nbsp;
<strong>add_overflow_signed_int</strong>:
        ...
        add     eax, edx
        jno     .L18
        ...
&nbsp;
<strong>add_overflow_unsigned_int</strong>:
        ...
        add     eax, edx
        jnc     .L22
        ...
</pre>

<p>Vzor je tedy vždy stejný &ndash; nejdříve se provede běžný součet založený
na instrukci <strong>ADD</strong>, pokaždé pochopitelně s&nbsp;různými typy
registrů (8 bitů, 16 bitů, 32 bitů). A po součtu následuje rozeskok realizovaný
instrukcí <strong>JNO</strong> (<i>Jump if Not Overflow</i>) nebo
<strong>JNC</strong> (<i>Jump if Not Carry</i>). Při realizaci podmíněného
rozeskoku se tedy testuje příznakový bit <i>overflow</i> u hodnot se znaménkem
nebo příznakový bit <i>carry</i> u hodnot bez znaménka. Naprosto stejnou
operaci by provedl i programátor v&nbsp;assembleru.</p>

<p>Při překladu se zapnutými optimalizacemi se ovšem žádný rozeskok neprovádí,
protože zde ihned za instrukcí součtu následuje instrukce <strong>seto</strong>
(součet hodnot se znaménkem) nebo <strong>setc</strong> (součet hodnot bez
znaménka). Instrukce <strong>SETcc</strong> přitom na platformě x86-64 existuje
ve více variantách, ovšem provádí vždy stejnou operaci &ndash; do cílového
registru nebo místa paměti dosadí hodnotu 1, pokud je splněna zvolená podmínka.
V&nbsp;opačném případě dosadí hodnotu 0:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Stručný popis instrukce</th></tr>
<tr><td>SETO  </td><td>Set to 1 if Overflow            </td><td>OF = 1</td></tr>
<tr><td>SETNO </td><td>Set to 1 if Not Overflow        </td><td>OF = 0</td></tr>
<tr><td>SETS  </td><td>Set to 1 if Sign                </td><td>SF = 1</td></tr>
<tr><td>SETNS </td><td>Set to 1 if Not Sign            </td><td>SF = 0</td></tr>
<tr><td>SETE  </td><td>Set to 1 if Equal               </td><td>ZF = 1</td></tr>
<tr><td>SETZ  </td><td>Set to 1 if Zero                </td><td>ZF = 1</td></tr>
<tr><td>SETNE </td><td>Set to 1 if Not Equal           </td><td>ZF = 0</td></tr>
<tr><td>SETNZ </td><td>Set to 1 if Not Zero            </td><td>ZF = 0</td></tr>
<tr><td>SETB  </td><td>Set to 1 if Below               </td><td>CF = 1</td></tr>
<tr><td>SETNAE</td><td>Set to 1 if Not Above or Equal  </td><td>CF = 1</td></tr>
<tr><td>SETC  </td><td>Set to 1 if Carry               </td><td>CF = 1</td></tr>
<tr><td>SETNB </td><td>Set to 1 if Not Below           </td><td>CF = 0</td></tr>
<tr><td>SETAE </td><td>Set to 1 if Above or Equal      </td><td>CF = 0</td></tr>
<tr><td>SETNC </td><td>Set to 1 if Not Carry           </td><td>CF = 0</td></tr>
<tr><td>SETBE </td><td>Set to 1 if Below or Equal      </td><td>CF = 1 | ZF = 1</td></tr>
<tr><td>SETNA </td><td>Set to 1 if Not Above           </td><td>CF = 1 | ZF = 1</td></tr>
<tr><td>SETA  </td><td>Set to 1 if Above               </td><td>CF = 0 &amp; ZF = 0</td></tr>
<tr><td>SETNBE</td><td>Set to 1 if Not Below or Equal  </td><td>CF = 0 &amp; ZF = 0</td></tr>
<tr><td>SETL  </td><td>Set to 1 if Less                </td><td>SF &lt;&gt; OF</td></tr>
<tr><td>SETNGE</td><td>Set to 1 if Not Greater or Equal</td><td>SF &lt;&gt; OF</td></tr>
<tr><td>SETGE </td><td>Set to 1 if Greater or Equal    </td><td>SF = OF</td></tr>
<tr><td>SETNL </td><td>Set to 1 if Not Less            </td><td>SF = OF</td></tr>
<tr><td>SETLE </td><td>Set to 1 if Less or Equal       </td><td>ZF = 1 | SF &lt;&gt; OF</td></tr>
<tr><td>SETNG </td><td>Set to 1 if Not Greater         </td><td>ZF = 1 | SF &lt;&gt; OF</td></tr>
<tr><td>SETG  </td><td>Set to 1 if Greater             </td><td>ZF = 0 &amp; SF = OF</td></tr>
<tr><td>SETNLE</td><td>Set to 1 if Not Less or Equal   </td><td>ZF = 0 &amp; SF = OF</td></tr>
<tr><td>SETP  </td><td>Set to 1 if Parity              </td><td>PF = 1</td></tr>
<tr><td>SETPE </td><td>Set to 1 if Parity Even         </td><td>PF = 1</td></tr>
<tr><td>SETNP </td><td>Set to 1 if Not Parity          </td><td>PF = 0</td></tr>
<tr><td>SETPO </td><td>Set to 1 if Parity Odd          </td><td>PF = 0</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad obecné funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</h2>

<pre>
add_overflow_signed_char:
        add     r0, r0, r1
        sxtb    r3, r0
        subs    r0, r0, r3
        it      ne
        movne   r0, #1
        bx      lr
add_overflow_unsigned_char:
        add     r0, r0, r1
        lsrs    r0, r0, #8
        bx      lr
add_overflow_signed_short:
        add     r0, r0, r1
        sxth    r3, r0
        subs    r0, r0, r3
        it      ne
        movne   r0, #1
        bx      lr
add_overflow_unsigned_short:
        add     r0, r0, r1
        lsrs    r0, r0, #16
        bx      lr
add_overflow_signed_int:
        adds    r0, r0, r1
        ite     vs
        movvs   r0, #1
        movvc   r0, #0
        bx      lr
add_overflow_unsigned_int:
        cmn     r0, r1
        ite     cs
        movcs   r0, #1
        movcc   r0, #0
        bx      lr
add_overflow_signed_long:
        adds    r0, r0, r1
        ite     vs
        movvs   r0, #1
        movvc   r0, #0
        bx      lr
add_overflow_unsigned_long:
        cmn     r0, r1
        ite     cs
        movcs   r0, #1
        movcc   r0, #0
        bx      lr
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překlad obecné funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</h2>

<pre>
add_overflow_signed_char:
        sxtb    w1, w1
        sxtb    w0, w0
        add     w2, w0, w1
        eon     w0, w0, w1
        eor     w1, w1, w2
        and     w0, w1, w0
        ubfx    w0, w0, 7, 1
        ret
add_overflow_unsigned_char:
        and     w0, w0, 255
        add     w1, w0, w1
        cmp     w0, w1, uxtb
        cset    w0, hi
        ret
add_overflow_signed_short:
        sxth    w1, w1
        sxth    w0, w0
        add     w2, w0, w1
        eon     w0, w0, w1
        eor     w1, w1, w2
        and     x0, x1, x0
        ubfx    x0, x0, 15, 1
        ret
add_overflow_unsigned_short:
        and     w0, w0, 65535
        add     w1, w0, w1
        cmp     w0, w1, uxth
        cset    w0, hi
        ret
add_overflow_signed_int:
        cmn     w0, w1
        cset    w0, vs
        ret
add_overflow_unsigned_int:
        adds    w0, w0, w1
        cset    w0, cs
        ret
add_overflow_signed_long:
        cmn     x0, x1
        cset    w0, vs
        ret
add_overflow_unsigned_long:
        cmn     x0, x1
        cset    w0, cs
        ret
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
#include <stdbool.h>

bool add_overflow_ccc(unsigned char x, unsigned char y) {
    unsigned char z;
    bool overflow = __builtin_add_overflow(x, y, &z);
    return overflow;
}

bool add_overflow_cci(unsigned char x, unsigned char y) {
    unsigned int z;
    bool overflow = __builtin_add_overflow(x, y, &z);
    return overflow;
}

bool add_overflow_cic(unsigned char x, unsigned int y) {
    unsigned char z;
    bool overflow = __builtin_add_overflow(x, y, &z);
    return overflow;
}

bool add_overflow_cii(unsigned char x, unsigned int y) {
    unsigned int z;
    bool overflow = __builtin_add_overflow(x, y, &z);
    return overflow;
}

bool add_overflow_icc(unsigned char x, unsigned char y) {
    unsigned char z;
    bool overflow = __builtin_add_overflow(x, y, &z);
    return overflow;
}

bool add_overflow_ici(unsigned int x, unsigned char y) {
    unsigned int z;
    bool overflow = __builtin_add_overflow(x, y, &z);
    return overflow;
}

bool add_overflow_iic(unsigned int x, unsigned int y) {
    unsigned char z;
    bool overflow = __builtin_add_overflow(x, y, &z);
    return overflow;
}

bool add_overflow_iii(unsigned int x, unsigned int y) {
    unsigned int z;
    bool overflow = __builtin_add_overflow(x, y, &z);
    return overflow;
}

</pre>

<pre>
add_overflow_ccc:
        add     sil, dil
        setc    al
        ret

add_overflow_cci:
        xor     eax, eax
        ret

add_overflow_cic:
        mov     esi, esi
        movzx   edi, dil
        add     rdi, rsi
        test    rdi, -256
        setne   al
        ret

add_overflow_cii:
        movzx   edi, dil
        add     edi, esi
        setc    al
        ret

add_overflow_icc:
        add     sil, dil
        setc    al
        ret

add_overflow_ici:
        movzx   esi, sil
        add     esi, edi
        setc    al
        ret

add_overflow_iic:
        mov     esi, esi
        mov     edi, edi
        add     rdi, rsi
        test    rdi, -256
        setne   al
        ret

add_overflow_iii:
        add     edi, esi
        setc    al
        ret
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Operace rozdílu s&nbsp;detekcí přetečení</h2>

<table>
<tr><th>Jméno funkce</th><th>Návratový typ</th><th>Parametry</th></tr>
<tr><td>__builtin_sub_overflow   </td><td>bool</td><td>type1 a, type2 b, type3 *res</td></tr>
<tr><td>__builtin_ssub_overflow  </td><td>bool</td><td>int a, int b, int *res</td></tr>
<tr><td>__builtin_ssubl_overflow </td><td>bool</td><td>long int a, long int b, long int *res</td></tr>
<tr><td>__builtin_ssubll_overflow</td><td>bool</td><td>long long int a, long long int b, long long int *res</td></tr>
<tr><td>__builtin_usub_overflow  </td><td>bool</td><td>unsigned int a, unsigned int b, unsigned int *res</td></tr>
<tr><td>__builtin_usubl_overflow </td><td>bool</td><td>unsigned long int a, unsigned long int b, unsigned long int *res</td></tr>
<tr><td>__builtin_usubll_overflow</td><td>bool</td><td>unsigned long long int a, unsigned long long int b, unsigned long long int *res</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
#include <stdbool.h>

bool sub_overflow_signed_char(signed char x, signed char y) {
    signed char z;
    bool overflow = __builtin_sub_overflow(x, y, &z);
    return overflow;
}

bool sub_overflow_unsigned_char(unsigned char x, unsigned char y) {
    unsigned char z;
    bool overflow = __builtin_sub_overflow(x, y, &z);
    return overflow;
}

bool sub_overflow_signed_short(signed short x, signed short y) {
    signed short z;
    bool overflow = __builtin_sub_overflow(x, y, &z);
    return overflow;
}

bool sub_overflow_unsigned_short(unsigned short x, unsigned short y) {
    unsigned short z;
    bool overflow = __builtin_sub_overflow(x, y, &z);
    return overflow;
}

bool sub_overflow_signed_int(signed int x, signed int y) {
    signed int z;
    bool overflow = __builtin_sub_overflow(x, y, &z);
    return overflow;
}

bool sub_overflow_unsigned_int(unsigned int x, unsigned int y) {
    unsigned int z;
    bool overflow = __builtin_sub_overflow(x, y, &z);
    return overflow;
}

bool sub_overflow_signed_long(signed long x, signed long y) {
    signed long z;
    bool overflow = __builtin_sub_overflow(x, y, &z);
    return overflow;
}

bool sub_overflow_unsigned_long(unsigned long x, unsigned long y) {
    unsigned long z;
    bool overflow = __builtin_sub_overflow(x, y, &z);
    return overflow;
}
</pre>

<pre>
sub_overflow_signed_char:
        sub     dil, sil
        seto    al
        ret

sub_overflow_unsigned_char:
        cmp     sil, dil
        seta    al
        ret

sub_overflow_signed_short:
        sub     di, si
        seto    al
        ret

sub_overflow_unsigned_short:
        cmp     si, di
        seta    al
        ret

sub_overflow_signed_int:
        sub     edi, esi
        seto    al
        ret

sub_overflow_unsigned_int:
        cmp     edi, esi
        setb    al
        ret

sub_overflow_signed_long:
        sub     rdi, rsi
        seto    al
        ret

sub_overflow_unsigned_long:
        cmp     rdi, rsi
        setb    al
        ret
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Kontrola, zda dojde k&nbsp;přetečení při součtu, rozdílu nebo součinu, ovšem bez uložení výsledků</h2>

<p></p>

<table>
<tr><th>Jméno funkce</th><th>Návratový typ</th><th>Parametry</th></tr>
<tr><td>__builtin_mul_overflow   </td><td>bool</td><td>type1 a, type2 b, type3 *res</td></tr>
<tr><td>__builtin_smul_overflow  </td><td>bool</td><td>int a, int b, int *res</td></tr>
<tr><td>__builtin_smull_overflow </td><td>bool</td><td>long int a, long int b, long int *res</td></tr>
<tr><td>__builtin_smulll_overflow</td><td>bool</td><td>long long int a, long long int b, long long int *res</td></tr>
<tr><td>__builtin_umul_overflow  </td><td>bool</td><td>unsigned int a, unsigned int b, unsigned int *res</td></tr>
<tr><td>__builtin_umull_overflow </td><td>bool</td><td>unsigned long int a, unsigned long int b, unsigned long int *res</td></tr>
<tr><td>__builtin_umulll_overflow</td><td>bool</td><td>unsigned long long int a, unsigned long long int b, unsigned long long int *res</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vestavěné funkce realizující součet tří hodnot s&nbsp;přetečením</h2>



unsigned int __builtin_addc (unsigned int a, unsigned int b, unsigned int carry_in, unsigned int *carry_out)
unsigned long int __builtin_addcl (unsigned long int a, unsigned long int b, unsigned int carry_in, unsigned long int *carry_out)
unsigned long long int __builtin_addcll (unsigned long long int a, unsigned long long int b, unsigned long long int carry_in, long long int *carry_out)



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Operace rozdílu: s&nbsp;výpůjčkou (<i>borrow</i>) nebo s&nbsp;přetečením (<i>carry</i>)?</h2>

unsigned int __builtin_subc (unsigned int a, unsigned int b, unsigned int carry_in, unsigned int *carry_out)
unsigned long int __builtin_subcl (unsigned long int a, unsigned long int b, unsigned int carry_in, unsigned long int *carry_out)
unsigned long long int __builtin_subcll (unsigned long long int a, unsigned long long int b, unsigned long long int carry_in, unsigned long long int *carry_out)


<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
s&nbsp;využitím překladače <strong>gcc</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add_overflow.c</td><td>volání vestavěné funkce <strong>__builtin_add_overflow</strong> s&nbsp;předáním operandů různých typů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow.c</a></td></tr>
<tr><td> 2</td><td>add_overflow_x86_64_O0.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_O0.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_O0.asm</a></td></tr>
<tr><td> 3</td><td>add_overflow_x86_64_Os.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_Os.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_Os.asm</a></td></tr>
<tr><td> 4</td><td>add_overflow_arm_32.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_32.asm</a></td></tr>
<tr><td> 5</td><td>add_overflow_arm_64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>add_diff_types.c</td><td>součet s&nbsp;využitím různých kombinací hodnot typu <strong>char</strong> a <strong>int</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types.c</a></td></tr>
<tr><td> 7</td><td>add_diff_types_x86_64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_x86_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_x86_64.asm</a></td></tr>
<tr><td> 8</td><td>add_diff_types_arm32.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm32.asm</a></td></tr>
<tr><td> 9</td><td>add_diff_types_arm64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>sub_overflow.c</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.c</a></td></tr>
<tr><td>11</td><td>sub_overflow.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Other Built-in Functions Provided by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>
</li>

<li>GCC: 6.60 Built-in Functions Specific to Particular Target Machines<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins">https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins</a>
</li>

<li>Stránka projektu Compiler Explorer<br />
<a href="https://godbolt.org/">https://godbolt.org/</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://llvm.org/">https://llvm.org/</a>
</li>

<li>GCC, the GNU Compiler Collection<br />
<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>
</li>

<li>Clang<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Clang: Assembling a Complete Toolchain<br />
<a href="https://clang.llvm.org/docs/Toolchain.html">https://clang.llvm.org/docs/Toolchain.html</a>
</li>

<li>Integer overflow<br />
<a href="https://en.wikipedia.org/wiki/Integer_overflow">https://en.wikipedia.org/wiki/Integer_overflow</a>
</li>

<li>SETcc — Set Byte on Condition<br />
<a href="https://www.felixcloutier.com/x86/setcc">https://www.felixcloutier.com/x86/setcc</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>Undefined behavior (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Undefined_behavior">https://en.wikipedia.org/wiki/Undefined_behavior</a>
</li>

<li>Is signed integer overflow still undefined behavior in C++?<br />
<a href="https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c">https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c</a>
</li>

<li>Allowing signed integer overflows in C/C++<br />
<a href="https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c">https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

