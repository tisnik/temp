<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Oslava 55 let od vzniku první implementace programovacího jazyka APL</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Oslava 55 let od vzniku první implementace programovacího jazyka APL</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Před 55 lety, tedy v listopadu 1966, byla vydána první verze programovacího jazyka APL. Jednalo se o přelomový jazyk, který byl založen na (tehdy) nové notaci zápisu matematických operací vymyšlenou Kennethem E. Iversonem. Jazyk APL je stále používán i v současnosti.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Oslava 55 let od vzniku první implementace programovacího jazyka APL</a></p>
<p><a href="#k02">2. Notace &ndash; osvobození z&nbsp;diktátu ASCII textu i důležitá myšlenková pomůcka</a></p>
<p><a href="#k03">3. Malá odbočka &ndash; programovací jazyky s&nbsp;netradiční notací</a></p>
<p><a href="#k04">4. První skutečný jazyk APL: APL\360</a></p>
<p><a href="#k05">5. Základní vlastnosti programovacího jazyka APL</a></p>
<p><a href="#k06">6. Ovšem je jazyk APL skutečně nečitelný?</a></p>
<p><a href="#k07">7. Základní (primitivní) funkce a operátory programovacího jazyka APL</a></p>
<p><a href="#k08">8. Výrazy</a></p>
<p><a href="#k09">9. n-dimenzionální pole jako základní datový typ jazyka APL</a></p>
<p><a href="#k10">10. Přístup k&nbsp;prvkům polí (použití indexů), funkce &bdquo;take&ldquo; a &bdquo;drop&ldquo;</a></p>
<p><a href="#k11">11. Šestice základních operátorů aplikovatelných na pole</a></p>
<p><a href="#k12">*** 12. Operátory &bdquo;reduce&ldquo; a &bdquo;scan&ldquo;</a></p>
<p><a href="#k13">*** 13. Operátor &bdquo;inner product&ldquo;</a></p>
<p><a href="#k14">*** 14. Operátor &bdquo;outer product&ldquo;</a></p>
<p><a href="#k15">*** 15. Hierarchické datové struktury, komprese polí</a></p>
<p><a href="#k16">*** 16. Praktické vyzkoušení možností jazyka APL</a></p>
<p><a href="#k17">*** 17. Jak myslet v&nbsp;APL &ndash; výpočet prvočísel netradičním způsobem</a></p>
<p><a href="#k18">18. Další programovací jazyky podporující práci s&nbsp; vektory a maticemi</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Oslava 55 let od vzniku první implementace programovacího jazyka APL</h2>

<p>Ve skutečnosti se ovšem historie programovacího jazyka <i>APL</i> začala
psát nikoli v&nbsp;roce 1966, ale již v&nbsp;roce 1957. Právě tehdy <i>Kenneth
E. Iverson</i>, který v&nbsp;té době pracoval na Harvardské universitě,
vytvořil novou notaci určenou pro jednotný zápis matematických funkcí i pro
tvorbu funkcí nových. Tato notace byla zcela odlišná od zavedené notace
(resp.&nbsp;přesněji řečeno) notací, které se v&nbsp;matematice používaly.
V&nbsp;roce 1962 byla tato notace popsána v&nbsp;knize nazvané &bdquo;A
Programming Language&ldquo; a (což původně nebylo plánováno) o několik let
později se začaly objevovat skutečné interpretry i překladače programovacího
jazyka používajícího stejné symboly, jaké popsal Iverson ve své knize.
Konkrétně se jednalo o jazyk nazvaný <i>IVSYS</i>, který byl implementovaný
v&nbsp;roce 1966 (což ovšem ještě nebyl <i>skutečný</i> APL, který byl
následován jazykem <i>APL\360</i> z&nbsp;roku 1966 a poté <i>APL\1130</i>
z&nbsp;roku 1968, jenž pracoval na počítači <i>IBM 1130</i>.</p>

*** image ***
<p><i>Obrázek 1: Přebal knihy K.E.Iversona o jeho revoluční notaci (ostatně
název naznačuje, že až si IT projde současným vývojem programovacích jazyků,
nakonec skončí stejně u APL :-).</i></p>

<p>Další implementace tohoto programovacího jazyka vznikly na mainframech
<i>IBM/370</i>, později se různé (ve větší či menší míře modifikované) verze
<i>APL</i> začaly používat i na minipočítačích a posléze i na mikropočítačích.
Dnes existují implementace pro všechny rozšířené operační systémy
mikropočítačů, takže <i>APL</i> je možné použít na Linuxu, Mac OS i Microsoft
Windows (viz odkazy uvedené <a href="#k20">ve dvacáté kapitole</a>). A
nejjednodušší je použít webovou verzi APL dostupnou na adrese <a
href="https://tryapl.org/">https://tryapl.org/</a>, což je ostatně téma,
kterému se budeme věnovat v&nbsp;navazujících kapitolách.</p>

<a href="http://i.iinfo.cz/images/252/apl-1.png"><img src="http://i.iinfo.cz/images/252/apl-1-prev.png" alt="apl" height="171" width="370" /></a>
<p><i>Obrázek 2: Rozložení znaků na klávesnici používané při programování
v&nbsp;jazyku APL. Speciální znaky na klávesnici reprezentují základní
(primitivní) funkce a operátory, z&nbsp;nichž mnohé si popíšeme.</i></p>

<p>Kenneth Iverson se rozvoji a propagaci jazyka <i>APL</i> aktivně věnoval
více než 20 let, za což mu byla v&nbsp;roce 1979 udělena Turingova cena
(<i>Turing Award</i>). Později Iverson navrhl programovací jazyk <i>J</i>,
v&nbsp;němž se místo speciálních symbolů (viz následující kapitoly) používají
pouze znaky obsažené v&nbsp;ASCII tabulce (v&nbsp;jazyku J se navíc ve velké
míře podporuje tzv. <i>tacit</i>, což je téma na samostatný článek). Vraťme se
však k&nbsp;<i>APL</i>. Specifikace tohoto jazyka se od poloviny šedesátých let
minulého století několikrát změnila (rozšířila). Jedním z&nbsp;nejvíce
důležitých rozšíření je <i>APL2</i> od J.&nbsp;Browna z&nbsp;IBM, které do
jazyka zavedlo podporu pro rekurzivní datové struktury (tedy, jak uvidíme dále,
pro pole jako prvky jiných polí, což je mimochodem dále zobecněno v&nbsp;jazyku
<i>BQN</i>). Většina dnešních implementací tohoto jazyka se snaží dodržovat
specifikaci <i>APL2</i>, i když je jazyk dále rozšiřován (například
v&nbsp;<i>APLX verze 4</i> byla přidána podpora pro objektově orientované
programování, i když v&nbsp;poněkud jiné podobě, než ji známe
z&nbsp;mainstreamových programovacích jazyků). Z&nbsp;moderních implementací
APL se pak musíme zmínit o komerčním <i>Dyalog APL</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Notace &ndash; osvobození z&nbsp;diktátu ASCII textu i důležitá myšlenková pomůcka</h2>

<p><i>&bdquo;Notation as a tool of thought&ldquo;</i></p>

<p><i>Kenneth Iverson</i> si v&nbsp;průběhu svého působení na univerzitě
uvědomil, jak důležitá je správně navržená notace pro popis složitějších
matematických výrazů, funkcí i celých algoritmů. <i>Notací</i> se v&nbsp;tomto
kontextu myslí systém resp.&nbsp;přesněji řečeno pravidla určující vzájemné
vztahy mezi symboly pro účely (strukturované) komunikace. Důležité je, že se
prakticky vždy jedná o nějakou doménově specifickou oblast, ať již se jedná
právě o matematiku (kde existuje hned několik vzájemně nekompatibilních
notací), hudbu, chemii, ale například i o astrologii :-).</p>

<img src="https://i.iinfo.cz/images/124/apl55-1-1.png" class="image-492254" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="805" height="247" />
<p><i>Obrázek 3: Hudební notace resp.&nbsp;jedna z&nbsp;forem hudební notace.</i></p>

<p>Důležitost a možná i nezbytnost volby správné notace si můžeme ukázat na
klasickém příkladu &ndash; způsobu zápisu čísel, konkrétně na dvou zcela
odlišných notacích. Jedná se o římské číslice a o notaci, kterou dnes
(nepřesně) označujeme jako arabské číslice. Způsob zápisu/notace římských
číslic do značné míry komplikuje prakticky všechny aritmetické operace (zkuste
si například vydělit DCCCCLXXXXVIIII hodnotou CXI &ndash; já to přímo
nedokážu), ovšem komplikuje i další rozšiřování zápisu, například o nulu, o
záporná čísla nebo o čísla s&nbsp;neceločíselnou částí. Pokud se ovšem má
stejná operace provést s&nbsp;využitím zápisu hodnot arabskými číslicemi, jedná
se o trivialitu, kterou prakticky kdokoli vypočte zpaměti. Ovšem ani klasická
notace s&nbsp;arabskými číslicemi není všemocná, takže se musela pro výpočty
s&nbsp;velmi malými nebo naopak velkými čísly rozšířit o &bdquo;vědeckou&ldquo;
notaci a&times;10<sup>b</sup>.</p>

<img src="https://i.iinfo.cz/images/124/apl55-1-2.png" class="image-492255" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="612" height="299" />
<p><i>Obrázek 4: Dvě z&nbsp;mnoha notací používaných v&nbsp;chemii
(a mimochodem popisujících stejnou strukturu).</i></p>

<p>S&nbsp;různými notacemi se setkáme především v&nbsp;matematice; jednotlivé
notace se odlišují podle své domény. Známá je například <i>Einsteinova
notace</i> nebo <i>Einsteinova sumační konvence</i>, která zajišťuje úsporný
zápis (a manipulaci!) rovnic v&nbsp;obecné teorii relativity (ovšem je ji možné
použít i obecně v&nbsp;rámci lineární algebry).</p>

<img src="https://i.iinfo.cz/images/124/apl55-1-3.png" class="image-492256" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="701" height="81" />
<p><i>Obrázek 5: Matematická notace.</i></p>

<p><div class="rs-tip-major">Poznámka: to vlastně může znamenat, že lidský
mozek problém neřeší přímo (na základě jeho podstaty), ale &bdquo;pouze&ldquo;
manipulací se symboly v&nbsp;dané notaci. O to víc je tedy jazyk APL užitečný
:-)</div></p>

<img src="https://i.iinfo.cz/images/124/apl55-1-4.png" class="image-492257" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="434" height="79" />
<p><i>Obrázek 6: Další ukázka matematické notace.</i></p>

<img src="https://i.iinfo.cz/images/124/apl55-1-5.png" class="image-492258" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="667" height="127" />
<p><i>Obrázek 7: A poslední ukázka matematické notace.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Malá odbočka &ndash; programovací jazyky s&nbsp;netradiční notací</h2>

<p>Naprostá většina v&nbsp;současnosti používaných programovacích jazyků je
založena na použití omezeného množství symbolů; typicky se jedná o znaky ASCII
(s&nbsp;tím, že některé jazyky umožňují, aby uživatelské identifikátory
obsahovaly i další znaky &ndash; mnohdy ovšem s&nbsp;omezeními). Ovšem nebylo
tomu tak vždy, protože existuje poměrně velké množství programovacích jazyků,
v&nbsp;nichž se používají i další symboly popř.&nbsp;dokonce jazyky,
v&nbsp;nichž se program nezapisuje lineárně zleva doprava a shora dolů, ale má
složitější &bdquo;2D&ldquo; strukturu.</p>

<img src="https://i.iinfo.cz/images/124/apl55-1-11.jpg" class="image-492264" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="330" height="251" />
<p><i>Obrázek 8: I toto je forma notace.</i></p>

<p>Z&nbsp;historicky důležitých jazyků se jedná například o <i>Algol</i>;
konkrétně si přiblížíme <i>Algol 68</i>. ALGOL je jedním z&nbsp;prvních jazyků,
u nichž syntax existuje v&nbsp;několika rozdílných variantách. V&nbsp;případě
Algolu se nazývají <i>reference syntax</i>, <i>publication syntax</i> a
<i>implementation syntax</i>. Referenční syntax je použita především
v&nbsp;oficiálním &bdquo;Reportu&ldquo;, publikační syntax je použita
v&nbsp;článcích, při ukázce algoritmů na tabuli (slajdech) atd. A implementační
syntax se liší podle použitého počítače a jeho schopností (znaková sada atd.).
Kvůli této trojí syntaxi se zápis algoritmů v&nbsp;článcích a knihách mnohdy
dosti podstatným způsobem odlišuje od zápisu pro konkrétní počítač. Navíc to
umožňuje měnit (v&nbsp;článcích i konkrétní implementaci) klíčová slova a
nahrazovat je za národní varianty, používat desetinnou čárku namísto desetinné
tečky atd.</p>

<p>V&nbsp;&bdquo;publikační&ldquo; syntaxi nalezneme kromě jiného i následující
symboly:</p>

<ul>
<li>∧, ∨</li>
<li>×, ÷, ÷×, ÷*, %×</li>
<li>≤, ≥, ≠, ¬=</li>
<li>→, ○, ¢, ⏨, □</li>
<li>×:=, ÷:=, ÷×:=, ÷*:=,  %×:=</li>
<li>¬, ↑, ↓, ⌊, ⌈, ⊥</li>
<li>⊂, ≡, ␣, ⊃, ⎩, ⎧</li>
</ul>

<p>Dalším příkladem může být programovací jazyk <i>Fortress</i>, který se sice
zapisuje ve standardní textové podobě, která je ovšem následně transformována
do tisknutelné podoby přes LaTex. Podívejme se na několik ukázek:</p>

<img src="https://i.iinfo.cz/images/124/apl55-1-8.png" class="image-492261" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="636" height="250" />
<p><i>Obrázek 9: Výrazy a příkaz jazyka Fortress v&nbsp;prezentační
formě.</i></p>

<img src="https://i.iinfo.cz/images/124/apl55-1-9.png" class="image-492262" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="286" height="199" />
<p><i>Obrázek 10: Zápis funkce v&nbsp;prezentační formě jazyka
Fortress.</i></p>

<img src="https://i.iinfo.cz/images/124/apl55-1-10.png" class="image-492263" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="879" height="264" />
<p><i>Obrázek 11: Vstupní a prezentační formy některých zápisů v&nbsp;jazyku
Fortress (a toto má již velmi blízko v&nbsp;APL).</i></p>

<p>A konečně posledním příkladem je programovací jazyk <i>Epigram</i>, který
taktéž podporuje vstupní formu zápisu a výstupní (prezentační) formu
generovanou přes LaTeX. Uvedeme si dva příklady &ndash; prvním je definice
datového typu, druhým pak definice funkce.</p>

<p>Definice datového typu:</p>

<pre>
     (         !       (          !   (  n : Nat  !
data !---------! where !----------! ; !-----------!
     ! Nat : * )       !zero : Nat)   !suc n : Nat)
</pre>

<p>Výsledek:</p>

<img src="https://i.iinfo.cz/images/124/apl55-1-6.png" class="image-492259" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="670" height="82" />
<p><i>Obrázek 12: Datový typ v&nbsp;prezentační formě.</i></p>

<p>Definice funkce:</p>

<pre>
plus x y &lt;= rec x {
  plus x y &lt;= case x {
    plus zero y =&gt; y
    plus (suc x) y =&gt; suc (plus x y)
  }
}
</pre>

<p>Výsledek:</p>

<img src="https://i.iinfo.cz/images/124/apl55-1-8.png" class="image-492261" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="636" height="250" />
<p><i>Obrázek 13: Rekurzivní definice funkce v&nbsp;prezentační formě.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. První skutečný jazyk APL: APL\360</h2>

<p><a href="#k01">V&nbsp;úvodní kapitole</a> jsme si řekli, že APL původně
vznikl jako koncept nové unifikované notace zápisu matematických operací a
algoritmů. Teprve později (a trvalo to ve skutečnosti celých devět let) byl na
základě tohoto konceptu vytvořen prakticky použitelný programovací jazyk. První
praktická implementace jazyka APL se nazývá <i>APL\360</i>. Toto poněkud
podivné jméno vychází z&nbsp;toho, že tato verze APL byla provozována na
slavných mainframech <i>IBM System/360</i> (jak je patrné, lomítka a zpětná
lomítka byla tehdy v&nbsp;IBM populární). <i>APL\360</i> byl dokončen
v&nbsp;listopadu 1966, což znamená, že slavíme (přesněji za tři týdny budeme
slavit) 55. výročí tohoto neobvyklého programovacího jazyka. Mimochodem &ndash;
tvůrci APL\360 získali <i>cenu Grace Murray Hopperové</i> za rok 1973, viz též
<a
href="https://en.wikipedia.org/wiki/Grace_Murray_Hopper_Award">https://en.wikipedia.org/wiki/Grace_Murray_Hopper_Award</a>
(z&nbsp;nějakého důvodu je zde však u každého roku uveden pouze jeden
oceněný).</p>

<img src="http://i.iinfo.cz/images/558/ibm3-1.jpg" alt="ibm3_" height="376" width="381" />
<p><i>Obrázek 14: Zrekonstruovaný řídicí panel počítače IBM System/360 Model
30. Na dlaždici před panelem (zhruba pod čtveřicí bílých tlačítek) je pro
porovnání velikostí umístěný současný mikrořadič PIC.</i></p>

<p><div class="rs-tip-major">Poznámka: je zajímavé, že první dostupné
implementace APL vznikly na půdě firmy IBM, která dodávala i specializovaný
hardware pro jeho podporu (tedy například tiskárny s&nbsp;typovými kolečky pro
APL). V&nbsp;roce 1973 byl dokonce vydán APL.SV, což je systém umožňující
sdílení proměnných (polí) mezi procesy běžícími na různých procesorech atd.
Později ovšem společnost IBM začala oficiálně preferovat a prosazovat jiné
programovací jazyky, i když se APL interně stále používal.</div></p>

<a href="http://i.iinfo.cz/images/558/ibm3-3.jpg"><img src="http://i.iinfo.cz/images/558/ibm3-3-prev.jpg" alt="ibm3_" height="238" width="370" /></a>
<p><i>Obrázek 15: Moduly počítačů řady IBM System/360. Zpočátku měl každý modul
podobu větší či menší skříně, později docházelo ke slučování některých funkcí
do menšího počtu modulů i k&nbsp;celkovému zmenšování jak obsazeného prostoru,
tak i spotřeby elektrické energie (to znamenalo i menší nároky na chlazení
&ndash; klimatizaci).</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Základní vlastnosti programovacího jazyka APL</h2>

<p><i>&bdquo;Real Programmers don't write in APL, unless the whole program can
be written on one line&ldquo;</i></p>

<p>Tento článek se nezabývá &bdquo;pouze&ldquo; historií vzniku programovacího
jazyka <i>APL</i> popř.&nbsp;vlivem použité notace na způsob myšlení. Popíšeme
si totiž i některé základní vlastnosti tohoto &ndash; jak uvidíme dále &ndash;
zcela netradičně pojatého programovacího jazyka. V&nbsp;APL jsou přitom
jednotlivé vlastnosti a operace nerozlučně spjaty právě s&nbsp;notací, tedy se
způsobem jejich zápisu.</p>

<p>Prvním z&nbsp;typických rysů programovacího jazyka <i>APL</i> je jeho
orientace na zpracování vektorů a matic (obecně polí téměř libovolné dimenze;
většina implementací povoluje definovat až 63dimenzionální struktury, což je
plně dostačující), a to bez nutnosti použití čítačů či programových smyček.
Jazyk <i>APL</i> s&nbsp;těmito datovými strukturami pracuje z&nbsp;hlediska
programátora prakticky stejným způsobem jako se skalárními hodnotami (čísly),
takže například součet odpovídajících si položek dvou polí je zapisován
s&nbsp;využitím stejné notace jako součet dvou číselných hodnot. Dalším
typickým rysem je způsob aplikace funkcí na hodnoty (obecně pole) a vzájemné
kombinace funkcí pomocí operátorů (slovem <i>operátor</i> jsou
v&nbsp;programovacím jazyce <i>APL</i> označovány funkce vyššího řádu,
tj.&nbsp;funkce vracející jiné funkce; s&nbsp;funkcemi vyššího řádu se dnes
pochopitelně můžeme setkat i v&nbsp;mnoha dalších programovacích jazycích).
S&nbsp;využitím funkcí a operátorů, které jsou přímo v&nbsp;<i>APL</i>
definovány, je možné nahradit i řídicí struktury &ndash; podmíněné příkazy a
programové smyčky &ndash; které dokonce v&nbsp;prvních verzích jazyka ani
nebylo možné zapisovat (v&nbsp;pozdějších verzích se pro usnadnění programování
tyto řídicí struktury do <i>APL</i> přidaly).</p>

<p><div class="rs-tip-major">Poznámka: jazyk APL má mnoho společných rysů
s&nbsp;funkcionálními jazyky. Ostatně některé funkcionální prvky se poprvé
objevily právě v&nbsp;APL, aby byly později adaptovány například do Haskellu.
Konkrétně se jedná například o operátor pro <i>kompozici funkcí</i>.</div></p>

<p>Každá základní (primitivní) funkce a operátor je v&nbsp;jazyce <i>APL</i>
zapisována formou nějakého &bdquo;jednoznakového&ldquo; symbolu, přičemž je
nutné zdůraznit, že většina těchto symbolů (znaků) se <u>ne</u>nachází
v&nbsp;ASCII tabulce, ale jedná se buď o písmeno řecké abecedy nebo jiný
(matematický) symbol zvolený Iversonem (některé symboly jsou zcela unikátní pro
APL). Použití symbolů namísto kombinace alfanumerických znaků, tj.&nbsp;zápisu
známého z&nbsp;většiny dalších vysokoúrovňových programovacích jazyků, je
třetím a pro většinu programátorů nejtypičtějším (resp.&nbsp;nejviditelnějším)
rysem programovacího jazyka <i>APL</i>. V&nbsp;podstatě se jedná o zcela opačný
přístup než jaký jsme mohli vidět například při vývoji programovacího jazyka
<i>COBOL</i>, jenž byl navržen takovým způsobem, aby bylo možné programy
modifikovat i neprogramátory (což se pochopitelně v&nbsp;praxi prakticky nikdy
nestalo). Zatímco v&nbsp;<i>COBOLu</i> se každá programová konstrukce
popisovala jedním či několika klíčovými slovy (kterých existuje více než 300),
jazyk <i>APL</i> ve skutečnosti žádná klíčová slova neobsahuje, ale nabízí
programátorům sadu základních (primitivních) funkcí (cca 50) a operátorů
(celkem šest v&nbsp;základní variantě), které je možné kombinovat a vytvářet
tak nové uživatelské funkce i uživatelské operátory.</p>

<p><div class="rs-tip-major">Poznámka: podobným směrem jako COBOL se vydal i
doménově specifický jazyk SQL, který mimochodem taktéž vznikal na půdě
IBM.</div></p>

*** image ***
<p><i>Obrázek 14: Základní funkce a operátory vypsané v&nbsp;nápovědě
k&nbsp;prostředí TryAPL, s&nbsp;nímž se setkáme v&nbsp;dalším textu.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ovšem je jazyk APL skutečně nečitelný?</h2>

<p>Vzájemná kombinace (zřetězení) primitivních funkcí a operátorů bez vytváření
a pojmenování funkcí vlastních vede k&nbsp;velmi úspornému zápisu kódu, což je
ještě umocněno tím, že všechny základní funkce a operátory se zapisují jediným
znakem. Výsledkem je sice stručný zápis, který je však pro většinu programátorů
prakticky nečitelný (mnozí programátoři čtení podobných programů přirovnávají
k&nbsp;luštění hieroglyfů), o čemž se můžete přesvědčit například
z&nbsp;následujícího výpisu několika výrazů (vzhledem k&nbsp;tomu, že na
některých systémech nemusí být všechny znaky zobrazeny korektně, byl
z&nbsp;výpisu programu pořízen screenshot:</p>

<img src="http://i.iinfo.cz/images/252/apl-2.png" alt="apl" height="425" width="436" />
<p><i>Obrázek 15: Užitečné a relativně často používané idiomy jazyka APL
zapisované pomocí kombinace základních funkcí a operátorů.</i></p>

<p>Podobné programátorské praktiky, jaké byly ukázány na předchozím výpisu
(ovšem vytvořené profesionálem, nejedná se o žádné nesmyslné demo, ale užitečné
idiomy), vedly k&nbsp;tomu, že je jazyk <i>APL</i> považován, byť poněkud
neoprávněně, za jazyk &bdquo;write only&ldquo;, podobně jako <i>Forth</i> (i
když z&nbsp;poněkud jiného důvodu). Ve skutečnosti je však i v&nbsp;jazyku
<i>APL</i> možné poměrně snadno psát přehledné a srozumitelné programy, ve
kterých navíc programátoři mohou využívat všechny výhody tohoto jazyka (mezi
něž patří jednoduchá práce s&nbsp;vektory, maticemi a poli, funkce vyššího
řádu, velmi rychlé prototypování vhodné pro aplikace, ve kterých je důležitý co
nejrychlejší nástup na trh atd.). V&nbsp;případě, že jsou například
nadefinovány základní řídicí příkazy (mnoho moderních implementací <i>APL</i>
je obsahuje), lze programy v&nbsp;<i>APL</i> zapisovat prakticky stejným
způsobem, jako v&nbsp;jiných programovacích jazycích (symbol &#8592; značí
přiřazení a symbol &#9109; neboli <i>quad</i> je primitivní funkce pro načtení
libovolné hodnoty z&nbsp;klávesnice či obecně ze standardního vstupu):</p>

<pre>
GUESS;VAL
    'Hadej cislo'
    :Repeat
        VAL &#8592; &#9109;
        :If VAL=42
            'Uhodl jsi!'
            :Leave
        :EndIf
        'Tesne vedle, zkus to znovu...'
    :EndRepeat
</pre>

<a href="http://i.iinfo.cz/images/252/apl-3.png"><img src="http://i.iinfo.cz/images/252/apl-3-prev.png" alt="apl" height="270" width="329" /></a>
<p><i>Obrázek 16: Moderní fonty (OpenType, PostScriptové) obsahují buď část
nebo dokonce všechny znaky používané jazykem APL pro zápis základních funkcí a
operátorů.</i></p>

<p>Nicméně cesta k&nbsp;efektivní práci s&nbsp;<i>APL</i> vyžaduje, aby se
programátor postupně naučil různé <i>idiomy</i>, tj.&nbsp;sekvence symbolů
popisujících nějakou známou operaci. Tyto idiomy lze po určité době snadno
rozeznat, a to bez toho, aby musel programátor program číst pomalým způsobem
symbol po symbolu. Ostatně pokud lidský mozek něco umí skutečně efektivně, jde
o rozeznávání vzorů (<i>pattern</i>) a idiomy lze za takové vzory považovat.
Opět se nejedná o žádnou specialitu jazyka <i>APL</i>, protože rozeznání idiomů
provádí i každý matematik, který například uvidí tento zápis:</p>

*** image ***
<p><i>Obrázek 17: Vzor/idiom, který lze rozeznat jediným pohledem, pochopitelně
až po náležitém tréninku. Prostřední řádek představuje převod hodnoty
z&nbsp;dekadické soustavy do soustavy binární.</i></p>

<p>Každý matematik by měl ihned rozeznat, že se jedná o harmonickou řadu a
automaticky si tento zápis spojit se všemi vlastnostmi této řady.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základní (primitivní) funkce a operátory programovacího jazyka APL</h2>

<p>V&nbsp;úvodním textu jsme si řekli, že programovací jazyk <i>APL</i>
obsahuje přibližně padesát základních (primitivních) funkcí. V&nbsp;<i>APL</i>
se můžeme setkat se třemi typy funkcí. Jedná se o funkce bez argumentů
(takzvané <i>niladické funkce</i>), tj.&nbsp;ve skutečnosti o procedury, dále
pak o funkce s&nbsp;jedním argumentem (takzvané <i>monadické funkce</i>) a
konečně o funkce se dvěma argumenty (takzvané <i>dyadické funkce</i>).
V&nbsp;jazyce <i>APL</i> je možné přímo ze zápisu zdrojového kódu určit, jakého
typu je volaná funkce, což mj.&nbsp;Iversonovi umožnilo použít jeden symbol pro
reprezentaci většího množství funkcí &ndash; podle toho, jakým způsobem je
symbol v&nbsp;programu použit, je zavolána určitá primitivní funkce.</p>

<p>Na jednu stranu se může zdát, že toto &bdquo;přetížení symbolů&ldquo; povede
k&nbsp;větší nepřehlednosti programů, na stranu druhou jsou však symboly
&bdquo;přetížené&ldquo; s&nbsp;rozmyslem, takže například symbol <i>-</i> značí
negaci (<i>monadická funkce</i> resp.&nbsp;<i>monadická forma</i>) či rozdíl
(<i>dyadická funkce</i>), podobně jako v&nbsp;mnoha dalších programovacích
jazycích, kde se nad tímto dualismem symbolu &bdquo;-&ldquo; nepozastavujeme.
Symbol <i>&divide;</i> znamená v&nbsp;monadické formě výpočet převrácené
hodnoty a ve formě dyadické podíl čísel, vektorů či korespondujících prvků polí
(monadická forma je logická, pokud si uvědomíme, že pro násobení/dělení je
jednotkovým prvkem jednička, kdežto pro součet/součin je jím nula).
V&nbsp;následující tabulce jsou vypsány některé primitivní funkce jazyka
<i>APL</i> (pro korektní zobrazení symbolů v&nbsp;tabulce je nutné použít fonty
s&nbsp;podporou Unicode, například některý z&nbsp;řezů fontu DejaVu):</p>

<table>
<tr><th>Symbol  </th><th>Unicode (hex)</th><th>Jeden argument (monadická forma)</th><th>Dva argumenty (dyadická forma)</th></tr>
<tr><td>+       </td><td>002B</td><td>identita</td><td>součet</td></tr>
<tr><td>-       </td><td>002D</td><td>negace</td><td>rozdíl</td></tr>
<tr><td>&times; </td><td>00D7</td><td>znaménko</td><td>součin</td></tr>
<tr><td>&divide;</td><td>00F7</td><td>převrácená hodnota</td><td>podíl</td></tr>
<tr><td>&#5285; </td><td>2308</td><td>zaokrouhlení na celé číslo nahoru</td><td>vrátí větší argument</td></tr>
<tr><td>&#5290; </td><td>230A</td><td>zaokrouhlení na celé číslo dolů</td><td>vrátí menší argument</td></tr>
<tr><td>|       </td><td>007C</td><td>absolutní hodnota</td><td>zbytek po dělení</td></tr>
<tr><td>&iota;  </td><td>2373</td><td>čítač (generátor sekvence hodnot)</td><td></td></tr>
<tr><td>*       </td><td>002A</td><td>e<sup>x</sup></td><td>x<sup>y</sup></td></tr>
<tr><td>&lt;    </td><td>003C</td><td></td><td>menší než</td></tr>
<tr><td>&le;    </td><td>2264</td><td></td><td>menší nebo rovno</td></tr>
<tr><td>=       </td><td>003D</td><td></td><td>rovno</td></tr>
<tr><td>&ge;    </td><td>2265</td><td></td><td>větší nebo rovno</td></tr>
<tr><td>&gt;    </td><td>003E</td><td></td><td>větší než</td></tr>
<tr><td>&ne;    </td><td>2260</td><td></td><td>nerovno</td></tr>
<tr><td>&isin;  </td><td>220A</td><td></td><td>obsahuje (dotaz na existenci prvku v poli)</td></tr>
<tr><td><u>&isin;</u></td><td>22F8</td></td><td>nalezení hodnoty (prvku v poli)</td></tr>
<tr><td>&#9675;</td><td>25CB</td><td>&pi;&times;hodnota</td><td>goniometrická funkce specifikovaná 2.argumentem</td></tr>
<tr><td>!      </td><td>0021</td><td>1&times;2&times;3&times;.. (faktoriál)</td><td>kombinace</td></tr>
<tr><td>&#9017;</td><td>2339</td><td>inverze matice</td><td>podíl matic</td></tr>
<tr><td>&#9033;</td><td>2349</td><td>transpozice řádků za sloupce</td><td>transpozice specifikovaná 2.argumentem</td></tr>
<tr><td>&#9021;</td><td>233D</td><td>obrácení pořadí položek</td><td>rotace položek (vektoru, matice)</td></tr>
<tr><td>&#9035;</td><td>234B</td><td>setřídění položek vektoru vzestupně</td><td>setřídění podle zadaného argumentu</td></tr>
<tr><td>&#9042;</td><td>2352</td><td>setřídění položek vektoru sestupně</td><td>setřídění podle zadaného argumentu</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: s&nbsp;nejdůležitější šesticí operátorů aplikovaných na pole se setkáme <a href="#k11">v&nbsp;jedenácté kapitole</a>.</div></p>

<a href="http://i.iinfo.cz/images/252/apl-4.png"><img src="http://i.iinfo.cz/images/252/apl-4-prev.png" alt="apl" height="234" width="370" /></a>
<p><i>Obrázek 18: Programátorské textové editory a integrovaná vývojová
prostředí pro programovací jazyk APL dnes většinou obsahují i dialog
s&nbsp;nabídkou symbolů používaných při zápisu základních funkcí a
operátorů.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výrazy</h2>

<p>Algoritmy zapisované v&nbsp;jazyce <i>APL</i> se skládají z&nbsp;výrazů, při
jejichž zápisu se musí dodržovat jen minimální množství syntaktických pravidel.
Nejdůležitějším pravidlem je, že se jednotlivé funkce vyhodnocují zprava doleva
(což sice může vypadat zvláštně, ovšem jsou pro to praktické důvody), přičemž
již vyhodnocená funkce (tj.&nbsp;její návratová hodnota) je použita jako
argument funkce ležící nalevo od ní. Symboly <i>monadických</i> funkcí se
zapisují vždy před svůj argument, naopak symboly funkcí <i>dyadických</i> jsou
zapsány mezi oba argumenty (což je v&nbsp;matematice obvyklé, protože funkce
v&nbsp;<i>APL</i> odpovídají v&nbsp;matematice operátorům &ndash; a je to jeden
z&nbsp;důvodů, proč nejsou podporovány funkce s&nbsp;větším počtem parametrů).
Při zápisu aritmetických výrazů je zapotřebí si dát pozor především na to, že
všechny funkce mají stejné priority (bylo by totiž velmi složité definovat či
zapamatovat si prioritu více než padesáti primitivních funkcí!). Interpret
programovacího jazyka <i>APL</i> vypisuje hodnotu vyhodnoceného výrazu
(tj.&nbsp;návratovou hodnotu nejlevější funkce) na výstup. Podívejme se nyní na
několik jednoduchých příkladů.</p>

<p>Jednoduchý aritmetický výraz (povšimněte si zápisu násobení):</p>

<pre>
1+2&times;3
7
</pre>

<p>Vyhodnocení je prováděno zprava doleva, priority všech funkcí jsou stejné:</p>

<pre>
2&times;3+1
8
</pre>

<p>Argumentem funkce může být i vektor či pole (zde vektor šesti čísel) každá
položka vektoru je vynásobena hodnotou 0.5:</p>

<pre>
2 4 6 8 &times; 0.5
1 2 3 4
</pre>


<p>Totéž pravidlo platí i pro monadickou funkci &bdquo;převrácená hodnota&ldquo;:</p>

<pre>
&divide;1 2 3 4 5
1 0.5 0.3333333333 0.25 0.2
</pre>

<p>Hodnota 10 je vydělena každou hodnotou z vektoru, výsledkem je též vektor:</p>

<pre>
10&divide;1 2 3 4 5 10
10 5 3.33333333 2.5 2.0 1
</pre>

<p>Ukázka kombinace více funkcí, vyhodnocování je stále prováděno zprava doleva:</p>

<pre>
&#5285; 10&divide;1 2 3 4 5 10
10 5 4 3 2 1
</pre>

<p>Dtto pro funkci provádějící zaokrouhlení na celá čísla směrem dolů:</p>

<pre>
&#5290; 10&divide;1 2 3 4 5 10
10 5 3 2 2 1
</pre>

<p>Mezery mezi funkcemi jsou zbytečné:</p>

<pre>
⌊10÷1 2 3 4 5 10
10 5 3 2 2 1
</pre>

<a href="http://i.iinfo.cz/images/252/apl-5.png"><img src="http://i.iinfo.cz/images/252/apl-5-prev.png" alt="apl" height="270" width="235" /></a>
<p><i>Obrázek 19: Ukázka obrazovky integrovaného vývojového prostředí jazyka
APL se zvýrazněním syntaxe, automatickým číslováním řádků při zápisu funkcí
atd.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. n-dimenzionální pole jako základní datový typ jazyka APL</h2>

<p>Již <a href="#k08">v&nbsp;předchozí kapitole</a> jsme si na několika
demonstračních příkladech ukázali základy práce s&nbsp;číselnými vektory. Jazyk
<i>APL</i> podporuje i práci s&nbsp;vícedimenzionálními poli, kde hraje velkou
roli monadická a dyadická funkce <i>&rho;</i> (ró, <i>reshape</i>) a taktéž
monadická funkce <i>&iota;</i> (jóta, index, též čítač).</p>

<p>Většina starších i současných překladačů a interpretrů programovacího jazyka
<i>APL</i> podporuje tvorbu polí s&nbsp;maximálně 63 dimenzemi, ovšem
v&nbsp;praxi se většinou můžeme setkat s&nbsp;0-dimenzionálními poli
(skalárními hodnotami, tj.&nbsp;čísly či znaky), jednodimenzionálními poli
(vektory) a dvoudimenzionálními poli (maticemi). Při práci s&nbsp;poli hraje
velkou roli již výše zmíněná monadická a dyadická funkce &rho; (<i>ró</i>,
<i>reshape</i>) a taktéž monadická funkce &iota; (<i>jóta</i>, <i>index</i>,
též <i>čítač</i>). Monadická forma funkce &rho; slouží ke zjištění prvků
vektoru či velikosti matice (popř.&nbsp;vícerozměrného pole). Výsledkem této
funkce je tedy vektor obsahující tolik prvků, kolik jich odpovídá dimenzi pole
a hodnota každého prvku ve výsledku odpovídá velikosti pole v&nbsp;dané dimenzi
(v&nbsp;případě vektoru se tedy vrátí jediné číslo reprezentující jeho délku, u
matice dvojice číslic odpovídajících počtu řádků a sloupců, u trojrozměrných
polí trojice číslic atd.).</p>

<p><div class="rs-tip-major">Poznámka: podobný koncept známe například i
z&nbsp;knihovny <i>NumPy</i> pro Python.</div></p>

<p>V&nbsp;následujících ukázkách si povšimněte způsobu přiřazení hodnoty
(čísla, vektoru nebo pole) do proměnné pomocí funkce &#8592;.</p>

<p>Zjištění počtu prvků vektoru pomocí monadické funkce &rho;:</p>

<pre>
&rho; 1 2 3 4
4
</pre>

<p>Přiřazení vektoru do proměnné:</p>

<pre>
VECTOR &#8592; 1 2 3 4 5 6
</pre>

<p>Zjištění počtu prvků vektoru pomocí monadické funkce &rho;:</p>

<pre>
&rho;VECTOR
6
</pre>

<p>Použití funkce &iota;, která vygeneruje vektor s&nbsp;prvky 1..n (Pythonisté
zde mohou vidět souvislost s&nbsp;voláním range()):</p>

<pre>
VECTOR &#8592; &iota;10
VECTOR
1 2 3 4 5 6 7 8 9 10
</pre>

<p>Jeden ze způsobů vytvoření prázdného vektoru (seznamu) pomocí funkce
&iota;:</p>

<pre>
EMPTY_LIST &#8592; &iota;0
EMPTY_LIST
*** zde se nic nezobrazilo :-) ***
</pre>

<p>Zjištění počtu prvků vektoru pomocí monadické funkce &rho;:</p>

<pre>
&rho;EMPTY_LIST
0
</pre>

<p>Vytvoření dvourozměrného pole pomocí dyadické funkce &rho; nejdříve se zadá
rozměr jako první argument (4&times;3), druhým argumentem je seznam, který je
transformován do požadovaného pole:</p>

<pre>
4 3 &rho; 1 2 3 4 5 6 7 8 9 10 11 12
1 2 3
4 5 6
7 8 9
10 11 12
</pre>

<p><div class="rs-tip-major">Poznámka: první argument se nemusí zapisovat do
závorek!</div></p>

<p>Dvourozměrné pole lze taktéž naplnit pomocí funkce &iota;:</p>

<pre>
4 3 &rho; &iota;12
1 2 3
4 5 6
7 8 9
10 11 12
</pre>

<p>Pokud nemá seznam dostatečnou délku pro naplnění pole, jsou jeho položky do
pole vloženy opakovaně za sebou:</p>

<pre>
4 3 &rho; 1 2 3 4
1 2 3
4 1 2
3 4 1
2 3 4
</pre>

<p>Výše uvedené vlastnosti lze snadno využít pro vytvoření pole s&nbsp;prvky o
stejné hodnotě:</p>

<pre>
4 3 &rho; 0
0 0 0
0 0 0
0 0 0
0 0 0
</pre>

<p>Naplnění proměnné hodnotou matice:</p>

<pre>
MATICE &#8592; 3 3 &rho; &iota; 9
MATICE
1 2 3
4 5 6
7 8 9
</pre>

<p>Operace nad prvky matice:</p>

<pre>
MATICE &times; 10
10 20 30
40 50 60
70 80 90
</pre>

<p>Vytvoření matice se třemi řádky a dvěma sloupci:</p>

<pre>
CENY &#8592; 3 2 &rho; 1 2 3 4 5 6
CENY
1 2
3 4
5 6
</pre>

<p>Přeuspořádaní prvků v matici:</p>

<pre>
CENY &#8592; 2 3 &rho; CENY
CENY
1 2 3
4 5 6
</pre>

<p>Vytvoření matice 2&times;2 se všemi prvky = 1:</p>

<pre>
M1 &#8592; 2 2 &rho; 1
</pre>

<p>Vytvoření matice 2&times;6 se všemi prvky = 2:</p>

<pre>
M2 &#8592; 2 6 &rho; 5
</pre>

<p>Spojení matic (musí mít stejný počet řádků):</p>

<pre>
VYSLEDEK &#8592; M1,M2
</pre>

<p>Výpis obsahu všech tří matic:</p>

<pre>
M1
1 1
1 1
&nbsp;
M2
5 5 5 5 5 5
5 5 5 5 5 5
&nbsp;
VYSLEDEK
1 1 5 5 5 5 5 5
1 1 5 5 5 5 5 5
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Přístup k&nbsp;prvkům polí (použití indexů), funkce &bdquo;take&ldquo; a &bdquo;drop&ldquo;</h2>

<p>V&nbsp;programovacím jazyku <i>APL</i> je možné, podobně jako
v&nbsp;prakticky všech moderních programovacích jazycích, přistupovat
k&nbsp;jednotlivým prvkům polí, tj.&nbsp;k&nbsp;prvkům vektorů, matic atd. Na
následujícím demonstračním příkladu je ukázán způsob vytvoření jednorozměrného
pole (vektoru) se sedmi prvky a přístup ke třetímu prvku tohoto pole
s&nbsp;využitím indexu zapsaného do hranatých závorek. Posléze je vytvořeno
dvourozměrné pole (tj.&nbsp;matice) velikosti 3&times;3 prvky a následně je
proveden přístup k&nbsp;prvku ležícímu uprostřed této matice. Dvojice indexů je
v&nbsp;tomto případě taktéž zapsána do závorek, přičemž indexy jsou od sebe
odděleny středníkem (nikoli čárkou, ta má zcela jiný význam, protože v&nbsp;APL
slouží ke spojování polí!). Povšimněte si, že prvky pole jsou číslovány od
jedničky (na rozdíl od jazyků odvozených od céčka), což zjednodušuje poměrně
velkou část algoritmů, především v&nbsp;těch případech, kdy se nepoužívají
programové smyčky, kterým se v&nbsp;<i>APL</i> můžeme v&nbsp;mnoha případech
velmi elegantně vyhnout:</p>

<pre>
    Vektor &#8592; 11 22 33 44 55 66 77
    Vektor
11 22 33 44 55 66 77
    Vektor[3]
33
&nbsp;
    Matice &#8592; 3 3 &rho; &iota; 9
    Matice
1 2 3
4 5 6
7 8 9
    Matice[2;2]
5
</pre>

<p>Výše uvedená dvojice demonstračních příkladů pravděpodobně žádného vývojáře
nepřekvapila, protože přístup k&nbsp;jednomu prvku pole je v&nbsp;naprosté
většině současných programovacích jazyků velmi podobný, samozřejmě pokud
zanedbáme některé méně podstatné implementační detaily (způsob zápisu závorek,
hodnota indexu prvního prvku, způsob oddělení indexů). Zajímavější je však to,
že v&nbsp;programovacím jazyku <i>APL</i> je možné vybrat libovolný počet prvků
pole, přičemž indexy prvků ve výběru se mohou opakovat nebo být různě
zpřeházené. Výsledkem všech následujících operací je vektor, tj.&nbsp;nikoli
pouze skalární hodnota. U posledního příkazu je navíc použita monadická
varianta funkce &iota;, která v&nbsp;generuje indexy od jedničky až do zadané
hodnoty (v&nbsp;tomto konkrétním případě se jedná o čísla 1 2 3 4 5, takže se
vrátí hodnoty prvního až pátého prvku):</p>

<pre>
    Pole &#8592; 11 22 33 44 55 66 77
    Pole
11 22 33 44 55 66 77
    Pole[1 2 3]
11 22 33
    Pole[3 2 1]
33 22 11
    Pole[1 3 5 5 3]
11 33 55 55 33
    Pole[&iota;5]
11 22 33 44 55
</pre>

<p>Ovšem všechny výše uvedené příklady jsou jen pouhým náznakem síly operací,
které je možné s&nbsp;prvky polí provádět. Prvkům polí lze přiřazovat hodnoty
(to samozřejmě nikoho neohromí), ovšem mnohem zajímavější je, že hodnoty lze
přiřadit i více prvkům polí současně (v&nbsp;podstatě se jedná o opak výše
ukázaných operací vrácení hodnot vybraných prvků polí). V&nbsp;některých
případech je vhodné pracovat přímo s&nbsp;celým sloupcem či řádkem dvourozměrné
i vícerozměrné matice. I tuto operaci programovací jazyk <i>APL</i> samozřejmě
podporuje. Nejlépe se tato operace vysvětluje na dvourozměrných maticích: pokud
je zapotřebí vybrat celý řádek matice, postačuje do hranatých závorek zadat
číslo řádku, za nímž následuje pouze středník (bez dalších hodnot). Výběr
sloupce je obdobný &ndash; do hranatých závorek se zapíše středník následovaný
indexem sloupce (ve skutečnosti jsou hodnoty uložené ve sloupci převedeny na
řádkový vektor, což je však v&nbsp;kontextu jazyka <i>APL</i> logické). Dokonce
je možné jednotlivé způsoby zkombinovat, tj.&nbsp;například vybrat pouze
několik hodnot na jednom řádku matice atd. &ndash; viz následující
příklady:</p>

<pre>
    Pole &#8592; 11 22 33 44 55 66 77
    Pole
11 22 33 44 55 66 77
    Pole[7] &#8592; 777
    Pole
11 22 33 44 55 66 777
    Pole[1 2 3] &#8592; 0 42 6502
    Pole
0 42 6502 44 55 66 777
    Pole[7 6] &#8592; 0 1
    Pole
0 42 6502 44 55 1 0
    Pole[&iota;5]
0 42 6502 44 55
    10&times;Pole[&iota;5]
0 420 65020 440 550
&nbsp;
    Matice &#8592; 3 3 &rho; &iota; 9
    Matice
1 2 3
4 5 6
7 8 9
    Matice[2;2]
5
    Matice[1;]
1 2 3
    Matice[;1]
1 4 7
    Matice[;1] + Matice[;3]
4 10 16
    2&times;Matice[1;]
2 4 6
    Matice[3;1 3]
7 9
    Matice[;3] &#8592; Matice[;1] + Matice[;2]
    Matice[3;] &#8592; Matice[2;] &times; Matice[3;]
</pre>

<p>Programovací jazyk <i>APL</i> obsahuje i dvojici funkcí, které se používají
pro manipulaci se seznamy, jenž jsou reprezentovány pomocí vektorů,
tj.&nbsp;jednodimenzionálních polí. Jedná se o funkce pojmenované
&bdquo;take&ldquo; a &bdquo;drop&ldquo;. Funkce &bdquo;take&ldquo;, která se
zapisuje pomocí symbolu &#8593;, slouží k&nbsp;získání prvních <i>n</i> prvků
seznamu. Pokud je použita monadická forma této funkce, vrátí se pouze první
prvek (což v&nbsp;Lispu odpovídá funkci <i>car</i>), v&nbsp;případě použití
dyadické formy se vrátí takový počet prvků, jaký udává hodnota prvního
parametru této funkce (druhým parametrem je samotný seznam). Naproti tomu
funkce &bdquo;drop&ldquo; zapisovaná pomocí symbolu &#8595;
&bdquo;zahodí&ldquo; prvních <i>n</i> prvků seznamu a následně vrátí jeho
zbytek (takže 1&#8595; odpovídá v&nbsp;Lispu funkci <i>cdr</i>). U obou funkcí
lze <i>n</i> zadat i jako záporné číslo. V&nbsp;tomto případě se prvky vybírají
či zahazují z&nbsp;konce seznamu a nikoli z&nbsp;jeho začátku. Následuje
jednoduchý příklad ukazující vlastnosti obou výše zmíněných funkcí
&bdquo;take&ldquo; a &bdquo;drop&ldquo;. V&nbsp;příkladu jsou použita záporná
čísla, která jsou označena symbolem &#175; (overbar, high-minus) a nikoli
funkcí - (minus):</p>

<pre>
    Seznam &#8592; &iota;10
    Seznam
1 2 3 4 5 6 7 8 9 10
    1 &#8593; Seznam
1
    1 &#8595; Seznam
2 3 4 5 6 7 8 9 10
    &#8593; Seznam
1
    4 &#8593; Seznam
1 2 3 4
    5 &#8595; Seznam
6 7 8 9 10
    &#175;1 &#8593; Seznam
10
    &#175;1 &#8595; Seznam
1 2 3 4 5 6 7 8 9
</pre>

<p>Funkce &bdquo;take&ldquo; a &bdquo;drop&ldquo; je možné použít i ke
složitějším výpočtům s&nbsp;vektory, opět (jak je tomu v&nbsp;programovacím
jazyce <i>APL</i> zvykem) bez použití programových smyček. Jedná se o výpočty,
ve kterých je nutné provádět aritmetické či logické operace se sousedními
hodnotami uloženými ve vektoru, a to tehdy, když není možné použít minule
popsané operátory <i>reduce</i> a <i>scan</i>. Například budeme chtít vypočítat
meziměsíční rozdíly mezi tržbami nějaké firmy (tržby jsou uloženy ve vektoru
<i>Trzby</i>), a to jak v&nbsp;absolutních hodnotách, tak i rozdíly vyjádřené
v&nbsp;procentech poklesu či naopak vzrůstu. Nejprve si vytvoříme dva pomocné
vektory, z&nbsp;nichž jeden <strong>ne</strong>obsahuje první prvek původního
vektoru a druhý naopak <strong>ne</strong>obsahuje jeho prvek poslední.
Vytvoření pomocných vektorů zajistí funkce &bdquo;drop&ldquo; (bylo by sice
možné použít i funkci &bdquo;take&ldquo;, ale u té by se musela vypočítat délka
vektoru, což je zbytečně komplikované):</p>

<pre>
    Trzby &#8592; 56 59 67 64 60 61 68 73 78 75 81 84
    Trzby
56 59 67 64 60 61 68 73 78 75 81 84
    1 &#8595; Trzby
59 67 64 60 61 68 73 78 75 81 84
    &#175;1 &#8595; Trzby
56 59 67 64 60 61 68 73 78 75 81
</pre>

<p>Výpočet rozdílů mezi jednotlivými měsíčními tržbami je po získání pomocných
vektorů triviální, neboť tyto vektory stačí od sebe odečíst:</p>

<pre>
    (1 &#8595; Trzby) - (&#175;1 &#8595; Trzby)
3 8 &#175;3 &#175;4 1 7 5 5 &#175;3 6 3
</pre>

<p>Následuje vzorec pro výpočet růstu či poklesu tržeb vyjádřeného
v&nbsp;procentech, opět bez použití programových smyček a pomocných
proměnných:</p>

<pre>
    100 &times; ((1 &#8595; Trzby) &divide; (&#175;1 &#8595; Trzby)) - 1
5.35 13.56 &#175;4.48 ...
</pre>

<p>V&nbsp;případě nejistoty, zda se nejdříve provede odečtení jedničky od
mezivýsledku či vynásobení mezivýsledku hodnotou 100 si připomeňme, že
v&nbsp;jazyku <i>APL</i> se parametry všech funkcí vyhodnocují zprava doleva,
tj.&nbsp;nejdříve je od podílu odečtena jednička a teprve poté je proveden
převod na procentní vyjádření výsledku celého výpočtu (pomocí závorek se
samozřejmě dá pořadí vyhodnocování v&nbsp;případě potřeby upravit).</p>

<p><div class="rs-tip-major">Poznámka: idiomatický zápis by byl ovšem odlišný,
protože není vhodné opakovat dvakrát stejné jméno vstupního parametru,
v&nbsp;tomto případě vektoru <strong>Trzby</strong>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Šestice základních operátorů aplikovatelných na pole</h2>

<p>Dalším zajímavým a přitom velmi důležitým nástrojem vývojářů
v&nbsp;programovacím jazyce <i>APL</i> jsou vybrané <i>operátory</i>, pomocí
nichž je možné například aplikovat nějakou funkci na všechny prvky pole,
zkombinovat vzájemně všechny prvky v&nbsp;poli (z&nbsp;vektoru o <i>n</i>
prvcích se aplikací operátoru <i>inner product</i> stane matice o rozměrech
<i>n&times;n</i> prvků) atd. Právě díky těmto operátorům nemusí programátoři
tvořící aplikace v&nbsp;jazyku <i>APL</i> vytvářet programové smyčky, protože
například součet (sumu) či součin (produkt) všech prvků vektoru lze velmi
jednoduše zapsat pomocí dyadické funkce <i>+</i> nebo <i>&times;</i> aplikované
postupně na všechny prvky vstupního vektoru. Programovací jazyk <i>APL</i>
obsahuje šest základních operátorů, ovšem některé jeho modernější implementace
nabízí operátorů více (většinou osm). Šestice základních operátorů, se kterou
se můžeme setkat ve většině dialektů jazyka <i>APL</i>, je vypsána
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Operátor</th><th>Unicode</th><th>Jméno</th></tr>
<tr><td>&#168;  </td><td>00a8      </td><td>each</td></tr>
<tr><td>/       </td><td>002f      </td><td>slash, reduce</td></tr>
<tr><td>\       </td><td>005c      </td><td>backslash, scan</td></tr>
<tr><td>[]      </td><td>005b, 005d</td><td>axis</td></tr>
<tr><td>.       </td><td>002e      </td><td>inner product</td></tr>
<tr><td>&#9702;.</td><td>25e6, 002e</td><td>outer product</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: slovo <i>operátor</i> je zde tedy
použito k&nbsp;popisu funkce vyššího řádu.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Operátory &bdquo;reduce&ldquo; a &bdquo;scan&ldquo;</h2>

<p>Základním operátorem, využívaným v&nbsp;prakticky jakékoli aplikaci napsané
v&nbsp;programovacím jazyku <i>APL</i>, je operátor &bdquo;reduce&ldquo;
nazývaný také &bdquo;slash&ldquo; (druhý název tohoto operátoru vznikl ze
symbolu, kterým je operátor zapisovaný &ndash; <i>/</i>). Tento operátor se
zapisuje za symbol dyadické funkce a má ten význam, že vybranou funkci
postupně aplikuje (volá) na všechny prvky pole. Prvním argumentem každé
aplikace funkce je mezivýsledek (většinou skalární hodnota, prvním
mezivýsledkem je první prvek pole), druhým argumentem pak <i>n</i>-tý prvek
pole. Operátor <i>reduce</i> tedy předané pole zpracovává postupně, prvek po
prvku. Typickým příkladem může být výpočet sumy (součtu, v&nbsp;matematice
zapisovaný symbolem &Sigma;) všech prvků vektoru či součinu všech jeho prvků
(v&nbsp;matematice se používá symbol &Pi;). Tyto dvě často používané operace je
možné s&nbsp;využitím operátoru <i>reduce</i> naprogramovat v&nbsp;jazyku
<i>APL</i> velmi snadno bez použití programové smyčky a pomocných
proměnných:</p>

<pre>
    +/ 1 2 3 4
10
    &times;/ 1 2 3 4
24
</pre>

<p>Při použití operátoru <i>reduce</i> samozřejmě můžeme použít jakoukoli
dyadickou funkci, například i minule popsané funkce &#5285; a &#5290;, které
vrací větší popř.&nbsp;menší z&nbsp;obou předaných argumentů. Pokud se tyto
funkce postupně aplikují na celý vektor, vrátí největší nebo nejmenší prvek
tohoto vektoru:</p>

<pre>
    &#5285;/ 75 72 78 90 69 77 81 88
90

    &#5290;/ 75 72 78 90 69 77 81 88
69
</pre>

<p>Výpočet průměru řady čísel uložených ve vektoru je velmi jednoduchý když si
uvědomíme, že počet čísel, tj.&nbsp;délku vektoru, lze zjistit pomocí funkce
&rho;. Nejprve se tedy všechna čísla sečtou a následně se mezivýsledek vydělí
jejich počtem:</p>

<pre>
    X &#8592; 1 2 3 4 5
    (+/X)&divide;&rho;X
3
</pre>

<p>Nyní si ukažme, jakým způsobem se používá operátor <i>reduce</i> při práci
s&nbsp;maticemi. Při popisu tohoto operátoru jsme si řekli, že se postupně volá
nějaká vybraná funkce na všechny prvky pole. V&nbsp;případě vektoru byla
situace jednoduchá, protože prvkem vektoru byly přímo skalární hodnoty (čísla).
Pokud se však operátor <i>reduce</i> použije na dvourozměrné matice (podobně i
na vícedimenzionální struktury), jsou v&nbsp;tomto případě prvkem pole myšlené
celé vektory (řádky matice), na jejichž prvky je funkce aplikována (jinými
slovy &ndash; operátor je uplatňován na nejnižší dimenzi,
tj.&nbsp;sloupcích):</p>

<pre>
    Matice &#8592; 3 3 &rho; &iota; 9
    Matice
1 2 3
4 5 6
7 8 9

    +/ Matice
6 15 24
</pre>

<p>Součet všech prvků matice lze zajistit dvojím použitím operátoru
<i>reduce</i>. Jeho první aplikace zajistí součet všech hodnot na jednotlivých
řádcích matice, druhá aplikace operátoru sečte vektor součtů (6 15 24)
jednotlivých řádků:</p>

<pre>
    +/ +/ Matice
45
</pre>

<p>Sumu lze samozřejmě spočítat i pro vybraný sloupec či řádek matice, dokonce
je možné specifikovat dimenzi, ve které bude operátor uplatňován
(v&nbsp;případě dvourozměrných matic tak lze operátor aplikovat buď na sloupce
nebo na řádky bez nutnosti transpozice matice):</p>

<pre>
    +/ Matice[;1]
12

    +/[1] Matice
12 15 18
</pre>

<p>Dalším operátorem, se kterým se v&nbsp;tomto článku krátce seznámíme, je
operátor nazvaný <i>scan</i> nebo také <i>backslash</i>. Tento operátor je
v&nbsp;programech zapisovaných v&nbsp;jazyku <i>APL</i> reprezentován, jak již
ostatně jeho druhé jméno napovídá, obráceným lomítkem &ndash; <i>\</i>.
Operátor <i>scan</i> má chování podobné výše popsanému operátoru <i>reduce</i>,
ovšem s&nbsp;jedním podstatným rozdílem &ndash; zatímco v&nbsp;případě použití
operátoru <i>reduce</i> se dozvíme pouze celkový výsledek aplikace vybrané
funkce na pole, je u operátoru <i>scan</i> vrácen vektor všech mezivýsledků,
čehož je možné v&nbsp;některých případech využít a opět tak eliminovat potřebu
tvorby programových smyček. Tento operátor lze použít spolu s&nbsp;jakoukoli
dyadickou funkcí. Na následujících příkladech si povšimněte rozdílu
v&nbsp;chování obou operátorů:</p>

<pre>
    +/ 1 2 3 4 5
15

    +\ 1 2 3 4 5
1 3 6 10 15

    &times;/ &iota;4
24

    &times; \ &iota;4
1 2 6 24
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Operátor &bdquo;inner product&ldquo;</h2>

<p>Další z&nbsp;doposud nepopsaných operátorů je operátor &bdquo;inner product&ldquo; zapisovaný formou tečky okolo které se uvádí programátorem zvolená dvojice funkcí (může se jednat jak o uživatelské funkce, tak i o funkce primitivní). V&nbsp;podstatě se jedná o zobecněnou operaci násobení matic, ovšem s&nbsp;tím rozšířením, že obě aritmetické operace použité při násobení matic (tj.&nbsp;součin a součet) je při použití operátoru &bdquo;inner product&ldquo; možné zadat formou dvojice dyadických funkcí. To znamená, že pouze při použití cca dvaceti základních primitivních funkcí je možné vytvořit až 400 jejich kombinací a nahradit tak poměrně značnou část (nejenom maticových) algoritmů pouhou aplikací jednoho operátoru na dvojici funkcí.  Kromě násobení matic lze například pomocí &bdquo;inner productu&ldquo; vyjádřit hodnotu polynomu pro libovolné <i>x</i> (polynom je zadán vektorem koeficientů <i>a<sub>i</sub></i>) atd.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Operátor &bdquo;outer product&ldquo;</h2>

<p>Jedním z&nbsp;prozatím nepopsaných operátorů je operátor nazvaný &bdquo;outer product&ldquo; zapisovaný dvojicí symbolů &#9702;. (kolečko+tečka) za níž následuje jméno či symbol nějaké dyadické funkce. Tento operátor je založen na principu aplikace zvolené dyadické funkce na dvojici vektorů <i>x</i> a <i>y</i>, přičemž vybraná funkce je aplikována na všechny možné kombinace složek prvního a druhého vektoru. Výsledkem je matice <i>Z</i> obsahující v&nbsp;prvku <i>z<sub>ij</sub></i> návratovou hodnotu funkce aplikované na prvky <i>x<sub>i</sub></i> a <i>y<sub>j</sub></i>. Nejlépe si význam i princip práce tohoto operátoru vysvětlíme na příkladu, ve kterém se pokusíme vypsat část tabulky malé násobilky:</p>

<pre>
     1 2 3 4 5 &#9702;.&times; 1 2 3 4 5
1 2 3 4 5
2 4 6 8 10
3 6 9 12 15
4 8 12 16 20
5 10 15 20 25
</pre>

<p>Programátoři v&nbsp;<i>APL</i> by ale spíše napsali:</p>

<pre>
     (&iota;5)&#9702;.&times;(&iota;5)
1 2 3 4 5
2 4 6 8 10
3 6 9 12 15
4 8 12 16 20
5 10 15 20 25
</pre>

<p>V&nbsp;úvodní části dnešního článku jsme si uvedli i primitivní
funkci *, která slouží k&nbsp;umocnění dvou čísel, tj.&nbsp;provedení operace
<i>x<sup>y</sup></i>. Tabulku mocnin prvních čtyř přirozených čísel lze získat
snadno:</p>

<pre>
     (&iota;4)&#9702;.*(&iota;4)
1 1 1 1
2 4 8 16
3 9 27 81
4 16 64 256
</pre>

<p>Tento operátor je samozřejmě možné použít i v&nbsp;kombinaci s&nbsp;dalšími
funkcemi, nejenom s&nbsp;násobením a umocňováním. Poměrně často se používá
například ke konstrukci jednotkové matice či trojúhelníkové matice obsahující
pouze prvky s&nbsp;hodnotou 0 a 1. Konstrukce těchto matic je s&nbsp;využitím
výše uvedených porovnávacích (relačních) funkcí velmi snadná a rychlá:</p>

<pre>
     (&iota;5)&#9702;.=(&iota;5)
1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 0
0 0 0 0 1
     (&iota;5)&#9702;.&lt;(&iota;5)
0 1 1 1 1
0 0 1 1 1
0 0 0 1 1
0 0 0 0 1
0 0 0 0 0
     (&iota;5)&#9702;.&le;(&iota;5)
1 1 1 1 1
0 1 1 1 1
0 0 1 1 1
0 0 0 1 1
0 0 0 0 1
     (&iota;5)&#9702;.&ge;(&iota;5)
1 0 0 0 0
1 1 0 0 0
1 1 1 0 0
1 1 1 1 0
1 1 1 1 1
</pre>


<p><a name="k15"></a></p>
<h2 id="k15">15. Hierarchické datové struktury, komprese polí</h2>

<p>Ve všech předchozích příkladech jsme používali buď skalární hodnoty, vektory
(jednorozměrná pole) nebo pravidelné matice (dvourozměrná pole). Programovací
jazyk <i>APL</i> však ve svých moderních implementacích podporuje i
hierarchické datové struktury, které jsou ovšem stále reprezentovány pomocí
polí. Jednou z&nbsp;nejpoužívanějších struktur jsou vnořené seznamy, na které
se lze také dívat jako na &bdquo;zubaté&ldquo; pole, resp.&nbsp;jako na matici
s&nbsp;nestejně dlouhými řádky. Zápis takové struktury je velmi jednoduchý
(povšimněte si, že při inicializaci není nutné uvádět  dimenze ani velikost
pole):</p>

<pre>
DATA &#8592; (1 2 3) (4 5) (6 7) (8 9 10 11)
</pre>

<p>Předchozí struktura představuje vektor, jehož prvky jsou taktéž vektory.
Podobnou strukturu lze vytvořit i z&nbsp;matic &ndash; prvkem matice totiž může
být skalární hodnota, vektor, matice či pole o prakticky libovolné dimenzi
(většinou jsme omezeni 63 dimenzemi, takže se o skutečné omezení ani nejedná).
Následující příkaz vytvoří tabulku (matici) o dvou řádcích a třech sloupcích.
První prvek matice je taktéž maticí, tentokrát o velikosti 2&times;2 prvky,
druhý prvek je seznamem (vektorem) o pěti prvcích, třetí prvek je řetězcem
(seznamem šesti znaků) atd. Povšimněte si nutnosti uzávorkování některých
podvýrazů:</p>

<pre>
NEST &#8592; 2 3&rho;(2 2&rho;&iota;4) (&iota;5) 'HELLO!' (2 4&rho;&iota;8) 23 (3 2&rho; 'APL')
NEST
1 2       1 2 3 4 5  HELLO!
3 4

1 2 3 4          23  APL APL
5 6 7 8              APL APL
                     APL APL
</pre>

<p>Rozměr pole lze zjistit, jak už víme z&nbsp;předchozích částí seriálu,
pomocí monadické formy primitivní funkce &rho;:</p>

<pre>
&rho;NEST
2 3
</pre>

<p>Při práci s&nbsp;hierarchickými strukturami je někdy nutné zjistit stupeň
zanoření zpracovávané datové struktury. Pro zjištění stupně zanoření jakéhokoli
objektu zpracovávaného jazykem <i>APL</i> je určena funkce <i>depth</i>
zapisovaná pomocí symbolu &#8801;. Platí, že skalární hodnoty mají vždy stupeň
zanoření roven nule, kdežto pole (vektory, matice, ...) obsahující pouze
skalární hodnoty mají stupeň zanoření 1. Výše uvedené pole <i>NEST</i> má
stupeň zanoření roven dvěma, protože jako svůj prvek obsahuje matice.
Vlastnosti funkce &#8801; si můžeme snadno ověřit na několika hodnotách:</p>

<pre>
&#8801;42
0

&#8801;1 2 3
1

&#8801;2 2&rho;3 4 5 6
1

&#8801;NEST
2
</pre>

<p>S&nbsp;vektory či maticemi obsahujícími binární hodnoty úzce souvisí i
funkce provádějící takzvanou <i>kompresi</i> polí. Jedná se o dyadickou
primitivní funkci představovanou symbolem /, která na základě pole (vektoru,
matice) obsahujícího pouze binární hodnoty 0 nebo 1 vybere z&nbsp;jiného pole o
stejné dimenzi i velikosti ty prvky, u nichž je odpovídající binární hodnota
rovna jedničce. Nejlépe si funkci komprese pole ukážeme na jednoduchém
příkladu, ve kterém bude opět použit vektor <i>Prodeje</i>, s&nbsp;nímž jsme se
již setkali v&nbsp;předchozí kapitole:</p>

<pre>
    Prodeje &#8592; 1100 1200 1300 900 850 930 1050 970
    Prodeje
1100 1200 1300 900 850 930 1050 970
    0 1 0 1 0 1 0 1 / Prodeje
1200 900 930 970
</pre>

<p>Binární vektor lze samozřejmě získat na základě jiného příkazu; například je
možné vzít výsledek funkce porovnání (relace) popsané v&nbsp;předchozím
odstavci a na základě hodnoty výsledného binárního vektoru vybrat z&nbsp;pole
<i>Prodeje</i> jen hodnoty odpovídající zvolené podmínce:</p>

<pre>
    Prodeje &#8592; 1100 1200 1300 900 850 930 1050 970
    (Prodeje &gt; 1000) / Prodeje
1100 1200 1300 1050
</pre>

<p>V&nbsp;případě, že je zapotřebí získat indexy prvků a nikoli jejich hodnoty,
můžeme si vypomoci vektorem zkonstruovaným pomocí funkce &iota; (jóta) se
stejnou délkou, jako má původní vektor:</p>

<pre>
    Prodeje &#8592; 1100 1200 1300 900 850 930 1050 970
    Prodeje
1100 1200 1300 900 850 930 1050 970
    Prodeje &gt; 1000
1 1 1 0 0 0 1 0
    &rho;Prodeje
8
    &iota;&rho;Prodeje
1 2 3 4 5 6 7 8
</pre>

<p>Máme tedy dva mezivýsledky, oba ve formě vektoru o shodné délce (konkrétně
vektor 1 1 1 0 0 0 1 0 a 1 2 3 4 5 6 7 8), které je možné zkonstruovat a
současně i vzájemně zkombinovat v&nbsp;jednom příkazu a získat tak indexy prvků
odpovídajících zapsané podmínce:</p>

<pre>
    (Prodeje&gt;1000)/&iota;&rho;Prodeje
1 2 3 7
</pre>




<p><a name="k16"></a></p>
<h2 id="k16">16. Praktické vyzkoušení možností jazyka APL</h2>

<p>V&nbsp;současnosti je pravděpodobně nejpoužívanější variantou <i>APL</i>
<i>Dyalog</i>, což je komerční (a velmi dobré) vývojové prostředí, které lze
získat z&nbsp;adresy <a
href="https://www.dyalog.com/">https://www.dyalog.com/</a>. Ovšem pro
otestování možností <i>APL</i> není nutné si <i>Dyalog</i> instalovat, protože
je k&nbsp;dispozici webové prostředí dostupné na adrese <a
href="https://tryapl.org/">https://tryapl.org/</a>, které lze spustit přímo
z&nbsp;prakticky jakéhokoli moderního webového prohlížeče. Toto prostředí
mj.&nbsp;nabízí i trojí způsob zápisu základních funkcí a operátorů &ndash; buď
se vybírají z&nbsp;horního pruhu se symboly, nebo je možné použít dvojznaku
následovaného klávesou <strong>Tab</strong> popř.&nbsp;prefixového znaku
následovaného nějakým ASCII znakem. Obě poslední možnosti jsou uvedeny
v&nbsp;tabulce pro často používaný symbol &iota;:</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Jak myslet v&nbsp;APL &ndash; výpočet prvočísel netradičním způsobem</h2>

<p>Ukažme si nyní, jakým způsobem by bylo možné s&nbsp;využitím programovacího
jazyka <i>APL</i> napsat program pro výpočet prvočísel. Použijeme přitom pro
jednoduchost neidiomatickou formu zápisu, v&nbsp;níž se několikrát vyskytuje
mezivýsledek. Výsledný program pro výpočet prvočísel od 2 do hodnoty
<strong>x</strong> může vypadat následovně:</p>

<pre>
(∼R∈R∘.×R)/R←1↓⍳x
</pre>

<p>Pro jazyk <i>APL</i> je typické, že výsledný program nemusí být příliš
čitelný, zatímco jeho tvorba je (pro autora) zcela logická. Bude tedy vhodnější
si ukázat, jak vlastně tento program vznikl &ndash; protože myšlenkový postup
se dosti podstatným způsobem odlišuje od &bdquo;klasické&ldquo; implementace
generátoru prvočísel, který bývá založen na algoritmu <a
href="https://rosettacode.org/wiki/Sieve_of_Eratosthenes">Eratosthenova
síta</a>. V&nbsp;APL lze využít odlišného postupu (ale když se nad programem
zamyslíme, ve skutečnosti ne zcela odlišného &ndash; ve skutečnosti i zde
obdobu Eratosthenova síta najdeme, ovšem v&nbsp;&bdquo;maticové&ldquo;
podobě).</p>

<p>Jednotlivé kroky si postupně rozepíšeme:</p>

<table>
<tr><th>Krok</th><th>Zápis</th><th>Význam</th></tr>
<tr><td>1</td><td>⍳x</td><td></td></tr>
<tr><td>2</td><td>1↓⍳x</td><td></td></tr>
<tr><td>3</td><td>R←1↓⍳x</td><td></td></tr>
<tr><td>4</td><td>R∘.×R</td><td></td></tr>
<tr><td>5</td><td>R∊R∘.×R</td><td></td></tr>
<tr><td>6</td><td>~R∊R∘.×R</td><td></td></tr>
<tr><td>7</td><td>(~R∊R∘.×R)/R</td><td></td></tr>
</table>

x ← 10

⍳x
1 2 3 4 5 6 7 8 9 10

1↓⍳x
2 3 4 5 6 7 8 9 10

R←1↓⍳x
R
2 3 4 5 6 7 8 9 10

      R∘.×R
 4  6  8 10 12 14 16 18  20
 6  9 12 15 18 21 24 27  30
 8 12 16 20 24 28 32 36  40
10 15 20 25 30 35 40 45  50
12 18 24 30 36 42 48 54  60
14 21 28 35 42 49 56 63  70
16 24 32 40 48 56 64 72  80
18 27 36 45 54 63 72 81  90
20 30 40 50 60 70 80 90 100

R∊R∘.×R
0 0 1 0 1 0 1 1 1

~R∊R∘.×R
1 1 0 1 0 1 0 0 0

(~R∊R∘.×R)/R
2 3 5 7



<p><a name="k18"></a></p>
<h2 id="k18">18. Další programovací jazyky podporující práci s&nbsp;vektory a maticemi</h2>

<p>Práce s&nbsp;vektory a maticemi ovšem nebyla pouze doménou programovacího
jazyka <i>APL</i>. Objevila se již ve FORTRANu; ostatně překlad programů
s&nbsp;orientací na paralelní výpočty proběhl právě s&nbsp;FORTRANem (konkrétně
u superpočítačů vyráběných společností <i>Cray</i>). Nesmíme ale zapomenout ani
na ideového následníka <i>APL</i>, jímž je programovací jazyk nazvaný <i>J</i>.
Kromě dua <i>APL</i> a <i>J</i> (a na nich navazujících jazyků <i>K</i>,
<i>BQN</i> apod.) byly maticové operace součástí programovacího jazyka
<i>BASIC</i>, konkrétně jeho původní &bdquo;originální a jediné pravé&ldquo;
varianty nazvané <i>Dartmouth BASIC</i>, který ve své třetí verzi pocházející
z&nbsp;roku 1966 obsahoval deklaraci <strong>MAT</strong> doplňující již dříve
používanou deklaraci pole příkazem <strong>DIM</strong>. Zajímavé přitom je, že
se v&nbsp;BASICu operace pro deklaraci a práci s&nbsp;maticemi objevily dříve
než podpora řetězců, což bylo pravděpodobně způsobeno především tím, že oba
autoři BASICu (tedy jak John Kemeny, tak i Thomas Kurtz) byli matematici a
současně i vývojáři s&nbsp;velmi dobrou znalostí programovacího jazyka
FORTRAN.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;IT skutečně vše souvisí se vším a
většina &bdquo;nových a významných&ldquo; myšlenek se ve skutečnosti již
(dávno) objevila.</div></p>

<p>V&nbsp;současnosti je používáno relativně velké množství programovacích
jazyků popř.&nbsp;specializovaných knihoven orientovaných na práci
s&nbsp;vektory a poli. Z&nbsp;komerčních nástrojů je zapotřebí jmenovat
především známý <i>MATLAB</i> vydávaný společností <i>MathWorks</i> (ten má
matici již ve svém názvu), nativní práci s&nbsp;maticemi a vektory ovšem velmi
dobře podporuje také nástroj <a
href="https://www.gnu.org/software/octave/doc/interpreter/Matrices.html">GNU
Octave</a> (<a
href="https://gnu.org/software/octave/">https://gnu.org/software/octave/</a>),
<a href="http://www.ats.ucla.edu/stat/r/library/matrix_alg.htm">jazyk R</a> (<a
href="http://www.r-project.org/">http://www.r-project.org/</a>) a také
relativně nový jazyk <i>Julia</i> (<a
href="http://julialang.org/">http://julialang.org/</a>, zajímavé výsledky
benchmarků lze najít na adrese <a
href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>).
Z&nbsp;knihoven jmenujme především oblíbenou a dnes dosti intenzivně využívanou
Pythonovskou knihovnu <i>NumPy</i> (<a
href="http://www.numpy.org/">http://www.numpy.org/</a>).</p>

<p>Programovací jazyk <i>APL</i> do vývoje některých typů aplikací
(finančnictví, simulace, ...) přinesl mnoho nových myšlenek (ostatně i proto se
doposud používá), ale i několik nectností, ostatně jako každý programovací
jazyk, který vznikl na samotném začátku vývoje interpretrů a překladačů,
tj.&nbsp;v&nbsp;době, kdy ještě nebyla teorie překladačů tak rozvinutá jako
v&nbsp;pozdějších letech (nejvíce byla neexistence teorie překladačů patrná u
prvního překladače <i>Fortranu</i> firmou IBM, jehož vývoj by byl při uplatnění
dnešních znalostí mnohem rychlejší i levnější). Už při letmém pohledu na
programy napsané v&nbsp;programovacím jazyce <i>APL</i> je zřejmé, že se
v&nbsp;něm používá velké množství symbolů, které se nenachází ve znakové sadě
ASCII, což je sice velmi unikátní vlastnost (právě proto mnozí vývojáři
v&nbsp;<i>APL</i> programují čistě pro radost), ale způsobuje poměrně velké
problémy, a to jak při zápisu programů (rozložení znaků na klávesnici), tak i
při jejich úpravách, prezentaci na Internetu, protože zdaleka ne všechny fonty
obsahují všechny požadované symboly. Některé vlastnosti jazyka <i>APL</i> navíc
nebyly navrženy zcela dokonale &ndash; typickým příkladem je podpora pro
<i>tacit programming</i>, která ustrnula na půli cesty.</p>

<p>Z&nbsp;výše uvedených důvodů otec jazyka <i>APL</i> (již je v&nbsp;dnešním
článku mnohokrát zmiňovaný <i>Kenneth Iverson</i>) na počátku devadesátých let
minulého století navrhl nový programovací jazyk nazvaný jednoduše <i>J</i>,
který některé výše zmíněné nedostatky jazyka <i>APL</i> odstranil a navíc jazyk
rozšířil o některé důležité nové rysy, primitivní funkce i operátory.
Programovací jazyk <i>J</i> je, podobně jako jeho ideový předchůdce <i>APL</i>,
určen především pro tvorbu aplikací, v&nbsp;nichž se zpracovávají data uložená
ve vektorech, maticích či polích s&nbsp;větším počtem dimenzí (může se jednat
například o hierarchické mřížky atd.). Z&nbsp;tohoto důvodu je jazyk <i>J</i>
vybaven jak jednoduchou syntaxí určenou pro zápis vektorů a matic, tak i sadou
primitivních (základních) funkcí, pomocí nichž lze nad vektory i maticemi
provádět různé operace. Tento jazyk dnes existuje jak v&nbsp;komerční, tak i
volně dostupné variantě.</p>

<p><div class="rs-tip-major">Poznámka: i přes své jméno nemá jazyk <i>J</i>
prakticky nic společného s&nbsp;Javou ani s&nbsp;JavaScriptem.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p>O programovacím jazyku APL resp.&nbsp;o Iversonově notaci vzniklo mnoho
knih. V&nbsp;dnešním článku je udávám především z&nbsp;toho důvodu, že některé
z&nbsp;nich je možné najít i v&nbsp;tuzemských univerzitních nebo technických
knihovnách:</p>

<ol>

<li>Ajay Askoolum, &bdquo;<i>System Building with APL + WIN,</i>&ldquo;<br />Wiley, ISBN: 0-470-03020-8, August 2006.</li>

<li>Brown et. al. &bdquo;<i>APL2 at a Glance,</i>&ldquo;<br />Prentice Hall, ISBN 0-13-038670-7.</li>

<li>T. Budd, &bdquo;<i>An APL Compiler,</i>&ldquo;<br />Springer-Verlag.</li>

<li>Maurice Dalois, &bdquo;<i>Introduction to APL*PLUS PC,</i>&ldquo;</li>

<li>J. Ever and C. Fair, &bdquo;<i>Guidelines for APL Systems,</i>&ldquo;<br />DPD 22 IBM 037301, March 1976.</li>

<li>Gilman and Rose, &bdquo;<i>APL - An Interactive Approach,</i>&ldquo;<br /> Wiley, ISBN 220-471-30022-5.</li>

<li>Ulf Grenander, &bdquo;<i>Mathematical Experiments on the Computer,</i>&ldquo;<br />Academic Press, 1982, ISBN 0-12-301750-5.</li>

<li>Kent Haralson, &bdquo;<i>Useful APL Defined Functions</i>&ldquo;,<br />IBM Technical Report, TR 00.2409, Feb. 8 1973.</li>

<li>Timothy Holls, &bdquo;<i>APL Programming Guide,</i>&ldquo;<br />IBM G320-6103, 1978, and G320-6735, 1981.</li>

<li>IBM, &bdquo;<i>APL2 Programming: Language Reference</i>&ldquo;<br />(Version 2, SH21-1061; Version 1, SH20-9227).</li>

<li>IBM, &bdquo;<i>The APL Handbook of Techniques</i>&ldquo;,<br />IBM publication number S320-5996, April 1978.</li>

<li>IBM, &bdquo;<i>The IBM System Journal, V. 30, No. 4 (1991)</i>&ldquo;,<br />Special Issue Devoted to APL.</li>

<li>MicroAPL, &bdquo;<i>Learning APL with APLX</i>&ldquo;,<br />Version 5.0 July 2009</li>

<li>A.D. Falkoff, K.E Iverson, E.H Sussenguth, &bdquo;<i>A formal description of System/360,</i>&ldquo;<br />The IBM System Journal, V. 3, No. 3 (1964)</li>

<li>K. E. Iverson, &bdquo;<i>A Programming Language</i>&ldquo;,<br />Wiley, 1962.</li>

<li>K. E. Iverson, &bdquo;<i>Algebra : an algorithmic treatment</i>&ldquo;,<br />APL Press 1977, Copyright 1972 by Addison Wesley,<br />Preliminary Edition entitled &bdquo;<i>Elementary Algebra</i>&ldquo;<br />Copyright 1971 by IBM Corporation.</li>

<li>K. E. Iverson, &bdquo;<i>Elementary analysis</i>&ldquo;,<br />APL press 1976, Preliminary Edition &bdquo;<i>Elementary Functions</i>&ldquo;<br />Copyright 1974 by IBM Corporation ISBN 0-917326-01-6</li>

<li>K. E. Iverson, &bdquo;<i>An introduction to APL for Scientists and Engineers</i>&ldquo;,<br />APL Press 1976,<br />First published by IMB Corporation as Technical Report No 320-3019 March 1973 - ISBN 0-917326-04-0</li>

<li>K. E. Iverson, &bdquo;<i>APL in exposition</i>&ldquo;,<br />APL Press 1976,<br />First published by IBM Corporation as Technical Report No 320-3010 March 1973 - ISBN 0-917326-02-4.</li>

<li>K. E. Iverson, &bdquo;<i>Introduction To APL</i>&ldquo;,<br />(1984-APL Press Palo Alto) ISBN 0-917326-14-8.</li>

<li>K. E. Iverson, &bdquo;<i>A personal view of APL,</i>&ldquo;<br />IBM Systems Journal,</li>

<li> K. E. Iverson, &bdquo;<i>Concrete Mathematics Companion</i>&ldquo;.</li>

<li>S. Kamin, &bdquo;<i>Programming Languages: An Interpreter-Based Approach,</i>&ldquo;<br />contains (among other things) toy implementations of Lisp, APL, Scheme, SASL, CLU, Smalltalk, and Prolog, Addison-Wesley, 1990, ISBN 0-201-06824-9.</li>

<li>Bernard LEGRAND, &bdquo;<i>Les APL Etendus,</i>&ldquo;<br />Masson, Paris, 1994. An introduction to modern APL (French).</li>

<li>Jon McGrew, &bdquo;<i>An Introduction to APL2,</i>&ldquo;<br />IBM (SH20-9229).</li>

<li>James A. Mason, &bdquo;<i>Learning APL: An Array Processing Language,</i>&ldquo;<br />Harper &amp; Row Publishers Inc., New York, 1986, ISBN 0-06-044243-3 260 pp.</li>

<li>Peelle, &bdquo;<i>APL an Introduction</i>&ldquo;,<br />Holt, Rinehart &amp; Winston, ISBN 0-03-004953-9.</li>

<li>Reiter &amp; Jones, &bdquo;<i>APL with a Mathematical Accent</i>&ldquo;,<br />Brooks/Cole ISBN 0-534-12864-5, (now being distributed by Chapman &amp; Hall).</li>

<li>C. Reiter, &bdquo;<i>Fractuals Visualization and J</i>&ldquo;,<br />Iverson Software, Inc, 1995 ISBN 1-895721-11-3.</li>

<li>Adrian Smith, &bdquo;<i>APL, A Design Handbook for Commercial Systems,</i>&ldquo;<br />Wiley series in information processing, Wiley &amp; Sons, 1982, ISBN 0-471-10092-7.</li>

<li>D. Stiers, M.J. Goovaerts, J. De Kerf, &bdquo;<i>APL - The Language and its Actuarial Applications</i>&ldquo;</li>

<li>Norman D. Thomson, Raymond P. Polivka, &bdquo;<i>APL2 in Depth,</i>&ldquo;<br />Springer-Verlag, 1995, ISBN 0-387-94213-0.</li>

<li>Jerry R. Turner, &bdquo;<i>APL IS EASY!,</i>&ldquo;<br />Manugistics, 1993.</li>

<li>&bdquo;<i>SHARP APL Reference Manual,</i>&ldquo;<br />2nd ed., Soliton Associates Limited PC Version: Iverson Software, 1993, ISBN 1-895721-07-5.</li>

<li>&bdquo;<i>A Source Book in APL,</i>&ldquo;<br />APL Press, 1981, ISBN 0-917326-10-5.</li>

<li>&bdquo;<i>J Phrases,</i>&ldquo;<br />Iverson Software, 1996, ISBN 1-895721-12-1</li>

<li>&bdquo;<i>Exploring Math</i>&ldquo;, Iverson Software, 1996, ISBN 1-895721-13-X</li>

<li>&bdquo;<i>J Primer,</i>&ldquo;<br />Iverson Software, 1996, ISBN 1-895721-14-8</li>

<li>Linda Alvord and Norman Thomson, &bdquo;<i>Easy-J: An Introduction to the World's most Remarkable Programming Language</i>&ldquo;<br />October 2002</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 – An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>APL na replit<br />
<a href="https://replit.com/languages/apl">https://replit.com/languages/apl</a>
</li>

<li>Advent of Code 2020 in APL!<br />
<a href="https://www.youtube.com/watch?v=0RQFW6P1Tt0">https://www.youtube.com/watch?v=0RQFW6P1Tt0</a>
</li>

<li>Python vs APL (1 Problem)<br />
<a href="https://www.youtube.com/watch?v=APdKFJkmBbM">https://www.youtube.com/watch?v=APdKFJkmBbM</a>
</li>

<li>APL Wins (vs C++, Java &amp; Python)<br />
<a href="https://www.youtube.com/watch?v=59vAjBS3yZM">https://www.youtube.com/watch?v=59vAjBS3yZM</a>
</li>

<li>A Tour de Force of APL in 16 Expressions by Roger Hui<br />
<a href="https://www.youtube.com/watch?v=e0rywC7-i0U">https://www.youtube.com/watch?v=e0rywC7-i0U</a>
</li>

<li>Conway's Game Of Life in APL<br />
<a href="https://www.youtube.com/watch?v=a9xAKttWgP4">https://www.youtube.com/watch?v=a9xAKttWgP4</a>
</li>

<li>A List of companies that use Array Languages (J, K, APL, q)<br />
<a href="https://github.com/interregna/arraylanguage-companies">https://github.com/interregna/arraylanguage-companies</a>
</li>

<li>APL - one of the greatest programming languages ever<br />
<a href="http://www.vaxman.de/publications/apl_slides.pdf">http://www.vaxman.de/publications/apl_slides.pdf</a>
</li>

<li>"The J Programming Language" by Tracy Harms (2013)<br />
<a href="https://www.youtube.com/watch?v=RWYkx6-L04Q">https://www.youtube.com/watch?v=RWYkx6-L04Q</a>
</li>

<li>Dyalog Modern Programming Language, Morten Kromberg, Talks at Google<br />
<a href="https://www.youtube.com/watch?v=PlM9BXfu7UY">https://www.youtube.com/watch?v=PlM9BXfu7UY</a>
</li>

<li>The J Language: Consistency, Adjacency, and Solution-Oriented Programming - Tracy Harms<br />
<a href="https://www.youtube.com/watch?v=gLULrFY2-fI">https://www.youtube.com/watch?v=gLULrFY2-fI</a>
</li>

<li>Un-directed programming<br />
<a href="https://www.sacrideo.us/un-structured-programming/">https://www.sacrideo.us/un-structured-programming/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

