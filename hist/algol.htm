<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Šedesátiny převratného programovacího jazyka ALGOL-60</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Šedesátiny převratného programovacího jazyka ALGOL-60</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Prvním významným kulatým výročím, které si letos na Rootu připomeneme, jsou šedesáté narozeniny programovacího jazyka ALGOL-60. I když se dnes jedná o mrtvý jazyk, stál právě ALGOL-60 na začátku vývoje dvou větví programovacích jazyků &ndash; větve &bdquo;céčkové&ldquo; a &bdquo;pascalské&ldquo;.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Šedesátiny převratného programovacího jazyka ALGOL-60</a></p>
<p><a href="#k02">2. ALGOL ve stručnosti</a></p>
<p><a href="#k03">3. ALGOL-58 &ndash; jazyk inspirovaný Superplanem</a></p>
<p><a href="#k04">4. ALGOL-60</a></p>
<p><a href="#k05">5. Tři tváře ALGOLu</a></p>
<p><a href="#k06">6. Bloková struktura programů a lexikální rozsah platnosti</a></p>
<p><a href="#k07">7. Podmínky</a></p>
<p><a href="#k08">8. Programové smyčky</a></p>
<p><a href="#k09">9. Příkaz skoku (<strong>goto</strong> a <strong>go to</strong>)</a></p>
<p><a href="#k10">10. Volání hodnotou a volání jménem</a></p>
<p><a href="#k11">11. Další vývoj ALGOLu: rozkol v&nbsp;komisi</a></p>
<p><a href="#k12">12. ALGOL-68</a></p>
<p><a href="#k13">13. Algol-W</a></p>
<p><a href="#k14">14. Rozdíly mezi ALGOLem-60 a Algolem-W</a></p>
<p><a href="#k15">15. Od Algolu-W k&nbsp;Pascalu</a></p>
<p><a href="#k16">16. Komu vděčíme za složené závorky a operátory ++ a --?</a></p>
<p><a href="#k17">17. Vybrané vlastnosti programovacího jazyka &bdquo;B&ldquo;</a></p>
<p><a href="#k18">18. Vznik programovacího jazyka &bdquo;C&ldquo;</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Šedesátiny převratného programovacího jazyka ALGOL-60</h2>

<p><i>&bdquo;Here is a language so far ahead of its time that it was not only
an improvement on its predecessors but also on nearly all its
successors&ldquo;<br />
Sir Tony Hoare</i></p>

<p>V&nbsp;loňském roce jsme si na stránkách Roota připomněli trojici kulatých
výročí v&nbsp;oblasti programovacích jazyků. Po dvojici článků o <a
href="https://www.root.cz/clanky/tricet-let-od-vydani-revolucniho-turbo-pascalu-5-5/">třicátých
narozeninách Turbo Pascalu 5.5</a> a <a
href="https://www.root.cz/clanky/the-future-s-bright-the-future-s-cobol/">šedesátém
výročí vzniku programovacího jazyka COBOL</a> jsme si připomněli i sedmdesát
let, které <a
href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">uběhly
od vzniku nástroje</a>, který dnes nazýváme <i>assembler</i>. Některá podobně
významná (a možná i důležitější) výročí si postupně připomeneme i letos.
Zapomenout nesmíme především na programovací jazyk <i>ALGOL</i>, jehož
nejznámější varianta, která se jmenuje <i>ALGOL-60</i>, skutečně vznikla již
v&nbsp;roce 1960 s&nbsp;malými doplňky o dva roky později. Dnes se s&nbsp;tímto
programovacím jazykem prakticky nesetkáme, ovšem i přesto se jedná o jeden
z&nbsp;nejvýznamnějších programovacích jazyků, jaké kdy byly vytvořeny.</p>

<a href="http://i.iinfo.cz/images/529/4808.jpg"><img src="http://i.iinfo.cz/images/529/4808-prev.jpg" width="370" height="173" alt=" " /></a>
<p><i>Obrázek 1: Sálový počítač Burroughs B5000, který se primárně programoval
právě v&nbsp;Algolu.</i></p>

<p>S&nbsp;koncepcemi, které byly do ALGOLu zařazeny, se setkáme nejen
v&nbsp;jeho přímých následovnících (což je ve stručnosti Pascalská větev a
céčková větev), ale například i v&nbsp;mnoha LISPovských jazycích. Ty sice
tvoří samostatnou větev vývoje, ovšem z&nbsp;ALGOLu se do LISPovských jazyků
dostal především koncept lexikální oblasti platnosti identifikátorů. A jen na
okraj &ndash; právě na základě dvojice článků &bdquo;Report on the Algorithmic
Language ALGOL 60&ldquo; a &bdquo;Revised Report on the Algorithmic Language
Algol 60&ldquo; vznikla tradice, že se specifikace programovacího jazyka <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">Scheme</a>
vydává v&nbsp;článcích pojmenovaných &bdquo;Revised<sup>n</sup>Report on the
Algorithmic LanguageScheme&ldquo; s&nbsp;postupně rostoucí číslovkou
<i>n</i>.</p>

<p><div class="rs-tip-major">Poznámka: zvláštní je, že některé dobré myšlenky,
které v&nbsp;ALGOLu nalezneme, nebyly plně využity v&nbsp;navazujících
jazycích. Znovu byly &bdquo;objeveny&ldquo; až o několik desítek let
později.</div></p>

<a href="http://i.iinfo.cz/images/331/comp-hist-50-2.jpg"><img src="http://i.iinfo.cz/images/331/comp-hist-50-2-prev.jpg" width="370" height="150" alt=" " /></a>
<p><i>Obrázek 2: V&nbsp;pozadí tohoto snímku můžeme vidět moduly, v&nbsp;nichž
se nachází procesory, operační paměť (core memory) a taktéž vstupně-výstupní
kanály počítače Burroughs B5500. V&nbsp;popředí je dvojice řádkových tiskáren a
taktéž operátorská konzole.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. ALGOL ve stručnosti</h2>

<p>Jak jsme si již řekli v&nbsp;úvodním odstavci, je dnes ALGOL mrtvým jazykem,
ovšem přesto jazykem s&nbsp;velkým vlivem na další vývoj IT. Jedná se o
programovací jazyk, který původně vznikl za účelem snadno pochopitelného
algoritmického popisu matematických (především numerických) úloh, výuku
programování a vývoj překladačů (na rozdíl od C, který byl naopak zaměřen
přísně prakticky). Z&nbsp;tohoto důvodu například původní návrh jazyka (<i>IAL
&ndash; International Algorithmic Language</i>, později přejmenovaný na
<i>ALGOL 58</i>) zpočátku neobsahoval žádné konstrukce pro vstup a výstup dat,
ovšem se vznikem prvních reálných překladačů se množina konstrukcí jazyka
postupně rozrůstala, takže ve standardu <i>ALGOL 68</i> (poslední významný
standard ALGOLu, který se popravdě příliš nepovedl &ndash; více o tom za
chvíli), již jazyk obsahoval jak operace vstupu a výstupu, tak i podporu pro
nenumerické úlohy aj. V&nbsp;programovacím jazyce <i>ALGOL</i> byly prakticky
poprvé použity konstrukce umožňující strukturované programování &ndash; týká se
to především programových smyček bez návěští, podmíněných příkazů, blokové
struktury programu a též výše zmíněný koncept lexikálního rozsahu
(viditelnosti) proměnných (tuto vlastnost z&nbsp;<i>ALGOLu</i> převzal i
programovací jazyk <i>Scheme</i>, který je v&nbsp;v&nbsp;mnoha jiných ohledech
založený na <i>LISPu</i>).</p>

<img src="http://i.iinfo.cz/images/38/ibm-5-7.jpg" alt="ibm-5" height="193" width="140" />
<p><i>Obrázek 3: Jedna z&nbsp;populárních dobových učebnic ALGOLU 68.</i></p>

<p><i>ALGOL</i> se využíval jak pro zápis programů v&nbsp;učebnicích a
vědeckých článcích, tak i v&nbsp;každodenní programátorské praxi.
V&nbsp;tištěné literatuře se používal poněkud jiný způsob zápisu, protože bylo
možné použít typografické zvýraznění jednotlivých prvků jazyka i sadu znaků
velké a malé abecedy, zatímco některé mainframy používaly pouze znaky velké
abecedy (ve skutečnosti existují minimálně tři způsoby zápisu, podrobněji se
jimi budeme věnovat v&nbsp;navazujících kapitolách). Jednou ze zajímavostí je,
že se tento jazyk (resp.&nbsp;jeden z&nbsp;jeho dialektů) používal i
v&nbsp;SSSR, mj.&nbsp;také v&nbsp;projektu raketoplánu <i>Buran</i>. Tato verze
jazyka byla dokonce v&nbsp;SSSR standardizována jako <i>GOST 10859</i>.
Existuje i čínská verze tohoto jazyka, ve které se namísto znaků z&nbsp;tabulek
ASCII či EBDIC používají národní znaky.</p>

<p><div class="rs-tip-major">Poznámka: zde je patrné, že ALGOL byl chápán spíše
jako koncept a ne jako konkrétní jazyk s&nbsp;pevně danou syntaxí a
sémantikou.</div></p>

<p>Programovacím jazykem <i>ALGOL</i> se inspirovali tvůrci mnoha dalších
programovacích jazyků. Jedná se například o jazyky <i>Simula</i>, <i>Pascal</i>
(i další jazyky navržené N. Wirthem) a v&nbsp;neposlední řadě též trojice na
sebe navazujících jazyků <i>BCPL</i>, <i>B</i> a <i>C</i>. Na syntaxi céčka
jsou postaveny další jazyky, zejména <i>C++</i>, <i>Java</i> a dokonce
dynamicky typovaný <i>JavaScript</i>. Těmto jazykům se proto také někdy říká
&bdquo;algolské&ldquo; (Algol-like) nebo též jazyky patřící do algolské
větve.</p>

<p>Na následujícím výpisu krátkého programu (jedná se o známý <a
href="https://www.root.cz/clanky/framebuffer-na-raspberry-pi-vykreslovani-slozitejsich-objektu/#k04">Bresenhamův
algoritmus rasterizace úsečky</a>) si povšimněte, že je celý program snadno
pochopitelný i v&nbsp;případě, že jazyk <i>ALGOL</i> neznáte. Mnoho konstrukcí
<i>ALGOLu</i> totiž skutečně &bdquo;zdomácnělo&ldquo; i v&nbsp;dalších
programovacích jazycích. Poznámka: zde je použitý dialekt <i>ALGOL 68</i>, při
použití <i>ALGOLu 60</i> by se například programové smyčky zapisovaly odlišným
způsobem.</p>

<pre>
PRAGMAT READ "Basic_bitmap_storage.a68" PRAGMAT;
&nbsp; 
line OF class image := (REF IMAGE picture, POINT start, stop, PIXEL color)VOID:
BEGIN
   REAL dx = ABS (x OF stop - x OF start),
        dy = ABS (y OF stop - y OF start);
   REAL err;
   POINT here := start,
         step := (1, 1);
   IF x OF start &gt; x OF stop THEN
      x OF step := -1
   FI;
   IF y OF start &gt; y OF stop THEN
      y OF step := -1
   FI;
   IF dx &gt; dy THEN
      err := dx / 2;
      WHILE x OF here /= x OF stop DO
         picture[x OF here, y OF here] := color;
         err -:= dy;
         IF err &lt; 0 THEN
            y OF here +:= y OF step;
            err +:= dx
         FI;
         x OF here +:= x OF step
      OD
   ELSE
      err := dy / 2;
      WHILE y OF here /= y OF stop DO
         picture[x OF here, y OF here] := color;
         err -:= dx;
         IF err &lt; 0 THEN
            x OF here +:= x OF step;
            err +:= dy
         FI;
         y OF here +:= y OF step
      OD
   FI;
   picture[x OF here, y OF here] := color # ensure dots to be drawn #
END # line #;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. ALGOL-58 &ndash; jazyk inspirovaný Superplanem</h2>

<p><i>&bdquo;ALGOL is probably the most influential language you’ve never heard
of.&ldquo;</i></p>

<p>Práce na vývoji programovacího jazyka, který později dostal název
<i>ALGOL</i>, začala již na konci padesátých let minulého století. Tehdy se na
konferenci v&nbsp;Curychu sešla skupina význačných osobností z&nbsp;oblasti IT,
aby navrhli programovací jazyk vhodný primárně pro <i>popis algoritmů</i>. Mezi
účastníky konference a současně i autory první varianty ALGOLu patřili
Friedrich L. Bauer, Hermann Bottenbruch, Heinz Rutishauser, Klaus Samelson,
John Backus, Charles Katz, Alan Perlis, Joseph Henry Wegstein (povšimněte si,
že se tehdy o vývoji IT rozhodovalo jak v&nbsp;USA, tak i v&nbsp;Evropě).</p>

<p>Z&nbsp;těchto osobností je důležité zmínit především <a
href="https://en.wikipedia.org/wiki/Heinz_Rutishauser">Heinze Rutishausera</a>,
který v&nbsp;letech 1949 až 1951 vyvinul vyšší programovací jazyk pojmenovaný
<i>Superplan</i>. V&nbsp;tomto programovacím jazyku se mj.&nbsp;používalo
klíčové slovo <strong>Für</strong> pro počítanou programovou smyčku. A
poangličtěná varianta tohoto klíčového slova (tedy <strong>for</strong>) se
dostala jak do ALGOLu, tak i do prakticky všech moderních programovacích jazyků
(původní FORTRAN měl smyčku realizovanou slovem <strong>do</strong>, LISP byl
založen na rekurzi a tedy smyčky původně nepodporoval).</p>

<p>Mezi další osobnost, která stála za vznikem ALGOLu, zmiňme Johna Backuse,
který se předtím podílel mj.&nbsp;i na vývoji FORTRANu. John Backus přišel se
zajímavou myšlenkou &ndash; pro popis syntaxe ALGOLu navrhl formalizovaný
způsob zápisu, jenž je dnes známý pod jménem <i>Backusova-Naurova forma</i>
neboli <i>BNF</i>. Oproti pouhému textovému popisu se jedná o velké vylepšení,
které pomáhá jak vývojářům překladače, tak i samotným programátorům, neboť jim
usnadňuje nalezení chyb.</p>

<p>Dnes se <i>BNF</i> popř.&nbsp;rozšířená varianta <i>EBNF</i> stále používá.
Nalezneme ji například ve <a
href="https://golang.org/ref/spec#Notation">specifikaci programovacího jazyka
Go</a>, <a
href="http://www.cs.kent.edu/~durand/CS43101Fall2004/resources/Pascal-EBNF.html">Pascalu</a>
nebo <a href="http://www.lua.org/manual/5.1/manual.html#8">programovacího
jazyka Lua</a>.</p>

<p>Výše zmíněná komise původně pracovala na návrhu jazyka se jménem <i>IAL</i>
neboli <i>International Algebraic Language</i>. Později se ovšem (velmi
rozumně) shodli na tom, že se jedná o těžko vyslovitelný název, který je navíc
poněkud nabubřelý. Namísto <i>IAL</i> byl tedy zvolen hezčí, vyslovitelný a
snadno zapamatovatelný název <i>ALGOL</i> neboli <i>ALGOrithmic Language</i>, i
když někomu může připadat mírně hrozivý (hvězda Algol &ndash; hlava démona
&ndash; totiž nemá v&nbsp;některých kulturách dobrou pověst).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. ALGOL-60</h2>

<p><i>&bdquo;The meetings were exhausting, interminable, and exhilarating. One
became aggravated when one's good ideas were discarded along with the bad ones
of others. Nevertheless, diligence persisted during the entire period. The
chemistry of the 13 was excellent.&ldquo;</i></p>

<p>Samotný ALGOL-58 původně nebyl ani implementovaný [*], i když vývoj
překladače byl zahájen minimálně ve firmě IBM. Jinak tomu ovšem bylo
v&nbsp;případě ALGOLu-60, jehož návrh &ndash; jak již zajisté tušíte &ndash;
vznikl právě v&nbsp;roce 1960. Opět se sešla komise, která se skládala jak
z&nbsp;původních členů výboru z&nbsp;roku 1958, tak i z&nbsp;několika členů
nových: J. W.  Backus, F. L. Bauer, J. Green, H. Rutishauser, C. Katz, K.
Samelson, J. McCarthy, B. Vauquois, A. J. Perlis, J. H. Wegstein A. van
Wijngaarden M. Woodger. Výsledkem byl článek &bdquo;Report on the Algorithmic
Language ALGOL 60&ldquo;, v&nbsp;němž je popsána jak syntaxe (BNF), tak i
sémantika nového programovacího jazyka.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti existovala jedna
implementace ALGOLu-58. Vznikla až v&nbsp;roce 1961 a jmenovala se Dartmouth
ALGOL 30. Za jejím vznikem stojí Thomas Eugene Kurtz, který se později
mj.&nbsp;podílel i na vzniku <a
href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/#k01">BASICu</a>.</div></p>

<img src="https://i.iinfo.cz/images/55/algol-60-1.png" class="image-402359" alt="&#160;" width="607" height="159" />
<p><i>Obrázek 4: Vývoj programovacích jazyků, jejichž prapředkem je
ALGOL-58.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tři tváře ALGOLu</h2>

<p>ALGOL je poněkud zvláštní a mnohdy i matoucí tím, že jeho syntax existuje ve
třech rozdílných variantách, které se nazývají <i>reference syntax</i>,
<i>publication syntax</i> a <i>implementation syntax</i>. Referenční syntax je
použita především v&nbsp;oficiálním &bdquo;Reportu&ldquo; (viz též předchozí
kapitoly), publikační syntax je použita v&nbsp;článcích, při ukázce algoritmů
na tabuli (slajdech) atd. A implementační syntax se liší podle použitého
počítače a jeho schopností (znaková sada atd.). Kvůli této trojí syntaxi se
zápis algoritmů v&nbsp;článcích a knihách mnohdy dosti podstatným způsobem
odlišuje od zápisu pro konkrétní počítač. Navíc to umožňuje měnit
(v&nbsp;článcích i konkrétní  implementaci) klíčová slova a nahrazovat je za
národní varianty, používat desetinnou čárku namísto desetinné tečky atd.</p>

<p>Příkladem mohou být aritmetické operátory, které v&nbsp;tištěné podobě mají
tvar:</p>

<pre>
↑    (mocnina)
×, / (real), ÷ (integer)
+, -
</pre>

<p>V&nbsp;konkrétní implementaci (zde na počítačích IBM) se však zápis mění:</p>

<pre>
**    (mocnina)
*, / (real), / (integer)
+, -
</pre>

<p>Podobně je rozdíl mezi tiskovou podobou relačních operátorů:</p>

<pre>
&lt;, ≤, =, ≥, &gt;, ≠
</pre>

<p>které nelze v&nbsp;mnoha znakových sadách zapsat.</p>

<p>Nejzajímavější jsou rozdíly v&nbsp;logických operátorech:</p>

<pre>
¬ (not)
∧ (and)
∨ (or)
⊃ (implication)
≡ (equivalence) 
</pre>

<p>Mj.&nbsp;i kvůli nutnosti zápisu operátorů and a or byl do ASCII tabulky
přidán symbol \, takže bylo možné psát:</p>

<pre>
/\ (and)
&nbsp;
\/ (or)
</pre>

<p>Tím se dostáváme k&nbsp;tomu, proč vlastně existovalo několik způsobů
zápisu. Problém spočívá v&nbsp;tom, že v&nbsp;roce 1960 vlastně neexistoval
uznávaný standard v&nbsp;oblasti znakové sady, protože například EBCDIC měla
několik variant atd. Samotná práce na unifikované znakové sadě, kterou dnes
známe pod jménem ASCII, začala právě v&nbsp;roce 1960, první verze byla
publikována v&nbsp;roce 1963 a poslední revize vyšla v&nbsp;roce 1967. Není
tedy divu, že tvůrci ALGOLu měli poměrně volné ruce (a mohli docela dobře
předpokládat, že se do normy později dostanou minimálně všechny relační
operátory a nikoli jenom tři z&nbsp;nich &ndash; ostatně způsob zápisu ≠
existuje v&nbsp;různých programovacích jazycích minimálně v&nbsp;sedmi
variantách).</p>

<p><div class="rs-tip-major">Poznámka: mimochodem, operátor mocniny je
vyhodnocován jinak, než například v&nbsp;Pythonu:</div></p>

<pre>
&gt;&gt;&gt; 2**3**2
512
&gt;&gt;&gt; 2**(3**2)
512
&gt;&gt;&gt; (2**3)**2
64
</pre>

<p>Zatímco v&nbsp;ALGOLu zápis 2↑x↑y znamená (2<sup>x</sup>)<sup>y</sup>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Bloková struktura programů a lexikální rozsah platnosti</h2>

<p>ALGOL byl prvním rozšířeným programovacím jazykem, který striktně zavedl
blokovou strukturu programů, tedy konstrukci, kterou používáme dodnes. Bloky
byly určeny klíčovými slovy <strong>begin</strong> a <strong>end</strong> a
mohly být vnořené:</p>

<pre>
begin
comment block in main block;
    begin
        real x;
        x := 1.234;
        outreal(1,x); outstring (1,"\n")
    end
end
</pre>

<p>Někdy se setkáme s&nbsp;odlišným odsazením, v&nbsp;němž se blok začíná
zapisovat přímo za slovo <strong>begin</strong> (odpadají tak hádky, o kolik
mezer odsazovat):</p>

<pre>
begin
comment block in main block;
      begin real x;
            x := 1.234;
            outreal(1,x); outstring (1,"\n")
      end
end
</pre>

<p>S&nbsp;bloky souvisí i rozsah platnosti proměnných, který je stanoven
lexikálně (v&nbsp;čase překladu) a nikoli dynamicky (v&nbsp;době běhu).
V&nbsp;následujícím bloku kódu existují dvě proměnné <strong>x</strong>, každá
s&nbsp;odlišnou viditelností:</p>

<pre>
begin integer x;
      x := 1;
      begin outinteger(1,x);
      end;
      begin integer x;
            x := 2;
            outinteger(1,x);
      end;
      outinteger(1,x);
end 
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Podmínky</h2>

<p>Do ALGOLu byly zařazeny příkazy pro zápis podmínek, které jsou založeny na
vyhodnocení pravdivostního výrazu, který určuje, do jaké větve
(&bdquo;then&ldquo; nebo &bdquo;else&ldquo;) se řízení programu přesune.
Pravděpodobně si říkáte, že se nejedná o velký objev, ovšem například ve
FORTRANu se v&nbsp;té době používal takzvaný &bdquo;aritmetický IF&ldquo;
s&nbsp;několika nepříjemnými vlastnostmi (zejména se to týkalo určení hodnoty,
která už je nulová), nehledě na to, že IF pokračoval skokem. IF založený na
pravdivostní hodnotě byl zařazen až do FORTRANu IV, který vyšel až v&nbsp;roce
1961, tedy po ALGOLu.</p>

<p>Zápis podmínky s&nbsp;větvemi <strong>then</strong> i <strong>else</strong>
vypadá takto:</p>

<pre>
begin integer n;
      ininteger(0,n);
      if n &lt; 0 then outstring(1,"negative")
      else outstring(1, "0 or positive");
      outstring(1,"\n")
end
</pre>

<p><div class="rs-tip-major">Poznámka: jak si možná někteří pamatují
z&nbsp;výuky Pascalu, před <strong>else</strong> se nepíše středník.</div></p>

<p>Podmínky je možné zanořovat a vytvářet ve větvích nové bloky, což je také
novinka:</p>

<pre>
begin integer n, m;
      ininteger(0,n);
      if n &lt; 0 then 
      begin
            if n&gt;= -2 then m := -n else m := -2
      end
      else m := 0; 
      outinteger(1, m); outstring(1,"\n")
end
</pre>

<p>A konečně &ndash; samotný zápis podmínky lze použít ve výrazu, což je
kupodivu konstrukce, která se do mnoha dalších jazyků inspirovaných ALGOLem
nedostala (objevuje se až později ve tvaru ternárního operátoru):</p>

<pre>
begin integer n, m;
      ininteger(0,n);
      m := if n &lt; 0 then -n else n; 
      outinteger(1, m);
end
</pre>

<p><div class="rs-tip-major">Poznámka: funkce <strong>ininteger</strong> a
<strong>outinteger</strong> slouží pro čtení resp.&nbsp;zápis do zvoleného
<i>handle</i> (zde standardního vstupu a výstupu).</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Programové smyčky</h2>

<p><i>&bdquo;ALGOL is not a language you need to learn to get a job or to be a
successful developer. However, it was hugely influential on both the practice
and theory of computer programming.&ldquo;</i></p>

<p>Pro zápis programových smyček se používalo klíčové slovo
<strong>for</strong> (odvozené od staršího <strong>Für</strong>), které bylo
doplněno o <strong>step</strong>, <strong>while/until</strong> a
<strong>do</strong>. Použití je snadné (v&nbsp;mnoha jazycích je ovšem
<strong>until</strong> nahrazeno za <strong>to</strong>):</p>

<pre>
begin integer n, m, i, s;
      real sum;
      ininteger(0,n);
&nbsp;
      for i:=1 step 1 until n do
      begin
            sum := sum + i
      end
&nbsp;
      outinteger(1, s); 
end
</pre>

<p>V&nbsp;dále zmíněném ALGOLu-W by zápis vypadal takto:</p>

<pre>
begin
    integer i;
    i := 1024;
    while i &gt; 0 do
    begin
        write( i );
        i := i div 2
    end
end.
</pre>

<p>Pro implementaci nekonečné smyčky je možné použít malého triku &ndash; zde
se hodnoty 2 nikdy nedosáhne, protože je použit krok 0:</p>

<pre>
begin integer i;
      for i:=1 step 0 until 2 do 
          outtext("***")
end
</pre>

<p>V&nbsp;dále zmíněném ALGOLu-W by zápis vypadal takto:</p>

<pre>
begin
    for i := 1 step 0 until 2 do write( "***" )
end.
</pre>

<p>Smyčky je možné vnořovat:</p>

<pre>
procedure Absmax(a) Size:(n, m) Result:(y) Subscripts:(i, k);
    value n, m; array a; integer n, m, i, k; real y;
begin integer p, q;
      y := 0; i := k := 1;
      for p := 1 step 1 until n do
          for q := 1 step 1 until m do
              if abs(a[p, q]) &gt; y then
                  begin y := abs(a[p, q]);
                      i := p; k := q
                  end
end Absmax
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Příkaz skoku</h2>

<p>V&nbsp;ALGOLu se používal i příkaz skoku, především pro implementaci
složitějších programových smyček. Pro tento účel se používalo klíčové slovo
<strong>goto</strong>, někdy též dvousloví <strong>go to</strong>:</p>

<pre>
begin
        integer n;
        n := 0;
start:;
        if n = 20 then goto finish
        else 
        begin n := n + 1;
              outinteger(1, n);
              goto start
        end;
finish:;
        outstring(1,"\n")
end
</pre>

<p>Na cíle skoků (návěští neboli <i>label</i>) však byla kladena stejná
pravidla, jako na lokální proměnné. Jinými slovy &ndash; návěští byla viditelná
jen v&nbsp;rámci svého bloku. To automaticky znamenalo, že nebylo možné skočit
<i>dovnitř</i> bloku, ovšem naopak bylo možné z&nbsp;bloku vyskočit. Toto
jednoduše pochopitelné pravidlo (které se nijak nevymyká lexikální viditelnosti
proměnných) se kupodivu do některých dalších po-algolských jazyků
nedostalo.</p>

<p>Příkladem je jazyk C, v&nbsp;němž je následující program přeložitelný i
spustitelný:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
void main(void)
{
    goto inside;
    {
        int i;
        for (i=0; i!=10; i++) {
            puts("*");
inside:
            puts("inside");
        }
    }
}
</pre>

<p>Nebo Turbo Pascal, jehož koncepce bloků je převzata z&nbsp;ALGOLu:</p>

<pre>
program goto_test;
&nbsp;
label
    inside;
var
    i:integer;
&nbsp;
begin
    goto inside;
&nbsp;
    for i := 1 to 10 do
    begin
        writeln(i);
        inside:
        writeln('inside');
    end;
    readln;
end.
</pre>

<p>Ovšem neplatí to pro Go:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var i int
        goto inside
        for i = 0; i != 10; i++ {
                fmt.Println("*")
        inside:
                fmt.Println("inside")
        }
}
</pre>

<p>Výsledek pokusu o překlad:</p>

<pre>
./goto.go:7:7: goto inside jumps into block starting at ./t.go:8:25
</pre>

<img src="https://i.iinfo.cz/images/55/algol-60-2.png" class="image-402360" alt="&#160;" width="640" height="400" />
<p><i>Obrázek 5: Skoky v&nbsp;Turbo Pascalu 7.0.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Volání hodnotou a volání jménem</h2>

<p>Pravděpodobně nejproblematičtějším rysem ALGOLu (minimálně pro tvůrce
překladačů) byl způsob volání funkcí a procedur (kde procedura je funkce, která
nevrací hodnotu). V&nbsp;ALGOLu existují dva způsoby předávání parametrů
funkcím a procedurám. První způsob se jmenuje předávání jménem
(<i>call-by-name</i> nebo možná přesněji <i>pass-by-name</i>) a druhý předávání
hodnotou (<i>call-by-value</i>, <i>pass-by-value</i>) neboli přiřazením.
Nejdříve si ukažme druhý způsob, protože ten se z&nbsp;ALGOLu (a LISPu)
rozšířil i do většiny dalších programovacích jazyků. Ještě před zavoláním
funkce/procedury jsou parametry vyhodnoceny a je předána jejich výsledná
hodnota, což známe i z&nbsp;dalších programovacích jazyků. Předání jménem je
složitější &ndash; celý parametr (což může být složitý výraz) je do volané
funkce předán tak, jak je zapsán a v&nbsp;těle funkce je jméno parametru tímto
výrazem nahrazeno, jakoby se jednalo o expanzi makra (což je právě pro
překladač složité). O tom, jak se parametry předávají, může programátor
rozhodnout použitím klauzule <strong>value</strong>.</p>

<p>Podívejme se na příklad:</p>

<pre>
procedure sum(suc, alfa, i, a, b);
    value a, b;
    real alfa, suc;
    integer i, a, b;
    begin suc := 0;
          for i := a step 1 until b do
              suc := suc + alfa;
    end
</pre>

<p>Této proceduře se předává pět parametrů, přičemž parametry
<strong>a</strong> a <strong>b</strong> jsou předány hodnotou (jako
v&nbsp;běžných jazycích) a zbylé parametry jménem neboli &bdquo;textovou
expanzí&ldquo;. Pokud tuto proceduru zavoláme stylem:</p>

<pre>
sum(result, u+v/2, counter, 10*x, 10*y+5)
</pre>

<p>bude se procedura vykonávat zhruba tak, jakoby se jednalo o tento kód
zapsaný přímo do místa volání:</p>

<pre>
a := 10*x;
b := 10*y+5;
begin result := 0;
      for counter := a step 1 until b do
          result := result + u+v/2
end
</pre>

<p>V&nbsp;později vytvořených algolských jazycích bylo volání jménem nahrazeno
za volání odkazem (což je případ Pascalu), popř.&nbsp;bylo zavedeno pouze
volání hodnotou, ovšem s&nbsp;tím, že lze získat ukazatel na libovolnou
proměnnou (C, Go).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Další vývoj ALGOLu: rozkol v&nbsp;komisi</h2>

<p>ALGOL-60 se stal poměrně populární a dobře doplňoval ostatní dva dobové
mainstreamové jazyky &ndash; FORTRAN a LISP. Po vydání &bdquo;Reportu&ldquo; o
ALGOLu-60 vznikla pracovní skupina, která měla za úkol navrhnout další verzi
ALGOLu. V&nbsp;roce 1966 se komise rozhodovala mezi trojicí návrhů. Jeden
z&nbsp;návrhů podal Niklaus Wirth, další byl podán Van Wijngaarden, o němž jsme
se již zmínili v&nbsp;souvislosti s&nbsp;originálním ALGOLem. Zatímco Wirthův
návrh směřoval spíše ke zjednodušení jazyka, byl Van Wijngaardenův návrh mnohem
komplexnější a představoval vlastně zcela nový jazyk. A právě tento návrh byl
přijat jako základ pro jazyk později pojmenovaný C++^H^H^H ALGOL
68.</p>

<p>Toto rozhodnutí nebylo přijato všemi členy komise s&nbsp;nadšením
(diplomaticky řečeno). Hlavními kritiky byl jak Wirth, tak i (a to možná
především) C.A.R. Hoare. Tito dva členové komisi opustili a mezi řádky můžeme
číst, že se nejednalo o přátelské rozloučení. Wirth poté pokračoval ve vývoji
vlastního jazyka, který vešel ve známost pod jménem ALGOL-W (paradoxní je, že i
Van Wijngaarden mohl vytvořit jazyk se stejným jménem).</p>

<a href="https://www.root.cz/obrazek/402361/"><img src="https://i.iinfo.cz/images/55/algol-60-3-prev.png" class="image-402361" alt="&#160;" width="370" height="198" /></a>
<p><i>Obrázek 6: Snímek <a
href="https://www.youtube.com/watch?v=Og847HVwRSI">z&nbsp;videa</a> vývoje
popularity programovacích jazyků.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. ALGOL-68</h2>

<p><i>&bdquo;The complexity of Algol 68, intrinsic to it, has contributed to
the fact that the language was nested primarily in the academic and university
environment and did not find a large support in the industry. There was a
danger that Algol 68 could have become an object of purely mathematical
investigations with all closeness proper to them.&ldquo;</i></p>

<p>Jak již bylo naznačeno v&nbsp;předchozím textu, vedl návrh ideového
pokračovatele ALGOLu-60 ke vzniku jazyka, který byl pojmenován ALGOL-68.
Jednalo se o jazyk velmi komplikovaný, což brzdilo jeho zavedení do praxe
&ndash; týkalo se to jak výrobců překladačů, tak i potenciálních uživatelů.
Ostatně samotný popis tohoto jazyka měl několik set stránek psaných dosti
těžkopádným stylem; porovnejte například <a
href="https://www.lua.org/manual/5.3/manual.html#9">s&nbsp;popisem jazyka
Lua</a>, který se vejde na dvě stránky nebo <a
href="http://www.cheat-sheets.org/saved-copy/go-lang-cheat-sheet-master.20181212/golang_refcard.pdf">s&nbsp;cheatsheetem
k&nbsp;jazyku Go</a>, který má stran šest (i když nejde o tak rigorózní popis,
jako u ALGOLu-68, prakticky všem programátorům postačí). Pro popis jazyka byla
zavedena nová notace (W-Grammar podle jejího autora Adriaana van Wijngaardena,
s&nbsp;nímž jsme se již setkali), v&nbsp;níž se nepopisovaly pouze sekvence
klíčových slov a dalších identifikátorů (BNF, EBNF), ale i datový typ platný
v&nbsp;daném kontextu. Samotný ALGOL-68 sice byl implementovaný, a to vícekrát,
ovšem stále se u něj opakovalo tvrzení &bdquo;no implementations and no
users&ldquo;.</p>

<p>Nutno poznamenat, že se v&nbsp;ALGOLu-68 objevilo mnoho konceptů, které byly
až později přidány do dalších jazyků. Příkladem může být operátor
<strong>PLUSAB</strong> neboli <i>‘PLUS And Becomes</i>, který odpovídá
céčkovskému += (a podobně i další aritmetické operátory). Najdeme zde i
koncept, kdy se začátek nějaké konstrukce ukončuje stejným klíčovým slovem,
ovšem napsaným pozpátku (viz též adopce tohoto způsobu v&nbsp;BASHi):</p>

<pre>
IF bool THEN some_expression ELSE other_expression FI
CASE intvalue IN expr1, expr2, …, exprN OUT  another expr ESAC
</pre>

<p>Příklad použití:</p>

<pre>
days in month :=
  CASE month OF date IN
    31,
    IF is leap year( year OF date ) THEN 29 ELSE 28
    FI,
    31, 30, 31, 30, 31, 31, 30, 31, 30, 31
  ESAC
</pre>

<p><div class="rs-tip-major">Poznámka: vtipkuje se, že je dobře, že autoři
jazyka tento koncept nedovedli do důsledků, protože by se namísto
<strong>END</strong> muselo psát <strong>NIGEB</strong>.</div></p>

<p>V&nbsp;ALGOLu-68 se taktéž v&nbsp;některých implementacích setkáme
s&nbsp;takzvaným <i>stroppingem</i>. Jedná se o techniku použitou
v&nbsp;některých (většinou postarších) programovacích jazycích pro přesnější
určení klíčových slov, operátorů či jiných identifikátorů. Příkladem stroppingu
mohou být některé původní operátory ve FORTRANu zapisované stylem
<strong>.eq.</strong>, <strong>.ne.</strong> atd. (stropping je tvořen oněmi
tečkami). V&nbsp;ALGOLu se někdy používal zápis bez stroppingu, typicky při
tvorbě článků:</p>

<pre>
¢ underline or
   bold typeface ¢
 mode xint = int;
 xint sum sq:=0;
 for i while
   sum sq≠70×70
 do
   sum sq+:=i↑2
 od
</pre>

<p>Překladače ovšem mnohdy vyžadovaly označení klíčových slov, což je dosti
nepřehledný způsob, který navíc může vést k&nbsp;mnoha chybám:</p>

<pre>
'pr' quote 'pr'
'mode' 'xint' = 'int';
'xint' sum sq:=0;
'for' i 'while'
  sum sq≠70×70
'do'
  sum sq+:=i↑2
'od'
</pre>

<p>ALGOL-68 sice nebyl z&nbsp;globálního pohledu příliš úspěšný (zvláště když
si uvědomíme, kam mezitím dospěl Pascal a především C), ovšem i přesto se
používal. Příkladem mohou být systémy vytvářené v&nbsp;SSSR, kde byl ALGOL
(&#1040;&#1083;&#1075;&#1086;&#1083; využitý například i na prozatím
nezmíněných počítačích <i>Elbrus</i> a <i>Odra</i>), popř.&nbsp;jeho varianta
pojmenovaná &#1040;&#1083;&#1075;&#1101;&#1082;, která byla jakýmsi hybridem
mezi COBOLem a originálním ALGOLem. Ve variantě ALGOLu-68 byly programovány i
některé subsystémy raketoplánu Buran.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Algol-W</h2>

<p><i>&bdquo;In my opinion, Algol W is a much better teaching language than
Pascal or pretty much any of the languages which have followed
it.&ldquo;</i></p>

<p>Paralelně a nezávisle na vývoji ALGOLu-68 pokračoval Wirth v&nbsp;návrhu
jazyka nazvaného ALGOL-W (též psáno Algol-W). Tento jazyk se již některými
svými vlastnostmi přibližoval (tehdy pochopitelně neexistujícímu) Pascalu, i
když prozatím chyběla nejzásadnější vlastnost Pascalu &ndash; jeho typový
systém. Jazyk dodržoval blokový zápis programů, nabízel více základních
datových typů, novou konstrukci programové smyčky a několik dalších vylepšení.
Syntaxe jazyka byla, jak se stalo u &bdquo;pascalské&ldquo; větve zvykem,
popsána pomocí BNF.</p>

<p>Mezi rezervovaná klíčová slova patřila:</p>

<pre>
ABS       ALGOL     AND       ARRAY     ASSERT
BEGIN     BITS      CASE      COMMENT   COMPLEX
DIV       DO        ELSE      END       FALSE
FOR       FORTRAN   GO TO     GOTO      IF
INTEGER   IS        LOGICAL   LONG      NULL
OF        OR        PROCEDURE REAL      RECORD
REFERENCE REM       RESULT    SHL       SHORT
SHR       STEP      STRING    THEN      TRUE
UNTIL     VALUE     WHILE
</pre>

<p>Příklad procedury naprogramované v&nbsp;Algolu-W:</p>

<pre>
procedure PQ_Sink(integer value k);
begin
    logical Done;
    Done := false;
&nbsp;
    while 2*K &lt;= PQ_Size and not Done do
    begin
        integer J;
        J := 2 * K;
        if J &lt; PQ_Size and PQ_Greater(J, J+1)
        then
            J := J + 1;
        if PQ_Greater(K, J)
        then begin
            PQ_Exchange(K, J);
            K := J;
        end
        else begin
            Done := true;
        end;
    end
end;
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o proceduru použitou při
implementaci prioritní fronty.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Rozdíly mezi ALGOLem-60 a Algolem-W</h2>

<p>Mezi původním ALGOLem-60 a Wirthovým Algolem-W nalezneme několik rozdílů,
zjednodušení a současně i rozšíření. Zajímavé je, že některé změny byly později
samotným Wirthem navrhnuty v&nbsp;jeho dalším jazyku &ndash; přelomovém
Pascalu:</p>

<ol>

<li>Algol-W používal datový typ <strong>logical</strong> a nikoli
<strong>boolean</strong>. V&nbsp;Pascalu jsme se vrátili k&nbsp;ALGOLu.</li>

<li>Indexy polí se zapisovaly do kulatých závorek. Jak ALGOL-60, tak i Pascal
používají hranaté závorky.</li>

<li>Pro celočíselné dělení se používá operátor <strong>div</strong> a nikoli
%.</li>

<li>Typy parametrů předávaných do procedur jsou zapisovány přímo uvnitř závorek
za jménem procedury (jako v&nbsp;Pascalu, ANSI C, Javě, Go atd. atd.).</li>

<li>Byly definovány nové datové typy long real, complex, long complex, bits a
řetězce o délce maximálně 255 znaků (s&nbsp;tím později bojoval i Pascal).</li>

<li>Podpora záznamů (struktur) a referencí na ně (prakticky nutnost pro
rozsáhlejší projekty). Koncept záznamů byl zachován i v&nbsp;Pascalu.</li>

<li>Komentáře zapisované do % ... % namísto použití <strong>comment</strong>
... <strong>end</strong>.</li>

<li>Nový typ programové smyčky <strong>while() do</strong>, kterou taktéž známe
z&nbsp;Pascalu.</li>

<li>Smyčka <strong>for</strong> nutně nevyžadovala použití klauzule
<strong>step</strong></li>

<li>Nově byly definované procedury pro vstup a výstup.</li>

</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Od Algolu-W k&nbsp;Pascalu</h2>

<p>Od Algolu-W vedla již poměrně krátká cesta k&nbsp;programovacímu jazyku
Pascal, jehož první verze vznikla v&nbsp;roce 1970, což mimochodem představuje
další kulaté výročí. Tím se však budeme zabývat až v&nbsp;navazujícím
článku.</p>

<a href="http://i.iinfo.cz/images/75/llang02images-3.png"><img src="http://i.iinfo.cz/images/75/llang02images-3-prev.png" width="370" height="205" alt=" " /></a>
<p><i>Obrázek 7: Hlavní menu vývojového prostředí Turbo Pascalu 1.0.
Z&nbsp;tohoto menu se vyvolávaly jednotlivé moduly integrovaného vývojového
prostředí. Teprve později došlo k&nbsp;úplnému sjednocení jednotlivých částí a
hlavní obrazovkou se stal samotný programátorský editor se stavovým řádkem a
hlavním menu.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Komu vděčíme za složené závorky a operátory ++ a --?</h2>

<p>Zdánlivě nezávisle na ALGOLu a jím inspirovaných programovacích jazyků se
v&nbsp;Bellových laboratořích začal vyvíjet nový typ operačního systému, který
se později proslavil pod jménem UNIX. Kromě samotného jádra UNIXu byl pro tento
operační systém vyvinut i jednoduchý textový editor, assembler, interpret
příkazů (předchůdce dnešních shellů) a několik základních utilit,
odpovídajících dnešním programům <i>rm</i>, <i>ls</i>, <i>cp</i> či
<i>cat</i>.</p>

<a href="http://i.iinfo.cz/images/76/pdp2-2.jpg"><img src="http://i.iinfo.cz/images/76/pdp2-2-prev.jpg" alt="pdp2" height="270" width="220" /></a>
<p><i>Obrázek 8: Počítač PDP-7.</i></p>

<p><i>Ken Thompson</i> a jeho kolega <i>Dennis Ritchie</i>, kteří se na UNIXu
podíleli, se oprávněně domnívali, že nově vytvořený operační systém vyžaduje
také nový systémově orientovaný programovací jazyk, tj.&nbsp;jazyk, ve kterém
by bylo možné psát systémové programy a popř.&nbsp;i uživatelské aplikace
(ovšem s&nbsp;prioritou na vývoj samotného operačního systému). Nejprve se sice
uvažovalo o využití překladače <i>Fortranu</i>, ovšem tato myšlenka byla
vzhledem k&nbsp;mnoha omezeným hardwarovým možnostem mikropočítače <i>PDP-7</i>
následně opuštěna. Namísto toho Ken Thompson vytvořil nový programovací jazyk
nazvaný jednoduše <strong>B</strong>. Tento jazyk byl založen na existujícím
jazyku <strong>BCPL</strong> (<i>Basic Combined Programming Language</i>), jenž
byl vytvořen Martinem Richardsem již v&nbsp;roce 1966 a jehož
&bdquo;dědečkem&ldquo; byl právě <i>ALGOL</i>. Vzhledem k&nbsp;tomu, že jazyk
<strong>BCPL</strong> byl z&nbsp;hlediska konstrukce překladače poměrně složitý
(což je poněkud paradoxní, neboť se jednalo o zjednodušený jazyk
<strong>CPL</strong> ze začátku šedesátých let), nebylo možné, aby se jeho
překladač na mikropočítači <i>PDP-7</i> spouštěl z&nbsp;operačního systému,
protože jen pro samotný překlad zdrojových kódů bylo zapotřebí cca 16 kB
operační paměti.</p>

<a href="http://i.iinfo.cz/images/76/pdp2-5.jpg"><img src="http://i.iinfo.cz/images/76/pdp2-5-prev.jpg" alt="pdp2" height="270" width="337" /></a>
<p><i>Obrázek 9: Známá fotografie Kena Thompsona a Dennise Ritchieho sedících
před PDP.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Vybrané vlastnosti programovacího jazyka &bdquo;B&ldquo;</h2>

<p>Z&nbsp;tohoto důvodu Ken Thompson z&nbsp;původního jazyka
<strong>BCPL</strong> odstranil některé vlastnosti, které nepovažoval za
podstatné (například složitější typy programových smyček) a naopak změnil jeho
základní syntaxi takovým způsobem, aby se zápis programů mohl co nejvíce
zkrátit. Právě z&nbsp;této snahy například pochází i způsob zápisu operátorů
s&nbsp;využitím speciálních znaků a nikoli klíčových slov (včetně zcela nových
operátorů ++ a --), což je zvyk používaný doposud &ndash; viz například
současné programovací jazyky, jakými jsou C, C++, Java, JavaScript či
programovací jazyky Go a Rust. Taktéž se v&nbsp;jazyku <strong>B</strong>
objevuje použití středníků pro ukončení příkazů (ovšem s&nbsp;jiným sémantickým
významem, než v&nbsp;ALGOLu či Pascalu).</p>

<p>Thompson navíc při programování překladače použil techniku využívanou dodnes
&ndash; překladač programovacího jazyka <strong>B</strong> byl napsán
v&nbsp;přímo v&nbsp;samotném jazyku <strong>B</strong>, což sice na samotném
začátku vyžaduje takzvaný bootstrap (například první interpretr napsaný
v&nbsp;assembleru), ale ve výsledku tato metoda vedla jak ke zrychlení vývoje,
tak i ke kvalitnějšímu návrhu jazyka (z&nbsp;tohoto hlediska není nic lepšího,
než když je programátor nucen používat své vlastní produkty :-). Při pohledu do
<a href="http://cm.bell-labs.com/cm/cs/who/dmr/kbman.html">referenční příručky
jazyka B</a>, popř.&nbsp;na ukázku programového kódu je vidět nápadná shoda
s&nbsp;programovacím jazykem <strong>C</strong>, o kterém se zmíníme později
(v&nbsp;podstatě zde chybí datové typy a struktury):</p>

<pre>
/* The following program will calculate the constant e-2 to about
   4000 decimal digits, and print it 50 characters to the line in
   groups of 5 characters.  The method is simple output conversion
   of the expansion
     1/2! + 1/3! + ... = .111....
   where the bases of the digits are 2, 3, 4, . . . */
&nbsp;
main() {
        extrn putchar, n, v;
        auto i, c, col, a;
&nbsp;
        i = col = 0;
        while(i&lt;n)
                v[i++] = 1;
        while(col&lt;2*n) {
                a = n+1 ;
                c = i = 0;
                while (i&lt;n) {
                        c =+ v[i] *10;
                        v[i++]  = c%a;
                        c =/ a--;
                }
&nbsp;
                putchar(c+'0');
                if(!(++col%5))
                        putchar(col%50?' ': '*n');
        }
        putchar('*n*n');
}
&nbsp;
v[2000];
n 2000;
</pre>

<p>Na programovacím jazyku <strong>B</strong> bylo zvláštní především to, že
podporoval pouze jeden datový typ &ndash; slovo (word) &ndash; jehož bitová
šířka se měnila podle toho, pro jaký procesor byly programy překládány. I
adresy v&nbsp;paměti byly reprezentovány pomocí slov (přesněji jako indexy do
pole, neboť paměť byla v&nbsp;B považována za jedno velké lineární pole), což
se později ukázalo být problematické, protože na mnoha platformách mají adresy
jinou bitovou šířku než slova zpracovávaná procesorem a i aritmetické a relační
operace s&nbsp;adresami jsou mnohdy &bdquo;zvláštní&ldquo;. Nicméně pro účely
systémového programování na počítači <i>PDP-7</i> programovací jazyk
<strong>B</strong> vyhovoval a jeho překladače byly později naprogramovány i
pro některé další minipočítače, například dále popsaný <i>PDP-11</i>.</p>

<p>Druhá zvláštnost spočívá v&nbsp;tom, že překladač jazyka <strong>B</strong>
na <i>PDP-7</i> i na <i>PDP-11</i> překládal program nikoli přímo do strojového
kódu, ale do bajtkódu, který musel být následně interpretován. Jednalo se ve
své podstatě o stejnou technologii, jaká je použita například u P-kódu (Pascal)
či u interpretrů Javovského bajtkódu (dnes se již čisté interpretry tohoto
bajtkódu v&nbsp;reálných JRE nepoužívají).</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Vznik programovacího jazyka &bdquo;C&ldquo;</h2>

<p>Některé vlastnosti <a href="#k17">výše zmíněného</a> programovacího jazyka
<strong>B</strong> implementovaného na počítačích <i>PDP-7</i> a později i na
<i>PDP-11</i> však nebyly příliš vhodné pro systémové programování, například
z&nbsp;toho důvodu, že <i>PDP-11</i>, na rozdíl od <i>PDP-7</i>, zpracovával
data různých bitových šířek, včetně bajtů (ASCII znaky). Z&nbsp;tohoto důvodu
se vývojáři v&nbsp;Bellových laboratořích rozhodli, že v&nbsp;rámci přechodu na
počítač <i>PDP-11</i> vytvoří nový programovací jazyk, který mj.&nbsp;umožní
více odstínit programátora od hardwarové architektury počítače. Tento
programovací jazyk &ndash; &bdquo;nový B&ldquo; &ndash; se na návrh Kena
Thompsona pojmenoval <strong>C</strong>. Jestli se jedná o další písmeno
v&nbsp;abecedě ('C'=='B'+1) nebo o následující znak v&nbsp;označení předchůdce
obou jazyků &ndash; jazyka <strong>BCPL</strong>, je již otázka, kterou tvůrci
ponechali nezodpovězenou.</p>

<img src="http://i.iinfo.cz/images/76/pdp2-8.jpg" alt="pdp2" height="247" width="239" />
<p><i>Obrázek 10: Brian Kernighan, který spolu s&nbsp;Dennisem Ritchiem napsal
světoznámou knížku &bdquo;C Programming Language&ldquo;, podle níž se
popisovaný dialekt označuje K&amp;R. Počáteční písmeno jeho příjmení se rovněž
vyskytuje v&nbsp;názvu programovacího jazyka AWK.</i></p>

<p>Na jazyk C, který byl standardizován v&nbsp;několika normách (ANSI C, ISO C,
viz též C89, C90, C95, C99, C11 a C18; pravděpodobně vznikne i C2x) již přímo
navázaly další programovací jazyky, z&nbsp;nichž mnohé se používají dodnes
(podobně jako <a href="https://www.tiobe.com/tiobe-index/">samotné céčko, které
je stále populární</a>). Nejdříve &bdquo;C with Classes&ldquo;, z&nbsp;něhož se
vyvinul programovací jazyk C++. Dále pak jazyky D, Objective C, Java a
JavaScript, ovšem velký vliv programovacího jazyka C můžeme vidět i na dalších
programovacích jazycích, například na jazyku <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">Rust</a> či <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">Go</a>.</p>

<p><div class="rs-tip-major">Poznámka: zajímavá situace nastala v&nbsp;případě
programovacího jazyka Go. Od ALGOLu-60 se totiž vývoj &bdquo;algolských&ldquo;
jazyků rozdělil do dvou větví &ndash; &bdquo;pascalské&ldquo; (poněkud
s&nbsp;nadsázkou se používá označení evropská větev) a &bdquo;céčkové&ldquo;
(americká větev). A u jazyka Go došlo k&nbsp;opětovnému spojení obou větví;
v&nbsp;mnoha ohledech má Go blíže k&nbsp;Algolu, než k&nbsp;jazyku C.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>V. Jankovič:<br />
ALGOL &ndash; FORTRAN &ndash; COBOL<br />
ALFA, 1972</li>

<li>C.A.R. Hoare:<br />
The Emperor's Old Clothes<br />
Communications of the ACM, 1981</li>

<li>IBM:<br />
IBM System/360 Operating System: ALGOL Language<br />
IBM</li>

<li>B. Randell and L.J. Russell:<br />
ALGOL 60 Implementation: The Translation and Use of ALGOL 60 Programs on a Computer<br />
Academic Press, 1964. The design of the Whetstone Compiler.</li>

<li>E. W, Dijkstra:<br />
Algol 60 translation: an algol 60 translator for the x1 and making a translator for algol 60
<br />report MR 35/61. Mathematisch Centrum, Amsterdam, 1961.</li>

<li>Peter O'Hearn and Robert Tennent:<br />
Algol-like Languages<br />
Progress in Theoretical Computer Science Volume 2</li>

<li>D. J. Malcolme-Lawes:<br />
Programming — ALGOL<br />
The Commonwealth and international library of science, technology, engineering, and liberal studies</li>

<li>F. L. Bauer:<br />
Introduction to Algol<br />
Prentice Hall (January 1964)</li>

<li>Carl-Erik Ekman, Torgil; Froberg:<br />
Introduction to Algol Programming<br />
Studentlitteratur</li>

</ol>

<p><div class="rs-tip-major">Poznámka: v&nbsp;naprosté většině případů se jedná
o muzeální výtisky.</div></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Algol 60 Lego Pieces<br />
<a href="http://algol60.org/6legoPieces.htm">http://algol60.org/6legoPieces.htm</a>
</li>

<li>Report on the Algorithmic Language ALGOL 60<br />
<a href="http://www.softwarepreservation.org/projects/ALGOL/report/Algol60_report_CACM_1960_June.pdf">http://www.softwarepreservation.org/projects/ALGOL/report/Algol60_report_CACM_1960_June.pdf</a>
</li>

<li>ALGOL na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/ALGOL">https://en.wikipedia.org/wiki/ALGOL</a>
</li>

<li>ALGOL: The Best Language You’ve Never Heard Of<br />
<a href="https://www.whoishostingthis.com/resources/algol/">https://www.whoishostingthis.com/resources/algol/</a>
</li>

<li>Timeline of programming languages<br />
<a href="https://en.wikipedia.org/wiki/Timeline_of_programming_languages">https://en.wikipedia.org/wiki/Timeline_of_programming_languages</a>
</li>

<li>A History of Computer Programming Languages<br />
<a href="https://cs.brown.edu/~adf/programming_languages.html">https://cs.brown.edu/~adf/programming_languages.html</a>
</li>

<li>ALGOL 60 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ALGOL_60">https://en.wikipedia.org/wiki/ALGOL_60</a>
</li>

<li>Revised Report on the Algorithmic Language Algol 60<br />
<a href="https://www.masswerk.at/algol60/report.htm">https://www.masswerk.at/algol60/report.htm</a>
</li>

<li>Does anyone still use the ALGOL programming language?<br />
<a href="https://www.quora.com/Does-anyone-still-use-the-ALGOL-programming-language">https://www.quora.com/Does-anyone-still-use-the-ALGOL-programming-language</a>
</li>

<li>Was ALGOL ever used for “mainstream” programming?<br />
<a href="https://stackoverflow.com/questions/1463321/was-algol-ever-used-for-mainstream-programming">https://stackoverflow.com/questions/1463321/was-algol-ever-used-for-mainstream-programming</a>
</li>

<li>ALGOL W - Introduction<br />
<a href="https://try-mts.com/algol-w-introduction/">https://try-mts.com/algol-w-introduction/</a>
</li>

<li>ALGOL 60 - Language features<br />
<a href="https://try-mts.com/algol-60-language-features/">https://try-mts.com/algol-60-language-features/</a>
</li>

<li>A COURSE OF ALGOL 60 PROGRAMMING<br />
<a href="http://archive.computerhistory.org/resources/text/algol/ACM_Algol_bulletin/1064048/frontmatter.pdf">http://archive.computerhistory.org/resources/text/algol/ACM_Algol_bulletin/1064048/frontmatter.pdf</a>
</li>

<li>The Algol 68 Genie project<br />
<a href="https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html">https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html</a>
</li>

<li>ALGOL based programming languages<br />
<a href="https://en.wikipedia.org/wiki/Generational_list_of_programming_languages#ALGOL_based">https://en.wikipedia.org/wiki/Generational_list_of_programming_languages#ALGOL_based</a>
</li>

<li>Category:ALGOL 60 (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/Category:ALGOL_60">http://rosettacode.org/wiki/Category:ALGOL_60</a>
</li>

<li>Category:ALGOL W (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/Category:ALGOL_W">http://rosettacode.org/wiki/Category:ALGOL_W</a>
</li>

<li>Algol W<br />
<a href="https://everything2.com/title/Algol%2520W">https://everything2.com/title/Algol%2520W</a>
</li>

<li>Historic Documents in Computer Science<br />
<a href="http://web.eah-jena.de/~kleine/history/history.html">http://web.eah-jena.de/~kleine/history/history.html</a>
</li>

<li>A comparison of PASCAL and ALGOL 68<br />
<a href="https://academic.oup.com/comjnl/article/21/4/316/356817">https://academic.oup.com/comjnl/article/21/4/316/356817</a>
</li>

<li>Stropping (syntax)<br />
<a href="https://en.wikipedia.org/wiki/Stropping_(syntax)">https://en.wikipedia.org/wiki/Stropping_(syntax)</a>
</li>

<li>A contribution to the development of ALGOL<br />
<a href="https://dl.acm.org/doi/10.1145/365696.365702">https://dl.acm.org/doi/10.1145/365696.365702</a>
</li>

<li>Syntax the Algorithmic Language Algol 60<br />
<a href="http://cse.csusb.edu/dick/samples/algol60.syntax.html">http://cse.csusb.edu/dick/samples/algol60.syntax.html</a>
</li>

<li>Scope (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">https://en.wikipedia.org/wiki/Scope_(computer_science)</a>
</li>

<li>Scope and closure (LISP)<br />
<a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)#Scope_and_closure">https://en.wikipedia.org/wiki/Lisp_(programming_language)#Scope_and_closure</a>
</li>

<li>Programming languages in MTS<br />
<a href="https://try-mts.com/programming-languages-in-mts/">https://try-mts.com/programming-languages-in-mts/</a>
</li>

<li>ALGOL 60 - Josephus problem<br />
<a href="https://try-mts.com/algol-60-josephus-problem/">https://try-mts.com/algol-60-josephus-problem/</a>
</li>

<li>ALGOL W - Priority queue<br />
<a href="https://try-mts.com/algol-w-priority-queue/">https://try-mts.com/algol-w-priority-queue/</a>
</li>

<li>Syntaxe a sémantika Algolu<br />
<a href="http://www.softwarepreservation.org/projects/ALGOL/paper/Backus-Syntax_and_Semantics_of_Proposed_IAL.pdf">http://www.softwarepreservation.org/projects/ALGOL/paper/Backus-Syntax_and_Semantics_of_Proposed_IAL.pdf</a>
</li>

<li>John Backus<br />
<a href="https://en.wikipedia.org/wiki/John_Backus">https://en.wikipedia.org/wiki/John_Backus</a>
</li>

<li>Backus–Naur form<br />
<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form</a>
</li>

<li>The future's bright… the future's Cobol<br />
<a href="https://www.root.cz/clanky/the-future-s-bright-the-future-s-cobol/">https://www.root.cz/clanky/the-future-s-bright-the-future-s-cobol/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Třicet let od vydání revolučního Turbo Pascalu 5.5<br />
<a href="https://www.root.cz/clanky/tricet-let-od-vydani-revolucniho-turbo-pascalu-5-5/">https://www.root.cz/clanky/tricet-let-od-vydani-revolucniho-turbo-pascalu-5-5/</a>
</li>

<li>Algol 60 Forever! <br />
<a href="http://algol60.org/">http://algol60.org/</a>
</li>

<li>Heinz Rutishauser<br />
<a href="https://en.wikipedia.org/wiki/Heinz_Rutishauser">https://en.wikipedia.org/wiki/Heinz_Rutishauser</a>
</li>

<li>The Development of the C Language<br />
<a href="http://cm.bell-labs.com/cm/cs/who/dmr/chist.html">http://cm.bell-labs.com/cm/cs/who/dmr/chist.html</a>
</li>

<li>B (programming language)<br />
<a href="http://en.wikipedia.org/wiki/B_(programming_language)">http://en.wikipedia.org/wiki/B_(programming_language)</a>
</li>

<li>Users' Reference to Bo<br />
<a href="http://cm.bell-labs.com/cm/cs/who/dmr/kbman.html">http://cm.bell-labs.com/cm/cs/who/dmr/kbman.html</a>
</li>

<li>THE PROGRAMMING LANGUAGE B<br />
<a href="http://cm.bell-labs.com/cm/cs/who/dmr/bintro.html">http://cm.bell-labs.com/cm/cs/who/dmr/bintro.html</a>
</li>

<li>BCPL<br />
<a href="http://en.wikipedia.org/wiki/BCPL">http://en.wikipedia.org/wiki/BCPL</a>
</li>

<li>Algol 68 - Years in the USSR<br />
<a href="http://www.computer-museum.ru/english/algol68.htm">http://www.computer-museum.ru/english/algol68.htm</a>
</li>

<li>Programming languages genealogical tree<br />
<a href="https://github.com/stereobooster/programming-languages-genealogical-tree">https://github.com/stereobooster/programming-languages-genealogical-tree</a>
</li>

<li>NASE A60 Algol Interpreter<br />
<a href="https://www.bertnase.de/a60/">https://www.bertnase.de/a60/</a>
</li>

<li>Most Popular Programming Languages 1965 - 2019<br />
<a href="https://www.youtube.com/watch?v=Og847HVwRSI">https://www.youtube.com/watch?v=Og847HVwRSI</a>
</li>

<li>Comparison of programming languages<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages">https://en.wikipedia.org/wiki/Comparison_of_programming_languages</a>
</li>

</li>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

