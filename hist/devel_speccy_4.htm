<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V pořadí již čtvrté části seriálu o vývoji programů pro legendární osmibitový domácí mikropočítač ZX Spectrum si ukážeme různé způsoby přímé manipulace s obrazovou pamětí, tedy konkrétně takové postupy, které se obejdou bez využití podprogramů, které jsou uloženy v ROM.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny</a></p>
<p><a href="#k02">2. Modifikace barvy a dalších atributů vykreslovaného řetězce</a></p>
<p><a href="#k03">3. Struktura bitmapy tvořící část obrazové paměti</a></p>
<p><a href="#k04">4. Vyplnění celé bitmapy pixely s&nbsp;barvou inkoustu</a></p>
<p><a href="#k05">5. Program bez návratu do BASICu</a></p>
<p><a href="#k06">6. Vyplnění obrazové paměti vybraným vzorkem</a></p>
<p><a href="#k07">7. Zpomalené vyplňování obrazové paměti: vizualizace její struktury</a></p>
<p><a href="#k08">8. Vlastní vykreslovací subrutiny &ndash; od vykreslení bloku k&nbsp;vykreslení celého (obarveného) řetězce</a></p>
<p><a href="#k09">9. Vykreslení vzorku 8&times;8 pixelů: základ pro algoritmus vykreslení znaků a řetězců</a></p>
<p><a href="#k10">10. Vykreslení vertikálního vzorku namísto vyplněného bloku</a></p>
<p><a href="#k11">11. Optimalizace vykreslení bloku: využití specifické struktury obrazové paměti ZX Spectra</a></p>
<p><a href="#k12">12. Vykreslení znaku s&nbsp;využitím masky uložené v&nbsp;paměti ROM</a></p>
<p><a href="#k13">*** 13. Tvorba podprogramů (subrutin) v&nbsp;assembleru mikroprocesoru Zilog Z80</a></p>
<p><a href="#k14">*** 14. Podprogram pro vykreslení libovolně zvoleného znaku na obrazovku</a></p>
<p><a href="#k15">15. Výpočet adresy v&nbsp;obrazové paměti pro vykreslení bloku</a></p>
<p><a href="#k16">16. Vykreslení bloku 8&times;8 na libovolné místo na obrazovce</a></p>
<p><a href="#k17">17. Obsah navazujícího článku</a></p>
<p><a href="#k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny</h2>

<p>V&nbsp;pořadí již čtvrté části <a
href="https://www.root.cz/serialy/vyvoj-pro-slavne-zx-spectrum/">seriálu o
vývoji programů pro legendární osmibitový domácí mikropočítač <i>ZX
Spectrum</i></a> si ukážeme různé způsoby přímé manipulace s&nbsp;obrazovou
pamětí, tedy konkrétně takové postupy, které se obejdou bez využití
podprogramů, které jsou uloženy v&nbsp;paměti ROM. Popíšeme si tedy jak
strukturu obrazové paměti (prozatím jsme si v&nbsp;demonstračních příkladech
otestovali &bdquo;pouze&ldquo; strukturu paměti s&nbsp;barvovými atributy,
nikoli ovšem způsob uložení podkladové bitmapy), tak i některé vlastní rutiny
použitelné pro vykreslování různých obrazců, ale i běžného textu. Později se
budeme věnovat i některým postupům, které se na ZX Spectru používají pro
vykreslení pohybujících se objektů (<i>spritů</i>). Nakonec se zmíníme o
problematice práce s&nbsp;okrajem obrazovky (<i>border</i>), protože i tato
část obrazu může být do jisté míry využita (buď například pro rozšíření obzoru
nebo alespoň ve fázi ladění pro odhad doby trvání některých operací).</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-19.png" class="image-825997" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 1: Vícebarevný a částečně blikající text vytištěný
s&nbsp;využitím vykreslovací rutiny dostupné ve standardní paměti ROM. Způsob
využití této rutiny (subrutiny) jsme si popsali minule.</i></p>

<p>V&nbsp;ROM jsou uloženy i pokročilejší vykreslovací subrutiny, jejichž
funkcionalita odpovídá příslušným příkazům Sinclair BASICu. Konkrétně se jedná
o příkazy <strong>PLOT</strong>, <strong>DRAW</strong>, <strong>CIRCLE</strong>
pro vykreslení obrazců, které jsou doplněné o nastavovací příkazy
<strong>INK</strong>, <strong>PAPER</strong>, <strong>FLASH</strong>,
<strong>BRIGHT</strong>, <strong>INVERSE</strong>, <strong>OVER</strong>,
<strong>BORDER</strong> a o příkaz <strong>POINT</strong> sloužící pro zjištění
stavu obrazové paměti. Tyto příkazy resp.&nbsp;jejich subrutiny je možné volat
i z&nbsp;assembleru, ale vzhledem k&nbsp;formátu a struktuře parametrů bude
výhodnější použít odlišné postupy.</p>

<img src="https://i.iinfo.cz/images/629/devel-speccy-3-20.png" class="image-825998" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 2: Vícebarevný a částečně blikající text vytištěný
s&nbsp;využitím vykreslovací rutiny dostupné ve standardní paměti ROM.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Modifikace barvy a dalších atributů vykreslovaného řetězce</h2>

<p><a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">Ve
třetí části tohoto seriálu</a> jsme si ukázali, jakým způsobem je možné využít
subrutinu nazvanou <strong>ROM_PRINT</strong>, která je uložena od adresy
0x203C. Tato subrutina umožňuje vykreslení celého řetězce na obrazovku, přičemž
v&nbsp;řetězci mohou být uloženy i řídicí znaky pro změnu barvy i dalších
atributů vykreslovaných znaků. Poslední nastavená barva a atributy (konkrétně
blikání, vysoká intenzita barvy inkoustu) jsou touto subrutinou uloženy do
bajtu umístěného na adrese 23695 (což je RAM, protože se jedná o adresu vyšší
než 16383). V&nbsp;případě, že hodnotu uloženou na této adrese (její symbolické
jméno je <strong>ATTR_T</strong>) přímo změníme, je možné modifikovat barvy
následně vykreslovaného řetězce či řetězců (zapsaná hodnota je zapamatována do
té doby, dokud ji přímo či nepřímo nezměníme buď my nebo systém/interpret).</p>

<p>V&nbsp;následujícím příkladu je ukázána modifikace bajtu na adrese
<strong>ATTR_T</strong> následovaná vykreslením řetězce rutinou z&nbsp;adresy
<strong>ROM_PRINT</strong>. Jak změna barvy, tak i vykreslení řetězce probíhá
ve smyčce:</p>

<pre>
ENTRY_POINT      equ $8000
ROM_OPEN_CHANNEL equ $1601
ROM_PRINT        equ $203C
ATTR_T           equ 23695
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld   A,2              <i>; číslo kanálu</i>
        call ROM_OPEN_CHANNEL <i>; otevření kanálu číslo 2 (screen)</i>
&nbsp;
        ld   B, 64            <i>; barva tisku</i>
        ld   HL, ATTR_T       <i>; adresa systémové proměnné ATTR_T</i>
&nbsp;
loop:
        ld   (HL), B          <i>; změna barvy tisku</i>
        push BC               <i>; uchovat BC</i>
        ld   DE, TEXT         <i>; adresa prvního znaku v řetězci</i>
        ld   BC, TEXT_LENGTH  <i>; délka textu</i>
        call ROM_PRINT        <i>; volání subrutiny v ROM</i>
        pop  BC               <i>; obnovit BC</i>
        djnz loop             <i>; tisk další barvou</i>
        ret                   <i>; ukončit program</i>
&nbsp;
<i>; řetězec</i>
TEXT:   db "Hello, speccy!"
&nbsp;
TEXT_LENGTH: equ $ - TEXT
&nbsp;
end ENTRY_POINT
</pre>

<p>Takto vypadá výsledek:</p>

*** image ***
<p><i>Obrázek 3: Obrazovka vyplněná barevným textem vykresleným příkladem (ROM
rutina si navíc vynutí pokračování vykreslování po stisku klávesy).</i></p>

*** image ***
<p><i>Obrázek 4: Poslední obarvené zprávy vypsané demonstračním
příkladem.</i></p>

<p>Způsob překladu do strojového kódu vypadá následovně (samotná textová zpráva
je uložena ihned za strojovým kódem):</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_OPEN_CHANNEL EQU 1601
ROM_PRINT       EQU 203C
ATTR_T          EQU 5C8F
                ORG 8000
8000:           label start
8000:3E02       LD A, 02
8002:CD0116     CALL 1601
8005:0640       LD B, 40
8007:218F5C     LD HL, 5C8F
800A:           label loop
800A:70         LD (HL), B
800B:C5         PUSH BC
800C:111980     LD DE, 8019
800F:010E00     LD BC, 000E
8012:CD3C20     CALL 203C
8015:C1         POP BC
8016:10F2       DJNZ 800A
8018:C9         RET
8019:           label TEXT
8019:48656C6C   DEFB of 14 bytes
801D:6F2C2073
8021:70656363
8025:7921
TEXT_LENGTH     EQU 000E
8027:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8026
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Struktura bitmapy tvořící část obrazové paměti</h2>

<p>Z&nbsp;pohledu mikroprocesoru (tj.&nbsp;jeho adresové sběrnice) začínala
obrazová paměť na adrese 16384, protože do prvních 16 kB byla namapována paměť
ROM a od adresy 32768 se nacházel blok paměti RAM o kapacitě 32 kB, do které
měl přístup pouze mikroprocesor. Jediný blok paměti, který byl sdílený mezi
<i>ULA</i> (to je čip, který se kromě dalších operací staral o generování video
signálu) a mikroprocesorem, se nacházel od zmíněné adresy 16384 až do adresy
32767.</p>

*** image ***
<p><i>Obrázek 5: Některé hry dokážou vykreslit i obrovské animované sprity
(Trap Door a jeho pokračování).</i></p>

<p>Obrazová paměť je rozdělena na dvě části &ndash; bitmapu s&nbsp;rozlišením
256&times;192 pixelů o velikosti 256&times;192/8=6144 bajtů a maticí atributů
s&nbsp;32&nbsp;24=768 bajty (práci s&nbsp;touto částí obrazové paměti již
známe). Každému pixelu je v&nbsp;bitmapě přiřazen jediný bit rozlišující, zda
se jedná o pixel s&nbsp;barvou pozadí (<i>paper</i>) či popředí (<i>ink</i>),
což znamená, že v&nbsp;jednom bajtu jsou uloženy informace o osmi pixelech
ležících na jednom obrazovém řádku. Pixely na jednom obrazovém řádku, tvořící
blok o délce 32 bajtů, jsou uloženy lineárně za sebou, ovšem jednotlivé
obrazové řádky jsou v&nbsp;paměti uloženy na přeskáčku: šestnáctibitovou adresu
lze v&nbsp;případě práce s obrazovou pamětí rozdělit na více částí tak, jak je
naznačeno níže (každé písmeno odpovídá jednomu bitu šestnáctibitové
adresy):</p>

<pre>
010 BB SSS RRR CCCCC
&nbsp;
BS:    číslo bloku 0,1,2 (v bloku číslo 3 je atributová paměť)
SSS:   číslo řádky v&nbsp;jednom znaku, který je vysoký osm obrazových řádků
RRR:   pozice textového řádku v&nbsp;bloku. Každý blok je vysoký 64 obrazových řádků, což odpovídá osmi řádkům textovým
CCCCC: index sloupce bajtu v rozmezí 0..31, kde je uložena osmice sousedních pixelů
</pre>

*** image ***
<p><i>Obrázek 6: Statický obrázek umně využívající omezení atributové paměti.</i></p>

<p><div class="rs-tip-major">Poznámka: toto rozdělení sice na první pohled může
připadat poněkud zvláštní, ale jak uvidíme dále, do značné míry zjednodušuje
subrutinu pro tisk znaků a řetězců (namísto složitého 16bitového součtu se
použije jediná instrukce <strong>inc</strong> pro přechod na další obrazový
řádek).</div></p>

<p>Nejlépe je tato organizace paměti patrná při nahrávání programu
z&nbsp;kazety, neboť nahrávací rutina pouze načítá data a postupně je ukládá od
adresy 16384, tj.&nbsp;na obrazovce se nahrávaná bitmapa objevuje po
jednotlivých &bdquo;zpřeházených&ldquo; řádcích: nejprve první řádek, řádek
osmý, šestnáctý atd. až dojde k&nbsp;vyplnění celého bloku o výšce 64
obrazových řádků. Viz například <a
href="https://www.youtube.com/watch?v=MtBoRp_cSxQ">toto video</a>.</p>

*** image ***
<p><i>Obrázek 7: Disassembler, v&nbsp;němž se používají především subrutiny pro
vykreslení textu.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vyplnění celé bitmapy pixely s&nbsp;barvou inkoustu</h2>

<p>Vzhledem k&nbsp;tomu, že bitmapa je sice v&nbsp;obrazové paměti uložena jako
sekvence &bdquo;zpřeházených&ldquo; řádků, ale mezi obrazovými řádky nejsou
v&nbsp;paměti žádné mezery, je možné celou bitmapu jednoduše vyplnit bitovým
vzorkem popř.&nbsp;konstantní barvou (popředí či pozadí). To je operace, kterou
realizujeme programovou smyčkou, jejíž základy jsme si popsali minule &ndash;
vnitřní část smyčky vždy vyplní 256 bajtový blok, vnější smyčka tuto operaci
zopakuje 24&times;, takže se celkově vyplní 256&times;24=6144 bajtů, což je
přesná velikost bitmapy počítaná v&nbsp;bajtech (pixelů je pochopitelně osmkrát
více):</p>

<pre>
SCREEN_ADR    equ $4000
ENTRY_POINT   equ $8000
&nbsp;
PIXELS        equ 256*192
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, SCREEN_ADR     <i>; adresa pro zápis</i>
        ld a, PIXELS/8/256    <i>; počet opakování bloku s 256 zápisy</i>
        ld b, 0               <i>; počitadlo vnitřní smyčky</i>
&nbsp;
loop:
        ld (hl), 0xff         <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy</i>
        djnz loop             <i>; vnitřní smyčka: blok s 256 zápisy</i>
        dec a                 <i>; počitadlo vnější smyčky</i>
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
finish:
        ret                   <i>; ukončit program</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledek by měl vypadat následovně (povšimněte si, že část bitmapy byla
přepsána interpretrem BASICu po ukončení programu):</p>

*** image ***
<p><i>Obrázek 8: Bitmapa vyplněná barvou popředí (ink) a částečně přepsaná
interpretem BASICu.o</i></p>

<p>Překlad výše uvedené smyčky do strojového kódu může vypadat takto:</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PIXELS          EQU C000
                ORG 8000
8000:           label start
8000:210040     LD HL, 4000
8003:3E18       LD A, 18
8005:0600       LD B, 00
8007:           label loop
8007:36FF       LD (HL), FF
8009:23         INC HL
800A:10FB       DJNZ 8007
800C:3D         DEC A
800D:C20780     JP NZ, 8007
8010:           label finish
8010:C9         RET
8011:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8010
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Program bez návratu do BASICu</h2>

<p>Program <a href="#k04">z&nbsp;předchozí kapitoly</a> končil instrukcí
<strong>ret</strong>, což znamená, že se řízení vrátilo zpět do BASICu, který
část obrázku překreslil vlastními zprávami:</p>

<pre>
finish:
        ret                   <i>; ukončit program</i>
</pre>

<p>Pokud namísto <strong>ret</strong> použijeme nekonečnou smyčku, program
v&nbsp;této smyčce pochopitelně setrvá a zprávy BASICu se již neobjeví:</p>

<pre>
finish:
        jr finish             <i>; nevrátíme se do systému</i>
</pre>

<p>Výsledkem by měla být bitmapa, která je celá vyplněná samými jedničkami
(tedy pixely s&nbsp;barvou popředí):</p>

*** image ***
<p><i>Obrázek 9: Bitmapa vyplněná barvou popředí (ink) (nyní již BASIC žádnou
část obrazovky nepřekreslil).</i></p>

<p>Pro úplnost si ukažme celý zdrojový kód takto upraveného příkladu:</p>

<pre>
SCREEN_ADR    equ $4000
ENTRY_POINT   equ $8000
&nbsp;
PIXELS        equ 256*192
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, SCREEN_ADR     <i>; adresa pro zápis</i>
        ld a, PIXELS/8/256    <i>; počet opakování bloku s 256 zápisy</i>
        ld b, 0               <i>; počitadlo vnitřní smyčky</i>
&nbsp;
loop:
        ld (hl), 0xff         <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy</i>
        djnz loop             <i>; vnitřní smyčka: blok s 256 zápisy</i>
        dec a                 <i>; počitadlo vnější smyčky</i>
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
<strong>finish:</strong>
        <strong>jr finish</strong>             <i>; nevrátíme se do systému</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Způsob překladu do strojového kódu ukazuje, že instrukce <strong>jr</strong>
je pouze dvoubajtová, na rozdíl od absolutního skoku:</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PIXELS          EQU C000
                ORG 8000
8000:           label start
8000:210040     LD HL, 4000
8003:3E18       LD A, 18
8005:0600       LD B, 00
8007:           label loop
8007:36FF       LD (HL), FF
8009:23         INC HL
800A:10FB       DJNZ 8007
800C:3D         DEC A
800D:C20780     JP NZ, 8007
8010:           label finish
8010:18FE       JR 8010
8012:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8011
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vyplnění obrazové paměti vybraným vzorkem</h2>

<p>Samozřejmě není nutné obrazovou paměť vyplnit pouze samými bitovými
jedničkami (tedy bajty s&nbsp;hodnotou 0xff v&nbsp;případě, že se provádí zápis
po bajtech a nikoli po slovech). Pokud pro zápis použijeme odlišnou zapisovanou
hodnotu, například 10101010 (bitově), dojde podle očekávání k&nbsp;vizuální
změně na obrazovce, která by nyní měla obsahovat vertikální úsečky
s&nbsp;šířkou jednoho pixelu:</p>

*** image ***
<p><i>Obrázek 10: Bitmapa s&nbsp;pixely vyplněnými barvou popředí (ink) a barvou
pozadí (paper).</i></p>

<p>Celý programový kód je upraven jen nepatrně &ndash; použijeme konstantu
<strong>PATTERN</strong> se zapisovaným bitovým vzorkem:</p>

<pre>
SCREEN_ADR    equ $4000
ENTRY_POINT   equ $8000
&nbsp;
PIXELS        equ 256*192
<strong>PATTERN       equ %10101010</strong>
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, SCREEN_ADR     <i>; adresa pro zápis</i>
        ld a, PIXELS/8/256    <i>; počet opakování bloku s 256 zápisy</i>
        ld b, 0               <i>; počitadlo vnitřní smyčky</i>
&nbsp;
loop:
        ld (hl), <strong>PATTERN</strong>      <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy</i>
        djnz loop             <i>; vnitřní smyčka: blok s 256 zápisy</i>
        dec a                 <i>; počitadlo vnější smyčky</i>
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
finish:
        jr finish             <i>; nevrátíme se do systému</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Pro úplnost si opět uveďme způsob překladu tohoto demonstračního příkladu do
strojového kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PIXELS          EQU C000
PATTERN         EQU 00AA
                ORG 8000
8000:           label start
8000:210040     LD HL, 4000
8003:3E18       LD A, 18
8005:0600       LD B, 00
8007:           label loop
8007:36AA       LD (HL), AA
8009:23         INC HL
800A:10FB       DJNZ 8007
800C:3D         DEC A
800D:C20780     JP NZ, 8007
8010:           label finish
8010:18FE       JR 8010
8012:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8011
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zpomalené vyplňování obrazové paměti: vizualizace její struktury</h2>

<p>V&nbsp;úvodním textu jsme si řekli, že struktura obrazové paměti je dobře
viditelná při nahrávání obrázků z&nbsp;kazety. Ovšem pokud zpomalíme naši
vykreslovací smyčku, bude struktura paměti patrná i při spuštění takto
upraveného programu &ndash; celé vyplňování může probíhat tak pomalu, aby bylo
viditelné lidským okem. To je ukázáno v&nbsp;dalším demonstračním příkladu,
v&nbsp;němž před vykreslením každé osmice pixelů 256&times; snižujeme obsah
akumulátoru a teprve poté se vykreslení provede (to nám mimochodem ukazuje, jak
je vlastně Z80 relativně pomalý a jak málo strojového času mají
k&nbsp;dispozici běžné vykreslovací subrutiny, které překreslují celou
obrazovku &ndash; což jsou hry se scrollujícím světem). Samotná zpožďovací
smyčka je realizována třemi instrukcemi okolo návěští
<strong>delay</strong>:</p>

<pre>
SCREEN_ADR    equ $4000
ENTRY_POINT   equ $8000
&nbsp;
PIXELS        equ 256*192
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, SCREEN_ADR     <i>; adresa pro zápis</i>
        ld c, PIXELS/8/256    <i>; počet opakování bloku s 256 zápisy</i>
        ld b, 0               <i>; počitadlo vnitřní smyčky</i>
&nbsp;
loop:
&nbsp;
        xor a                 <i>; počitadlo zpožďovací smyčky</i>
delay:
        dec a                 <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr  NZ, delay         <i>; opakovat, dokud není dosaženo nuly</i>
&nbsp;  
        ld (hl), 0xff         <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy</i>
        djnz loop             <i>; vnitřní smyčka: blok s 256 zápisy</i>
        dec c                 <i>; počitadlo vnější smyčky</i>
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret                   <i>; návrat do systému</i>
&nbsp;
end ENTRY_POINT
</pre>

*** image ***
<p><i>Obrázek 11: Postupné vyplňování obrazové paměti pixely s&nbsp;barvou
inkoustu.</i></p>

*** image ***
<p><i>Obrázek 12: Postupné vyplňování obrazové paměti pixely s&nbsp;barvou
inkoustu.</i></p>

*** image ***
<p><i>Obrázek 13: Postupné vyplňování obrazové paměti pixely s&nbsp;barvou
inkoustu.</i></p>

*** image ***
<p><i>Obrázek 14: Postupné vyplňování obrazové paměti pixely s&nbsp;barvou
inkoustu.</i></p>

<p>Překlad do strojového kódu bude vypadat takto:</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PIXELS          EQU C000
                ORG 8000
8000:           label start
8000:210040     LD HL, 4000
8003:0E18       LD C, 18
8005:0600       LD B, 00
8007:           label loop
8007:AF         XOR A
8008:           label delay
8008:3D         DEC A
8009:20FD       JR NZ, 8008
800B:36FF       LD (HL), FF
800D:23         INC HL
800E:10F7       DJNZ 8007
8010:0D         DEC C
8011:C20780     JP NZ, 8007
8014:C9         RET
8015:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8014
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a>.</div></p>

<p>Pro úplnost si uveďme upravenou variantu tohoto příkladu, který nikdy
nepředá řízení zpět do BASICu a tudíž se výsledná obrazovka nepřekreslí:</p>

<pre>
SCREEN_ADR    equ $4000
ENTRY_POINT   equ $8000
&nbsp;
PIXELS        equ 256*192
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, SCREEN_ADR     <i>; adresa pro zápis</i>
        ld c, PIXELS/8/256    <i>; počet opakování bloku s 256 zápisy</i>
        ld b, 0               <i>; počitadlo vnitřní smyčky</i>
&nbsp;
loop:
&nbsp;
        xor a                 <i>; počitadlo zpožďovací smyčky</i>
delay:
        dec a                 <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr  NZ, delay         <i>; opakovat, dokud není dosaženo nuly</i>
        
        ld (hl), 0xff         <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy</i>
        djnz loop             <i>; vnitřní smyčka: blok s 256 zápisy</i>
        dec c                 <i>; počitadlo vnější smyčky</i>
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
finish:
        jr finish             <i>; nevrátíme se do systému</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Struktura instrukcí ve strojovém kódu vypadá takto:</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PIXELS          EQU C000
                ORG 8000
8000:           label start
8000:210040     LD HL, 4000
8003:0E18       LD C, 18
8005:0600       LD B, 00
8007:           label loop
8007:AF         XOR A
8008:           label delay
8008:3D         DEC A
8009:20FD       JR NZ, 8008
800B:36FF       LD (HL), FF
800D:23         INC HL
800E:10F7       DJNZ 8007
8010:0D         DEC C
8011:C20780     JP NZ, 8007
8014:           label finish
8014:18FE       JR 8014
8016:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8015
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vlastní vykreslovací subrutiny &ndash; od vykreslení bloku k&nbsp;vykreslení celého (obarveného) řetězce</h2>

<p>Koncepty představené v&nbsp;předchozích kapitolách jsou sice prozatím velmi
jednoduché, ale postupně je můžeme a budeme rozšiřovat takovým způsobem,
abychom (minimálně) dokázali na obrazovku vykreslit znak či celý řetězec znaků,
a to bez volání subrutin uložených v&nbsp;paměti ROM. A samozřejmě nám nic
nebude bránit ve vykreslení obarveného řetězce (zvláště v&nbsp;situaci, kdy
budeme vykreslovat zarovnané znaky s&nbsp;maskou o velikosti 8&times;8 pixelů).
Samotné masky znaků bude přitom možné číst jak z&nbsp;paměti ROM (což znamená
standardní znakovou sadu odvozenou od ASCII) nebo z&nbsp;paměti RAM, což nám
naopak umožní využití vlastní znakové sady doplněné například o znaky
s&nbsp;nabodeníčky atd. A nesmíme zapomenout na to, že způsob vykreslování
<i>spritů</i> se v&nbsp;mnoha ohledech podobá vykreslování znaků, takže se
nabízí možnost vytvoření univerzálnějších algoritmů (které však nebudou tak
rychlé, jako algoritmy plně optimalizované na provedení jediné grafické
operace).</p>

<p><div class="rs-tip-major">Poznámka: důležité je taktéž slovo
<i>subrutina</i>, protože naznačuje, že se bude jednat o podprogramy volané
instrukcí <strong>CALL</strong>, který se budou přes pracovní registry
popř.&nbsp;přes zásobník předávat parametry.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vykreslení vzorku 8&times;8 pixelů: základ pro algoritmus vykreslení znaků a řetězců</h2>

<p>Podprogram pro tisk celého řetězce je poměrně komplikovaný. Z&nbsp;tohoto
důvodu budeme postupovat po jednotlivých krocích. Nejdříve si vyzkoušíme, jak
se vykreslí blok o velikosti 8&times;8 pixelů do levého horního rohu obrazovky.
Postup je snadný:</p>

<ol>
<li>Nastavíme pracovní adresu (pro zápis) na hodnotu 0x4000, což je první bajt obrazové paměti</li>
<li>Nastavíme počitadlo smyčky na hodnotu 8, protože se má vykreslit osm obrazových řádků</li>
<li>Na vypočtenou adresu se zapíše hodnota 0xff. Tím se vykreslí osm horizontálních pixelů</li>
<li>Adresa se zvýší o hodnotu odpovídající délce obrazového řádku v&nbsp;bajtech vynásobené osmi (protože řádky nejsou uloženy za sebou)</li>
<li>Sníží se počitadlo smyčky o jedničku</li>
<li>Pokud se <i>ne</i>dosáhlo nuly, bude program pokračovat od bodu 3</li>
</ol>

<p>Tento postup je sice poměrně neoptimální (zejména výpočet adresy lze
upravit, jak ostatně uvidíme dále), ale zato je relativně snadno pochopitelný.
Samotná vykreslovací smyčka je tvořena pouze třemi instrukcemi:</p>

<pre>
SCREEN_ADR      equ $4000
ENTRY_POINT     equ $8000
&nbsp;
PIXELS          equ 256*192
SCANLINE_LENGTH equ 256/8
NEXT_SCANLINE   equ SCANLINE_LENGTH*8
&nbsp;
PATTERN         equ $ff
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, SCREEN_ADR     <i>; adresa pro zápis</i>
        ld b, 8               <i>; počitadlo zapsaných bajtů</i>
        ld de, NEXT_SCANLINE  <i>; offset pro přechod na další obrazový řádek</i>
&nbsp;
loop:
        ld (hl), PATTERN      <i>; zápis hodnoty na adresu (HL)</i>
        add hl, de            <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop             <i>; vnitřní smyčka: blok s osmi zápisy</i>
finish:
        ret                   <i>; ukončit program</i>
&nbsp;
end ENTRY_POINT
</pre>

*** image ***
<p><i>Obrázek 15: Blok o velikosti 8&times;8 pixelů vykreslený do levého
horního rohu obrazovky (to prosím není kurzor :-).</i></p>

<p>Překlad do strojového kódu dopadne následovně:</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PIXELS          EQU C000
SCANLINE_LENGTH EQU 0020
NEXT_SCANLINE   EQU 0100
PATTERN         EQU 00FF
                ORG 8000
8000:           label start
8000:210040     LD HL, 4000
8003:0608       LD B, 08
8005:110001     LD DE, 0100
8008:           label loop
8008:36FF       LD (HL), FF
800A:19         ADD HL, DE
800B:10FB       DJNZ 8008
800D:           label finish
800D:C9         RET
800E:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800D
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vykreslení vertikálního vzorku namísto vyplněného bloku</h2>

<p>Podobně jako jsme vyplnili obrazovku jak barvou inkoustu (zapisované bajty
měly hodnotu 0xff) tak i zvoleným vzorkem, můžeme totéž udělat i v&nbsp;případě
vykreslení bloku 8&times;8 pixelů. I zde lze původní zapisovanou hodnotu 0xff
nahradit jinou hodnotou, například bitovým vzorkem 10101010. Výsledek by měl
vypadat následovně:</p>

*** image ***
<p><i>Obrázek 16: Blok o velikosti 8&times;8 pixelů vyplněný vzorkem a
vykreslený do levého horního rohu obrazovky.</i></p>

<p>Samotný programový kód se přitom změní jen nepatrně &ndash; odlišnou
hodnotou uloženou do symbolické hodnoty <strong>PATTERN</strong>:</p>

<pre>
SCREEN_ADR      equ $4000
ENTRY_POINT     equ $8000
&nbsp;
PIXELS          equ 256*192
SCANLINE_LENGTH equ 256/8
NEXT_SCANLINE   equ SCANLINE_LENGTH*8
&nbsp;
<strong>PATTERN         equ %10101010</strong>
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, SCREEN_ADR     <i>; adresa pro zápis</i>
        ld b, 8               <i>; počitadlo zapsaných bajtů</i>
        ld de, NEXT_SCANLINE  <i>; offset pro přechod na další obrazový řádek</i>
&nbsp;
loop:
        ld (hl), <strong>PATTERN</strong>      <i>; zápis hodnoty na adresu (HL)</i>
        add hl, de            <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop             <i>; vnitřní smyčka: blok s osmi zápisy</i>
finish:
        ret                   <i>; ukončit program</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledek překladu zdrojového kódu z&nbsp;assembleru do strojového kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PIXELS          EQU C000
SCANLINE_LENGTH EQU 0020
NEXT_SCANLINE   EQU 0100
PATTERN         EQU 00AA
                ORG 8000
8000:           label start
8000:210040     LD HL, 4000
8003:0608       LD B, 08
8005:110001     LD DE, 0100
8008:           label loop
8008:36AA       LD (HL), AA
800A:19         ADD HL, DE
800B:10FB       DJNZ 8008
800D:           label finish
800D:C9         RET
800E:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800D
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Optimalizace vykreslení bloku: využití specifické struktury obrazové paměti ZX Spectra</h2>

<p>Podívejme se ještě jednou na strukturu adresy bajtu zapisovaného do obrazové
paměti:</p>

<pre>
010 BB SSS RRR CCCCC
&nbsp;
BS:    nyní nezajímavé
SSS:   číslo řádky v&nbsp;jednom znaku, který je vysoký osm obrazových řádků
RRR:   nyní nezajímavé
CCCCC: nyní nezajímavé
</pre>

<p>Z&nbsp;poněkud upraveného popisku je patrné, že v&nbsp;dolních třech bitech
<i>vyššího bajtu adresy</i> je zapsáno číslo obrazového řádku 0..7. To vlastně
znamená, že pokud vypisujeme znak s&nbsp;maskou 8&times;8 pixelů, je zápis
dalšího bajtu proveden na adresu o 256 vyšší, než byla adresa předchozí. A
vzhledem k&nbsp;tomu, že adresa je zapsána ve dvojici registrů
<strong>HL</strong> (či <strong>BC</strong> nebo <strong>DE</strong>),
postačuje nám pouze zvýšit hodnotu v&nbsp;horním osmibitovém registru &ndash;
což je mnohem rychlejší i kratší operace!</p>

<pre>
loop:
        ld (hl), PATTERN      <i>; zápis hodnoty na adresu (HL)</i>
        inc h                 <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop             <i>; vnitřní smyčka: blok s osmi zápisy</i>
</pre>

<p><div class="rs-tip-major">Poznámka: nyní je pravděpodobně patrné, že na
první pohled &bdquo;zmatená&ldquo; struktura obrazové paměti ZX Spectra je
vlastně velmi promyšlená (s&nbsp;ohledem na požadavky BASICu a dalších textově
orientovaných aplikací).</div></p>

*** image ***
<p><i>Obrázek 17: Blok o velikosti 8&times;8 pixelů vyplněný vzorkem a
vykreslený do levého horního rohu obrazovky.</i></p>

<p>Takto vypadá upravený zdrojový kód, který bude po překladu kratší a současně
i rychlejší:</p>

<pre>
SCREEN_ADR      equ $4000
ENTRY_POINT     equ $8000
&nbsp;
PIXELS          equ 256*192
&nbsp;
PATTERN         equ %10101010
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, SCREEN_ADR     <i>; adresa pro zápis</i>
        ld b, 8               <i>; počitadlo zapsaných bajtů</i>
&nbsp;
loop:
        ld (hl), PATTERN      <i>; zápis hodnoty na adresu (HL)</i>
        inc h                 <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop             <i>; vnitřní smyčka: blok s osmi zápisy</i>
finish:
        ret                   <i>; ukončit program</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Povšimněte si, že kód je kratší o 0x800d-0x800a=3 bajty. Navíc instrukce
<strong>inc h</strong> trvá čtyři takty, zatímco <strong>add hl, de</strong>
trvá taktů jedenáct:</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PIXELS          EQU C000
PATTERN         EQU 00AA
                ORG 8000
8000:           label start
8000:210040     LD HL, 4000
8003:0608       LD B, 08
8005:           label loop
8005:36AA       LD (HL), AA
8007:24         INC H
8008:10FB       DJNZ 8005
800A:           label finish
800A:C9         RET
800B:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800A
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vykreslení znaku s&nbsp;využitím masky uložené v&nbsp;paměti ROM</h2>

<p>Nyní si již konečně ukažme, jak se vlastně vykreslí skutečný znak, například
znak &bdquo;A&ldquo;. Masky znaků jsou uloženy v&nbsp;paměti ROM od adresy
0x3c00, takže předchozí vykreslovací rutinu musíme nepatrně změnit &ndash;
namísto konstantního vzorku budeme muset 8&times; načíst bajt z&nbsp;ROM a
samozřejmě vždy zvýšit adresu o jedničku pro další čtení. Pro čtení znaků
z&nbsp;ROM je použit registrový pár <strong>DE</strong>, pro zápis do obrazové
paměti pak registrový pár <strong>HL</strong>, u něhož budeme zvyšovat hodnotu
registru <strong>H</strong> (viz předchozí kapitolu):</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld de, CHAR_ADR + 'A'*8  <i>; adresa masky znaku A</i>
        ld hl, SCREEN_ADR        <i>; adresa pro zápis</i>
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
&nbsp;
loop:
        ld a, (de)               <i>; načtení jednoho bajtu z masky</i>
        ld (hl), a               <i>; zápis hodnoty na adresu (HL)</i>
        inc de                   <i>; posun na další bajt masky</i>
        inc h                    <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
finish:
        ret                      <i>; ukončit program</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Interní programová smyčka se nepatrně prodloužila, ovšem výsledek již vypadá
velmi dobře:</p>

*** image ***
<p><i>Obrázek 18: Znak (v&nbsp;levém horním rohu) vykreslený nikoli rutinou
v&nbsp;ROM, ale naší programovou smyčkou!</i></p>

<p>Překlad do strojového kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:11083E     LD DE, 3E08
8003:210040     LD HL, 4000
8006:0608       LD B, 08
8008:           label loop
8008:1A         LD A, (DE)
8009:77         LD (HL), A
800A:13         INC DE
800B:24         INC H
800C:10FA       DJNZ 8008
800E:           label finish
800E:C9         RET
800F:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800E
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Tvorba podprogramů (subrutin) v&nbsp;assembleru mikroprocesoru Zilog Z80</h2>

<p></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Podprogram pro vykreslení libovolně zvoleného znaku na obrazovku</h2>

<p></p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld de, SCREEN_ADR        <i>; adresa pro zápis</i>
        ld a, 'A'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
        ld de, SCREEN_ADR+1      <i>; adresa pro zápis</i>
        ld a, 'B'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
        ld de, SCREEN_ADR+128+31 <i>; adresa pro zápis</i>
        ld a, '?'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
finish:
        ret                      <i>; ukončit program</i>
&nbsp;
draw_char:
        ld hl, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld b, 0
        ld c, a                  <i>; kód znaku je nyní ve dvojici BC</i>
        sla c
        rl b
        sla c
        rl b
        sla c
        rl b                     <i>; vynásobení BC osmi</i>
        add hl, bc               <i>; přičíst adresu k offsetu masky znaku</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
loop:
        ld a, (hl)               <i>; načtení jednoho bajtu z masky</i>
        ld (de), a               <i>; zápis hodnoty na adresu (DE)</i>
        inc hl                   <i>; posun na další bajt masky</i>
        inc d                    <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:110040     LD DE, 4000
8003:3E41       LD A, 41
8005:CD1980     CALL 8019
8008:110140     LD DE, 4001
800B:3E42       LD A, 42
800D:CD1980     CALL 8019
8010:119F40     LD DE, 409F
8013:3E3F       LD A, 3F
8015:CD1980     CALL 8019
8018:           label finish
8018:C9         RET
8019:           label draw_char
8019:21003C     LD HL, 3C00
801C:0600       LD B, 00
801E:4F         LD C, A
801F:CB21       SLA C
8021:CB10       RL B
8023:CB21       SLA C
8025:CB10       RL B
8027:CB21       SLA C
8029:CB10       RL B
802B:09         ADD HL, BC
802C:0608       LD B, 08
802E:           label loop
802E:7E         LD A, (HL)
802F:12         LD (DE), A
8030:23         INC HL
8031:14         INC D
8032:10FA       DJNZ 802E
8034:C9         RET
8035:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8034
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a>.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výpočet adresy v&nbsp;obrazové paměti pro vykreslení bloku</h2>

<p><a href="#k03">Ve třetí kapitole</a> jsme si popsali organizaci obrazové
paměti. Připomeňme si, že adresa každého bajtu obrazové paměti se skládá
z&nbsp;několika bitových polí v&nbsp;tomto formátu (jedná se o 16bitovou adresu
zapsanou formou bitů):</p>

<pre>
010 BB SSS RRR CCCCC
&nbsp;
BS:    číslo bloku 0,1,2 (v bloku číslo 3 je atributová paměť)
SSS:   číslo řádky v&nbsp;jednom znaku, který je vysoký osm obrazových řádků
RRR:   pozice textového řádku v&nbsp;bloku. Každý blok je vysoký 64 obrazových řádků, což odpovídá osmi řádkům textovým
CCCCC: index sloupce bajtu v rozmezí 0..31, kde je uložena osmice sousedních pixelů
</pre>

<p>V&nbsp;případě, že budeme chtít vykreslovat znaky s&nbsp;maskou 8&times;8
pixelů, bude bitové pole SSS obsahovat nulové bity, protože číslo nejvyššího
obrazového řádku znaku je rovno nule (pokud nebude znak vertikálně posunut).
Formát se nám tedy zjednoduší do této podoby:</p>

<pre>
010 BB 000 RRR CCCCC
</pre>

<p>Ve chvíli, kdy máme dvojici souřadnic znaku [x,y], bude rozmístění
jednotlivých bitů těchto souřadnic [X4 X3 X2 X1 X0, Y4 Y3 Y2 Y1 Y0] vypadat
následovně:</p>

<pre>
0 1 0 Y4 Y3 0 0 0 | Y2 Y1 Y0 X4 X3 X2 X1 X0
</pre>

<p>A takovou adresu je možné vypočítat poměrně snadno:</p>

<ol>
<li>Spodní tři bity y-ové souřadnice se posunou na pozice bitů 7, 6 a 5</li>
<li>K&nbsp;těmto bitům se operací <strong>or</strong> přidají bity s&nbsp;x-ovou souřadnicí (takto vznikne spodní bajt adresy)</li>
<li>Horní dva bity y-ové souřadnice jsou na správných místech, takže pouze operací <strong>and</strong> zamaskujeme ostatních pět bitů</li>
<li>A instrukcí <strong>or</strong> přidáme prefixové bity 010 na pozice 7, 6 a 5 (takto vznikne horní bajt adresy)</li>
</ol>

<p>Tento postup můžeme přepsat do formy podprogramu, kterému se v&nbsp;registru
<strong>B</strong> předá x-ová souřadnice znaku a v&nbsp;registru
<strong>C</strong> y-ová souřadnice. Podprogram vypočítá adresu prvního bajtu
znaku a vrátí ji v&nbsp;registrové dvojici <strong>HL</strong>:</p>

<pre>
calc_block_address:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>; C - y-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis bloku</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y5 Y4 0 0 0 | Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
        ld  a, c
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (řádky 0..7)</i>
        rra
        rra
        rra
        rra                   <i>; nyní jsou čísla řádků v horních třech bitech</i>
        or  b                 <i>; připočítat x-ovou souřadnici</i>
        ld  l, a              <i>; máme spodní bajt adresy</i>
                              <i>; Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
&nbsp;
        ld  a, c              <i>; y-ová souřadnice</i>
        and %00011000         <i>; dva bity s indexem "bloku" 0..3 (dolní tři bity už máme zpracovány)</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; máme horní bajt adresy</i>
                              <i>; 0 1 0 Y5 Y4 0 0 0</i>
        ret                   <i>; návrat z podprogramu</i>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Vykreslení bloku 8&times;8 na libovolné místo na obrazovce</h2>

<p>Nyní, když již máme k&nbsp;dispozici podprogram pro výpočet adresy znaku,
můžeme tento podprogram použít v&nbsp;kódu, který na zadané místo na obrazovce
vykreslí blok o velikosti 8&times;8 pixelů. Zkombinujeme tedy znalosti a
techniky, které již známe. Pro ukázku toho, že je blok skutečně možné umístit
na obrazovku do libovolného místa (v&nbsp;rastru 32&times;24 znaků) se vykreslí
hned několik bloků. Povšimněte si způsobu předávání parametrů do podprogramů
<strong>calc_block_address</strong> (registry <strong>B</strong> a
<strong>C</strong>) a <strong>fill_block</strong> (registr <strong>A</strong> a
registrový pár <strong>HL</strong>):</p>

<pre>
SCREEN_ADR      equ $4000
ENTRY_POINT     equ $8000
&nbsp;
PATTERN         equ $ff
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
&nbsp;
        ld b, 0                 <i>; x-ová souřadnice</i>
        ld c, 0                 <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
        ld b, 15                <i>; x-ová souřadnice</i>
        ld c, 12                <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
        ld b, 2                 <i>; x-ová souřadnice</i>
        ld c, 2                 <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
        ld b, 31                <i>; x-ová souřadnice</i>
        ld c, 23                <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
finish:
        jr finish               <i>; žádný návrat do systému</i>
&nbsp;
&nbsp;
calc_block_address:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>; C - y-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis bloku</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y4 Y3 0 0 0 | Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
        ld  a, c
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (řádky 0..7)</i>
        rra
        rra
        rra
        rra                   <i>; nyní jsou čísla řádků v horních třech bitech</i>
        or  b                 <i>; připočítat x-ovou souřadnici</i>
        ld  l, a              <i>; máme spodní bajt adresy</i>
                              <i>; Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
&nbsp;
        ld  a, c              <i>; y-ová souřadnice</i>
        and %00011000         <i>; dva bity s indexem "bloku" 0..3 (dolní tři bity už máme zpracovány)</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; máme horní bajt adresy</i>
                              <i>; 0 1 0 Y5 Y4 0 0 0</i>
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
fill_block:
        <i>; parametry:</i>
        <i>; A - pattern</i>
        <i>; HL - adresa vykreslení bloku</i>
        ld b, 8               <i>; počitadlo zapsaných bajtů</i>
loop:
        ld (hl), PATTERN      <i>; zápis hodnoty na adresu (HL)</i>
        inc h                 <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop             <i>; vnitřní smyčka: blok s osmi zápisy</i>
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Podívejme se nyní na výsledek:</p>
<p>Strojový kód získaný překladem z&nbsp;assembleru je již poměrně dlouhý
&ndash; celých 73 bajtů :):</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PATTERN         EQU 00FF
                ORG 8000
8000:           label start
8000:0600       LD B, 00
8002:0E00       LD C, 00
8004:CD3280     CALL 8032
8007:3EFF       LD A, FF
8009:CD4280     CALL 8042
800C:060F       LD B, 0F
800E:0E0C       LD C, 0C
8010:CD3280     CALL 8032
8013:3EFF       LD A, FF
8015:CD4280     CALL 8042
8018:0602       LD B, 02
801A:0E02       LD C, 02
801C:CD3280     CALL 8032
801F:3EFF       LD A, FF
8021:CD4280     CALL 8042
8024:061F       LD B, 1F
8026:0E17       LD C, 17
8028:CD3280     CALL 8032
802B:3EFF       LD A, FF
802D:CD4280     CALL 8042
8030:           label finish
8030:18FE       JR 8030
8032:           label calc_block_address
8032:79         LD A, C
8033:E607       AND 07
8035:1F         RRA
8036:1F         RRA
8037:1F         RRA
8038:1F         RRA
8039:B0         OR B
803A:6F         LD L, A
803B:79         LD A, C
803C:E618       AND 18
803E:F640       OR 40
8040:67         LD H, A
8041:C9         RET
8042:           label fill_block
8042:0608       LD B, 08
8044:           label loop
8044:36FF       LD (HL), FF
8046:24         INC H
8047:10FB       DJNZ 8044
8049:C9         RET
804A:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8049
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a>.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah navazujícího článku</h2>

<p>V&nbsp;navazujícím článku nejprve dokončíme téma, kterému jsme se věnovali
dnes. Máme již totiž k&nbsp;dispozici programový kód pro umístění a vykreslení
bloku kamkoli na obrazovku a současně umíme vykreslit znak, jehož maska je
přečtena z&nbsp;ROM a navíc umíme změnit hodnotu libovolného barvového
atributu. Tyto tři znalosti je nutné zkombinovat a vytvořit rutinu pro tisk
obarvených znaků popř.&nbsp;řetězců kamkoli na obrazovku. Posléze si ukážeme
způsob realizace dalších vykreslovacích rutin. Začneme zdánlivě jednoduše
&ndash; vykreslením pixelů &ndash; ale postupně si ukážeme i další algoritmy,
například algoritmus pro vykreslení úsečky, kružnice (viz Elite) atd.</p>

*** image ***
<p><i>Obrázek XX: Ve hře Elite lze najít množství propracovaných vykreslovacích
algoritmů.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<p>Výše uvedené demonstrační příklady i příklady, které již byly popsány
v&nbsp;předchozích třech článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">3</a>],
je možné přeložit s&nbsp;využitím souboru Makefile, jehož aktuální verze vypadá
následovně (pro překlad a slinkování je použit assembler <i>Pasmo</i>):</p>

<pre>
ASSEMBLER := pasmo
&nbsp;
all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap \
    31.tap 32.tap 33.tap 34.tap 35.tap 36.tap 37.tap 38.tap 39.tap 40.tap \
    41.tap
&nbsp;
clean:
        rm -f *.tap
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 01-color-attribute.lst
&nbsp;
02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 02-blinking-attribute.lst
&nbsp;
03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 03-symbolic-names.lst
&nbsp;
04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 04-operators.lst
&nbsp;
05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 05-better-symbols.lst
&nbsp;
06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 06-tapbas-v1.lst
&nbsp;
07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 07-tapbas-v2.lst
&nbsp;
08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 08-loop.lst
&nbsp;
09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 09-loop.lst
&nbsp;
10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 10-loop.lst
&nbsp;
11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 11-loop.lst
&nbsp;
12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 12-loop.lst
&nbsp;
13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 13-loop.lst
&nbsp;
14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 14-loop.lst
&nbsp;
15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 15-loop.lst
&nbsp;
16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 16-loop.lst
&nbsp;
17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 17-loop.lst
&nbsp;
18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 18-cls.lst
&nbsp;
19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 19-print-char-call.lst
&nbsp;
20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 20-print-char-rst.lst
&nbsp;
21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 21-print-char.lst
&nbsp;
22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 22-print-all-chars.lst
&nbsp;
23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 23-print-all-chars.lst
&nbsp;
24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 24-change-color.lst
&nbsp;
25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 25-change-flash.lst
&nbsp;
26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 26-print-at.lst
&nbsp;
27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 27-print-string.lst
&nbsp;
28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 28-print-string.lst
&nbsp;
29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 29-print-colorized-string.lst
&nbsp;
30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 30-print-string-ROM.lst
&nbsp;
31.tap: 31-attributes.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 31-attributes.lst
&nbsp;
32.tap: 32-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 32-fill-in-vram.lst
&nbsp;
33.tap: 33-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 33-fill-in-vram-no-ret.lst
&nbsp;
34.tap: 34-fill-in-vram-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 34-fill-in-vram-pattern.lst
&nbsp;
35.tap: 35-slow-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 35-slow-fill-in-vram.lst
&nbsp;
36.tap: 36-slow-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 36-slow-fill-in-vram-no-ret.lst
&nbsp;
37.tap: 37-fill-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 37-fill-block.lst
&nbsp;
38.tap: 38-fill-block-with-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 38-fill-block-with-pattern.lst
&nbsp;
39.tap: 39-fill-block-optimized.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 39-fill-block-optimized.lst
&nbsp;
40.tap: 40-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 40-draw-char.lst
&nbsp;
41.tap: 41-draw-any-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 41-draw-any-char.lst
&nbsp;
42.tap: 42-block-anywhere.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 42-block-anywhere.lst
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>31-attributes.asm</td><td>modifikace atributů pro tisk řetězce subrutinou uloženou v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a></td></tr>
<tr><td>32</td><td>32-fill-in-vram.asm</td><td>vyplnění celé bitmapy barvou popředí, návrat do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a></td></tr>
<tr><td>33</td><td>33-fill-in-vram-no-ret.asm</td><td>vyplnění celé bitmapy barvou popředí, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>34</td><td>34-fill-in-vram-pattern.asm</td><td>vyplnění celé bitmapy zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a></td></tr>
<tr><td>35</td><td>35-slow-fill-in-vram.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a></td></tr>
<tr><td>36</td><td>36-slow-fill-in-vram-no-ret.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>37</td><td>37-fill-block.asm</td><td>vykreslení bloku 8&times;8 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a></td></tr>
<tr><td>38</td><td>38-fill-block-with-pattern.asm</td><td>vykreslení bloku 8&times;8 pixelů zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a></td></tr>
<tr><td>39</td><td>39-fill-block-optimized.asm</td><td>optimalizace předchozího příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a></td></tr>
<tr><td>40</td><td>40-draw-char.asm</td><td>vykreslení znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a></td></tr>
<tr><td>41</td><td>41-draw-any-char.asm</td><td>podprogram pro vykreslení libovolně zvoleného znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a></td></tr>
<tr><td>42</td><td>42-block-anywhere.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech demonstračních příkladů do podoby obrazu magnetické pásky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>The system variables<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

