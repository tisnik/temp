<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Specifika instrukční sady mikroprocesorů Intel 8086/8088 (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Specifika instrukční sady mikroprocesorů Intel 8086/8088 (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se zaměříme na specifické instrukce, které byly na mikroprocesorech Intel 8086/8088 podporovány. Bude se v první řadě jednat o instrukce pro BCD aritmetiku (ty mají hned dva formáty) a o "řetězcové instrukce", které jsou pro platformu 8086 zcela typické.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Specifika instrukční sady mikroprocesorů Intel 8086/8088 (2)</a></p>
<p><a href="#k02">2. Výpis osmibitové hexadecimální hodnoty na obrazovku</a></p>
<p><a href="#k03">3. Instrukce <strong>XLAT</strong></a></p>
<p><a href="#k04">4. BCD aritmetika na čipech Intel 8086/8088</a></p>
<p><a href="#k05">5. Operace součtu s&nbsp;využitím binární i BCD aritmetiky</a></p>
<p><a href="#k06">6. Instrukce <strong>DAA</strong> po provedení operace rozdílu</a></p>
<p><a href="#k07">7. Instrukce <strong>DAS</strong> po provedení operace rozdílu</a></p>
<p><a href="#k08">8. BCD formát, v&nbsp;němž je každá cifra uložena v&nbsp;celém bajtu</a></p>
<p><a href="#k09">9. Korekce výsledku na jedinou BCD cifru operací <strong>AAA</strong></a></p>
<p><a href="#k10">10. Operace součinu a podílu</a></p>
<p><a href="#k11">11. Ukázka výpočtu součinu dvou osmibitových hodnot</a></p>
<p><a href="#k12">12. BCD korekce po výpočtu součinu instrukcí <strong>AAM</strong></a></p>
<p><a href="#k13">13. Řetězcové a blokové operace podporované mikroprocesory Intel 8086/8088</a></p>
<p><a href="#k14">14. Varianty řetězcových a blokových operací</a></p>
<p><a href="#k15">15. Zápis několika po sobě jdoucích znaků do řetězce</a></p>
<p><a href="#k16">16. Vylepšení předchozího příkladu: opakování instrukce <strong>STOSB</strong> CX-krát</a></p>
<p><a href="#k17">17. Překlad řetězcových instrukcí s&nbsp;prefixem i bez prefixu</a></p>
<p><a href="#k18">18. Obsah navazujícího článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Specifika instrukční sady mikroprocesorů Intel 8086/8088 (2)</h2>

<p>V&nbsp;dnešním článku navážeme na <a
href="https://www.root.cz/clanky/specifika-instrukcni-sady-mikroprocesoru-intel-8086-8088/">úvodní
část</a>, přičemž se zaměříme na skutečně specifické instrukce, které byly na
mikroprocesorech Intel 8086/8088 podporovány a v&nbsp;šestnáctibitovém a
32bitovém režimu musí být na platformě x86/x86-64(AMD64) podporovány dodnes, a
to i na nejmodernějších čipech (ať již přímo nebo v&nbsp;emulované podobě).
Bude se v&nbsp;první řadě jednat o instrukce pro BCD aritmetiku (dvě formy,
takzvaná &bdquo;ASCII BCD&ldquo; a &bdquo;packed BCD&ldquo;) a o
&bdquo;řetězcové instrukce&ldquo;, které jsou pro platformu 8086 zcela typické
a nutno říci, že zjednodušují vývoj v&nbsp;assembleru a zkracují popř.&nbsp;i
zrychlují výsledný strojový kód.  Nezapomeneme ale ani na zajímavou instrukci
<strong>XLAT</strong>.</p>

<p>Demonstrační příklady, které budou uvedeny v&nbsp;navazujících kapitolách,
jsou založeny na následující šabloně, v&nbsp;níž je definován formát výstupního
souboru i podporovaná instrukční sada (jen 8086/8088). Navíc jsou
v&nbsp;šabloně definována makra pro ukončení procesu, pro čekání na stisk
klávesy (služba BIOSu) a taktéž pro tisk řetězce na obrazovku (služba
DOSu):</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        print message
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
message db 0x01, 0x01, 0x0d, 0x0a, "$"
</pre>

<p><div class="rs-tip-major">Poznámka: znaky s&nbsp;ASCII kódem 0x01, které
jsou vytisknuty, mají na IBM PC tvar obličeje.</div></p>

<p>U jednotlivých demonstračních příkladů si budeme uvádět i výsledný strojový
kód (bajty ve druhém sloupci za číslem řádku). Ten vypadá pro naši šablonu
následovně:</p>

<pre>
     1                                  BITS 16         ; 16bitovy vystup pro DOS
     2                                  CPU 8086        ; specifikace pouziteho instrukcniho souboru
     3                                  
     4                                  ; ukonceni procesu a navrat do DOSu
     5                                  %macro exit 0
     6                                          ret
     7                                  %endmacro
     8                                  
     9                                  ; vyprazdneni bufferu klavesnice a cekani na klavesu
    10                                  %macro wait_key 0
    11                                          xor     ax, ax
    12                                          int     0x16
    13                                  %endmacro
    14                                  
    15                                  ; tisk retezce na obrazovku
    16                                  %macro print 1
    17                                          mov     dx, %1
    18                                          mov     ah, 9
    19                                          int     0x21
    20                                  %endmacro
    21                                  
    22                                  ;-----------------------------------------------------------------------------
    23                                  org  0x100        ; zacatek kodu pro programy typu COM (vzdy se zacina na 256)
    24                                  
    25                                  start:
    26                                          print message
    17 00000000 BA[0C00]            &lt;1&gt;  mov dx, %1
    18 00000003 B409                &lt;1&gt;  mov ah, 9
    19 00000005 CD21                &lt;1&gt;  int 0x21
    27                                          wait_key
    11 00000007 31C0                &lt;1&gt;  xor ax, ax
    12 00000009 CD16                &lt;1&gt;  int 0x16
    28                                          exit
     6 0000000B C3                  &lt;1&gt;  ret
    29                                  
    30                                          ; retezec ukonceny znakem $
    31                                          ; (tato data jsou soucasti vysledneho souboru typu COM)
    32 0000000C 01010D0A24              message db 0x01, 0x01, 0x0d, 0x0a, "$"
</pre>

<p><div class="rs-tip-major">Poznámka: tento výpis se povoluje přepínačem
<strong>-l</strong>, za nímž je nutné uvést jméno souboru, do kterého se má
výpis (<i>listing</i>) zapsat.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Výpis osmibitové hexadecimální hodnoty na obrazovku</h2>

<p>V&nbsp;dalších příkladech budeme pracovat s&nbsp;numerickými hodnotami,
takže si ukažme, jakým způsobem lze na obrazovku vytisknout osmibitovou
<i>hexadecimální</i> hodnotu. Nebude to nijak těžké. Nejdříve si připravíme
řetězec, který budeme tisknout, přičemž první dva znaky tohoto řetězce budeme
nahrazovat hexa číslicemi 0-9, a-f. Následují dva znaky pro odřádkování a
návrat na začátek řádku a znak dolaru, který řetězec ukončuje (v&nbsp;tomto se
DOS &bdquo;inspiroval&ldquo; systémem CP/M):</p>

<pre>
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
message db 0x01, 0x01, 0x0d, 0x0a, "$"
</pre>

<p>Převod hodnoty 0-15 na hexadecimální číslici lze naprogramovat (to jsme si
ukázali u ZX Spectra) nebo lze použít jednoduchou převodní tabulku. ASCII sada
totiž po číslici "9" nenavazuje znakem "A" nebo "a", takže v&nbsp;převodní
tabulce (nebo programovém kódu) musíme realizovat &bdquo;přeskok&ldquo;:</p>

<pre>
        <i>; prevodni tabulka hodnoty 0-15 na ASCII znak</i>
hex_digits db "0123456789abcdef"
</pre>

<p>Nyní se pokusíme převést první (vyšší) číslici uloženou v&nbsp;registru
<strong>CL</strong> na ASCII znak a ten uložit do výše uvedeného řetězce
<strong>message</strong> (zapisujeme do kódového segmentu :-). Postupně si
připravíme hodnotu 0-15 v&nbsp;registru <strong>BX</strong> a využijeme
adresovací režim popsaný minule:</p>

<pre>
        xor     bh, bh                <i>; vynulovat horni bajt offsetu</i>
&nbsp;
        mov     bl, cl                <i>; do BL se vlozi horni hexa cifra</i>
        and     bl, 0xf0              <i>; není zapotřebí, jen naznačujeme, že se využijí horní 4 bity</i>
        shr     bl, 1                 <i>; horní čtyři bity do dolních čtyř bitů</i>
        shr     bl, 1
        shr     bl, 1
        shr     bl, 1
&nbsp;
        mov     al, [hex_digits + bx] <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
</pre>

<p>Výpis spodní číslice je jednodušší, neboť nemusíme použít bitové posuny:</p>

<pre>
        mov     bl, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     bl, 0x0f
        mov     al, [hex_digits + bx] <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
</pre>

<p>Celý výše uvedený kód vložíme do subrutiny nebo do makra. Pro zajímavost
použijeme makro (což ale v&nbsp;praxi znamená, že každé použití makra nám celý
program &bdquo;natáhne&ldquo; o cca 40 bajtů!):</p>

<pre>
<i>; tisk hexadecimalni hodnoty</i>
%macro <strong>print_hex</strong> 1
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
        xor     bh, bh                <i>; vynulovat horni bajt offsetu</i>
&nbsp;
        mov     bl, cl                <i>; do BL se vlozi horni hexa cifra</i>
        and     bl, 0xf0              <i>; není zapotřebí, jen naznačujeme, že se využijí horní 4 bity</i>
        shr     bl, 1
        shr     bl, 1
        shr     bl, 1
        shr     bl, 1
&nbsp;
        mov     al, [hex_digits + bx] <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     bl, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     bl, 0x0f
        mov     al, [hex_digits + bx] <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
        print   message
%endmacro
</pre>

<p>Překlad výše uvedeného makra při jeho prvním použití (expanzi):</p>

<pre>
    48                                     print_hex 0x00
    24 00000000 B100                mov cl, %1
    25 00000002 30FF                xor bh, bh
    26                              
    27 00000004 88CB                mov bl, cl
    28 00000006 80E3F0              and bl, 0xf0
    29 00000009 D0EB                shr bl, 1
    30 0000000B D0EB                shr bl, 1
    31 0000000D D0EB                shr bl, 1
    32 0000000F D0EB                shr bl, 1
    33                              
    34 00000011 8A87[B600]          mov al, [hex_digits + bx]
    35 00000015 A2[B100]            mov [message], al
    36                              
    37 00000018 88CB                mov bl, cl
    38 0000001A 80E30F              and bl, 0x0f
    39 0000001D 8A87[B600]          mov al, [hex_digits + bx]
    40 00000021 A2[B200]            mov [message + 1], al
    41                              print message
    17 00000024 BA[B100]            mov dx, %1
    18 00000027 B409                mov ah, 9
    19 00000029 CD21                int 0x21
</pre>

<p>A takto vypadá úplný zdrojový kód dnešního druhého demonstračního
příkladu:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>; tisk hexadecimalni hodnoty</i>
%macro <strong>print_hex</strong> 1
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
        xor     bh, bh                <i>; vynulovat horni bajt offsetu</i>
&nbsp;
        mov     bl, cl                <i>; do BL se vlozi horni hexa cifra</i>
        and     bl, 0xf0              <i>; není zapotřebí, jen naznačujeme, že se využijí horní 4 bity</i>
        shr     bl, 1
        shr     bl, 1
        shr     bl, 1
        shr     bl, 1
&nbsp;
        mov     al, [hex_digits + bx] <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     bl, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     bl, 0x0f
        mov     al, [hex_digits + bx] <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
        print   message
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        print_hex 0x00
        print_hex 0x12
        print_hex 0xab
        print_hex 0xff
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db 0x01, 0x01, 0x0d, 0x0a, "$"
&nbsp;
        <i>; prevodni tabulka hodnoty 0-15 na ASCII znak</i>
<strong>hex_digits</strong> db "0123456789abcdef"
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instrukce <strong>XLAT</strong></h2>

<p>Ve skutečnosti je možné převod hexadecimální hodnoty na ASCII řetězec napsat
i odlišným způsobem, konkrétně s&nbsp;využitím instrukce <strong>XLAT</strong>.
Tato instrukce dokáže načíst hodnotu z&nbsp;adresy <strong>DS:[BX+AL]</strong>
a uložit výsledek opět do registru <strong>AL</strong>. To znamená, že takto
můžeme relativně snadno realizovat vyhledávací tabulky. Mimochodem: jedná se o
jedinou instrukci, v&nbsp;níž je použit registr <strong>AL</strong> pro výpočet
adresy.</p>

<p>Po malých úpravách (změna použitých registrů) bude makro pro převod
osmibitové hodnoty na ASCII řetězec s&nbsp;hexadecimální variantou hodnoty
vypadat následovně:</p>

<pre>
        mov     bx, hex_digits
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
&nbsp;
        mov     al, cl                <i>; do AL se vlozi horni hexa cifra</i>
        and     al, 0xf0              <i>; není zapotřebí, jen naznačujeme, že se využijí horní 4 bity</i>
        shr     al, 1
        shr     al, 1
        shr     al, 1
        shr     al, 1
&nbsp;
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     al, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     al, 0x0f
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
</pre>

<p>Pro úplnost si ukažme, jak vypadá celý zdrojový kód dnešního třetího
demonstračního příkladu:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>; tisk hexadecimalni hodnoty</i>
%macro <strong>print_hex</strong> 1
        mov     bx, hex_digits
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
&nbsp;
        mov     al, cl                <i>; do AL se vlozi horni hexa cifra</i>
        and     al, 0xf0              <i>; není zapotřebí, jen naznačujeme, že se využijí horní 4 bity</i>
        shr     al, 1
        shr     al, 1
        shr     al, 1
        shr     al, 1
&nbsp;
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     al, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     al, 0x0f
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        print   message
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        print_hex 0x00
        print_hex 0x12
        print_hex 0xab
        print_hex 0xff
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db 0x01, 0x01, 0x0d, 0x0a, "$"
&nbsp;
        <i>; prevodni tabulka hodnoty 0-15 na ASCII znak</i>
<strong>hex_digits</strong> db "0123456789abcdef"
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. BCD aritmetika na čipech Intel 8086/8088</h2>

<p>Mikroprocesory řady Intel 8086 (a tím pádem i 8088) podporovaly provádění
základních aritmetických operací s&nbsp;BCD hodnotami (<i>Binary-Coded
Decimal</i>). V&nbsp;tomto případě osmibitové registry obsahují buď pouze jednu
cifru (tj.&nbsp;hodnotu 0-15 z&nbsp;možného rozsahu 0-256) nebo dvojici
desítkových cifer &ndash; první cifra je uložena v&nbsp;horních čtyřech bitech,
druhá cifra pochopitelně v&nbsp;dolních čtyřech bitech). Maximální rozsah
uložených hodnot tedy nebude 0-255, ale jen 0-99, ovšem výhodou je snadnější
převod do tisknutelné podoby, snadné zvětšení počtu cifer atd. S&nbsp;BCD,
především s&nbsp;jeho &bdquo;komprimovanou&ldquo; podobou (tedy rozsah 0-99
v&nbsp;jednom bajtu) se setkáme jak v&nbsp;některých čipech (hodiny reálného
času, řadiče sedmisegmentových displejů), tak i například v&nbsp;databázových
systémech, v&nbsp;některých systémech pro zpracování měny atd.</p>

<p><div class="rs-tip-major">Poznámka: když se nad způsobem uložení cifer
zamyslíme, zjistíme, že naše makro pro tisk hexadecimálních hodnot bude beze
změny pracovat i pro BCD; ostatně proto jsme si ho uváděli.</div></p>

<p>K&nbsp;dispozici jsou následující instrukce pro práci s&nbsp;BCD:</p>

<table>
<tr><th>Instrukce</th><th>Operand</th><th>Stručný popis instrukce</th></tr>
<tr><td>AAA</td><td>jedna cifra v&nbsp;bajtu</td><td>úprava výsledku součtu na BCD tvar</td></tr>
<tr><td>AAS</td><td>jedna cifra v&nbsp;bajtu</td><td>úprava výsledku rozdílu na BCD tvar</td></tr>
<tr><td>DAA</td><td>dvě cifry v&nbsp;bajtu</td><td>úprava výsledku součtu na BCD tvar</td></tr>
<tr><td>DAS</td><td>dvě cifry v&nbsp;bajtu</td><td>úprava výsledku rozdílu na BCD tvar</td></tr>
<tr><td>AAM</td><td>dvě cifry v&nbsp;bajtu</td><td>úprava výsledku součinu na BCD tvar</td></tr>
<tr><td>AAD</td><td>dvě cifry v&nbsp;bajtu</td><td>úprava hodnoty před provedením operace dělení</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: všechny tyto instrukce si postupně
ukážeme. Pouze poslední instrukce <strong>AAD</strong> bude popsána příště
&ndash; je sice poněkud zvláštní, ovšem má i své praktické využití.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace součtu s&nbsp;využitím binární i BCD aritmetiky</h2>

<p>Mikroprocesory 8086 se nepřepínají do &bdquo;režimu binární
aritmetiky&ldquo; a &bdquo;režimu BCD&ldquo; tak, jako například <i>MOS
6502</i>. Namísto toho se po provedení nějaké aritmetické operace musí
explicitně výsledek této operace upravit. Základem je instrukce
<strong>DAA</strong>, která upraví výsledek součtu. Konkrétně to znamená, že
pokud dojde k&nbsp;přetečení mezi čtvrtým a pátým bitem (což se nastaví jako
jeden z&nbsp;příznaků) a současně je hodnota nižších čtyř bitů větší než 0x0f,
přičte se k&nbsp;výsledku šestka, čímž se upraví spodní cifra a zvýší cifra
horní. Podobně pokud je hodnota vyšší než 0x99 a došlo k&nbsp;přenosu, přičte
se k&nbsp;výsledku 0x60. Po provedení instrukce <strong>DAA</strong> tedy bude
registr <strong>AL</strong> obsahovat hodnotu 0-99 zakódovanou jako dvojici BCD
cifer.</p>

<p>Vyzkoušejme si to na čtveřici operací &ndash; vždy dvě budou provedeny
s&nbsp;binárními hodnotami a dvě s&nbsp;BCD hodnotami:</p>

<pre>
        mov  al, 0x49
        inc  al
        print_hex al    <i>; vytiskne se 4a (binární)</i>
&nbsp;
        mov  al, 0x49
        inc  al
        daa
        print_hex al    <i>; vytiskne se 50 (korektní BCD)</i>
&nbsp;
        mov  al, 0x99
        inc  al
        print_hex al    <i>; vytiskne se 9a (binární)</i>
&nbsp;
        mov  al, 0x99
        inc  al
        daa
        print_hex al    <i>; vytiskne se 00 (korektní BCD, došlo k&nbsp;přetečení, takže vlastně 100)</i>
</pre>

<p>Úplný zdrojový kód demonstračního příkladu vypadá takto:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>; tisk hexadecimalni hodnoty</i>
%macro <strong>print_hex</strong> 1
        mov     bx, hex_digits
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
&nbsp;
        mov     al, cl                <i>; do AL se vlozi horni hexa cifra</i>
        and     al, 0xf0
        shr     al, 1
        shr     al, 1
        shr     al, 1
        shr     al, 1
&nbsp;
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     al, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     al, 0x0f
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        print   message
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        mov  al, 0x49
        inc  al
        print_hex al
&nbsp;
        mov  al, 0x49
        inc  al
        daa
        print_hex al
&nbsp;
        mov  al, 0x99
        inc  al
        print_hex al
&nbsp;
        mov  al, 0x99
        inc  al
        daa
        print_hex al
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db 0x01, 0x01, 0x0d, 0x0a, "$"
&nbsp;
        <i>; prevodni tabulka hodnoty 0-15 na ASCII znak</i>
<strong>hex_digits</strong> db "0123456789abcdef"
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce <strong>DAA</strong> po provedení operace rozdílu</h2>

<p>V&nbsp;předchozí kapitole jsme si řekli, že instrukce <strong>DAA</strong>
slouží pro úpravu výsledku operace součtu na BCD tvar. Jak je tomu však ve
chvíli, kdy provedeme <strong>DAA</strong> po operaci rozdílu? Na některých CPU
bude výsledek korektní, takže si si zkusme:</p>

<pre>
        mov  al, 0x40
        sub  al, 1
        print_hex al    <i>; = 3f, což je korektní v binárním kódu</i>
&nbsp;
        mov  al, 0x40
        sub  al, 1
        daa
        print_hex al    <i>; = 45, což je v&nbsp;BCD špatně</i>
&nbsp;
        xor  al, al
        sub  al, 1
        print_hex al    <i>; = ff, což je korektní -1</i>
&nbsp;
        xor  al, al
        sub  al, 1
        daa
        print_hex al    <i>; = 65, což je v&nbsp;BCD špatně</i>
</pre>

<p>Vidíme tedy, že instrukce <strong>DAA</strong> po operaci rozdílu nebo
snížení hodnoty o 1 nedává korektní výsledky, i když nastavuje všechny potřebné
příznaky.</p>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>; tisk hexadecimalni hodnoty</i>
%macro <strong>print_hex</strong> 1
        mov     bx, hex_digits
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
&nbsp;
        mov     al, cl                <i>; do AL se vlozi horni hexa cifra</i>
        and     al, 0xf0
        shr     al, 1
        shr     al, 1
        shr     al, 1
        shr     al, 1
&nbsp;
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     al, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     al, 0x0f
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        print   message
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        mov  al, 0x40
        sub  al, 1
        print_hex al
&nbsp;
        mov  al, 0x40
        sub  al, 1
        daa
        print_hex al
&nbsp;
        xor  al, al
        sub  al, 1
        print_hex al
&nbsp;
        xor  al, al
        sub  al, 1
        daa
        print_hex al
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db 0x01, 0x01, 0x0d, 0x0a, "$"
&nbsp;
        <i>; prevodni tabulka hodnoty 0-15 na ASCII znak</i>
<strong>hex_digits</strong> db "0123456789abcdef"
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce <strong>DAS</strong> po provedení operace rozdílu</h2>

<p>Po provedení operace rozdílu je nutné pro získání korektního výsledku
reprezentovaného v&nbsp;BCD použít instrukci <strong>DAS</strong>, která
provádí podobné korekce jako <strong>DAA</strong> (na základě hodnoty horních a
spodních čtyř bitů výsledku i příznaků), ovšem namísto toho, aby se
k&nbsp;cifrám přičítaly hodnoty 6 a 0x60, se tyto hodnoty odečítají. Opět si
tedy ověřme, zda kombinace <strong>SUB+DAS</strong> (nebo
<strong>DEC+DAS</strong>) poskytne korektní BCD hodnotu:</p>

<pre>
        mov  al, 0x40
        sub  al, 1
        print_hex al    <i>; = 3f, což je korektní v binárním kódu</i>
&nbsp;
        mov  al, 0x40
        sub  al, 1
        daa
        print_hex al    <i>; = 39, což je v&nbsp;BCD dobře</i>
&nbsp;
        xor  al, al
        sub  al, 1
        print_hex al    <i>; = ff, což je korektní -1</i>
&nbsp;
        xor  al, al
        sub  al, 1
        daa
        print_hex al    <i>; = 99, což je v&nbsp;BCD dobře (0-1 = 99-100)</i>
</pre>

<p>Pro jistotu si opět uveďme úplný zdrojový kód tohoto demonstračního
příkladu:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>; tisk hexadecimalni hodnoty</i>
%macro <strong>print_hex</strong> 1
        mov     bx, hex_digits
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
&nbsp;
        mov     al, cl                <i>; do AL se vlozi horni hexa cifra</i>
        and     al, 0xf0
        shr     al, 1
        shr     al, 1
        shr     al, 1
        shr     al, 1
&nbsp;
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     al, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     al, 0x0f
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        print   message
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        mov  al, 0x40
        sub  al, 1
        print_hex al
&nbsp;
        mov  al, 0x40
        sub  al, 1
        das
        print_hex al
&nbsp;
        xor  al, al
        sub  al, 1
        print_hex al
&nbsp;
        xor  al, al
        sub  al, 1
        das
        print_hex al
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db 0x01, 0x01, 0x0d, 0x0a, "$"
&nbsp;
        <i>; prevodni tabulka hodnoty 0-15 na ASCII znak</i>
<strong>hex_digits</strong> db "0123456789abcdef"
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. BCD formát, v&nbsp;němž je každá cifra uložena v&nbsp;celém bajtu</h2>

<p>Mikroprocesory řady Intel 8086 podporovaly i BCD formát, ve kterém je každá
cifra uložena v&nbsp;celém bajtu, tj.&nbsp;bajt může obsahovat pouze hodnoty 0
až 9, zbylých 245 možných hodnot je nevyužito. To pochopitelně představuje
značné paměťové nároky, protože například hodnotu 10000 lze uložit do dvou
bajtů při použití binárního formátu, do třech bajtů při použití
&bdquo;packed&ldquo; BCD, ovšem do celých pěti bajtu při použití zde
popisovaného &bdquo;unpacked&ldquo; formátu. Na druhou stranu je například
převod hodnoty na ASCII triviální (přičtení konstanty nebo <strong>OR</strong>
konstanty) a obejde se bez bitových posunů, maskování nebo dokonce provedení
operace dělení.</p>

<p>Podobně jako pro &bdquo;packed&ldquo; BCD existují instrukce pro korekci
výsledku nazvané <strong>DAA</strong> a <strong>DAS</strong>, existuje pro
&bdquo;unpacked&ldquo; BCD dvojice instrukcí nazvaných <strong>AAA</strong> a
<strong>AAS</strong>, tedy korekce po součtu resp.&nbsp;rozdílu.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Korekce výsledku na jedinou BCD cifru operací <strong>AAA</strong></h2>

<p>Nejprve si ukažme korekci výsledku po součtu dvojice BCD hodnot (a je jedno,
jestli ve formátu &bdquo;packed&ldquo; nebo &bdquo;unpacked&ldquo;) instrukcí
<strong>AAA</strong>. Výsledky porovnáme s&nbsp;korekční instrukcí
<strong>DAA</strong>:</p>

<pre>
        mov  al, 8
        inc  al
        print_hex al   <i>; = 9 (korektní pro všechny formáty, protože cifra nepřetekla na (1)0)</i>
&nbsp;
        mov  al, 9
        inc  al
        print_hex al   <i>; = 0a (korektní pro binární formát)</i>
&nbsp;
        mov  al, 8
        inc  al
        daa
        print_hex al   <i>; = 9 (korektní pro všechny formáty, protože cifra nepřetekla na (1)0)</i>
&nbsp;
        mov  al, 9
        inc  al
        daa
        print_hex al   <i>; = 10 (korektní pro packed BCD)</i>
&nbsp;
        mov  al, 8
        inc  al
        aaa
        print_hex al   <i>; = 9 (korektní pro všechny formáty, protože cifra nepřetekla na (1)0)</i>
&nbsp;
        mov  al, 9
        inc  al
        aaa
        print_hex al   <i>; = 0 (korektní pro unpacked BCD - došlo k přetečení)</i>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;posledním případě je nejenom
nastaven příznak <strong>CF</strong>, ale navíc se i zvýší hodnota
v&nbsp;registru <strong>AH</strong> o jedničku, což by bylo možné využít tehdy,
pokud tento registr obsahuje další (vyšší) cifru.</div></p>

<p>A opět, jak je již zvykem, si uveďme celý příklad:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>; tisk hexadecimalni hodnoty</i>
%macro <strong>print_hex</strong> 1
        mov     bx, hex_digits
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
&nbsp;
        mov     al, cl                <i>; do AL se vlozi horni hexa cifra</i>
        and     al, 0xf0
        shr     al, 1
        shr     al, 1
        shr     al, 1
        shr     al, 1
&nbsp;
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     al, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     al, 0x0f
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        print   message
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        mov  al, 8
        inc  al
        print_hex al
&nbsp;
        mov  al, 9
        inc  al
        print_hex al
&nbsp;
        mov  al, 8
        inc  al
        daa
        print_hex al
&nbsp;
        mov  al, 9
        inc  al
        daa
        print_hex al
&nbsp;
        mov  al, 8
        inc  al
        aaa
        print_hex al
&nbsp;
        mov  al, 9
        inc  al
        aaa
        print_hex al
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db 0x01, 0x01, 0x0d, 0x0a, "$"
&nbsp;
        <i>; prevodni tabulka hodnoty 0-15 na ASCII znak</i>
<strong>hex_digits</strong> db "0123456789abcdef"
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Operace součinu a podílu</h2>

<p>Čipy Intel 8086/8088 již patří do generace mikroprocesorů
s&nbsp;implementovanou operací násobení a dělení (tedy součinu a podílu). Zde
konkrétně se tyto operace rozlišují podle toho, zda se násobí osmibitové či
16bitové operandy (popř.&nbsp;dělí 32bitový dělitel nebo 16bitový dělitel) a
zda má být operace provedena se znaménkem nebo bez znaménka. Tyto operace
nejsou v&nbsp;žádném případě rychlé, což ostatně naznačuje i následující
tabulka:</p>

<table>
<tr><th>Instrukce</th><th>Operace</th><th>Doba trvání</th><th>Stručný popis instrukce</th></tr>
<tr><td>MUL </td><td>AX = AL * 8bit    </td><td>70-77</td><td>součin bezznaménkových hodnot</td></tr>
<tr><td>MUL </td><td>DX:AX = AX * 16bit</td><td>118-133</td><td>součin bezznaménkových hodnot</td></tr>
<tr><td>IMUL</td><td>AX = AL * 8bit    </td><td>80-98</td><td>součin hodnot se znaménkem</td></tr>
<tr><td>IMUL</td><td>DX:AX = AX * 16bit</td><td>128-154</td><td>součin hodnot se znaménkem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>DIV </td><td>AL = AX / 8bit, AH = AX % 8bit</td><td>80-90</td><td>podíl (a zbytek) bezznaménkových hodnot</td></tr>
<tr><td>DIV </td><td>AX = DX:AX / 16bit, DX = DX:AX % 16bit</td><td>144-162</td><td>podíl (a zbytek) bezznaménkových hodnot</td></tr>
<tr><td>IDIV</td><td>AL = AX / 8bit, AH = AX % 8bit</td><td>101-112</td><td>podíl (a zbytek) hodnot se znaménkem</td></tr>
<tr><td>IDIV</td><td>AX = DX:AX / 16bit, DX = DX:AX % 16bit</td><td>165-184</td><td>podíl (a zbytek) hodnot se znaménkem</td></tr>
</table>

<p>I pro tyto operace existují &bdquo;korekční&ldquo; instrukce pro BCD formát,
jak si ukážeme níže a taktéž v&nbsp;navazujícím článku.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Ukázka výpočtu součinu dvou osmibitových hodnot</h2>

<p>Vyzkoušejme si pro zajímavost vynásobit dvě osmibitové hodnoty. Víme již, že
jeden z&nbsp;činitelů musí být uložen v&nbsp;registru <strong>AL</strong> a
16bitový výsledek bude uložen do registru <strong>AX</strong>. Násobení
provedeme instrukcí <strong>MUL</strong>, což znamená, že jak operandy, tak i
výsledek budou bezznaménkové:</p>

<pre>
        mov  al, 6
        mov  ah, 7
        mul  ah
        print_hex al
</pre>

<p>Výsledná vypsaná hodnota bude rovna <strong>2A</strong>, což dekadicky
skutečně znamená 42 (6&times;7).</p>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>; tisk hexadecimalni hodnoty</i>
%macro <strong>print_hex</strong> 1
        mov     bx, hex_digits
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
&nbsp;
        mov     al, cl                <i>; do AL se vlozi horni hexa cifra</i>
        and     al, 0xf0
        shr     al, 1
        shr     al, 1
        shr     al, 1
        shr     al, 1
&nbsp;
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     al, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     al, 0x0f
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        print   message
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        mov  al, 6
        mov  ah, 7
        mul  ah
        print_hex al
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db 0x01, 0x01, 0x0d, 0x0a, "$"
&nbsp;
        <i>; prevodni tabulka hodnoty 0-15 na ASCII znak</i>
<strong>hex_digits</strong> db "0123456789abcdef"
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. BCD korekce po výpočtu součinu instrukcí <strong>AAM</strong></h2>

<p>Po provedení násobení je výsledek uložen v&nbsp;binárním formátu, jak je to
obvyklé. Můžeme ovšem provést nějakou korekci výsledku tak, aby byl součin
transformován do BCD? Na platformě Intel 8086/8088 je to možné, protože tato
platforma nabízí neobvyklou instrukci nazvanou <strong>AAM</strong> neboli
<i>ASCII Adjust After Multiply</i>. Název této operace je poněkud matoucí,
ovšem její funkce je relativně jednoduchá, protože se provedou tyto tři
operace:</p>

<pre>
tmp := AL
AH := tmp / imm8
AL := tmp MOD imm8
</pre>

<p>přičemž platí, že se instrukce <strong>AAM</strong> přeloží tak, že druhý
bajt instrukčního kódu obsahuje konstantu <strong>imm8</strong> nastavenou na
10. To znamená, že <strong>AAM</strong> vypočítá nejnižší cifru výsledku a
uloží ji do <strong>AL</strong>. Hodnotu výsledku podělenou deseti pak uloží do
registru <strong>AH</strong>, takže opakovaným prováděním instrukce
<strong>AAM</strong> můžeme získat jednotlivé cifry. Jednoduché řešení, že?</p>

<p><div class="rs-tip-major">Poznámka: ruční úpravou (zakódováním) druhého
bajtu instrukce lze realizovat například převody z&nbsp;osmičkové soustavy, ze
soustavy dvanáctkové, šedesátkové (to je užitečné při práci s&nbsp;časem!) atd.
Některé klony Intel 8086 však tento bajt neinterpretovaly, takže se jedná o
obecně mírně nebezpečný trik.</div></p>

<p>Podívejme se nyní, jak získáme jednotlivé cifry výsledku operace 6&times;7.
Víme, že se bude jednat o dvouciferný výsledek, takže pouze zobrazíme
<strong>AL</strong> (nižší cifru) a potom <strong>AH</strong> (výsledek po
vydělení 10, nyní přímo vyšší cifru):</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>; tisk hexadecimalni hodnoty</i>
%macro <strong>print_hex</strong> 1
        mov     bx, hex_digits
        mov     cl, %1                <i>; zapamatovat si predanou hodnotu</i>
&nbsp;
        mov     al, cl                <i>; do AL se vlozi horni hexa cifra</i>
        and     al, 0xf0
        shr     al, 1
        shr     al, 1
        shr     al, 1
        shr     al, 1
&nbsp;
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message], al         <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        mov     al, cl                <i>; do BL se vlozi dolni hexa cifra</i>
        and     al, 0x0f
        xlat                          <i>; prevod hodnoty 0-15 na ASCII znak</i>
        mov     [message + 1], al     <i>; zapis ASCII znaku do retezce</i>
&nbsp;
        print   message
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        mov  al, 6
        mov  ah, 7
        mul  ah      <i>; nasobek</i>
        aam          <i>; naplni se AX</i>
        shl ah, 1    <i>; vysuneme cifru do hornich 4 bitu</i>
        shl ah, 1 
        shl ah, 1 
        shl ah, 1 
        or  al, ah   <i>; spojime dve BCD cifry</i>
        print_hex al
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db 0x01, 0x01, 0x0d, 0x0a, "$"
&nbsp;
        <i>; prevodni tabulka hodnoty 0-15 na ASCII znak</i>
<strong>hex_digits</strong> db "0123456789abcdef"
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Řetězcové a blokové operace podporované mikroprocesory Intel 8086/8088</h2>

<p>Zcela specifickou vlastností mikroprocesorů řady Intel 8086/8088 jsou
instrukce určené pro provádění řetězcových a blokových operací. Tyto instrukce
dokážou přečíst popř.&nbsp;zapsat (popř.&nbsp;provést obě operace za sebou)
bajt či slovo z&nbsp;adresy určené segmentovým a indexovým registrem, přičemž
se příslušným způsobem upraví hodnota indexového registru: zvýší či sníží se o
jedničku. Navíc lze prefixem <strong>REP</strong> (a jeho variantami) zajistit
opakování těchto instrukcí, takže je například možné přenést celý řetězec či
blok jedinou instrukcí. To znamená velkou úsporu místa (programový kód) a
částečně i času (rychlejší provádění instrukcí), ovšem je nutné mít připraveny
všechny adresy v&nbsp;příslušných registrech, mít korektně nastaven příznak
určující, zda se mají adresy zvyšovat či snižovat a při opakování instrukcí je
nutné mít i nastaveno počitadlo. A především &ndash; překladače vyšších
programovacích jazyků musí být schopné tyto instrukce využít (což se zpočátku
nedělo, takže tato vlastnost čipů Intel 8086 nebyla plně využívána).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Varianty řetězcových a blokových operací</h2>

<p>V&nbsp;instrukčním souboru mikroprocesorů Intel 8086 nalezneme následující
instrukce realizující řetězcové a blokové operace popř.&nbsp;jejich
nastavení:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis instrukce</th></tr>
<tr><td>CLD</td><td>nastaví příznak DF pro určení směru přenosu (nahoru/dolů)</td></tr>
<tr><td>STD</td><td>nastaví příznak DF pro určení směru přenosu (nahoru/dolů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>LODSB</td><td>načtení bajtu do AL z DS:[SI], zvýšení/snížení SI o 1</td></tr>
<tr><td>LODSW</td><td>načtení slova do AX z DS:[SI], zvýšení/snížení SI o 2</td></tr>
<tr><td>STOSB</td><td>uložení slova z AL do ES:[DI], zvýšení/snížení DI o 1</td></tr>
<tr><td>STOSW</td><td>uložení slova z AL do ES:[DI], zvýšení/snížení DI o 2</td></tr>
<tr><td>MOVSB</td><td>kombinace LODSB + STOSB v&nbsp;jediné instrukci</td></tr>
<tr><td>MOVSW</td><td>kombinace LODSW + STOSW v&nbsp;jediné instrukci</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CMPSB</td><td>porovnání dvou bajtů z&nbsp;DS:[SI] a ES:[DI], zvýšení/snížení SI a DI</td></tr>
<tr><td>CMPSW</td><td>porovnání dvou slov z&nbsp;DS:[SI] a ES:[DI], zvýšení/snížení SI a DI</td></tr>
<tr><td>SCASB</td><td>nalezení bajtu v&nbsp;AL na adrese DS:[SI] (mění příznaky)</td></tr>
<tr><td>SCASW</td><td>nalezení bajtu v&nbsp;AX na adrese DS:[SI] (mění příznaky)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>INSB</td><td>přečtení bajtu z&nbsp;portu, uložení na ES:[DI], zvýšení/snížení DI</td></tr>
<tr><td>OUTSB</td><td>zápis bajtu na port z&nbsp;DS:[SI], zvýšení/snížení SI</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>REP/REPE/REPZ</td><td>opakování další operace CX-krát</td></tr>
<tr><td>REPNE/REPNZ</td><td>opakování další operace CX-krát, nebo až bude ZF==1</td></tr>
</table>

<p>Jednotlivé instrukce i jejich varianty si pochopitelně postupně popíšeme.
Taktéž se zmíníme o rychlosti provedení těchto operací, protože to může být
v&nbsp;reálných programech kritickým místem.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Zápis několika po sobě jdoucích znaků do řetězce</h2>

<p>Pokusme se nyní do následujícího řetězce:</p>

<pre>
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
message db "Hello, world!", 0x0d, 0x0a, "$"
</pre>

<p>zapsat namísto prvního slova pětici hvězdiček, tj.&nbsp;výsledek by měl
vypadat takto: &bdquo;*****, world!\r\n!&ldquo;</p>

<p>Tuto operaci lze provést následujícím způsobem:</p>

<ol>
<li>Do dvojice registrů <strong>ES:DI</strong> vložíme adresu prvního znaku (tedy znaku &bdquo;H&ldquo;)</li>
<li>Do registru <strong>AL</strong> vložíme ASCII hodnotu hvězdičky</li>
<li>(Měl by se nastavit i příznak DF, ten je však při startu korektní)</li>
<li>Pětkrát zopakujeme instrukci <strong>STOSB</strong>, která vlastně provede <strong>mov ES:[DI], AL</strong> + <strong>inc AL</strong></li>
</ol>

<p>V&nbsp;assembleru to vypadá následovně (prozatím otrocky opíšeme
<strong>STOSB</strong> pětkrát):</p>

<pre>
        push cs
        pop  es   <i>; ES:DI obsahuje adresu prvniho znaku ve zprave</i>
        mov di, message
&nbsp;
        mov al, "*"
&nbsp;
        stosb     <i>; zapis hvezdicky a posun adresy</i>
        stosb     <i>; zapis hvezdicky a posun adresy</i>
        stosb     <i>; zapis hvezdicky a posun adresy</i>
        stosb     <i>; zapis hvezdicky a posun adresy</i>
        stosb     <i>; zapis hvezdicky a posun adresy</i>
</pre>

<p>Výsledkem bude očekávaný řetězec, což si ostatně můžeme velmi snadno ověřit
na reálném PC nebo v&nbsp;DOSBoxu překladem a spuštěním tohoto příkladu:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        print message
&nbsp;
        push cs
        pop  es   <i>; ES:DI obsahuje adresu prvniho znaku ve zprave</i>
        mov di, message
&nbsp;
        mov al, "*"
&nbsp;
        stosb     <i>; zapis hvezdicky a posun adresy</i>
        stosb     <i>; zapis hvezdicky a posun adresy</i>
        stosb     <i>; zapis hvezdicky a posun adresy</i>
        stosb     <i>; zapis hvezdicky a posun adresy</i>
        stosb     <i>; zapis hvezdicky a posun adresy</i>
&nbsp;
        print message
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db "Hello, world!", 0x0d, 0x0a, "$"
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Vylepšení předchozího příkladu: opakování instrukce <strong>STOSB</strong> CX-krát</h2>

<p>Demonstrační příklad <a href="#k15">z&nbsp;předchozí kapitoly</a> lze
upravit takovým způsobem, aby se instrukce <strong>STOSB</strong> v&nbsp;kódu
vyskytovala pouze jedenkrát. Postačuje před ní vložit prefixovou instrukci
<strong>REP</strong>, která zajistí opakování CX-krát. Celý postup by tedy měl
vypadat následovně:</p>

<ol>
<li>Do dvojice registrů <strong>ES:DI</strong> vložíme adresu prvního znaku (tedy znaku &bdquo;H&ldquo;)</li>
<li>Do registru <strong>AL</strong> vložíme ASCII hodnotu hvězdičky</li>
<li>(Měl by se nastavit i příznak DF, ten je však při startu korektní)</li>
<li>Do registru <strong>CX</strong> vložíme konstantu 5</li>
<li>Spustíme instrukci <strong>REP STOSB</strong>, která vlastně CX-krák provede <strong>mov ES:[DI], AL</strong> + <strong>inc AL</strong></li>
</ol>

<p>V&nbsp;assembleru lze tuto posloupnost instrukcí realizovat snadno:</p>

<pre>
        push cs
        pop  es   <i>; ES:DI obsahuje adresu prvniho znaku ve zprave</i>
        mov di, message
&nbsp;
        mov al, "*"
        mov cx, 5
        rep stosb <i>; zapis peti hvezdicek</i>
</pre>

<p>Výsledek bude odpovídat předchozímu příkladu.</p>

<p>Pro úplnost si uveďme výpis zdrojového kódu, který je velmi krátký:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        print message
&nbsp;
        push cs
        pop  es   <i>; ES:DI obsahuje adresu prvniho znaku ve zprave</i>
        mov di, message
&nbsp;
        mov al, "*"
        mov cx, 5
        rep stosb <i>; zapis peti hvezdicek</i>
&nbsp;
        print message
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong> db "Hello, world!", 0x0d, 0x0a, "$"
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Překlad řetězcových instrukcí s&nbsp;prefixem i bez prefixu</h2>

<p>Zajímavé bude zjistit, jak jsou vlastně řetězcové instrukce zakódovány ve
strojovém kódu a jak jejich kód ovlivňuje použití prefixu <strong>REP</strong>.
Podívejme se tedy nejdříve na výpis strojového kódu příkladu s&nbsp;opakujícími
se instrukcemi <strong>STOSB</strong>:</p>

<pre>
    22                                  ;-----------------------------------------------------------------------------
    23                                  org  0x100        ; zacatek kodu pro programy typu COM (vzdy se zacina na 256)
    24                                  
    25                                  start:
    26                                          print message
    17 00000000 BA[1F00]            &lt;1&gt;  mov dx, %1
    18 00000003 B409                &lt;1&gt;  mov ah, 9
    19 00000005 CD21                &lt;1&gt;  int 0x21
    27                                  
    28 00000007 0E                              push cs
    29 00000008 07                              pop  es   ; ES:DI obsahuje adresu prvniho znaku ve zprave
    30 00000009 BF[1F00]                        mov di, message
    31                                  
    32 0000000C B02A                            mov al, "*"
    33                                  
    34 0000000E AA                              stosb     ; zapis hvezdicky a posun adresy
    35 0000000F AA                              stosb     ; zapis hvezdicky a posun adresy
    36 00000010 AA                              stosb     ; zapis hvezdicky a posun adresy
    37 00000011 AA                              stosb     ; zapis hvezdicky a posun adresy
    38 00000012 AA                              stosb     ; zapis hvezdicky a posun adresy
    39                                  
    40                                          print message
    17 00000013 BA[1F00]            &lt;1&gt;  mov dx, %1
    18 00000016 B409                &lt;1&gt;  mov ah, 9
    19 00000018 CD21                &lt;1&gt;  int 0x21
    41                                  
    42                                          wait_key
    11 0000001A 31C0                &lt;1&gt;  xor ax, ax
    12 0000001C CD16                &lt;1&gt;  int 0x16
    43                                          exit
     6 0000001E C3                  &lt;1&gt;  ret
    44                                  
    45                                          ; retezec ukonceny znakem $
    46                                          ; (tato data jsou soucasti vysledneho souboru typu COM)
    47 0000001F 48656C6C6F2C20776F-     message db "Hello, world!", 0x0d, 0x0a, "$"
    47 00000028 726C64210D0A24     
</pre>

<p>Z&nbsp;výpisu je patrné, že tak složitá instrukce, jakou
<strong>STOSB</strong> interně je, je zakódována jen jediným bajtem
<strong>0xaa</strong>.</p>

<p>Ve druhém kroku se podívejme na příklad s&nbsp;instrukcí <strong>REP
STOSB</strong>:</p>

<pre>
    22                                  ;-----------------------------------------------------------------------------
    23                                  org  0x100        ; zacatek kodu pro programy typu COM (vzdy se zacina na 256)
    24                                  
    25                                  start:
    26                                          print message
    17 00000000 BA[1F00]            &lt;1&gt;  mov dx, %1
    18 00000003 B409                &lt;1&gt;  mov ah, 9
    19 00000005 CD21                &lt;1&gt;  int 0x21
    27                                  
    28 00000007 0E                              push cs
    29 00000008 07                              pop  es   ; ES:DI obsahuje adresu prvniho znaku ve zprave
    30 00000009 BF[1F00]                        mov di, message
    31                                  
    32 0000000C B02A                            mov al, "*"
    33 0000000E B90500                          mov cx, 5
    34 00000011 F3AA                            rep stosb ; zapis peti hvezdicek
    35                                  
    36                                          print message
    17 00000013 BA[1F00]            &lt;1&gt;  mov dx, %1
    18 00000016 B409                &lt;1&gt;  mov ah, 9
    19 00000018 CD21                &lt;1&gt;  int 0x21
    37                                  
    38                                          wait_key
    11 0000001A 31C0                &lt;1&gt;  xor ax, ax
    12 0000001C CD16                &lt;1&gt;  int 0x16
    39                                          exit
     6 0000001E C3                  &lt;1&gt;  ret
    40                                  
    41                                          ; retezec ukonceny znakem $
    42                                          ; (tato data jsou soucasti vysledneho souboru typu COM)
    43 0000001F 48656C6C6F2C20776F-     message db "Hello, world!", 0x0d, 0x0a, "$"
    43 00000028 726C64210D0A24     
</pre>

<p>Z&nbsp;výpisu je patrné použití dvou bajtů s&nbsp;hodnotami
<strong>0xf3</strong> <strong>0xaa</strong>. To opět není mnoho a jen to
potvrzuje domněnku, že se mělo jednat o centrální instrukce čipu Intel 8086
(tyto instrukce jsou kratší, než běžné <strong>MOV</strong> nebo
<strong>INC</strong>).</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujícího článku</h2>

<p>V&nbsp;navazujícím článku dokončíme popis instrukčního souboru
mikroprocesorů Intel 8086/8088. Zejména si doplníme informaci o řetězcových a
blokových instrukcích (doby jejich provedení, některé optimalizace atd.) a
taktéž se zmíníme o způsobu kódování instrukcí do strojového kódu.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>cga_text_mode_1.asm</td><td>standardní textový režim s&nbsp;rozlišením 40&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm</a></td></tr>
<tr><td>27</td><td>cga_text_mode_3.asm</td><td>standardní textový režim s&nbsp;rozlišením 80&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm</a></td></tr>
<tr><td>28</td><td>cga_text_mode_intensity.asm</td><td>změna významu nejvyššího bitu atributového bajtu: vyšší intenzita namísto blikání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm</a></td></tr>
<tr><td>29</td><td>cga_text_mode_cursor.asm</td><td>změna tvaru textového kurzoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm</a></td></tr>
<tr><td>30</td><td>cga_text_gfx_1.asm</td><td>zobrazení &bdquo;rastrové mřížky&ldquo;: pseudografický režim 160&times;25 pixelů (interně textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm</a></td></tr>
<tr><td>31</td><td>cga_text_mode_char_height.asm</td><td>změna výšky znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm</a></td></tr>
<tr><td>32</td><td>cga_text_160x100.asm</td><td>grafický režim 160&times;100 se šestnácti barvami (interně upravený textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>hercules_text_mode_1.asm</td><td>využití standardního textového režimu společně s&nbsp;kartou Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm</a></td></tr>
<tr><td>34</td><td>hercules_text_mode_2.asm</td><td>zákaz blikání v&nbsp;textových režimech</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm</a></td></tr>
<tr><td>35</td><td>hercules_turn_off.asm</td><td>vypnutí generování video signálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm</a></td></tr>
<tr><td>36</td><td>hercules_gfx_mode_1.asm</td><td>přepnutí karty Hercules do grafického režimu (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm</a></td></tr>
<tr><td>37</td><td>hercules_gfx_mode_2.asm</td><td>přepnutí karty Hercules do grafického režimu (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm</a></td></tr>
<tr><td>38</td><td>hercules_putpixel.asm</td><td>subrutina pro vykreslení jediného pixelu na kartě Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>ega_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm</a></td></tr>
<tr><td>40</td><td>ega_text_mode_80x43.asm</td><td>zobrazení 43 textových řádků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm</a></td></tr>
<tr><td>41</td><td>ega_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm</a></td></tr>
<tr><td>42</td><td>ega_gfx_mode_640x200.asm</td><td>přepnutí do grafického režimu 640&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm</a></td></tr>
<tr><td>43</td><td>ega_gfx_mode_640x350.asm</td><td>přepnutí do grafického režimu 640&times;350 pixelů se čtyřmi nebo šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm</a></td></tr>
<tr><td>44</td><td>ega_gfx_mode_bitplanes_1.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (základní způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm</a></td></tr>
<tr><td>45</td><td>ega_gfx_mode_bitplanes_2.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (rychlejší způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>ega_320x200_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm</a></td></tr>
<tr><td>47</td><td>ega_640x350_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 640&times;350 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>ega_standard_font.asm</td><td>použití standardního fontu grafické karty EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm</a></td></tr>
<tr><td>49</td><td>ega_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>ega_palette_1.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 320&times;200 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm</a></td></tr>
<tr><td>51</td><td>ega_palette_2.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 640&times;350 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm</a></td></tr>
<tr><td>52</td><td>ega_palette_3.asm</td><td>změna všech barev v&nbsp;barvové paletě s&nbsp;využitím programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm</a></td></tr>
<tr><td>53</td><td>ega_palette_4.asm</td><td>změna všech barev, včetně barvy okraje, v&nbsp;barvové paletě voláním funkce BIOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>vga_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm</a></td></tr>
<tr><td>55</td><td>vga_text_mode_80x50.asm</td><td>zobrazení 50 a taktéž 28 textových řádků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm</a></td></tr>
<tr><td>56</td><td>vga_text_mode_intensity_1.asm</td><td>změna chování atributového bitu pro blikání (nebezpečná varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm</a></td></tr>
<tr><td>57</td><td>vga_text_mode_intensity_2.asm</td><td>změna chování atributového bitu pro blikání (bezpečnější varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm</a></td></tr>
<tr><td>58</td><td>vga_text_mode_9th_column.asm</td><td>modifikace způsobu zobrazení devátého sloupce ve znakových režimech (720 pixelů na řádku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm</a></td></tr>
<tr><td>59</td><td>vga_text_mode_cursor_shape.asm</td><td>změna tvaru textového kurzoru na grafické kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm</a></td></tr>
<tr><td>60</td><td>vga_text_mode_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>vga_gfx_mode_640x480.asm</td><td>přepnutí do grafického režimu 640&times;480 pixelů se šestnácti barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm</a></td></tr>
<tr><td>62</td><td>vga_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů s&nbsp;256 barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm</a></td></tr>
<tr><td>63</td><td>vga_gfx_mode_palette.asm</td><td>změna všech barev v&nbsp;barvové paletě grafické karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm</a></td></tr>
<tr><td>64</td><td>vga_gfx_mode_dac_1.asm</td><td>využití DAC (neočekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm</a></td></tr>
<tr><td>65</td><td>vga_gfx_mode_dac_2.asm</td><td>využití DAC (očekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>66</td><td>vga_640x480_putpixel.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 640&times;480 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm</a></td></tr>
<tr><td>67</td><td>vga_320x200_putpixel_1.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm</a></td></tr>
<tr><td>68</td><td>vga_320x200_putpixel_2.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (rychlejší varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>vga_gfx_mode_dac_3.asm</td><td>přímé využití DAC v&nbsp;grafickém režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>70</td><td>vga_gfx_mode_unchained_step_1.asm</td><td>zobrazení barevných pruhů v&nbsp;režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm</a></td></tr>
<tr><td>71</td><td>vga_gfx_mode_unchained_step_2.asm</td><td>vypnutí zřetězení bitových rovin a změna způsobu adresování pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm</a></td></tr>
<tr><td>72</td><td>vga_gfx_mode_unchained_step_3.asm</td><td>vykreslení barevných pruhů do vybraných bitových rovin</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>73</td><td>vga_gfx_mode_320x400.asm</td><td>nestandardní grafický režim s&nbsp;rozlišením 320&times;400 pixelů a 256 barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm</a></td></tr>
<tr><td>74</td><td>vga_320x200_image.asm</td><td>zobrazení rastrového obrázku ve standardním grafickém režimu 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm</a></td></tr>
<tr><td>75</td><td>vga_320x200_unchained_image_1.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (nekorektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm</a></td></tr>
<tr><td>76</td><td>vga_320x200_unchained_image_2.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (korektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm</a></td></tr>
<tr><td>77</td><td>vga_320x400_unchained_image.asm</td><td>zobrazení rastrového obrázku v&nbsp;nestandardním režimu 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>78</td><td>vga_vertical_scroll_1.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm</a></td></tr>
<tr><td>79</td><td>vga_vertical_scroll_2.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm</a></td></tr>
<tr><td>80</td><td>vga_split_screen_1.asm</td><td>režim split-screen a scrolling, nefunční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm</a></td></tr>
<tr><td>81</td><td>vga_split_screen_2.asm</td><td>režim split-screen a scrolling, plně funkční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm</a></td></tr>
<tr><td>82</td><td>vga_horizontal_scroll_1.asm</td><td>horizontální scrolling bez rozšíření počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm</a></td></tr>
<tr><td>83</td><td>vga_horizontal_scroll_2.asm</td><td>horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm</a></td></tr>
<tr><td>84</td><td>vga_horizontal_scroll_3.asm</td><td>jemný horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>85</td><td>vga_320x240_image.asm</td><td>nastavení grafického režimu Mode-X, načtení a vykreslení obrázku, scrolling</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>86</td><td>io.asm</td><td>knihovna maker pro I/O operace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm</a></td></tr>
<tr><td>87</td><td>vga_lib.asm</td><td>knihovna maker a podprogramů pro programování karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm</a></td></tr>
<tr><td>88</td><td>vga_320x240_lib.asm</td><td>nastavení grafického režimu Mode-X, tentokrát knihovními funkcemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>89</td><td>vga_bitblt_1.asm</td><td>první (naivní) implementace operace <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm</a></td></tr>
<tr><td>90</td><td>vga_bitblt_2.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm</a></td></tr>
<tr><td>91</td><td>vga_bitblt_3.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro čtení i zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm</a></td></tr>
<tr><td>92</td><td>vga_bitblt_4.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace makry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm</a></td></tr>
<tr><td>93</td><td>vga_bitblt_5.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace podprogramem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>94</td><td>vga_bitblt_rotate.asm</td><td>zápisový režim s&nbsp;rotací bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm</a></td></tr>
<tr><td>95</td><td>vga_bitblt_fast.asm</td><td>rychlá korektní 32bitová operace typu <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm</a></td></tr>
<tr><td>96</td><td>vga_320x400_bitblt_1.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (neúplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm</a></td></tr>
<tr><td>97</td><td>vga_320x400_bitblt_2.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (úplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm</a></td></tr>
<tr><td>98</td><td>vga_write_modes_1.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis bez úpravy latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm</a></td></tr>
<tr><td>99</td><td>vga_write_modes_2.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis s&nbsp;modifikací latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm</a></td></tr>
<tr><td>100</td><td>vga_write_modes_3.asm</td><td>volitelné zápisové režimy grafické karty VGA, cílená modifikace latche vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>101</td><td>instruction_jump.asm</td><td>použití instrukce <strong>JMP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jump.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jump.asm</a></td></tr>
<tr><td>102</td><td>instruction_jnz.asm</td><td>použití instrukce <strong>JNZ</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jnz.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jnz.asm</a></td></tr>
<tr><td>103</td><td>instruction_jz_jmp.asm</td><td>použití instrukcí <strong>JZ</strong> a <strong>JMP</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jz_jmp.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jz_jmp.asm</a></td></tr>
<tr><td>104</td><td>instruction_loop.asm</td><td>použití instrukce <strong>LOOP</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_loop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>105</td><td>instruction_template.asm</td><td>šablona všech následujících demonstračních příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_template.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_template.asm</a></td></tr>
<tr><td>106</td><td>instruction_print_hex.asm</td><td>tisk osmibitové hexadecimální hodnoty</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_print_hex.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_print_hex.asm</a></td></tr>
<tr><td>107</td><td>instruction_xlat.asm</td><td>využití instrukce <strong>XLAT</strong> pro získání tisknutelné hexadecimální cifry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_xlat.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_xlat.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>108</td><td>instruction_daa.asm</td><td>operace součtu s&nbsp;využitím binární i BCD aritmetiky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa.asm</a></td></tr>
<tr><td>109</td><td>instruction_daa_sub.asm</td><td>instrukce <strong>DAA</strong> po provedení operace rozdílu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa_sub.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa_sub.asm</a></td></tr>
<tr><td>110</td><td>instruction_das.asm</td><td>instrukce <strong>DAS</strong> po provedení operace rozdílu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_das.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_das.asm</a></td></tr>
<tr><td>111</td><td>instruction_aaa.asm</td><td>korekce výsledku na jedinou BCD cifru operací <strong>AAA</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aaa.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aaa.asm</a></td></tr>
<tr><td>112</td><td>instruction_mul.asm</td><td>ukázka výpočtu součinu dvou osmibitových hodnot</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_mul.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_mul.asm</a></td></tr>
<tr><td>113</td><td>instruction_aam.asm</td><td>BCD korekce po výpočtu součinu instrukcí <strong>AAM</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aam.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aam.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>114</td><td>instruction_stosb.asm</td><td>blokový zápis dat instrukcí <strong>STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_stosb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_stosb.asm</a></td></tr>
<tr><td>115</td><td>instruction_rep_stosb.asm</td><td>opakované provádění instrukce <strong>STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_stosb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_stosb.asm</a></td></tr>
<tr><td>116</td><td>instruction_lodsb.asm</td><td>čtení dat instrukcí <strong>LODSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_lodsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_lodsb.asm</a></td></tr>
<tr><td>117</td><td>instruction_movsb.asm</td><td>přenos jednoho bajtu instrukcí <strong>MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_movsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_movsb.asm</a></td></tr>
<tr><td>118</td><td>instruction_rep_movsb.asm</td><td>blokový přenos po bajtech instrukcí <strong>MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_movsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_movsb.asm</a></td></tr>
<tr><td>119</td><td>instruction_rep_scas.asm</td><td>vyhledávání v&nbsp;řetězci instrukcí <strong>SCAS</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_scas.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_scas.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>6845 - Motorola CRT Controller<br />
<a href="https://stanislavs.org/helppc/6845.html">https://stanislavs.org/helppc/6845.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

<li>Programmer's Guide to Yamaha YMF 262/OPL3 FM Music Synthesizer<br />
<a href="https://moddingwiki.shikadi.net/wiki/OPL_chip">https://moddingwiki.shikadi.net/wiki/OPL_chip</a>
</li>

<li>Does anybody understand how OPL2 percussion mode works?<br />
<a href="https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/">https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/</a>
</li>

<li>Yamaha YMF262 OPL3 music - MoonDriver for OPL3 DEMO [Oscilloscope View]<br />
<a href="https://www.youtube.com/watch?v=a7I-QmrkAak">https://www.youtube.com/watch?v=a7I-QmrkAak</a>
</li>

<li>Yamaha OPL vs OPL2 vs OPL3 comparison<br />
<a href="https://www.youtube.com/watch?v=5knetge5Gs0">https://www.youtube.com/watch?v=5knetge5Gs0</a>
</li>

<li>OPL3 Music Crockett's Theme<br />
<a href="https://www.youtube.com/watch?v=HXS008pkgSQ">https://www.youtube.com/watch?v=HXS008pkgSQ</a>
</li>

<li>Bad Apple (Adlib Tracker - OPL3)<br />
<a href="https://www.youtube.com/watch?v=2lEPH6Y3Luo">https://www.youtube.com/watch?v=2lEPH6Y3Luo</a>
</li>

<li>FM Synthesis Chips, Codecs and DACs<br />
<a href="https://www.dosdays.co.uk/topics/fm_synthesizers.php">https://www.dosdays.co.uk/topics/fm_synthesizers.php</a>
</li>

<li>The Zen Challenge - YMF262 OPL3 Original (For an upcoming game)<br />
<a href="https://www.youtube.com/watch?v=6JlFIFz1CFY">https://www.youtube.com/watch?v=6JlFIFz1CFY</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

