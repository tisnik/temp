<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Zobrazení čísel a zpracování příznaků mikroprocesoru Zilog Z80</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Zobrazení čísel a zpracování příznaků mikroprocesoru Zilog Z80</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V osmé části seriálu o vývoji programů pro legendární osmibitový domácí mikropočítač ZX Spectrum si nejprve ukážeme, jakým způsobem lze s využitím standardního podprogramu z ROM tisknout celá čísla. Tyto znalosti použijeme při zkoumání příznaků (flags) mikroprocesoru Zilog Z80, jejichž detailní znalost je při programování v assembleru nedocenitelná.</a>



<h2>Obsah</h2>

<p><a href="#k01">1. Zobrazení čísel a zpracování příznaků mikroprocesoru Zilog Z80</a></p>
<p><a href="#k02">2. Podprogram pro tisk celočíselné hodnoty v&nbsp;rozsahu 0 až 9999</a></p>
<p><a href="#k03">3. Ukázka použití podprogramu pro tisk celého čísla</a></p>
<p><a href="#k04">4. Výsledek pokusu o vytištění záporných čísel</a></p>
<p><a href="#k05">5. Tisk maximální podporované hodnoty a pokus o vytištění vyšší hodnoty</a></p>
<p><a href="#k06">6. Vytištění číselné řady</a></p>
<p><a href="#k07">7. Kombinace s&nbsp;dalšími subrutinami</a></p>
<p><a href="#k08">8. Příznaky mikroprocesoru Zilog Z80</a></p>
<p><a href="#k09">9. Seznam instrukcí, které modifikují příznakové bity</a></p>
<p><a href="#k10">10. Zobrazení obsahu příznakového registru <strong>F</strong> po provedení vybrané operace</a></p>
<p><a href="#k11">11. Příznakové bity po provedení celočíselné operace 1+2</a></p>
<p><a href="#k12">12. Příznakové bity po provedení celočíselné operace 0+0</a></p>
<p><a href="#k13">13. Příznakové bity po provedení operace 255+1</a></p>
<p><a href="#k14">14. Příznakové bity po provedení operace 254+1</a></p>
<p><a href="#k15">15. Příznakové bity po provedení operace 255+255</a></p>
<p><a href="#k16">16. Příznakové bity po provedení operace 100+100</a></p>
<p><a href="#k17">17. První shrnutí: význam příznaků C, V, S a Z</a></p>
<p><a href="#k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Zobrazení čísel a zpracování příznaků mikroprocesoru Zilog Z80</h2>

<p>V&nbsp;úvodní části dnešního článku si ukážeme způsob použití standardního
podprogramu (subrutiny) uloženého v&nbsp;paměti ROM, který slouží pro výpis
celých čísel na obrazovku. Tento podprogram byl sice původně určen pro
specifické účely (konkrétně pro výpis čísel řádků v&nbsp;Sinclair BASICu),
ovšem i přes jeho některá omezení bude podpora pro výpis numerických hodnot
velmi užitečná v&nbsp;navazující části článku.</p>

*** image ***
<p><i>Obrázek 1: Výpis numerických hodnot na obrazovku podprogramem uloženým
v&nbsp;ROM.</i></p>

<p>Navíc se podrobněji zmíníme o problematice příznaků (<i>flags</i>), které
jsou nastavovány některými instrukcemi a které lze využít jak
v&nbsp;podmíněných skocích, tak i v&nbsp;dalších typech strojových instrukcí
(rotacích atd). Prozatím jsme totiž používali pouze dva příznaky, a to
konkrétně <strong>carry</strong> (příznak přenosu) a <strong>zero</strong>
(příznak nulovosti), ovšem mikroprocesor Zilog Z80 kromě toho nabízí i další
příznaky, které lze využít jak ve výpočtech s&nbsp;hodnotami se znaménkem, tak
i při realizaci některých optimalizací.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podprogram pro tisk celočíselné hodnoty v&nbsp;rozsahu 0 až 9999</h2>

<p>Jak jsme si již naznačili <a href="#k01">v&nbsp;úvodní kapitole</a>,
popíšeme si v&nbsp;dnešním článku nejdříve způsob použití standardního
podprogramu uloženého v&nbsp;paměti ROM, který dokáže vypsat hodnotu celého
čísla na obrazovku a přitom posunout pomyslný (neviditelný) kurzor takovým
způsobem, aby tisk dalších znaků následoval až za nově zobrazeným číslem. Tento
podprogram, jenž je i s&nbsp;dalšími podrobnostmi popsán například na stránce
<a
href="https://skoolkid.github.io/rom/asm/1A1B.html">https://skoolkid.github.io/rom/asm/1A1B.html</a>,
začíná na adrese <strong>0x1A1B</strong> a očekává na vstupu celé
šestnáctibitové číslo uložené v&nbsp;registrovém páru <strong>BC</strong>
(připomeňme si, že ROM je mapována od <strong>0x0000</strong> do
<strong>0x3fff</strong>). Číslo předané v&nbsp;registrovém páru
<strong>BC</strong> je vytištěno a přitom subrutina nenávratně modifikuje obsah
akumulátoru <strong>A</strong> a již zmíněného registrového páru
<strong>BC</strong> (a podle očekávání i příznaků). Ostatní dva registrové páry
<strong>DE</strong> a <strong>HL</strong> nejsou touto subrutinou modifikovány
(jsou totiž uloženy na zásobník a před koncem subrutiny jsou obnoveny).</p>

*** image ***
<p><i>Obrázek 2: Tento podprogram je využíván například interpretrem Sinclair
BASICu pro zobrazení čísel řádků.</i></p>

<p><div class="rs-tip-major">Poznámka: numerická hodnota se vytiskne
v&nbsp;decimální soustavě.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázka použití podprogramu pro tisk celého čísla</h2>

<p>Základní způsob použití výše zmíněného podprogramu je ve skutečnosti až
triviální. Pouze nám postačuje smazat obrazovku (či alternativně otevřít kanál
pro zápis na obrazovku &ndash; <i>screen</i>), vložit do registrového páru
<strong>BC</strong> celočíselnou hodnotu, která se má vypsat a následně zavolat
subrutinu pro tisk celého čísla. Vše lze realizovat čtyřmi (resp.&nbsp;jak
uvidíme o odstavec dále, tak jen třemi) instrukcemi:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
        ld   BC, 1234   <i>; numerická hodnota, kterou chceme vytisknout</i>
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Způsob překladu tohoto programu do strojového kódu bude vypadat
následovně:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:01D204     LD BC, 04D2
8006:CD1B1A     CALL 1A1B
8009:C9         RET
800A:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8009
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm</a>.</div></p>

<p>Podívejme se na výsledek tak, jak ho uvidíme na obrazovce ZX Spectra:</p>

*** image ***
<p><i>Obrázek 3: Hodnota 1234 vytištěná na obrazovce ZX Spectra.</i></p>

<p>Poznámka na okraj &ndash; v&nbsp;případě, že program končí dvojicí instrukcí
<strong>CALL</strong> + <strong>RET</strong>, můžeme program o jednu instrukci
zkrátit. Je tomu tak z&nbsp;toho důvodu, že volaná subrutina (jakákoli) končí
instrukcí <strong>RET</strong> (nebo její podmíněnou variantou), takže můžeme
tuto instrukci &bdquo;zneužít&ldquo; pro přímý návrat do BASICu. To konkrétně
znamená, že následující dvojici řádků:</p>

<pre>
call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
ret             <i>; návrat z programu do BASICu</i>
</pre>

<p>je možné nahradit za jedinou instrukci:</p>

<pre>
jp OUT_NUM_1    <i>; zavolání rutiny pro výpis celého čísla + návrat</i>
</pre>

<p>V&nbsp;dnešních demonstračních příkladech ovšem ponechávám delší variantu,
aby bylo možné snadno a bez většího přemýšlení za volání
<strong>OUT_NUM_1</strong> přidat další instrukce.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výsledek pokusu o vytištění záporných čísel</h2>

<p>Již v&nbsp;úvodním textu jsme si řekli, že standardní subrutina
<strong>OUT_NUM_1</strong> byla původně určena pro tisk čísel řádků
v&nbsp;Sinclair BASICu. S&nbsp;tím do značné míry souvisí i různá omezení,
které tato subrutina má. Například nedokáže korektně vytisknout záporná čísla
(to ovšem dává smysl, protože čísla řádků nemohou být záporná). O tomto omezení
se můžeme velmi snadno přesvědčit překladem a spuštěním nepatrně upraveného
demonstračního příkladu:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
        ld   BC, -1234  <i>; numerická hodnota, kterou chceme vytisknout</i>
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledek bude vypadat následovně:</p>

*** image ***
<p><i>Obrázek 4: Výsledek pokusu o vytištění záporného čísla standardní
subrutinou <strong>OUT_NUM_1</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tisk maximální podporované hodnoty a pokus o vytištění vyšší hodnoty</h2>

<p>V&nbsp;Sinclair BASICu platí ještě další omezení na rozsah čísel řádků.
Nejvyšší číslo řádku může mít hodnotu 9999 (což je zvláštní, protože další
BASICy pro osmibitové mikropočítače mají méně umělé omezení na 32767 řádků nebo
na 65535 řádků):</p>

*** image ***
<p><i>Obrázek 5: Program v&nbsp;BASICu s&nbsp;číslem řádku 9999.</i></p>

*** image ***
<p><i>Obrázek 6: Program v&nbsp;BASICu s&nbsp;číslem řádku 10000 je již
nekorektní.</i></p>

<p>A rutina <strong>OUT_NUM_1</strong> toto omezení skutečně bere v&nbsp;úvahu,
protože maximální celočíselná hodnota, kterou lze bez problémů vytisknout, je
rovna právě 9999. Opět se o tom snadno přesvědčíme, a to překladem a spuštěním
následujících dvou demonstračních příkladů. První příklad by měl vytisknout
hodnotu 9999, druhý pak &bdquo;pokaženou&ldquo; hodnotu 10000 (která již není
podporována).</p>

*** image ***
<p><i>Obrázek 7: Vytištění maximální hodnoty podporované subrutinou
<strong>OUT_NUM_1</strong>.</i></p>

*** image ***
<p><i>Obrázek 8: Pokus o vytištění hodnoty 10000 subrutinou
<strong>OUT_NUM_1</strong>.</i></p>

<p>Zdrojový kód příkladu, jenž vytiskne hodnotu 9999:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
        ld   BC, 9999   <i>; numerická hodnota, kterou chceme vytisknout</i>
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm</a>.</div></p>

<p>Program, který se pokusí o vytištění hodnoty 10000:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
        ld   BC, 10000  <i>; numerická hodnota, kterou chceme vytisknout</i>
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm</a>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vytištění číselné řady</h2>

<p>Vyzkoušejme si nyní tisk číselné řady, v&nbsp;níž jednotlivé hodnoty od sebe
nebudou nijak odděleny. Nejprve vytiskneme číslici 1, potom ihned za ní číslici
2 atd. až do hodnoty 10. Výsledek zobrazený na obrazovce ZX Spectra by tedy měl
vypadat následovně:</p>

*** image ***
<p><i>Obrázek 9: Celočíselné hodnoty 1, 2, ... až 10 zobrazené za sebou, bez
použití oddělovače.</i></p>

<p>Samozřejmě nám nic nebrání ve vložení volání subrutiny
<strong>OUT_NUM_1</strong> do programové smyčky, která může mít následující
strukturu:</p>

<pre>
        ld   BC, 1      <i>; numerická hodnota, kterou chceme vytisknout</i>
next_number:
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
        inc  C          <i>; a zvýšit o jedničku</i>
        ld   A, C
        cp   11         <i>; kontrola na konec smyčky</i>
        jr   nz, next_number
</pre>

<p>Problém ovšem spočívá v&nbsp;tom, že hodnota uložená v&nbsp;registrovém páru
<strong>BC</strong> je v&nbsp;subrutině <strong>OUT_NUM_1</strong> poškozena a
tudíž takto navržená smyčka nebude zcela funkční. Musíme tedy před voláním
subrutiny obsah <strong>BC</strong> uschovat (například na zásobník nebo do
druhé sady registrů) a po návratu ze subrutiny ji obnovit:</p>

<pre>
        ld   BC, 1      <i>; numerická hodnota, kterou chceme vytisknout</i>
next_number:
        <strong>push BC</strong>         <i>; uchovat počitadlo</i>
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
        <strong>pop  BC</strong>         <i>; obnovit počitadlo</i>
        inc  C          <i>; a zvýšit o jedničku</i>
        ld   A, C
        cp   11         <i>; kontrola na konec smyčky</i>
        jr   nz, next_number
</pre>

<p>Takto navržená programová smyčka již bude plně funkční a můžeme ji tedy
použít v&nbsp;demonstračním příkladu, jenž bude mít tvar:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
        ld   BC, 1      <i>; numerická hodnota, kterou chceme vytisknout</i>
next_number:
        push BC         <i>; uchovat počitadlo</i>
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
        pop  BC         <i>; obnovit počitadlo</i>
        inc  C          <i>; a zvýšit o jedničku</i>
        ld   A, C
        cp   11         <i>; kontrola na konec smyčky</i>
        jr   nz, next_number
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Pro úplnost se podívejme, jak je tento příklad přeložen do strojového kódu.
Jeho délka je rovna sedmnácti bajtům:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:010100     LD BC, 0001
8006:           label next_number
8006:C5         PUSH BC
8007:CD1B1A     CALL 1A1B
800A:C1         POP BC
800B:0C         INC C
800C:79         LD A, C
800D:FE0B       CP 0B
800F:20F5       JR NZ, 8006
8011:C9         RET
8012:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8011
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kombinace s&nbsp;dalšími subrutinami</h2>

<p>V&nbsp;úvodním textu jsme si řekli, že subrutina <strong>OUT_NUM_1</strong>
byla navržena tak, aby ji mohl využívat přímo interpret Sinclair BASICu. Lze ji
tedy zkombinovat s&nbsp;dalšími podprogramy určenými pro tisk textů a dalších
hodnot na obrazovku ZX Spectra. Díky tomu je například možné po zobrazení
celočíselné hodnoty vytisknout znak pro nový řádek subrutinou na adrese 0x10
(tu již dobře známe) a tím pádem provést odřádkování:</p>

*** image ***
<p><i>Obrázek 10: Hodnoty 1 až 10 vytištěné po sobě, ovšem
s&nbsp;odřádkováním.</i></p>

<p>Aby se provedlo odřádkování, musíme programovou smyčku <a
href="#k06">z&nbsp;předchozí kapitoly</a> pouze rozšířit o vytištění řídicího
znaku 0x0d. Podívejme se, jak úprava programu vypadá:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
        ld   BC, 1      <i>; numerická hodnota, kterou chceme vytisknout</i>
next_number:
        push BC         <i>; uchovat počitadlo</i>
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
        ld   A, 0x0d    <i>; kód znaku pro odřádkování</i>
        rst  0x10       <i>; zavolání rutiny v ROM</i>
        pop  BC         <i>; obnovit počitadlo</i>
        inc  C          <i>; a zvýšit o jedničku</i>
        ld   A, C
        cp   11         <i>; kontrola na konec smyčky</i>
        jr   nz, next_number
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě si můžete namísto znaku pro
konec řádku vytisknout čárku, mezeru atd.</div></p>

<p>Způsob překladu tohoto demonstračního příkladu do strojového kódu:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:010100     LD BC, 0001
8006:           label next_number
8006:C5         PUSH BC
8007:CD1B1A     CALL 1A1B
800A:3E0D       LD A, 0D
800C:D7         RST 10
800D:C1         POP BC
800E:0C         INC C
800F:79         LD A, C
8010:FE0B       CP 0B
8012:20F2       JR NZ, 8006
8014:C9         RET
8015:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8014
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Příznaky mikroprocesoru Zilog Z80</h2>

<p>Ve druhé části dnešního článku se budeme zabývat popisem příznaků
(<i>flags</i>) osmibitového mikroprocesoru Zilog Z80. Jedná se o sadu šesti
bitů, které jsou nastavovány mnoha strojovými instrukcemi (typicky instrukcemi
aritmetickými, ale i mnoha dalšími, jak uvidíme dále) a mohou být testovány
v&nbsp;podmíněných skocích, podmíněných skocích do podprogramů či podmíněných
výskoků (návratů) z&nbsp;podprogramů. Všech šest příznaků je uloženo
v&nbsp;příznakovém registru nazvaném příznačně <strong>F</strong> (od slova
<i>flags</i>). Struktura tohoto registru vypadá následovně:</p>

<table>
<tr><th>Bit</th><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><th>Příznak</th><td>S</td><td>Z</td><td>x</td><td>H</td><td>y</td><td>P/V</td><td>N</td><td>C</td></tr>
</table>

<p>Jednotlivé příznakové bity mají následující význam:</p>

<table>
<tr><th>Příznak</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td>C</td><td>carry</td><td>příznak přenosu nebo výpůjčky, taktéž první nebo poslední bit u bitových posunů</td></tr>
<tr><td>N</td><td>add/subtract</td><td>nulovaný instrukcí ADD, nastavovaný instrukcí SUB</td></tr>
<tr><td>P/V</td><td>parity/overflow</td><td>lichá či sudá parita u logických operací, přetečení do znaménkového bitu u aritmetických operací</td></tr>
<tr><td>y</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>H</td><td>half carry</td><td>přetečení ze čtvrtého do pátého bitu při provádění aritmetických operací</td></tr>
<tr><td>x</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>Z</td><td>zero</td><td>příznak nulovosti výsledku</td></tr>
<tr><td>S</td><td>sign</td><td>nejvyšší (osmý) bit výsledku, který nese informace o znaménku</td></tr>
</table>

<p>Mezi aritmetické operace pro zjednodušení počítáme i instrukci
<strong>CP</strong> pro porovnání. Ta skutečně provede výpočet rozdílu, ovšem
výsledek se zahodí; nastaví se pouze příznakové bity.</p>

<p><div class="rs-tip-major">Poznámka: podrobnější informace o jednotlivých
příznacích budou postupně uvedeny v&nbsp;navazujících kapitolách.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Seznam instrukcí, které modifikují příznakové bity</h2>

<p>Na mikroprocesoru Zilog Z80 modifikuje příznakové bity mnoho strojových
instrukcí. Tyto instrukce jsou vypsány v&nbsp;následující tabulce, přičemž je u
každého příznaku uvedeno, jak se daný příznak instrukcí modifikuje. Význam
symbolů použitých v&nbsp;této tabulce byl převzat ze stránky <a
href="http://www.textfiles.com/programming/CARDS/z80">80 MICROPROCESSOR
Instruction Set Summary</a>:</p>

<table>
<tr><th>Symbol</th><th>Význam</th></tr>
<tr><td>-</td><td>příznak zůstane nezměněn</td></tr>
<tr><td>*</td><td>příznak je instrukcí změněn (na základě provedené operace)</td></tr>
<tr><td>0</td><td>příznak se vynuluje</td></tr>
<tr><td>1</td><td>příznak se nastaví na jedničku</td></tr>
<tr><td>?</td><td>hodnota příznaku není oficiálně specifikována</td></tr>
</table>

<p>Následuje slíbená tabulka s&nbsp;instrukcemi, z&nbsp;nichž každá nějakým
způsobem modifikuje příznak či několik příznaků:</p>

<table>
<tr><th>Instrukce</th><th>S</th><th>Z</th><th>H</th><th>P</th><th>N</th><th>C</th></tr>
<tr><td>ADC A,s   </td><td>*</td><td>*</td><td>*</td><td>V</td><td>0</td><td>*</td></tr>
<tr><td>ADC HL,ss </td><td>*</td><td>*</td><td>?</td><td>V</td><td>0</td><td>*</td></tr>
<tr><td>ADD A,s   </td><td>*</td><td>*</td><td>*</td><td>V</td><td>0</td><td>*</td></tr>
<tr><td>ADD HL,ss </td><td>-</td><td>-</td><td>?</td><td>-</td><td>0</td><td>*</td></tr>
<tr><td>ADD IX,pp </td><td>-</td><td>-</td><td>?</td><td>-</td><td>0</td><td>*</td></tr>
<tr><td>ADD IY,rr </td><td>-</td><td>-</td><td>?</td><td>-</td><td>0</td><td>*</td></tr>
<tr><td>AND s     </td><td>*</td><td>*</td><td>*</td><td>P</td><td>0</td><td>0</td></tr>
<tr><td>BIT b,m   </td><td>?</td><td>*</td><td>1</td><td>?</td><td>0</td><td>-</td></tr>
<tr><td>CCF       </td><td>-</td><td>-</td><td>?</td><td>-</td><td>0</td><td>*</td></tr>
<tr><td>CP s      </td><td>*</td><td>*</td><td>*</td><td>V</td><td>1</td><td>*</td></tr>
<tr><td>CPD       </td><td>*</td><td>*</td><td>*</td><td>*</td><td>1</td><td>-</td></tr>
<tr><td>CPDR      </td><td>*</td><td>*</td><td>*</td><td>*</td><td>1</td><td>-</td></tr>
<tr><td>CPI       </td><td>*</td><td>*</td><td>*</td><td>*</td><td>1</td><td>-</td></tr>
<tr><td>CPIR      </td><td>*</td><td>*</td><td>*</td><td>*</td><td>1</td><td>-</td></tr>
<tr><td>CPL       </td><td>-</td><td>-</td><td>1</td><td>-</td><td>1</td><td>-</td></tr>
<tr><td>DAA       </td><td>*</td><td>*</td><td>*</td><td>P</td><td>-</td><td>*</td></tr>
<tr><td>DEC s     </td><td>*</td><td>*</td><td>*</td><td>V</td><td>1</td><td>-</td></tr>
<tr><td>IN r,[C]  </td><td>*</td><td>*</td><td>*</td><td>P</td><td>0</td><td>-</td></tr>
<tr><td>INC r     </td><td>*</td><td>*</td><td>*</td><td>V</td><td>0</td><td>-</td></tr>
<tr><td>INC [HL]  </td><td>*</td><td>*</td><td>*</td><td>V</td><td>0</td><td>-</td></tr>
<tr><td>INC [xx+d]</td><td>*</td><td>*</td><td>*</td><td>V</td><td>0</td><td>-</td></tr>
<tr><td>IND       </td><td>?</td><td>*</td><td>?</td><td>?</td><td>1</td><td>-</td></tr>
<tr><td>INDR      </td><td>?</td><td>1</td><td>?</td><td>?</td><td>1</td><td>-</td></tr>
<tr><td>INI       </td><td>?</td><td>*</td><td>?</td><td>?</td><td>1</td><td>-</td></tr>
<tr><td>INIR      </td><td>?</td><td>1</td><td>?</td><td>?</td><td>1</td><td>-</td></tr>
<tr><td>LD A,i    </td><td>*</td><td>*</td><td>0</td><td>*</td><td>0</td><td>-</td></tr>
<tr><td>LDD       </td><td>-</td><td>-</td><td>0</td><td>*</td><td>0</td><td>-</td></tr>
<tr><td>LDDR      </td><td>-</td><td>-</td><td>0</td><td>0</td><td>0</td><td>-</td></tr>
<tr><td>LDI       </td><td>-</td><td>-</td><td>0</td><td>*</td><td>0</td><td>-</td></tr>
<tr><td>LDIR      </td><td>-</td><td>-</td><td>0</td><td>0</td><td>0</td><td>-</td></tr>
<tr><td>NEG       </td><td>*</td><td>*</td><td>*</td><td>V</td><td>1</td><td>*</td></tr>
<tr><td>OR s      </td><td>*</td><td>*</td><td>*</td><td>P</td><td>0</td><td>0</td></tr>
<tr><td>OTDR      </td><td>?</td><td>1</td><td>?</td><td>?</td><td>1</td><td>-</td></tr>
<tr><td>OTIR      </td><td>?</td><td>1</td><td>?</td><td>?</td><td>1</td><td>-</td></tr>
<tr><td>OUTD      </td><td>?</td><td>*</td><td>?</td><td>?</td><td>1</td><td>-</td></tr>
<tr><td>OUTI      </td><td>?</td><td>*</td><td>?</td><td>?</td><td>1</td><td>-</td></tr>
<tr><td>RL m      </td><td>*</td><td>*</td><td>0</td><td>P</td><td>0</td><td>*</td></tr>
<tr><td>RLA       </td><td>-</td><td>-</td><td>0</td><td>-</td><td>0</td><td>*</td></tr>
<tr><td>RLC m     </td><td>*</td><td>*</td><td>0</td><td>P</td><td>0</td><td>*</td></tr>
<tr><td>RLCA      </td><td>-</td><td>-</td><td>0</td><td>-</td><td>0</td><td>*</td></tr>
<tr><td>RLD       </td><td>*</td><td>*</td><td>0</td><td>P</td><td>0</td><td>-</td></tr>
<tr><td>RR m      </td><td>*</td><td>*</td><td>0</td><td>P</td><td>0</td><td>*</td></tr>
<tr><td>RRA       </td><td>-</td><td>-</td><td>0</td><td>-</td><td>0</td><td>*</td></tr>
<tr><td>RRC m     </td><td>*</td><td>*</td><td>0</td><td>P</td><td>0</td><td>*</td></tr>
<tr><td>RRCA      </td><td>-</td><td>-</td><td>0</td><td>-</td><td>0</td><td>*</td></tr>
<tr><td>RRD       </td><td>*</td><td>*</td><td>0</td><td>P</td><td>0</td><td>-</td></tr>
<tr><td>SBC A,s   </td><td>*</td><td>*</td><td>*</td><td>V</td><td>1</td><td>*</td></tr>
<tr><td>SBC HL,ss </td><td>*</td><td>*</td><td>?</td><td>V</td><td>1</td><td>*</td></tr>
<tr><td>SCF       </td><td>-</td><td>-</td><td>0</td><td>-</td><td>0</td><td>1</td></tr>
<tr><td>SLA m     </td><td>*</td><td>*</td><td>0</td><td>P</td><td>0</td><td>*</td></tr>
<tr><td>SRA m     </td><td>*</td><td>*</td><td>0</td><td>P</td><td>0</td><td>*</td></tr>
<tr><td>SRL m     </td><td>*</td><td>*</td><td>0</td><td>P</td><td>0</td><td>*</td></tr>
<tr><td>SUB s     </td><td>*</td><td>*</td><td>*</td><td>V</td><td>1</td><td>*</td></tr>
<tr><td>XOR s     </td><td>*</td><td>*</td><td>*</td><td>P</td><td>0</td><td>0</td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zobrazení obsahu příznakového registru <strong>F</strong> po provedení vybrané operace</h2>

<p>V&nbsp;dalších kapitolách si na několika příkladech ukážeme, jakým způsobem
jsou jednotlivé příznaky ovlivněny aritmetickými a jinými operacemi. Musíme být
tedy schopni nějakým způsobem vytisknout hodnoty příznaků. Pro jednoduchost
&ndash; protože pro vytištění příznaků sofistikovanějším způsobem je nutné
vědět, jak příznaky používat :-) &ndash; se spokojíme s&nbsp;tím, že vytiskneme
obsah celého osmibitového registru <strong>F</strong>. Jak to však můžeme
provést? Prozatím umíme vytisknout numerickou hodnotu uloženou
v&nbsp;registrovém páru <strong>BC</strong>, takže pouze musíme vynulovat obsah
<strong>B</strong> a naopak přenést obsah registru <strong>F</strong> do
registru <strong>C</strong>.</p>

<p>To ovšem nelze provést přímo instrukcí <strong>ld C, B</strong>, takže si
musíme pomoci trikem &ndash; přesunem hodnot přes zásobník:</p>

<pre>
push AF         <i>; uložíme pár AF na zásobník</i>
pop  BC         <i>; obnovíme původní obsah AF ze zásobníku, ovšem nyní do BC</i>
ld   B, 0       <i>; vymažeme B (což byl obsah A), ponecháme jen C (což byl obsah F)</i>
</pre>

<p>Nyní již registrový pár <strong>BC</strong> obsahuje původní hodnotu
registru <strong>F</strong> v&nbsp;rozsahu 0 až 255, kterou lze snadno
vytisknout na obrazovku:</p>

<pre>
call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
</pre>

<p>Přesně tento postup použijeme v&nbsp;navazujících kapitolách.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příznakové bity po provedení celočíselné operace 1+2</h2>

<p>Nyní si vyzkoušejme, jaké příznakové bity budou nastaveny (či naopak
nenastaveny) po provedení celočíselné operace 1+2 realizované instrukcí
<strong>add</strong>, tedy konkrétně tímto způsobem:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        <strong>ld   A, 1</strong>       <i>; první sčítanec</i>
        <strong>add  A, 2</strong>       <i>; druhý sčítance + výsledek operace</i>
&nbsp;
        push AF         <i>; uložíme pár AF na zásobník</i>
        pop  BC         <i>; obnovíme původní obsah AF ze zásobníku, ovšem nyní do BC</i>
        ld   B, 0       <i>; vymažeme B (což byl obsah A), ponecháme jen C (což byl obsah F)</i>
&nbsp;
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
&nbsp;
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Po překladu a spuštění tohoto příkladu zjistíme, že jsou všechny bity
příznakového registru nulové:</p>

*** image ***
<p><i>Obrázek 11: Všechny bity příznakového registru <strong>F</strong> jsou
nulové.</i></p>

<p>To konkrétně znamená následující:</p>

<table>
<tr><th>Příznak</th><th>Význam</th><th>Hodnota</th><th>Vysvětlení</th></tr>
<tr><td>C</td><td>carry</td><td>0</td><td>bez přenosu do devátého bitu</td></tr>
<tr><td>N</td><td>add/subtract</td><td>0</td><td>operace <strong>ADD</strong></td></tr>
<tr><td>V</td><td>overflow</td><td>0</td><td>bez přetečení do znaménkového bitu</td></tr>
<tr><td>H</td><td>half carry</td><td>0</td><td>bez přenosu ze čtvrtého do pátého bitu</td></tr>
<tr><td>Z</td><td>zero</td><td>0</td><td>výsledek je nenulový</td></tr>
<tr><td>S</td><td>sign</td><td>0</td><td>výsledek je kladný</td></tr>
</table>

<p>Dnes již naposledy si ještě pro úplnost ukážeme, jak vypadá překlad do
strojového kódu:</p>

<pre>
ENTRY_POINT     EQU 8000
ROM_CLS         EQU 0DAF
OUT_NUM_1       EQU 1A1B
                ORG 8000
8000:           label start
8000:CDAF0D     CALL 0DAF
8003:3E01       LD A, 01
8005:C602       ADD A, 02
8007:F5         PUSH AF
8008:C1         POP BC
8009:0600       LD B, 00
800B:CD1B1A     CALL 1A1B
800E:C9         RET
800F:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800E
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Příznakové bity po provedení celočíselné operace 0+0</h2>

<p>Nyní předchozí demonstrační příklad nepatrně upravíme, a to takovým
způsobem, že budeme provádět součet 0+0 (s&nbsp;nulovým výsledkem). Zdrojový
kód příkladu se změní jen nepatrně &ndash; viz zvýrazněnou část kódu:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        <strong>ld   A, 0</strong>       <i>; první sčítanec</i>
        <strong>add  A, 0</strong>       <i>; druhý sčítance + výsledek operace</i>
&nbsp;
        push AF         <i>; uložíme pár AF na zásobník</i>
        pop  BC         <i>; obnovíme původní obsah AF ze zásobníku, ovšem nyní do BC</i>
        ld   B, 0       <i>; vymažeme B (což byl obsah A), ponecháme jen C (což byl obsah F)</i>
&nbsp;
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
&nbsp;
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledná hodnota uložená do příznakového bitu bude nyní odlišná:</p>

*** image ***
<p><i>Obrázek 12: Nastaven je pouze sedmý bit příznakového registru <strong>F</strong>.</i></p>

<p>Nastaven je tedy pouze příznak/bit <strong>zero</strong> znamenající nulový
výsledek poslední aritmetické nebo logické operace. To konkrétně znamená
následující:</p>

<table>
<tr><th>Příznak</th><th>Význam</th><th>Hodnota</th><th>Vysvětlení</th></tr>
<tr><td>C</td><td>carry</td><td>0</td><td>bez přenosu do devátého bitu</td></tr>
<tr><td>N</td><td>add/subtract</td><td>0</td><td>operace <strong>ADD</strong></td></tr>
<tr><td>V</td><td>overflow</td><td>0</td><td>bez přetečení do znaménkového bitu</td></tr>
<tr><td>H</td><td>half carry</td><td>0</td><td>bez přenosu ze čtvrtého do pátého bitu</td></tr>
<tr><td>Z</td><td>zero</td><td>1</td><td>výsledek je <strong>nulový</strong></td></tr>
<tr><td>S</td><td>sign</td><td>0</td><td>výsledek je kladný</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příznakové bity po provedení operace 255+1</h2>

<p>Nyní sečteme hodnoty 255+1. Výsledkem tedy bude nula (osmibitová hodnota
přeteče přes 255), stejně jako tomu bylo <a href="#k12">v&nbsp;předchozím</a>
demonstračním příkladu. Ovšem budou stejně nastaveny i příznakové bity?</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        <strong>ld   A, 255</strong>     <i>; první sčítanec</i>
        <strong>add  A, 1</strong>       <i>; druhý sčítance + výsledek operace</i>
&nbsp;
        push AF         <i>; uložíme pár AF na zásobník</i>
        pop  BC         <i>; obnovíme původní obsah AF ze zásobníku, ovšem nyní do BC</i>
        ld   B, 0       <i>; vymažeme B (což byl obsah A), ponecháme jen C (což byl obsah F)</i>
&nbsp;
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
&nbsp;
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledná dekadická hodnota 81 odpovídá binární hodnotě 01010001:</p>

*** image ***
<p><i>Obrázek 13: Příznakový registr obsahuje bity s&nbsp;hodnotami 01010001.</i></p>

<p>Výsledek součtu je tedy nulový, ovšem příznaky nám mohou napovědět, že se
k&nbsp;výsledné nule došlo jiným způsobem:</p>

<table>
<tr><th>Příznak</th><th>Význam</th><th>Hodnota</th><th>Vysvětlení</th></tr>
<tr><td>C</td><td>carry</td><td>1</td><td>s&nbsp;přenosem do devátého bitu (výsledek je větší než 255)</td></tr>
<tr><td>N</td><td>add/subtract</td><td>0</td><td>operace <strong>ADD</strong></td></tr>
<tr><td>V</td><td>overflow</td><td>0</td><td>bez přetečení do znaménkového bitu</td></tr>
<tr><td>H</td><td>half carry</td><td>1</td><td>s&nbsp;přenosem ze čtvrtého do pátého bitu</td></tr>
<tr><td>Z</td><td>zero</td><td>1</td><td>výsledek je <strong>nulový</strong></td></tr>
<tr><td>S</td><td>sign</td><td>0</td><td>výsledek je kladný</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Příznakové bity po provedení operace 254+1</h2>

<p>Zkusme nyní první sčítanec o jedničku snížit a provést aritmetickou operaci
254+1. Výsledkem bude 255, což je hodnota, která se vejde do osmibitového
výsledného registru. Ovšem hodnoty příznaků budou opět odlišné:</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        <strong>ld   A, 254</strong>     <i>; první sčítanec</i>
        <strong>add  A, 1</strong>       <i>; druhý sčítance + výsledek operace</i>
&nbsp;
        push AF         <i>; uložíme pár AF na zásobník</i>
        pop  BC         <i>; obnovíme původní obsah AF ze zásobníku, ovšem nyní do BC</i>
        ld   B, 0       <i>; vymažeme B (což byl obsah A), ponecháme jen C (což byl obsah F)</i>
&nbsp;
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
&nbsp;
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledná dekadická hodnota 168 odpovídá binární hodnotě 10101000:</p>

*** image ***
<p><i>Obrázek 14: Příznakový registr obsahuje bity s&nbsp;hodnotami 10101000.</i></p>

<p>Příznakové bity jsou opět prakticky zcela odlišné od předchozích
výsledků:</p>

<table>
<tr><th>Příznak</th><th>Význam</th><th>Hodnota</th><th>Vysvětlení</th></tr>
<tr><td>C</td><td>carry</td><td>0</td><td>bez přenosu do devátého bitu (výsledek je menší nebo roven 255)</td></tr>
<tr><td>N</td><td>add/subtract</td><td>0</td><td>operace <strong>ADD</strong></td></tr>
<tr><td>V</td><td>overflow</td><td>0</td><td>bez přetečení do znaménkového bitu</td></tr>
<tr><td>H</td><td>half carry</td><td>0</td><td>bez přenosu ze čtvrtého do pátého bitu</td></tr>
<tr><td>Z</td><td>zero</td><td>0</td><td>výsledek je nenulový</td></tr>
<tr><td>S</td><td>sign</td><td>1</td><td>výsledek je <strong>záporný</strong></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: změnily se i bity x a y, ty ovšem
prozatím můžeme bez problémů ignorovat.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Příznakové bity po provedení operace 255+255</h2>

<p>Pokračujme dále. Zajímavé bude zjistit, jak se bude chovat operace 255+255.
Na tuto operaci se můžeme dívat jako na součet dvou celých <i>kladných</i>
čísel nebo naopak jako na součet dvou celých čísel <i>záporných</i>, protože
hodnota 255 je binárně uložena jako 11111111, což ovšem je současně i hodnota
-1 v&nbsp;případě, že budeme operace provádět ve dvojkovém doplňku (samotné
operace budou stejné, pouze interpretace operandů a výsledku je jiná):</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        <strong>ld   A, 255</strong>     <i>; první sčítanec</i>
        <strong>add  A, 255</strong>     <i>; druhý sčítance + výsledek operace</i>
&nbsp;
        push AF         <i>; uložíme pár AF na zásobník</i>
        pop  BC         <i>; obnovíme původní obsah AF ze zásobníku, ovšem nyní do BC</i>
        ld   B, 0       <i>; vymažeme B (což byl obsah A), ponecháme jen C (což byl obsah F)</i>
&nbsp;
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
&nbsp;
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Příznakový registr bude obsahovat dekadickou hodnotu 185, což binárně odpovídá 10111001.</p>

*** image ***
<p><i>Obrázek 15: Příznakový registr obsahuje bity s&nbsp;hodnotami 10111001.</i></p>

<p>Příznakové bity jsou opět odlišné od předchozích výsledků:</p>

<table>
<tr><th>Příznak</th><th>Význam</th><th>Hodnota</th><th>Vysvětlení</th></tr>
<tr><td>C</td><td>carry</td><td>1</td><td>s&nbsp;přenosem do devátého bitu (výsledek je větší než 255)</td></tr>
<tr><td>N</td><td>add/subtract</td><td>0</td><td>operace <strong>ADD</strong></td></tr>
<tr><td>V</td><td>overflow</td><td>0</td><td>bez přetečení do znaménkového bitu</td></tr>
<tr><td>H</td><td>half carry</td><td>1</td><td>s&nbsp;přenosem ze čtvrtého do pátého bitu</td></tr>
<tr><td>Z</td><td>zero</td><td>0</td><td>výsledek je nenulový</td></tr>
<tr><td>S</td><td>sign</td><td>1</td><td>výsledek je <strong>záporný</strong></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Příznakové bity po provedení operace 100+100</h2>

<p>V&nbsp;dnešním posledním demonstračním příkladu se pokusíme sečíst dvě
hodnoty 100. Výsledkem je pochopitelně hodnota 200. Ovšem nyní dochází
k&nbsp;zajímavé situaci, pokud budeme oba operandy i výsledek považovat za
hodnoty se znaménkem reprezentované s&nbsp;dvojkovým doplňkem. Oba sčítance
jsou stále kladnými hodnotami, ovšem 200 je bitově 11001000, což ve dvojkovém
doplňku znamená -56 (a to ani nedošlo k&nbsp;přenosu!):</p>

<pre>
ENTRY_POINT   equ $8000
ROM_CLS       equ $0DAF
OUT_NUM_1     equ $1A1B
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        call ROM_CLS    <i>; smazání obrazovky a otevření kanálu číslo 2 (screen)</i>
&nbsp;
        <strong>ld   A, 100</strong>     <i>; první sčítanec</i>
        <strong>add  A, 100</strong>     <i>; druhý sčítance + výsledek operace</i>
&nbsp;
        push AF         <i>; uložíme pár AF na zásobník</i>
        pop  BC         <i>; obnovíme původní obsah AF ze zásobníku, ovšem nyní do BC</i>
        ld   B, 0       <i>; vymažeme B (což byl obsah A), ponecháme jen C (což byl obsah F)</i>
&nbsp;
        call OUT_NUM_1  <i>; zavolání rutiny pro výpis celého čísla</i>
&nbsp;
        ret             <i>; návrat z programu do BASICu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Na obrazovce ZX Spectra se zobrazí hodnota 140:</p>

*** image ***
<p><i>Obrázek 16: Příznakový registr obsahuje bity s&nbsp;hodnotami 10001100.</i></p>

<p>Příznakové bity jsou opět odlišné od předchozích výsledků:</p>

<table>
<tr><th>Příznak</th><th>Význam</th><th>Hodnota</th><th>Vysvětlení</th></tr>
<tr><td>C</td><td>carry</td><td>0</td><td>bez přenosu do devátého bitu (výsledek je menší nebo roven 255)</td></tr>
<tr><td>N</td><td>add/subtract</td><td>0</td><td>operace <strong>ADD</strong></td></tr>
<tr><td>V</td><td>overflow</td><td>1</td><td>s&nbsp;přetečením do znaménkového bitu</td></tr>
<tr><td>H</td><td>half carry</td><td>0</td><td>bez přenosu ze čtvrtého do pátého bitu</td></tr>
<tr><td>Z</td><td>zero</td><td>0</td><td>výsledek je nenulový</td></tr>
<tr><td>S</td><td>sign</td><td>1</td><td>výsledek je <strong>záporný</strong></td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. První shrnutí: význam příznaků C, V, S a Z</h2>

<p>Nyní si již můžeme shrnout význam čtyř příznakových bitů při provádění
<i>aritmetických</i> operací:</p>

<table>
<tr><th>Příznak</th><td>S</td><td>Z</td><td>V</td><td>C</td><th>Poznámka</th></tr>
<tr><td>1+2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>kladný výsledek</td></tr>
<tr><td>0+0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>nulový výsledek</td></tr>
<tr><td>255+1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>nulový výsledek, ovšem vzniklý přenosem (0=256)</td></tr>
<tr><td>254+1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>nenulový výsledek větší než 127 (a tedy záporný ve dvojkovém doplňku)</td></tr>
<tr><td>255+255</td><td>1</td><td>0</td><td>0</td><td>1</td><td>nenulový výsledek větší než 127, který ovšem vznikl přenosem</td></tr>
<tr><td>100+100</td><td>1</td><td>0</td><td>1</td><td>0</td><td>záporný výsledek vzniklý součtem dvou kladných čísel</td></tr>
<tr><td>128+128</td><td>0</td><td>1</td><td>1</td><td>1</td><td>nulový nezáporný výsledek, došlo ovšem jak k&nbsp;přetečení, tak i přenosu (toto je specifický případ)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že ne všechny kombinace příznaků mohou v&nbsp;praxi nastat. Příkladem je výsledek typu &bdquo;záporná nula&ldquo; (tedy S=1 a současně Z=1) atd. Ovšem z&nbsp;tabulky je současně zřejmé, že Zilog Z80 lze použít jak pro výpočty s&nbsp;hodnotami bez znaménka (<i>unsigned</i>), tak i s&nbsp;hodnotami se znaménkem (<i>signed</i>). A dokonce jsou tyto výpočty jednodušší, než například na MOS 6502 atd.</div></p>

<p>Zbývá nám popis dvou dalších příznaků <strong>N</strong> a především
příznaku <strong>H</strong>. Tyto příznaky jsou použity například
v&nbsp;instrukci <strong>DAA</strong>, což je pravděpodobně nejkomplikovanější
a nejhůře (oficiálně) popsaná instrukce Z80 vůbec.</p>

*** image ***
<p><i>Obrázek 17: Příznakový registr po provedení operace 128+128.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<p>Výše uvedené demonstrační příklady i příklady, které již byly popsány
v&nbsp;předchozích sedmi článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">3</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny/">4</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-podruhe/">5</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-potreti/">6</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-dokonceni-realizace-prikazu-plot/">7</a>],
je možné přeložit s&nbsp;využitím souboru Makefile, jehož aktuální verze vypadá
následovně (pro překlad a slinkování je použit assembler <i>Pasmo</i>):</p>

<pre>
ASSEMBLER := pasmo
&nbsp;
all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap \
    31.tap 32.tap 33.tap 34.tap 35.tap 36.tap 37.tap 38.tap 39.tap 40.tap \
    41.tap 42.tap 43.tap 44.tap 45.tap 46.tap 47.tap 48.tap 49.tap 50.tap \
    51.tap 52.tap 53.tap 54.tap 55.tap 56.tap 57.tap 58.tap 59.tap 60.tap \
    61.tap 62.tap 63.tap 64.tap 65.tap 66.tap 67.tap 68.tap 69.tap 70.tap \
    71.tap 72.tap
&nbsp;
clean:
        rm -f *.tap
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 01-color-attribute.lst
&nbsp;
02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 02-blinking-attribute.lst
&nbsp;
03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 03-symbolic-names.lst
&nbsp;
04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 04-operators.lst
&nbsp;
05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 05-better-symbols.lst
&nbsp;
06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 06-tapbas-v1.lst
&nbsp;
07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 07-tapbas-v2.lst
&nbsp;
08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 08-loop.lst
&nbsp;
09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 09-loop.lst
&nbsp;
10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 10-loop.lst
&nbsp;
11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 11-loop.lst
&nbsp;
12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 12-loop.lst
&nbsp;
13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 13-loop.lst
&nbsp;
14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 14-loop.lst
&nbsp;
15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 15-loop.lst
&nbsp;
16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 16-loop.lst
&nbsp;
17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 17-loop.lst
&nbsp;
18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 18-cls.lst
&nbsp;
19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 19-print-char-call.lst
&nbsp;
20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 20-print-char-rst.lst
&nbsp;
21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 21-print-char.lst
&nbsp;
22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 22-print-all-chars.lst
&nbsp;
23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 23-print-all-chars.lst
&nbsp;
24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 24-change-color.lst
&nbsp;
25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 25-change-flash.lst
&nbsp;
26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 26-print-at.lst
&nbsp;
27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 27-print-string.lst
&nbsp;
28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 28-print-string.lst
&nbsp;
29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 29-print-colorized-string.lst
&nbsp;
30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 30-print-string-ROM.lst
&nbsp;
31.tap: 31-attributes.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 31-attributes.lst
&nbsp;
32.tap: 32-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 32-fill-in-vram.lst
&nbsp;
33.tap: 33-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 33-fill-in-vram-no-ret.lst
&nbsp;
34.tap: 34-fill-in-vram-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 34-fill-in-vram-pattern.lst
&nbsp;
35.tap: 35-slow-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 35-slow-fill-in-vram.lst
&nbsp;
36.tap: 36-slow-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 36-slow-fill-in-vram-no-ret.lst
&nbsp;
37.tap: 37-fill-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 37-fill-block.lst
&nbsp;
38.tap: 38-fill-block-with-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 38-fill-block-with-pattern.lst
&nbsp;
39.tap: 39-fill-block-optimized.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 39-fill-block-optimized.lst
&nbsp;
40.tap: 40-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 40-draw-char.lst
&nbsp;
41.tap: 41-draw-any-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 41-draw-any-char.lst
&nbsp;
42.tap: 42-block-anywhere.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 42-block-anywhere.lst
&nbsp;
43.tap: 43-block-anywhere-rrca.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 43-block-anywhere-rrca.lst
&nbsp;
44.tap: 44-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 44-better-draw-char.lst
&nbsp;
45.tap: 45-even-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 45-even-better-draw-char.lst
&nbsp;
46.tap: 46-draw-char-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 46-draw-char-at.lst
&nbsp;
47.tap: 47-draw-char-at-unrolled.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 47-draw-char-at-unrolled.lst
&nbsp;
48.tap: 48-incorrect-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 48-incorrect-print-string.lst
&nbsp;
49.tap: 49-correct-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 49-correct-print-string.lst
&nbsp;
50.tap: 50-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 50-ascii-table.lst
&nbsp;
51.tap: 51-plot-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 51-plot-block.lst
&nbsp;
52.tap: 52-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 52-plot-pixel.lst
&nbsp;
53.tap: 53-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 53-plot-pixel.lst
&nbsp;
54.tap: 54-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 54-plot-pixel-on-background.lst
&nbsp;
55.tap: 55-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 55-plot-pixel-on-background.lst
&nbsp;
56.tap: 56-inverse-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 56-inverse-ascii-table.lst
&nbsp;
57.tap: 57-plot-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 57-plot-pixel-on-inverse-background.lst
&nbsp;
58.tap: 58-plot-inverse-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 58-plot-inverse-pixel-on-inverse-background.lst
&nbsp;
59.tap: 59-configurable-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 59-configurable-ascii-table.lst
&nbsp;
60.tap: 60-plot-over.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 60-plot-over.lst
&nbsp;
61.tap: 61-print-number-A.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 61-print-number-A.lst
&nbsp;
62.tap: 62-print-number-B.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 62-print-number-B.lst
&nbsp;
63.tap: 63-print-number-C.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 63-print-number-C.lst
&nbsp;
64.tap: 64-print-number-D.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 64-print-number-D.lst
&nbsp;
65.tap: 65-more-numbers-A.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 65-more-numbers-A.lst
&nbsp;
66.tap: 66-more-numbers-B.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 66-more-numbers-B.lst
&nbsp;
67.tap: 67-print-flags-1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 67-print-flags-1.lst
&nbsp;
68.tap: 68-print-flags-2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 68-print-flags-2.lst
&nbsp;
69.tap: 69-print-flags-3.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 69-print-flags-3.lst
&nbsp;
70.tap: 70-print-flags-4.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 70-print-flags-4.lst
&nbsp;
71.tap: 71-print-flags-5.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 71-print-flags-5.lst
&nbsp;
72.tap: 72-print-flags-6.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 72-print-flags-6.lst
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>31-attributes.asm</td><td>modifikace atributů pro tisk řetězce subrutinou uloženou v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a></td></tr>
<tr><td>32</td><td>32-fill-in-vram.asm</td><td>vyplnění celé bitmapy barvou popředí, návrat do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a></td></tr>
<tr><td>33</td><td>33-fill-in-vram-no-ret.asm</td><td>vyplnění celé bitmapy barvou popředí, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>34</td><td>34-fill-in-vram-pattern.asm</td><td>vyplnění celé bitmapy zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a></td></tr>
<tr><td>35</td><td>35-slow-fill-in-vram.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a></td></tr>
<tr><td>36</td><td>36-slow-fill-in-vram-no-ret.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>37</td><td>37-fill-block.asm</td><td>vykreslení bloku 8&times;8 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a></td></tr>
<tr><td>38</td><td>38-fill-block-with-pattern.asm</td><td>vykreslení bloku 8&times;8 pixelů zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a></td></tr>
<tr><td>39</td><td>39-fill-block-optimized.asm</td><td>optimalizace předchozího příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a></td></tr>
<tr><td>40</td><td>40-draw-char.asm</td><td>vykreslení znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a></td></tr>
<tr><td>41</td><td>41-draw-any-char.asm</td><td>podprogram pro vykreslení libovolně zvoleného znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a></td></tr>
<tr><td>42</td><td>42-block-anywhere.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>43-block-anywhere-rrca.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm</a></td></tr>
<tr><td>44</td><td>44-better-draw-char.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm</a></td></tr>
<tr><td>45</td><td>45-even-better-draw-char.asm</td><td>posun offsetu pro vykreslení dalšího znaku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm</a></td></tr>
<tr><td>46</td><td>46-draw-char-at.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm</a></td></tr>
<tr><td>47</td><td>47-draw-char-at-unrolled.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm</a></td></tr>
<tr><td>48</td><td>48-incorrect-print-string.asm</td><td>tisk řetězce, nekorektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm</a></td></tr>
<tr><td>49</td><td>49-correct-print-string.asm</td><td>tisk řetězce, korektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>50-ascii-table.asm</td><td>tisk několika bloků ASCII tabulky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm</a></td></tr>
<tr><td>51</td><td>51-plot-block.asm</td><td>vykreslení pixelu verze 1: zápis celého bajtu na pozici pixelu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm</a></td></tr>
<tr><td>52</td><td>52-plot-pixel.asm</td><td>vykreslení pixelu verze 2: korektní vykreslení jednoho pixelu, ovšem překreslení celého bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm</a></td></tr>
<tr><td>53</td><td>53-plot-pixel.asm</td><td>vykreslení pixelu verze 3: vylepšená verze předchozího demonstračního příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm</a></td></tr>
<tr><td>54</td><td>54-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (nekorektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm</a></td></tr>
<tr><td>55</td><td>55-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (korektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>56</td><td>56-inverse-ascii-table.asm</td><td>vykreslení ASCII tabulky inverzní barvou (inkoust vs. papír)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm</a></td></tr>
<tr><td>57</td><td>57-plot-pixel-on-inverse-background.asm</td><td>vykreslení pixelů barvou papíru proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm</a></td></tr>
<tr><td>58</td><td>58-plot-inverse-pixel-on-inverse-background.asm</td><td>vykreslení pixelů inverzní barvou proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/58-plot-inverse-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm58-plot-inverse-pixel-on-inverse-background.asm/</a></td></tr>
<tr><td>59</td><td>59-configurable-ascii-table.asm</td><td>vykreslení ASCII tabulky buď přímo inkoustem nebo inverzně</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm</a></td></tr>
<tr><td>60</td><td>60-plot-over.asm</td><td>přibližná implementace příkazu <strong>PLOT OVER</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>61-print-number-A.asm</td><td>ukázka použití podprogramu pro tisk celého čísla</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm</a></td></tr>
<tr><td>62</td><td>62-print-number-B.asm</td><td>pokus o vytištění záporných čísel</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm</a></td></tr>
<tr><td>63</td><td>63-print-number-C.asm</td><td>tisk maximální podporované hodnoty 9999</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm</a></td></tr>
<tr><td>64</td><td>64-print-number-D.asm</td><td>tisk vyšší než podporované hodnoty 10000</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm</a></td></tr>
<tr><td>65</td><td>65-more-numbers-A.asm</td><td>vytištění číselné řady</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm</a></td></tr>
<tr><td>66</td><td>66-more-numbers-B.asm</td><td>kombinace tisku celočíselných hodnot s&nbsp;dalšími subrutinami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm</a></td></tr>
<tr><td>67</td><td>67-print-flags-1.asm</td><td>příznakové bity po provedení celočíselné operace 1+2</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/67-print-flags-1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/67-print-flags-1.asm</a></td></tr>
<tr><td>68</td><td>68-print-flags-2.asm</td><td>příznakové bity po provedení celočíselné operace 0+0</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/68-print-flags-2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/68-print-flags-2.asm</a></td></tr>
<tr><td>69</td><td>69-print-flags-3.asm</td><td>příznakové bity po provedení operace 255+1</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/69-print-flags-3.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/69-print-flags-3.asm</a></td></tr>
<tr><td>70</td><td>70-print-flags-4.asm</td><td>příznakové bity po provedení operace 254+1</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/70-print-flags-4.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/70-print-flags-4.asm</a></td></tr>
<tr><td>71</td><td>71-print-flags-5.asm</td><td>příznakové bity po provedení operace 255+255</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/71-print-flags-5.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/71-print-flags-5.asm</a></td></tr>
<tr><td>72</td><td>72-print-flags-6.asm</td><td>výsledek operace 100+100, nastavení příznakových bitů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/72-print-flags-6.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/72-print-flags-6.asm</a></td></tr>
<tr><td>73</td><td>73-print-flags-7.asm</td><td>výsledek operace 128+128, nastavení příznakových bitů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/73-print-flags-7.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/73-print-flags-7.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7x</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech demonstračních příkladů do podoby obrazu magnetické pásky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>The system variables<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html</a>
</li>

<li>ZX Spectrum manual: chapter #17 Graphics<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html</a>
</li>

<li>Why does Sinclair BASIC have two formats for storing numbers in the same structure?<br />
<a href="https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu">https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu</a>
</li>

<li>Plovoucí řádová čárka na ZX Spectru<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

<li>1A1B: THE 'REPORT AND LINE NUMBER PRINTING' SUBROUTINE<br />
<a href="https://skoolkid.github.io/rom/asm/1A1B.html">https://skoolkid.github.io/rom/asm/1A1B.html</a>
</li>

<li>2DE3: THE 'PRINT A FLOATING-POINT NUMBER' SUBROUTINE<br />
<a href="https://skoolkid.github.io/rom/asm/2DE3.html">https://skoolkid.github.io/rom/asm/2DE3.html</a>
</li>

<li>5C63: STKBOT - Address of bottom of calculator stack<br />
<a href="https://skoolkid.github.io/rom/asm/5C63.html">https://skoolkid.github.io/rom/asm/5C63.html</a>
</li>

<li>5C65: STKEND - Address of start of spare space<br />
<a href="https://skoolkid.github.io/rom/asm/5C65.html">https://skoolkid.github.io/rom/asm/5C65.html</a>
</li>

<li>Why does Sinclair BASIC have two formats for storing numbers in the same structure?<br />
<a href="https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu">https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu</a>
</li>

<li>Chapter 24: The memory<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap24.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap24.html</a>
</li>

<li>Survey of Floating-Point Formats  <br />
<a href="https://mrob.com/pub/math/floatformats.html">https://mrob.com/pub/math/floatformats.html</a>
</li>

<li>Convert an 8bit number to hex in z80 assembler<br />
<a href="https://stackoverflow.com/questions/22838444/convert-an-8bit-number-to-hex-in-z80-assembler">https://stackoverflow.com/questions/22838444/convert-an-8bit-number-to-hex-in-z80-assembler</a>
</li>

<li>80 MICROPROCESSOR Instruction Set Summary<br />
<a href="http://www.textfiles.com/programming/CARDS/z80">http://www.textfiles.com/programming/CARDS/z80</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

