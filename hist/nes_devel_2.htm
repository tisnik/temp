<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Základy tvorby her pro herní konzoli NES: mikroprocesor 6502 a assembler ca65</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Základy tvorby her pro herní konzoli NES: mikroprocesor 6502 a assembler ca65</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhém článku o tvorbě her a grafických či zvukových dem pro osmibitovou herní konzoli NES se seznámíme s programátorským modelem mikroprocesoru MOS 6502 (resp. Ricoh 2A03.) a vysvětlíme si, jak vlastně skutečně pracuje kostra reálného programu pro NES.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Základy tvorby her pro herní konzoli NES: mikroprocesor 6502 a assembler ca65</a></p>
<p><a href="#k02">2. Hlavička obrazu ROM</a></p>
<p><a href="#k03">3. Mapa paměti NESu</a></p>
<p><a href="#k04">4. Realizace obsluhy přerušení pro všechny tři typy přerušení procesoru 6502</a></p>
<p><a href="#k05">5. Programátorský model mikroprocesoru MOS 6502</a></p>
<p><a href="#k06">6. Registry a příznakové bity mikroprocesoru MOS 6502</a></p>
<p><a href="#k07">7. Adresovací režimy, využití registrů X a Y pro adresování</a></p>
<p><a href="#k08">8. Aritmetické a logické instrukce</a></p>
<p><a href="#k09">9. Skoky a rozvětvení</a></p>
<p><a href="#k10">10. Instrukce pro přesuny dat</a></p>
<p><a href="#k11">11. Manipulace s&nbsp;příznakovými bity</a></p>
<p><a href="#k12">12. Zbývající instrukce</a></p>
<p><a href="#k13">13. Kde si lze možnosti 6502 otestovat bez nutnosti pochopit strukturu NESu?</a></p>
<p><a href="#k14">14. Druhý pohled na kostru programu</a></p>
<p><a href="#k15">15. Nastavení stavu mikroprocesoru po resetu</a></p>
<p><a href="#k16">16. Nastavení řídicích registrů</a></p>
<p><a href="#k17">17. Trik pro čekání na zobrazení dalšího snímku</a></p>
<p><a href="#k18">18. Trik pro vymazání obsahu RAM</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Základy tvorby her pro herní konzoli NES: mikroprocesor 6502 a assembler ca65</h2>

<p>Na <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-vyvoj-her-a-demo-programu-pro-herni-konzoli-nes/">úvodní
článek</a> o vývoji her nebo grafických a zvukových dem pro slavnou osmibitovou
herní konzoli NES dnes navážeme. Podrobněji si popíšeme dvě technologie, které
je nutné alespoň do určité míry znát (prozatím nám však budou stačit skutečně
jen základní znalosti). Konkrétně se jedná o osmibitový mikroprocesor MOS 6502
a taktéž o assembler, v&nbsp;našem případě konkrétně o assembler nazvaný <a
href="https://cc65.github.io/doc/ca65.html">ca65</a>. Připomeňme si, že pro
vývoj pro NES nám bude postačovat jen základní sada nástrojů (a nijak
rozsáhlých či komplikovaných):</p>

<ol>
<li>Libovolný programátorský textový editor</li>
<li>Assembler <strong>ca65</strong></li>
<li>Linker <strong>cl65</strong></li>
<li>Libovolný emulátor NESu (podporující formát INES &ndash; což dnes umí každý emulátor)</li>
</ol>

<p>V&nbsp;závěru úvodního článku jsme si ukázali, jak vypadá kostra programu
určeného pro NES zapsaná v&nbsp;assembleru. Jedná se o nepatrně delší kód, a to
z&nbsp;toho prostého důvodu, že NES neobsahuje žádný operační systém ani BIOS,
takže se programátor musí nejprve zabývat inicializací hardware &ndash; tedy
především čipu PPU (grafika).</p>

<p>Celý kód, který jehož význam si postupně vysvětlíme (a vylepšíme), vypadá
následovně:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 1
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "INES"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
.code
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
.proc nmi
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
.proc irq
        rti                     <i>; návrat z přerušení</i>
.endproc
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
.proc reset
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx $2000               <i>; nastavení PPUCTRL = 0</i>
        stx $2001               <i>; nastavení PPUMASK = 0</i>
        stx $4015               <i>; nastavení APUSTATUS = 0</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
wait1:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait1               <i>; skok, pokud je příznak N nulový</i>
wait2:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait2               <i>; skok, pokud je příznak N nulový</i>
&nbsp;
        <i>; vymazání obsahu RAM</i>
        lda #$00                <i>; vynulování registru A</i>
loop:   sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne loop                <i>; po přetečení 0xff -&gt; 0x00 konec smyčky</i>
&nbsp;
        <i>; čekání na dokončení dalšího snímku, potom může začít herní smyčka</i>
wait3:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait3               <i>; skok, pokud je příznak N nulový</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTOR"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>

<p>Důležitá je i konfigurace linkeru, tedy (zjednodušeně řečeno) mapování
logických jmen segmentů na fyzické adresy a určení, které segmenty jsou
zapisovatelné a které nikoli (tedy zda se jedná o RAM či o ROM):</p>

<pre>
MEMORY {
    ZP:     start = $0000, size = $0100, type = rw;
    RAM:    start = $0300, size = $0400, type = rw;
    HEADER: start = $0000, size = $0010, type = rw,
            file = %O, fill = yes;
    PRG0:   start = $8000, size = $4000, type = ro,
            file = %O, fill = yes;
    CHR0a:  start = $0000, size = $1000, type = ro,
            file = %O, fill = yes;
    CHR0b:  start = $1000, size = $1000, type = ro,
            file = %O, fill = yes;
}
&nbsp;
SEGMENTS {
    ZEROPAGE: load = ZP, type = zp;
    BSS:    load = RAM, type = bss;
    HEADER: load = HEADER, type = ro, align = $10;
    CODE:   load = PRG0, type = ro;
    VECTORS: load = PRG0, type = ro, start = $BFFA;
    CHR0a:  load = CHR0a, type = ro;
    CHR0b:  load = CHR0b, type = ro;
}
</pre>

<p><div class="rs-tip-major">Poznámka: jak jste si již mohli všimnout, uvozují
se ve světě procesorů MOS 6502 hexadecimální hodnoty znakem dolaru, například
<strong>$BFFA</strong>. Tohoto způsobu zápisu se budeme držet i v&nbsp;dnešním
článku.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Hlavička obrazu ROM</h2>

<p>Teoreticky je možné, aby assembler vygeneroval přesnou kopii paměti NESu.
Tj.&nbsp;výsledkem by byl binární soubor o velikosti přesně 65536 bajtů
obsahující jak RAM a ROM, tak i všechny řídicí registry (a opakující se bloky
paměti). Ve skutečnosti se však dnes používá poměrně flexibilní formát INES,
který obsahuje libovolné bloky paměti a jeho velikost je tak proměnlivá. Navíc
podporuje mapování dalších paměťových bloků pro hry s&nbsp;větší ROM. Důležité
pro nás je, že tento formát <a
href="https://github.com/camsaul/nesasm/blob/master/ines_header_format.txt">obsahuje
hlavičku</a> s&nbsp;důležitými informacemi, kterou musíme naplnit. Tato
hlavička bude v&nbsp;assembleru reprezentována obsahem segmentu nazvaného
&bdquo;INES&ldquo; a obsahuje velikost ROM pro program, velikost ROM pro
dlaždice (grafiku) atd.:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 1
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "INES"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
.code
</pre>

<p>Po překladu příkladu (viz úvodní článek) získáme binární soubor nazvaný
<strong>ctnes.nes</strong>, jehož obsah si můžeme prohlédnout libovolným <a
href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">hexa
prohlížečem</a>. Standardním hexa prohlížečem na Linuxu je <strong>od</strong>
(nenechte se zmást jeho jménem, které klame &ndash; jedná se <strong>i</strong>
o hexa prohlížeč):</p>

<pre>
$ <strong>od -t x1 ctnes.nes</strong>
</pre>

<p>Důležitých je prvních šestnáct bajtů, které skutečně obsahují kýženou
hlavičku:</p>

<pre>
0000000 4e 45 53 1a 01 01 01 00 00 00 00 00 00 00 00 00
0000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0040000 00 00 00 00 00 00 00 00 00 00 00 10 02 10 01 10
0040020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0050020 40 40 78 d8 a2 ff 9a a2 00 8e 00 20 8e 01 20 8e
0050040 15 40 2c 02 20 10 fb 2c 02 20 10 fb a9 00 95 00
0050060 9d 00 01 9d 00 02 9d 00 03 9d 00 04 9d 00 05 9d
0050100 00 06 9d 00 07 e8 d0 e6 2c 02 20 10 fb 4c 3d 10
0050120 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Mapa paměti NESu</h2>

<p>Pro vývoj pro NES je vhodné seznámit s&nbsp;mapou paměti, přesněji řečeno
obsazení adres tak, jak je vidí mikroprocesor:</p>

<pre>
+-----------------------+ $FFFF
| Vektory NMI/RESET/IRQ |
+-----------------------+ $FFFA
|                       |
|                       |
|  Cartridge ROM (PRG)  |
|  32kB                 |
|                       |
|                       |
+-----------------------+ $8000
|                       |
|  Cartridge RAM (WRAM) |
|  8kB (+expansion ROM) |
|                       |
+-----------------------+ $4020
|  Řídicí registry APU  |
|  20B (jen 20 bajtů)   |
+-----------------------+ $4000
|  Řídicí registry PPU  |
|  8B (jen osm bajtů)   |
+-----------------------+ $2000
|                       |
|                       |
| (zrcadlená RAM)       |
|                       |
|                       |
+-----------------------+ $0800
|  Interní paměť RAM    |
|  2kB                  |
|.......................| $0200
|  Stack 256B           |
|.......................| $0100
|  Zero Page 256B       |
+-----------------------+ $0000
</pre>

<p>V&nbsp;nejvyšších šesti bajtech jsou uloženy vektory (adresy) přerušovacích
subrutin volaných automaticky při detekci přerušení či při resetu
(inicializaci) CPU:</p>

<pre>
$FFFA-$FFFB = NMI vector
$FFFC-$FFFD = Reset vector
$FFFE-$FFFF = IRQ/BRK vector
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Realizace obsluhy přerušení pro všechny tři typy přerušení procesoru 6502</h2>

<p>Mikroprocesor MOS 6502 podporuje tři typy přerušení:</p>

<ol>
<li>NMI (nemaskovatelné hardwarové přerušení)</li>
<li>RESET (reset mikroprocesoru)</li>
<li>IRQ (maskovatelné přerušení nebo instrukce BRK)</li>
</ol>

<p>Vzhledem k&nbsp;tomu, že v&nbsp;NESu není žádný operační systém ani BIOS,
musíme obsluhu přerušení realizovat vlastními prostředky. Vektory přerušení,
tj.&nbsp;adresy subrutin (podprogramů) pro obsluhu přerušení, jsou uloženy na
šesti nejvyšších adresách paměti, což pro nás v&nbsp;assembleru znamená obsah
(mini)segmentu &bdquo;VECTOR&ldquo;:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTOR"
.addr nmi
.addr reset
.addr irq
</pre>

<p>Tento segment skutečně obsahuje jen trojici adres, konkrétně adres subrutin.
Subrutina pro NMI bude prozatím obsahovat jen instrukci <strong>RTI</strong>
znamenající návrat z&nbsp;přerušení:</p>

<pre>
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
.proc nmi
        rti                     <i>; návrat z přerušení</i>
.endproc
</pre>

<p>Podobně jednoduchá bude obsluha IRQ &ndash; opět se vyvolá jen jediná
instrukce <strong>RTI</strong>:</p>

<pre>
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
.proc irq
        rti                     <i>; návrat z přerušení</i>
.endproc
</pre>

<p>Ovšem složitější již bude obslužná rutina přerušení RESET. Proč tomu tak je?
Tuto rutinu zavolá mikroprocesor po skutečném RESETu, ovšem i po zapnutí herní
konzole. Je to tedy vstupní bod do naší hry či dema a můžeme v&nbsp;něm
realizovat všechny inicializace a dokonce i spustit hlavní herní smyčku (viz
další text):</p>

<pre>
<i>; Obslužná rutina pro RESET</i>
&nbsp;
.proc reset
        ...
        ...
        ...
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: podrobnější popis této subrutiny bude
uveden <a href="#k14">ve čtrnácté kapitole</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Programátorský model mikroprocesoru MOS 6502</h2>

<p>Z&nbsp;programátorského hlediska se mikroprocesor MOS 6502 dosti podstatným
způsobem odlišuje jak od konkurenčního Intelu 8080 (i od později vydaného
Zilogu Z80), tak i od čipu RCA-1802. Zatímco procesor Intel 8080 obsahoval
poměrně rozsáhlou sadu obecně použitelných osmibitových registrů (A, B, C, D,
E, H a L), které se u některých instrukcí kombinovaly do 16bitových
registrových párů, měl 6502 pouze jeden osmibitový akumulátor (registr A) a dva
taktéž osmibitové index-registry pojmenované X a Y. Oba zmíněné typy procesorů
samozřejmě obsahovaly další speciální registry, jako ukazatel na vrchol
zásobníku (SP), programový čítač (PC) a příznakový registr (F).</p>

<p>Na první pohled by se mohlo zdát, že počet registrů mikroprocesoru MOS 6502
je zcela nedostatečný pro provádění většiny aritmetických či logických operací.
Ve skutečnosti tomu tak není, protože tento procesor podporuje načtení druhého
operandu z&nbsp;operační paměti (rychlost RAM nebyla tak limitujícím faktorem,
jako je tomu dnes &ndash; ve skutečnosti byl přístup do RAM dvojnásobně rychlý
v&nbsp;porovnání s&nbsp;mikroprocesorem). U mnoha instrukcí je podporován větší
počet adresovacích režimů, celkově je možné operandy strojových instrukcí
adresovat třinácti navzájem odlišnými způsoby. Při adresování se často
používají oba index-registry, které je možné inkrementovat a dekrementovat
&ndash; tím je umožněno provádění blokových přenosů dat, mazání souvislé
oblasti paměti atd.</p>

<p>Mikroprocesor MOS 6502 také zavádí pojem takzvané <i>nulté stránky
paměti</i>, která byla důsledně využita v&nbsp;instrukční sadě. Jedná se o
prvních 256 bytů operační paměti, kterou je možné adresovat zjednodušeným
způsobem. Adresa libovolné buňky z&nbsp;nulté stránky paměti je totiž uložena
na jednom byte v&nbsp;operačním kódu instrukce, takže celá instrukce může být
kratší (typicky pouze dva byte). Současně je i provádění instrukcí adresujících
nultou stránku paměti rychlejší než při šestnáctibitovém adresování (například
se provádí pouze osmibitové sčítání atd.). Z&nbsp;tohoto důvodu se můžeme na
nultou stránku paměti dívat jako na pole 256 registrů resp.&nbsp;alternativně
na 128 plnohodnotně využitelných 16bitových ukazatelů (musíme si opět uvědomit,
že operační paměti byly v&nbsp;té době stejně rychlé jako procesor, takže čtení
či zápis dat do paměti byla záležitost jednoho či dvou cyklů). Myšlenka nulté
stránky paměti byla dále rozšířena v&nbsp;procesoru Motorola 6809, kde se však
tato stránka dala v&nbsp;adresovatelné paměti posouvat na libovolné místo,
podobně jako v&nbsp;pokračovateli 6502 &ndash; 16bitovém čipu 65816 (použit
například v&nbsp;herní konzoli SNES).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Registry a příznakové bity mikroprocesoru MOS 6502</h2>

<p><i>&bdquo;The 65xx processors are not ruined with too many
registers.&ldquo;</i></p>

<p><a href="#k05">V&nbsp;předchozí kapitole</a> jsme si řekli, že MOS 6502
obsahoval pouze minimální, ovšem ještě prakticky použitelný počet registrů.
Všechny tyto registry, a to jak registry pracovní, tak i speciální, jsou
vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Registr</th><th>Šířka</th><th>Význam</th></tr>
<tr><td>1</td><td>A</td><td>8 bitů</td><td>akumulátor (pracovní registr)</td></tr>
<tr><td>2</td><td>X</td><td>8 bitů</td><td>index registr</td></tr>
<tr><td>3</td><td>Y</td><td>8 bitů</td><td>index registr</td></tr>
<tr><td>4</td><td>SP</td><td>8 bitů</td><td>část ukazatele na vrchol zásobníku (+ $0100)</td></tr>
<tr><td>5</td><td>PC</td><td>16 bitů</td><td>čítač instrukcí</td></tr>
<tr><td>6</td><td>P</td><td>7/8 bitů</td><td>příznakový a stavový registr</td></tr>
</table>

<p>Většina aritmetických a logických operací používala jako jeden
z&nbsp;operandů akumulátor, tedy registr <strong>A</strong>. Druhý operand byl
typicky načítán z&nbsp;operační paměti. Přitom se pro adresování velmi často
používaly index registry <strong>X</strong> a <strong>Y</strong>. Ukazatel na
vrchol zásobníku <strong>SP</strong> (či jen <strong>S</strong>) dokázal
adresovat zásobník v&nbsp;rozsahu $0100 až $01FF, tedy 256 bajtů (takzvanou
první stránku paměti). A příznakový registr <strong>P</strong> měl obsazen jen
sedm bitů:</p>

<table>
<tr><th>Bit</th><th>Zkratka</th><th>Označení</th><th>Význam</th></tr>
<tr><td>7</td><td>N</td><td>Negative</td><td>záporný výsledek předchozí operace (popř.&nbsp;nastavený sedmý bit)</td></tr>
<tr><td>6</td><td>V</td><td>oVerflow</td><td>přetečení do sedmého bitu (popř.&nbsp;nastavený šestý bit)</td></tr>
<tr><td>5</td><td>-</td><td>-</td><td>neobsazeno</td></tr>
<tr><td>4</td><td>B</td><td>Break</td><td>rozlišení přerušení od instrukce BRK či PHP</td></tr>
<tr><td>3</td><td>D</td><td>Decimal</td><td>režim výpočtů: binární versus BCD (decimální)</td></tr>
<tr><td>2</td><td>I</td><td>Interrupt</td><td>zákaz přerušení</td></tr>
<tr><td>1</td><td>Z</td><td>Zero</td><td>nulový výsledek předchozí operace</td></tr>
<tr><td>0</td><td>C</td><td>Carry</td><td>přenos při předchozí operaci</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: dá se říci, že &bdquo;aritmetické&ldquo;
příznakové bity <strong>N</strong>, <strong>V</strong>, <strong>Z</strong>, a
<strong>C</strong> byly <a
href="https://www.root.cz/clanky/pohled-programatora-na-mikroprocesory-arm/#k04">převzaty
a použity</a> při návrhu procesorů ARM, protože ARM byl vytvořen právě jako
náhrada za 6502 v&nbsp;počítačích pro Britskou veřejnost.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Adresovací režimy, využití registrů X a Y pro adresování</h2>

<p>Adresovací režimy odlišují osmibitový mikroprocesor MOS 6502 od naprosté
většiny ostatních mikroprocesorů a umožňují použít (zcela) odlišný styl
programování založený na efektivním použití nulté stránky paměti a obou index
registrů <strong>X</strong> i <strong>Y</strong>. Existuje celkem třináct
adresovacích režimů, ovšem již na tomto místě je nutné podotknout, že žádná
instrukce nevyužívá všechny tyto režimy. Některé adresovací režimy jsou určeny
pouze pro skoky, další pro implicitní operandy atd.:</p>

<table>
<tr><th> #</th><th>Zápis</th><th>Název</th><th>Assembler</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>A</td><td>accumulator</td><td>INS A</td><td>operandem je přímo akumulátor (instrukce tedy nemá žádný explicitně zapsaný operand)</td></tr>
<tr><td> 2</td><td>abs</td><td>absolute</td><td>INS $HHLL</td><td>za instrukcí následuje šestnáctibitová adresa, na níž je operand uložen</td></tr>
<tr><td> 3</td><td>abs,X</td><td>absolute, X-indexed</td><td>INS $HHLL,X</td><td>za instrukcí následuje šestnáctibitová adresa, která je přičtena k&nbsp;X</td></tr>
<tr><td> 4</td><td>abs,Y</td><td>absolute, Y-indexed</td><td>INS $HHLL,Y</td><td>za instrukcí následuje šestnáctibitová adresa, která je přičtena k&nbsp;Y</td></tr>
<tr><td> 5</td><td>#</td><td>immediate</td><td>INS #$BB</td><td>za instrukcí následuje bajt s&nbsp;osmibitovou konstantou</td></tr>
<tr><td> 6</td><td>impl</td><td>implied</td><td>INS</td><td>operand je odvozen přímo z&nbsp;instrukce, například INX</td></tr>
<tr><td> 7</td><td>ind</td><td>indirect</td><td>INS ($HHLL)</td><td>nepřímá adresace přes adresu uloženou za instrukcí (ta je ukazatelem), nepřímý skok</td></tr>
<tr><td> 8</td><td>X,ind</td><td>X-indexed, indirect</td><td>INS ($LL,X)</td><td>efektivní adresa je spočtena z&nbsp;hodnoty uložené na (LL+X)</td></tr>
<tr><td> 9</td><td>ind,Y</td><td>indirect, Y-indexed</td><td>INS ($LL),Y</td><td>efektivní adresa je spočtena z&nbsp;hodnoty uložené na LL, k&nbsp;výsledku se přičte Y</td></tr>
<tr><td>10</td><td>rel</td><td>relative</td><td>INS $BB</td><td>použito u relativních skoků; za instrukcí je jeden bajt reprezentující offset se znaménkem</td></tr>
<tr><td>11</td><td>zpg</td><td>zeropage</td><td>INS $LL</td><td>operand je uložen na nulté stránce na adrese LL</td></tr>
<tr><td>12</td><td>zpg,X</td><td>zeropage, X-indexed</td><td>INS $LL,X</td><td>operand je uložen na nulté stránce na adrese LL+X</td></tr>
<tr><td>13</td><td>zpg,Y</td><td>zeropage, Y-indexed</td><td>INS $LL,Y</td><td>operand je uložen na nulté stránce na adrese LL+Y</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: použití registrů <strong>X</strong> a
<strong>Y</strong> není zcela symetrické, protože se od sebe liší podporou
resp.&nbsp;nepodporou adresovacího režimu X,ind a ind,Y. Zejména režim číslo 9
lze použít pro operace s&nbsp;poli, přesuny bloků, mazání bloků atd. (je to
zcela typická součást MOS 6502 ukazující na promyšlený návrh celého
čipu).</div></p>

<p>Ukažme si nyní zajímavé použití již výše zmíněného režimu číslo 9. Prozatím
ovšem nemáme znalosti HW NESu, takže si ukažme, jakým způsobem se na
osmibitových počítačích Atari vypíše znak &bdquo;A&ldquo; do levého horního
rohu. To je zdánlivě snadné &ndash; v&nbsp;textovém režimu prostě na první
adresu video paměti zapíšeme kód znaku &bdquo;A&ldquo;, což je v&nbsp;ATASCII
hodnota 33. Ovšem jak zjistit adresu video paměti, která se odlišuje podle
použitého počítače (kapacita RAM může být 16kB, 48kB či 64kB), stavu cartridge
atd.? Systém zajišťuje, že tato adresa je uložena v&nbsp;nulté stránce paměti,
konkrétně na adresách $88 a $89. Na <i>adresu uloženou na těchto adresách</i>
tedy musíme zapsat hodnotu 33. Jedno z&nbsp;možných (plně funkčních) řešení
vypadá takto (registr <strong>Y</strong> je nutné použít, ovšem jeho hodnotu
ponecháme na nule, takže adresu neovlivní &ndash; <strong>Y</strong> použijeme
při tisku celého řetězce):</p>

<pre>
.include "atari.inc"
&nbsp;
.CODE
&nbsp;
.proc <strong>main</strong>
        lda #33                 <i>; ATASCII hodnota znaku "A"</i>
        ldy #0                  <i>; vynulovat registr Y</i>
        sta (88),y              <i>; tisk znaku "A" na první místo na obrazovce</i>
                                <i>; (adresa Video RAM je na adresách 88 a 89)</i>
loop:   jmp loop
end:
.endproc
&nbsp;
&nbsp;
.segment "EXEHDR"
.word   $ffff
.word   main
.word   main::end - 1
&nbsp;
&nbsp;
.segment "AUTOSTRT"
.word   RUNAD                   <i>; definováno v atari.h</i>
.word   RUNAD+1
.word   main
</pre>

<p><img src="https://i.iinfo.cz/images/320/atari-a.png" class="image-576309" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="336" height="240" /></p>
<p><i>Obrázek 1: Předchozí program po spuštění.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Aritmetické a logické instrukce</h2>

<p>Mikroprocesor <i>MOS 6502</i> obsahuje <a
href="https://masswerk.at/6502/6502_instruction_set.html">pouze 56
instrukcí</a>, přičemž mnoho instrukcí podporuje větší množství adresovacích
režimů a tudíž i více variant (i tak však zdaleka <a
href="https://masswerk.at/6502/6502_instruction_set.html">není obsazeno všech
256 možných kombinací</a> &ndash; ty byly postupně obsazovány v&nbsp;dalších
procesorech, popř.&nbsp;na původním MOS 6502 měly sice oficiálně
nedokumentovanou, ovšem logickou/očekávanou funkci &ndash; například načtení
registru A i X jedinou instrukcí atd.). Nejprve si popíšeme aritmetické a
logické instrukce mikroprocesoru MOS 6502. Většina dále popsaných instrukcí
jako svůj první operand akceptuje akumulátor a druhým operandem může být
konstanta popř.&nbsp;hodnota načtená z&nbsp;operační paměti s&nbsp;využitím
výše popsaných adresovacích režimů. Výjimkou jsou instrukce s&nbsp;jediným
operandem, v&nbsp;nichž nemusí vystupovat akumulátor popř.&nbsp;instrukce,
v&nbsp;nichž je přímo operand vyjádřen názvem instrukce (<strong>INX</strong>
atd.):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Plné jméno</th><th>Popis</th></tr>
<tr><td> 1</td><td>ADC</td><td>add with carry</td><td>součet hodnoty s&nbsp;akumulátorem (včetně přetečení)</td></tr>
<tr><td> 2</td><td>SBC</td><td>subtract with carry</td><td>odečtení hodnoty od akumulátoru (včetně výpůjčky)</td></tr>
<tr><td> 3</td><td>AND</td><td>and with accumulator</td><td>logická operace AND s&nbsp;akumulátorem</td></tr>
<tr><td> 4</td><td>ORA</td><td>or with accumulator</td><td>logická operace OR s&nbsp;akumulátorem</td></tr>
<tr><td> 5</td><td>EOR</td><td>exclusive or with accumulator</td><td>logická operace XOR s&nbsp;akumulátorem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>INC</td><td>increment</td><td>zvýšení hodnoty o 1 (kupodivu nelze provést přímo s&nbsp;akumulátorem, ovšem s&nbsp;pamětí ano)</td></tr>
<tr><td> 7</td><td>INX</td><td>increment X</td><td>zvýšení hodnoty index registru <strong>X</strong> o 1 </td></tr>
<tr><td> 8</td><td>INY</td><td>increment Y</td><td>zvýšení hodnoty index registru <strong>Y</strong> o 1 </td></tr>
<tr><td> 9</td><td>DEC</td><td>decrement</td><td>snížení hodnoty o 1 (opět nelze provést s&nbsp;akumulátorem)</td></tr>
<tr><td>10</td><td>DEX</td><td>decrement X</td><td>snížení hodnoty index registru <strong>X</strong> o 1 </td></tr>
<tr><td>11</td><td>DEY</td><td>decrement Y</td><td>snížení hodnoty index registru <strong>Y</strong> o 1 </td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>CMP</td><td>compare with accumulator</td><td>odečtení hodnoty od akumulátoru bez zápisu výsledku</td></tr>
<tr><td>13</td><td>CPX</td><td>compare with X</td><td>odečtení hodnoty od index registru <strong>X</strong> bez zápisu výsledku</td></tr>
<tr><td>14</td><td>CPY</td><td>compare with Y</td><td>odečtení hodnoty od index registru <strong>Y</strong> bez zápisu výsledku</td></tr>
<tr><td>15</td><td>BIT</td><td>bit test</td><td>logické AND bez uložení výsledků (změní se jen příznakové bity)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>ASL</td><td>arithmetic shift left</td><td>aritmetický posun doleva o jeden bit</td></tr>
<tr><td>17</td><td>LSR</td><td>logical shift right</td><td>logický posun doprava o jeden bit</td></tr>
<tr><td>18</td><td>ROL</td><td>rotate left</td><td>rotace doleva o jeden bit</td></tr>
<tr><td>19</td><td>ROR</td><td>rotate right</td><td>rotace doprava o jeden bit</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: instrukce <strong>CMP</strong>,
<strong>CPX</strong>, <strong>CPY</strong> a <strong>BIT</strong> nastavují
příznakové bity a setkáme se s&nbsp;nimi později.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Skoky a rozvětvení</h2>

<p>Následuje další skupina instrukcí. Konkrétně se jedná o instrukce skoku,
popř.&nbsp;skoku a výskoku ze subrutiny (podprogramu). Skákat je možné
v&nbsp;rámci celé adresovatelné RAM, tedy v&nbsp;rozsahu plných 64kB:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Plné jméno</th><th>Popis</th></tr>
<tr><td>20</td><td>JMP</td><td>jump</td><td>skok (existuje několik adresovacích režimů této instrukce)</td></tr>
<tr><td>21</td><td>JSR</td><td>jump to subroutine</td><td>skok do podprogramu s&nbsp;uložením návratové adresy na zásobník</td></tr>
<tr><td>22</td><td>RTS</td><td>return from subroutine</td><td>návrat z&nbsp;podprogramu</td></tr>
<tr><td>23</td><td>RTI</td><td>return from interrupt</td><td>návrat z&nbsp;prerušovací rutiny (již jsme tuto instrukci potkali)</td></tr>
</table>

<p>Relativní skoky v&nbsp;rámci rozsahu -128 až 127 jsou provedeny na základě
vyhodnocení nějaké podmínky, konkrétně testování zvoleného příznakového bitu.
Oproti Motorole 6800, ze které 6502 ideově vychází, byl počet podmíněných skoků
snížen na polovinu, takže některé kombinace podmínek neexistují (včetně
<strong>BRA</strong> a <strong>BRN</strong>):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Plné jméno</th><th>Popis</th></tr>
<tr><td>24</td><td>BCC</td><td>branch on carry clear</td><td>rozvětvení za podmínky <strong>C</strong>==0</td></tr>
<tr><td>25</td><td>BCS</td><td>branch on carry set</td><td>rozvětvení za podmínky <strong>C</strong>==1</td></tr>
<tr><td>26</td><td>BEQ</td><td>branch on equal (zero set)</td><td>rozvětvení za podmínky <strong>Z</strong>==1</td></tr>
<tr><td>27</td><td>BMI</td><td>branch on minus (negative set)</td><td>rozvětvení za podmínky <strong>N</strong>==1</td></tr>
<tr><td>28</td><td>BNE</td><td>branch on not equal (zero clear)</td><td>rozvětvení za podmínky <strong>Z</strong>==0</td></tr>
<tr><td>29</td><td>BPL</td><td>branch on plus (negative clear)</td><td>rozvětvení za podmínky <strong>N</strong>==0</td></tr>
<tr><td>30</td><td>BVC</td><td>branch on overflow clear</td><td>rozvětvení za podmínky <strong>O</strong>==0</td></tr>
<tr><td>31</td><td>BVS</td><td>branch on overflow set</td><td>rozvětvení za podmínky <strong>O</strong>==1</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si neexistence podmíněných
skoků, kde by podmínka byla tvořena kombinací příznakových bitů. Typickými
příklady z&nbsp;jiných architektur by byly instrukce související
s&nbsp;aritmetikou s&nbsp;dvojkovým doplňkem (tedy s&nbsp;potenciálně zápornými
hodnotami), jejichž porovnání je složitější.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukce pro přesuny dat</h2>

<p>Další skupinou instrukcí jsou instrukce určené pro přesuny dat mezi operační
pamětí a registry, popř.&nbsp;mezi registry navzájem. Jedná se o poměrně velké
množství instrukcí, které jsou zvláštní tím, že instrukce pro načtení dat
modifikují příznakové bity <strong>N</strong> a <strong>Z</strong>, takže již
pouhé načtení hodnoty zjistí, zda se jedná o hodnotu zápornou nebo nulovou
(resp.&nbsp;nezápornou či nenulovou):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Plné jméno</th><th>Popis</th></tr>
<tr><td>32</td><td>LDA</td><td>load accumulator</td><td>načtení bajtu do akumulátoru</td></tr>
<tr><td>33</td><td>LDX</td><td>load X</td><td>načtení bajtu do registru X</td></tr>
<tr><td>34</td><td>LDY</td><td>load Y</td><td>načtení bajtu do registru Y</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>35</td><td>STA</td><td>store accumulator</td><td>uložení hodnoty akumulátoru</td></tr>
<tr><td>36</td><td>STX</td><td>store X</td><td>uložení hodnoty registru X</td></tr>
<tr><td>37</td><td>STY</td><td>store Y</td><td>uložení hodnoty registru Y</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>38</td><td>TAX</td><td>transfer accumulator to X</td><td>přesun X=A</td></tr>
<tr><td>39</td><td>TAY</td><td>transfer accumulator to Y</td><td>přesun Y=A</td></tr>
<tr><td>40</td><td>TSX</td><td>transfer stack pointer to X</td><td>přesun X=SP</td></tr>
<tr><td>41</td><td>TXA</td><td>transfer X to accumulator</td><td>přesun A=X</td></tr>
<tr><td>42</td><td>TXS</td><td>transfer X to stack pointer</td><td>přesun SP=X</td></tr>
<tr><td>43</td><td>TYA</td><td>transfer Y to accumulator</td><td>přesun A=Y</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>44</td><td>PHA</td><td>push accumulator</td><td>uložení akumulátoru na zásobník</td></tr>
<tr><td>45</td><td>PHP</td><td>push processor status (SR)</td><td>uložení příznaků na zásobník</td></tr>
<tr><td>46</td><td>PLA</td><td>pull accumulator</td><td>obnovení akumulátoru ze zásobníku</td></tr>
<tr><td>47</td><td>PLP</td><td>pull processor status (SR)</td><td>obnovení příznaků ze zásobníku</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si určité neortogonality
resp.&nbsp;nesymetrie v&nbsp;této části instrukční sady. Například instrukce
<strong>T..</strong> neobsahují všechny možné kombinace; příkladem je
neexistující instrukce <strong>TXY</strong> apod. Dále chybí některé adresovací
režimy u <strong>LDX</strong> a <strong>LDY</strong> v&nbsp;porovnání
s&nbsp;<strong>LDA</strong>:</div></p>

<pre>
LDA
    immediate     LDA #oper
    zeropage      LDA oper
    zeropage,X    LDA oper,X
    absolute      LDA oper
    absolute,X    LDA oper,X
    absolute,Y    LDA oper,Y
    (indirect,X)  LDA (oper,X)
    (indirect),Y  LDA (oper),Y
&nbsp;
LDX
    immediate     LDX #oper
    zeropage      LDX oper
    zeropage,Y    LDX oper,Y
    absolute      LDX oper
    absolute,Y    LDX oper,Y
&nbsp;
LDY
    immediate     LDY #oper
    zeropage      LDY oper
    zeropage,X    LDY oper,X
    absolute      LDY oper
    absolute,X    LDY oper,X
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Manipulace s&nbsp;příznakovými bity</h2>

<p>Několik instrukcí manipuluje přímo s&nbsp;příznakovými bity. Jedná se o
následující instrukce:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Plné jméno</th><th>Operace provedená instrukcí</th></tr>
<tr><td>48</td><td>CLC</td><td>clear carry</td><td>nastavení C=0</td></tr>
<tr><td>49</td><td>CLD</td><td>clear decimal</td><td>nastavení D=0</td></tr>
<tr><td>50</td><td>CLI</td><td>clear interrupt disable</td><td>nastavení I=0</td></tr>
<tr><td>51</td><td>CLV</td><td>clear overflow</td><td>nastavení V=0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>SEC</td><td>set carry</td><td>nastavení C=1</td></tr>
<tr><td>53</td><td>SED</td><td>set decimal</td><td>nastavení D=1</td></tr>
<tr><td>54</td><td>SEI</td><td>set interrupt disable</td><td>nastavení I=1</td></tr>
</table>

<p>Mnemotechnika pojmenování těchto instrukcí je jednoduchá &ndash;
<strong>CL</strong> znamená <i>clear</i> kdežto <strong>SE</strong> znamená
<i>set</i>.</p>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že zdaleka ne všechny
příznaky je možné přímo nastavit nebo vynulovat (celkově bychom totiž
potřebovali čtrnáct instrukcí). Ovšem mnoho příznaků je nastavováno či nulováno
jinými instrukcemi, například <strong>BIT</strong> či <strong>CMP</strong>,
čehož je možné využít (při výpočtech vlastně musíme přímo manipulovat jen
s&nbsp;příznakem <strong>C</strong> kvůli rotacím).</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zbývající instrukce</h2>

<p>Zbývá nám popsat už jen dvě instrukce nezařazené do žádné výše uvedené
skupiny. Jedná se o tyto instrukce:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Plné jméno</th><th>Popis</th></tr>
<tr><td>55</td><td>NOP</td><td>no operation</td><td>přechod na další instrukci</td></tr>
<tr><td>56</td><td>BRK</td><td>break / interrupt</td><td>uložení PC a SR na zásobník, zastavení (návrat do monitoru)</td></tr>
</table>

<p>Instrukce <strong>BRK</strong> je velmi zvláštní. Samotný operační kód má
délku jednoho bajtu, ovšem pokud procesor tuto instrukci vykoná, zapíše na
zásobník adresu o další bajt (jedničku) zvětšenou. To znamená, že při návratu
z&nbsp;obsluhy přerušení (protože <strong>BRK</strong> je vlastně softwarové
přerušení) se zdá, jakoby <strong>BRK</strong> měla délku dva bajty. Tento bajt
navíc lze použít například pro rozlišení, o které přerušení se jedná atd. A
navíc je operační kód instrukce <strong>BRK</strong> roven $00. Pokud je paměť
(až na program) vynulována a provede se skok kamkoli mimo program, dojde ihned
k&nbsp;jeho zastavení &ndash; což je opět užitečné, zejména pokud je 6502
použit v&nbsp;kritických aplikacích. Mnohé jiné architektury mají operační kód
$00 vyhrazen pro <strong>NOP</strong>, což znamená, že při špatném skoku bude
procesor interpretovat tyto <strong>NOP</strong>y až narazí na nějakou náhodnou
instrukci/instrukce, které vykoná (což nechceme).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Kde si lze možnosti 6502 otestovat bez nutnosti pochopit strukturu NESu?</h2>

<p>Instrukční sadu mikroprocesoru MOS 6502 si lze dokonce odzkoušet na
prakticky jakémkoli současném počítači či tabletu, a to bez nutnosti instalace
assembleru a/nebo simulátoru (popř.&nbsp;emulátoru některého osmibitového
domácího mikropočítače nebo herní konzole). Na stránce <a
href="http://6502asm.com/">http://6502asm.com/</a> se totiž nachází vydařený
simulátor virtuálního počítače vybaveného jednoduchým displejem, klávesnicí a
v&nbsp;neposlední řadě právě mikroprocesorem MOS 6502. Tento simulátor, jenž
byl naprogramovaný Stianem Sorengem, obsahuje editor (ve skutečnosti se
v&nbsp;současné verzi jedná o pouhé textové pole umístěné na HTML stránce), do
něhož je možné zapsat program v&nbsp;jazyku symbolických instrukcí a následně
tento program přeložit vestavěným assemblerem a poté i spustit. Na adrese $fe
se nachází generátor náhodných číel, na adrese $ff pak kód stisknuté klávesy.
Jediným výstupním médiem je rastrový obrázek 32&times;32 pixelů uložený od
adresy $200 do $5ff (1024 bajtů), ovšem jen spodní bity obsahují barvu.</p>

<p><div class="rs-tip-major">Poznámka: to je vše &ndash; popis tohoto
(pseudo)počítače se skutečně vlezl do jediného odstavce! NES je v&nbsp;tomto
ohledu velmi odlišný.</div></p>

<p>Příklad vykreslení svislých pruhů na &bdquo;obrazovku&ldquo;:</p>

<pre>
    LDA #0       ; zapisovaná hodnota
    LDX #0       ; počitadlo a současně i adresa pro zápis
LOOP:
    STA $200,X   ; vykreslení do první čtvrtiny obrazovky
    STA $300,X
    STA $400,X
    STA $500,X   ; vykreslení do čtvrté čtvrtiny obrazovky
    ADC #1       ; index vykreslované barvy
    INX          ; přechod na další pixel
BNE LOOP         ; skonči po zápisu 256 pixelů
</pre>

<p><div class="rs-tip-major">Poznámka: pokuste se použít index
<strong>Y</strong> pro vnější smyčku, aby nebylo nutné provádět čtyři zápisy
ručně.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Druhý pohled na kostru programu</h2>

<p>Nyní již máme dostatek informací pro pochopení kostry programu, kterou jsme
si <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-vyvoj-her-a-demo-programu-pro-herni-konzoli-nes/#k18">uvedli
minule</a>. Připomeňme si, že se jedná o plně funkční kód, který ihned po
spuštění herní konzole (nebo jejího emulátoru) provede inicializaci
mikroprocesoru, následně inicializaci PPU a APU (grafika a zvuky), vymaže
operační paměť a spustí nekonečnou (prozatím prázdnou) herní smyčku. Jednotlivé
části tohoto kódu jsou vysvětleny v&nbsp;navazujících kapitolách:</p>

<pre>
<i>; Obslužná rutina pro RESET</i>
&nbsp;
.proc reset
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx $2000               <i>; nastavení PPUCTRL = 0</i>
        stx $2001               <i>; nastavení PPUMASK = 0</i>
        stx $4015               <i>; nastavení APUSTATUS = 0</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
wait1:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait1               <i>; skok, pokud je příznak N nulový</i>
wait2:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait2               <i>; skok, pokud je příznak N nulový</i>
&nbsp;
        <i>; vymazání obsahu RAM</i>
        lda #$00                <i>; vynulování registru A</i>
loop:   sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne loop                <i>; po přetečení 0xff -&gt; 0x00 konec smyčky</i>
&nbsp;
        <i>; čekání na dokončení dalšího snímku, potom může začít herní smyčka</i>
wait3:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait3               <i>; skok, pokud je příznak N nulový</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
.endproc
</pre>




<p><a name="k15"></a></p>
<h2 id="k15">15. Nastavení stavu mikroprocesoru po resetu</h2>

<p>Víme již, že jak nastavení hardware, tak i vlastního mikroprocesoru po
resetu (a tedy i po spuštění konzole) musíme jako vývojáři zajistit sami.
Nejprve se podívejme na způsob nastavení stavu mikroprocesoru. Typicky ihned na
začátku zakážeme maskovatelné přerušení instrukcí <strong>SEI</strong> (<i>Set
Interrupt Disable Status</i>) a následně pro jistotu vypneme dekadický režim
výpočtů (BCD), jenž stejně není čipem Ricoh 2A03 podporován (a tedy jeho
povolení by byla nedefinovaná operace):</p>

<pre>
<i>; nastavení stavu CPU</i>
sei                     <i>; zákaz přerušení</i>
cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
</pre>

<p>Následuje malý trik, kterým se vlastně vymaže celý zásobník. Nastavíme totiž
adresu vrcholu zásobníku na adresu $1ff, přičemž prefix $100 je řešen samotným
procesorem (nastavujeme jen spodních osm bitů). Takto ušetříme několik bajtů na
zásobníku, protože vlastně zahodíme jak výplňový bajt, tak i adresu návratu ze
subrutiny <strong>reset</strong> (ta končí nekonečnou smyčkou, tudíž z&nbsp;ní
nikdy nevyskočíme):</p>

<pre>
ldx #$ff
txs                     <i>; vrchol zásobníku nastaven na 0x1ff (první stránka)</i>
</pre>

<p><div class="rs-tip-major">Poznámka: registr <strong>Y</strong> je jediným
registrem, který lze použít pro přímý přesun hodnoty do registru
<strong>S/SP</strong>. Jedná se o jeden z&nbsp;případů neortogonality
instrukční sady MOS 6502.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Nastavení řídicích registrů</h2>

<p>Před spuštěním herní smyčky je nutné nastavit i některé <a
href="https://nesdev-wiki.nes.science/wikipages/PPU_registers.xhtml">řídicí
registry PPU</a> (grafika) i APU (hudba a zvuky). Zejména je nutné vynulovat
registr <a
href="https://nesdev-wiki.nes.science/wikipages/PPU_registers.xhtml#Controller_.28.242000.29_.3E_write">PPUCTRL</a>.
Zápisem nuly mj.&nbsp;zajistíme, že se nebude generovat NMI (nemaskovatelné
přerušení) po každém zobrazeném snímku. Další registr, který vynulujeme, se
jmenuje <a
href="https://nesdev-wiki.nes.science/wikipages/PPU_registers.xhtml#Mask_.28.242001.29_.3E_write">PPUMASK</a>.
Zápisem nuly mj.&nbsp;zakážeme zobrazení všech grafických objektů, tj.&nbsp;jak
pozadí, tak i spritů. Nulu zapíšeme i do řídicího registru nazvaného
<strong>SND_CHN</strong> neboli plným jménem &bdquo;Sound channels enable and
status&ldquo;. Ten je  (z&nbsp;pohledu mikroprocesoru) namapován na adresu
$4015 a zápisem nuly vypneme zvuky:</p>

<pre>
<i>; nastavení řídicích registrů</i>
ldx #$00
stx $2000               <i>; nastavení PPUCTRL = 0</i>
stx $2001               <i>; nastavení PPUMASK = 0</i>
stx $4015               <i>; nastavení APUSTATUS = 0</i>
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě zde můžeme použít akumulátor
<strong>A</strong> a zapisovat nuly instrukcí <strong>STA</strong>.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Trik pro čekání na zobrazení dalšího snímku</h2>

<p>Před provedením dalších operací je nutné počkat na stabilizaci grafického
čipu. Typicky je tato operace vyřešena počkáním na vykreslení dvou snímků. Jak
je však možné toto čekání realizovat v&nbsp;praxi? Realizace je založena na
opakovaném čtení registru <a
href="https://nesdev-wiki.nes.science/wikipages/PPU_registers.xhtml#Status_.28.242002.29_.3C_read">PPUSTATUS</a>,
který je mapován na adresu $2002. Při čtení nás bude zajímat nejvyšší (sedmý)
bit, jenž je nastaven na jedničku ve chvíli, kdy probíhá takzvaný <i>vertical
blank</i> neboli vertikální zatemnění obrazu po vykreslení snímku. Zajímavé je,
že po přečtení stavového registru je tento bit automaticky smazán. Algoritmus
čekání na snímek tedy bude vypadat takto:</p>

<ol>
<li>Přečti obsah sedmého bitu registru PPUSTATUS</li>
<li>Pokud je obsah nulový, skok na bod 1</li>
<li>...jsme ve vertikálním zatemnění - snímek byl vykreslen</li>
</ol>

<p>A při realizaci kroku 1 a 2 využijeme elegantní trik procesoru 6502.
Použijeme totiž instrukci <strong>BIT</strong>, která načte obsah paměti na
specifikované adrese a (kromě dalších operací) zkopíruje obsah sedmého bitu
z&nbsp;načtené hodnoty do příznakového bitu <strong>N</strong>
(<i>negative</i>). Test na nulovost tedy v&nbsp;tomto případě zajistí instrukce
<strong>BPL</strong> (<i>branch if plus</i>):</p>

<pre>
wait1:  bit $2002               <i>; test obsahu registru PPUSTATUS </i>
        bpl wait1               <i>; skok, pokud je příznak N nulový</i>
</pre>

<p><div class="rs-tip-major">Poznámka: instrukce <strong>BIT</strong> umožňuje
i provedení dalších triků, s&nbsp;nimiž se seznámíme příště.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Trik pro vymazání obsahu RAM</h2>

<p>Po zapnutí herní konzole je obecně obsah RAM náhodný. Minimálně pro ladicí
účely je vhodné paměť promazat, už jen z&nbsp;toho důvodu, že hodnota $00
znamená operační kód instrukce <strong>BRK</strong>. Existuje mnoho možností,
jak zajistit přepsání bloku paměti konstantní hodnotou a žádný z&nbsp;těchto
způsobů není příliš intuitivní. Je tomu tak z&nbsp;toho důvodu, že indexové
registry mají šířku jen osmi bitů a případná přímá změna adresy v&nbsp;kódu
instrukce není možná, pokud je tento kód uložen v&nbsp;ROM. Ovšem díky tomu, že
kapacita RAM u NES je rovna pouze dvěma kilobajtům, což odpovídá osmi stránkám
paměti (po 256 bajtech), můžeme &bdquo;otrocky&ldquo; smazat těchto osm stránek
například takto:</p>

<pre>
        <i>; vymazání obsahu RAM</i>
        lda #$00                <i>; vynulování registru A</i>
loop:   sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne loop                <i>; po přetečení 0xff -&gt; 0x00 konec smyčky</i>
</pre>

<p><div class="rs-tip-major">Poznámka: u moderních architektur je podobný kód
obecně velmi špatný, protože nevyužívá &bdquo;burst&ldquo; přenosu a navíc může
zbytečně přetěžovat cache (vyrovnávací paměť). Ovšem výhodou MOS 6502 i dalších
osmibitových CPU je fakt, že podobné techniky většinou vůbec nepodporují a
proto je zde RAM skutečně &bdquo;random access memory&ldquo;, což o moderních
architekturách neplatí ani náhodou.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad pomocí <strong>ca65</strong>, byly uložen do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již poměrně rozsáhlý) repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>example01.asm</td><td>zdrojový kód příkladu tvořeného kostrou aplikace pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm</a></td></tr>
<tr><td>2</td><td>example02.asm</td><td>použití standardní konfigurace linkeru pro konzoli NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm</a></td></tr>
<tr><td>3</td><td>example03.asm</td><td>symbolická jména řídicích registrů PPU</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm</a></td></tr>
<tr><td>4</td><td>example04.asm</td><td>zjednodušený zápis lokálních smyček</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>link.cfg</td><td>konfigurace segmentů pro linker <strong>ld65</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg</a></td></tr>
<tr><td>6</td><td>Makefile</td><td>Makefile pro překlad příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>NesDev.org<br />
<a href="https://www.nesdev.org/">https://www.nesdev.org/</a>
</li>

<li>How to Program an NES game in C<br />
<a href="https://nesdoug.com/">https://nesdoug.com/</a>
</li>

<li>Getting Started Programming in C: Coding a Retro Game with C Part 2<br />
<a href="https://retrogamecoders.com/getting-started-with-c-cc65/">https://retrogamecoders.com/getting-started-with-c-cc65/</a>
</li>

<li>"Game Development in Eight Bits" by Kevin Zurawel<br />
<a href="https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4">https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4</a>
</li>

<li>Game Development for the 8-bit NES: A class by Bob Rost<br />
<a href="http://bobrost.com/nes/">http://bobrost.com/nes/</a>
</li>

<li>Game Development for the 8-bit NES: Lecture Notes<br />
<a href="http://bobrost.com/nes/lectures.php">http://bobrost.com/nes/lectures.php</a>
</li>

<li>NES Graphics Explained<br />
<a href="https://www.youtube.com/watch?v=7Co_8dC2zb8">https://www.youtube.com/watch?v=7Co_8dC2zb8</a>
</li>

<li>NES GAME PROGRAMMING PART 1<br />
<a href="https://rpgmaker.net/tutorials/227/?post=240020">https://rpgmaker.net/tutorials/227/?post=240020</a>
</li>

<li>NES 6502 Programming Tutorial - Part 1: Getting Started<br />
<a href="https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/">https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/</a>
</li>

<li>Minimal NES example using ca65<br />
<a href="https://github.com/bbbradsmith/NES-ca65-example">https://github.com/bbbradsmith/NES-ca65-example</a>
</li>

<li>List of 6502-based Computers and Consoles<br />
<a href="https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/">https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/</a>
</li>

<li>History of video game consoles (second generation): Wikipedia<br />
<a href="http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)">http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)</a>
</li>

<li>6502 - the first RISC &micro;P<br />
<a href="http://ericclever.com/6500/">http://ericclever.com/6500/</a>
</li>

<li>3 Generations of Game Machine Architecture<br />
<a href="http://www.atariarchives.org/dev/CGEXPO99.html">http://www.atariarchives.org/dev/CGEXPO99.html</a>
</li>

<li>bee - The Multi-Console Emulator<br />
<a href="http://www.thebeehive.ws/">http://www.thebeehive.ws/</a>
</li>

<li>Nerdy Nights Mirror<br />
<a href="https://nerdy-nights.nes.science/">https://nerdy-nights.nes.science/</a>
</li>

<li>NES Development Day 1: Creating a ROM<br />
<a href="https://www.moria.us/blog/2018/03/nes-development">https://www.moria.us/blog/2018/03/nes-development</a>
</li>

<li>How to Start Making NES Games<br />
<a href="https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/">https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/</a>
</li>

<li>ca65 Users Guide<br />
<a href="https://cc65.github.io/doc/ca65.html">https://cc65.github.io/doc/ca65.html</a>
</li>

<li>cc65 Users Guide<br />
<a href="https://cc65.github.io/doc/cc65.html">https://cc65.github.io/doc/cc65.html</a>
</li>

<li>ld65 Users Guide<br />
<a href="https://cc65.github.io/doc/ld65.html">https://cc65.github.io/doc/ld65.html</a>
</li>

<li>da65 Users Guide<br />
<a href="https://cc65.github.io/doc/da65.html">https://cc65.github.io/doc/da65.html</a>
</li>

<li>Nocash NES Specs<br />
<a href="http://nocash.emubase.de/everynes.htm">http://nocash.emubase.de/everynes.htm</a>
</li>

<li>Nintendo Entertainment System<br />
<a href="http://cs.wikipedia.org/wiki/NES">http://cs.wikipedia.org/wiki/NES</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>NesDev<br />
<a href="http://nesdev.parodius.com/">http://nesdev.parodius.com/</a>
</li>

<li>2A03 technical reference<br />
<a href="http://nesdev.parodius.com/2A03%20technical%20reference.txt">http://nesdev.parodius.com/2A03%20technical%20reference.txt</a>
</li>

<li>NES Dev wiki: 2A03<br />
<a href="http://wiki.nesdev.com/w/index.php/2A03">http://wiki.nesdev.com/w/index.php/2A03</a>
</li>

<li>Ricoh 2A03<br />
<a href="http://en.wikipedia.org/wiki/Ricoh_2A03">http://en.wikipedia.org/wiki/Ricoh_2A03</a>
</li>

<li>2A03 pinouts<br />
<a href="http://nesdev.parodius.com/2A03_pinout.txt">http://nesdev.parodius.com/2A03_pinout.txt</a>
</li>

<li>27c3: Reverse Engineering the MOS 6502 CPU (en)<br />
<a href="https://www.youtube.com/watch?v=fWqBmmPQP40">https://www.youtube.com/watch?v=fWqBmmPQP40</a>
</li>

<li>“Hello, world” from scratch on a 6502 — Part 1<br />
<a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">https://www.youtube.com/watch?v=LnzuMJLZRdU</a>
</li>

<li>A Tour of 6502 Cross-Assemblers<br />
<a href="https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/">https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/</a>
</li>

<li>Nintendo Entertainment System (NES)<br />
<a href="https://8bitworkshop.com/docs/platforms/nes/">https://8bitworkshop.com/docs/platforms/nes/</a>
</li>

<li>Question about NES vectors and PPU<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t4154.xhtml">https://archive.nes.science/nesdev-forums/f10/t4154.xhtml</a>
</li>

<li>How do mapper chips actually work?<br />
<a href="https://archive.nes.science/nesdev-forums/f9/t13125.xhtml">https://archive.nes.science/nesdev-forums/f9/t13125.xhtml</a>
</li>

<li>INES<br />
<a href="https://www.nesdev.org/wiki/INES">https://www.nesdev.org/wiki/INES</a>
</li>

<li>NES Basics and Our First Game<br />
<a href="http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html">http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html</a>
</li>

<li>Where is the reset vector in a .nes file?<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t17413.xhtml">https://archive.nes.science/nesdev-forums/f10/t17413.xhtml</a>
</li>

<li>CPU memory map<br />
<a href="https://www.nesdev.org/wiki/CPU_memory_map">https://www.nesdev.org/wiki/CPU_memory_map</a>
</li>

<li>How to make NES music<br />
<a href="http://blog.snugsound.com/2008/08/how-to-make-nes-music.html">http://blog.snugsound.com/2008/08/how-to-make-nes-music.html</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>MIDINES<br />
<a href="http://www.wayfar.net/0xf00000_overview.php">http://www.wayfar.net/0xf00000_overview.php</a>
</li>

<li>FamiTracker<br />
<a href="http://famitracker.com/">http://famitracker.com/</a>
</li>

<li>nerdTracker II<br />
<a href="http://nesdev.parodius.com/nt2/">http://nesdev.parodius.com/nt2/</a>
</li>

<li>How NES Graphics work<br />
<a href="http://nesdev.parodius.com/nesgfx.txt">http://nesdev.parodius.com/nesgfx.txt</a>
</li>

<li>NES Technical/Emulation/Development FAQ<br />
<a href="http://nesdev.parodius.com/NESTechFAQ.htm">http://nesdev.parodius.com/NESTechFAQ.htm</a>
</li>

<li>Adventures with ca65<br />
<a href="https://atariage.com/forums/topic/312451-adventures-with-ca65/">https://atariage.com/forums/topic/312451-adventures-with-ca65/</a>
</li>

<li>example ca65 startup code<br />
<a href="https://atariage.com/forums/topic/209776-example-ca65-startup-code/">https://atariage.com/forums/topic/209776-example-ca65-startup-code/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer<br />
<a href="http://wilsonminesco.com/6502primer/">http://wilsonminesco.com/6502primer/</a>
</li>

<li>6502 Instruction Set<br />
<a href="https://www.masswerk.at/6502/6502_instruction_set.html">https://www.masswerk.at/6502/6502_instruction_set.html</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Single-board computer<br />
<a href="https://en.wikipedia.org/wiki/Single-board_computer">https://en.wikipedia.org/wiki/Single-board_computer</a>
</li>

<li>www.6502.org<br />
<a href="http://www.6502­.org/">http://www.6502­.org/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer &ndash; clock generator<br />
<a href="http://wilsonminesco.com/6502primer/ClkGen.html">http://wilsonminesco.com/6502primer/ClkGen.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://www.cpushack.com/CPU/cpu.html">http://www.cpushack.com/CPU/cpu.html</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Osmibitové mikroprocesory a mikrořadiče firmy Motorola (1)<br />
<a href="https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/">https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/</a>
</li>

<li>Mikrořadiče a jejich použití v jednoduchých mikropočítačích<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/">https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/</a>
</li>

<li>Mikrořadiče a jejich aplikace v jednoduchých mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/">https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Comparison of instruction set architectures<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures">https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</a>
</li>

<li>INES header format<br />
<a href="https://github.com/camsaul/nesasm/blob/master/ines_header_format.txt">https://github.com/camsaul/nesasm/blob/master/ines_header_format.txt</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

