<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vývoj her pro herní konzoli NES: atributy spritů, pokročilejší makra, zjištění velikosti generované ROM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vývoj her pro herní konzoli NES: atributy spritů, pokročilejší makra, zjištění velikosti generované ROM</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V sedmé části seriálu o vývoji her a multimediálních dem určených pro slavnou a v mnoha ohledech přelomovou osmibitovou herní konzoli Nintendo Entertainment System (NES) si podrobněji ukážeme práci s atributy spritů (barva, zrcadlení, ...), vytvoříme složitější makra a zjistíme, kolik bajtů ROM je obsazeno námi vytvořeným demem.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Barvy použité při zobrazení spritů</a></p>
<p><a href="#k02">2. Uložení indexu barvové palety v&nbsp;atributech spritů</a></p>
<p><a href="#k03">3. Realizace změny barvové palety spritů při stisku tlačítka A</a></p>
<p><a href="#k04">4. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k05">5. Zpomalení změny barvové palety spritů při stisku tlačítka</a></p>
<p><a href="#k06">6. Realizace jednoduchého čítače</a></p>
<p><a href="#k07">7. Úplný zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k08">8. Horizontální a vertikální zrcadlení spritů</a></p>
<p><a href="#k09">9. Makro pro inverzi vybraného bitu či bitů v&nbsp;paměťovém bloku</a></p>
<p><a href="#k10">10. Realizace zrcadlení spritů řízených hráčem</a></p>
<p><a href="#k11">11. Úplný zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k12">12. Celková velikost vygenerovaného strojového kódu</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Barvy použité při zobrazení spritů</h2>

<p>V&nbsp;první polovině dnešního článku si ukážeme, jakým způsobem je možné
modifikovat barvy spritů zobrazených na displeji řízeného osmibitovou herní
konzolí NES. Jedná se o relativně komplikovanou techniku, protože barvy všech
objektů ve scéně nejsou určeny přímo (například s&nbsp;využitím RGB), ale je
zde zvolen odlišný způsob &ndash; mapování barev s&nbsp;využitím barvové palety
(<i>color table</i>). Ovšem ve skutečnosti je situace ještě nepatrně
složitější, protože se nepracuje přímo s&nbsp;indexy do jedné barvové palety,
ale je prováděno dvojí mapování, což je sice z&nbsp;pohledu vývojáře složitější
řešení, ale počet operací s&nbsp;pamětí se poměrně radikálním způsobem snižuje,
stejně jako celkové nároky na kapacitu RAM i ROM (ROM je přitom instalována na
cartridgi, jejíž celková cena se nepřímo promítá do ceny každé hry).</p>

<p>Připomeňme si, že barvová paleta používaná v&nbsp;daném okamžiku je uložena
v&nbsp;operační paměti od adresy $3f00, tedy konkrétně na konci třetí stránky
paměti (každá stránka má 256 bajtů):</p>

<pre>
PALETTE = $3f00
</pre>

<p>Celková délka palety je rovna 32 bajtům, přičemž nejhrubší rozdělení je na
šestnáct barev pozadí (<i>background</i>) a šestnáct barev spritů:</p>

<pre>
<i>; samotná barvová paleta</i>
palette:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
</pre>

<p>Hodnoty zde uložené jsou indexy do této barvové škály:</p>

<img src="http://i.iinfo.cz/images/357/8417-1.png" width="256" height="76" alt="&#160;" />
<p><i>Obrázek 1: Barvová paleta používaná herní konzolí NES.</i></p>

<p>Ve skutečnosti je oněch 32 bajtů rozděleno nikoli do pouhých dvou oblastí,
ale do devíti bloků:</p>

<table>
<tr><th>Od</th><th>Do</th><th>Význam</th></tr>
<tr><td>0x3f00</td><td>(jediný bajt)</td><td>globální barva pozadí</td></tr>
<tr><td>0x3f01</td><td>0x3f03</td><td>paleta pozadí #0</td></tr>
<tr><td>0x3f05</td><td>0x3f07</td><td>paleta pozadí #1</td></tr>
<tr><td>0x3f09</td><td>0x3f0b</td><td>paleta pozadí #2</td></tr>
<tr><td>0x3f0d</td><td>0x3f0f</td><td>paleta pozadí #3</td></tr>
<tr><td>0x3f11</td><td>0x3f13</td><td>paleta spritů #0</td></tr>
<tr><td>0x3f15</td><td>0x3f17</td><td>paleta spritů #1</td></tr>
<tr><td>0x3f19</td><td>0x3f1b</td><td>paleta spritů #2</td></tr>
<tr><td>0x3f1d</td><td>0x3f1f</td><td>paleta spritů #3</td></tr>
</table>

<p>Zaměřme se nyní na barvy pixelů v&nbsp;zobrazených spritech. Skutečná barva
je vybrána z&nbsp;výše uvedené palety (32 kódů barev), ovšem index do této
palety se počítá složitějším způsobem. Konkrétní paleta #0 až #3 je uložena
v&nbsp;atributu spritu, konkrétně v&nbsp;dolních dvou bitech atributového bajtu
(viz další kapitolu) &ndash; to znamená, že můžeme barvovou paletu snadno
modifikovat zápisem jediného bajtu do RAM. A barva v&nbsp;rámci této palety je
získána ze dvou bitů bitmapy, která popisuje vlastní tvar spritu. Přitom platí,
že barva číslo 0 je průhledná, takže sprite v&nbsp;pixelech s&nbsp;touto barvou
není vykreslen a prosvítá zde buď jiný sprite nebo pozadí.</p>

<img src="https://i.iinfo.cz/images/653/nes-devel-3-a.png" class="image-576979" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" width="524" height="617" />
<p><i>Obrázek 2: V&nbsp;tomto editoru spritů je patrné, jak jsou bitmapy spritů
uloženy v&nbsp;ROM. Každý pixel může nabývat jedné ze čtyř barev (první barva
je přitom při zobrazení na displeji průhledná) a jedná se o nepravé barvy.
Konkrétní barva spritu je získána až výběrem určité palety čtyř barev
atributovým bajtem (resp.&nbsp;dvěma bity atributového bajtu).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Uložení indexu barvové palety v&nbsp;atributech spritů</h2>

<p>Ještě jednou se podívejme na to, jaké metainformace o spritech jsou uloženy
v&nbsp;operační paměti dostupné mikroprocesoru MOS 6502. Připomeňme si, že pro
uložení těchto informací máme rezervovanou celou druhou stránku operační
paměti, tj.&nbsp;paměťové buňky s&nbsp;adresami $0200 až $02ff. Celkem je možné
do těchto 256 bajtů uložit metainformace o 64 spritech, protože pro každý
sprite jsou vyhrazeny čtyři bajty. Nás nyní bude nejvíce zajímat třetí bajt
s&nbsp;atributy spritů. Prozatím zobrazujeme jen osm spritů, takže se celkově
bude jednat o 8&times;4=32 bajtů:</p>

<pre>
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, <strong>$00</strong>, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, <strong>$00</strong>, $10
    .byte $18, $02, <strong>$00</strong>, $08
    .byte $18, $03, <strong>$00</strong>, $10
    .byte $20, $04, <strong>$00</strong>, $08
    .byte $20, $05, <strong>$00</strong>, $10
    .byte $28, $06, <strong>$00</strong>, $08
    .byte $28, $07, <strong>$00</strong>, $10
</pre>

<p>Třetí bajt z&nbsp;celé čtyřbajtové struktury s&nbsp;metainformacemi o spritu
obsahuje jedno bitové pole a tři samostatné bity, které řídí způsob zobrazení
daného spritu (a to zcela nezávisle na ostatních spritech):</p>

<pre>
7 6 5 4 3 2 1 0
| | | | | | | |
| | | | | | +-+- Index barvové palety
| | | | | |   
| | | +-+-+----- Nepoužito
| | |         
| | +----------- Priorita (0: před pozadím; 1: za pozadím)
| |           
| +------------- Horizontální zrcadlení spritu
|             
+--------------- Vertikální zrcadlení spritu
</pre>

<p>Prozatím nás budou zajímat nejnižší dva bity, které určují index do barvové
palety &ndash; viz též <a href="#k01">úvodní kapitolu</a> s&nbsp;podrobnějšími
informacemi.</p>

*** image ***
<p><i>Obrázek 3: Sprity zobrazené s&nbsp;využitím první barvové palety.</i></p>

*** image ***
<p><i>Obrázek 4: Sprity zobrazené s&nbsp;využitím druhé barvové palety.</i></p>

*** image ***
<p><i>Obrázek 5: Sprity zobrazené s&nbsp;využitím třetí barvové palety.</i></p>

*** image ***
<p><i>Obrázek 6: Sprity zobrazené s&nbsp;využitím čtvrté barvové
palety.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Realizace změny barvové palety spritů při stisku tlačítka A</h2>

<p>V&nbsp;této kapitole si ukážeme, jakým způsobem lze realizovat změnu barvové
palety spritů zobrazených na obrazovce (konkrétně se jedná o osm spritů
tvořících figurku Maria), a to konkrétně (opakovaným) stiskem tlačítka A na
prvním herním ovladači.</p>

<p>Nejprve je nutné načíst stav všech osmi tlačítek do záchytného registru. To
je technika, s&nbsp;níž jsme se již seznámili <a
href="https://www.root.cz/clanky/vyvoj-her-pro-herni-konzoli-nes-cteni-ovladace-pohyb-spritu-a-rutina-vblank/#k04">minule</a>
a spočívá v&nbsp;poslání signálu <i>latch</i> (záchyt hodnot) do řídicího
registru $4016, jenž je v&nbsp;našich zdrojových kódech pojmenován
<strong>JOYPAD</strong>:</p>

<pre>
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
                           <i>; </i>
                           <i>; 1) A                      </i>
                           <i>; 2) B                      </i>
                           <i>; 3) Select                 </i>
                           <i>; 4) Start                  </i>
                           <i>; 5) Up                     </i>
                           <i>; 6) Down                   </i>
                           <i>; 7) Left                   </i>
                           <i>; 8) Right</i>
</pre>

<p>Po provedení této operace je nutné osmkrát přečíst obsah řídicího registru
<strong>JOYPAD1</strong> a získat tak postupně stav všech osmi tlačítek
ovladače. Nás dnes bude zajímat jen přečtení stavu tlačítka A. V&nbsp;případě,
že je toto tlačítko stlačeno, provede se kód zapsaný v&nbsp;makru
<strong>increment_block_mask</strong>:</p>

<pre>
&nbsp;
        ATTRS = $0202      <i>; adresa buňky paměti s atributy spritu</i>
&nbsp;
        read_button        <i>; stisk tlačítka A bude sloužit pro přepínání barvy spritů</i>
        beq button_a_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        <strong>increment_block_mask ATTRS, 8, 4, 3</strong>
&nbsp;
button_a_not_pressed:
        ...
        ...
        ...
</pre>

<p>Makro <strong>increment_block_mask</strong> zvýší obsah buněk ve vybraném
paměťovém bloku, přičemž se po zvýšení hodnoty dané paměťové buňky provede
maskování hodnoty bitovou maskou uloženou v&nbsp;parametru
<strong>mask</strong> (my použijeme hodnotu 3, což znamená, že se nastaví jen
dva nejnižší bity). Jak již dobře víme z&nbsp;minulého článku, nebudeme
pracovat s&nbsp;blokem paměťových buněk uložených ihned za sebou, ale naopak
s&nbsp;buňkami, mezi nimiž se nachází tři další bajty, které měnit nechceme.
Adresa další paměťové buňky je tedy zvyšována nikoli o jedničku, ale o hodnotu
specifikovanou v&nbsp;parametru <strong>gap</strong> (což je konkrétně hodnota
4):</p>

<pre>
<strong>.macro increment_block_mask address, count, gap, mask</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        lda address, x     <i>; maskování hodnoty</i>
        and #mask
        sta address, x
&nbsp;
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že se skutečně jedná o
makro a tudíž je nutné korektně pracovat se znakem #, který určuje konstanty.
Například <strong>adc #gap</strong> a <strong>adc gap</strong> jsou zcela
odlišné instrukce &ndash; první pracuje s&nbsp;konstantou, druhá s&nbsp;obsahem
adresy <strong>gap</strong>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu (v&nbsp;pořadí
již dvacátého druhého příkladu pro NES) je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example22.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example22.asm</a>.
Pro překlad a slinkování tohoto příkladu je zapotřebí i <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">Makefile</a>
a příkaz <strong>make example21.nes</strong>:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Nastavení barvové palety, zvýšení intenzity barvy</i>
<i>; Setup PPU přes makro</i>
<i>; Definice spritu a zobrazení spritů s rozloženým Mariem.</i>
<i>; Pohyb celého Maria.</i>
<i>; Využití symbolických jmen adres.</i>
<i>; Pomocná makra pro pohyb spritu.</i>
<i>; Změna dalších vlastností spritů s využitím tlačítek A a B</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Taktéž založeno na https://nerdy-nights.nes.science/#main_tutorial-3</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
PPUADDR         = $2006
PPUDATA         = $2007
DMC_FREQ        = $4010
OAM_DMA         = $4014
&nbsp;
<i>; Další důležité adresy</i>
PALETTE         = $3f00
&nbsp;
<i>; Ovladače</i>
JOYPAD1         = $4016
JOYPAD2         = $4017
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro ppu_data_palette_address</strong>
        lda PPUSTATUS   <i>; reset záchytného registru</i>
        lda #&gt;PALETTE   <i>; nastavení adresy pro barvovou paletu $3f00</i>
        sta PPUADDR
        lda #&lt;PALETTE   <i>; nižší bajt adresy</i>
        sta PPUADDR
<strong>.endmacro</strong>
&nbsp;
<strong>.macro increment_block address, count, gap</strong>
        ldx #0             <i>; inicializace okonkrétní ffsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro decrement_block address, count, gap</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        dec address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro increment_block_mask address, count, gap, mask</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        lda address, x     <i>; maskování hodnoty</i>
        and #mask
        sta address, x
&nbsp;
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro read_button</strong>
        lda JOYPAD1        <i>; stav tlačítka</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
<strong>.endmacro</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 2
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp;
.segment "ZEROPAGE"
.segment "STARTUP"
.segment "CODE"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
.code
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
;
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
<strong>.proc nmi</strong>
        lda #$02           <i>; horní bajt adresy pro přenos + zahájení přenosu</i>
        sta OAM_DMA
&nbsp;
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
                           <i>; </i>
                           <i>; 1) A                      </i>
                           <i>; 2) B                      </i>
                           <i>; 3) Select                 </i>
                           <i>; 4) Start                  </i>
                           <i>; 5) Up                     </i>
                           <i>; 6) Down                   </i>
                           <i>; 7) Left                   </i>
                           <i>; 8) Right</i>
&nbsp;
        XPOS = $0203       <i>; adresa buňky paměti s x-ovou souřadnicí spritu</i>
        YPOS = $0200       <i>; adresa buňky paměti y x-ovou souřadnicí spritu</i>
        ATTRS = $0202      <i>; adresa buňky paměti s atributy spritu</i>
&nbsp;
        read_button        <i>; stisk tlačítka A bude sloužit pro přepínání barvy spritů</i>
        beq button_a_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        increment_block_mask ATTRS, 8, 4, 3
&nbsp;
button_a_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka B jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Select jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
&nbsp;
        read_button        <i>; stav tlačítka Up</i>
        beq up_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        decrement_block YPOS, 8, 4
&nbsp;
up_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Down</i>
        beq down_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        increment_block YPOS, 8, 4
&nbsp;
down_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Left</i>
        beq left_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        decrement_block XPOS, 8, 4
&nbsp;
left_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Right</i>
        beq right_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        increment_block XPOS, 8, 4
&nbsp;
right_not_pressed:
&nbsp;
        rti                <i>; návrat z přerušení</i>
&nbsp;
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
<strong>.proc irq</strong>
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ            <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017               <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        <i>; nastavení barvové palety</i>
        jsr load_palette  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; nastavení spritů</i>
        jsr load_sprites  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; vynulování barvové palety</i>
<strong>.proc clear_palette</strong>
        ppu_data_palette_address
&nbsp;
        ldx #$20        <i>; počitadlo barev v paletě: 16+16</i>
        lda #$00        <i>; vynulování každé barvy</i>
&nbsp;
:
        sta PPUDATA     <i>; zápis barvy</i>
        dex             <i>; snížení hodnoty počitadla</i>
        bne :-
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; nastavení barvové palety</i>
<strong>.proc load_palette</strong>
        ppu_data_palette_address
&nbsp;
        <i>; $3f00-$3f0f - paleta pozadí</i>
        <i>; $3f10-$3f1f - paleta spritů</i>
&nbsp;
        ldx #$00        <i>; vynulovat počitadlo a offset</i>
&nbsp;
:
        lda palette, x  <i>; načíst bajt s offsetem</i>
        sta PPUDATA     <i>; zápis barvy do PPU</i>
        inx             <i>; zvýšit počitadlo/offset</i>
        cpx #32         <i>; limit počtu barev</i>
        bne :-          <i>; opakovat smyčku 32x</i>
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; načtení spritů</i>
<strong>.proc load_sprites</strong>
        ldx #0
:
        lda spritedata,X  <i>; budeme přesouvat data z této oblasti</i>
        sta $0200,X       <i>; uložení do paměti spritů</i>
        inx               <i>; zvýšení hodnoty počitadla</i>
        cpx #32           <i>; každý sprite má 4 bajty: y-coord, tile, attributy, y-coord * 8 spritů = 32</i>
        bne :-
&nbsp;
        cli               <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10000000      
        sta PPUCTRL       <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
&nbsp;
        lda #%00010000    <i>; povolení zobrazení spritů</i>
        sta PPUMASK
&nbsp;
        rts               <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; samotná barvová paleta</i>
palette:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
&nbsp;
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
.segment "CHARS"
    .incbin "mario.chr"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zpomalení změny barvové palety spritů při stisku tlačítka</h2>

<p>Pokud jste si předchozí demonstrační příklad přeložili a spustili,
pravděpodobně jste již přišli na jednu jeho nepříjemnou vlastnost &ndash; změna
barvové palety spritů totiž probíhá (pokud je pochopitelně tlačítko A
stisknuto) velmi rychle. Je tomu tak z&nbsp;toho jednoduchého důvodu, že se
test stisku tlačítka a případná změna palety provádí v&nbsp;subrutině VBLANK
volané automaticky 50&times; až 60&times; za sekundu. To znamená, že i změna
vybrané barvové palety probíhá s&nbsp;touto relativně vysokou frekvencí. Toto
chování nijak nevadilo ve chvíli, kdy jsme zajišťovali pohyb spritu, protože
změna pozice spritu 50&times;/60&times; za sekundu znamená, že sprite přejede
přes celou obrazovku za přibližně pět sekundu (256/50 resp.&nbsp;256/60 &ndash;
lze si snadno a dokonce i relativně přesně ověřit stopkami). Nicméně se vraťme
k&nbsp;problematice změny barvové palety. Bylo by ideální, kdyby tato změna
probíhala s&nbsp;menší frekvencí, řekněme jen několikrát za sekundu. Toho lze
relativně snadno dosáhnout s&nbsp;využitím čítače, který je postupně
(s&nbsp;frekvencí 50 resp.&nbsp;60 Hz) snižován na nulu a teprve při dosažení
nuly se provede příslušná změna atributu spritů (a hodnota čítače je obnovena
na původní hodnotu).</p>

<p>To znamená, že frekvence změny barvové palety bude přibližně rovna:</p>

<pre>
50/počáteční_hodnota_čítače
</pre>

<p>nebo:</p>

<pre>
60/počáteční_hodnota_čítače
</pre>

<p><div class="rs-tip-major">Poznámka: mimochodem &ndash; ve hrách,
v&nbsp;nichž se sprity pohybují rychleji, tj.&nbsp;přejedou přes celou
obrazovku za méně než přibližně pět sekund, je změna pozice spritu prováděna o
více než 1 pixel v&nbsp;každém směru (to se týká střel atd.). I přesto
v&nbsp;naprosté většině případů není toto &bdquo;poskakování&ldquo;
patrné.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Realizace jednoduchého čítače</h2>

<p>Nyní se podívejme na způsob realizace čítače zmíněného <a
href="#k05">v&nbsp;předchozí kapitole</a>. Hodnota čítače bude maximálně
osmibitová a čítač uložíme do nulté stránky paměti, z&nbsp;níž je možné data
číst či zapisovat efektivněji &ndash; všechny instrukce pracující s&nbsp;nultou
stránkou paměti jsou totiž kratší o jeden bajt a taktéž rychlejší (typicky o
jeden strojový cyklus &ndash; viz například <a
href="https://www.masswerk.at/6502/6502_instruction_set.html#LDA">https://www.masswerk.at/6502/6502_instruction_set.html#LDA</a>):</p>

<pre>
addressing      assembler       opc     bytes   cycles
<strong>immediate       LDA #oper       A9      2       2</strong>
zeropage        LDA oper        A5      2       3
zeropage,X      LDA oper,X      B5      2       4
<strong>absolute        LDA oper        AD      3       4</strong>
absolute,X      LDA oper,X      BD      3       4*
absolute,Y      LDA oper,Y      B9      3       4*
(indirect,X)    LDA (oper,X)    A1      2       6
(indirect),Y    LDA (oper),Y    B1      2       5*
</pre>

<p>Definujme tedy adresu, na níž je čítač uložen (poslední bajt nulté
stránky):</p>

<pre>
<i>; Čítač</i>
COUNTER         = $00ff 
</pre>

<p>Čítač nastavíme na výchozí hodnotu v&nbsp;rutině RESET, která je zavolána
automaticky při inicializaci herní konzole:</p>

<pre>
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        ...
        ...
        ...
        lda #10           <i>; inicializace čítače</i>
        sta COUNTER
        ...
        ...
        ...
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
</pre>

<p>A v&nbsp;obslužné rutině VBLANK provedeme tento pseudokód:</p>

<pre>
if stisknuto(tlačítko_a) {
    čítač -= 1
    if čítač == 0 {
        čítač = výchozí_hodnota
        změn_atributy(sprite0..7)
    }
}
</pre>

<p>Výše uvedených sedm řádků pseudokódu lze zapsat do pouhých osmi řádků
v&nbsp;assembleru:</p>

<pre>
        read_button              <i>; stisk tlačítka A bude sloužit pro přepínání barvy spritů</i>
        beq button_a_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        dec COUNTER              <i>; snížení hodnoty čítače a test na nulu</i>
        bne button_a_not_pressed <i>; čítač != 0? =&gt; skok</i>
&nbsp;
        lda #10                  <i>; nastavení výchozí hodnoty čítače</i>
        sta COUNTER
&nbsp;
        increment_block_mask ATTRS, 8, 4, 3
&nbsp;
button_a_not_pressed:
</pre>

<p><div class="rs-tip-major">Poznámka: je to zajímavé (a možná i neintuitivní),
ale podobné jednoduché rozhodovací a konstrukce bývají v&nbsp;assembleru stejně
složité (či naopak jednoduché), jako například v&nbsp;céčku. Situace se ovšem
radikálně změní ve chvíli, kdy se volají funkce (s&nbsp;předáním parametrů),
nebo se pracuje s&nbsp;poli či záznamy.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód druhého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu (v&nbsp;pořadí
již dvacátého třetího příkladu pro NES) je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example23.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example23.asm</a>.
Pro překlad a slinkování tohoto příkladu je zapotřebí i <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">Makefile</a>
a příkaz <strong>make example23.nes</strong>:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Nastavení barvové palety, zvýšení intenzity barvy</i>
<i>; Setup PPU přes makro</i>
<i>; Definice spritu a zobrazení spritů s rozloženým Mariem.</i>
<i>; Pohyb celého Maria.</i>
<i>; Využití symbolických jmen adres.</i>
<i>; Pomocná makra pro pohyb spritu.</i>
<i>; Změna dalších vlastností spritů s využitím tlačítek A a B</i>
;
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Taktéž založeno na https://nerdy-nights.nes.science/#main_tutorial-3</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
PPUADDR         = $2006
PPUDATA         = $2007
DMC_FREQ        = $4010
OAM_DMA         = $4014
&nbsp;
<i>; Další důležité adresy</i>
PALETTE         = $3f00
&nbsp;
<i>; Ovladače</i>
JOYPAD1         = $4016
JOYPAD2         = $4017
&nbsp;
<i>; Čítač</i>
COUNTER         = $00ff 
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro ppu_data_palette_address</strong>
        lda PPUSTATUS   <i>; reset záchytného registru</i>
        lda #&gt;PALETTE   <i>; nastavení adresy pro barvovou paletu $3f00</i>
        sta PPUADDR
        lda #&lt;PALETTE   <i>; nižší bajt adresy</i>
        sta PPUADDR
<strong>.endmacro</strong>
&nbsp;
<strong>.macro increment_block address, count, gap</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro decrement_block address, count, gap</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        dec address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro increment_block_mask address, count, gap, mask</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        lda address, x     <i>; maskování hodnoty</i>
        and #mask
        sta address, x
&nbsp;
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro read_button</strong>
        lda JOYPAD1        <i>; stav tlačítka</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
<strong>.endmacro</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 2
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp;
.segment "ZEROPAGE"
.segment "STARTUP"
.segment "CODE"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
.code
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
;
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
<strong>.proc nmi</strong>
        lda #$02           <i>; horní bajt adresy pro přenos + zahájení přenosu</i>
        sta OAM_DMA
&nbsp;
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
                           <i>; </i>
                           <i>; 1) A                      </i>
                           <i>; 2) B                      </i>
                           <i>; 3) Select                 </i>
                           <i>; 4) Start                  </i>
                           <i>; 5) Up                     </i>
                           <i>; 6) Down                   </i>
                           <i>; 7) Left                   </i>
                           <i>; 8) Right</i>
&nbsp;
        XPOS = $0203       <i>; adresa buňky paměti s x-ovou souřadnicí spritu</i>
        YPOS = $0200       <i>; adresa buňky paměti y x-ovou souřadnicí spritu</i>
        ATTRS = $0202      <i>; adresa buňky paměti s atributy spritu</i>
&nbsp;
        read_button        <i>; stisk tlačítka A bude sloužit pro přepínání barvy spritů</i>
        beq button_a_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        dec COUNTER
        bne button_a_not_pressed
&nbsp;
        lda #10
        sta COUNTER
&nbsp;
        increment_block_mask ATTRS, 8, 4, 3
&nbsp;
button_a_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka B jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Select jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
&nbsp;
        read_button        <i>; stav tlačítka Up</i>
        beq up_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        decrement_block YPOS, 8, 4
&nbsp;
up_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Down</i>
        beq down_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        increment_block YPOS, 8, 4
&nbsp;
down_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Left</i>
        beq left_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        decrement_block XPOS, 8, 4
&nbsp;
left_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Right</i>
        beq right_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        increment_block XPOS, 8, 4
&nbsp;
right_not_pressed:
&nbsp;
        rti                <i>; návrat z přerušení</i>
&nbsp;
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
<strong>.proc irq</strong>
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ            <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017               <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        <i>; nastavení barvové palety</i>
        jsr load_palette  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; nastavení spritů</i>
        jsr load_sprites  <i>; zavolání subrutiny</i>
&nbsp;
        lda #10           <i>; inicializace čítače</i>
        sta COUNTER
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; vynulování barvové palety</i>
<strong>.proc clear_palette</strong>
        ppu_data_palette_address
&nbsp;
        ldx #$20        <i>; počitadlo barev v paletě: 16+16</i>
        lda #$00        <i>; vynulování každé barvy</i>
&nbsp;
:
        sta PPUDATA     <i>; zápis barvy</i>
        dex             <i>; snížení hodnoty počitadla</i>
        bne :-
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; nastavení barvové palety</i>
<strong>.proc load_palette</strong>
        ppu_data_palette_address
&nbsp;
        <i>; $3f00-$3f0f - paleta pozadí</i>
        <i>; $3f10-$3f1f - paleta spritů</i>
&nbsp;
        ldx #$00        <i>; vynulovat počitadlo a offset</i>
&nbsp;
:
        lda palette, x  <i>; načíst bajt s offsetem</i>
        sta PPUDATA     <i>; zápis barvy do PPU</i>
        inx             <i>; zvýšit počitadlo/offset</i>
        cpx #32         <i>; limit počtu barev</i>
        bne :-          <i>; opakovat smyčku 32x</i>
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; načtení spritů</i>
<strong>.proc load_sprites</strong>
        ldx #0
:
        lda spritedata,X  <i>; budeme přesouvat data z této oblasti</i>
        sta $0200,X       <i>; uložení do paměti spritů</i>
        inx               <i>; zvýšení hodnoty počitadla</i>
        cpx #32           <i>; každý sprite má 4 bajty: y-coord, tile, attributy, y-coord * 8 spritů = 32</i>
        bne :-
&nbsp;
        cli               <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10000000      
        sta PPUCTRL       <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
&nbsp;
        lda #%00010000    <i>; povolení zobrazení spritů</i>
        sta PPUMASK
&nbsp;
        rts               <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; samotná barvová paleta</i>
palette:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
&nbsp;
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
.segment "CHARS"
    .incbin "mario.chr"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Horizontální a vertikální zrcadlení spritů</h2>

<p>Vraťme se nyní k&nbsp;obsahu bajtu, který pro každý sprite zvlášť určuje,
jakým způsobem se má sprite zobrazit. Již víme, jakou roli hrají dva nejnižší
bity &ndash; určují index barvové palety. Další tři bity jsou nevyužity a
nejvyšší tři bity určují prioritu (ukážeme si příště), horizontální zrcadlení
spritu a vertikální zrcadlení spritu:</p>

<pre>
7 6 5 4 3 2 1 0
| | | | | | | |
| | | | | | +-+- Index barvové palety
| | | | | |   
| | | +-+-+----- Nepoužito
| | |         
| | +----------- Priorita (0: před pozadím; 1: za pozadím)
| |           
| +------------- Horizontální zrcadlení spritu
|             
+--------------- Vertikální zrcadlení spritu
</pre>

<p>Díky možnosti individuálního zrcadlení spritů je možné, aby se Mario (či
další postavy ve hrách) pohybovaly doprava i doleva, a to bez nutnosti mít pro
každý směr rezervovány další sprity (tedy &bdquo;obličej doprava&ldquo; i
&bdquo;obličej doleva&ldquo;). Zrcadlení je možné využít i k&nbsp;dalším
trikům, k&nbsp;nimž se vrátíme později. V&nbsp;každém případě se jedná o
nenápadnou, ale o to důležitější součást grafického subsystému NESu.</p>

*** image ***
<p><i>Obrázek 7: Nezrcadlené sprity.</i></p>

*** image ***
<p><i>Obrázek 8: Vertikální zrcadlení.</i></p>

*** image ***
<p><i>Obrázek 9: Horizontální zrcadlení.</i></p>

*** image ***
<p><i>Obrázek 10: Horizontální i vertikální zrcadlení.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Makro pro inverzi vybraného bitu či bitů v&nbsp;paměťovém bloku</h2>

<p>Pokud budeme chtít zrcadlit (ať již vertikálně či horizontálně) všech osm
spritů tvořících postavičku Maria, bude nutné projít všemi osmi atributovými
bajty a nastavit nebo invertovat buď sedmý bit nebo bit šestý. K&nbsp;tomuto
účelu lze použít instrukci nazvanou <strong>EOR</strong> neboli <i>exclusive
or</i> (známá na jiných platformách jako <i>XOR</i>). Inverzi sedmého
(nejvyššího) bitu tak můžeme provést takto:</p>

<pre>
	lda address, x     <i>; maskování hodnoty</i>
	eor #%10000000
	sta address, x
</pre>

<p>podobně inverze šestého bitu se provede následovně:</p>

<pre>
	lda address, x     <i>; maskování hodnoty</i>
	eor #%01000000
	sta address, x
</pre>

<p>přičemž v&nbsp;<strong>address</strong> je uložena počáteční adresa
metainformací o spritech (tedy konkrétně hodnota $0200) a v&nbsp;registru
<strong>x</strong> offset atributového bajtu.</p>

<p>Můžeme tedy velmi snadno upravit již existující makro
<strong>increment_block_mask</strong> tak, aby se namísto pouhého zvýšení
obsahu atributového bajtu (s&nbsp;následným maskováním) jen invertoval jediný
bit tohoto atributu. Maska pro inverzi je předána v&nbsp;parametru
<strong>mask</strong>:</p>

<pre>
<strong>.macro flip_bit_block address, count, gap, mask</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
	lda address, x     <i>; maskování hodnoty</i>
	eor #mask
	sta address, x
&nbsp;
	txa                <i>; přesun offsetu do akumulátoru</i>
	clc
	adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
	tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
	cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
</pre>

<p>Příklad aplikace tohoto makra pro inverzi šestého bitu:</p>

<pre>
        flip_bit_block ATTRS, 8, 4, %01000000
</pre>

<p>Pro úplnost dodejme seznam parametrů makra:</p>

<table>
<tr><th>Parametr</th><th>Význam</th></tr>
<tr><td>ATTRS</td><td>adresa buňky paměti s atributy prvního spritu ($0202)</td></tr>
<tr><td>8</td><td>celkový počet spritů, jejichž atributy se mají měnit</td></tr>
<tr><td>4</td><td>offset mezi dvěma sousedními atributovými bajty</td></tr>
<tr><td>%01000000</td><td>vlastní bitová maska (zapsána binárně)</td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Realizace zrcadlení spritů řízených hráčem</h2>

<p>Vlastní realizace zrcadlení spritů bude jednoduchá. Zrcadlení jsou
realizována stiskem tlačítek B a Select. Stisk každého z&nbsp;těchto tlačítek
vede k&nbsp;zahájení odpočítávání čítače a při dosažení nuly se neguje nejvyšší
bit nebo šestý bit atributového bajtu všech prvních osmi spritů:</p>

<pre>
        read_button        <i>; stisk tlačítka B bude sloužit pro přepínání atributů spritů</i>
        beq button_b_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
	dec COUNTER2
	bne button_b_not_pressed
&nbsp;
	lda #10
	sta COUNTER2
&nbsp;
        <strong>flip_bit_block ATTRS, 8, 4, %01000000</strong>
&nbsp;
button_b_not_pressed:
&nbsp;
        read_button        <i>; stisk tlačítka Select bude sloužit pro přepínání atributů spritů</i>
        beq button_select_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
	dec COUNTER2
	bne button_select_not_pressed
&nbsp;
	lda #10
	sta COUNTER2
&nbsp;
        <strong>flip_bit_block ATTRS, 8, 4, %10000000</strong>
&nbsp;
button_select_not_pressed:
</pre>

<p><div class="rs-tip-major">Poznámka: stále tedy používáme stejných triků i
stejné množiny instrukcí.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Úplný zdrojový kód třetího demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního třetího demonstračního příkladu (v&nbsp;pořadí
již dvacátého čtvrtého příkladu pro NES) je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example24.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example24.asm</a>.
Pro překlad a slinkování tohoto příkladu je zapotřebí i <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">Makefile</a>
a příkaz <strong>make example24.nes</strong>:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Nastavení barvové palety, zvýšení intenzity barvy</i>
<i>; Setup PPU přes makro</i>
<i>; Definice spritu a zobrazení spritů s rozloženým Mariem.</i>
<i>; Pohyb celého Maria.</i>
<i>; Využití symbolických jmen adres.</i>
<i>; Pomocná makra pro pohyb spritu.</i>
<i>; Změna dalších vlastností spritů s využitím tlačítek A a B</i>
;
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Taktéž založeno na https://nerdy-nights.nes.science/#main_tutorial-3</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
PPUADDR         = $2006
PPUDATA         = $2007
DMC_FREQ        = $4010
OAM_DMA         = $4014
&nbsp;
<i>; Další důležité adresy</i>
PALETTE         = $3f00
&nbsp;
<i>; Ovladače</i>
JOYPAD1         = $4016
JOYPAD2         = $4017
&nbsp;
<i>; Čítače</i>
COUNTER1        = $00fe 
COUNTER2        = $00ff 
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro ppu_data_palette_address</strong>
        lda PPUSTATUS   <i>; reset záchytného registru</i>
        lda #&gt;PALETTE   <i>; nastavení adresy pro barvovou paletu $3f00</i>
        sta PPUADDR
        lda #&lt;PALETTE   <i>; nižší bajt adresy</i>
        sta PPUADDR
<strong>.endmacro</strong>
&nbsp;
<strong>.macro increment_block address, count, gap</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
	txa                <i>; přesun offsetu do akumulátoru</i>
	clc
	adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
	tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
	cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro decrement_block address, count, gap</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        dec address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
	txa                <i>; přesun offsetu do akumulátoru</i>
	clc
	adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
	tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
	cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro increment_block_mask address, count, gap, mask</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
	lda address, x     <i>; maskování hodnoty</i>
	and #mask
	sta address, x
&nbsp;
	txa                <i>; přesun offsetu do akumulátoru</i>
	clc
	adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
	tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
	cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro flip_bit_block address, count, gap, mask</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
	lda address, x     <i>; maskování hodnoty</i>
	eor #mask
	sta address, x
&nbsp;
	txa                <i>; přesun offsetu do akumulátoru</i>
	clc
	adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
	tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
	cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro read_button</strong>
        lda JOYPAD1        <i>; stav tlačítka</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
<strong>.endmacro</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 2
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp;
.segment "ZEROPAGE"
.segment "STARTUP"
.segment "CODE"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
.code
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
;
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
<strong>.proc nmi</strong>
        lda #$02           <i>; horní bajt adresy pro přenos + zahájení přenosu</i>
        sta OAM_DMA
&nbsp;
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
                           <i>; </i>
                           <i>; 1) A                      </i>
                           <i>; 2) B                      </i>
                           <i>; 3) Select                 </i>
                           <i>; 4) Start                  </i>
                           <i>; 5) Up                     </i>
                           <i>; 6) Down                   </i>
                           <i>; 7) Left                   </i>
                           <i>; 8) Right</i>
&nbsp;
        XPOS = $0203       <i>; adresa buňky paměti s x-ovou souřadnicí spritu</i>
        YPOS = $0200       <i>; adresa buňky paměti y x-ovou souřadnicí spritu</i>
	ATTRS = $0202      <i>; adresa buňky paměti s atributy spritu</i>
&nbsp;
        read_button        <i>; stisk tlačítka A bude sloužit pro přepínání barvy spritů</i>
        beq button_a_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
	dec COUNTER1
	bne button_a_not_pressed
&nbsp;
	lda #10
	sta COUNTER1
&nbsp;
        increment_block_mask ATTRS, 8, 4, 3
&nbsp;
button_a_not_pressed:
&nbsp;
        read_button        <i>; stisk tlačítka B bude sloužit pro přepínání atributů spritů</i>
        beq button_b_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
	dec COUNTER2
	bne button_b_not_pressed
&nbsp;
	lda #10
	sta COUNTER2
&nbsp;
        flip_bit_block ATTRS, 8, 4, %01000000
&nbsp;
button_b_not_pressed:
&nbsp;
        read_button        <i>; stisk tlačítka Select bude sloužit pro přepínání atributů spritů</i>
        beq button_select_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
	dec COUNTER2
	bne button_select_not_pressed
&nbsp;
	lda #10
	sta COUNTER2
&nbsp;
        flip_bit_block ATTRS, 8, 4, %10000000
&nbsp;
button_select_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
&nbsp;
        read_button        <i>; stav tlačítka Up</i>
        beq up_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        decrement_block YPOS, 8, 4
&nbsp;
up_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Down</i>
        beq down_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        increment_block YPOS, 8, 4
&nbsp;
down_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Left</i>
        beq left_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        decrement_block XPOS, 8, 4
&nbsp;
left_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Right</i>
        beq right_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        increment_block XPOS, 8, 4
&nbsp;
right_not_pressed:
&nbsp;
        rti                <i>; návrat z přerušení</i>
&nbsp;
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
<strong>.proc irq</strong>
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ            <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017               <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        <i>; nastavení barvové palety</i>
        jsr load_palette  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; nastavení spritů</i>
        jsr load_sprites  <i>; zavolání subrutiny</i>
&nbsp;
	lda #10           <i>; inicializace čítačů</i>
	sta COUNTER1
	sta COUNTER2
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; vynulování barvové palety</i>
<strong>.proc clear_palette</strong>
        ppu_data_palette_address
&nbsp;
        ldx #$20        <i>; počitadlo barev v paletě: 16+16</i>
        lda #$00        <i>; vynulování každé barvy</i>
&nbsp;
:
        sta PPUDATA     <i>; zápis barvy</i>
        dex             <i>; snížení hodnoty počitadla</i>
        bne :-
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; nastavení barvové palety</i>
<strong>.proc load_palette</strong>
        ppu_data_palette_address
&nbsp;
        <i>; $3f00-$3f0f - paleta pozadí</i>
        <i>; $3f10-$3f1f - paleta spritů</i>
&nbsp;
        ldx #$00        <i>; vynulovat počitadlo a offset</i>
&nbsp;
:
        lda palette, x  <i>; načíst bajt s offsetem</i>
        sta PPUDATA     <i>; zápis barvy do PPU</i>
        inx             <i>; zvýšit počitadlo/offset</i>
        cpx #32         <i>; limit počtu barev</i>
        bne :-          <i>; opakovat smyčku 32x</i>
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; načtení spritů</i>
<strong>.proc load_sprites</strong>
        ldx #0
:
        lda spritedata,X  <i>; budeme přesouvat data z této oblasti</i>
        sta $0200,X       <i>; uložení do paměti spritů</i>
        inx               <i>; zvýšení hodnoty počitadla</i>
        cpx #32           <i>; každý sprite má 4 bajty: y-coord, tile, attributy, y-coord * 8 spritů = 32</i>
        bne :-
&nbsp;
        cli               <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10000000      
        sta PPUCTRL       <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
&nbsp;
        lda #%00010000    <i>; povolení zobrazení spritů</i>
        sta PPUMASK
&nbsp;
        rts               <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; samotná barvová paleta</i>
palette:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
&nbsp;
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
.segment "CHARS"
    .incbin "mario.chr"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Celková velikost vygenerovaného strojového kódu</h2>

<p>Zdrojový kód demonstračních příkladů již překročil 400 řádků, takže (pokud
by se jednalo o vyšší programovací jazyk) by bylo vhodné zjistit, kolik ROM
jsme vlastně prozatím obsadili (v&nbsp;případě RAM to víme &ndash; čtyři
paměťové stránky, takže 1kB, z&nbsp;toho naprostá většina místa je prozatím
nevyužita). ROM je rozdělena do jednotlivých segmentů, přičemž velikosti
segmentů je možné v&nbsp;případě assembleru <strong>ca65</strong> zjistit tak,
že se při překladu dvakrát použije přepínač <strong>-v -v</strong> (druhou
možností je vyčtení stejných údajů z&nbsp;listingu):</p>

<pre>
$ <strong>ca65 example24.asm -o example24.o -v -v</strong>
</pre>

<p>Assembler v&nbsp;tomto případě vypíše obsah jednotlivých buněk ROM, což nás
ovšem nyní nezajímá. Důležitější jsou pro nás informace na řádcích <strong>End
PC</strong>, které udávají adresu poslední zapisované buňky a tedy i velikost
segmentu:</p>

<pre>
New segment: CODE
  Literal: A9 02 8D 14 40 A9 01 8D 16 40 A9 00 8D 16 40 AD 16 40
  Literal: 29 01 F0 1E C6 FE D0 1A A9 0A 85 FE A2 00 FE 02 02
  ...
  ...
  ...
  Literal: FB A9 00 95 00 9D 00 01 9D 00 02 9D 00 03 9D 00 04
  Literal: 9D 00 05 9D 00 06 9D 00 07 E8 D0 E6 2C 02 20 10 FB
  Literal: 20
  Expression (2):  SYM( SEC $013A +) 
  ...
  ...
  ...
  Literal: 17 0F 22 16 27 18 22 1A 30 27 22 16 30 27 22 0F 36
  Literal: 17 10 00 00 08 10 01 00 10 18 02 00 08 18 03 00 10
  Literal: 20 04 00 08 20 05 00 10 28 06 00 08 28 07 00 10
  End PC = $01AE
&nbsp;
New segment: HEADER
  Literal: 4E 45 53 1A 02 01 01 00
  End PC = $0008
&nbsp;
New segment: VECTORS
  Expression (2):  SYM( SEC) 
&nbsp;
  Expression (2):  SYM( SEC $00D3 +) 
&nbsp;
  Expression (2):  SYM( SEC $00D2 +) 
&nbsp;
  End PC = $0006
&nbsp;
New segment: CHARS
  Literal: 03 0F 1F 1F 1C 24 26 66 00 00 00 00 1F 3F 3F 7F E0 C0 80 FC 80 C0 00 20
  Literal: 00 20 60 00 F0 FC FE FE 60 70 18 07 0F 1F 3F 7F 7F 7F 1F 07 00 1E 3F 7F
  Literal: FC 7C 00 00 E0 F0 F8 F8 FC FC F8 C0 C2 67 2F 37 7F 7F FF FF 07 07 0F 0F
  ...
  ...
  ...
  Literal: 00 58 52 46 58 52 C6 9C F7 FF C6 F6 FE C6 F6 7A 00 7B 42 02 7A 42 02 7A
  Literal: 38 BC F6 F6 F6 F6 FE 5C 00 18 52 52 52 52 46 5C 00 FF FF FF FF FF FF FF
  Literal: FF FF FF FF FF FF FF FF
  End PC = $2000
</pre>

<p>Shrňme si tedy zjištěné informace do tabulky:</p>

<table>
<tr><th>Segment</th><th>Velikost (hex)</th><th>Velikost (dec)</th><th>Poznámka</th></tr>
<tr><th>CODE</th><th>$01AE</th><th>430</th><th>veškerý náš programový kód po překladu</th></tr>
<tr><th>HEADER</th><th>$0008</th><th>8</th><th>hlavička ROM má pevně zadanou strukturu i délku 8 bajtů</th></tr>
<tr><th>VECTORS</th><th>$0006</th><th>6</th><th>tři vektory pro RESET, IRQ a NMI: 3&times;2=6 bajtů</th></tr>
<tr><td>CHARS</td><td>$2000</td><td>8192</td><td>dlaždice 8&times;8 pixelů s 2bpp (16 bajtů). 256 dlaždic pozadí + 256 dlaždic spritů</td></tr>
</table>

<p>Strojový kód nám tedy poněkud narostl, a to mj.&nbsp;i kvůli barvové paletě
(32 bajtů+obslužná rutina), datům spritů (32 bajtů) a expanzi maker. Nicméně
s&nbsp;dalším rozšiřováním <i>programové logiky</i> bude velikost kódu narůstat
velmi pomalu &ndash; a necelých 0,5kB je stále dobrá hodnota. V&nbsp;případě
potřeby často volaná makra předěláme na běžné podprogramy (subrutiny).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad pomocí assembleru <strong>ca65</strong> (jenž je součástí
<strong>cc65</strong>), byly uložen do Git repositáře, který je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>example01.asm</td><td>zdrojový kód příkladu tvořeného kostrou aplikace pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm</a></td></tr>
<tr><td> 2</td><td>example02.asm</td><td>použití standardní konfigurace linkeru pro konzoli NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm</a></td></tr>
<tr><td> 3</td><td>example03.asm</td><td>symbolická jména řídicích registrů PPU</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm</a></td></tr>
<tr><td> 4</td><td>example04.asm</td><td>zjednodušený zápis lokálních smyček v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm</a></td></tr>
<tr><td> 5</td><td>example05.asm</td><td>zvukový výstup s&nbsp;využitím prvního &bdquo;square&ldquo; kanálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm</a></td></tr>
<tr><td> 6</td><td>example06.asm</td><td>použití maker bez parametrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>example07.asm</td><td>nastavení barvové palety, zvýšení intenzity zvolené barvové složky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example07.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example07.asm</a></td></tr>
<tr><td> 8</td><td>example08.asm</td><td>využití operátorů &lt; a &gt;</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example08.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example08.asm</a></td></tr>
<tr><td> 9</td><td>example09.asm</td><td>vymazání barvové palety realizované makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example09.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example09.asm</a></td></tr>
<tr><td>10</td><td>example10.asm</td><td>vymazání barvové palety realizované podprogramem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example10.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example10.asm</a></td></tr>
<tr><td>11</td><td>example11.asm</td><td>nastavení barvové palety pozadí i spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example11.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example11.asm</a></td></tr>
<tr><td>12</td><td>example12.asm</td><td>refaktoring předchozího příkladu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example12.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example12.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>example13.asm</td><td>zobrazení spritů tvořících Maria</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example13.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example13.asm</a></td></tr>
<tr><td>14</td><td>example14.asm</td><td>posun spritů, aby se zdůraznila jejich nezávislost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example14.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example14.asm</a></td></tr>
<tr><td>15</td><td>example15.asm</td><td>větší množství spritů na obrazovce rozdělených do řádků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example15.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example15.asm</a></td></tr>
<tr><td>16</td><td>example16.asm</td><td>větší množství spritů na obrazovce na jediném řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example16.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example16.asm</a></td></tr>
<tr><td>17</td><td>example17.asm</td><td>pohyb jednoho spritu pomocí ovladače</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example17.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example17.asm</a></td></tr>
<tr><td>18</td><td>example18.asm</td><td>odvozeno z&nbsp;předchozího příkladu, symbolická jména adres</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example18.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example18.asm</a></td></tr>
<tr><td>19</td><td>example19.asm</td><td>odvozeno z&nbsp;předchozího příkladu, pomocná makra pro pohyb spritu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example19.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example19.asm</a></td></tr>
<tr><td>20</td><td>example20.asm</td><td>pohyb spritu je založen na instrukcích <strong>INC</strong> a <strong>DEC</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example20.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example20.asm</a></td></tr>
<tr><td>21</td><td>example21.asm</td><td>přesun celého Maria (8 spritů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example21.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example21.asm</a></td></tr>
<tr><td>22</td><td>example22.asm</td><td>(rychlá) změna barvové palety spritů tlačítkem A</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example22.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example22.asm</a></td></tr>
<tr><td>23</td><td>example23.asm</td><td>realizace čítače pro snížení frekvence změn barvové palety</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example23.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example23.asm</a></td></tr>
<tr><td>24</td><td>example24.asm</td><td>horizontální a vertikální zrcadlení spritů řízené hráčem stiskem tlačítek</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example24.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example24.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>link.cfg</td><td>konfigurace segmentů pro linker <strong>ld65</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg</a></td></tr>
<tr><td>26</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: pro slinkování a spuštění dnešních
demonstračních příkladů potřebujete i soubor <a
href="https://github.com/ericdigioia/6502-Assembly-NES-Game-Development-Playground/raw/main/mario.chr">mario.chr</a>.
Ten je stažen automaticky po zadání <strong>make example16</strong> až
<strong>make example23</strong>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>The Thirty Million Line Problem<br />
<a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">https://www.youtube.com/watch?v=kZRE7HIO3vk</a>
</li>

<li>NesDev.org<br />
<a href="https://www.nesdev.org/">https://www.nesdev.org/</a>
</li>

<li>The Sprite Attribute Byte<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-17/">https://www.patater.com/nes-asm-tutorials/day-17/</a>
</li>

<li>How to Program an NES game in C<br />
<a href="https://nesdoug.com/">https://nesdoug.com/</a>
</li>

<li>Cycle reference chart<br />
<a href="https://www.nesdev.org/wiki/Cycle_reference_chart">https://www.nesdev.org/wiki/Cycle_reference_chart</a>
</li>

<li>Getting Started Programming in C: Coding a Retro Game with C Part 2<br />
<a href="https://retrogamecoders.com/getting-started-with-c-cc65/">https://retrogamecoders.com/getting-started-with-c-cc65/</a>
</li>

<li>NES game development in 6502 assembly - Part 1<br />
<a href="https://kibrit.tech/en/blog/nes-game-development-part-1">https://kibrit.tech/en/blog/nes-game-development-part-1</a>
</li>

<li>NES (Nintendo Entertainment System) controller pinout<br />
<a href="https://pinoutguide.com/Game/NES_controller_pinout.shtml">https://pinoutguide.com/Game/NES_controller_pinout.shtml</a>
</li>

<li>NES Controller Shift Register<br />
<a href="https://www.allaboutcircuits.com/uploads/articles/nes-controller-arduino.png?v=1469416980041">https://www.allaboutcircuits.com/uploads/articles/nes-controller-arduino.png?v=1469416980041</a>
</li>

<li>"Game Development in Eight Bits" by Kevin Zurawel<br />
<a href="https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4">https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4</a>
</li>

<li>Game Development for the 8-bit NES: A class by Bob Rost<br />
<a href="http://bobrost.com/nes/">http://bobrost.com/nes/</a>
</li>

<li>Game Development for the 8-bit NES: Lecture Notes<br />
<a href="http://bobrost.com/nes/lectures.php">http://bobrost.com/nes/lectures.php</a>
</li>

<li>NES Graphics Explained<br />
<a href="https://www.youtube.com/watch?v=7Co_8dC2zb8">https://www.youtube.com/watch?v=7Co_8dC2zb8</a>
</li>

<li>NES GAME PROGRAMMING PART 1<br />
<a href="https://rpgmaker.net/tutorials/227/?post=240020">https://rpgmaker.net/tutorials/227/?post=240020</a>
</li>

<li>NES 6502 Programming Tutorial - Part 1: Getting Started<br />
<a href="https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/">https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/</a>
</li>

<li>Minimal NES example using ca65<br />
<a href="https://github.com/bbbradsmith/NES-ca65-example">https://github.com/bbbradsmith/NES-ca65-example</a>
</li>

<li>List of 6502-based Computers and Consoles<br />
<a href="https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/">https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/</a>
</li>

<li>History of video game consoles (second generation): Wikipedia<br />
<a href="http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)">http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)</a>
</li>

<li>6502 - the first RISC &micro;P<br />
<a href="http://ericclever.com/6500/">http://ericclever.com/6500/</a>
</li>

<li>3 Generations of Game Machine Architecture<br />
<a href="http://www.atariarchives.org/dev/CGEXPO99.html">http://www.atariarchives.org/dev/CGEXPO99.html</a>
</li>

<li>bee - The Multi-Console Emulator<br />
<a href="http://www.thebeehive.ws/">http://www.thebeehive.ws/</a>
</li>

<li>Nerdy Nights Mirror<br />
<a href="https://nerdy-nights.nes.science/">https://nerdy-nights.nes.science/</a>
</li>

<li>The Nerdy Nights ca65 Remix<br />
<a href="https://github.com/ddribin/nerdy-nights">https://github.com/ddribin/nerdy-nights</a>
</li>

<li>NES Development Day 1: Creating a ROM<br />
<a href="https://www.moria.us/blog/2018/03/nes-development">https://www.moria.us/blog/2018/03/nes-development</a>
</li>

<li>How to Start Making NES Games<br />
<a href="https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/">https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/</a>
</li>

<li>ca65 Users Guide<br />
<a href="https://cc65.github.io/doc/ca65.html">https://cc65.github.io/doc/ca65.html</a>
</li>

<li>cc65 Users Guide<br />
<a href="https://cc65.github.io/doc/cc65.html">https://cc65.github.io/doc/cc65.html</a>
</li>

<li>ld65 Users Guide<br />
<a href="https://cc65.github.io/doc/ld65.html">https://cc65.github.io/doc/ld65.html</a>
</li>

<li>da65 Users Guide<br />
<a href="https://cc65.github.io/doc/da65.html">https://cc65.github.io/doc/da65.html</a>
</li>

<li>Nocash NES Specs<br />
<a href="http://nocash.emubase.de/everynes.htm">http://nocash.emubase.de/everynes.htm</a>
</li>

<li>Nintendo Entertainment System<br />
<a href="http://cs.wikipedia.org/wiki/NES">http://cs.wikipedia.org/wiki/NES</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>NesDev<br />
<a href="http://nesdev.parodius.com/">http://nesdev.parodius.com/</a>
</li>

<li>2A03 technical reference<br />
<a href="http://nesdev.parodius.com/2A03%20technical%20reference.txt">http://nesdev.parodius.com/2A03%20technical%20reference.txt</a>
</li>

<li>NES Dev wiki: 2A03<br />
<a href="http://wiki.nesdev.com/w/index.php/2A03">http://wiki.nesdev.com/w/index.php/2A03</a>
</li>

<li>Ricoh 2A03<br />
<a href="http://en.wikipedia.org/wiki/Ricoh_2A03">http://en.wikipedia.org/wiki/Ricoh_2A03</a>
</li>

<li>2A03 pinouts<br />
<a href="http://nesdev.parodius.com/2A03_pinout.txt">http://nesdev.parodius.com/2A03_pinout.txt</a>
</li>

<li>27c3: Reverse Engineering the MOS 6502 CPU (en)<br />
<a href="https://www.youtube.com/watch?v=fWqBmmPQP40">https://www.youtube.com/watch?v=fWqBmmPQP40</a>
</li>

<li>“Hello, world” from scratch on a 6502 — Part 1<br />
<a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">https://www.youtube.com/watch?v=LnzuMJLZRdU</a>
</li>

<li>A Tour of 6502 Cross-Assemblers<br />
<a href="https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/">https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/</a>
</li>

<li>Nintendo Entertainment System (NES)<br />
<a href="https://8bitworkshop.com/docs/platforms/nes/">https://8bitworkshop.com/docs/platforms/nes/</a>
</li>

<li>Question about NES vectors and PPU<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t4154.xhtml">https://archive.nes.science/nesdev-forums/f10/t4154.xhtml</a>
</li>

<li>How do mapper chips actually work?<br />
<a href="https://archive.nes.science/nesdev-forums/f9/t13125.xhtml">https://archive.nes.science/nesdev-forums/f9/t13125.xhtml</a>
</li>

<li>INES<br />
<a href="https://www.nesdev.org/wiki/INES">https://www.nesdev.org/wiki/INES</a>
</li>

<li>NES Basics and Our First Game<br />
<a href="http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html">http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html</a>
</li>

<li>Where is the reset vector in a .nes file?<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t17413.xhtml">https://archive.nes.science/nesdev-forums/f10/t17413.xhtml</a>
</li>

<li>CPU memory map<br />
<a href="https://www.nesdev.org/wiki/CPU_memory_map">https://www.nesdev.org/wiki/CPU_memory_map</a>
</li>

<li>How to make NES music<br />
<a href="http://blog.snugsound.com/2008/08/how-to-make-nes-music.html">http://blog.snugsound.com/2008/08/how-to-make-nes-music.html</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>MIDINES<br />
<a href="http://www.wayfar.net/0xf00000_overview.php">http://www.wayfar.net/0xf00000_overview.php</a>
</li>

<li>FamiTracker<br />
<a href="http://famitracker.com/">http://famitracker.com/</a>
</li>

<li>nerdTracker II<br />
<a href="http://nesdev.parodius.com/nt2/">http://nesdev.parodius.com/nt2/</a>
</li>

<li>How NES Graphics work<br />
<a href="http://nesdev.parodius.com/nesgfx.txt">http://nesdev.parodius.com/nesgfx.txt</a>
</li>

<li>NES Technical/Emulation/Development FAQ<br />
<a href="http://nesdev.parodius.com/NESTechFAQ.htm">http://nesdev.parodius.com/NESTechFAQ.htm</a>
</li>

<li>Adventures with ca65<br />
<a href="https://atariage.com/forums/topic/312451-adventures-with-ca65/">https://atariage.com/forums/topic/312451-adventures-with-ca65/</a>
</li>

<li>example ca65 startup code<br />
<a href="https://atariage.com/forums/topic/209776-example-ca65-startup-code/">https://atariage.com/forums/topic/209776-example-ca65-startup-code/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer<br />
<a href="http://wilsonminesco.com/6502primer/">http://wilsonminesco.com/6502primer/</a>
</li>

<li>6502 Instruction Set<br />
<a href="https://www.masswerk.at/6502/6502_instruction_set.html">https://www.masswerk.at/6502/6502_instruction_set.html</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Single-board computer<br />
<a href="https://en.wikipedia.org/wiki/Single-board_computer">https://en.wikipedia.org/wiki/Single-board_computer</a>
</li>

<li>www.6502.org<br />
<a href="http://www.6502­.org/">http://www.6502­.org/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer &ndash; clock generator<br />
<a href="http://wilsonminesco.com/6502primer/ClkGen.html">http://wilsonminesco.com/6502primer/ClkGen.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://www.cpushack.com/CPU/cpu.html">http://www.cpushack.com/CPU/cpu.html</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Osmibitové mikroprocesory a mikrořadiče firmy Motorola (1)<br />
<a href="https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/">https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/</a>
</li>

<li>Mikrořadiče a jejich použití v jednoduchých mikropočítačích<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/">https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/</a>
</li>

<li>Mikrořadiče a jejich aplikace v jednoduchých mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/">https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Comparison of instruction set architectures<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures">https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</a>
</li>

<li>Day 1 - Beginning NES Assembly<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-1/">https://www.patater.com/nes-asm-tutorials/day-1/</a>
</li>

<li>Day 2 - A Source Code File's Structure<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-2/">https://www.patater.com/nes-asm-tutorials/day-2/</a>
</li>

<li>Assembly Language Misconceptions<br />
<a href="https://www.youtube.com/watch?v=8_0tbkbSGRE">https://www.youtube.com/watch?v=8_0tbkbSGRE</a>
</li>

<li>How Machine Language Works<br />
<a href="https://www.youtube.com/watch?v=HWpi9n2H3kE">https://www.youtube.com/watch?v=HWpi9n2H3kE</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

