<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny (3)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny (3)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes si ukážeme, jakým způsobem je možné v assembleru mikroprocesoru Zilog Z80 realizovat operaci typu PLOT. Jedná se o standardní příkaz Sinclair BASICu sloužící pro vykreslení jediného pixelu na obrazovku ZX Spectra. Jak uvidíme dále, není vykreslení pixelu zcela triviální operací.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny (3)</a></p>
<p><a href="#k02">2. Vykreslení několika sad ASCII tabulek na obrazovku ZX Spectra</a></p>
<p><a href="#k03">3. Úplný zdrojový kód demonstračního příkladu pro tisk ASCII tabulek</a></p>
<p><a href="#k04">4. První varianta podprogramu typu <strong>PLOT</strong> pro vykreslení pixelu na obrazovku</a></p>
<p><a href="#k05">5. Výpočet adresy bajtu s&nbsp;obsahem pixelu pro zadané souřadnice</a></p>
<p><a href="#k06">6. Realizace výpočtu adresy</a></p>
<p><a href="#k07">7. Pomalé vykreslení úsečky složené z&nbsp;&bdquo;pixelů&ldquo;</a></p>
<p><a href="#k08">8. Kód pro vykreslení šikmé úsečky z&nbsp;jednotlivých blokových &bdquo;pixelů&ldquo;</a></p>
<p><a href="#k09">9. Úplný zdrojový kód demonstračního příkladu pro vykreslení úsečky z&nbsp;&bdquo;blokových pixelů&ldquo;</a></p>
<p><a href="#k10">10. Výpočet masky pixelu</a></p>
<p><a href="#k11">11. Realizace výpočtu masky pixelu</a></p>
<p><a href="#k12">12. Úplný zdrojový kód demonstračního příkladu pro vykreslení úsečky z&nbsp;&bdquo;pravých pixelů&ldquo;</a></p>
<p><a href="#k13">13. Zjednodušení výpočtu masky pixelu</a></p>
<p><a href="#k14">14. Úplný zdrojový kód upraveného demonstračního příkladu</a></p>
<p><a href="#k15">15. Vykreslení pixelů na libovolném pozadí</a></p>
<p><a href="#k16">16. Korektní zápis masky pixelu tak, aby nedošlo ke smazání pozadí</a></p>
<p><a href="#k17">17. Úplný zdrojový kód dnešního posledního demonstračního příkladu</a></p>
<p><a href="#k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny (3)</h2>

<p>V&nbsp;pořadí již šesté části <a
href="https://www.root.cz/serialy/vyvoj-pro-slavne-zx-spectrum/">seriálu o
vývoji programů pro legendární osmibitový domácí mikropočítač <i>ZX
Spectrum</i></a> se vrátíme k&nbsp;tématu, kterému jsme se začali věnovat <a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-podruhe/">již
minule</a>, a to konkrétně <a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-podruhe#k15">v&nbsp;patnácté
kapitole</a>. Řekli jsme si, že již relativně dobře umíme na obrazovku ZX
Spectra vypsat znak či celý řetězec. Dokonce máme k&nbsp;dispozici několik
metod, jak toho dosáhnout. Zejména můžeme využít subrutinu zapsanou přímo
v&nbsp;ROM ZX Spectra (ta umí kromě dalších věcí rozeznávat řídicí kódy) nebo
můžeme zavolat naši subrutinu, která je sice původně navržena pro tisk znaků
v&nbsp;masce 8&times;8 znaků, ale relativně snadno ji lze upravit na různé
výšky znaků (složitější bude úprava pro různé šířky).</p>

<p>Ovšem zajímavější (i když možná méně praktické) bude zjistit, jakým způsobem
je možné realizovat operaci typu <strong>PLOT</strong>. Jedná se o standardní
příkaz <a
href="https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html">Sinclair
BASICu</a> sloužící pro vykreslení jediného pixelu (a navíc pro zapamatování
souřadnice vykreslení pixelu pro další operace, například pr vykreslení
úsečky). Aby byla situace nepatrně zajímavější, existuje tento příkaz
v&nbsp;několika variantách:</p>

<table>
<tr><th>Příkaz</th><th>Stručný popis příkazu</th></tr>
<tr><td>PLOT x,y</td><td>vykreslení pixelu na souřadnice [x,y] barvou inkoustu (<i>ink</i>)</td></tr>
<tr><td>PLOT INVERSE 1; x, y</td><td>vykreslení pixelu barvou papíru (<i>paper</i>)</td></tr>
<tr><td>PLOT OVER 1; x, y</td><td>negace barvy pixelu</td></tr>
<tr><td>PLOT INVERSE 1;OVER 1;</td><td>pouze přesune grafický &bdquo;kurzor&ldquo; na nové souřadnice</td></tr>
</table>

<p>Při realizaci naší vlastní varianty příkazu <strong>PLOT</strong> budeme
pochopitelně postupovat krok za krokem. Konkrétně si dnes ukážeme několik
demonstračních příkladů, které budou postupně realizovat následující funkce
(realizované formou podprogramů &ndash; subrutin):</p>

<ol>

<li>Subrutina pro vykreslení ASCII tabulky, kterou použijeme později pro
vyplnění pozadí obrazovky, aby bylo jasně patrné, jak pracuje námi realizovaný
příkaz PLOT.</li>

<li>Výpočet adresy bajtu v&nbsp;obrazové paměti, kam se má pixel
vykreslit.</li>

<li>Vykreslení &bdquo;širokého&ldquo; pixelu o šířce osmi obrazových
pixelů.</li>

<li>Výpočet bitové masky pixelu, protože každý pixel je zapsán jako jediný bit
uložený společně s&nbsp;dalšími sedmi pixely v&nbsp;bajtu.</li>

<li>Vykreslení &bdquo;úzkého&ldquo; pixelu na korektní místo na obrazovce.</li>

<li>Zajištění, že se nesmaže pozadí celé osmice pixelů, na tom místě na
obrazovce, kam se provádí zápis.</li>

</ol>

<img src="https://i.iinfo.cz/images/645/speccyb-11.png" class="image-449688" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" width="512" height="384" />
<p><i>Obrázek 1: Obchodní část hry Elite přepsaná do Sinclair BASICu. O
vykreslení celé obrazovky se z&nbsp;velké části starají standardní grafické
příkazy Sinclair BASICu.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vykreslení několika sad ASCII tabulek na obrazovku ZX Spectra</h2>

<p>Ještě předtím, než se budeme zabývat subrutinou pro vykreslení pixelu, si
ukážeme program, který po svém spuštění vykreslí na obrazovku několik ASCII
tabulek. Tento program budeme potřebovat proto, abychom zaplnili plochu pozadí
nějakým vzorkem, na němž bude patrné, zda vykreslovací rutina
<strong>PLOT</strong> pracuje korektně či nikoli. Výsledná obrazovka by měla
vypadat následovně:</p>

*** image ***
<p><i>Obrázek 2: Několik ASCII tabulek, které vyplňují</i></p>

<p>Činnost celého programu je založena na podprogramu, který volá nám již známý
podprogram <strong>draw_char</strong>, který vytiskne jeden znak a následně
posune hodnotu uloženou v&nbsp;registrovém páru <strong>DE</strong> na adresu
v&nbsp;obrazové paměti, kam se má vykreslit další znak. V&nbsp;jedné iteraci
vykreslíme dvojici znaků &ndash; nějaký znak s&nbsp;kódem uloženým
v&nbsp;počitadlu smyčky a mezeru:</p>

<pre>
<strong>draw_ascii_table</strong>:
        <i>; Vytištění ASCII tabulky</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call <strong>draw_char</strong>           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call <strong>draw_char</strong>           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že hodnotu registru
<strong>A</strong>, který obsahuje ASCII kód vykreslovaného znaku, musíme
(společně s&nbsp;příznakovým registrem <strong>F</strong>) uložit na zásobník,
protože obsah tohoto registru podprogram <strong>draw_char</strong>
ničí.</div></p>

<p>Vykreslení několika ASCII tabulek přes celou obrazovku je již snadné,
protože nám postačuje zavolat výše popsanou subrutinu
<strong>draw_ascii_table</strong> čtyřikrát za sebou, přičemž nebudeme
zasahovat do adresy uložené v&nbsp;registrovém páru <strong>DE</strong>:</p>

<pre>
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR        <i>; adresa pro vykreslení prvního bloku znaků</i>
        call <strong>draw_ascii_table</strong>    <i>; vykreslení 96 znaků</i>
        call <strong>draw_ascii_table</strong>    <i>; vykreslení 96 znaků</i>
        call <strong>draw_ascii_table</strong>    <i>; vykreslení 96 znaků</i>
        call <strong>draw_ascii_table</strong>    <i>; vykreslení 96 znaků</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p>Samotné tělo programu se tedy zkrátí na zavolání subrutiny
<strong>fill_in_screen</strong> následované vstupem do nekonečné smyčky (aby se
řízení nevrátilo zpět do BASICu):</p>

<pre>
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call <strong>fill_in_screen</strong>      <i>; vyplnění obrazovky ASCII tabulkami</i>
<strong>finito</strong>:
        jr <strong>finito</strong>                <i>; ukončit program nekonečnou smyčkou</i>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Úplný zdrojový kód demonstračního příkladu pro tisk ASCII tabulek</h2>

<p>Úplný zdrojový kód demonstračního příkladu popsaného <a href="#k02">ve druhé
kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm</a>:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call <strong>fill_in_screen</strong>      <i>; vyplnění obrazovky ASCII tabulkami</i>
<strong>finito</strong>:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR        <i>; adresa pro vykreslení prvního bloku znaků</i>
        call <strong>draw_ascii_table</strong>    <i>; vykreslení 96 znaků</i>
        call <strong>draw_ascii_table</strong>    <i>; vykreslení 96 znaků</i>
        call <strong>draw_ascii_table</strong>    <i>; vykreslení 96 znaků</i>
        call <strong>draw_ascii_table</strong>    <i>; vykreslení 96 znaků</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_ascii_table</strong>:
        <i>; Vytištění ASCII tabulky</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call <strong>draw_char</strong>           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call <strong>draw_char</strong>           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_char</strong>:
        <i>; Vytištění jednoho znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
loop:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Podívejme se ještě na způsob překladu tohoto příkladu do strojového kódu.
Jeho celková délka dosahuje šedesáti bajtů:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:CD0580     CALL 8005
8003:           label finito
8003:18FE       JR 8003
8005:           label fill_in_screen
8005:110040     LD DE, 4000
8008:CD1580     CALL 8015
800B:CD1580     CALL 8015
800E:CD1580     CALL 8015
8011:CD1580     CALL 8015
8014:C9         RET
8015:           label draw_ascii_table
8015:3E20       LD A, 20
8017:           label next_char
8017:F5         PUSH AF
8018:CD2780     CALL 8027
801B:3E20       LD A, 20
801D:CD2780     CALL 8027
8020:F1         POP AF
8021:3C         INC A
8022:FE80       CP 80
8024:20F1       JR NZ, 8017
8026:C9         RET
8027:           label draw_char
8027:01003C     LD BC, 3C00
802A:61         LD H, C
802B:6F         LD L, A
802C:29         ADD HL, HL
802D:29         ADD HL, HL
802E:29         ADD HL, HL
802F:09         ADD HL, BC
8030:0608       LD B, 08
8032:4A         LD C, D
8033:           label loop
8033:7E         LD A, (HL)
8034:12         LD (DE), A
8035:2C         INC L
8036:14         INC D
8037:10FA       DJNZ 8033
8039:1C         INC E
803A:C8         RET Z
803B:51         LD D, C
803C:C9         RET
803D:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 803C
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. První varianta podprogramu typu <strong>PLOT</strong> pro vykreslení pixelu na obrazovku</h2>

<p>Vraťme se k&nbsp;ústřednímu tématu dnešního článku &ndash;
k&nbsp;implementaci podprogramu, který by měl být obdobou příkazu
<strong>PLOT</strong>, tj.&nbsp;který by měl provést vykreslení jednoho pixelu
na obrazovku. Připomeňme si, že rozlišení obrazovky ZX Spectra je 256&times;192
pixelů, což znamená, že x-ová i y-ová souřadnice pixelu musí být reprezentována
osmibitovým číslem (což je oproti počítačům s&nbsp;rozlišením 320&times;xxx
pixelů značné zjednodušení). X-ovou souřadnici budeme do postupně vznikajícího
podprogramu předávat v&nbsp;registru <strong>B</strong>, y-ovou souřadnici pak
v&nbsp;registru <strong>C</strong>.</p>

<p>Nejprimitivnější podoba podprogramu <strong>PLOT</strong> na základě obsahu
pracovních registrů <strong>B</strong> a <strong>C</strong> (souřadnic pixelu)
vypočítá adresu pixelu (resp.&nbsp;celé osmice pixelů) v&nbsp;obrazové paměti a
následně na tuto adresu uloží konstantu 0xff. To vlastně znamená, že
nevykreslíme jediný pixel, ale osmici sousedních pixelů. Nějak však začít
musíme :)</p>

<p>Podprogram bude vypadat následovně:</p>

<pre>
<strong>plot</strong>:
        <i>; první varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call <strong>calc_pixel_address</strong>  <i>; výpočet adresy pixelu</i>
        ld (hl), 0xff            <i>; zápis "něčeho" na adresu pixelu</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výpočet adresy bajtu s&nbsp;obsahem pixelu pro zadané souřadnice</h2>

<p>Výpočet adresy v&nbsp;obrazové paměti, na níž má být zápis proveden, je
relativně komplikované, ovšem na druhou stranu se vyhneme nutnosti násobení
atd. (popř.&nbsp;náhradě násobení za posuny a součty). <a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/#k03">Ve
třetí části tohoto seriálu</a> jsme si popsali organizaci obrazové paměti.
Připomeňme si, že adresa každého bajtu obrazové paměti se skládá
z&nbsp;několika bitových polí v&nbsp;tomto formátu (jedná se o 16bitovou adresu
zapsanou formou jednotlivých bitů):</p>

<pre>
010 BB SSS RRR CCCCC
&nbsp;
BB:    číslo bloku 0,1,2 (v bloku číslo 3 je atributová paměť)
SSS:   číslo řádky v&nbsp;jednom znaku, který je vysoký osm obrazových řádků
RRR:   pozice textového řádku v&nbsp;bloku. Každý blok je vysoký 64 obrazových řádků, což odpovídá osmi řádkům textovým
CCCCC: index sloupce bajtu v rozmezí 0..31, kde je uložena osmice sousedních pixelů
</pre>

<p>My ovšem nyní nepracujeme se znaky, ale s&nbsp;pixely. Schéma adresy se
ovšem změní jen nepatrně (opět je adresa uvedena po jednotlivých bitech):</p>

<pre>
010 Y7 Y6 Y2 Y1 Y0 | Y5 Y3 Y3 X7 X6 X5 X4 X3
</pre>

<p>Povšimněte si, že nyní nejvyšší dva bity y-ové souřadnice uvádí číslo bloku.
Naopak se v&nbsp;adrese vůbec nevyskytují bity X2, X1 a X0, což je logické,
protože tyto tři bity specifikují index bitu v&nbsp;zapisovaném bajtu (viz
navazující kapitoly). Našim úkolem je tedy realizovat tento algoritmus:</p>

<ol>
<li>Prvním vstupem jsou hodnoty X7 X6 X5 X4 X3 X3 X1 X0 uložené v&nbsp;registru <strong>B</strong></li>
<li>Druhým vstupem jsou hodnoty Y7 Y6 Y5 Y4 Y3 Y3 Y1 Y0 uložené v&nbsp;registru <strong>C</strong></li>
<li>Výstupem je 16bitová adresa 010 Y7 Y6 Y2 Y1 Y0 Y5 Y3 Y3 X7 X6 X5 X4 X3</li>
<li>Vyšší bajt adresy 010 Y7 Y6 Y2 Y1 Y0 bude uložen do registru <strong>H</strong></li>
<li>Nižší bajt adresy Y5 Y3 Y3 X7 X6 X5 X4 X3 bude uložen do registru <strong>L</strong></li>
</ol>



<p><a name="k06"></a></p>
<h2 id="k06">6. Realizace výpočtu adresy</h2>

<p>Výše uvedený algoritmus je možné realizovat bitovými operacemi
(<strong>and</strong>, <strong>or</strong>) a bitovými posuny
(<strong>rra</strong>). Realizace celého algoritmu se &bdquo;vejde&ldquo; do 29
bajtů (a to jsme neprováděli žádné optimalizace):</p>

<pre>
<strong>calc_pixel_address</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis pixelu</i>
        <i>;</i>
        <i>; pozměněné registry:</i>
        <i>; A</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y7 Y6 Y2 Y1 Y0 | Y5 Y4 Y3 X4 X3 X2 X1 X0</i>
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (Y2 Y1 Y0)</i>
                              <i>; A: 0 0 0 0 0 Y2 Y1 Y0</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; část horního bajtu adresy je vypočtena</i>
                              <i>; H: 0 1 0 0 0 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> Y1 Y0 xx Y7 Y6 Y5 Y4 Y3</i>
        and %00011000         <i>; zamaskovat</i>
                              <i>; A: 0  0  0 Y7 Y6  0  0  0</i>
        or  h                 <i>; a přidat k vypočtenému mezivýsledku</i>
        ld  h, a              <i>; H: 0  1  0 Y7 Y6 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rla
        rla                   <i>; A:  Y5 Y4 Y3 Y2 Y1 Y0 xx xx</i>
        and %11100000         <i>; A:  Y5 Y4 Y3 0  0  0  0  0</i>
        ld  l, a              <i>; část spodního bajtu adresy je vypočtena</i>
&nbsp;
        ld  a, b              <i>; všech osm bitů X-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> 0  0  0  X7 X6 X5 X4</i>
        and %00011111         <i>; A: 0  0  0  X7 X6 X5 X4 X3</i>
        or  l                 <i>; A: Y5 Y3 Y3 X7 X6 X5 X4 X3</i>
        ld  l, a              <i>; spodní bajt adresy je vypočten</i>
&nbsp;
        ret                   <i>; návrat z podprogramu</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pomalé vykreslení úsečky složené z&nbsp;&bdquo;pixelů&ldquo;</h2>

<p>Aby bylo patrné, jak dobře či špatně se nám daří vypočítat adresu
vykreslovaných pixelů, pokusíme se na obrazovku vykreslit šikmou úsečku (pod
úhlem 45&deg;). Úsečku přitom vykreslíme zpomaleně &ndash; mezi vykreslení
každého dalšího pixelu bude vložena zpožďovací rutina. Vzhledem
k&nbsp;relativně vysoké rychlosti mikroprocesoru Zilog Z80 využívá tato rutina
dvojici vnořených programových smyček, každou s&nbsp;osmibitovým čítačem (jedna
smyčka s&nbsp;osmibitovým čítačem by nestačila). Jedna z&nbsp;možných variant
této zpožďovací smyčky může vypadat takto:</p>

<pre>
<strong>delay</strong>:
        <i>; zpožďovací rutina</i>
        <i>; nemění žádné registry</i>
        push bc                  <i>; uschovat hodnoty registrů, které se používají ve smyčkách</i>
        ld   b, 20               <i>; počitadlo vnější zpožďovací smyčky</i>
<strong>outer_loop</strong>:
        ld   c, 0                <i>; počitadlo vnitřní zpožďovací smyčky</i>
<strong>inner_loop</strong>:
        dec  c                   <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr   NZ, <strong>inner_loop</strong>      <i>; opakovat, dokud není dosaženo nuly</i>
        djnz <strong>outer_loop</strong>          <i>; opakovat vnější smyčku, nyní s počitadlem v B</i>
        pop  bc                  <i>; obnovit hodnoty registrů změněných smyčkami</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že tato rutina na konci
obnoví všechny použité registry, takže ji je možné volat kdekoli
v&nbsp;kódu.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Kód pro vykreslení šikmé úsečky z&nbsp;jednotlivých blokových &bdquo;pixelů&ldquo;</h2>

<p>Samotné vykreslení šikmé úsečky je již jednoduché, protože nám postačuje
postupně modifikovat hodnoty pracovních registrů <strong>B</strong> a
<strong>C</strong>, které jsou použity při volání podprogramu
<strong>PLOT</strong> a které obsahují x-ovou a y-ovou souřadnici pixelu. Jak
již víme, budeme vkládat mezi jednotlivá volání subrutiny <strong>plot</strong>
zpožďovací smyčky:</p>

<pre>
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
<strong>loop</strong>:
        call <strong>plot</strong>                <i>; vykreslení pixelu</i>
        call <strong>delay</strong>
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, <strong>loop</strong>              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
<strong>finito</strong>:
        jr <strong>finito</strong>                <i>; ukončit program nekonečnou smyčkou</i>
</pre>

<p>Výsledek bude vypadat zhruba následovně:</p>

*** image ***
<p><i>Obrázek 3: Postupné vykreslování úsečky z&nbsp;&bdquo;blokových pixelů&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 4: Postupné vykreslování úsečky z&nbsp;&bdquo;blokových pixelů&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 5: Postupné vykreslování úsečky z&nbsp;&bdquo;blokových pixelů&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 6: Postupné vykreslování úsečky z&nbsp;&bdquo;blokových pixelů&ldquo;.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód demonstračního příkladu pro vykreslení úsečky z&nbsp;&bdquo;blokových pixelů&ldquo;</h2>

<p>Úplný zdrojový kód demonstračního příkladu popsaného v&nbsp;předchozích
kapitolách je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm</a>
a vypadá takto:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
start:
        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
loop:
        call plot                <i>; vykreslení pixelu</i>
        call delay
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, loop              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
finito:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
delay:
        <i>; zpožďovací rutina</i>
        <i>; nemění žádné registry</i>
        push bc                  <i>; uschovat hodnoty registrů, které se používají ve smyčkách</i>
        ld   b, 20               <i>; počitadlo vnější zpožďovací smyčky</i>
outer_loop:
        ld   c, 0                <i>; počitadlo vnitřní zpožďovací smyčky</i>
inner_loop:
        dec  c                   <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr   NZ, inner_loop      <i>; opakovat, dokud není dosaženo nuly</i>
        djnz outer_loop          <i>; opakovat vnější smyčku, nyní s počitadlem v B</i>
        pop  bc                  <i>; obnovit hodnoty registrů změněných smyčkami</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
plot:
        <i>; první varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        ld (hl), 0xff            <i>; zápis "něčeho" na adresu pixelu</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
calc_pixel_address:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis pixelu</i>
        <i>;</i>
        <i>; pozměněné registry:</i>
        <i>; A</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y7 Y6 Y2 Y1 Y0 | Y5 Y4 Y3 X4 X3 X2 X1 X0</i>
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (Y2 Y1 Y0)</i>
                              <i>; A: 0 0 0 0 0 Y2 Y1 Y0</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; část horního bajtu adresy je vypočtena</i>
                              <i>; H: 0 1 0 0 0 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> Y1 Y0 xx Y7 Y6 Y5 Y4 Y3</i>
        and %00011000         <i>; zamaskovat</i>
                              <i>; A: 0  0  0 Y7 Y6  0  0  0</i>
        or  h                 <i>; a přidat k vypočtenému mezivýsledku</i>
        ld  h, a              <i>; H: 0  1  0 Y7 Y6 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rla
        rla                   <i>; A:  Y5 Y4 Y3 Y2 Y1 Y0 xx xx</i>
        and %11100000         <i>; A:  Y5 Y4 Y3 0  0  0  0  0</i>
        ld  l, a              <i>; část spodního bajtu adresy je vypočtena</i>
&nbsp;
        ld  a, b              <i>; všech osm bitů X-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> 0  0  0  X7 X6 X5 X4</i>
        and %00011111         <i>; A: 0  0  0  X7 X6 X5 X4 X3</i>
        or  l                 <i>; A: Y5 Y3 Y3 X7 X6 X5 X4 X3</i>
        ld  l, a              <i>; spodní bajt adresy je vypočten</i>
&nbsp;
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Po překladu do strojového kódu získáme sekvenci instrukcí s&nbsp;délkou
pouhých 65 bajtů:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:0600       LD B, 00
8002:0E00       LD C, 00
8004:           label loop
8004:CD1F80     CALL 801F
8007:CD1380     CALL 8013
800A:04         INC B
800B:0C         INC C
800C:78         LD A, B
800D:FEC0       CP C0
800F:20F3       JR NZ, 8004
8011:           label finito
8011:18FE       JR 8011
8013:           label delay
8013:C5         PUSH BC
8014:0614       LD B, 14
8016:           label outer_loop
8016:0E00       LD C, 00
8018:           label inner_loop
8018:0D         DEC C
8019:20FD       JR NZ, 8018
801B:10F9       DJNZ 8016
801D:C1         POP BC
801E:C9         RET
801F:           label plot
801F:CD2580     CALL 8025
8022:36FF       LD (HL), FF
8024:C9         RET
8025:           label calc_pixel_address
8025:79         LD A, C
8026:E607       AND 07
8028:F640       OR 40
802A:67         LD H, A
802B:79         LD A, C
802C:1F         RRA
802D:1F         RRA
802E:1F         RRA
802F:E618       AND 18
8031:B4         OR H
8032:67         LD H, A
8033:79         LD A, C
8034:17         RLA
8035:17         RLA
8036:E6E0       AND E0
8038:6F         LD L, A
8039:78         LD A, B
803A:1F         RRA
803B:1F         RRA
803C:1F         RRA
803D:E61F       AND 1F
803F:B5         OR L
8040:6F         LD L, A
8041:C9         RET
8042:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8041
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výpočet masky pixelu</h2>

<p>Abychom nekreslili pouze &bdquo;široké pixely&ldquo;, ale dokázali skutečně
vykreslit jednotlivý pixel, musíme nejdříve vypočítat masku pixelu. Jedná se o
bajt, který obsahuje pouze jediný nastavený bit vypočtený na základě nejnižších
tří bitů X-ové souřadnice (tyto tři bity jsme prozatím ignorovali). Výpočet je
snadný za předpokladu, pokud si uvědomíme, jak má maska vypadat:</p>

<pre>
X2 X1 X0   Maska
0  0  0    10000000
0  0  1    01000000
0  1  0    00100000
0  1  1    00010000
1  0  0    00001000
1  0  1    00000100
1  1  0    00000010
1  1  1    00000001
</pre>

<p>Vidíme, že se vlastně jedná o posun bitové hodnoty 1000000 doprava o
<i>n</i> bitů, přičemž <i>n</i> odpovídá spodním třem bitům x-ové souřadnice od
0 do 7.</p>

<p>Jakmile je maska vypočtena, můžeme ji (prozatím chybně) uložit do obrazové
paměti takto:</p>

<pre>
<strong>plot</strong>:
        <i>; druhá varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call <strong>calc_pixel_address</strong>  <i>; výpočet adresy pixelu</i>
        call <strong>calc_pixel_value</strong>    <i>; výpočet ukládané hodnoty</i>
        ld (hl), a               <i>; zápis hodnoty pixelu</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: předpokládáme, že podprogram
<strong>calc_pixel_value</strong> vrátí vypočtenou hodnotu v&nbsp;akumulátoru,
tedy v&nbsp;registru <strong>A</strong>.</div></p>

<p>Výsledek bude vypadat zhruba následovně:</p>

*** image ***
<p><i>Obrázek 7: Postupné vykreslování úsečky z&nbsp;&bdquo;úzkých pixelů&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 8: Postupné vykreslování úsečky z&nbsp;&bdquo;úzkých pixelů&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 9: Postupné vykreslování úsečky z&nbsp;&bdquo;úzkých pixelů&ldquo;.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Realizace výpočtu masky pixelu</h2>

<p>Podívejme se nyní na neoptimalizovaný program, který vypočte masku pixelu na
základě plné osmibitové x-ové souřadnice, která je předána v&nbsp;registru
<strong>B</strong>. Nejprve se z&nbsp;této souřadnice získají spodní tři bity a
následně se použijí jako počitadlo smyčky, v&nbsp;níž je realizován posun
bitové hodnoty 10000000 doprava:</p>

<pre>
<strong>calc_pixel_value</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; A - hodnota pixelu</i>
        push bc                  <i>; zapamatovat si hodnotu v registru B</i>
        ld   a, b                <i>; A: X7 X6 X5 X4 X3 X2 X1 X0 </i>
        and  %00000111           <i>; A: 0  0  0  0  0  X2 X1 X0</i>
        jr z, <strong>put_1</strong>              <i>; pokud je nyní souřadnice nulová, zapíšeme výchozí masku + konec</i>
&nbsp;
        ld b, a                  <i>; počitadlo smyčky</i>
        ld a, %10000000          <i>; výchozí maska</i>
<strong>next_shift</strong>:
        srl a                    <i>; posunout masku doprava</i>
        djnz <strong>next_shift</strong>          <i>; 1x až 7x</i>
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
<strong>put_1</strong>:
        ld a, %10000000          <i>; výchozí maska je současně i návratovou hodnotou</i>
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: výsledný podprogram není nijak
optimalizován a je otázkou, zda celý výpočet nenahradit za načtení příslušné
hodnoty z&nbsp;tabulky &ndash; to si ostatně ukážeme později.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úplný zdrojový kód demonstračního příkladu pro vykreslení úsečky z&nbsp;&bdquo;pravých pixelů&ldquo;</h2>

<p>Úplný zdrojový kód demonstračního příkladu popsaného v&nbsp;předchozích dvou
kapitolách je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm</a>
a vypadá takto:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
<strong>loop</strong>:
        call plot                <i>; vykreslení pixelu</i>
        call delay
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, loop              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
<strong>finito</strong>:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>delay</strong>:
        <i>; zpožďovací rutina</i>
        <i>; nemění žádné registry</i>
        push bc                  <i>; uschovat hodnoty registrů, které se používají ve smyčkách</i>
        ld   b, 20               <i>; počitadlo vnější zpožďovací smyčky</i>
<strong>outer_loop</strong>:
        ld   c, 0                <i>; počitadlo vnitřní zpožďovací smyčky</i>
<strong>inner_loop</strong>:
        dec  c                   <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr   NZ, inner_loop      <i>; opakovat, dokud není dosaženo nuly</i>
        djnz outer_loop          <i>; opakovat vnější smyčku, nyní s počitadlem v B</i>
        pop  bc                  <i>; obnovit hodnoty registrů změněných smyčkami</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>plot</strong>:
        <i>; druhá varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld (hl), a               <i>; zápis hodnoty pixelu</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>calc_pixel_value</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; A - hodnota pixelu</i>
        push bc                  <i>; zapamatovat si hodnotu v registru B</i>
        ld   a, b                <i>; A: X7 X6 X5 X4 X3 X2 X1 X0 </i>
        and  %00000111           <i>; A: 0  0  0  0  0  X2 X1 X0</i>
        jr z, put_1              <i>; pokud je nyní souřadnice nulová, zapíšeme výchozí masku + konec</i>
&nbsp;
        ld b, a                  <i>; počitadlo smyčky</i>
        ld a, %10000000          <i>; výchozí maska</i>
<strong>next_shift</strong>:
        srl a                    <i>; posunout masku doprava</i>
        djnz next_shift          <i>; 1x až 7x</i>
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
<strong>put_1</strong>:
        ld a, %10000000          <i>; výchozí maska je současně i návratovou hodnotou</i>
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>calc_pixel_address</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis pixelu</i>
        <i>;</i>
        <i>; pozměněné registry:</i>
        <i>; A</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y7 Y6 Y2 Y1 Y0 | Y5 Y4 Y3 X4 X3 X2 X1 X0</i>
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (Y2 Y1 Y0)</i>
                              <i>; A: 0 0 0 0 0 Y2 Y1 Y0</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; část horního bajtu adresy je vypočtena</i>
                              <i>; H: 0 1 0 0 0 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> Y1 Y0 xx Y7 Y6 Y5 Y4 Y3</i>
        and %00011000         <i>; zamaskovat</i>
                              <i>; A: 0  0  0 Y7 Y6  0  0  0</i>
        or  h                 <i>; a přidat k vypočtenému mezivýsledku</i>
        ld  h, a              <i>; H: 0  1  0 Y7 Y6 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rla
        rla                   <i>; A:  Y5 Y4 Y3 Y2 Y1 Y0 xx xx</i>
        and %11100000         <i>; A:  Y5 Y4 Y3 0  0  0  0  0</i>
        ld  l, a              <i>; část spodního bajtu adresy je vypočtena</i>
&nbsp;
        ld  a, b              <i>; všech osm bitů X-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> 0  0  0  X7 X6 X5 X4</i>
        and %00011111         <i>; A: 0  0  0  X7 X6 X5 X4 X3</i>
        or  l                 <i>; A: Y5 Y3 Y3 X7 X6 X5 X4 X3</i>
        ld  l, a              <i>; spodní bajt adresy je vypočten</i>
&nbsp;
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>A pro úplnost si ukažme způsob překladu do strojového kódu, přičemž výsledek
bude mít stále přijatelných 86 bajtů:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:0600       LD B, 00
8002:0E00       LD C, 00
8004:           label loop
8004:CD1F80     CALL 801F
8007:CD1380     CALL 8013
800A:04         INC B
800B:0C         INC C
800C:78         LD A, B
800D:FEC0       CP C0
800F:20F3       JR NZ, 8004
8011:           label finito
8011:18FE       JR 8011
8013:           label delay
8013:C5         PUSH BC
8014:0614       LD B, 14
8016:           label outer_loop
8016:0E00       LD C, 00
8018:           label inner_loop
8018:0D         DEC C
8019:20FD       JR NZ, 8018
801B:10F9       DJNZ 8016
801D:C1         POP BC
801E:C9         RET
801F:           label plot
801F:CD3A80     CALL 803A
8022:CD2780     CALL 8027
8025:77         LD (HL), A
8026:C9         RET
8027:           label calc_pixel_value
8027:C5         PUSH BC
8028:78         LD A, B
8029:E607       AND 07
802B:2809       JR Z, 8036
802D:47         LD B, A
802E:3E80       LD A, 80
8030:           label next_shift
8030:CB3F       SRL A
8032:10FC       DJNZ 8030
8034:C1         POP BC
8035:C9         RET
8036:           label put_1
8036:3E80       LD A, 80
8038:C1         POP BC
8039:C9         RET
803A:           label calc_pixel_address
803A:79         LD A, C
803B:E607       AND 07
803D:F640       OR 40
803F:67         LD H, A
8040:79         LD A, C
8041:1F         RRA
8042:1F         RRA
8043:1F         RRA
8044:E618       AND 18
8046:B4         OR H
8047:67         LD H, A
8048:79         LD A, C
8049:17         RLA
804A:17         RLA
804B:E6E0       AND E0
804D:6F         LD L, A
804E:78         LD A, B
804F:1F         RRA
8050:1F         RRA
8051:1F         RRA
8052:E61F       AND 1F
8054:B5         OR L
8055:6F         LD L, A
8056:C9         RET
8057:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8056
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zjednodušení výpočtu masky pixelu</h2>

<p>Způsob výpočtu masky pixelu, který jsme si ukázali <a
href="#k11">v&nbsp;jedenácté kapitole</a>, je možné různými způsoby
zjednodušit. Jedna z&nbsp;možných variant zjednodušení spočívá
v&nbsp;odstranění duplicitních instrukcí <strong>pop bc</strong> a
<strong>ret</strong> a současně i naplnění masky hodnotou %10000000 pro nulové
souřadnice X2, X1, X0. Postačuje nám nepatrně upravit programovou logiku, kdy
počáteční hodnotu masky %10000000 vložíme do registru <strong>A</strong> a
teprve poté testujeme, jestli nejsou hodnoty X2, X1 a X0 nulové &ndash; to nám
Zilog Z80 skutečně umožňuje, protože instrukce <strong>ld</strong> nenastavují
příznaky (na rozdíl od MOSu 6502, kde by tento postup nešel použít). Upravená
subrutina pro výpočet masky pixelu vypadá následovně:</p>

<pre>
<strong>calc_pixel_value</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; A - hodnota pixelu</i>
        push bc                  <i>; zapamatovat si hodnotu v registru B</i>
        ld   a, b                <i>; A: X7 X6 X5 X4 X3 X2 X1 X0 </i>
        and  %00000111           <i>; A: 0  0  0  0  0  X2 X1 X0</i>
        ld b, a                  <i>; počitadlo smyčky (neměníme příznaky)</i>
        ld a, %10000000          <i>; výchozí maska (neměníme příznaky)</i>
        jr z, <strong>end_calc</strong>           <i>; pokud je nyní souřadnice nulová, zapíšeme výchozí masku + konec</i>
&nbsp;
<strong>next_shift</strong>:
        srl a                    <i>; posunout masku doprava</i>
        djnz <strong>next_shift</strong>          <i>; 1x až 7x</i>
<strong>end_calc</strong>:
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p>Výsledné chování programu se tím nijak nezmění:</p>

*** image ***
<p><i>Obrázek 10: Postupné vykreslování úsečky z&nbsp;&bdquo;úzkých pixelů&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 11: Postupné vykreslování úsečky z&nbsp;&bdquo;úzkých pixelů&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 12: Postupné vykreslování úsečky z&nbsp;&bdquo;úzkých pixelů&ldquo;.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Úplný zdrojový kód upraveného demonstračního příkladu</h2>

<p>Úplný zdrojový kód upraveného demonstračního příkladu popsaného <a
href="#k13">v&nbsp;předchozí kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm</a>
a vypadá takto:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
<strong>loop</strong>:
        call plot                <i>; vykreslení pixelu</i>
        call delay
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, loop              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
<strong>finito</strong>:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>delay</strong>:
        <i>; zpožďovací rutina</i>
        <i>; nemění žádné registry</i>
        push bc                  <i>; uschovat hodnoty registrů, které se používají ve smyčkách</i>
        ld   b, 20               <i>; počitadlo vnější zpožďovací smyčky</i>
<strong>outer_loop</strong>:
        ld   c, 0                <i>; počitadlo vnitřní zpožďovací smyčky</i>
<strong>inner_loop</strong>:
        dec  c                   <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr   NZ, inner_loop      <i>; opakovat, dokud není dosaženo nuly</i>
        djnz outer_loop          <i>; opakovat vnější smyčku, nyní s počitadlem v B</i>
        pop  bc                  <i>; obnovit hodnoty registrů změněných smyčkami</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>plot</strong>:
        <i>; druhá varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld (hl), a               <i>; zápis hodnoty pixelu</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>calc_pixel_value</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; A - hodnota pixelu</i>
        push bc                  <i>; zapamatovat si hodnotu v registru B</i>
        ld   a, b                <i>; A: X7 X6 X5 X4 X3 X2 X1 X0 </i>
        and  %00000111           <i>; A: 0  0  0  0  0  X2 X1 X0</i>
        ld b, a                  <i>; počitadlo smyčky (neměníme příznaky)</i>
        ld a, %10000000          <i>; výchozí maska (neměníme příznaky)</i>
        jr z, end_calc           <i>; pokud je nyní souřadnice nulová, zapíšeme výchozí masku + konec</i>
&nbsp;
<strong>next_shift</strong>:
        srl a                    <i>; posunout masku doprava</i>
        djnz next_shift          <i>; 1x až 7x</i>
<strong>end_calc</strong>:
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>calc_pixel_address</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis pixelu</i>
        <i>;</i>
        <i>; pozměněné registry:</i>
        <i>; A</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y7 Y6 Y2 Y1 Y0 | Y5 Y4 Y3 X4 X3 X2 X1 X0</i>
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (Y2 Y1 Y0)</i>
                              <i>; A: 0 0 0 0 0 Y2 Y1 Y0</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; část horního bajtu adresy je vypočtena</i>
                              <i>; H: 0 1 0 0 0 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> Y1 Y0 xx Y7 Y6 Y5 Y4 Y3</i>
        and %00011000         <i>; zamaskovat</i>
                              <i>; A: 0  0  0 Y7 Y6  0  0  0</i>
        or  h                 <i>; a přidat k vypočtenému mezivýsledku</i>
        ld  h, a              <i>; H: 0  1  0 Y7 Y6 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rla
        rla                   <i>; A:  Y5 Y4 Y3 Y2 Y1 Y0 xx xx</i>
        and %11100000         <i>; A:  Y5 Y4 Y3 0  0  0  0  0</i>
        ld  l, a              <i>; část spodního bajtu adresy je vypočtena</i>
&nbsp;
        ld  a, b              <i>; všech osm bitů X-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> 0  0  0  X7 X6 X5 X4</i>
        and %00011111         <i>; A: 0  0  0  X7 X6 X5 X4 X3</i>
        or  l                 <i>; A: Y5 Y3 Y3 X7 X6 X5 X4 X3</i>
        ld  l, a              <i>; spodní bajt adresy je vypočten</i>
&nbsp;
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Po překladu do strojového kódu snadno zjistíme, že jsme ušetřili čtyři
bajty. To se sice na první pohled nezdá moc, ale jedná se o celá 4% celkové
velikosti kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:0600       LD B, 00
8002:0E00       LD C, 00
8004:           label loop
8004:CD1F80     CALL 801F
8007:CD1380     CALL 8013
800A:04         INC B
800B:0C         INC C
800C:78         LD A, B
800D:FEC0       CP C0
800F:20F3       JR NZ, 8004
8011:           label finito
8011:18FE       JR 8011
8013:           label delay
8013:C5         PUSH BC
8014:0614       LD B, 14
8016:           label outer_loop
8016:0E00       LD C, 00
8018:           label inner_loop
8018:0D         DEC C
8019:20FD       JR NZ, 8018
801B:10F9       DJNZ 8016
801D:C1         POP BC
801E:C9         RET
801F:           label plot
801F:CD3680     CALL 8036
8022:CD2780     CALL 8027
8025:77         LD (HL), A
8026:C9         RET
8027:           label calc_pixel_value
8027:C5         PUSH BC
8028:78         LD A, B
8029:E607       AND 07
802B:47         LD B, A
802C:3E80       LD A, 80
802E:2804       JR Z, 8034
8030:           label next_shift
8030:CB3F       SRL A
8032:10FC       DJNZ 8030
8034:           label end_calc
8034:C1         POP BC
8035:C9         RET
8036:           label calc_pixel_address
8036:79         LD A, C
8037:E607       AND 07
8039:F640       OR 40
803B:67         LD H, A
803C:79         LD A, C
803D:1F         RRA
803E:1F         RRA
803F:1F         RRA
8040:E618       AND 18
8042:B4         OR H
8043:67         LD H, A
8044:79         LD A, C
8045:17         RLA
8046:17         RLA
8047:E6E0       AND E0
8049:6F         LD L, A
804A:78         LD A, B
804B:1F         RRA
804C:1F         RRA
804D:1F         RRA
804E:E61F       AND 1F
8050:B5         OR L
8051:6F         LD L, A
8052:C9         RET
8053:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8052
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vykreslení pixelů na libovolném pozadí</h2>

<p>Nyní si předchozí demonstrační příklad, který již (alespoň zdánlivě) dokáže
vykreslit pixely na obrazovku korektním způsobem, nepatrně upravíme. Použijeme
totiž podprogram <strong>fill_in_screen</strong>, kterým jsme se zabývali <a
href="#k02">v&nbsp;první části dnešního článku</a>, tak, aby se ještě před
vykreslením úsečky z&nbsp;pixelů zaplnilo celé pozadí ASCII znaky. Celý program
je složen ze série podprogramů, takže jeho úprava bude snadná:</p>

<pre>
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call <strong>fill_in_screen</strong>      <i>; vyplnění obrazovky ASCII tabulkami</i>

        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
<strong>loop</strong>:
        call <strong>plot</strong>                <i>; vykreslení pixelu</i>
        call <strong>dela</strong>y
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, loop              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
<strong>finito</strong>:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
</pre>

<p>Výsledek však ukáže, že jsme ještě stále nedošli ke kýženému výsledku,
protože se vždy smaže překreslí celý blok osmi pixelů. Ve výsledku se tak
jakoby smažou všechny znaky ležící na diagonále:</p>

*** image ***
<p><i>Obrázek 13: Zápis jediného pixelu vede k&nbsp;překreslení osmice sousedících pixelů.</i></p>

*** image ***
<p><i>Obrázek 14: Zápis jediného pixelu vede k&nbsp;překreslení osmice sousedících pixelů.</i></p>

*** image ***
<p><i>Obrázek 15: Zápis jediného pixelu vede k&nbsp;překreslení osmice sousedících pixelů.</i></p>

*** image ***
<p><i>Obrázek 16: Zápis jediného pixelu vede k&nbsp;překreslení osmice sousedících pixelů.</i></p>

<p>Pro úplnost si ukažme celý zdrojový kód takto upraveného demonstračního
příkladu:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
start:
        call fill_in_screen      <i>; vyplnění obrazovky ASCII tabulkami</i>
&nbsp;
        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
loop:
        call plot                <i>; vykreslení pixelu</i>
        call delay
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, loop              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
finito:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
delay:
        <i>; zpožďovací rutina</i>
        <i>; nemění žádné registry</i>
        push bc                  <i>; uschovat hodnoty registrů, které se používají ve smyčkách</i>
        ld   b, 20               <i>; počitadlo vnější zpožďovací smyčky</i>
outer_loop:
        ld   c, 0                <i>; počitadlo vnitřní zpožďovací smyčky</i>
inner_loop:
        dec  c                   <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr   NZ, inner_loop      <i>; opakovat, dokud není dosaženo nuly</i>
        djnz outer_loop          <i>; opakovat vnější smyčku, nyní s počitadlem v B</i>
        pop  bc                  <i>; obnovit hodnoty registrů změněných smyčkami</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
plot:
        <i>; druhá varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld (hl), a               <i>; zápis hodnoty pixelu</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
calc_pixel_value:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; A - hodnota pixelu</i>
        push bc                  <i>; zapamatovat si hodnotu v registru B</i>
        ld   a, b                <i>; A: X7 X6 X5 X4 X3 X2 X1 X0 </i>
        and  %00000111           <i>; A: 0  0  0  0  0  X2 X1 X0</i>
        ld b, a                  <i>; počitadlo smyčky (neměníme příznaky)</i>
        ld a, %10000000          <i>; výchozí maska (neměníme příznaky)</i>
        jr z, end_calc           <i>; pokud je nyní souřadnice nulová, zapíšeme výchozí masku + konec</i>
&nbsp;
next_shift:
        srl a                    <i>; posunout masku doprava</i>
        djnz next_shift          <i>; 1x až 7x</i>
end_calc:
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
calc_pixel_address:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis pixelu</i>
        <i>;</i>
        <i>; pozměněné registry:</i>
        <i>; A</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y7 Y6 Y2 Y1 Y0 | Y5 Y4 Y3 X4 X3 X2 X1 X0</i>
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (Y2 Y1 Y0)</i>
                              <i>; A: 0 0 0 0 0 Y2 Y1 Y0</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; část horního bajtu adresy je vypočtena</i>
                              <i>; H: 0 1 0 0 0 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> Y1 Y0 xx Y7 Y6 Y5 Y4 Y3</i>
        and %00011000         <i>; zamaskovat</i>
                              <i>; A: 0  0  0 Y7 Y6  0  0  0</i>
        or  h                 <i>; a přidat k vypočtenému mezivýsledku</i>
        ld  h, a              <i>; H: 0  1  0 Y7 Y6 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rla
        rla                   <i>; A:  Y5 Y4 Y3 Y2 Y1 Y0 xx xx</i>
        and %11100000         <i>; A:  Y5 Y4 Y3 0  0  0  0  0</i>
        ld  l, a              <i>; část spodního bajtu adresy je vypočtena</i>
&nbsp;
        ld  a, b              <i>; všech osm bitů X-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> 0  0  0  X7 X6 X5 X4</i>
        and %00011111         <i>; A: 0  0  0  X7 X6 X5 X4 X3</i>
        or  l                 <i>; A: Y5 Y3 Y3 X7 X6 X5 X4 X3</i>
        ld  l, a              <i>; spodní bajt adresy je vypočten</i>
&nbsp;
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
fill_in_screen:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR        <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
draw_ascii_table:
        <i>; Vytištění ASCII tabulky</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
next_char:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
draw_char:
        <i>; Vytištění jednoho znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
loop2:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop2               <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Korektní zápis masky pixelu tak, aby nedošlo ke smazání pozadí</h2>

<p>Původní algoritmus příkazu <strong>PLOT</strong> nejprve zjistil adresu, na
kterou se má zapsat bitová maska a následně tuto bitovou masku vypočítal.
Následně se <i>celá</i> bitová maska uložila na vypočtenou adresu, což ovšem
znamenalo, že se vždy nastavil (na barvu inkoustu) jediný pixel z&nbsp;celé
osmice, zatímco ostatních sedm pixelů bylo smazáno na barvu papíru. Toto
&bdquo;vykreslení+smazání&ldquo; je realizováno instrukcí <strong>ld (hl),
a</strong>:</p>

<pre>
<strong>plot</strong>:
        <i>; druhá varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call <strong>calc_pixel_address</strong>  <i>; výpočet adresy pixelu</i>
        call <strong>calc_pixel_value</strong>    <i>; výpočet ukládané hodnoty</i>
        ld (hl), a               <i>; zápis hodnoty pixelu</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p>My ovšem musíme provést odlišnou operaci &ndash; vykreslení jediného pixelu,
tj.&nbsp;zápis (resp.&nbsp;modifikaci) jediného bitu z&nbsp;celé osmice. Tuto
operaci lze realizovat relativně snadno:</p>

<ol>
<li>Načtení původní hodnoty všech osmi bitů z&nbsp;obrazové paměti</li>
<li>Aplikace vypočtené bitové masky operací <strong>or</strong> (ta v&nbsp;našem případě nastaví jediný bit)</li>
<li>Uložení vypočtené nové hodnoty všech osmi bitů do obrazové paměti</li>
</ol>

<p>Upravený kód bude vypadat takto:</p>

<pre>
<strong>plot</strong>:
        <i>; třetí varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld d, (hl)               <i>; přečíst původní hodnotu osmice pixelů</i>
        or d                     <i>; použít vypočtenou masku pro nastavení jediného bitu</i>
        ld (hl), a               <i>; zápis hodnoty pixelu (ostatních sedm pixelů se nezmění)</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p>Výsledky již mluví za vše:</p>

*** image ***
<p><i>Obrázek 17: Nyní se pixely správně překreslují přes pozadí.</i></p>

*** image ***
<p><i>Obrázek 18: Nyní se pixely správně překreslují přes pozadí.</i></p>

*** image ***
<p><i>Obrázek 19: Nyní se pixely správně překreslují přes pozadí.</i></p>

*** image ***
<p><i>Obrázek 20: Nyní se pixely správně překreslují přes pozadí.</i></p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti ještě budeme muset
zajistit vykreslení pixelu barvou pozadí (papíru).</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úplný zdrojový kód dnešního posledního demonstračního příkladu</h2>

<p>Úplný zdrojový kód opraveného demonstračního příkladu s&nbsp;úpravou
popsanou <a href="#k16">v&nbsp;předchozí kapitole</a> je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel.asm</a>
a vypadá takto:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
start:
        call fill_in_screen      <i>; vyplnění obrazovky ASCII tabulkami</i>
&nbsp;
        ld b, 0                  <i>; x-ová souřadnice vykreslovaného pixelu</i>
        ld c, 0                  <i>; y-ová souřadnice vykreslovaného pixelu</i>
loop:
        call plot                <i>; vykreslení pixelu</i>
        call delay
        inc b                    <i>; posun na další souřadnici</i>
        inc c
        ld  a, b
        cp  192                  <i>; test na ukončení smyčky</i>
        jr nz, loop              <i>; opakovat, dokud není vykreslena celá šikmá "úsečka"</i>
finito:
        jr finito                <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
delay:
        <i>; zpožďovací rutina</i>
        <i>; nemění žádné registry</i>
        push bc                  <i>; uschovat hodnoty registrů, které se používají ve smyčkách</i>
        ld   b, 20               <i>; počitadlo vnější zpožďovací smyčky</i>
outer_loop:
        ld   c, 0                <i>; počitadlo vnitřní zpožďovací smyčky</i>
inner_loop:
        dec  c                   <i>; snížení hodnoty počitadla (v první iteraci 256->255)</i>
        jr   NZ, inner_loop      <i>; opakovat, dokud není dosaženo nuly</i>
        djnz outer_loop          <i>; opakovat vnější smyčku, nyní s počitadlem v B</i>
        pop  bc                  <i>; obnovit hodnoty registrů změněných smyčkami</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
plot:
        <i>; třetí varianta podprogramu pro vykreslení pixelu</i>
        <i>;</i>
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        call calc_pixel_address  <i>; výpočet adresy pixelu</i>
        call calc_pixel_value    <i>; výpočet ukládané hodnoty</i>
        ld d, (hl)               <i>; přečíst původní hodnotu osmice pixelů</i>
        or d                     <i>; použít vypočtenou masku pro nastavení jediného bitu</i>
        ld (hl), a               <i>; zápis hodnoty pixelu (ostatních sedm pixelů se nezmění)</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
calc_pixel_value:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; A - hodnota pixelu</i>
        push bc                  <i>; zapamatovat si hodnotu v registru B</i>
        ld   a, b                <i>; A: X7 X6 X5 X4 X3 X2 X1 X0 </i>
        and  %00000111           <i>; A: 0  0  0  0  0  X2 X1 X0</i>
        ld b, a                  <i>; počitadlo smyčky (neměníme příznaky)</i>
        ld a, %10000000          <i>; výchozí maska (neměníme příznaky)</i>
        jr z, end_calc           <i>; pokud je nyní souřadnice nulová, zapíšeme výchozí masku + konec</i>
&nbsp;
next_shift:
        srl a                    <i>; posunout masku doprava</i>
        djnz next_shift          <i>; 1x až 7x</i>
end_calc:
        pop bc                   <i>; obnovit hodnotu v registru B</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
calc_pixel_address:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (v pixelech)</i>
        <i>; C - y-ová souřadnice (v pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis pixelu</i>
        <i>;</i>
        <i>; pozměněné registry:</i>
        <i>; A</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y7 Y6 Y2 Y1 Y0 | Y5 Y4 Y3 X4 X3 X2 X1 X0</i>
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (Y2 Y1 Y0)</i>
                              <i>; A: 0 0 0 0 0 Y2 Y1 Y0</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; část horního bajtu adresy je vypočtena</i>
                              <i>; H: 0 1 0 0 0 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> Y1 Y0 xx Y7 Y6 Y5 Y4 Y3</i>
        and %00011000         <i>; zamaskovat</i>
                              <i>; A: 0  0  0 Y7 Y6  0  0  0</i>
        or  h                 <i>; a přidat k vypočtenému mezivýsledku</i>
        ld  h, a              <i>; H: 0  1  0 Y7 Y6 Y2 Y1 Y0</i>
&nbsp;
        ld  a, c              <i>; všech osm bitů Y-ové souřadnice</i>
        rla
        rla                   <i>; A:  Y5 Y4 Y3 Y2 Y1 Y0 xx xx</i>
        and %11100000         <i>; A:  Y5 Y4 Y3 0  0  0  0  0</i>
        ld  l, a              <i>; část spodního bajtu adresy je vypočtena</i>
&nbsp;
        ld  a, b              <i>; všech osm bitů X-ové souřadnice</i>
        rra
        rra
        rra                   <i>; rotace doprava -> 0  0  0  X7 X6 X5 X4</i>
        and %00011111         <i>; A: 0  0  0  X7 X6 X5 X4 X3</i>
        or  l                 <i>; A: Y5 Y3 Y3 X7 X6 X5 X4 X3</i>
        ld  l, a              <i>; spodní bajt adresy je vypočten</i>
&nbsp;
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
fill_in_screen:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR        <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
draw_ascii_table:
        <i>; Vytištění ASCII tabulky</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
next_char:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
draw_char:
        <i>; Vytištění jednoho znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
loop2:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop2               <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Ani takto rozsáhlý příklad nebude po překladu do strojového kódu nijak
závratně objemný, protože bude mít délku pouhých 143 bajtů:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:CD5880     CALL 8058
8003:0600       LD B, 00
8005:0E00       LD C, 00
8007:           label loop
8007:CD2280     CALL 8022
800A:CD1680     CALL 8016
800D:04         INC B
800E:0C         INC C
800F:78         LD A, B
8010:FEC0       CP C0
8012:20F3       JR NZ, 8007
8014:           label finito
8014:18FE       JR 8014
8016:           label delay
8016:C5         PUSH BC
8017:0614       LD B, 14
8019:           label outer_loop
8019:0E00       LD C, 00
801B:           label inner_loop
801B:0D         DEC C
801C:20FD       JR NZ, 801B
801E:10F9       DJNZ 8019
8020:C1         POP BC
8021:C9         RET
8022:           label plot
8022:CD3B80     CALL 803B
8025:CD2C80     CALL 802C
8028:56         LD D, (HL)
8029:B2         OR D
802A:77         LD (HL), A
802B:C9         RET
802C:           label calc_pixel_value
802C:C5         PUSH BC
802D:78         LD A, B
802E:E607       AND 07
8030:47         LD B, A
8031:3E80       LD A, 80
8033:2804       JR Z, 8039
8035:           label next_shift
8035:CB3F       SRL A
8037:10FC       DJNZ 8035
8039:           label end_calc
8039:C1         POP BC
803A:C9         RET
803B:           label calc_pixel_address
803B:79         LD A, C
803C:E607       AND 07
803E:F640       OR 40
8040:67         LD H, A
8041:79         LD A, C
8042:1F         RRA
8043:1F         RRA
8044:1F         RRA
8045:E618       AND 18
8047:B4         OR H
8048:67         LD H, A
8049:79         LD A, C
804A:17         RLA
804B:17         RLA
804C:E6E0       AND E0
804E:6F         LD L, A
804F:78         LD A, B
8050:1F         RRA
8051:1F         RRA
8052:1F         RRA
8053:E61F       AND 1F
8055:B5         OR L
8056:6F         LD L, A
8057:C9         RET
8058:           label fill_in_screen
8058:110040     LD DE, 4000
805B:CD6880     CALL 8068
805E:CD6880     CALL 8068
8061:CD6880     CALL 8068
8064:CD6880     CALL 8068
8067:C9         RET
8068:           label draw_ascii_table
8068:3E20       LD A, 20
806A:           label next_char
806A:F5         PUSH AF
806B:CD7A80     CALL 807A
806E:3E20       LD A, 20
8070:CD7A80     CALL 807A
8073:F1         POP AF
8074:3C         INC A
8075:FE80       CP 80
8077:20F1       JR NZ, 806A
8079:C9         RET
807A:           label draw_char
807A:01003C     LD BC, 3C00
807D:61         LD H, C
807E:6F         LD L, A
807F:29         ADD HL, HL
8080:29         ADD HL, HL
8081:29         ADD HL, HL
8082:09         ADD HL, BC
8083:0608       LD B, 08
8085:4A         LD C, D
8086:           label loop2
8086:7E         LD A, (HL)
8087:12         LD (DE), A
8088:2C         INC L
8089:14         INC D
808A:10FA       DJNZ 8086
808C:1C         INC E
808D:C8         RET Z
808E:51         LD D, C
808F:C9         RET
8090:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 808F
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<p>Výše uvedené demonstrační příklady i příklady, které již byly popsány
v&nbsp;předchozích pěti článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">3</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny/">4</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-podruhe/">5</a>],
je možné přeložit s&nbsp;využitím souboru Makefile, jehož aktuální verze vypadá
následovně (pro překlad a slinkování je použit assembler <i>Pasmo</i>):</p>

<pre>
ASSEMBLER := pasmo
&nbsp;
all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap \
    31.tap 32.tap 33.tap 34.tap 35.tap 36.tap 37.tap 38.tap 39.tap 40.tap \
    41.tap 42.tap 43.tap 44.tap 45.tap 46.tap 47.tap 48.tap 49.tap 50.tap \
    51.tap 52.tap 53.tap 54.tap 55.tap
&nbsp;
clean:
        rm -f *.tap
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 01-color-attribute.lst
&nbsp;
02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 02-blinking-attribute.lst
&nbsp;
03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 03-symbolic-names.lst
&nbsp;
04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 04-operators.lst
&nbsp;
05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 05-better-symbols.lst
&nbsp;
06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 06-tapbas-v1.lst
&nbsp;
07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 07-tapbas-v2.lst
&nbsp;
08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 08-loop.lst
&nbsp;
09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 09-loop.lst
&nbsp;
10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 10-loop.lst
&nbsp;
11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 11-loop.lst
&nbsp;
12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 12-loop.lst
&nbsp;
13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 13-loop.lst
&nbsp;
14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 14-loop.lst
&nbsp;
15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 15-loop.lst
&nbsp;
16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 16-loop.lst
&nbsp;
17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 17-loop.lst
&nbsp;
18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 18-cls.lst
&nbsp;
19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 19-print-char-call.lst
&nbsp;
20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 20-print-char-rst.lst
&nbsp;
21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 21-print-char.lst
&nbsp;
22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 22-print-all-chars.lst
&nbsp;
23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 23-print-all-chars.lst
&nbsp;
24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 24-change-color.lst
&nbsp;
25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 25-change-flash.lst
&nbsp;
26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 26-print-at.lst
&nbsp;
27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 27-print-string.lst
&nbsp;
28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 28-print-string.lst
&nbsp;
29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 29-print-colorized-string.lst
&nbsp;
30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 30-print-string-ROM.lst
&nbsp;
31.tap: 31-attributes.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 31-attributes.lst
&nbsp;
32.tap: 32-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 32-fill-in-vram.lst
&nbsp;
33.tap: 33-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 33-fill-in-vram-no-ret.lst
&nbsp;
34.tap: 34-fill-in-vram-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 34-fill-in-vram-pattern.lst
&nbsp;
35.tap: 35-slow-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 35-slow-fill-in-vram.lst
&nbsp;
36.tap: 36-slow-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 36-slow-fill-in-vram-no-ret.lst
&nbsp;
37.tap: 37-fill-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 37-fill-block.lst
&nbsp;
38.tap: 38-fill-block-with-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 38-fill-block-with-pattern.lst
&nbsp;
39.tap: 39-fill-block-optimized.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 39-fill-block-optimized.lst
&nbsp;
40.tap: 40-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 40-draw-char.lst
&nbsp;
41.tap: 41-draw-any-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 41-draw-any-char.lst
&nbsp;
42.tap: 42-block-anywhere.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 42-block-anywhere.lst
&nbsp;
43.tap: 43-block-anywhere-rrca.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 43-block-anywhere-rrca.lst
&nbsp;
44.tap: 44-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 44-better-draw-char.lst
&nbsp;
45.tap: 45-even-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 45-even-better-draw-char.lst
&nbsp;
46.tap: 46-draw-char-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 46-draw-char-at.lst
&nbsp;
47.tap: 47-draw-char-at-unrolled.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 47-draw-char-at-unrolled.lst
&nbsp;
48.tap: 48-incorrect-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 48-incorrect-print-string.lst
&nbsp;
49.tap: 49-correct-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 49-correct-print-string.lst
&nbsp;
50.tap: 50-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 50-ascii-table.lst
&nbsp;
51.tap: 51-plot-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 51-plot-block.lst
&nbsp;
52.tap: 52-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 52-plot-pixel.lst
&nbsp;
53.tap: 53-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 53-plot-pixel.lst
&nbsp;
54.tap: 54-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 54-plot-pixel-on-background.lst
&nbsp;
55.tap: 55-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 55-plot-pixel-on-background.lst
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>31-attributes.asm</td><td>modifikace atributů pro tisk řetězce subrutinou uloženou v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a></td></tr>
<tr><td>32</td><td>32-fill-in-vram.asm</td><td>vyplnění celé bitmapy barvou popředí, návrat do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a></td></tr>
<tr><td>33</td><td>33-fill-in-vram-no-ret.asm</td><td>vyplnění celé bitmapy barvou popředí, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>34</td><td>34-fill-in-vram-pattern.asm</td><td>vyplnění celé bitmapy zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a></td></tr>
<tr><td>35</td><td>35-slow-fill-in-vram.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a></td></tr>
<tr><td>36</td><td>36-slow-fill-in-vram-no-ret.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>37</td><td>37-fill-block.asm</td><td>vykreslení bloku 8&times;8 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a></td></tr>
<tr><td>38</td><td>38-fill-block-with-pattern.asm</td><td>vykreslení bloku 8&times;8 pixelů zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a></td></tr>
<tr><td>39</td><td>39-fill-block-optimized.asm</td><td>optimalizace předchozího příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a></td></tr>
<tr><td>40</td><td>40-draw-char.asm</td><td>vykreslení znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a></td></tr>
<tr><td>41</td><td>41-draw-any-char.asm</td><td>podprogram pro vykreslení libovolně zvoleného znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a></td></tr>
<tr><td>42</td><td>42-block-anywhere.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>43-block-anywhere-rrca.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm</a></td></tr>
<tr><td>44</td><td>44-better-draw-char.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm</a></td></tr>
<tr><td>45</td><td>45-even-better-draw-char.asm</td><td>posun offsetu pro vykreslení dalšího znaku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm</a></td></tr>
<tr><td>46</td><td>46-draw-char-at.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm</a></td></tr>
<tr><td>47</td><td>47-draw-char-at-unrolled.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm</a></td></tr>
<tr><td>48</td><td>48-incorrect-print-string.asm</td><td>tisk řetězce, nekorektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm</a></td></tr>
<tr><td>49</td><td>49-correct-print-string.asm</td><td>tisk řetězce, korektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>50-ascii-table.asm</td><td>tisk několika bloků ASCII tabulky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm</a></td></tr>
<tr><td>51</td><td>51-plot-block.asm</td><td>vykreslení pixelu verze 1: zápis celého bajtu na pozici pixelu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm</a></td></tr>
<tr><td>52</td><td>52-plot-pixel.asm</td><td>vykreslení pixelu verze 2: korektní vykreslení jednoho pixelu, ovšem překreslení celého bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm</a></td></tr>
<tr><td>53</td><td>53-plot-pixel.asm</td><td>vykreslení pixelu verze 3: vylepšená verze předchozího demonstračního příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm</a></td></tr>
<tr><td>54</td><td>54-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (nekorektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm</a></td></tr>
<tr><td>55</td><td>55-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (korektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>56</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech demonstračních příkladů do podoby obrazu magnetické pásky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>The system variables<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html</a>
</li>

<li>ZX Spectrum manual: chapter #17 Graphics<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

