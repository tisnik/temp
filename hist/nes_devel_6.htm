<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vývoj her pro herní konzoli NES: čtení ovladače, pohyb spritů a rutina VBLANK</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vývoj her pro herní konzoli NES: čtení ovladače, pohyb spritů a rutina VBLANK</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V šesté části seriálu o vývoji her a multimediálních dem určených pro slavnou a v mnoha ohledech přelomovou osmibitovou herní konzoli Nintendo Entertainment System (NES) si ukážeme, jak lze číst stav tlačítek herního ovladače a jak lze pomocí tohoto ovladače pohybovat sprity na obrazovce.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vývoj her pro herní konzoli NES: čtení ovladače, pohyb spritů a rutina VBLANK</a></p>
<p><a href="#k02">2. Ovládání her na osmibitových počítačích a herních konzolích</a></p>
<p><a href="#k03">3. Posuvný registr v&nbsp;ovladačích NESu</a></p>
<p><a href="#k04">4. Čtení stavu tlačítek na ovladačích NESu</a></p>
<p><a href="#k05">5. Programový test stavu tlačítek</a></p>
<p><a href="#k06">6. Posun spritu s&nbsp;využitím ovladače</a></p>
<p><a href="#k07">7. Rutina VBLANK</a></p>
<p><a href="#k08">8. Praktická realizace posunu spritu</a></p>
<p><a href="#k09">9. Úplný zdrojový kód dnešního prvního demonstračního příkladu</a></p>
<p><a href="#k10">10. Assembler se překládal jako JSA &ndash; Jazyk Symbolických Adres</a></p>
<p><a href="#k11">11. Úplný zdrojový kód dnešního druhého demonstračního příkladu</a></p>
<p><a href="#k12">12. Podpůrná makra <strong>increment</strong> a <strong>decrement</strong></a></p>
<p><a href="#k13">13. Úplný zdrojový kód dnešního třetího demonstračního příkladu</a></p>
<p><a href="#k14">14. MOS 6502 není RISCovým procesorem aneb síla instrukcí <strong>INC</strong> a <strong>DEC</strong></a></p>
<p><a href="#k15">15. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</a></p>
<p><a href="#k16">16. Přesun všech osmi spritů tvořících figurku Maria</a></p>
<p><a href="#k17">17. Trik &ndash; aritmetické operace s&nbsp;registrem X</a></p>
<p><a href="#k18">18. Úplný zdrojový kód dnešního pátého demonstračního příkladu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vývoj her pro herní konzoli NES: čtení ovladače, pohyb spritů a rutina VBLANK</h2>

<p>V&nbsp;(mini)seriálu o vývoji her a multimediálních dem určených pro slavnou
a v mnoha ohledech přelomovou osmibitovou herní konzoli Nintendo Entertainment
System (NES) jsme si již ukázali, jak má vlastně vypadat kostra hry či dema
napsaného v&nbsp;assembleru, konkrétně v&nbsp;assembleru <strong>ca65</strong>.
Taktéž již máme základní informace nutné pro přehrání zvuků a hudby a umíme na
obrazovku vykreslit 64 spritů, každý z&nbsp;nich s&nbsp;rozlišením 8&times;8
pixelů. Dalším krokem bude rozhýbání celé zobrazené scény. Začneme skutečně tím
nejtriviálnějším příkladem, konkrétně ukázkou a vysvětlením, jakým způsobem je
možné pohybovat spritem po obrazovce s&nbsp;využitím standardního ovladače NESu
(ten má namísto joysticku D-pad). Budeme se tedy muset naučit hned několik
věcí:</p>

<ol>
<li>Přečtení stavu tlačítek ovladače (to není zcela triviální)</li>
<li>Změnu pozice spritu (a práce s&nbsp;příznakem přetečení)</li>
<li>Zajištění, že se sprite bude po obrazovce pohybovat konstantní rychlostí</li>
<li>Zajištění pohybu celé postavičky (Maria), která je složena z&nbsp;osmi spritů</li>
</ol>

<p>Příklady, které budou ukázány v&nbsp;navazujících kapitolách, jsou založeny
na příkladu <p><a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example13.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example13.asm</a>,
jenž dokáže na obrazovce zobrazit postavičku Maria. Všechny části tohoto
příkladu jsme si již vysvětlili v&nbsp;předchozích článcích:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Nastavení barvové palety, zvýšení intenzity barvy</i>
<i>; Setup PPU přes makro</i>
<i>; Definice spritu a zobrazení spritů s Mariem</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Taktéž založeno na https://nerdy-nights.nes.science/#main_tutorial-3</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
PPUADDR         = $2006
PPUDATA         = $2007
DMC_FREQ        = $4010
OAM_DMA         = $4014
&nbsp;
<i>; Další důležité adresy</i>
PALETTE         = $3f00
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -&gt; 0x00 konec smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro ppu_data_palette_address</strong>
        lda PPUSTATUS   <i>; reset záchytného registru</i>
        lda #&gt;PALETTE   <i>; nastavení adresy pro barvovou paletu $3f00</i>
        sta PPUADDR
        lda #&lt;PALETTE   <i>; nižší bajt adresy</i>
        sta PPUADDR
<strong>.endmacro</strong>
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 2
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp;
.segment "ZEROPAGE"
.segment "STARTUP"
.segment "CODE"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
.code
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
<strong>.proc nmi</strong>
        lda #$02                <i>; horní bajt adresy pro přenos + zahájení přenosu</i>
        sta OAM_DMA
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
<strong>.proc irq</strong>
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ            <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017               <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        <i>; nastavení barvové palety</i>
        jsr load_palette  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; nastavení spritů</i>
        jsr load_sprites  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; vynulování barvové palety</i>
<strong>.proc clear_palette</strong>
        ppu_data_palette_address
&nbsp;
        ldx #$20        <i>; počitadlo barev v paletě: 16+16</i>
        lda #$00        <i>; vynulování každé barvy</i>
&nbsp;
:
        sta PPUDATA     <i>; zápis barvy</i>
        dex             <i>; snížení hodnoty počitadla</i>
        bne :-
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; nastavení barvové palety</i>
<strong>.proc load_palette</strong>
        ppu_data_palette_address
&nbsp;
        <i>; $3f00-$3f0f - paleta pozadí</i>
        <i>; $3f10-$3f1f - paleta spritů</i>
&nbsp;
        ldx #$00        <i>; vynulovat počitadlo a offset</i>
&nbsp;
:
        lda palette, x  <i>; načíst bajt s offsetem</i>
        sta PPUDATA     <i>; zápis barvy do PPU</i>
        inx             <i>; zvýšit počitadlo/offset</i>
        cpx #32         <i>; limit počtu barev</i>
        bne :-          <i>; opakovat smyčku 32x</i>
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; načtení spritů</i>
<strong>.proc load_sprites</strong>
        ldx #0            <i>; vynulování počitadla</i>
:
        lda spritedata,X  <i>; budeme přesouvat data z této oblasti</i>
        sta $0200,X       <i>; uložení do paměti spritů</i>
        inx               <i>; zvýšení hodnoty počitadla</i>
        cpx #32           <i>; každý sprite má 4 bajty: y-coord, tile, attributy, y-coord * 8 spritů = 32</i>
        bne :-
&nbsp;
        cli               <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10000000      
        sta PPUCTRL       <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
&nbsp;
        lda #%00010000    <i>; povolení zobrazení spritů</i>
        sta PPUMASK
&nbsp;
        rts               <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; samotná barvová paleta</i>
<strong>palette</strong>:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
&nbsp;
<i>; data pro osm spritů</i>
<strong>spritedata</strong>:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
.segment "CHARS"
    .incbin "mario.chr"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Ovládání her na osmibitových počítačích a herních konzolích</h2>

<p>Na většině klasických osmibitových počítačích a herních konzolích se setkáme
s&nbsp;možností připojení standardních ovladačů, typicky joysticků (výjimkou je
ZX Spectrum, kde původně standard neexistoval, takže &bdquo;standardů&ldquo;
vzniklo více &ndash; odtud nabídka různých typů ovládání v&nbsp;prakticky každé
hře pro Speccy). Typické dobové joysticky byla jednoduchá zařízení &ndash;
čtyři (mikro)spínače sloužily pro určení směru (náklonu) joysticku; dále byl
joystick vybaven jedním nebo dvěma tlačítky, která měla buď stejnou funkci
(paralelní zapojení), nebo dvě funkce. Těchto pět resp.&nbsp;šest tlačítek bylo
připojeno přímo k&nbsp;počítači &bdquo;paralelním&ldquo; způsobem &ndash; každé
tlačítko na samostatný pin k&nbsp;tomu určeného konektoru. Programátor tak
typicky mohl načtením jednoho osmibitového registru najednou získat informaci o
stavu všech tlačítek.</p>

<img src="https://i.iinfo.cz/images/388/nes-devel-6-1.jpg" class="image-579692" alt="&#160;" title="Autor: Wikipedia, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="400" height="400" />
<p><i>Obrázek 1: Atari joystick a způsob jeho zapojení byl svým způsobem
standardem.</i></p>

<p><div class="rs-tip-major">Poznámka: některé joysticky podporovaly
automatickou střelbu, což ovšem bylo řešeno přímo elektronikou v&nbsp;joysticku
&ndash; navenek se stále jednalo o rychle mačkané tlačítko.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Posuvný registr v&nbsp;ovladačích NESu</h2>

<p>Ovladač pro herní konzoli NES vypadá odlišně než klasický joystick. Najdeme
zde D-pad pro určení čtyř směrů (nebo jejich kombinací) a taktéž čtveřici
tlačítek označených Select, Start, A a B:</p>

<img src="https://i.iinfo.cz/images/388/nes-devel-6-2.jpg" class="image-579693" alt="&#160;" title="Autor: Wikipedia, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="400" height="246" />
<p><i>Obrázek 2: Ovladač pro herní konzoli NES.</i></p>

<p>Mohlo by se tedy zdát, že všech osm tlačítek (čtyři na D-padu, čtyři
ostatní) budou vyvedeny na konektor ve formě osmi samostatných pinů. Ve
skutečnosti tomu tak není, protože v&nbsp;ovladači je posuvný registr (<i>shift
register</i>) který na základě signálu z&nbsp;konzole (<i>latch</i>) zaznamená
stav všech osmi tlačítek. Poté je nutné tyto informace postupně
z&nbsp;posuvného registru vysunout, a to bit po bitu &ndash; přenos je tedy
sériový. Programátor musí sám zajistit jak signál <i>latch</i>, tak i postupné
načtení osmi bitů z&nbsp;posuvného registru (což není těžké).</p>

<p><div class="rs-tip-major">Poznámka: bližší informace o ovladačích NESu lze
najít například na stránkách <a
href="https://www.allaboutcircuits.com/uploads/articles/nes-controller-arduino.png?v=1469416980041">NES
Controller Shift Register</a> a <a
href="https://pinoutguide.com/Game/NES_controller_pinout.shtml">NES (Nintendo
Entertainment System) controller pinout</a></div>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Čtení stavu tlačítek na ovladačích NESu</h2>

<p>Vlastní realizace čtení stavu tlačítek na ovladačích NESu není ve
skutečnosti nijak složitá. Čtení lze provádět pro oba ovladače zvlášť; přitom
si vystačíme s&nbsp;pouhými dvěma osmibitovými řídicími registry na adresách
$4016 a $4017 (znak $ označuje hexadecimální konstanty):</p>

<pre>
<i>; Ovladače</i>
JOYPAD1         = $4016
JOYPAD2         = $4017
</pre>

<p>Před čtením stavu tlačítek musíme zachytit jejich stav a uložit ho do
posuvného registru. Budeme tedy provádět <i>bit banging</i> &ndash; pomocí SW
budeme generovat řídicí signály, zde konkrétně signál <i>latch</i>:</p>

<pre>
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
</pre>

<p>Nyní již můžeme postupně přečíst stav jednotlivých tlačítek v&nbsp;pořadí,
které naznačuje následující kód. Pořadí nelze změnit (je dáno pořadím bitů
v&nbsp;posuvném registru):</p>

<pre>
        lda JOYPAD1        <i>; stav tlačítka A jen načteme a ingorujeme</i>
        ...
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka B jen načteme a ingorujeme</i>
        ...
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Select jen načteme a ingorujeme</i>
        ...
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
        ...
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Up</i>
        ...
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Down</i>
        ...
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Left</i>
        ...
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Right</i>
        ...
</pre>

<p><div class="rs-tip-major">Poznámka: stejnou operaci lze použít i pro druhý
ovladač.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Programový test stavu tlačítek</h2>

<p>Hodnota přečtená instrukcí <strong>LDA</strong> do akumulátoru má
pochopitelně osm bitů. Horních sedm bitů obsahují další (pro nás prozatím
nerelevantní) informace, takže jediným bitem, který nás zajímá, je nejnižší bit
akumulátoru. Jeho stav lze otestovat mnoha způsoby &ndash; vysunutím/rotací do
<strong>carry</strong>, maskováním a zjištěním příznaku <strong>zero</strong>,
odečtením jedničky a zjištěním příznaku <strong>zero</strong> atd. Podívejme se
na nejpřímější (i když ne nejrychlejší) způsob &ndash; maskování. Horních sedm
bitů akumulátoru zamaskujeme (vynulujeme) instrukcí <strong>AND</strong>, která
automaticky nastaví příznak <strong>zero</strong> v&nbsp;případě, že je nový
obsah akumulátoru nulový (a tedy tlačítko není stisknuto). Tento stav následně
využijeme v&nbsp;podmíněném skoku <strong>BEQ</strong> (<i>branch if equal</i>
== <i>branch if zero flag is set</i>):</p>

<pre>
        lda JOYPAD1        <i>; stav tlačítka Up</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq up_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        <i>; instrukce provedené v případě, že je tlačítko stisknuto</i>
&nbsp;
up_not_pressed:
&nbsp;
        <i>; pokračování běhu programu</i>
&nbsp;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Posun spritu s&nbsp;využitím ovladače</h2>

<p>Nyní si ukažme, jak je možné provést posun spritu (prozatím jediného spritu,
tedy bloku 8&times;8 pixelů) s&nbsp;využitím ovladače. Logika je vlastně velmi
jednoduchá, protože metainformace o spritech &ndash; jejich tvaru (bitmapě),
pozici, indexu barvové palety máme zkopírovány z&nbsp;paměti ROM do paměti RAM,
konkrétně ve druhé stránce paměti, tedy od adresy $0200. Deklarace tvaru a
pozice prvních osmi spritů vypadá následovně:</p>

<pre>
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
</pre>

<p>Těchto osm spritů vytvoří obrázek Maria:</p>

<img src="https://i.iinfo.cz/images/54/nes-devel-5-1.png" class="image-579467" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="89" height="129" />
<p><i>Obrázek 3: Postavička Maria vykreslená z&nbsp;osmi spritů.</i></p>

<p>Tato postavička je složena, jak již ostatně velmi dobře víme, z&nbsp;osmi
spritů, z&nbsp;nichž každý má rozměry 8&times;8 pixelů:</p>

<img src="https://i.iinfo.cz/images/54/nes-devel-5-2.png" class="image-579468" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="89" height="139" />
<p><i>Obrázek 4: Postavička Maria je ve skutečnosti složená z&nbsp;osmi
spritů.</i></p>

<p>Posun prvního spritu z&nbsp;této osmice lze zajistit modifikací bajtu na
adrese $0200 (y-ová souřadnice) a $0203 (x-ová souřadnice). To je
z&nbsp;pohledu programátora vše &ndash; modifikaci pozice na obrazovce již
zajistí DMA. A kdy změnu provést &ndash; v&nbsp;rutině VBLANK!</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rutina VBLANK</h2>

<p>Jak je však možné zajistit, aby se sprite (či později celá postavička)
pohybovala po herním poli určenou konstantní rychlostí? Pro tento účel poměrně
dobře poslouží rutina VBLANK, která je zavolána automaticky ve chvíli, kdy PPU
dokončil vykreslení jednoho snímku na obrazovce. Na konci (nebo začátku)
každého snímku se nachází 21 prázdných obrazových řádků, během nichž není
prováděno vykreslování. To mj.&nbsp;znamená, že je to vhodný okamžik pro řízení
PPU (tedy &bdquo;grafického procesoru&ldquo;). A navíc je tato rutina volána
zcela pravidelně, konkrétně 25&times; za sekundu na NESu v&nbsp;systému PAL a
29.97&times; (tedy prakticky 30&times;) na NESu v&nbsp;systému NTSC. Pokud tedy
budeme stav tlačítek číst a následně modifikovat pozici spritu v&nbsp;rutině
VBLANK, bude se sprite pohybovat přesně rychlostí 25 resp. 30 pixelů za
sekundu. Je zde pochopitelně malý háček &ndash; jak rozlišit PAL od NTSC.
Některé hry běží v&nbsp;systému PAL pomaleji (tj.&nbsp;nijak tento problém
neřeší), další existují ve dvou variantách. VBLANK je zavolána automaticky,
protože informace o nadcházejícím VBLANK způsobí nemaskovatelné přerušení
(NMI).</p>

<p><div class="rs-tip-major">Poznámka: později uvidíme, že pokud není možné vše
&bdquo;ustíhat&ldquo; v&nbsp;době trvání již zmíněných 21 prázdných obrazových
řádků, bude v&nbsp;rutině VBLANK jen kód oznamující hlavnímu vláknu aplikace,
že může provést přepočet herního světa.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Praktická realizace posunu spritu</h2>

<p>Posun spritu o &pm; dva pixely (či o jinou hodnotu požadovanou
programátorem) v&nbsp;horizontálním i vertikálním směru musíme realizovat pro
každý směr zvlášť, a to následujícím způsobem:</p>

<ol>
<li>Test stavu příslušného tlačítka (Up, Down, Left, Right)</li>
<li>Pokud je tlačítko stisknuto, změní se příslušná hodnota na adrese $0200 (y-ová souřadnice) či $0203 (x-ová souřadnice)</li>
</ol>

<p>Musíme si jen dát pozor na to, že před operací <strong>ADC</strong> je nutné
vynulovat příznak <i>carry</i> a před operací <strong>SBC</strong> ho naopak
nastavit (tím se mikroprocesor MOS 6502 odlišuje od ostatních osmibitových mikroprocesorů):</p>

<p>Nejprve přečteme stav všech tlačítek do posuvného registru:</p>

<pre>
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek</i>
</pre>

<p>Následně přečteme a zapomeneme stav tlačítek A, B, Select a Start:</p>

<pre>
        lda JOYPAD1        <i>; stav tlačítka A jen načteme a ingorujeme</i>
        lda JOYPAD1        <i>; stav tlačítka B jen načteme a ingorujeme</i>
        lda JOYPAD1        <i>; stav tlačítka Select jen načteme a ingorujeme</i>
        lda JOYPAD1        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
</pre>

<p>Poté následuje čtení stavu směrových tlačítek na D-padu a modifikace x-ové
či y-ové souřadnice pixelu. Pokud je příslušné tlačítko zmáčknuto (tedy když je
vybrán směr), podmíněný skok se <i>ne</i>provede a vykoná se kód pro zvýšení či
snížení pozice spritu o &pm; 2 pixely:</p>

<pre>
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Up</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq up_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda $0200          <i>; změna y-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; y--</i>
        sta $0200          <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
up_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Down</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq down_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda $0200          <i>; změna y-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; y++</i>
        sta $0200          <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
down_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Left</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq left_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda $0203          <i>; změna x-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; x--</i>
        sta $0203          <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
left_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Right</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq right_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda $0203          <i>; změna x-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; x--</i>
        sta $0203          <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
right_not_pressed:
</pre>

<img src="https://i.iinfo.cz/images/388/nes-devel-6-3.png" class="image-579694" alt="&#160;" title="Autor: Wikipedia, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="126" height="132" />
<p><i>Obrázek 5: Posun jediného spritu (8&times;8 pixelů) ve scéně.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód dnešního prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu (v&nbsp;pořadí
již sedmnáctého příkladu pro NES) je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example17.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example17.asm</a>.
Pro překlad a slinkování tohoto příkladu je zapotřebí i <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">Makefile</a>
a příkaz <strong>make example17.nes</strong>:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Nastavení barvové palety, zvýšení intenzity barvy</i>
<i>; Setup PPU přes makro</i>
<i>; Definice spritu a zobrazení spritů s rozloženým Mariem. Pohyb spritu.</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Taktéž založeno na https://nerdy-nights.nes.science/#main_tutorial-3</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
PPUADDR         = $2006
PPUDATA         = $2007
DMC_FREQ        = $4010
OAM_DMA         = $4014
&nbsp;
<i>; Další důležité adresy</i>
PALETTE         = $3f00
&nbsp;
<i>; Ovladače</i>
JOYPAD1         = $4016
JOYPAD2         = $4017
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -&gt; 0x00 konec smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro ppu_data_palette_address</strong>
        lda PPUSTATUS   <i>; reset záchytného registru</i>
        lda #&gt;PALETTE   <i>; nastavení adresy pro barvovou paletu $3f00</i>
        sta PPUADDR
        lda #&lt;PALETTE   <i>; nižší bajt adresy</i>
        sta PPUADDR
<strong>.endmacro</strong>
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 2
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp;
.segment "ZEROPAGE"
.segment "STARTUP"
.segment "CODE"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
.code
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
<strong>.proc nmi</strong>
        lda #$02           <i>; horní bajt adresy pro přenos + zahájení přenosu</i>
        sta OAM_DMA
&nbsp;
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
                           <i>; </i>
                           <i>; 1) A                      </i>
                           <i>; 2) B                      </i>
                           <i>; 3) Select                 </i>
                           <i>; 4) Start                  </i>
                           <i>; 5) Up                     </i>
                           <i>; 6) Down                   </i>
                           <i>; 7) Left                   </i>
                           <i>; 8) Right</i>
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka A jen načteme a ingorujeme</i>
        lda JOYPAD1        <i>; stav tlačítka B jen načteme a ingorujeme</i>
        lda JOYPAD1        <i>; stav tlačítka Select jen načteme a ingorujeme</i>
        lda JOYPAD1        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Up</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq up_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda $0200          <i>; změna y-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; y--</i>
        sta $0200          <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
up_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Down</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq down_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda $0200          <i>; změna y-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; y++</i>
        sta $0200          <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
down_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Left</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq left_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda $0203          <i>; změna x-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; x--</i>
        sta $0203          <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
left_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Right</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq right_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda $0203          <i>; změna x-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; x--</i>
        sta $0203          <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
right_not_pressed:
&nbsp;
        rti                <i>; návrat z přerušení</i>
&nbsp;
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
<strong>.proc irq</strong>
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ            <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017               <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        <i>; nastavení barvové palety</i>
        jsr load_palette  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; nastavení spritů</i>
        jsr load_sprites  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; vynulování barvové palety</i>
<strong>.proc clear_palette</strong>
        ppu_data_palette_address
&nbsp;
        ldx #$20        <i>; počitadlo barev v paletě: 16+16</i>
        lda #$00        <i>; vynulování každé barvy</i>
&nbsp;
:
        sta PPUDATA     <i>; zápis barvy</i>
        dex             <i>; snížení hodnoty počitadla</i>
        bne :-
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; nastavení barvové palety</i>
<strong>.proc load_palette</strong>
        ppu_data_palette_address
&nbsp;
        <i>; $3f00-$3f0f - paleta pozadí</i>
        <i>; $3f10-$3f1f - paleta spritů</i>
&nbsp;
        ldx #$00        <i>; vynulovat počitadlo a offset</i>
&nbsp;
:
        lda palette, x  <i>; načíst bajt s offsetem</i>
        sta PPUDATA     <i>; zápis barvy do PPU</i>
        inx             <i>; zvýšit počitadlo/offset</i>
        cpx #32         <i>; limit počtu barev</i>
        bne :-          <i>; opakovat smyčku 32x</i>
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; načtení spritů</i>
<strong>.proc load_sprites</strong>
        ldx #0
:
        lda spritedata,X  <i>; budeme přesouvat data z této oblasti</i>
        sta $0200,X       <i>; uložení do paměti spritů</i>
        inx               <i>; zvýšení hodnoty počitadla</i>
        cpx #32           <i>; každý sprite má 4 bajty: y-coord, tile, attributy, y-coord * 8 spritů = 32</i>
        bne :-
&nbsp;
        cli               <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10000000      
        sta PPUCTRL       <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
&nbsp;
        lda #%00010000    <i>; povolení zobrazení spritů</i>
        sta PPUMASK
&nbsp;
        rts               <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; samotná barvová paleta</i>
palette:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
&nbsp;
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
.segment "CHARS"
    .incbin "mario.chr"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Assembler se překládal jako JSA &ndash; Jazyk Symbolických Adres</h2>

<p>V&nbsp;češtině se namísto pojmu <i>assembler</i> používal název &bdquo;<a
href="https://cs.wikipedia.org/wiki/Jazyk_symbolick%C3%BDch_adres">Jazyk
Symbolických Adres</a>&ldquo; neboli JSA. Ovšem v&nbsp;předchozím kódu jsme
přímo používali adresy $0203 a $0200 v&nbsp;jejich numerické podobě, což je
zbytečně nízkoúrovňové. V&nbsp;assembleru/JSA máme možnost si tyto adresy
pojmenovat, což může vést ke zpřehlednění kódu (v&nbsp;tomto ohledu je
assembler na vyšší úrovni abstrakce, než například BASIC):</p>

<pre>
        XPOS = $0203       <i>; adresa buňky paměti s x-ovou souřadnicí spritu</i>
        YPOS = $0200       <i>; adresa buňky paměti y x-ovou souřadnicí spritu</i>
</pre>

<p>Nyní mohou být tyto magické konstanty v&nbsp;kódu nahrazeny jménem:</p>

<pre>
        lda JOYPAD1        <i>; stav tlačítka Up</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq up_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda YPOS           <i>; změna y-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; y--</i>
        sta YPOS           <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
up_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Down</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq down_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda YPOS           <i>; změna y-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; y++</i>
        sta YPOS           <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
down_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Left</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq left_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda XPOS           <i>; změna x-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; x--</i>
        sta XPOS           <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
left_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Right</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq right_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda XPOS           <i>; změna x-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; x--</i>
        sta XPOS           <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
right_not_pressed:
</pre>

<p><div class="rs-tip-major">Poznámka: nic nám nebrání jít ještě dále a
nahradit i další magické konstanty vhodnými symboly:</div></p>

<pre>
        XPOS = $0203       <i>; adresa buňky paměti s x-ovou souřadnicí spritu</i>
        YPOS = $0200       <i>; adresa buňky paměti y x-ovou souřadnicí spritu</i>
&nbsp;
        BUTTON_MASK = %00000001
        STEP = $02
</pre>

<p>V&nbsp;kódu je stále nutné rozlišovat mezi hodnotou a adresou (u hodnoty je
uveden znak #):</p>

<pre>
        lda JOYPAD1        <i>; stav tlačítka Up</i>
        and #BUTTON_MASK   <i>; maskovat všechny bity kromě prvního</i>
        beq up_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        lda YPOS           <i>; změna y-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #STEP          <i>; y--</i>
        sta YPOS           <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
up_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Down</i>
        and #BUTTON_MASK   <i>; maskovat všechny bity kromě prvního</i>
        beq down_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        lda YPOS           <i>; změna y-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #STEP          <i>; y++</i>
        sta YPOS           <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
down_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Left</i>
        and #BUTTON_MASK   <i>; maskovat všechny bity kromě prvního</i>
        beq left_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda XPOS           <i>; změna x-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #STEP          <i>; x--</i>
        sta XPOS           <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
left_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Right</i>
        and #BUTTON_MASK   <i>; maskovat všechny bity kromě prvního</i>
        beq right_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda XPOS           <i>; změna x-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #STEP          <i>; x--</i>
        sta XPOS           <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
right_not_pressed:
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Úplný zdrojový kód dnešního druhého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu (v&nbsp;pořadí
již osmnáctého příkladu pro NES) je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example18.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example18.asm</a>.
Pro překlad a slinkování tohoto příkladu je zapotřebí i <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">Makefile</a>
a příkaz <strong>make example18.nes</strong>:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Nastavení barvové palety, zvýšení intenzity barvy</i>
<i>; Setup PPU přes makro</i>
<i>; Definice spritu a zobrazení spritů s rozloženým Mariem. Pohyb spritu.</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Taktéž založeno na https://nerdy-nights.nes.science/#main_tutorial-3</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
PPUADDR         = $2006
PPUDATA         = $2007
DMC_FREQ        = $4010
OAM_DMA         = $4014
&nbsp;
<i>; Další důležité adresy</i>
PALETTE         = $3f00
&nbsp;
<i>; Ovladače</i>
JOYPAD1         = $4016
JOYPAD2         = $4017
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -&gt; 0x00 konec smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro ppu_data_palette_address</strong>
        lda PPUSTATUS   <i>; reset záchytného registru</i>
        lda #&gt;PALETTE   <i>; nastavení adresy pro barvovou paletu $3f00</i>
        sta PPUADDR
        lda #&lt;PALETTE   <i>; nižší bajt adresy</i>
        sta PPUADDR
<strong>.endmacro</strong>
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 2
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp;
.segment "ZEROPAGE"
.segment "STARTUP"
.segment "CODE"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
.code
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
<strong>.proc nmi</strong>
        lda #$02           <i>; horní bajt adresy pro přenos + zahájení přenosu</i>
        sta OAM_DMA
&nbsp;
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
                           <i>; </i>
                           <i>; 1) A                      </i>
                           <i>; 2) B                      </i>
                           <i>; 3) Select                 </i>
                           <i>; 4) Start                  </i>
                           <i>; 5) Up                     </i>
                           <i>; 6) Down                   </i>
                           <i>; 7) Left                   </i>
                           <i>; 8) Right</i>
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka A jen načteme a ingorujeme</i>
        lda JOYPAD1        <i>; stav tlačítka B jen načteme a ingorujeme</i>
        lda JOYPAD1        <i>; stav tlačítka Select jen načteme a ingorujeme</i>
        lda JOYPAD1        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
&nbsp;
        XPOS = $0203       <i>; adresa buňky paměti s x-ovou souřadnicí spritu</i>
        YPOS = $0200       <i>; adresa buňky paměti y x-ovou souřadnicí spritu</i>
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Up</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq up_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda YPOS           <i>; změna y-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; y--</i>
        sta YPOS           <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
up_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Down</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq down_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda YPOS           <i>; změna y-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; y++</i>
        sta YPOS           <i>; uložení nové y-ové pozice spritu</i>
&nbsp;
down_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Left</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq left_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda XPOS           <i>; změna x-ové pozice spritu</i>
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; x--</i>
        sta XPOS           <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
left_not_pressed:
&nbsp;
        lda JOYPAD1        <i>; stav tlačítka Right</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
        beq right_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        lda XPOS           <i>; změna x-ové pozice spritu</i>
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; x--</i>
        sta XPOS           <i>; uložení nové x-ové pozice spritu</i>
&nbsp;
right_not_pressed:
&nbsp;
        rti                <i>; návrat z přerušení</i>
&nbsp;
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
<strong>.proc irq</strong>
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ            <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017               <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        <i>; nastavení barvové palety</i>
        jsr load_palette  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; nastavení spritů</i>
        jsr load_sprites  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; vynulování barvové palety</i>
<strong>.proc clear_palette</strong>
        ppu_data_palette_address
&nbsp;
        ldx #$20        <i>; počitadlo barev v paletě: 16+16</i>
        lda #$00        <i>; vynulování každé barvy</i>
&nbsp;
:
        sta PPUDATA     <i>; zápis barvy</i>
        dex             <i>; snížení hodnoty počitadla</i>
        bne :-
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; nastavení barvové palety</i>
<strong>.proc load_palette</strong>
        ppu_data_palette_address
&nbsp;
        <i>; $3f00-$3f0f - paleta pozadí</i>
        <i>; $3f10-$3f1f - paleta spritů</i>
&nbsp;
        ldx #$00        <i>; vynulovat počitadlo a offset</i>
&nbsp;
:
        lda palette, x  <i>; načíst bajt s offsetem</i>
        sta PPUDATA     <i>; zápis barvy do PPU</i>
        inx             <i>; zvýšit počitadlo/offset</i>
        cpx #32         <i>; limit počtu barev</i>
        bne :-          <i>; opakovat smyčku 32x</i>
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; načtení spritů</i>
<strong>.proc load_sprites</strong>
        ldx #0
:
        lda spritedata,X  <i>; budeme přesouvat data z této oblasti</i>
        sta $0200,X       <i>; uložení do paměti spritů</i>
        inx               <i>; zvýšení hodnoty počitadla</i>
        cpx #32           <i>; každý sprite má 4 bajty: y-coord, tile, attributy, y-coord * 8 spritů = 32</i>
        bne :-
&nbsp;
        cli               <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10000000      
        sta PPUCTRL       <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
&nbsp;
        lda #%00010000    <i>; povolení zobrazení spritů</i>
        sta PPUMASK
&nbsp;
        rts               <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; samotná barvová paleta</i>
palette:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
&nbsp;
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
.segment "CHARS"
    .incbin "mario.chr"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Podpůrná makra <strong>increment</strong> a <strong>decrement</strong></h2>

<p>Předchozí kód byl zbytečně složitý, protože se v&nbsp;něm 2&times;
vyskytovala sekvence instrukcí určených pro zvýšení či naopak snížení obsahu
paměťové buňky o nějakou hodnotu. Tento kód můžeme přenést do subrutiny (tu je
nutné volat a zvětšovat tak časové nároky rutiny VBLANK) nebo do makra.
V&nbsp;tom nejjednodušším případě mohou příslušná makra vypadat takto:</p>

<pre>
<strong>.macro increment address</strong>
        lda address
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; x++</i>
        sta address
<strong>.endmacro</strong>
&nbsp;
<strong>.macro decrement address</strong>
        lda address
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; x--</i>
        sta address
<strong>.endmacro</strong>
</pre>

<p>Makra akceptují jediný parametr &ndash; adresu:</p>

<pre>
        read_button        <i>; stav tlačítka Up</i>
        beq up_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        decrement YPOS
&nbsp;
up_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Down</i>
        beq down_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        increment YPOS
&nbsp;
</pre>

<p><div class="rs-tip-major">Poznámka: bylo by zajímavější, aby makra
akceptovala i konstantu, o kterou se má hodnota paměťové buňky zvýšit či
snížit. Tuto jednoduchou úpravu ponechám na laskavém čtenáři jako malé cvičení
assembleru <strong>ca65</strong>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Úplný zdrojový kód dnešního třetího demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního třetího demonstračního příkladu (v&nbsp;pořadí
již devatenáctého příkladu pro NES) je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example19.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example19.asm</a>.
Pro překlad a slinkování tohoto příkladu je zapotřebí i <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">Makefile</a>
a příkaz <strong>make example19.nes</strong>:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Nastavení barvové palety, zvýšení intenzity barvy</i>
<i>; Setup PPU přes makro</i>
<i>; Definice spritu a zobrazení spritů s rozloženým Mariem. Pohyb spritu.</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Taktéž založeno na https://nerdy-nights.nes.science/#main_tutorial-3</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
PPUADDR         = $2006
PPUDATA         = $2007
DMC_FREQ        = $4010
OAM_DMA         = $4014
&nbsp;
<i>; Další důležité adresy</i>
PALETTE         = $3f00
&nbsp;
<i>; Ovladače</i>
JOYPAD1         = $4016
JOYPAD2         = $4017
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -&gt; 0x00 konec smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro ppu_data_palette_address</strong>
        lda PPUSTATUS   <i>; reset záchytného registru</i>
        lda #&gt;PALETTE   <i>; nastavení adresy pro barvovou paletu $3f00</i>
        sta PPUADDR
        lda #&lt;PALETTE   <i>; nižší bajt adresy</i>
        sta PPUADDR
<strong>.endmacro</strong>
&nbsp;
<strong>.macro increment address</strong>
        lda address
        clc                <i>; vynulovat přenos</i>
        adc #$02           <i>; x++</i>
        sta address
<strong>.endmacro</strong>
&nbsp;
<strong>.macro decrement address</strong>
        lda address
        sec                <i>; nastavit přenos</i>
        sbc #$02           <i>; x--</i>
        sta address
<strong>.endmacro</strong>
&nbsp;
<strong>.macro read_button</strong>
        lda JOYPAD1        <i>; stav tlačítka</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
<strong>.endmacro</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 2
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp;
.segment "ZEROPAGE"
.segment "STARTUP"
.segment "CODE"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
.code
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
<strong>.proc nmi</strong>
        lda #$02           <i>; horní bajt adresy pro přenos + zahájení přenosu</i>
        sta OAM_DMA
&nbsp;
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
                           <i>; </i>
                           <i>; 1) A                      </i>
                           <i>; 2) B                      </i>
                           <i>; 3) Select                 </i>
                           <i>; 4) Start                  </i>
                           <i>; 5) Up                     </i>
                           <i>; 6) Down                   </i>
                           <i>; 7) Left                   </i>
                           <i>; 8) Right</i>
&nbsp;
        read_button        <i>; stav tlačítka A jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka B jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Select jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
&nbsp;
        XPOS = $0203       <i>; adresa buňky paměti s x-ovou souřadnicí spritu</i>
        YPOS = $0200       <i>; adresa buňky paměti y x-ovou souřadnicí spritu</i>
&nbsp;
        read_button        <i>; stav tlačítka Up</i>
        beq up_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        decrement YPOS
&nbsp;
up_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Down</i>
        beq down_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        increment YPOS
&nbsp;
down_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Left</i>
        beq left_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        decrement XPOS
&nbsp;
left_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Right</i>
        beq right_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        increment XPOS
&nbsp;
right_not_pressed:
&nbsp;
        rti                <i>; návrat z přerušení</i>
&nbsp;
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
<strong>.proc irq</strong>
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ            <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017               <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        <i>; nastavení barvové palety</i>
        jsr load_palette  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; nastavení spritů</i>
        jsr load_sprites  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; vynulování barvové palety</i>
<strong>.proc clear_palette</strong>
        ppu_data_palette_address
&nbsp;
        ldx #$20        <i>; počitadlo barev v paletě: 16+16</i>
        lda #$00        <i>; vynulování každé barvy</i>
&nbsp;
:
        sta PPUDATA     <i>; zápis barvy</i>
        dex             <i>; snížení hodnoty počitadla</i>
        bne :-
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; nastavení barvové palety</i>
<strong>.proc load_palette</strong>
        ppu_data_palette_address
&nbsp;
        <i>; $3f00-$3f0f - paleta pozadí</i>
        <i>; $3f10-$3f1f - paleta spritů</i>
&nbsp;
        ldx #$00        <i>; vynulovat počitadlo a offset</i>
&nbsp;
:
        lda palette, x  <i>; načíst bajt s offsetem</i>
        sta PPUDATA     <i>; zápis barvy do PPU</i>
        inx             <i>; zvýšit počitadlo/offset</i>
        cpx #32         <i>; limit počtu barev</i>
        bne :-          <i>; opakovat smyčku 32x</i>
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; načtení spritů</i>
<strong>.proc load_sprites</strong>
        ldx #0
:
        lda spritedata,X  <i>; budeme přesouvat data z této oblasti</i>
        sta $0200,X       <i>; uložení do paměti spritů</i>
        inx               <i>; zvýšení hodnoty počitadla</i>
        cpx #32           <i>; každý sprite má 4 bajty: y-coord, tile, attributy, y-coord * 8 spritů = 32</i>
        bne :-
&nbsp;
        cli               <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10000000      
        sta PPUCTRL       <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
&nbsp;
        lda #%00010000    <i>; povolení zobrazení spritů</i>
        sta PPUMASK
&nbsp;
        rts               <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; samotná barvová paleta</i>
palette:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
&nbsp;
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
.segment "CHARS"
    .incbin "mario.chr"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. MOS 6502 není RISCovým procesorem aneb síla instrukcí <strong>INC</strong> a <strong>DEC</strong></h2>

<p>Původní čip MOS 6502 nabízí programátorům šestici instrukcí, které dokážou
zvýšit či snížit obsah paměťové buňky o jedničku, popř.&nbsp;zvýšit či snížit
obsah registru X či Y o jedničku:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>INC</td><td>zvýšení obsahu paměťové buňky o jedničku</td></tr>
<tr><td>DEC</td><td>snížení obsahu paměťové buňky o jedničku</td></tr>
<tr><td>INX</td><td>zvýšení obsahu index registru X o jedničku</td></tr>
<tr><td>DEX</td><td>snížení obsahu index registru X o jedničku</td></tr>
<tr><td>INY</td><td>zvýšení obsahu index registru Y o jedničku</td></tr>
<tr><td>DEY</td><td>snížení obsahu index registru Y o jedničku</td></tr>
</table>

<p>Povšimněte si, že MOS 6502 nemá instrukce INA/DEA pro zvýšení/snížení obsahu
akumulátoru (u registrů X a Y se jedná o nutnost, u akumulátoru se používá ADC
a SBC se všemi z&nbsp;toho plynoucími důsledky). Tento nedostatek byl napraven
v&nbsp;čipu 65C02, který obě zmíněné instrukce obsahuje, což podle některých
autorů vedlo ke zmenšení programového kódu až o 5%.</p>

<p>Co je ovšem pro nás důležité &ndash; instrukce INC a DEC podporují přímé
uvedení absolutní adresy, takže pokud budeme chtít pohybovat sprity o jeden
pixel v&nbsp;libovolném směru, bude celý programový kód značně jednodušší:</p>

<pre>
        read_button        <i>; stav tlačítka Up</i>
        beq up_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        <strong>dec YPOS</strong>
&nbsp;
up_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Down</i>
        beq down_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        <strong>inc YPOS</strong>
&nbsp;
down_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Left</i>
        beq left_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        <strong>dec XPOS</strong>
&nbsp;
left_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Right</i>
        beq right_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        <strong>inc XPOS</strong>
&nbsp;
right_not_pressed:
</pre>

<p><div class="rs-tip-major">Poznámka: společně s&nbsp;instrukcemi posuvu jsou
právě instrukce INC a DEC příkladem toho, že MOS 6502 není (a ani neměl být)
RISCovým procesorem; ostatně je řízen PLA a sekvencérem a ani neobsahuje
klasickou RISCovou pipeline.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu (v&nbsp;pořadí
již dvacátého příkladu pro NES) je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example20.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example20.asm</a>.
Pro překlad a slinkování tohoto příkladu je zapotřebí i <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">Makefile</a>
a příkaz <strong>make example20.nes</strong>:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Nastavení barvové palety, zvýšení intenzity barvy</i>
<i>; Setup PPU přes makro</i>
<i>; Definice spritu a zobrazení spritů s rozloženým Mariem. Pohyb spritu.</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Taktéž založeno na https://nerdy-nights.nes.science/#main_tutorial-3</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
PPUADDR         = $2006
PPUDATA         = $2007
DMC_FREQ        = $4010
OAM_DMA         = $4014
&nbsp;
<i>; Další důležité adresy</i>
PALETTE         = $3f00
&nbsp;
<i>; Ovladače</i>
JOYPAD1         = $4016
JOYPAD2         = $4017
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -&gt; 0x00 konec smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro ppu_data_palette_address</strong>
        lda PPUSTATUS   <i>; reset záchytného registru</i>
        lda #&gt;PALETTE   <i>; nastavení adresy pro barvovou paletu $3f00</i>
        sta PPUADDR
        lda #&lt;PALETTE   <i>; nižší bajt adresy</i>
        sta PPUADDR
<strong>.endmacro</strong>
&nbsp;
<strong>.macro read_button</strong>
        lda JOYPAD1        <i>; stav tlačítka</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
<strong>.endmacro</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 2
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp;
.segment "ZEROPAGE"
.segment "STARTUP"
.segment "CODE"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
.code
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
<strong>.proc nmi</strong>
        lda #$02           <i>; horní bajt adresy pro přenos + zahájení přenosu</i>
        sta OAM_DMA
&nbsp;
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
                           <i>; </i>
                           <i>; 1) A                      </i>
                           <i>; 2) B                      </i>
                           <i>; 3) Select                 </i>
                           <i>; 4) Start                  </i>
                           <i>; 5) Up                     </i>
                           <i>; 6) Down                   </i>
                           <i>; 7) Left                   </i>
                           <i>; 8) Right</i>
&nbsp;
        read_button        <i>; stav tlačítka A jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka B jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Select jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
&nbsp;
        XPOS = $0203       <i>; adresa buňky paměti s x-ovou souřadnicí spritu</i>
        YPOS = $0200       <i>; adresa buňky paměti y x-ovou souřadnicí spritu</i>
&nbsp;
        read_button        <i>; stav tlačítka Up</i>
        beq up_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        dec YPOS
&nbsp;
up_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Down</i>
        beq down_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        inc YPOS
&nbsp;
down_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Left</i>
        beq left_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        dec XPOS
&nbsp;
left_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Right</i>
        beq right_not_pressed <i>; není stisknuto? =&gt; skok</i>
&nbsp;
        inc XPOS
&nbsp;
right_not_pressed:
&nbsp;
        rti                <i>; návrat z přerušení</i>
&nbsp;
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
<strong>.proc irq</strong>
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ            <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017               <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        <i>; nastavení barvové palety</i>
        jsr load_palette  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; nastavení spritů</i>
        jsr load_sprites  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; vynulování barvové palety</i>
<strong>.proc clear_palette</strong>
        ppu_data_palette_address
&nbsp;
        ldx #$20        <i>; počitadlo barev v paletě: 16+16</i>
        lda #$00        <i>; vynulování každé barvy</i>
&nbsp;
:
        sta PPUDATA     <i>; zápis barvy</i>
        dex             <i>; snížení hodnoty počitadla</i>
        bne :-
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; nastavení barvové palety</i>
<strong>.proc load_palette</strong>
        ppu_data_palette_address
&nbsp;
        <i>; $3f00-$3f0f - paleta pozadí</i>
        <i>; $3f10-$3f1f - paleta spritů</i>
&nbsp;
        ldx #$00        <i>; vynulovat počitadlo a offset</i>
&nbsp;
:
        lda palette, x  <i>; načíst bajt s offsetem</i>
        sta PPUDATA     <i>; zápis barvy do PPU</i>
        inx             <i>; zvýšit počitadlo/offset</i>
        cpx #32         <i>; limit počtu barev</i>
        bne :-          <i>; opakovat smyčku 32x</i>
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; načtení spritů</i>
<strong>.proc load_sprites</strong>
        ldx #0
:
        lda spritedata,X  <i>; budeme přesouvat data z této oblasti</i>
        sta $0200,X       <i>; uložení do paměti spritů</i>
        inx               <i>; zvýšení hodnoty počitadla</i>
        cpx #32           <i>; každý sprite má 4 bajty: y-coord, tile, attributy, y-coord * 8 spritů = 32</i>
        bne :-
&nbsp;
        cli               <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10000000      
        sta PPUCTRL       <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
&nbsp;
        lda #%00010000    <i>; povolení zobrazení spritů</i>
        sta PPUMASK
&nbsp;
        rts               <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; samotná barvová paleta</i>
palette:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
&nbsp;
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
.segment "CHARS"
    .incbin "mario.chr"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Přesun všech osmi spritů tvořících figurku Maria</h2>

<p>Náš další úkol je zřejmý &ndash; upravit program takovým způsobem, aby bylo
možné pohybovat celou figurkou Maria, která se skládá z&nbsp;osmi spritů.
Nějakým vhodným způsobem tedy budeme muset vždy zvýšit či snížit souřadnici
nikoli jediného spritu, ale hned osmi spritů. To lze provést několika různými
způsoby, například využít toho, že nová souřadnice je pro několik spritů vždy
stejná atd. Ovšem ukažme si druhý nejjednodušší způsob &ndash; realizace formou
programové smyčky, která vždy změní hodnotu osmi bajtů v&nbsp;paměti. Tyto
bajty však nejsou uloženy ihned za sebou, ale s&nbsp;mezerou 4 adres. To
vychází ze způsobu uložení metainformací o spritech v&nbsp;paměti:</p>

<pre>
<strong>spritedata</strong>:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
</pre>

<p>Měnit budeme buď hodnoty v&nbsp;prvním sloupci nebo v&nbsp;sloupci
posledním.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Trik &ndash; aritmetické operace s&nbsp;registrem X</h2>

<p>Pro zvýšení nebo naopak snížení hodnot v&nbsp;osmi paměťových buňkách můžeme
použít instrukci <strong>inc adresa, x</strong> či <strong>dec adresa,
x</strong>, což znamená, že k&nbsp;pevně zadané adrese se přičítá offset
uložený v&nbsp;registru <strong>X</strong>. Postačuje nám tedy použít registr
<strong>X</strong> současně i ve funkci počitadla smyčky, která postupně
hodnotu tohoto registru nastaví na 4, 8, 12, 16, 20, 24, 28 a 32. To lze
provést tímto <i>pseudokódem</i>:</p>

<pre>
        ldx #0             <i>; inicializace offsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        <strong>adc x, #gap</strong>        <i>; zvýšení o hodnotu gap (4, další sprite)</i>
&nbsp;
        <strong>cmp x, #count*gap</strong>  <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
</pre>

<p>Jediný problém spočívá v&nbsp;tom, že tučně zapsané instrukce mikroprocesor
MOS 6502 neobsahuje. Jedná se totiž o aritmetické operace a ty lze provádět jen
s&nbsp;akumulátorem. Pomůžeme si tudíž malým trikem &ndash; instrukcí
<strong>TXA</strong> přesuneme obsah registru <strong>X</strong> do
akumulátoru, provedeme všechny nutné aritmetické operace a následně přesuneme
nový obsah akumulátoru do registru <strong>X</strong> instrukcí
<strong>TAX</strong>:</p>

<pre>
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
</pre>

<p>Následně pouze otestujeme, zda jsme dospěli k&nbsp;poslednímu offsetu, který
se má použít pro instrukci <strong>INC</strong> či <strong>DEC</strong>:</p>

<pre>
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: zde testujeme hodnotu akumulátoru,
protože je shodná s&nbsp;hodnotou uloženou v&nbsp;registru
<strong>X</strong>.</div></p>

<p>Výsledkem jsou následující dvě makra:</p>

<pre>
<strong>.macro increment_block address, count, gap</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro decrement_block address, count, gap</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        dec address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
        txa                <i>; přesun offsetu do akumulátoru</i>
        clc
        adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
        tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
        cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>

        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
</pre>

<p>Která se používají takto:</p>

<pre>
        read_button        <i>; stav tlačítka Up</i>
        beq up_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        <strong>decrement_block YPOS, 8, 4</strong>
&nbsp;
up_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Down</i>
        beq down_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        <strong>increment_block YPOS, 8, 4</strong>
&nbsp;
down_not_pressed:
        ...
        ...
        ...
        ...
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak se díky makrům stává
z&nbsp;assembleru relativně mocný programovací jazyk.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Úplný zdrojový kód dnešního pátého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního posledního demonstračního příkladu
(v&nbsp;pořadí již dvacátého prvního příkladu pro NES) je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example21.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example21.asm</a>.
Pro překlad a slinkování tohoto příkladu je zapotřebí i <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">Makefile</a>
a příkaz <strong>make example21.nes</strong>:</p>

<pre>
<i>; ---------------------------------------------------------------------</i>
<i>; Kostra programu pro herní konzoli NES</i>
<i>; Nastavení barvové palety, zvýšení intenzity barvy</i>
<i>; Setup PPU přes makro</i>
<i>; Definice spritu a zobrazení spritů s rozloženým Mariem.</i>
<i>; Pohyb celého Maria.</i>
<i>; Využití symbolických jmen adres.</i>
<i>; Pomocná makra pro pohyb spritu.</i>
<i>;</i>
<i>; Založeno na příkladu https://github.com/depp/ctnes/tree/master/nesdev/01</i>
<i>; Taktéž založeno na https://nerdy-nights.nes.science/#main_tutorial-3</i>
<i>; Viz též článek na https://www.moria.us/blog/2018/03/nes-development</i>
<i>; Audio https://raw.githubusercontent.com/iliak/nes/master/doc/apu_ref.txt</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Jména řídicích registrů použitých v kódu</i>
PPUCTRL         = $2000
PPUMASK         = $2001
PPUSTATUS       = $2002
PPUADDR         = $2006
PPUDATA         = $2007
DMC_FREQ        = $4010
OAM_DMA         = $4014
&nbsp;
<i>; Další důležité adresy</i>
PALETTE         = $3f00
&nbsp;
<i>; Ovladače</i>
JOYPAD1         = $4016
JOYPAD2         = $4017
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice maker</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<strong>.macro setup_cpu</strong>
        <i>; nastavení stavu CPU</i>
        sei                     <i>; zákaz přerušení</i>
        cld                     <i>; vypnutí dekadického režimu (není podporován)</i>
&nbsp;
        ldx #$ff
        txs                     <i>; vrchol zásobníku nastaven na 0xff (první stránka)</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro wait_for_frame</strong>
:       bit PPUSTATUS            <i>; test obsahu registru PPUSTATUS </i>
        bpl :-                   <i>; skok, pokud je příznak N nulový</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro clear_ram</strong>
        lda #$00                <i>; vynulování registru A</i>
:       sta $000, x             <i>; vynulování X-tého bajtu v nulté stránce</i>
        sta $100, x
        sta $200, x
        sta $300, x
        sta $400, x
        sta $500, x
        sta $600, x
        sta $700, x             <i>; vynulování X-tého bajtu v sedmé stránce</i>
        inx                     <i>; přechod na další bajt</i>
        bne :-                  <i>; po přetečení 0xff -> 0x00 konec smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro ppu_data_palette_address</strong>
        lda PPUSTATUS   <i>; reset záchytného registru</i>
        lda #&gt;PALETTE   <i>; nastavení adresy pro barvovou paletu $3f00</i>
        sta PPUADDR
        lda #&lt;PALETTE   <i>; nižší bajt adresy</i>
        sta PPUADDR
<strong>.endmacro</strong>
&nbsp;
<strong>.macro increment_block address, count, gap</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        inc address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
	txa                <i>; přesun offsetu do akumulátoru</i>
	clc
	adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
	tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
	cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro decrement_block address, count, gap</strong>
        ldx #0             <i>; inicializace offsetu</i>
:
        dec address, x     <i>; zvýšit pozici spritu o jedničku</i>
&nbsp;
	txa                <i>; přesun offsetu do akumulátoru</i>
	clc
	adc #gap           <i>; zvýšení o hodnotu gap (4, další sprite)</i>
	tax                <i>; přesun nového offsetu zpět do registru X</i>
&nbsp;
	cmp #count*gap     <i>; porovnání, zda jsme již dosáhli posledního spritu</i>
&nbsp;
        bne :-             <i>; pokud ne, skok na začátek smyčky</i>
<strong>.endmacro</strong>
&nbsp;
<strong>.macro read_button</strong>
        lda JOYPAD1        <i>; stav tlačítka</i>
        and #%00000001     <i>; maskovat všechny bity kromě prvního</i>
<strong>.endmacro</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Definice hlavičky obrazu ROM</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Size of PRG in units of 16 KiB.</i>
prg_npage = 2
&nbsp;
<i>; Size of CHR in units of 8 KiB.</i>
chr_npage = 1
&nbsp;
<i>; INES mapper number.</i>
mapper = 0
&nbsp;
<i>; Mirroring (0 = horizontal, 1 = vertical)</i>
mirroring = 1
&nbsp;
.segment "HEADER"
        .byte $4e, $45, $53, $1a
        .byte prg_npage
        .byte chr_npage
        .byte ((mapper &amp; $0f) &lt;&lt; 4) | (mirroring &amp; 1)
        .byte mapper &amp; $f0
&nbsp;
.segment "ZEROPAGE"
.segment "STARTUP"
.segment "CODE"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Blok paměti s definicí dlaždic 8x8 pixelů</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "CHR0a"
.segment "CHR0b"
&nbsp;
&nbsp;
.code
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Programový kód rutin pro NMI, RESET a IRQ volaných automaticky CPU</i>
<i>;</i>
<i>; viz též https://www.pagetable.com/?p=410</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
<i>; Obslužná rutina pro NMI (nemaskovatelné přerušení, vertical blank)</i>
&nbsp;
<strong>.proc nmi</strong>
        lda #$02           <i>; horní bajt adresy pro přenos + zahájení přenosu</i>
        sta OAM_DMA
&nbsp;
        lda #$01
        sta JOYPAD1        <i>; načtení stavu všech osmi tlačítek do záchytného registru</i>
        lda #$00
        sta JOYPAD1        <i>; začátek načítání jednotlivých bitů se stavy tlačítek v tomto pořadí:</i>
                           <i>; </i>
                           <i>; 1) A                      </i>
                           <i>; 2) B                      </i>
                           <i>; 3) Select                 </i>
                           <i>; 4) Start                  </i>
                           <i>; 5) Up                     </i>
                           <i>; 6) Down                   </i>
                           <i>; 7) Left                   </i>
                           <i>; 8) Right</i>
&nbsp;
        read_button        <i>; stav tlačítka A jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka B jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Select jen načteme a ingorujeme</i>
        read_button        <i>; stav tlačítka Start jen načteme a ingorujeme</i>
&nbsp;
        XPOS = $0203       <i>; adresa buňky paměti s x-ovou souřadnicí spritu</i>
        YPOS = $0200       <i>; adresa buňky paměti y x-ovou souřadnicí spritu</i>
&nbsp;
        read_button        <i>; stav tlačítka Up</i>
        beq up_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        decrement_block YPOS, 8, 4
&nbsp;
up_not_pressed:
&nbsp;
        read_button        <i>; stav tlačítka Down</i>
        beq down_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        increment_block YPOS, 8, 4
&nbsp;
down_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Left</i>
        beq left_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        decrement_block XPOS, 8, 4
&nbsp;
left_not_pressed:
&nbsp;
        read_button      <i>; stav tlačítka Right</i>
        beq right_not_pressed <i>; není stisknuto? => skok</i>
&nbsp;
        increment_block XPOS, 8, 4
&nbsp;
right_not_pressed:
&nbsp;
        rti                <i>; návrat z přerušení</i>
&nbsp;
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro IRQ (maskovatelné přerušení)</i>
&nbsp;
<strong>.proc irq</strong>
        rti                     <i>; návrat z přerušení</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; Obslužná rutina pro RESET</i>
&nbsp;
<strong>.proc reset</strong>
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$00
        stx PPUCTRL             <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK             <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ            <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017               <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        <i>; nastavení barvové palety</i>
        jsr load_palette  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; nastavení spritů</i>
        jsr load_sprites  <i>; zavolání subrutiny</i>
&nbsp;
        <i>; vlastní herní smyčka je prozatím prázdná</i>
game_loop:
        jmp game_loop           <i>; nekonečná smyčka (později rozšíříme)</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; vynulování barvové palety</i>
<strong>.proc clear_palette</strong>
        ppu_data_palette_address
&nbsp;
        ldx #$20        <i>; počitadlo barev v paletě: 16+16</i>
        lda #$00        <i>; vynulování každé barvy</i>
&nbsp;
:
        sta PPUDATA     <i>; zápis barvy</i>
        dex             <i>; snížení hodnoty počitadla</i>
        bne :-
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; nastavení barvové palety</i>
<strong>.proc load_palette</strong>
        ppu_data_palette_address
&nbsp;
        <i>; $3f00-$3f0f - paleta pozadí</i>
        <i>; $3f10-$3f1f - paleta spritů</i>
&nbsp;
        ldx #$00        <i>; vynulovat počitadlo a offset</i>
&nbsp;
:
        lda palette, x  <i>; načíst bajt s offsetem</i>
        sta PPUDATA     <i>; zápis barvy do PPU</i>
        inx             <i>; zvýšit počitadlo/offset</i>
        cpx #32         <i>; limit počtu barev</i>
        bne :-          <i>; opakovat smyčku 32x</i>
&nbsp;
        rts             <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; načtení spritů</i>
<strong>.proc load_sprites</strong>
        ldx #0
:
        lda spritedata,X  <i>; budeme přesouvat data z této oblasti</i>
        sta $0200,X       <i>; uložení do paměti spritů</i>
        inx               <i>; zvýšení hodnoty počitadla</i>
        cpx #32           <i>; každý sprite má 4 bajty: y-coord, tile, attributy, y-coord * 8 spritů = 32</i>
        bne :-
&nbsp;
        cli               <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10000000      
        sta PPUCTRL       <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
&nbsp;
        lda #%00010000    <i>; povolení zobrazení spritů</i>
        sta PPUMASK
&nbsp;
        rts               <i>; návrat ze subrutiny</i>
<strong>.endproc</strong>
&nbsp;
&nbsp;
&nbsp;
<i>; samotná barvová paleta</i>
palette:
    .byte $22, $29, $1a, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F  <i>; barvy pozadí</i>
    .byte $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17  <i>; barvy spritů</i>
&nbsp;
<i>; data pro větší množství spritů</i>
spritedata:
    .byte $10, $00, $00, $08   <i>; y-coord, tile number, attributes, x-coord</i>
    .byte $10, $01, $00, $10
    .byte $18, $02, $00, $08
    .byte $18, $03, $00, $10
    .byte $20, $04, $00, $08
    .byte $20, $05, $00, $10
    .byte $28, $06, $00, $08
    .byte $28, $07, $00, $10
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Tabulka vektorů CPU</i>
<i>; ---------------------------------------------------------------------</i>
&nbsp;
.segment "VECTORS"
.addr nmi
.addr reset
.addr irq
&nbsp;
&nbsp;
&nbsp;
.segment "CHARS"
    .incbin "mario.chr"
&nbsp;
&nbsp;
&nbsp;
<i>; ---------------------------------------------------------------------</i>
<i>; Finito</i>
<i>; ---------------------------------------------------------------------</i>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad pomocí assembleru <strong>ca65</strong> (jenž je součástí
<strong>cc65</strong>), byly uložen do Git repositáře, který je dostupný na
adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>example01.asm</td><td>zdrojový kód příkladu tvořeného kostrou aplikace pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm</a></td></tr>
<tr><td> 2</td><td>example02.asm</td><td>použití standardní konfigurace linkeru pro konzoli NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm</a></td></tr>
<tr><td> 3</td><td>example03.asm</td><td>symbolická jména řídicích registrů PPU</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm</a></td></tr>
<tr><td> 4</td><td>example04.asm</td><td>zjednodušený zápis lokálních smyček v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm</a></td></tr>
<tr><td> 5</td><td>example05.asm</td><td>zvukový výstup s&nbsp;využitím prvního &bdquo;square&ldquo; kanálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm</a></td></tr>
<tr><td> 6</td><td>example06.asm</td><td>použití maker bez parametrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>example07.asm</td><td>nastavení barvové palety, zvýšení intenzity zvolené barvové složky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example07.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example07.asm</a></td></tr>
<tr><td> 8</td><td>example08.asm</td><td>využití operátorů &lt; a &gt;</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example08.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example08.asm</a></td></tr>
<tr><td> 9</td><td>example09.asm</td><td>vymazání barvové palety realizované makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example09.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example09.asm</a></td></tr>
<tr><td>10</td><td>example10.asm</td><td>vymazání barvové palety realizované podprogramem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example10.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example10.asm</a></td></tr>
<tr><td>11</td><td>example11.asm</td><td>nastavení barvové palety pozadí i spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example11.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example11.asm</a></td></tr>
<tr><td>12</td><td>example12.asm</td><td>refaktoring předchozího příkladu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example12.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example12.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>example13.asm</td><td>zobrazení spritů tvořících Maria</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example13.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example13.asm</a></td></tr>
<tr><td>14</td><td>example14.asm</td><td>posun spritů, aby se zdůraznila jejich nezávislost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example14.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example14.asm</a></td></tr>
<tr><td>15</td><td>example15.asm</td><td>větší množství spritů na obrazovce rozdělených do řádků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example15.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example15.asm</a></td></tr>
<tr><td>16</td><td>example16.asm</td><td>větší množství spritů na obrazovce na jediném řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example16.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example16.asm</a></td></tr>
<tr><td>17</td><td>example17.asm</td><td>pohyb jednoho spritu pomocí ovladače</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example17.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example17.asm</a></td></tr>
<tr><td>18</td><td>example18.asm</td><td>odvozeno z&nbsp;předchozího příkladu, symbolická jména adres</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example18.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example18.asm</a></td></tr>
<tr><td>19</td><td>example19.asm</td><td>odvozeno z&nbsp;předchozího příkladu, pomocná makra pro pohyb spritu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example19.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example19.asm</a></td></tr>
<tr><td>20</td><td>example20.asm</td><td>pohyb spritu je založen na instrukcích <strong>INC</strong> a <strong>DEC</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example20.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example20.asm</a></td></tr>
<tr><td>21</td><td>example21.asm</td><td>přesun celého Maria (8 spritů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example21.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example21.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>link.cfg</td><td>konfigurace segmentů pro linker <strong>ld65</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg</a></td></tr>
<tr><td>23</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: pro slinkování a spuštění dnešních
demonstračních příkladů potřebujete i soubor <a
href="https://github.com/ericdigioia/6502-Assembly-NES-Game-Development-Playground/raw/main/mario.chr">mario.chr</a>.
Ten je stažen automaticky po zadání <strong>make example16</strong> až
<strong>make example21</strong>.</div></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>NesDev.org<br />
<a href="https://www.nesdev.org/">https://www.nesdev.org/</a>
</li>

<li>The Sprite Attribute Byte<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-17/">https://www.patater.com/nes-asm-tutorials/day-17/</a>
</li>

<li>How to Program an NES game in C<br />
<a href="https://nesdoug.com/">https://nesdoug.com/</a>
</li>

<li>Cycle reference chart<br />
<a href="https://www.nesdev.org/wiki/Cycle_reference_chart">https://www.nesdev.org/wiki/Cycle_reference_chart</a>
</li>

<li>Getting Started Programming in C: Coding a Retro Game with C Part 2<br />
<a href="https://retrogamecoders.com/getting-started-with-c-cc65/">https://retrogamecoders.com/getting-started-with-c-cc65/</a>
</li>

<li>NES game development in 6502 assembly - Part 1<br />
<a href="https://kibrit.tech/en/blog/nes-game-development-part-1">https://kibrit.tech/en/blog/nes-game-development-part-1</a>
</li>

<li>NES (Nintendo Entertainment System) controller pinout<br />
<a href="https://pinoutguide.com/Game/NES_controller_pinout.shtml">https://pinoutguide.com/Game/NES_controller_pinout.shtml</a>
</li>

<li>NES Controller Shift Register<br />
<a href="https://www.allaboutcircuits.com/uploads/articles/nes-controller-arduino.png?v=1469416980041">https://www.allaboutcircuits.com/uploads/articles/nes-controller-arduino.png?v=1469416980041</a>
</li>

<li>"Game Development in Eight Bits" by Kevin Zurawel<br />
<a href="https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4">https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4</a>
</li>

<li>Game Development for the 8-bit NES: A class by Bob Rost<br />
<a href="http://bobrost.com/nes/">http://bobrost.com/nes/</a>
</li>

<li>Game Development for the 8-bit NES: Lecture Notes<br />
<a href="http://bobrost.com/nes/lectures.php">http://bobrost.com/nes/lectures.php</a>
</li>

<li>NES Graphics Explained<br />
<a href="https://www.youtube.com/watch?v=7Co_8dC2zb8">https://www.youtube.com/watch?v=7Co_8dC2zb8</a>
</li>

<li>NES GAME PROGRAMMING PART 1<br />
<a href="https://rpgmaker.net/tutorials/227/?post=240020">https://rpgmaker.net/tutorials/227/?post=240020</a>
</li>

<li>NES 6502 Programming Tutorial - Part 1: Getting Started<br />
<a href="https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/">https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/</a>
</li>

<li>Minimal NES example using ca65<br />
<a href="https://github.com/bbbradsmith/NES-ca65-example">https://github.com/bbbradsmith/NES-ca65-example</a>
</li>

<li>List of 6502-based Computers and Consoles<br />
<a href="https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/">https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/</a>
</li>

<li>History of video game consoles (second generation): Wikipedia<br />
<a href="http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)">http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)</a>
</li>

<li>6502 - the first RISC &micro;P<br />
<a href="http://ericclever.com/6500/">http://ericclever.com/6500/</a>
</li>

<li>3 Generations of Game Machine Architecture<br />
<a href="http://www.atariarchives.org/dev/CGEXPO99.html">http://www.atariarchives.org/dev/CGEXPO99.html</a>
</li>

<li>bee - The Multi-Console Emulator<br />
<a href="http://www.thebeehive.ws/">http://www.thebeehive.ws/</a>
</li>

<li>Nerdy Nights Mirror<br />
<a href="https://nerdy-nights.nes.science/">https://nerdy-nights.nes.science/</a>
</li>

<li>The Nerdy Nights ca65 Remix<br />
<a href="https://github.com/ddribin/nerdy-nights">https://github.com/ddribin/nerdy-nights</a>
</li>

<li>NES Development Day 1: Creating a ROM<br />
<a href="https://www.moria.us/blog/2018/03/nes-development">https://www.moria.us/blog/2018/03/nes-development</a>
</li>

<li>How to Start Making NES Games<br />
<a href="https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/">https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/</a>
</li>

<li>ca65 Users Guide<br />
<a href="https://cc65.github.io/doc/ca65.html">https://cc65.github.io/doc/ca65.html</a>
</li>

<li>cc65 Users Guide<br />
<a href="https://cc65.github.io/doc/cc65.html">https://cc65.github.io/doc/cc65.html</a>
</li>

<li>ld65 Users Guide<br />
<a href="https://cc65.github.io/doc/ld65.html">https://cc65.github.io/doc/ld65.html</a>
</li>

<li>da65 Users Guide<br />
<a href="https://cc65.github.io/doc/da65.html">https://cc65.github.io/doc/da65.html</a>
</li>

<li>Nocash NES Specs<br />
<a href="http://nocash.emubase.de/everynes.htm">http://nocash.emubase.de/everynes.htm</a>
</li>

<li>Nintendo Entertainment System<br />
<a href="http://cs.wikipedia.org/wiki/NES">http://cs.wikipedia.org/wiki/NES</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>NesDev<br />
<a href="http://nesdev.parodius.com/">http://nesdev.parodius.com/</a>
</li>

<li>2A03 technical reference<br />
<a href="http://nesdev.parodius.com/2A03%20technical%20reference.txt">http://nesdev.parodius.com/2A03%20technical%20reference.txt</a>
</li>

<li>NES Dev wiki: 2A03<br />
<a href="http://wiki.nesdev.com/w/index.php/2A03">http://wiki.nesdev.com/w/index.php/2A03</a>
</li>

<li>Ricoh 2A03<br />
<a href="http://en.wikipedia.org/wiki/Ricoh_2A03">http://en.wikipedia.org/wiki/Ricoh_2A03</a>
</li>

<li>2A03 pinouts<br />
<a href="http://nesdev.parodius.com/2A03_pinout.txt">http://nesdev.parodius.com/2A03_pinout.txt</a>
</li>

<li>27c3: Reverse Engineering the MOS 6502 CPU (en)<br />
<a href="https://www.youtube.com/watch?v=fWqBmmPQP40">https://www.youtube.com/watch?v=fWqBmmPQP40</a>
</li>

<li>“Hello, world” from scratch on a 6502 — Part 1<br />
<a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">https://www.youtube.com/watch?v=LnzuMJLZRdU</a>
</li>

<li>A Tour of 6502 Cross-Assemblers<br />
<a href="https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/">https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/</a>
</li>

<li>Nintendo Entertainment System (NES)<br />
<a href="https://8bitworkshop.com/docs/platforms/nes/">https://8bitworkshop.com/docs/platforms/nes/</a>
</li>

<li>Question about NES vectors and PPU<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t4154.xhtml">https://archive.nes.science/nesdev-forums/f10/t4154.xhtml</a>
</li>

<li>How do mapper chips actually work?<br />
<a href="https://archive.nes.science/nesdev-forums/f9/t13125.xhtml">https://archive.nes.science/nesdev-forums/f9/t13125.xhtml</a>
</li>

<li>INES<br />
<a href="https://www.nesdev.org/wiki/INES">https://www.nesdev.org/wiki/INES</a>
</li>

<li>NES Basics and Our First Game<br />
<a href="http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html">http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html</a>
</li>

<li>Where is the reset vector in a .nes file?<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t17413.xhtml">https://archive.nes.science/nesdev-forums/f10/t17413.xhtml</a>
</li>

<li>CPU memory map<br />
<a href="https://www.nesdev.org/wiki/CPU_memory_map">https://www.nesdev.org/wiki/CPU_memory_map</a>
</li>

<li>How to make NES music<br />
<a href="http://blog.snugsound.com/2008/08/how-to-make-nes-music.html">http://blog.snugsound.com/2008/08/how-to-make-nes-music.html</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>MIDINES<br />
<a href="http://www.wayfar.net/0xf00000_overview.php">http://www.wayfar.net/0xf00000_overview.php</a>
</li>

<li>FamiTracker<br />
<a href="http://famitracker.com/">http://famitracker.com/</a>
</li>

<li>nerdTracker II<br />
<a href="http://nesdev.parodius.com/nt2/">http://nesdev.parodius.com/nt2/</a>
</li>

<li>How NES Graphics work<br />
<a href="http://nesdev.parodius.com/nesgfx.txt">http://nesdev.parodius.com/nesgfx.txt</a>
</li>

<li>NES Technical/Emulation/Development FAQ<br />
<a href="http://nesdev.parodius.com/NESTechFAQ.htm">http://nesdev.parodius.com/NESTechFAQ.htm</a>
</li>

<li>Adventures with ca65<br />
<a href="https://atariage.com/forums/topic/312451-adventures-with-ca65/">https://atariage.com/forums/topic/312451-adventures-with-ca65/</a>
</li>

<li>example ca65 startup code<br />
<a href="https://atariage.com/forums/topic/209776-example-ca65-startup-code/">https://atariage.com/forums/topic/209776-example-ca65-startup-code/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer<br />
<a href="http://wilsonminesco.com/6502primer/">http://wilsonminesco.com/6502primer/</a>
</li>

<li>6502 Instruction Set<br />
<a href="https://www.masswerk.at/6502/6502_instruction_set.html">https://www.masswerk.at/6502/6502_instruction_set.html</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Single-board computer<br />
<a href="https://en.wikipedia.org/wiki/Single-board_computer">https://en.wikipedia.org/wiki/Single-board_computer</a>
</li>

<li>www.6502.org<br />
<a href="http://www.6502­.org/">http://www.6502­.org/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer &ndash; clock generator<br />
<a href="http://wilsonminesco.com/6502primer/ClkGen.html">http://wilsonminesco.com/6502primer/ClkGen.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://www.cpushack.com/CPU/cpu.html">http://www.cpushack.com/CPU/cpu.html</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Osmibitové mikroprocesory a mikrořadiče firmy Motorola (1)<br />
<a href="https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/">https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/</a>
</li>

<li>Mikrořadiče a jejich použití v jednoduchých mikropočítačích<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/">https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/</a>
</li>

<li>Mikrořadiče a jejich aplikace v jednoduchých mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/">https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Comparison of instruction set architectures<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures">https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</a>
</li>

<li>Day 1 - Beginning NES Assembly<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-1/">https://www.patater.com/nes-asm-tutorials/day-1/</a>
</li>

<li>Day 2 - A Source Code File's Structure<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-2/">https://www.patater.com/nes-asm-tutorials/day-2/</a>
</li>

<li>Assembly Language Misconceptions<br />
<a href="https://www.youtube.com/watch?v=8_0tbkbSGRE">https://www.youtube.com/watch?v=8_0tbkbSGRE</a>
</li>

<li>How Machine Language Works<br />
<a href="https://www.youtube.com/watch?v=HWpi9n2H3kE">https://www.youtube.com/watch?v=HWpi9n2H3kE</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

