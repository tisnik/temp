<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Kopie bloku o délce šestnácti bajtů přes zásobník</a></p>
<p><a href="#k03">*** 3. Doba přenosu šestnácti bajtů</a></p>
<p><a href="#k04">*** 4. Teoretická doba přenosu celého bloku 2048 bajtů</a></p>
<p><a href="#k05">5. Úplný zdrojový kód dnešního prvního demonstračního příkladu</a></p>
<p><a href="#k06">6. Makra v&nbsp;assemblerech</a></p>
<p><a href="#k07">7. Generování strojového kódu s&nbsp;využitím makra</a></p>
<p><a href="#k08">*** 8. Opakované použití makra</a></p>
<p><a href="#k09">9. Úplný zdrojový kód dnešního druhého demonstračního příkladu</a></p>
<p><a href="#k10">*** 10. Opakování libovolného bloku v&nbsp;assembleru</a></p>
<p><a href="#k11">*** 11. Realizace kopie osmi bloků, z&nbsp;nichž každý má velikost šestnácti bajtů</a></p>
<p><a href="#k12">12. Úplný zdrojový kód dnešního třetího demonstračního příkladu</a></p>
<p><a href="#k13">*** 13. Kopie bloku pixelů na různá místa na obrazovce</a></p>
<p><a href="#k14">*** 14. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</a></p>
<p><a href="#k15">*** 15. Shrnutí: blokové přesuny dat na mikroprocesoru Z80</a></p>
<p><a href="#k16">*** 16. Kam dál?</a></p>
<p><a href="#k17">*** 17. Čtení stisknutých kláves</a></p>
<p><a href="#k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<pre>
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Kopie bloku o délce šestnácti bajtů přes zásobník</h2>

<p></p>

<pre>
di
</pre>

<p></p>

<pre>
ld   sp, <u>source_address</u>
pop  af
pop  bc
pop  de
pop  hl
</pre>

<p></p>

<pre>
exx
ex   af, af'
pop  af
pop  bc
pop  de
pop  hl
</pre>

<p></p>

<pre>
ld   sp, <u>destination_address+16</u>
push hl
push de
push bc
push af
</pre>

<p></p>

<pre>
exx
ex   af, af'
push hl
push de
push bc
push af
</pre>

<p></p>

<pre>
ei
</pre>

<p></p>

<pre>
di
ld   sp, <u>source_address</u>
pop  af
pop  bc
pop  de
pop  hl
exx
ex   af, af'
pop  af
pop  bc
pop  de
pop  hl
ld   sp, <u>destination_address+16</u>
push hl
push de
push bc
push af
exx
ex   af, af'
push hl
push de
push bc
push af
ei
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Doba přenosu šestnácti bajtů</h2>

<p>Nyní je nutné si vypočítat, kolik strojových cyklů zabere přenos šestnácti
bajtů přes zásobník. Připišme si tedy k&nbsp;jednotlivým instrukcím počet
cyklů:</p>

<pre>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Teoretická doba přenosu celého bloku 2048 bajtů</h2>

<p></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Úplný zdrojový kód dnešního prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu založeného na
použití zásobníku bude vypadat následovně:</p>

<pre>
<i>; Example #90:</i>
<i>;    Print ASCII table on screen + copy it to second part of screen using stack.</i>
&nbsp;
SCREEN_ADR          equ $4000
SCREEN_BLOCK_SIZE   equ 32*64
SECOND_SCREEN_BLOCK equ SCREEN_ADR+SCREEN_BLOCK_SIZE
&nbsp;
CHAR_ADR            equ $3c00
ENTRY_POINT         equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call fill_in_screen           <i>; vyplnění obrazovky ASCII tabulkami</i>
        di
&nbsp;
        ld   sp, SCREEN_ADR+32*9
        pop  af
        pop  bc
        pop  de
        pop  hl
        exx
        ex   af, af'
        pop  af
        pop  bc
        pop  de
        pop  hl
        ld   sp, SECOND_SCREEN_BLOCK+16
        push hl
        push de
        push bc
        push af
        exx
        ex   af, af'
        push hl
        push de
        push bc
        push af
&nbsp;
        ld   sp, SCREEN_ADR+32*(8+9)
        pop  af
        pop  bc
        pop  de
        pop  hl
        exx
        ex   af, af'
        pop  af
        pop  bc
        pop  de
        pop  hl
        ld   sp, SECOND_SCREEN_BLOCK+16+(32*8)
        push hl
        push de
        push bc
        push af
        exx
        ex   af, af'
        push hl
        push de
        push bc
        push af
&nbsp;
        ld   sp, SCREEN_ADR+32*(8+8+9)
        pop  af
        pop  bc
        pop  de
        pop  hl
        exx
        ex   af, af'
        pop  af
        pop  bc
        pop  de
        pop  hl
        ld   sp, SECOND_SCREEN_BLOCK+16+(32*8*2)
        push hl
        push de
        push bc
        push af
        exx
        ex   af, af'
        push hl
        push de
        push bc
        push af
&nbsp;
        ld sp, SCREEN_ADR+SECOND_SCREEN_BLOCK+2048
        ei
<strong>finito</strong>:
        jr finito                     <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR        <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_ascii_table</strong>:
        <i>; Vytištění ASCII tabulky</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_char</strong>:
        <i>; Vytištění jednoho znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop</strong>:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/90-copy-ascii-table-F.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/90-copy-ascii-table-F.asm</a>.</div></p>

<p>Pro úplnost si uveďme u způsob překladu z&nbsp;assembleru do strojového
kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
SCREEN_BLOCK_SIZE EQU 0800
SECOND_SCREEN_BLOCK EQU 4800
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:CD5880     CALL 8058
8003:F3         DI
8004:312041     LD SP, 4120
8007:F1         POP AF
8008:C1         POP BC
8009:D1         POP DE
800A:E1         POP HL
800B:D9         EXX
800C:08         EX AF, AF'
800D:F1         POP AF
800E:C1         POP BC
800F:D1         POP DE
8010:E1         POP HL
8011:311048     LD SP, 4810
8014:E5         PUSH HL
8015:D5         PUSH DE
8016:C5         PUSH BC
8017:F5         PUSH AF
8018:D9         EXX
8019:08         EX AF, AF'
801A:E5         PUSH HL
801B:D5         PUSH DE
801C:C5         PUSH BC
801D:F5         PUSH AF
801E:312042     LD SP, 4220
8021:F1         POP AF
8022:C1         POP BC
8023:D1         POP DE
8024:E1         POP HL
8025:D9         EXX
8026:08         EX AF, AF'
8027:F1         POP AF
8028:C1         POP BC
8029:D1         POP DE
802A:E1         POP HL
802B:311049     LD SP, 4910
802E:E5         PUSH HL
802F:D5         PUSH DE
8030:C5         PUSH BC
8031:F5         PUSH AF
8032:D9         EXX
8033:08         EX AF, AF'
8034:E5         PUSH HL
8035:D5         PUSH DE
8036:C5         PUSH BC
8037:F5         PUSH AF
8038:312043     LD SP, 4320
803B:F1         POP AF
803C:C1         POP BC
803D:D1         POP DE
803E:E1         POP HL
803F:D9         EXX
8040:08         EX AF, AF'
8041:F1         POP AF
8042:C1         POP BC
8043:D1         POP DE
8044:E1         POP HL
8045:31104A     LD SP, 4A10
8048:E5         PUSH HL
8049:D5         PUSH DE
804A:C5         PUSH BC
804B:F5         PUSH AF
804C:D9         EXX
804D:08         EX AF, AF'
804E:E5         PUSH HL
804F:D5         PUSH DE
8050:C5         PUSH BC
8051:F5         PUSH AF
8052:310090     LD SP, 9000
8055:FB         EI
8056:           label finito
8056:18FE       JR 8056
8058:           label fill_in_screen
8058:110040     LD DE, 4000
805B:CD5F80     CALL 805F
805E:C9         RET
805F:           label draw_ascii_table
805F:3E20       LD A, 20
8061:           label next_char
8061:F5         PUSH AF
8062:CD7180     CALL 8071
8065:3E20       LD A, 20
8067:CD7180     CALL 8071
806A:F1         POP AF
806B:3C         INC A
806C:FE80       CP 80
806E:20F1       JR NZ, 8061
8070:C9         RET
8071:           label draw_char
8071:01003C     LD BC, 3C00
8074:61         LD H, C
8075:6F         LD L, A
8076:29         ADD HL, HL
8077:29         ADD HL, HL
8078:29         ADD HL, HL
8079:09         ADD HL, BC
807A:0608       LD B, 08
807C:4A         LD C, D
807D:           label loop
807D:7E         LD A, (HL)
807E:12         LD (DE), A
807F:2C         INC L
8080:14         INC D
8081:10FA       DJNZ 807D
8083:1C         INC E
8084:C8         RET Z
8085:51         LD D, C
8086:C9         RET
8087:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8086
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že velikost kódu nám
narostla na 134 bajtů. To se sice nemusí z&nbsp;dnešního pohledu zdát jako
nějaká velká hodnota, ale v&nbsp;kontextu ZX Spectra s&nbsp;48 kB RAM je to již
znatelné.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Makra v&nbsp;assemblerech</h2>

<p>Původní utility určené pro generování strojového kódu, které začaly vznikat
již na začátku padesátých let minulého století, byly relativně jednoduché
nástroje, které pouze převáděly symbolická jména instrukcí na binární kód.
Později se ovšem začaly možnosti assemblerů rozšiřovat a vylepšovat, například
do nich přibyla podpora textových maker, řízení víceprůchodového překladu,
překlad využívající podmínky pro výběr větví kódu, vytváření výstupních sestav
s&nbsp;překládanými symboly, později i skutečné linkování s&nbsp;knihovnami
atd.). Takto vylepšeným nástrojům se začalo obecně říkat <i>assemblery</i> a
jazyku pro symbolický zápis programů pak <i>jazyk symbolických instrukcí</i> či
<i>jazyk symbolických adres</i> &ndash; <i>assembly language</i> (někdy též
zkráceně nazývaný assembler, takže toto slovo má vlastně dodnes oba dva
významy). Jednalo se o svým způsobem převratnou myšlenku: sám počítač byl
použit pro tvorbu programů, čímž odpadla namáhavá práce s&nbsp;tužkou a
papírem.</p>

<p>A speciálně assemblerům, které podporovaly makra, se říkalo
<i>makroassemblery</i>. Dnes se již s&nbsp;tímto jménem setkáme jen minimálně,
protože všechny moderní assemblery práci s&nbsp;makry podporují, takže tuto
vlastnost již není zapotřebí tak zdůrazňovat. A mezi tyto assemblery patří i
<i>Pasmo</i>, v&nbsp;němž zapisujeme programy pro ZX Spectrum. Makrům se budeme
věnovat v&nbsp;navazujících kapitolách.</p>

<a href="http://www.root.cz/obrazek/211571/"><img src="http://i.iinfo.cz/images/322/a2-prev.png" class="image-211571" alt="&#160;" height="264" width="370" /></a>
<p><i>Obrázek 2: Vývojové prostředí Atari Macro Assembleru pro konkurenční
platformu s&nbsp;mikroprocesorem MOS 6502. Povšimněte si použití třípísmenných
mnemotechnických názvů instrukcí.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Generování strojového kódu s&nbsp;využitím makra</h2>

<p>V&nbsp;assembleru <i>Pasmo</i> je možné makra definovat dvěma způsoby, které
vypadají následovně:</p>

<pre>
jméno_makra <strong>MACRO</strong> [nepovinný seznam parametrů]
    ...
    ...
    ...
<strong>ENDM</strong>
</pre>

<p>Nebo:</p>

<pre>
<strong>MACRO</strong> jméno_makra, [nepovinný seznam parametrů]
    ...
    ...
    ...
<strong>ENDM</strong>
</pre>

<p>Druhý způsob vypadá poněkud neobvykle, protože vyžaduje, aby se za jménem
makra zapsala čárka a za ní seznam parametrů. Z&nbsp;tohoto důvodu (a taktéž
proto, že to odpovídá mnoha dalším assemblerům) použijeme první naznačený
způsob.</p>

<p>Pro naše potřeby si vytvoříme makro pojmenované
<strong>copy16bytes</strong>, které bude akceptovat dva parametry &ndash;
zdrojovou a cílovou adresu. Ovšem je nutné počítat s&nbsp;tím, že se jedná o
parametry makra vyhodnocované <i>v&nbsp;době překladu</i>. Podobně jako
v&nbsp;programovacím jazyku C se vlastně jedná o poměrně primitivní textovou
náhradu jména parametru za jeho skutečnou hodnotu použitou při volání makra
(což může u složitějších výrazů vyžadovat důsledné &bdquo;závorkování&ldquo;).
V&nbsp;našem konkrétním případě však žádné složitější výrazy nepoužíváme, takže
definice makra je přímočará &ndash; vzniklá kopií původního kódu
s&nbsp;doplněním jmen parametrů (podtrženo):</p>

<pre>
copy16bytes <strong>MACRO</strong> <u>source_address</u>, <u>destination_address</u>
        ld   sp, <u>source_address</u>
        pop  af
        pop  bc
        pop  de
        pop  hl
        exx
        ex   af, af'
        pop  af
        pop  bc
        pop  de
        pop  hl
        ld   sp, <u>destination_address+16</u>
        push hl
        push de
        push bc
        push af
        exx
        ex   af, af'
        push hl
        push de
        push bc
        push af
<strong>ENDM</strong>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Opakované použití makra</h2>

<p></p>

<pre>
<strong>copy16bytes</strong> SCREEN_ADR+32*(0*8+9), SECOND_SCREEN_BLOCK+(32*8*0)
<strong>copy16bytes</strong> SCREEN_ADR+32*(1*8+9), SECOND_SCREEN_BLOCK+(32*8*1)
<strong>copy16bytes</strong> SCREEN_ADR+32*(2*8+9), SECOND_SCREEN_BLOCK+(32*8*2)
<strong>copy16bytes</strong> SCREEN_ADR+32*(3*8+9), SECOND_SCREEN_BLOCK+(32*8*3)
<strong>copy16bytes</strong> SCREEN_ADR+32*(4*8+9), SECOND_SCREEN_BLOCK+(32*8*4)
<strong>copy16bytes</strong> SCREEN_ADR+32*(5*8+9), SECOND_SCREEN_BLOCK+(32*8*5)
<strong>copy16bytes</strong> SCREEN_ADR+32*(6*8+9), SECOND_SCREEN_BLOCK+(32*8*6)
<strong>copy16bytes</strong> SCREEN_ADR+32*(7*8+9), SECOND_SCREEN_BLOCK+(32*8*7)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód dnešního druhého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu, v&nbsp;němž
bude použito výše popsané makro <strong>copy16bytes</strong>, bude vypadat
následovně:</p>

<pre>
<i>; Example #91:</i>
&nbsp;
SCREEN_ADR          equ $4000
SCREEN_BLOCK_SIZE   equ 32*64
SECOND_SCREEN_BLOCK equ SCREEN_ADR+SCREEN_BLOCK_SIZE
&nbsp;
CHAR_ADR            equ $3c00
ENTRY_POINT         equ $8000
&nbsp;
<strong>copy16bytes</strong> MACRO source_address, destination_address
        ld   sp, source_address
        pop  af
        pop  bc
        pop  de
        pop  hl
        exx
        ex   af, af'
        pop  af
        pop  bc
        pop  de
        pop  hl
        ld   sp, destination_address+16
        push hl
        push de
        push bc
        push af
        exx
        ex   af, af'
        push hl
        push de
        push bc
        push af
ENDM
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call fill_in_screen           <i>; vyplnění obrazovky ASCII tabulkami</i>
        di
&nbsp;
        <strong>copy16bytes</strong> SCREEN_ADR+32*(0*8+9), SECOND_SCREEN_BLOCK+(32*8*0)
        <strong>copy16bytes</strong> SCREEN_ADR+32*(1*8+9), SECOND_SCREEN_BLOCK+(32*8*1)
        <strong>copy16bytes</strong> SCREEN_ADR+32*(2*8+9), SECOND_SCREEN_BLOCK+(32*8*2)
        <strong>copy16bytes</strong> SCREEN_ADR+32*(3*8+9), SECOND_SCREEN_BLOCK+(32*8*3)
        <strong>copy16bytes</strong> SCREEN_ADR+32*(4*8+9), SECOND_SCREEN_BLOCK+(32*8*4)
        <strong>copy16bytes</strong> SCREEN_ADR+32*(5*8+9), SECOND_SCREEN_BLOCK+(32*8*5)
        <strong>copy16bytes</strong> SCREEN_ADR+32*(6*8+9), SECOND_SCREEN_BLOCK+(32*8*6)
        <strong>copy16bytes</strong> SCREEN_ADR+32*(7*8+9), SECOND_SCREEN_BLOCK+(32*8*7)
&nbsp;
        ld sp, SCREEN_ADR+SECOND_SCREEN_BLOCK+2048
        ei
<strong>finito</strong>:
        jr finito                     <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR        <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_ascii_table</strong>:
        <i>; Vytištění ASCII tabulky</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_char</strong>:
        <i>; Vytištění jednoho znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
loop:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/91-copy-ascii-table-G.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/91-copy-ascii-table-G.asm</a>.</div></p>

<p>Na tomto místě je vhodné si ověřit, jakým způsobem bylo vlastně makro
<strong>copy16bytes</strong> expandováno a jak rozsáhlý je výsledný zdrojový
kód. Všechny tyto informace lze nalézt s&nbsp;<i>listingu</i>, který assembler
<i>Pasmo</i> může vytvářet (opět se jedná o vlastnost společnou mnoha moderním
assemblerům):</p>

<pre>
SCREEN_ADR      EQU 4000
SCREEN_BLOCK_SIZE EQU 0800
SECOND_SCREEN_BLOCK EQU 4800
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
Defining MACRO copy16bytes
Params: source_address, destination_address
                ORG 8000
8000:           label start
8000:CDDA80     CALL 80DA
8003:F3         DI
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( 0000 * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * 0000 ) 
LD SP , source_address 
8004:312041     LD SP, 4120
POP AF 
8007:F1         POP AF
POP BC 
8008:C1         POP BC
POP DE 
8009:D1         POP DE
POP HL 
800A:E1         POP HL
EXX 
800B:D9         EXX
EX AF , AF' 
800C:08         EX AF, AF'
POP AF 
800D:F1         POP AF
POP BC 
800E:C1         POP BC
POP DE 
800F:D1         POP DE
POP HL 
8010:E1         POP HL
LD SP , destination_address + 0010 
8011:311048     LD SP, 4810
PUSH HL 
8014:E5         PUSH HL
PUSH DE 
8015:D5         PUSH DE
PUSH BC 
8016:C5         PUSH BC
PUSH AF 
8017:F5         PUSH AF
EXX 
8018:D9         EXX
EX AF , AF' 
8019:08         EX AF, AF'
PUSH HL 
801A:E5         PUSH HL
PUSH DE 
801B:D5         PUSH DE
PUSH BC 
801C:C5         PUSH BC
PUSH AF 
801D:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( 0001 * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * 0001 ) 
LD SP , source_address 
801E:312042     LD SP, 4220
POP AF 
8021:F1         POP AF
POP BC 
8022:C1         POP BC
POP DE 
8023:D1         POP DE
POP HL 
8024:E1         POP HL
EXX 
8025:D9         EXX
EX AF , AF' 
8026:08         EX AF, AF'
POP AF 
8027:F1         POP AF
POP BC 
8028:C1         POP BC
POP DE 
8029:D1         POP DE
POP HL 
802A:E1         POP HL
LD SP , destination_address + 0010 
802B:311049     LD SP, 4910
PUSH HL 
802E:E5         PUSH HL
PUSH DE 
802F:D5         PUSH DE
PUSH BC 
8030:C5         PUSH BC
PUSH AF 
8031:F5         PUSH AF
EXX 
8032:D9         EXX
EX AF , AF' 
8033:08         EX AF, AF'
PUSH HL 
8034:E5         PUSH HL
PUSH DE 
8035:D5         PUSH DE
PUSH BC 
8036:C5         PUSH BC
PUSH AF 
8037:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( 0002 * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * 0002 ) 
LD SP , source_address 
8038:312043     LD SP, 4320
POP AF 
803B:F1         POP AF
POP BC 
803C:C1         POP BC
POP DE 
803D:D1         POP DE
POP HL 
803E:E1         POP HL
EXX 
803F:D9         EXX
EX AF , AF' 
8040:08         EX AF, AF'
POP AF 
8041:F1         POP AF
POP BC 
8042:C1         POP BC
POP DE 
8043:D1         POP DE
POP HL 
8044:E1         POP HL
LD SP , destination_address + 0010 
8045:31104A     LD SP, 4A10
PUSH HL 
8048:E5         PUSH HL
PUSH DE 
8049:D5         PUSH DE
PUSH BC 
804A:C5         PUSH BC
PUSH AF 
804B:F5         PUSH AF
EXX 
804C:D9         EXX
EX AF , AF' 
804D:08         EX AF, AF'
PUSH HL 
804E:E5         PUSH HL
PUSH DE 
804F:D5         PUSH DE
PUSH BC 
8050:C5         PUSH BC
PUSH AF 
8051:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( 0003 * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * 0003 ) 
LD SP , source_address 
8052:312044     LD SP, 4420
POP AF 
8055:F1         POP AF
POP BC 
8056:C1         POP BC
POP DE 
8057:D1         POP DE
POP HL 
8058:E1         POP HL
EXX 
8059:D9         EXX
EX AF , AF' 
805A:08         EX AF, AF'
POP AF 
805B:F1         POP AF
POP BC 
805C:C1         POP BC
POP DE 
805D:D1         POP DE
POP HL 
805E:E1         POP HL
LD SP , destination_address + 0010 
805F:31104B     LD SP, 4B10
PUSH HL 
8062:E5         PUSH HL
PUSH DE 
8063:D5         PUSH DE
PUSH BC 
8064:C5         PUSH BC
PUSH AF 
8065:F5         PUSH AF
EXX 
8066:D9         EXX
EX AF , AF' 
8067:08         EX AF, AF'
PUSH HL 
8068:E5         PUSH HL
PUSH DE 
8069:D5         PUSH DE
PUSH BC 
806A:C5         PUSH BC
PUSH AF 
806B:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( 0004 * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * 0004 ) 
LD SP , source_address 
806C:312045     LD SP, 4520
POP AF 
806F:F1         POP AF
POP BC 
8070:C1         POP BC
POP DE 
8071:D1         POP DE
POP HL 
8072:E1         POP HL
EXX 
8073:D9         EXX
EX AF , AF' 
8074:08         EX AF, AF'
POP AF 
8075:F1         POP AF
POP BC 
8076:C1         POP BC
POP DE 
8077:D1         POP DE
POP HL 
8078:E1         POP HL
LD SP , destination_address + 0010 
8079:31104C     LD SP, 4C10
PUSH HL 
807C:E5         PUSH HL
PUSH DE 
807D:D5         PUSH DE
PUSH BC 
807E:C5         PUSH BC
PUSH AF 
807F:F5         PUSH AF
EXX 
8080:D9         EXX
EX AF , AF' 
8081:08         EX AF, AF'
PUSH HL 
8082:E5         PUSH HL
PUSH DE 
8083:D5         PUSH DE
PUSH BC 
8084:C5         PUSH BC
PUSH AF 
8085:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( 0005 * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * 0005 ) 
LD SP , source_address 
8086:312046     LD SP, 4620
POP AF 
8089:F1         POP AF
POP BC 
808A:C1         POP BC
POP DE 
808B:D1         POP DE
POP HL 
808C:E1         POP HL
EXX 
808D:D9         EXX
EX AF , AF' 
808E:08         EX AF, AF'
POP AF 
808F:F1         POP AF
POP BC 
8090:C1         POP BC
POP DE 
8091:D1         POP DE
POP HL 
8092:E1         POP HL
LD SP , destination_address + 0010 
8093:31104D     LD SP, 4D10
PUSH HL 
8096:E5         PUSH HL
PUSH DE 
8097:D5         PUSH DE
PUSH BC 
8098:C5         PUSH BC
PUSH AF 
8099:F5         PUSH AF
EXX 
809A:D9         EXX
EX AF , AF' 
809B:08         EX AF, AF'
PUSH HL 
809C:E5         PUSH HL
PUSH DE 
809D:D5         PUSH DE
PUSH BC 
809E:C5         PUSH BC
PUSH AF 
809F:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( 0006 * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * 0006 ) 
LD SP , source_address 
80A0:312047     LD SP, 4720
POP AF 
80A3:F1         POP AF
POP BC 
80A4:C1         POP BC
POP DE 
80A5:D1         POP DE
POP HL 
80A6:E1         POP HL
EXX 
80A7:D9         EXX
EX AF , AF' 
80A8:08         EX AF, AF'
POP AF 
80A9:F1         POP AF
POP BC 
80AA:C1         POP BC
POP DE 
80AB:D1         POP DE
POP HL 
80AC:E1         POP HL
LD SP , destination_address + 0010 
80AD:31104E     LD SP, 4E10
PUSH HL 
80B0:E5         PUSH HL
PUSH DE 
80B1:D5         PUSH DE
PUSH BC 
80B2:C5         PUSH BC
PUSH AF 
80B3:F5         PUSH AF
EXX 
80B4:D9         EXX
EX AF , AF' 
80B5:08         EX AF, AF'
PUSH HL 
80B6:E5         PUSH HL
PUSH DE 
80B7:D5         PUSH DE
PUSH BC 
80B8:C5         PUSH BC
PUSH AF 
80B9:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( 0007 * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * 0007 ) 
LD SP , source_address 
80BA:312048     LD SP, 4820
POP AF 
80BD:F1         POP AF
POP BC 
80BE:C1         POP BC
POP DE 
80BF:D1         POP DE
POP HL 
80C0:E1         POP HL
EXX 
80C1:D9         EXX
EX AF , AF' 
80C2:08         EX AF, AF'
POP AF 
80C3:F1         POP AF
POP BC 
80C4:C1         POP BC
POP DE 
80C5:D1         POP DE
POP HL 
80C6:E1         POP HL
LD SP , destination_address + 0010 
80C7:31104F     LD SP, 4F10
PUSH HL 
80CA:E5         PUSH HL
PUSH DE 
80CB:D5         PUSH DE
PUSH BC 
80CC:C5         PUSH BC
PUSH AF 
80CD:F5         PUSH AF
EXX 
80CE:D9         EXX
EX AF , AF' 
80CF:08         EX AF, AF'
PUSH HL 
80D0:E5         PUSH HL
PUSH DE 
80D1:D5         PUSH DE
PUSH BC 
80D2:C5         PUSH BC
PUSH AF 
80D3:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
80D4:310090     LD SP, 9000
80D7:FB         EI
80D8:           label finito
80D8:18FE       JR 80D8
80DA:           label fill_in_screen
80DA:110040     LD DE, 4000
80DD:CDE180     CALL 80E1
80E0:C9         RET
80E1:           label draw_ascii_table
80E1:3E20       LD A, 20
80E3:           label next_char
80E3:F5         PUSH AF
80E4:CDF380     CALL 80F3
80E7:3E20       LD A, 20
80E9:CDF380     CALL 80F3
80EC:F1         POP AF
80ED:3C         INC A
80EE:FE80       CP 80
80F0:20F1       JR NZ, 80E3
80F2:C9         RET
80F3:           label draw_char
80F3:01003C     LD BC, 3C00
80F6:61         LD H, C
80F7:6F         LD L, A
80F8:29         ADD HL, HL
80F9:29         ADD HL, HL
80FA:29         ADD HL, HL
80FB:09         ADD HL, BC
80FC:0608       LD B, 08
80FE:4A         LD C, D
80FF:           label loop
80FF:7E         LD A, (HL)
8100:12         LD (DE), A
8101:2C         INC L
8102:14         INC D
8103:10FA       DJNZ 80FF
8105:1C         INC E
8106:C8         RET Z
8107:51         LD D, C
8108:C9         RET
8109:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8108
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že velikost strojového
kódu narostla na 264 bajtů, což je již ve světě ZX Spectra poměrně vysoké
číslo.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Opakování libovolného bloku v&nbsp;assembleru</h2>

<p></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Realizace kopie osmi bloků, z&nbsp;nichž každý má velikost šestnácti bajtů</h2>

<p></p>

<pre>
copy16bytes <strong>MACRO</strong> <u>source_address</u>, <u>destination_address</u>
        ld   sp, <u>source_address</u>
        pop  af
        pop  bc
        pop  de
        pop  hl
        exx
        ex   af, af'
        pop  af
        pop  bc
        pop  de
        pop  hl
        ld   sp, <u>destination_address+16</u>
        push hl
        push de
        push bc
        push af
        exx
        ex   af, af'
        push hl
        push de
        push bc
        push af
<strong>ENDM</strong>
</pre>

<p></p>

<pre>
REPT 8, cnt, 0
<strong>copy16bytes</strong> SCREEN_ADR+32*(cnt*8+9), SECOND_SCREEN_BLOCK+(32*8*cnt)
ENDM
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úplný zdrojový kód dnešního třetího demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního třetího demonstračního příkladu, v&nbsp;němž
bude využita opakovaná aplikace makra, bude vypadat následovně:</p>

<pre>
SCREEN_ADR          equ $4000
SCREEN_BLOCK_SIZE   equ 32*64
SECOND_SCREEN_BLOCK equ SCREEN_ADR+SCREEN_BLOCK_SIZE
&nbsp;
CHAR_ADR            equ $3c00
ENTRY_POINT         equ $8000
&nbsp;
copy16bytes MACRO source_address, destination_address
        ld   sp, source_address
        pop  af
        pop  bc
        pop  de
        pop  hl
        exx
        ex   af, af'
        pop  af
        pop  bc
        pop  de
        pop  hl
        ld   sp, destination_address+16
        push hl
        push de
        push bc
        push af
        exx
        ex   af, af'
        push hl
        push de
        push bc
        push af
ENDM
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call fill_in_screen           <i>; vyplnění obrazovky ASCII tabulkami</i>
        di
&nbsp;
        REPT 8, cnt, 0
        copy16bytes SCREEN_ADR+32*(cnt*8+9), SECOND_SCREEN_BLOCK+(32*8*cnt)
        ENDM
&nbsp;
        ld sp, SCREEN_ADR+SECOND_SCREEN_BLOCK+2048
        ei
<strong>finito</strong>:
        jr finito                     <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR        <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_ascii_table</strong>:
        <i>; Vytištění ASCII tabulky</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_char</strong>:
        <i>; Vytištění jednoho znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop</strong>:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/92-copy-ascii-table-H.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/92-copy-ascii-table-H.asm</a>.</div></p>

<p>Při expanzi makra vznikne již obrovský kód:</p>

<pre>
SCREEN_ADR      EQU 4000
SCREEN_BLOCK_SIZE EQU 0800
SECOND_SCREEN_BLOCK EQU 4800
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
Defining MACRO copy16bytes
Params: source_address, destination_address
                ORG 8000
8000:           label start
8000:CDAA81     CALL 81AA
8003:F3         DI
                REPT 8
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( cnt * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * cnt ) 
LD SP , source_address 
8004:312041     LD SP, 4120
POP AF 
8007:F1         POP AF
POP BC 
8008:C1         POP BC
POP DE 
8009:D1         POP DE
POP HL 
800A:E1         POP HL
EXX 
800B:D9         EXX
EX AF , AF' 
800C:08         EX AF, AF'
POP AF 
800D:F1         POP AF
POP BC 
800E:C1         POP BC
POP DE 
800F:D1         POP DE
POP HL 
8010:E1         POP HL
LD SP , destination_address + 0010 
8011:311048     LD SP, 4810
PUSH HL 
8014:E5         PUSH HL
PUSH DE 
8015:D5         PUSH DE
PUSH BC 
8016:C5         PUSH BC
PUSH AF 
8017:F5         PUSH AF
EXX 
8018:D9         EXX
EX AF , AF' 
8019:08         EX AF, AF'
PUSH HL 
801A:E5         PUSH HL
PUSH DE 
801B:D5         PUSH DE
PUSH BC 
801C:C5         PUSH BC
PUSH AF 
801D:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
...
...
...
Expanding MACRO copy16bytes
source_address= 0010 + SCREEN_ADR + 0020 * ( cnt * 0008 + 0009 ) 
destination_address= 0010 + SECOND_SCREEN_BLOCK + ( 0020 * 0008 * cnt ) 
LD SP , source_address 
818A:313048     LD SP, 4830
POP AF 
818D:F1         POP AF
POP BC 
818E:C1         POP BC
POP DE 
818F:D1         POP DE
POP HL 
8190:E1         POP HL
EXX 
8191:D9         EXX
EX AF , AF' 
8192:08         EX AF, AF'
POP AF 
8193:F1         POP AF
POP BC 
8194:C1         POP BC
POP DE 
8195:D1         POP DE
POP HL 
8196:E1         POP HL
LD SP , destination_address + 0010 
8197:31204F     LD SP, 4F20
PUSH HL 
819A:E5         PUSH HL
PUSH DE 
819B:D5         PUSH DE
PUSH BC 
819C:C5         PUSH BC
PUSH AF 
819D:F5         PUSH AF
EXX 
819E:D9         EXX
EX AF , AF' 
819F:08         EX AF, AF'
PUSH HL 
81A0:E5         PUSH HL
PUSH DE 
81A1:D5         PUSH DE
PUSH BC 
81A2:C5         PUSH BC
PUSH AF 
81A3:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
                ENDM
81A4:310090     LD SP, 9000
81A7:FB         EI
81A8:           label finito
81A8:18FE       JR 81A8
81AA:           label fill_in_screen
81AA:110040     LD DE, 4000
81AD:CDB181     CALL 81B1
81B0:C9         RET
81B1:           label draw_ascii_table
81B1:3E20       LD A, 20
81B3:           label next_char
81B3:F5         PUSH AF
81B4:CDC381     CALL 81C3
81B7:3E20       LD A, 20
81B9:CDC381     CALL 81C3
81BC:F1         POP AF
81BD:3C         INC A
81BE:FE80       CP 80
81C0:20F1       JR NZ, 81B3
81C2:C9         RET
81C3:           label draw_char
81C3:01003C     LD BC, 3C00
81C6:61         LD H, C
81C7:6F         LD L, A
81C8:29         ADD HL, HL
81C9:29         ADD HL, HL
81CA:29         ADD HL, HL
81CB:09         ADD HL, BC
81CC:0608       LD B, 08
81CE:4A         LD C, D
81CF:           label loop
81CF:7E         LD A, (HL)
81D0:12         LD (DE), A
81D1:2C         INC L
81D2:14         INC D
81D3:10FA       DJNZ 81CF
81D5:1C         INC E
81D6:C8         RET Z
81D7:51         LD D, C
81D8:C9         RET
81D9:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 81D8
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si délky kódu &ndash; celých
472 bajtů! To je cena, kterou zaplatíme za rozbalený a velmi rychlý kód pro
kopii bloků dat.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Kopie bloku pixelů na různá místa na obrazovce</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního čtvrtého a současně i posledního demonstračního
příkladu, v&nbsp;němž bude využita opakovaná aplikace makra, bude vypadat
následovně:</p>

<pre>
SCREEN_ADR          equ $4000
SCREEN_BLOCK_SIZE   equ 32*64
SECOND_SCREEN_BLOCK equ SCREEN_ADR+SCREEN_BLOCK_SIZE
&nbsp;
CHAR_ADR            equ $3c00
ENTRY_POINT         equ $8000
&nbsp;
copy16bytes MACRO source_address, destination_address
        ld   sp, source_address
        pop  af
        pop  bc
        pop  de
        pop  hl
        exx
        ex   af, af'
        pop  af
        pop  bc
        pop  de
        pop  hl
        ld   sp, destination_address+16
        push hl
        push de
        push bc
        push af
        exx
        ex   af, af'
        push hl
        push de
        push bc
        push af
ENDM
&nbsp;
        org ENTRY_POINT
&nbsp;
        <i>; Vstupní bod celého programu</i>
<strong>start</strong>:
        call fill_in_screen           <i>; vyplnění obrazovky ASCII tabulkami</i>
        di
&nbsp;
        REPT 8, cnt, 0
        copy16bytes SCREEN_ADR+32*(cnt*8+9), SECOND_SCREEN_BLOCK+(32*8*cnt)
        copy16bytes 16+SCREEN_ADR+32*(cnt*8+9), 16+SECOND_SCREEN_BLOCK+(32*8*cnt)
        ENDM
&nbsp;
        ld sp, SCREEN_ADR+SECOND_SCREEN_BLOCK+2048
        ei
<strong>finito</strong>:
        jr finito                     <i>; ukončit program nekonečnou smyčkou</i>
&nbsp;
&nbsp;
<strong>fill_in_screen</strong>:
        <i>; Vyplnění obrazovky snadno rozpoznatelným vzorkem - ASCII tabulkami</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; žádné</i>
        ld de, SCREEN_ADR        <i>; adresa pro vykreslení prvního bloku znaků</i>
        call draw_ascii_table    <i>; vykreslení 96 znaků</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_ascii_table</strong>:
        <i>; Vytištění ASCII tabulky</i>
        <i>;       </i>
        <i>; vstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        ld a, ' '                <i>; kód vykreslovaného znaku</i>
<strong>next_char</strong>:
        push af                  <i>; uschovat akumulátor na zásobník</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, ' '                <i>; vykreslit za znakem mezeru</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        pop af                   <i>; obnovit akumulátor ze zásobníku</i>
        inc a                    <i>; ASCII kód dalšího znaku</i>
        cp  ' ' + 96             <i>; jsme již na konci ASCII tabulky?</i>
        jr nz, next_char         <i>; ne? potom pokračujeme</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>draw_char</strong>:
        <i>; Vytištění jednoho znaku na obrazovku</i>
        <i>;</i>
        <i>; vstupy:</i>
        <i>; A - kód znaku pro vykreslení</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení znaku</i>
        <i>;</i>
        <i>; výstupy:</i>
        <i>; DE - adresa v obrazové paměti pro vykreslení dalšího znaku</i>
        <i>;</i>
        <i>; změněné registry:</i>
        <i>; všechny</i>
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop</strong>:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld   (de),a              <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc  e
        ret  z                   <i>; D+=8,E=E+1=0</i>
        ld   d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu najdete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/93-copy-ascii-table-I.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/93-copy-ascii-table-I.asm</a>.</div></p>

<pre>
SCREEN_ADR      EQU 4000
SCREEN_BLOCK_SIZE EQU 0800
SECOND_SCREEN_BLOCK EQU 4800
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
Defining MACRO copy16bytes
Params: source_address, destination_address
                ORG 8000
8000:           label start
8000:CDAA81     CALL 81AA
8003:F3         DI
                REPT 8
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( cnt * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * cnt ) 
LD SP , source_address 
8004:312041     LD SP, 4120
POP AF 
8007:F1         POP AF
POP BC 
8008:C1         POP BC
POP DE 
8009:D1         POP DE
POP HL 
800A:E1         POP HL
EXX 
800B:D9         EXX
EX AF , AF' 
800C:08         EX AF, AF'
POP AF 
800D:F1         POP AF
POP BC 
800E:C1         POP BC
POP DE 
800F:D1         POP DE
POP HL 
8010:E1         POP HL
LD SP , destination_address + 0010 
8011:311048     LD SP, 4810
PUSH HL 
8014:E5         PUSH HL
PUSH DE 
8015:D5         PUSH DE
PUSH BC 
8016:C5         PUSH BC
PUSH AF 
8017:F5         PUSH AF
EXX 
8018:D9         EXX
EX AF , AF' 
8019:08         EX AF, AF'
PUSH HL 
801A:E5         PUSH HL
PUSH DE 
801B:D5         PUSH DE
PUSH BC 
801C:C5         PUSH BC
PUSH AF 
801D:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= 0010 + SCREEN_ADR + 0020 * ( cnt * 0008 + 0009 ) 
destination_address= 0010 + SECOND_SCREEN_BLOCK + ( 0020 * 0008 * cnt ) 
LD SP , source_address 
801E:313041     LD SP, 4130
POP AF 
8021:F1         POP AF
POP BC 
8022:C1         POP BC
POP DE 
8023:D1         POP DE
POP HL 
8024:E1         POP HL
EXX 
8025:D9         EXX
EX AF , AF' 
8026:08         EX AF, AF'
POP AF 
8027:F1         POP AF
POP BC 
8028:C1         POP BC
POP DE 
8029:D1         POP DE
POP HL 
802A:E1         POP HL
LD SP , destination_address + 0010 
802B:312048     LD SP, 4820
PUSH HL 
802E:E5         PUSH HL
PUSH DE 
802F:D5         PUSH DE
PUSH BC 
8030:C5         PUSH BC
PUSH AF 
8031:F5         PUSH AF
EXX 
8032:D9         EXX
EX AF , AF' 
8033:08         EX AF, AF'
PUSH HL 
8034:E5         PUSH HL
PUSH DE 
8035:D5         PUSH DE
PUSH BC 
8036:C5         PUSH BC
PUSH AF 
8037:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( cnt * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * cnt ) 
LD SP , source_address 
8038:312042     LD SP, 4220
POP AF 
803B:F1         POP AF
POP BC 
803C:C1         POP BC
POP DE 
803D:D1         POP DE
POP HL 
803E:E1         POP HL
EXX 
803F:D9         EXX
EX AF , AF' 
8040:08         EX AF, AF'
POP AF 
8041:F1         POP AF
POP BC 
8042:C1         POP BC
POP DE 
8043:D1         POP DE
POP HL 
8044:E1         POP HL
LD SP , destination_address + 0010 
8045:311049     LD SP, 4910
PUSH HL 
8048:E5         PUSH HL
PUSH DE 
8049:D5         PUSH DE
PUSH BC 
804A:C5         PUSH BC
PUSH AF 
804B:F5         PUSH AF
EXX 
804C:D9         EXX
EX AF , AF' 
804D:08         EX AF, AF'
PUSH HL 
804E:E5         PUSH HL
PUSH DE 
804F:D5         PUSH DE
PUSH BC 
8050:C5         PUSH BC
PUSH AF 
8051:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= 0010 + SCREEN_ADR + 0020 * ( cnt * 0008 + 0009 ) 
destination_address= 0010 + SECOND_SCREEN_BLOCK + ( 0020 * 0008 * cnt ) 
LD SP , source_address 
8052:313042     LD SP, 4230
POP AF 
8055:F1         POP AF
POP BC 
8056:C1         POP BC
POP DE 
8057:D1         POP DE
POP HL 
8058:E1         POP HL
EXX 
8059:D9         EXX
EX AF , AF' 
805A:08         EX AF, AF'
POP AF 
805B:F1         POP AF
POP BC 
805C:C1         POP BC
POP DE 
805D:D1         POP DE
POP HL 
805E:E1         POP HL
LD SP , destination_address + 0010 
805F:312049     LD SP, 4920
PUSH HL 
8062:E5         PUSH HL
PUSH DE 
8063:D5         PUSH DE
PUSH BC 
8064:C5         PUSH BC
PUSH AF 
8065:F5         PUSH AF
EXX 
8066:D9         EXX
EX AF , AF' 
8067:08         EX AF, AF'
PUSH HL 
8068:E5         PUSH HL
PUSH DE 
8069:D5         PUSH DE
PUSH BC 
806A:C5         PUSH BC
PUSH AF 
806B:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( cnt * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * cnt ) 
LD SP , source_address 
806C:312043     LD SP, 4320
POP AF 
806F:F1         POP AF
POP BC 
8070:C1         POP BC
POP DE 
8071:D1         POP DE
POP HL 
8072:E1         POP HL
EXX 
8073:D9         EXX
EX AF , AF' 
8074:08         EX AF, AF'
POP AF 
8075:F1         POP AF
POP BC 
8076:C1         POP BC
POP DE 
8077:D1         POP DE
POP HL 
8078:E1         POP HL
LD SP , destination_address + 0010 
8079:31104A     LD SP, 4A10
PUSH HL 
807C:E5         PUSH HL
PUSH DE 
807D:D5         PUSH DE
PUSH BC 
807E:C5         PUSH BC
PUSH AF 
807F:F5         PUSH AF
EXX 
8080:D9         EXX
EX AF , AF' 
8081:08         EX AF, AF'
PUSH HL 
8082:E5         PUSH HL
PUSH DE 
8083:D5         PUSH DE
PUSH BC 
8084:C5         PUSH BC
PUSH AF 
8085:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= 0010 + SCREEN_ADR + 0020 * ( cnt * 0008 + 0009 ) 
destination_address= 0010 + SECOND_SCREEN_BLOCK + ( 0020 * 0008 * cnt ) 
LD SP , source_address 
8086:313043     LD SP, 4330
POP AF 
8089:F1         POP AF
POP BC 
808A:C1         POP BC
POP DE 
808B:D1         POP DE
POP HL 
808C:E1         POP HL
EXX 
808D:D9         EXX
EX AF , AF' 
808E:08         EX AF, AF'
POP AF 
808F:F1         POP AF
POP BC 
8090:C1         POP BC
POP DE 
8091:D1         POP DE
POP HL 
8092:E1         POP HL
LD SP , destination_address + 0010 
8093:31204A     LD SP, 4A20
PUSH HL 
8096:E5         PUSH HL
PUSH DE 
8097:D5         PUSH DE
PUSH BC 
8098:C5         PUSH BC
PUSH AF 
8099:F5         PUSH AF
EXX 
809A:D9         EXX
EX AF , AF' 
809B:08         EX AF, AF'
PUSH HL 
809C:E5         PUSH HL
PUSH DE 
809D:D5         PUSH DE
PUSH BC 
809E:C5         PUSH BC
PUSH AF 
809F:F5         PUSH AF
ENDM 
                ENDM
End of MACRO copy16bytes
Expanding MACRO copy16bytes
source_address= SCREEN_ADR + 0020 * ( cnt * 0008 + 0009 ) 
destination_address= SECOND_SCREEN_BLOCK + ( 0020 * 0008 * cnt ) 
LD SP , source_address 
80A0:312044     LD SP, 4420
POP AF 
80A3:F1         POP AF
POP BC 
80A4:C1         POP BC
POP DE 
80A5:D1         POP DE
POP HL 
80A6:E1         POP HL
EXX 
80A7:D9         EXX
EX AF , AF' 
80A8:08         EX AF, AF'
POP AF 
80A9:F1         POP AF
POP BC 
80AA:C1         POP BC
POP DE 
80AB:D1         POP DE
POP HL 
80AC:E1         POP HL
LD SP , destination_address + 0010 
80AD:31104B     LD SP, 4B10
PUSH HL 
80B0:E5         PUSH HL
PUSH DE 
80B1:D5         PUSH DE
PUSH BC 
80B2:C5         PUSH BC
PUSH AF 
80B3:F5         PUSH AF
EXX 
80B4:D9         EXX
EX AF , AF' 
80B5:08         EX AF, AF'
PUSH HL 
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Shrnutí: blokové přesuny dat na mikroprocesoru Z80</h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<p>Výše uvedené demonstrační příklady i příklady, které již byly popsány
v&nbsp;předchozích jedenácti článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">3</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny/">4</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-podruhe/">5</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny-potreti/">6</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-dokonceni-realizace-prikazu-plot/">7</a>],
[<a
href="https://www.root.cz/clanky/zobrazeni-cisel-a-zpracovani-priznaku-mikroprocesoru-zilog-z80/">8</a>],
[<a href="https://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ulozenymi-binarne-i-ve-formatu-bcd/">9</a>],
[<a href="https://www.root.cz/clanky/tisk-hexadecimalnich-hodnot-s-vyuzitim-instrukce-daa-na-zx-spectru/">10</a>],
[<a href="https://www.root.cz/clanky/kopie-datovych-bloku-na-zx-spectru-prenaseni-bajt-po-bajtu/">11</a>],
je možné přeložit s&nbsp;využitím souboru Makefile, jehož aktuální verze vypadá
následovně (pro překlad a slinkování je použit assembler <i>Pasmo</i>):</p>

<pre>
ASSEMBLER := pasmo
&nbsp;
all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap \
    31.tap 32.tap 33.tap 34.tap 35.tap 36.tap 37.tap 38.tap 39.tap 40.tap \
    41.tap 42.tap 43.tap 44.tap 45.tap 46.tap 47.tap 48.tap 49.tap 50.tap \
    51.tap 52.tap 53.tap 54.tap 55.tap 56.tap 57.tap 58.tap 59.tap 60.tap \
    61.tap 62.tap 63.tap 64.tap 65.tap 66.tap 67.tap 68.tap 69.tap 70.tap \
    71.tap 72.tap 73.tap 74.tap 75.tap 76.tap 77.tap 78.tap 79.tap 80.tap \
    81.tap 82.tap 83.tap 84.tap 85.tap 86.tap 87.tap 88.tap 80.tap 90.tap \
    91.tap 92.tap 93.tap 94.tap 95.tap 96.tap
&nbsp;
clean:
        rm -f *.tap
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 01-color-attribute.lst
&nbsp;
02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 02-blinking-attribute.lst
&nbsp;
03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 03-symbolic-names.lst
&nbsp;
04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 04-operators.lst
&nbsp;
05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 05-better-symbols.lst
&nbsp;
06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 06-tapbas-v1.lst
&nbsp;
07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 07-tapbas-v2.lst
&nbsp;
08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 08-loop.lst
&nbsp;
09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 09-loop.lst
&nbsp;
10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 10-loop.lst
&nbsp;
11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 11-loop.lst
&nbsp;
12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 12-loop.lst
&nbsp;
13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 13-loop.lst
&nbsp;
14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 14-loop.lst
&nbsp;
15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 15-loop.lst
&nbsp;
16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 16-loop.lst
&nbsp;
17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 17-loop.lst
&nbsp;
18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 18-cls.lst
&nbsp;
19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 19-print-char-call.lst
&nbsp;
20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 20-print-char-rst.lst
&nbsp;
21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 21-print-char.lst
&nbsp;
22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 22-print-all-chars.lst
&nbsp;
23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 23-print-all-chars.lst
&nbsp;
24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 24-change-color.lst
&nbsp;
25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 25-change-flash.lst
&nbsp;
26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 26-print-at.lst
&nbsp;
27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 27-print-string.lst
&nbsp;
28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 28-print-string.lst
&nbsp;
29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 29-print-colorized-string.lst
&nbsp;
30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 30-print-string-ROM.lst
&nbsp;
31.tap: 31-attributes.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 31-attributes.lst
&nbsp;
32.tap: 32-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 32-fill-in-vram.lst
&nbsp;
33.tap: 33-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 33-fill-in-vram-no-ret.lst
&nbsp;
34.tap: 34-fill-in-vram-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 34-fill-in-vram-pattern.lst
&nbsp;
35.tap: 35-slow-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 35-slow-fill-in-vram.lst
&nbsp;
36.tap: 36-slow-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 36-slow-fill-in-vram-no-ret.lst
&nbsp;
37.tap: 37-fill-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 37-fill-block.lst
&nbsp;
38.tap: 38-fill-block-with-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 38-fill-block-with-pattern.lst
&nbsp;
39.tap: 39-fill-block-optimized.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 39-fill-block-optimized.lst
&nbsp;
40.tap: 40-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 40-draw-char.lst
&nbsp;
41.tap: 41-draw-any-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 41-draw-any-char.lst
&nbsp;
42.tap: 42-block-anywhere.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 42-block-anywhere.lst
&nbsp;
43.tap: 43-block-anywhere-rrca.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 43-block-anywhere-rrca.lst
&nbsp;
44.tap: 44-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 44-better-draw-char.lst
&nbsp;
45.tap: 45-even-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 45-even-better-draw-char.lst
&nbsp;
46.tap: 46-draw-char-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 46-draw-char-at.lst
&nbsp;
47.tap: 47-draw-char-at-unrolled.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 47-draw-char-at-unrolled.lst
&nbsp;
48.tap: 48-incorrect-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 48-incorrect-print-string.lst
&nbsp;
49.tap: 49-correct-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 49-correct-print-string.lst
&nbsp;
50.tap: 50-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 50-ascii-table.lst
&nbsp;
51.tap: 51-plot-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 51-plot-block.lst
&nbsp;
52.tap: 52-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 52-plot-pixel.lst
&nbsp;
53.tap: 53-plot-pixel.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 53-plot-pixel.lst
&nbsp;
54.tap: 54-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 54-plot-pixel-on-background.lst
&nbsp;
55.tap: 55-plot-pixel-on-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 55-plot-pixel-on-background.lst
&nbsp;
56.tap: 56-inverse-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 56-inverse-ascii-table.lst
&nbsp;
57.tap: 57-plot-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 57-plot-pixel-on-inverse-background.lst
&nbsp;
58.tap: 58-plot-inverse-pixel-on-inverse-background.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 58-plot-inverse-pixel-on-inverse-background.lst
&nbsp;
59.tap: 59-configurable-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 59-configurable-ascii-table.lst
&nbsp;
60.tap: 60-plot-over.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 60-plot-over.lst
&nbsp;
61.tap: 61-print-number-A.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 61-print-number-A.lst
&nbsp;
62.tap: 62-print-number-B.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 62-print-number-B.lst
&nbsp;
63.tap: 63-print-number-C.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 63-print-number-C.lst
&nbsp;
64.tap: 64-print-number-D.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 64-print-number-D.lst
&nbsp;
65.tap: 65-more-numbers-A.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 65-more-numbers-A.lst
&nbsp;
66.tap: 66-more-numbers-B.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 66-more-numbers-B.lst
&nbsp;
67.tap: 67-print-flags-1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 67-print-flags-1.lst
&nbsp;
68.tap: 68-print-flags-2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 68-print-flags-2.lst
&nbsp;
69.tap: 69-print-flags-3.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 69-print-flags-3.lst
&nbsp;
70.tap: 70-print-flags-4.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 70-print-flags-4.lst
&nbsp;
71.tap: 71-print-flags-5.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 71-print-flags-5.lst
&nbsp;
72.tap: 72-print-flags-6.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 72-print-flags-6.lst
&nbsp;
73.tap: 73-print-flags-7.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 73-print-flags-7.lst
&nbsp;
74.tap: 74-print-hex-number.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 74-print-hex-number.lst
&nbsp;
75.tap: 75-print-hex-number.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 75-print-hex-number.lst
&nbsp;
76.tap: 76-print-hex-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 76-print-hex-numbers.lst
&nbsp;
77.tap: 77-add-hex-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 77-add-hex-numbers.lst
&nbsp;
78.tap: 78-add-bcd-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 78-add-bcd-numbers.lst
&nbsp;
79.tap: 79-print-hex-digit-jmp.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 79-print-hex-digit-jmp.lst
&nbsp;
80.tap: 80-print-hex-digit-overflow.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 80-print-hex-digit-overflow.lst
&nbsp;
81.tap: 81-print-hex-digit-daa.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 81-print-hex-digit-daa.lst
&nbsp;
82.tap: 82-print-hex-numbers-daa.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 82-print-hex-numbers-daa.lst
&nbsp;
83.tap: 83-print-fp-numbers.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 83-print-fp-numbers.lst
&nbsp;
84.tap: 84-print-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 84-print-ascii-table.lst
&nbsp;
85.tap: 85-copy-ascii-table.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 85-copy-ascii-table.lst
&nbsp;
86.tap: 86-copy-ascii-table-B.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 86-copy-ascii-table-B.lst
&nbsp;
87.tap: 87-copy-ascii-table-C.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 87-copy-ascii-table-C.lst
&nbsp;
88.tap: 88-copy-ascii-table-D.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 88-copy-ascii-table-D.lst
&nbsp;
89.tap: 89-copy-ascii-table-E.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 89-copy-ascii-table-E.lst
&nbsp;
90.tap: 90-copy-ascii-table-F.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 90-copy-ascii-table-F.lst
&nbsp;
91.tap: 91-copy-ascii-table-G.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 91-copy-ascii-table-G.lst
&nbsp;
92.tap: 92-copy-ascii-table-H.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 92-copy-ascii-table-H.lst
&nbsp;
93.tap: 93-copy-ascii-table-I.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 93-copy-ascii-table-I.lst
&nbsp;
94.tap: 94-color-attribute.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 94-color-attribute.lst
&nbsp;
95.tap: 95-keypress.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 95-keypress.lst
&nbsp;
96.tap: 96-keypress-row.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 96-keypress-row.lst
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>31-attributes.asm</td><td>modifikace atributů pro tisk řetězce subrutinou uloženou v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a></td></tr>
<tr><td>32</td><td>32-fill-in-vram.asm</td><td>vyplnění celé bitmapy barvou popředí, návrat do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a></td></tr>
<tr><td>33</td><td>33-fill-in-vram-no-ret.asm</td><td>vyplnění celé bitmapy barvou popředí, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>34</td><td>34-fill-in-vram-pattern.asm</td><td>vyplnění celé bitmapy zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a></td></tr>
<tr><td>35</td><td>35-slow-fill-in-vram.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a></td></tr>
<tr><td>36</td><td>36-slow-fill-in-vram-no-ret.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>37</td><td>37-fill-block.asm</td><td>vykreslení bloku 8&times;8 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a></td></tr>
<tr><td>38</td><td>38-fill-block-with-pattern.asm</td><td>vykreslení bloku 8&times;8 pixelů zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a></td></tr>
<tr><td>39</td><td>39-fill-block-optimized.asm</td><td>optimalizace předchozího příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a></td></tr>
<tr><td>40</td><td>40-draw-char.asm</td><td>vykreslení znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a></td></tr>
<tr><td>41</td><td>41-draw-any-char.asm</td><td>podprogram pro vykreslení libovolně zvoleného znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a></td></tr>
<tr><td>42</td><td>42-block-anywhere.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>43-block-anywhere-rrca.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm</a></td></tr>
<tr><td>44</td><td>44-better-draw-char.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm</a></td></tr>
<tr><td>45</td><td>45-even-better-draw-char.asm</td><td>posun offsetu pro vykreslení dalšího znaku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm</a></td></tr>
<tr><td>46</td><td>46-draw-char-at.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm</a></td></tr>
<tr><td>47</td><td>47-draw-char-at-unrolled.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm</a></td></tr>
<tr><td>48</td><td>48-incorrect-print-string.asm</td><td>tisk řetězce, nekorektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm</a></td></tr>
<tr><td>49</td><td>49-correct-print-string.asm</td><td>tisk řetězce, korektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>50-ascii-table.asm</td><td>tisk několika bloků ASCII tabulky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/50-ascii-table.asm</a></td></tr>
<tr><td>51</td><td>51-plot-block.asm</td><td>vykreslení pixelu verze 1: zápis celého bajtu na pozici pixelu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/51-plot-block.asm</a></td></tr>
<tr><td>52</td><td>52-plot-pixel.asm</td><td>vykreslení pixelu verze 2: korektní vykreslení jednoho pixelu, ovšem překreslení celého bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/52-plot-pixel.asm</a></td></tr>
<tr><td>53</td><td>53-plot-pixel.asm</td><td>vykreslení pixelu verze 3: vylepšená verze předchozího demonstračního příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/53-plot-pixel.asm</a></td></tr>
<tr><td>54</td><td>54-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (nekorektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/54-plot-pixel-on-background.asm</a></td></tr>
<tr><td>55</td><td>55-plot-pixel-on-background.asm</td><td>vykreslení pixelu vůči pozadí (korektní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/55-plot-pixel-on-background.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>56</td><td>56-inverse-ascii-table.asm</td><td>vykreslení ASCII tabulky inverzní barvou (inkoust vs. papír)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/56-inverse-ascii-table.asm</a></td></tr>
<tr><td>57</td><td>57-plot-pixel-on-inverse-background.asm</td><td>vykreslení pixelů barvou papíru proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/57-plot-pixel-on-inverse-background.asm</a></td></tr>
<tr><td>58</td><td>58-plot-inverse-pixel-on-inverse-background.asm</td><td>vykreslení pixelů inverzní barvou proti inverzní ASCII tabulce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/58-plot-inverse-pixel-on-inverse-background.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm58-plot-inverse-pixel-on-inverse-background.asm/</a></td></tr>
<tr><td>59</td><td>59-configurable-ascii-table.asm</td><td>vykreslení ASCII tabulky buď přímo inkoustem nebo inverzně</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/59-configurable-ascii-table.asm</a></td></tr>
<tr><td>60</td><td>60-plot-over.asm</td><td>přibližná implementace příkazu <strong>PLOT OVER</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/60-plot-over.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>61-print-number-A.asm</td><td>ukázka použití podprogramu pro tisk celého čísla</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/61-print-number-A.asm</a></td></tr>
<tr><td>62</td><td>62-print-number-B.asm</td><td>pokus o vytištění záporných čísel</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/62-print-number-B.asm</a></td></tr>
<tr><td>63</td><td>63-print-number-C.asm</td><td>tisk maximální podporované hodnoty 9999</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/63-print-number-C.asm</a></td></tr>
<tr><td>64</td><td>64-print-number-D.asm</td><td>tisk vyšší než podporované hodnoty 10000</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/64-print-number-D.asm</a></td></tr>
<tr><td>65</td><td>65-more-numbers-A.asm</td><td>vytištění číselné řady</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/65-more-numbers-A.asm</a></td></tr>
<tr><td>66</td><td>66-more-numbers-B.asm</td><td>kombinace tisku celočíselných hodnot s&nbsp;dalšími subrutinami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/66-more-numbers-B.asm</a></td></tr>
<tr><td>67</td><td>67-print-flags-1.asm</td><td>příznakové bity po provedení celočíselné operace 1+2</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/67-print-flags-1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/67-print-flags-1.asm</a></td></tr>
<tr><td>68</td><td>68-print-flags-2.asm</td><td>příznakové bity po provedení celočíselné operace 0+0</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/68-print-flags-2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/68-print-flags-2.asm</a></td></tr>
<tr><td>69</td><td>69-print-flags-3.asm</td><td>příznakové bity po provedení operace 255+1</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/69-print-flags-3.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/69-print-flags-3.asm</a></td></tr>
<tr><td>70</td><td>70-print-flags-4.asm</td><td>příznakové bity po provedení operace 254+1</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/70-print-flags-4.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/70-print-flags-4.asm</a></td></tr>
<tr><td>71</td><td>71-print-flags-5.asm</td><td>příznakové bity po provedení operace 255+255</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/71-print-flags-5.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/71-print-flags-5.asm</a></td></tr>
<tr><td>72</td><td>72-print-flags-6.asm</td><td>výsledek operace 100+100, nastavení příznakových bitů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/72-print-flags-6.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/72-print-flags-6.asm</a></td></tr>
<tr><td>73</td><td>73-print-flags-7.asm</td><td>výsledek operace 128+128, nastavení příznakových bitů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/73-print-flags-7.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/73-print-flags-7.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>74</td><td>74-print-hex-number.asm</td><td>tisk hexadecimálního čísla v&nbsp;rozsahu 0x00 až 0xff (neoptimalizovaná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/74-print-hex-number.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/74-print-hex-number.asm</a></td></tr>
<tr><td>75</td><td>75-print-hex-number.asm</td><td>tisk hexadecimálního čísla v&nbsp;rozsahu 0x00 až 0xff (optimalizovaná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/75-print-hex-number.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/75-print-hex-number.asm</a></td></tr>
<tr><td>76</td><td>76-print-hex-numbers.asm</td><td>tisk několika hexadecimálních hodnot</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/76-print-hex-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/76-print-hex-numbers.asm</a></td></tr>
<tr><td>77</td><td>77-add-hex-numbers.asm</td><td>součet dvou osmibitových hexadecimálních hodnot s&nbsp;tiskem všech výsledků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/77-add-hex-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/77-add-hex-numbers.asm</a></td></tr>
<tr><td>78</td><td>78-add-bcd-numbers.asm</td><td>součet dvou osmibitových BCD hodnot s&nbsp;tiskem všech výsledků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/78-add-bcd-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/78-add-bcd-numbers.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>79</td><td>79-print-hex-digit-jmp.asm</td><td>tisk jedné hexadecimální cifry s&nbsp;využitím podmíněného skoku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/79-print-hex-digit-jmp.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/79-print-hex-digit-jmp.asm</a></td></tr>
<tr><td>80</td><td>80-print-hex-digit-overflow.asm</td><td>otestování, jaký znak je vytištěn pro hodnoty větší než 15</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/80-print-hex-digit-overflow.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/80-print-hex-digit-overflow.asm</a></td></tr>
<tr><td>81</td><td>81-print-hex-digit-daa.asm</td><td>tisk jedné hexadecimální cifry s&nbsp;využitím instrukce DAA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/81-print-hex-digit-daa.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/81-print-hex-digit-daa.asm</a></td></tr>
<tr><td>82</td><td>82-print-hex-numbers-daa.asm</td><td>tisk série hexadecimálních hodnot s&nbsp;využitím instrukce DAA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/82-print-hex-numbers-daa.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/82-print-hex-numbers-daa.asm</a></td></tr>
<tr><td>83</td><td>83-print-fp-numbers.asm</td><td>tisk numerických hodnot reprezentovaných v&nbsp;systému plovoucí řádové tečky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/83-print-fp-numbers.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/83-print-fp-numbers.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>84</td><td>84-print-ascii-table.asm</td><td>tisk jednoho bloku s&nbsp;ASCII tabulkou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/84-print-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/84-print-ascii-table.asm</a></td></tr>
<tr><td>85</td><td>85-copy-ascii-table.asm</td><td>kopie bloku bajt po bajtu založená na naivní programové smyčce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/85-copy-ascii-table.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/85-copy-ascii-table.asm</a></td></tr>
<tr><td>86</td><td>86-copy-ascii-table-B.asm</td><td>kopie bloku s&nbsp;využitím instrukce <strong>LDIR</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/86-copy-ascii-table-B.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/86-copy-ascii-table-B.asm</a></td></tr>
<tr><td>87</td><td>87-copy-ascii-table-C.asm</td><td>kopie bloku bajt po bajtu založená na programové smyčce a instrukci <strong>LDI</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/87-copy-ascii-table-C.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/87-copy-ascii-table-C.asm</a></td></tr>
<tr><td>88</td><td>88-copy-ascii-table-D.asm</td><td>rozbalení programové smyčky s&nbsp;instrukcí <strong>LDI</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/88-copy-ascii-table-D.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/88-copy-ascii-table-D.asm</a></td></tr>
<tr><td>89</td><td>89-copy-ascii-table-E.asm</td><td>korektní smyčka pro všechny možné velikosti bloků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/89-copy-ascii-table-E.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/89-copy-ascii-table-E.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>90</td><td>90-copy-ascii-table-F.asm</td><td>kostra programu, který pro kopii bloků (16 bajtů) využívá zásobník</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/90-copy-ascii-table-F.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/90-copy-ascii-table-F.asm</a></td></tr>
<tr><td>91</td><td>91-copy-ascii-table-G.asm</td><td>definice makra a několikeré použití (aplikace) tohoto makra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/91-copy-ascii-table-G.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/91-copy-ascii-table-G.asm</a></td></tr>
<tr><td>92</td><td>92-copy-ascii-table-H.asm</td><td>opakování makra založené na <strong>REPT</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/92-copy-ascii-table-H.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/92-copy-ascii-table-H.asm</a></td></tr>
<tr><td>93</td><td>93-copy-ascii-table-I.asm</td><td>vícenásobná kopie části obrazovky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/93-copy-ascii-table-I.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/93-copy-ascii-table-I.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>91</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech demonstračních příkladů do podoby obrazu magnetické pásky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>The system variables<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html</a>
</li>

<li>ZX Spectrum manual: chapter #17 Graphics<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html</a>
</li>

<li>Why does Sinclair BASIC have two formats for storing numbers in the same structure?<br />
<a href="https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu">https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu</a>
</li>

<li>Plovoucí řádová čárka na ZX Spectru<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k05</a>
</li>

<li>1A1B: THE 'REPORT AND LINE NUMBER PRINTING' SUBROUTINE<br />
<a href="https://skoolkid.github.io/rom/asm/1A1B.html">https://skoolkid.github.io/rom/asm/1A1B.html</a>
</li>

<li>2DE3: THE 'PRINT A FLOATING-POINT NUMBER' SUBROUTINE<br />
<a href="https://skoolkid.github.io/rom/asm/2DE3.html">https://skoolkid.github.io/rom/asm/2DE3.html</a>
</li>

<li>5C63: STKBOT - Address of bottom of calculator stack<br />
<a href="https://skoolkid.github.io/rom/asm/5C63.html">https://skoolkid.github.io/rom/asm/5C63.html</a>
</li>

<li>5C65: STKEND - Address of start of spare space<br />
<a href="https://skoolkid.github.io/rom/asm/5C65.html">https://skoolkid.github.io/rom/asm/5C65.html</a>
</li>

<li>Why does Sinclair BASIC have two formats for storing numbers in the same structure?<br />
<a href="https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu">https://retrocomputing.stackexchange.com/questions/8834/why-does-sinclair-basic-have-two-formats-for-storing-numbers-in-the-same-structu</a>
</li>

<li>Chapter 24: The memory<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap24.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap24.html</a>
</li>

<li>Survey of Floating-Point Formats  <br />
<a href="https://mrob.com/pub/math/floatformats.html">https://mrob.com/pub/math/floatformats.html</a>
</li>

<li>Convert an 8bit number to hex in z80 assembler<br />
<a href="https://stackoverflow.com/questions/22838444/convert-an-8bit-number-to-hex-in-z80-assembler">https://stackoverflow.com/questions/22838444/convert-an-8bit-number-to-hex-in-z80-assembler</a>
</li>

<li>80 MICROPROCESSOR Instruction Set Summary<br />
<a href="http://www.textfiles.com/programming/CARDS/z80">http://www.textfiles.com/programming/CARDS/z80</a>
</li>

<li>Extended Binary Coded Decimal Interchange Code<br />
<a href="http://en.wikipedia.org/wiki/EBCDIC">http://en.wikipedia.org/wiki/EBCDIC</a>
</li>

<li>ASCII/EBCDIC Conversion Table<br />
<a href="http://docs.hp.com/en/32212-90008/apcs01.html">http://docs.hp.com/en/32212-90008/apcs01.html</a>
</li>

<li>EBCDIC<br />
<a href="http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php">http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php</a>
</li>

<li>EBCDIC tables<br />
<a href="http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm">http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm</a>
</li>

<li>The Mainframe Blog<br />
<a href="http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html">http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>BCD<br />
<a href="https://cs.wikipedia.org/wiki/BCD">https://cs.wikipedia.org/wiki/BCD</a>
</li>

<li>Z80 heaven: Floating Point<br />
<a href="http://z80-heaven.wikidot.com/floating-point">http://z80-heaven.wikidot.com/floating-point</a>
</li>

<li>Z80, the 8-bit Number Cruncher<br />
<a href="http://www.andreadrian.de/oldcpu/Z80_number_cruncher.html">http://www.andreadrian.de/oldcpu/Z80_number_cruncher.html</a>
</li>

<li>Floating-point library for Z80<br />
<a href="https://github.com/DW0RKiN/Floating-point-Library-for-Z80">https://github.com/DW0RKiN/Floating-point-Library-for-Z80</a>
</li>

<li>z80float<br />
<a href="https://github.com/Zeda/z80float">https://github.com/Zeda/z80float</a>
</li>

<li>Fixed point arithmetic<br />
<a href="https://www.root.cz/clanky/fixed-point-arithmetic/">https://www.root.cz/clanky/fixed-point-arithmetic/</a>
</li>

<li>ZX Spectrum BASIC Programming - 2nd Edition<br />
<a href="https://archive.org/details/zx-spectrum-basic-programming/page/n167/mode/2up">https://archive.org/details/zx-spectrum-basic-programming/page/n167/mode/2up</a>
</li>

<li>ZX Spectrum BASIC Programming - 2nd Edition<br />
<a href="https://archive.org/details/zx-spectrum-basic-programming/page/n169/mode/2up">https://archive.org/details/zx-spectrum-basic-programming/page/n169/mode/2up</a>
</li>

<li>How fast is memcpy on the Z80?<br />
<a href="https://retrocomputing.stackexchange.com/questions/4744/how-fast-is-memcpy-on-the-z80">https://retrocomputing.stackexchange.com/questions/4744/how-fast-is-memcpy-on-the-z80</a>
</li>

<li>How do Z80 Block Transfer instructions work?<br />
<a href="https://retrocomputing.stackexchange.com/questions/5416/how-do-z80-block-transfer-instructions-work">https://retrocomputing.stackexchange.com/questions/5416/how-do-z80-block-transfer-instructions-work</a>
</li>

<li>Retro Programming Made Simple: Keyboard<br />
<a href="http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/keyboard">http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/keyboard</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

