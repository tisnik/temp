<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Specifika instrukční sady mikroprocesorů Intel 8086/8088 (3)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Specifika instrukční sady mikroprocesorů Intel 8086/8088 (3)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku dokončíme popis blokových a řetězcových instrukcí, které jsou specifickým rysem instrukční sady mikroprocesorů Intel 8086/8088. Ukážeme si vliv směru přenosu dat a zaměříme se na problematiku rychlosti provádění blokových operací.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Specifika instrukční sady mikroprocesorů Intel 8086/8088 (3)</a></p>
<p><a href="#k02">2. Blokový přenos prováděný po bajtech</a></p>
<p><a href="#k03">3. Realizace blokového přenosu instrukcí <strong>MOVSx</strong></a></p>
<p><a href="#k04">4. Opakování operace blokového přenosu prefixem <strong>REP</strong></a></p>
<p><a href="#k05">5. Porovnání rychlosti jednotlivých realizací blokových přenosů</a></p>
<p><a href="#k06">6. Krátké zopakování: přenos rastrového obrázku z&nbsp;kódového segmentu do obrazové paměti</a></p>
<p><a href="#k07">7. Přenos maximálního počtu bajtů instrukcí <strong>REP MOVSB</strong></a></p>
<p><a href="#k08">8. Jak velký blok se přenese při nastavení <strong>CX=0</strong>?</a></p>
<p><a href="#k09">9. Přenos po bajtech, 16bitových slovech nebo 32bitových slovech</a></p>
<p><a href="#k10">10. Porovnání rychlosti přenosu realizovaného po bajtech, 16bitových či 32bitových slovech</a></p>
<p><a href="#k11">11. Počet cyklů nutných pro přenos bloku o velikosti 64000 bajtů</a></p>
<p><a href="#k12">12. Určení směru přenosu při blokových operacích</a></p>
<p><a href="#k13">13. Blokový přenos ve chvíli, kdy se zdrojový a cílový blok překrývají</a></p>
<p><a href="#k14">14. Realizace zpětného blokového přenosu</a></p>
<p><a href="#k15">15. Korektní realizace zpětného blokového přenosu</a></p>
<p><a href="#k16">16. Úplný zdrojový kód příkladu realizujícího zpětný blokový přenos</a></p>
<p><a href="#k17">*** 17. Vyhledávání znaku v&nbsp;řetězci</a></p>
<p><a href="#k18">18. Seznam již popsaných instrukcí</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Specifika instrukční sady mikroprocesorů Intel 8086/8088 (3)</h2>

<p>V&nbsp;dnešním článku dokončíme popis blokových a řetězcových instrukcí,
které jsou specifickým rysem instrukční sady mikroprocesorů Intel 8086 (a tím
pádem i Intel 8088). Ukážeme si například vliv změny směru načítání či ukládání
dat, vliv instrukčního prefixu <strong>REP</strong>, ale například i způsob
vyhledání znaku v&nbsp;řetězci atd. Nezapomeneme ani na problematiku rychlosti
provádění blokových operací, protože mikroprocesory Intel se v&nbsp;tomto
ohledu dosti významným způsobem zlepšovaly.</p>

<p>Připomeňme si, které instrukce řadíme mezi instrukce řetězcové a
blokové:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis instrukce</th></tr>
<tr><td>CLD</td><td>nastaví příznak DF pro určení směru přenosu (nahoru/dolů)</td></tr>
<tr><td>STD</td><td>nastaví příznak DF pro určení směru přenosu (nahoru/dolů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>LODSB</td><td>načtení bajtu do AL z DS : [SI], zvýšení/snížení SI o 1</td></tr>
<tr><td>LODSW</td><td>načtení slova do AX z DS : [SI], zvýšení/snížení SI o 2</td></tr>
<tr><td>STOSB</td><td>uložení slova z AL do ES : [DI], zvýšení/snížení DI o 1</td></tr>
<tr><td>STOSW</td><td>uložení slova z AL do ES : [DI], zvýšení/snížení DI o 2</td></tr>
<tr><td>MOVSB</td><td>kombinace LODSB + STOSB v&nbsp;jediné instrukci</td></tr>
<tr><td>MOVSW</td><td>kombinace LODSW + STOSW v&nbsp;jediné instrukci</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CMPSB</td><td>porovnání dvou bajtů z&nbsp;DS : [SI] a ES : [DI], zvýšení/snížení SI a DI</td></tr>
<tr><td>CMPSW</td><td>porovnání dvou slov z&nbsp;DS : [SI] a ES : [DI], zvýšení/snížení SI a DI</td></tr>
<tr><td>SCASB</td><td>nalezení bajtu v&nbsp;AL na adrese DS : [SI] (mění příznaky)</td></tr>
<tr><td>SCASW</td><td>nalezení bajtu v&nbsp;AX na adrese DS : [SI] (mění příznaky)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>INSB</td><td>přečtení bajtu z&nbsp;portu, uložení na ES : [DI], zvýšení/snížení DI</td></tr>
<tr><td>OUTSB</td><td>zápis bajtu na port z&nbsp;DS : [SI], zvýšení/snížení SI</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>REP/REPE/REPZ</td><td>opakování další operace CX-krát</td></tr>
<tr><td>REPNE/REPNZ</td><td>opakování další operace CX-krát, nebo až bude ZF==1</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Blokový přenos prováděný po bajtech</h2>

<p>Instrukce <strong>LODSB</strong> a <strong>STOSB</strong> můžeme velmi
snadno &bdquo;spárovat&ldquo; a realizovat tak operaci přesunu jednoho bajtu
(popř.&nbsp;16bitového nebo u pozdějších čipů i 32bitového slova). Připomeňme
si, že <strong>LODSB</strong> načítá hodnotu z&nbsp;adresy DS : [SI] a
<strong>STOSB</strong> ukládá hodnotu na adresu ES : [DI], přičemž se korektně
zvýší jak registr SI, tak i registr DI. A pochopitelně můžeme mezi
<strong>LODSB</strong> a <strong>STOSB</strong> vložit další
instrukci/instrukce a realizovat tak například negaci obrázku atd. Typicky se
tato dvojice instrukcí doplňuj instrukcí <strong>LOOP</strong> pro snížení
registru CX o jedničku a skok ve chvíli, kdy se ještě nedosáhlo nuly:</p>

<pre>
<strong>opak</strong>:
        lodsb     <i>; precteni bajtu a posun adresy</i>
        ...       <i>; modifikace bajtu v AL</i>
        stosb     <i>; zapis bajtu a posun adresy</i>
        loop opak
</pre>

<p>V&nbsp;dnešním prvním demonstračním příkladu přepíšeme část řetězce na
adrese <strong>message</strong> částí řetězce na adrese
<strong>replacement</strong>. Řetězce nejsou ukončeny nulou, takže použijeme
explicitně nastavené počitadlo:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        print message
&nbsp;
        push cs
        pop  es   <i>; ES:DI obsahuje adresu prvniho znaku ve zprave</i>
        mov  di, message
&nbsp;
        push cs
        pop  ds   <i>; DS:SI obsahuje adresu prvniho znaku ve zprave</i>
        mov  si, replacement
&nbsp;
        mov  cx, 12 <i>; pocet prepisovanych znaku</i>
<strong>opak</strong>:
        lodsb     <i>; precteni znaku a posun adresy</i>
        stosb     <i>; zapis znaku a posun adresy</i>
        loop opak
&nbsp;
        print message
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong>     db "Hello, world!", 0x0d, 0x0a, "$"
<strong>replacement</strong> db "Zdravim svet"
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Realizace blokového přenosu instrukcí <strong>MOVSx</strong></h2>

<p>V&nbsp;praxi se velmi často setkáme s&nbsp;požadavkem na realizaci
&bdquo;čistého&ldquo; blokového přenosu, při němž se nijak nemění přenášená
data. To znamená, že namísto:</p>

<pre>
<strong>opak</strong>:
        lodsb     <i>; precteni bajtu a posun adresy</i>
        ...       <i>; modifikace bajtu v AL</i>
        stosb     <i>; zapis bajtu a posun adresy</i>
        loop opak
</pre>

<p>vlastně potřebujeme realizovat pouze:</p>

<pre>
<strong>opak</strong>:
        lodsb     <i>; precteni bajtu a posun adresy</i>
        stosb     <i>; zapis bajtu a posun adresy</i>
        loop opak
</pre>

<p>V&nbsp;instrukčním souboru mikroprocesorů Intel 8086/8088 ovšem existuje i
instrukce <strong>MOVSx</strong> (tedy například <strong>MOVSB</strong>), která
spojuje možnosti <strong>LODSB</strong> a <strong>STOSB</strong> do jediné
instrukce (což je interně již dosti komplikovaná operace):</p>

<pre>
<strong>opak</strong>:
        movsb     <i>; precteni bajtu a posun adresy, zapis bajtu a posun adresy</i>
        loop opak
</pre>

<p>Otestujme si i tuto operaci na nepatrně upraveném demonstračním
příkladu:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        print message
&nbsp;
        push cs
        pop  es   <i>; ES:DI obsahuje adresu prvniho znaku ve zprave</i>
        mov  di, message
&nbsp;
        push cs
        pop  ds   <i>; DS:SI obsahuje adresu prvniho znaku ve zprave</i>
        mov  si, replacement
&nbsp;
        mov  cx, 12 <i>; pocet prepisovanych znaku</i>
<strong>opak</strong>:
        movsb     <i>; precteni znaku a posun adresy</i>
                  <i>; zapis znaku a posun adresy</i>
        loop opak
&nbsp;
        print message
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong>     db "Hello, world!", 0x0d, 0x0a, "$"
<strong>replacement</strong> db "Zdravim svet"
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Opakování operace blokového přenosu prefixem <strong>REP</strong></h2>

<p>Již minule jsme se seznámili s&nbsp;instrukčním prefixem
<strong>REP</strong>, který umožňuje opakovat některou z&nbsp;řetězcových nebo
blokových operací (<strong>STOSB</strong>, <strong>LODSB</strong> atd.)
CX-krát. Tentýž instrukční prefix je možné použít společně s&nbsp;operací
<strong>MOVSB</strong> a realizovat tak skutečný blokový přenos z&nbsp;adresy
<strong>DS : [SI]</strong> do paměťového bloku začínajícího na adrese
<strong>ES : [DI]</strong>, přičemž se přenese přesně CX bajtů:</p>

<pre>
        mov  cx, 12 <i>; pocet prepisovanych znaku</i>
        rep movsb   <i>; precteni znaku a posun adresy</i>
                    <i>; zapis znaku a posun adresy</i>
</pre>

<p>Opět si ukažme použití takto modifikované instrukce pro přepis obsahu části
řetězce jiným řetězcem. Bude se tedy jednat o zkrácenou verzi předchozích dvou
demonstračních příkladů:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        print message
&nbsp;
        push cs
        pop  es   <i>; ES:DI obsahuje adresu prvniho znaku ve zprave</i>
        mov  di, message
&nbsp;
        push cs
        pop  ds   <i>; DS:SI obsahuje adresu prvniho znaku ve zprave</i>
        mov  si, replacement
&nbsp;
        mov  cx, 12 <i>; pocet prepisovanych znaku</i>
        rep movsb   <i>; precteni znaku a posun adresy</i>
                    <i>; zapis znaku a posun adresy</i>
&nbsp;
        print message
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong>     db "Hello, world!", 0x0d, 0x0a, "$"
<strong>replacement</strong> db "Zdravim svet"
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Porovnání rychlosti jednotlivých realizací blokových přenosů</h2>

<p>Zkusme si nyní porovnat rychlost různých realizací blokových přenosů. Budeme
přitom uvažovat přenos z&nbsp;adresy <strong>DS : [SI]</strong> a na adresu
<strong>ES : [DI]</strong>, přičemž se <strong>SI</strong> a
<strong>DI</strong> budou postupně zvyšovat o jedničku a provede se
<strong>CX</strong> opakování. Takovou operaci lze realizovat mnoha způsoby,
například explicitně zapsanou smyčkou:</p>

<pre>
opak:
        mov al, ds:[si]     <i>; 12+5+2=19</i>
        mov es:[di], al     <i>; 12+5+2=19</i>
        inc si              <i>; 3</i>
        inc di              <i>; 3</i>
        loop opak           <i>; 17</i>
        ; celkem            <i>; 3904000</i>
</pre>

<p><div class="rs-tip-major">Poznámka: což dosahuje téměř času jedné
sekundy!</div></p>

<p>Použití kombinace <strong>LODSB</strong> a <strong>STOSB</strong> by mělo
vést k&nbsp;rychlejší realizaci:</p>

<pre>
opak:
        lodsb               <i>; 16</i>
        stosb               <i>; 11</i>
        loop opak           <i>; 17</i>
        ; celkem            <i>; 2816000</i>
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je to o cca 12 cyklů méně
&ndash; poslední skok se již neprovede.</div></p>

<p>Použití <strong>MOVSB</strong> s&nbsp;explicitně zapsanou smyčkou je opět o
několik desítek procent rychlejší:</p>

<pre>
opak:
        movsb               <i>; 18</i>
        loop opak           <i>; 17</i>
        ; celkem            <i>; 2240000 = (18 + 17) * 64000</i>
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je to opět o cca 12 cyklů
méně &ndash; poslední skok se již neprovede.</div></p>

<p>A konečně použití <strong>MOVSB</strong> s&nbsp;opakováním bude na Intelu
8088 či 8086 nejrychlejší možnou realizací blokového přenosu:</p>

<pre>
     rep movsb              <i>; 9 + 17n</i>
        ; celkem            <i>; 1088009 = 9 + 17*64000</i>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;komentářích je uveden počet cyklů
platných pro procesoru Intel 8086 nebo Intel 8088.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Krátké zopakování: přenos rastrového obrázku z&nbsp;kódového segmentu do obrazové paměti</h2>

<p>S&nbsp;programovým kódem uvedeným v&nbsp;této kapitole jsme se již setkali.
Je zde realizován přenos rastrového obrázku z&nbsp;kódového segmentu do
obrazové paměti (Video RAM). Vše se bude odehrávat ve standardním grafickém
režimu 13H, takže přenášený obrázek bude mít velikost 320&times;200 pixelů,
tedy přesně 64000 bajtů. Obrázek lze na platformě Intel 8086/8088 přenést buď
po bajtech nebo po celých 16bitových slovech. Zvolíme druhou možnost (čímž
mimochodem eliminujeme možnost reálného využití latche, což nám však nebude
vadit):</p>

<pre>
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*200/2   <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw           <i>; prenos celeho obrazku</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>

<p>Výsledkem by měla být obrazovka s&nbsp;tímto obsahem:</p>

*** image ***
<p><i>Obrázek 1: Obrazovka po přenosu rastrového obrázku o velikosti 64000 bajtů</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přenos maximálního počtu bajtů instrukcí <strong>REP MOVSB</strong></h2>

<p>Instrukce <strong>REP MOVSB</strong> dokáže přenést maximálně CX bajtů a
vzhledem k&nbsp;tomu, že CX je šestnáctibitovým registrem, je maximální
velikost přenášeného bloku rovna 65535 bajtům. Nelze tedy přenést celý segment
(jeden bajt chybí), což lze nahradit explicitně provedenou operací MOVSB na
konci. Předpokládá se přitom, že SI i DI budou nulové, protože nelze provést
přenosy přes hranice segmentů (dojde k&nbsp;přetečení):</p>

<pre>
     rep movsb  <i>; přenos 65535 bajtů</i>
     movsb      <i>; přenos posledního bajtu</i>
</pre>

<p>Ukažme si to (zde jen čistě pro opakování) na přenosu obrázku do obrazové
paměti. Omezeni jsme na velikost kódového segmentu, tedy na 64kB i na možnost
přenosu maximálně 65535 bajtů:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku: prenos 65535 bajtu/pixelu</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        xor si, si          <i>; nyni DS:SI obsahuje adresu prvniho bajtu v kodovem segmentu</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 65535       <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsb           <i>; prenos celeho obrazku</i>

        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>

<p>Výsledek:</p>

*** image ***
<p><i>Obrázek 2: Výsledek přenosu celého kódového segmentu do obrazové paměti.</i></p>

<p>Ještě si ukažme, co se stane, když začneme přenášet data z&nbsp;poloviny
kódového segmentu (tedy například od adresy 32000). Mělo by dojít
k&nbsp;přetečení obsahu registru SI a tím pádem i k&nbsp;přenosu kódu i začátku
obrazu do druhé poloviny obrazovky:</p>

*** image ***
<p><i>Obrázek 3: Výsledek přenosu celého kódového segmentu do obrazové paměti,
ovšem začínáme od SI=32000 a nikoli od nuly.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Jak velký blok se přenese při nastavení <strong>CX=0</strong>?</h2>

<p>Následující sekvence instrukcí přenese celých 65536 bajtů, protože
<strong>LOOP</strong> nejdříve sníží obsah <strong>CX</strong> a posléze ho
kontroluje na nulovost před provedením skoku:</p>

<pre>
        xor cx, cx          <i>; pocet zapisovanych bajtu (=pixelu)</i>
<strong>opak</strong>:
        movsb
        loop opak
</pre>

<p>Ovšem co provede přepis této smyčky do následující podoby?</p>

<pre>
        xor cx, cx          <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsb           
</pre>

<p>Výsledkem bude, že se NEpřenese žádný blok, protože ve skutečnosti
<strong>REP</strong> kontroluje obsah registru <strong>CX</strong> ještě před
přenosem prvního bajtu:</p>

*** image ***
<p><i>Obrázek 4: Výsledek přenosu bloku o nulové délce.</i></p>

<p>Úplný zdrojový kód takto upraveného demonstračního příkladu vypadá
následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku, prenos 0 bajtu.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_320x200_image_0B.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_320x200_image_0B.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro grayscale_palette 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        xor cx, cx          <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsb           <i>; prenos celeho obrazku</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přenos po bajtech, 16bitových slovech nebo 32bitových slovech</h2>

<p>Přenos rastrového obrázku (nebo libovolného jiného bloku) po bajtech již
velmi dobře známe:</p>

<pre>
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*200/2   <i>; pocet zapisovanych bajtu (=pixelu)</i>
        rep movsw           <i>; prenos celeho obrazku</i>
</pre>

<p>Víme také, že obrázek má &bdquo;kulatou&ldquo; velikost 64000 bajtů, což je
hodnota celočíselně dělitelná dvěma. Můžeme tedy alternativně přenášet i po
celých šestnáctibitových slovech:</p>

<pre>
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*200/2   <i>; pocet zapisovanych slov (=dvoupixelu)</i>
        rep movsw           <i>; prenos celeho obrazku</i>
</pre>

<p>Současně se jedná o hodnotu dělitelnou i čtyřmi, takže by bylo možné
provádět blokový přenos i po 32bitových slovech. Taková možnost na čipech Intel
8086/8088 neexistuje, ovšem na čipech 80386 a vyšších je to možné realizovat
pomocí instrukce <strong>MOVSD</strong>. Nejprve se tedy assembleru povolíme
použití instrukčního souboru 80386:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 386         <i>; specifikace pouziteho instrukcniho souboru</i>
</pre>

<p>A přenos provedeme takto:</p>

<pre>
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*200/4   <i>; pocet zapisovanych 32bitovych slov (=ctyrpixelu)</i>
        rep movsd           <i>; prenos celeho obrazku</i>
</pre>

<p>Výsledný příklad by mohl vypadat následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku: prenos po 32bitovych slovech.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_320x200_image_movsd.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_320x200_image_movsd.asm</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 386         <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*200/4   <i>; pocet zapisovanych 32bitovych slov (=ctyrpixelu)</i>
        rep movsd           <i>; prenos celeho obrazku</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Porovnání rychlosti přenosu realizovaného po bajtech, 16bitových či 32bitových slovech</h2>

<p>Podívejme se, jak rychlý bude přenos bloku při použití různých forem přenosu
&ndash; po bajtech, šestnáctibitových slovech nebo po slovech 32bitových. Nyní
již budeme rozlišovat mezi několika procesorovými architekturami (což je ovšem
problematika, ke které se ještě vrátíme):</p>

<table>
<tr><th>Operace</th><th>8086</th><th>186</th><th>286</th><th>386</th><td>486</td><td>Pentium</td>
<tr><td>rep movsb</td><td>9+17n</td><td>8+8n</td><td>5+4n</td><td>7+4n</td><td>12+3n*</td><td>3+n</td></tr>
<tr><td>rep movsw</td><td>9+25n</td><td>8+8n</td><td>5+4n</td><td>7+4n</td><td>12+3n*</td><td>3+n</td></tr>
<tr><td>rep movsd</td><td>&times;</td><td>&times;</td><td>&times;</td><td>7+4n</td><td>12+3n*</td><td>3+n</td></tr>
</table>

<p>Povšimněte si, že rozdíl mezi šířkou přenášených dat nalezneme vlastně jen
na čipu 8086.</p>

<p><div class="rs-tip-major">Poznámka: na Pentiu není možné tyto instrukce
párovat s&nbsp;jinou instrukcí, což je i pochopitelné, když si uvědomíme, jak
složitá operace se vlastně provádí.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Počet cyklů nutných pro přenos bloku o velikosti 64000 bajtů</h2>

<p>Nyní je již snadné zjistit, kolik strojových cyklů se &bdquo;spálí&ldquo;
při přenosu bloku o velikosti 64000 bajtů. Přitom porovnáváme čistě jen počet
cyklů a nikoli reálný čas, protože ten závisí na frekvenci hodinového signálu a
tedy znamená, že dvě totožné sekvence instrukcí se provedou rychleji na
mikroprocesoru s&nbsp;vyšší frekvencí hodinového signálu. Nás však nyní bude
zajímat čistě rychlost implementace blokových operací:</p>

<table>
<tr><th>Operace</th><th>n</th><th>8086</th><th>186</th><th>286</th><th>386</th><td>486</td><td>Pentium</td>
<tr><td>rep movsb</td><td>64000</td><td>1088009</td><td> 512008</td><td> 256005</td><td>256007</td><td>192012</td><td>64003</td></tr>
<tr><td>rep movsw</td><td>32000</td><td> 800009</td><td> 256008</td><td> 128005</td><td>128007</td><td> 96012</td><td>32003</td></tr>
<tr><td>rep movsd</td><td>16000</td><td>&times;</td><td>&times;</td><td>&times;</td><td> 64007</td><td> 48012</td><td>16003</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: zde je tedy více než zřejmé, že
kvalitnější architektura mikroprocesorů (a šířka datové sběrnice) je stejně
důležitým údajem, jako informace o hodinové frekvenci.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Určení směru přenosu při blokových operacích</h2>

<p>Instrukcemi <strong>CLD</strong> a <strong>STD</strong> se mění hodnota
příznaku <strong>DF</strong> uloženého v&nbsp;příznakovém registru
<strong>FLAGS</strong>. Tento příznak ovlivňuje chování těch instrukcí,
v&nbsp;nichž se mění zdrojový indexový registr <strong>SI</strong> a/nebo
cílový indexový registr <strong>DI</strong>. Hodnoty těchto registrů se totiž
mohou jak zvyšovat (což jsme si již ukázali), tak i snižovat. Blokový přenos se
snižováním adres (a nikoli jejich zvyšováním) se využije ve chvíli, kdy se
zdrojový a cílový blok překrývají, což je problém, který je možné si relativně
snadno vizualizovat, jak to ostatně uvidíme v&nbsp;navazujících kapitolách.</p>

<p><div class="rs-tip-major">Poznámka: čipy Intel 8086/8088 byly tak pomalé
relativně k&nbsp;rychlosti operační paměti, že se nepoužívala vyrovnávací paměť
(cache), takže blokové přenosy směrem dolů nebyly z&nbsp;tohoto pohledu příliš
problematické. V&nbsp;dalších generacích řady x86 to však již tak jednoduché
není.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Blokový přenos ve chvíli, kdy se zdrojový a cílový blok překrývají</h2>

<p>Nyní se pokusíme o provedení následujících operací:</p>

<ol>

<li>Vykreslíme část rastrového obrázku, konkrétně jeho prvních 100 řádků do
obrazové paměti.</li>

<li>Přesuneme blok o velikosti 320&times;100 bajtů (=stejný počet pixelů) ve
video RAM z&nbsp;adresy 0 na adresu 320&times;10, což znamená, že se pokusíme o
přesun (resp.&nbsp;kopii) obrázku o deset obrazových řádků níže.</li>

</ol>

<p>Realizace těchto dvou operací v&nbsp;assembleru je snadná.</p>

<p>První operace:</p>

<pre>
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        rep movsb           <i>; prenos celeho obrazku</i>
</pre>

<p>Výsledek první operace:</p>

*** image ***
<p><i>Obrázek 5: Obrazovka po provedení první operace.</i></p>

<p>Druhá operace:</p>

<pre>
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov ds, ax
        xor si, si          <i>; DS:SI ukazuje na zacatek video RAM (source)</i>
&nbsp;
        mov es, ax
        mov di, 320*10      <i>; ES:DI ukazuje na zacatek radku cislo 10 ve video RAM (destination)</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        rep movsb           <i>; prenos celeho obrazku</i>
</pre>

*** image ***
<p><i>Obrázek 6: Obrazovka po provedení druhé operace.</i></p>

<p>Je dobré si uvědomit, proč vypadá výsledek tak, jak vypadá. Přenesení
každého řádku znamená, že si přepíšeme část zdrojového bloku, protože zdrojový
a cílový blok se překrývají. Konkrétně se prvních 10 obrazových řádků
rozkopíruje do dalších 10 řádků atd., takže ve výsledku se prvních 10 řádků
několikrát opakuje v&nbsp;cílovém obrázku. Důvod je ten, že kopírujeme od
prvního bajtu směrem k&nbsp;bajtu poslednímu a &bdquo;dopředně&ldquo; si zdroj
přepisujeme.</p>

<p>Otázka na čtenáře: jaký bude vizuální výsledek následující operace?</p>

<pre>
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov ds, ax
        xor si, si          <i>; DS:SI ukazuje na zacatek video RAM (source)</i>
&nbsp;
        mov es, ax
        mov di, 1           <i>; ES:DI ukazuje na zacatek ciloveho bloku (destination)</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        rep movsb           <i>; prenos celeho obrazku</i>
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku: prenos po bajtech prekryvajici se oblasti.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_320x200_image_movsb_forward.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_320x200_image_movsb_forward.asm</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        rep movsb           <i>; prenos celeho obrazku</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
&nbsp;
        <i>; nyni provedeme prenos bloku, kdyz se bude zdroj a cil prekryvat</i>
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov ds, ax
        xor si, si          <i>; DS:SI ukazuje na zacatek video RAM (source)</i>
&nbsp;
        mov es, ax
        mov di, 320*10      <i>; ES:DI ukazuje na zacatek radku cislo 10 ve video RAM (destination)</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        rep movsb           <i>; prenos celeho obrazku</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Realizace zpětného blokového přenosu</h2>

<p><a href="#k13">Výše uvedený problém</a> je možné vyřešit tak, že začneme
blokový přenos od posledního bajtu a budeme postupně <i>snižovat</i> obsah
indexových registrů <strong>SI</strong> a <strong>DI</strong> a nikoli je
zvyšovat. Navíc je nutné instrukcí <strong>STD</strong> změnit směr přenosu.
Upravený kód může v&nbsp;první variantě vypadat následovně:</p>

<pre>
        <i>; nyni provedeme prenos bloku, kdyz se bude zdroj a cil prekryvat</i>
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov ds, ax
        mov si, 320*100     <i>; konec bloku, ktery se ma prenest</i>
                            <i>; DS:SI ukazuje na zacatek video RAM (source)</i>
&nbsp;
        mov es, ax
        mov di, 320*(100+10) <i>; ES:DI ukazuje na konec bloku, ktery se ma prenest (destination)</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        std                 <i>; zmena smeru prenosu!</i>
        rep movsb           <i>; prenos celeho obrazku</i>
</pre>

<p>A takto vypadají výsledky:</p>

*** image ***
<p><i>Obrázek 7: Obrazovka po provedení první operace.</i></p>

*** image ***
<p><i>Obrázek 8: Obrazovka po provedení druhé operace.</i></p>

<p>Povšimněte si levého horního rohu. Přes provedením přenosu jsme totiž pixel
v&nbsp;tomto rohu vyplnili černou barvou:</p>

<pre>
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
        mov byte es:[di], 0 <i>; oznacime si levy horni roh cernym pixelem</i>
</pre>

<p>Při pohledu na obrázek číslo 8 je patrné, že jsme se dopustili klasické
&bdquo;chyby &plusmn; 1&ldquo;, což se pokusíme napravit.</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku: prenos po bajtech prekryvajici se oblasti.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_320x200_image_movsb_backward_1.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_320x200_image_movsb_backward_1.asm</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        rep movsb           <i>; prenos celeho obrazku</i>
&nbsp;
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
        mov byte es:[di], 0 <i>; oznacime si levy horni roh cernym pixelem</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
&nbsp;
        <i>; nyni provedeme prenos bloku, kdyz se bude zdroj a cil prekryvat</i>
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov ds, ax
        mov si, 320*100     <i>; konec bloku, ktery se ma prenest</i>
                            <i>; DS:SI ukazuje na zacatek video RAM (source)</i>
&nbsp;
        mov es, ax
        mov di, 320*(100+10) <i>; ES:DI ukazuje na konec bloku, ktery se ma prenest (destination)</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        std                 <i>; zmena smeru prenosu!</i>
        rep movsb           <i>; prenos celeho obrazku</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Korektní realizace zpětného blokového přenosu</h2>

<p>Jak by tedy měla vypadat korektní realizace zpětného blokového přenosu?
Musíme začít od reálné poslední adresy, což ovšem nejsou offsety 320&times;100
a 320&times;(100+10), ale hodnoty 320&times;100-1 a 320&times;(100+10)-1.
Nepatrně tedy upravíme konstanty, kterými naplníme registry <strong>SI</strong>
(od které adresy se bude provádět přenos) a <strong>DI</strong> (na kterou
adresu se bude přenášet):</p>

<pre>
        <i>; nyni provedeme prenos bloku, kdyz se bude zdroj a cil prekryvat</i>
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov ds, ax
        mov si, 320*100-1   <i>; konec bloku, ktery se ma prenest</i>
                            <i>; DS:SI ukazuje na zacatek video RAM (source)</i>
&nbsp;
        mov es, ax
        mov di, 320*(100+10)-1 <i>; ES:DI ukazuje na konec bloku, ktery se ma prenest (destination)</i>
</pre>

<p>Samotný blokový přenos již bude probíhat naprosto stejným způsobem:</p>

<pre>
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        std                 <i>; zmena smeru prenosu!</i>
        rep movsb           <i>; prenos celeho obrazku</i>
</pre>

<p>A takto vypadají výsledky:</p>

*** image ***
<p><i>Obrázek 9: Obrazovka po provedení první operace.</i></p>

*** image ***
<p><i>Obrázek 10: Obrazovka po provedení druhé operace.</i></p>

<p>Z&nbsp;těchto dvou screenshotů je patrné, že nyní by měl být blokový přenos
korektní.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Úplný zdrojový kód příkladu realizujícího zpětný blokový přenos</h2>

<p>Úplný zdrojový kód demonstračního příkladu provádějícího zpětný blokový
přenos v&nbsp;obrazové paměti vypadá následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku: prenos po bajtech prekryvajici se oblasti.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o vga.com vga_320x200_image_movsb_backward_2.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o vga.com vga_320x200_image_movsb_backward_2.asm</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
<strong>next_dac</strong>:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        rep movsb           <i>; prenos celeho obrazku</i>
&nbsp;
        xor di, di          <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
        mov byte es:[di], 0 <i>; oznacime si levy horni roh cernym pixelem</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
&nbsp;
        <i>; nyni provedeme prenos bloku, kdyz se bude zdroj a cil prekryvat</i>
        mov ax, 0xa000      <i>; video RAM v textovem rezimu</i>
        mov ds, ax
        mov si, 320*100-1   <i>; konec bloku, ktery se ma prenest</i>
                            <i>; DS:SI ukazuje na zacatek video RAM (source)</i>
&nbsp;
        mov es, ax
        mov di, 320*(100+10)-1 <i>; ES:DI ukazuje na konec bloku, ktery se ma prenest (destination)</i>
&nbsp;
        mov cx, 320*100     <i>; pocet zapisovanych bajtu (=pixelu) odpovida 100 radkum</i>
        std                 <i>; zmena smeru prenosu!</i>
        rep movsb           <i>; prenos celeho obrazku</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Vyhledávání znaku v&nbsp;řetězci</h2>

<p>Některé operace nabízené mikroprocesory Intel 8086/8088 lze použít i pro
zpracování řetězců. Ukažme si například, jak by bylo možné realizovat nalezení
první mezery v&nbsp;řetězci s&nbsp;následnou záměnou této mezery na
hvězdičku:</p>

<pre>
<strong>message</strong>     db "Hello, world!", 0x0d, 0x0a, "$"
</pre>

<p>Výsledkem by měl být řetězec:</p>

<pre>
<strong>message</strong>     db "Hello,*world!", 0x0d, 0x0a, "$"
</pre>

<pre>
        pop  es   <i>; ES:DI obsahuje adresu prvniho znaku ve zprave</i>
        mov  di, message
&nbsp;
        mov al, " "   <i>; hledani mezery v retezci</i>
        repne scasb
</pre>

<pre>
        mov al, "*"   <i>; prepis mezery za hvezdicku</i>
        dec di
        stosb
</pre>

<p>Úplný zdrojový kód dnešního posledního demonstračního příkladu vypadá
následovně:</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 8086        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        ret
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; tisk retezce na obrazovku</i>
%macro <strong>print</strong> 1
        mov     dx, %1
        mov     ah, 9
        int     0x21
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        print message
&nbsp;
        push cs
        pop  es   <i>; ES:DI obsahuje adresu prvniho znaku ve zprave</i>
        mov  di, message
&nbsp;
        mov al, " "   <i>; hledani mezery v retezci</i>
        repne scasb
&nbsp;
        mov al, "*"   <i>; prepis mezery za hvezdicku</i>
        dec di
        stosb
&nbsp;
        print message <i>; tisk upravene zpravy</i>
&nbsp;
        wait_key
        exit
&nbsp;
        <i>; retezec ukonceny znakem $</i>
        <i>; (tato data jsou soucasti vysledneho souboru typu COM)</i>
<strong>message</strong>     db "Hello, world!", 0x0d, 0x0a, "$"
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Seznam již popsaných instrukcí</h2>

<p>Podobně jako <a
href="https://www.root.cz/clanky/specifika-instrukcni-sady-mikroprocesoru-intel-8086-8088/">v&nbsp;sedmnácté
části</a> <a
href="https://www.root.cz/serialy/vyvoj-her-a-grafickych-dem-pro-platformu-pc/">tohoto
seriálu</a> si i dnes uvedeme rozšířenou tabulku se všemi instrukcemi
mikroprocesorů Intel 8086/8088, které byly doposud popsány (a doplněny
demonstračními příklady):</p>

<table>
<tr><td>ADC</td><td>Add with carry</td></tr>
<tr><td>ADD</td><td>Add</td></tr>
<tr><td>AND</td><td>Logical AND</td></tr>
<tr><td>CMP</td><td>Compare operands</td></tr>
<tr><td>DEC</td><td>Decrement by 1</td></tr>
<tr><td>DIV</td><td>Unsigned divide</td></tr>
<tr><td>IDIV</td><td>Signed divide</td></tr>
<tr><td>IMUL</td><td>Signed multiply in One-operand form</td></tr>
<tr><td>INC</td><td>Increment by 1</td></tr>
<tr><td>Jcc</td><td>Jump if condition</td></tr>
<tr><td>JMP</td><td>Jump</td></tr>
<tr><td>JCXZ</td><td>Jump if CX is zero</td></tr>
<tr><td>LOOP/LOOPx</td><td>Loop control</td></tr>
<tr><td>MUL</td><td>Unsigned multiply</td></tr>
<tr><td>NEG</td><td>Two's complement negation</td></tr>
<tr><td>NOT</td><td>Negate the operand, logical NOT</td></tr>
<tr><td>OR</td><td>Logical OR</td></tr>
<tr><td>RCL</td><td>Rotate left (with carry)</td></tr>
<tr><td>RCR</td><td>Rotate right (with carry)</td></tr>
<tr><td>ROL</td><td>Rotate left</td></tr>
<tr><td>ROR</td><td>Rotate right</td></tr>
<tr><td>SAL</td><td>Shift Arithmetically left (signed shift left)</td></tr>
<tr><td>SAR</td><td>Shift Arithmetically right (signed shift right)</td></tr>
<tr><td>SBB</td><td>Subtraction with borrow</td></tr>
<tr><td>SHL</td><td>Shift left (unsigned shift left)</td></tr>
<tr><td>SHR</td><td>Shift right (unsigned shift right)</td></tr>
<tr><td>SUB</td><td>Subtraction</td></tr>
<tr><td>TEST</td><td>Logical compare (AND)</td></tr>
<tr><td>XOR</td><td>Exclusive OR</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>XLAT</td><td>Table look-up translation</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>DAA</td><td>Decimal adjust AL after addition</td></tr>
<tr><td>DAS</td><td>Decimal adjust AL after subtraction</td></tr>
<tr><td>AAA</td><td>ASCII adjust AL after addition</td></tr>
<tr><td>AAD</td><td>ASCII adjust AX before division</td></tr>
<tr><td>AAM</td><td>ASCII adjust AX after multiplication</td></tr>
<tr><td>AAS</td><td>ASCII adjust AL after subtraction</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CLD</td><td>Clear direction flag</td></tr>
<tr><td>STC</td><td>Set carry flag</td></tr>
<tr><td>LODSB</td><td>Load string byte</td></tr>
<tr><td>LODSW</td><td>Load string word</td></tr>
<tr><td>STOSB</td><td>Store byte in string</td></tr>
<tr><td>STOSW</td><td>Store word in string</td></tr>
<tr><td>MOVSB</td><td>Move byte from string to string</td></tr>
<tr><td>MOVSW</td><td>Move word from string to string</td></tr>
<tr><td>CMPSB</td><td>Compare bytes in memory</td></tr>
<tr><td>CMPSW</td><td>Compare words</td></tr>
<tr><td>SCASB</td><td>Compare byte string</td></tr>
<tr><td>SCASW</td><td>Compare word string</td></tr>
<tr><td>REPxx</td><td>Repeat MOVS/STOS/CMPS/LODS/SCAS</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>cga_text_mode_1.asm</td><td>standardní textový režim s&nbsp;rozlišením 40&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm</a></td></tr>
<tr><td>27</td><td>cga_text_mode_3.asm</td><td>standardní textový režim s&nbsp;rozlišením 80&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm</a></td></tr>
<tr><td>28</td><td>cga_text_mode_intensity.asm</td><td>změna významu nejvyššího bitu atributového bajtu: vyšší intenzita namísto blikání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm</a></td></tr>
<tr><td>29</td><td>cga_text_mode_cursor.asm</td><td>změna tvaru textového kurzoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm</a></td></tr>
<tr><td>30</td><td>cga_text_gfx_1.asm</td><td>zobrazení &bdquo;rastrové mřížky&ldquo;: pseudografický režim 160&times;25 pixelů (interně textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm</a></td></tr>
<tr><td>31</td><td>cga_text_mode_char_height.asm</td><td>změna výšky znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm</a></td></tr>
<tr><td>32</td><td>cga_text_160x100.asm</td><td>grafický režim 160&times;100 se šestnácti barvami (interně upravený textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>hercules_text_mode_1.asm</td><td>využití standardního textového režimu společně s&nbsp;kartou Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm</a></td></tr>
<tr><td>34</td><td>hercules_text_mode_2.asm</td><td>zákaz blikání v&nbsp;textových režimech</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm</a></td></tr>
<tr><td>35</td><td>hercules_turn_off.asm</td><td>vypnutí generování video signálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm</a></td></tr>
<tr><td>36</td><td>hercules_gfx_mode_1.asm</td><td>přepnutí karty Hercules do grafického režimu (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm</a></td></tr>
<tr><td>37</td><td>hercules_gfx_mode_2.asm</td><td>přepnutí karty Hercules do grafického režimu (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm</a></td></tr>
<tr><td>38</td><td>hercules_putpixel.asm</td><td>subrutina pro vykreslení jediného pixelu na kartě Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>ega_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm</a></td></tr>
<tr><td>40</td><td>ega_text_mode_80x43.asm</td><td>zobrazení 43 textových řádků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm</a></td></tr>
<tr><td>41</td><td>ega_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm</a></td></tr>
<tr><td>42</td><td>ega_gfx_mode_640x200.asm</td><td>přepnutí do grafického režimu 640&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm</a></td></tr>
<tr><td>43</td><td>ega_gfx_mode_640x350.asm</td><td>přepnutí do grafického režimu 640&times;350 pixelů se čtyřmi nebo šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm</a></td></tr>
<tr><td>44</td><td>ega_gfx_mode_bitplanes_1.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (základní způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm</a></td></tr>
<tr><td>45</td><td>ega_gfx_mode_bitplanes_2.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (rychlejší způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>ega_320x200_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm</a></td></tr>
<tr><td>47</td><td>ega_640x350_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 640&times;350 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>ega_standard_font.asm</td><td>použití standardního fontu grafické karty EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm</a></td></tr>
<tr><td>49</td><td>ega_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>ega_palette_1.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 320&times;200 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm</a></td></tr>
<tr><td>51</td><td>ega_palette_2.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 640&times;350 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm</a></td></tr>
<tr><td>52</td><td>ega_palette_3.asm</td><td>změna všech barev v&nbsp;barvové paletě s&nbsp;využitím programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm</a></td></tr>
<tr><td>53</td><td>ega_palette_4.asm</td><td>změna všech barev, včetně barvy okraje, v&nbsp;barvové paletě voláním funkce BIOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>vga_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm</a></td></tr>
<tr><td>55</td><td>vga_text_mode_80x50.asm</td><td>zobrazení 50 a taktéž 28 textových řádků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm</a></td></tr>
<tr><td>56</td><td>vga_text_mode_intensity_1.asm</td><td>změna chování atributového bitu pro blikání (nebezpečná varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm</a></td></tr>
<tr><td>57</td><td>vga_text_mode_intensity_2.asm</td><td>změna chování atributového bitu pro blikání (bezpečnější varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm</a></td></tr>
<tr><td>58</td><td>vga_text_mode_9th_column.asm</td><td>modifikace způsobu zobrazení devátého sloupce ve znakových režimech (720 pixelů na řádku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm</a></td></tr>
<tr><td>59</td><td>vga_text_mode_cursor_shape.asm</td><td>změna tvaru textového kurzoru na grafické kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm</a></td></tr>
<tr><td>60</td><td>vga_text_mode_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>vga_gfx_mode_640x480.asm</td><td>přepnutí do grafického režimu 640&times;480 pixelů se šestnácti barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm</a></td></tr>
<tr><td>62</td><td>vga_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů s&nbsp;256 barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm</a></td></tr>
<tr><td>63</td><td>vga_gfx_mode_palette.asm</td><td>změna všech barev v&nbsp;barvové paletě grafické karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm</a></td></tr>
<tr><td>64</td><td>vga_gfx_mode_dac_1.asm</td><td>využití DAC (neočekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm</a></td></tr>
<tr><td>65</td><td>vga_gfx_mode_dac_2.asm</td><td>využití DAC (očekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>66</td><td>vga_640x480_putpixel.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 640&times;480 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm</a></td></tr>
<tr><td>67</td><td>vga_320x200_putpixel_1.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm</a></td></tr>
<tr><td>68</td><td>vga_320x200_putpixel_2.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (rychlejší varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>vga_gfx_mode_dac_3.asm</td><td>přímé využití DAC v&nbsp;grafickém režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>70</td><td>vga_gfx_mode_unchained_step_1.asm</td><td>zobrazení barevných pruhů v&nbsp;režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm</a></td></tr>
<tr><td>71</td><td>vga_gfx_mode_unchained_step_2.asm</td><td>vypnutí zřetězení bitových rovin a změna způsobu adresování pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm</a></td></tr>
<tr><td>72</td><td>vga_gfx_mode_unchained_step_3.asm</td><td>vykreslení barevných pruhů do vybraných bitových rovin</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>73</td><td>vga_gfx_mode_320x400.asm</td><td>nestandardní grafický režim s&nbsp;rozlišením 320&times;400 pixelů a 256 barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm</a></td></tr>
<tr><td>74</td><td>vga_320x200_image.asm</td><td>zobrazení rastrového obrázku ve standardním grafickém režimu 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm</a></td></tr>
<tr><td>75</td><td>vga_320x200_unchained_image_1.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (nekorektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm</a></td></tr>
<tr><td>76</td><td>vga_320x200_unchained_image_2.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (korektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm</a></td></tr>
<tr><td>77</td><td>vga_320x400_unchained_image.asm</td><td>zobrazení rastrového obrázku v&nbsp;nestandardním režimu 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>78</td><td>vga_vertical_scroll_1.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm</a></td></tr>
<tr><td>79</td><td>vga_vertical_scroll_2.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm</a></td></tr>
<tr><td>80</td><td>vga_split_screen_1.asm</td><td>režim split-screen a scrolling, nefunční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm</a></td></tr>
<tr><td>81</td><td>vga_split_screen_2.asm</td><td>režim split-screen a scrolling, plně funkční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm</a></td></tr>
<tr><td>82</td><td>vga_horizontal_scroll_1.asm</td><td>horizontální scrolling bez rozšíření počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm</a></td></tr>
<tr><td>83</td><td>vga_horizontal_scroll_2.asm</td><td>horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm</a></td></tr>
<tr><td>84</td><td>vga_horizontal_scroll_3.asm</td><td>jemný horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>85</td><td>vga_320x240_image.asm</td><td>nastavení grafického režimu Mode-X, načtení a vykreslení obrázku, scrolling</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>86</td><td>io.asm</td><td>knihovna maker pro I/O operace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm</a></td></tr>
<tr><td>87</td><td>vga_lib.asm</td><td>knihovna maker a podprogramů pro programování karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm</a></td></tr>
<tr><td>88</td><td>vga_320x240_lib.asm</td><td>nastavení grafického režimu Mode-X, tentokrát knihovními funkcemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>89</td><td>vga_bitblt_1.asm</td><td>první (naivní) implementace operace <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm</a></td></tr>
<tr><td>90</td><td>vga_bitblt_2.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm</a></td></tr>
<tr><td>91</td><td>vga_bitblt_3.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro čtení i zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm</a></td></tr>
<tr><td>92</td><td>vga_bitblt_4.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace makry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm</a></td></tr>
<tr><td>93</td><td>vga_bitblt_5.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace podprogramem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>94</td><td>vga_bitblt_rotate.asm</td><td>zápisový režim s&nbsp;rotací bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm</a></td></tr>
<tr><td>95</td><td>vga_bitblt_fast.asm</td><td>rychlá korektní 32bitová operace typu <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm</a></td></tr>
<tr><td>96</td><td>vga_320x400_bitblt_1.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (neúplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm</a></td></tr>
<tr><td>97</td><td>vga_320x400_bitblt_2.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (úplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm</a></td></tr>
<tr><td>98</td><td>vga_write_modes_1.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis bez úpravy latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm</a></td></tr>
<tr><td>99</td><td>vga_write_modes_2.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis s&nbsp;modifikací latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm</a></td></tr>
<tr><td>100</td><td>vga_write_modes_3.asm</td><td>volitelné zápisové režimy grafické karty VGA, cílená modifikace latche vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>101</td><td>instruction_jump.asm</td><td>použití instrukce <strong>JMP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jump.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jump.asm</a></td></tr>
<tr><td>102</td><td>instruction_jnz.asm</td><td>použití instrukce <strong>JNZ</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jnz.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jnz.asm</a></td></tr>
<tr><td>103</td><td>instruction_jz_jmp.asm</td><td>použití instrukcí <strong>JZ</strong> a <strong>JMP</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jz_jmp.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jz_jmp.asm</a></td></tr>
<tr><td>104</td><td>instruction_loop.asm</td><td>použití instrukce <strong>LOOP</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_loop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>105</td><td>instruction_template.asm</td><td>šablona všech následujících demonstračních příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_template.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_template.asm</a></td></tr>
<tr><td>106</td><td>instruction_print_hex.asm</td><td>tisk osmibitové hexadecimální hodnoty</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_print_hex.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_print_hex.asm</a></td></tr>
<tr><td>107</td><td>instruction_xlat.asm</td><td>využití instrukce <strong>XLAT</strong> pro získání tisknutelné hexadecimální cifry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_xlat.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_xlat.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>108</td><td>instruction_daa.asm</td><td>operace součtu s&nbsp;využitím binární i BCD aritmetiky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa.asm</a></td></tr>
<tr><td>109</td><td>instruction_daa_sub.asm</td><td>instrukce <strong>DAA</strong> po provedení operace rozdílu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa_sub.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa_sub.asm</a></td></tr>
<tr><td>110</td><td>instruction_das.asm</td><td>instrukce <strong>DAS</strong> po provedení operace rozdílu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_das.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_das.asm</a></td></tr>
<tr><td>111</td><td>instruction_aaa.asm</td><td>korekce výsledku na jedinou BCD cifru operací <strong>AAA</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aaa.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aaa.asm</a></td></tr>
<tr><td>112</td><td>instruction_mul.asm</td><td>ukázka výpočtu součinu dvou osmibitových hodnot</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_mul.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_mul.asm</a></td></tr>
<tr><td>113</td><td>instruction_aam.asm</td><td>BCD korekce po výpočtu součinu instrukcí <strong>AAM</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aam.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aam.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>114</td><td>instruction_stosb.asm</td><td>blokový zápis dat instrukcí <strong>STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_stosb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_stosb.asm</a></td></tr>
<tr><td>115</td><td>instruction_rep_stosb.asm</td><td>opakované provádění instrukce <strong>STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_stosb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_stosb.asm</a></td></tr>
<tr><td>116</td><td>instruction_lodsb.asm</td><td>čtení dat instrukcí <strong>LODSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_lodsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_lodsb.asm</a></td></tr>
<tr><td>117</td><td>instruction_movsb.asm</td><td>přenos jednoho bajtu instrukcí <strong>MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_movsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_movsb.asm</a></td></tr>
<tr><td>118</td><td>instruction_rep_movsb.asm</td><td>blokový přenos po bajtech instrukcí <strong>MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_movsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_movsb.asm</a></td></tr>
<tr><td>119</td><td>instruction_rep_scas.asm</td><td>vyhledávání v&nbsp;řetězci instrukcí <strong>SCAS</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_scas.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_scas.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>120</td><td>vga_320x200_image_0B.asm</td><td>výsledek blokového přenosu ve chvíli, kdy je <strong>CX=0</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_0B.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_0B.asm</a></td></tr>
<tr><td>121</td><td>vga_320x200_image_64kB.asm</td><td>výsledek blokového přenosu ve chvíli, kdy je <strong>CX=0xffff</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_64kB.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_64kB.asm</a></td></tr>
<tr><td>122</td><td>vga_320x200_image_movsb.asm</td><td>blokový přenos v&nbsp;rámci obrazové paměti instrukcí <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb.asm</a></td></tr>
<tr><td>123</td><td>vga_320x200_image_movsw.asm</td><td>blokový přenos v&nbsp;rámci obrazové paměti instrukcí <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsw.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsw.asm</a></td></tr>
<tr><td>124</td><td>vga_320x200_image_movsd.asm</td><td>blokový přenos v&nbsp;rámci obrazové paměti instrukcí <strong>REP MOVSD</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsd.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsd.asm</a></td></tr>
<tr><td>125</td><td>vga_320x200_image_movsb_forward.asm</td><td>blokový přenos překrývajících se bloků paměti (zvyšující se adresy)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_forward.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_forward.asm</a></td></tr>
<tr><td>126</td><td>vga_320x200_image_movsb_backward_1.asm</td><td>blokový přenos překrývajících se bloků paměti (snižující se adresy, nekorektní nastavení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_backward_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_backward_1.asm</a></td></tr>
<tr><td>127</td><td>vga_320x200_image_movsb_backward_2.asm</td><td>blokový přenos překrývajících se bloků paměti (snižující se adresy, korektní nastavení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_backward_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_backward_2.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>6845 - Motorola CRT Controller<br />
<a href="https://stanislavs.org/helppc/6845.html">https://stanislavs.org/helppc/6845.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

<li>Programmer's Guide to Yamaha YMF 262/OPL3 FM Music Synthesizer<br />
<a href="https://moddingwiki.shikadi.net/wiki/OPL_chip">https://moddingwiki.shikadi.net/wiki/OPL_chip</a>
</li>

<li>Does anybody understand how OPL2 percussion mode works?<br />
<a href="https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/">https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/</a>
</li>

<li>Yamaha YMF262 OPL3 music - MoonDriver for OPL3 DEMO [Oscilloscope View]<br />
<a href="https://www.youtube.com/watch?v=a7I-QmrkAak">https://www.youtube.com/watch?v=a7I-QmrkAak</a>
</li>

<li>Yamaha OPL vs OPL2 vs OPL3 comparison<br />
<a href="https://www.youtube.com/watch?v=5knetge5Gs0">https://www.youtube.com/watch?v=5knetge5Gs0</a>
</li>

<li>OPL3 Music Crockett's Theme<br />
<a href="https://www.youtube.com/watch?v=HXS008pkgSQ">https://www.youtube.com/watch?v=HXS008pkgSQ</a>
</li>

<li>Bad Apple (Adlib Tracker - OPL3)<br />
<a href="https://www.youtube.com/watch?v=2lEPH6Y3Luo">https://www.youtube.com/watch?v=2lEPH6Y3Luo</a>
</li>

<li>FM Synthesis Chips, Codecs and DACs<br />
<a href="https://www.dosdays.co.uk/topics/fm_synthesizers.php">https://www.dosdays.co.uk/topics/fm_synthesizers.php</a>
</li>

<li>The Zen Challenge - YMF262 OPL3 Original (For an upcoming game)<br />
<a href="https://www.youtube.com/watch?v=6JlFIFz1CFY">https://www.youtube.com/watch?v=6JlFIFz1CFY</a>
</li>

<li>[adlib tracker II techno music - opl3] orbit around alpha andromedae I<br />
<a href="https://www.youtube.com/watch?v=YqxJCu_WFuA">https://www.youtube.com/watch?v=YqxJCu_WFuA</a>
</li>

<li>[adlib tracker 2 music - opl3 techno] hybridisation process on procyon-ii<br />
<a href="https://www.youtube.com/watch?v=daSV5mN0sJ4">https://www.youtube.com/watch?v=daSV5mN0sJ4</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

