<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Překladače na platformě IBM PC: od assembleru k C (32bitový kód)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Překladače na platformě IBM PC: od assembleru k C (32bitový kód)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní článek o vyšších programovacích jazycích používaných v době kralování platformy IBM PC a DOSu dnes navážeme. Zatímco minule jsme se zaměřili na šestnáctibitový kód, dnes si ukážeme ty překladače, které dokážou i pro DOS vytvářet 32bitový kód.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Překladače na platformě IBM PC: od assembleru k&nbsp;C (32bitový kód)</a></p>
<p><a href="#k02">2. Vyplnění pole zadanou hodnotou</a></p>
<p><a href="#k03">3. Výsledky vygenerované překladačem Borland C++</a></p>
<p><a href="#k04">4. Výsledky vygenerované překladačem Watcom C/C++</a></p>
<p><a href="#k05">5. Porovnání s&nbsp;moderními instrukčními sadami a moderními překladači</a></p>
<p><a href="#k06">6. Překladače podporující 32bitovou instrukční sadu</a></p>
<p><a href="#k07">7. Šestnáctibitové a 32bitovové instrukce v&nbsp;reálném a chráněném režimu</a></p>
<p><a href="#k08">8. DJGPP</a></p>
<p><a href="#k09">*** 9. Malá odbočka: RHIDE</a></p>
<p><a href="#k10">*** 10. Překlad testovacích příkladů pomocí DJGPP</a></p>
<p><a href="#k11">*** 11. Funkce pro součet dvou celých čísel</a></p>
<p><a href="#k12">*** 12. Funkce pro vyplnění paměťové oblasti</a></p>
<p><a href="#k13">*** 13. Funkce pro nalezení největší hodnoty v&nbsp;poli</a></p>
<p><a href="#k14">*** 14. Funkce pro vyplnění pole zadanou hodnotou</a></p>
<p><a href="#k15">*** 15. Podpora operací s&nbsp;plovoucí řádovou čárkou v&nbsp;céčkových překladačích</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Překladače na platformě IBM PC: od assembleru k&nbsp;C (32bitový kód)</h2>

<p>Na <a
href="https://www.root.cz/clanky/prekladace-na-platforme-ibm-pc-od-assembleru-k-c/">úvodní
článek</a> o vyšších programovacích jazycích používaných v&nbsp;době kralování
platformy IBM PC a DOSu dnes navážeme. Zatímco minule jsme se zaměřili na
šestnáctibitový kód, jehož struktura musela odpovídat šestnáctibitovým
mikroprocesorům původní řady 8086 (a také 80286), dnes přeskočíme jednu trnitou
kapitolu vývoje (snahu o rozumné možnosti adresace celé dostupné paměti
v&nbsp;reálném režimu) a zaměříme se na ty překladače jazyka C, které dokázaly
generovat 32bitový kód kompatibilní s&nbsp;mikroprocesory 80386 a 80486. Ovšem
nejenom to &ndash; tyto překladače obsahovaly podporu pro takzvané <i>DOS
extendery</i> umožňující běh programů v&nbsp;chráněném režimu, ve kterém již
neplatí omezení režimu reálného. Právě tyto překladače umožnili vývoj
rozsáhlejších aplikací, samozřejmě včetně her.</p>

<p><div class="rs-tip-major">Poznámka: navíc si ukážeme, jak dobře či špatně
dokázaly překladače pracovat s&nbsp;matematickým koprocesorem, což byla další
potenciálně problematická komponenta platformy IBM PC &ndash; minimálně
v&nbsp;prvních deseti letech existence této platformy totiž bylo nutné počítat
s&nbsp;tím, že počítače nejsou matematickým koprocesorem vůbec osazeny (a tudíž
se musela řešit problematika emulace atd.)</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vyplnění pole zadanou hodnotou</h2>

<p>Ještě se na chvíli zastavme u překladu zdrojových kódů z&nbsp;jazyka C do
šestnáctibitové instrukční sady kompatibilní s&nbsp;původními mikroprocesory
Intel 8086 (resp.&nbsp;Intel 8088). Poměrně dlouhou dobu se tradovalo, že
překladačům jazyka C je nutné &bdquo;dopomoci&ldquo; v&nbsp;případě, že se
přistupuje k&nbsp;prvkům polí. Namísto přístupu k&nbsp;prvkům polí přes index
bylo doporučováno přímé využití ukazatelů. Ostatně takový příklad jsme si
ukazovali minule; jednalo se o realizaci funkce <strong>memset</strong>:</p>

<pre>
void * <strong>memset</strong>(void *dest, register int val, register size_t len) {
    register unsigned char *ptr = (unsigned char*)dest;
    while (len-- &gt; 0)
        *ptr++ = val;
    return dest;
}
</pre>

<p>Nyní zjistíme, jak dobře či naopak špatně dokážou překladače optimalizovat
funkci pro vyplnění celého pole zadanou hodnotou (což do značné míry odpovídá
funkci <strong>memset</strong> zmíněné výše). Nyní ovšem budeme k&nbsp;prvkům
polí přistupovat důsledně přes index, tj.&nbsp;bez využití ukazatelů:</p>

<pre>
void <strong>fill_array</strong>(int *array, int size, int value) {
    int i;
    for (i=0; i&lt;size; i++) {
        array[i] = value;
    }
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výsledky vygenerované překladačem Borland C++</h2>

<p>Nejprve se podívejme na kód vygenerovaný překladačem Borland C++ 2.0. Bude
se jednat o čistě šestnáctibitový kód, což znamená, že datový typ
<strong>int</strong> bude mít šířku dvou bajtů. To pochopitelně ovlivní způsob
adresování prvků v&nbsp;poli:</p>

<pre>
_fill_array     proc    near
        push    bp
        mov     bp,sp
        push    si
   ;    
   ;        int i;
   ;        for (i=0; i&lt;size; i++) {
   ;    
        xor     si,si
        jmp     short @1@98
@1@50:
   ;    
   ;            array[i] = value;
   ;    
        mov     ax,si
        shl     ax,1
        mov     bx,word ptr [bp+4]
        add     bx,ax
        mov     ax,word ptr [bp+8]
        mov     word ptr [bx],ax
        inc     si
@1@98:
        cmp     si,word ptr [bp+6]
        jl      short @1@50
   ;    
   ;        }
   ;    }
   ;    
        pop     si
        pop     bp
        ret     
_fill_array     endp
</pre>

<p>Povšimněte si především toho, že překladač sice použil registr
<strong>SI</strong> pro úschovu adresy, ovšem jeho zvýšení o hodnotu 2 (16bitů)
je řešeno přes akumulátor <strong>AX</strong> a vlastní přístup k&nbsp;prvku
zajišťuje registr <strong>BX</strong>. Tj.&nbsp;jedna operace je řešena
s&nbsp;využitím tří registrů:</p>

<pre>
        mov     ax,si
        shl     ax,1
        mov     bx,word ptr [bp+4]
        add     bx,ax
        ...
        mov     word ptr [bx],ax
        inc     si
</pre>

<p>Dva přístupy do paměti jsou zbytečné. Zejména naplnění registru
<strong>BX</strong> bázovou adresou pole by mohlo být vyřešeno mimo vlastní
programovou smyčku &ndash; kód je mj.&nbsp;i v&nbsp;tomto ohledu dosti
neoptimální.</p>

<p>Překladač Borland C++ dokáže provádět i malé optimalizace, což se projeví i
na způsobu zápisu prvků do pole:</p>

<pre>
_fill_array     proc    near
        push    bp
        mov     bp,sp
        push    si
        push    di
        mov     di,word ptr [bp+4]
        mov     dx,word ptr [bp+6]
        mov     cx,word ptr [bp+8]
   ;    
   ;        int i;
   ;        for (i=0; i&lt;size; i++) {
   ;    
        xor     si,si
        jmp     short @1@98
@1@50:
   ;    
   ;            array[i] = value;
   ;    
        mov     bx,si
        shl     bx,1
        mov     ax,cx
        mov     word ptr [bx+di],ax
        inc     si
@1@98:
        cmp     si,dx
        jl      short @1@50
   ;    
   ;        }
   ;    }
   ;    
        pop     di
        pop     si
        pop     bp
        ret     
_fill_array     endp
</pre>

<p>Nyní je zápis do pole kratší. Pro adresaci je opět použit registr
<strong>BX</strong> společně s&nbsp;bází uloženou v&nbsp;registru
<strong>DI</strong>:</p>

<pre>
        mov     bx,si
        shl     bx,1
        mov     ax,cx
        mov     word ptr [bx+di],ax
        inc     si
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výsledky vygenerované překladačem Watcom C/C++</h2>

<p>Druhým překladačem, který otestujeme, je &ndash; podobně jako minule &ndash;
Watcom C/C++. Ten by měl umět vygenerovat lepší kód, než Borland C++. Podívejme
se nejdříve na způsob překladu při <i>vypnutí</i> všech optimalizací:</p>

<pre>
Module: C:\fill_a.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 00000022 bytes
0000                          fill_array_:
0000    50                        push        ax 
0001    B8 06 00                  mov         ax,0x0006 
0004    E8 00 00                  call        __STK 
0007    58                        pop         ax 
0008    51                        push        cx 
0009    56                        push        si 
000A    89 C6                     mov         si,ax 
000C    89 D9                     mov         cx,bx 
000E    31 C0                     xor         ax,ax 
0010                          L$1:
0010    39 D0                     cmp         ax,dx 
0012    7D 0B                     jge         L$2 
0014    89 C3                     mov         bx,ax 
0016    D1 E3                     shl         bx,0x01 
0018    01 F3                     add         bx,si 
001A    89 0F                     mov         word ptr [bx],cx 
001C    40                        inc         ax 
001D    EB F1                     jmp         L$1 
001F                          L$2:
001F    5E                        pop         si 
0020    59                        pop         cx 
0021    C3                        ret         
&nbsp;
Routine Size: 34 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p>Instrukce realizující interní počítanou smyčku sice nejsou naprogramovány
ideálně, ovšem provádí se zde pouze jediný přístup do paměti, což je oproti
překladači Borland C++ lepší řešení. Stále se však pro adresaci prvků pole
používá zbytečně velké množství registrů:</p>

<pre>
L$1:
    cmp         ax,dx 
    jge         L$2 
    mov         bx,ax 
    shl         bx,0x01 
    add         bx,si 
    mov         word ptr [bx],cx 
    inc         ax 
    jmp         L$1 
</pre>

<p>Následuje výpis kódu vytvořeného týmž překladačem, ovšem po zapnutí
vybraných optimalizací. Celková délka kódu zůstává shodná, ovšem jednotlivé
instrukce jsou odlišné:</p>

<pre>
Module: C:\fill_a.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 00000022 bytes
0000                          fill_array_:
0000    50                        push        ax 
0001    B8 06 00                  mov         ax,0x0006 
0004    E8 00 00                  call        __STK 
0007    58                        pop         ax 
0008    51                        push        cx 
0009    56                        push        si 
000A    89 C6                     mov         si,ax 
000C    89 D9                     mov         cx,bx 
000E    31 C0                     xor         ax,ax 
0010                          L$1:
0010    39 D0                     cmp         ax,dx 
0012    7D 0B                     jge         L$2 
0014    89 C3                     mov         bx,ax 
0016    01 C3                     add         bx,ax 
0018    01 F3                     add         bx,si 
001A    89 0F                     mov         word ptr [bx],cx 
001C    40                        inc         ax 
001D    EB F1                     jmp         L$1 
001F                          L$2:
001F    5E                        pop         si 
0020    59                        pop         cx 
0021    C3                        ret         
&nbsp;
Routine Size: 34 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p>V&nbsp;tomto případě se liší způsob výpočtu adresy prvku pole &ndash; pro
tento účel se používá registr <strong>BX</strong>, zatímco <strong>AX</strong>
je počitadlo smyčky současně i registru pro uložení indexu. Bázová adresa pole
se nachází v&nbsp;registru <strong>SI</strong> a kupodivu se báze+offset sčítá
explicitně a nikoli s&nbsp;využitím adresovacího režimu:</p>

<pre>
L$1:
    cmp         ax,dx 
    jge         L$2 
    mov         bx,ax 
    add         bx,ax 
    add         bx,si 
    mov         word ptr [bx],cx 
    inc         ax 
    jmp         L$1 
</pre>

<p>Zapnutí maximálních optimalizací:</p>

<pre>
Module: C:\fill_a.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE16 0000001B bytes
0000                          fill_array_:
0000    51                        push        cx 
0001    56                        push        si 
0002    89 C6                     mov         si,ax 
0004    89 D1                     mov         cx,dx 
0006    89 DA                     mov         dx,bx 
0008    89 F3                     mov         bx,si 
000A    31 C0                     xor         ax,ax 
000C                          L$1:
000C    39 C8                     cmp         ax,cx 
000E    7D 08                     jge         L$2 
0010    40                        inc         ax 
0011    89 17                     mov         word ptr [bx],dx 
0013    83 C3 02                  add         bx,0x0002 
0016    EB F4                     jmp         L$1 
0018                          L$2:
0018    5E                        pop         si 
0019    59                        pop         cx 
001A    C3                        ret         
&nbsp;
Routine Size: 27 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST WORD USE16 00000000 bytes
&nbsp;
Segment: CONST2 WORD USE16 00000000 bytes
&nbsp;
Segment: _DATA WORD USE16 00000000 bytes
</pre>

<p>Vygenerovaný programový kód se o sedm bajtů zkrátil, ovšem důležité jsou
optimalizace vnitřní programové smyčky. Nyní je adresace skutečně krátká
&ndash; využívá se zde pouze registr <strong>BX</strong>, jenž je původně
nastaven na bázi pole (adresu prvního prvku):</p>

<pre>
L$1:
    cmp         ax,cx 
    jge         L$2 
    inc         ax 
    mov         word ptr [bx],dx 
    add         bx,0x0002 
    jmp         L$1 
</pre>

<p>Pro zajímavost se ještě podívejme na způsob překladu do 32bitového kódu,
v&nbsp;němž je šířka typu <strong>int</strong> rovna třiceti dvěma bitům, což
ovlivňuje jak maximální délku pole, tak i rozsah hodnot jeho prvků:</p>

<pre>
Module: C:\fill_a.c
GROUP: 'DGROUP' CONST,CONST2,_DATA
&nbsp;
Segment: _TEXT BYTE USE32 00000013 bytes
0000                          fill_array_:
0000    51                        push        ecx 
0001    89 D1                     mov         ecx,edx 
0003    31 D2                     xor         edx,edx 
0005                          L$1:
0005    39 CA                     cmp         edx,ecx 
0007    7D 08                     jge         L$2 
0009    42                        inc         edx 
000A    89 18                     mov         dword ptr [eax],ebx 
000C    83 C0 04                  add         eax,0x00000004 
000F    EB F4                     jmp         L$1 
0011                          L$2:
0011    59                        pop         ecx 
0012    C3                        ret         
&nbsp;
Routine Size: 19 bytes,    Routine Base: _TEXT + 0000
&nbsp;
No disassembly errors
&nbsp;
Segment: CONST DWORD USE32 00000000 bytes
git@github.com:tisnik/lightspeed-providers.git
Segment: CONST2 DWORD USE32 00000000 bytes
&nbsp;
Segment: _DATA DWORD USE32 00000000 bytes
</pre>

<p>16bitový a 32bitový kód se liší vlastně jen nepatrně, což je ještě lépe
patrné při porovnání stylem instrukce po instrukci:</p>

<pre>
L$1:                                  L$1:
    cmp         ax,cx                     cmp         edx,ecx 
    jge         L$2                       jge         L$2 
    inc         ax                        inc         edx 
    mov         word ptr [bx],dx          mov         dword ptr [eax],ebx 
    add         bx,0x0002                 add         eax,0x00000004 
    jmp         L$1                       jmp         L$1 
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;32bitovém režimu je možné použít
pro adresování i registr <strong>EAX</strong>, což je jeden z&nbsp;důvodů, proč
je výsledný programový kód kratší, než jeho 16bitová varianta.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Porovnání s&nbsp;moderními instrukčními sadami a moderními překladači</h2>

<p>A jak bude stejný zdrojový kód přeložen moderním překladačem s&nbsp;využitím
instrukční sady x86-64? Výsledný kód je ovlivněn snahou o lepší využití fronty
instrukcí, rozbalení smyčky atd. Například překladač GCC při použití základních
optimalizací (-O2) vygeneruje kód, v&nbsp;němž se v&nbsp;každé iteraci do pole
zapíše <i>dvojice</i> hodnot. Možnost, že by pole obsahovalo lichý počet prvků,
je řešena ještě před vstupem do smyčky. Celý kód je sice delší, ale díky
částečnému rozbalení smyčky (od návěští .L3 do návěští .L1) se lépe využijí
možnosti moderních CPU:</p>

<pre>
fill_array:
.LFB0:
        test    esi, esi
        jle     .L1
        movsx   rsi, esi
        lea     rax, [rdi+rsi*4]
        and     esi, 1
        je      .L3
        mov     DWORD PTR [rdi], edx
        add     rdi, 4
        cmp     rdi, rax
        je      .L11
.L3:
        mov     DWORD PTR [rdi], edx
        add     rdi, 8
        mov     DWORD PTR [rdi-4], edx
        cmp     rdi, rax
        jne     .L3
.L1:
        ret
.L11:
        ret
</pre>

<p>Mnohem delší a interně složitější kód je vygenerován při povolení maximální
úrovně optimalizací. Ústředním prvkem výsledného kódu je částečně rozbalená
programová smyčka pracující s&nbsp;registry <strong>XMMx</strong>, tedy se
128bitovými vektory. V&nbsp;jedné iteraci se do pole zapíše 256 bitů:</p>

<pre>
.L4:
        movups  XMMWORD PTR [rax], xmm0
        add     rax, 32
        movups  XMMWORD PTR [rax-16], xmm0
        cmp     rax, rdi
        jne     .L4
</pre>

<p>Celý kód je ovšem mnohem složitější, protože řeší přípravu konstanty uložené
do registru <strong>XMM0</strong> a taktéž stavy, kdy pole obsahuje počet
prvků, který není dělitelný osmi:</p>

<pre>
fill_array:
.LFB0:
        mov     r8, rdi
        mov     ecx, esi
        test    esi, esi
        jle     .L1
        lea     eax, [rsi-1]
        cmp     eax, 2
        jbe     .L6
        shr     esi, 2
        movd    xmm1, edx
        mov     rax, rdi
        sal     rsi, 4
        pshufd  xmm0, xmm1, 0
        lea     rdi, [rsi+rdi]
        and     esi, 16
        je      .L4
        lea     rax, [r8+16]
        movups  XMMWORD PTR [r8], xmm0
        cmp     rax, rdi
        je      .L13
.L4:
        movups  XMMWORD PTR [rax], xmm0
        add     rax, 32
        movups  XMMWORD PTR [rax-16], xmm0
        cmp     rax, rdi
        jne     .L4
.L13:
        mov     eax, ecx
        and     eax, -4
        test    cl, 3
        je      .L15
.L3:
        movsx   rsi, eax
        mov     DWORD PTR [r8+rsi*4], edx
        lea     rdi, [0+rsi*4]
        lea     esi, [rax+1]
        cmp     ecx, esi
        jle     .L1
        add     eax, 2
        mov     DWORD PTR [r8+4+rdi], edx
        cmp     ecx, eax
        jle     .L1
        mov     DWORD PTR [r8+8+rdi], edx
.L1:
        ret
.L15:
        ret
.L6:
        xor     eax, eax
        jmp     .L3
</pre>

<p>Naopak, pokud si vyžádáme vygenerování co nejkratšího kódu, získáme velmi
jednoduchou smyčku s&nbsp;adresováním typu báze+index*konstanta:</p>

<pre>
fill_array:
.LFB0:
        xor     eax, eax
.L2:
        cmp     esi, eax
        jle     .L5
        mov     DWORD PTR [rdi+rax*4], edx
        inc     rax
        jmp     .L2
.L5:
        ret
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překladače podporující 32bitovou instrukční sadu</h2>

<p>Jednou z&nbsp;největších revolucí, která na platformě IBM PC proběhla, se
stal postupný přechod k&nbsp;mikroprocesorům 80386. Interně se jednalo o nové
typy mikroprocesorů. Mikroprocesory 80386 nabízely nové užitečné instrukce,
které jsme si již v&nbsp;tomto seriálu popsali.</p>

<p>To však není ani zdaleka vše, protože mikroprocesory 80386 a 80486 jsou
nazývány 32bitovými čipy mj.&nbsp;i z&nbsp;toho důvodu, že se u nich rozšířila
aritmeticko-logická jednotka tak, aby bylo možné pracovat s&nbsp;32bitovými
operandy. A tomu se musela přizpůsobit i sada pracovních registrů. Společnost
Intel se rozhodla, že namísto &bdquo;párování&ldquo; dvou šestnáctibitových
registrů do registrů 32bitových rozšíří původní registry ze šestnácti bitů na
plných 32 bitů. Týká se to všech čtyř pracovních registrů AX, BX, CX, DX,
indexových registrů SI, DI, bázových registrů SP, BP i ukazatele na instrukci
IP. Tyto registry byly rozšířeny o horních šestnáct bitů, přičemž je stále
možné adresovat spodních 16 bitů původními jmény registrů a/nebo (pouze u
pracovních registrů) použít jejich horních a spodních osm bitů zvlášť (AX=AH+AL
atd.). V&nbsp;assembleru se 32bitové registry poznají podle toho, že začínají
písmenem <strong>E</strong>.</p>

<p>A konečně &ndash; zlepšily se možnosti adresování v&nbsp;chráněném režimu a
navíc bylo možné využít i režim virtuální.</p>

<p>Všechny tyto změny museli tvůrci překladačů nějakým způsobem začít
podporovat. V&nbsp;některých případech se jednalo &bdquo;pouze&ldquo; o podporu
nových instrukcí a rozšířených registrů, další překladače již dokázaly
překládat 32bitový kód pro chráněný režim. To je rozdíl, který se projevuje i
na způsobu kódování instrukcí.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Šestnáctibitové a 32bitovové instrukce v&nbsp;reálném a chráněném režimu</h2>

<p>V&nbsp;systému DOS se ve výchozím stavu používá reálný režim (<i>real
mode</i>), ve kterém je sice možné používat jak šestnáctibitové, tak i 32bitové
instrukce, ovšem v&nbsp;případě 32bitových instrukcí se před každou instrukci
vloží prefix 0x66 nebo 0x67. Ovšem naopak v&nbsp;32bitovém chráněném režimu
(<i>protected mode</i>) se prefixy vkládají před šestnáctibitové instrukce.
Připomeňme si tyto rozdíly na dvojici příkladů psaných přímo
v&nbsp;assembleru.</p>

<pre>
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU 386         <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
        xor  al, al
        inc  al
&nbsp;
        xor  ax, ax
        inc  ax
&nbsp;
        xor  eax, eax
        inc  eax
</pre>

<p>Po překladu si povšimněte prefixů 0x66 u posledních dvou instrukcí:</p>

<pre>
    27 00000000 30C0                            xor  al, al
    28 00000002 FEC0                            inc  al
    29                                  
    30 00000004 31C0                            xor  ax, ax
    31 00000006 40                              inc  ax
    32                                  
    33 00000007 6631C0                          xor  eax, eax
    34 0000000A 6640                            inc  eax
</pre>

<p>Mohlo by se zdát, že třetí generace mikroprocesorů sice dokáže provádět
32bitové operace, ale platíme za to dosti vysokou cenu &ndash; každá instrukce
je o bajt delší, což ovlivňuje využití cache atd. Ve skutečnosti tomu tak je
pouze v&nbsp;původním šestnáctibitovém režimu mikroprocesorů. Pokud se
mikroprocesor nachází v&nbsp;režimu 32bitovém (čehož ovšem není zcela snadné
dosáhnout), bude situace prakticky opačná. Jak by situace vypadala
v&nbsp;32bitovém režimu, si můžeme ověřit překladem následujícího příkladu,
v&nbsp;němž jsme pozměnili specifikaci <strong>BITS 16</strong> na <strong>BITS
32</strong>. Výsledný binární soubor sice nebude v&nbsp;DOSu přímo spustitelný,
ovšem nás nyní zajímá především způsob zakódování 32bitových instrukcí:</p>

<pre>
BITS 32         <i>; 16bitovy vystup pro DOS</i>
CPU 386         <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
        xor  al, al
        inc  al
&nbsp;
        xor  ax, ax
        inc  ax
&nbsp;
        xor  eax, eax
        inc  eax
</pre>

<p>Nyní budou prefixy použity naopak u šestnáctibitových operací. Operace nad
bajty zůstanou v&nbsp;obou případech totožné:</p>

<pre>
    27 00000000 30C0                            xor  al, al
    28 00000002 FEC0                            inc  al
    29                                  
    30 00000004 6631C0                          xor  ax, ax
    31 00000007 6640                            inc  ax
    32                                  
    33 00000009 31C0                            xor  eax, eax
    34 0000000B 40                              inc  eax
</pre>

<p>Co to konkrétně znamená pro překladače? Podívejme se nejprve na způsob
překladu stejné funkce (<strong>memset</strong>), nejprve pro 16bitový reálný
režim. V&nbsp;prvním případě se používají jen šestnáctibitové intstrukce, ovšem
<i>současně</i> je velikost typu <strong>int</strong> pouze šestnáctibitová
(což je mimochodem zcela v&nbsp;souladu s&nbsp;normami jazyka C!):</p>

<pre>
0000                          memset_:
0000    51                        push        cx 
0001    89 C1                     mov         cx,ax 
0003    89 D8                     mov         ax,bx 
0005    89 CB                     mov         bx,cx 
0007                          L$1:
0007    48                        dec         ax 
0008    3D FF FF                  cmp         ax,0xffff 
000B    74 05                     je          L$2 
000D    88 17                     mov         byte ptr [bx],dl 
000F    43                        inc         bx 
0010    EB F5                     jmp         L$1 
0012                          L$2:
0012    89 C8                     mov         ax,cx 
0014    59                        pop         cx 
0015    C3                        ret         
</pre>

<p>Při překladu s&nbsp;využitím 32bitových instrukcí již bude velikost typu
<strong>int</strong> taktéž 32bitová, ovšem současně překladač provedl překlad
pro chráněný 32bitový režim. Za povšimnutí stojí prakticky stejná struktura
výsledného kódu a taktéž adresace hodnotou uloženou v&nbsp;akumulátoru
<strong>EAX</strong> (zatímco <strong>AX</strong> v&nbsp;režimu
šestnáctibitovém pro tyto účely využít nelze):</p>

<pre>
0000                          memset_:
0000    51                        push        ecx 
0001    89 C1                     mov         ecx,eax 
0003                          L$1:
0003    4B                        dec         ebx 
0004    83 FB FF                  cmp         ebx,0xffffffff 
0007    74 05                     je          L$2 
0009    88 10                     mov         byte ptr [eax],dl 
000B    40                        inc         eax 
000C    EB F5                     jmp         L$1 
000E                          L$2:
000E    89 C8                     mov         eax,ecx 
0010    59                        pop         ecx 
0011    C3                        ret         
</pre>

<p>Porovnání po jednotlivých instrukcích ukazuje, jak se vylepšené možnosti
adresování v&nbsp;32bitovém režimu projevily ve výsledném kódu:</p>

<pre>
memset_:                               memset_:
    push        cx                         push        ecx 
    mov         cx,ax                      mov         ecx,eax 
    mov         ax,bx
    mov         bx,cx
L$1:                                   L$1:
    dec         ax                         dec         ebx 
    cmp         ax,0xffff                  cmp         ebx,0xffffffff 
    je          L$2                        je          L$2 
    mov         byte ptr [bx], dl          mov         byte ptr [eax],dl
    inc         bx                         inc         eax 
    jmp         L$1                        jmp         L$1 
L$2:                                   L$2:
    mov         ax,cx                      mov         eax,ecx 
    pop         cx                         pop         ecx 
    ret                                    ret         
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že druhý kód je ve
skutečnosti o čtyři bajty kratší, než kód první!</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. DJGPP</h2>

<p></p>

DJGPP was born around 1989, when Richard Stallman spoke at .... I asked if the FSF ever planned on porting gcc to MS-DOS, and he said it couldn't be done because gcc was too big and MS-DOS was a 16-bit operating system. Challenge in hand, I began.

The first gcc I built was 1.35, which I built on an ISC Unix system running on a 386/16. I wrote custom replacements for the system calls, linked with ISC's libc.a, write a custom program to turn the resulting binary into a 32-bit EXE that Phar Lap's extender could use, and had the first gcc that ran on MS-DOS.



<p><a name="k09"></a></p>
<h2 id="k09">9. Malá odbočka: RHIDE</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Překlad testovacích příkladů pomocí DJGPP</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Funkce pro součet dvou celých čísel</h2>

<pre>
int add(int a, int b) {
    return a+b;
}
</pre>

<pre>
_add:
LFB0:
        push    ebp
        mov     ebp, esp
        mov     edx, DWORD PTR [ebp+8]
        mov     eax, DWORD PTR [ebp+12]
        add     eax, edx
        pop     ebp
        ret
</pre>

<pre>
_add:
LFB0:
        mov     eax, DWORD PTR [esp+8]
        mov     edx, DWORD PTR [esp+4]
        add     eax, edx
        ret
</pre>

<pre>
_add:
LFB0:
        push    ebp
        mov     ebp, esp
        mov     eax, DWORD PTR [ebp+12]
        add     eax, DWORD PTR [ebp+8]
        pop     ebp
        ret
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Funkce pro vyplnění paměťové oblasti</h2>

<pre>
#include <mem.h>

void * memset(void *dest, register int val, register size_t len) {
    register unsigned char *ptr = (unsigned char*)dest;
    while (len-- > 0)
        *ptr++ = val;
    return dest;
}
</pre>

<pre>
_memset:
LFB0:
        push    ebp
        mov     ebp, esp
        push    ebx
        mov     ecx, DWORD PTR [ebp+16]
        mov     ebx, DWORD PTR [ebp+8]
        jmp     L2
L3:
        mov     eax, ebx
        lea     ebx, [eax+1]
        mov     dl, BYTE PTR [ebp+12]
        mov     BYTE PTR [eax], dl
L2:
        mov     eax, ecx
        lea     ecx, [eax-1]
        test    eax, eax
        jne     L3
        mov     eax, DWORD PTR [ebp+8]
        pop     ebx
        pop     ebp
        ret
</pre>

<pre>
_memset:
LFB0:
        push    edi
        push    ebx
        mov     edx, DWORD PTR [esp+20]
        test    edx, edx
        je      L12
        xor     ebx, ebx
        mov     edi, DWORD PTR [esp+12]
        mov     bl, BYTE PTR [esp+16]
        cmp     edx, 4
        jnb     L22
L3:
        and     edx, 3
        je      L12
        xor     eax, eax
L6:
        mov     BYTE PTR [edi+eax], bl
        inc     eax
        cmp     eax, edx
        jb      L6
L12:
        mov     eax, DWORD PTR [esp+12]
        pop     ebx
        pop     edi
        ret
L22:
        xor     eax, eax
        mov     al, bl
        mov     ah, al
        mov     ecx, eax
        sal     ecx, 16
        or      eax, ecx
        test    edi, 1
        jne     L23
L4:
        test    edi, 2
        jne     L24
L5:
        mov     ecx, edx
        shr     ecx, 2
        rep stosd
        jmp     L3
L23:
        mov     BYTE PTR [edi], al
        dec     edx
        mov     ecx, DWORD PTR [esp+12]
        lea     edi, [ecx+1]
        jmp     L4
L24:
        mov     WORD PTR [edi], ax
        sub     edx, 2
        add     edi, 2
        jmp     L5
</pre>

<pre>
_memset:
LFB0:
        push    ebp
        mov     ebp, esp
        push    ebx
        mov     edx, DWORD PTR [ebp+8]
        mov     ecx, DWORD PTR [ebp+16]
        add     ecx, edx
        mov     eax, edx
L2:
        cmp     eax, ecx
        je      L6
        inc     eax
        mov     bl, BYTE PTR [ebp+12]
        mov     BYTE PTR [eax-1], bl
        jmp     L2
L6:
        pop     ebx
        mov     eax, edx
        pop     ebp
        ret
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce pro nalezení největší hodnoty v&nbsp;poli</h2>

<pre>
#include <stdio.h>

typedef unsigned int uint;

uint find_max(uint *array, uint length) {
    uint max = 0;
    uint i;
    uint *item = array;

    for (i=0; i<length; i++) {
        if (max < *item) {
            max = *item;
        }
        item++;
    }
    return max;
}

int main(void) {
#define LENGTH 10

    uint array[LENGTH] = {5, 6, 7, 8, 9, 0, 1, 2, 3, 4};
    uint max = find_max(array, LENGTH);
    printf("%d\n", max);
    return 0;
}
</pre>

<pre>
_find_max:
LFB0:
        push    ebp
        mov     ebp, esp
        sub     esp, 16
        mov     DWORD PTR [ebp-4], 0
        mov     eax, DWORD PTR [ebp+8]
        mov     DWORD PTR [ebp-12], eax
        mov     DWORD PTR [ebp-8], 0
        jmp     L2
L4:
        mov     eax, DWORD PTR [ebp-12]
        mov     eax, DWORD PTR [eax]
        cmp     DWORD PTR [ebp-4], eax
        jnb     L3
        mov     eax, DWORD PTR [ebp-12]
        mov     eax, DWORD PTR [eax]
        mov     DWORD PTR [ebp-4], eax
L3:
        add     DWORD PTR [ebp-12], 4
        inc     DWORD PTR [ebp-8]
L2:
        mov     eax, DWORD PTR [ebp-8]
        cmp     eax, DWORD PTR [ebp+12]
        jb      L4
        mov     eax, DWORD PTR [ebp-4]
        leave
        ret
</pre>

<pre>
_find_max:
LFB0:
        push    esi
        push    ebx
        mov     ebx, DWORD PTR [esp+16]
        mov     esi, DWORD PTR [esp+12]
        test    ebx, ebx
        je      L5
        xor     eax, eax
        xor     ecx, ecx
L4:
        mov     edx, DWORD PTR [esi+eax*4]
        cmp     ecx, edx
        jnb     L3
        mov     ecx, edx
L3:
        inc     eax
        cmp     ebx, eax
        jne     L4
        pop     ebx
        mov     eax, ecx
        pop     esi
        ret
L5:
        xor     ecx, ecx
        pop     ebx
        mov     eax, ecx
        pop     esi
        ret
</pre>

<pre>
_find_max:
LFB0:
        push    ebp
        xor     eax, eax
        mov     ebp, esp
        xor     edx, edx
L2:
        cmp     eax, DWORD PTR [ebp+12]
        je      L7
        mov     ecx, DWORD PTR [ebp+8]
        mov     ecx, DWORD PTR [ecx+eax*4]
        cmp     edx, ecx
        jnb     L3
        mov     edx, ecx
L3:
        inc     eax
        jmp     L2
L7:
        mov     eax, edx
        pop     ebp
        ret
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Funkce pro vyplnění pole zadanou hodnotou</h2>

<pre>
void fill_array(int *array, int size, int value) {
    int i;
    for (i=0; i<size; i++) {
        array[i] = value;
    }
}
</pre>

<pre>
_fill_array:
LFB0:
        push    ebp
        mov     ebp, esp
        sub     esp, 16
        mov     DWORD PTR [ebp-4], 0
        jmp     L2
L3:
        mov     eax, DWORD PTR [ebp-4]
        lea     edx, [0+eax*4]
        mov     eax, DWORD PTR [ebp+8]
        add     edx, eax
        mov     eax, DWORD PTR [ebp+16]
        mov     DWORD PTR [edx], eax
        inc     DWORD PTR [ebp-4]
L2:
        mov     eax, DWORD PTR [ebp-4]
        cmp     eax, DWORD PTR [ebp+12]
        jl      L3
        nop
        nop
        leave
        ret
</pre>

<pre>
_fill_array:
LFB0:
        mov     ecx, DWORD PTR [esp+8]
        mov     edx, DWORD PTR [esp+12]
        test    ecx, ecx
        jle     L1
        mov     eax, DWORD PTR [esp+4]
        lea     ecx, [eax+ecx*4]
L3:
        mov     DWORD PTR [eax], edx
        add     eax, 4
        cmp     ecx, eax
        jne     L3
L1:
        ret
</pre>

<pre>
_fill_array:
LFB0:
        push    ebp
        xor     eax, eax
        mov     ebp, esp
        mov     edx, DWORD PTR [ebp+8]
        mov     ecx, DWORD PTR [ebp+16]
L2:
        cmp     eax, DWORD PTR [ebp+12]
        jge     L6
        mov     DWORD PTR [edx+eax*4], ecx
        inc     eax
        jmp     L2
L6:
        pop     ebp
        ret
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Podpora operací s&nbsp;plovoucí řádovou čárkou v&nbsp;céčkových překladačích</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyce C, které jsou primárně určené
pro překlad s&nbsp;využitím překladačů <i>Turbo C</i> a <i>(Open)Watcom C)</i>,
byly uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<p>Borland C:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add.c</a></td></tr>
<tr><td> 2</td><td>add1.asm</td><td>překlad přes assembler, externí symboly začínají pomlčkou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add1.asm</a></td></tr>
<tr><td> 3</td><td>add2.asm</td><td>překlad přes assembler, externí symboly nejsou přejmenovány</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add2.asm</a></td></tr>
<tr><td> 4</td><td>add3.asm</td><td>výsledek překladu se zákazem optimalizací (externí symboly s&nbsp;pomlčkou)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add3.asm</a></td></tr>
<tr><td> 5</td><td>add4.asm</td><td>výsledek překladu se zákazem optimalizací (externí symboly nejsou přejmenovány)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add4.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add4.asm</a></td></tr>
<tr><td> 6</td><td>add5.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add5.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add5.asm</a></td></tr>
<tr><td> 7</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset.c</a></td></tr>
<tr><td> 8</td><td>memset_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_1.asm</a></td></tr>
<tr><td> 9</td><td>memset_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/memset_2.asm</a></td></tr>
<tr><td>10</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max.c</a></td></tr>
<tr><td>11</td><td>find_max_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_1.asm</a></td></tr>
<tr><td>12</td><td>find_max_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_2.asm</a></td></tr>
<tr><td>13</td><td>find_max_3.asm</td><td>výsledek překladu s&nbsp;povolením instrukcí procesorů 80286</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/find_max_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>add_f.c</td><td>funkce pro součet dvou čísel s&nbsp;plovoucí řádovou čárkou naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f.c</a></td></tr>
<tr><td>15</td><td>add_f_1.asm</td><td>překlad přes assembler</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f_1.asm</a></td></tr>
<tr><td>16</td><td>add_f_2.asm</td><td>překlad přes assembler s&nbsp;eliminací skoků a dalšími optimalizacemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/bc/add_f_2.asm</a></td></tr>
</table>



<p>(Open)Watcom pro platformu IBM PC:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add.c</a></td></tr>
<tr><td> 2</td><td>add1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add1.asm</a></td></tr>
<tr><td> 3</td><td>add2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add2.asm</a></td></tr>
<tr><td> 4</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset.c</a></td></tr>
<tr><td> 5</td><td>memset1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset1.asm</a></td></tr>
<tr><td> 6</td><td>memset2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset2.asm</a></td></tr>
<tr><td> 7</td><td>memset3.asm</td><td>výsledek překladu do 32bitového kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/memset3.asm</a></td></tr>
<tr><td> 8</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max.c</a></td></tr>
<tr><td> 9</td><td>find_max_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_1.asm</a></td></tr>
<tr><td>10</td><td>find_max_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_2.asm</a></td></tr>
<tr><td>11</td><td>find_max_3.asm</td><td>výsledek překladu do 32bitového kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/find_max_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>add_f.c</td><td>funkce pro součet dvou čísel s&nbsp;plovoucí řádovou čárkou naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f.c</a></td></tr>
<tr><td>13</td><td>add_f_1.asm</td><td>překlad přes assembler</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_1.asm</a></td></tr>
<tr><td>14</td><td>add_f_2.asm</td><td>překlad přes assembler s&nbsp;optimalizacemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_2.asm</a></td></tr>
<tr><td>15</td><td>add_f_3.asm</td><td>překlad přes assembler s&nbsp;využitím FP knihovny</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/watcom/add_f_3.asm</a></td></tr>
</table>

<p>GCC pro platformu x86-64:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td>funkce pro součet dvou celých čísel naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.c</a></td></tr>
<tr><td> 2</td><td>add.asm</td><td>výsledek překladu do assembleru s&nbsp;použitím optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/add.asm</a></td></tr>
<tr><td> 3</td><td>memset.c</td><td>funkce pro vyplnění paměťového bloku naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset.c</a></td></tr>
<tr><td> 4</td><td>memset_1.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_1.asm</a></td></tr>
<tr><td> 5</td><td>memset_2.asm</td><td>výsledek překladu s&nbsp;povolením optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/memset_2.asm</a></td></tr>
<tr><td> 6</td><td>find_max.c</td><td>funkce pro nalezení největšího prvku v&nbsp;poli naprogramovaná v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max.c</a></td></tr>
<tr><td> 7</td><td>find_max_default.asm</td><td>výsledek překladu se zákazem optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_default.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_default.asm</a></td></tr>
<tr><td> 8</td><td>find_max_smallest.asm</td><td>výsledek překladu s&nbsp;optimalizací na velikost kódu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_smallest.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_smallest.asm</a></td></tr>
<tr><td> 9</td><td>find_max_vector.asm</td><td>výsledek překladu s&nbsp;optimalizací na rychlost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_vector.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/gcc/find_max_vector.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>

<p>DGJPP</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add.c</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add.c</a></td></tr>
<tr><td> 2</td><td>add_1.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_1.asm</a></td></tr>
<tr><td> 3</td><td>add_2.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_2.asm</a></td></tr>
<tr><td> 4</td><td>add_3.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/add_3.asm</a></td></tr>
<tr><td> 5</td><td>memset.c</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset.c</a></td></tr>
<tr><td> 6</td><td>memset_1.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_1.asm</a></td></tr>
<tr><td> 7</td><td>memset_2.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_2.asm</a></td></tr>
<tr><td> 8</td><td>memset_3.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/memset_3.asm</a></td></tr>
<tr><td> 9</td><td>find_max.c</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/find_max.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/find_max.c</a></td></tr>
<tr><td>10</td><td>findmax1.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax1.asm</a></td></tr>
<tr><td>11</td><td>findmax2.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax2.asm</a></td></tr>
<tr><td>12</td><td>findmax3.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/findmax3.asm</a></td></tr>
<tr><td>13</td><td>fill_a.c</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a.c">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a.c</a></td></tr>
<tr><td>14</td><td>fill_a_1.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_1.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_1.asm</a></td></tr>
<tr><td>15</td><td>fill_a_2.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_2.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_2.asm</a></td></tr>
<tr><td>16</td><td>fill_a_3.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_3.asm">https://github.com/tisnik/8bit-fame/blob/master/compilers/djgpp/fill_a_3.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>DJGPP (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/DJGPP">https://cs.wikipedia.org/wiki/DJGPP</a>
</li>

<li>DJGPP home page<br />
<a href="http://www.delorie.com/djgpp/">http://www.delorie.com/djgpp/</a>
</li>

<li>DJGPP Zip File Picker<br />
<a href="http://www.delorie.com/djgpp/zip-picker.html">http://www.delorie.com/djgpp/zip-picker.html</a>
</li>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Warnings Are Your Friend - A Code Quality Primer<br />
<a href="https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/">https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/</a>
</li>

<li>Defending Against Compiler-Based Backdoors<br />
<a href="https://blog.regehr.org/archives/1241">https://blog.regehr.org/archives/1241</a>
</li>

<li>Reflections on Trusting Trust<br />
<a href="https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html">https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html</a>
</li>

<li>Coding Machines (povídka)<br />
<a href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>
</li>

<li>Stage0<br />
<a href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>
</li>

<li>Projekt stage0 na GitHubu<br />
<a href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>
</li>

<li>Bootstraping wiki<br />
<a href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>
</li>

<li>Bootstrapped 6502 Assembler<br />
<a href="https://github.com/robinluckey/bootstrap-6502">https://github.com/robinluckey/bootstrap-6502</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>What is a coder's worst nightmare?<br />
<a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute</a>
</li>

<li>Tiny C Compiler<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Welcome to C--<br />
<a href="https://www.cs.tufts.edu/~nr/c--/index.html">https://www.cs.tufts.edu/~nr/c--/index.html</a>
</li>

<li>c4 - C in four functions<br />
<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>Lattice C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Lattice_C">https://en.wikipedia.org/wiki/Lattice_C</a>
</li>

<li>Aztec C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Aztec_C">https://en.wikipedia.org/wiki/Aztec_C</a>
</li>

<li>Digital Mars (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Digital_Mars">https://en.wikipedia.org/wiki/Digital_Mars</a>
</li>

<li>Stránky projektu Open Watcom<br />
<a href="https://openwatcom.org/">https://openwatcom.org/</a>
</li>

<li>Repositář Open Watcom<br />
<a href="https://github.com/open-watcom/open-watcom-v2">https://github.com/open-watcom/open-watcom-v2</a>
</li>

<li>Watcom C/C++ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B">https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B</a>
</li>

<li>Turbo C (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_C">https://en.wikipedia.org/wiki/Turbo_C</a>
</li>

<li>Borland C++ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Borland_C%2B%2B">https://en.wikipedia.org/wiki/Borland_C%2B%2B</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

