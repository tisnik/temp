<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari</a></p>
<p><a href="#k02">2. Assemblery, interpretry a překladače</a></p>
<p><a href="#k03">3. Atari Assembler Editor</a></p>
<p><a href="#k04">4. MAC/65</a></p>
<p><a href="#k05">5. Atari BASIC</a></p>
<p><a href="#k06">6. Vybrané vlastnosti Atari BASICu</a></p>
<p><a href="#k07">7. Slavný Turbo-BASIC XL</a></p>
<p><a href="#k08">8. Strukturované programování v&nbsp;Turbo-BASICu</a></p>
<p><a href="#k09">9. Pomůcky při vývoji a ladění programů v&nbsp;Turbo-BASICu</a></p>
<p><a href="#k10">10. Atari LOGO</a></p>
<p><a href="#k11">11. Unikátní vlastnosti Atari Loga</a></p>
<p><a href="#k12">*** 12. Interlisp/65</a></p>
<p><a href="#k13">*** 13. Specifika Intelispu/65</a></p>
<p><a href="#k14">*** 14. Programovací jazyk Action!</a></p>
<p><a href="#k15">*** 15. Datové typy v&nbsp;jazyku Action!</a></p>
<p><a href="#k16">*** 16. Programové konstrukce v&nbsp;jazyku Action!</a></p>
<p><a href="#k17">*** 17. FIG-Forth</a></p>
<p><a href="#k18">*** 18. FastBASIC</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari</h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;vybranými programovacími jazyky
používanými na domácích osmibitových mikropočítačích Atari. S&nbsp;některými
dále zmíněnými jazyky jsme se sice již na stránkách Roota setkali dříve, ovšem
většinou pouze ve stručnosti a v&nbsp;odlišném kontextu. Popíšeme si jak
některé assemblery (resp.&nbsp;přesněji řečeno jazyky symbolických adres
&ndash; JSA &ndash; popř.&nbsp;jazyky symbolických instrukcí &ndash; JSI), tak
i vybrané interpretované jazyky, mezi které patří například <a
href="#k05">Atari BASIC</a>, <a href="#k07">Turbo-BASIC XL</a>, <a
href="#k10">Atari LOGO</a> či <a href="k12">Interlisp/65</a>. Nezapomeneme
ovšem ani na překladače (mezi něž ve světě osmibitových Atari patří zejména <a
href="#k15">jazyk Action!</a>) a dokonce ani na ty programovací jazyky, které
leží na pomezí mezi čistými interpretry na straně jedné a čistými překladači na
straně druhé &ndash; jedná se především o programovací jazyk <i>Forth</i>,
konkrétně o jeho variantu pojmenovanou <i>FIG-Forth</i> zmíněnou <a
href="#k17">v&nbsp;sedmnácté kapitole</a>. Na závěr se zmíníme o mnohem mladším
jazyku, jenž se jmenuje <a href="#k18">FastBASIC</a>. Tento jazyk se
v&nbsp;několika zásadních ohledech od klasických BASICů odlišuje a využívá se
dnes <a
href="https://atariage.com/forums/topic/316645-basic-10-liner-contest-2021/">v&nbsp;některých
programátorských soutěžích</a>.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-1.png" class="image-445912" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 1: Tuto obrazovku zná každý Atarista. Jedná se o výchozí režim
osmibitových mikropočítačů Atari ve chvíli, kdy není přítomna cartridge, nebyl
spuštěn Self Test, není zapnut režim nahrávání z&nbsp;kazetového magnetofonu
ani není připojena disketová jednotka. V&nbsp;tomto režimu může uživatel
zadávat příkazy Atari BASICu, s&nbsp;nímž se ve stručnosti seznámíme
v&nbsp;rámci páté kapitoly. Na rozdíl od implementací BASICu pro některé jiné
mikropočítače je v&nbsp;případě Atari BASICu k&nbsp;dispozici celoobrazovkový
textový editor s&nbsp;průběžnou kontrolou chyb.</i></p>

<p><div class="rs-tip-major">Poznámka: tento článek je zkrácenou verzí
rozsáhlejšího článku, který vyjde <a
href="http://flop.atariportal.cz/">v&nbsp;magazínu (přesněji řečeno
<i>diskmagu</i>) FLOP</a> určeného (nejenom) pro skalní Ataristy. Všechny
předchozí díly FLOPu je možné spustit v&nbsp;prakticky libovolném emulátoru
osmibitových Atari, například v&nbsp;multiplatformním emulátoru <a
href="https://github.com/atari800/atari800">atari800</a>.</div></p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-2.png" class="image-445913" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 2: Uvítací obrazovka jedné z&nbsp;variant Interlispu pro
osmibitové domácí mikropočítače Atari. O tomto jazyku se zmíníme ve dvanácté
kapitole.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Assemblery, interpretry a překladače</h2>

<p>Na osmibitových mikropočítačích (a nyní se zaměříme především na domácí
mikropočítače) měli ti uživatelé, kteří se chtěli zabývat programováním, na
výběr z&nbsp;relativně velkého množství různých vývojových nástrojů a pomůcek.
Některé mikropočítače byly vybaveny pouze velmi jednoduchým operačním systémem
zajišťujícím základní vstupně/výstupní operace (čtení klávesnice, zápis znaku
na obrazovku, rutiny pro čtení a zápis dat na magnetofon). Poměrně často byl
tento minimalistický operační systém doplněn o takzvaný <i>monitor</i> což byl
(a někde doposud je) program umožňující manipulaci s&nbsp;daty v&nbsp;operační
paměti, tj.&nbsp;zápis dat do paměti, čtení (zobrazení) vybraného bloku, přesun
bloku, vyplnění určité oblasti konstantou, čtení a zápis dat na externí
paměťové médium (typicky na magnetofon) a některé pokročilejší <i>monitory</i>
byly vybaveny i takzvaným <i>disassemblerem</i> umožňujícím transformaci
sekvence bajtů na symbolické instrukce. Mimochodem &ndash; při výpisu obsahu
operační paměti se v&nbsp;monitorech většinou používal stejný formát, jaký
najdeme u mnoha moderních <a
href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">programátorských
hexa editorů</a>.</p>

<a href="http://www.root.cz/obrazek/210810/"><img src="http://i.iinfo.cz/images/462/dev-8bit-6-prev.png" class="image-210810" width="370" height="254" alt="&#160;" /></a>
<p><i>Obrázek 3: Celoobrazovkové uživatelské rozhraní monitoru pro
mikropočítače Apple II.</i></p>

<p><div class="rs-tip-major">Poznámka: pro zajímavost &ndash; původní monitor
použitý v&nbsp;počítači <i>PMD 85.1</i> byl uložen ve čtyřech kilobajtech
paměti EPROM a obsahoval následující příkazy: <strong>SUB</strong>,
<strong>JUMP</strong>, <strong>MEM</strong>, <strong>DUMP</strong>,
<strong>BASIC</strong>, <strong>MGLD</strong>, <strong>MGSV</strong>,
<strong>MGEND</strong> a <strong>JOB</strong>.</div></p>

<a href="http://www.root.cz/obrazek/210811/"><img src="http://i.iinfo.cz/images/462/dev-8bit-7-prev.png" class="image-210811" width="370" height="264" alt="&#160;" /></a>
<p><i>Obrázek 4: Monitor pro slavné osmibitové počítače Commodore C64.</i></p>

<p>Monitory, zejména ty vybavené <i>disassemblerem</i> (zpětným assemblerem)
bylo možné použít i pro tvorbu programů na úrovni strojového kódu. Program se
většinou nejprve zapsal na papír ve formě assembleru, dále se provedl ruční
překlad jednotlivých instrukcí do sekvence decimálních nebo hexadecimálních
číslic a následně se tato sekvence zapsala do monitoru do určité předem vybrané
oblasti operační paměti. V&nbsp;případě, že monitor podporoval zápis bloku
paměti na externí paměťové médium (kazetový magnetofon, disketu), jednalo se o
dosti primitivní, ovšem stále ještě použitelné (a v&nbsp;některých případech i
používané) vývojové prostředí. Programování na úrovni strojového kódu je
samozřejmě velmi pracné, zejména ve chvíli, kdy je nutné existující program
modifikovat a tím pádem měnit cílové adresy skoků, adresy globálních proměnných
atd. Mnohem civilizovanější způsob představovalo použití takzvaných
<i>assemblerů</i>, což byly nástroje schopné překládat programy zapsané
v&nbsp;jazyku symbolických adres/instrukcí do strojového kódu &ndash; ostatně
přesně pro podobné činnosti jsou počítače zkonstruovány.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-3.png" class="image-445914" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 5: Jedním z&nbsp;poměrně velkého množství assemblerů vyvinutých
pro osmibitové mikropočítače Atari je SynAssembler vytvořený a prodávaný
společností Synapse Software. Tato společnost, s&nbsp;níž jsme se již na
stránkách Roota seznámili, se nezaměřovala pouze na vývoj počítačových her.
Kromě nich totiž vydávala i programy určené jak pro běžné koncové uživatele
(FileManager 800, DiskManager, SynFile+, SynCalc, SynChron, SynComm, SynStock,
SynTrend, ...) tak právě vývojové nástroje; mezi nimi i SynAssembler.</i></p>

<p>Na osmibitových domácích mikropočítačích se používaly dva typy
<i>assemblerů</i>. Prvním typem byly assemblery interaktivní, které uživateli
nabízely poměrně komfortní vývojové prostředí, v&nbsp;němž bylo možné zapisovat
jednotlivé instrukce, spouštět programy, krokovat je, vypisovat obsahy registrů
mikroprocesoru atd. Výhodou takto pojatého řešení byla nezávislost těchto
assemblerů na rychlém externím paměťovém médiu. S&nbsp;těmito assemblery
určenými pro počítače Atari se ve stručnosti seznámíme i v&nbsp;dnešním článku,
protože jak <a href="#k03">Atari Assembler Editor</a>, tak i <a
href="#k04">MAC/65</a> náleží do této kategorie. Druhý typ assemblerů je
používán dodnes &ndash; jedná se vlastně o běžné překladače, kterým se na
vstupu předloží zdrojový kód (uložený na kazetě či disketě) a po překladu se
výsledný nativní kód taktéž uloží na paměťové médium (odkud ho lze spustit).
Tyto assemblery byly mnohdy vybaveny více či méně dokonalým systémem maker
(odtud název <i>macroassembler</i>). Příkladem takového assembleru pro Atari
jsou všechny moderní <i>crossassemblery</i>.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-4.png" class="image-445915" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 6: Disassembler (zpětný assembler) určený pro mikropočítače Atari
(úvodní nastavení).</i></p>

<p>Mezi nejpoužívanější jazyky populární v&nbsp;dobách osmibitových domácích
mikropočítačů patřily zejména výše zmíněné assemblery a taktéž více či méně
dokonalé interpretry BASICu. To ovšem neznamená, že by nabídka programovacích
jazyků byla takto omezená. Ve skutečnosti bylo na osmibitové mikropočítače
portováno velké množství překladačů vyšších programovacích jazyků, zejména
jazyků podporujících procedurální paradigma, tj.&nbsp;skládání programů
z&nbsp;procedur (subrutin), v&nbsp;nichž se používají strukturované konstrukce
pro tvorbu rozeskoků a programových smyček.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-5.png" class="image-445916" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 7: Disassembler určený pro mikropočítače Atari (výpis
disassemblovaného kódu).</i></p>

<p>Z&nbsp;těchto jazyků byl populární především <i>Pascal</i>, a to díky tomu,
že tento jazyk byl navržen takovým způsobem, aby byl překlad programů proveden
jednoprůchodově a tudíž velmi rychle v&nbsp;porovnání s&nbsp;víceprůchodovými
překladači. Ovšem existovaly i další jazyky, například i populární céčko. Zde
je nutné zmínit především známý překladač <i>Aztec C</i> portovaný na velké
množství různých typů mikropočítačů, zapomenout nesmíme ani na <i>Deep Blue
C</i> pro počítače Atari (zde se autoři museli vyrovnat s&nbsp;faktem, že
znaková sada neobsahovala složené závorky, tento jazyk měl ovšem i mnoho
dalších omezení). A taktéž se jednalo o jazyky, které vznikly pouze pro jedinou
platformu a jinam se nerozšířily. Ve světě osmibitových Atari je takovým
jazykem <i>Action!</i>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Atari Assembler Editor</h2>

<p>Jedním z&nbsp;nejstarších vývojových nástrojů pro osmibitové mikropočítače
Atari je <i>Atari Assembler Editor</i>, jehož vznik se datuje do let 1979 až
1980. Tento nástroj byl používán i pro vývoj samotného operačního systému
počítačů Atari. Jak však tento nástroj vůbec vznikl, když ještě vlastně
počítače Atari nebyly dokončené? První (zjednodušené) verze byly ručně děrovány
na děrnou pásku, která byla použita pro naprogramování čipu EPROM. Ten byl
vložen do prototypu Atari a následně otestován. Jednalo se tak o jednu
z&nbsp;forem <i>bootstrapingu</i>, kterým jsme ze zabývali v&nbsp;článku <a
href="https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/">Můžeme
věřit překladačům? Projekty řešící schéma „důvěřivé důvěry“</a>. Výsledná
podoba Atari Assembler Editoru byla dodávána na standardní cartridge o kapacitě
osmi kilobajtů (ovšem ve skutečnosti se do značné míry využívaly subrutiny
z&nbsp;operačního systému a používané i Atari Basicem).</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-6.png" class="image-445917" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 8: Úvodní obrazovka Atari Assembler Editoru je pojata přísně
minimalisticky. Pouze se na ní oznamuje aktuálně vybraný režim, zde konkrétně
režim editace.</i></p>

<p><i>Atari Assembler Editor</i> se skládal ze tří částí: editoru, assembleru a
debuggeru (což však byl ve skutečnosti pouze <i>monitor</i>). Všechny tři části
byly dostupné z&nbsp;cartridge a bylo možné se mezi nimi přepínat. Zdrojový kód
zapisovaný v&nbsp;editoru byl překládán dvouprůchodovým překladačem a mohl být
v&nbsp;operační paměti uložen souběžně se zdrojovým kódem, což ovšem znamenalo
omezení maximálního objemu zdrojového kódu. Zajímavé a typické pro interaktivní
assemblery je, že řádky zdrojového kódu byly číslovány, podobně jako
v&nbsp;BASICu. K&nbsp;dispozici však byly i poměrně pokročilé operace pro
vyhledání návěští atd.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-7.png" class="image-445918" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 9: Přepnutí do režimu debuggeru a výpis obsahu prvních několika
bajtů s&nbsp;interpretrem jazyka Basic.</i></p>

<p>Debugger (spíše monitor) umožňoval zobrazení obsahu operační paměti,
zobrazení obsahu registrů mikroprocesoru, modifikaci paměti, zobrazení
disassemblované části paměti, krokování programu atd. &ndash; ovšem ne tak
kvalitně, jako tomu bylo u dále popsaného assembleru <i>MAC/65</i>.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-8.png" class="image-445919" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 10: Disassembling neboli zobrazení symbolických instrukcí
získaných z&nbsp;obsahu strojového kódu.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. MAC/65</h2>

<p>Další programátorský nástroj, s&nbsp;nímž se dnes alespoň ve stručnosti
seznámíme, se jmenuje <i>MAC/65</i>. Jedná se o assembler a současně i o
debugger, jehož ovládání je odvozeno od výše zmíněného <a href="#k03">Atari
Assembler Editoru</a>; ve skutečnosti je však <i>MAC/65</i> prakticky po všech
stránkách lepší (až na poněkud vyšší cenu). Za vývojem <i>MAC/65</i> stála
společnost <i>Optimized Systems Software (OSS)</i>, s&nbsp;níž se setkáme ještě
jednou v&nbsp;souvislosti s&nbsp;programovacím jazykem <i>Action!</i> (ovšem
OSS vytvořila i překladače jazyků C a Pascalu). <i>MAC/65</i> byl dodáván na
specializované cartridgi s&nbsp;kapacitou 16kB, což je dvojnásobná kapacita,
než jakou počítače Atari podporují (konektor měl pouze třináct adresních pinů).
Z&nbsp;tohoto důvodu bylo oněch 16kB rozděleno do dvojice paměťových bank,
z&nbsp;nichž každá měla kapacitu osmi kilobajtů a mezi kterými se provádělo
automatické přepínání (taková cartridge se někdy nazývala
&bdquo;supercartridge&ldquo; a existovalo jich více typů, které se lišily
způsobem přepínání paměťových bank).</p>

<img src="https://i.iinfo.cz/images/488/mac65-1.png" class="image-446023" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 11: Úvodní obrazovka MAC/65 verze 1.02.</i></p>

<p>Předností assembleru MAC/65 byl mnohem rychlejší překlad v&nbsp;porovnání
s&nbsp;Atari Assembler Editorem. Taktéž byla k&nbsp;dispozici lepší forma
debuggeru dostupná pod příkazem <strong>DDT</strong>. Některé základní
vlastnosti MAC/65 si ukážeme na sérii screenshotů, v&nbsp;němž vytvoříme velmi
jednoduchou programovou smyčku.</p>

<img src="https://i.iinfo.cz/images/488/mac65-2.png" class="image-446024" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 12: V&nbsp;režimu <strong>EDIT</strong> se zapisují jednotlivé
deklarace i instrukce procesoru MOS 6502. Řádky s&nbsp;deklaracemi a
instrukcemi jsou číslovány, takže přidání resp.&nbsp;smazání řádku je snadné.
Taktéž je možné si vyžádat automatické číslování (což například Atari BASIC
neumí). K&nbsp;dispozici jsou i složitější příkazy &ndash; obecně je možné
říci, že programátorský editor v&nbsp;MAC/65 je propracovanější, než
v&nbsp;případě BASICů.</i></p>

<img src="https://i.iinfo.cz/images/488/mac65-3.png" class="image-446025" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 13: Po žádosti o překlad se zobrazí (pokud to ovšem není zakázáno
příslušnou deklarací) zapsaný program i s&nbsp;ukázkou strojového kódu.
V&nbsp;prvním sloupci jsou adresy, v&nbsp;dalším sloupci pak vlastní strojový
kód (operační kódy instrukcí).</i></p>

<img src="https://i.iinfo.cz/images/488/mac65-4.png" class="image-446026" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 14: Příkazem <strong>DDT</strong> se spustí debugger a současně i
monitor. Můžeme zde vidět, že se zobrazuje jak obsah paměti (s&nbsp;instrukcemi
strojového kódu), tak i registry mikroprocesoru, obsah příznakového registru a
nastavené breakpointy.</i></p>

<img src="https://i.iinfo.cz/images/488/mac65-5.png" class="image-446027" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 15: Do vstupního pole <strong>ENTER COMMAND</strong> se zapisují
příkazy debuggeru.</i></p>

<img src="https://i.iinfo.cz/images/488/mac65-6.png" class="image-446028" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 16: Po opuštění debuggeru příkazem <strong>Q</strong> je možné
pokračovat ve vývoji, například si nechat vypsat uživatelem zapsaný kód
příkazem <strong>PRINT</strong>, zde bez čísel řádků.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Atari BASIC</h2>

<p>Popis vývojových nástrojů a programovacích jazyků pro osmibitové
mikropočítače Atari by samozřejmě nebyl úplný, pokud by nebyl zmíněn vyšší
programovací jazyk, jehož více či méně kvalitní dialekty existovaly prakticky
pro všechny typy domácích (ale i profesionálních) osmibitových počítačů. Jedná
se samozřejmě o jazyk <i>BASIC</i> (<i>Beginner's All-purpose Symbolic
Instruction Code</i>), jehož syntaxe a především sémantika pozitivně ale i
negativně ovlivnily celou jednu generaci programátorů (včetně autora tohoto
článku :-). Ovšem tento programovací jazyk je z&nbsp;historického hlediska
zajímavý i proto, že se v&nbsp;souvislosti s&nbsp;jeho vývojem poprvé objevují
jména Bill Gates a Paul Allen spolu s&nbsp;jejich společností původně nazývanou
<i>Micro-Soft</i>.</p>

<img src="https://i.iinfo.cz/images/87/basic1-3.png" class="image-446034" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 17: Programovací jazyk Atari BASIC obsahoval příkazy, pomocí
nichž bylo možné nastavovat různé grafické režimy, vykreslovat body (pixely) či
úsečky popř.&nbsp;měnit barvovou paletu. Na tomto obrázku je zobrazen grafický
režim číslo 15, v&nbsp;němž se zobrazuje čtyřbarevná bitmapa o rozlišení
160&times;160 pixelů, pod níž jsou umístěny čtyři textové řádky, které může
interpret jazyka BASIC využít stejným způsobem, jako standardní textový režim
(číslo 0) &ndash; tedy pro svůj interaktivní editor.</i></p>

<p>Osmibitové mikropočítače Atari byly dodávány s&nbsp;24&nbsp;kB paměti ROM,
přičemž 16&nbsp;kB obsadil samotný operační systém počítače (včetně ovladačů
základních periferních zařízení) a zbylých 8&nbsp;kB bylo vyhrazeno pro
interpret programovacího jazyka BASIC. Inženýři ze společnosti <i>Atari</i>
původně plánovali využít, podobně jako například firma <i>Apple</i> pro její
modely <i>Apple ][</i>, programovací jazyk BASIC dodaný firmou
<i>Micro-Soft</i>, ovšem tento interpret se nevešel do zbylých 8 kB paměti ROM
(někteří lidé poněkud zlomyslně poznamenávají, že <i>Micro-Soft</i> měl již
tehdy problém s&nbsp;hardwarovou náročností svých aplikací, což se projevilo
právě při portaci interpretru BASICu na procesor <i>MOS 6502</i>, při jehož
programování je nutná poměrně podrobná znalost jeho adresových režimů).</p>

<img src="https://i.iinfo.cz/images/87/basic1-4.png" class="image-446035" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 18: Ukázka použití grafického režimu číslo 8, v&nbsp;němž se
pracovalo s&nbsp;monochromatickou bitmapou o rozlišení 320&times;160 pixelů a
obligátním čtyřřádkovým textovým polem.</i></p>

<p>Vzhledem k&nbsp;tomu, že rozšíření kapacity paměti ROM by bylo problematické
a samozřejmě i poměrně drahé (každý ušetřený dolar se v&nbsp;tomto případě
násobil počtem prodaných počítačů) se nakonec firma <i>Atari</i> rozhodla, že
bude financovat vývoj vlastního interpretru programovacího jazyka BASIC,
přičemž na nový jazyk měla dva základní požadavky &ndash; interpret se musí
vejít do 8 kB ROM a jazyk by měl obsahovat příkazy, které by alespoň částečně
dokázaly využít grafické a zvukové schopnosti počítačů <i>Atari</i>, což je
důležité jak z&nbsp;praktického, tak i obchodního hlediska. <i>Atari BASIC</i>,
jak se nově vzniklý programovací jazyk jmenoval, se skutečně podařilo uložit do
pouhých osmi kilobajtů paměti ROM. Jednalo se sice o relativně pomalý
interpret, ovšem jeho vlastnosti byly poměrně zajímavé. Tento dialekt BASICu
totiž obsahoval celou řadu rutin umožňujících práci s&nbsp;rozličnými
grafickými režimy čipů <i>ANTIC</i> a <i>GTIA</i>; například se jednalo o
příkazy <strong>COLOR</strong>, <strong>SETCOLOR</strong>,
<strong>PLOT</strong>, <strong>DRAWTO</strong>, <strong>POSITION</strong> či
<strong>LOCATE</strong>.</p>

<img src="https://i.iinfo.cz/images/87/basic1-5.png" class="image-446036" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 19: Jednoduchý program pro výpočet největšího společného dělitele
(NSD, GCD) celých čísel z&nbsp;řady 2..10. V&nbsp;tomto programu jsou
mj.&nbsp;využity i některé formátovací možnosti příkazu PRINT, například
přechod na další tabulační zarážku (formátovací znak čárka) či zákaz přechodu
na další řádek (formátovací znak středník).</i></p>

<p>Dále <i>Atari BASIC</i> obsahoval příkaz <strong>SOUND</strong> pro základní
ovládání zvukového čipu <i>POKEY</i> (<i>POKEY</i> byl při práci
v&nbsp;<i>Atari BASICu</i> nastaven do režimu čtyřkanálového zvukového
generátoru, kde byl každému kanálu přiřazen jeden osmibitový čítač). Tento
programovací jazyk dále umožňoval práci se skalárními proměnnými,
jednorozměrnými poli (vektory) i dvourozměrnými poli (maticemi), v&nbsp;nichž
mohla být uložena čísla s&nbsp;pohyblivou řádovou čárkou. Každé číslo bylo
reprezentováno šesticí bajtů, jejich rozsah i přesnost tedy ležely zhruba
v&nbsp;polovině mezi typy <i>single</i> a <i>double</i> známými z&nbsp;dnešních
programovacích jazyků a matematických koprocesorů. Taktéž bylo možné pracovat
s&nbsp;jednorozměrnými řetězci (pole řetězců však nebyla přímo v&nbsp;jazyku
podporována, většinou se nahrazovala jediným řetězcem a vektorem indexů nebo
oddělovacími znaky).</p>

<img src="https://i.iinfo.cz/images/87/basic1-1.png" class="image-446032" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 20: Hra naprogramovaná v&nbsp;Atari BASICu s&nbsp;využitím
strojových subrutin (Dungeons of Xotha).</i></p>

<p>Jednou z&nbsp;nevýhod <i>Atari BASICu</i> byla jeho pomalá interpretace a
taktéž to, že dokázal pracovat pouze s&nbsp;šestibajtovými reálnými čísly,
nikoli například s&nbsp;dvoubajtovými čísly celými, jak tomu bylo
v&nbsp;některých jiných dialektech BASICu. Právě kvůli pomalým rutinám pro
práci s&nbsp;reálnými čísly (resp.&nbsp;přesněji řečeno s&nbsp;čísly
s&nbsp;plovoucí řádovou čárkou) a pomalém vyhledávání cílů skoků se jednalo o
jeden z&nbsp;pomalejších interpretrů, zejména při porovnání
s&nbsp;konkurenčními platformami.</p>

<img src="https://i.iinfo.cz/images/87/basic1-2.png" class="image-446033" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 21: Další screenshot ze hry Dungeons of Xotha.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vybrané vlastnosti Atari BASICu</h2>

<p>V&nbsp;Atari BASICu, přesněji řečeno v&nbsp;subrutinách uložených
v&nbsp;ROM, které se staraly o výpočty nad reálnými čísly, se používal formát
odlišný od prakticky všech formátů používaných na jiných platformách. Stále se
sice jednalo o hodnoty s&nbsp;plovoucí řádovou čárkou, ovšem báze nebyla rovna
dvěma (většina strojů) ani šestnácti (IBM/360), ale stu! Navíc nebyla mantisa
uložená binárně, ale používal se kód BCD, což konkrétně znamená, že v&nbsp;pěti
bajtech bylo uloženo přesně deset číslic (procesor 6502 dokázal s&nbsp;BCD
pracovat nativně). To na jednu stranu není úplně špatné řešení, protože ho
najdeme například na mnoha kalkulačkách. Zjednodušují se převody řetězců na
čísla a naopak, na druhou stranu jsou však veškeré výpočty značně pomalejší a
přesnost ani rozsah hodnot není tak vysoký, jako při použití binárního kódu. I
z&nbsp;tohoto důvodu další dialekty BASICu zaváděly práci s&nbsp;celými
čísly.</p>

<p>Příklad výpočtu založeného na práci s&nbsp;reálnými čísly počítačů Atari
ukazuje, že i proměnné používané v&nbsp;programových smyčkách
<strong>FOR-NEXT</strong> byly reprezentovány jako reálné číslo:</p>

<pre>
1 REM VYPOCET KONSTANTY PI
2 REM UPRAVA PRO ATARI BASIC
3 REM 
10 N=1
20 FOR I=1 TO 10
25 GOSUB 1000:REM VYPOCET PI
30 PRINT I,N,PI
35 N=N*2
40 NEXT I
999 END 
1000 REM 
1001 REM SUBRUTINA PRO VYPOCET PI
1002 REM 
1010 PI=4
1020 FOR J=3 TO N+2 STEP 2
1030 PI=PI*(J-1)/J*(J+1)/J
1040 NEXT J
1050 RETURN 
</pre>

<p>Zajímavým způsobem je v&nbsp;Atari BASICu realizováno uložení řetězců, což
je vedle jednorozměrných a dvourozměrných polí jediná datová struktura (na
rozdíl od jediného primitivního typu &ndash; čísel s&nbsp;plovoucí řádovou
tečkou). V&nbsp;tomto dialektu BASICu je totiž nutné velikost řetězce předem
určit příkazem <strong>DIM</strong>, který současně i provede alokaci bloku
v&nbsp;operační paměti pro řetězec. Ve skutečnosti jsou však v&nbsp;operační
paměti uloženy dvě struktury, které řetězec plně popisují &ndash; jedná se
především o sekvenci znaků v&nbsp;kódování ATASCII (odvozeno od ASCII doplněním
spodních 32 znaků a změnou několika běžných znaků) a taktéž o strukturu o délce
osmi bajtů, která obsahuje typ proměnné (první bajt), index jména proměnné
s&nbsp;řetězcem (druhý bajt), adresu začátku řetězce (přesněji řečeno offset),
alokovanou délku řetězce (maximálně 32767 znaků) a aktuální délku řetězce (opět
maximálně 32767 znaků). To znamená, že i když je například provedena alokace
pro řetězec o délce 1000 znaků, může v&nbsp;něm být reálně uloženo jen deset
znaků.</p>

<img src="https://i.iinfo.cz/images/644/retezce-4.png" class="image-303820" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 22: Po inicializaci interpretru Atari Basicu je k&nbsp;dispozici
37902 volných bajtů. Po alokaci řetězce o délce deseti znaků přijdeme celkem o
20 bajtů &ndash; dva bajty zabere název proměnné, osm bajtů struktura popsaná
v&nbsp;předchozím odstavci (typ+index proměnné, adresa řetězce, jeho maximální
délka a aktuální délka) a zbylých 10 bajtů je vyhrazeno pro vlastní
řetězec.</i></p>

<p>Veškeré operace s&nbsp;řetězci jsou zcela bezpečné, protože nikdy nedojde
k&nbsp;překročení jeho délky (přepisu jiné paměti); při spojování řetězců dojde
k&nbsp;ukončení na předem stanoveném limitu. Mimochodem: poměrně častým trikem
bylo uložení strojových instrukcí do řetězce, zjištění adresy řetězce funkcí
<strong>ADR</strong> a &bdquo;spuštění řetězce&ldquo; další funkcí
<strong>USR</strong>, které se předala adresa řetězce (resp.&nbsp;jeho prvního
znaku).</p>

<img src="https://i.iinfo.cz/images/644/retezce-5.png" class="image-303821" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 23: Pokud alokujeme další řetězec o maximální kapacitě 100 znaků,
přijdeme o 110 bajtů. Opět platí, že &bdquo;chybějících&ldquo; deset bajtů bylo
použito pro jméno proměnné, její typ, adresu+délku+maximální délku
řetězce.</i></p>

<p>Vzhledem k&nbsp;tomu, že Atari BASIC neumožňuje ukládat řetězce do polí,
bylo možné operátor indexování () &bdquo;přetížit&ldquo; takovým způsobem, že
je možné přistupovat jak k&nbsp;jednotlivým znakům řetězce, tak i
k&nbsp;podřetězci (jedná se tedy o operaci, kterou dnes nazýváme termínem
<i>slicing</i>). Tento operátor je možné použít i na levé straně přiřazovacího
příkazu pro změnu vybrané části řetězce, což je velmi užitečný přístup
k&nbsp;řetězcům:</p>

<pre>
10 DIM S$(15),T$(15),Q$(15)      vypíše se
20 S$="ATASIC":PRINT S$          ATASIC
30 Q$=S$(3,5):PRINT Q$           ASI
40 T$="RI_BA":PRINT T$           RI_BA
50 S$(7,13)="T$:PRINT S$         ATASICRI_BA
60 S$=S$(1,6):PRINT S$           ATASIC
70 T$(6,9)=S$(4,6):PRINT T$      RI_BASIC
80 S$(4)=T$:PRINT S$             ATARI_BASIC
90 Q$=S$(1):PRINT Q$             ATARI_BASIC
100 Q$=S$(1,1):PRINT Q$          A
</pre>

<img src="https://i.iinfo.cz/images/644/retezce-6.png" class="image-303822" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 24: Z&nbsp;výpisu adres řetězců je zřejmé, že jsou v&nbsp;paměti
uloženy těsně za sebou (první řetězec má délku 10 znaků) a že se nepočítá
s&nbsp;žádným ukončovacím znakem.</i></p>

<img src="https://i.iinfo.cz/images/644/retezce-7.png" class="image-303823" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 25: Do řetězce A$ o kapacitě deseti znaků můžeme uložit kratší
text a zjistit jeho délku. Při snaze o uložení delšího textu nedojde
k&nbsp;žádné chybě a už vůbec ne k&nbsp;přepisu cizí paměti &ndash; řetězec se
pouze na příslušném místě odřízne.</i></p>

<img src="https://i.iinfo.cz/images/644/retezce-8.png" class="image-303824" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 26: Pokus o alokaci řetězce, který se již nevejde do volné
operační paměti samozřejmě skončí s&nbsp;chybou a proměnná nebude
vytvořena.</i></p>

<p>Podívejme se nyní na způsob uložení programového kódu v&nbsp;operační
paměti. Ihned po zápisu každého řádku se provádí takzvaná <i>tokenizace</i>,
která nahradí jednotlivé konstrukce jazyka osmibitovými kódy. Příkladem může
být tokenizace tohoto programového řádku:</p>

<pre>
10 LET X=1 : PRINT X
</pre>

<p>V&nbsp;operační paměti tento kód není uložen (pouze v&nbsp;bufferu textového
editoru, odtud je však ihned poté přemazán). Namísto toho se uloží sekvence
bajtů s&nbsp;následujícím významem:</p>

<table>
<tr><th>Sekvence bajtů</th><th>Stručný popis</th></tr>
<tr><td>A0 00</td>číslo programového řádku (10)<td></td></tr>
<tr><td>13</td><td>délka celého tokenizovaného řádku (19 bajtů)</td></tr>
<tr><td>0F</td><td>offset konce prvního příkazu</td></tr>
<tr><td>06</td><td>token příkazu <strong>LET</strong></td></tr>
<tr><td>80</td><td>index proměnné <strong>X</strong></td></tr>
<tr><td>2D</td><td>token operátoru <strong>=</strong></td></tr>
<tr><td>0E</td><td>následuje numerická konstanta</td></tr>
<tr><td>40 01 00 00 00 00</td><td>takto vypadá zakódovaná hodnota 1 (na začátku je exponent)</td></tr>
<tr><td>14</td><td>konec (prvního) příkazu</td></tr>
<tr><td>13</td><td>offset konce druhého příkazu</td></tr>
<tr><td>20</td><td>token příkazu <strong>PRINT</strong></td></tr>
<tr><td>80</td><td>index proměnné <strong>X</strong></td></tr>
<tr><td>16</td><td>značka <strong>EOL</strong> pro konec řádku</td></tr>
</table>

<p>Před začátkem tokenizovaného kódu se ještě ukládá několik tabulek, především
tabulka s&nbsp;proměnnými, tabulka s&nbsp;vektory (adresami) několika dalších
paměťových struktur atd. Například následující zdrojový kód:</p>

<pre>
10 PRINT "X=";
20 INPUT X
30 PRINT "Y=";
40 INPUT Y
50 IF X=Y THEN PRINT "GCD: ";X:END 
60 IF X&gt;Y THEN X=X-Y:GOTO 50
70 IF X&lt;Y THEN Y=Y-X:GOTO 50
</pre>

<p>Se převede do tokenizované a spustitelné (resp.&nbsp;interpretovatelné)
podoby takto:</p>

<pre>
00000000: 00 00 00 01 02 01 03 01 13 01 85 01 96 01 d8 d9  ................
00000010: 00 00 00 40 08 00 00 00 00 00 01 40 08 00 00 00  ...@.......@....
00000020: 00 0a 00 0b 0b 20 0f 02 58 3d 15 16 14 00 07 07  ..... ..X=......
00000030: 02 80 16 1e 00 0b 0b 20 0f 02 59 3d 15 16 28 00  ....... ..Y=..(.
00000040: 07 07 02 81 16 32 00 18 09 07 80 22 81 1b 15 20  .....2....."... 
00000050: 0f 05 47 43 44 3a 20 15 80 14 18 15 16 3c 00 1b  ..GCD: ......&lt;..
00000060: 09 07 80 21 81 1b 11 36 80 2d 80 26 81 14 1b 0a  ...!...6.-.&amp;....
00000070: 0e 40 50 00 00 00 00 16 46 00 1b 09 07 80 20 81  .@P.....F..... .
00000080: 1b 11 36 81 2d 81 26 80 14 1b 0a 0e 40 50 00 00  ..6.-.&amp;.....@P..
00000090: 00 00 16 00 80 11 11 19 0f 09 48 3a 47 43 44 2e  ..........H:GCD.
000000a0: 42 49 4e 16                                      BIN.
</pre>

<p>Velikost souboru s&nbsp;čitelným zdrojovým programem v&nbsp;BASICu je rovna
146 bajtům, zatímco soubor s&nbsp;tokenizovanou formou má v&nbsp;tomto případě
délku 164 bajtů.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;některých případech je však
tokenizovaná podoba kratší. Ovšem předností tokenizace není v&nbsp;první řadě
úspora operační paměti, ale spíše urychlení interpretace a taktéž urychlení
nahrávání programů z&nbsp;kazety nebo diskety (ostatně i z&nbsp;tohoto důvodu
se při načítání zdrojových kódů příkazem <strong>ENTER</strong> používají delší
odmlky mezi bloky, než při nahrávání tokenizovaného kódu příkazem
<strong>CLOAD</strong>).</div></p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-25.png" class="image-445936" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 27: Jednou z&nbsp;her naprogramovaných v&nbsp;Atari BASICu je simulátor jaderné elektrárny SCRAM. Viz též <a href="https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-simulace-a-strategicke-hry-naprogramovane-chrisem-crawfordem/#k03">Historie vývoje počítačových her: simulace a strategické hry naprogramované Chrisem Crawfordem</a></i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Slavný Turbo-BASIC XL</h2>

<p>Rychlost interpretru programovacího jazyka <i>Atari BASIC</i> záhy přestala
mnoha programátorům a samozřejmě i uživatelům dostačovat. Někteří
z&nbsp;vývojářů se namísto BASICu naučili využívat assembler mikroprocesoru
<i>MOS 6502</i>, ovšem jiní by uvítali &bdquo;pouze&ldquo; rychlejší variantu
BASICu, ideálně ještě doplněnou o některé chybějící příkazy. Kromě poměrně
neúspěšného <i>Microsoft BASICu</i> se záhy rozšířil překladač BASICu do
strojového kódu (který byl ovšem v&nbsp;praxi použitelný především pro překlad
již odladěných programů, nikoli pro samotný vývoj) a především <i>Turbo
BASIC</i>, jehož autorem je známý Frank Ostrowski (tento programátor později
vytvořil <i>GFA BASIC</i> pro osobní počítače <i>Atari ST</i>). <i>Turbo
BASIC</i> téměř splňoval všechny sny BASICových programátorů &ndash; byl
rychlejší než původní <i>Atari BASIC</i>, byl s&nbsp;<i>Atari BASICem</i> plně
kompatibilní, díky programovému &bdquo;odklápění&ldquo; ROM nabízel vývojářům
prakticky stejné množství volné operační paměti (což působilo téměř magicky) a
navíc <i>Turbo BASIC</i> obsahoval poměrně velké množství nových příkazů, ať
již určených pro strukturované programování (nové typy programových smyček),
tak i příkazy zjednodušující programátorovu každodenní činnost.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-26.png" class="image-445937" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 28: Úvodní obrazovka Turbo-BASICu XL.</i></p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti pro počítače Atari
vznikla celá řada dalších dialektů BASICu, například BASIC A+ (od stejných
autorů, jako původní Atari BASIC), BASIC XL (velmi úspěšný), BASIC XE (málo
rozšířený), Advanced BASIC, Microsoft BASIC a moderní dialekty Altirra BASIC a
Fast BASIC.</div></p>

<img src="https://i.iinfo.cz/images/556/tb2-1.png" class="image-446037" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 29: Program pro vykreslení Mandelbrotovy množiny
naprogramovaný v&nbsp;Atari BASICu, ovšem beze změn použitelný i v&nbsp;Turbo
BASICu.</i></p>

<p>Novými &bdquo;grafickými&ldquo; příkazy byly například
<strong>CIRCLE</strong> či <strong>TEXT</strong> (vykreslení textu do bitmapy),
k&nbsp;příkazu <strong>SOUND</strong> přibyl příkaz <strong>DSOUND</strong>
(práce se šestnáctibitovými čítači čipu <i>POKEY</i> namísto čítačů
osmibitových), dvojice příkazů <strong>POKE</strong> a <strong>PEEK</strong>
pracujících s&nbsp;hodnotami uloženými v&nbsp;jedné (osmibitové) paměťové buňce
byla doplněna o šestnáctibitové varianty <strong>DPOKE</strong> a
<strong>DPEEK</strong>, což programátorům ušetřilo opakované použití výrazů
typu <i>PEEK(88)+256*PEEK(89)</i> atd. Originální <i>Turbo BASIC</i> byl různým
způsobem upravován a rozšiřován. Mezi tuzemské úpravy patří především
zabudování ovladače Turba 2000, takže se práce s&nbsp;kazetovým magnetofonem
v&nbsp;mnohém vylepšila (<strong>LOAD "T:POKUS.BAS"</strong> namísto
primitivního <strong>CLOAD</strong> atd.) a taktéž zabudování ovladače tiskárny
<i>BT-100</i> &ndash; kromě nové funkce příkazů <strong>LLIST</strong>,
<strong>LPRINT</strong> atd. bylo dokonce možné vyvolat hardcopy obrazovky,
tj.&nbsp;tisk aktuálního obsahu obrazovky a to i tehdy, pokud byl použit nějaký
nestandardní grafický režim.</p>

<img src="https://i.iinfo.cz/images/556/tb2-2.png" class="image-446038" alt="&#160;" width="640" height="478" />
<p><i>Obrázek 30: Výsledek běhu programu, jehož listing je zobrazený na
patnáctém obrázku. Doba výpočtu Mandelbrotovy množiny dosahuje několika hodin
v&nbsp;případě použití Atari BASICu a cca jednu hodinu při použití Turbo
BASICu.</i></p>

<p>Turbo BASIC převzal z&nbsp;Atari BASICu i mnohé nedokonalosti. Jedna
z&nbsp;nich se týká automatického rozpoznávání příkazů &ndash; klasické BASICy
totiž vždy musely za číslem řádku používat příkaz, což například znamenalo, že
přiřazení muselo začínat slovem <strong>LET</strong>. Atari BASIC již
explicitní <strong>LET</strong> nevyžaduje (přidává si totiž vlastní
<strong>LET</strong> s&nbsp;odlišným tokenem), ovšem v&nbsp;případě, že jméno
proměnné začíná stejně jako příkaz, nebude tento koncept pracovat korektně.</p>

<p>Podívejme se na následující příklad, kde se snažíme přiřadit hodnoty do dvou
proměnných nazvaných <strong>ED</strong> a <strong>PRINTED</strong>:</p>

<pre>
1 REM JMENO PROMENNE ZACINAJICI NA PRINT
2 REM UPRAVA PRO ATARI BASIC
3 REM 
10 ED=42
20 PRINTED=0
30 PRINTED=42
</pre>

<p>Atari BASIC ovšem tento program pochopí jinak &ndash; jako snahu o výpis,
zda je hodnota proměnné <strong>ED</strong> rovna nule či 42:</p>

<pre>
1 REM JMENO PROMENNE ZACINAJICI NA PRINT
2 REM UPRAVA PRO ATARI BASIC
3 REM 
10 ED=42
20 PRINT ED=0
30 PRINT ED=42
</pre>

<p>V&nbsp;Turbo BASICu je problém ještě větší, protože tento jazyk obsahuje
více klíčových slov. Další příklad je tedy zcela korektní v&nbsp;Atari BASICu,
ovšem nikoli v&nbsp;Turbo BASICu, protože <strong>DO</strong> je v&nbsp;tomto
jazyce klíčové slovo:</p>

<pre>
1 REM JMENO PROMENNE ZACINAJICI NA DO
2 REM UPRAVA PRO TURBO BASIC
3 REM 
10 DONE=1
20 DONE=0
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o jednu z&nbsp;mála
nekompatibilit mezi oběma popisovanými programovacími jazyky.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Strukturované programování v&nbsp;Turbo-BASICu</h2>

<p>Turbo-BASIC obsahuje některé konstrukce, které se přibližují klasickému
strukturovanému programování. Konkrétně to znamená to, že jsou podporovány
procedury (pojmenované podprogramy), strukturovaná konstrukce
<strong>IF-ELSE-ENDIF</strong> a programové smyčky <strong>FOR-NEXT</strong>,
<strong>DO-LOOP</strong>, <strong>WHILE-WEND</strong> a
<strong>REPEAT-UNTIL</strong>. Interpret Turbo BASICu dokáže tyto konstrukce
<i>automaticky</i> vypsat s&nbsp;odsazením, které v&nbsp;tokenizovaném kódu
nezabírá žádné místo (tudíž zde neexistují nekonečné diskuse o tom, jak má
odsazení vypadat, o kolik znaků se odsazuje a zda používat TAB nebo mezery).
Použití těchto konstrukcí si ukážeme na několika demonstračních příkladech.</p>

<p>Výpočet faktoriálu v&nbsp;Atari BASICu, v&nbsp;němž se podprogramy realizují
pomocí <strong>GOSUB</strong> a <strong>RETURN</strong>:</p>

<pre>
1 REM VYPOCET FAKTORIALU
2 REM UPRAVA PRO ATARI BASIC
3 REM
10 FOR N=0 TO 20
11 GOSUB 100
12 PRINT N,FACT
13 NEXT N
99 END 
100 REM VYPOCET FAKTORIALU
101 FACT=1
102 FOR I=N TO 1 STEP -1
103 FACT=FACT*I
104 NEXT I
105 RETURN 
</pre>

<p>Přepis do Turbo BASICu využívajícího pojmenované procedury &ndash; klíčová
slova <strong>PROC</strong> a <strong>ENDPROC</strong>:</p>

<pre>
1 REM VYPOCET FAKTORIALU
2 REM UPRAVA PRO TURBO-BASIC XL
3 REM 
4 ------------------------------
10 FOR N=0 TO 20
11   EXEC FACTORIAL
12   PRINT N,FACT
13 NEXT N
99 END 
100 ------------------------------
101 REM VYPOCET FAKTORIALU
102 PROC FACTORIAL
103   FACT=1
104   FOR I=N TO 1 STEP -1
105     FACT=FACT*I
106   NEXT I
107 ENDPROC 
</pre>

<p>Výpočet největšího společného dělitele s&nbsp;několika příkazy
<strong>GOTO</strong>:</p>

<pre>
1 REM VYPOCET NEJVETSIHO SPOLECNEHO DELITELE
2 REM REALIZACE V ATARI BASICU
3 REM
10 PRINT "X=";
20 INPUT X
30 PRINT "Y=";
40 INPUT Y
50 IF X=Y THEN PRINT "GCD: ";X:END 
60 IF X&gt;Y THEN X=X-Y:GOTO 50
70 IF X&lt;Y THEN Y=Y-X:GOTO 50
</pre>

<p>Realizace s&nbsp;využitím <strong>WHILE-WEND</strong> a strukturovaných
podmínek:</p>

<pre>
1 REM VYPOCET NEJVETSIHO SPOLECNEHO DELITELE
2 REM IMPLEMENTACE PRO TURBO-BASIC XL
3 REM 
4 ------------------------------
10 PRINT "X=";
20 INPUT X
30 PRINT "Y=";
40 INPUT Y
50 WHILE X&lt;&gt;Y
60   IF X&gt;Y
61     X=X-Y
63   ENDIF 
70   IF X&lt;Y
71     Y=Y-X
73   ENDIF 
80 WEND 
90 PRINT "GCD: ";X
91 END 
</pre>

<p>Využití programové smyčky typu <strong>REPEAT-UNTIL</strong>
s&nbsp;podmínkou na konci:</p>

<pre>
1 REM TEST PRESNOSTI VYPOCTU FP
2 REM REALIZACE PRO TURBO-BASIC XL
3 REM 
4 ------------------------------
10 H1=0
11 H2=0
12 N=1
20 REPEAT 
21   H1=H2
22   H2=H1+1/N
23   PRINT N;" ";H1;" ";H2
24   N=N+1
30 UNTIL H1=H2
</pre>

<p>Využití programové smyčky typu <strong>REPEAT-UNTIL</strong>
s&nbsp;podmínkou na konci i klasické smyčky <strong>FOR-NEXT</strong>:</p>

<pre>
1 REM CIRCLE MOIRE
2 REM UPRAVA PRO ATARI BASIC
3 REM GRAFICKY REZIM 9
4 ------------------------------
10 GRAPHICS 9
20 FOR Y=0 TO 191
30   FOR X=0 TO 79
40     C=INT(X*X/10+Y*Y/40)
50     COLOR C MOD 16
60     PLOT X,Y
70   NEXT X
80 NEXT Y
998 REM CEKANI NA STISK TLACITKA JOYSTICKU
999 REPEAT :UNTIL STRIG(0)=0
1000 END 
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Pomůcky při vývoji a ladění programů v&nbsp;Turbo-BASICu</h2>

<p>Při ladění programů v&nbsp;Turbo-BASICu lze využít několik užitečných
příkazů. Především se jedná o příkaz <strong>TRACE</strong>, jenž po spuštění
programu začne vypisovat čísla řádků, které se právě spouští. Dále musíme
zmínit příkaz <strong>DUMP</strong> určený pro výpis všech proměnných,
samozřejmě včetně jejich hodnoty. Výpis lze provést i na vybrané zařízení,
například na tiskárnu, disketovou jednotku, RAMdisk atd. S&nbsp;čísly řádků tak
typickými právě pro klasické BASICy souvisí i příkazy pro jejich manipulaci.
Jedná se o příkaz <strong>DEL</strong> pro smazání vybraných řádků
resp.&nbsp;rozsahu hodnot a dále o příkaz <strong>RENUM</strong> pro
přečíslování určitého bloku. Pro získání informace o poslední chybě (tu lze
odchytit pomocí <strong>TRAP</strong>) slouží pseudoproměnné
<strong>ERR</strong> (číslo chyby) a <strong>ERL</strong> (číslo programového
řádku). A konečně &ndash; při vzniku chyby se nevypíše pouze její číslo (kód),
ale i krátký popisek chyby.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Atari LOGO</h2>

<p>Většina programovacích jazyků byla vytvořena buď pro potřeby praktického
programování nebo pro výuku programování. Programovací jazyk <i>Logo</i>, o
němž se v&nbsp;dnešním článku taktéž v&nbsp;krátkosti zmíníme, je v&nbsp;tomto
smyslu poněkud odlišný jazyk, protože programování zde není cílem ale pouze
nástrojem, který má pomoci při vzdělávání. Logo stojí na základech daných
takzvanou konstruktivní vzdělávací filozofií a je navrženo k&nbsp;podpoře
konstruktivního učení. Konstruktivismus vysvětluje znalosti a dovednosti, jak
jsou vytvořeny žáky v&nbsp;jejich vlastních myslích, prostřednictvím vzájemné
interakce s&nbsp;jinými lidmi a okolím. Tato zajímavá teorie je spojena
především se švýcarským psychologem <i>Jeanem Piagetem</i>, který strávil mnoho
času studováním a zdokumentováním učení malých dětí. S&nbsp;Piagetem
v&nbsp;Ženevě spolupracoval i <i>Seymour Papert</i>, který později stál u
vzniku Loga jakožto poněkud svébytného programovacího jazyka.</p>

<img alt="logo0101" width="324" height="391" src="https://i.iinfo.cz/urs/logo_01_01-118277842201407.gif" class="xy" />
<p><i>Obrázek 31: Pohled na klasické Logo – grafická plocha a příkazový řádek.</i></p>

<p>První testovací implementace programovacího jazyka Logo se jmenovala
&bdquo;ghost&ldquo; a byla vytvořena na slavné MIT společně s&nbsp;firmou BBN
(Bolt, Beranek and Newman Inc.) v&nbsp;programovacím jazyce LISP na počítači
PDP-1. U zárodku této prvotní implementace, která vznikla už v&nbsp;roce 1967,
stál i Seymour Papert, který však jazyk neprogramoval (programátoři, kteří Logo
implementovali, se jmenovali Daniel Bobrow a Wallace Feurzeig), ale pracoval
jako odborný konzultant. Tato implementace Loga se po nezbytných úpravách
postupně rozšířila i mimo MIT, například na univerzitu v&nbsp;Edinburgu. Jméno
Logo se objevuje až později s&nbsp;implementací od Wallace Feurzeiga (opět) a
Paula Wexelblata, ve které se poprvé objevuje známá želva (<i>turtle</i>), a to
dokonce v&nbsp;mechanické podobě a ovládaná radiem (tento robotek se jmenoval
Irving).</p>

<a href="https://i.iinfo.cz/urs/logo_01_02-118277843921494.jpg"><img alt="logo0102" width="450" height="373" src="https://i.iinfo.cz/urs/logo_01_02-preview-118277843921494.jpg" class="xy" /></a>
<p><i>Obrázek 32: Mechanická želva vytvořená z LEGA a ovládaná programem
napsaným v Logu.</i></p>

<p>Větší rozšíření Loga nastalo až s&nbsp;nástupem osmibitových domácích
počítačů. V&nbsp;Evropě jsou známé především značky Sinclair, Atari a
Commodore, ale v&nbsp;USA, kde se Logo začalo těšit prakticky masové oblibě, se
ještě před těmito značkami rozšířily především osmibitové domácí počítače Apple
II (zejména model Apple IIe), které obsahovaly mikroprocesor MOS 6502 (později
MOS 6502C) taktovaný na 1MHz. U Apple II bylo možné v grafickém režimu
s&nbsp;vysokým rozlišením zobrazovat bitmapy o rozměrech 280&times;192 pixelů
ve čtyřech, popř.&nbsp;v&nbsp;šesti barvách. Takové grafické schopnosti již
dostačují k&nbsp;práci želví grafiky, na které je Logo částečně postaveno. Ve
stejně době bylo Logo také portováno na počítače Texas Instruments TI 99/4.</p>

<img alt="logo0106" width="296" height="292" src="https://i.iinfo.cz/urs/logo_01_06-118277852408627.gif" class=" " />
<p><i>Obrázek 33: Schématický květ nakreslený pomocí Loga.</i></p>

<p>Pravděpodobně nejúspěšnější implementace Loga pro počítače Apple II pochází
od firmy LCSI (Logo Computer Systems, Inc.), která v roce 1980 vytvořila Apple
Logo. Tato implementace se stala základem i pro verze určené pro novou generaci
domácích počítačů &ndash; Atari Logo, Commodore Logo (jedna verze Commodore
Loga byla postavena nad Terrapin Logem), atd. O tom, jak bylo Apple Logo
úspěšné, svědčí i to, že některé moderní komerční implementace Loga ve svých
manuálech uvádí převodní tabulku mezi příkazy Apple Loga a jeho moderním
protějškem. V&nbsp;kontextu dnešního článku se pochopitelně zaměříme především
na Atari Logo, jehož některé unikátní vlastnosti jsou popsány <a
href="#k11">v&nbsp;navazující kapitole</a>.</p>

<img alt="logo0110" width="196" height="187" src="https://i.iinfo.cz/urs/logo_01_10-118277860232316.gif" class=" " >
<p><i>Obrázek 34: Vzor vytvořený v Logu za pomoci želví grafiky.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Unikátní vlastnosti Atari Loga</h2>

<p><i>&bdquo;Atari Logo is one of the most intelligently-conceived and
well-executed pieces of software ever published by ATARI."&ldquo;</i></p>

<p>Atari LOGO bylo vyvinuto na základě LCSI Loga, ovšem došlo <a
href="https://archive.org/details/AtariLOGOReferenceManual/page/n1/mode/2up">k&nbsp;několika
úpravám</a>, které umožnily do větší míry využít některá specifika osmibitových
mikropočítačů Atari. Především byly přidány příkazy pro přehrávání melodií.
Konkrétně se jedná o příkaz <strong>TOOT</strong>, jenž dokáže přehrát notu o
zvolené frekvenci, hlasitosti a délce trvání &ndash; to je podstatný rozdíl
oproti příkazu <strong>SOUND</strong> v&nbsp;BASICech. Přidány byly taktéž
příkazy pro čtení hodnot <i>paddle</i> (tedy analogových ovladačů).</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-20.png" class="image-445931" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 35: Úvodní obrazovka Atari LOGA.</i></p>

<p>Největší změny se týkají samotné želvy. Kromě jedné želvy (standardní Logo)
je totiž možné použít až čtyři želvy (každou s&nbsp;jinou barvou), které lze
ovládat buď samostatně nebo je možné stejné příkazy nechat vykonat více
želvami. Samotné želvy jsou realizovány sprity, což tvůrcům Atari LOGA umožnilo
i další triky &ndash; například existují příkazy pro změnu tvaru želvy, příkazy
pro zjištění, zda se želva dotkla nějakého nakresleného obrazce
(popř.&nbsp;jakou barvu tento obrazec měl) a zjistit lze i kolize dvou želv.
Samotný svět, v&nbsp;nichž se želvy pohybují, může být nekonečný, nebo se jeho
protilehlé okraje mohou dotýkat tak, jak je to implementováno například ve hře
<i>Asteroids</i>.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-21.png" class="image-445932" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 36: Zobrazení kreslicí plochy a želvy příkazem <strong>HOME</strong>.</i></p>

<p>Implicitní zobrazení grafické plochy, po které se želvy pohybují, je
realizováno grafickým režimem 7, tj.&nbsp;lze kreslit třemi barvami a používá
se rozlišení 160&times;192 pixelů.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-22.png" class="image-445933" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 37: Kreslení s&nbsp;použitím dvojice želv.</i></p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-23.png" class="image-445934" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 38: Kreslení pomocí čtyř želv.</i></p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-24.png" class="image-445935" alt="&#160;" width="640" height="480" />
<p><i>Obrázek 39: Všechny čtyři želvy vykonávají stejné příkazy.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Interlisp/65</h2>

<p></p>

<p>Jeden z&nbsp;populárních dialektů programovacího jazyka Lisp se jmenoval
<i>MacLisp</i>. Ten byl používán ve slavných AI Lab na MITu od konce šedesátých
let minulého století až do začátku osmdesátých let, byl po dlouhou dobu
považován za neoficiální standard Lispu, tedy za jakousi &bdquo;referenční
implementaci&ldquo; (což je dnes zcela běžné &ndash; ostatně mnoho moderních
programovacích jazyků staví právě na referenční implementaci a nikoli na
rigidní specifikaci). MacLisp byl rozšířen na poměrně mnoho platforem,
například na PDP-6 a PDP-10, Honeywell 6180, běžel na Multicsu (ten ukázal
slepou uličku, kterou se NEvydal pozdější UNIX) atd. Samotný MacLisp se
pochopitelně postupně vyvíjel a zajímavé je, že byl použit pro vývoj a
implementaci dalších variant programovacích jazyků, mezi jinými i jazyka
Scheme. Dále není bez zajímavosti, že první varianta Emacsu založená na Lispu,
používala právě MacLisp pro systém Multics (v&nbsp;IT je prostě vše
propojeno).</p>

<p>Interlisp, jakožto ideový pokračovatel MacLispu, znamenal v&nbsp;době svého
vzniku poměrně zásadní změnu v&nbsp;tom, jak byl jazyk a celé jeho interaktivní
prostředí navržen. Původní Lispy totiž do značné míry vypadaly tak, jako
například dnešní GNU Guile &ndash; všechny formy musely být zapsány jako
s-výrazy, přičemž se netolerovaly žádné chyby, závorky musely být balancovány
atd. Interlisp byl dosti odlišný. Zejména byly rozšířeny možnosti nástrojů
dodávaných společně s&nbsp;tímto jazykem &ndash; přidán byl například v&nbsp;té
době přelomový korektor překlepů, přidány byly balíčky pro práci se soubory,
balíček CLISP umožňující zápis algebraických výrazů, programátorský editor pro
strukturovaný kód atd. Za většinou nových myšlenek implementovaných
v&nbsp;Interlispu stál <i>Warren Teitelman</i>, který napsal svoji disertaci na
téma symbiózy mezi člověkem a počítačem. A povšimněte si, že všechny novinky
implementované v&nbsp;Interlispu a zmíněné výše se soustředí právě na rozhraní
mezi počítačem a uživatelem (resp.&nbsp;programátorem) a nikoli například na
nové jazykové konstrukce.</p>

<p>Příkladem může být korektor překlepů realizovaný balíčkem pojmenovaným
<strong>DWIM</strong> neboli &bdquo;Do What I Mean&ldquo;. Pokud se ve formě
zapsané uživatelem nacházel neznámý symbol, mohl být balíček DWIM automaticky
vyvolán, aby našel správný symbol ze seznamu již definovaných symbolů a nabídl
uživateli opravu, korigoval chybu automaticky nebo vypsal chybové hlášení, jak
je to dodnes běžné.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-14.png" class="image-445925" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/360/atari-devtools-15.png" class="image-445926" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/360/atari-devtools-16.png" class="image-445927" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/360/atari-devtools-17.png" class="image-445928" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/360/atari-devtools-18.png" class="image-445929" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/360/atari-devtools-19.png" class="image-445930" alt="&#160;" width="640" height="480" />



<p><a name="k13"></a></p>
<h2 id="k13">13. Specifika Intelispu/65</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Programovací jazyk Action!</h2>

<p>Velmi zajímavým vyšším programovacím jazykem, který byl optimalizován pro použití na osmibitových mikropočítačích, byl jazyk nazvaný <i>Action!</i>.  Tento jazyk byl určen pro osmibitové mikropočítače Atari a od ostatních (obecnějších) jazyků se odlišoval zejména tím, že jeho možnosti odrážely schopnosti těchto mikropočítačů (datové typy omezeny na bajt, 16bitový integer se znaménkem a bez znaménka atd.). Syntaxe jazyka <i>Action!</i> je odvozena od Algolu (resp.&nbsp;od Algolské větve jazyků, kam spadá i Pascal), což se týká zejména způsobu zápisu programových smyček a podmínek (<strong>IF-FI</strong>, <strong>DO-OD</strong>). <i>Action!</i> podporoval strukturované programování, uživatelé mohli vytvářet lokální proměnné, ovšem ne na zásobníku, jehož velikost i možnosti adresování byly na MOS 6502 omezeny. Zajímavě bylo vyřešeno rozhraní jazyka <i>Action!</i>, protože uživatelé měli k&nbsp;dispozici plnohodnotný textový editor, jednoprůchodový (a tedy rychlý) překladač a <i>monitor</i>, v&nbsp;němž bylo možné provádět i ladění vyvíjené aplikace. Zdrojový text mohl být neustále uložen v&nbsp;operační paměti současně s&nbsp;přeloženou (nativní) aplikací, což bylo umožněno tím, že samotný <i>Action!</i> byl umístěn na přídavném paměťovém modulu.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-9.png" class="image-445920" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/360/atari-devtools-10.png" class="image-445921" alt="&#160;" width="640" height="480" />

<a href="http://www.root.cz/obrazek/210850/"><img src="http://i.iinfo.cz/images/462/dev-8bit-46-prev.png" class="image-210850" width="370" height="221" alt="&#160;" /></a>
<p><i>Obrázek 48: Zdrojový kód části programu napsaného v&nbsp;jazyce </i>Action!</i></p>

<p>V&nbsp;následující tabulce jsou vypsána všechna klíčová slova jazyky Action!:</p>

<table>
<tr><td>AND</td><td>FI</td><td>OR</td><td>UNTIL</td></tr>
<tr><td>ARRAY</td><td>FOR</td><td>POINTER</td><td>WHILE</td></tr>
<tr><td>BYTE</td><td>FUNC</td><td>PROC</td><td>XOR</td></tr>
<tr><td>CARD</td><td>IF</td><td>RETURN</td><td>&nbsp;</td></tr>
<tr><td>CHAR</td><td>INCLUDE</td><td>RSH</td><td>&nbsp;</td></tr>
<tr><td>DEFINE</td><td>INT</td><td>SET</td><td>&nbsp;</td></tr>
<tr><td>DO</td><td>LSH</td><td>STEP</td><td>&nbsp;</td></tr>
<tr><td>ELSE</td><td>MOD</td><td>THEN</td><td>&nbsp;</td></tr>
<tr><td>ELSEIF</td><td>MODULE</td><td>TO</td><td>&nbsp;</td></tr>
<tr><td>EXIT</td><td>OD</td><td>TYPE</td><td>&nbsp;</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se tvůrci tohoto jazyka pravděpodobně nechali inspirovat <a href="">Algolem 68</a>, protože v&nbsp;obou těchto jazycích nalezneme stejné &bdquo;příkazové závorky&ldquo;, konkrétně dvojici</div></p>

<img src="https://i.iinfo.cz/images/502/atari-devtools-2-1.png" class="image-445939" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/502/atari-devtools-2-2.png" class="image-445940" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/502/atari-devtools-2-3.png" class="image-445941" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/502/atari-devtools-2-4.png" class="image-445942" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/502/atari-devtools-2-5.png" class="image-445943" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/502/atari-devtools-2-6.png" class="image-445944" alt="&#160;" width="640" height="480" />

algol 68



; komentar
$ hexa
'A
'@
"string"
ptr^
5+ptr^


<p><a name="k15"></a></p>
<h2 id="k15">15. Datové typy v&nbsp;jazyku Action!</h2>

BYTE
CARD unsigned
INT signed

BYTE x,y,z
INT num=[0]  <- inicializace
BYTE x=$8000 <- ulozeni na adresu

BYTE POINTER ptr
CARD POINTER ptr2

BYTE ARRAY pole
INT ARRAY x(10)
BYTE ARRAY str = "This is a string constant"

TYPE r=[BYTE b1, b2
        INT i1]

lze mixovat ve vyrazech: automaticke prevody BYTE->INT->CARD


<p><a name="k16"></a></p>
<h2 id="k16">16. Programové konstrukce v&nbsp;jazyku Action!</h2>

IF podmínka THEN
    příkazy
    příkazy
    příkazy
FI

IF podmínka THEN
    příkazy
    příkazy
    příkazy
ELSE
    příkazy
    příkazy
    příkazy
FI

IF podmínka THEN
    příkazy
    příkazy
    příkazy
ELSEIF podmínka THEN
    příkazy
    příkazy
    příkazy
ELSE
    příkazy
    příkazy
    příkazy
FI

DO
    příkazy
    příkazy
    příkazy
OD

DO
    příkazy
    příkazy
    IF podmínka THEN
        EXIT
    FI
    příkazy
OD

FOR proměnná=start TO end
DO
    příkazy
    příkazy
    příkazy
OD

FOR proměnná=start TO end STEP step
DO
    příkazy
    příkazy
    příkazy
OD

WHILE podmínka
DO
    příkazy
    příkazy
    příkazy
OD

DO
    příkazy
    příkazy
    příkazy
    UNTIL podmínka
OD

PROC název_procedury(parametry)
    příkazy
    příkazy
    příkazy
RETURN

type FUNC název_funkce(parametry)
    příkazy
    příkazy
    příkazy
RERUN výraz

DEFINE size="256" makro

DEFINE begin = "DO", end = "OD"


<p><a name="k17"></a></p>
<h2 id="k17">17. FIG-Forth</h2>

<p>If you're a frequent calculator user, you owe it to yourself to investigate the advantages of RPN. RPN stands for Reverse Polish Notation. Reverse Polish Notation was developed in 1920 by Jan Lukasiewicz as a way to write a mathematical expression without using parentheses and brackets. Hewlett-Packard Co., realizing that Lukasiewicz's met­hod was superior to standard algebraic expressions when using calculators and computers, adapted RPN for its first hand-held scientific calculator, the HP35, in 1972.
Hewlett-Packard Development Company The RPN Method: An Overview and History</p>

<p>Programovacímu jazyku Forth jsme se již na stránkách Rootu kdysi věnovali <a href="https://www.root.cz/serialy/programovaci-jazyk-forth/">v&nbsp;samostatném seriálu</a>. Tento jazyk, který je založený na konceptu dvou zásobníků (jeden je používaný pro operandy a druhý pro uložení návratových adres volajících funkcí), je známý mj.&nbsp;i tím, že jeho implementaci lze v&nbsp;nejjednodušší variantě provést v&nbsp;několika stovkách bajtů paměti, tj.&nbsp;přibližně s&nbsp;300 až 500 strojovými instrukcemi a navíc se některé dialekty Forthu provozovaly bez použití operačního systému (Forthovské jazyky byly součástí i několika BIOSů). V&nbsp;takto malém počtu instrukcí bude složité uložit jakákoli nebezpečná zadní vrátka. Na druhou stranu je nutné poznamenat, že Forth tvoří svůj velmi zajímavý, ale dosti izolovaný svět, takže v&nbsp;něm pravděpodobně nikdy nevznikne překladač C ani dalšího vyššího programovacího jazyka (typicky se ovšem Forth spojuje s&nbsp;assemblerem, což je ostatně i logičtější).</p>

<p>V roce 1976 byla firma FORTH Inc. (jejím zakladatelem byl kdo jiný než Chuck Moore) požádána, aby Forth portovala na mikroprocesor CDP-1802 (mimochodem, tento procesor, určený pro vojenské a kosmické aplikace, měl velmi zajímavý instrukční soubor – viz například stránku Great Microprocessors of the Past and Present). Nový produkt byl nazván microFORTH a v dalších letech byl portován na celou skupinu vzájemně odlišných mikroprocesorů, zejména Intel 8080, Motorola 6800, MOS 6502 a Zilog Z80. Systém microFORTH byl s úspěchem použit pro vytváření průmyslových a řídících aplikací, které využívaly právě tyto osmibitové mikroprocesory. Mnohé tyto systémy prý pracují až do dnešní doby (tomu ostatně po zhlédnutí historických sdělovacích a zabezpečovacích zařízení v některých našich [polo]státních podnicích ochotně věřím – on také nebývá důvod měnit fungující zařízení).</p>

<p>Všechny výše zmíněné mikroprocesory jsou osmibitové a v průmyslových aplikacích byly osazeny operační pamětí o typické kapacitě 16 kB. Tyto aplikace byly spouštěny většinou z pamětí EPROM nebo PROM, protože disky se používaly pouze v minipočítačích. Ostatní firmy pro tyto mikroprocesory dodávaly buď pouze assembler, nebo jazyk PL/M (raději na něj zapomeňte), ostatní jazyky byly buď příliš náročné na systémové prostředky (C, Pascal), nebo nevhodné pro programování složitějších aplikací (Basic). V této „konkurenci“ je jasné, že se Forth velmi dobře prosazoval, zejména jako náhrada assembleru.</p>

<p>Programovací jazyk Forth byl s poměrně velkým úspěchem použit i na osmibitových domácích počítačích. Zde se významně projevila schopnost Forthu generovat krátký kód, který bylo možné zpracovat velmi jednoduchým interpreterem. Ten byl dlouhý pouze několik strojových instrukcí.</p>

<p>Jednou z prvních aplikací Forthu v oblasti osmibitových počítačů byly některé systémové rutiny uložené v paměti ROM počítače ZX-81. Jednalo se o operace s hodnotami uloženými v pohyblivé řádové čárce. Pomocí Forthu byl vytvořen velmi krátký kód hojně používající smyčky a iterace. Běh rutin byl díky tomu pomalý, proto byl v dalších počítačích firmySinclair Research použit kód psaný přímo v assembleru, který však byl delší. Osmibitové počítače ještě v době svého největšího rozmachu zažily vznik oblíbeného FIG Forthu, jehož autoři si kladli za cíl vytvořit standard mezi různými dialekty Forthu. A právě FIG-Forthem se budeme ve stručnosti zabývat v&nbsp;této kapitole.</p>

<img src="https://i.iinfo.cz/images/360/atari-devtools-11.png" class="image-445922" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/360/atari-devtools-12.png" class="image-445923" alt="&#160;" width="640" height="480" />
<img src="https://i.iinfo.cz/images/360/atari-devtools-13.png" class="image-445924" alt="&#160;" width="640" height="480" />


<p><a name="k18"></a></p>
<h2 id="k18">18. FastBASIC</h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Na GitHubu nalezneme &ndash; pochopitelně vedle zdrojových kódů psaných v&nbsp;moderních programovacích jazycích &ndash; mnohdy i vyložené obskurnosti, takže pravděpodobně nebude na škodu zveřejnit několik kódů naprogramovaných v&nbsp;Atari BASICu a taktéž v&nbsp;Turbo-BASICu XL. Vzhledem k&nbsp;odlišnostem mezi ASCII a ATASCII (tedy znakovou sadou používanou v&nbsp;osmibitových mikropočítačích Atari) byly zdrojové kódy převedeny do čitelné podoby, což prakticky znamená, že došlo k&nbsp;převodu znaku pro konec řádku a k&nbsp;dalším nepatrným úpravám.</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na herní konzoli Atari 2600<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-herni-konzoli-atari-2600/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-herni-konzoli-atari-2600/</a>
</li>

<li>Stránka magazínu (diskmagu) FLOP<br />
<a href="http://flop.atariportal.cz/">http://flop.atariportal.cz/</a>
</li>

<li>Action (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Action">https://atariwiki.org/wiki/Wiki.jsp?page=Action</a>
</li>

<li>Assembler (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Assembler">https://atariwiki.org/wiki/Wiki.jsp?page=Assembler</a>
</li>

<li>Basic (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Basic">https://atariwiki.org/wiki/Wiki.jsp?page=Basic</a>
</li>

<li>C (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=C">https://atariwiki.org/wiki/Wiki.jsp?page=C</a>
</li>

<li>Forth (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Forth">https://atariwiki.org/wiki/Wiki.jsp?page=Forth</a>
</li>

<li>Fortran (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Fortran">https://atariwiki.org/wiki/Wiki.jsp?page=Fortran</a>
</li>

<li>Lisp (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Lisp">https://atariwiki.org/wiki/Wiki.jsp?page=Lisp</a>
</li>

<li>Logo (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Logo">https://atariwiki.org/wiki/Wiki.jsp?page=Logo</a>
</li>

<li>Pascal (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Pascal">https://atariwiki.org/wiki/Wiki.jsp?page=Pascal</a>
</li>

<li>Pilot (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Pilot">https://atariwiki.org/wiki/Wiki.jsp?page=Pilot</a>
</li>

<li>PL65 (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=PL65">https://atariwiki.org/wiki/Wiki.jsp?page=PL65</a>
</li>

<li>Quick (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=Quick">https://atariwiki.org/wiki/Wiki.jsp?page=Quick</a>
</li>

<li>WSFN (AtariWiki.org)<br />
<a href="https://atariwiki.org/wiki/Wiki.jsp?page=WSFN">https://atariwiki.org/wiki/Wiki.jsp?page=WSFN</a>
</li>

<li>MAC/65 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MAC/65">https://en.wikipedia.org/wiki/MAC/65</a>
</li>

<li>Atari Assembler Editor<br />
<a href="https://en.wikipedia.org/wiki/Atari_Assembler_Editor#AMAC">https://en.wikipedia.org/wiki/Atari_Assembler_Editor#AMAC</a>
</li>

<li>cc65<br />
<a href="https://cc65.github.io/">https://cc65.github.io/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Stránky RetroFestu<br />
<a href="http://retrofest.cz/">http://retrofest.cz/</a>
</li>

<li>RetroHerna<br />
<a href="http://retroherna.cz/">http://retroherna.cz/</a>
</li>

<li>BASIC<br />
<a href="http://cs.wikipedia.org/wiki/BASIC">http://cs.wikipedia.org/wiki/BASIC</a>
</li>

<li>BASIC<br />
<a href="http://en.wikipedia.org/wiki/BASIC">http://en.wikipedia.org/wiki/BASIC</a>
</li>

<li>Rosetta Code &ndash; Category Basic<br />
<a href="http://rosettacode.org/wiki/Category:BASIC">http://rosettacode.org/wiki/Category:BASIC</a>
</li>

<li>Dartmouth College Computation Center: 1964 &ndash; The original Dartmouth BASIC manual<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf</a>
</li>

<li>The Original BASIC<br />
<a href="http://www.truebasic.com/">http://www.truebasic.com/</a>
</li>

<li>BASIC - Beginners All-purpose Symbolic Instruction Code<br />
<a href="http://hopl.murdoch.edu.au/showlanguage.prx?exp=176">http://hopl.murdoch.edu.au/showlanguage.prx?exp=176</a>
</li>

<li>Turbo BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Turbo_BASIC">http://cs.wikipedia.org/wiki/Turbo_BASIC</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Action!<br />
<a href="https://atari8bitbot.com/action/">https://atari8bitbot.com/action/</a>
</li>

<li>Atari Logo<br />
<a href="https://atari8bitbot.com/atari-logo/">https://atari8bitbot.com/atari-logo/</a>
</li>

<li>Atari PILOT &amp; Super PILOT<br />
<a href="https://atari8bitbot.com/atari-pilot/">https://atari8bitbot.com/atari-pilot/</a>
</li>

<li>Turbo-BASIC XL<br />
<a href="https://atari8bitbot.com/turbo-basic-xl/">https://atari8bitbot.com/turbo-basic-xl/</a>
</li>

<li>Atari Assembler/Editor<br />
<a href="https://atari8bitbot.com/atari-assembler-editor/">https://atari8bitbot.com/atari-assembler-editor/</a>
</li>

<li>Strings in Atari BASIC<br />
<a href="http://www.cyberroach.com/analog/an11/strings.htm">http://www.cyberroach.com/analog/an11/strings.htm</a>
</li>

<li>String Arrays in Atari BASIC<br />
<a href="http://www.atarimagazines.com/compute/issue11/52_1_STRING_ARRAYS_IN_ATARI_BASIC.php">http://www.atarimagazines.com/compute/issue11/52_1_STRING_ARRAYS_IN_ATARI_BASIC.php</a>
</li>

<li>An Atari BASIC Tutorial<br />
<a href="http://www.cyberroach.com/analog/an25/basictutorial.htm">http://www.cyberroach.com/analog/an25/basictutorial.htm</a>
</li>

<li>Atari Logo<br />
<a href="https://en.wikipedia.org/wiki/Atari_Logo">https://en.wikipedia.org/wiki/Atari_Logo</a>
</li>

<li>Computer art and animation : a user's guide to Atari logo<br />
<a href="https://archive.org/details/Computer_Art_and_Animation">https://archive.org/details/Computer_Art_and_Animation</a>
</li>

<li>Going into Action! with Atari XL/XE – Part 1 – Hello World!<br />
<a href="https://vintageisthenewold.com/going-into-action-with-atari-xl-xe-part-1-hello-world/">https://vintageisthenewold.com/going-into-action-with-atari-xl-xe-part-1-hello-world/</a>
</li>

<li>Going into Action! with Atari XL/XE – Part 2 – Graphics<br />
<a href="https://vintageisthenewold.com/going-into-action-with-atari-xl-xe-part-2-graphics/">https://vintageisthenewold.com/going-into-action-with-atari-xl-xe-part-2-graphics/</a>
</li>

<li>Going into Action! with Atari XL/XE – Part 3 – More Variables, Memory and Pointers (ugh!)<br />
<a href="https://vintageisthenewold.com/going-into-action-with-atari-xl-xe-part-3-more-variables-memory-and-pointers-ugh/">https://vintageisthenewold.com/going-into-action-with-atari-xl-xe-part-3-more-variables-memory-and-pointers-ugh/</a>
</li>

<li>Going into Action! with Atari XL/XE – Part 4 – Using VSCode and Action! with syntax highlighting<br />
<a href="https://vintageisthenewold.com/going-into-action-with-atari-xl-xe-part-4-using-vscode-and-action-with-syntax-highlighting/">https://vintageisthenewold.com/going-into-action-with-atari-xl-xe-part-4-using-vscode-and-action-with-syntax-highlighting/</a>
</li>

<li>Atari800 (emulátor)<br />
<a href="https://github.com/atari800/atari800">https://github.com/atari800/atari800</a>
</li>

<li>Atari MAC/65 Tutorial<br />
<a href="https://www.youtube.com/watch?v=RyBsGDJBXD0">https://www.youtube.com/watch?v=RyBsGDJBXD0</a>
</li>

<li>MAC/65 Manual<br />
<a href="http://www.mixinc.net/atari/mac65.htm">http://www.mixinc.net/atari/mac65.htm</a>
</li>

<li>BASIC 10 Liner Contest 2021<br />
<a href="https://atariage.com/forums/topic/316645-basic-10-liner-contest-2021/">https://atariage.com/forums/topic/316645-basic-10-liner-contest-2021/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Deep Blue C<br />
<a href="https://en.wikipedia.org/wiki/Deep_Blue_C">https://en.wikipedia.org/wiki/Deep_Blue_C</a>
</li>

<li>Deep Blue C Compiler<br />
<a href="https://www.atariarchives.org/APX/showinfo.php?cat=20166">https://www.atariarchives.org/APX/showinfo.php?cat=20166</a>
</li>

<li>Historie vývoje počítačových her: simulace a strategické hry naprogramované Chrisem Crawfordem<br />
<a href="https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-simulace-a-strategicke-hry-naprogramovane-chrisem-crawfordem/">https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-simulace-a-strategicke-hry-naprogramovane-chrisem-crawfordem/</a>
</li>

<li>Explore BASIC Programming Languages for the Atari 8-Bit Computers (30-60 mins)<br />
<a href="http://atariprojects.org/2020/08/29/explore-different-basic-programming-languages-for-the-atari-8-bit-computers-30-60-mins/">http://atariprojects.org/2020/08/29/explore-different-basic-programming-languages-for-the-atari-8-bit-computers-30-60-mins/</a>
</li>

<li>Learn How to Make a Game in BASIC XE (30-60 mins)<br />
<a href="http://atariprojects.org/2019/12/21/learn-how-to-make-a-game-in-basic-xe-30-60-mins/">http://atariprojects.org/2019/12/21/learn-how-to-make-a-game-in-basic-xe-30-60-mins/</a>
</li>

<li>Atari BASIC XL (manuál)<br />
<a href="http://www.atarimania.com/8bit/files/BASIC%20XL%20%C2%A4%20Second%20Edition.pdf">http://www.atarimania.com/8bit/files/BASIC%20XL%20%C2%A4%20Second%20Edition.pdf</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

