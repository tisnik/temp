<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vývoj her a grafických i zvukových dem pro ZX Spectrum: vlastní vykreslovací subrutiny (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V pořadí již páté části seriálu o vývoji programů pro legendární osmibitový domácí mikropočítač ZX Spectrum nejdříve dokončíme problematiku tisku znaků na obrazovku. Poté si ukážeme, jak je možné vytisknout celé řetězce a následně se zaměříme na emulaci BASICovského příkazu PLOT.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukce pro bitové posuny a rotace</a></p>
<p><a href="#k02">2. Náhrada čtveřice operací <strong>rra</strong> za trojici operací <strong>rrca</strong></a></p>
<p><a href="#k03">3. Vylepšený výpočet adresy masky znaku uloženého v&nbsp;paměti ROM</a></p>
<p><a href="#k04">4. Rutina pro vykreslení znaku, která vrátí adresu pro zápis dalšího znaku</a></p>
<p><a href="#k05">5. Vykreslení znaku na libovolné místo na obrazovce</a></p>
<p><a href="#k06">6. Rozbalení programových smyček</a></p>
<p><a href="#k07">7. Realizace rozbalení programové smyčky</a></p>
<p><a href="#k08">8. První pokus o vytištění celého řetězce</a></p>
<p><a href="#k09">9. Úplný zdrojový kód celého demonstračního příkladu</a></p>
<p><a href="#k10">10. Kde vlastně došlo k&nbsp;chybě?</a></p>
<p><a href="#k11">11. Uložení hodnot na zásobník; obnova hodnot ze zásobníku</a></p>
<p><a href="#k12">12. Oprava podprogramu pro tisk řetězce</a></p>
<p><a href="#k13">13. Jedná se o korektní opravu?</a></p>
<p><a href="#k14">14. Úplný zdrojový kód opraveného demonstračního příkladu</a></p>
<p><a href="#k15">15. Realizace operace typu <strong>PLOT</strong> &ndash; vykreslení pixelu</a></p>
<p><a href="#k16">16. Bitové operace prováděné na mikroprocesoru Zilog Z80</a></p>
<p><a href="#k17">17. Operace pro otestování, nastavení a vynulování konkrétního bitu</a></p>
<p><a href="#k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukce pro bitové posuny a rotace</h2>

<p>Instrukce mikroprocesoru Zilog Z80, které jsme si popsali v&nbsp;předchozích
čtyřech článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">3</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny/">4</a>],
nám již dnes nebudou postačovat, neboť začneme při tisku do obrazové paměti
provádět posuny a rotace dat. Na rozdíl od minimalisticky pojatého čipu MOS
6502 nabízí Z80 programátorům celou řadu instrukcí pro rotaci (přes osm bitů
nebo přes devět bitů s&nbsp;carry) i pro aritmetický a bitový posun doleva a
doprava. V&nbsp;tabulce pro úplnost uvádím i instrukci <strong>SLL</strong>,
kterou lze použít, i když nebyla oficiálně zdokumentovaná:</p>

<table>
<tr><th>Instrukce</th><th>Popis prováděné operace</th></tr>
<tr><td>RLCA</td><td>rotace akumulátoru doleva, sedmý bit do carry</td></tr>
<tr><td>RLA</td><td>rotace akumulátoru i s&nbsp;carry doleva</td></tr>
<tr><td>RRCA</td><td>rotace akumulátoru doleva, nultý bit do carry</td></tr>
<tr><td>RRA</td><td>rotace akumulátoru i s&nbsp;carry doprava</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>RLC</td><td>rotace registru doleva, sedmý bit do carry</td></tr>
<tr><td>RL</td><td>rotace registru i s&nbsp;carry doleva</td></tr>
<tr><td>RRC</td><td>rotace registru doleva, nultý bit do carry</td></tr>
<tr><td>RR</td><td>rotace registru i s&nbsp;carry doprava</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SLA</td><td>aritmetický posun doleva (násobení dvěma), sedmý bit do carry</td></tr>
<tr><td>SLL*</td><td>dtto, ovšem do nultého bitu se nasune jednička (nedokumentovaná instrukce)</td></tr>
<tr><td>SRA</td><td>aritmetický posun doprava (dělení dvěma), nultý bit do carry</td></tr>
<tr><td>SRL</td><td>logický posun doprava (do sedmého bitu se nasune nula)</td></tr>
</table>

<img src="https://i.iinfo.cz/images/485/devel-speccy-4-1.png" class="image-827259" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 1: Obrazovka vyplněná barevným textem vykresleným příkladem (ROM
rutina si navíc vynutí pokračování vykreslování po stisku klávesy).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Náhrada čtveřice operací <strong>rra</strong> za trojici operací <strong>rrca</strong></h2>

<p>Připomeňme si nejdříve, jak vlastně vypadal program, který dokázal na určené
místo na obrazovce v&nbsp;rastru 32&times;24 znaků vykreslit blok o velikosti
8&times;8 pixelů. Tento program nejdříve vypočítal adresu prvního zapisovaného
bajtu s&nbsp;tím, že adresa bajtu na dalším obrazovém řádku je díky
&bdquo;podivné&ldquo; struktuře obrazové paměti ZX Spectra vlastně umístěna na
adrese o 256 bajtů vyšší. A přechod o 256 bajtů výše se provádí až triviálně
snadno &ndash; pouhou inkrementací hodnoty <i>vyššího bajtu adresy</i> (což je
rychlá osmibitová operace).</p>

<p>Zdrojový kód tohoto programu vypadá následovně:</p>

<pre>
SCREEN_ADR      equ $4000
ENTRY_POINT     equ $8000
&nbsp;
PATTERN         equ $ff
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
&nbsp;
        ld b, 0                 <i>; x-ová souřadnice</i>
        ld c, 0                 <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
        ld b, 15                <i>; x-ová souřadnice</i>
        ld c, 12                <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
        ld b, 2                 <i>; x-ová souřadnice</i>
        ld c, 2                 <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
        ld b, 31                <i>; x-ová souřadnice</i>
        ld c, 23                <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
finish:
        jr finish               <i>; žádný návrat do systému</i>
&nbsp;
&nbsp;
calc_block_address:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>; C - y-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis bloku</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y4 Y3 0 0 0 | Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
        ld  a, c
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (řádky 0..7)</i>
        rra
        rra
        rra
        rra                   <i>; nyní jsou čísla řádků v horních třech bitech</i>
        or  b                 <i>; připočítat x-ovou souřadnici</i>
        ld  l, a              <i>; máme spodní bajt adresy</i>
                              <i>; Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
&nbsp;
        ld  a, c              <i>; y-ová souřadnice</i>
        and %00011000         <i>; dva bity s indexem "bloku" 0..3 (dolní tři bity už máme zpracovány)</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; máme horní bajt adresy</i>
                              <i>; 0 1 0 Y5 Y4 0 0 0</i>
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
fill_block:
        <i>; parametry:</i>
        <i>; A - pattern</i>
        <i>; HL - adresa vykreslení bloku</i>
        ld b, 8               <i>; počitadlo zapsaných bajtů</i>
loop:
        ld (hl), PATTERN      <i>; zápis hodnoty na adresu (HL)</i>
        inc h                 <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop             <i>; vnitřní smyčka: blok s osmi zápisy</i>
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

*** image ***
<p><i>Obrázek 2: Bloky vykreslené popisovaným demonstračním příkladem.</i></p>

<p>Zajímat nás nyní bude především sekvence instrukcí, která vysune tři bity
y-ové souřadnice (tedy vlastně číslo obrazového řádku v&nbsp;rámci znaku
vysokého osm pixelů) do nejvyšších třech bitů. Tuto operaci jsme realizovali
maskou a následným čtyřnásobným posunem doprava přes <strong>carry</strong>
(popř.&nbsp;pětinásobným posunem doleva):</p>

<pre>
ld  a, c
and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (řádky 0..7)</i>
rra
rra
rra
rra                   <i>; nyní jsou čísla řádků v horních třech bitech</i>
                      <i>; Y2 Y1 Y0 0 0 0 0 0</i>
</pre>

<p>Ve skutečnosti je možné tento bitový posun (což je vlastně rotace) o jednu
instrukci zkrátit, když nebudeme rotovat přes <strong>carry</strong>, ale pouze
v&nbsp;rámci jednoho bajtu (carry se sice nastavuje, ale to nás nemusí
trápit):</p>

<pre>
ld  a, c
and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (řádky 0..7)</i>
rrca
rrca
rrca                  <i>; nyní jsou čísla řádků v horních třech bitech</i>
                      <i>; Y2 Y1 Y0 0 0 0 0 0</i>
</pre>

<p><div class="rs-tip-major">Poznámka: díky čtenáři <strong>_dw</strong> za
upozornění!</div></p>

<p>Výsledný program bude vypadat takto:</p>

<pre>
SCREEN_ADR      equ $4000
ENTRY_POINT     equ $8000
&nbsp;
PATTERN         equ $ff
&nbsp;
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
&nbsp;
        ld b, 0                 <i>; x-ová souřadnice</i>
        ld c, 0                 <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
        ld b, 15                <i>; x-ová souřadnice</i>
        ld c, 12                <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
        ld b, 2                 <i>; x-ová souřadnice</i>
        ld c, 2                 <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
        ld b, 31                <i>; x-ová souřadnice</i>
        ld c, 23                <i>; y-ová souřadnice</i>
        call calc_block_address <i>; výpočet adresy</i>
        ld a, PATTERN
        call fill_block         <i>; vykreslit blok</i>
&nbsp;
finish:
        jr finish               <i>; žádný návrat do systému</i>
&nbsp;
&nbsp;
calc_block_address:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>; C - y-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; HL - adresa pro zápis bloku</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y4 Y3 0 0 0 | Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
        ld  a, c
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (řádky 0..7)</i>
        rrca
        rrca
        rrca                  <i>; nyní jsou čísla řádků v horních třech bitech</i>
        or  b                 <i>; připočítat x-ovou souřadnici</i>
        ld  l, a              <i>; máme spodní bajt adresy</i>
                              <i>; Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
&nbsp;
        ld  a, c              <i>; y-ová souřadnice</i>
        and %00011000         <i>; dva bity s indexem "bloku" 0..3 (dolní tři bity už máme zpracovány)</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  h, a              <i>; máme horní bajt adresy</i>
                              <i>; 0 1 0 Y5 Y4 0 0 0</i>
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
fill_block:
        <i>; parametry:</i>
        <i>; A - pattern</i>
        <i>; HL - adresa vykreslení bloku</i>
        ld b, 8               <i>; počitadlo zapsaných bajtů</i>
loop:
        ld (hl), PATTERN      <i>; zápis hodnoty na adresu (HL)</i>
        inc h                 <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop             <i>; vnitřní smyčka: blok s osmi zápisy</i>
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
end ENTRY_POINT
</pre>

<p>Výsledek by měl být přitom stejný, jako tomu bylo u originálního
příkladu:</p>

*** image ***
<p><i>Obrázek 3: Bloky vykreslené upraveným demonstračním příkladem.</i></p>

<p>Pro úplnost se podívejme na způsob překladu do strojového kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
ENTRY_POINT     EQU 8000
PATTERN         EQU 00FF
                ORG 8000
8000:           label start
8000:0600       LD B, 00
8002:0E00       LD C, 00
8004:CD3280     CALL 8032
8007:3EFF       LD A, FF
8009:CD4180     CALL 8041
800C:060F       LD B, 0F
800E:0E0C       LD C, 0C
8010:CD3280     CALL 8032
8013:3EFF       LD A, FF
8015:CD4180     CALL 8041
8018:0602       LD B, 02
801A:0E02       LD C, 02
801C:CD3280     CALL 8032
801F:3EFF       LD A, FF
8021:CD4180     CALL 8041
8024:061F       LD B, 1F
8026:0E17       LD C, 17
8028:CD3280     CALL 8032
802B:3EFF       LD A, FF
802D:CD4180     CALL 8041
8030:           label finish
8030:18FE       JR 8030
8032:           label calc_block_address
8032:79         LD A, C
8033:E607       AND 07
8035:0F         RRCA
8036:0F         RRCA
8037:0F         RRCA
8038:B0         OR B
8039:6F         LD L, A
803A:79         LD A, C
803B:E618       AND 18
803D:F640       OR 40
803F:67         LD H, A
8040:C9         RET
8041:           label fill_block
8041:0608       LD B, 08
8043:           label loop
8043:36FF       LD (HL), FF
8045:24         INC H
8046:10FB       DJNZ 8043
8048:C9         RET
8049:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8048
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vylepšený výpočet adresy masky znaku uloženého v&nbsp;paměti ROM</h2>

<p>Dalším kódem, který je možné optimalizovat, je kód pro výpočet adresy masky
znaku uloženého v&nbsp;paměti ROM. Původní tvar výpočtu pro kód znaku zapsaného
do akumulátoru <strong>A</strong> vypadal následovně:</p>

<pre>
<strong>draw_char</strong>:
        ld hl, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld b, 0
        ld c, a                  <i>; kód znaku je nyní ve dvojici BC</i>
        sla c
        rl b
        sla c
        rl b
        sla c
        rl b                     <i>; vynásobení BC osmi</i>
        add hl, bc               <i>; přičíst adresu k offsetu masky znaku</i>
</pre>

<p>Povšimněte si, že jsme kód znaku nejdříve uložili do dvojice registrů BC a
poté bitovými posuny a rotacemi vynásobili tuto hodnotu osmi. Výsledek byl
přičten k&nbsp;bázové adrese masek znaků, která byla uložena do dvojice
registrů HL.</p>

<p>I tento kód můžeme zkrátit a urychlit, a to tak, že prohodíme význam dvojic
BC s&nbsp;HL. Bázová adresa bude nyní uložena ve dvojici BC, zatímco HL bude
použit pro výpočet offsetu. Proč zrovna HL? Protože je možné bitové rotace a
posuny nahradit šestnáctibitovým součtem (16bitové operace nejsou ortogonální,
tj.&nbsp;nejsou dostupné pro všechny dvojice registrů):</p>

<pre>
<strong>draw_char</strong>:
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
</pre>

<p><div class="rs-tip-major">Poznámka: opět díky čtenáři <strong>_dw</strong>
za upozornění!</div></p>

*** image ***
<p><i>Obrázek 4: Tisk znaků upraveným demonstračním příkladem.</i></p>

<p>Upravený zdrojový kód demonstračního příkladu vypadá následovně:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld de, SCREEN_ADR        <i>; adresa pro zápis</i>
        ld a, 'A'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
        ld de, SCREEN_ADR+1      <i>; adresa pro zápis</i>
        ld a, 'B'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
        ld de, SCREEN_ADR+128+31 <i>; adresa pro zápis</i>
        ld a, '?'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
finish:
        ret                      <i>; ukončit program</i>
&nbsp;
draw_char:
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
&nbsp;
loop:
        ld    a,(hl)             <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Překlad do objektového kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:110040     LD DE, 4000
8003:3E41       LD A, 41
8005:CD1980     CALL 8019
8008:110140     LD DE, 4001
800B:3E42       LD A, 42
800D:CD1980     CALL 8019
8010:119F40     LD DE, 409F
8013:3E3F       LD A, 3F
8015:CD1980     CALL 8019
8018:           label finish
8018:C9         RET
8019:           label draw_char
8019:01003C     LD BC, 3C00
801C:61         LD H, C
801D:6F         LD L, A
801E:29         ADD HL, HL
801F:29         ADD HL, HL
8020:29         ADD HL, HL
8021:09         ADD HL, BC
8022:0608       LD B, 08
8024:           label loop
8024:7E         LD A, (HL)
8025:12         LD (DE), A
8026:2C         INC L
8027:14         INC D
8028:10FA       DJNZ 8024
802A:C9         RET
802B:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 802A
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rutina pro vykreslení znaku, která vrátí adresu pro zápis dalšího znaku</h2>

<p>Podprogram <strong>draw_char</strong> určený pro tisk jednoho znaku očekává,
že v&nbsp;registrovém páru <strong>DE</strong> je uložena adresa do obrazové
paměti, kam se má uložit první mikrořádek znaku (tedy prvních osm pixelů).
Většinou budeme chtít tisknout více znaků za sebou, takže by bylo vhodné, aby
rutina automaticky zvýšila adresu <strong>DE</strong> tak, aby bylo možné ihned
začít tisknout další znak. Původní tvar podprogramu ovšem tento výpočet
nedělal, protože se sice zvyšovala hodnota v&nbsp;registru <strong>D</strong>,
ale takovým způsobem, že by se další znak vytisknul <i>pod</i> znak předchozí
(navíc ne vždy, protože obrazovka je rozdělena do třech oblastí):</p>

<pre>
<strong>draw_char</strong>:
        ...
        ...
        ...
&nbsp;
loop:
        ...
        ...
        ...
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        ret                      <i>; návrat z podprogramu</i>
</pre>

<p>Můžeme ovšem provést relativně malé množství úprav, které změnu adresy
<strong>DE</strong> na adresu dalšího znaku zajistí. Musíme si uvědomit, že
další znak na stejném řádku začíná na adrese <strong>DE+1</strong>, takže by se
smyčka dala upravit takto:</p>

<pre>
<strong>draw_char</strong>:
        ...
        ...
        ...
        ld c, d
&nbsp;
loop:
        ...
        ...
        ...
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc   e
        ld    d, c
        ret                      <i>; E=E+1</i>
</pre>

<p>Musíme ovšem počítat i s&nbsp;tím, že na konci celého bloku je nutné se
přesunout na blok další, tj.&nbsp;že hodnota <strong>D</strong> vypočtená
uvnitř smyčky je vlastně korektní a pouze zvýšíme hodnotu v&nbsp;registru
<strong>E</strong> (navíc nemusíme řešit přetečení do <strong>D</strong>,
protože víme, že <strong>E</strong> je na konci bloku nulové). Úprava bude nyní
následující:</p>

<pre>
<strong>draw_char</strong>:
        ...
        ...
        ...
        ld c, d
&nbsp;
loop:
        ...
        ...
        ...
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc   e
        ret   z                  <i>; D+=8,E=E+1=0</i>
        ld    d, c
        ret                      <i>; D=D,E=E+1</i>
</pre>

*** image ***
<p><i>Obrázek 5: Tisk tří znaků za sebou upraveným demonstračním
příkladem.</i></p>

<p>Upravená varianta demonstračního příkladu vypadá následovně. Povšimněte si,
že znaky A, B a ? vytiskneme za sebou bez úpravy adresy:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld de, SCREEN_ADR        <i>; adresa pro zápis</i>
        ld a, 'A'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
        ld a, 'B'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
        ld a, '?'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
finish:
        ret                      <i>; ukončit program</i>
&nbsp;
draw_char:
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
loop:
        ld    a,(hl)             <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc   e
        ret   z                  <i>; D+=8,E=E+1=0</i>
        ld    d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Způsob překladu z&nbsp;assembleru do strojového kódu:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:110040     LD DE, 4000
8003:3E41       LD A, 41
8005:CD1380     CALL 8013
8008:3E42       LD A, 42
800A:CD1380     CALL 8013
800D:3E3F       LD A, 3F
800F:CD1380     CALL 8013
8012:           label finish
8012:C9         RET
8013:           label draw_char
8013:01003C     LD BC, 3C00
8016:61         LD H, C
8017:6F         LD L, A
8018:29         ADD HL, HL
8019:29         ADD HL, HL
801A:29         ADD HL, HL
801B:09         ADD HL, BC
801C:0608       LD B, 08
801E:4A         LD C, D
801F:           label loop
801F:7E         LD A, (HL)
8020:12         LD (DE), A
8021:2C         INC L
8022:14         INC D
8023:10FA       DJNZ 801F
8025:1C         INC E
8026:C8         RET Z
8027:51         LD D, C
8028:C9         RET
8029:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8028
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vykreslení znaku na libovolné místo na obrazovce</h2>

<p>V&nbsp;této chvíli již máme k&nbsp;dispozici programový kód pro umístění a
vykreslení bloku kamkoli na obrazovku a současně umíme vykreslit znak, jehož
maska je přečtena z&nbsp;ROM. Tyto dvě znalosti je nutné zkombinovat a vytvořit
rutinu pro tisk znaků popř.&nbsp;(později) řetězců kamkoli na obrazovku. Postup
je vlastně triviální, protože potřebujeme znát a využít pouze trojici hodnot:
kód znaku, x-ovou souřadnici 0..31 a y-ovou souřadnici 0..23. Ze souřadnic
vypočteme adresu znaku na obrazovce a poté znak vykreslíme:</p>

<pre>
ld b, 15                 <i>; x-ová souřadnice</i>
ld c, 12                 <i>; y-ová souřadnice</i>
call calc_char_address   <i>; výpočet adresy</i>
ld a, 'A'                <i>; kód vykreslovaného znaku</i>
call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
</pre>

*** image ***
<p><i>Obrázek 6: Trojice znaků vykreslená na různá místa na obrazovce.</i></p>

<p>Upravený zdrojový kód demonstračního příkladu bude nyní vypadat
následovně:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld b, 15                 <i>; x-ová souřadnice</i>
        ld c, 12                 <i>; y-ová souřadnice</i>
        call calc_char_address   <i>; výpočet adresy</i>
        ld a, 'A'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
        ld a, 'B'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
        ld b, 31                 <i>; x-ová souřadnice</i>
        ld c, 23                 <i>; y-ová souřadnice</i>
        call calc_char_address   <i>; výpočet adresy</i>
        ld a, '?'                <i>; kód vykreslovaného znaku</i>
        call draw_char           <i>; zavolat subrutinu pro vykreslení znaku</i>
&nbsp;
finish:
        jr finish               <i>; žádný návrat do systému</i>
&nbsp;
&nbsp;
calc_char_address:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>; C - y-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; DE - adresa pro zápis bloku</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y4 Y3 0 0 0 | Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
        ld  a, c
        and %00000111         <i>; pouze spodní tři bity y-ové souřadnice (řádky 0..7)</i>
        rrca
        rrca
        rrca                  <i>; nyní jsou čísla řádků v horních třech bitech</i>
        or  b                 <i>; připočítat x-ovou souřadnici</i>
        ld  e, a              <i>; máme spodní bajt adresy</i>
                              <i>; Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
&nbsp;
        ld  a, c              <i>; y-ová souřadnice</i>
        and %00011000         <i>; dva bity s indexem "bloku" 0..3 (dolní tři bity už máme zpracovány)</i>
        or  %01000000         <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  d, a              <i>; máme horní bajt adresy</i>
                              <i>; 0 1 0 Y5 Y4 0 0 0</i>
        ret                   <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
draw_char:
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
loop:
        ld    a,(hl)             <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc   e
        ret   z                  <i>; D+=8,E=E+1=0</i>
        ld    d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
end ENTRY_POINT
</pre>

<p>Po překladu získáme strojový kód o velikosti celých 67 bajtů:</p>

<pre>
SCREEN_ADR      EQU 4000
CHAR_ADR        EQU 3C00
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:060F       LD B, 0F
8002:0E0C       LD C, 0C
8004:CD1F80     CALL 801F
8007:3E41       LD A, 41
8009:CD2E80     CALL 802E
800C:3E42       LD A, 42
800E:CD2E80     CALL 802E
8011:061F       LD B, 1F
8013:0E17       LD C, 17
8015:CD1F80     CALL 801F
8018:3E3F       LD A, 3F
801A:CD2E80     CALL 802E
801D:           label finish
801D:18FE       JR 801D
801F:           label calc_char_address
801F:79         LD A, C
8020:E607       AND 07
8022:0F         RRCA
8023:0F         RRCA
8024:0F         RRCA
8025:B0         OR B
8026:5F         LD E, A
8027:79         LD A, C
8028:E618       AND 18
802A:F640       OR 40
802C:57         LD D, A
802D:C9         RET
802E:           label draw_char
802E:01003C     LD BC, 3C00
8031:61         LD H, C
8032:6F         LD L, A
8033:29         ADD HL, HL
8034:29         ADD HL, HL
8035:29         ADD HL, HL
8036:09         ADD HL, BC
8037:0608       LD B, 08
8039:4A         LD C, D
803A:           label loop
803A:7E         LD A, (HL)
803B:12         LD (DE), A
803C:2C         INC L
803D:14         INC D
803E:10FA       DJNZ 803A
8040:1C         INC E
8041:C8         RET Z
8042:51         LD D, C
8043:C9         RET
8044:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8043
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozbalení programových smyček</h2>

<p>Ještě jednou se podívejme na tu část vykreslovací rutiny, která postupně
načte osm masek znaku a vykreslí je, tj.&nbsp;přesune je do obrazové
paměti:</p>

<pre>
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
&nbsp;
loop:
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
</pre>

<p>Můžeme zde vidět, že se jedná o programovou smyčku, která se bude opakovat
osmkrát. Samotná obsluha smyčky (tj.&nbsp;instrukce, které jsou nutné pro její
provedení) je realizována jednou osmibitovou instrukcí <strong>ld</strong> a
osmkrát volanou instrukcí <strong>djnz</strong>. Celkem tedy obsluha smyčky
vyžaduje relativně velký počet strojových cyklů:</p>

<table>
<tr><th>Instrukce</th><th>Opakování</th><th>Počet cyklů na instrukci</th><th>Celkem cyklů</th></tr>
<tr><td>ld b, 8</td><td>1&times;</td><td>7</td><td>7</td></tr>
<tr><td>djnz loop pro b&gt;1</td><td>7&times;</td><td>13</td><td>91</td></tr>
<tr><td>djnz loop pro b==1</td><td>1&times;</td><td>8</td><td>8</td></tr>
</table>

<p>Celkem tedy i prázdná programová smyčka opakovaná osmkrát vyžaduje
7+91+8=106 strojových cyklů!</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Realizace rozbalení programové smyčky</h2>

<p>Za cenu poněkud větší spotřeby operační paměti můžeme smyčku ručně (nebo
s&nbsp;využitím makra) rozbalit, a to tak, že jednoduše sekvenci instrukcí
osmkrát zopakujeme. Dosáhneme tak vyšší rychlosti vykreslování (konkrétně
ušetříme 106 strojových cyklů), ovšem za cenu větší spotřeby RAM, což je pro
osmibitové stroje zcela typické dilema, které je nutné řešit prakticky
neustále:</p>

<pre>
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
&nbsp;
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
&nbsp;
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
&nbsp;
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
&nbsp;
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
&nbsp;
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
&nbsp;
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
&nbsp;
        ld   a,(hl)              <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
</pre>

<p>Všechny výše uvedené instrukce jsou jednobajtové, takže rozbalení smyčky
zabere 4&times;7+3=31 bajtů. To může být relativně dobrá cena, kterou zaplatíme
za urychlení vykreslování.</p>

*** image ***
<p><i>Obrázek 7: Trojice znaků vykreslená na různá místa na obrazovce rozbalenou smyčkou.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. První pokus o vytištění celého řetězce</h2>

<p>Ve druhé části dnešního článku si ukážeme, jak můžeme upravený podprogram
pro vytištění znaku použít pro vytištění celého řetězce. Využijeme přitom toho,
že podprogram správně spočítá adresu dalšího znaku, takže teoreticky by mohlo
být vytištění řetězce (speciálně ASCII řetězce ukončeného nulou) realizováno
velmi jednoduchým způsobem:</p>

<pre>
<strong>print_string</strong>:
        ld   a, (hl)             <i>; načíst kód znaku z řetězce</i>
        and  a                   <i>; test na kód znak s kódem 0</i>
        ret  Z                   <i>; ukončit podprogram na konci řetězce</i>
        call draw_char           <i>; tisk jednoho znaku</i>
        inc  hl                  <i>; přechod na další znak</i>
        jr   print_string        <i>; na další znak</i>
</pre>

<p>Tento podprogram vyžaduje, aby při jeho volání byla v&nbsp;dvojici registrů
<strong>HL</strong> uložena adresa řetězce, který budeme chtít vytisknout. Dále
podprogram vyžaduje uložení adresy prvního znaku v&nbsp;obrazové paměti
v&nbsp;registrovém páru <strong>DE</strong> (tuto hodnotu nám připraví
podprogram <strong>calc_char_address</strong>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód celého demonstračního příkladu</h2>

<p>Podívejme se nyní na úplný zdrojový kód takto upraveného a rozšířeného
demonstračního příkladu. Jedná se sice o poněkud delší kód, který by však stále
měl být relativně snadno pochopitelný:</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld b, 15                 <i>; x-ová souřadnice</i>
        ld c, 12                 <i>; y-ová souřadnice</i>
        call calc_char_address   <i>; výpočet adresy</i>
        ld   hl, TEXT            <i>; adresa prvního znaku v řetězci</i>
        call print_string        <i>; tisk celého řetězce</i>
&nbsp;
finish:
        jr finish                <i>; žádný návrat do systému</i>
&nbsp;
&nbsp;
calc_char_address:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>; C - y-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; DE - adresa pro zápis bloku</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y4 Y3 0 0 0 | Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
        ld  a, c
        and %00000111            <i>; pouze spodní tři bity y-ové souřadnice (řádky 0..7)</i>
        rrca
        rrca
        rrca                     <i>; nyní jsou čísla řádků v horních třech bitech</i>
        or  b                    <i>; připočítat x-ovou souřadnici</i>
        ld  e, a                 <i>; máme spodní bajt adresy</i>
                                 <i>; Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
&nbsp;
        ld  a, c                 <i>; y-ová souřadnice</i>
        and %00011000            <i>; dva bity s indexem "bloku" 0..3 (dolní tři bity už máme zpracovány)</i>
        or  %01000000            <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  d, a                 <i>; máme horní bajt adresy</i>
                                 <i>; 0 1 0 Y5 Y4 0 0 0</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
print_string:
        ld   a, (hl)             <i>; načíst kód znaku z řetězce</i>
        and  a                   <i>; test na kód znak s kódem 0</i>
        ret  Z                   <i>; ukončit podprogram na konci řetězce</i>
        call draw_char           <i>; tisk jednoho znaku</i>
        inc  hl                  <i>; přechod na další znak</i>
        jr   print_string        <i>; na další znak</i>
&nbsp;
draw_char:
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
loop:
        ld    a,(hl)             <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc   e
        ret   z                  <i>; D+=8,E=E+1=0</i>
        ld    d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
<i>; nulou ukončený řetězec</i>
TEXT:   db "Hello, Speccy!", 0
&nbsp;
end ENTRY_POINT
</pre>

<p>Po jeho překladu a spuštění se však namísto očekávané zprávy &bdquo;Hello,
Speccy!&ldquo; objeví chybný text:</p>

*** image ***
<p><i>Obrázek 8: Nekorektní text zobrazený tímto demonstračním příkladem.</i></p>

<p><div class="rs-tip-major">Poznámka: velká výhoda ZX Spectra spočívá ve
faktu, že prakticky všichni by měli vidět stejné chyby!</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Kde vlastně došlo k&nbsp;chybě?</h2>

<p>Program uvedený <a href="#k08">v&nbsp;předchozí kapitole</a> sice vykreslil
špatný řetězec, ovšem aspoň skončil :-), vytiskl neplatný řetězec na správné
místo na obrazovce a navíc je první znak korektní (&bdquo;H&ldquo;). To může
znamenat, že chyba se nachází v&nbsp;té části programu, který počítá adresy
znaků v&nbsp;řetězci. Adresa znaku se nachází ve dvojici registrů
<strong>HL</strong>, jejíž hodnota se vy smyčce postupně zvyšuje (a to
korektně):</p>

<pre>
<strong>print_string</strong>:
        ld   a, (hl)             <i>; načíst kód znaku z řetězce</i>
        and  a                   <i>; test na kód znak s kódem 0</i>
        ret  Z                   <i>; ukončit podprogram na konci řetězce</i>
        call draw_char           <i>; tisk jednoho znaku</i>
        inc  hl                  <i>; přechod na další znak</i>
        jr   print_string        <i>; na další znak</i>
</pre>

<p>Problém tedy musíme hledat přímo v&nbsp;podprogramu
<strong>draw_char</strong>. A skutečně &ndash; zde se
s&nbsp;<strong>HL</strong> skutečně manipuluje:</p>

<pre>
draw_char:
        ...
        ...
        ...
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
        ...
        ...
        ...
</pre>

<p>Chybu jsme tedy našli &ndash; volaný podprogram nám přepisuje obsah
registrů. Nyní se ji pokusíme nějakým způsobem opravit.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Uložení hodnot na zásobník; obnova hodnot ze zásobníku</h2>

<p>Ještě předtím, než si ukážeme, jakým způsobem je možné program <a
href="#k08">z&nbsp;předchozí kapitoly</a> opravit, si popíšeme strojové
instrukce sloužící pro uložení hodnot na zásobník a instrukce pro následnou
obnovu hodnot ze zásobníku. Zásobníkem je v&nbsp;kontextu mikroprocesoru Zilog
Z80 myšlena oblast operační paměti, do níž se data (většinou) ukládají pod
adresu uloženou ve speciálním 16bitovém registru <strong>SP</strong>, přičemž
při uložení hodnot se adresa v&nbsp;<strong>SP</strong> sníží a při obnově
hodnot (načtení ze zásobníku) naopak zvýší. Zásobník tedy roste směrem dolů.
Zajímavostí mikroprocesorů Z80 (a 8080) je to, že se na zásobník vždy ukládají
dvě osmibitové hodnoty, což je buď návratová adresa nebo dvojice osmibitových
registrů. K&nbsp;dispozici jsou následující instrukce, které nějakým způsobem
manipulují s&nbsp;obsahem zásobníku:</p>

<table>
<tr><th>Instrukce</th><th>Délka</th><th>Stručný popis</th></tr>
<tr><td>push BC</td><td>1</td><td>uložení registrového páru BC na zásobník</td></tr>
<tr><td>push DE</td><td>1</td><td>uložení registrového páru DE na zásobník</td></tr>
<tr><td>push HL</td><td>1</td><td>uložení registrového páru HL na zásobník</td></tr>
<tr><td>push AF</td><td>1</td><td>uložení akumulátoru a příznakového registru na zásobník</td></tr>
<tr><td>push IX</td><td>2</td><td>uložení index registru IX na zásobník</td></tr>
<tr><td>push IY</td><td>2</td><td>uložení index registru IY na zásobník</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>pop BC</td><td>1</td><td>vyjmutí 16bitové hodnoty ze zásobníku s&nbsp;jejím uložením do registrového páru BC</td></tr>
<tr><td>pop DE</td><td>1</td><td>vyjmutí 16bitové hodnoty ze zásobníku s&nbsp;jejím uložením do registrového páru DE</td></tr>
<tr><td>pop HL</td><td>1</td><td>vyjmutí 16bitové hodnoty ze zásobníku s&nbsp;jejím uložením do registrového páru HL</td></tr>
<tr><td>pop AF</td><td>1</td><td>vyjmutí 16bitové hodnoty ze zásobníku s&nbsp;jejím uložením do akumulátoru a příznakového registru</td></tr>
<tr><td>pop IX</td><td>2</td><td>vyjmutí 16bitové hodnoty ze zásobníku s&nbsp;jejím uložením do index registru IX</td></tr>
<tr><td>pop IY</td><td>2</td><td>vyjmutí 16bitové hodnoty ze zásobníku s&nbsp;jejím uložením do index registru IY</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>call adresa</td><td>3</td><td>volání podprogramu (uložení návratové adresy na zásobník)</td></tr>
<tr><td>call příznak, adresa</td><td>3</td><td>volání podprogramu při splnění podmínky (uložení návratové adresy na zásobník)</td></tr>
<tr><td>rst x</td><td>1</td><td>volání podprogramu, zkrácená verze pro vybrané adresy (uložení návratové adresy na zásobník)</td></tr>
<tr><td>ret</td><td>1</td><td>návrat z&nbsp;podprogramu (přečtení návratové adresy ze zásobníku)</td></tr>
<tr><td>ret příznak</td><td>1</td><td>návrat z&nbsp;podprogramu při splnění podmínky (přečtení návratové adresy ze zásobníku)</td></tr>
<tr><td>retn</td><td>2</td><td>návrat z&nbsp;nemaskovatelného přerušení (přečtení návratové adresy ze zásobníku)</td></tr>
<tr><td>reti</td><td>2</td><td>návrat z&nbsp;maskovatelného přerušení (přečtení návratové adresy ze zásobníku)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že instrukce pracující
s&nbsp;index registry IX a IY mají délku dvou bajtů, protože před operačním
kódem instrukce je uveden jednobajtový prefix.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Oprava podprogramu pro tisk řetězce</h2>

<p>Podprogram pro tisk řetězce můžeme opravit velmi snadno. Víme totiž, že se
v&nbsp;podprogramu <strong>draw_char</strong>, který se postupně volá pro každý
tisknutý znak, mj.&nbsp;&bdquo;ničí&ldquo; obsah registrového páru
<strong>HL</strong>, který ovšem potřebujeme, protože obsahuje adresu právě
zpracovávaného znaku. Celá oprava tedy bude spočívat v&nbsp;tom, že obsah
tohoto registrového páru před voláním <strong>draw_char</strong> uložíme na
zásobník a ihned po návratu z&nbsp;podprogramu obsah registrového páru
obnovíme, takže bude použitelný pro načtení dalšího znaku v&nbsp;řetězci, který
se má vytisknout. Oprava může vypadat následovně:</p>

<pre>
<strong>print_string</strong>:
        ld   a, (hl)             <i>; načíst kód znaku z řetězce</i>
        and  a                   <i>; test na kód znak s kódem 0</i>
        ret  Z                   <i>; ukončit podprogram na konci řetězce</i>
        <strong>push hl</strong>                  <i>; uschovat HL na zásobník</i>
        call draw_char           <i>; tisk jednoho znaku</i>
        <strong>pop  hl</strong>                  <i>; obnovit obsah HL ze zásobníku</i>
        inc  hl                  <i>; přechod na další znak</i>
        jr   print_string        <i>; na další znak</i>
</pre>

<p>S&nbsp;aplikací této opravy by měl výpis řetězce dopadnout následovně:</p>

*** image ***
<p><i>Obrázek 9: Výpis řetězce na obrazovku &ndash; nyní je vše
korektní.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Jedná se o korektní opravu?</h2>

<p>Na tomto místě je vhodné si položit otázku, jestli je oprava korektní, a to
jak z&nbsp;hlediska činnosti programu, tak i z&nbsp;hlediska jeho čitelnosti
resp.&nbsp;&bdquo;očekávatelnosti&ldquo; chování. Program jsme evidentně
opravili, protože tiskne správný řetězec. Ovšem při volání podprogramu
<strong>draw_char</strong> si neustále musíme dávat pozor na uložení a opětovné
obnovení obsahu <strong>HL</strong>. Z&nbsp;tohoto pohledu by mohlo být lepší,
aby se instrukce <strong>push hl</strong> a <strong>pop hl</strong> vložily
přímo do podprogramu <strong>draw_char</strong> (popř.&nbsp;by se mohl
podprogram upravit do takové míry, aby nemodifikoval žádné registry,
v&nbsp;nichž nebudou předány návratové hodnoty).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Úplný zdrojový kód opraveného demonstračního příkladu</h2>

<p>Pro úplnost se nyní podívejme na to, jak vlastně vypadá opravená varianta
demonstračního příkladu pro výpis řetězce na libovolné místo na obrazovce (opět
počítáno v&nbsp;&bdquo;textovém&ldquo; rastru 32&times;24 znaků):</p>

<pre>
SCREEN_ADR      equ $4000
CHAR_ADR        equ $3c00
ENTRY_POINT     equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
<strong>start</strong>:
        ld b, 15                 <i>; x-ová souřadnice</i>
        ld c, 12                 <i>; y-ová souřadnice</i>
        call calc_char_address   <i>; výpočet adresy</i>
        ld   hl, TEXT            <i>; adresa prvního znaku v řetězci</i>
        call print_string        <i>; tisk celého řetězce</i>
&nbsp;
<strong>finish</strong>:
        jr finish                <i>; žádný návrat do systému</i>
&nbsp;
&nbsp;
<strong>calc_char_address</strong>:
        <i>; parametry:</i>
        <i>; B - x-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>; C - y-ová souřadnice (ve znacích, ne pixelech)</i>
        <i>;</i>
        <i>; návratové hodnoty:</i>
        <i>; DE - adresa pro zápis bloku</i>
        <i>;</i>
        <i>; vzor adresy:</i>
        <i>; 0 1 0 Y4 Y3 0 0 0 | Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
        ld  a, c
        and %00000111            <i>; pouze spodní tři bity y-ové souřadnice (řádky 0..7)</i>
        rrca
        rrca
        rrca                     <i>; nyní jsou čísla řádků v horních třech bitech</i>
        or  b                    <i>; připočítat x-ovou souřadnici</i>
        ld  e, a                 <i>; máme spodní bajt adresy</i>
                                 <i>; Y2 Y1 Y0 X4 X3 X2 X1 X0</i>
&nbsp;
        ld  a, c                 <i>; y-ová souřadnice</i>
        and %00011000            <i>; dva bity s indexem "bloku" 0..3 (dolní tři bity už máme zpracovány)</i>
        or  %01000000            <i>; "posun" do obrazové paměti (na 0x4000)</i>
        ld  d, a                 <i>; máme horní bajt adresy</i>
                                 <i>; 0 1 0 Y5 Y4 0 0 0</i>
        ret                      <i>; návrat z podprogramu</i>
&nbsp;
&nbsp;
<strong>print_string</strong>:
        ld   a, (hl)             <i>; načíst kód znaku z řetězce</i>
        and  a                   <i>; test na kód znak s kódem 0</i>
        ret  Z                   <i>; ukončit podprogram na konci řetězce</i>
        push hl                  <i>; uschovat HL na zásobník</i>
        call draw_char           <i>; tisk jednoho znaku</i>
        pop  hl                  <i>; obnovit obsah HL ze zásobníku</i>
        inc  hl                  <i>; přechod na další znak</i>
        jr   print_string        <i>; na další znak</i>
&nbsp;
<strong>draw_char</strong>:
        ld bc, CHAR_ADR          <i>; adresa, od níž začínají masky znaků</i>
        ld h, c                  <i>; C je nulové, protože CHAR_ADR=0x3c00</i>
        ld l, a                  <i>; kód znaku je nyní ve dvojici HL</i>
&nbsp;
        add  hl, hl              <i>; 2x</i>
        add  hl, hl              <i>; 4x</i>
        add  hl, hl              <i>; 8x</i>
        add  hl, bc              <i>; přičíst bázovou adresu masek znaků</i>
&nbsp;
        ld b, 8                  <i>; počitadlo zapsaných bajtů</i>
        ld c, d
&nbsp;
<strong>loop</strong>:
        ld    a,(hl)             <i>; načtení jednoho bajtu z masky</i>
        ld  (de),a               <i>; zápis hodnoty na adresu (DE)</i>
        inc  l                   <i>; posun na další bajt masky (nemusíme řešit přetečení do vyššího bajtu)</i>
        inc  d                   <i>; posun na definici dalšího obrazového řádku</i>
        djnz loop                <i>; vnitřní smyčka: blok s osmi zápisy</i>
        inc   e
        ret   z                  <i>; D+=8,E=E+1=0</i>
        ld    d, c
        ret                      <i>; D=D,E=E+1</i>
&nbsp;
<i>; nulou ukončený řetězec</i>
<strong>TEXT</strong>:   db "Hello, Speccy!", 0
&nbsp;
end ENTRY_POINT
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Realizace operace typu <strong>PLOT</strong> &ndash; vykreslení pixelu</h2>

<p>Nyní již relativně dobře umíme na obrazovku ZX Spectra vypsat řetězec.
Dokonce máme k&nbsp;dispozici několik metod. Můžeme využít subrutinu zapsanou
přímo v&nbsp;ROM ZX Spectra (ta umí kromě dalších věcí rozeznávat řídicí kódy)
nebo můžeme zavolat naši subrutinu, která je sice původně navržena pro tisk
znaků v&nbsp;masce 8&times;8 znaků, ale relativně snadno ji lze upravit na
různé výšky znaků. Ovšem zajímavější (i když možná méně praktické) bude
zjistit, jakým způsobem je možné realizovat operaci typu <strong>PLOT</strong>.
Jedná se o standardní příklad <a
href="https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html">Sinclair
BASICu</a> sloužící pro vykreslení jediného pixelu. Aby byla situace nepatrně
zajímavější, existuje tento příkaz v&nbsp;několika variantách:</p>

<table>
<tr><th>Příkaz</th><th>Stručný popis příkazu</th></tr>
<tr><td>PLOT x,y</td><td>vykreslení pixelu na souřadnice [x,y] barvou inkoustu</td></tr>
<tr><td>PLOT INVERSE 1; x, y</td><td>vykreslení pixelu barvou papíru</td></tr>
<tr><td>PLOT OVER 1; x, y</td><td>negace harvy pixelu</td></tr>
<tr><td>PLOT INVERSE 1;OVER 1;</td><td>pouze přesune grafický &bdquo;kurzor&ldquo; na nové souřadnice</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: počátek souřadnicového systému je
v&nbsp;levém <i>dolním</i> rohu, přesněji řečeno na začátku řádku 175, protože
spodní dva textové řádky (2&times;8 obrazových řádků) jsou vyhrazeny pro BASIC.
Naše programy budou mít naproti tomu počátek v&nbsp;levém <i>horním</i>
rohu.</div></p>

*** image ***
<p><i>Obrázek 10: Slavná hra Elite používá velké množství grafických entit:
body, úsečky, kružnice, vyplněné bloky a znaky.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Bitové operace prováděné na mikroprocesoru Zilog Z80</h2>

<p>Vykreslování na úrovni jednotlivých pixelů bude vzhledem ke struktuře
obrazové paměti ZX Spectra vyžadovat provádění bitových operací. Jaké operace
ovšem vůbec máme k&nbsp;dispozici? To nám napoví následující tabulka,
v&nbsp;níž jsou příslušné instrukce vypsány:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis instrukce</th></tr>
<tr><td>AND r</td><td>bitový součin akumulátoru s&nbsp;osmibitovým registrem</td></tr>
<tr><td>AND n</td><td>bitový součin akumulátoru s&nbsp;osmibitovou konstantou</td></tr>
<tr><td>AND (HL)</td><td>bitový součin akumulátoru s&nbsp;osmibitovou hodnotou uloženou na adrese HL</td></tr>
<tr><td>AND (IX+d)</td><td>bitový součin akumulátoru s&nbsp;osmibitovou hodnotou uloženou na adrese IX+d</td></tr>
<tr><td>AND (IY+d)</td><td>bitový součin akumulátoru s&nbsp;osmibitovou hodnotou uloženou na adrese IY+d</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>OR r</td><td>bitový součet akumulátoru s&nbsp;osmibitovým registrem</td></tr>
<tr><td>OR n</td><td>bitový součet akumulátoru s&nbsp;osmibitovou konstantou</td></tr>
<tr><td>OR (HL)</td><td>bitový součet akumulátoru s&nbsp;osmibitovou hodnotou uloženou na adrese HL</td></tr>
<tr><td>OR (IX+d)</td><td>bitový součet akumulátoru s&nbsp;osmibitovou hodnotou uloženou na adrese IX+d</td></tr>
<tr><td>OR (IY+d)</td><td>bitový součet akumulátoru s&nbsp;osmibitovou hodnotou uloženou na adrese IY+d</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>XOR r</td><td>bitová nonekvivalence akumulátoru s&nbsp;osmibitovým registrem</td></tr>
<tr><td>XOR n</td><td>bitová nonekvivalence akumulátoru s&nbsp;osmibitovou konstantou</td></tr>
<tr><td>XOR (HL)</td><td>bitová nonekvivalence akumulátoru s&nbsp;osmibitovou hodnotou uloženou na adrese HL</td></tr>
<tr><td>XOR (IX+d)</td><td>bitová nonekvivalence akumulátoru s&nbsp;osmibitovou hodnotou uloženou na adrese IX+d</td></tr>
<tr><td>XOR (IY+d)</td><td>bitová nonekvivalence akumulátoru s&nbsp;osmibitovou hodnotou uloženou na adrese IY+d</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CPL</td><td>bitová negace všech bitů v&nbsp;akumulátoru</td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Operace pro otestování, nastavení a vynulování konkrétního bitu</h2>

<p>Instrukční soubor osmibitového mikroprocesoru Zilog Z80 <a
href="https://www.zophar.net/fileuploads/2/10816buusf/z80opcod.txt">obsahuje
přibližně 1200</a> operačních kódů instrukcí, přičemž velkou část z&nbsp;tohoto
množství zaberou instrukce <strong>BIT</strong>, <strong>SET</strong> a
<strong>RES</strong>. Tyto instrukce slouží pro test jednoho bitu (výsledek je
ukládán do příznaku <strong>zero</strong>), nastavení konkrétního bitu na
jedničku nebo vynulování zvoleného bitu. Důvodem, proč tyto instrukce zabírají
velké množství operačních kódů je fakt, že v&nbsp;operačním kódu instrukce je
zakódován i index testovaného, nastavovaného či nulovaného bitu, tj.&nbsp;každá
instrukce vlastně existuje v&nbsp;osmi variantách, což je dále násobeno
několika adresovacími režimy (může se použít libovolný registr, adresa
v&nbsp;HL, navíc je někdy nutné uložit i offset <strong>d</strong> atd.):</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis instrukce</th></tr>
<tr><td>BIT b,r</td><td>test bitu <i>b</i> uloženého v&nbsp;některém osmibitovém registru</td></tr>
<tr><td>BIT b,(HL)</td><td>test bitu <i>b</i> uloženého na adrese HL</td></tr>
<tr><td>BIT b,(IX+d)</td><td>test bitu <i>b</i> uloženého na adrese IX+d</td></tr>
<tr><td>BIT b,(IY+d)</td><td>test bitu <i>b</i> uloženého na adrese IY+d</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SET b,r</td><td>nastavení bitu <i>b</i> uloženého v&nbsp;některém osmibitovém registru</td></tr>
<tr><td>SET b,(HL)</td><td>nastavení bitu <i>b</i> uloženého na adrese HL</td></tr>
<tr><td>SET b,(IX+d)</td><td>nastavení bitu <i>b</i> uloženého na adrese IX+d</td></tr>
<tr><td>SET b,(IY+d)</td><td>nastavení bitu <i>b</i> uloženého na adrese IY+d</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>RES b,r</td><td>vynulování bitu <i>b</i> uloženého v&nbsp;některém osmibitovém registru</td></tr>
<tr><td>RES b,(HL)</td><td>vynulování bitu <i>b</i> uloženého na adrese HL</td></tr>
<tr><td>RES b,(IX+d)</td><td>vynulování bitu <i>b</i> uloženého na adrese IX+d</td></tr>
<tr><td>RES b,(IY+d)</td><td>vynulování bitu <i>b</i> uloženého na adrese IY+d</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si určité ortogonality
instrukční sady &ndash; adresovací režimy odpovídají výše uvedeným logickým
operacím.</div></p>

<p>Tyto instrukce mají většinou prefix 0xCB, 0xDD 0xCB nebo 0xFD 0xCB. Jejich
délka je dva či čtyři bajty.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: upravený soubor Makefile pro překlad demonstračních příkladů</h2>

<p>Výše uvedené demonstrační příklady i příklady, které již byly popsány
v&nbsp;předchozích čtyřech článcích [<a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">1</a>]
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-mikroprocesor-zilog-z80-a-smycky-v-assembleru/">2</a>],
[<a
href="https://www.root.cz/clanky/vyvoj-pro-zx-spectrum-vypis-informaci-na-obrazovku/">3</a>],
[<a href="https://www.root.cz/clanky/vyvoj-her-a-dem-pro-zx-spectrum-vlastni-vykreslovaci-subrutiny/">4</a>],
je možné přeložit s&nbsp;využitím souboru Makefile, jehož aktuální verze vypadá
následovně (pro překlad a slinkování je použit assembler <i>Pasmo</i>):</p>

<pre>
ASSEMBLER := pasmo
&nbsp;
all: 01.tap 02.tap 03.tap 04.tap 05.tap 06.tap 07.tap 08.tap 09.tap 10.tap \
    11.tap 12.tap 13.tap 14.tap 15.tap 16.tap 17.tap 18.tap 19.tap 20.tap \
    21.tap 22.tap 23.tap 24.tap 25.tap 26.tap 27.tap 28.tap 29.tap 30.tap \
    31.tap 32.tap 33.tap 34.tap 35.tap 36.tap 37.tap 38.tap 39.tap 40.tap \
    41.tap 42.tap 43.tap 44.tap 45.tap 46.tap 47.tap 48.tap 49.tap
&nbsp;
clean:
        rm -f *.tap
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
01.tap: 01-color-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 01-color-attribute.lst
&nbsp;
02.tap: 02-blinking-attribute.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 02-blinking-attribute.lst
&nbsp;
03.tap: 03-symbolic-names.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 03-symbolic-names.lst
&nbsp;
04.tap: 04-operators.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 04-operators.lst
&nbsp;
05.tap: 05-better-symbols.asm
        $(ASSEMBLER) -v -d --tap $&lt; $@ &gt; 05-better-symbols.lst
&nbsp;
06.tap: 06-tapbas-v1.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 06-tapbas-v1.lst
&nbsp;
07.tap: 07-tapbas-v2.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 07-tapbas-v2.lst
&nbsp;
08.tap: 08-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 08-loop.lst
&nbsp;
09.tap: 09-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 09-loop.lst
&nbsp;
10.tap: 10-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 10-loop.lst
&nbsp;
11.tap: 11-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 11-loop.lst
&nbsp;
12.tap: 12-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 12-loop.lst
&nbsp;
13.tap: 13-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 13-loop.lst
&nbsp;
14.tap: 14-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 14-loop.lst
&nbsp;
15.tap: 15-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 15-loop.lst
&nbsp;
16.tap: 16-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 16-loop.lst
&nbsp;
17.tap: 17-loop.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 17-loop.lst
&nbsp;
18.tap: 18-cls.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 18-cls.lst
&nbsp;
19.tap: 19-print-char-call.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 19-print-char-call.lst
&nbsp;
20.tap: 20-print-char-rst.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 20-print-char-rst.lst
&nbsp;
21.tap: 21-print-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 21-print-char.lst
&nbsp;
22.tap: 22-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 22-print-all-chars.lst
&nbsp;
23.tap: 23-print-all-chars.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 23-print-all-chars.lst
&nbsp;
24.tap: 24-change-color.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 24-change-color.lst
&nbsp;
25.tap: 25-change-flash.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 25-change-flash.lst
&nbsp;
26.tap: 26-print-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 26-print-at.lst
&nbsp;
27.tap: 27-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 27-print-string.lst
&nbsp;
28.tap: 28-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 28-print-string.lst
&nbsp;
29.tap: 29-print-colorized-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 29-print-colorized-string.lst
&nbsp;
30.tap: 30-print-string-ROM.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 30-print-string-ROM.lst
&nbsp;
31.tap: 31-attributes.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 31-attributes.lst
&nbsp;
32.tap: 32-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 32-fill-in-vram.lst
&nbsp;
33.tap: 33-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 33-fill-in-vram-no-ret.lst
&nbsp;
34.tap: 34-fill-in-vram-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 34-fill-in-vram-pattern.lst
&nbsp;
35.tap: 35-slow-fill-in-vram.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 35-slow-fill-in-vram.lst
&nbsp;
36.tap: 36-slow-fill-in-vram-no-ret.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 36-slow-fill-in-vram-no-ret.lst
&nbsp;
37.tap: 37-fill-block.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 37-fill-block.lst
&nbsp;
38.tap: 38-fill-block-with-pattern.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 38-fill-block-with-pattern.lst
&nbsp;
39.tap: 39-fill-block-optimized.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 39-fill-block-optimized.lst
&nbsp;
40.tap: 40-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 40-draw-char.lst
&nbsp;
41.tap: 41-draw-any-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 41-draw-any-char.lst
&nbsp;
42.tap: 42-block-anywhere.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 42-block-anywhere.lst
&nbsp;
43.tap: 43-block-anywhere-rrca.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 43-block-anywhere-rrca.lst
&nbsp;
44.tap: 44-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 44-better-draw-char.lst
&nbsp;
45.tap: 45-even-better-draw-char.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 45-even-better-draw-char.lst
&nbsp;
46.tap: 46-draw-char-at.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 46-draw-char-at.lst
&nbsp;
47.tap: 47-draw-char-at-unrolled.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 47-draw-char-at-unrolled.lst
&nbsp;
48.tap: 48-incorrect-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 48-incorrect-print-string.lst
&nbsp;
49.tap: 49-correct-print-string.asm
        $(ASSEMBLER) -v -d --tapbas $&lt; $@ &gt; 49-correct-print-string.lst
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>18-cls.asm</td><td>smazání obrazovky a otevření kanálu číslo 2 (screen) přes funkci v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/18-cls.asm</a></td></tr>
<tr><td>19</td><td>19-print-char-call.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce CALL)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/19-print-char-call.asm</a></td></tr>
<tr><td>20</td><td>20-print-char-rst.asm</td><td>smazání obrazovky a výpis jednoho znaku na obrazovku přes funkci v&nbsp;ROM (použití instrukce RST)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/20-print-char-rst.asm</a></td></tr>
<tr><td>21</td><td>21-print-char.asm</td><td>pouze výpis jednoho znaku na obrazovku bez jejího smazání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/21-print-char.asm</a></td></tr>
<tr><td>22</td><td>22-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (nekorektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/22-print-all-chars.asm</a></td></tr>
<tr><td>23</td><td>23-print-all-chars.asm</td><td>výpis znakové sady znak po znaku (korektní verze příkladu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/23-print-all-chars.asm</a></td></tr>
<tr><td>24</td><td>24-change-color.asm</td><td>změna barvových atributů (popředí a pozadí) vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/24-change-color.asm</a></td></tr>
<tr><td>25</td><td>25-change-flash.asm</td><td>povolení či zákaz blikání vypisovaných znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/25-change-flash.asm</a></td></tr>
<tr><td>26</td><td>26-print-at.asm</td><td>výpis znaku či znaků na určené místo na obrazovce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/26-print-at.asm</a></td></tr>
<tr><td>27</td><td>27-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/27-print-string.asm</a></td></tr>
<tr><td>28</td><td>28-print-string.asm</td><td>výpis celého řetězce explicitně zapsanou programovou smyčkou (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/28-print-string.asm</a></td></tr>
<tr><td>29</td><td>29-print-colorized-string.asm</td><td>výpis řetězce, který obsahuje i řídicí znaky pro změnu barvy atd.</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/29-print-colorized-string.asm</a></td></tr>
<tr><td>30</td><td>30-print-string-ROM.asm</td><td>výpis řetězce s&nbsp;využitím služby/subrutiny uložené v&nbsp;ROM ZX Spectra</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/30-print-string-ROM.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>31-attributes.asm</td><td>modifikace atributů pro tisk řetězce subrutinou uloženou v&nbsp;ROM</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/31-attributes.asm</a></td></tr>
<tr><td>32</td><td>32-fill-in-vram.asm</td><td>vyplnění celé bitmapy barvou popředí, návrat do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/32-fill-in-vram.asm</a></td></tr>
<tr><td>33</td><td>33-fill-in-vram-no-ret.asm</td><td>vyplnění celé bitmapy barvou popředí, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/33-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>34</td><td>34-fill-in-vram-pattern.asm</td><td>vyplnění celé bitmapy zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/34-fill-in-vram-pattern.asm</a></td></tr>
<tr><td>35</td><td>35-slow-fill-in-vram.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/35-slow-fill-in-vram.asm</a></td></tr>
<tr><td>36</td><td>36-slow-fill-in-vram-no-ret.asm</td><td>pomalé vyplnění celé bitmapy, vizualizace struktury bitmapy, bez návratu do systému</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/36-slow-fill-in-vram-no-ret.asm</a></td></tr>
<tr><td>37</td><td>37-fill-block.asm</td><td>vykreslení bloku 8&times;8 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/37-fill-block.asm</a></td></tr>
<tr><td>38</td><td>38-fill-block-with-pattern.asm</td><td>vykreslení bloku 8&times;8 pixelů zvoleným vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/38-fill-block-with-pattern.asm</a></td></tr>
<tr><td>39</td><td>39-fill-block-optimized.asm</td><td>optimalizace předchozího příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/39-fill-block-optimized.asm</a></td></tr>
<tr><td>40</td><td>40-draw-char.asm</td><td>vykreslení znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/40-draw-char.asm</a></td></tr>
<tr><td>41</td><td>41-draw-any-char.asm</td><td>podprogram pro vykreslení libovolně zvoleného znaku do levého horního rohu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/41-draw-any-char.asm</a></td></tr>
<tr><td>42</td><td>42-block-anywhere.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/42-block-anywhere.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>43-block-anywhere-rrca.asm</td><td>podprogramy pro vykreslení bloku 8&times;8 pixelů kamkoli na obrazovku, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/43-block-anywhere-rrca.asm</a></td></tr>
<tr><td>44</td><td>44-better-draw-char.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/44-better-draw-char.asm</a></td></tr>
<tr><td>45</td><td>45-even-better-draw-char.asm</td><td>posun offsetu pro vykreslení dalšího znaku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/45-even-better-draw-char.asm</a></td></tr>
<tr><td>46</td><td>46-draw-char-at.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/46-draw-char-at.asm</a></td></tr>
<tr><td>47</td><td>47-draw-char-at-unrolled.asm</td><td>vykreslení znaku v&nbsp;masce 8&times;8 pixelů kamkoli na obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/47-draw-char-at-unrolled.asm</a></td></tr>
<tr><td>48</td><td>48-incorrect-print-string.asm</td><td>tisk řetězce, nekorektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/48-incorrect-print-string.asm</a></td></tr>
<tr><td>49</td><td>49-correct-print-string.asm</td><td>tisk řetězce, korektní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/49-correct-print-string.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech demonstračních příkladů do podoby obrazu magnetické pásky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>The system variables<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap25.html</a>
</li>

<li>ZX Spectrum manual: chapter #17 Graphics<br />
<a href="https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html">https://worldofspectrum.org/ZXBasicManual/zxmanchap17.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

