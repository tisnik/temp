<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Od grafické karty VGA k vyšším rozlišením i většímu množství barev (2. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Od grafické karty VGA k vyšším rozlišením i většímu množství barev (2. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na předchozí článek, ve kterém jsme si řekli základní informace o standardu VESA i o rozšíření původního BIOSu o VBE navážeme. Ukážeme si, jak lze provést přepnutí do zvoleného grafického režimu a jak se do obrazové paměti zapisují jednotlivé pixely, což může být komplikované.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Od grafické karty VGA k&nbsp;vyšším rozlišením i většímu množství barev (2. část)</a></p>
<p><a href="#k02">2. Rozdělení obrazové paměti na bitové roviny</a></p>
<p><a href="#k03">3. Typická organizace grafické paměti u grafických karet SVGA podporovaných VBE</a></p>
<p><a href="#k04">4. Přístup do grafické paměti přesahující velikost jednoho segmentu</a></p>
<p><a href="#k05">5. První demonstrační příklad: zjištění informací o okně pro zápis do obrazové paměti</a></p>
<p><a href="#k06">6. Druhý demonstrační příklad: nastavení grafického režimu</a></p>
<p><a href="#k07">7. Zápis barev pixelů do video paměti v&nbsp;reálném režimu</a></p>
<p><a href="#k08">8. Třetí demonstrační příklad: vyplnění jednoho okna video paměti přes segment A000</a></p>
<p><a href="#k09">9. Změna pozice okna pro zápis do jiné oblasti video paměti</a></p>
<p><a href="#k10">10. Čtvrtý demonstrační příklad: vyplnění obsahu lichých oken přes segment A000</a></p>
<p><a href="#k11">11. Uložení pixelů v&nbsp;grafických režimech se šestnácti miliony barev</a></p>
<p><a href="#k12">*** 12. Uložení pixelů v&nbsp;grafických režimech s&nbsp;bitovou hloubkou 15 a 16</a></p>
<p><a href="#k13">*** 13. Informace o uložení pixelů</a></p>
<p><a href="#k14">*** 14. Pátý demonstrační příklad: formát uložení pixelů v&nbsp;režimech s&nbsp;bitovou hloubkou 15 a 16 bitů</a></p>
<p><a href="#k15">*** 15. Šestý demonstrační příklad: formát uložení pixelů v&nbsp;režimu s&nbsp;24 nebo 32bitovou hloubkou</a></p>
<p><a href="#k16">*** 16. Ověření, že formát uložení pixelů odpovídá zjištěným informacím</a></p>
<p><a href="#k17">*** 17. Univerzální rutina pro vykreslení pixelu?</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Od grafické karty VGA k&nbsp;vyšším rozlišením i většímu množství barev (2. část)</h2>

<p>Na předchozí článek, ve kterém jsme si řekli základní informace o standardu
VESA i o rozšíření původního BIOSu o VBE (<i>VESA BIOS Extension</i>) dnes
navážeme. Ukážeme si, jakým způsobem je možné přepnutí do zvoleného grafického
režimu a jak se do obrazové paměti zapisují jednotlivé pixely. Na platformě IBM
PC nebyl způsob zápisu jednotlivých pixelů nikdy jednoduchý (CGA měla
prokládaný režim, EGA zavedla bitové roviny, VGA navíc zřetězení rovin
v&nbsp;256barevných režimech). Tyto problémy přetrvaly i do doby SVGA karet a
standardu VESA, protože bylo nutné zpřístupnit celou obrazovou paměť i
v&nbsp;reálném režimu a navíc nebylo přesně stanoveno, jakým způsobem jsou
uloženy barvové složky v&nbsp;režimech s&nbsp;15bitovou, 16bitovou nebo 24/32
bitovou hloubkou.</p>

<p>Připomeňme si, že ve standardu VESA se do jisté míry standardizovala čísla
některých grafických režimů. Ta jsou vypsána v&nbsp;následující tabulce. Ovšem
je nutné poznamenat, že například režimy s&nbsp;rozlišením 320&times;200 pixelů
nejsou vždy podporovány. V&nbsp;demonstračních příkladech budeme používat režim
0x103 s&nbsp;rozlišením 800&times;600 pixelů a s&nbsp;256 barvami. A posléze
otestujeme i režimy s&nbsp;větší bitovou hloubkou:</p>

<table>
<tr><th>Číslo</th><th>Rozlišení</th><th>Bitů na pixel</th><th>Počet barev</th></tr>
<tr><td>0x0100</td><td> 640&times;400</td><td>8    </td><td>256</td></tr>
<tr><td>0x0101</td><td> 640&times;480</td><td>8    </td><td>256</td></tr>
<tr><td>0x0102</td><td> 800&times;600</td><td>4    </td><td>16 </td></tr>
<tr><td>0x0103</td><td> 800&times;600</td><td>8    </td><td>256</td></tr>
<tr><td>0x010D</td><td> 320&times;200</td><td>15   </td><td>32768</td></tr>
<tr><td>0x010E</td><td> 320&times;200</td><td>16   </td><td>65536</td></tr>
<tr><td>0x010F</td><td> 320&times;200</td><td>24/32</td><td>1677216</td></tr>
<tr><td>0x0110</td><td> 640&times;480</td><td>15   </td><td>32768</td></tr>
<tr><td>0x0111</td><td> 640&times;480</td><td>16   </td><td>65536</td></tr>
<tr><td>0x0112</td><td> 640&times;480</td><td>24/32</td><td>1677216</td></tr>
<tr><td>0x0113</td><td> 800&times;600</td><td>15   </td><td>32768</td></tr>
<tr><td>0x0114</td><td> 800&times;600</td><td>16   </td><td>65536</td></tr>
<tr><td>0x0115</td><td> 800&times;600</td><td>24/32</td><td>1677216</td></tr>
<tr><td>0x0116</td><td>1024&times;768</td><td>15   </td><td>32768</td></tr>
<tr><td>0x0117</td><td>1024&times;768</td><td>16   </td><td>65536</td></tr>
<tr><td>0x0118</td><td>1024&times;768</td><td>24/32</td><td>1677216</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozdělení obrazové paměti na bitové roviny</h2>

<p>Ve standardu VESA (a tím pádem i VBE) bylo definováno poměrně velké množství
možností, jakým způsobem může být organizována grafická paměť
(resp.&nbsp;přesněji řečeno video paměť neboli VideoRAM či VRAM). Některé
grafické karty mohou podporovat původní organizaci paměti zavedenou již u
grafických karet EGA a VGA, tj.&nbsp;rozdělení bitů tvořících jednotlivé pixely
do bitových rovin. Ovšem v&nbsp;praxi se s&nbsp;touto organizací paměti setkáme
většinou pouze u grafického režimu s&nbsp;rozlišením 800&times;600 pixelů a se
šestnácti barvami. Tento režim je poměrně specifický, protože při jeho využití
je v&nbsp;každé bitové rovině uloženo přesně 800&times;600/8=60000 bajtů, což
je kapacita, která se (dokonce s&nbsp;malou rezervou) vejde do jednoho segmentu
(ten obsáhne 65536 bajtů). Je tedy možné používat &bdquo;staré dobré&ldquo;
rozdělení na čtyři bitové roviny a vlastně tak být prakticky 100% kompatibilní
s&nbsp;oběma staršími standardy.</p>

<p>Problém ovšem spočívá v&nbsp;tom, že u vyšších rozlišení již není možné
bitovou rovinu uložit do jednoho segmentu, takže toto dělení postrádá smysl. A
naopak pro větší bitovou hloubku (větší počet barev) by již bylo nutné použít
větší počet bitových rovin, což je problematické s&nbsp;ohledem na zpětnou
kompatibilitu. A opět &ndash; stejně není možné tímto způsobem překročit
rozlišení 800&times;600 pixelů, protože i kdybychom měli k&nbsp;dispozici
například osm či patnáct bitových rovin, jejich velikost by přesáhla velikost
jednoho segmentu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Typická organizace grafické paměti u grafických karet SVGA podporovaných VBE</h2>

<p>V&nbsp;praxi se proto u karet SVGA mnohem častěji setkáme spíše
s&nbsp;odlišným přístupem, který je založen na tom, že barvy pixelů jsou
uloženy pěti různými způsoby:</p>

<ol>
<li>Barvy dvou pixelů v&nbsp;jednom bajtu (platí pro 16barevné režimy)</li>
<li>Barva jednoho pixelu v&nbsp;jednom bajtu (platí pro 256barevné režimy)</li>
<li>Barva jednoho pixelu ve dvou po sobě jdoucích bajtech (režimy s&nbsp;15bitovou a 16bitovou hloubkou)</li>
<li>Barva jednoho pixelu ve třech po sobě jdoucích bajtech (režimy s&nbsp;16 miliony barev)</li>
<li>Barva jednoho pixelu ve čtyřech po sobě jdoucích bajtech (taktéž režimy s&nbsp;16 miliony barev)</li>
</ol>

<p>Ovšem tím reálné problémy teprve začínají. Grafické karty,
resp.&nbsp;přesněji řečeno grafické režimy, se od sebe totiž odlišují i dalšími
vlastnostmi:</p>

<ol>

<li>Obrazové řádky na sebe nemusí přímo navazovat. Mezi řádky se totiž mohou
nacházet &bdquo;neviditelné&ldquo; bajty používané pro různé účely
popř.&nbsp;pouze kvůli zarovnání.</li>

<li>Není pevně stanoveno, jakým způsobem jsou uloženy barvové složky RGB
v&nbsp;grafických režimech s&nbsp;15bitovou, 16bitovou, 24bitovou nebo
32bitovou hloubkou. Způsob uložení se může lišit nejenom pro různé výrobce, ale
i pro jednoho výrobce s&nbsp;různými čipy.</li>

<li>Pochopitelně není zaručeno, že grafický režim bude podporován monitorem.
Zjištění parametrů monitoru přes <i>DDC</i> bylo v&nbsp;době vydání první verze
standardu VESA spíše v&nbsp;plenkách a nedalo se na něj plně spolehnout (o této
technologii se ještě později zmíníme).</li>

<li>Může se lišit i obnovovací (obrazová) frekvence. Může se přitom stát, že
například režimy s&nbsp;rozlišením 640&times;480 pixelů budou podporovat různé
obrazové frekvence pro různé bitové hloubky, protože se zde již projevuje
pomalost přístupu do video paměti při obnovování obrazu.</li>

</ol>

<p>Všemi těmito problémy se postupně budeme zabývat v&nbsp;navazujícím
textu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přístup do grafické paměti přesahující velikost jednoho segmentu</h2>

<p>I ve chvíli, kdy je vybrán korektní grafický režim kompatibilní
s&nbsp;monitorem a nějakým způsobem (popsaným dále) zjistíme i formát uložení
pixelů, stále není vyhráno. Nyní totiž záleží na tom, zda námi vyvíjená
aplikace bude pracovat v&nbsp;reálném režimu (<i>real mode</i>) nebo
v&nbsp;režimu chráněném (<i>protected mode</i>). V&nbsp;případě, že aplikace
poběží v&nbsp;chráněném režimu, je možné v&nbsp;nových verzích VBE získat
přístup k&nbsp;celé obrazové paměti, což je problematika, ke které se ještě
vrátíme.</p>

<p>Ovšem komplikovanější je situace v&nbsp;případě, že vyvíjená aplikace má
běžet v&nbsp;režimu reálném. Připomeňme si, že v&nbsp;tomto případě je přímo
dostupný pouze paměťový prostor nepatrně přesahující kapacitu 1MB. V&nbsp;rámci
tohoto paměťového prostoru jsou pro obrazovou paměť vyhrazeny dva segmenty,
které začínají na adresách A000:0000 a B000:0000. Typicky se však
v&nbsp;grafickým režimech využívá pouze první segment, což konkrétně znamená
adresy v&nbsp;rozsahu A000:0000 až A000:FFFF (tedy přesně 64kB). Druhý segment
se využívá v&nbsp;textových režimech a jen některé karty umožňují použít celý
rozsah 128kB (i když to podporovala i VGA).</p>

<p>Do tohoto velmi stísněného adresního rozsahu je nutné nějakým způsobem
namapovat celou obrazovou paměť. A ta již může být celkem velká. Poměrně dobrým
příkladem je grafický režim s&nbsp;rozlišením 1024&times;768 pixelů
s&nbsp;bitovou hloubkou 15 bitů nebo 16 bitů. V&nbsp;obou případech je potřebná
kapacita video paměti rovna 1024&times;768&times;2=1536 kB, což je o mnoho
více, než dostupný paměťový rozsah 64 kB. Standard VESA v&nbsp;tomto případě
nabídl řešení založené na rozdělení obrazové paměti na takzvané <i>banky</i>,
které se zde ovšem nazývají <i>okna</i> (<i>windows</i>). Toto označení může
být poněkud matoucí, protože tato okna tvoří v&nbsp;obrazové paměti spíše
pruhy. V&nbsp;jeden okamžik je typicky možné pracovat s&nbsp;jedním nebo oběma
okny, a podle nastavení lze z&nbsp;obrazové paměti číst (obecně velmi pomalá
operace) nebo zapisovat.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. První demonstrační příklad: zjištění informací o okně pro zápis do obrazové paměti</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu využijeme již popsanou službu
číslo 01h pro získání informací o zvoleném grafickém režimu. Nyní si ovšem
necháme vypsat informace o okně/oknech, zejména to, zda je vůbec práce
s&nbsp;okny podporována a taktéž to, do jakého segmentu je okno nebo okna
namapována. Samotnou službu jsme si již popsali minule:</p>

<pre>
Vstup:  AH = 4Fh        Služby SVGA
        AL = 01h        Získání informací o zvoleném grafickém režimu
        CX = číslo režimu
        ES:DI = ukazatel na buffer (256 bajtů)
&nbsp;
Výstup: AL = 4Fh pokud je služba podporována, jinak odlišná hodnota
        AH = 00h pokud je volání úspěšné, jinak hodnota 01h
</pre>

<p>Číst budeme prvních několik informací o oknech, které se nazývají okno A a
okno B:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        clc                        <i>; ziskani zakladnich informaci o grafickem rezimu</i>
        mov  di, graphics_mode_block_info
        mov  cx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f01
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
<strong>success</strong>:
        print_string success_msg
&nbsp;
        xor eax, eax
        mov al, [WinAAttributes]
        print_hex eax
&nbsp;
        xor eax, eax
        mov al, [WinBAttributes]
        print_hex eax
&nbsp;
        xor eax, eax
        mov ax, [WinGranularity]
        print_dec_16
&nbsp;
        xor eax, eax
        mov ax, [WinSize]
        print_dec_16
&nbsp;
        xor eax, eax
        mov ax, [WinASegment]
        print_hex eax
&nbsp;
        xor eax, eax
        mov ax, [WinBSegment]
        print_hex eax
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
section .bss
<strong>graphics_mode_block_info</strong>:
        ModeAttributes      resw 1 <i>; mode attributes</i>
        WinAAttributes      resb 1 <i>; window A attributes</i>
        WinBAttributes      resb 1 <i>; window B attributes</i>
        WinGranularity      resw 1 <i>; window granularity</i>
        WinSize             resw 1 <i>; window size</i>
        WinASegment         resw 1 <i>; window A start segment</i>
        WinBSegment         resw 1 <i>; window B start segment</i>
        WinFuncPtr          resd 1 <i>; pointer to windor function</i>
        BytesPerScanLine    resw 1 <i>; bytes per scan line</i>
&nbsp;
        XResolution         resw 1 <i>; horizontal resolution</i>
        YResolution         resw 1 <i>; vertical resolution</i>
        XCharSize           resb 1 <i>; character cell width</i>
        YCharSize           resb 1 <i>; character cell height</i>
        NumberOfPlanes      resb 1 <i>; number of memory planes</i>
        BitsPerPixel        resb 1 <i>; bits per pixel</i>
        NumberOfBanks       resb 1 <i>; number of banks</i>
        MemoryModel         resb 1 <i>; memory model type</i>
        BankSize            resb 1 <i>; bank size in kb</i>
        NumberOfImagePages  resb 1 <i>; number of images</i>
        Reserved1           resb 1 <i>; reserved for page function</i>
&nbsp;
        RedMaskSize         resb 1 <i>; size of direct color red mask in bits</i>
        RedFieldPosition    resb 1 <i>; bit position of LSB of red mask</i>
        GreenMaskSize       resb 1 <i>; size of direct color green mask in bits</i>
        GreenFieldPosition  resb 1 <i>; bit position of LSB of green mask</i>
        BlueMaskSize        resb 1 <i>; size of direct color blue mask in bits</i>
        BlueFieldPosition   resb 1 <i>; bit position of LSB of blue mask</i>
        RsvdMaskSize        resb 1 <i>; size of direct color reserved mask in bits</i>
        DirectColorModeInfo resb 1 <i>; Direct Color mode attributes</i>
        Reserved2           resb 216 <i>; remainder of ModeInfoBlock</i>
</pre>

<p>Na počítači s&nbsp;kartou S3 Trio (nebo v&nbsp;DOSBoxu s&nbsp;emulací této
karty) se vypíšou tyto řádky:</p>

<pre>
Success
00000007
00000000
0000000064
0000000064
0000A000
00000000
</pre>

<p>Ty lze dekódovat takto:</p>

<pre>
Success     - volání služby bez chyby
00000007    - okno A je podporováno pro čtení i pro zápis
00000000    - okno B není podporováno
0000000064  - velikost okna je 64kB (jeden segment)
0000000064  - granularita okna B je 64kB (jeden segment)
0000A000    - segment pro okno A je A000, tedy standard EGA/VGA
00000000    - segment pro okno B není nastaven (stejně není podporováno)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý demonstrační příklad: nastavení grafického režimu</h2>

<p>V&nbsp;dnešním druhém demonstračním příkladu je ukázán způsob nastavení
grafického režimu. Ve skutečnosti se nejedná o nic těžkého. Pouze musíme
zavolat službu 02 a v&nbsp;registru <strong>BX</strong> jí předat číslo
požadovaného režimu. Opět platí, že v&nbsp;případě úspěšného provedení (režim
je podporován atd.) se v&nbsp;registru <strong>AX</strong> vrátí hodnota
0x004f. Nastavení grafického režimu 0x103 tedy může vypadat následovně:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zápis barev pixelů do video paměti v&nbsp;reálném režimu</h2>

<p>Ve chvíli, kdy jsme provedli přepnutí do zvoleného grafického režimu, již
lze modifikovat barvy jednotlivých pixelů. Postup je zdánlivě snadný: do okna A
je namapována nějaká oblast obrazové paměti (typicky její začátek) a máme tak
k&nbsp;dispozici 64 kB video RAM, ke které se přistupuje přes segment A000
(teoreticky se může jednat i o segment B000, ale většinou ne). Musíme tedy
zjistit, jaký je formát uložení pixelů a provést zápisy. Pokud je nutné
přistoupit do jiné oblasti obrazové paměti, musí se okno A posunout nad tuto
oblast (a opět platí &ndash; granularita bývá 64 kB, ale může být i 16 kB nebo
dokonce jen 4 kB). V&nbsp;dalších demonstračních příkladech si tyto možnosti
postupně ukážeme a budeme si budovat (tak, jako generace programátorů před
námi) jednoduchou knihovnu, která nás do jisté míry od rozdílů SVGA karet
odstíní.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí demonstrační příklad: vyplnění jednoho okna video paměti přes segment A000</h2>

<p>V&nbsp;dnešním třetím demonstračním příkladu nejprve provedeme přepnutí do
grafického režimu s&nbsp;rozlišením 800&times;600 pixelů s&nbsp;256 barvami.
V&nbsp;mém konkrétním případě má tento režim číslo 0x103 (ovšem může být i
odlišný). Následně &ndash; bez jakékoli manipulace s&nbsp;oknem, se provede
změna všech bajtů v&nbsp;segmentu A000, tj.&nbsp;v&nbsp;celém rozsahu 64 kB.
Program by tedy měl modifikovat celkem 65536 pixelů, což zhruba odpovídá
65536/800=81 obrazovým řádkům. Výsledek může vypadat takto:</p>

*** image ***
<p><i>Obrázek 1: Prvních 81 obrazových řádků vykreslených v&nbsp;grafickém režimu 800&times;600&times;256.</i></p>

<p>Zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
<strong>success</strong>:
        mov ax, 0xa000             <i>; video RAM v grafickem rezimu</i>
        mov es, ax
        mov di, 0                  <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 0                  <i>; pocet zapisovanych pixelu = 65536</i>
        mov al, 0                  <i>; kod pixelu</i>
opak:
        stosb                      <i>; zapis barvy pixelu</i>
        inc al                     <i>; dalsi pixel</i>
        loop opak                  <i>; opakujeme CX-krat</i>
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
section .bss
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Změna pozice okna pro zápis do jiné oblasti video paměti</h2>

<p>Samotný zápis do segmentu A000 pro nás není žádnou novinkou, ovšem ještě
musíme mít možnost provádět další operaci &ndash; posun okna (okna A) nad jinou
část obrazové paměti, aby se tato část namapovala právě do segmentu A000 (64
kB). Oknem nelze posunovat libovolně po jednotlivých bajtech, ale po celých
sekcích (bank). Krok posunu záleží na <i>granularitě</i> jejíž hodnotu jsme
přečetli. Typická hodnota granularity je 64kB, takže okno může nad celou
obrazovou pamětí &bdquo;poskakovat&ldquo; právě po celých 64 kB. Ovšem
granularita může být i nižší (vím o kartách s&nbsp;granularitou 4kB).</p>

<p>Pro posun okna se používá služba VBE číslo 0x05. Její volání vypadá
takto:</p>

<pre>
Vstup:  AH = 4Fh        Služby SVGA
        AL = 05h        Změna okna
        BH = 00h        Nastavení okna
        BH = 01h        Přečtení, které okno bylo nastaveno
        BL = 00h        Pro okno A
        BL = 01h        Pro okno B
        DX = ...        Hodnota banku, který se má nastavit pro vybrané okno
&nbsp;
Výstup: AL = 4Fh pokud je služba podporována, jinak odlišná hodnota
        AH = 00h pokud je volání úspěšné, jinak hodnota 01h
</pre>

<p>Zkráceně: pokud potřebujeme posunout okno A, bude volání vypadat
následovně:</p>

<pre>
mov ax, 0x4f05             <i>; sluzba pro nastaveni okna</i>
mov bx, 0x0000             <i>; okno A + jeho nastaveni</i>
int     0x10               <i>; volani VBE</i>
</pre>

<p>Což si můžeme přepsat do podoby subrutiny:</p>

<pre>
<strong>set_video_window</strong>:
        <i>; ocekava se, ze DL je nastaven korektne!</i>
        mov ax, 0x4f05             <i>; nastaveni okna</i>
        mov bx, 0x0000             <i>; okno A</i>
        int     0x10               <i>; volani VBE</i>
        ret                        <i>; navrat ze subrutiny</i>
</pre>

<p><div class="rs-tip-major">Poznámka: i tak je však volání pomalé. Existuje
ale ještě rychlejší způsob &ndash; přímé volání podprogramu VBE, což si taktéž
později ukážeme.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Čtvrtý demonstrační příklad: vyplnění obsahu lichých oken přes segment A000</h2>

<p>V&nbsp;dnešním čtvrtém demonstračním příkladu se nejprve přepneme do režimu
s&nbsp;rozlišením 800&times;600 pixelů a poté vyplníme liché banky obrazové
paměti. Pokud je granularita posunu okna nastavená na 64 kB, bude to znamenat,
že se vykreslí prvních zhruba 82 řádků (to známe), dalším 82/83 řádků zůstane
nezměněno, provede se vykreslení až následujících 82/83 obrazových řádků atd.
(optimisticky přitom počítáme s&nbsp;tím, že mezi řádky není žádná
&bdquo;výplň&ldquo;). Výsledek by mohl vypadat následovně:</p>

*** image ***
<p><i>Obrázek 2: Výsledek po vyplnění každého lichého banku obrazové paměti.</i></p>

<p><div class="rs-tip-major">Poznámka: takto bude vypadat výsledek je ve
chvíli, kdy mezi obrazovými řádky není žádná výplň a současně je granularita
posunu okna rovna 64 kB. Mnohé karty tyto požadavky nesplňují!</div></p>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x103             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
<strong>success</strong>:
        call fill_video_segment
&nbsp;
        mov  dx, 2
        call set_video_window
        call fill_video_segment
&nbsp;
        mov  dx, 4
        call set_video_window
        call fill_video_segment
&nbsp;
        mov  dx, 6
        call set_video_window
        call fill_video_segment
&nbsp;
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<strong>fill_video_segment</strong>:
        mov ax, 0xa000             <i>; video RAM v grafickem rezimu</i>
        mov es, ax
        mov di, 0                  <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 0                  <i>; pocet zapisovanych pixelu = 65536</i>
        mov al, 0                  <i>; kod pixelu</i>
opak:
        stosb                      <i>; zapis barvy pixelu</i>
        inc al                     <i>; dalsi pixel</i>
        loop opak                  <i>; opakujeme CX-krat</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<strong>set_video_window</strong>:
        <i>; ocekava se, ze DL je nastaven korektne!</i>
        mov ax, 0x4f05             <i>; nastaveni okna</i>
        mov bx, 0x0000             <i>; okno A</i>
        int     0x10               <i>; volani VBE</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
section .bss
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Uložení pixelů v&nbsp;grafických režimech se šestnácti miliony barev</h2>

<p>V&nbsp;režimech s&nbsp;256 barvami je každý pixel uložen v&nbsp;jednom
bajtu. A barva pixelu je přečtena z&nbsp;barvové palety naprosto stejným
způsobem, jako u karet VGA (s&nbsp;tím, že DAC je již osmibitový a nikoli jen
šestibitový). Ovšem jak je tomu v&nbsp;grafických režimech s&nbsp;vyšším počtem
barev? Tam je situace komplikovanější. Začneme &bdquo;plnobarevnými&ldquo;
režimy, tj.&nbsp;režimy se šestnácti miliony barev. V&nbsp;těchto režimech může
být pixel uložen ve třech nebo ve čtyřech bajtech (jeden bajt je výplňový),
ovšem navíc není zřejmé, v&nbsp;jakém pořadí jsou uloženy barvové složky RGB.
Může se například jednat o pořadí RGB, BGR popř.&nbsp;i jiné. A pokud přidáme
existenci výplňového bajtu, lze se v&nbsp;praxi setkat s&nbsp;uložením:</p>

<pre>
RGB
BGR
RGBx
xRGB
BGRx
xBGR
</pre>

<p><div class="rs-tip-major">Poznámka: teoreticky jsou možné i další
kombinace.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Uložení pixelů v&nbsp;grafických režimech s&nbsp;bitovou hloubkou 15 a 16</h2>

<p></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Informace o uložení pixelů</h2>

<p></p>

<pre>
Success
0000000640   XResolution
0000000480   YResolution
0000001280   BytesPerScanLine
0000000015   BitsPerPixel
0000000001   NumberOfPlanes
</pre>

<p></p>

<pre>
        RedMaskSize         resb 1 <i>; size of direct color red mask in bits</i>
        RedFieldPosition    resb 1 <i>; bit position of LSB of red mask</i>
        GreenMaskSize       resb 1 <i>; size of direct color green mask in bits</i>
        GreenFieldPosition  resb 1 <i>; bit position of LSB of green mask</i>
        BlueMaskSize        resb 1 <i>; size of direct color blue mask in bits</i>
        BlueFieldPosition   resb 1 <i>; bit position of LSB of blue mask</i>
        RsvdMaskSize        resb 1 <i>; size of direct color reserved mask in bits</i>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Pátý demonstrační příklad: formát uložení pixelů v&nbsp;režimech s&nbsp;bitovou hloubkou 15 a 16 bitů</h2>

<p></p>

<pre>
Success
0000000005
0000000010
0000000005
0000000005
0000000005
0000000000
0000000001
</pre>

<pre>
Success
0000000005
0000000011
0000000006
0000000005
0000000005
0000000000
0000000000
</pre>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
start:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
main:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        clc                        <i>; ziskani zakladnich informaci o grafickem rezimu</i>
        mov  di, graphics_mode_block_info
        mov  cx, 0x110             <i>; cislo rezimu: 640x480x15 bitu</i>
        mov  ax, 0x4f01
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
success:
        print_string success_msg
&nbsp;
        xor eax, eax
        mov al, [RedMaskSize]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [RedFieldPosition]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [GreenMaskSize]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [GreenFieldPosition]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [BlueMaskSize]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [BlueFieldPosition]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [RsvdMaskSize]
        print_dec_8
&nbsp;
        jmp     finish
&nbsp;
failed:
        print_string failed_msg
&nbsp;
finish:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
success_msg:     db "Success", 0x0a, 0x0d, "$"
failed_msg:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
section .bss
graphics_mode_block_info:
        ModeAttributes      resw 1 <i>; mode attributes</i>
        WinAAttributes      resb 1 <i>; window A attributes</i>
        WinBAttributes      resb 1 <i>; window B attributes</i>
        WinGranularity      resw 1 <i>; window granularity</i>
        WinSize             resw 1 <i>; window size</i>
        WinASegment         resw 1 <i>; window A start segment</i>
        WinBSegment         resw 1 <i>; window B start segment</i>
        WinFuncPtr          resd 1 <i>; pointer to windor function</i>
        BytesPerScanLine    resw 1 <i>; bytes per scan line</i>
&nbsp;
        XResolution         resw 1 <i>; horizontal resolution</i>
        YResolution         resw 1 <i>; vertical resolution</i>
        XCharSize           resb 1 <i>; character cell width</i>
        YCharSize           resb 1 <i>; character cell height</i>
        NumberOfPlanes      resb 1 <i>; number of memory planes</i>
        BitsPerPixel        resb 1 <i>; bits per pixel</i>
        NumberOfBanks       resb 1 <i>; number of banks</i>
        MemoryModel         resb 1 <i>; memory model type</i>
        BankSize            resb 1 <i>; bank size in kb</i>
        NumberOfImagePages  resb 1 <i>; number of images</i>
        Reserved1           resb 1 <i>; reserved for page function</i>
&nbsp;
        RedMaskSize         resb 1 <i>; size of direct color red mask in bits</i>
        RedFieldPosition    resb 1 <i>; bit position of LSB of red mask</i>
        GreenMaskSize       resb 1 <i>; size of direct color green mask in bits</i>
        GreenFieldPosition  resb 1 <i>; bit position of LSB of green mask</i>
        BlueMaskSize        resb 1 <i>; size of direct color blue mask in bits</i>
        BlueFieldPosition   resb 1 <i>; bit position of LSB of blue mask</i>
        RsvdMaskSize        resb 1 <i>; size of direct color reserved mask in bits</i>
        DirectColorModeInfo resb 1 <i>; Direct Color mode attributes</i>
        Reserved2           resb 216 <i>; remainder of ModeInfoBlock</i>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Šestý demonstrační příklad: formát uložení pixelů v&nbsp;režimu s&nbsp;24 nebo 32bitovou hloubkou</h2>

<pre>
Success
0000000008
0000000016
0000000008
0000000008
0000000008
0000000000
0000000008
</pre>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
start:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
main:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        clc                        <i>; ziskani zakladnich informaci o grafickem rezimu</i>
        mov  di, graphics_mode_block_info
        mov  cx, 0x112             <i>; cislo rezimu: 640x480x15 bitu</i>
        mov  ax, 0x4f01
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
success:
        print_string success_msg
&nbsp;
        xor eax, eax
        mov al, [RedMaskSize]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [RedFieldPosition]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [GreenMaskSize]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [GreenFieldPosition]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [BlueMaskSize]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [BlueFieldPosition]
        print_dec_8
&nbsp;
        xor eax, eax
        mov al, [RsvdMaskSize]
        print_dec_8
&nbsp;
        jmp     finish
&nbsp;
failed:
        print_string failed_msg
&nbsp;
finish:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
success_msg:     db "Success", 0x0a, 0x0d, "$"
failed_msg:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
section .bss
graphics_mode_block_info:
        ModeAttributes      resw 1 <i>; mode attributes</i>
        WinAAttributes      resb 1 <i>; window A attributes</i>
        WinBAttributes      resb 1 <i>; window B attributes</i>
        WinGranularity      resw 1 <i>; window granularity</i>
        WinSize             resw 1 <i>; window size</i>
        WinASegment         resw 1 <i>; window A start segment</i>
        WinBSegment         resw 1 <i>; window B start segment</i>
        WinFuncPtr          resd 1 <i>; pointer to windor function</i>
        BytesPerScanLine    resw 1 <i>; bytes per scan line</i>
&nbsp;
        XResolution         resw 1 <i>; horizontal resolution</i>
        YResolution         resw 1 <i>; vertical resolution</i>
        XCharSize           resb 1 <i>; character cell width</i>
        YCharSize           resb 1 <i>; character cell height</i>
        NumberOfPlanes      resb 1 <i>; number of memory planes</i>
        BitsPerPixel        resb 1 <i>; bits per pixel</i>
        NumberOfBanks       resb 1 <i>; number of banks</i>
        MemoryModel         resb 1 <i>; memory model type</i>
        BankSize            resb 1 <i>; bank size in kb</i>
        NumberOfImagePages  resb 1 <i>; number of images</i>
        Reserved1           resb 1 <i>; reserved for page function</i>
&nbsp;
        RedMaskSize         resb 1 <i>; size of direct color red mask in bits</i>
        RedFieldPosition    resb 1 <i>; bit position of LSB of red mask</i>
        GreenMaskSize       resb 1 <i>; size of direct color green mask in bits</i>
        GreenFieldPosition  resb 1 <i>; bit position of LSB of green mask</i>
        BlueMaskSize        resb 1 <i>; size of direct color blue mask in bits</i>
        BlueFieldPosition   resb 1 <i>; bit position of LSB of blue mask</i>
        RsvdMaskSize        resb 1 <i>; size of direct color reserved mask in bits</i>
        DirectColorModeInfo resb 1 <i>; Direct Color mode attributes</i>
        Reserved2           resb 216 <i>; remainder of ModeInfoBlock</i>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Ověření, že formát uložení pixelů odpovídá zjištěným informacím</h2>

<p></p>

*** image ***
<p><i>Obrázek 3: Výsledek po vyplnění každého lichého banku obrazové paměti;
v&nbsp;každém banku je nastavena jen jedna barvová složka.</i></p>

<p></p>

<pre>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
<strong>main</strong>:
        push ds
        pop  es                    <i>; nastaveni CS=DS=ES</i>
&nbsp;
        mov  bx, 0x112             <i>; cislo rezimu</i>
        mov  ax, 0x4f02            <i>; nastaveni grafickeho rezimu</i>
        int      0x10
&nbsp;
        cmp ax, 0x004f             <i>; test, zda bylo volani funkce BIOSu uspesne</i>
        jne     failed
&nbsp;
<strong>success</strong>:
        mov  di, 0                 <i>; posun v ramci segmentu A000</i>
        call fill_video_segment
&nbsp;
        mov  dx, 2
        call set_video_window
        mov  di, 1                 <i>; posun v ramci segmentu A000</i>
        call fill_video_segment
&nbsp;
        mov  dx, 4
        call set_video_window
        mov  di, 2                 <i>; posun v ramci segmentu A000</i>
        call fill_video_segment
&nbsp;
        mov  dx, 6
        call set_video_window
        mov  di, 3                 <i>; posun v ramci segmentu A000</i>
        call fill_video_segment
&nbsp;
&nbsp;
        jmp     finish
&nbsp;
<strong>failed</strong>:
        print_string failed_msg
&nbsp;
<strong>finish</strong>:
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<strong>fill_video_segment</strong>:
        mov ax, 0xa000             <i>; video RAM v grafickem rezimu</i>
        mov es, ax
        <i>;mov di, 0                  ; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 0                  <i>; pocet zapisovanych pixelu = 65536</i>
        mov al, 0                  <i>; kod pixelu</i>
<strong>opak</strong>:
        stosb                      <i>; zapis barvove slozky</i>
        add di, 3
        inc al                     <i>; dalsi barva (intenzita)</i>
        loop opak                  <i>; opakujeme CX-krat</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
<strong>set_video_window</strong>:
        <i>; ocekava se, ze DL je nastaven korektne!</i>
        mov ax, 0x4f05             <i>; nastaveni okna</i>
        mov bx, 0x0000             <i>; okno A</i>
        int     0x10               <i>; volani VBE</i>
        ret                        <i>; navrat ze subrutiny</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
<strong>success_msg</strong>:     db "Success", 0x0a, 0x0d, "$"
<strong>failed_msg</strong>:      db "Failed", 0x0a, 0x0d, "$"
&nbsp;
section .bss
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Univerzální rutina pro vykreslení pixelu?</h2>

<p>Z&nbsp;předchozího textu je zřejmé, že i přesto, že existoval standard VESA (a navíc i rozšíření BIOSu nazvané VBE), nebyla práce se SVGA kartami jednoduchá a i ty aplikace, které pracovaly v&nbsp;jediném grafickém režimu (řekněme 800&times;600&times;16 bitů), musely řešit různou granularitu oken, různé formáty pixelů atd. I z&nbsp;tohoto důvodu se většinou nesetkáme s&nbsp;univerzální subrutinou určenou pro vykreslování pixelů, která by byla dostatečně rychlá pro praktické použití. Většinou byly tyto subrutiny připravovány pro jednotlivé varianty rozlišení/formátu pixelů, což poněkud zvětšovaly knihovny používané různými softwarovými balíčky. Příště budeme postupovat podobným způsobem a pokusíme se vytvořit subrutinu pro vykreslení pixelu v&nbsp;několika různých grafických režimech.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (v&nbsp;současnosti již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>cga_text_mode_1.asm</td><td>standardní textový režim s&nbsp;rozlišením 40&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>VESA BIOS Extensions<br />
<a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions">https://en.wikipedia.org/wiki/VESA_BIOS_Extensions</a>
</li>

<li>Video Electronics Standards Association<br />
<a href="https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association">https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association</a>
</li>

<li>DJGPP (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/DJGPP">https://cs.wikipedia.org/wiki/DJGPP</a>
</li>

<li>DJGPP home page<br />
<a href="http://www.delorie.com/djgpp/">http://www.delorie.com/djgpp/</a>
</li>

<li>DJGPP Zip File Picker<br />
<a href="http://www.delorie.com/djgpp/zip-picker.html">http://www.delorie.com/djgpp/zip-picker.html</a>
</li>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

<li>Programmer's Guide to Yamaha YMF 262/OPL3 FM Music Synthesizer<br />
<a href="https://moddingwiki.shikadi.net/wiki/OPL_chip">https://moddingwiki.shikadi.net/wiki/OPL_chip</a>
</li>

<li>Does anybody understand how OPL2 percussion mode works?<br />
<a href="https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/">https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/</a>
</li>

<li>Yamaha YMF262 OPL3 music - MoonDriver for OPL3 DEMO [Oscilloscope View]<br />
<a href="https://www.youtube.com/watch?v=a7I-QmrkAak">https://www.youtube.com/watch?v=a7I-QmrkAak</a>
</li>

<li>Yamaha OPL vs OPL2 vs OPL3 comparison<br />
<a href="https://www.youtube.com/watch?v=5knetge5Gs0">https://www.youtube.com/watch?v=5knetge5Gs0</a>
</li>

<li>OPL3 Music Crockett's Theme<br />
<a href="https://www.youtube.com/watch?v=HXS008pkgSQ">https://www.youtube.com/watch?v=HXS008pkgSQ</a>
</li>

<li>Bad Apple (Adlib Tracker - OPL3)<br />
<a href="https://www.youtube.com/watch?v=2lEPH6Y3Luo">https://www.youtube.com/watch?v=2lEPH6Y3Luo</a>
</li>

<li>FM Synthesis Chips, Codecs and DACs<br />
<a href="https://www.dosdays.co.uk/topics/fm_synthesizers.php">https://www.dosdays.co.uk/topics/fm_synthesizers.php</a>
</li>

<li>The Zen Challenge - YMF262 OPL3 Original (For an upcoming game)<br />
<a href="https://www.youtube.com/watch?v=6JlFIFz1CFY">https://www.youtube.com/watch?v=6JlFIFz1CFY</a>
</li>

<li>[adlib tracker II techno music - opl3] orbit around alpha andromedae I<br />
<a href="https://www.youtube.com/watch?v=YqxJCu_WFuA">https://www.youtube.com/watch?v=YqxJCu_WFuA</a>
</li>

<li>[adlib tracker 2 music - opl3 techno] hybridisation process on procyon-ii<br />
<a href="https://www.youtube.com/watch?v=daSV5mN0sJ4">https://www.youtube.com/watch?v=daSV5mN0sJ4</a>
</li>

<li>Hyper Duel - Black Rain (YMF262 OPL3 Cover)<br />
<a href="https://www.youtube.com/watch?v=pu_mzRRq8Ho">https://www.youtube.com/watch?v=pu_mzRRq8Ho</a>
</li>

<li>IBM 5155-5160 Technical Reference<br />
<a href="https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf">https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf</a>
</li>

<li>a ymf262/opl3+pc speaker thing i made<br />
<a href="https://www.youtube.com/watch?v=E-Mx0lEmnZ0">https://www.youtube.com/watch?v=E-Mx0lEmnZ0</a>
</li>

<li>[OPL3] Like a Thunder<br />
<a href="https://www.youtube.com/watch?v=MHf06AGr8SU">https://www.youtube.com/watch?v=MHf06AGr8SU</a>
</li>

<li>(PC SPEAKER) bad apple<br />
<a href="https://www.youtube.com/watch?v=LezmKIIHyUg">https://www.youtube.com/watch?v=LezmKIIHyUg</a>
</li>

<li>Powering devices from PC parallel port<br />
<a href="http://www.epanorama.net/circuits/lptpower.html">http://www.epanorama.net/circuits/lptpower.html</a>
</li>

<li>Magic Mushroom (demo pro PC s DOSem)<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar">http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar</a>
</li>

<li>Píseň Magic Mushroom - originál<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3</a>
</li>

<li>Píseň Magic Mushroom - hráno na PC Speakeru<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3</a>
</li>

<li>Pulse Width Modulation (PWM) Simulation Example<br />
<a href="http://decibel.ni.com/content/docs/DOC-4599">http://decibel.ni.com/content/docs/DOC-4599</a>
</li>

<li>Resistor/Pulse Width Modulation DAC<br />
<a href="http://www.k9spud.com/traxmod/pwmdac.php">http://www.k9spud.com/traxmod/pwmdac.php</a>
</li>

<li>Class D Amplifier<br />
<a href="http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D">http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D</a>
</li>

<li>Covox Speech Thing / Disney Sound Source (1986)<br />
<a href="http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5">http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5</a>
</li>

<li>Covox Digital-Analog Converter (Rusky, obsahuje schémata)<br />
<a href="http://phantom.sannata.ru/konkurs/netskater002.shtml">http://phantom.sannata.ru/konkurs/netskater002.shtml</a>
</li>

<li>PC-GPE on the Web<br />
<a href="http://bespin.org/~qz/pc-gpe/">http://bespin.org/~qz/pc-gpe/</a>
</li>

<li>Keyboard Synthesizer<br />
<a href="http://www.solarnavigator.net/music/instruments/keyboards.htm">http://www.solarnavigator.net/music/instruments/keyboards.htm</a>
</li>

<li>FMS - Fully Modular Synthesizer<br />
<a href="http://fmsynth.sourceforge.net/">http://fmsynth.sourceforge.net/</a>
</li>

<li>Javasynth<br />
<a href="http://javasynth.sourceforge.net/">http://javasynth.sourceforge.net/</a>
</li>

<li>Software Sound Synthesis &amp; Music Composition Packages<br />
<a href="http://www.linux-sound.org/swss.html">http://www.linux-sound.org/swss.html</a>
</li>

<li>Mx44.1 Download Page (software synthesizer for linux)<br />
<a href="http://hem.passagen.se/ja_linux/">http://hem.passagen.se/ja_linux/</a>
</li>

<li>Software synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Software_synthesizer">http://en.wikipedia.org/wiki/Software_synthesizer</a>
</li>

<li>Frequency modulation synthesis<br />
<a href="http://en.wikipedia.org/wiki/Frequency_modulation_synthesis">http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</a>
</li>

<li>Yamaha DX7<br />
<a href="http://en.wikipedia.org/wiki/Yamaha_DX7">http://en.wikipedia.org/wiki/Yamaha_DX7</a>
</li>

<li>Wave of the Future<br />
<a href="http://www.wired.com/wired/archive/2.03/waveguides_pr.html">http://www.wired.com/wired/archive/2.03/waveguides_pr.html</a>
</li>

<li>Analog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Analog_synthesizer">http://en.wikipedia.org/wiki/Analog_synthesizer</a>
</li>

<li>Minimoog<br />
<a href="http://en.wikipedia.org/wiki/Minimoog">http://en.wikipedia.org/wiki/Minimoog</a>
</li>

<li>Moog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Moog_synthesizer">http://en.wikipedia.org/wiki/Moog_synthesizer</a>
</li>

<li>Tutorial for Frequency Modulation Synthesis<br />
<a href="http://www.sfu.ca/~truax/fmtut.html">http://www.sfu.ca/~truax/fmtut.html</a>
</li>

<li>An Introduction To FM<br />
<a href="http://ccrma.stanford.edu/software/snd/snd/fm.html">http://ccrma.stanford.edu/software/snd/snd/fm.html</a>
</li>

<li>John Chowning<br />
<a href="http://en.wikipedia.org/wiki/John_Chowning">http://en.wikipedia.org/wiki/John_Chowning</a>
</li>

<li>I'm Impressed, Adlib Music is AMAZING!<br />
<a href="https://www.youtube.com/watch?v=PJNjQYp1ras">https://www.youtube.com/watch?v=PJNjQYp1ras</a>
</li>

<li>Milinda- Diode Milliampere ( OPL3 )<br />
<a href="https://www.youtube.com/watch?v=oNhazT5HG0E">https://www.youtube.com/watch?v=oNhazT5HG0E</a>
</li>

<li>Dune 2 - Roland MT-32 Soundtrack <br />
<a href="https://www.youtube.com/watch?v=kQADZeB-z8M">https://www.youtube.com/watch?v=kQADZeB-z8M</a>
</li>

<li>Interrupts<br />
<a href="https://wiki.osdev.org/Interrupts#Types_of_Interrupts">https://wiki.osdev.org/Interrupts#Types_of_Interrupts</a>
</li>

<li>Assembly8086SoundBlasterDmaSingleCycleMode<br />
<a href="https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm">https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm</a>
</li>

<li>Interrupts in 8086 microprocessor<br />
<a href="https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/">https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/</a>
</li>

<li>Interrupt Structure of 8086<br />
<a href="https://www.eeeguide.com/interrupt-structure-of-8086/">https://www.eeeguide.com/interrupt-structure-of-8086/</a>
</li>

<li>A20 line<br />
<a href="https://en.wikipedia.org/wiki/A20_line">https://en.wikipedia.org/wiki/A20_line</a>
</li>

<li>Extended memory<br />
<a href="https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)">https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)</a>
</li>

<li>Expanded memory<br />
<a href="https://en.wikipedia.org/wiki/Expanded_memory">https://en.wikipedia.org/wiki/Expanded_memory</a>
</li>

<li>Protected mode<br />
<a href="https://en.wikipedia.org/wiki/Protected_mode">https://en.wikipedia.org/wiki/Protected_mode</a>
</li>

<li>Virtual 8086 mode<br />
<a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">https://en.wikipedia.org/wiki/Virtual_8086_mode</a>
</li>

<li>Unreal mode<br />
<a href="https://en.wikipedia.org/wiki/Unreal_mode">https://en.wikipedia.org/wiki/Unreal_mode</a>
</li>

<li>DOS memory management<br />
<a href="https://en.wikipedia.org/wiki/DOS_memory_management">https://en.wikipedia.org/wiki/DOS_memory_management</a>
</li>

<li>Upper memory area<br />
<a href="https://en.wikipedia.org/wiki/Upper_memory_area">https://en.wikipedia.org/wiki/Upper_memory_area</a>
</li>

<li>Removing the Mystery from SEGMENT : OFFSET Addressing<br />
<a href="https://thestarman.pcministry.com/asm/debug/Segments.html">https://thestarman.pcministry.com/asm/debug/Segments.html</a>
</li>

<li>Segment descriptor<br />
<a href="https://en.wikipedia.org/wiki/Segment_descriptor">https://en.wikipedia.org/wiki/Segment_descriptor</a>
</li>

<li>When using a 32-bit register to address memory in the real mode, contents of the register must never exceed 0000FFFFH. Why?<br />
<a href="https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the">https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the</a>
</li>

<li>A Brief History of Unreal Mode<br />
<a href="https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/">https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/</a>
</li>

<li>Segment Limits<br />
<a href="https://wiki.osdev.org/Segment_Limits">https://wiki.osdev.org/Segment_Limits</a>
</li>

<li>How do 32 bit addresses in real mode work?<br />
<a href="https://forum.osdev.org/viewtopic.php?t=30642">https://forum.osdev.org/viewtopic.php?t=30642</a>
</li>

<li>The LOADALL Instruction by Robert Collins<br />
<a href="https://www.rcollins.org/articles/loadall/tspec_a3_doc.html">https://www.rcollins.org/articles/loadall/tspec_a3_doc.html</a>
</li>

<li>How do you put a 286 in Protected Mode?<br />
<a href="https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode">https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode</a>
</li>

<li>Control register<br />
<a href="https://en.wikipedia.org/wiki/Control_register">https://en.wikipedia.org/wiki/Control_register</a>
</li>

<li>CPU Registers x86<br />
<a href="https://wiki.osdev.org/CPU_Registers_x86">https://wiki.osdev.org/CPU_Registers_x86</a>
</li>

<li>x86 Assembly/Protected Mode<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode">https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode</a>
</li>

<li>MSW: Machine Status Word<br />
<a href="https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html">https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html</a>
</li>

<li>80x87 Floating Point Opcodes<br />
<a href="http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html">http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html</a>
</li>

<li>Page Translation<br />
<a href="https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm">https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm</a>
</li>

<li>80386 Paging and Segmenation<br />
<a href="https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation">https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation</a>
</li>

<li>80386 Memory Management<br />
<a href="https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html">https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html</a>
</li>

<li>DOSEMU<br />
<a href="http://www.dosemu.org/">http://www.dosemu.org/</a>
</li>

<li>Intel 80386, a revolutionary CPU<br />
<a href="https://www.xtof.info/intel80386.html">https://www.xtof.info/intel80386.html</a>
</li>

<li>PAI Unit 3 Paging in 80386 Microporcessor<br />
<a href="https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor">https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor</a>
</li>

<li>64 Terabytes of virtual memory for 32-bit x86 using segmentation: how?<br />
<a href="https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how">https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how</a>
</li>

<li>Pi in the Pentium: reverse-engineering the constants in its floating-point unit<br />
<a href="http://www.righto.com/2025/01/pentium-floating-point-ROM.html">http://www.righto.com/2025/01/pentium-floating-point-ROM.html</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>8087 Numeric Data Processor<br />
<a href="https://www.eeeguide.com/8087-numeric-data-processor/">https://www.eeeguide.com/8087-numeric-data-processor/</a>
</li>

<li>Data Types and Instruction Set of 8087 co-processor<br />
<a href="https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/">https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/</a>
</li>

<li>8087 instruction set and examples<br />
<a href="https://studylib.net/doc/5625221/8087-instruction-set-and-examples">https://studylib.net/doc/5625221/8087-instruction-set-and-examples</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Grafické karty a grafické akcelerátory (14)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/</a>
</li>

<li>Grafické karty a grafické akcelerátory (15)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/</a>
</li>

<li>Grafické karty a grafické akcelerátory (16)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/</a>
</li>

<li>VESA Video Modes<br />
<a href="https://wiki.osdev.org/VESA_Video_Modes">https://wiki.osdev.org/VESA_Video_Modes</a>
</li>

<li>Introduction to VESA programming<br />
<a href="http://www.monstersoft.com/tutorial1/VESA_intro.html">http://www.monstersoft.com/tutorial1/VESA_intro.html</a>
</li>

<li>Guide: VBE 2.0 graphics modes<br />
<a href="https://delorie.com/djgpp/doc/ug/graphics/vbe20.html">https://delorie.com/djgpp/doc/ug/graphics/vbe20.html</a>
</li>

<li>NASM instruction list<br />
<a href="https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html">https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

