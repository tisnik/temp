<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Instrukční sada AArch64 (2.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Instrukční sada AArch64 (2.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku budeme pokračovat v popisu instrukční sady AArch64. Zmíníme se zejména o instrukcích matematického koprocesoru a taktéž o SIMD operacích umožňujících paralelní zpracování prvků vektorů. Na závěr si popíšeme způsob volání služeb jádra.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukční sada AArch64 (2.část)</a></p>
<p><a href="#k02">2. Načtení konstanty do FP registru</a></p>
<p><a href="#k03">3. Přenos operandů mezi registry</a></p>
<p><a href="#k04">4. Konverze mezi různými formáty</a></p>
<p><a href="#k05">5. Převod na celá čísla (zaokrouhlení)</a></p>
<p><a href="#k06">6. Základní aritmetické operace</a></p>
<p><a href="#k07">7. Porovnání operandů</a></p>
<p><a href="#k08">8. SIMD operace</a></p>
<p><a href="#k09">*** 9. Operace s&nbsp;prvky vektorů</a></p>
<p><a href="#k10">*** 10. Aritmetické operace s&nbsp;prvky uloženými ve vektorech</a></p>
<p><a href="#k11">11. Doplnění &ndash; problematika načítání konstant</a></p>
<p><a href="#k12">12. Volání služeb jádra (syscall) na procesorech AArch64</a></p>
<p><a href="#k13">13. Příklad programu volajícího službu jádra <strong>exit</strong></a></p>
<p><a href="#k14">14. Výsledná podoba binárního souboru s&nbsp;přeloženými instrukcemi</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukční sada AArch64 (2.část)</h2>

<p>Instrukce používané klasickou celočíselnou aritmeticko-logickou jednotkou
64bitových procesorů s&nbsp;architekturou AArch64 jsme si popsali minule, takže
se dnes zaměříme na matematický koprocesor a posléze i na &bdquo;vektorovou
jednotku&ldquo;. Připomeňme si, že u operací s&nbsp;plovoucí řádovou čárkou je
používána samostatná sada pracovních registrů pojmenovaných <strong>v0</strong>
až <strong>v31</strong> s&nbsp;šířkou celých 128 bitů (typ <i>quad</i>),
přičemž spodních 64 bitů a také 32 bitů lze využít pro operace s&nbsp;hodnotami
typu <i>single/float</i> a <i>double</i>:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>v0..v31</td><td>128bitové registry</td></tr>
<tr><td>d0..d31</td><td>spodních 64 bitů registrů v0..v31, použito pro hodnoty typu <i>double</i></td></tr>
<tr><td>s0..s31</td><td>spodních 32 bitů registrů v0..v31, použito pro hodnoty typu <i>single/float</i></td></tr>
</table>

<p>Seznam popsaných instrukcí se nám úspěšně rozšiřuje:</p>

<table>
<tr><th>Skupina</th><th>Další dělení</th></tr>
<tr><td>Load-Store</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k03">Load-Store pro jeden registr</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k04">Load-Store pro dvojici registrů</a></td></tr>
<tr><td>&nbsp;</td><td>Prefetch</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Skoky</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k05">Nepodmíněné skoky</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k05">Skoky do subrutiny</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k05">Nepodmíněný skok na adresu v&nbsp;registru</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k06">Podmíněné skoky</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ALU operace</td><td><a href="#k07">Základní aritmetické instrukce</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k08">Násobení a dělení</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k09">Logické instrukce</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k10">Znaménkové rozšíření operandu či rozšíření o nuly</a></td></tr>
<tr><td>Bitové operace</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k11">Bitové posuny</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k11">Aritmetické posuny</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k12">Podmíněné zpracování dat</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k13">Podmíněný výběr operandu</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k14">Další instrukce s&nbsp;podmínkou</a></td></tr>
<tr><td>&nbsp;</td><td><a href="https://www.root.cz/clanky/instrukcni-sada-aarch64#k15">Extrakce dat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FP operace</td><td><a href="#k02">Přenos operandů mezi registry</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k03">Načtení hodnoty do FP registru</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k04">Konverze mezi různými formáty</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k05">Převod na celá čísla (zaokrouhlení)</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k06">Základní aritmetické operace</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k06">Výpočet minima a maxima</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k06">MAC (Multiply Accumulate)</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#k07">Porovnání operandů</a></td></tr>
<tr><td>&nbsp;</td><td>Podmíněný výběr operandu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SIMD operace</td><td>Aritmetické operace se skaláry</td></tr>
<tr><td>&nbsp;</td><td>Aritmetické operace s&nbsp;vektory</td></tr>
<tr><td>&nbsp;</td><td>Permutace vektorů</td></tr>
<tr><td>&nbsp;</td><td>Konverze dat</td></tr>
<tr><td>&nbsp;</td><td>Instrukce z&nbsp;crypto extension (patří do SIMD)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Systémové instrukce</td><td>Zpracování výjimek</td></tr>
<tr><td>&nbsp;</td><td>Přístup k&nbsp;systémovým registrům</td></tr>
<tr><td>&nbsp;</td><td>Implementace bariér</td></tr>
<tr><td>&nbsp;</td><td>Instrukce pro jádro systému</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Načtení konstanty do FP registru</h2>

<p>Pro načtení konstanty typu <i>single/float</i> a <i>double</i> se používá
instrukce <strong>FMOV</strong>. Ovšem vzhledem k&nbsp;tomu, že jak instrukční
slovo, tak i konstanta mají dohromady pouhých 32 bitů, je zřejmé, že tímto
způsobem není možné načíst libovolné číslo, ale pouze hodnotu odpovídající
určitým pravidlům. Reprezentovatelná hodnota odpovídá výrazu
&pm;n&div;16&times;2<sup>r</sup>, kde <i>n</i> je celé číslo 16 &le; n &le; 31
a <i>r</i> je taktéž celé číslo -3 &le; r &le; 4. Tato čísla jsou
reprezentována čtyřmi resp.&nbsp;třemi bity, další bit slouží pro uložení
znaménka v&nbsp;instrukčním slovu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FMOV Sd, #fpimm</td><td>načtení konstanty typu <i>single/float</i></td></tr>
<tr><td>2</td><td>FMOV Dd, #fpimm</td><td>načtení konstanty typu <i>double</i></td></tr>
</table>

<p>Speciálním případem je načtení nuly, které se provede jednoduše &ndash;
použitím registrů <strong>XZR</strong> či <strong>WZR</strong>, které obsahují
nulu a konstanta nula (0,0) je ve formátu IEEE 754 taktéž reprezentována samými
nulovými bity.</p>

<p>Tento úryvek céčkového kódu:</p>

<pre>
float  x = 0.0;
double y = 0.0;
</pre>

<p>se přeloží následovně (jedná se o lokální proměnné ukládané na zásobníkový
rámec, tedy relativně vůči <strong>SP</strong>):</p>

<pre>
<i>// float x = 0.0</i>
str  wzr, [sp, 28]
&nbsp;
<i>// double y = 0.0</i>
str  xzr, [sp, 16]
</pre>

<p>Další instrukce slouží pro načtení operandu z&nbsp;paměti a pro uložení
operandů zpět do paměti. Tyto instrukce již známe, pouze došlo k&nbsp;jejich
rozšíření i pro použití s&nbsp;FP registry. Operace s&nbsp;jednotlivými bajty
se používají u vektorových operací. Samozřejmě nesmíme zapomenout ani na
instrukce pro načtení a uložení registrového páru:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>LDR Bt, adresa</td><td>načtení spodních osmi bitů</td></tr>
<tr><td>2</td><td>LDR Ht, adresa</td><td>načtení spodních šestnácti bitů</td></tr>
<tr><td>3</td><td>LDR St, adresa</td><td>načtení 32 bitů (float)</td></tr>
<tr><td>4</td><td>LDR Dt, adresa</td><td>načtení 64 bitů (double)</td></tr>
<tr><td>5</td><td>LDR Qt, adresa</td><td>načtení 128 bitů (quad)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>STR Bt, adresa</td><td>uložení spodních osmi bitů</td></tr>
<tr><td>7</td><td>STR Ht, adresa</td><td>uložení spodních šestnácti bitů</td></tr>
<tr><td>8</td><td>STR St, adresa</td><td>uložení 32 bitů (float)</td></tr>
<tr><td>9</td><td>STR Dt, adresa</td><td>uložení 64 bitů (double)</td></tr>
<tr><td>10</td><td>STR Qt, adresa</td><td>uložení 128 bitů (quad)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>LDP S1, S2, adresa</td><td>načtení registrového páru (single)</td></tr>
<tr><td>12</td><td>LDP D1, D2, adresa</td><td>načtení registrového páru (double)</td></tr>
<tr><td>13</td><td>LDP Q1, Q2, adresa</td><td>načtení registrového páru (quad)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>STP S1, S2, adresa</td><td>uložení registrového páru (single)</td></tr>
<tr><td>15</td><td>STP D1, D2, adresa</td><td>uložení registrového páru (double)</td></tr>
<tr><td>16</td><td>STP Q1, Q2, adresa</td><td>uložení registrového páru (quad)</td></tr>
</table>

<p>Podívejme se opět na použití. Následující fragment céčkového kódu
s&nbsp;inicializací čtyř lokálních proměnných:</p>

<pre>
float  x = 1.0;
float  y = 10.0;
float  z = 100.0;
float  w = 1000.0;
</pre>

<p>se přeloží takto:</p>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 12]
&nbsp;
<i>// float  y = 10.0;</i>
fmov    s0, 1.0e+1
str     s0, [sp, 8]
&nbsp;
<i>// float  z = 100.0;</i>
adrp    x0, .LC0
add     x0, x0, :lo12:.LC0
ldr     s0, [x0]
str     s0, [sp, 4]
&nbsp;
<i>// float  w = 1000.0;</i>
adrp    x0, .LC1
add     x0, x0, :lo12:.LC1
ldr     s0, [x0]
str     s0, [sp]
</pre>

<p>První proměnné lze načíst přímo instrukcí <strong>FMOV</strong> (konstanta
je součástí instrukce), další pouze nepřímo z&nbsp;operační paměti.</p>

<p>Konstanty uložené v&nbsp;operační paměti:</p>

<pre>
.LC0:
        .word   1120403456
.LC1:
        .word   1148846080
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Přenos operandů mezi registry</h2>

<p>Další skupina instrukcí sice taktéž používá mnemotechnickou zkratku
<strong>FMOV</strong>, ovšem neslouží k&nbsp;načtení konstanty, ale
k&nbsp;přenosu operandu mezi různými registry. Zajímavé je, že je možné
přenášet operandy mezi celočíselnými registry a FP registry; v&nbsp;takovém
případě se přenese bitový obraz uloženého čísla a neprovádí se žádné konverze
(zaokrouhlení atd.).  Poslední dvě instrukce jsou užitečné pro přenos 64 bitů
do nebo ze 128 bitového registru Vd:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FMOV Sd, Sn</td><td>přenos mezi registry (single)</td></tr>
<tr><td>2</td><td>FMOV Wd, Sn</td><td>přenos mezi registry (32bit integer, single)</td></tr>
<tr><td>3</td><td>FMOV Sd, Wn</td><td>přenos mezi registry (32bit integer, single)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>FMOV Dd, Dn</td><td>přenos mezi registry (double)</td></tr>
<tr><td>5</td><td>FMOV Xd, Dn</td><td>přenos mezi registry (integer, double)</td></tr>
<tr><td>6</td><td>FMOV Dd, Xn</td><td>přenos mezi registry (integer, double)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>FMOV Xd, Vn.D[1]</td><td>přenos 64 bitů Vn&lt;127:64&gt; &rarr; Xd</td></tr>
<tr><td>8</td><td>FMOV Vd.D[1], Xn</td><td>přenos 64 bitů Xn &rarr; Vd&lt;127:64&gt;, ostatní bity Vd se nezmení</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Konverze mezi různými formáty</h2>

<p>Pro konverzi hodnot mezi různými formáty (<i>half float</i>, <i>single</i>,
<i>double</i>) slouží instrukce nazvaná <strong>FCVT</strong> (<i>float
convert</i>). Některé převody lze provést bez problémů (neztratí se ani
přesnost ani rozsah), u dalších převodů buď ztratíme přesnost nebo bude hodnota
převedena na &infin; nebo -&infin;:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FCVT Sd, Hn</td><td>převod mezi formátem <i>half float</i> a <i>single</i> (bez ztráty)</td></tr>
<tr><td>2</td><td>FCVT Hd, Sn</td><td>převod mezi formátem <i>single</i> a <i>half float</i> (ztráta přesnosti)</td></tr>
<tr><td>3</td><td>FCVT Dd, Hn</td><td>převod mezi formátem <i>half float</i> a <i>double</i> (bez ztráty)</td></tr>
<tr><td>4</td><td>FCVT Hd, Dn</td><td>převod mezi formátem <i>double</i> a <i>half float</i> (ztráta přesnosti)</td></tr>
<tr><td>5</td><td>FCVT Dd, Sn</td><td>převod mezi formátem <i>single</i> a <i>double</i> (bez ztráty)</td></tr>
<tr><td>6</td><td>FCVT Sd, Dn</td><td>převod mezi formátem <i>double</i> a <i>single</i> (ztráta přesnosti)</td></tr>
</table>

<p>Opět se podívejme na příklad použití při konverzi mezi hodnotami lokálních
proměnných:</p>

<pre>
float  x = 1.0;
double y = 1.0;
double z = x;
float  w = y;
</pre>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 28]
&nbsp;
<i>// double y = 1.0;</i>
fmov    d0, 1.0e+0
str     d0, [sp, 16]
&nbsp;
<i>// double z = x;</i>
ldr     s0, [sp, 28]
fcvt    d0, s0
str     d0, [sp, 8]
&nbsp;
<i>// float  w = y;</i>
ldr     d0, [sp, 16]
fcvt    s0, d0
str     s0, [sp, 4]
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Převod na celá čísla (zaokrouhlení)</h2>

<p>Poměrně rozsáhlá skupina instrukcí slouží pro převod FP hodnot na celá
čísla. Podívejme se na tabulku:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FCVTAS</td><td>konverze FP na integer se znaménkem, zaokrouhlení směrem k&nbsp;nekonečnům</td></tr>
<tr><td>2</td><td>FCVTAU</td><td>dtto, ale konverze na unsigned integer</td></tr>
<tr><td>3</td><td>FCVTMS</td><td>konverze na signed integer se zaokrouhlením směrem k&nbsp;-&infin;</td></tr>
<tr><td>4</td><td>FCVTMU</td><td>konverze na unsigned integer se zaokrouhlením směrem k&nbsp;-&infin;</td></tr>
<tr><td>5</td><td>FCVTNS</td><td>konverze se zaokrouhlením na nejbližší sudé číslo</td></tr>
<tr><td>6</td><td>FCVTNU</td><td>dtto pro unsigned integer</td></tr>
<tr><td>7</td><td>FCVTPS</td><td>konverze na signed integer se zaokrouhlením směrem k&nbsp;+&infin;</td></tr>
<tr><td>8</td><td>FCVTPU</td><td>konverze na unsigned integer se zaokrouhlením směrem k&nbsp;+&infin;</td></tr>
<tr><td>9</td><td>FCVTZS</td><td>konverze na signed integer se zaokrouhlením směrem k&nbsp;nule</td></tr>
<tr><td>10</td><td>FCVTZU</td><td>konverze na unsigned integer se zaokrouhlením směrem k&nbsp;nule</td></tr>
<tr><td>11</td><td>SCVTF</td><td>zpětná konverze na FP hodnotu</td></tr>
<tr><td>12</td><td>UCVTF</td><td>zpětná konverze na FP hodnotu</td></tr>
</table>

<p>Instrukce <strong>FCVTNS</strong> a <strong>FCVTNU</strong> zaokrouhlují na
nejbližší sudé číslo ty hodnoty, které leží přesně v&nbsp;polovině intervalu
(1/2).</p>

<p>Nezapomeneme si samozřejmě ukázat, jak tyto instrukce používá překladač
v&nbsp;praxi:</p>

<pre>
float  x = 1.0;
double y = 2.0;
int    i = x;
int    j = y;
</pre>

<p>Způsob překladu do assembleru:</p>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 28]
&nbsp;
<i>// double y = 2.0;</i>
fmov    d0, 2.0e+0
str     d0, [sp, 16]
&nbsp;
<i>// int    i = x;</i>
ldr     s0, [sp, 28]
fcvtzs  w0, s0
str     w0, [sp, 12]
&nbsp;
<i>// int    j = y;</i>
ldr     d0, [sp, 16]
fcvtzs  w0, d0
str     w0, [sp, 8]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní aritmetické operace</h2>

<p>Poměrně rozsáhlá je skupina instrukcí určených pro provádění základních
aritmetických operací, k&nbsp;nimž navíc přidáváme instrukce pro výpočet
absolutní hodnoty, odmocniny, minima, maxima atd.:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FABS</td><td>výpočet absolutní hodnoty (jeden zdrojový operand)</td></tr>
<tr><td>2</td><td>FNEG</td><td>negace hodnoty (jeden zdrojový operand)</td></tr>
<tr><td>3</td><td>FSQRT</td><td>výpočet druhé odmocniny (jeden zdrojový operand)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>FADD</td><td>součet</td></tr>
<tr><td>5</td><td>FSUB</td><td>rozdíl</td></tr>
<tr><td>6</td><td>FMUL</td><td>součin</td></tr>
<tr><td>7</td><td>FNMUL</td><td>součin a následná změna znaménka výsledku</td></tr>
<tr><td>8</td><td>FDIV</td><td>podíl</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>FMIN</td><td>výpočet minima, pokud je jeden ze zdrojových operandů NaN, vrací NaN</td></tr>
<tr><td>10</td><td>FMAX</td><td>výpočet maxima, pokud je jeden ze zdrojových operandů NaN, vrací NaN</td></tr>
<tr><td>11</td><td>FMINNUM</td><td>výpočet minima, pokud je jeden ze zdrojových operandů NaN, vrací druhý operand</td></tr>
<tr><td>12</td><td>FMAXNUM</td><td>výpočet maxima, pokud je jeden ze zdrojových operandů NaN, vrací druhý operand</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>FMADD</td><td>(MAC) cíl = zdroj1 + zdroj2 &times; zdroj3</td></tr>
<tr><td>14</td><td>FMSUB</td><td>cíl = zdroj1 - zdroj2 &times; zdroj3</td></tr>
<tr><td>15</td><td>FNMADD</td><td>cíl = -zdroj1 + zdroj2 &times; zdroj3</td></tr>
<tr><td>16</td><td>FNMSUB</td><td>cíl = -zdroj1 - zdroj2 &times; zdroj3</td></tr>
</table>

<p>Opět se podívejme na příklad, tentokrát s&nbsp;poněkud složitějším
výpočtem:</p>

<pre>
float  x = 1.0;
float  y = 2.0;
float  z = 3.0;
float  w = x*y + y/z + fabs(z);
</pre>

<p>Tento příklad se (bez optimalizací) přeloží následovně:</p>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 12]
&nbsp;
<i>// float  y = 2.0;</i>
fmov    s0, 2.0e+0
str     s0, [sp, 8]
&nbsp;
<i>// float  w = x*y + y/z + fabs(z);</i>
fmov    s0, 3.0e+0
str     s0, [sp, 4]
&nbsp;
<i>// float  w = x*y + y/z + fabs(z);</i>
ldr     s1, [sp, 12]
ldr     s0, [sp, 8]
fmul    s1, s1, s0 <i>// x*y</i>
ldr     s2, [sp, 8]
ldr     s0, [sp, 4]
fdiv    s0, s2, s0 <i>// y/z</i>
fadd    s1, s1, s0
ldr     s0, [sp, 4]
fabs    s0, s0
fadd    s0, s1, s0
</pre>

<p>Kombinace aritmetické operace s&nbsp;konverzí výsledku:</p>

<pre>
float  x = 1.0;
double y = 1.0;
float  z = x+y;
</pre>

<p>Se může přeložit takto:</p>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 28]
&nbsp;
<i>// double y = 1.0;</i>
fmov    d0, 1.0e+0
str     d0, [sp, 16]
&nbsp;
<i>// float  z = x+y;</i>
ldr     s0, [sp, 28]
fcvt    d1, s0
ldr     d0, [sp, 16]
fadd    d0, d1, d0
fcvt    s0, d0
str     s0, [sp, 12]
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Porovnání operandů</h2>

<p>Instrukce, které slouží pro porovnání dvou FP registrů, nastavují příznakové
bity <strong>N</strong>, <strong>V</strong>, <strong>Z</strong> a
<strong>C</strong>. To znamená, že tyto instrukce je možné přímo zkombinovat
například s&nbsp;podmíněnými skoky:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FCMP</td><td>porovnání dvou operandů na rovnost, popř.&nbsp;porovnání s&nbsp;nulou</td></tr>
<tr><td>2</td><td>FCMPE</td><td>dtto, ovšem pokud je jeden z&nbsp;operandů NaN, dojde k&nbsp;výjimce</td></tr>
<tr><td>3</td><td>FCCMP</td><td>pokud je podmínka splněna, provede se porovnání, jinak se příznakové bity nastaví na určenou konstantu</td></tr>
<tr><td>4</td><td>FCCMPE</td><td>dtto ale s&nbsp;kontrolou operandů na NaN</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>FCSEL</td><td>obdoba CSEL, ovšem pro FP operandy (čtvrtým parametrem je podmínka)</td></tr>
</table>

<p>Podívejme se na jednoduchý příklad, opět využívající lokální proměnné
uložené na zásobníkovém rámci:</p>

<pre>
float  x = 1.0;
float  y = 10.0;
float  z = 20.0;
int i = x == y;
int j = x &lt; y;
int k = x &lt;= y;
int l = x != y;
int m = x &gt; y;
</pre>

<p>Způsob překladu neoptimalizujícím překladačem:</p>

<pre>
<i>float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 28]
&nbsp;
<i>// float  y = 10.0;</i>
fmov    s0, 1.0e+1
str     s0, [sp, 24]
&nbsp;
<i>// float  z = 20.0;</i>
fmov    s0, 2.0e+1
str     s0, [sp, 20]
&nbsp;
<i>// int i = x == y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmp    s1, s0
cset    w0, eq         <i>// testuje se příznakový bit Z (zero)</i>
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
str     w0, [sp, 16]
&nbsp;
<i>// int j = x &lt; y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmpe   s1, s0
cset    w0, mi
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
str     w0, [sp, 12]
&nbsp;
<i>// int k = x &lt;= y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmpe   s1, s0
cset    w0, ls
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
str     w0, [sp, 8]
&nbsp;
<i>// int l = x != y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmp    s1, s0
cset    w0, ne         <i>// testuje se příznakový bit Z (zero)</i>
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
str     w0, [sp, 4]
&nbsp;
<i>// int m = x &gt; y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmpe   s1, s0
cset    w0, gt
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. SIMD operace</h2>

<p>Pro SIMD operace, tj.&nbsp;operace pracující s&nbsp;krátkými vektory, se
128bitové registry <strong>Vn</strong> rozdělují takto:</p>

<table>
<tr><th>Tvar (shape)</th><th>Celkem</th><th>Pojmenování v&nbsp;assembleru</th></tr>
<tr><td>8b&times;8</td><td>64b</td><td>Vn.8B</td></tr>
<tr><td>8b&times;16</td><td>128b</td><td>Vn.16B</td></tr>
<tr><td>16b&times;4</td><td>64b</td><td>Vn.4H</td></tr>
<tr><td>16b&times;8</td><td>128b</td><td>Vn.8H</td></tr>
<tr><td>32b&times;2</td><td>64b</td><td>Vn.2S</td></tr>
<tr><td>32b&times;4</td><td>128b</td><td>Vn.4S</td></tr>
<tr><td>64b&times;1</td><td>64b</td><td>Vn.1D</td></tr>
<tr><td>64b&times;2</td><td>128b</td><td>Vn.2D</td></tr>
</table>

<p>U některých instrukcí se uvádí jak zdrojový a cílový vektor, tak i index
prvku vektoru. Zápis v&nbsp;assembleru potom může vypadat například takto:</p>

<pre>
DUP V1.8B, V2.8B, [5]
</pre>

<p>Poznámka: počet &bdquo;vektorových&ldquo; instrukcí je větší, než počet
všech zbývajících instrukcí (včetně instrukcí matematického koprocesoru), takže
si dnes budeme moci ukázat pouze malou skupinu vybraných operací. Navíc
překladače většinou &bdquo;vektorové&ldquo; instrukce přímo negenerují, pokud
samozřejmě ve zdrojových kódech nepoužijeme příslušné <i>intrinsic</i>
funkce.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Operace s&nbsp;prvky vektorů</h2>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>DUP</td><td>vybraný prvek zdrojového vektoru je rozkopírován do všech prvků vektoru cílového</td></tr>
<tr><td>2</td><td>DUP Vd.typ, Wn</td><td>speciální případ pro rozkopírování n-bitů celočíselného registru</td></tr>
<tr><td>3</td><td>DUP Vd.typ, Xn</td><td>speciální případ pro rozkopírování n-bitů celočíselného registru</td></tr>
<tr><td>4</td><td></td><td></td></tr>
<tr><td>5</td><td></td><td></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Aritmetické operace s&nbsp;prvky uloženými ve vektorech</h2>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td></td><td></td></tr>
<tr><td>2</td><td></td><td></td></tr>
<tr><td>3</td><td></td><td></td></tr>
<tr><td>4</td><td></td><td></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Doplnění &ndash; problematika načítání konstant</h2>

<p>Již několikrát jsme se zmínili o tom, že kvůli konstantní šířce všech
instrukcí může být problematické uložení konstanty do některého pracovního
registru. Problém je to logický a vlastně shodný pro prakticky všechny
&bdquo;klasické&ldquo; RISCové mikroprocesory: šířka pracovních registrů je 32
bitů a současně je šířka instrukcí taktéž 32 bitů, tudíž není možné, aby se
v&nbsp;instrukci vedle operačního kódu nacházela i 32 bitová konstanta. Tvůrci
dalších RISCových mikroprocesorů se s&nbsp;touto problematikou snažili
vypořádat různým způsobem, například zavedli speciální instrukci pro naplnění
horních šestnácti bitů registru, zatímco pro naplnění spodních šestnácti bitů
bylo možné použít například instrukci <strong>ADD</strong> s&nbsp;konstantou a
nulovým registrem <i>R0</i> (zhruba takovýmto způsobem je tato problematika
řešena na mikroprocesorech <i>MIPS</i>).</p>

<p>U procesorů AArch64 je možné pro načtení konstanty použít kombinace různých
instrukcí, typicky <strong>MOV</strong> a <strong>MOVK</strong> nebo
<strong>MOVN</strong> a <strong>MOVK</strong>. V&nbsp;praxi může překladač
postupovat následovně:</p>

<pre>
int a = 100;
int b = 1000;
int c = 10000;
int d = 100000;
int e = 1000000;
int f = 10000000;
</pre>

<p>Tato inicializace lokálních proměnných se přeloží takto:</p>

<pre>
<i>// int a = 100;</i>
mov     w0, 100
str     w0, [sp, 28]
&nbsp;
<i>// int b = 1000;</i>
mov     w0, 1000
str     w0, [sp, 24]
&nbsp;
<i>// int c = 10000;</i>
mov     w0, 10000
str     w0, [sp, 20]
&nbsp;
<i>// int d = 100000;</i>
mov     w0, 34464
movk    w0, 0x1, lsl 16
str     w0, [sp, 16]
&nbsp;
<i>// int e = 1000000;</i>
mov     w0, 16960
movk    w0, 0xf, lsl 16
str     w0, [sp, 12]
&nbsp;
<i>// int f = 10000000;</i>
mov     w0, 38528
movk    w0, 0x98, lsl 16
str     w0, [sp, 8]
</pre>

<p>Povšimněte si, že u instrukce <strong>MOVK</strong> se určuje, do kterého
místa cílového registru se konstanta načte (jinými slovy jak se konstanta
posune doleva).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Volání služeb jádra (syscall) na procesorech AArch64</h2>

<p>Volání služeb jádra Linuxu se na procesorech AArch64 hned v&nbsp;několika
ohledech odlišuje od původního způsobu volání, které známe z&nbsp;procesorů ARM
(dnes tedy ARM32). První změna je pochopitelná &ndash; při předávání
celočíselných argumentů se používají 64bitové registry <strong>x0</strong> až
<strong>x30</strong> a nikoli 32bitové registry <strong>r0</strong> až
<strong>r14</strong>. Druhá změna spočívá v&nbsp;tom, že samotné číslo syscallu
se ukládá do registru <strong>x8</strong> a nikoli do registru
<strong>r7</strong>. Tuto změnu si můžete poměrně snadno zapamatovat pomocí
mnemotechnické pomůcky, protože nejnovější 32bitová jádra mají architekturu
ARMv<strong>7</strong>-A zatímco 64bitová jádra ARMv<strong>8</strong>-A.
Kupodivu došlo i ke změně čísel syscallů, které jsou od původní 32bitové
architektury zcela odlišné. Nová čísla syscallů můžete najít například přímo
v&nbsp;hlavičkovém souboru Linuxu na adrese <a
href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příklad programu volajícího službu jádra <strong>exit</strong></h2>

<p>Pro zajímavost se podívejme, jak by vypadal program (pravděpodobně dokonce
nejjednodušší program vůbec), který po svém spuštění pouze zavolá službu jádra,
která program ukončí a předá volajícímu (rodičovskému) procesu návratový kód.
Celý program obsahuje pouze tři instrukce, přičemž první instrukce slouží pro
naplnění registru obsahujícího číslo služby jádra, druhá instrukce naplní
registr s&nbsp;návratovým kódem a třetí instrukce skutečně zavolá jádro
(<strong>svc</strong> znamená <i>supervisor call</i>). V&nbsp;GNU assembleru by
varianta určená pro 32bitové procesory ARM vypadala následovně:</p>

<pre>
# asmsyntax=as
&nbsp;
# Linux kernel system call
sys_exit=1
&nbsp;
&nbsp;
&nbsp;
.section .data
&nbsp;
.section .bss
&nbsp;
.section .text
        .global _start          @ tento symbol ma byt dostupny i z linkeru
&nbsp;
_start:
        mov   r7,$sys_exit      @ cislo sycallu pro funkci "exit"
        mov   r0,#0             @ exit code = 0
        svc   0                 @ volani Linuxoveho kernelu
</pre>

<p>Naproti tomu verze pro 64bitové procesory AArch 64 vypadá nepatrně
odlišně:</p>

<pre>
# asmsyntax=as
&nbsp;
# Linux kernel system call
sys_exit=93
&nbsp;
&nbsp;
&nbsp;
.section .data
&nbsp;
.section .bss
&nbsp;
.section .text
        .global _start          // tento symbol ma byt dostupny i z linkeru
&nbsp;
_start:
        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
</pre>

<p>Můžeme vidět, že změny se týkají použitých registrů a čísla syscallu. Po
překladu však získáme zcela odlišný binární soubor, protože se kódování
instrukcí mezi ARM32 a AArch64 zcela změnilo.</p>

<p>Překlad příkladu a jeho slinkování se provede standardním způsobem, tedy
s&nbsp;použitím nástrojů <strong>as</strong> (GNU Assembler &ndash; GAS) a
<strong>ld</strong> (GNU Linker):</p>

<pre>
as aarch64.s -o aarch64.o
ld -s aarch64.o
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výsledná podoba binárního souboru s&nbsp;přeloženými instrukcemi</h2>

<p>Pro zajímavost se podívejme na obsah vytvořeného spustitelného binárního
souboru <strong>a.out</strong>. Tento obsah získáme dalším nástrojem nazvaným
<strong>objdump</strong>:</p>

<pre>
objdump -f -d -t -h a.out
</pre>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x0000000000400078
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000000c  0000000000400078  0000000000400078  00000078  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
SYMBOL TABLE:
no symbols
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;.text&gt;:
  400078:       d2800ba8        mov     x8, #0x5d                       // #93
  40007c:       d2800000        mov     x0, #0x0                        // #0
  400080:       d4000001        svc     #0x0
</pre>

<p>Povšimněte si, že všechny instrukce mají skutečně konstantní šířku 32 bitů.
Navíc je zajímavé, že obě instrukce <strong>mov</strong> pracují se skutečnými
konstantami uloženými přímo v&nbsp;instrukčním slovu (což je ovšem možné jen
pro určité konstanty, typicky pro malá kladná i záporná čísla).</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>GNU Binutils<br />
<a href="https://www.gnu.org/software/binutils/">https://www.gnu.org/software/binutils/</a>
</li>

<li>GNU Assembler<br />
<a href="https://en.wikipedia.org/wiki/GNU_Assembler">https://en.wikipedia.org/wiki/GNU_Assembler</a>
</li>

<li>Exploring AArch64 assembler – Chapter 1<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/</a>
</li>

<li>Exploring AArch64 assembler – Chapter 2<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/</a>
</li>

<li>Aarch64 Register and Instruction Quick Start<br />
<a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>A64 General Instructions<br />
<a href="http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm">http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm</a>
</li>

<li>ARMv8 (AArch64) Instruction Encoding<br />
<a href="http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html">http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

