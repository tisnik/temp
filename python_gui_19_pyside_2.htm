<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Tvorba GUI v Pythonu s využitím frameworku PySide: signály a sloty, správci rozložení komponent</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Tvorba GUI v Pythonu s využitím frameworku PySide: signály a sloty, správci rozložení komponent</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o tvorbě aplikací s grafickým uživatelským rozhraním v Pythonu budeme pokračovat v popisu knihovny PySide. Nejdříve si ukážeme práci se signály a sloty a posléze si popíšeme tři základní správce rozložení komponent.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Tvorba GUI v Pythonu s&nbsp;využitím frameworku PySide: signály a sloty, správci rozložení komponent</a></p>
<p><a href="#k02">2. Navázání signálu s&nbsp;využitím funkce <strong>QtCore.QObject.connect</strong></a></p>
<p><a href="#k03">3. Navázání signálu s&nbsp;využitím metody <strong>QtGui.QAbstractButton.clicked</strong></a></p>
<p><a href="#k04">4. Použití dekorátoru u slotu, zavolání metody namísto funkce při příjmu signálu</a></p>
<p><a href="#k05">5. Umístění většího množství tlačítek do okna</a></p>
<p><a href="#k06">6. Absolutní pozicování ovládacích prvků</a></p>
<p><a href="#k07">7. Správci rozložení ovládacích prvků v&nbsp;kontejneru</a></p>
<p><a href="#k08">8. Správce rozložení <strong>QHBoxLayout</strong></a></p>
<p><a href="#k09">9. Ukázka použití správce rozložení <strong>QHBoxLayout</strong></a></p>
<p><a href="#k10">10. Vložení pružných mezer mezi ovládací prvky</a></p>
<p><a href="#k11">11. Správce rozložení <strong>QVBoxLayout</strong></a></p>
<p><a href="#k12">12. Ukázka použití správce rozložení <strong>QVBoxLayout</strong></a></p>
<p><a href="#k13">13. Správce rozložení <strong>QGridLayout</strong></a></p>
<p><a href="#k14">14. Ukázka použití správce rozložení <strong>QGridLayout</strong></a></p>
<p><a href="#k15">15. Komponenty umístěné do mřížky přes větší množství řádků či sloupců</a></p>
<p><a href="#k16">16. Horizontální a vertikální zarovnání komponent v&nbsp;mřížce</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Tvorba GUI v Pythonu s&nbsp;využitím frameworku PySide: signály a sloty, správci rozložení komponent</h2>

<p>V&nbsp;první části dnešního článku se budeme zabývat způsobem práce
s&nbsp;takzvanými <i>signály</i> a <i>sloty</i>. V&nbsp;knihovně <i>PySide</i>
může každý ovládací prvek (widget) generovat signály, a to konkrétně
v&nbsp;případě vzniku nějaké události (tou může být například stisk tlačítka,
změna pozice posuvníku, změna velikosti okna atd.) nebo změny stavu widgetu.
Signály mohou být napojené na takzvané <i>sloty</i>, což je pojmenování pro
funkce, které mohou reagovat na příchozí signál. V&nbsp;knihovně Qt, nad níž je
PySide postaven, jsou signály zpracovávány nativními funkcemi, PySide ovšem
celý koncept signálů a slotů dokáže &bdquo;obalit&ldquo; takovým způsobem, že
sloty jsou běžnými Pythonovskými funkcemi či metodami. Musíme však explicitně
specifikovat propojení mezi signálem (resp.&nbsp;jeho typem) a slotem. To lze
zajistit dvěma způsoby popsanými v&nbsp;navazujících kapitolách.</p>

<p>Poznámka: ve skutečnosti se signály a sloty nepoužívají pouze pro práci
s&nbsp;GUI, ale jedná se o univerzálnější koncept, který je v&nbsp;PySide
používaný i pro další činnosti.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Navázání signálu s&nbsp;využitím funkce <strong>QtCore.QObject.connect</strong></h2>

<p>První způsob navázání signálu na slot používá funkci
<strong>QtCore.QObject.connect</strong>. Této funkci se předávají tři
parametry, které přesně specifikují propojení mezi signálem vyslaným určitým
widgetem se slotem:</p>

<table>
<tr><th>Parametr</th><th>Význam parametru</th></tr>
<tr><td>sender</td><td>widget, který bude signál vysílat (například tlačítko)</td></tr>
<tr><td>signal</td><td>přesná specifikace typu signálu</td></tr>
<tr><td>method</td><td>metoda nebo funkce, která bude zavolána při přijetí signálu</td></tr>
</table>

<p>Význam prvního i třetího parametru je zřejmý, ještě si však musíme
vysvětlit, jakým způsobem se získá typ signálu. Pro tento účel se používá
funkce <strong>QtCore.SIGNAL</strong>, která dokáže převést název signálu
reprezentovaný textovým řetězcem do formátu akceptovatelného funkcí
<strong>QtCore.QObject.connect</strong>. Pokud tedy budeme chtít, aby se po
stisku tlačítka reprezentovatelného objektem <strong>button</strong> zavolala
metoda <strong>closeApplication</strong>, provedeme to následovně:</p>

<pre>
QtCore.QObject.connect(button, QtCore.SIGNAL('clicked()'), closeApplication)
</pre>

<p>Nám již známý příklad z&nbsp;předchozího článku, v&nbsp;němž je vytvořeno
okno s&nbsp;jediným tlačítkem, nyní upravíme tak, aby stisk tlačítka aplikaci
ukončil. Nejdříve vytvoříme funkci, která bude reagovat na signál:</p>

<pre>
def closeApplication():
    print("Closing...")
    sys.exit(0)
</pre>

<p>Dále vytvoříme tlačítko, nastavíme jeho vlastnosti a nakonfigurujeme
příjemce signálu vyslaného po stisku tlačítka:</p>

<pre>
# tlačítko
button = QtGui.QPushButton("Quit", self)
button.resize(button.sizeHint())
button.setToolTip("Immediately quit this application")
&nbsp;
# starý způsob navázání signálu, který není příliš Python-friendly
QtCore.QObject.connect(button, QtCore.SIGNAL ('clicked()'), closeApplication)
</pre>

<img src="https://i.iinfo.cz/images/488/pyside2-1.png" class="image-313946" alt="&#160;" height="267" width="322" />
<p><i>Obrázek 1: Tlačítko umístěné v&nbsp;oknu dnešního prvního demonstračního
příkladu.</i></p>

<p>Úplný zdrojový kód příkladu bude vypadat následovně:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
<strong># callback funkce</strong>
<strong>def closeApplication():</strong>
    <strong>print("Closing...")</strong>
    <strong>sys.exit(0)</strong>
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        <strong># tlačítko</strong>
        <strong>button = QtGui.QPushButton("Quit", self)</strong>
        <strong>button.resize(button.sizeHint())</strong>
        <strong>button.setToolTip("Immediately quit this application")</strong>
&nbsp;
        <strong># starý způsob navázání signálu, který není příliš Python-friendly</strong>
        <strong>QtCore.QObject.connect(button, QtCore.SIGNAL ('clicked()'), closeApplication)</strong>
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Navázání signálu s&nbsp;využitím metody <strong>QtGui.QAbstractButton.clicked</strong></h2>

<p>Volání funkce <strong>QtCore.QObject.connect</strong> sice velmi přesně
reflektuje způsob, jakým se signály a sloty konfigurují v&nbsp;knihovně Qt a
v&nbsp;jazyku C++, ovšem v&nbsp;PySide můžeme použít i přímočařejší a
z&nbsp;hlediska zápisu kratší způsob. Konkrétně u tlačítek, tedy u widgetů typu
<strong>QPushButton</strong>, můžeme použít trojici metod pro registraci
příjemce příslušného signálu:</p>

<table>
<tr><th>Metoda</th><th>Stručný popis</th></tr>
<tr><td>QPushButton.clicked()</td><td>kliknutí na tlačítko či stisk mezerníku, pokud má tlačítko fokus</td></tr>
<tr><td>QPushButton.pressed()</td><td>stisk tlačítka (používáno méně často)</td></tr>
<tr><td>QPushButton.released()</td><td>puštění tlačítka (opět používáno méně často)</td></tr>
</table>

<p>Pokud konfigurujeme signál vyslaný po stisku widgetu představovaného
objektem <strong>button</strong>, můžeme namísto volání:</p>

<pre>
QtCore.QObject.connect(button, QtCore.SIGNAL('clicked()'), closeApplication)
</pre>

<p>použít kratší a přehlednější zápis:</p>

<pre>
button.clicked.connect(closeApplication)
</pre>

<p>Opět se podívejme, jak bude příklad upraven. Jedná se vlastně o změnu
jediného řádku:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# callback funkce
def closeApplication():
    print("Closing...")
    sys.exit(0)
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítko
        button = QtGui.QPushButton("Quit", self)
        button.resize(button.sizeHint())
        button.setToolTip("Immediately quit this application")
&nbsp;
        # navázání akce na signál
        <strong>button.clicked.connect(closeApplication)</strong>
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Použití dekorátoru u slotu, zavolání metody namísto funkce při příjmu signálu</h2>

<p>Často se také setkáme s&nbsp;tím, že příjemce signálu, tj.&nbsp;funkce
vystupující v&nbsp;roli slotu, je označen dekorátorem. Může to vypadat
takto:</p>

<pre>
# callback funkce
<strong>@QtCore.Slot()</strong>
def closeApplication():
    print("Closing...")
    sys.exit(0)
</pre>

<p>Zde sice není použití dekorátoru nutné, ovšem obecně jejich využití vede
k&nbsp;menší spotřebě operační paměti a k&nbsp;nepatrně rychlejšímu běhu
aplikace. V&nbsp;dalších příkladech prozatím tento dekorátor používat nebudeme,
ale ještě se k&nbsp;jeho funkci vrátíme ve chvíli, kdy si budeme ukazovat
způsob vytvoření vlastního nového typu signálu.</p>

<p>Dále si ukažme, že příjemcem signálu nemusí být jen funkce, ale i metoda,
což je ostatně užitečnější. Namísto registrace funkce:</p>

<pre>
button.clicked.connect(closeApplication)
</pre>

<p>můžeme zaregistrovat metodu:</p>

<pre>
button.clicked.connect(self.quit)
</pre>

<p>Tato metoda musí mít hlavičku:</p>

<pre>
def quit(self):
</pre>

<p>Samozřejmě i zde lze přidat dekorátor:</p>

<pre>
@QtCore.Slot()
def quit(self):
</pre>

<p>Pokud metoda nepřistupuje k&nbsp;atributům objektu, může být statická
(nepředává se jí <strong>self</strong>):</p>

<pre>
button.clicked.connect(MainWindow.quit)
&nbsp;
    @QtCore.Slot()
    @staticmethod
    def quit():
        print("Closing...")
</pre>

<p>V&nbsp;dalším příkladu již používáme korektní způsob ukončení aplikace
v&nbsp;metodě <strong>MainWindow.quit</strong>:</p>

<pre>
def quit(self):
    print("Closing...")
    self.close()
</pre>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítko
        button = QtGui.QPushButton("Quit", self)
        button.resize(button.sizeHint())
        button.setToolTip("Immediately quit this application")
&nbsp;
        # navázání akce na signál
        <strong>button.clicked.connect(self.quit)</strong>
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    <strong>@QtCore.Slot()</strong>
    <strong>def quit(self):</strong>
        <strong>print("Closing...")</strong>
        <strong>self.close()</strong>
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Umístění většího množství tlačítek do okna</h2>

<p>Ve druhé části dnešního článku se budeme zabývat tím, jak se vlastně
jednotlivé ovládací prvky (widgety) umisťují do okna či do dalšího kontejneru.
Tento problém je nutné vyřešit u všech aplikací, v&nbsp;nichž se nachází okna a
dialogy s&nbsp;více než jedním widgetem. Abychom si ukázali, že se jedná o
důležité téma, nebudeme se v&nbsp;dalším příkladu o umístění komponent do
hlavního okna nijak starat a budeme jen pozorovat, jaké je implicitní chování.
Vytvoříme pět tlačítek a umístíme je do hlavního okna:</p>

<pre>
# tlačítka
button1 = QtGui.QPushButton("One", self)
button2 = QtGui.QPushButton("Two", self)
button3 = QtGui.QPushButton("Three", self)
button4 = QtGui.QPushButton("Four", self)
button5 = QtGui.QPushButton("Five", self)
</pre>

<p>Výsledek po spuštění bude vypadat následovně &ndash; všechna tlačítka jsou
zobrazena na stejném místě, konkrétně v&nbsp;levém horním rohu hlavního
okna:</p>

<img src="https://i.iinfo.cz/images/488/pyside2-2.png" class="image-313947" alt="&#160;" height="267" width="322" />
<p><i>Obrázek 2: Všechna tlačítka se vměstnala na stejné místo v&nbsp;hlavním
oknu, konkrétně do levého horního rohu.</i></p>

<p>Zdrojový kód příkladu, v&nbsp;němž se do hlavního okna vykreslí pět tlačítek
(na stejném místě) vypadá takto:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        <strong># tlačítka</strong>
        <strong>button1 = QtGui.QPushButton("One", self)</strong>
        <strong>button2 = QtGui.QPushButton("Two", self)</strong>
        <strong>button3 = QtGui.QPushButton("Three", self)</strong>
        <strong>button4 = QtGui.QPushButton("Four", self)</strong>
        <strong>button5 = QtGui.QPushButton("Five", self)</strong>
&nbsp;
        # navázání akce na signál
        button1.clicked.connect(self.quit)
        button2.clicked.connect(self.quit)
        button3.clicked.connect(self.quit)
        button4.clicked.connect(self.quit)
        button5.clicked.connect(self.quit)
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    def quit(self):
        print("Closing...")
        self.close()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>

<p>Mimochodem: povšimněte si, že všechna tlačítka mají signály navázané na
shodnou callback funkci:</p>

<pre>
# navázání akce na signál
button1.clicked.connect(self.quit)
button2.clicked.connect(self.quit)
button3.clicked.connect(self.quit)
button4.clicked.connect(self.quit)
button5.clicked.connect(self.quit)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Absolutní pozicování ovládacích prvků</h2>

<p>Jednou z&nbsp;možností rozmístění ovládacích prvků (widgetů) na ploše okna
je použití tzv.&nbsp;absolutního pozicování. To jistě znají pamětníci RAD
nástrojů typu Delphi či Visual Basic. Při použití absolutního pozicování se
explicitně specifikují pozice a rozměry každého widgetu, nezávisle na widgetech
ostatních a taktéž nezávisle na rozlišení, globálního nastavení velikosti
fontů, rozměrů okna či dialogu atd. Tento způsob rozmístění widgetů může být
dosti problematický zejména ve chvíli, kdy je aplikace provozována na počítači
s&nbsp;jinak nastaveným prostředím (stačí se jen přepnout do režimu pro
slabozraké atd.). Ovšem pro úplnost si ukažme, jak je možné absolutního
pozicování docílit. Není to nic složitého, protože každý widget podporuje
metodu <a
href="https://pyside.github.io/docs/pyside/PySide/QtGui/QWidget.html#PySide.QtGui.PySide.QtGui.QWidget.move">move</a>,
které se předává dvojice souřadnic [x,y] platných v&nbsp;rámci lokálního
souřadného systému okna.</p>

<p>Ukažme si nyní, jak se přesunou čtyři tlačítka z&nbsp;naší pětice tak, aby
si navzájem nepřekážela. Je to snadné:</p>

<pre>
# přesun tlačítek na absolutní pozice
button2.move(30, 30)
button3.move(60, 60)
button4.move(90, 90)
button5.move(120, 120)
</pre>

<p>Výsledek naší snahy je vidět na dalším screenshotu:</p>

<img src="https://i.iinfo.cz/images/488/pyside2-3.png" class="image-313948" alt="&#160;" height="267" width="322" />
<p><i>Obrázek 3: Čtyři tlačítka (z&nbsp;pěti) byla přemístěna na absolutní
souřadnice.</i></p>

<p>Opět si ukažme úplný zdrojový kód takto upraveného demonstračního příkladu
s&nbsp;vyznačením provedených změn:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítka
        button1 = QtGui.QPushButton("One", self)
        button2 = QtGui.QPushButton("Two", self)
        button3 = QtGui.QPushButton("Three", self)
        button4 = QtGui.QPushButton("Four", self)
        button5 = QtGui.QPushButton("Five", self)
&nbsp;
        <strong># přesun tlačítek na absolutní pozice</strong>
        <strong>button2.move(30, 30)</strong>
        <strong>button3.move(60, 60)</strong>
        <strong>button4.move(90, 90)</strong>
        <strong>button5.move(120, 120)</strong>
&nbsp;
        # navázání akce na signál
        button1.clicked.connect(self.quit)
        button2.clicked.connect(self.quit)
        button3.clicked.connect(self.quit)
        button4.clicked.connect(self.quit)
        button5.clicked.connect(self.quit)
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    def quit(self):
        print("Closing...")
        self.close()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Správci rozložení ovládacích prvků v&nbsp;kontejneru</h2>

<p>U většiny aplikací je vhodnější namísto absolutního pozicování jednotlivých
ovládacích prvků použít již připravené <i>správce rozložení (layout
manager)</i>, kteří se sami starají o umístění komponent na základě jejich
vzájemných vztahů. Při použití knihovny PySide si můžeme vybrat hned
z&nbsp;několika typů správců, popř.&nbsp;lze správce kombinovat, a to díky
tomu, že do okna je možné vložit další komponentu ve funkci kontejneru pro
další komponenty. Seznam správců rozložení podporovaných knihovnou PySide
naleznete v&nbsp;další tabulce:</p>

<table>
<tr><th>Správce rozložení</th></tr>
<tr><td><a href="#k08">QHBoxLayout</a></td></tr>
<tr><td><a href="#k11">QVBoxLayout</a></td></tr>
<tr><td><a href="#k13">QGridLayout</a></td></tr>
<tr><td>QStackedLayout</td></tr>
<tr><td>QFormLayout</td></tr>
</table>

<p>V&nbsp;dalších kapitolách si popíšeme první tři správce,
tj.&nbsp;<strong>QHBoxLayout</strong>, <strong>QVBoxLayout</strong> a
<strong>QGridLayout</strong>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Správce rozložení <strong>QHBoxLayout</strong></h2>

<p>Velmi jednoduchým správcem rozložení komponent v&nbsp;okně/dialogu je
<strong>QHBoxLayout</strong>, který zajišťuje, že se jednotlivé ovládací prvky
uspořádají horizontálně za sebe do jedné řady (v&nbsp;našich podmínkách zleva
doprava). Komponenty se při použití tohoto správce přidávají metodou
<strong>addWidget</strong>, které se v&nbsp;nejjednodušším případě pouze předá
reference na přidávaný widget. Podívejme se nyní na způsob použití tohoto
správce.</p>

<p>Nejprve vytvoříme novou instanci správce <strong>QHBoxLayout</strong>:</p>

<pre>
layout = QtGui.QHBoxLayout()
</pre>

<p>Následně již můžeme začít přidávat jednotlivé widgety, přičemž první widget
bude umístěn zcela vlevo, další napravo od něj atd. atd.:</p>

<pre>
layout.addWidget(button1)
layout.addWidget(button2)
layout.addWidget(button3)
layout.addWidget(button4)
layout.addWidget(button5)
</pre>

<p>Následně nesmíme zapomenout oznámit hlavnímu oknu, že má použít právě
vytvořený a nakonfigurovaný správce rozložení. Pokud na tento krok zapomeneme,
komponenty se nevykreslí!</p>

<pre>
self.setLayout(layout)
</pre>

<p>Použití je tedy velmi podobné správci geometrie <strong>pack</strong>
z&nbsp;knihovny Tkinter.</p>

<img src="https://i.iinfo.cz/images/488/pyside2-4.png" class="image-313949" alt="&#160;" height="267" width="473" />
<p><i>Obrázek 4: Pětice tlačítek umístěných do okna s&nbsp;využitím
<strong>QHBoxLayout</strong>.</i></p>

<p>Do metody <strong>QHBoxLayout.addWidget</strong> lze předat i další dva
nepovinné parametry nazvané <strong>stretch</strong> a
<strong>alignment</strong>. Parametr <strong>stretch</strong> je celočíselný a
slouží k&nbsp;řízení míry rozpínání widgetů v&nbsp;okně či dialogu, pokud se
mění jeho velikost. Implicitní hodnotou je nula. Parametr
<strong>alignment</strong> je možné využít ke specifikaci zarovnání ovládacích
prvků (v&nbsp;rámci jednoho řádku):</p>

<table>
<tr><th>Hodnota <strong>alignment</strong></th><th>Význam</th></tr>
<tr><td>QtCore.Qt.AlignTop</td><td>zarovnání widgetu nahoru</td></tr>
<tr><td>QtCore.Qt.AlignBottom</td><td>zarovnání widgetu dolů</td></tr>
<tr><td>QtCore.Qt.AlignVCenter</td><td>vertikální vycentrování widgetu</td></tr>
<tr><td>QtCore.Qt.AlignCenter</td><td>vycentrování widgetu ve vertikálním i horizontálním směru</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Ukázka použití správce rozložení <strong>QHBoxLayout</strong></h2>

<p>Podívejme se nyní, jak je možné správce rozložení
<strong>QHBoxLayout</strong> použít v&nbsp;praktickém příkladu:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítka
        button1 = QtGui.QPushButton("One")
        button2 = QtGui.QPushButton("Two")
        button3 = QtGui.QPushButton("Three")
        button4 = QtGui.QPushButton("Four")
        button5 = QtGui.QPushButton("Five")
&nbsp;
        <strong># vytvoření správce geometrie a umístění widgetů</strong>
        <strong>layout = QtGui.QHBoxLayout()</strong>
        <strong>layout.addWidget(button1)</strong>
        <strong>layout.addWidget(button2)</strong>
        <strong>layout.addWidget(button3)</strong>
        <strong>layout.addWidget(button4)</strong>
        <strong>layout.addWidget(button5)</strong>
&nbsp;
        <strong># nastavení správce geometrie a vložení všech komponent do okna</strong>
        <strong>self.setLayout(layout)</strong>
&nbsp;
        # navázání akce na signál
        button1.clicked.connect(self.quit)
        button2.clicked.connect(self.quit)
        button3.clicked.connect(self.quit)
        button4.clicked.connect(self.quit)
        button5.clicked.connect(self.quit)
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    def quit(self):
        print("Closing...")
        self.close()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vložení pružných mezer mezi ovládací prvky</h2>

<p>Mezi jednotlivé viditelné widgety je možné vkládat pružné mezery
s&nbsp;využitím metody <strong>addStretch</strong>. Vliv těchto mezer se
samozřejmě projeví ve chvíli, kdy se mění velikost okna nebo dialogu. Zkusme si
nejdříve vložit pružnou mezeru před první tlačítko, tj.&nbsp;mezera bude
vložena doleva. U malého okna bude mít mezera nulovou šířku, která se ale bude
se zvětšováním postupně měnit:</p>

<pre>
# vytvoření správce geometrie a umístění widgetů
layout = QtGui.QHBoxLayout()
&nbsp;
# pružná mezera
<strong>layout.addStretch(1)</strong>
layout.addWidget(button1)
layout.addWidget(button2)
layout.addWidget(button3)
layout.addWidget(button4)
layout.addWidget(button5)
</pre>

<img src="https://i.iinfo.cz/images/488/pyside2-5.png" class="image-313950" alt="&#160;" height="267" width="473" />
<p><i>Obrázek 5: Pružná mezera vložená před první tlačítko (okno
v&nbsp;původní velikosti).</i></p>

<img src="https://i.iinfo.cz/images/618/pyside2-1.png" class="image-313951" alt="&#160;" height="267" width="683" />
<p><i>Obrázek 6: Pružná mezera vložená před první tlačítko (okno po manuálním
zvětšení).</i></p>

<p>Pro úplnost &ndash; zdrojový text příkladu nyní vypadá takto:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítka
        button1 = QtGui.QPushButton("One")
        button2 = QtGui.QPushButton("Two")
        button3 = QtGui.QPushButton("Three")
        button4 = QtGui.QPushButton("Four")
        button5 = QtGui.QPushButton("Five")
&nbsp;
        <strong># vytvoření správce geometrie a umístění widgetů</strong>
        <strong>layout = QtGui.QHBoxLayout()</strong>
&nbsp;
        <strong># pružná mezera</strong>
        <strong>layout.addStretch(1)</strong>
        <strong>layout.addWidget(button1)</strong>
        <strong>layout.addWidget(button2)</strong>
        <strong>layout.addWidget(button3)</strong>
        <strong>layout.addWidget(button4)</strong>
        <strong>layout.addWidget(button5)</strong>
&nbsp;
        <strong># nastavení správce geometrie a vložení všech komponent do okna</strong>
        <strong>self.setLayout(layout)</strong>
&nbsp;
        # navázání akce na signál
        button1.clicked.connect(self.quit)
        button2.clicked.connect(self.quit)
        button3.clicked.connect(self.quit)
        button4.clicked.connect(self.quit)
        button5.clicked.connect(self.quit)
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    def quit(self):
        print("Closing...")
        self.close()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>

<p>Nyní se podívejme, co se stane při vložení pružné mezery až za druhé
tlačítko:</p>

<pre>
# vytvoření správce geometrie a umístění widgetů
layout = QtGui.QHBoxLayout()
&nbsp;
layout.addWidget(button1)
layout.addWidget(button2)
&nbsp;
# pružná mezera
<strong>layout.addStretch(1)</strong>
&nbsp;
layout.addWidget(button3)
layout.addWidget(button4)
layout.addWidget(button5)
</pre>

<img src="https://i.iinfo.cz/images/488/pyside2-7.png" class="image-313952" alt="&#160;" height="267" width="473" />
<p><i>Obrázek 7: Pružná mezera vložená až za druhé tlačítko (okno
v&nbsp;původní velikosti).</i></p>

<img src="https://i.iinfo.cz/images/488/pyside2-8.png" class="image-313953" alt="&#160;" height="266" width="675" />
<p><i>Obrázek 8: Pružná mezera vložená až za druhé tlačítko (okno po manuálním
zvětšení).</i></p>

<p>Opět následuje výpis upraveného kódu příkladu:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítka
        button1 = QtGui.QPushButton("One")
        button2 = QtGui.QPushButton("Two")
        button3 = QtGui.QPushButton("Three")
        button4 = QtGui.QPushButton("Four")
        button5 = QtGui.QPushButton("Five")
&nbsp;
        <strong># vytvoření správce geometrie a umístění widgetů</strong>
        <strong>layout = QtGui.QHBoxLayout()</strong>
&nbsp;
        <strong>layout.addWidget(button1)</strong>
        <strong>layout.addWidget(button2)</strong>
&nbsp;
        <strong># pružná mezera</strong>
        <strong>layout.addStretch(1)</strong>
        <strong>layout.addWidget(button3)</strong>
        <strong>layout.addWidget(button4)</strong>
        <strong>layout.addWidget(button5)</strong>
&nbsp;
        <strong># nastavení správce geometrie a vložení všech komponent do okna</strong>
        <strong>self.setLayout(layout)</strong>
&nbsp;
        # navázání akce na signál
        button1.clicked.connect(self.quit)
        button2.clicked.connect(self.quit)
        button3.clicked.connect(self.quit)
        button4.clicked.connect(self.quit)
        button5.clicked.connect(self.quit)
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    def quit(self):
        print("Closing...")
        self.close()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Správce rozložení <strong>QVBoxLayout</strong></h2>

<p>Správce rozložení nazvaný <strong>QVBoxLayout</strong> umisťuje jednotlivé
ovládací prvky (komponenty) pod sebe, tedy vertikálně. Jeho použití je
prakticky shodné s&nbsp;výše popsaným správcem <strong>QHBoxLayout</strong>,
takže si na tomto místě pouze uveďme základní příklad použití:</p>

<pre>
# vytvoření správce geometrie a umístění widgetů
layout = QtGui.QVBoxLayout()
&nbsp;
layout.addWidget(button1)
layout.addWidget(button2)
layout.addWidget(button3)
layout.addWidget(button4)
layout.addWidget(button5)
&nbsp;
# nastavení správce geometrie a vložení všech komponent do okna
self.setLayout(layout)
</pre>

<img src="https://i.iinfo.cz/images/488/pyside2-9.png" class="image-313954" alt="&#160;" height="208" width="109" />
<p><i>Obrázek 9: Pětice tlačítek rozmístěných do okna pomocí
<strong>QVBoxLayout</strong>.</i></p>

<p>Ve skutečnosti je do metody <strong>QVBoxLayout.addWidget</strong> opět
možné předat i další dva nepovinné parametry nazvané <strong>stretch</strong> a
<strong>alignment</strong>. Parametr <strong>stretch</strong> je celočíselný a
slouží k&nbsp;řízení míry rozpínání widgetů v&nbsp;okně či dialogu, pokud se
mění jeho velikost. Implicitní hodnotou je nula. Parametr
<strong>alignment</strong> je možné využít ke specifikaci zarovnání ovládacích
prvků (pod sebe):</p>

<table>
<tr><th>Hodnota <strong>alignment</strong></th><th>Význam</th></tr>
<tr><td>QtCore.Qt.AlignLeft</td><td>zarovnání widgetu doleva</td></tr>
<tr><td>QtCore.Qt.AlignRight</td><td>zarovnání widgetu doprava</td></tr>
<tr><td>QtCore.Qt.AlignHCenter</td><td>horizontální vycentrování widgetu</td></tr>
<tr><td>QtCore.Qt.AlignCenter</td><td>vycentrování widgetu ve vertikálním i horizontálním směru</td></tr>
</table>

<p>Poznámka: kromě <strong>QtCore.Qt.AlignCenter</strong> se hodnoty zarovnání
odlišují od správce <strong>QHBoxLayout</strong>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Ukázka použití správce rozložení <strong>QVBoxLayout</strong></h2>

<p>Z&nbsp;následujícího zdrojového kódu je patrné, že se správce rozložení
<strong>QVBoxLayout</strong> používá naprosto stejným způsobem, jako již
popsaný správce rozložení <strong>QHBoxLayout</strong>, i když výsledná podoba
hlavního okna je samozřejmě odlišná:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        # velikost není potřeba specifikovat
        # self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítka
        button1 = QtGui.QPushButton("One")
        button2 = QtGui.QPushButton("Two")
        button3 = QtGui.QPushButton("Three")
        button4 = QtGui.QPushButton("Four")
        button5 = QtGui.QPushButton("Five")
&nbsp;
        <strong># vytvoření správce geometrie a umístění widgetů</strong>
        <strong>layout = QtGui.QVBoxLayout()</strong>
        <strong>layout.addWidget(button1)</strong>
        <strong>layout.addWidget(button2)</strong>
        <strong>layout.addWidget(button3)</strong>
        <strong>layout.addWidget(button4)</strong>
        <strong>layout.addWidget(button5)</strong>
&nbsp;
        <strong># nastavení správce geometrie a vložení všech komponent do okna</strong>
        <strong>self.setLayout(layout)</strong>
&nbsp;
        # navázání akce na signál
        button1.clicked.connect(self.quit)
        button2.clicked.connect(self.quit)
        button3.clicked.connect(self.quit)
        button4.clicked.connect(self.quit)
        button5.clicked.connect(self.quit)
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    def quit(self):
        print("Closing...")
        self.close()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Správce rozložení <strong>QGridLayout</strong></h2>

<p>Zatímco správci rozložení <strong>QHBoxLayout</strong> a
<strong>QVBoxLayout</strong> mohou posloužit pro tvorbu spíše jednodušších
dialogů popř.&nbsp;pro hierarchickou tvorbu GUI s&nbsp;využitím kontejnerů
umístěných v&nbsp;jiných kontejnerech, je správce rozvržení nazvaný
<strong>QGridLayout</strong> mnohem univerzálnější. Podobně jako správce <a
href="https://www.root.cz/clanky/graficke-uzivatelske-rozhrani-v-pythonu-knihovna-tkinter#k10">Grid</a>
z&nbsp;knihovny Tkinter umožňuje <strong>QGridLayout</strong> umístit
komponenty do pomyslné mřížky, jejíž velikost (počet sloupců a řádků) i rozměry
buněk závisí na komponentách, které se do mřížky vloží. V&nbsp;tom
nejjednodušším případě je pro každou komponentu vyhrazena jedna buňka mřížky,
jejíž koordináty se specifikují při vkládání komponenty do GUI. První číslo
odpovídá řádku, druhé sloupci:</p>

<pre>
# vytvoření správce geometrie a umístění widgetů
layout = QtGui.QGridLayout()
&nbsp;
#                komponenta  řádek  sloupec
layout.addWidget(button1,    1,     1)
layout.addWidget(button2,    2,     2)
layout.addWidget(button3,    2,     3)
layout.addWidget(button4,    3,     2)
layout.addWidget(button5,    4,     1)
layout.addWidget(button6,    4,     2)
&nbsp;
# nastavení správce geometrie a vložení všech komponent do okna
self.setLayout(layout)
</pre>

<img src="https://i.iinfo.cz/images/488/pyside2-10.png" class="image-313955" alt="&#160;" height="175" width="291" />
<p><i>Obrázek 10: Šest tlačítek umístěných do pomyslné mřížky.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Ukázka použití správce rozložení <strong>QGridLayout</strong></h2>

<p>Upravme si nyní náš demonstrační příklad takovým způsobem, aby se v&nbsp;něm
namísto správce <strong>QHBoxLayout</strong> či <strong>QVBoxLayout</strong>
využil právě správce <strong>QGridLayout</strong>. Úprava je velmi snadná:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        # velikost není potřeba specifikovat
        # self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítka
        button1 = QtGui.QPushButton("One")
        button2 = QtGui.QPushButton("Two")
        button3 = QtGui.QPushButton("Three")
        button4 = QtGui.QPushButton("Four")
        button5 = QtGui.QPushButton("Five")
        button6 = QtGui.QPushButton("Six")
&nbsp;
        <strong># vytvoření správce geometrie a umístění widgetů</strong>
        <strong>layout = QtGui.QGridLayout()</strong>
        <strong>layout.addWidget(button1, 1, 1)</strong>
        <strong>layout.addWidget(button2, 2, 2)</strong>
        <strong>layout.addWidget(button3, 2, 3)</strong>
        <strong>layout.addWidget(button4, 3, 2)</strong>
        <strong>layout.addWidget(button5, 4, 1)</strong>
        <strong>layout.addWidget(button6, 4, 2)</strong>
&nbsp;
        # nastavení správce geometrie a vložení všech komponent do okna
        self.setLayout(layout)
&nbsp;
        # navázání akce na signál
        button1.clicked.connect(self.quit)
        button2.clicked.connect(self.quit)
        button3.clicked.connect(self.quit)
        button4.clicked.connect(self.quit)
        button5.clicked.connect(self.quit)
        button6.clicked.connect(self.quit)
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    def quit(self):
        print("Closing...")
        self.close()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Komponenty umístěné do mřížky přes větší množství řádků či sloupců</h2>

<p>Pro složitější okna a dialogy si nevystačíme s&nbsp;pouhým umístěním
komponent do jednotlivých buněk tabulky, ale budeme muset některé komponenty
umístit přes větší množství buněk. I to je samozřejmě možné, protože při
vkládání komponenty do mřížky je možné použít další dva nepovinné parametry,
jimiž se zadává počet sloučených řádků a počet sloučených buněk. Pokud nejsou
tyto parametry explicitně zapsány, předpokládá se, že jsou rovny jedné:</p>

<pre>
# vytvoření správce geometrie a umístění widgetů
layout = QtGui.QGridLayout()
&nbsp;
#                komponenta  řádek  sloupec   slouč. řádků  slouč. sloupců
layout.addWidget(button1,    1,     1,        1,            2)
layout.addWidget(button2,    2,     2)
layout.addWidget(button3,    2,     3)
layout.addWidget(button4,    3,     2,        1,            2)
layout.addWidget(button5,    3,     1,        2,            1)
layout.addWidget(button6,    4,     2)
&nbsp;
# nastavení správce geometrie a vložení všech komponent do okna
self.setLayout(layout)
</pre>

<img src="https://i.iinfo.cz/images/488/pyside2-11.png" class="image-313956" alt="&#160;" height="175" width="291" />
<p><i>Obrázek 11: Šest tlačítek, z&nbsp;nichž některá jsou umístěná do několika
sloučených buněk.</i></p>

<p>Opět se podívejme na výpis úplného zdrojového kódu demonstračního příkladu
se zvýrazněním provedených změn:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        # velikost není potřeba specifikovat
        # self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítka
        button1 = QtGui.QPushButton("One")
        button2 = QtGui.QPushButton("Two")
        button3 = QtGui.QPushButton("Three")
        button4 = QtGui.QPushButton("Four")
        button5 = QtGui.QPushButton("Five")
        button6 = QtGui.QPushButton("Six")
&nbsp;
        # vytvoření správce geometrie a umístění widgetů
        <strong>layout = QtGui.QGridLayout()</strong>
        <strong>layout.addWidget(button1, 1, 1, 1, 2)</strong>
        <strong>layout.addWidget(button2, 2, 2)</strong>
        <strong>layout.addWidget(button3, 2, 3)</strong>
        <strong>layout.addWidget(button4, 3, 2, 1, 2)</strong>
        <strong>layout.addWidget(button5, 3, 1, 2, 1)</strong>
        <strong>layout.addWidget(button6, 4, 2)</strong>
&nbsp;
        # nastavení správce geometrie a vložení všech komponent do okna
        self.setLayout(layout)
&nbsp;
        # navázání akce na signál
        button1.clicked.connect(self.quit)
        button2.clicked.connect(self.quit)
        button3.clicked.connect(self.quit)
        button4.clicked.connect(self.quit)
        button5.clicked.connect(self.quit)
        button6.clicked.connect(self.quit)
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    def quit(self):
        print("Closing...")
        self.close()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Horizontální a vertikální zarovnání komponent v&nbsp;mřížce</h2>

<p>S&nbsp;problematikou zarovnání komponent jsme se již setkali, takže si jen
doplňme, že i při použití správce rozvržení <strong>QGridLayout</strong> je
možné specifikovat, jak se jednotlivé komponenty zarovnají:</p>

<pre>
# vytvoření správce geometrie a umístění widgetů
layout = QtGui.QGridLayout()
layout.setHorizontalSpacing(0)
layout.setVerticalSpacing(20)
&nbsp;
#                komponenta  řádek  sloupec   slouč. řádků  slouč. sloupců  zarovnání
layout.addWidget(button1,    1,     1)
layout.addWidget(button2,    2,     1)
layout.addWidget(button3,    3,     1)
layout.addWidget(button4,    4,     1)
layout.addWidget(button5,    1,     2,        2,            1,              <strong>QtCore.Qt.AlignTop</strong>)
layout.addWidget(button6,    3,     2,        2,            1,              <strong>QtCore.Qt.AlignBottom</strong>)
</pre>

<img src="https://i.iinfo.cz/images/488/pyside2-12.png" class="image-313957" alt="&#160;" height="217" width="194" />
<p><i>Obrázek 12: Šest tlačítek, z&nbsp;nichž některá jsou umístěna do několika
sloučených buněk. Dvě tlačítka ve druhém sloupci jsou explicitně zarovnána na
horní resp.&nbsp;dolní okraj sloučených buněk.</i></p>

<p>Nyní však máme k&nbsp;dispozici ucelený repertoár zarovnání &ndash; jak
horizontálního, tak i vertikálního:</p>

<table>
<tr><th>Hodnota <strong>alignment</strong></th><th>Význam</th></tr>
<tr><td>QtCore.Qt.AlignLeft</td><td>zarovnání widgetu doleva</td></tr>
<tr><td>QtCore.Qt.AlignRight</td><td>zarovnání widgetu doprava</td></tr>
<tr><td>QtCore.Qt.AlignHCenter</td><td>horizontální vycentrování widgetu</td></tr>
<tr><td>QtCore.Qt.AlignTop</td><td>zarovnání widgetu nahoru</td></tr>
<tr><td>QtCore.Qt.AlignBottom</td><td>zarovnání widgetu dolů</td></tr>
<tr><td>QtCore.Qt.AlignVCenter</td><td>vertikální vycentrování widgetu</td></tr>
<tr><td>QtCore.Qt.AlignCenter</td><td>vycentrování widgetu ve vertikálním i horizontálním směru</td></tr>
</table>

<p>Opět se podívejme na příklad, dnes již poslední. V&nbsp;příkladu navíc
explicitně nastavujeme mezery mezi komponentami:</p>

<pre>
layout.setHorizontalSpacing(0)
layout.setVerticalSpacing(20)
</pre>

<p>Zdrojový kód:</p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import sys
&nbsp;
# import "jádra" frameworku Qt i modulu pro GUI
from PySide import QtCore
from PySide import QtGui
&nbsp;
&nbsp;
# nový widget bude odvozen od obecného widgetu
class MainWindow(QtGui.QWidget):
&nbsp;
    def __init__(self):
        # zavoláme konstruktor předka
        super(MainWindow, self).__init__()
&nbsp;
        # konfigurace GUI + přidání widgetu do okna
        self.prepareGUI()
&nbsp;
    def prepareGUI(self):
        # velikost není potřeba specifikovat
        # self.resize(320, 240)
        self.setWindowTitle("Quit Button")
&nbsp;
        # tlačítka
        button1 = QtGui.QPushButton("One")
        button2 = QtGui.QPushButton("Two")
        button3 = QtGui.QPushButton("Three")
        button4 = QtGui.QPushButton("Four")
        button5 = QtGui.QPushButton("Five")
        button6 = QtGui.QPushButton("Six")
&nbsp;
        # vytvoření správce geometrie a umístění widgetů
        layout = QtGui.QGridLayout()
        layout.setHorizontalSpacing(0)
        layout.setVerticalSpacing(20)
&nbsp;
        <strong>layout.addWidget(button1, 1, 1)</strong>
        <strong>layout.addWidget(button2, 2, 1)</strong>
        <strong>layout.addWidget(button3, 3, 1)</strong>
        <strong>layout.addWidget(button4, 4, 1)</strong>
        <strong>layout.addWidget(button5, 1, 2, 2, 1, QtCore.Qt.AlignTop)</strong>
        <strong>layout.addWidget(button6, 3, 2, 2, 1, QtCore.Qt.AlignBottom)</strong>
&nbsp;
        # nastavení správce geometrie a vložení všech komponent do okna
        self.setLayout(layout)
&nbsp;
        # navázání akce na signál
        button1.clicked.connect(self.quit)
        button2.clicked.connect(self.quit)
        button3.clicked.connect(self.quit)
        button4.clicked.connect(self.quit)
        button5.clicked.connect(self.quit)
        button6.clicked.connect(self.quit)
&nbsp;
    def run(self, app):
        # zobrazení okna na obrazovce
        self.show()
        # vstup do smyčky událostí (event loop)
        app.exec_()
&nbsp;
    def quit(self):
        print("Closing...")
        self.close()
&nbsp;
&nbsp;
def main():
    app = QtGui.QApplication(sys.argv)
    MainWindow().run(app)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dvanácti dnes popsaných demonstračních příkladů byly
opět uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Pokud nechcete klonovat celý repositář, můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>13_event_and_signals_old_approach.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/13_event_and_signals_old_approach.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/13_event_and_signals_old_approach.py</a></td></tr>
<tr><td>14_event_and_signals.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/14_event_and_signals.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/14_event_and_signals.py</a></td></tr>
<tr><td>15_events_and_signals2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/15_events_and_signals2.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/15_events_and_signals2.py</a></td></tr>
<tr><td>16_no_layout.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/16_no_layout.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/16_no_layout.py</a></td></tr>
<tr><td>17_absolute_positioning.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/17_absolute_positioning.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/17_absolute_positioning.py</a></td></tr>
<tr><td>18_hbox_layout.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/18_hbox_layout.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/18_hbox_layout.py</a></td></tr>
<tr><td>19_stretch.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/19_stretch.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/19_stretch.py</a></td></tr>
<tr><td>20_stretch2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/20_stretch2.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/20_stretch2.py</a></td></tr>
<tr><td>21_vbox_layout.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/21_vbox_layout.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/21_vbox_layout.py</a></td></tr>
<tr><td>22_grid_layout.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/22_grid_layout.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/22_grid_layout.py</a></td></tr>
<tr><td>23_grid_layout_span.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/23_grid_layout_span.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/23_grid_layout_span.py</a></td></tr>
<tr><td>24_grid_layout_alignment.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/24_grid_layout_alignment.py">https://github.com/tisnik/presentations/blob/master/Python_GUI/PySide/24_grid_layout_alignment.py</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>PySide documentation<br />
<a href="https://srinikom.github.io/pyside-docs/index.html">https://srinikom.github.io/pyside-docs/index.html</a>
</li>

<li>Differences Between PySide and PyQt<br />
<a href="https://wiki.qt.io/Differences_Between_PySide_and_PyQt">https://wiki.qt.io/Differences_Between_PySide_and_PyQt</a>
</li>

<li>PySide tutorials<br />
<a href="https://srinikom.github.io/pyside-docs/tutorials/index.html">https://srinikom.github.io/pyside-docs/tutorials/index.html</a>
</li>

<li>PySide tutorial<br />
<a href="http://zetcode.com/gui/pysidetutorial/">http://zetcode.com/gui/pysidetutorial/</a>
</li>

<li>QLayout<br />
<a href="https://srinikom.github.io/pyside-docs/PySide/QtGui/QLayout.html">https://srinikom.github.io/pyside-docs/PySide/QtGui/QLayout.html</a>
</li>

<li>QStackedLayout<br />
<a href="https://srinikom.github.io/pyside-docs/PySide/QtGui/QStackedLayout.html">https://srinikom.github.io/pyside-docs/PySide/QtGui/QStackedLayout.html</a>
</li>

<li>QFormLayout<br />
<a href="https://srinikom.github.io/pyside-docs/PySide/QtGui/QFormLayout.html">https://srinikom.github.io/pyside-docs/PySide/QtGui/QFormLayout.html</a>
</li>

<li>QBoxLayout<br />
<a href="https://srinikom.github.io/pyside-docs/PySide/QtGui/QBoxLayout.html">https://srinikom.github.io/pyside-docs/PySide/QtGui/QBoxLayout.html</a>
</li>

<li>QHBoxLayout<br />
<a href="https://srinikom.github.io/pyside-docs/PySide/QtGui/QHBoxLayout.html">https://srinikom.github.io/pyside-docs/PySide/QtGui/QHBoxLayout.html</a>
</li>

<li>QVBoxLayout<br />
<a href="https://srinikom.github.io/pyside-docs/PySide/QtGui/QVBoxLayout.html">https://srinikom.github.io/pyside-docs/PySide/QtGui/QVBoxLayout.html</a>
</li>

<li>QGridLayout<br />
<a href="https://srinikom.github.io/pyside-docs/PySide/QtGui/QGridLayout.html">https://srinikom.github.io/pyside-docs/PySide/QtGui/QGridLayout.html</a>
</li>

<li>Signals &amp; Slots<br />
<a href="http://doc.qt.io/qt-4.8/signalsandslots.html">http://doc.qt.io/qt-4.8/signalsandslots.html</a>
</li>

<li>Signals and Slots in PySide<br />
<a href="http://wiki.qt.io/Signals_and_Slots_in_PySide">http://wiki.qt.io/Signals_and_Slots_in_PySide</a>
</li>

<li>Intro to PySide/PyQt: Basic Widgets and Hello, World!<br />
<a href="http://www.pythoncentral.io/intro-to-pysidepyqt-basic-widgets-and-hello-world/">http://www.pythoncentral.io/intro-to-pysidepyqt-basic-widgets-and-hello-world/</a>
</li>

<li>QWidget<br />
<a href="https://srinikom.github.io/pyside-docs/PySide/QtGui/QWidget.html">https://srinikom.github.io/pyside-docs/PySide/QtGui/QWidget.html</a>
</li>

<li>Leo editor<br />
<a href="http://leoeditor.com/">http://leoeditor.com/</a>
</li>

<li>IPython Qt Console aneb vylepšený pseudoterminál<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-ipython-a-ipython-notebook/#k06">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-ipython-a-ipython-notebook/#k06</a>
</li>

<li>Vývojová prostředí ve Fedoře (4. díl)<br />
<a href="https://mojefedora.cz/vyvojova-prostredi-ve-fedore-4-dil/">https://mojefedora.cz/vyvojova-prostredi-ve-fedore-4-dil/</a>
</li>

<li>Seriál Letní škola programovacího jazyka Logo<br />
<a href="http://www.root.cz/serialy/letni-skola-programovaciho-jazyka-logo/">http://www.root.cz/serialy/letni-skola-programovaciho-jazyka-logo/</a>
</li>

<li>Educational programming language<br />
<a href="http://en.wikipedia.org/wiki/Educational_programming_language">http://en.wikipedia.org/wiki/Educational_programming_language</a>
</li>

<li>Logo Tree Project:<br />
<a href="http://www.elica.net/download/papers/LogoTreeProject.pdf">http://www.elica.net/download/papers/LogoTreeProject.pdf</a></li>

<li>Hra Breakout napísaná v Tkinteri<br />
<a href="https://www.root.cz/clanky/hra-breakout-napisana-v-tkinteri/">https://www.root.cz/clanky/hra-breakout-napisana-v-tkinteri/</a>
</li>

<li>Hra Snake naprogramovaná v Pythone s pomocou Tkinter<br />
<a href="https://www.root.cz/clanky/hra-snake-naprogramovana-v-pythone-s-pomocou-tkinter/">https://www.root.cz/clanky/hra-snake-naprogramovana-v-pythone-s-pomocou-tkinter/</a>
</li>

<li>24.1. turtle — Turtle graphics<br />
<a href="https://docs.python.org/3.5/library/turtle.html#module-turtle">https://docs.python.org/3.5/library/turtle.html#module-turtle</a>
</li>

<li>TkDND<br />
<a href="http://freecode.com/projects/tkdnd">http://freecode.com/projects/tkdnd</a>
</li>

<li>Python Tkinter Fonts<br />
<a href="https://www.tutorialspoint.com/python/tk_fonts.htm">https://www.tutorialspoint.com/python/tk_fonts.htm</a>
</li>

<li>The Tkinter Canvas Widget<br />
<a href="http://effbot.org/tkinterbook/canvas.htm">http://effbot.org/tkinterbook/canvas.htm</a>
</li>

<li>Ovládací prvek (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Ovl%C3%A1dac%C3%AD_prvek_%28po%C4%8D%C3%ADta%C4%8D%29">https://cs.wikipedia.org/wiki/Ovl%C3%A1dac%C3%AD_prvek_%28po%C4%8D%C3%ADta%C4%8D%29</a>
</li>

<li>Rezervovaná klíčová slova v&nbsp;Pythonu<br />
<a href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">https://docs.python.org/3/reference/lexical_analysis.html#keywords</a>
</li>

<li>TkDocs: Styles and Themes<br />
<a href="http://www.tkdocs.com/tutorial/styles.html">http://www.tkdocs.com/tutorial/styles.html</a>
</li>

<li>Drawing in Tkinter<br />
<a href="http://zetcode.com/gui/tkinter/drawing/">http://zetcode.com/gui/tkinter/drawing/</a>
</li>

<li>Changing ttk widget text color (StackOverflow)<br />
<a href="https://stackoverflow.com/questions/16240477/changing-ttk-widget-text-color">https://stackoverflow.com/questions/16240477/changing-ttk-widget-text-color</a>
</li>

<li>The Hitchhiker's Guide to Pyhton: GUI Applications<br />
<a href="http://docs.python-guide.org/en/latest/scenarios/gui/">http://docs.python-guide.org/en/latest/scenarios/gui/</a>
</li>

<li>7 Top Python GUI Frameworks for 2017<br />
<a href="http://insights.dice.com/2014/11/26/5-top-python-guis-for-2015/">http://insights.dice.com/2014/11/26/5-top-python-guis-for-2015/</a>
</li>

<li>GUI Programming in Python<br />
<a href="https://wiki.python.org/moin/GuiProgramming">https://wiki.python.org/moin/GuiProgramming</a>
</li>

<li>Cameron Laird's personal notes on Python GUIs<br />
<a href="http://phaseit.net/claird/comp.lang.python/python_GUI.html">http://phaseit.net/claird/comp.lang.python/python_GUI.html</a>
</li>

<li>Python GUI development<br />
<a href="http://pythoncentral.io/introduction-python-gui-development/">http://pythoncentral.io/introduction-python-gui-development/</a>
</li>

<li>Graphic User Interface FAQ<br />
<a href="https://docs.python.org/2/faq/gui.html#graphic-user-interface-faq">https://docs.python.org/2/faq/gui.html#graphic-user-interface-faq</a>
</li>

<li>TkInter<br />
<a href="https://wiki.python.org/moin/TkInter">https://wiki.python.org/moin/TkInter</a>
</li>

<li>Tkinter 8.5 reference: a GUI for Python<br />
<a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html">http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html</a>
</li>

<li>TkInter (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tkinter">https://en.wikipedia.org/wiki/Tkinter</a>
</li>

<li>appJar<br />
<a href="http://appjar.info/">http://appjar.info/</a>
</li>

<li>appJar (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/AppJar">https://en.wikipedia.org/wiki/AppJar</a>
</li>

<li>appJar na Pythonhosted<br />
<a href="http://pythonhosted.org/appJar/">http://pythonhosted.org/appJar/</a>
</li>

<li>appJar widgets<br />
<a href="http://appjar.info/pythonWidgets/">http://appjar.info/pythonWidgets/</a>
</li>

<li>Stránky projektu PyGTK<br />
<a href="http://www.pygtk.org/">http://www.pygtk.org/</a>
</li>

<li>PyGTK (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/PyGTK">https://cs.wikipedia.org/wiki/PyGTK</a>
</li>

<li>Stránky projektu PyGObject<br />
<a href="https://wiki.gnome.org/Projects/PyGObject">https://wiki.gnome.org/Projects/PyGObject</a>
</li>

<li>Stránky projektu Kivy<br />
<a href="https://kivy.org/#home">https://kivy.org/#home</a>
</li>

<li>Stránky projektu PyQt<br />
<a href="https://riverbankcomputing.com/software/pyqt/intro">https://riverbankcomputing.com/software/pyqt/intro</a>
</li>

<li>PyQt (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/PyGTK">https://cs.wikipedia.org/wiki/PyGTK</a>
</li>

<li>Stránky projektu PySide<br />
<a href="https://wiki.qt.io/PySide">https://wiki.qt.io/PySide</a>
</li>

<li>PySide (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/PySide">https://en.wikipedia.org/wiki/PySide</a>
</li>

<li>Stránky projektu Kivy<br />
<a href="https://kivy.org/#home">https://kivy.org/#home</a>

<li>Kivy (framework, Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Kivy_(framework)">https://en.wikipedia.org/wiki/Kivy_(framework)</a>

<li>QML Applications<br />
<a href="http://doc.qt.io/qt-5/qmlapplications.html">http://doc.qt.io/qt-5/qmlapplications.html</a>
</li>

<li>KDE<br />
<a href="https://www.kde.org/">https://www.kde.org/</a>
</li>

<li>Qt<br />
<a href="https://www.qt.io/">https://www.qt.io/</a>
</li>

<li>GNOME<br />
<a href="https://en.wikipedia.org/wiki/GNOME">https://en.wikipedia.org/wiki/GNOME</a>
</li>

<li>Category:Software that uses PyGTK<br />
<a href="https://en.wikipedia.org/wiki/Category:Software_that_uses_PyGTK">https://en.wikipedia.org/wiki/Category:Software_that_uses_PyGTK</a>
</li>

<li>Category:Software that uses PyGObject<br />
<a href="https://en.wikipedia.org/wiki/Category:Software_that_uses_PyGObject">https://en.wikipedia.org/wiki/Category:Software_that_uses_PyGObject</a>
</li>

<li>Category:Software that uses wxWidgets<br />
<a href="https://en.wikipedia.org/wiki/Category:Software_that_uses_wxWidgets">https://en.wikipedia.org/wiki/Category:Software_that_uses_wxWidgets</a>
</li>

<li>GIO<br />
<a href="https://developer.gnome.org/gio/stable/">https://developer.gnome.org/gio/stable/</a>
</li>

<li>GStreamer<br />
<a href="https://gstreamer.freedesktop.org/">https://gstreamer.freedesktop.org/</a>
</li>

<li>GStreamer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GStreamer">https://en.wikipedia.org/wiki/GStreamer</a>
</li>

<li>Wax Gui Toolkit<br />
<a href="https://wiki.python.org/moin/Wax">https://wiki.python.org/moin/Wax</a>
</li>

<li>Python Imaging Library (PIL)<br />
<a href="http://infohost.nmt.edu/tcc/help/pubs/pil/">http://infohost.nmt.edu/tcc/help/pubs/pil/</a>
</li>

<li>Why Pyjamas Isn’t a Good Framework for Web Apps (blogpost z&nbsp;roku 2012)<br />
<a href="http://blog.pyjeon.com/2012/07/29/why-pyjamas-isnt-a-good-framework-for-web-apps/">http://blog.pyjeon.com/2012/07/29/why-pyjamas-isnt-a-good-framework-for-web-apps/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

