<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: textury a texturování při vykreslování trojrozměrných scén (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: textury a texturování při vykreslování trojrozměrných scén (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Multimediální knihovna Pyglet: textury a texturování při vykreslování trojrozměrných scén (dokončení)</a></p>
<p><a href="#k02">*** 2. Textury v&nbsp;trojrozměrných scénách</a></p>
<p><a href="#k03">*** 3. První demonstrační příklad &ndash; textury na stěnách 3D tělesa</a></p>
<p><a href="#k04">*** 4. Nastavení blendingu a modulace textur</a></p>
<p><a href="#k05">*** 5. Režimy výpočtu barev stěn při nanášení textur</a></p>
<p><a href="#k06">*** 6. Druhý demonstrační příklad &ndash; nanesení textury na různobarevné čtverce</a></p>
<p><a href="#k07">*** 7. Zákaz modulace textur</a></p>
<p><a href="#k08">*** 8. Třetí demonstrační příklad &ndash; zákaz modulace textur</a></p>
<p><a href="#k09">*** 9. Nanášení texelů bez dalších úprav popř.&nbsp;použití alfa kanálu</a></p>
<p><a href="#k10">*** 10. Čtvrtý demonstrační příklad: použití alfa kanálu textury</a></p>
<p><a href="#k11">*** 11. Blending na úrovni textur</a></p>
<p><a href="#k12">*** 12. Pátý demonstrační příklad &ndash; blending na úrovni textur</a></p>
<p><a href="#k13">*** 13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">*** 14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimediální knihovna Pyglet: textury a texturování při vykreslování trojrozměrných scén (dokončení)</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Textury v&nbsp;trojrozměrných scénách</h2>


*** image ***
<p><i>Obrázek 1: První demonstrační příklad &ndash; texturování je nyní vypnuto.</i></p>

*** image ***
<p><i>Obrázek 2: První demonstrační příklad &ndash; texturování je nyní zapnuto.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad &ndash; textury na stěnách 3D tělesa</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                    # hodnota zorneho uhlu - field of view
nearPlane = 0.1                               # blizsi orezavaci rovina
farPlane = 90.0                               # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

depthBufferEnabled = False                    # povoleni ci zakaz Z-bufferu
texturesEnabled = False                       # povoleni ci zakaz textur

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()

keys = key.KeyStateHandler()
window.push_handlers(keys)



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                      # funkce pro testovani fragmentu

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_walls():
    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor3f(0.0, 0.0, 1.0)                  # modra barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)                  # zelena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor3f(1.0, 0.0, 0.0)                  # cervena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor3f(1.0, 1.0, 0.0)                  # zluta barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()



def draw_roof():
    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor3f(0.0, 1.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(1.0, 0.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(1.0, 1.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(0.0, 0.0, 0.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)



def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) # vymazani i Z/W bufferu
    else:
        glClear(GL_COLOR_BUFFER_BIT)          # vymazani vsech bitovych rovin barvoveho bufferu



@window.event
def on_draw():
    global r1, r2
    global depthBufferEnabled
    global texturesEnabled

    if keys[key.LEFT]:
        r2 = r2 - 1
    if keys[key.RIGHT]:
        r2 = r2 + 1
    if keys[key.UP]:
        r1 = r1 - 1
    if keys[key.DOWN]:
        r1 = r1 + 1
    if keys[key.Z]:
        depthBufferEnabled = not depthBufferEnabled
    if keys[key.T]:
        texturesEnabled = not texturesEnabled


    clear_buffers(depthBufferEnabled)
    set_depth_buffer(depthBufferEnabled)

    glMatrixMode(GL_PROJECTION)               # zacatek modifikace projekcni matice
    glLoadIdentity()                          # vymazani projekcni matice (=identita)
    gluPerspective(fov, 1.0, nearPlane, farPlane);

    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                          # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
              0.0, 2.0,  0.0,                 # bod, kam se kamera diva
              0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)              # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0) 

    if texturesEnabled:
        glEnable(GL_TEXTURE_2D)
    else:
        glDisable(GL_TEXTURE_2D)

    draw_walls()
    draw_roof()



pyglet.app.run()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Nastavení blendingu a modulace textur</h2>

<p>Grafická knihovna OpenGL podporuje takzvanou <i>modulaci textur</i>. S&nbsp;využitím modulace textur je možné kombinovat texturu, která je na objekt nanášena, s&nbsp;barvou, která je buď přímo zadána jako vlastnost vykreslované plošky (nám již známý příkaz <strong>glColor*()</strong>) nebo je vypočtena pomocí osvětlovacího modelu. Lze samozřejmě provádět i kombinaci textury s&nbsp;barevným přechodem.</p>

<p>Nastavení modulace textur se v&nbsp;OpenGL provádí pomocí funkcí:</p>

<pre>
void glTexEnvf(
    GLenum  target,
    GLenum  pname,
    GLfloat param
);

void glTexEnvi(
    GLenum  target,
    GLenum  pname,
    GLint   param
);
</pre>

<p>popřípadě funkcemi, jejichž posledním parametrem je ukazatel na pole hodnot:</p>

<pre>
void glTexEnvfv(
    GLenum target,
    GLenum pname,
    const  GLfloat *params
);

void glTexEnviv(
    GLenum target,
    GLenum pname,
    const  GLint *params
);
</pre>

<p>Význam jednotlivých argumentů těchto funkcí:</p>

<ul>

<li>Při volání všech uvedených funkcí se do argumentu <strong>target</strong> zadává cílový objekt, jehož parametry měníme. V&nbsp;případě textur se do tohoto argumentu vždy zadává symbolická konstanta <strong>GL_TEXTURE_ENV</strong>.</li>

<li>Argument <strong>pname</strong> může nabývat dvou hodnot, podle toho, jaké parametry texturování měníme. První hodnotou je <strong>GL_TEXTURE_ENV_MODE</strong>, kdy v&nbsp;dalším parametru <strong>param</strong> specifikujeme mód výpočtu textur. Druhou hodnotou tohoto argumentu je symbolická konstanta <strong>GL_TEXTURE_ENV_COLOR</strong>, kdy je dalším parametrem <strong>params</strong> zadávána barva použitá při blendingu (míchání) textur.</li>

<li>V&nbsp;posledním argumentu <strong>param</strong> resp. <strong>params</strong> jsou buď zadány režimy výpočtu textur, nebo barva použitá při blendingu textur.</li>

</ul>



<p><a name="k05"></a></p>
<h2 id="k05">5. Režimy výpočtu barev stěn při nanášení textur</h2>

Pomocí funkcí glTexEnvi() a glTexEnvf(), které jsou popsané v předchozí kapitole, je možné nastavit režim výpočtu textur, tj. způsob, jakým bude barva jednotlivých texelů textury kombinována s jinou barvou, získanou například pomocí osvětlovacího modelu. Nastavování se provede konkrétně tímto příkazem:

glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, mode); 

kde poslední argument mode může nabývat tří hodnot:

    GL_DECAL – jednotlivé texely budou nanášeny na vykreslovaný povrch bez dalších úprav. Tímto příkazem tedy zakazujeme jak blending, tak i modulaci textur. Více informací o tomto režimu je uvedeno ve čtvrtém odstavci.
    GL_BLEND – vykreslované texely jsou míchány s předem zadanou barvou. Více informací o tomto režimu je uvedeno v pátém odstavci.
    GL_MODULATE – vykreslované texely čtené z rastrové textury jsou modulovány podkladovou barvou. Více informací je uvedeno v šestém odstavci.

Při inicializaci aplikace, která pro vykreslování používá grafickou knihovnu OpenGL, je standardně nastaveno modulování textur (tj. GL_MODULATE) a míchací barva (GL_TEXTURE_EN­V_COLOR) pro blending je černá s nulovou alfa složkou, tj. (0, 0, 0, 0).

Při běhu aplikace je možné provést dotaz na aktuálně nastavený režim výpočtu textur. K tomuto účelu se používají funkce:

void glGetTexEnvfv(
    GLenum target,
    GLenum pname,
    GLfloat * params
);

void glGetTexEnviv(
    GLenum target,
    GLenum pname,
    GLint * params
);

Význam jednotlivých parametrů je stejný jako při zadávání režimu výpočtu, pouze s tím rozdílem, že poslední argumenty jsou určeny pro přepis.



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý demonstrační příklad &ndash; nanesení textury na různobarevné čtverce</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS)

    glTexCoord2f(0.0, 0.0)
    glVertex2i(x, y)

    glTexCoord2f(1.0, 0.0)
    glVertex2i(x+150, y)

    glTexCoord2f(1.0, 1.0)
    glVertex2i(x+150, y+150)

    glTexCoord2f(0.0, 1.0)
    glVertex2i(x, y+150)

    glEnd()


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)

    # prostredni ctverec
    glColor3f(1.0, 1.0, 1.0)
    draw_quad(165, 165)

    # vlevo chybi cervena slozka
    glColor3f(0.0, 1.0, 1.0)
    draw_quad(10, 165)

    # vpravo chybi modra slozka
    glColor3f(1.0, 1.0, 0.0)
    draw_quad(320, 165)

    # nahore chybi zelena slozka
    glColor3f(1.0, 0.0, 1.0)
    draw_quad(165, 320)

    # dole chybi zelena a modra slozka
    glColor3f(1.0, 0.0, 0.0)
    draw_quad(165, 10)



# spusteni aplikace
pyglet.app.run()
</pre>

*** image ***
<p><i>Obrázek 3: Screenshot dnešního druhého demonstračního příkladu.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zákaz modulace textur</h2>




<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí demonstrační příklad &ndash; zákaz modulace textur</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS)

    glTexCoord2f(0.0, 0.0)
    glVertex2i(x, y)

    glTexCoord2f(1.0, 0.0)
    glVertex2i(x+150, y)

    glTexCoord2f(1.0, 1.0)
    glVertex2i(x+150, y+150)

    glTexCoord2f(0.0, 1.0)
    glVertex2i(x, y+150)

    glEnd()


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)

    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE)

    # prostredni ctverec
    glColor3f(1.0, 1.0, 1.0)
    draw_quad(165, 165)

    # vlevo chybi cervena slozka
    glColor3f(0.0, 1.0, 1.0)
    draw_quad(10, 165)

    # vpravo chybi modra slozka
    glColor3f(1.0, 1.0, 0.0)
    draw_quad(320, 165)

    # nahore chybi zelena slozka
    glColor3f(1.0, 0.0, 1.0)
    draw_quad(165, 320)

    # dole chybi zelena a modra slozka
    glColor3f(1.0, 0.0, 0.0)
    draw_quad(165, 10)



# spusteni aplikace
pyglet.app.run()
</pre>

*** image ***
<p><i>Obrázek 4: Screenshot dnešního třetího demonstračního příkladu.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Nanášení texelů bez dalších úprav popř.&nbsp;použití alfa kanálu textury</h2>

<p>V&nbsp;případě, že je texturování nastaveno do režimu <strong>GL_DECAL</strong>, jsou barvy texelů pro některé typy textur mapovány do jednotlivých fragmentů bez dalších úprav barvových složek. Jestliže je však formát textury nastaven tak, že neobsahuje přímé barvy, jsou tyto barvy vypočteny buď na základě zadané intenzity či luminance (tj.&nbsp;textury ve stupních šedi), nebo se použije původní barva fragmentu (formát <strong>GL_ALPHA</strong>). Pokud je textura uložena v&nbsp;barvovém modelu RGBA, je provedeno i míchání barev na základě alfa složky texelů. Naše zkušební textura se zeměkoulí používá barvový model RGBA, takže se v&nbsp;demonstračním příkladu použije právě tato možnost.</p>

<p>Všechny popsané možnosti jsou vyjádřeny v&nbsp;následující tabulce:</p>

<table>
<tr><td>Počet<br />barvových<br />komponent</td><td>Typ<br />komponent</td><td>Výpočet<br />barvy</td></tr>
<tr><td>1</td><td>GL_ALPHA</td><td>C=C<sub>f</sub><br />A=A<sub>t</sub></td></tr>
<tr><td>1</td><td>GL_LUMINANCE</td><td>C=L<sub>t</sub><br />A=A<sub>f</sub></td></tr>
<tr><td>1</td><td>GL_INTENSITY</td><td>C=I<sub>t</sub><br />A=I<sub>t</sub></td></tr>
<tr><td>2</td><td>GL_LUMINANCE_ALPHA</td><td>C=L<sub>t</sub><br />A=A<sub>t</sub></td></tr>
<tr><td>3</td><td>GL_RGB</td><td>C=C<sub>t</sub><br />A=A<sub>f</sub></td></tr>
<tr><td>4</td><td>GL_RGBA</td><td>C=(1-A<sub>t</sub>)C<sub>f</sub>+A<sub>t</sub>C<sub>t</sub><br />A=A<sub>t</sub></td></tr>
</table>

<p>Význam jednotlivých symbolů:</p>

<table>
<tr><th>Symbol</th><th>Význam</th></tr>
<tr><td>C</td><td>výsledná barva, jedná se o vektor C=(R, G, B)</td></tr>
<tr><td>C<sub>f</sub></td><td>barva fragmentu</td></tr>
<tr><td>C<sub>t</sub></td><td>barva texelu</td></tr>
<tr><td>A</td><td>vypočtená alfa složka</td></tr>
<tr><td>A<sub>f</sub></td><td>alfa složka fragmentu</td></tr>
<tr><td>A<sub>t</sub></td><td>alfa složka texelu</td></tr>
<tr><td>L<sub>t</sub></td><td>luminance texelu</td></tr>
</table>


<p><a name="k10"></a></p>
<h2 id="k10">10. Čtvrtý demonstrační příklad: použití alfa kanálu textury</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS)

    glTexCoord2f(0.0, 0.0)
    glVertex2i(x, y)

    glTexCoord2f(1.0, 0.0)
    glVertex2i(x+150, y)

    glTexCoord2f(1.0, 1.0)
    glVertex2i(x+150, y+150)

    glTexCoord2f(0.0, 1.0)
    glVertex2i(x, y+150)

    glEnd()


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)

    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL)

    # prostredni ctverec
    glColor3f(1.0, 1.0, 1.0)
    draw_quad(165, 165)

    # vlevo chybi cervena slozka
    glColor3f(0.0, 1.0, 1.0)
    draw_quad(10, 165)

    # vpravo chybi modra slozka
    glColor3f(1.0, 1.0, 0.0)
    draw_quad(320, 165)

    # nahore chybi zelena slozka
    glColor3f(1.0, 0.0, 1.0)
    draw_quad(165, 320)

    # dole chybi zelena a modra slozka
    glColor3f(1.0, 0.0, 0.0)
    draw_quad(165, 10)



# spusteni aplikace
pyglet.app.run()
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Blending na úrovni textur</h2>

V případě, že je povolen blending textur, tj. je zavolán příkaz
glTexEnvi(GL_TEX­TURE_ENV, GL_TEXTURE_EN­V_MODE, GL_BLEND), musí se specifikovat barva, se kterou se bude textura míchat. Pro zadání této barvy je možné použít funkce:
glTexEnviv(GL_TEX­TURE_ENV, GL_TEXTURE_EN­V_COLOR, color) resp.
glTexEnvfv(GL_TEX­TURE_ENV, GL_TEXTURE_EN­V_COLOR, color), kde color je ukazatel na čtyři hodnoty typu GLint neboGLfloat, které reprezentují barvu v barevném modelu RGBA. Pokud je blending vypnutý, nemá nastavená barva na vykreslovanou texturu samozřejmě žádný vliv.

Pokud je barva zadaná jako čtyři složky typu GLfloat, jsou tyto složky oříznuty do intervalu –1..1. Pokud se naopak použijí složky typu GLint, je interně proveden převod na GLfloat tak, aby byla nejvyšší hodnota typu GLint převedena na hodnotu 1.0 a nejnižší hodnota na –1.0.

Připomeňme si, že při zadávání rastrových dat textury pomocí funkce glTexImage() je v této funkci specifikováno, které složky barvy jsou v textuře použity. V případě, že je zadána pouze jedna složka, je považována za světlost (L – Luminance). Pokud jsou zadány složky dvě, jsou považovány za světlost následovanou průhledností alfa. Tři zadané složky představují barvový model RGB bez alfa kanálu, složky čtyři potom úplný model RGBA.

V následující tabulce je ukázáno, jak se vypočte vykreslovaná barva v režimu GL_BLEND v závislosti na počtu a typu barevných komponent:



<p><a name="k12"></a></p>
<h2 id="k12">12. Pátý demonstrační příklad &ndash; blending na úrovni textur</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS)

    glTexCoord2f(0.0, 0.0)
    glVertex2i(x, y)

    glTexCoord2f(1.0, 0.0)
    glVertex2i(x+150, y)

    glTexCoord2f(1.0, 1.0)
    glVertex2i(x+150, y+150)

    glTexCoord2f(0.0, 1.0)
    glVertex2i(x, y+150)

    glEnd()


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)

    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND)
    color = [0.5, 0.5, 0.5]
    color_gl = (GLfloat * len(color))(*color)
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, color_gl)


    # prostredni ctverec
    glColor3f(1.0, 1.0, 1.0)
    draw_quad(165, 165)

    # vlevo chybi cervena slozka
    glColor3f(0.0, 1.0, 1.0)
    draw_quad(10, 165)

    # vpravo chybi modra slozka
    glColor3f(1.0, 1.0, 0.0)
    draw_quad(320, 165)

    # nahore chybi zelena slozka
    glColor3f(1.0, 0.0, 1.0)
    draw_quad(165, 320)

    # dole chybi zelena a modra slozka
    glColor3f(1.0, 0.0, 0.0)
    draw_quad(165, 10)



# spusteni aplikace
pyglet.app.run()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>glTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

