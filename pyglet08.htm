<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: konfigurace texturovací jednotky při nanášení textur na stěny těles</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: konfigurace texturovací jednotky při nanášení textur na stěny těles</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;osmé části seriálu o multimediální knihovně Pyglet si ukážeme, jak lze nakonfigurovat texturovací jednotku při nanášení textur na stěny těles. Kromě přímého nanášení jednotlivých texelů je totiž možné textury takzvaně <i>modulovat</i>, míchat barvy texelů s&nbsp;další vybranou barvou apod. Modulace textur se poměrně často používá v&nbsp;praxi, protože umožňuje, aby se z&nbsp;jediného rastrového obrázku s&nbsp;texturou vytvořilo hned několik odlišných variant textur, a to bez větších nároků na kapacitu paměti použité grafickým procesorem pro uložení bitmap/pixmap s&nbsp;texturami.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Multimediální knihovna Pyglet: konfigurace texturovací jednotky při nanášení textur na stěny těles</a></p>
<p><a href="#k02">*** 2. Textury v&nbsp;trojrozměrných scénách</a></p>
<p><a href="#k03">*** 3. První demonstrační příklad &ndash; textury na stěnách 3D tělesa</a></p>
<p><a href="#k04">4. Nastavení blendingu a modulace textur</a></p>
<p><a href="#k05">5. Režimy výpočtu barev stěn při nanášení textur</a></p>
<p><a href="#k06">6. Druhý demonstrační příklad &ndash; nanesení textury na různobarevné čtverce</a></p>
<p><a href="#k07">7. Zákaz modulace textur</a></p>
<p><a href="#k08">8. Třetí demonstrační příklad &ndash; zákaz modulace textur</a></p>
<p><a href="#k09">9. Nanášení texelů bez dalších úprav popř.&nbsp;použití alfa kanálu</a></p>
<p><a href="#k10">10. Čtvrtý demonstrační příklad: použití alfa kanálu textury</a></p>
<p><a href="#k11">11. Blending na úrovni textur</a></p>
<p><a href="#k12">12. Předání parametrů funkcím glTexEnviv a glTexEnvfv</a></p>
<p><a href="#k13">13. Pátý demonstrační příklad &ndash; blending na úrovni textur</a></p>
<p><a href="#k14">14. Funkce knihovny OpenGL a pomocné knihovny GLU, které byly použity ve zdrojových kódech</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimediální knihovna Pyglet: konfigurace texturovací jednotky při nanášení textur na stěny těles</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Textury v&nbsp;trojrozměrných scénách</h2>

<p></p>

*** image ***
<p><i>Obrázek 1: První demonstrační příklad &ndash; texturování je nyní vypnuto.</i></p>

*** image ***
<p><i>Obrázek 2: První demonstrační příklad &ndash; texturování je nyní zapnuto.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad &ndash; textury na stěnách 3D tělesa</h2>

<p></p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                    # hodnota zorneho uhlu - field of view
nearPlane = 0.1                               # blizsi orezavaci rovina
farPlane = 90.0                               # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

depthBufferEnabled = False                    # povoleni ci zakaz Z-bufferu
texturesEnabled = False                       # povoleni ci zakaz textur

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()

keys = key.KeyStateHandler()
window.push_handlers(keys)



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                      # funkce pro testovani fragmentu

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_walls():
    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor3f(0.0, 0.0, 1.0)                  # modra barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)                  # zelena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor3f(1.0, 0.0, 0.0)                  # cervena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor3f(1.0, 1.0, 0.0)                  # zluta barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()



def draw_roof():
    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor3f(0.0, 1.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(1.0, 0.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(1.0, 1.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(0.0, 0.0, 0.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)



def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) # vymazani i Z/W bufferu
    else:
        glClear(GL_COLOR_BUFFER_BIT)          # vymazani vsech bitovych rovin barvoveho bufferu



@window.event
def on_draw():
    global r1, r2
    global depthBufferEnabled
    global texturesEnabled

    if keys[key.LEFT]:
        r2 = r2 - 1
    if keys[key.RIGHT]:
        r2 = r2 + 1
    if keys[key.UP]:
        r1 = r1 - 1
    if keys[key.DOWN]:
        r1 = r1 + 1
    if keys[key.Z]:
        depthBufferEnabled = not depthBufferEnabled
    if keys[key.T]:
        texturesEnabled = not texturesEnabled


    clear_buffers(depthBufferEnabled)
    set_depth_buffer(depthBufferEnabled)

    glMatrixMode(GL_PROJECTION)               # zacatek modifikace projekcni matice
    glLoadIdentity()                          # vymazani projekcni matice (=identita)
    gluPerspective(fov, 1.0, nearPlane, farPlane)

    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                          # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
              0.0, 2.0,  0.0,                 # bod, kam se kamera diva
              0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)              # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0) 

    if texturesEnabled:
        glEnable(GL_TEXTURE_2D)
    else:
        glDisable(GL_TEXTURE_2D)

    draw_walls()
    draw_roof()



pyglet.app.run()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Nastavení blendingu a modulace textur</h2>

<p>Grafická knihovna OpenGL (a tím pádem i knihovna Pyglet, i když samozřejmě jen nepřímo) podporuje techniku nazvanou <i>modulace textur</i>. S&nbsp;využitím modulace textur je možné kombinovat texturu, jejíž texely jsou na stěny objektu nanášeny, s&nbsp;barvou, která je buď přímo zadána jako vlastnost vykreslované plošky (viz nám již známý příkaz <strong>glColor*()</strong>, resp.&nbsp;přesněji řečeno jeho různé variace) nebo je vypočtena s&nbsp;využitím takzvaného osvětlovacího modelu. Lze samozřejmě provádět i kombinaci textury s&nbsp;barevným přechodem a další podobné triky.</p>

<p>Nastavení modulace textur se v&nbsp;OpenGL provádí pomocí funkcí:</p>

<pre>
void glTexEnvf(
    GLenum  target,
    GLenum  pname,
    GLfloat param
);

void glTexEnvi(
    GLenum  target,
    GLenum  pname,
    GLint   param
);
</pre>

<p>popřípadě funkcemi, jejichž posledním parametrem je ukazatel na pole hodnot:</p>

<pre>
void glTexEnvfv(
    GLenum target,
    GLenum pname,
    const  GLfloat *params
);

void glTexEnviv(
    GLenum target,
    GLenum pname,
    const  GLint *params
);
</pre>

<p>V&nbsp;knihovně Pyglet se nemusíme zabývat přesnými typy parametrů, takže se hlavičky funkcí zjednoduší na:</p>

<pre>
def glTexEnvf(
    target,
    pname,
    param
)

def glTexEnvi(
    target,
    pname,
    param
)

def glTexEnvfv(
    target,
    pname,
    params
)

def glTexEnviv(
    target,
    pname,
    params
)
</pre>

<p>Význam jednotlivých argumentů těchto funkcí je následující:</p>

<ul>

<li>Při volání všech uvedených funkcí se do prvního argumentu <strong>target</strong> zadává cílový objekt (nebo typ objektu) v&nbsp;kontextu knihovny OpenGL, jehož parametry měníme. V&nbsp;případě textur se do tohoto argumentu vždy zadává symbolická konstanta <strong>GL_TEXTURE_ENV</strong>.</li>

<li>Druhý argument <strong>pname</strong> může nabývat několika hodnot, podle toho, jaké konkrétní parametry texturování měníme. První povolenou hodnotou je <strong>GL_TEXTURE_ENV_MODE</strong>, kdy v&nbsp;dalším parametru <strong>param</strong> specifikujeme mód výpočtu textur. Druhou hodnotou tohoto argumentu je symbolická konstanta <strong>GL_TEXTURE_ENV_COLOR</strong>, kdy je dalším parametrem <strong>params</strong> zadávána barva použitá při blendingu (míchání) textur. Obě možnosti si konkrétně vysvětlíme v&nbsp;navazujících kapitolách. Další možné hodnoty tohoto parametru jsou <strong>GL_COMBINE_RGB</strong>, <strong>GL_COMBINE_ALPHA</strong>, <strong>GL_RGB_SCALE</strong>, <strong>GL_ALPHA_SCALE</strong>, <strong>GL_SRC0_RGB</strong>, <strong>GL_SRC1_RGB</strong>, <strong>GL_SRC2_RGB</strong>, <strong>GL_SRC0_ALPHA</strong>, <strong>GL_SRC1_ALPHA</strong> a <strong>GL_SRC2_ALPHA</strong>.</li>

<li>V&nbsp;posledním argumentu <strong>param</strong> resp. <strong>params</strong> jsou buď zadány režimy výpočtu textur, nebo barva použitá při takzvaném blendingu textur.</li>

</ul>



<p><a name="k05"></a></p>
<h2 id="k05">5. Režimy výpočtu barev stěn při nanášení textur</h2>

<p>Pomocí funkcí <strong>glTexEnvi()</strong> a <strong>glTexEnvf()</strong>, které jsou popsané <a href="#k04">v&nbsp;předchozí kapitole</a>, je možné nastavit režim výpočtu textur, tj.&nbsp;způsob, jakým bude barva jednotlivých texelů textury kombinována s&nbsp;jinou barvou, získanou například pomocí osvětlovacího modelu. Nastavování se provede konkrétně tímto příkazem:</p>

<pre>
glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, mode); 
</pre>

<p>přičemž poslední argument mode může nabývat tří hodnot:</p>

<ul>
<li><strong>GL_DECAL</strong> &ndash; jednotlivé texely budou nanášeny na vykreslovaný povrch bez dalších úprav. Tímto příkazem tedy zakazujeme jak blending, tak i modulaci textur. Více informací o tomto režimu je uvedeno v&nbsp;dalším textu.</li>
<li><strong>GL_BLEND</strong> &ndash; vykreslované texely jsou míchány s&nbsp;předem zadanou barvou.</li>
<li><strong>GL_MODULATE</strong> &ndash; vykreslované texely čtené z&nbsp;rastrové textury jsou modulovány podkladovou barvou.</li>
</ul>

<p>Důležité je vědět, že při inicializaci aplikace, která pro vykreslování používá grafickou knihovnu OpenGL, je standardně nastaveno modulování textur (tj. <strong>GL_MODULATE</strong>) a míchací barva (<strong>GL_TEXTURE_ENV_COLOR</strong>) pro blending je černá s&nbsp;nulovou alfa složkou, tj. (0, 0, 0, 0).</p>

<p>Při běhu aplikace je možné provést dotaz na aktuálně nastavený režim výpočtu textur. K tomuto účelu se používají funkce:</p>

<pre>
void glGetTexEnvfv(
    GLenum target,
    GLenum pname,
    GLfloat * params
);

void glGetTexEnviv(
    GLenum target,
    GLenum pname,
    GLint * params
);
</pre>

<p>Význam jednotlivých parametrů je stejný jako při zadávání režimu výpočtu, pouze s&nbsp;tím rozdílem, že poslední argumenty jsou určeny pro přepis, tj.&nbsp;je v&nbsp;nich vrácena nastavená hodnota.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý demonstrační příklad &ndash; nanesení textury na různobarevné čtverce</h2>

<p>V&nbsp;dnešním druhém demonstračním příkladu je vykresleno pět čtverců s&nbsp;použitím této funkce:

<pre>
def draw_quad(x, y):
    glBegin(GL_QUADS)

    glTexCoord2f(0.0, 0.0)
    glVertex2i(x, y)

    glTexCoord2f(1.0, 0.0)
    glVertex2i(x+150, y)

    glTexCoord2f(1.0, 1.0)
    glVertex2i(x+150, y+150)

    glTexCoord2f(0.0, 1.0)
    glVertex2i(x, y+150)

    glEnd()
</pre>

<p>Každý čtverec má nastavenou jinou podkladovou barvu a je na něj nanesena textura:</p>

<pre>
glEnable(GL_TEXTURE_2D)

# prostredni ctverec
glColor3f(1.0, 1.0, 1.0)
draw_quad(165, 165)

# vlevo chybi cervena slozka
glColor3f(0.0, 1.0, 1.0)
draw_quad(10, 165)

# vpravo chybi modra slozka
glColor3f(1.0, 1.0, 0.0)
draw_quad(320, 165)

# nahore chybi zelena slozka
glColor3f(1.0, 0.0, 1.0)
draw_quad(165, 320)

# dole chybi zelena a modra slozka
glColor3f(1.0, 0.0, 0.0)
draw_quad(165, 10)
</pre>

<p>Textura je sice vždy tvořena stejným obrázkem, ovšem díky použití alfa kanálu a implicitní operaci <strong>GL_MODULATE</strong> jsou texely zkombinovány s&nbsp;podkladovou barvou. Výsledkem bude tato scéna:</p>

*** image ***
<p><i>Obrázek 3: Screenshot dnešního druhého demonstračního příkladu.</i></p>

<p>Následuje výpis zdrojového kódu demonstračního příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS)

    glTexCoord2f(0.0, 0.0)
    glVertex2i(x, y)

    glTexCoord2f(1.0, 0.0)
    glVertex2i(x+150, y)

    glTexCoord2f(1.0, 1.0)
    glVertex2i(x+150, y+150)

    glTexCoord2f(0.0, 1.0)
    glVertex2i(x, y+150)

    glEnd()


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)

    # prostredni ctverec
    glColor3f(1.0, 1.0, 1.0)
    draw_quad(165, 165)

    # vlevo chybi cervena slozka
    glColor3f(0.0, 1.0, 1.0)
    draw_quad(10, 165)

    # vpravo chybi modra slozka
    glColor3f(1.0, 1.0, 0.0)
    draw_quad(320, 165)

    # nahore chybi zelena slozka
    glColor3f(1.0, 0.0, 1.0)
    draw_quad(165, 320)

    # dole chybi zelena a modra slozka
    glColor3f(1.0, 0.0, 0.0)
    draw_quad(165, 10)



# spusteni aplikace
pyglet.app.run()
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zákaz modulace textur</h2>

<p>Jestliže v&nbsp;aplikaci používající knihovny OpenGL a Pyglet zavoláme následující příkaz:</p>

<pre>
glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE)
</pre>

<p>bude při nanášení texelů na povrch těles původní barva odstraněna a uvidíme tedy pouze texturu, nikoli případné barevné pozadí. To platí i ve chvíli, kdy textura obsahuje poloprůhledné pixely (režim RGBA) &ndash; průhlednost je totiž zcela ignorována. Výsledkem aplikace tohoto režimu v&nbsp;našem demonstračním příkladu bude následující obrázek, v&nbsp;němž není ani stopa po původní barvě čtverců:</p>

*** image ***
<p><i>Obrázek 4: Screenshot dnešního třetího demonstračního příkladu.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí demonstrační příklad &ndash; zákaz modulace textur</h2>

<p>Čtvrtý screenshot, který jste mohli vidět <a href="#k07">v&nbsp;předchozí kapitole</a>, byl získán po nastavení:</p>

<pre>
glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE)
</pre>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS)

    glTexCoord2f(0.0, 0.0)
    glVertex2i(x, y)

    glTexCoord2f(1.0, 0.0)
    glVertex2i(x+150, y)

    glTexCoord2f(1.0, 1.0)
    glVertex2i(x+150, y+150)

    glTexCoord2f(0.0, 1.0)
    glVertex2i(x, y+150)

    glEnd()


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)

    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE)

    # prostredni ctverec
    glColor3f(1.0, 1.0, 1.0)
    draw_quad(165, 165)

    # vlevo chybi cervena slozka
    glColor3f(0.0, 1.0, 1.0)
    draw_quad(10, 165)

    # vpravo chybi modra slozka
    glColor3f(1.0, 1.0, 0.0)
    draw_quad(320, 165)

    # nahore chybi zelena slozka
    glColor3f(1.0, 0.0, 1.0)
    draw_quad(165, 320)

    # dole chybi zelena a modra slozka
    glColor3f(1.0, 0.0, 0.0)
    draw_quad(165, 10)



# spusteni aplikace
pyglet.app.run()
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Nanášení texelů bez dalších úprav popř.&nbsp;použití alfa kanálu textury</h2>

<p>V&nbsp;případě, že je texturování nastaveno do režimu <strong>GL_DECAL</strong>, jsou barvy texelů pro některé typy textur mapovány do jednotlivých fragmentů bez dalších úprav barvových složek. Jestliže je však formát textury nastaven tak, že neobsahuje přímé barvy (což je dnes zcela běžné), jsou tyto barvy vypočteny buď na základě zadané intenzity či luminance (tj.&nbsp;textury ve stupních šedi), nebo se použije původní barva fragmentu (formát <strong>GL_ALPHA</strong>). Pokud je textura uložena v&nbsp;barvovém modelu RGBA, je provedeno i míchání barev na základě alfa složky texelů. Naše zkušební textura se zeměkoulí používá barvový model RGBA, takže se v&nbsp;demonstračním příkladu použije právě tato možnost.</p>

<p>Všechny popsané možnosti jsou vyjádřeny v&nbsp;následující tabulce:</p>

<table>
<tr><td>Počet<br />barvových<br />komponent</td><td>Typ<br />komponent</td><td>Výpočet<br />barvy</td></tr>
<tr><td>1</td><td>GL_ALPHA</td><td>C=C<sub>f</sub><br />A=A<sub>t</sub></td></tr>
<tr><td>1</td><td>GL_LUMINANCE</td><td>C=L<sub>t</sub><br />A=A<sub>f</sub></td></tr>
<tr><td>1</td><td>GL_INTENSITY</td><td>C=I<sub>t</sub><br />A=I<sub>t</sub></td></tr>
<tr><td>2</td><td>GL_LUMINANCE_ALPHA</td><td>C=L<sub>t</sub><br />A=A<sub>t</sub></td></tr>
<tr><td>3</td><td>GL_RGB</td><td>C=C<sub>t</sub><br />A=A<sub>f</sub></td></tr>
<tr><td>4</td><td>GL_RGBA</td><td>C=(1-A<sub>t</sub>)C<sub>f</sub>+A<sub>t</sub>C<sub>t</sub><br />A=A<sub>t</sub></td></tr>
</table>

<p>Poznámka: dnes se prakticky setkáme jen s&nbsp;pátým a se šestým formátem.</p>

<p>Význam jednotlivých symbolů:</p>

<table>
<tr><th>Symbol</th><th>Význam</th></tr>
<tr><td>C</td><td>výsledná barva, jedná se o vektor C=(R, G, B)</td></tr>
<tr><td>C<sub>f</sub></td><td>barva fragmentu</td></tr>
<tr><td>C<sub>t</sub></td><td>barva texelu</td></tr>
<tr><td>A</td><td>vypočtená alfa složka</td></tr>
<tr><td>A<sub>f</sub></td><td>alfa složka fragmentu</td></tr>
<tr><td>A<sub>t</sub></td><td>alfa složka texelu</td></tr>
<tr><td>L<sub>t</sub></td><td>luminance texelu</td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Čtvrtý demonstrační příklad: použití alfa kanálu textury</h2>

<p>V&nbsp;dalším příkladu je texturovací jednotka nastavena do režimu <strong>GL_DECAL</strong></p>

<pre>
glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL)
</pre>

<p>Výsledkem by měla být tato scéna, protože naše textura je uložena v&nbsp;barvovém modelu RGBA a v&nbsp;režimu <strong>GL_DECAL</strong> je za těchto okolností provedeno míchání barev na základě alfa složky texelů:</p>

*** image ***
<p><i>Obrázek 5: Screenshot dnešního čtvrtého demonstračního příkladu.</i></p>

<p>Následuje výpis zdrojového kódu demonstračního příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS)

    glTexCoord2f(0.0, 0.0)
    glVertex2i(x, y)

    glTexCoord2f(1.0, 0.0)
    glVertex2i(x+150, y)

    glTexCoord2f(1.0, 1.0)
    glVertex2i(x+150, y+150)

    glTexCoord2f(0.0, 1.0)
    glVertex2i(x, y+150)

    glEnd()


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)

    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL)

    # prostredni ctverec
    glColor3f(1.0, 1.0, 1.0)
    draw_quad(165, 165)

    # vlevo chybi cervena slozka
    glColor3f(0.0, 1.0, 1.0)
    draw_quad(10, 165)

    # vpravo chybi modra slozka
    glColor3f(1.0, 1.0, 0.0)
    draw_quad(320, 165)

    # nahore chybi zelena slozka
    glColor3f(1.0, 0.0, 1.0)
    draw_quad(165, 320)

    # dole chybi zelena a modra slozka
    glColor3f(1.0, 0.0, 0.0)
    draw_quad(165, 10)



# spusteni aplikace
pyglet.app.run()
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Blending na úrovni textur</h2>

<p>V&nbsp;případě, že je povolen blending textur, tj.&nbsp;když je zavolán příkaz:</p>

<pre>
glTexEnvi(GL_TEX­TURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND)
</pre>

<p>musí se specifikovat barva, se kterou se bude textura míchat. Pro zadání této barvy je možné použít funkce:</p>

<pre>
glTexEnviv(GL_TEX­TURE_ENV, GL_TEXTURE_ENV_COLOR, color)
</pre>

<p>resp.:</p>

<pre>
glTexEnvfv(GL_TEX­TURE_ENV, GL_TEXTURE_ENV_COLOR, color)
</pre>

<p>kde <strong>color</strong> je v&nbsp;jazyku C ukazatel na čtyři hodnoty typu <strong>GLint</strong> nebo <strong>GLfloat</strong>, které reprezentují barvu v&nbsp;barvovém modelu RGBA. Pokud je blending vypnutý, nemá nastavená barva na vykreslovanou texturu samozřejmě žádný vliv.</p>

<p>Pokud je barva zadaná jako čtyři složky typu <strong>GLfloat</strong>, jsou tyto složky oříznuty do intervalu –1..1. Pokud se naopak použijí složky typu <strong>GLint</strong>, je interně proveden převod na <strong>GLfloat</strong> tak, aby byla nejvyšší hodnota typu <strong>GLint</strong> převedena na hodnotu 1.0 a nejnižší hodnota na –1.0.</p>

<p>Připomeňme si, že při zadávání rastrových dat textury pomocí funkce <strong>glTexImage()</strong> je v&nbsp;této funkci specifikováno, které složky barvy jsou v&nbsp;textuře použity. V&nbsp;případě, že je zadána pouze jedna složka, je považována za světlost (<strong>L</strong> &ndash; <i>Luminance</i>). Pokud jsou zadány složky dvě, jsou považovány za světlost následovanou průhledností alfa. Tři zadané složky představují barvový model RGB bez alfa kanálu, složky čtyři potom úplný model RGBA.</p>

<p>V&nbsp;následující tabulce je ukázáno, jak se vypočte vykreslovaná barva v&nbsp;režimu <strong>GL_BLEND</strong> v&nbsp;závislosti na počtu a typu barevných komponent:</p>

<table>
<tr><td>Počet<br />barvových<br />komponent</td><td>Typ<br />komponent</td><td>Výpočet<br />barvy</td></tr>
<tr><td>1</td><td>GL_ALPHA</td><td>není definováno</td></tr>
<tr><td>1</td><td>GL_LUMINANCE</td><td>C=(1-L<sub>t</sub>)C<sub>f</sub>+L<sub>t</sub>C<sub>c</sub><br />A=A<sub>t</sub></td></tr>
<tr><td>1</td><td>GL_INTENSITY</td><td>C=(1-I<sub>t</sub>)C<sub>f</sub>+I<sub>t</sub>C<sub>c</sub><br />A=A<sub>t</sub></td></tr>
<tr><td>2</td><td>GL_LUMINANCE_ALPHA</td><td>C=(1-L<sub>t</sub>)C<sub>f</sub>+L<sub>t</sub>C<sub>c</sub><br />A=A<sub>f</sub>A<sub>t</sub></td></tr>
<tr><td>3</td><td>GL_RGB</td><td>není definováno</td></tr>
<tr><td>4</td><td>GL_RGBA</td><td>není definováno</td></tr>

<p>Význam jednotlivých symbolů:</p>

<table>
<tr><th>Symbol</th><th>Význam</th></tr>
<tr><td>C</td><td>výsledná barva, jedná se o vektor C=(R, G, B)</td></tr>
<tr><td>C<sub>f</sub></td><td>barva fragmentu</td></tr>
<tr><td>C<sub>t</sub></td><td>barva texelu</td></tr>
<tr><td>C<sub>c</sub></td><td>barva nastavená pomocí funkce glTexEnv*v()</td></tr>
<tr><td>A</td><td>vypočtená alfa složka</td></tr>
<tr><td>A<sub>f</sub></td><td>alfa složka fragmentu</td></tr>
<tr><td>A<sub>t</sub></td><td>alfa složka texelu</td></tr>
<tr><td>L<sub>t</sub></td><td>luminance texelu</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Předání parametrů funkcím glTexEnviv a glTexEnvfv</h2>

<p>Podívejme se nyní na způsob předání parametrů funkcím <strong>glTexEnviv</strong> a <strong>glTexEnvfv</strong>. V&nbsp;programovacím jazyku C je předání jednoduché, protože se použije ukazatel na konkrétní pole s&nbsp;prvky. Při volání wrapperů těchto funkcí v&nbsp;Pythonu musíme použít modul <strong>ctypes</strong>. Nejprve vytvoříme běžný seznam, zde konkrétně obsahující barvu, tj.&nbsp;trojici hodnot RGB:</p>

<pre>
color = [0.5, 0.5, 0.5]
</pre>

<p>Následně musíme tento seznam převést na pole, zde konkrétně pole prvků typu <strong>GLfloat</strong>. Následující příkaz se skládá ze tří částí &ndash; vytvoření pole o třech prvcích typu <strong>GLfloat</strong> (výraz v&nbsp;první závorce, jedná se o idiomatický způsob zápisu), předání seznamu ve formě n-tice (výraz ve druhé závorce s&nbsp;hvězdičkou na začátku) a přiřazení výsledku (což je v&nbsp;tomto případě objekt vytvořený z&nbsp;třídy <strong>PyCArrayType</strong>) do proměnné <strong>color_gl</strong>:</p>

<pre>
color_gl = (GLfloat * len(color))(*color)
</pre>

<p>Následně je již možné zavolat kýženou funkci, zde konkrétně <strong>glTexEnvfv</strong>:</p>

<pre>
glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, color_gl)
</pre>

<p>Poznámka: samozřejmě je možné všechny tři příkazy vykonat přímo ve volání funkce <strong>glTexEnvfv</strong>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Pátý demonstrační příklad &ndash; blending na úrovni textur</h2>

<p><a href="#k12">Výše popsané</a> předání parametrů funkci <strong>glTexEnvfv()</strong> je použito v&nbsp;pátém a dnes i posledním demonstračním příkladu, jehož úplný zdrojový kód vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS)

    glTexCoord2f(0.0, 0.0)
    glVertex2i(x, y)

    glTexCoord2f(1.0, 0.0)
    glVertex2i(x+150, y)

    glTexCoord2f(1.0, 1.0)
    glVertex2i(x+150, y+150)

    glTexCoord2f(0.0, 1.0)
    glVertex2i(x, y+150)

    glEnd()


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)

    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND)
    color = [0.5, 0.5, 0.5]
    color_gl = (GLfloat * len(color))(*color)
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, color_gl)


    # prostredni ctverec
    glColor3f(1.0, 1.0, 1.0)
    draw_quad(165, 165)

    # vlevo chybi cervena slozka
    glColor3f(0.0, 1.0, 1.0)
    draw_quad(10, 165)

    # vpravo chybi modra slozka
    glColor3f(1.0, 1.0, 0.0)
    draw_quad(320, 165)

    # nahore chybi zelena slozka
    glColor3f(1.0, 0.0, 1.0)
    draw_quad(165, 320)

    # dole chybi zelena a modra slozka
    glColor3f(1.0, 0.0, 0.0)
    draw_quad(165, 10)



# spusteni aplikace
pyglet.app.run()
</pre>

*** image ***
<p><i>Obrázek 6: Screenshot dnešního pátého demonstračního příkladu.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Funkce knihovny OpenGL a pomocné knihovny GLU, které byly použity ve zdrojových kódech</h2>

<p>V&nbsp;demonstračních příkladech, které byly uvedeny v&nbsp;dnešním článku, byly použity následující funkce převzaté z&nbsp;knihoven OpenGL a GLU:</p>

<ol>

<li>glLoadIdentity<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml</a>
</li>

<li>glRotate<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml</a>
</li>

<li>glMatrixMode<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml</a>
</li>

<li>glViewport<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glViewport.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glViewport.xml</a>
</li>

<li>glColor3f<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml</a>
</li>

<li>glClearColor<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearColor.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearColor.xml</a>
</li>

<li>glClear<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClear.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClear.xml</a>
</li>

<li>glTexEnvi<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glTexEnvf<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glTexEnviv<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glTexEnvfv<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glBegin<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml</a>
</li>

<li>glEnd<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml</a>
</li>

<li>glBindTexture<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBindTexture.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBindTexture.xml</a>
</li>

<li>glTexParameteri<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexParameter.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexParameter.xml</a>
</li>

<li>glEnable<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml</a>
</li>

<li>glDisable<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml</a>
</li>

<li>glDepthFunc<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDepthFunc.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDepthFunc.xml</a>
</li>

<li>glVertex3f<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml</a>
</li>

<li>glTexCoord2f<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml</a>
</li>

<li>gluLookAt<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml</a>
</li>

<li>gluPerspective<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml</a>
</li>

</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace balíčku s&nbsp;Pygletem, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>41_texture_on_3d.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/41_texture_on_3d.py">https://github.com/tisnik/presentations/blob/master/pyglet/41_texture_on_3d.py</a></td></tr>
<tr><td>42_textures_and_colors_modulate.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/42_textures_and_colors_modulate.py">https://github.com/tisnik/presentations/blob/master/pyglet/42_textures_and_colors_modulate.py</a></td></tr>
<tr><td>43_textures_and_colors_replace.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/43_textures_and_colors_replace.py">https://github.com/tisnik/presentations/blob/master/pyglet/43_textures_and_colors_replace.py</a></td></tr>
<tr><td>44_textures_and_colors_decal.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/44_textures_and_colors_decal.py">https://github.com/tisnik/presentations/blob/master/pyglet/44_textures_and_colors_decal.py</a></td></tr>
<tr><td>45_textures_and_colors_blend.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/45_textures_and_colors_blend.py">https://github.com/tisnik/presentations/blob/master/pyglet/45_textures_and_colors_blend.py</a></td></tr>
</table>

<p>Poznámka: všechny demonstrační příklady navíc vyžadují v&nbsp;aktuálním adresáři přítomnost <a href="https://github.com/tisnik/presentations/blob/master/pyglet/gnome-globe.png">tohoto obrázku</a>, z&nbsp;něhož se textura vytváří.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>glTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glGetTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml</a>
</li>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

