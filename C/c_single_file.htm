<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Svět jednohlavičkových knihoven pro jazyky C a C++</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Svět jednohlavičkových knihoven pro jazyky C a C++</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes se seznámíme s konceptem takzvaných jednohlavičkových knihoven (header-only library) používaných v C i C++. Jedná se o knihovny, které jsou celé tvořeny pouze jediným hlavičkovým souborem obsahujícím definice maker, definice funkcí a současně i jejich deklarace.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Svět jednohlavičkových knihoven pro jazyky C a C++</a></p>
<p><a href="#k02">2. Výhody a nevýhody jednohlavičkových knihoven</a></p>
<p><a href="#k03">3. Ukázka typické jednohlavičkové knihovny: <strong>stb_image_write.h</strong></a></p>
<p><a href="#k04">4. Korektní způsob použití knihovny <strong>stb_image_write.h</strong></a></p>
<p><a href="#k05">5. Prototypy funkcí vs definice funkcí</a></p>
<p><a href="#k06">6. Kontroly chybových stavů</a></p>
<p><a href="#k07">7. Oddělený překlad jednohlavičkové knihovny?</a></p>
<p><a href="#k08">8. Rozdělení překladu knihovny <strong>stb_image_write.h</strong> od zbytku aplikace</a></p>
<p><a href="#k09">9. Kombinace většího množství jednohlavičkových knihoven</a></p>
<p><a href="#k10">10. Vykreslení Perlinova šumu s&nbsp;uložením výsledného obrázku na disk</a></p>
<p><a href="#k11">11. Jednohlavičkové knihovny s&nbsp;implementací (datových) kontejnerů</a></p>
<p><a href="#k12">12. Vektory s&nbsp;dynamicky měnitelnou kapacitou</a></p>
<p><a href="#k13">13. Demonstrační příklady: manipulace s&nbsp;vektory</a></p>
<p><a href="#k14">14. Mapy (slovníky)</a></p>
<p><a href="#k15">15. Demonstrační příklady: použití slovníků</a></p>
<p><a href="#k16">16. Jednohlavičková knihovna pro vyhodnocování výrazů</a></p>
<p><a href="#k17">*** 17. Příklady realizace vyhodnocování výrazů bez proměnných i s&nbsp;proměnnými</a></p>
<p><a href="#k18">18. Příloha: Makefile soubor pro překlad všech demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Svět jednohlavičkových knihoven pro jazyky C a C++</h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;konceptem takzvaných
jednohlavičkových knihoven (<i>header-only library</i>) v&nbsp;ekosystému
programovacích jazyků C a C++. Jak již název napovídá, jedná se o knihovny,
které jsou celé tvořeny pouze jediným hlavičkovým souborem, jenž obsahuje
definice maker, definice funkcí a současně i jejich deklarace.
V&nbsp;závislosti na konkrétní knihovně je možné tyto hlavičkové soubory přímo
vložit do zdrojových kódů příkazem preprocesoru <strong>#include</strong>,
ovšem některé z&nbsp;těchto knihoven umožňují i oddělený překlad (knihovna se
v&nbsp;takovém případě přeloží do objektového souboru, který se následně může
slinkovat s&nbsp;ostatními objektovými soubory). Jednohlavičkové soubory jsou
poměrně populární, zejména kvůli snadnosti jejich instalace a zařazení do
vyvíjeného projektu. Na druhou stranu však zejména v&nbsp;případě
programovacího jazyka C můžeme narazit na určitá omezení, která jsou daná jak
typovým systémem tohoto jazyka, tak i neexistencí jmenných prostorů
(<i>namespace</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Výhody a nevýhody jednohlavičkových knihoven</h2>

<p>Jak jsem se již zmínil <a href="#k01">v&nbsp;úvodní kapitole</a>, jsou
jednohlavičkové knihovny ve světě programovacích jazyků C a C++ poměrně
populární. Přispívá k&nbsp;tomu i fakt, že takové knihovny lze velmi snadno
začlenit do vytvářeného projektu a navíc nejsou vývojáři nuceni používat
sofistikované (a mnohdy zbytečně komplikované) správce projektů a balíčků;
vystačí si s&nbsp;nástroji <strong>make</strong>, <strong>git</strong> nebo i
jen s&nbsp;nástrojem <strong>wget</strong>. Ostatně v&nbsp;této oblasti
neexistuje pro jazyky C ani C++ jednotný a uznávaný standard, takže by se mohlo
s&nbsp;nadsázkou říci, že jakékoli řešení je lepší než žádné řešení.</p>

<p>Ovšem kromě předností má toto řešení i několik více či méně závažných
záporů. Často se zmiňuje fakt, že modifikace provedené v&nbsp;kódu vkládané
jednohlavičkové knihovny vyžaduje přeložení všech dalších zdrojových kódů,
které tuto knihovnu používají. To je však většinou nutné provést v&nbsp;každém
případě, tedy i kdyby se používal oddělený překlad (vyžaduje to koncept
hlavičkových souborů). V&nbsp;případě, že se jednohlavičková knihovna vkládá
přímo do zdrojového kódu i s&nbsp;těly funkcí, bude pochopitelně delší i čas
překladu tohoto zdrojového kódu. Tento problém mnohé knihovny řeší tak, že
umožňují oddělený překlad. A poslední problém (který lze též do jisté míry
řešit odděleným překladem) spočívá v&nbsp;tom, že jazyk C nepodporuje změnu
jmenných prostorů, takže teoreticky může nastat situace, kdy knihovna i kód
použijí stejný symbol v&nbsp;různých kontextech. Jednohlavičkové knihovny musí
všechny své symboly začínat stejným prefixem a naopak ostatní kód by takový
prefix používat neměl.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázka typické jednohlavičkové knihovny: <strong>stb_image_write.h</strong></h2>

<p>První jednohlavičkovou knihovnou, se kterou se v&nbsp;dnešním článku alespoň
ve stručnosti seznámíme, je knihovna nazvaná
<strong>stb_image_write.h</strong>. Tato knihovna obsahuje definice funkcí
sloužících pro ukládání rastrových obrázků do formátů PNG, BMP, TGA, JPG a HDR.
Jedná se o tyto funkce:</p>

<pre>
int <strong>stbi_write_png</strong>(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);
int <strong>stbi_write_bmp</strong>(char const *filename, int w, int h, int comp, const void *data);
int <strong>stbi_write_tga</strong>(char const *filename, int w, int h, int comp, const void *data);
int <strong>stbi_write_jpg</strong>(char const *filename, int w, int h, int comp, const void *data, int quality);
int <strong>stbi_write_hdr</strong>(char const *filename, int w, int h, int comp, const float *data);
</pre>

<p>Dále tato knihovna obsahuje zobecněné funkce, které lze využít například při
posílání rastrového obrázku přes sockety atd. Tyto funkce neprovádí přímé
manipulace se soubory, ale provedou uložení rastrového obrázku do zvoleného
formátu v&nbsp;operační paměti a přitom zavolají nastavenou callback
funkci:</p>

<pre>
int <strong>stbi_write_png_to_func</strong>(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);
int <strong>stbi_write_bmp_to_func</strong>(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
int <strong>stbi_write_tga_to_func</strong>(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
int <strong>stbi_write_hdr_to_func</strong>(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);
int <strong>stbi_write_jpg_to_func</strong>(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality);
</pre>

<p>Callback funkce, která bude automaticky zavolána, musí mít tuto
hlavičku:</p>

<pre>
void <strong>stbi_write_func</strong>(void *context, void *data, int size);
</pre>

<p>Navíc je možné přes další funkce ovlivnit například úroveň komprimace u
formátu PNG atd. (výchozí úroveň je nízká, takže lze PNG dále optimalizovat,
například nástrojem <strong>pngcrush</strong> atd.).</p>

<p>Knihovnu <strong>stb_image_write.h</strong> získáme snadno:</p>

<pre>
$ <strong>wget https://raw.githubusercontent.com/nothings/stb/refs/heads/master/stb_image_write.h</strong>
&nbsp;
Saving 'stb_image_write.h'
HTTP response 200  [https://raw.githubusercontent.com/nothings/stb/refs/heads/master/stb_image_write.h]
stb_image_write.h    100% [=====================================================================================&gt;]   19.88K    --.-KB/s
                          [Files: 1  Bytes: 19.88K [68.56KB/s] Redirects: 0  Todo: 0  Errors: 0                  ]
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Korektní způsob použití knihovny <strong>stb_image_write.h</strong></h2>

<p>Použití knihovny <strong>stb_image_write.h</strong> je poměrně snadné.
Ukážeme si to na několika jednoduchých a krátkých demonstračních příkladech.
V&nbsp;prvním příkladu provedeme uložení rastrového obrázku o velikosti
4&times;4 pixely do formátu PNG. Jednotlivé pixely jsou reprezentovány
32bitovou hodnotou RGBA (nejvyšší bajt nese informaci o průhlednosti, další tři
bajty pak barvové složky RGB, ovšem v&nbsp;pořadí modrá-zelená-červená). To
tedy znamená, že obrázek 4&times;4 pixely s&nbsp;černým okrajem, uvnitř něhož
je uložen červený, zelený, žlutý a modrý pixel, lze reprezentovat
následovně:</p>

<pre>
uint32_t <strong>image</strong>[] = {
    0xff000000, 0xff000000, 0xff000000, 0xff000000,
    0xff000000, 0xff0000ff, 0xff00ff00, 0xff000000,
    0xff000000, 0xff00ffff, 0xffff0000, 0xff000000,
    0xff000000, 0xff000000, 0xff000000, 0xff000000,
};
</pre>

<p>Knihovnu <strong>stb_image_write.h</strong> vložíme do zdrojového kódu takto
(včetně definice makrosymbolu):</p>

<pre>
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
</pre>

<p>Uložení rastrového obrázku do souboru typu PNG je snadné:</p>

<pre>
stbi_write_png("test.png", šířka, výška, bajtů_na_pixel, rastrový_obrázek, stride_délka_řádku);
</pre>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu může vypadat
následovně:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
&nbsp;
#define WIDTH 4
#define HEIGHT 4
#define RGBA 4
&nbsp;
uint32_t <strong>image</strong>[] = {
    0xff000000, 0xff000000, 0xff000000, 0xff000000,
    0xff000000, 0xff0000ff, 0xff00ff00, 0xff000000,
    0xff000000, 0xff00ffff, 0xffff0000, 0xff000000,
    0xff000000, 0xff000000, 0xff000000, 0xff000000,
};
&nbsp;
int <strong>main</strong>(void) {
    stbi_write_png("test.png", WIDTH, HEIGHT, RGBA, image, 4*sizeof(uint32_t));
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: poslední parametr obsahuje informaci o
délce obrazového řádku v&nbsp;bajtech.</div></p>

<p>Překlad zdrojového kódu tohoto demonstračního příkladu je snadný:</p>

<pre>
$ <strong>gcc -Wall -pedantic simple_image_2.c -o simple_image_2</strong>
</pre>

<p>Po překladu tento příklad spustíme:</p>

<pre>
$ <strong>./simple_image_2</strong>
</pre>

<p>V&nbsp;pracovním adresáři by měl po spuštění vzniknout rastrový obrázek
uložený do souboru s&nbsp;názvem <strong>test.png</strong>:</p>

<pre>
$ <strong>ls -1</strong>
&nbsp;
simple_image_1.c
simple_image_2
stb_image_write.h
test.png
</pre>

<p>Ověříme si, zda se skutečně jedná o rastrový obrázek:</p>

<pre>
$ <strong>file test.png</strong>
&nbsp;
test.png: PNG image data, 4 x 4, 8-bit/color RGBA, non-interlaced
</pre>

<p>Výsledek po zvětšení dvacetinásobném zvětšení získaného rastrového
obrázku:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 80px"><a href="https://www.root.cz/obrazek/1273815/"><img src="https://i.iinfo.cz/images/604/header-only-3.png" class="image-1273815" width="80" height="80" data-prev-filename="https://i.iinfo.cz/images/604/header-only-3.png" data-prev-filename-webp="https://i.iinfo.cz/images/604/header-only-3.webp" data-prev-width="80" data-prev-height="80" data-large-filename="https://i.iinfo.cz/images/604/header-only-3.png" data-large-filename-webp="https://i.iinfo.cz/images/604/header-only-3.webp" data-large-width="80" data-large-height="80" alt="Header-only libraries" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 80px" /></a><p>&#160;Obrázek 1: Rastrový obrázek 4&times;4 pixely vytvořený demonstračním příkladem.</p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k05"></a></p>
<h2 id="k05">5. Prototypy funkcí vs definice funkcí</h2>

<p>V&nbsp;předchozím demonstračním příkladu jsme před importem jednohlavičkové
knihovny definovali i symbol
<strong>STB_IMAGE_WRITE_IMPLEMENTATION</strong>:</p>

<pre>
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
</pre>

<p>Tento symbol zajistí, že se při importu vloží do zdrojového kódu nejenom
hlavičky všech funkcí, ale i jejich implementace.</p>

<p>Otestujme si, co se stane v&nbsp;případě, že se pouze pokusíme o vložení
hlavičkového souboru bez definice
<strong>STB_IMAGE_WRITE_IMPLEMENTATION</strong>:</p>

<pre>
#include "stb_image_write.h"
</pre>

<p>Pokud se nyní pokusíme o překlad takto upraveného příkladu, dojde
k&nbsp;chybě ve fázi slinkování:</p>

<pre>
$ <strong>gcc -Wall -pedantic simple_image_1.c</strong>
&nbsp;
/usr/bin/ld: /tmp/ccwoMWRf.o: in function `main':
simple_image_1.c:(.text+0x25): undefined reference to `stbi_write_png'
collect2: error: ld returned 1 exit status
</pre>

<p><div class="rs-tip-major">Poznámka: tato chyba není způsobena chybou
v&nbsp;jednohlavičkové knihovně, ale jedná se o záměr. Díky této vlastnosti je
totiž možné v&nbsp;případě potřeby knihovnu přeložit v&nbsp;samostatném kroku a
zajistit tak její oddělený překlad.</div></p>

<p>Upravený zdroj demonstračního příkladu bude vypadat následovně:</p>

<pre>
#include &lt;stdint.h&gt;
#include "stb_image_write.h"
&nbsp;
#define WIDTH 4
#define HEIGHT 4
#define RGBA 4
&nbsp;
uint32_t <strong>image</strong>[] = {
    0xff000000, 0xff000000, 0xff000000, 0xff000000,
    0xff000000, 0xff0000ff, 0xff00ff00, 0xff000000,
    0xff000000, 0xff00ffff, 0xffff0000, 0xff000000,
    0xff000000, 0xff000000, 0xff000000, 0xff000000,
};
&nbsp;
int <strong>main</strong>(void) {
    stbi_write_png("test.png", WIDTH, HEIGHT, RGBA, image, 4*sizeof(uint32_t));
    return 0;
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Kontroly chybových stavů</h2>

<p>Většina jednohlavičkových knihoven je naprogramována zkušenými vývojáři. I
z&nbsp;tohoto důvodu je většinou vyřešen i problém hlášení chybových stavů.
V&nbsp;jazyce C neexistuje koncept klasických výjimek, takže se většinou
chybový stav oznamuje v&nbsp;návratové hodnotě funkce (nebo nastavením nějaké
globální proměnné). Příkladem může být i funkce
<strong>stbi_write_png</strong>, která vrací jedničku v&nbsp;případě, že funkce
proběhla v&nbsp;pořádku a nulu v&nbsp;opačném případě:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
&nbsp;
#define WIDTH 4
#define HEIGHT 4
#define RGBA 4
&nbsp;
uint32_t <strong>image</strong>[] = {
    0xff000000, 0xff000000, 0xff000000, 0xff000000,
    0xff000000, 0xff0000ff, 0xff00ff00, 0xff000000,
    0xff000000, 0xff00ffff, 0xffff0000, 0xff000000,
    0xff000000, 0xff000000, 0xff000000, 0xff000000,
};
&nbsp;
int <strong>main</strong>(void) {
    int status = stbi_write_png("test.png", WIDTH, HEIGHT, RGBA, image, 4*sizeof(uint32_t));
    printf("Success? %s\n", status ? "yes" : "no");
    return 0;
}
</pre>

<p>Tento příklad přeložíme běžným způsobem:</p>

<pre>
$ <strong>gcc -Wall -pedantic simple_image_3.c -o simple_image_3</strong>
</pre>

<p>Po spuštění se nejenom vytvoří výsledný obrázek, ale navíc se i zobrazí
informace o tom, jestli byla tato operace úspěšná či nikoli:</p>

<pre>
$ <strong>./simple_image_3</strong>
Success?
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Oddělený překlad jednohlavičkové knihovny?</h2>

<p>Jednou z&nbsp;nevýhod při zápisu celého kódu knihovny v&nbsp;jediném
hlavičkovém souboru je fakt, že je (zdánlivě) nutné překlad neustále opakovat
při každém vložení kódu knihovny konstrukcí <strong>#include</strong>. Mnohé
jednohlavičkové knihovny tento problém ovšem řeší, a to tak, že umožňují
oddělený překlad knihovny. Konkrétně v&nbsp;případě knihovny
<strong>stb_image_write.h</strong> jsme viděli, že pro vložení definic všech
funkcí je nutné nejdříve definovat symbol preprocesoru
<strong>STB_IMAGE_WRITE_IMPLEMENTATION</strong>. To tedy znamená, že by bylo
možné provést oddělený překlad pouze jednohlavičkové knihovny tak, jak to
zhruba odpovídá následujícímu příkazu:</p>

<pre>
$ <strong>gcc -D STB_IMAGE_WRITE_IMPLEMENTATION -c stb_image_write.h</strong>
</pre>

<p>Ovšem zde se projevuje jedna z&nbsp;vlastností překladače GCC &ndash; pokud
se překládá hlavičkový soubor (to překladač pozná podle koncovky), nebude
výsledkem objektový kód (<strong>.o</strong>), ale soubor s&nbsp;koncovkou
<strong>.gch</strong>, který obsahuje předkompilované hlavičky (což ovšem
v&nbsp;tomto případě vůbec nepotřebujeme):</p>

<pre>
$ <strong>ls -1</strong>
&nbsp;
simple_image_1.c
stb_image_write.h
stb_image_write.h.gch
</pre>

<p>I tento problém je však možné snadno vyřešit, což si ukážeme v&nbsp;další
kapitole.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rozdělení překladu knihovny <strong>stb_image_write.h</strong> od zbytku aplikace</h2>

<p>Aby překladač GCC přeložil hlavičkový soubor stejným způsobem jako běžný
zdrojový soubor napsaný v&nbsp;jazyku C, musíme překladači předat přepínač
<strong>-x c</strong>. Překlad knihovny <strong>stb_image_write</strong> do
objektového kódu obsahujícího všechny funkce provedeme následovně:</p>

<pre>
$ <strong>gcc -D STB_IMAGE_WRITE_IMPLEMENTATION -x c -c stb_image_write.h</strong>
</pre>

<p>Nyní by měl pracovní adresář obsahovat (minimálně) tyto soubory:</p>

<pre>
$ <strong>ls -1</strong>
&nbsp;
simple_image_1.c
stb_image_write.h
stb_image_write.o
</pre>

<p>Následně můžeme, zcela odděleně, přeložit zdrojový kód
<strong>simple_image_1.c</strong>, který jsme si ukázali <a href="#k04">ve
čtvrté kapitole</a>:</p>

<pre>
$ <strong>gcc -c simple_image_1.c</strong>
</pre>

<p>Obsah pracovního adresáře:</p>

<pre>
$ <strong>ls -1</strong>
&nbsp;
simple_image_1.c
simple_image_1.o
stb_image_write.h
stb_image_write.o
</pre>

<p>Na závěr oba objektové soubory slinkujeme:</p>

<pre>
$ <strong>gcc simple_image_1.o stb_image_write.o -o simple_image_1</strong>
</pre>

<p>Obsah pracovního adresáře po poslední operaci:</p>

<pre>
$ <strong>ls -1</strong>
&nbsp;
simple_image_1
simple_image_1.c
simple_image_1.o
stb_image_write.h
stb_image_write.o
</pre>

<p>Nyní již můžeme právě vytvořený spustitelný soubor skutečně spustit:</p>

<pre>
$ <strong>./simple_image_1</strong>
</pre>

<p>Výsledkem bude nový rastrový obrázek:</p>

<pre>
$ <strong>file test.png</strong>
&nbsp;
test.png: PNG image data, 4 x 4, 8-bit/color RGBA, non-interlaced
</pre>

<p><div class="rs-tip-major">Poznámka: všechny funkce přeložené do objektového
souboru si můžeme vypsat například takto:</div></p>

<pre>
$ <strong>nm -g stb_image_write.o | grep " T "</strong>
&nbsp;
0000000000000000 T stbi_flip_vertically_on_write
0000000000000ae0 T stbi_write_bmp
0000000000000a70 T stbi_write_bmp_to_func
0000000000001938 T stbi_write_hdr
00000000000018c8 T stbi_write_hdr_to_func
00000000000054c8 T stbi_write_jpg
0000000000005451 T stbi_write_jpg_to_func
00000000000039a1 T stbi_write_png
0000000000003a5b T stbi_write_png_to_func
0000000000003302 T stbi_write_png_to_mem
0000000000000f90 T stbi_write_tga
0000000000000f20 T stbi_write_tga_to_func
0000000000001c46 T stbi_zlib_compress
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Kombinace většího množství jednohlavičkových knihoven</h2>

<p>V&nbsp;praxi se dříve či později setkáme s&nbsp;požadavkem využití většího
množství jednohlavičkových knihoven v&nbsp;jednom projektu. To, zda bude
skutečně možné zkombinovat více knihoven, do značné míry závisí na tom, jestli
byli původní autoři důslední v&nbsp;pojmenovávání identifikátorů
v&nbsp;jednotlivých knihovnách. To se týká maker, datových typů, funkcí a
teoreticky i globálních proměnných. Pokud obsahují všechny tyto identifikátory
nějaký unikátní prefix, měla by být kombinace většího množství knihoven
prakticky proveditelná, což si ostatně ukážeme <a href="#k10">v&nbsp;navazující
kapitole</a>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vykreslení Perlinova šumu s&nbsp;uložením výsledného obrázku na disk</h2>

<p>Kombinaci více jednohlavičkových knihoven si ukážeme na demonstračním
příkladu, který po svém spuštění vykreslí známý Perlinův šum a uloží výsledek
do rastrového obrázku. Pro výpočet Perlinova šumu použijeme knihovnu
<strong>stb_perlin.h</strong>, jejíž zdrojový kód (v&nbsp;hlavičkovém souboru)
získáme snadno:</p>

<pre>
$ <strong>wget https://raw.githubusercontent.com/nothings/stb/refs/heads/master/stb_perlin.h</strong>
</pre>

<p>Obě knihovny můžeme do projektu vložit v&nbsp;libovolném pořadí:</p>

<pre>
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
&nbsp;
#define STB_PERLIN_IMPLEMENTATION
#include "stb_perlin.h"
</pre>

<p>Celý výpočet i s&nbsp;uložením výsledného souboru vypadá následovně:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
&nbsp;
#define STB_PERLIN_IMPLEMENTATION
#include "stb_perlin.h"
&nbsp;
#define WIDTH 512
#define HEIGHT 512
#define RGBA 4
&nbsp;
uint32_t <strong>image</strong>[HEIGHT][WIDTH] = {0};
&nbsp;
int <strong>main</strong>(void) {
    int x, y;
    for (y=0; y&lt;HEIGHT; y++) {
        for (x=0; x&lt;WIDTH; x++) {
            int i = (int)(250.0*stb_perlin_turbulence_noise3(x/50., y/50., 0, 2.1, 0.5, 6));
            if (i&gt;255) i=255;
            uint32_t color = (0xff &lt;&lt; 24) + (i &lt;&lt; 16) + (i &lt;&lt; 8) + i;
            image[y][x] = color;
        }
    }
    stbi_write_png("perlin.png", WIDTH, HEIGHT, RGBA, image, WIDTH*sizeof(uint32_t));
    return 0;
}
</pre>

<p>Po překladu a spuštění tohoto demonstračního příkladu bychom měli získat
rastrový obrázek <strong>perlin.png</strong>, který bude obsahovat Perlinův šum
reprezentovaný ve stupních šedi:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 512px"><a href="https://www.root.cz/obrazek/1273809/"><img src="https://i.iinfo.cz/images/604/header-only-1.png" class="image-1273809" width="512" height="512" data-prev-filename="https://i.iinfo.cz/images/604/header-only-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/604/header-only-1-prev.webp" data-prev-width="270" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/604/header-only-1.png" data-large-filename-webp="https://i.iinfo.cz/images/604/header-only-1.webp" data-large-width="512" data-large-height="512" alt="Header-only libraries" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 512px" /></a><p>Obrázek 2: Perlinův šum ve stupních šedi.&#160;<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>Ukažme si ještě jeden příklad generování Perlinova šumu. Nyní je šum počítán
odděleně pro každou barvovou složku:</p>

<pre>
int r = (int)(300.0*stb_perlin_turbulence_noise3(x/200., y/200., 0, 2.2, 0.5, 6));
int g = (int)(300.0*stb_perlin_turbulence_noise3(x/200., y/200., 0, 1.9, 0.5, 7));
int b = (int)(300.0*stb_perlin_turbulence_noise3(x/200., y/200., 0, 2.1, 0.5, 8));
</pre>

<p>Upravený zdrojový kód demonstračního příkladu:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
&nbsp;
#define STB_PERLIN_IMPLEMENTATION
#include "stb_perlin.h"
&nbsp;
#define WIDTH 512
#define HEIGHT 512
#define RGBA 4
&nbsp;
uint32_t <strong>image</strong>[HEIGHT][WIDTH] = {0};
&nbsp;
int <strong>main</strong>(void) {
    int x, y;
    for (y=0; y&lt;HEIGHT; y++) {
        for (x=0; x&lt;WIDTH; x++) {
            int r = (int)(300.0*stb_perlin_turbulence_noise3(x/200., y/200., 0, 2.2, 0.5, 6));
            if (r&gt;255) r=255;
            int g = (int)(300.0*stb_perlin_turbulence_noise3(x/200., y/200., 0, 1.9, 0.5, 7));
            if (g&gt;255) g=255;
            int b = (int)(300.0*stb_perlin_turbulence_noise3(x/200., y/200., 0, 2.1, 0.5, 8));
            if (b&gt;255) b=255;
            uint32_t color = (0xff &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;
            image[y][x] = color;
        }
    }
    stbi_write_png("perlin.png", WIDTH, HEIGHT, RGBA, image, WIDTH*sizeof(uint32_t));
    return 0;
}
</pre>

<p>Výsledek (podle očekávání) je zcela odlišný od předchozího příkladu:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 512px"><a href="https://www.root.cz/obrazek/1273812/"><img src="https://i.iinfo.cz/images/604/header-only-2.png" class="image-1273812" width="512" height="512" data-prev-filename="https://i.iinfo.cz/images/604/header-only-2-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/604/header-only-2-prev.webp" data-prev-width="270" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/604/header-only-2.png" data-large-filename-webp="https://i.iinfo.cz/images/604/header-only-2.webp" data-large-width="512" data-large-height="512" alt="Header-only libraries" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 512px" /></a><p>Obrázek 3: Perlinův šum vygenerovaný pro každou barvovou složku RGB zvlášť.&#160;<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k11"></a></p>
<h2 id="k11">11. Jednohlavičkové knihovny s&nbsp;implementací (datových) kontejnerů</h2>

<p>Vzhledem k&nbsp;tomu, že standardní knihovna programovacího jazyka C
prakticky neobsahuje žádnou implementaci datových kontejnerů, nebude
pravděpodobně velkým překvapením, že existuje poměrně velké množství
jednohlavičkových knihoven s&nbsp;implementací takových kontejnerů. Setkáme se
s&nbsp;implementacemi dynamických polí (ať již mají jakýkoli název), map
(slovníků), stromových datových struktur (<i>tree</i>), ale například i
jednosměrných a obousměrných front (<i>queue</i>, <i>deque</i>) nebo zásobníků
(<i>stack</i>) a cyklických front (<i>ring buffer</i>). V&nbsp;navazujících
kapitolách si ukážeme dva zástupce těchto knihoven. První z&nbsp;nich
implementuje dynamická pole (ovšem nazývá je vektory), druhá knihovna pak
obsahuje implementaci map (slovníků).</p>

<p><div class="rs-tip-major">Poznámka: u všech těchto knihoven je dobré
sledovat, jakou technologií rozšiřují datový systém programovacího jazyka C.
Typicky je ve velké míře využit makrosystém céčka. Výsledek není ideální,
zejména v&nbsp;porovnání s&nbsp;těmi jazyky, které tyto datové typy nativně
podporují.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vektory s&nbsp;dynamicky měnitelnou kapacitou</h2>

<p>První knihovnou, která implementuje nějaký datový kontejner, je knihovna
nazvaná <strong>vec.h</strong>. V&nbsp;této knihovně nalezneme implementaci
vektorů, což je ovšem poněkud zavádějící označení. Jedná se totiž o vektory
v&nbsp;takové podobě, v&nbsp;jaké je můžeme znát z&nbsp;programovacího jazyka
C++: vektory jsou ve standardní knihovně C++ realizovány formou polí
s&nbsp;rychlým přístupem k&nbsp;prvkům v&nbsp;konstantním čase O(1), ale
s&nbsp;možností přidávání a odstraňování prvků (vektory tedy dynamicky mění
svoji velikost). A stejným způsobem je navržena i knihovna
<strong>vec.h</strong>.</p>

<p>Hlavičkový soubor s&nbsp;úplnou implementací všech potřebných maker a
pomocných funkcí pro práci s&nbsp;vektory získáme snadno:</p>

<pre>
$ <strong>wget https://raw.githubusercontent.com/OguzhanUmutlu/vec.h/refs/heads/main/vec.h</strong>
</pre>

<p>Nejdříve je nutné vytvořit nový typ představující vektor určitých
hodnot:</p>

<pre>
vec_define(type, NAME)
</pre>

<p>Makrosystémem jazyka C jsou pro tento nový vektor vytvořeny všechny potřebné
funkce, například:</p>

<pre>
NAME_alloc()
NAME_push()
NAME_pop()
NAME_at()
NAME_set()
NAME_empty()
NAME_reverse()
NAME_shrink()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Demonstrační příklady: manipulace s&nbsp;vektory</h2>

<p>V&nbsp;prvním demonstračním příkladu, který využívá vektory (dynamické pole)
nadeklarujeme datové typy <strong>Name</strong> (prvek vektoru) a
<strong>Names</strong> (vlastní vektor). Následně se do vektoru vygenerovanou
funkcí <strong>Names_push</strong> vloží trojice prvků, získáme prvek na pozici
1 a poté obsah vektoru smažeme:</p>

<pre>
#include &lt;stdio.h&gt;
#include "vec.h"
&nbsp;
typedef char* <strong>Name</strong>;
&nbsp;
vec_define(Name, Names);
vec_define_free_simple(Name, Names);
vec_define_print(Name, Names, printf("%s", a));
&nbsp;
int <strong>mai</strong>n() {
    Names names;
    Names_init(&amp;names);
&nbsp;
    Name p1 = {"Alice"};
    Name p2 = {"Bob"};
    Name p3 = {"Charlie"};
&nbsp;
    Names_push(&amp;names, p1);
    Names_push(&amp;names, p2);
    Names_push(&amp;names, p3);
&nbsp;
    Names_print(names);
    printf("\n\n");
&nbsp;
    Name p = Names_at(names, 1);
    printf("Element at index 1: \"%s\"\n", p);
&nbsp;
    Names_clear(&amp;names);
    return 0;
}
</pre>

<p>Ve druhém demonstračním příkladu je ukázáno, jakým způsobem je možné
iterovat (procházet) přes všechny prvky vektoru. Používá se zde vygenerovaná
funkce <strong>Names_at</strong>, která má konstantní časovou složitost:</p>

<pre>
#include &lt;stdio.h&gt;
#include "vec.h"
&nbsp;
typedef char* <strong>Name</strong>;
&nbsp;
vec_define(Name, Names);
vec_define_free_simple(Name, Names);
vec_define_print(Name, Names, printf("%s", a));
&nbsp;
int <strong>main</strong>() {
    Names names;
    Names_init(&amp;names);
    printf("Initial size=%d and capacity=%d\n", names.size, names.capacity);
&nbsp;
    Name p1 = {"Alice"};
    Name p2 = {"Bob"};
    Name p3 = {"Charlie"};
&nbsp;
    Names_push(&amp;names, p1);
    Names_push(&amp;names, p2);
    Names_push(&amp;names, p3);
&nbsp;
    printf("Actual size=%d and capacity=%d\n", names.size, names.capacity);
&nbsp;
    Names_print(names);
    printf("\n\n");
&nbsp;
    int i;
    for (i=0; i&lt;names.size; i++) {
        Name p = Names_at(names, i);
        printf("Element at index %d: \"%s\"\n", i, p);
    }
&nbsp;
    Names_clear(&amp;names);
    return 0;
}
</pre>

<p>A konečně příklad třetí je inspirován přímo dokumentací ke knihovně
<strong>vec.h</strong>. Pracuje se zde s&nbsp;typem vektoru nazvaným
<strong>People</strong>, který obsahuje prvky typu <strong>Person</strong>, což
jsou z&nbsp;pohledu programovacího jazyka C struktury:</p>

<pre>
#include &lt;stdio.h&gt;
#include "vec.h"
&nbsp;
typedef struct <strong>Person</strong> {
    char name[50];
    int age;
} <strong>Person</strong>;
&nbsp;
vec_define(Person, People);
vec_define_free_simple(Person, People);
vec_define_print(Person, People, printf("%s:%d", a.name, a.age));
&nbsp;
int <strong>main</strong>() {
    People people;
    People_init(&amp;people);
&nbsp;
    Person p1 = {"Alice", 30};
    Person p2 = {"Bob", 25};
    Person p3 = {"Charlie", 35};
&nbsp;
    People_push(&amp;people, p1);
    People_push(&amp;people, p2);
    People_push(&amp;people, p3);
&nbsp;
    People_print(people);
&nbsp;
    Person p = People_at(people, 1);
    printf("Element at index 1: { name: \"%s\", age: %d }\n", p.name, p.age);
&nbsp;
    Person updated = {"Bob Jr.", 26};
    People_set(&amp;people, 1, updated);
    printf("Modified element at index 1: { name: \"%s\", age: %d }\n",
           People_at(people, 1).name, People_at(people, 1).age);
&nbsp;
    Person popped = People_pop(&amp;people);
    printf("Popped: { name: \"%s\", age: %d }\n", popped.name, popped.age);
&nbsp;
    People_clear(&amp;people);
    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Mapy (slovníky)</h2>

<p>Dynamické pole, jehož jednu implementaci jsme si popsali v&nbsp;předchozích
dvou kapitolách, je pochopitelně velmi často využívaným datovým kontejnerem.
Ovšem prakticky stejně často se můžeme setkat i s&nbsp;požadavkem na použití
mapy (<i>map</i>) resp.&nbsp;slovníku (<i>dictionary</i>). Jednohlavičková
implementace tohoto typu kontejneru pochopitelně existuje, a to dokonce
v&nbsp;několika variantách. V&nbsp;dnešním článku se ve stručnosti seznámíme
s&nbsp;možnostmi poskytovanými knihovnou nazvanou <strong>hashmap.h</strong>.
Tu je možné získat následovně:</p>

<pre>
$ <strong>wget https://raw.githubusercontent.com/sheredom/hashmap.h/refs/heads/master/hashmap.h</strong>
</pre>

<p>Tato knihovna poskytuje všechny potřebné operace pro práci se slovníky:
vložení prvku (<i>put</i>), získání (přečtení) prvku (<i>get</i>), smazání
prvku (<i>remove</i>), test na existenci prvku (nepřímo) a taktéž procházení
prvky uloženými ve slovníku (ovšem v&nbsp;odlišném pořadí, než v&nbsp;jakém
byly prvky do slovníku vloženy).</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Demonstrační příklady: použití slovníků</h2>

<p>V&nbsp;této kapitole si ukážeme několik příkladů použití slovníků.
V&nbsp;příkladu prvním jsou do slovníku přidány dva prvky pod klíči
&bdquo;root&ldquo; a &bdquo;user&ldquo;. Povšimněte si, že se předávají jak
samotné klíče (řetězce), tak i délky těchto klíčů. Prvky je nutné předávat
ukazatelem, což mj.&nbsp;znamená, že následující příklad pracuje korektně jen
díky tomu, že se slovník používá v&nbsp;jediné funkci (ukládané hodnoty jsou
umístěny na zásobníkový rámec!):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
#include "hashmap.h"
&nbsp;
int <strong>main</strong>(void) {
    struct hashmap_s hashmap;
    hashmap_create(10, &amp;hashmap);
&nbsp;
    int x = 0;
    int y = 1000;
&nbsp;
    hashmap_put(&amp;hashmap, "root", strlen("root"), &amp;x);
    hashmap_put(&amp;hashmap, "user", strlen("user"), &amp;y);
&nbsp;
    int *id= hashmap_get(&amp;hashmap, "root", strlen("root"));
    if (id != NULL)
        printf("%d\n", *id);
    else
        printf("not found\n");
&nbsp;
    id = hashmap_get(&amp;hashmap, "user", strlen("user"));
    if (id != NULL)
        printf("%d\n", *id);
    else
        printf("not found\n");
&nbsp;
    id = hashmap_get(&amp;hashmap, "other", strlen("other"));
    if (id != NULL)
        printf("%d\n", *id);
    else
        printf("not found\n");
&nbsp;
    hashmap_destroy(&amp;hashmap);
}
</pre>

<p>Výsledkem budou hodnoty dvou prvků a informace o tom, že třetí prvek nebyl
nalezen:</p>

<pre>
0
1000
not found
</pre>

<p>Zatímco v&nbsp;prvním demonstračním příkladu byly použity operace <i>get</i>
a <i>put</i>, ve druhém příkladu je sledována i kapacita slovníku a navíc se
používá operace <i>remove</i>. Ta však nemění kapacitu &ndash; reorganizaci
slovníku je nutné provést explicitně (to má své kladné i záporné stránky):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
#include "hashmap.h"
&nbsp;
int <strong>main</strong>(void) {
    struct hashmap_s hashmap;
    hashmap_create(2, &amp;hashmap);
&nbsp;
    int x = 0;
    int y = 1000;
&nbsp; printf("Capacity: %d\n", hashmap_capacity(&amp;hashmap));
&nbsp;
    hashmap_put(&amp;hashmap, "root", strlen("root"), &amp;x);
    hashmap_put(&amp;hashmap, "user", strlen("user"), &amp;y);
    hashmap_put(&amp;hashmap, "foo", strlen("foo"), &amp;y);
    hashmap_put(&amp;hashmap, "bar", strlen("bar"), &amp;y);
    hashmap_put(&amp;hashmap, "baz", strlen("baz"), &amp;y);
&nbsp;
    printf("Capacity: %d\n", hashmap_capacity(&amp;hashmap));
&nbsp;
    int *id= hashmap_get(&amp;hashmap, "root", strlen("root"));
    if (id != NULL)
        printf("%d\n", *id);
    else
        printf("not found\n");
&nbsp;
    id = hashmap_get(&amp;hashmap, "user", strlen("user"));
    if (id != NULL)
        printf("%d\n", *id);
    else
        printf("not found\n");
&nbsp;
    id = hashmap_get(&amp;hashmap, "other", strlen("other"));
    if (id != NULL)
        printf("%d\n", *id);
    else
        printf("not found\n");
&nbsp;
    hashmap_remove(&amp;hashmap, "foo", strlen("foo"));
    hashmap_remove(&amp;hashmap, "bar", strlen("bar"));
    hashmap_remove(&amp;hashmap, "baz", strlen("baz"));
    hashmap_remove(&amp;hashmap, "root", strlen("root"));
    hashmap_remove(&amp;hashmap, "user", strlen("user"));
    printf("Capacity: %d\n", hashmap_capacity(&amp;hashmap));
&nbsp;
    hashmap_destroy(&amp;hashmap);
}
</pre>

<p>Povšimněte si, že kapacita slovníku skutečně stále roste:</p>

<pre>
Capacity: 2
Capacity: 8
0
1000
not found
Capacity: 8
</pre>

<p>V&nbsp;příkladu třetím se slovníkem prochází (v&nbsp;pseudonáhodném pořadí).
Pro každý nalezený prvek se volá callback funkce <strong>iterate</strong>,
která vrací hodnotu 1 znamenající &bdquo;pokračuj dále&ldquo; (návratovou
hodnotou lze řídit, kdy se má průchod zastavit):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
#include "hashmap.h"
&nbsp;
static int <strong>iterate</strong>(void* const context, void* const value) {
    int *x = value;
    printf("%d\n", *x);
    return 1;
}
&nbsp;
int <strong>main</strong>(void) {
    struct hashmap_s hashmap;
    hashmap_create(10, &amp;hashmap);
&nbsp; 
    int x = 0;
    int y = 1000;
&nbsp; 
    hashmap_put(&amp;hashmap, "root", strlen("root"), &amp;x);
    hashmap_put(&amp;hashmap, "user", strlen("user"), &amp;y);
&nbsp; 
    int a = 1, b = 2, c = 3;
    hashmap_put(&amp;hashmap, "foo", strlen("foo"), &amp;a);
    hashmap_put(&amp;hashmap, "bar", strlen("bar"), &amp;b);
    hashmap_put(&amp;hashmap, "baz", strlen("baz"), &amp;c);
&nbsp; 
    int* value;
    hashmap_iterate(&amp;hashmap, iterate, &amp;value);
    hashmap_destroy(&amp;hashmap);
}
</pre>

<p>Hodnoty nalezených prvků jsou vráceny a vytištěny v&nbsp;pseudonáhodném
pořadí:</p>

<pre>
1
1000
3
0
2
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Jednohlavičková knihovna pro vyhodnocování výrazů</h2>

<p>Poslední jednohlavičkovou knihovnou, se kterou se v&nbsp;dnešním článku
setkáme, je knihovna, která se jmenuje <strong>ceval.h</strong>. Tato knihovna
dokáže vyhodnotit výrazy uložené do řetězce. Výrazy, přesněji řečeno
<i>infixové výrazy</i>, mohou obsahovat základní aritmetické operátory, logické
operátory, volání některých funkcí (goniometrické atd.) a pochopitelně i
závorky ovlivňující prioritu prováděných operací. Ve výrazech se sice očekávají
konstantní hodnoty, což je velké omezení, ovšem ukážeme si jeden trik, který
nám umožní do výrazů předat i hodnoty proměnných a navíc i
&bdquo;externě&ldquo; řídit, které hodnoty lze předat a které nikoli. Samotné
vyhodnocení (<i>evaluation</i>) výrazů je tedy bezpečnou operací.</p>

<p>Hlavičkový soubor s&nbsp;touto knihovnou získáme snadno:</p>

<pre>
$ <strong>wget https://raw.githubusercontent.com/erstan/ceval-single-header/refs/heads/e_t/ceval.hSaving 'ceval.h'</strong>
&nbsp;
HTTP response 200  [https://raw.githubusercontent.com/erstan/ceval-single-header/refs/heads/e_t/ceval.h]
ceval.h              100% [=====================================================================================&gt;]    7.33K    --.-KB/s
                          [Files: 1  Bytes: 7.33K [11.64KB/s] Redirects: 0  Todo: 0  Errors: 0                   ]
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příklady realizace vyhodnocování výrazů bez proměnných i s&nbsp;proměnnými</h2>

<p>V&nbsp;prvním příkladu se vyhodnocuje výraz 1+2*3:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
#include "ceval.h"
&nbsp;
int <strong>main</strong>(void) {
    static char expression[] = "1+2*3";
    double result = ceval_result(expression);
    printf("Result=%f\n", result);
    return 0;
}
</pre>

<p>Tento příklad nebude přeložen, protože knihovna <strong>ceval.h</strong> vyžaduje funkce ze standardní knihovny <strong>stdlib.h</strong></p>
<pre>
</pre>

<p></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
#include "ceval.h"
&nbsp;
int <strong>main</strong>(void) {
    static char expression[] = "1+2*3";
    double result = ceval_result(expression);
    printf("Result=%f\n", result);
    return 0;
}
</pre>

<p></p>

<pre>
Result=7.000000
</pre>

<p></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
#include "ceval.h"
&nbsp;
int <strong>main</strong>(void) {
    static char expression[] = "(3-20)*(14+20)+20*(14-3+20)";
    double result = ceval_result(expression);
    printf("Result=%f\n", result);
    return 0;
}
</pre>

<p></p>

<pre>
Result=42.000000
</pre>

<p></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
#include "ceval.h"
&nbsp;
int <strong>main</strong>(void) {
    double a = 3;
    double b = 20;
    double c = 14;
&nbsp;
    static char expression[] = "(%f-%f)*(%f+%f)+%f*(%f-%f+%f)";
    char buffer[200];
&nbsp;
    snprintf(buffer, sizeof(buffer), expression, a, b, c, b, b, c, a, b);
    double result = ceval_result(buffer);
    printf("Result=%f\n", result);
    return 0;
}
</pre>

<p></p>

<pre>
Result=42.000000
</pre>

<p></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
#include "ceval.h"
&nbsp;
int <strong>main</strong>(void) {
    static char expression[] = "sin(deg2rad(45))";
    double result = ceval_result(expression);
    printf("Result=%f\n", result);
    return 0;
}
</pre>

<p></p>

<pre>
Result=0.707107
</pre>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
&nbsp;
#include "ceval.h"
&nbsp;
int <strong>main</strong>(void) {
    static char expression[] = "1+2*3";
    ceval_tree(expression);
    return 0;
}
</pre>

<p></p>

<pre>
                3
        *
                2
+
        1
</pre>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
&nbsp;
#include "ceval.h"
&nbsp;
int <strong>main</strong>(void) {
    static char expression[] = "(3-20)*(14+20)+20*(14-3+20)";
    ceval_tree(expression);
    return 0;
}
</pre>

<p></p>

<pre>
                        20
                +
                                3
                        -
                                14
        *
                20
+
                        20
                +
                        14
        *
                        20
                -
                        3
</pre>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
&nbsp;
#include "ceval.h"
&nbsp;
int <strong>main</strong>(void) {
    static char expression[] = "sin(deg2rad(45))";
    ceval_tree(expression);
    return 0;
}
</pre>

<p></p>

<pre>
                45
        deg2rad
sin
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: Makefile soubor pro překlad všech demonstračních příkladů</h2>

<p>Všechny výše uvedené demonstrační příklady je možné přeložit s&nbsp;využitím
souboru <strong>Makefile</strong>, který je zobrazen pod tímto odstavcem.
Povšimněte si, že tento soubor obsahuje i cíle (<i>targets</i>), které
v&nbsp;případě potřeby stáhnou i potřebné jednohlavičkové knihovny:</p>

<pre>
CC=gcc
&nbsp;
<strong>all</strong>:    stb_image_write.h ceval.h vec.h hashmap.h \
        evaluation_2 evaluation_3 evaluation_4 evaluation_5 \
        evaluation_6 evaluation_7 evaluation_8 \
        vector_usage_1 vector_usage_2 vector_usage_3 \
        simple_image_1 simple_image_2 simple_image_3 simple_image_4 \
        hashmap_usage_1 hashmap_usage_2 hashmap_usage_3 \
        perlin_noise perlin_noise_2
&nbsp;
<strong>clean</strong>:
        rm -f ceval.h
        rm -f stb_image_write.h
        rm -f stb_image_write.h
        rm -f vec.h
        rm -f hashmap.h
        rm -f evaluation_1 evaluation_2 evaluation_3 evaluation_4 evaluation_5
        rm -f evaluation_6 evaluation_7 evaluation_8
        rm -f vector_usage_1 vector_usage_2 vector_usage_3
        rm -f simple_image_1 simple_image_2 simple_image_3 simple_image_4
        rm -f hashmap_usage_1 hashmap_usage_2 hashmap_usage_3
        rm -f perlin_noise perlin_noise_2
&nbsp;
<strong>evaluation_1</strong>:   evaluation_1.c ceval.h
        $(CC) -lm -O0 $&lt; -o $@
&nbsp;
<strong>evaluation_2</strong>:   evaluation_2.c ceval.h
        $(CC) -lm -O0 $&lt; -o $@
&nbsp;
<strong>evaluation_3</strong>:   evaluation_3.c ceval.h
        $(CC) -lm -O0 $&lt; -o $@
&nbsp;
<strong>evaluation_4</strong>:   evaluation_4.c ceval.h
        $(CC) -lm -O0 $&lt; -o $@
&nbsp;
<strong>evaluation_5</strong>:   evaluation_5.c ceval.h
        $(CC) -lm -O0 $&lt; -o $@
&nbsp;
<strong>evaluation_6</strong>:   evaluation_6.c ceval.h
        $(CC) -lm -O0 $&lt; -o $@
&nbsp;
<strong>evaluation_7</strong>:   evaluation_7.c ceval.h
        $(CC) -lm -O0 $&lt; -o $@
&nbsp;
<strong>evaluation_8</strong>:   evaluation_8.c ceval.h
        $(CC) -lm -O0 $&lt; -o $@
&nbsp;
<strong>hashmap_usage_1</strong>:        hashmap_usage_1.c vec.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>hashmap_usage_2</strong>:        hashmap_usage_2.c vec.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>hashmap_usage_3</strong>:        hashmap_usage_3.c vec.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>vector_usage_1</strong>: vector_usage_1.c vec.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>vector_usage_2</strong>: vector_usage_2.c vec.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>vector_usage_3</strong>: vector_usage_3.c vec.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>simple_image_1</strong>: simple_image_1.c stb_image_write.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>simple_image_2</strong>: simple_image_2.c stb_image_write.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>simple_image_3</strong>: simple_image_3.c stb_image_write.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>simple_image_4</strong>: simple_image_4.c stb_image_write.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>perlin_noise</strong>:   perlin_noise.c stb_image_write.h stb_perlin.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>perlin_noise_2</strong>:   perlin_noise_2.c stb_image_write.h stb_perlin.h
        $(CC) -O0 $&lt; -o $@
&nbsp;
<strong>stb_image_write.h</strong>:
        wget https://raw.githubusercontent.com/nothings/stb/refs/heads/master/stb_image_write.h
&nbsp;
<strong>ceval.h</strong>:
        wget https://raw.githubusercontent.com/erstan/ceval-single-header/refs/heads/e_t/ceval.h
&nbsp;
<strong>vec.h</strong>:
        wget https://raw.githubusercontent.com/OguzhanUmutlu/vec.h/refs/heads/main/vec.h
&nbsp;
<strong>hashmap.h</strong>:
        wget https://raw.githubusercontent.com/sheredom/hashmap.h/refs/heads/master/hashmap.h
&nbsp;
<strong>stb_perlin.h</strong>:
        wget https://raw.githubusercontent.com/nothings/stb/refs/heads/master/stb_perlin.h
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, s&nbsp;nimiž jsme se v&nbsp;dnešním článku
seznámili a které jsou určeny pro překlad s&nbsp;využitím prakticky libovolného
moderního překladače jazyka C, jsou dostupné, jak je zvykem, na GitHubu.
V&nbsp;tabulce níže jsou uvedeny odkazy na jednotlivé zdrojové kódy psané
v&nbsp;jazyku C, které typicky vyžadují nějakou &bdquo;jednosouborovou&ldquo;
knihovnu &ndash; viz <a href="#k18">výše uvedený</a> soubor Makefile, který
obsahuje příslušné příkazy pro stažení těchto knihoven:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td> 1</td><td>Makefile</td><td>definice cílů pro překlad všech demonstračních příkladů z&nbsp;této tabulky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/Makefile">https://github.com/tisnik/8bit-fame/blob/master/header-only/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>evaluation_1.c</td><td>vyhodnocování výrazů, ukázka závislosti knihovny na standardní knihovně</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_1.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_1.c</a></td></tr>
<tr><td> 3</td><td>evaluation_2.c</td><td>vyhodnocování výrazů, jednoduchý výraz, korektní varianta příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_2.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_2.c</a></td></tr>
<tr><td> 4</td><td>evaluation_3.c</td><td>vyhodnocování výrazů, složitější výraz</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_3.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_3.c</a></td></tr>
<tr><td> 5</td><td>evaluation_4.c</td><td>vyhodnocování výrazů, náhrada symbolů za hodnoty proměnných</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_4.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_4.c</a></td></tr>
<tr><td> 6</td><td>evaluation_5.c</td><td>vyhodnocování výrazů, vestavěné funkce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_5.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_5.c</a></td></tr>
<tr><td> 7</td><td>evaluation_6.c</td><td>vyhodnocování výrazů, zobrazení stromu s&nbsp;jednoduchým výrazem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_6.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_6.c</a></td></tr>
<tr><td> 8</td><td>evaluation_7.c</td><td>vyhodnocování výrazů, zobrazení stromu se složitějším výrazem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_7.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_7.c</a></td></tr>
<tr><td> 9</td><td>evaluation_8.c</td><td>vyhodnocování výrazů, zobrazení stromu s&nbsp;výrazem, ve kterém se volají funkce</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_8.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/evaluation_8.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>hashmap_usage_1.c</td><td>základní operace s&nbsp;mapou v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/hashmap_usage_1.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/hashmap_usage_1.c</a></td></tr>
<tr><td>11</td><td>hashmap_usage_2.c</td><td>vymazání prvků z&nbsp;mapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/hashmap_usage_2.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/hashmap_usage_2.c</a></td></tr>
<tr><td>12</td><td>hashmap_usage_3.c</td><td>iterace nad prvky uloženými v&nbsp;mapě</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/hashmap_usage_3.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/hashmap_usage_3.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>simple_image_1.c</td><td>uložení rastrového obrázku do PNG, příklad s&nbsp;odděleným překladem knihovny</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/simple_image_1.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/simple_image_1.c</a></td></tr>
<tr><td>14</td><td>simple_image_2.c</td><td>uložení rastrového obrázku do PNG, příklad, který lze přeložit v&nbsp;jednom kroku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/simple_image_2.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/simple_image_2.c</a></td></tr>
<tr><td>15</td><td>simple_image_3.c</td><td>uložení rastrového obrázku do PNG s&nbsp;kontrolou chyb</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/simple_image_3.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/simple_image_3.c</a></td></tr>
<tr><td>16</td><td>simple_image_4.c</td><td>uložení rastrového obrázku do PNG, rozdělení definice a deklarace funkcí z&nbsp;knihovny</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/simple_image_4.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/simple_image_4.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>vector_usage_1.c</td><td>vektor řetězců, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/vector_usage_1.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/vector_usage_1.c</a></td></tr>
<tr><td>18</td><td>vector_usage_2.c</td><td>vektor řetězců, složitější varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/vector_usage_2.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/vector_usage_2.c</a></td></tr>
<tr><td>19</td><td>vector_usage_3.c</td><td>vektor struktur (záznamů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/vector_usage_3.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/vector_usage_3.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>perlin_noise.c</td><td>výpočet a vykreslení Perlinova šumu s&nbsp;uložením výsledku do obrázku typu PNG</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/header-only/perlin_noise.c">https://github.com/tisnik/8bit-fame/blob/master/header-only/perlin_noise.c</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Header-only (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Header-only">https://en.wikipedia.org/wiki/Header-only</a>
</li>

<li>C/C++ open-source libraries with minimal dependencies<br />
<a href="https://github.com/r-lyeh/single_file_libs">https://github.com/r-lyeh/single_file_libs</a>
</li>

<li>single-file public domain (or MIT licensed) libraries for C/C++<br />
<a href="https://github.com/nothings/stb/tree/master">https://github.com/nothings/stb/tree/master</a>
</li>

<li>Top 19 C single-header Projects<br />
<a href="https://www.libhunt.com/l/c/topic/single-header">https://www.libhunt.com/l/c/topic/single-header</a>
</li>

<li>ceval-single-header<br />
<a href="https://github.com/erstan/ceval-single-header">https://github.com/erstan/ceval-single-header</a>
</li>

<li>Zdrojový kód knihovny ceval<br />
<a href="https://github.com/erstan/ceval-single-header/blob/e_t/ceval.h">https://github.com/erstan/ceval-single-header/blob/e_t/ceval.h</a>
</li>

<li>Are single header libraries good?<br />
<a href="https://www.reddit.com/r/C_Programming/comments/12u7s37/are_single_header_libraries_good/">https://www.reddit.com/r/C_Programming/comments/12u7s37/are_single_header_libraries_good/</a>
</li>

<li>Nanoprintf, a tiny header-only vsnprintf that supports floats! Zero dependencies, zero libc calls. No allocations, &lt; 100B stack, &lt; 5K C89/C99<br />
<a href="https://www.reddit.com/r/C_Programming/comments/cae52j/comment/et9amng/">https://www.reddit.com/r/C_Programming/comments/cae52j/comment/et9amng/</a>
</li>

<li>Lessons learned about how to make a header-file library<br />
<a href="https://github.com/nothings/stb/blob/master/docs/stb_howto.txt">https://github.com/nothings/stb/blob/master/docs/stb_howto.txt</a>
</li>

<li>Libraries That Quietly Revolutionized C<br />
<a href="https://www.youtube.com/watch?v=kS_GqDp6IT4">https://www.youtube.com/watch?v=kS_GqDp6IT4</a>
</li>

<li>C (programming language)<br />
<a href="https://en.wikipedia.org/wiki/C_(programming_language)">https://en.wikipedia.org/wiki/C_(programming_language)</a>
</li>

<li>ANSI C<br />
<a href="https://en.wikipedia.org/wiki/ANSI_C">https://en.wikipedia.org/wiki/ANSI_C</a>
</li>

<li>C++<br />
<a href="https://en.wikipedia.org/wiki/C%2B%2B">https://en.wikipedia.org/wiki/C%2B%2B</a>
</li>

<li>GNU Make<br />
<a href="https://www.gnu.org/software/make/">https://www.gnu.org/software/make/</a>
</li>

<li>Cmake<br />
<a href="https://cmake.org/">https://cmake.org/</a>
</li>

<li>Avoid the Temptation of Header-Only Libraries<br />
<a href="https://dev.to/pauljlucas/avoid-the-temptation-of-header-only-libraries-33an">https://dev.to/pauljlucas/avoid-the-temptation-of-header-only-libraries-33an</a>
</li>

<li>header-only-library<br />
<a href="https://github.com/topics/header-only-library?o=desc&amp;s=updated">https://github.com/topics/header-only-library?o=desc&amp;s=updated</a>
</li>

<li>vec.h - Lightweight Dynamic Arrays in C<br />
<a href="https://github.com/OguzhanUmutlu/vec.h">https://github.com/OguzhanUmutlu/vec.h</a>
</li>

<li>stb_image_write.h<br />
<a href="https://raw.githubusercontent.com/nothings/stb/refs/heads/master/stb_image_write.h">https://raw.githubusercontent.com/nothings/stb/refs/heads/master/stb_image_write.h</a>
</li>

<li>The SQLite Amalgamation<br />
<a href="https://sqlite.org/amalgamation.html">https://sqlite.org/amalgamation.html</a>
</li>

<li>SQLite Download Page<br />
<a href="https://sqlite.org/download.html">https://sqlite.org/download.html</a>
</li>

<li>hashmap.h<br />
<a href="https://github.com/sheredom/hashmap.h">https://github.com/sheredom/hashmap.h</a>
</li>

<li>C Function Declaration and Definition<br />
<a href="https://www.w3schools.com/c/c_functions_decl.php">https://www.w3schools.com/c/c_functions_decl.php</a>
</li>

<li>Using Precompiled Headers<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html">https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html</a>
</li>

<li>Perlin noise<br />
<a href="https://en.wikipedia.org/wiki/Perlin_noise">https://en.wikipedia.org/wiki/Perlin_noise</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2026</small></p>
</body>
</html>

