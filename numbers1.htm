<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Interní reprezentace numerických hodnot: od skutečného počítačového pravěku po IEEE 754-2008</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Interní reprezentace numerických hodnot: od skutečného počítačového pravěku po IEEE 754-2008</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V předchozím článku jsme se věnovali zmatkům, které vládnou ve způsobu interní reprezentace řetězců. Ovšem pokud se podíváme na způsob ukládání numerických hodnot s plovoucí řádovou čárkou, zjistíme, že v této oblasti existovalo hned několik mezi sebou nekompatibilních standardů i pseudostandardů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Interní reprezentace numerických hodnot: od skutečného počítačového pravěku po IEEE 754-2008</a></p>
<p><a href="#k02">2. Reprezentace hodnot v&nbsp;plovoucí řádové čárce na různých typech počítačů a systémů</a></p>
<p><a href="#k03">3. Používané varianty báze, exponentu a mantisy</a></p>
<p><a href="#k04">4. Elektronkové a tranzistorové sálové počítače IBM</a></p>
<p><a href="#k05">5. Rozdělení sálových počítačů IBM podle způsobu jejich použití</a></p>
<p><a href="#k06">6. IBM 704 &ndash; sálový počítač určený pro vědeckotechnické výpočty</a></p>
<p><a href="#k07">7. Počítače série IBM 1400</a></p>
<p><a href="#k08">8. Formát dat zpracovávaných počítači IBM 1400</a></p>
<p><a href="#k09">9. Sovětský elektronkový počítač Strela a jím používaný formát numerických hodnot</a></p>
<p><a href="#k10">10. Slavná architektura IBM/360 a její matematický procesor</a></p>
<p><a href="#k11">11. Superpočítače Cray</a></p>
<p><a href="#k12">12. Příchod osmibitových mikropočítačů</a></p>
<p><a href="#k13">13. Formát FP hodnot v&nbsp;Applesoft BASICu a na ZX Spectru</a></p>
<p><a href="#k14">14. Atari BASIC a jeho neortodoxní reprezentace reálných čísel</a></p>
<p><a href="#k15">15. Vlastnosti formátu použitého v&nbsp;osmibitových Atari</a></p>
<p><a href="#k16">16. Datový typ <strong>real</strong> v&nbsp;Turbo Pascalu</a></p>
<p><a href="#k17">17. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Interní reprezentace numerických hodnot: od skutečného počítačového pravěku po IEEE 754-2008</h2>

<p>Reálná čísla (resp.&nbsp;přesněji řečeno samozřejmě podmnožina z&nbsp;této
nespočetné množiny) začala být používána už u prvních mechanických a
elektromechanických počítačů, což není příliš překvapivé, protože tyto stroje
zpočátku skutečně sloužily především pro výpočty; teprve později byly navrženy
stroje pro zpracování dat. První moderní (sic) použití reálných čísel nalezneme
především u počítače Z1 navrženého v&nbsp;letech 1935 až 1936 Konradem Zusem.
Tento počítač používal pro reprezentaci reálných čísel slova o šířce 22 bitů.
Později vyvinutý stroj Z4 již využíval slova o šířce 32 bitů.</p>

<img src="https://i.iinfo.cz/images/373/fp-nubmers-1.png" class="image-304883" alt="&#160;" width="450" height="336" />
<p><i>Obrázek 1: Konrad Zuse u makety svého mechanicko-elektronického počítače
Z1.</i></p>

<p>Další vývoj systémů pro ukládání numerických hodnot byl prováděn především
ve společnosti IBM (dalo by se říci, že paralelně s&nbsp;vývojem Fortranu),
přičemž právě zde došlo k&nbsp;první unifikaci interní reprezentace reálných
čísel s&nbsp;využitím slov rozdělených na tři části, které postupně
reprezentují <i>znaménko</i>, <i>mantisu</i> a <i>exponent</i>. Tento systém,
který si popíšeme <a href="#k02">v&nbsp;následující kapitole</a>, se ukázal byl
nadčasový, protože je používán dodnes. Ovšem konkrétní způsoby uložení mantisy
a exponentu, stejně jako volba takzvané <i>báze</i>, se na různých typech
počítačů a nebo operačních systémů, od sebe odlišují, takže se liší i rozsah
reprezentovatelných hodnot, přesnost, existence či neexistence speciálních
hodnot (+&infin;, -&infin;) atd.</p>

<img src="http://i.iinfo.cz/images/214/sssr02.jpg" width="450" height="282" alt="sssr02" />
<p><i>Obrázek 2: Hlavní moduly počítače MESM (SSSR) včetně jeho řídicího
(operátorského) panelu.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Reprezentace hodnot v&nbsp;plovoucí řádové čárce na různých typech počítačů a systémů</h2>

<p>Všechny dále popsané formáty (reprezentace) čísel používají systém takzvané
plovoucí řádové čárky (anglicky <i>floating point</i>, protože se
v&nbsp;angličtině namísto čárky používá tečka). Systém plovoucí řádové čárky je
založen na tom, že vybraná podmnožina reálných čísel může být vyjádřena
vztahem:</p>

<p><strong>X<sub>FP</sub> = (-1)<sup>s</sup>&nbsp;&times;&nbsp;b<sup>exp-bias</sup>&nbsp;&times;&nbsp;m</strong></p>

<p>přičemž význam jednotlivých symbolů ve vztahu je následující:</p>

<ul>

<li><strong>X<sub>FP</sub></strong> značí reprezentovanou numerickou hodnotu
z&nbsp;podmnožiny racionálních čísel (ta je zase podmnožinou čísel reálných).
Díky vyhrazeným (speciálním) hodnotám je většinou možné rozlišit kladnou a
zápornou nulu i kladné a záporné nekonečno, což je jeden z&nbsp;důležitých
rozdílů oproti způsobu reprezentace celých čísel. Také se většinou může uložit
nečíselná hodnota: <i>NaN &ndash; (Not a Number)</i>, která je výsledkem
některých matematicky nedefinovaných operací, například 0/0 nebo
0<sup>0</sup>.</li>

<li><strong>b</strong> je <i>báze</i>, někdy také nazývaná <i>radix</i>, u
normy <i>IEEE 754</i> je to vždy dvojka, protože výpočty s&nbsp;bází dvě jsou
pro číslicové obvody nejjednodušší. V&nbsp;minulosti se však používaly i jiné
báze, například 8, 16 nebo i 10, s&nbsp;nimi se však již dnes prakticky
nesetkáme (o to relevantnější jsou však v&nbsp;dnešním článku).</li>

<li><strong>exp</strong> je vždy kladná hodnota exponentu posunutého o hodnotu
<strong>bias</strong></li>

<li><strong>bias</strong> je hodnota, díky které je uložený exponent vždy
kladný. Tato hodnota se většinou volí dle vztahu:<br />
<i>bias=2<sup>eb-1</sup>-1</i>, kde <i>eb</i> je počet bitů vyhrazených pro
exponent. Pro specifické účely je však možné zvolit i jinou hodnotu.</li>

<li><strong>m</strong> je mantisa, která je u formátů dle normy <i>IEEE 754</i>
vždy kladná</li>

<li><strong>s</strong> je znaménkový bit nabývající hodnoty 0 nebo 1. Pokud je
tento bit nulový, je reprezentovaná hodnota <strong>X<sub>FP</sub></strong>
kladná, v&nbsp;opačném případě se jedná o zápornou hodnotu. Vzhledem
k&nbsp;tomu, že je jeden bit vyhrazen na uložení znaménka, je možné rozlišit
kladnou a zápornou nulu (některé systémy bit znaménka používají v&nbsp;negované
podobě).</li>

</ul>

<a href="http://i.iinfo.cz/images/22/ibm05.jpg"><img src="http://i.iinfo.cz/images/22/ibm05-prev.jpg" alt="ibm05" height="149" width="370" /></a>
<p><i>Obrázek 3: Sálový počítač IBM-702 z&nbsp;roku 1953. Jednalo se o jeden
z&nbsp;prvních počítačů specializovaných na hromadné zpracování dat, který byl
vystavěn s&nbsp;využitím technologie elektronek a katodových (Williamsových)
trubic.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Používané varianty báze, exponentu a mantisy</h2>

<p>Do následující tabulky jsem se pokusil napsat všechny důležité formáty
reprezentace exponentu a mantisy současně s&nbsp;uvedením báze. Ta je většinou
dvojková, ovšem výjimkou je IBM 360 se šestnáctkovou bází a FP rutiny u
osmibitových Atari s&nbsp;desítkovou bází:</p>

<table>
<tr><th>Počítač/norma/systém</th><th>Šířka (b)</th><th>Báze</th><th>Exponent (b)</th><th>Mantisa (b)</th></tr>
<tr><td>IEEE 754 half</td><td>16</td><td>2</td><td>5</td><td>10+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 single</td><td>32</td><td>2</td><td>8</td><td>23+1</td></tr>
<tr><td>IEEE 754 double</td><td>64</td><td>2</td><td>11</td><td>52+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 double extended</td><td>80</td><td>2</td><td>15</td><td>64</td></tr>
<tr><td>IEEE 754 quadruple</td><td>128</td><td>2</td><td>15</td><td>112+1</td></tr>
<tr><td>IEEE 754 octuple</td><td>256</td><td>2</td><td>19</td><td>236+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#k06">IBM řady 7xx</a></td><td>36</td><td>2</td><td>8</td><td>27</td></tr>
<tr><td><a href="#k10">IBM 360 single</a></td><td>32</td><td>16</td><td>7</td><td>24</td></tr>
<tr><td><a href="#k10">IBM 360 double</a></td><td>64</td><td>16</td><td>7</td><td>56</td></tr>
<tr><td>HP 3000 single</td><td>32</td><td>2</td><td>9</td><td>22</td></tr>
<tr><td>HP 3000 double</td><td>64</td><td>2</td><td>9</td><td>54</td></tr>
<tr><td>CDC 6000, 6600</td><td>60</td><td>2</td><td>11</td><td>48+1</td></tr>
<tr><td><a href="#k11">Cray-1</a></td><td>64</td><td>2</td><td>15</td><td>48</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#k09">Strela</a></td><td>43</td><td>2</td><td>7</td><td>35</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#k13">Apple II</a></td><td>40</td><td>2</td><td>8</td><td>31+1</td></tr>
<tr><td><a href="#k14">ZX Spectrum</a></td><td>40</td><td>2</td><td>8</td><td>31+1</td></tr>
<tr><td><a href="#k15">Atari (FP rutiny)</a></td><td>48</td><td>10</td><td>7</td><td>40</td></tr>
<tr><td><a href="#k16">Turbo Pascal real</a></td><td>48</td><td>2</td><td>8</td><td>39</td></tr>
</table>

<p>Poznámka: pokud je ve sloupci <i>Mantisa</i> napsána hodnota n+1, znamená
to, že hodnoty jsou normalizovány tak, aby první bit mantisy byl vždy
jedničkový. V&nbsp;takovém případě tento bit nemusíme nikam zapisovat (víme, že
je jednička) a tudíž se mantisa automaticky o tento jeden bit rozšiřuje. To
samozřejmě neplatí pro denormalizované hodnoty (blízké nule).</p>

<p>Poznámka<sup>2</sup>: to, že u normy IEEE 754 se pro exponent používá 8(11)
bitů a pro mantisu 23(52) bitů nemusí být ve všech případech ideální řešení,
protože někdy vyžadujeme spíše menší rozsah hodnot, ale větší přesnost či
naopak.</p>

<a href="http://i.iinfo.cz/images/656/ibm06.jpg"><img src="http://i.iinfo.cz/images/656/ibm06-prev.jpg" alt="ibm06" height="270" width="316" /></a>
<p><i>Obrázek 4: Ovládací panel sálového počítače IBM-702.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Elektronkové a tranzistorové sálové počítače IBM</h2>

<p>První generace sálových počítačů firmy IBM byla označována tříciferným kódem
začínajícím na 7. Celkem se vyrábělo pět typů počítačů této generace &ndash;
<strong>IBM 701</strong>, <strong>IBM 702</strong>, <strong>IBM 704</strong>,
<strong>IBM 705</strong> a <strong>IBM 709</strong>. Číselné označení těchto
počítačů respektuje i posloupnost jejich vzniku (rok vzniku počítače), což u
dalších řad již není vždy splněno. Procesor těchto počítačů byl sestaven
z&nbsp;elektronek a pasivních elektronických součástek. Operační paměť se u
modelů <strong>701</strong> a <strong>702</strong> skládala z&nbsp;katodových
trubic a u dalších třech modelů pak z&nbsp;magnetické paměti vytvořené ze sítě
feritových jader navlečených na adresové a čtecí/zápisové vodiče. Dva modely
těchto počítačů byly určeny pro hromadné zpracování dat (tomu byla uzpůsobena
především instrukční sada), další dva modely byly optimalizovány spíše pro
vědeckotechnické výpočty &ndash; viz tabulka zobrazená pod tímto odstavcem.</p>

<table>
<tr><th>Model</th><th>Určení</th><th>Rok výroby</th></tr>
<tr><td>701</td><td>první elektronický počítač firmy IBM</td><td>1952</td></tr>
<tr><td>702</td><td>hromadné zpracování dat</td><td>1953</td></tr>
<tr><td>704</td><td>vědeckotechnické výpočty</td><td>1954</td></tr>
<tr><td>705</td><td>hromadné zpracování dat</td><td>1954</td></tr>
<tr><td>709</td><td>vědeckotechnické výpočty</td><td>1958</td></tr>
</table>

<img src="http://i.iinfo.cz/images/288/ibm01.png" alt="ibm01" height="120" width="180" />
<p><i>Obrázek 5: Elektronky byly v&nbsp;prvních sálových počítačích firmy IBM
použity pro konstrukci kombinačních i sekvenčních logických obvodů.</i></p>

<p>Druhá generace sálových počítačů firmy IBM, jejíž modely jsou označovány
čtyřciferným kódem začínajícím opět na sedmičku, se od první generace
odlišovala především v&nbsp;použití odlišné technologie elektronických
součástek &ndash; namísto rozměrných a poruchových elektronek s&nbsp;velkou
spotřebou elektrické energie se zde objevují tranzistory. Rozdělení počítačů
podle způsobu jejich použití (vědeckotechnické výpočty, hromadné zpracování
dat, účetní operace v&nbsp;dekadické soustavě) však zůstává zachováno. Některé
modely z&nbsp;druhé generace nejsou v&nbsp;podstatě ničím jiným, než počítači
první generace s&nbsp;upravenou součástkovou základnou a několika dalšími
vylepšeními (příkladem může být model <strong>IBM 705</strong>, který byl
nahrazen modernějším modelem <strong>IBM 7080</strong>). V&nbsp;následující
tabulce jsou vypsány nejvýznamnější modely druhé generace sálových počítačů
firmy IBM (vynechány jsou pouze některé méně často prodávané varianty těchto
počítačů):</p>

<table>
<tr><th>Model</th><th>Určení</th><th>Rok výroby</th></tr>
<tr><td>7090   </td><td>vědeckotechnické výpočty</td><td>1959</td></tr>
<tr><td>7094   </td><td>vědeckotechnické výpočty</td><td>1962</td></tr>
<tr><td>7094 II</td><td>vědeckotechnické výpočty</td><td>1964</td></tr>
<tr><td>7040   </td><td>vědeckotechnické výpočty</td><td>1963</td></tr>
<tr><td>7044   </td><td>vědeckotechnické výpočty</td><td>1963</td></tr>
<tr><td>7080   </td><td>hromadné zpracování dat </td><td>1961</td></tr>
<tr><td>7010   </td><td>rozšířená verze IBM 1410</td><td>1962</td></tr>
<tr><td>7070   </td><td>dekadická soustava</td><td>1960</td></tr>
<tr><td>7072   </td><td>dekadická soustava</td><td>1962</td></tr>
<tr><td>7074   </td><td>dekadická soustava</td><td>1961</td></tr>
</table>

<a href="http://i.iinfo.cz/images/311/ibm08.jpg"><img src="http://i.iinfo.cz/images/311/ibm08-prev.jpg" alt="ibm08" height="270" width="349" /></a>
<p><i>Obrázek 6: Sálový počítač IBM-705.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozdělení sálových počítačů IBM podle způsobu jejich použití</h2>

<p>Nehledě na technologii elektronických součástek používaných při implementaci
logických obvodů (elektronky &times; tranzistory) byly první dvě generace
sálových počítačů firmy IBM vyráběny v&nbsp;několika různých řadách, které se
od sebe odlišovaly především tím, pro jaký typ úloh byly tyto počítače určeny.
Jedná se o odlišný přístup, než na jaký jsme zvyklí dnes, protože
v&nbsp;současnosti se setkáváme s&nbsp;prakticky zcela univerzálními počítači
(i když výjimky se také najdou, jedná se například o specializované
mikrořadiče, zařízení se signálovými procesory atd.). Nicméně na přelomu
padesátých a šedesátých let minulého století byli inženýři firmy IBM (a nejenom
oni) přesvědčeni o tom, že struktura procesoru (aritmeticko-logické jednotky,
řadiče a registrů)  a tím pádem i jeho instrukční sada musí být optimalizována
s&nbsp;ohledem na to, k&nbsp;jakému účelu je daný model počítače používán, zda
pro numerické vědeckotechnické výpočty (tyto počítače byly například používány
v&nbsp;misích NASA), účetní operace či pro hromadné zpracování dat.</p>

<p>Instrukční sady sálových počítačů byly navíc poměrně složité (dnes bychom
řekli, že se jednalo o architekturu CISC), což sice pomáhalo programátorům při
psaní aplikací v&nbsp;assembleru, ale s&nbsp;nástupem překladačů vyšších
programovacích jazyků se ukázalo, že mnohé strojové instrukce tyto překladače
vůbec nepoužívají a že zjednodušení instrukční sady procesorů může vést
k&nbsp;urychlení zpracování instrukcí (například se vynechá nutnost
mikroprogramování či dokonce nanoprogramování, zjednoduší se dekodér instrukcí
atd.), což je idea, která a mnoho let později vedla ke vzniku procesorů RISC,
tj.&nbsp;procesorů se zjednodušenou instrukční sadou. Nicméně v&nbsp;dobách
sálových počítačů 7xx a 7xxx se firmy, které si tyto počítače pořizovaly,
musely podle plánovaného nasazení těchto strojů rozhodnout, který typ si
zakoupí &ndash; bližší informace jsou uvedeny v&nbsp;navazujících
kapitolách.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. IBM 704 &ndash; sálový počítač určený pro vědeckotechnické výpočty</h2>

<p>Typickým představitelem sálových počítačů navržených pro provádění
vědeckotechnických výpočtů je model <strong>IBM 704</strong>. Jedná se o
počítač založený na dnes již překonaných technologiích &ndash; elektronkách
(procesor, tj.&nbsp;jak aritmeticko-logická jednotka, tak i řadič) a feritových
pamětech s&nbsp;dobou přístupu 12 mikrosekund. Tento počítač zpracovával
numerické hodnoty uložené ve slovech, jejichž šířka byla rovna 36 bitům,
přičemž <i>akumulátor</i> (registr používaný jako zdroj i cíl aritmetických
operací) byl rozšířen o další dva bity na celkovou šířku 38 bitů.
Aritmeticko-logická jednotka tohoto počítače dokázala zpracovávat tři typy
hodnot:</p>

<ol>

<li>Celá čísla či čísla s&nbsp;pevnou řádovou čárkou. Absolutní hodnota čísla
byla uložena v&nbsp;35 bitech, bit s&nbsp;nejvyšší váhou nesl znaménko uložené
či zpracovávané hodnoty (to je zajímavé, bylo tak možné reprezentovat i
zápornou nulu, kód byl symetrický).</li>

<li>Čísla s&nbsp;pohyblivou řádovou čárkou, u kterých byl jeden bit rezervován
pro uložení znaménka, osm bitů pro uložení exponentu (posunutého o hodnotu 128)
a zbylých 27 bitů bylo použito pro uložení mantisy (v&nbsp;akumulátoru bylo
díky dalším dvou bitům možné mantisu uložit v&nbsp;29 bitech). Formát čísel
s&nbsp;pohyblivou řádovou čárkou použitý u tohoto počítače do značné míry
připomíná formát &bdquo;single&ldquo; specifikovaný v&nbsp;normě IEEE 754,
ovšem s&nbsp;tím rozdílem, že pro mantisu je zde použit větší počet bitů
(základem exponentu je v&nbsp;obou případech hodnota 2).</li>

<li>Alfanumerické znaky uložené po šesticích do slova s&nbsp;délkou 36 bitů.
Každý alfanumerický znak je v&nbsp;tomto případě představován šesti bity,
tj.&nbsp;rozeznávalo se pouze 64 různých znaků.</li>

</ol>

<p>Bitově vypadá rozdělení 36bitového slova s&nbsp;FP hodnotou:</p>

<table>
<tr><th>bit</th><td>35</td><td>34 ... 27</td><td>26 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (27 bitů)</td></tr>
</table>

<a href="http://i.iinfo.cz/images/118/ibm07.jpg"><img src="http://i.iinfo.cz/images/118/ibm07-prev.jpg" alt="ibm07" height="270" width="331" /></a>
<p><i>Obrázek 7: Sálový počítač IBM-704.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Počítače série IBM 1400</h2>

<p>Firma <i>IBM</i> na začátku šedesátých let minulého století nabízela i
počítače, jejichž procesory zpracovávaly řetězce a číselné údaje proměnné délky
(reprezentovaná různým způsobem, například v&nbsp;kódu 1 z 10 u děrných štítků
a v&nbsp;BCD v&nbsp;případě uložení údajů do operační paměti), což je poměrně
podstatný rozdíl oproti moderním mikroprocesorům, které zpracovávají numerické
údaje zakódované binárně do slov pevné délky (například 16, 32 či 64 bitů) a
zpracování řetězců buď není podporováno vůbec (RISC procesory) nebo pouze
několika strojovými instrukcemi (architektura <i>i386</i>). Jedná se o počítače
série <i>1400</i>, které byly i přes výkonnostní rozdíly vzájemně kompatibilní
(týká se to jak kompatibility aplikací, tak i kompatibility periferních
zařízení):</p>

<table>
<tr><th>Označení modelu</th><th>Rok vzniku</th></tr>
<tr><td>IBM 1240</td><td>1963</td></tr>
<tr><td>IBM 1401</td><td>1959</td></tr>
<tr><td>IBM 1410</td><td>1960</td></tr>
<tr><td>IBM 1420</td><td>1962</td></tr>
<tr><td>IBM 1440</td><td>1962</td></tr>
<tr><td>IBM 1450</td><td>1968</td></tr>
<tr><td>IBM 1460</td><td>1963</td></tr>
<tr><td>IBM 7010</td><td>1962</td></tr>
</table>

<a href="http://i.iinfo.cz/images/503/ibm2-1.jpg"><img src="http://i.iinfo.cz/images/503/ibm2-1-prev.jpg" alt="ibm2" height="184" width="370" /></a>
<p><i>Obrázek 8: Část sálového počítače IBM 1401.</i></p>

<p>Snaha o dosažení co nejvyšší míry kompatibility s&nbsp;počítači série <i>IBM
1400</i> šla dokonce tak daleko, že některé mainframy řady <i>IBM
System/360</i>, například model <i>30</i>, bylo možné nakonfigurovat tak, aby
dokázaly spouštět aplikace vytvořené pro řadu <i>1400</i>. Vzhledem
k&nbsp;tomu, že procesory počítačů <i>IBM System/360</i> většinou obsahovaly
mikrokód, bylo přepnutí do režimu kompatibility s&nbsp;počítači <i>1400</i>
poměrně snadné a zůstal přitom zachován relativně vysoký výpočetní výkon.
Emulace řady <i>1400</i> byla použita i u dalších mainframů firmy <i>IBM</i>,
takže aplikace napsané pro <i>IBM 1400</i> mnohdy beze změny fungovaly i
několik desítek let (do některých musel být zásah proveden až kvůli
&bdquo;syndromu&ldquo; Y2K, což znamená, že mnohé tyto programy mohly beze
změny pracovat i po dobu delší než 35 let!)).</p>

<a href="http://i.iinfo.cz/images/503/ibm2-2.jpg"><img src="http://i.iinfo.cz/images/503/ibm2-2-prev.jpg" alt="ibm2" height="270" width="188" /></a>
<p><i>Obrázek 9: Zrekonstruovaný řídicí panel počítače IBM 1401.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Formát dat zpracovávaných počítači IBM 1400</h2>

<p>V&nbsp;předchozí kapitole jsme si řekli, že počítače série <i>IBM 1400</i>
zpracovávaly řetězce a číselné hodnoty proměnné délky. Jednotlivé číslice byly
ukládány v&nbsp;kódu BCD (binary-coded decimal), tj.&nbsp;ve čtyřech bitech
označovaných symboly <strong>8</strong>, <strong>4</strong>, <strong>2</strong>
a <strong>1</strong> (tyto symboly samozřejmě odpovídají váze každého bitu).
K&nbsp;těmto čtyřem bitům se přidávaly bity označované symboly
<strong>A</strong> a <strong>B</strong>, jejichž nastavením bylo možné rozšířit
repertoár zpracovávaných dat i o znaky a řídicí kódy (u samotných číslic byly
bity <strong>A</strong> i <strong>B</strong> vždy nulové). K&nbsp;takto vzniklé
šestici bitů se navíc automaticky přidával bit <strong>C</strong> nesoucí
informaci o paritě (lichá parita použitá k&nbsp;detekci jednoduché chyby) a bit
<strong>M</strong>, jehož hodnota udávala, zda se jedná o poslední číslici
numerické hodnoty či poslední znak řetězce. Výsledný formát bajtů
zpracovávaných počítačem <i>IBM 1400</i> je následující:</p>

<pre>
C B A 8 4 2 1 M
</pre>

<p>Celou tabulku hodnot jednotlivých bitů i přiřazení těchto kombinací číslicím
a znakům je dostupný na adrese <a
href="http://en.wikipedia.org/wiki/IBM_1401#Character_and_Op_codes">http://en.wikipedia.org/wiki/IBM_1401#Character_and_Op_codes</a>.
Povšimněte se, že příznak ukončení numerické hodnoty či řetězce (bit
<strong>M</strong>) je součástí každého bajtu, což je poměrně velký rozdíl
oproti formátu řetězců používaných například v&nbsp;céčku (ukončení znakem NUL,
tj.&nbsp;nulovým bajtem; podporováno některými mikroprocesory) nebo řetězcům,
kterým předchází bajt/slovo s&nbsp;uloženu délkou (některé Basicy, klasický
Forth, Pascal atd., taktéž podporováno některými mikroprocesory, viz například
prefixový kód <strong>REP</strong> u architektury <i>i386</i>).</p>

<img src="http://i.iinfo.cz/images/503/ibm2-3.jpg" alt="ibm2" height="210" width="280" />
<p><i>Obrázek 10: Jedno velmi často používané periferní zařízení &ndash; řádková
tiskárna IBM 1403. Mimochodem: právě tuto tiskárnu můžete vidět ve slavném
filmu Dr. Divnoláska (Dr. Strangelove).</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Sovětský elektronkový počítač Strela a jím používaný formát numerických hodnot</h2>

<p>Jedním z&nbsp;prvních poměrně úspěšných počítačů navržených a vyráběných
v&nbsp;SSSR byly počítače <i>Strela-1</i>, které byly vytvořeny vývojovým týmem
vedeným Y. Bazilevským. Jednalo se o první počítač, který byl v&nbsp;SSSR
vyráběn sériově (v&nbsp;průběhu let 1953 až 1956), i když celkový počet
vyrobených a následně plně zprovozněných počítačů dosahoval pouze několika
jednotek, s&nbsp;velkou pravděpodobností 7 až 10 kusů. Dostupné údaje o počtu
vyrobených kusů se od sebe liší, pravděpodobně i z&nbsp;toho důvodu, že některé
instalace počítačů <i>Strela</i> neobsahovaly všechny moduly, takže například
počet vyrobených procesorových jednotek se odlišuje od počtu bubnových pamětí
atd. Po technologické stránce se tyto počítače příliš neodlišovaly od jejich
západních kolegů &ndash; procesorová jednotka i řadič byly vytvořeny
z&nbsp;elektronek a polovodičových diod, využívaly se bubnové paměti,
Williamsovy (katodové) trubice, magnetické pásky, děrné štítky atd.</p>

<a href="http://i.iinfo.cz/images/356/sssr03.jpg"><img src="http://i.iinfo.cz/images/356/sssr03-prev.jpg" width="370" height="128" alt="sssr03" /></a>
<p><i>Obrázek 11: Pohled na počítač Strela, z&nbsp;jehož rozměrů je zřejmé,
proč se těmto strojům říkalo &bdquo;sálové počítače&ldquo;.</i></p>

<p>Počítače <i>Strela</i> byly určeny především pro numerické výpočty
(simulace, vědeckotechnické aplikace, další vývoj výpočetní techniky), čemuž
odpovídá i formát údajů, které bylo možné v&nbsp;procesorové jednotce těchto
počítačů zpracovávat &ndash; jednalo se o číselné hodnoty reprezentované ve
formátu plovoucí řádové čárky, které byly uložené ve slovech i poněkud
neobvyklé šířce 43 bitů. Pokud vám připadá podivné, že tyto počítače
nezpracovávaly slova o šířce, jež je celočíselným násobkem osmi (8 bitů, 16
bitů, 32 bitů, 64 bitů), vzpomeňte si na <i>IBM 704</i> (1954,
tj.&nbsp;současník počítače <i>Strela</i>, dokonce i určení tohoto počítače
bylo podobné), jež zpracovávaly operandy o šířce 36 bitů. Bitová šířka
zpracovávaných operandů na hodnoty obvyklé dnes se ustálila až o cca 10 let
později.</p>

<p>Procesorová jednotka elektronkového počítače <i>Strela</i> pracovala
s&nbsp;operandy majícími šířku 43 bitů. Číselné hodnoty mohly být uloženy ve
dvou formátech &ndash; binárním formátu s&nbsp;pohyblivou řádovou čárkou (<i>FP
&ndash; floating point</i>) a BCD formátu, taktéž s&nbsp;pohyblivou řádovou
čárkou. Největší rozdíl mezi těmito dvěma formáty spočíval v&nbsp;tom, jakým
způsobem byly zakódovány číslice mantisy. Buď se jednalo o binární kód:
v&nbsp;tomto případě byla mantisa uložena na 35 bitech, což odpovídá 10 až 11
platným desítkovým číslicím. Nebo bylo možné pro uložení mantisy použít kód
BCD, což znamenalo, že každá číslice mantisy byla uložena ve čtveřici bitů.
Délka mantisy byla v&nbsp;tomto případě rovna 36 bitům, což odpovídá 36/4=9
číslicím. To je sice méně než při použití binárního formátu, ale operace pro
vstupy nebo výstupy numerických hodnot se díky použití BCD kódu zjednodušily
(ostatně právě z&nbsp;tohoto důvodu se BCD používal i na mnoha kalkulačkách,
včetně legendární <i>HP-35</i>). Funkce jednotlivých bitů 43bitových slov
zpracovávaných procesorem počítače <i>Strela</i> jsou uvedeny
v&nbsp;následující dvojici tabulek:</p>

<p><strong>Binární formát uložení mantisy:</strong></p>

<table>
<tr><th>Bity (pozice)</th><th>Význam</th></tr>
<tr><td>0    </td><td>znaménko mantisy</td></tr>
<tr><td>1-35 </td><td>absolutní hodnota mantisy</td></tr>
<tr><td>36   </td><td>znaménko exponentu</td></tr>
<tr><td>37-42</td><td>hodnota exponentu</td></tr>
<tr><th>Přesnost</th><td>10&ndash;11 desítkových číslic</td></tr>
<tr><th>Rozsah</th><td>1.8&times;10<sup>-19</sup> až 1.8&times;10<sup>19</sup></td></tr>
</table>

<p><strong>BCD formát uložení mantisy:</strong></p>

<table>
<tr><th>Bity (pozice)</th><th>Význam</th></tr>
<tr><td>0    </td><td>znaménko mantisy</td></tr>
<tr><td>1-36 </td><td>mantisa uložená v&nbsp;BCD tvaru &ndash; 4 bity na číslici</td></tr>
<tr><td>37   </td><td>znaménko exponentu</td></tr>
<tr><td>38-42</td><td>hodnota exponentu</td></tr>
<tr><th>Přesnost</th><td>9 desítkových číslic</td></tr>
<tr><th>Rozsah</th><td>1.8&times;10<sup>-19</sup> až 1.8&times;10<sup>19</sup></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Slavná architektura IBM/360 a její matematický procesor</h2>

<p>V&nbsp;roce 1964 firma <i>IBM</i> oznámila vznik nové série počítačů
pojmenované <i>System/360</i>. Číslo &bdquo;360&ldquo; v&nbsp;názvu této série
naznačovalo, že se jedná o universální počítače, což znamenalo určitý odklon
firmy IBM od návrhu počítačů specializovaných na určitý typ úloh (viz výše
popisované počítače specializované buď na hromadné zpracování dat nebo na
provádění vědeckotechnických výpočtů). Celá série <i>System/360</i> původně
zahrnovala šest vzájemně kompatibilních modelů, které se však od sebe
odlišovaly jak cenou, tak i výpočetním výkonem (mezi nejvýkonnějším a nejméně
výkonným modelem dosahoval poměr výpočetní rychlosti hodnoty téměř 25:1).</p>

<a href="http://i.iinfo.cz/images/503/ibm2-4.jpg"><img src="http://i.iinfo.cz/images/503/ibm2-4-prev.jpg" alt="ibm2" height="270" width="349" /></a>
<p><i>Obrázek 12 Jeden z&nbsp;prvních modelů počítače série System/360.</i></p>

<p>Procesory počítačů <i>System/360</i> zpracovávaly poměrně složité instrukce,
protože se jednalo o klasickou architekturu CISC (v&nbsp;té době se věřilo, že
komplexní instrukční sada pomůže programátorům překonat sémantickou propast
mezi strojovým kódem popř.&nbsp;assemblerem a vyššími programovacími jazyky).
Aby i jednodušší modely série <i>System/360</i> mohly zpracovávat všechny
instrukce, používaly jejich procesory mikrokód, pomocí něhož se složitější
instrukce rozdělily na sérii jednodušších mikroinstrukcí (ty měly zcela jiný
formát, protože se jimi přímo ovládaly jednotlivé bloky v&nbsp;procesoru
&ndash; ALU, registry, interní sběrnice atd.). Jednalo se o 32bitovou
architekturu se šestnácti 32bitovými registry označovanými jmény <i>R0</i> až
<i>R15</i> a čtyřmi 64bitovými registry určenými pro práci s&nbsp;hodnotami
uloženými ve formátu pohyblivé řádové čárky. Kromě pracovních registrů procesor
obsahoval i <strong>PSW</strong> (processor status word), v&nbsp;němž byl
uložen i čítač instrukcí <strong>PC</strong>, příznak práce
v&nbsp;superuživatelském režimu atd.</p>

<a href="http://i.iinfo.cz/images/503/ibm2-6.jpg"><img src="http://i.iinfo.cz/images/503/ibm2-6-prev.jpg" alt="ibm2" height="270" width="206" /></a>
<p><i>Obrázek 13: Úvodní stránka manuálu k&nbsp;assembleru počítačů
System/360.</i></p>

<p>Výkonný model označovaný <i>IBM System/360 Model 91</i> byl vybaven i
matematickým procesorem se čtyřmi pracovními registry, z&nbsp;nichž každý měl
šířku 64 bitů.  Pro reprezentaci čísel v&nbsp;pohyblivé řádové čárce se
používal formát navržený samotnou firmou IBM s&nbsp;jednoduchou (<i>single</i>)
či dvojitou (<i>double</i>) přesností, o kterém se v&nbsp;tomto článku zmiňuji
i z&nbsp;toho důvodu, že se dodnes používá například v&nbsp;několika
souborových formátech. I když moderní matematické koprocesory na platformě
<i>i386</i> využívají formát numerických hodnot definovaný v&nbsp;IEEE 754,
který je v&nbsp;několika ohledech od formátu firmy IBM odlišný (rozdílné šířky
mantisy a exponentu, jiná hodnota biasu), je původní &bdquo;360&ldquo; formát
zachován například v&nbsp;mainframech <i>IBM System z10</i>, spolu
s&nbsp;formátem IEEE 754.</p>

<p>Největším rozdílem IBM System/360 oproti jiným počítačům při práci s&nbsp;FP
hodnotami je použitá báze, která <i>není</i> rovna dvěma ale šestnácti. To
znamená, že změna exponentu o jedničku znamená změnu uložené hodnoty na
šestnáctinásobek či naopak na 1/16. Díky tomu se mohlo pro exponent obětovat
pouze sedm bitů, a to při zachování dostatečného rozsahu. Taktéž se lišil
algoritmu normalizace hodnot, který vyžadovat, že nejvyšší 4 bity mantisy budou
nenulové. To v&nbsp;některých případech snižovalo přesnost (u single na pouhých
21 bitů namísto 24). Zpočátku také nebylo nijak definováno, jak se mají
reprezentovat speciální hodnoty typu +&infin;, -&infin; a 0/0 (či jiné
NaN).</p>

<p>Rozsah normalizovaných hodnot je 16<sup>-65</sup> až zhruba
16<sup>63</sup>.</p>

<img src="http://i.iinfo.cz/images/558/ibm3-5.jpg" alt="ibm3_" height="269" width="349" />
<p><i>Obrázek 14: Částečně zrekonstruovaný ovládací panel počítače IBM
System/360 Model 91.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Superpočítače Cray</h2>

<p>V&nbsp;tomto článku samozřejmě nesmíme zapomenout na superpočítače Cray,
které jsou známé především díky špičkovému výpočetnímu výkonu a také
astronomickými sumami, za které je bylo možné pořídit :-). Tyto stroje byly
optimalizovány pro provádění výpočtů se skalárními hodnotami, vektory i
maticemi, což znamená, že se jejich architektura poměrně značně odlišovala od
například již zmíněných strojů <i>Connection Machine</i>, které spíše
excelovaly při (symbolickém) zpracovávání strukturovaných údajů &ndash;
seznamů, stromů, grafů atd. Díky tomu, že jedním z&nbsp;cílů počítačů
<i>Cray</i> byl co největší výpočetní výkon, umisťovaly se tyto stroje mezi
TOP10 nejvýkonnějších počítačů světa.</p>

<img src="http://i.iinfo.cz/images/625/37cray-a-1.jpg" width="350" height="467" alt=" " />
<p><i>Obrázek 15: Celkový pohled na superpočítač Cray-1.</i></p>

<p>Dokonce ještě v&nbsp;roce 2010 byl nejrychlejším (reálně existujícím)
počítačem na světě <i>Jaguar</i> neboli <i>Cray XT5</i> s&nbsp;výpočetním
výkonem neuvěřitelných 1.75 PFLOPS (petaflops), který překonal i <i>IBM
Roadrunner</i>. Vzhledem k&nbsp;tomu, že počítače Cray zpracovávaly a
zpracovávají neuvěřitelné množství numerických dat, může být popis jejich
interního formátu FP hodnot užitečný.</p>

<img src="http://i.iinfo.cz/images/625/37cray-a-2.jpg" width="350" height="438" alt=" " />
<p><i>Obrázek 16: Cray-1 a jeho duchovní otec a konstruktér.</i></p>

<p>Počítače <i>Cray-1</i> používaly pro skalární i vektorové operace numerické
hodnoty uložené v&nbsp;systému plovoucí řádové čárky (<i>FP</i>). Tyto hodnoty
byly sice uložené v&nbsp;64 bitech, podobně jako je tomu u formátu
<i>double</i> v&nbsp;normě IEEE 754, ovšem význam jednotlivých bitů je poněkud
jiný, takže se liší jak rozsah uchovávaných hodnot, tak i počet platných míst,
což je patrné z&nbsp;následující tabulky:</p>

<table>
<tr><th>&nbsp;</th><th>Min</th><th>Max</th><th>Počet míst</th></tr>
<tr><td>IEEE single</td><td>1.17E-0038</td><td>3.40E+0038</td><td> 7</td></tr>
<tr><td>IEEE double</td><td>2.22E-0308</td><td>1.79E+0308</td><td>16</td></tr>
<tr><td>Cray single</td><td>3.67E-2466</td><td>2.73E+2465</td><td>15</td></tr>
</table>

<img src="http://i.iinfo.cz/images/625/37cray-a-3.jpg" width="405" height="540" alt=" " />
<p><i>Obrázek 17: Detail spodní části superpočítače CRAY-1S. Na pravé straně
fotografie je patrný &bdquo;vstup&ldquo; do vnitřního prostoru stroje.</i></p>

<p>Obsazení bitů v&nbsp;64bitovém slovu (registru) je u počítačů <i>Cray-1</i>
následující:</p>

<pre>
 1 1      14                              48
+-+-+--------------+------------------------------------------------+
|s|t|      e       |                       m                        |
+-+-+--------------+------------------------------------------------+
</pre>

<p>kde:</p>

<ul>
<li><strong>s</strong>: znaménko mantisy</li>
<li><strong>t</strong>: znaménko exponentu</li>
<li><strong>e</strong>: exponent</li>
<li><strong>m</strong>: mantisa</li>
</ul>



<p><a name="k12"></a></p>
<h2 id="k12">12. Příchod osmibitových mikropočítačů</h2>

<p>O významu osmibitových domácích i osobních mikropočítačů jsme se již <a
href="https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/">zmiňovali
minule</a>, a to v&nbsp;kontextu s&nbsp;programovacími jazyky. Osmibitové
mikropočítače měly společnou minimálně jednu vlastnost &ndash; neobsahovaly
žádný matematický koprocesor, takže se veškeré výpočty musely zdlouhavě
provádět na osmibitovém CPU (přičemž jen některé CPU obsahovaly násobičku). Na
druhou stranu to tvůrcům programového vybavené umožnilo volbu rozličných
formátů reprezentace čísel. V&nbsp;dalších kapitolách se seznámíme
s&nbsp;formátem používaným Applesoft BASICem na počítačích Apple II, dále
s&nbsp;prakticky totožným formátem využívaným na ZX Spectru a nezapomeneme ani
na Atari BASIC se zajímavým formátem založeným na desítkové a nikoli dvojkové
bázi.</p>

<a href="http://www.root.cz/obrazek/210830/"><img src="http://i.iinfo.cz/images/462/dev-8bit-26.png" class="image-210830" width="336" height="240" alt="&#160;" /></a>
<p><i>Obrázek 18: Výkonu Crayů v&nbsp;FP operacích osmibitové mikropočítače
samozřejmě ani zdaleka nedosahovaly. Tento výpočet Mandelbrotovy množiny
v&nbsp;Atari BASICu trval přibližně osm hodin.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Formát FP hodnot v&nbsp;Applesoft BASICu a na ZX Spectru</h2>

<p><i>&bdquo;Before .Net, before math coprocessors, before IEEE-574, Microsoft
defined a bit pattern for floating-point numbers.&ldquo;</i></p>

<p>Applesoft BASIC na osobních osmibitových mikropočítačích Apple používal
formát FP hodnot, který je známý pod jménem MBF neboli Microsoft Binary Format.
Tento formát byl navržen Monte Davidoffem pro Altair Basic a později byl
portován i do Applesoft Basicu. Ve skutečnosti existoval Microsoft Binary
Format ve více variantách, především v&nbsp;32bitové a 40bitové variantě.
Applesoft BASIC využíval právě 40bitovou variantu, v&nbsp;níž je mantisa
uložena ve čtyřech bajtech (32 bitech), pro znaménko je vyhrazen další bit a
zbývajících sedm bitů je použito pro exponent s&nbsp;biasem (offsetem)
nastaveným na 128. Báze je samozřejmě rovna dvěma:</p>

<pre>
       8        1                        31
+--------------+-+------------------------------------------------+
|      e       |s|                       m                        |
+--------------+-+------------------------------------------------+
</pre>

<img src="https://i.iinfo.cz/images/373/fp-nubmers-2.png" class="image-304884" alt="&#160;" width="640" height="512" />
<p><i>Obrázek 19: Primitivní prográmek pro zjištění, zda dojde
k&nbsp;překročení maximální reprezentovatelné hodnoty.</i></p>

<p>I na ZX Spectru se používal podobný formát numerických hodnot uložených
v&nbsp;pěti bajtech (40 bitech), ovšem na těchto počítačích se mantisa
normalizovala takovým způsobem, aby její nejvyšší bit byl jedničkový. Nejmenší
reprezentovatelná hodnota odlišná od nuly byla přibližně
&pm;4&times;10<sup>-39</sup>, nejvyšší hodnota pak cca 10<sup>38</sup>, což pro
většinu výpočtů zcela dostačovalo. Při výpočtech se kontrolovalo překročení
maximální hodnoty, což mj.&nbsp;znamená, že neexistovaly speciální hodnoty typu
+&infin; atd.</p>

<img src="https://i.iinfo.cz/images/373/fp-nubmers-3.png" class="image-304885" alt="&#160;" width="640" height="512" />
<p><i>Obrázek 20: Interpret BASICu korektně zjistil, že výpočet přesáhl
maximální hodnotu.</i></p>

<p>Podobně jako u dále popsaného typu <strong>real</strong> v&nbsp;Turbo
Pascalu leží vlastnosti FP hodnot ZX Spectra mezi možnostmi typů single a
double podle IEEE 754.</p>

<img src="https://i.iinfo.cz/images/373/fp-nubmers-4.png" class="image-304886" alt="&#160;" width="640" height="512" />
<p><i>Obrázek 21: Výsledek pokusu o dělení nulou (viz výpis programu).</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Atari BASIC a jeho neortodoxní reprezentace reálných čísel</h2>

<p>V&nbsp;Atari BASICu, přesněji řečeno v&nbsp;subrutinách uložených
v&nbsp;ROM, které se staraly o výpočty nad reálnými čísly, se používal formát
odlišný od prakticky všech předchozích formátů. Stále se sice jedná o hodnoty
s&nbsp;plovoucí řádovou čárkou, ovšem báze není rovna dvěma (většina strojů)
ani šestnácti (IBM/360), ale stu! Navíc není mantisa uložená binárně, ale
používá se BCD, což konkrétně znamená, že v&nbsp;pěti bajtech je uloženo přesně
deset číslic (procesor 6502 dokázal s&nbsp;BCD pracovat nativně). To není úplně
špatné řešení, protože ho najdeme například na mnoha kalkulačkách. Zjednodušují
se převody řetězců na čísla a naopak, na druhou stranu jsou však veškeré
výpočty značně pomalejší a přesnost ani rozsah hodnot není tak vysoký, jako při
použití binárního kódu.</p>

<p>Formát uložení FP hodnot tedy vypadá následovně:</p>

<table>
<tr><th>Bajt</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr>
<tr><td>Význam</td><td>znaménko+exponent</td><td>2 BCD číslice</td><td>2 BCD číslice</td><td>2 BCD číslice</td><td>2 BCD číslice</td><td>2 BCD číslice</td></tr>
</table>

<p>Povšimněte si faktu, že pro uložení exponentu muselo stačit pouze sedm bitů,
což je pro formát používající šest bajtů pro jednu hodnotu, na první pohled
poměrně málo, ovšem musíme si uvědomit, že báze je rovna 100 a nikoli 2.</p>

<a href="https://www.root.cz/obrazek/304887/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-5-prev.png" class="image-304887" alt="&#160;" width="370" height="222" /></a>
<p><i>Obrázek 22: Po vytvoření nové proměnné (s&nbsp;reálnou hodnotou) se
v&nbsp;paměti alokuje celkem devět bajtů, přičemž šest bajtů zabere vlastní
hodnota (viz předchozí tabulku), dva bajty typ a jméno proměnné a jeden bajt
její index.</i></p>

<p>Uložená hodnota se vypočte takto: mantisa&times;100<sup>exponent-64</sup></p>

<p>Pokud je exponent sudý, lze přesně reprezentovat deset číslic (cifer), u
lichého exponentu jen devět číslic (cifer). Je to logické, protože změna
exponentu o jedničku znamená posun čárky o dvě cifry.</p>

<a href="https://www.root.cz/obrazek/304888/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-6-prev.png" class="image-304888" alt="&#160;" width="370" height="222" /></a>
<p><i>Obrázek 23: V&nbsp;mnoha moderních jazycích dojde při výpočtech
k&nbsp;&bdquo;tichému&ldquo; přetečení z&nbsp;nejvyšší hodnoty do nekonečna.
V&nbsp;Atari BASICu není možné &infin; reprezentovat a proto je namísto toho
hlášena chyba.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vlastnosti formátu použitého v&nbsp;osmibitových Atari</h2>

<p>Jaké má toto řešení výhody? Především lze přesně reprezentovat často
používané hodnoty 0,1, 0,01 atd. Ostatně podívejme se na to, jak se chová
interpret jazyka Lua (používá typ <i>double</i>), interpret Pythonu (taktéž
<i>double</i>) a interpret Atari BASICu:</p>

<p>Lua:</p>

<pre>
&gt; print(0.2 + 0.2 == 0.4)
true
&nbsp;
&gt; print(0.1 + 0.2 == 0.3)
<strong>false</strong>
&nbsp;
&gt; print(1 + 2 == 3)
true
</pre>

<p>Python:</p>

<pre>
&gt;&gt;&gt; 0.2 + 0.2 == 0.4
True
&nbsp;
&gt;&gt;&gt; 0.1 + 0.2 == 0.3
<strong>False</strong>
&nbsp;
&gt;&gt;&gt; 1 + 2 == 3
True
</pre>

<p>Atari BASIC:</p>

<pre>
PRINT 0.2 + 0.2 = 0.4
1
&nbsp;
PRINT 0.1 + 0.2 = 0.3
1
&nbsp;
PRINT 1 + 2 = 3
1
&nbsp;
</pre>

<p>Poznámka: v&nbsp;Atari BASICu odpovídá hodnota 1 pravdivostní hodnotě
True.</p>

<p>Dále &ndash; nebylo možné reprezentovat žádné speciální hodnoty, takže
dělení nulou či výpočet 0/0 skončil s&nbsp;chybou:</p>

<a href="https://www.root.cz/obrazek/304889/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-7-prev.png" class="image-304889" alt="&#160;" width="370" height="222" /></a>
<p><i>Obrázek 24: Speciální hodnoty není možné reprezentovat.</i></p>

<p>Pro zajímavost jsou v&nbsp;následující tabulce vypsány adresy těch
paměťových buněk, které se používají FP subsystémem operačního systému
osmibitových mikropočítačů Atari. Prvních šest oblastí paměti je uloženo
v&nbsp;RAM, další oblasti pak v&nbsp;paměti ROM (jedná se o subrutiny):</p>

<table>
<tr><th>Jméno</th><th>Adresa</th><th>Délka (bajtů)</th><th>Význam</th></tr>
<tr><td>FR0   </td><td>0x00D4</td><td>6</td><td>první FP operand</td></tr>
<tr><td>FR1   </td><td>0x00E0</td><td>6</td><td>druhý FP operand</td></tr>
<tr><td>CIX   </td><td>0x00F2</td><td>1</td><td>index do INBUFF</td></tr>
<tr><td>INBUFF</td><td>0x00F3</td><td>2</td><td>ukazatel na buffer používaný při převodu z&nbsp;řetězce na FP</td></tr>
<tr><td>FLPTR </td><td>0x00FC</td><td>2</td><td>ukazatel na uživatelský buffer</td></tr>
<tr><td>LBUFF </td><td>0x0580</td><td>?</td><td>buffer používaný při převodu na řetězec</td></tr>
<tr><td>AFP   </td><td>0xD800</td><td>?</td><td>subrutina pro převod řetězce na FP</td></tr>
<tr><td>FASC  </td><td>0xD8E6</td><td>?</td><td>subrutina pro převod FP na řetězec</td></tr>
<tr><td>IFP   </td><td>0xD9AA</td><td>?</td><td>subrutina pro převod integer na FP</td></tr>
<tr><td>FPI   </td><td>0xD9D2</td><td>?</td><td>subrutina pro převod FP na integer</td></tr>
<tr><td>ZFR0  </td><td>0xDA44</td><td>?</td><td>subrutina pro vymazání FR0</td></tr>
<tr><td>ZF1   </td><td>0xDA46</td><td>?</td><td>subrutina pro vymazání bufferu FP</td></tr>
<tr><td>FSUB  </td><td>0xDA60</td><td>?</td><td>subrutina pro výpočet FR0 - FR1</td></tr>
<tr><td>FADD  </td><td>0xDA66</td><td>?</td><td>subrutina pro výpočet FR0 + FR1</td></tr>
<tr><td>FMUL  </td><td>0xDADB</td><td>?</td><td>subrutina pro výpočet FR0 * FR1</td></tr>
<tr><td>FDIV  </td><td>0xDB28</td><td>?</td><td>subrutina pro výpočet FR0 / FR1</td></tr>
<tr><td>FLD0R </td><td>0xDD89</td><td>?</td><td>subrutina pro načtení FR0 s&nbsp;použitím X,Y jako ukazatelů</td></tr>
<tr><td>FLD0P </td><td>0xDD8D</td><td>?</td><td>subrutina pro načtení FR0 přes ukazatel FLPTR</td></tr>
<tr><td>FLD1R </td><td>0xDD98</td><td>?</td><td>subrutina pro načtení FR1 s&nbsp;použitím X,Y jako ukazatelů</td></tr>
<tr><td>FLD1P </td><td>0xDD9C</td><td>?</td><td>subrutina pro načtení FR1 přes ukazatel FLPTR</td></tr>
<tr><td>FST0R </td><td>0xDDA7</td><td>?</td><td>subrutina pro uložení FR0 na adresu v&nbsp;X,Y</td></tr>
<tr><td>FST1P </td><td>0xDDAB</td><td>?</td><td>subrutina pro uložení FR0 na adresu v&nbsp;FLPTR</td></tr>
<tr><td>FMOVE </td><td>0xDDB6</td><td>?</td><td>subrutina pro převod FR0 do FR1</td></tr>
<tr><td>EXP   </td><td>0xDDC0</td><td>?</td><td>subrutina pro výpočet e^n</td></tr>
<tr><td>EXP10 </td><td>0xDDCC</td><td>?</td><td>subrutina pro výpočet 10^n</td></tr>
<tr><td>PLYEVL</td><td>0xDD40</td><td>?</td><td>subrutina pro další výpočty pomocí řady</td></tr>
<tr><td>LOG   </td><td>0xDECD</td><td>?</td><td>subrutina pro výpočet ln FR0</td></tr>
<tr><td>LOG10 </td><td>0xDED1</td><td>?</td><td>subrutina pro výpočet log FR0</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Datový typ <strong>real</strong> v&nbsp;Turbo Pascalu</h2>

<p>Standard programovacího jazyka Pascal uvádí několik základních datových
typů, mezi jinými i <strong>real</strong>. Ovšem není nijak specifikováno,
s&nbsp;jakou přesností a rozsahem mají být hodnoty používající tento formát
uloženy. V&nbsp;populárním Turbo Pascalu se používal datový typ
<strong>real</strong>, který je někdy známý i pod označením <i>real48</i>,
protože pro reprezentaci FP hodnoty skutečně využíval 48 bitů. Tento typ byl
navržen ještě předtím, než se na IBM PC rozšířily matematické koprocesory, což
mj.&nbsp;znamenalo, že se hodnoty typu <strong>real</strong> zpracovávaly
softwarově. Rozsah a přesnost leží přibližně na polovině cesty mezi typem
<i>single/float</i> a <i>double</i> z&nbsp;normy IEEE 754.</p>

<a href="https://www.root.cz/obrazek/304890/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-8-prev.png" class="image-304890" alt="&#160;" width="370" height="231" /></a>
<p><i>Obrázek 25: Nabídka datových typů pro FP hodnoty nabízená Turbo Pascalem
7.</i></p>

<p>Formát <i>real48</i> je celkem jednoduchý &ndash; jeden bajt je rezervován
pro uložení exponentu posunutého o 129, dalších pět bajtů pak pro uložení
mantisy. Pouze v&nbsp;posledním bajtu (nejvyšším &ndash; jedná se o little
endian) je jeden bit rezervován pro uložení znaménka:</p>

<table>
<tr><th>Bajt</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr>
<tr><td>Význam</td><td>exponent</td><td>mantisa</td><td>mantisa</td><td>mantisa</td><td>mantisa</td><td>znaménko+mantisa</td></tr>
</table>

<a href="https://www.root.cz/obrazek/304891/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-9-prev.png" class="image-304891" alt="&#160;" width="370" height="231" /></a>
<p><i>Obrázek 26: Testovací prográmek pro zjištění, jak se testuje překročení
maximální hodnoty.</i></p>

<a href="https://www.root.cz/obrazek/304892/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-10-prev.png" class="image-304892" alt="&#160;" width="370" height="231" /></a>
<p><i>Obrázek 27: Pro typ real testování funguje.</i></p>

<a href="https://www.root.cz/obrazek/304893/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-11-prev.png" class="image-304893" alt="&#160;" width="370" height="231" /></a>
<p><i>Obrázek 28: Pro typ real testování funguje.</i></p>

<p>Později byly do Turbo Pascalu přidány i typy <i>single</i>, <i>double</i> a
<i>extended</i>, které mohly být zpracovány buď matematickým koprocesorem nebo
jeho emulátorem. Dnešní varianty Pascalu, tj.&nbsp;FreePascal a Lazarus, již
původní <i>real48</i> nepoužívají a mapují namísto toho <strong>real</strong>
buď na <strong>single</strong> (SW emulace) či na <strong>double</strong> (HW
koprocesor).</p>

<a href="https://www.root.cz/obrazek/304894/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-12-prev.png" class="image-304894" alt="&#160;" width="370" height="231" /></a>
<p><i>Obrázek 29: Testovací prográmek přepsaný pro použití typu single (podle
IEEE 754).</i></p>

<a href="https://www.root.cz/obrazek/304895/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-13-prev.png" class="image-304895" alt="&#160;" width="370" height="231" /></a>
<p><i>Obrázek 30: Hmm, nekonečná smyčka.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Odkazy na Internetu</h2>

<ol>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>IEEE-754 Floating-Point Conversion<br />
<a href="http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html">http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html</a>
</li>

<li>Small Float Formats<br />
<a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats">https://www.khronos.org/opengl/wiki/Small_Float_Formats</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>
<li>Floating-Point Formats<br />
<a href="http://www.quadibloc.com/comp/cp0201.htm">http://www.quadibloc.com/comp/cp0201.htm</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Mainframe computer<br />
<a href="http://en.wikipedia.org/wiki/Mainframe_computer">http://en.wikipedia.org/wiki/Mainframe_computer</a>
</li>

<li>IBM mainframe<br />
<a href="http://en.wikipedia.org/wiki/IBM_mainframe">http://en.wikipedia.org/wiki/IBM_mainframe</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>IBM Floating Point Architecture<br />
<a href="http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture">http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture</a>
</li>

<li>Extended Binary Coded Decimal Interchange Code<br />
<a href="http://en.wikipedia.org/wiki/EBCDIC">http://en.wikipedia.org/wiki/EBCDIC</a>
</li>

<li>ASCII/EBCDIC Conversion Table<br />
<a href="http://docs.hp.com/en/32212-90008/apcs01.html">http://docs.hp.com/en/32212-90008/apcs01.html</a>
</li>

<li>EBCDIC<br />
<a href="http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php">http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php</a>
</li>

<li>EBCDIC tables<br />
<a href="http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm">http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm</a>
</li>

<li>The Mainframe Blog<br />
<a href="http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html">http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html</a>
</li>

<li>IBM Tightens Stranglehold Over Mainframe Market Gets Hit with Antitrust Complaint in Europe<br />
<a href="http://www.ccianet.org/artmanager/publish/news/IBM_Tightens_Stranglehold_Over_Mainframe_Market_Gets_Hit_with_Antitrust_Complaint_in_Europe.shtml">http://www.ccianet.org/artmanager/publish/news/IBM_Tightens_Stranglehold_Over_Mainframe_Market_Gets_Hit_with_Antitrust_Complaint_in_Europe.shtml</a>
</li>

<li>Lectures in the History of Computing: Mainframes<br />
<a href="http://www.computinghistorymuseum.org/teaching/lectures/pptlectures/9-MainframeComputers.ppt">http://www.computinghistorymuseum.org/teaching/lectures/pptlectures/9-MainframeComputers.ppt</a>
</li>

<li>36-bit<br />
<a href="http://en.wikipedia.org/wiki/36-bit_word_length">http://en.wikipedia.org/wiki/36-bit_word_length</a>
</li>

<li>36bit.org<br />
<a href="http://www.36bit.org/">http://www.36bit.org/</a>
</li>

<li>Applesoft BASIC<br />
<a href="https://en.wikipedia.org/wiki/Applesoft_BASIC">https://en.wikipedia.org/wiki/Applesoft_BASIC</a>
</li>

<li>How did the Apple II do floating point?<br />
<a href="https://groups.google.com/forum/#!topic/comp.emulators.apple2/qSBiG2TAlRg">https://groups.google.com/forum/#!topic/comp.emulators.apple2/qSBiG2TAlRg</a>
</li>

<li>IBM Floating Point Architecture<br />
<a href="https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture">https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture</a>
</li>

<li>The Arithmetic Subroutines<br />
<a href="http://www.users.waitrose.com/~thunor/mmcoyzx81/chapter17.html">http://www.users.waitrose.com/~thunor/mmcoyzx81/chapter17.html</a>
</li>

<li>ZX Floating point to Decimal code in BASIC<br />
<a href="http://www.sinclairzxworld.com/viewtopic.php?t=1422">http://www.sinclairzxworld.com/viewtopic.php?t=1422</a>
</li>

<li>Floating Point Arithmetic Package<br />
<a href="http://www.retrocomputing.net/parts/atari/800/docs/atari_os/atari_os_user_manual_08.htm">http://www.retrocomputing.net/parts/atari/800/docs/atari_os/atari_os_user_manual_08.htm</a>
</li>

<li>704 Data Processing System<br />
<a href="https://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">https://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>Turbo Pascal Real<br />
<a href="http://www.shikadi.net/moddingwiki/Turbo_Pascal_Real">http://www.shikadi.net/moddingwiki/Turbo_Pascal_Real</a>
</li>

<li>THE FLOATING POINT ARITHMETIC PACKAGE<br />
<a href="http://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?14">http://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?14</a>
</li>

<li>Sinclair ZX81 BASIC Programming (by Steven Vickers)<br />
<a href="http://www.worldofspectrum.org/ZX81BasicProgramming/">http://www.worldofspectrum.org/ZX81BasicProgramming/</a>
</li>

<li>The Most Expensive One-byte Mistake: Did Ken, Dennis, and Brian choose wrong with NUL-terminated text strings?<br />
<a href="http://queue.acm.org/detail.cfm?id=2010365">http://queue.acm.org/detail.cfm?id=2010365</a>
</li>

<li>UCSD Pascal<br />
<a href="https://en.wikipedia.org/wiki/UCSD_Pascal">https://en.wikipedia.org/wiki/UCSD_Pascal</a>
</li>

<li>D Language: Strings<br />
<a href="https://dlang.org/spec/arrays.html#strings">https://dlang.org/spec/arrays.html#strings</a>
</li>

<li>The History Behind the Definition of a 'String'<br />
<a href="https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string">https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string</a>
</li>

<li>Libc: Representation of Strings<br />
<a href="https://www.gnu.org/software/libc/manual/html_node/Representation-of-Strings.html">https://www.gnu.org/software/libc/manual/html_node/Representation-of-Strings.html</a>
</li>

<li>ATARI BASIC<br />
<a href="http://www.atariarchives.org/dere/chapt10.php">http://www.atariarchives.org/dere/chapt10.php</a>
</li>

<li>BASIC (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/BASIC">http://en.wikipedia.org/wiki/BASIC</a>
</li>

<li>BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/BASIC">http://cs.wikipedia.org/wiki/BASIC</a>
</li>

<li>Turbo BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Turbo_BASIC">http://cs.wikipedia.org/wiki/Turbo_BASIC</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>More BASIC Computer Games<br />
<a href="http://www.atariarchives.org/morebasicgames/">http://www.atariarchives.org/morebasicgames/</a>
</li>

<li>Dartmouth College Computation Center: 1964 &ndash; The original Dartmouth BASIC manual<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf</a>
</li>

<li>The Original BASIC<br />
<a href="http://www.truebasic.com/">http://www.truebasic.com/</a>
</li>

<li>BASIC - Beginners All-purpose Symbolic Instruction Code<br />
<a href="http://hopl.murdoch.edu.au/showlanguage.prx?exp=176">http://hopl.murdoch.edu.au/showlanguage.prx?exp=176</a>
</li>

<li>Universal Coded Character Set<br />
<a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set">https://en.wikipedia.org/wiki/Universal_Coded_Character_Set</a>
</li>

<li>UTF-16<br />
<a href="https://en.wikipedia.org/wiki/UTF-16">https://en.wikipedia.org/wiki/UTF-16</a>
</li>

<li>PEP 393 -- Flexible String Representation<br />
<a href="https://www.python.org/dev/peps/pep-0393/">https://www.python.org/dev/peps/pep-0393/</a>
</li>

<li>In-memory size of a Python structure<br />
<a href="https://stackoverflow.com/questions/1331471/in-memory-size-of-a-python-structure">https://stackoverflow.com/questions/1331471/in-memory-size-of-a-python-structure</a>
</li>

<li>What is internal representation of string in Python 3.x<br />
<a href="https://stackoverflow.com/questions/1838170/what-is-internal-representation-of-string-in-python-3-x#9079985">https://stackoverflow.com/questions/1838170/what-is-internal-representation-of-string-in-python-3-x#9079985</a>
</li>

<li>How to profile memory usage in Python<br />
<a href="https://www.pluralsight.com/blog/tutorials/how-to-profile-memory-usage-in-python">https://www.pluralsight.com/blog/tutorials/how-to-profile-memory-usage-in-python</a>
</li>

<li>What's the rationale for null terminated strings?<br />
<a href="https://stackoverflow.com/questions/4418708/whats-the-rationale-for-null-terminated-strings">https://stackoverflow.com/questions/4418708/whats-the-rationale-for-null-terminated-strings</a>
</li>

<li>Unicode<br />
<a href="https://en.wikipedia.org/wiki/Unicode">https://en.wikipedia.org/wiki/Unicode</a>
</li>

<li>The Development of the C Language<br />
<a href="https://www.bell-labs.com/usr/dmr/www/chist.html">https://www.bell-labs.com/usr/dmr/www/chist.html</a>
</li>

<li>Borland Pascal Wiki: String operations<br />
<a href="http://borlandpascal.wikia.com/wiki/String_operations">http://borlandpascal.wikia.com/wiki/String_operations</a>
</li>

<li>Pascal Strings<br />
<a href="https://www.tutorialspoint.com/pascal/pascal_strings.htm">https://www.tutorialspoint.com/pascal/pascal_strings.htm</a>
</li>

<li>PChar - Null terminated strings<br />
<a href="https://www.freepascal.org/docs-html/ref/refsu12.html">https://www.freepascal.org/docs-html/ref/refsu12.html</a>
</li>

<li>Comparison of Pascal and C<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C">https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C</a>
</li>

<li>FORTRAN 66<br />
<a href="http://fortranwiki.org/fortran/show/FORTRAN+66">http://fortranwiki.org/fortran/show/FORTRAN+66</a>
</li>

<li>Fortran: strings<br />
<a href="https://en.wikibooks.org/wiki/Fortran/strings">https://en.wikibooks.org/wiki/Fortran/strings</a>
</li>

<li>Strings in Atari BASIC<br />
<a href="http://www.cyberroach.com/analog/an11/strings.htm">http://www.cyberroach.com/analog/an11/strings.htm</a>
</li>

<li>String Arrays in Atari BASIC<br />
<a href="http://www.atarimagazines.com/compute/issue11/52_1_STRING_ARRAYS_IN_ATARI_BASIC.php">http://www.atarimagazines.com/compute/issue11/52_1_STRING_ARRAYS_IN_ATARI_BASIC.php</a>
</li>

<li>An Atari BASIC Tutorial<br />
<a href="http://www.cyberroach.com/analog/an25/basictutorial.htm">http://www.cyberroach.com/analog/an25/basictutorial.htm</a>
</li>

<li>Basic Multilingual Plane<br />
<a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

