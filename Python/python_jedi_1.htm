<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití knihovny Jedi pro automatické doplňování kódu a statickou analýzu zdrojových kódů Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití knihovny Jedi pro automatické doplňování kódu a statickou analýzu zdrojových kódů Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;knihovnou Jedi určenou pro implementaci automatického doplňování kódu (kterou známe z&nbsp;mnoha IDE) i pro statickou analýzu zdrojových kódů psaných v&nbsp;Pythonu. Popíšeme si i plugin jedi-vim integrující Jedi do Vimu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití knihovny Jedi pro automatické doplňování kódu a statickou analýzu zdrojových kódů Pythonu</a></p>
<p><a href="#k02">2. Instalace knihovny Jedi a otestování korektnosti instalace</a></p>
<p><a href="#k03">3. Využití možností nabízených knihovnou Jedi v&nbsp;interpretru Pythonu (REPL)</a></p>
<p><a href="#k04">4. Základní funkce Jedi &ndash; automatické doplňování</a></p>
<p><a href="#k05">5. Atributy objektů představujících návrhy na doplnění zdrojového textu</a></p>
<p><a href="#k06">6. Dokumentační řetězce u návrhů doplnění zdrojového textu</a></p>
<p><a href="#k07">7. Podpora pro skoky na deklarace funkcí, tříd nebo metod</a></p>
<p><a href="#k08">8. Použití metody <strong>Script.goto_definitions()</strong></a></p>
<p><a href="#k09">9. Získání podrobnějších informací o deklarované funkci, třídě nebo metodě</a></p>
<p><a href="#k10">10. Problematika redefinice funkcí v&nbsp;Pythonu</a></p>
<p><a href="#k11">11. Dynamické chování Pythonu a jeho vliv na zjišťování informací o volaných funkcích</a></p>
<p><a href="#k12">12. Složitější příklad ukazující dynamické chování Pythonu</a></p>
<p><a href="#k13">13. Detekce míst ve zdrojovém kódu, v&nbsp;němž je nějaká funkce použita</a></p>
<p><a href="#k14">14. Složitější příklad s&nbsp;redeklarací funkcí</a></p>
<p><a href="#k15">15. Využití knihovny Jedi v&nbsp;pluginu <strong>jedi-vim</strong></a></p>
<p><a href="#k16">16. Možnosti nabízené pluginem <strong>jedi-vim</strong></a></p>
<p><a href="#k17">17. Obsah druhé části článku</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití knihovny Jedi pro automatické doplňování kódu a statickou analýzu zdrojových kódů Pythonu</h2>

<p>Jedním z&nbsp;velmi užitečných nástrojů určených především pro vývojáře
používající <a href="https://www.root.cz/n/python/">programovací jazyk
Python</a> je knihovna nazvaná <i>Jedi</i>. Tato knihovna slouží ke statické
analýze zdrojových kódů napsaných právě v&nbsp;Pythonu (buď verze 2.7,
popř.&nbsp;verzí 3.4, 3.5 atd.), přičemž výsledky provedené statické analýzy je
možné využít pro implementaci mnoha užitečných operací, které známe
z&nbsp;většiny moderních integrovaných vývojových prostředí (IDE). Zejména se
jedná o operaci automatického doplňování kódu (<a
href="https://en.wikipedia.org/wiki/Autocomplete"><i>autocompletion</i></a>),
například jména funkce, metody, názvu proměnné nebo parametru funkce. Ovšem
knihovna <i>Jedi</i> podporuje i některé další zajímavé operace, například
dokáže zjistit místo ve zdrojovém kódu, v&nbsp;němž je funkce/metoda/proměnná
definována, místa v&nbsp;kódu, kde všude je daný objekt použit, nepřímo dokáže
detekovat parametry funkcí a metod apod.</p>

<img src="https://i.iinfo.cz/images/179/jedi1-1.png" class="image-337022" alt="&#160;" width="200" height="226" />
<p><i>Obrázek 1: Logo knihovny Jedi.</i></p>

<p>Vzhledem k&nbsp;potenciální užitečnosti knihovny <i>Jedi</i> nebude příliš
velkým překvapením zjištění, že tuto knihovnu nalezneme jako součást pluginů
určených pro programátorské textové editory. To se týká zejména <a
href="https://www.root.cz/serialy/textovy-editor-vim-jako-ide/">Vimu</a>, pro
který existují pluginy <a href="#17">jedi-vim</a>, <i>YouCompleteMe</i> apod.
postavené právě na Jedi (první z&nbsp;nich si ostatně dnes popíšeme
v&nbsp;závěrečné části článku). Dále nesmíme zapomenout na textový editor
<i>Emacs</i> s&nbsp;pluginy <i>Jedi.el</i>, <i>elpy (Emacs Python Development
Environment)</i>, populární <i>Atom</i> s&nbsp;pluginem pojmenovaným
<i>autocomplete-python-jedi</i>, prostředí <i>Visual Studio Code</i>
s&nbsp;<i>Python Extension</i>, <i>Eric IDE</i> apod. Knihovna <i>Jedi</i> je
taktéž použita v&nbsp;populárním <i>IPythonu</i>, blíže viz <a
href="https://ipython.readthedocs.io/en/stable/whatsnew/version6.html#new-completion-api-and-interface">New
completion API and Interface</a> a dokonce můžeme její možnost automatického
doplňování kódu <a href="#k03">použít i v&nbsp;běžném interpretu
Pythonu, což si popíšeme ve třetí kapitole</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace knihovny Jedi a otestování korektnosti instalace</h2>

<p>V&nbsp;první polovině článku si na několika demonstračních příkladech
ukážeme veřejné API knihovny <i>Jedi</i>. Ještě předtím je však samozřejmě
nutné provést instalaci této knihovny, což ve skutečnosti není nic těžkého,
protože můžeme (podobně jako u většiny knihoven a nástrojů popisovaných
v&nbsp;předchozích <a href="https://www.root.cz/n/python/">článcích věnovaných
Pythonu</a>) použít nástroj <strong>pip2</strong> nebo <strong>pip3</strong>
(<i>Python Package Installer</i>). Instalaci provedeme s&nbsp;využitím
parametru <strong>--user</strong> lokálně pro přihlášeného uživatele, takže
nainstalovanou knihovnu nalezneme v&nbsp;adresáři
<strong>~/.local/lib/pythonX.Y/</strong> (kde X.Y je verze Pythonu 2 či Pythonu
3).</p>

<p>Příkaz pro instalaci Jedi ve variantě pro Python 3 a vlastní průběh
instalace bude vypadat následovně:</p>

<pre>
$ <strong>pip3 install --user jedi</strong>
&nbsp;
Collecting jedi
  Downloading https://files.pythonhosted.org/packages/3d/68/8bbf0ef969095a13ba0d4c77c1945bd86e9811960d052510551d29a2f23b/jedi-0.12.1-py2.py3-none-any.whl (174kB)
    100% |████████████████████████████████| 184kB 1.6MB/s
Collecting parso&gt;=0.3.0 (from jedi)
  Downloading https://files.pythonhosted.org/packages/09/51/9c48a46334be50c13d25a3afe55fa05c445699304c5ad32619de953a2305/parso-0.3.1-py2.py3-none-any.whl (88kB)
    100% |████████████████████████████████| 92kB 2.2MB/s
Installing collected packages: parso, jedi
Successfully installed jedi-0.12.1 parso-0.3.1
</pre>

<p>Korektnost instalace si můžeme velmi snadno ověřit. Nejprve spustíme
interpret Pythonu. Pokud jste pro instalaci použili příkaz
<strong>pip2</strong>, spustíte samozřejmě interpret Pythonu 2.x,
v&nbsp;případě použití příkazu <strong>pip3</strong> pak interpret Pythonu
3.x:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.6.3 (default, Oct  9 2017, 12:11:29) 
[GCC 7.2.1 20170915 (Red Hat 7.2.1-2)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>

<p>Následně se po zobrazení výzvy (<i>prompt</i>) pokusíme naimportovat hlavní
modul knihovny <i>Jedi</i>:</p>

<pre>
&gt;&gt;&gt; <strong>import jedi</strong>
</pre>

<p>V&nbsp;případě, že předchozí příkaz skončil bez chyby, můžeme se například
pokusit vypsat si nápovědu (dokumentační řetězec) k&nbsp;této knihovně:</p>

<pre>
&gt;&gt;&gt; <strong>help("jedi")</strong>
&nbsp;
Help on package jedi:
&nbsp;
NAME
    jedi
&nbsp;
DESCRIPTION
    Jedi is a static analysis tool for Python that can be used in IDEs/editors. Its
    historic focus is autocompletion, but does static analysis for now as well.
    Jedi is fast and is very well tested. It understands Python on a deeper level
    than all other static analysis frameworks for Python.
&nbsp;
    Jedi has support for two different goto functions. It's possible to search for
    related names and to list all names in a Python file and infer them. Jedi
    understands docstrings and you can use Jedi autocompletion in your REPL as
    well.
&nbsp;
    Jedi uses a very simple API to connect with IDE's. There's a reference
    implementation as a `VIM-Plugin &lt;https://github.com/davidhalter/jedi-vim&gt;`_,
    which uses Jedi's autocompletion.  We encourage you to use Jedi in your IDEs.
    It's really easy.
</pre>

<p>Pokud nastane situace, že knihovna nebyla nainstalována, nebo došlo při
instalaci k&nbsp;nějakým dalším problémům (špatně zadané cesty atd.), vypíše se
po pokusu o import tato chyba:</p>

<pre>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ImportError: No module named 'jedi'
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Využití možností nabízených knihovnou Jedi v&nbsp;interpretru Pythonu (REPL)</h2>

<p>Již <a href="#k01">v&nbsp;úvodní kapitole</a> jsme si řekli, že knihovnu
<i>Jedi</i>, přesněji řečeno její část umožňující automatické doplňování kódu
(jména metod a funkcí), je možné použít i ve standardním interpretru Pythonu.
Ukažme si nyní, jak lze tuto užitečnou vlastnost do interpretru vlastně přidat.
Nejdříve je nutné nastavit proměnnou prostředí nazvanou
<strong>PYTHONSTARTUP</strong>, do které je možné zapsat jméno souboru
s&nbsp;inicializačním skriptem (blíže viz <a
href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONSTARTUP">oficiální
dokumentace k&nbsp;Pythonu</a>). Nastavení by pro knihovnu Jedi mělo vypadat
následovně:</p>

<pre>
$ <strong>export PYTHONSTARTUP="$(python3 -m jedi repl)"</strong>
</pre>

<p>Dále již můžeme běžným způsobem spustit interpret Pythonu. Povšimněte si
ovšem posledního řádku zobrazeného před výzvou (<i>prompt</i>). Tento řádek nám
oznamuje, že se knihovna Jedi inicializovala a bude použita při zadávání
příkazů:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.6.3 (default, Oct  9 2017, 12:11:29) 
[GCC 7.2.1 20170915 (Red Hat 7.2.1-2)] on linux
Type "help", "copyright", "credits" or "license" for more information.
REPL completion using Jedi 0.12.1
&gt;&gt;&gt;
</pre>

<p>Pokusme se nyní využít automatické doplňování kódu nabízené touto knihovnou.
Nejdříve (čistě jen pro příklad) naimportujeme standardní knihovnu
<strong>time</strong>:</p>

<pre>
&gt;&gt;&gt; <strong>import time</strong>
</pre>

<p>Následně zadáme část příkazu <strong>time.asctime().is</strong> a namísto
doplnění celého jména funkce stlačíme klávesu <strong>[Tab]</strong>.
V&nbsp;tomto okamžiku je knihovně Jedi předán zapsaný skript (více viz
navazující kapitoly) a knihovna Jedi vrátí seznam metod objektu typu
<strong>str</strong>, které začínají na prefix &bdquo;is&ldquo;:</p>

<pre>
&gt;&gt;&gt; <strong>time.asctime().is</strong>
...alnum       ...digit       ...numeric     ...title       
...alpha       ...identifier  ...printable   ...upper       
...decimal     ...lower       ...space       
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se skutečně nabízí
pouze názvy metod, které mají v&nbsp;daném kontextu význam. Například se
nenabízí standardní funkce <strong>isinstance</strong> nebo
<strong>issubclass</strong>, protože ty nedávají pro návratovou hodnotu funkce
<strong>time.asctime()</strong> žádný rozumný význam.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Základní funkce Jedi &ndash; automatické doplňování</h2>

<p>Nyní si popíšeme základní koncepty, na nichž je postaveno veřejné API
knihovny <i>Jedi</i>. Ukažme si nejprve, jakým způsobem je možné funkci pro
automatické doplňování kódu (jmen funkcí atd.) ukázanou prakticky <a
href="#k03">v&nbsp;předchozí kapitole</a> využít programově,
tj.&nbsp;v&nbsp;běžném skriptu naprogramovaném přímo v&nbsp;Pythonu. Přitom si
vysvětlíme základní třídu <strong>Script</strong>, na níž je postavena základní
část API knihovny <i>Jedi</i>.</p>

<p>Nejprve provede import knihovny:</p>

<pre>
import jedi
</pre>

<p>Následně deklarujeme řetězec <strong>src</strong> reprezentující zdrojový
kód, nad nímž budeme automatické doplňování spouštět. Pro jednoduchost bude
tento kód reprezentován přímo v&nbsp;těle příkladu formou víceřádkového
řetězce, tedy následovně (v&nbsp;praxi by tento řetězec posílal přímo textový
editor nebo IDE):</p>

<pre>
src = '''
anybody=True
answer="42"
an'''
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že první řádek je prázdný
(za trojicí otevíracích apostrofů ''' následuje konec řádku) a taktéž toho, že
poslední řádek vlastně neobsahuje platný příkaz Pythonu. To knihovně
<i>Jedi</i> v&nbsp;žádném případě nevadí, ostatně i všechna běžná IDE se musí
vypořádat s&nbsp;tím, že v&nbsp;průběhu editace nepracují s&nbsp;validním
kódem.</div></p>

<p>Následuje nejdůležitější část celého skriptu &ndash; předání zdrojového kódu
knihovně <i>Jedi</i> a určení, na kterém místě se nachází pomyslný kurzor,
protože právě toto místo bude knihovna <i>Jedi</i> při analýze považovat za
klíčové pro funkci automatického doplňování. Pozice kurzoru je vyjádřena dvěma
celými čísly &ndash; číslem řádku a číslem sloupce, přičemž čísla řádků
začínají od jedničky (tak je tomu ostatně i v&nbsp;textových editorech). Číslo
sloupce nemusíme složitě počítat, ale použijeme funkci
<strong>len()</strong>:</p>

<pre>
     1  
     2  anybody=True
     3  answer="42"
     4  an<strong>[pozice kurzoru vypočtená funkcí len()]</strong>
</pre>

<p>Posledním parametrem předávaným konstruktoru třídy <strong>Script</strong>
je jméno modulu, ale to můžeme ponechat prázdné (prozatím ho nevyužijeme):</p>

<p>Zavolání konstruktoru třídy <strong>Script()</strong> tedy bude vypadat
následovně:</p>

<pre>
script = jedi.Script(src, 4, len('an'), '')
</pre>

<p>Metoda pro zjištění všech možností, které nám prefix &bdquo;an&ldquo;
nabízí, se zavolá následujícím způsobem:</p>

<pre>
print(script.completions())
</pre>

<p>Metoda <strong>Script.completions()</strong> by měla vrátit seznam
obsahující tři objekty typu <strong>Completion</strong>. Tyto objekty
představují texty &bdquo;answer&ldquo;, &bdquo;any&ldquo; a
&bdquo;anybody&ldquo;, tj.&nbsp;všechny možné identifikátory, které mají
v&nbsp;kontextu zdrojového kódu smysl (&bdquo;answer&ldquo; a
&bdquo;anybody&ldquo; je deklarován přímo v&nbsp;analyzovaném zdrojovém kódu,
&bdquo;any&ldquo; je naproti tomu standardní vestavěná funkce Pythonu):</p>

<pre>
[&lt;Completion: answer&gt;, &lt;Completion: any&gt;, &lt;Completion: anybody&gt;]
</pre>

<p><a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi01_simple_completions.py">Následuje
výpis úplného zdrojového kódu dnešního prvního demonstračního příkladu</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
anybody=True
answer="42"
an'''
&nbsp;
script = jedi.Script(src, 4, len('an'), '')
print(script.completions())
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Atributy objektů představujících návrhy na doplnění zdrojového textu</h2>

<p><a href="#k04">V&nbsp;předchozí kapitole</a> jsme si řekli, že metoda
<strong>Script.completions()</strong> nevrací pouze seznam textů (řetězců),
které v&nbsp;daném místě kódu dávají smysl pro doplnění. To by sice mohlo
dostačovat, ale pouze pro ty nejjednodušší IDE. V&nbsp;moderních IDE se
většinou očekává, že technologie pro automatické doplňování kódu zobrazí i
další relevantní údaje, například kde je definován identifikátor, který je
nabízen pro automatické doplnění atd. A právě tyto údaje je možné získat
z&nbsp;objektů typu <strong>Completion</strong>, které jsou metodou
<strong>Script.completions()</strong> vráceny.</p>

<p>Tyto objekty obsahují atribut nazvaný <strong>complete</strong>, který
obsahuje pouze text, který se má doplnit za již zapsaný text. V&nbsp;našem
ukázkovém skriptu se po zadání prefixu &bdquo;an&ldquo; vrátí tři objekty
s&nbsp;těmito atributy <strong>complete</strong>:</p>

<pre>
swer
y
ybody
</pre>

<p>Naproti tomu atribut <strong>name</strong> obsahuje plné jméno pro doplnění,
tedy včetně zapsaného prefixu:</p>

<pre>
answer
any
anybody
</pre>

<p>Díky existenci těchto dvou atributů je implementace technologie pro
automatické doplňování do IDE či textových editorů jednodušší.</p>

<p>Opět se podívejme na <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi02_completions_attributes.py">demonstrační
příklad</a>, který vypíše obsah obou výše popsaných atributů pro všechny
získané objekty typu <strong>Completion</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
anybody=True
answer="42"
an'''
&nbsp;
script = jedi.Script(src, 4, len('an'), '')
&nbsp;
completions = script.completions()
&nbsp;
for completion in completions:
    print(completion.complete)

print()
&nbsp;
for completion in completions:
    print(completion.name)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Dokumentační řetězce u návrhů doplnění zdrojového textu</h2>

<p>Další informací obsaženou v&nbsp;objektech typu <strong>Completion</strong>
je dokumentační řetězec, který je ovšem pochopitelně vyplněn pouze ve chvíli,
kdy je v&nbsp;analyzovaných zdrojových kódech nalezen. Dokumentační řetězec lze
získat zavoláním metody <strong>docstring()</strong> (nikoli atributu
<strong>docstring</strong>), což je ukázáno v&nbsp;dnešním <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi03_completions_docstrings.py">třetím
demonstračním příkladu</a>, v&nbsp;němž se bude funkce pro automatické doplnění
kódu spouštět nad skriptem obsahujícím i funkci s&nbsp;dokumentačním
řetězcem:</p>

<pre>
     1	
     2	def anagrams(word):
     3	    """Very primitive anagram generator."""
     4	    if len(word) &lt; 2:
     5	        return word
     6	    else:
     7	        tmp = []
     8	        for i, letter in enumerate(word):
     9	            for j in anagrams(word[:i]+word[i+1:]):
    10	                tmp.append(j+letter)
    11	    return tmp
    12	
    13	anybody=True
    14	answer="42"
    15	an<strong>[pozice kurzoru pro automatické doplňování]</strong>
</pre>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def anagrams(word):
    """Very primitive anagram generator."""
    if len(word) &lt; 2:
        return word
    else:
        tmp = []
        for i, letter in enumerate(word):
            for j in anagrams(word[:i]+word[i+1:]):
                tmp.append(j+letter)
    return tmp
&nbsp;
anybody=True
answer="42"
an'''
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('an'), '')
&nbsp;
completions = script.completions()
&nbsp;
for completion in completions:
    print(completion.name)
    print("-"*40)
    print(completion.docstring())
    print("\n"*3)
</pre>

<p>Výsledek bude vypadat následovně. Povšimněte si, že dokumentační řetězec
není vypsán u proměnných, u nichž není definován:</p>

<pre>
anagrams
----------------------------------------
anagrams(word)
&nbsp;
Very primitive anagram generator.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
answer
----------------------------------------
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
any
----------------------------------------
Return True if bool(x) is True for any x in the iterable.
&nbsp;
If the iterable is empty, return False.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
anybody
----------------------------------------
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Podpora pro skoky na deklarace funkcí, tříd nebo metod</h2>

<p>V&nbsp;knihovně <i>Jedi</i> nalezneme i další užitečnou funkcionalitu. Jedná
se zejména o zjištění podrobnějších informací o volané funkci nebo metodě.
Jméno funkce/metody je opět získáno na místě, kde se nachází pomyslný kurzor
definovaný číslem řádku a sloupce. Pro tento účel se používá metoda
<strong>Script.goto_definitions()</strong>, která vrací seznam objektů typu
<strong>Definition</strong> (skutečně se opět jedná o seznam, důvod bude
vysvětlen v&nbsp;navazujících kapitolách). Samotná třída
<strong>Definition</strong> je popsaná na stránce <a
href="https://jedi.readthedocs.io/en/latest/docs/api-classes.html#jedi.api.classes.Definition">https://jedi.readthedocs.io/en/latest/docs/api-classes.html#jedi.api.classes.Definition</a>;
její použití si ukážeme na několika demonstračních příkladech zmíněných
níže.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití metody <strong>Script.goto_definitions()</strong></h2>

<p>V&nbsp;dalším demonstračním příkladu si ukážeme použití metody
<strong>Script.goto_definitions()</strong> pro získání podrobnějších informací
o funkcích <strong>x</strong> a <strong>y</strong> volaných na řádcích 5 a 6
(v&nbsp;obou případech se jedná o sloupec 7, kde začíná volání funkce):</p>

<pre>
     1	
     2	def x():
     3	    return 42
     4	
     5	print(x())
     6	print(y())
</pre>

<p>Informace o těchto funkcích lze přečíst následujícím způsobem (povšimněte si
použití jména skriptu &bdquo;example.py&ldquo;, které může být vymyšleno a
typicky ho knihovně <i>Jedi</i> dodá textový editor):</p>

<pre>
</pre>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def x():
    return 42

print(x())
print(y())
'''
&nbsp;
script = jedi.Script(src, 5, 7, 'example.py')
&nbsp;
goto_definitions = script.goto_definitions()
print(goto_definitions)
&nbsp;
print("-"*40)
&nbsp;
script = jedi.Script(src, 6, 7, 'example.py')
&nbsp;
goto_definitions = script.goto_definitions()
print(goto_definitions)
</pre>

<p>Výsledkem bude v&nbsp;prvním případě jednoprvkový seznam obsahující (jediný)
objekt typu <strong>Definition</strong>. V&nbsp;případě druhém se vrátí prázdný
seznam, protože knihovna <i>Jedi</i> žádné informace o funkci
<strong>y</strong> nedokáže zjistit:</p>

<pre>
[&lt;Definition def x&gt;]
----------------------------------------
[]
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Získání podrobnějších informací o deklarované funkci, třídě nebo metodě</h2>

<p>Ukažme si ještě poněkud složitější příklad, v&nbsp;němž budeme zjišťovat
informace o volaných funkcích i anonymních funkcích v&nbsp;následujícím skriptu
(viz zvýrazněné pasáže):</p>

<pre>
     1	
     2	def x():
     3	    return 42
     4	
     5	def y():
     6	    return 42
     7	
     8	print(<strong>x()</strong>)
     9	print(<strong>y()</strong>)
    10	print(<strong>z()</strong>)
    11	
    12	w = lambda: 42
    13	
    14	print(<strong>w()</strong>)
</pre>

<p>Každý objekt typu <strong>Definition</strong> obsahuje několik atributů
s&nbsp;typem objektu (zda se jedná o funkci atd.), plným jménem objektu, jménem
modulu a taktéž řádkem, na němž byl objekt definován. O výpis se postará tato
pomocná funkce:</p>

<pre>
def print_definitions(source, line, column, module):
    print("-"*40)
&nbsp;
    script = jedi.Script(source, line, column, module)
&nbsp;
    goto_definitions = script.goto_definitions()
&nbsp;
    if not goto_definitions:
        print("not found")
        return
&nbsp;
    for definition in goto_definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
</pre>

<p>Zjištění a zobrazení informací pro výše zvýrazněné pasáže zajistí tyto čtyři
řádky:</p>

<pre>
script = print_definitions(src, 8, 7, 'example.py')
script = print_definitions(src, 9, 7, 'example.py')
script = print_definitions(src, 10, 7, 'example.py')
script = print_definitions(src, 14, 7, 'example.py')
</pre>

<p>S&nbsp;výsledky ukazujícími přesné místo deklarace příslušné funkce nebo
lambda funkce:</p>

<pre>
----------------------------------------
function __main__.x in example.py:2
----------------------------------------
function __main__.y in example.py:5
----------------------------------------
not found
----------------------------------------
function __main__.&lt;lambda&gt; in example.py:12
</pre>

<p><a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi05_goto_definitions_attributes.py">Úplný
zdrojový kód</a> tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def x():
    return 42
&nbsp;
def y():
    return 42
&nbsp;
print(x())  # line 8
print(y())  # line 9
print(z())  # line 10
&nbsp;
w = lambda: 42
&nbsp;
print(w())  # line 14
'''
&nbsp;
&nbsp;
def print_definitions(source, line, column, module):
    print("-"*40)
&nbsp;
    script = jedi.Script(source, line, column, module)
&nbsp;
    goto_definitions = script.goto_definitions()
&nbsp;
    if not goto_definitions:
        print("not found")
        return
&nbsp;
    for definition in goto_definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
script = print_definitions(src, 8, 7, 'example.py')
script = print_definitions(src, 9, 7, 'example.py')
script = print_definitions(src, 10, 7, 'example.py')
script = print_definitions(src, 14, 7, 'example.py')
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Problematika redefinice funkcí v&nbsp;Pythonu</h2>

<p>Co se stane ve chvíli, kdy se pokusíme funkci deklarovat vícekrát? To je
v&nbsp;Pythonu samozřejmě dovoleno:</p>

<pre>
     1	
     2	def x():
     3	    return 1
     4	
     5	def x():
     6	    return 2
     7	
     8	def x():
     9	    return 3
    10	
    11	print(<strong>x()</strong>)
</pre>

<p>Pro volání funkce <strong>x</strong> na jedenáctém řádku se nyní vypíše, že
se volá funkce deklarovaná na osmém řádku (což je v&nbsp;souladu
s&nbsp;chováním samotného Pythonu):</p>

<pre>
----------------------------------------
function __main__.x in example.py:8
</pre>

<p>Předchozí kód demonstračního příkladu byl nepatrně upraven a nyní vypadá
následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def x():
    return 1
&nbsp;
def x():
    return 2
&nbsp;
def x():
    return 3
&nbsp;
print(x())
'''
&nbsp;
&nbsp;
def print_definitions(source, line, column, module):
    print("-"*40)
&nbsp;
    script = jedi.Script(source, line, column, module)
&nbsp;
    goto_definitions = script.goto_definitions()
&nbsp;
    if not goto_definitions:
        print("not found")
        return
&nbsp;
    for definition in goto_definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
script = print_definitions(src, 11, 7, 'example.py')
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Dynamické chování Pythonu a jeho vliv na zjišťování informací o volaných funkcích</h2>

<p>Víme již, že návratovou hodnotou metody
<strong>Script.goto_definitions()</strong> je seznam objektů typu
<strong>Definition</strong>. Proč tomu tak je si ukážeme na dalším testovacím
skriptu:</p>

<pre>
     1	
     2	if random.random() &lt; 0.5:
     3	    def x():
     4	        return 1
     5	else:
     6	    def x():
     7	        return 2
     8	
     9	print(<strong>x()</strong>)
</pre>

<p>Při získání informací o funkci volané na devátém řádku získáme seznam se
dvěma objekty <strong>Definition</strong>, protože knihovna Jedi nemůže ze
statické analýzy kódu zjistit, která funkce se skutečně zavolá
(resp.&nbsp;přesněji řečeno, která funkce je vůbec deklarována):</p>

<pre>
----------------------------------------
function __main__.x in example.py:3
function __main__.x in example.py:6
</pre>

<p>Opět si pro úplnost ukažme <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi07_dynamic_behaviour_A.py">zdrojový
kód tohoto příkladu</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
if random.random() &lt; 0.5:
    def x():
        return 1
else:
    def x():
        return 2
&nbsp;
print(x())
'''
&nbsp;
&nbsp;
def print_definitions(source, line, column, module):
    print("-"*40)
&nbsp;
    script = jedi.Script(source, line, column, module)
&nbsp;
    goto_definitions = script.goto_definitions()
&nbsp;
    if not goto_definitions:
        print("not found")
        return
&nbsp;
    for definition in goto_definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
script = print_definitions(src, 9, 7, 'example.py')
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Složitější příklad ukazující dynamické chování Pythonu</h2>

<p>Předchozí příklad je možné upravit do ještě složitější podoby, tentokrát
dokonce s&nbsp;lambda funkcí:</p>

<pre>
     1  
     2  def x():
     3      return 1
     4  
     5  def y():
     6      return 2
     7  
     8  z = lambda: 3
     9  
    10  if random.random() &lt; 0.3:
    11      f = x
    12  else:
    13      if random.random() &lt; 0.3:
    14          f = y
    15      else:
    16          f = z
    17  
    18  print(<strong>f()</strong>)
</pre>

<p>Pokud se pokusíme získat informaci o deklaraci funkce <strong>x</strong>
volané na osmnáctém řádku, dostaneme tři objekty typu
<strong>Definition</strong>; u posledního objektu dokonce s&nbsp;korektní
informací o tom, že se jedná o lambda funkci:</p>

<pre>
----------------------------------------
function __main__.x in example.py:2
function __main__.y in example.py:5
function __main__.&lt;lambda&gt;; in example.py:8
</pre>

<p>Opět si pro úplnost ukažme <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi08_dynamic_behaviour_B.py">zdrojový
kód tohoto příkladu</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def x():
    return 1
&nbsp;
def y():
    return 2
&nbsp;
z = lambda: 3
&nbsp;
if random.random() &lt; 0.3:
    f = x
else:
    if random.random() &lt; 0.3:
        f = y
    else:
        f = z
&nbsp;
print(f())
'''
&nbsp;
&nbsp;
def print_definitions(source, line, column, module):
    print("-"*40)
&nbsp;
    script = jedi.Script(source, line, column, module)
&nbsp;
    goto_definitions = script.goto_definitions()
&nbsp;
    if not goto_definitions:
        print("not found")
        return
&nbsp;
    for definition in goto_definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))

&nbsp;
lines = src.count('\n')
script = print_definitions(src, lines, 7, 'example.py')
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Detekce míst ve zdrojovém kódu, v&nbsp;němž je nějaká funkce použita</h2>

<p>V&nbsp;dalším příkladu si ukážeme jeden ze způsobů, jakým je možné získat
seznam míst v&nbsp;analyzovaném zdrojovém kódu, v&nbsp;němž je nějaká funkce
použita (tedy volána) nebo deklarována. Testovací skript, který budeme
analyzovat, vypadá následovně:</p>

<pre>
     1  
     2  def x():
     3      return 1
     4  
     5  a = x()
     6  b = x() + x()
     7  
     8  print(x())
</pre>

<p>Povšimněte si, že na čtyřech místech voláme funkci <strong>x</strong>, která
je deklarována na řádku 2. Seznam deklarací a použití této funkce získáme
metodou <strong>Script.usages()</strong>, tedy přibližně následujícím
způsobem:</p>

<pre>
script = jedi.Script(source, line, column, module)
&nbsp;
usages = script.usages()
</pre>

<p>Záleží jen na nás, jaký výskyt funkce <strong>x</strong> zvolíme při volání
konstruktoru <strong>Script()</strong>. Může se jednat například o řádek 8,
sloupec 7, tj.&nbsp;o poslední volání funkce <strong>x</strong>:</p>

<pre>
     1  
     2  def x():
     3      return 1
     4  
     5  a = x()
     6  b = x() + x()
     7  
     8  print(<strong>x()</strong>)
</pre>

<p>Výsledek:</p>

<pre>
function __main__.x in example.py:2
statement __main__.x in example.py:5
statement __main__.x in example.py:6
statement __main__.x in example.py:6
statement __main__.x in example.py:8
</pre>

<p>Ovšem naprosto stejnou informaci získáme ve chvíli, kdy budeme analyzovat
řádek 2, sloupec 5, tj.&nbsp;deklaraci funkce:</p>

<pre>
     1  
     2  def <strong>x()</strong>:
     3      return 1
     4  
     5  a = x()
     6  b = x() + x()
     7  
     8  print(<strong>x()</strong>)
</pre>

<p>Výsledek je v&nbsp;tomto případě shodný s&nbsp;výsledkem předchozím:</p>

<pre>
function __main__.x in example.py:2
statement __main__.x in example.py:5
statement __main__.x in example.py:6
statement __main__.x in example.py:6
statement __main__.x in example.py:8
</pre>

<p>Celý <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi09_usages.py">zdrojový
kód</a>, který tyto výsledky vypisuje, vypadá následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def x():
    return 1
&nbsp;
a = x()
b = x() + x()
&nbsp;
print(x())
'''
&nbsp;
&nbsp;
def print_usages(source, line, column, module):
    script = jedi.Script(source, line, column, module)
&nbsp;
    usages = script.usages()
&nbsp;
    if not usages:
        print("not found")
        return
&nbsp;
    for usage in usages:
        print("{type} {name} in {module}.py:{line}".format(type=usage.type,
                                                           name=usage.full_name,
                                                           module=usage.module_name,
                                                           line=usage.line))
&nbsp;
&nbsp;
script = print_usages(src, 8, 7, 'example.py')
&nbsp;
print()
&nbsp;
script = print_usages(src, 2, 5, 'example.py')
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Složitější příklad s&nbsp;redeklarací funkcí</h2>

<p>Z&nbsp;předchozího příkladu by se mohlo zdát, že je úplně jedno, jaký výskyt
funkce ve zdrojovém kódu vybereme &ndash; vždy by se měl (zdánlivě) vrátit
stejný seznam použití a deklarací této funkce. Ve skutečnosti to však
pochopitelně není zcela pravdivé, protože díky dynamické povaze Pythonu je
možné funkci redeklarovat a zcela tak pozměnit její chování. Ostatně podívejme
se na následující skript, v&nbsp;němž je funkce <strong>x</strong> deklarována
dvakrát:</p>

<pre>
     1  
     2  def x():
     3      return 1
     4  
     5  print(x())
     6  
     7  a = x()
     8  b = x() + x()
     9  
    10  def x():
    11      return 2
    12  
    13  print(x())
</pre>

<p>Pokud se zeptáme na použití funkce na řádku 5, sloupci 7:</p>

<pre>
     1  
     2  def x():
     3      return 1
     4  
     5  print(<strong>x()</strong>)
     6  
     7  a = x()
     8  b = x() + x()
     9  
    10  def x():
    11      return 2
    12  
    13  print(x())
</pre>

<p>Dostaneme výsledek odpovídající zhruba prvním dvou třetinám skriptu (až do
druhé deklarace funkce <strong>x</strong>):</p>

<pre>
function __main__.x in example.py:2
statement __main__.x in example.py:5
statement __main__.x in example.py:7
statement __main__.x in example.py:8
statement __main__.x in example.py:8
</pre>

<p>Naproti tomu při analýze řádku 13, sloupce 7:</p>

<pre>
     1  
     2  def x():
     3      return 1
     4  
     5  print(x())
     6  
     7  a = x()
     8  b = x() + x()
     9  
    10  def x():
    11      return 2
    12  
    13  print(<strong>x()</strong>)
</pre>

<p>Bude výsledek zcela odlišný a bude plně odpovídat chování Pythonu:</p>

<pre>
function __main__.x in example.py:10
statement __main__.x in example.py:13
</pre>

<p>Tato užitečná vlastnost knihovny <i>Jedi</i> je ukázána v&nbsp;dnešním
posledním příkladu, jehož <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi10_usages_and_redeclarations.py">úplný
zdrojový kód</a> je následující:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def x():
    return 1
&nbsp;
print(x())
&nbsp;
a = x()
b = x() + x()
&nbsp;
def x():
    return 2
&nbsp;
print(x())
'''
&nbsp;
&nbsp;
def print_usages(source, line, column, module):
    script = jedi.Script(source, line, column, module)
&nbsp;
    usages = script.usages()
&nbsp;
    if not usages:
        print("not found")
        return
&nbsp;
    for usage in usages:
        print("{type} {name} in {module}.py:{line}".format(type=usage.type,
                                                           name=usage.full_name,
                                                           module=usage.module_name,
                                                           line=usage.line))
&nbsp;
&nbsp;
script = print_usages(src, 5, 7, 'example.py')
&nbsp;
print()
&nbsp;
script = print_usages(src, 13, 7, 'example.py')
&nbsp;
print()
&nbsp;
script = print_usages(src, 2, 5, 'example.py')
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Využití knihovny Jedi v&nbsp;pluginu <strong>jedi-vim</strong></h2>

<p>Podívejme se nyní na jeden ze způsobů praktického využití knihovny
<i>Jedi</i>. Tato knihovna je totiž intenzivně používaná například přídavným
modulem (pluginem) nazvaným <i>jedi-vim</i>, který je pochopitelně určený, jak
již jeho název napovídá, pro <a
href="https://www.root.cz/serialy/textovy-editor-vim-jako-ide/">textový editor
Vim</a>. Díky propojení Vimu s&nbsp;knihovnou Jedi je možné přímo
z&nbsp;prostředí textového editoru používat prakticky všechny základní operace,
na které jsme zvyklí z&nbsp;&bdquo;plnohodnotných&ldquo; integrovaných
vývojových prostředí (IDE). Zejména se jedná o automatické doplňování jmen
funkcí, tříd, metod a proměnných, zobrazení dynamické nápovědy s&nbsp;parametry
funkce či metody (u Pythonu bez uvedení typu), skok na deklaraci funkce, třídy,
metody, zobrazení dokumentace k&nbsp;prakticky libovolnému objektu, nad nímž se
nachází kurzor a konečně o operaci přejmenování (samozřejmě v&nbsp;míře
použitelné pro tak dynamický jazyk, jakým Python bezesporu je &ndash; nečekejte
zde stoprocentní funkčnost v&nbsp;míře obvyklé například pro Javu).</p>

<a href="https://www.root.cz/obrazek/337023/"><img src="https://i.iinfo.cz/images/179/jedi1-2-prev.png" class="image-337023" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 2: Pro bezproblémovou funkčnost pluginu <strong>jedi-vim</strong>
je nutné, aby byl textový editor Vim přeložen s&nbsp;povolenou volbou
<strong>+conceal</strong>. Existenci této volby zjistíme například příkazem
<strong>:ver</strong> či <strong>:version</strong>.</i></p>

<a href="https://www.root.cz/obrazek/337024/"><img src="https://i.iinfo.cz/images/179/jedi1-3-prev.png" class="image-337024" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 3: Na tomto screenshotu je patrné, že volba
<strong>+conceal</strong> byla na mém systému skutečně při překladu Vimu
povolena.</i></p>

<p>Před popisem základních vlastností pluginu <i>jedi-vim</i> si samozřejmě
musíme tento plugin nainstalovat. Ve Fedoře (ale i v&nbsp;dalších Linuxových
distribucích) je to jednoduché, neboť <i>jedi-vim</i> je většinou dostupný ve
standardním repositáři distribuce a tím pádem i ve správci balíčků. Pro větší
zmatek se však tento balíček někdy nejmenuje <i>jedi-vim</i> ale naopak
<i>vim-jedi</i> :-) Instalaci tedy provedeme buď z&nbsp;účtu
superuživatele:</p>

<pre>
# <strong>dnf install vim-jedi</strong>
</pre>

<p>Nebo alternativně z&nbsp;účtu toho uživatele, který má příslušná práva
nastavená v&nbsp;sudoers:</p>

<pre>
$ <strong>sudo dnf install vim-jedi</strong>
</pre>

<p>Samotná instalace je provedena prakticky okamžitě:</p>

<pre>
Last metadata expiration check: 1:19:11 ago on Fri 17 Aug 2018 05:30:26 AM EDT.
Dependencies resolved.
================================================================================
 Package          Arch      Version           Repository                   Size
================================================================================
Installing:
 vim-jedi         noarch    0.8.0-4.fc28      Fedora-Everything            28 k
Installing dependencies:
 python2-jedi     noarch    0.12.0-1.fc28     updates                     291 k
 python2-parso    noarch    0.2.1-1.fc28      updates                     142 k
&nbsp;
Transaction Summary
================================================================================
Install  3 Packages
&nbsp;
Total download size: 461 k
Installed size: 1.9 M
Is this ok [y/N]: y
</pre>

<p>Vidíme, že se v&nbsp;případě potřeby doinstaluje i samotná knihovna
Jedi:</p>

<pre>
Downloading Packages:
(1/3): vim-jedi-0.8.0-4.fc28.noarch.rpm         508 kB/s |  28 kB     00:00    
(2/3): python2-parso-0.2.1-1.fc28.noarch.rpm    375 kB/s | 142 kB     00:00    
(3/3): python2-jedi-0.12.0-1.fc28.noarch.rpm    674 kB/s | 291 kB     00:00    
--------------------------------------------------------------------------------
Total                                           524 kB/s | 461 kB     00:00     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : python2-parso-0.2.1-1.fc28.noarch                      1/3 
  Installing       : python2-jedi-0.12.0-1.fc28.noarch                      2/3 
  Installing       : vim-jedi-0.8.0-4.fc28.noarch                           3/3 
  Running scriptlet: vim-jedi-0.8.0-4.fc28.noarch                           3/3 
  Verifying        : vim-jedi-0.8.0-4.fc28.noarch                           1/3 
  Verifying        : python2-jedi-0.12.0-1.fc28.noarch                      2/3 
  Verifying        : python2-parso-0.2.1-1.fc28.noarch                      3/3 
&nbsp;
Installed:
  vim-jedi.noarch 0.8.0-4.fc28           python2-jedi.noarch 0.12.0-1.fc28     
  python2-parso.noarch 0.2.1-1.fc28     
&nbsp;
Complete!
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Možnosti nabízené pluginem <strong>jedi-vim</strong></h2>

<p>Použití pluginu <i>jedi-vim</i> při editaci zdrojových kódů napsaných
v&nbsp;Pythonu si nejlépe ukážeme na několika screenshotech:</p>

<a href="https://www.root.cz/obrazek/337025/"><img src="https://i.iinfo.cz/images/179/jedi1-4-prev.png" class="image-337025" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 4: Po instalaci pluginu jedi-vim je k&nbsp;dispozici i nápověda
vyvolaná příkazem <strong>:help jedi-vim</strong>.</i></p>

<a href="https://www.root.cz/obrazek/337026/"><img src="https://i.iinfo.cz/images/179/jedi1-5-prev.png" class="image-337026" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 5: Základní funkcí pluginu jedi-vim je automatické doplňování
kódu vyvolané klávesovou zkratkou <strong>Ctrl+Space</strong> ve vkládacím
režimu.</i></p>

<a href="https://www.root.cz/obrazek/337027/"><img src="https://i.iinfo.cz/images/179/jedi1-6-prev.png" class="image-337027" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 6: Zobrazení dokumentačního řetězce v&nbsp;režimu automatického
doplňování.</i></p>

<a href="https://www.root.cz/obrazek/337028/"><img src="https://i.iinfo.cz/images/179/jedi1-7-prev.png" class="image-337028" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 7: Nastavení zvýraznění skupiny <strong>jedifat</strong>
v&nbsp;případě, že nápověda k&nbsp;parametrům funkcí není čitelná (což skutečně
není ve chvíli, kdy je použit terminálu se světlým pozadím). Bližší informace o
této vlastnosti Vimu lze najít v&nbsp;článku <a
href="https://www.root.cz/clanky/textovy-editor-vim-jako-ide-4-cast/#k07">Textový
editor Vim jako IDE (4.část) </a>.</i></p>

<a href="https://www.root.cz/obrazek/337029/"><img src="https://i.iinfo.cz/images/179/jedi1-8-prev.png" class="image-337029" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 8: Zobrazení parametrů funkce se zvýrazněním právě zadávaného
parametru.</i></p>

<a href="https://www.root.cz/obrazek/337030/"><img src="https://i.iinfo.cz/images/179/jedi1-9-prev.png" class="image-337030" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 9: Zobrazení parametrů funkce se zvýrazněním právě zadávaného
parametru.</i></p>

<a href="https://www.root.cz/obrazek/337031/"><img src="https://i.iinfo.cz/images/179/jedi1-10-prev.png" class="image-337031" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 10: Zobrazení parametrů funkce se zvýrazněním právě zadávaného
parametru.</i></p>

<a href="https://www.root.cz/obrazek/337032/"><img src="https://i.iinfo.cz/images/179/jedi1-11-prev.png" class="image-337032" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 11: Zobrazení dokumentačního řetězce pro identifikátor, nad nímž
se nachází kurzor. Tato funkce je dostupná po stisku klávesové zkratky
<strong>K</strong>.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah druhé části článku</h2>

<p>Ve druhé části tohoto článku popis možností nabízených knihovnou <i>Jedi</i>
dokončíme. Ukážeme si další funkcionalitu dostupnou při statické analýze a
taktéž si popíšeme možnosti nastavení a konfigurace virtuálního prostředí
Pythonu v&nbsp;jehož rámci je vlastně statická analýza prováděna.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady ukazující některé možnosti
knihovny <i>Jedi</i> byly uloženy do Git repositáře, který je dostupný na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již poměrně rozsáhlý) repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td> 1</td><td>jedi01_simple_completions.py</td><td>základní automatické doplnění kódu</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi01_simple_completions.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi01_simple_completions.py</a></td></tr>
<tr><td> 2</td><td>jedi02_completions_attributes.py</td><td>atributy objektů <strong>Completion</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi02_completions_attributes.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi02_completions_attributes.py</a></td></tr>
<tr><td> 3</td><td>jedi03_completions_docstrings.py</td><td>dokumentační řetězce v&nbsp;objektech <strong>Completion</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi03_completions_docstrings.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi03_completions_docstrings.py</a></td></tr>
<tr><td> 4</td><td>jedi04_goto_definitions.py</td><td>získání základních informací o volaných funkcích</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi04_goto_definitions.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi04_goto_definitions.py</a></td></tr>
<tr><td> 5</td><td>jedi05_goto_definitions_attributes.py</td><td>získání podrobnějších informací o volaných funkcích</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi05_goto_definitions_attributes.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi05_goto_definitions_attributes.py</a></td></tr>
<tr><td> 6</td><td>jedi06_function_redeclaration.py</td><td>chování při opětovné deklaraci funkce</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi06_function_redeclaration.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi06_function_redeclaration.py</a></td></tr>
<tr><td> 7</td><td>jedi07_dynamic_behaviour_A.py</td><td>dynamické chování Pythonu a vliv na knihovnu Jedi</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi07_dynamic_behaviour_A.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi07_dynamic_behaviour_A.py</a></td></tr>
<tr><td> 8</td><td>jedi08_dynamic_behaviour_B.py</td><td>dynamické chování Pythonu a vliv na knihovnu Jedi</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi08_dynamic_behaviour_B.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi08_dynamic_behaviour_B.py</a></td></tr>
<tr><td> 9</td><td>jedi09_usages.py</td><td>informace o místech použití funkcí nebo metod</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi09_usages.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi09_usages.py</a></td></tr>
<tr><td>10</td><td>jedi10_usages_and_redeclarations.py</td><td>informace o místech použití funkcí nebo metod</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi10_usages_and_redeclarations.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi10_usages_and_redeclarations.py</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>Jedi - an awesome autocompletion/static analysis library for Python<br />
<a href="https://jedi.readthedocs.io/en/latest/index.html">https://jedi.readthedocs.io/en/latest/index.html</a>
</li>

<li>Jedi API Overview<br />
<a href="https://jedi.readthedocs.io/en/latest/docs/api.html">https://jedi.readthedocs.io/en/latest/docs/api.html</a>
</li>

<li>jedi-vim<br />
<a href="https://github.com/davidhalter/jedi-vim">https://github.com/davidhalter/jedi-vim</a>
</li>

<li>YouCompleteMe: A code-completion engine for Vim<br />
<a href="https://valloric.github.io/YouCompleteMe/">https://valloric.github.io/YouCompleteMe/</a>
</li>

<li>Elpy: Emacs Python Development Environment<br />
<a href="https://github.com/jorgenschaefer/elpy">https://github.com/jorgenschaefer/elpy</a>
</li>

<li>Emacs-Jedi<br />
<a href="https://github.com/tkf/emacs-jedi">https://github.com/tkf/emacs-jedi</a>
</li>

<li>Python Autocomplete Jedi Package<br />
<a href="https://atom.io/packages/autocomplete-python-jedi">https://atom.io/packages/autocomplete-python-jedi</a>
</li>

<li>Autocomplete (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Autocomplete">https://en.wikipedia.org/wiki/Autocomplete</a>
</li>

<li>Seriál Textový editor Vim jako IDE (zde na Root.cz)<br />
<a href="https://www.root.cz/serialy/textovy-editor-vim-jako-ide/">https://www.root.cz/serialy/textovy-editor-vim-jako-ide/</a>
</li>

<li>Jedi.el - Python auto-completion for Emacs<br />
<a href="https://tkf.github.io/emacs-jedi/latest/">https://tkf.github.io/emacs-jedi/latest/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

