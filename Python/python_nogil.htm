<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Interpret Pythonu bez GILu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Interpret Pythonu bez GILu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Za jednu příčinu relativně nízké rychlosti aplikací psaných v Pythonu (a to i programů s více vlákny) se uvádí existence GILu neboli Global Interepreter Locku. Proto existuje snaha o eliminaci GILu. Dnes si ukážeme, jakého urychlení je možné v praxi dosáhnout ve chvíli, kdy použijeme verzi CPythonu bez GILu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Interpret Pythonu bez GILu</a></p>
<p><a href="#k02">2. Překlad a instalace Pythonu bez GILu</a></p>
<p><a href="#k03">3. Je to užitečné v&nbsp;praxi? Role benchmarků</a></p>
<p><a href="#k04">4. Výpočet členů Fibonacciho posloupnosti</a></p>
<p><a href="#k05">5. Výsledky benchmarku pro různý počet vláken</a></p>
<p><a href="#k06">6. Algoritmus bublinkového řazení</a></p>
<p><a href="#k07">7. Výsledky benchmarku při vypnuté i zapnuté volbě &bdquo;nogil&ldquo;</a></p>
<p><a href="#k08">8. Složitější výpočty s&nbsp;velkým množstvím numerických operací</a></p>
<p><a href="#k09">9. Paralelní varianta výpočtů z&nbsp;předchozí kapitoly</a></p>
<p><a href="#k10">10. Výsledky benchmarku pro sekvenční i paralelní variantu výpočtů</a></p>
<p><a href="#k11">11. Benchmark s&nbsp;větším množstvím výpočtů, které je možné provádět paralelně</a></p>
<p><a href="#k12">12. Sekvenční a paralelní verze benchmarku</a></p>
<p><a href="#k13">13. Výsledky benchmarku pro sekvenční i paralelní variantu výpočtů</a></p>
<p><a href="#k14">14. Vliv počtu paralelně běžících vláken na čas dokončení výpočtů</a></p>
<p><a href="#k15">15. Několik pozorování</a></p>
<p><a href="#k16">16. Závěrem &ndash; vyplatí se to?</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Interpret Pythonu bez GILu</h2>

<p>Programovací jazyk Python, resp.&nbsp;přesněji řečeno jeho standardní
varianta CPython, nepatří (poněkud eufemisticky řečeno) mezi nejrychlejší
interpretry, i když se situace stále zlepšuje (viz například nedávno vydaný
článek <a
href="https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/">Rychlost
CPythonu 3.11 a 3.12 v porovnání s&nbsp;JIT a AOT překladači</a>). Příčin
relativně pomalé interpretace programů psaných v&nbsp;Pythonu je pochopitelně
větší množství, a mnohé z&nbsp;nich do značné míry souvisí s&nbsp;vlastnostmi
tohoto programovacího jazyka (dynamický typový systém, způsob uložení referencí
na hodnoty atd.).</p>

<p>Jedním z&nbsp;nejčastěji citovaných důvodů je existence (ne)slavného
<i>GILu</i>, což je zkratka sousloví <i>Global Interpreter Lock(u)</i>.
Existence GILu, která zajišťuje korektní přístup k&nbsp;hodnotám objektů atd.,
do značné míry znemožňuje skutečně paralelní běh vícevláknových aplikací.
Samozřejmě nám nic nebrání ve vytvoření aplikace s&nbsp;větším množstvím
vláken, ale ty poběží spíše souběžně (<i>concurrent</i>) a nikoli skutečně
paralelně (<i>parallel</i>), protože běh jednotlivých vláken bude často
zastaven právě na zámku (<i>lock</i>).</p>

<p>Není tedy divu, že s&nbsp;příchodem mikroprocesorů s&nbsp;větším množstvím
jader se vlastně neustále objevují snahy o odstranění GILu &ndash; dalo by se
dokonce říct, že je to v&nbsp;ekosystému programovacího jazyka Python evergreen
a každý &bdquo;skutečný programátor&ldquo; by měl aspoň jednou v&nbsp;životě
napsat do fóra Pythonu, že by bylo dobré GIL odstranit :-) A neustálé odmítání
odstranění GILu vedlo mnohé k&nbsp;tomu, že opakovali mantru &bdquo;interpret
Pythonu musí vždy GIL obsahovat&ldquo;. To pochopitelně není zcela pravda,
protože některé jiné interpretry Pythonu (určené pro běh nad virtuálními stroji
atd.) GIL neobsahují.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;Pythonu 3.12 se objevuje částečné
řešení tohoto problému spočívající v&nbsp;tom, že každý další spuštěný
podinterpret má vlastní GIL a nikoli skutečně globální GIL. To ovšem vyžaduje
spouštění podinterpretrů atd.</div></p>

<p>V&nbsp;současnosti je, většinou ve stavu <i>proof of concept</i>,
k&nbsp;dispozici hned několik upravených verzí CPythonu bez GILu (nebo
s&nbsp;redukovaným počtem zámků &ndash; locků). Jsou však tyto varianty
stabilní a přináší nějaké skutečné zrychlení vícevláknových aplikací? Pokusme
se o několik srovnání; využijeme přitom variantu CPythonu 3.9 bez GILu, jejíž
zdrojové kódy jsou dostupné na adrese <a
href="https://github.com/colesbury/nogil">https://github.com/colesbury/nogil</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Překlad a instalace Pythonu bez GILu</h2>

<p>Překlad a instalace vlastní varianty Pythonu (resp.&nbsp;CPythonu) bez GILu
je relativně snadná. Nejdříve si ovšem ověřte, že máte nainstalovány všechny
potřebné nástroje (git, gcc a Make) i knihovny. Závislosti jsou popsány <a
href="https://devguide.python.org/getting-started/setup-building/index.html">zde</a>.
Nezapomeňte především na knihovnu <strong>libssl-dev</strong>. Pokud tato
knihovna nebude nainstalována, interpret se sice přeloží, ale například
<strong>pip</strong> nebude (logicky) podporovat HTTPs a tím pádem nepůjdou
stáhnout balíčky z&nbsp;PyPi (a některé balíčky použijeme
v&nbsp;benchmarcích).</p>

<p>Ve druhém kroku naklonujeme repositář s&nbsp;Pythonem s&nbsp;odstraněným
GILem:</p>

<pre>
$ <strong>git clone https://github.com/colesbury/nogil</strong>
&nbsp;
Cloning into 'nogil'...
remote: Enumerating objects: 917040, done.
remote: Counting objects: 100% (917040/917040), done.
remote: Compressing objects: 100% (176101/176101), done.
remote: Total 917040 (delta 737567), reused 916960 (delta 737528), pack-reused 
Receiving objects: 100% (917040/917040), 404.58 MiB | 5.21 MiB/s, done.
Resolving deltas: 100% (737567/737567), done.
</pre>

<p>Další kroky jsou již standardní a vlastně se nijak neliší od překladu
klasického Pythonu. Zavoláme <strong>./configure</strong> s&nbsp;povolením
optimalizací:</p>

<pre>
$ <strong>./configure --enable-optimizations</strong>
</pre>

<p>Pokud vše proběhne v&nbsp;pořádku, zbývají nám pouze provést dva kroky.
Prvním z&nbsp;nich je vlastní překlad, ideálně prováděný paralelně. Příklad
překladu interpretru Pythonu na systému s&nbsp;osmi jádry:</p>

<pre>
$ <strong>make -j8</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;průběhu překladu se spouští i
testy atd.</div></p>

<p>A v&nbsp;posledním kroku si můžete (ale striktně nemusíte) nově vzniklý
interpret nechat nainstalovat do <strong>/usr/local/</strong> příkazem:</p>

<pre>
$ <strong>make install</strong>
</pre>

<p>Nyní se pokusme si nově přeložený (a popř.&nbsp;i nainstalovaný) interpret
Pythonu spustit:</p>

<pre>
$ <strong>./python </strong>
&nbsp;
Python 3.9.10 (heads/nogil:8f9803ddf4, Jan  5 2024, 13:38:23)
[nogil, GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavá je zmínka o
<strong>nogil</strong> na druhém řádku vypsaném interpretrem.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Je to užitečné v&nbsp;praxi? Role benchmarků</h2>

<p>Neexistence GILu by měla usnadnit paralelní běh vláken vytvořených
v&nbsp;jedné instanci interpretru Pythonu. Do jaké míry je to pravda, je
samozřejmě nutné si nejprve ověřit v&nbsp;praxi (v&nbsp;IT již totiž známe
příklady stovek &bdquo;vylepšení&ldquo;, která jsou dobrá jen na papíře nebo
spíš v&nbsp;PowerPointové prezentaci, zatímco praxe poněkud pokulhává).
Z&nbsp;tohoto důvodu si vyzkoušíme několik benchmarků, které jsou založeny na
spuštění a řízení běhu většího množství vláken s&nbsp;využitím třídy
<strong>ThreadPoolExecutor</strong>, se kterou jsme se již na stránkách Rootu
setkali a která je popsána <a
href="https://docs.python.org/3/library/concurrent.futures.html">zde</a>.</p>

<p><div class="rs-tip-major">Poznámka: samozřejmě je ovšem možné využít i další
techniky pro spuštění a řízení většího množství vláken. Některými těmito
technikami jsme se zabývali v&nbsp;článcích vypsaných v&nbsp;devatenácté
kapitole.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpočet členů Fibonacciho posloupnosti</h2>

<p>Přímo v&nbsp;dokumentaci, která je dostupná na <a
href="https://github.com/colesbury/nogil">https://github.com/colesbury/nogil</a>,
je uveden jednoduchý benchmark, jenž je založen na výpočtu členů Fibonacciho
posloupnosti. Zajímavé je, že tento benchmark se vlastně používá pro zjištění
hodnoty (resp.&nbsp;přesněji řečeno počtu vláken), která ještě mohou běžet
paralelně tak, aby se celková doba výpočtu nezvětšila. Zvýšení počtu vláken
tedy v&nbsp;tomto případě nevede ke zrychlení výpočtu jedné úlohy, ale ke
zvětšení počtu dokončených úloh (což je vlastně odvozeno od známého
<i>Gustafsonova zákona</i>, který v&nbsp;této oblasti nahrazuje <i>Amdahlův
zákon</i> zaměřený na snížení celkového času).</p>

<p>Zdrojový kód tohoto benchmarku vypadá následovně (získáno přímo ze stránky
<a
href="https://github.com/colesbury/nogil">https://github.com/colesbury/nogil</a>):</p>

<pre>
import sys
from concurrent.futures import ThreadPoolExecutor
&nbsp;
print(f"nogil={getattr(sys.flags, 'nogil', False)}")
&nbsp;
def <strong>fib</strong>(n):
    if n &lt; 2: return 1
    return fib(n-1) + fib(n-2)
&nbsp;
threads = 8
if len(sys.argv) &gt; 1:
    threads = int(sys.argv[1])
&nbsp;
with ThreadPoolExecutor(max_workers=threads) as executor:
    for _ in range(threads):
        executor.submit(lambda: print(fib(34)))
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výsledky benchmarku pro různý počet vláken</h2>

<p>Na stránkách <a href="https://github.com/colesbury/nogil">projektu nogil</a>
jsou uvedeny výsledky tohoto benchmarku provedené na počítači
s&nbsp;mikroprocesorem <a
href="https://ark.intel.com/content/www/us/en/ark/products/91753/intel-xeon-processor-e5-2698-v4-50m-cache-2-20-ghz.html">Intel
Xeon E5-2698 v4</a>, který má dvacet jader. A dosažené výsledky tomu
odpovídají.</p>

<p>V&nbsp;mém případě takový luxusní mikroprocesor není k&nbsp;dispozici.
Benchmark byl namísto toho spuštěn na mikroprocesoru <a
href="https://ark.intel.com/content/www/us/en/ark/products/193563/intel-core-i7-8665u-processor-8m-cache-up-to-4-80-ghz.html">Intel
Core i7-8665U</a>, který má &bdquo;jen&ldquo; čtyři jádra. Tomu budou odpovídat
i výsledky benchmarků.</p>

<p>Při spuštění jediného výpočtu bude reálný čas pro dokončení výpočtů
dosahovat 0,708 sekundy:</p>

<pre>
$ <strong>time python3.9 fib.py 1</strong>
</pre>

<p>Výsledky:</p>

<pre>
nogil=True
9227465
&nbsp;
real    0m0,708s
user    0m0,688s
sys     0m0,020s
</pre>

<p>V&nbsp;případě, že spustíme čtyři výpočty paralelně, bude reálný čas
prakticky stejný, konkrétně 0,787 sekundy (<i>user time</i> naproti tomu
naznačuje, že běžely čtyři výpočty, každý z&nbsp;nich přibližně oněch 0,7
sekundy):</p>

<pre>
$ <strong>time python3.9 fib.py 4</strong>
</pre>

<p>Výsledky:</p>

<pre>
nogil=True
9227465
9227465
9227465
9227465
&nbsp;
real    0m0,787s
user    0m2,856s
sys     0m0,013s
</pre>

<p>U většího počtu výpočtů se již nedosáhne stejného reálného času, protože
čtyři fyzická jádra neumožní plně paralelní běh pěti, šesti atd. výpočtů. Je to
jasně patrné na výsledcích:</p>

<pre>
$ <strong>time python3.9 fib.py 8</strong>
</pre>

<p>Nyní je již reálný čas přibližně dvojnásobný oproti předchozímu času, což
docela dobře odpovídá teorii: osm úloh běžících na čtyřech jádrech:</p>

<pre>
nogil=True
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
&nbsp;
real    0m1,474s
user    0m11,178s
sys     0m0,020s
</pre>

<p>A pro jistotu si ještě pusťme stejný výpočet, tentokrát však
šestnáctkrát:</p>

<pre>
$ <strong>time python3.9 fib.py 16</strong>
</pre>

<pre>
nogil=True
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
&nbsp;
real    0m3,177s
user    0m23,449s
sys     0m0,024s
</pre>

<p><div class="rs-tip-major">Závěr: u takto jednoduchých výpočtů je skutečně
dosaženo předpokládaného zvýšení výkonu, který odpovídá počtu dostupných
fyzických jader mikroprocesoru.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Algoritmus bublinkového řazení</h2>

<p>Jako druhý benchmark byl zvolen algoritmus bublinkového řazení, který
intenzivně pracuje s&nbsp;operační pamětí. Samozřejmě se jedná o velmi
neefektivní algoritmus (což vlastně benchmarky mají být :-). Čistě sekvenční
varianta tohoto benchmarku vypadá následovně:</p>

<pre>
from time import perf_counter
import random
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    t1 = perf_counter()
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(0, i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
    t2 = perf_counter()
&nbsp;
    print(f"Sorted in {t2-t1} seconds:")
&nbsp;
&nbsp;
t1 = perf_counter()
&nbsp;
for i in range(100):
    bubble_sort(5000)
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Total time: {t2-t1} seconds:")
</pre>

<p>V&nbsp;tomto benchmarku stokrát voláme funkci, která vytvoří pole
(realizované seznamem) se 10000 prvky s&nbsp;náhodnou hodnotou. Toto pole je
následně seřazeno. Pro úplnost se ještě měří čas seřazení pole a taktéž celkový
čas všech výpočtů.</p>

<p>Paralelní či možná lépe řečeno pseudoparalelní varianta benchmarku je
prakticky stejná, ovšem oněch sto volání funkce <strong>bubble_sort</strong>
není provedeno sekvenčně, ale využívá se namísto toho již výše zmíněná třída
<strong>ThreadPoolExecutor</strong>. Hodnotou <strong>max_workers</strong>
můžeme omezit počet úloh spouštěných současně:</p>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
from time import perf_counter
import random
&nbsp;
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    t1 = perf_counter()
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(0, i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
    t2 = perf_counter()
&nbsp;
    print(f"Sorted in {t2-t1} seconds:")
&nbsp;
&nbsp;
t1 = perf_counter()
&nbsp;
with ThreadPoolExecutor(max_workers=8) as executor:
    for i in range(100):
        executor.submit(bubble_sort, 5000)
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Total time: {t2-t1} seconds:")
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledky benchmarku při vypnuté i zapnuté volbě &bdquo;nogil&ldquo;</h2>

<p>Benchmark, přesněji řečeno dvojice benchmarků, <a
href="#k06">z&nbsp;předchozí kapitoly</a> byl spuštěn v&nbsp;interpretru
Pythonu, který jsme přeložili v&nbsp;rámci <a href="#k02">druhé kapitoly</a>.
Benchmark byl spuštěn celkem třikrát, a to konkrétně v&nbsp;těchto
variantách:</p>

<ol>
<li>Sekvenční varianta benchmarku běžící v&nbsp;jednom vlákně</li>
<li>Souběžná varianta benchmarku běžící ve více vláknech, ovšem se zapnutým GILem (proměnná prostředí <strong>PYTHONGIL=1</strong>)</li>
<li>Souběžná a současně i paralelní varianta benchmarku běžící ve více vláknech a s&nbsp;vypnutým GILem (proměnná prostředí <strong>PYTHONGIL=0</strong>)</li>
</ol>

<p>Výsledky jsou zajímavé:</p>

<table>
<tr><th>Varianta</th><th>Čas běhu benchmarku</th></tr>
<tr><td>sekvenční</td><td>202s</td></tr>
<tr><td>souběžná s&nbsp;GILem</td><td>205s</td></tr>
<tr><td>paralelní bez GILu</td><td>74s</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: benchmarky jsem ve skutečnosti spustit
každý několikrát a vypočítal průměr.</div></p>

<p>Nejprve se podívejme na první dva výsledky, což znamená 202 sekund u
sekvenční varianty a 205 sekund u varianty souběžné (zde lze použít i klasický
CPython). Časy výpočtu jsou prakticky shodné, i když chování benchmarku
v&nbsp;runtime se liší. Zatímco u sekvenčního benchmarku bylo trvale využito
jedno jádro procesoru prakticky na 100% a další jádra nebyla využita, u
souběžné varianty se sice využívalo více jader, ale jejich využití bylo menší
než 100% (pokud lze věřit <strong>top</strong>u, tak byla jádra využita ze 40%,
ale tipuji, že ve skutečnosti to bylo poněkud méně). Zde jsme tedy nic
neušetřili i přesto, že jsme použili vícevláknový program &ndash; a zde je
patrné, že volání pro odstranění GILu má svůj význam!</p>

<a href="https://www.root.cz/obrazek/1113716/"><img src="https://i.iinfo.cz/images/463/python-nogil-1-prev.webp" class="image-1113716" width="370" height="241" data-prev-filename="https://i.iinfo.cz/images/463/python-nogil-1-prev.webp" data-prev-width="370" data-prev-height="241" data-large-filename="https://i.iinfo.cz/images/463/python-nogil-1-large.webp" data-large-width="720" data-large-height="468" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 1: Při sekvenčním výpočtu je zatíženo jen jedno jádro mikroprocesoru.</i></p>

<a href="https://www.root.cz/obrazek/1113717/"><img src="https://i.iinfo.cz/images/463/python-nogil-2-prev.webp" class="image-1113717" width="370" height="241" data-prev-filename="https://i.iinfo.cz/images/463/python-nogil-2-prev.webp" data-prev-width="370" data-prev-height="241" data-large-filename="https://i.iinfo.cz/images/463/python-nogil-2-large.webp" data-large-width="720" data-large-height="468" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 2: Souběžné výpočty sice vytíží více jader (nenulové hodnoty
v&nbsp;levém horním rohu), ovšem nelze přesáhnout 100% výkonu (měřeno výkonem
jednoho jádra). Celkový čas výpočtu tedy bude srovnatelný se sekvenčním přístupem.</i></p>

<p>Paralelní běh bez GILu vytížil všechna jádra prakticky na 100%, takže bychom
očekávali, že doba běhu benchmarku bude dosahovat 202s/4=50 sekund. Ve
skutečnosti je to však o něco více. Díky odstranění GILu a spuštění výpočtu ve
více vláknech jsme na mikroprocesoru se čtyřmi fyzickými jádry dosáhli
přibližně trojnásobného zrychlení. To není špatné, i když na druhou stranu to
ukazuje, že se stále provádí nějaké synchronizace.</p>

<a href="https://www.root.cz/obrazek/1113718/"><img src="https://i.iinfo.cz/images/463/python-nogil-3-prev.webp" class="image-1113718" width="370" height="241" data-prev-filename="https://i.iinfo.cz/images/463/python-nogil-3-prev.webp" data-prev-width="370" data-prev-height="241" data-large-filename="https://i.iinfo.cz/images/463/python-nogil-3-large.webp" data-large-width="720" data-large-height="468" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 3: Teprve odstranění GILu vede k&nbsp;tomu, že jsou výpočtem
vytížena všechna jádra mikroprocesoru (zde se zobrazuje osm jader, ovšem
fyzicky se jedná o čtyři jádra).</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Složitější výpočty s&nbsp;velkým množstvím numerických operací</h2>

<p>Větší počet jader mikroprocesoru, které mohou v&nbsp;ideálním případě
pracovat paralelně, oceníme především ve chvíli, kdy musíme vykonat nějaké
složitější výpočty, neboť takové úlohy typicky nejsou omezeny rychlostí I/O
operací a mnohdy ani nemají velké množství čtení a zápisů do operační paměti.
Jednou typicky výpočetně náročnou úlohou (kterou jsme v&nbsp;nepatrně pozměněné
podobě již použili při testování nástroje <i>Numba</i> a <i>mypyc</i>), je
výpočet nějakého fraktálu v&nbsp;komplexní rovině.</p>

<a href="https://www.root.cz/obrazek/1113721/"><img src="https://i.iinfo.cz/images/463/python-nogil-6-prev.webp" class="image-1113721" width="270" height="270" data-prev-filename="https://i.iinfo.cz/images/463/python-nogil-6-prev.webp" data-prev-width="270" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/463/python-nogil-4.webp" data-large-width="512" data-large-height="512" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 4: Jedna varianta fraktálu vykreslená benchmarkem.</i></p>

<p>Zkusme si tedy nechat vykreslit několik Juliových množin ve větším rozlišení
(1024&times;1024 pixelů) a s&nbsp;využitím většího maximálního počtu iterací
(1000). Následující benchmark <i>sekvenčně</i> vypočítá deset obrázků Juliových
množin a uloží je na disk:</p>

<pre>
#!/usr/bin/env python
&nbsp;
<i>"""Renderer of the classic Julia fractal."""</i>
&nbsp;
from PIL import Image
from time import perf_counter
&nbsp;
IMAGE_WIDTH = 1024
IMAGE_HEIGHT = 1024
&nbsp;
&nbsp;
def <strong>julia</strong>(cx, cy, zx, zy, maxiter):
    c = complex(cx, cy)
    z = complex(zx, zy)
    for i in range(0, maxiter):
        if abs(z) &gt; 2:
            return i
        z = z * z + c
    return 0
&nbsp;
&nbsp;
def <strong>recalc_fractal</strong>(filename, palette, xmin, ymin, xmax, ymax, cx, cy, maxiter=1000):
    <i>"""Recalculate the whole fractal and render the set into given image."""</i>
    t1 = perf_counter()
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))
&nbsp;
    width, height = image.size
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height
&nbsp;
    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            i = julia(cx, cy, x1, y1, maxiter)
            i = 3 * i % 256
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
            x1 += stepx
        y1 += stepy
&nbsp;
    image.save(filename)
    t2 = perf_counter()
    print("Done", filename, t2-t1)
&nbsp;
&nbsp;
def <strong>main</strong>():
    import palette_mandmap
&nbsp;
    recalc_fractal("spiral_1.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.769824999999999998320, -0.109270000000000000000, 1000)
    recalc_fractal("spiral_2.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.171119200000000013445, 0.657309400000000000000, 1000)
    recalc_fractal("spiral_3.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.207190825000000012496, 0.676656624999999999983, 1000)
    recalc_fractal("spiral_4.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.540623850000000003876, 0.523798050000000000019, 1000)
    recalc_fractal("julia1.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.0, 1.0, 1000)
    recalc_fractal("julia2.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -1.0, 0.0, 500)
    recalc_fractal("julia3.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.285, 0.01, 1000)
    recalc_fractal("julia4.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.4, 0.6, 1000)
    recalc_fractal("julia5.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.835, -0.2321, 1000)
    recalc_fractal("julia6.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.4, 0.4, 1000)
&nbsp;
&nbsp;
if __name__ == "__main__":
    t1 = perf_counter()
    main()
    t2 = perf_counter()
    print(f"Rendering time: {t2-t1} seconds")
</pre>

<a href="https://www.root.cz/obrazek/1113722/"><img src="https://i.iinfo.cz/images/463/python-nogil-7-prev.webp" class="image-1113722" width="270" height="270" data-prev-filename="https://i.iinfo.cz/images/463/python-nogil-7-prev.webp" data-prev-width="270" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/463/python-nogil-4.webp" data-large-width="512" data-large-height="512" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 5: Další varianta fraktálu vykreslená benchmarkem.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Paralelní varianta výpočtů z&nbsp;předchozí kapitoly</h2>

<p>Výpočet z&nbsp;předchozí kapitoly je možné snadno převést do varianty, ve
které se výpočet každého obrázku odehraje v&nbsp;samostatném vláknu.
V&nbsp;závislosti na verzi Pythonu (s&nbsp;GILem či bez GILu) potom tato vlákna
běží buď souběžně (<i>concurrent</i>) nebo paralelně (<i>parallel</i>). Počet
vytvořených vláken lze specifikovat parametrem předávaným do konstruktoru
<strong>ThreadPoolExecutor</strong>:</p>

<pre>
#!/usr/bin/env python
&nbsp;
<i>"""Renderer of the classic Julia fractal."""</i>
&nbsp;
from concurrent.futures.thread import ThreadPoolExecutor
from PIL import Image
from time import perf_counter
&nbsp;
IMAGE_WIDTH = 1024
IMAGE_HEIGHT = 1024
&nbsp;
&nbsp;
def <strong>julia</strong>(cx, cy, zx, zy, maxiter):
    c = complex(cx, cy)
    z = complex(zx, zy)
    for i in range(0, maxiter):
        if abs(z) &gt; 2:
            return i
        z = z * z + c
    return 0
&nbsp;
&nbsp;
def <strong>recalc_fractal</strong>(filename, palette, xmin, ymin, xmax, ymax, cx, cy, maxiter=1000):
    <i>"""Recalculate the whole fractal and render the set into given image."""</i>
    t1 = perf_counter()
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))
&nbsp;
    width, height = image.size
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height
&nbsp;
    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            i = julia(cx, cy, x1, y1, maxiter)
            i = 3 * i % 256
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
            x1 += stepx
        y1 += stepy
&nbsp;
    image.save(filename)
    t2 = perf_counter()
    print("Done", filename, t2-t1)
&nbsp;
&nbsp;
def <strong>main</strong>():
    import palette_mandmap
&nbsp;
    with ThreadPoolExecutor(max_workers=10) as executor:
        executor.submit(recalc_fractal, "spiral_1.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.769824999999999998320, -0.109270000000000000000, 1000)
        executor.submit(recalc_fractal, "spiral_2.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.171119200000000013445, 0.657309400000000000000, 1000)
        executor.submit(recalc_fractal, "spiral_3.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.207190825000000012496, 0.676656624999999999983, 1000)
        executor.submit(recalc_fractal, "spiral_4.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.540623850000000003876, 0.523798050000000000019, 1000)
        executor.submit(recalc_fractal, "julia1.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.0, 1.0, 1000)
        executor.submit(recalc_fractal, "julia2.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -1.0, 0.0, 500)
        executor.submit(recalc_fractal, "julia3.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.285, 0.01, 1000)
        executor.submit(recalc_fractal, "julia4.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.4, 0.6, 1000)
        executor.submit(recalc_fractal, "julia5.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.835, -0.2321, 1000)
        executor.submit(recalc_fractal, "julia6.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.4, 0.4, 1000)
&nbsp;
&nbsp;
if __name__ == "__main__":
    t1 = perf_counter()
    main()
    t2 = perf_counter()
    print(f"Rendering time: {t2-t1} seconds")
</pre>

<a href="https://www.root.cz/obrazek/1113723/"><img src="https://i.iinfo.cz/images/463/python-nogil-8-prev.webp" class="image-1113723" width="270" height="270" data-prev-filename="https://i.iinfo.cz/images/463/python-nogil-8-prev.webp" data-prev-width="270" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/463/python-nogil-4.webp" data-large-width="512" data-large-height="512" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 6: Ještě jedna varianta fraktálu vykresleného popisovaným benchmarkem.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výsledky benchmarku pro sekvenční i paralelní variantu výpočtů</h2>

<p>Opět se podívejme na výsledky benchmarků získané pro tři varianty spuštění.
Tyto varianty již dobře známe:</p>

<ol>
<li>Sekvenční varianta benchmarku běžící v&nbsp;jednom vlákně</li>
<li>Souběžná varianta benchmarku běžící ve více vláknech, ovšem se zapnutým GILem (proměnná prostředí <strong>PYTHONGIL=1</strong>)</li>
<li>Souběžná a současně i paralelní varianta benchmarku běžící ve více vláknech a s&nbsp;vypnutým GILem (proměnná prostředí <strong>PYTHONGIL=0</strong>)</li>
</ol>

<p>Průběh výpočtů při jejich sekvenčním spouštění vypadá následovně. Časy
výpočtů jsou uvedeny v&nbsp;sekundách, stejně jako celkový čas výpočtu:</p>

<pre>
Done spiral_1.png 5.1859697019681334
Done spiral_2.png 4.786959243938327
Done spiral_3.png 3.4001936549320817
Done spiral_4.png 3.4124309360049665
Done julia1.png 2.20688958466053
Done julia2.png 13.11793684400618
Done julia3.png 3.6973323193378747
Done julia4.png 4.339927026070654
Done julia5.png 2.9289116361178458
Done julia6.png 2.5796306179836392
Rendering time: 45.65670717321336 seconds
</pre>

<p>Naproti tomu souběžné spuštění (s&nbsp;GILem) nám ukáže zcela odlišné časy
výpočtu. Všechny výpočty jsou spuštěny v&nbsp;prakticky stejný okamžik, ovšem
tím, že běží souběžně (nikoli plně paralelně), tak trvají mnohem delší dobu. A
celkový čas výpočtů je zde taktéž delší (!), pravděpodobně kvůli nutnosti
synchronizace vláken přes GIL (samotná práce se zámky není zcela zadarmo):</p>

<pre>
Done julia6.png 30.125944807194173
Done julia1.png 31.00761267496273
Done julia5.png 30.421344230882823
Done spiral_3.png 32.166233513038605
Done julia3.png 36.28653717506677
Done spiral_4.png 37.24156935699284
Done spiral_2.png 41.884877351112664
Done julia4.png 41.84162455704063
Done spiral_1.png 42.753659673035145
Done julia2.png 49.35199412936345
Rendering time: 49.35429013008252 seconds
</pre>

<p>A konečně se dostáváme k&nbsp;paralelnímu běhu bez GILu. Čas výpočtů
jednotlivých obrázků se zvýšil, protože počet vláken je vyšší, než počet
fyzických jader. Ovšem celkový čas se snížil ze 45 sekund na 25 sekund.
Teoretická doba výpočtů by měla být 45/4=11 sekund, to je ovšem, jak ukazuje
realita, spíše optimistické (a je zde mnoho proměnných, včetně koordinace
vláken, přístupy k&nbsp;operační paměti, teplotním managementem procesoru
atd.). Taktéž nesmíme zapomenout na to, že jednotlivé výpočty trvají různou
dobu a na konci se typicky již čeká na jediné vlákno:</p>

<pre>
Done julia1.png 11.038880513980985
Done julia6.png 12.374067123048007
Done spiral_4.png 12.891932097729295
Done julia5.png 13.229847213253379
Done spiral_3.png 14.292223097756505
Done julia4.png 15.105731802992523
Done julia3.png 15.142507585231215
Done spiral_2.png 16.04855623608455
Done spiral_1.png 16.921899473760277
Done julia2.png 25.186154996976256
Rendering time: 25.188359602820128 seconds
</pre>

<a href="https://www.root.cz/obrazek/1113726/"><img src="https://i.iinfo.cz/images/463/python-nogil-11-prev.webp" class="image-1113726" width="270" height="270" data-prev-filename="https://i.iinfo.cz/images/463/python-nogil-11-prev.webp" data-prev-width="270" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/463/python-nogil-4.webp" data-large-width="512" data-large-height="512" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 7: Poslední uvedená varianta fraktálu vykresleného popisovaným benchmarkem.</i></p>

Seq. anim
Rendering time: 17.87698882399127 seconds

Parallel anim
32 wokeru
Rendering time: 18.46730578970164 seconds

jen 8 workeru
Rendering time: 19.740191074088216 seconds

Parallel anim with noGIL
jen 8 workeru
Rendering time: 7.773274493869394 seconds

32 workeru
Rendering time: 8.4774330239743 seconds

pocet workeru
20.333684382028878
11.724789132829756
9.318350822199136
8.387834462802857
8.68224565917626
8.854519163724035
7.773274493869394




<p><a name="k11"></a></p>
<h2 id="k11">11. Benchmark s&nbsp;větším množstvím výpočtů, které je možné provádět paralelně</h2>

<pre>
#!/usr/bin/env python

"""Renderer of the classic Julia fractal."""

from PIL import Image
from time import perf_counter
import math

IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


def julia(cx, cy, zx, zy, maxiter):
    c = complex(cx, cy)
    z = complex(zx, zy)
    for i in range(0, maxiter):
        if abs(z) > 2:
            return i
        z = z * z + c
    return 0


def recalc_fractal(filename, palette, xmin, ymin, xmax, ymax, cx, cy, maxiter=1000):
    """Recalculate the whole fractal and render the set into given image."""
    t1 = perf_counter()
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

    width, height = image.size
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            i = julia(cx, cy, x1, y1, maxiter)
            i = 3 * i % 256
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
            x1 += stepx
        y1 += stepy

    image.save(filename)
    t2 = perf_counter()
    # print("Done", filename, t2-t1)


def main():
    import palette_mandmap

    for angle in range(0, 360, 5):
        rad = math.radians(angle)
        cx = 1.0 * math.cos(rad)
        cy = 1.0 * math.sin(rad)
        filename = f"anim_{angle:03d}.png"
        # print(filename)

        recalc_fractal(filename, palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, cx, cy, 1000)


if __name__ == "__main__":
    t1 = perf_counter()
    main()
    t2 = perf_counter()
    print(f"Threads: no   Rendering time: {t2-t1} seconds")
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
#!/usr/bin/env python

"""Renderer of the classic Julia fractal."""

import sys
from concurrent.futures.thread import ThreadPoolExecutor
from PIL import Image
from time import perf_counter
import math

IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


def julia(cx, cy, zx, zy, maxiter):
    c = complex(cx, cy)
    z = complex(zx, zy)
    for i in range(0, maxiter):
        if abs(z) > 2:
            return i
        z = z * z + c
    return 0


def recalc_fractal(filename, palette, xmin, ymin, xmax, ymax, cx, cy, maxiter=1000):
    """Recalculate the whole fractal and render the set into given image."""
    t1 = perf_counter()
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

    width, height = image.size
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            i = julia(cx, cy, x1, y1, maxiter)
            i = 3 * i % 256
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
            x1 += stepx
        y1 += stepy

    image.save(filename)
    t2 = perf_counter()
    # print("Done", filename, t2-t1)


def main(threads):
    import palette_mandmap

    with ThreadPoolExecutor(max_workers=threads) as executor:
        for angle in range(0, 360, 5):
            rad = math.radians(angle)
            cx = 1.0 * math.cos(rad)
            cy = 1.0 * math.sin(rad)
            filename = f"anim_{angle:03d}.png"
            # print(filename)

            executor.submit(recalc_fractal, filename, palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, cx, cy, 1000)


if __name__ == "__main__":
    threads = 8
    if len(sys.argv) > 1:
        threads = int(sys.argv[1])

    t1 = perf_counter()
    main(threads)
    t2 = perf_counter()
    print(f"Threads: {threads}   Rendering time: {t2-t1} seconds")
</pre>


<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Několik pozorování</h2>

<p>Zejména u druhého mikroprocesoru použitého pro benchmarky (12th Gen Intel(R)
Core(TM) i7-1270P) je nutné vypnout režim &bdquo;energy safe&ldquo;, protože
jinak byl výpočetní čas pro sekvenční zpracování a pro paralelní zpracování
prakticky stejný! Tj.&nbsp;v&nbsp;prvním případě pracovalo jen jedno jádro na
100%, ovšem v&nbsp;plné frekvenci a ve druhém případě pracovala všechna jádra
sice taktéž na 100%, ale při nižší frekvenci a výsledky se nakonec srovnaly (na
druhou stranu je vypnutí &bdquo;energy safe&ldquo; režimu na laptopu velmi
nepraktické (větrák pracující i ve chvíli, kdy je load prakticky nulový).</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Závěrem &ndash; vyplatí se to?</h2>

<p>V&nbsp;první řadě je nutné poznamenat, že &bdquo;Python bez GIL&ldquo; je
stabilní a týden jsem ho dokázal profesionálně používat namísto běžného Pythonu
3.12. Naproti tomu výsledky výpočetně náročných benchmarků ukazují, že
urychlení možná neodpovídá očekávání, protože v&nbsp;této oblasti bych skutečně
očekával, že urychlení bude zhruba odpovídat počtu jader. Nicméně i pro větší
počet fyzických jader procesoru se dosahuje maximálně dvojnásobného až
trojnásobného urychlení.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady (resp.&nbsp;jednoduché benchmarky) ukazující
vlastnosti Pythonu bez GILu naleznete v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Ideální je mít nainstalován Python bez GILu, protože jen tak se projeví výhody
paralelních variant benchmarků. Následují odkazy na jednotlivé
příklady/benchmarky:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>bubble_sort_seq.py</td><td>bublinkové řazení, sekvenční varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/bubble_sort_seq.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/bubble_sort_seq.py</a></td></tr>
<tr><td>2</td><td>bubble_sort_parallel.py</td><td>bublinkové řazení, paralelní (souběžná) varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/bubble_sort_parallel.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/bubble_sort_parallel.py</a></td></tr>
<tr><td>3</td><td>julia_seq_renderer.py</td><td>časově náročnější výpočet fraktálu, sekvenční varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_seq_renderer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_seq_renderer.py</a></td></tr>
<tr><td>4</td><td>julia_parallel_renderer.py</td><td>časově náročnější výpočet fraktálu, paralelní (souběžná) varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_parallel_renderer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_parallel_renderer.py</a></td></tr>
<tr><td>5</td><td>julia_seq_anim.py</td><td>časově náročnější výpočet animace, sekvenční varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_seq_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_seq_anim.py</a></td></tr>
<tr><td>6</td><td>julia_parallel_anim.py</td><td>časově náročnější výpočet animace, paralelní (souběžná) varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_parallel_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_parallel_anim.py</a></td></tr>
<tr><td>7</td><td>palette_mandmap.py</td><td>pomocný soubor s&nbsp;barvovou paletou používaný předchozími příklady</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/palette_mandmap.py</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</h2>

<p>Na stránkách <a href="https://www.root.cz">Roota</a> jsme se již několikrát
setkali s&nbsp;problematikou souběžnosti, paralelnosti a asynchronního běhu
v&nbsp;Pythonu. Různé varianty spouštění a řízení více vláken, procesů a
asynchronních úloh naleznete v&nbsp;následujících článcích (všechny
v&nbsp;článcích uvedené demonstrační příklady by měly být spustitelné i
v&nbsp;interpretru Pythonu bez GILu):</p>

<ol>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – Curio a Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – závěrečné zhodnocení<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>PEP 684 – A Per-Interpreter GIL<br />
<a href="https://peps.python.org/pep-0684/">https://peps.python.org/pep-0684/</a>
</li>

<li>What Is the Python Global Interpreter Lock (GIL)?<br />
<a href="https://realpython.com/python-gil/">https://realpython.com/python-gil/</a>
</li>

<li>PEP 703 – Making the Global Interpreter Lock Optional in CPython<br />
<a href="https://peps.python.org/pep-0703/">https://peps.python.org/pep-0703/</a>
</li>

<li>GlobalInterpreterLock<br />
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>
</li>

<li>What is the Python Global Interpreter Lock (GIL)<br />
<a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/">https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/</a>
</li>

<li>Python 3.12: More Faster and More Efficient Python<br />
<a href="https://medium.com/@HeCanThink/python-3-12-more-faster-and-more-efficient-python-b636f00b047">https://medium.com/@HeCanThink/python-3-12-more-faster-and-more-efficient-python-b636f00b047</a>
</a>

<li>Numba<br />
<a href="http://numba.pydata.org/">http://numba.pydata.org/</a>
</li>

<li>numba 0.57.0<br />
<a href="https://pypi.org/project/numba/">https://pypi.org/project/numba/</a>
</li>

<li>Pushing Python toward C speeds with SIMD <br />
<a href="https://laurenar.net/posts/python-simd/">https://laurenar.net/posts/python-simd/</a>
</li>

<li>Retrieve generated LLVM from Numba<br />
<a href="https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba">https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba</a>
</li>

<li>Numba documentation<br />
<a href="http://numba.pydata.org/numba-doc/latest/index.html">http://numba.pydata.org/numba-doc/latest/index.html</a>
</li>

<li>Numba na GitHubu<br />
<a href="https://github.com/numba/numba">https://github.com/numba/numba</a>
</li>

<li>First Steps with numba<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html</a>
</li>

<li>Numba and types<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html</a>
</li>

<li>Just-in-time compilation<br />
<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">https://en.wikipedia.org/wiki/Just-in-time_compilation</a>
</li>

<li>Cython (home page)<br />
<a href="http://cython.org/">http://cython.org/</a>
</li>

<li>Cython (wiki)<br />
<a href="https://github.com/cython/cython/wiki">https://github.com/cython/cython/wiki</a>
</li>

<li>Cython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cython">https://en.wikipedia.org/wiki/Cython</a>
</li>

<li>Cython (GitHub)<br />
<a href="https://github.com/cython/cython">https://github.com/cython/cython</a>
</li>

<li>PyPy (home page)<br />
<a href="https://pypy.org/">https://pypy.org/</a>
</li>

<li>PyPy (dokumentace)<br />
<a href="http://doc.pypy.org/en/latest/">http://doc.pypy.org/en/latest/</a>
</li>

<li>Nuitka<br />
<a href="https://github.com/Nuitka/Nuitka">https://github.com/Nuitka/Nuitka</a>
</li>

<li>SIMD Autovectorization in Numba<br />
<a href="https://tbetcke.github.io/hpc_lecture_notes/simd.html">https://tbetcke.github.io/hpc_lecture_notes/simd.html</a>
</li>

<li>Does Jython have the GIL?<br />
<a href="https://stackoverflow.com/questions/1120354/does-jython-have-the-gil">https://stackoverflow.com/questions/1120354/does-jython-have-the-gil</a>
</li>

<li>Let's remove the Global Interpreter Lock<br />
<a href="https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html">https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html</a>
</li>

<li>Global interpreter lock<br />
<a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">https://en.wikipedia.org/wiki/Global_interpreter_lock</a>
</li>

<li>Rychlost CPythonu 3.11 a 3.12 v&nbsp;porovnání s JIT a AOT překladači<br />
<a href="https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/">https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

