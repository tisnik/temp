<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Interpret Pythonu bez GILu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Interpret Pythonu bez GILu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Interpret Pythonu bez GILu</a></p>
<p><a href="#k02">*** 2. Překlad a instalace Pythonu bez GILu</a></p>
<p><a href="#k03">*** 3. Je to užitečné v&nbsp;praxi? Role benchmarků</a></p>
<p><a href="#k04">4. Výpočet členů Fibonacciho posloupnosti</a></p>
<p><a href="#k05">*** 5. Výsledky benchmarku pro různý počet vláken</a></p>
<p><a href="#k06">*** 6. Algoritmus bublinkového řazení</a></p>
<p><a href="#k07">*** 7. Výsledky benchmarku při vypnuté i zapnuté volbě &bdquo;nogil&ldquo;</a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Interpret Pythonu bez GILu</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Překlad a instalace Pythonu bez GILu</h2>

<pre>
</pre>

<pre>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Je to užitečné v&nbsp;praxi? Role benchmarků</h2>

<p></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpočet členů Fibonacciho posloupnosti</h2>

<p>Přímo v&nbsp;dokumentaci, která je dostupná na <a
href="https://github.com/colesbury/nogil">https://github.com/colesbury/nogil</a>,
je uveden jednoduchý benchmark, jenž je založen na výpočtu členů Fibonacciho
posloupnosti. Zajímavé je, že tento benchmark se vlastně používá pro zjištění
hodnoty (resp.&nbsp;přesněji řečeno počtu vláken), která ještě mohou běžet
paralelně tak, aby se celková doba výpočtu nezvětšila. Zvýšení počtu vláken
tedy nevede ke zrychlení výpočtu, ale ke zvětšení počtu dokončených úloh (což
je vlastně odvozeno od známého <i>Gustafsonova zákona</i>, který v&nbsp;této
oblasti nahrazuje <i>Amdahlův zákon</i> zaměřený na snížení celkového
času).</p>

<p>Zdrojový kód tohoto benchmarku vypadá následovně:</p>

<pre>
import sys
from concurrent.futures import ThreadPoolExecutor
&nbsp;
print(f"nogil={getattr(sys.flags, 'nogil', False)}")
&nbsp;
def <strong>fib</strong>(n):
    if n &lt; 2: return 1
    return fib(n-1) + fib(n-2)
&nbsp;
threads = 8
if len(sys.argv) &gt; 1:
    threads = int(sys.argv[1])
&nbsp;
with ThreadPoolExecutor(max_workers=threads) as executor:
    for _ in range(threads):
        executor.submit(lambda: print(fib(34)))
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výsledky benchmarku pro různý počet vláken</h2>

<pre>
$ <strong>time python3.9 fib.py 1</strong>
&nbsp;
nogil=True
9227465
&nbsp;
real    0m0,708s
user    0m0,688s
sys     0m0,020s
</pre>


<pre>
$ <strong>time python3.9 fib.py 4</strong>
</pre>

<pre>
nogil=True
9227465
9227465
9227465
9227465
&nbsp;
real    0m0,787s
user    0m2,856s
sys     0m0,013s
</pre>

<pre>
$ <strong>time python3.9 fib.py 8</strong>
</pre>

<pre>
nogil=True
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
&nbsp;
real    0m1,474s
user    0m11,178s
sys     0m0,020s
</pre>


<pre>
$ <strong>time python3.9 fib.py 16</strong>
</pre>

<pre>
nogil=True
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
9227465
&nbsp;
real    0m3,177s
user    0m23,449s
sys     0m0,024s
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Algoritmus bublinkového řazení</h2>

<pre>
from time import perf_counter
import random
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    t1 = perf_counter()
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(0, i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
    t2 = perf_counter()
&nbsp;
    print(f"Sorted in {t2-t1} seconds:")
&nbsp;
&nbsp;
t1 = perf_counter()
&nbsp;
for i in range(100):
    bubble_sort(5000)
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Total time: {t2-t1} seconds:")
</pre>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
from time import perf_counter
import random
&nbsp;
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    t1 = perf_counter()
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(0, i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
    t2 = perf_counter()
&nbsp;
    print(f"Sorted in {t2-t1} seconds:")
&nbsp;
&nbsp;
t1 = perf_counter()
&nbsp;
with ThreadPoolExecutor(max_workers=8) as executor:
    for i in range(100):
        executor.submit(bubble_sort, 5000)
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Total time: {t2-t1} seconds:")
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledky benchmarku při vypnuté i zapnuté volbě &bdquo;nogil&ldquo;</h2>



bubble sort
seq: 202
par : GIL 205
nogil 74



<p><a name="k08"></a></p>
<h2 id="k08">8. Složitější výpočty s&nbsp;velkým množstvím numerických operací</h2>

<pre>
#!/usr/bin/env python

"""Renderer of the classic Julia fractal."""

from PIL import Image
from time import perf_counter

IMAGE_WIDTH = 1024
IMAGE_HEIGHT = 1024


def julia(cx, cy, zx, zy, maxiter):
    c = complex(cx, cy)
    z = complex(zx, zy)
    for i in range(0, maxiter):
        if abs(z) > 2:
            return i
        z = z * z + c
    return 0


def recalc_fractal(filename, palette, xmin, ymin, xmax, ymax, cx, cy, maxiter=1000):
    """Recalculate the whole fractal and render the set into given image."""
    t1 = perf_counter()
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

    width, height = image.size
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            i = julia(cx, cy, x1, y1, maxiter)
            i = 3 * i % 256
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
            x1 += stepx
        y1 += stepy

    image.save(filename)
    t2 = perf_counter()
    print("Done", filename, t2-t1)


def main():
    import palette_mandmap

    recalc_fractal("spiral_1.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.769824999999999998320, -0.109270000000000000000, 1000)
    recalc_fractal("spiral_2.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.171119200000000013445, 0.657309400000000000000, 1000)
    recalc_fractal("spiral_3.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.207190825000000012496, 0.676656624999999999983, 1000)
    recalc_fractal("spiral_4.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.540623850000000003876, 0.523798050000000000019, 1000)
    recalc_fractal("julia1.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.0, 1.0, 1000)
    recalc_fractal("julia2.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -1.0, 0.0, 500)
    recalc_fractal("julia3.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.285, 0.01, 1000)
    recalc_fractal("julia4.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.4, 0.6, 1000)
    recalc_fractal("julia5.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.835, -0.2321, 1000)
    recalc_fractal("julia6.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.4, 0.4, 1000)


if __name__ == "__main__":
    t1 = perf_counter()
    main()
    t2 = perf_counter()
    print(f"Rendering time: {t2-t1} seconds")
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Paralelní varianta výpočtů</h2>

<pre>
#!/usr/bin/env python

"""Renderer of the classic Julia fractal."""

from concurrent.futures.thread import ThreadPoolExecutor
from PIL import Image
from time import perf_counter

IMAGE_WIDTH = 1024
IMAGE_HEIGHT = 1024


def julia(cx, cy, zx, zy, maxiter):
    c = complex(cx, cy)
    z = complex(zx, zy)
    for i in range(0, maxiter):
        if abs(z) > 2:
            return i
        z = z * z + c
    return 0


def recalc_fractal(filename, palette, xmin, ymin, xmax, ymax, cx, cy, maxiter=1000):
    """Recalculate the whole fractal and render the set into given image."""
    t1 = perf_counter()
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

    width, height = image.size
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            i = julia(cx, cy, x1, y1, maxiter)
            i = 3 * i % 256
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
            x1 += stepx
        y1 += stepy

    image.save(filename)
    t2 = perf_counter()
    print("Done", filename, t2-t1)


def main():
    import palette_mandmap

    with ThreadPoolExecutor(max_workers=10) as executor:
        executor.submit(recalc_fractal, "spiral_1.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.769824999999999998320, -0.109270000000000000000, 1000)
        executor.submit(recalc_fractal, "spiral_2.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.171119200000000013445, 0.657309400000000000000, 1000)
        executor.submit(recalc_fractal, "spiral_3.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.207190825000000012496, 0.676656624999999999983, 1000)
        executor.submit(recalc_fractal, "spiral_4.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.540623850000000003876, 0.523798050000000000019, 1000)
        executor.submit(recalc_fractal, "julia1.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.0, 1.0, 1000)
        executor.submit(recalc_fractal, "julia2.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -1.0, 0.0, 500)
        executor.submit(recalc_fractal, "julia3.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.285, 0.01, 1000)
        executor.submit(recalc_fractal, "julia4.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.4, 0.6, 1000)
        executor.submit(recalc_fractal, "julia5.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, -0.835, -0.2321, 1000)
        executor.submit(recalc_fractal, "julia6.png", palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, 0.4, 0.4, 1000)


if __name__ == "__main__":
    t1 = perf_counter()
    main()
    t2 = perf_counter()
    print(f"Rendering time: {t2-t1} seconds")
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



Done spiral_1.png 5.1859697019681334
Done spiral_2.png 4.786959243938327
Done spiral_3.png 3.4001936549320817
Done spiral_4.png 3.4124309360049665
Done julia1.png 2.20688958466053
Done julia2.png 13.11793684400618
Done julia3.png 3.6973323193378747
Done julia4.png 4.339927026070654
Done julia5.png 2.9289116361178458
Done julia6.png 2.5796306179836392
Rendering time: 45.65670717321336 seconds

Done julia6.png 30.125944807194173
Done julia1.png 31.00761267496273
Done julia5.png 30.421344230882823
Done spiral_3.png 32.166233513038605
Done julia3.png 36.28653717506677
Done spiral_4.png 37.24156935699284
Done spiral_2.png 41.884877351112664
Done julia4.png 41.84162455704063
Done spiral_1.png 42.753659673035145
Done julia2.png 49.35199412936345
Rendering time: 49.35429013008252 seconds

Done julia1.png 11.038880513980985
Done julia6.png 12.374067123048007
Done spiral_4.png 12.891932097729295
Done julia5.png 13.229847213253379
Done spiral_3.png 14.292223097756505
Done julia4.png 15.105731802992523
Done julia3.png 15.142507585231215
Done spiral_2.png 16.04855623608455
Done spiral_1.png 16.921899473760277
Done julia2.png 25.186154996976256
Rendering time: 25.188359602820128 seconds


Seq. anim
Rendering time: 17.87698882399127 seconds

Parallel anim
32 wokeru
Rendering time: 18.46730578970164 seconds

jen 8 workeru
Rendering time: 19.740191074088216 seconds

Parallel anim with noGIL
jen 8 workeru
Rendering time: 7.773274493869394 seconds

32 workeru
Rendering time: 8.4774330239743 seconds

pocet workeru
20.333684382028878
11.724789132829756
9.318350822199136
8.387834462802857
8.68224565917626
8.854519163724035
7.773274493869394




<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady (resp.&nbsp;jednoduché benchmarky) ukazující
vlastnosti Pythonu bez GILu naleznete v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Ideální je mít nainstalován Python bez GILu, aby se projevily výhody
paralelních variant benchmarků. Následují odkazy na jednotlivé
příklady/benchmarky:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>bubble_sort_seq.py</td><td>bublinkové řazení, sekvenční varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/bubble_sort_seq.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/bubble_sort_seq.py</a></td></tr>
<tr><td>2</td><td>bubble_sort_parallel.py</td><td>bublinkové řazení, paralelní (souběžná) varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/bubble_sort_parallel.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/bubble_sort_parallel.py</a></td></tr>
<tr><td>3</td><td>julia_seq_renderer.py</td><td>časově náročnější výpočet fraktálu, sekvenční varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_seq_renderer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_seq_renderer.py</a></td></tr>
<tr><td>4</td><td>julia_parallel_renderer.py</td><td>časově náročnější výpočet fraktálu, paralelní (souběžná) varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_parallel_renderer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_parallel_renderer.py</a></td></tr>
<tr><td>5</td><td>julia_seq_anim.py</td><td>časově náročnější výpočet animace, sekvenční varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_seq_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_seq_anim.py</a></td></tr>
<tr><td>6</td><td>julia_parallel_anim.py</td><td>časově náročnější výpočet animace, paralelní (souběžná) varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_parallel_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/julia_parallel_anim.py</a></td></tr>
<tr><td>7</td><td>palette_mandmap.py</td><td>pomocný soubor s&nbsp;barvovou paletou používaný předchozími příklady</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/nogil/palette_mandmap.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>PEP 684 – A Per-Interpreter GIL<br />
<a href="https://peps.python.org/pep-0684/">https://peps.python.org/pep-0684/</a>
</li>

<li>What Is the Python Global Interpreter Lock (GIL)?<br />
<a href="https://realpython.com/python-gil/">https://realpython.com/python-gil/</a>
</li>

<li>PEP 703 – Making the Global Interpreter Lock Optional in CPython<br />
<a href="https://peps.python.org/pep-0703/">https://peps.python.org/pep-0703/</a>
</li>

<li>GlobalInterpreterLock<br />
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>
</li>

<li>What is the Python Global Interpreter Lock (GIL)<br />
<a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/">https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/</a>
</li>

<li>Python 3.12: More Faster and More Efficient Python<br />
<a href="https://medium.com/@HeCanThink/python-3-12-more-faster-and-more-efficient-python-b636f00b047">https://medium.com/@HeCanThink/python-3-12-more-faster-and-more-efficient-python-b636f00b047</a>
</a>

<li>Numba<br />
<a href="http://numba.pydata.org/">http://numba.pydata.org/</a>
</li>

<li>numba 0.57.0<br />
<a href="https://pypi.org/project/numba/">https://pypi.org/project/numba/</a>
</li>

<li>Pushing Python toward C speeds with SIMD <br />
<a href="https://laurenar.net/posts/python-simd/">https://laurenar.net/posts/python-simd/</a>
</li>

<li>Retrieve generated LLVM from Numba<br />
<a href="https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba">https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba</a>
</li>

<li>Numba documentation<br />
<a href="http://numba.pydata.org/numba-doc/latest/index.html">http://numba.pydata.org/numba-doc/latest/index.html</a>
</li>

<li>Numba na GitHubu<br />
<a href="https://github.com/numba/numba">https://github.com/numba/numba</a>
</li>

<li>First Steps with numba<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html</a>
</li>

<li>Numba and types<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html</a>
</li>

<li>Just-in-time compilation<br />
<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">https://en.wikipedia.org/wiki/Just-in-time_compilation</a>
</li>

<li>Cython (home page)<br />
<a href="http://cython.org/">http://cython.org/</a>
</li>

<li>Cython (wiki)<br />
<a href="https://github.com/cython/cython/wiki">https://github.com/cython/cython/wiki</a>
</li>

<li>Cython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cython">https://en.wikipedia.org/wiki/Cython</a>
</li>

<li>Cython (GitHub)<br />
<a href="https://github.com/cython/cython">https://github.com/cython/cython</a>
</li>

<li>PyPy (home page)<br />
<a href="https://pypy.org/">https://pypy.org/</a>
</li>

<li>PyPy (dokumentace)<br />
<a href="http://doc.pypy.org/en/latest/">http://doc.pypy.org/en/latest/</a>
</li>

<li>Nuitka<br />
<a href="https://github.com/Nuitka/Nuitka">https://github.com/Nuitka/Nuitka</a>
</li>

<li>SIMD Autovectorization in Numba<br />
<a href="https://tbetcke.github.io/hpc_lecture_notes/simd.html">https://tbetcke.github.io/hpc_lecture_notes/simd.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

