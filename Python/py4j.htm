<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Komunikace mezi Pythonem a Javou s využitím nástroje py4j</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>


<body>

<h1>Komunikace mezi Pythonem a Javou s využitím nástroje py4j</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku si popíšeme potenciálně velmi užitečný projekt nazvaný py4j. Tento nástroj zajišťuje obousměrnou komunikaci na úrovni zdrojového kódu mezi Pythonem a programovacím jazykem Java. Umožňuje tak propojení dvou možná nejrozsáhlejších a nejpropracovanějších ekosystémů v oblasti IT.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Komunikace mezi Pythonem a Javou s&nbsp;využitím nástroje py4j</a></p>
<p><a href="#k02">2. Propojení staticky typovaného a kompilovaného jazyka s&nbsp;jazykem skriptovacím</a></p>
<p><a href="#k03">3. Instalace projektu py4j</a></p>
<p><a href="#k04">4. Příprava brány na straně JVM</a></p>
<p><a href="#k05">5. Překlad a spuštění brány &ndash; nastavení proměnné prostředí <strong>CLASSPATH</strong></a></p>
<p><a href="#k06">6. Port, který brána používá ve výchozím nastavení</a></p>
<p><a href="#k07">7. Zavolání metody definované v&nbsp;Javě z&nbsp;Pythonu</a></p>
<p><a href="#k08">8. Aplikace s&nbsp;několika otevřenými branami</a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">15. Alternativní řešení propojení Pythonu s&nbsp;ekosystémem Javy</a></p>
<p><a href="#k16">*** 16. JPype</a></p>
<p><a href="#k17">*** 17. Python na GraalVM</a></p>
<p><a href="#k18">*** 18. Jython</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Komunikace mezi Pythonem a Javou s&nbsp;využitím nástroje py4j</h2>

<p>Obor informatiky se, ostatně podobně jako i prakticky všechny další obory,
potýká s&nbsp;problémy, které vyplývají z&nbsp;nedostatečné standardizace a
unifikace. Tento stav nemusí být nutně špatný, protože může vést (a mnohdy
taktéž vede) k&nbsp;rychlejšímu vývoji nových technologií, ovšem na druhou
stranu dochází k&nbsp;situacím, kdy je například nutné (či alespoň vhodné)
propojit například dva ekosystémy, jenž se vyvíjely nezávisle na sobě.
Příkladem, kterým se budeme zabývat v&nbsp;dnešním článku, je dvojice
rozsáhlých a taktéž propracovaných ekosystémů. První ekosystém je postaven
okolo programovacího jazyka Java, či spíše okolo jeho virtuálního stoje (který
má podle mého názoru v&nbsp;současnosti již mnohem větší význam, než samotný
jazyk). A druhý ekosystém je postaven okolo Pythonu. V&nbsp;obou ekosystémech
se mnohdy řeší stejné problémy, ovšem jinými nástroji: Maven/pip, CLASSPATH a
class loadery/virtuální prostředí, profily, JNI/FFI atd. (a jak je již
z&nbsp;tohoto porovnání patrné, nejedná se mnohdy o náhrady 1:1).</p>

<p>Přitom je mnohdy žádoucí, aby bylo umožněno v&nbsp;projektech využívat jak
programovací jazyk Python, tak i Javu popř.&nbsp;jiné jazyky postavené nad
virtuálním strojem Javy. Samozřejmě je možné zajistit komunikaci například na
bázi REST API, systému front popř.&nbsp;systému <i>publish-subscribe</i> (MQTT
apod.), ovšem pro programátory je jednodušší přímá komunikace mezi programovým
kódem napsaným v&nbsp;Pythonu a kódem vytvořeným v&nbsp;Javě. A jedno
z&nbsp;řešení je nabízeno právě projektem <i>py4j</i>, jenž umožňuje
obousměrnou komunikaci mezi Pythonem a Javou. Nutno ovšem poznamenat, že
existují i další řešení postavené na odlišných technologiích. Příkladem může
být Python pro GraalVM, což je velmi užitečný projekt představený <a
href="#k17">v&nbsp;sedmnácté kapitole</a>. A druhým příkladem je <i>Jython</i>,
tedy reimplementace jazyka Python pro JVM. S&nbsp;tímto projektem jsme se již
na stránkách Roota setkali, takže si jeho existenci pouze krátce připomeneme <a
href="#18">v&nbsp;kapitole číslo 18</a>.</p>

<p>Díky projektu <i>py4j</i> může skript napsaný v&nbsp;Pythonu přistupovat ke
třídám, objektům a atributům vytvořeným v&nbsp;Javě a naopak. Skript
v&nbsp;Pythonu přitom běží nad klasickým CPythonem (možná bude funkční i
v&nbsp;PyPy) a kód psaný v&nbsp;Javě je zkompilován do standardního bajtkódu
JVM a spuštěn nad JVM. Komunikace probíhá s&nbsp;využitím protokolu TCP, a to
při výchozím nastavení pouze na lokální úrovni. Podrobnosti o použitých portech
a o možnosti komunikace s&nbsp;větším množstvím JVM (například) budou zmíněny
v&nbsp;navazujících kapitolách.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Propojení staticky typovaného a kompilovaného jazyka s&nbsp;jazykem skriptovacím</h2>

<p><i>&bdquo;Interview Guido van Rossum: “I'd rather write code than
papers.”&ldquo;</i></p>

<p>Z&nbsp;obecného pohledu je možné říci, že kombinace striktně typovaného a
většinou i překládaného programovacího jazyka s&nbsp;jazykem dynamicky
typovaným, jenž se používá ve formě &bdquo;lepidla&ldquo; (<i>glue</i>), bývá i
jen u mírně rozsáhlejších systémů velmi úspěšná. Jako typický příklad se mnohdy
uvádí samotný koncept UNIXu a tedy i klasického Linuxu &ndash; jádro, knihovny
i základní nástroje jsou naprogramovány v&nbsp;typovaném a překládaném jazyku
(i když z&nbsp;historických důvodů nikoli v&nbsp;silně typovaném jazyku),
zatímco jako &bdquo;lepidlo&ldquo; slouží skripty psané v&nbsp;nějakém shellu.
Navíc je rozhraní UNIXu navrženo takovým způsobem, že není dopředu stanoveno, o
jaký shell se musí jednat. Typicky se sice jedná o CSH, BASH, KSH apod., ovšem
stejně dobře by bylo možné použít například jazyk <i>Rexx</i>, s&nbsp;mírnými
problémy Python, <a
href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">Babashku</a>
atd. atd. Ovšem skriptovací jazyky, resp.&nbsp;rozhraní pro ně, jsou součástí i
mnoha dalších úspěšných aplikací, od Microsoft Office přes AutoCAD a GIMP po
(řekněme) <a
href="https://docs.blender.org/api/current/info_overview.html">Blender</a>.</p>

<p><a href="https://pypl.github.io/PYPL.html">Nejpoužívanějším</a>
vysokoúrovňovým dynamicky typovaným jazykem je v&nbsp;současnosti programovací
jazyk Python, jenž vznikl na samotném začátku devadesátých let minulého
století. Z&nbsp;mnoha pohledů se jednalo o důležitý mezník v&nbsp;rozvoji IT,
protože právě tehdy se začala stále více rozšiřovat myšlenka, že programovací
jazyky určené <i>pro vývoj plnohodnotných aplikací</i> lze zhruba rozdělit do
dvou kategorií &ndash; překládané systémové jazyky a jazyky skriptovací.
Samozřejmě, že se skriptovací jazyky používaly i před tímto obdobím, ale
většinou se jednalo o relativně primitivní formy předpisů pro dávkové úlohy
(výjimkou je například již zmíněný jazyk <i>Rexx</i>, jehož vyjadřovací
prostředky již byly na vysoké úrovni) a převažoval názor, že plnohodnotné
aplikace musí být psány v&nbsp;překládaných jazycích, tedy typicky
v&nbsp;jazycích ALGOLské větvě se statickým typováním (schválně nepíšu se
silným typováním, to je sice související, ovšem odlišná vlastnost).</p>

<p>V&nbsp;průběhu devadesátých let se tedy zpočátku mírně opovrhované
skriptovací jazyky staly mnohdy nedílnou součástí mnoha profesionálních
aplikací. Celý vývoj a s&nbsp;ním související myšlenkový posun byl nakonec
shrnut ve slavném článku <a
href="https://web.stanford.edu/~ouster/cgi-bin/home.php">Johna Ousterhouta</a>
&bdquo;Scripting: Higher Level Programming for the 21st Century&ldquo;, v&nbsp;
němž se opakovala myšlenka na souběžné a koopertivní použití dvou jazyků
&ndash; systémového a skriptovacího.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace projektu py4j</h2>

<p>Před vyzkoušením možností, které jsou nabízeny projektem <i>py4j</i>
samozřejmě musíme tento projekt nainstalovat. K&nbsp;tomuto účelu se používá
standardní pythonovský správce balíčků <strong>pip</strong>
resp.&nbsp;<strong>pip3</strong>. Nenechte se ovšem zmýlit, protože
<strong>pip</strong> ve skutečnosti nenainstaluje pouze část určenou přímo pro
jazyk Python, ale i Java archiv (neboli JAR) obsahující tu část <i>py4j</i>,
která musí běžet v&nbsp;JVM. Tento Java archiv je poněkud &bdquo;skrytý&ldquo;,
což bude později vyžadovat modifikaci proměnné prostředí
<strong>CLASSPATH</strong>, popř.&nbsp;přesun tohoto Java archivu na jiné místo
(postačuje samozřejmě pouze vytvoření symbolického odkazu &ndash;
<i>symlinku</i>).</p>

<p><div class="rs-tip-major">Poznámka: to, že <strong>pip</strong> dokáže kromě
kódu napsaného v&nbsp;Pythonu instalovat i další knihovny, Java archivy atd.
vlastně není nic překvapivého, protože i mnohé další balíčky pro jazyk Python
vyžadují nativní části, typicky překládané s&nbsp;využitím C či C++.</div></p>

<p>Vraťme se nyní k&nbsp;instalaci <i>py4j</i>. Ta se provede tímto
příkazem:</p>

<pre>
$ <strong>pip3 install --user py4j</strong>
&nbsp;
Collecting py4j
  Using cached https://files.pythonhosted.org/packages/30/42/25ad191f311fcdb38b750d49de167abd535e37a144e730a80d7c439d1751/py4j-0.10.9.1-py2.py3-none-any.whl
    100% |████████████████████████████████| 204kB 1.3MB/s 
Installing collected packages: py4j
Successfully installed py4j-0.10.9.1
</pre>

<p>Po provedení tohoto příkazu by měla být v&nbsp;Pythonu přímo dostupná
pythonovská část projektu <i>py4j</i>, což si ostatně můžeme ihned otestovat
v&nbsp;interaktivní smyčce REPL Pythonu:</p>

<pre>
&gt;&gt;&gt; <strong>from py4j.java_gateway import JavaGateway</strong>
&nbsp;
&gt;&gt;&gt; <strong>help(JavaGateway)</strong>
&nbsp;
Help on class JavaGateway in module py4j.java_gateway:
&nbsp;
class JavaGateway(builtins.object)
 |  A `JavaGateway` is the main interaction point between a Python VM and
 |     a JVM.
 |  
 |  * A `JavaGateway` instance is connected to a `Gateway` instance on the
 |    Java side.
 |  
 |  * The `entry_point` field of a `JavaGateway` instance is connected to
 |    the `Gateway.entryPoint` instance on the Java side.
 |  
 |  * The `java_gateway_server` field of a `JavaGateway` instance is connected
 |    to the `GatewayServer` instance on the Java side.
 |  
 |  * The `jvm` field of `JavaGateway` enables user to access classes, static
 |    members (fields and methods) and call constructors.
 |  
 |  * The `java_process` field of a `JavaGateway` instance is a
 |    subprocess.Popen object for the Java process that the `JavaGateway`
 |    is connected to, or None if the `JavaGateway` connected to a preexisting
 |    Java process (in which case we cannot directly access that process from
 |    Python).
</pre>

<p>Současně by mělo dojít k&nbsp;instalaci již výše zmíněného Java archivu,
který byl na mém systému umístěn do adresáře
<strong>~/.local/share/py4j</strong>:</p>

<pre>
$ <strong>ls -l ~/.local/share/py4j</strong>
&nbsp;
total 128
-rw-rw-r--. 1 ptisnovs ptisnovs 121370 Feb 21 09:21 py4j0.10.9.1.jar
</pre>

<p><div class="rs-tip-major">Poznámka: toto umístění se ovšem může
odlišovat.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příprava brány na straně JVM</h2>

<p>Vyzkoušejme si nyní, jakým způsobem je vlastně navázána komunikace mezi
Pythonem na jedné straně a virtuálním strojem programovacího jazyka Java na
straně druhé. Nejdříve vytvoříme jednoduchý projekt v&nbsp;Javě, který bude
mj.&nbsp;sloužit i jako server, k&nbsp;němuž se následně připojíme
z&nbsp;Pythonu. V&nbsp;tomto projektu je definován takzvaný <i>vstupní bod
(entry point)</i>, jenž mj.&nbsp;definuje objekty, metody atd. dosažitelné
z&nbsp;Pythonu. Dále je spuštěn server (který se nazývá <i>gateway</i>):</p>

<pre>
import py4j.GatewayServer;
&nbsp;
public class <strong>Gateway1</strong> {
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        System.out.println("Starting gateway server");
        GatewayServer gatewayServer = new <u>GatewayServer(new Gateway1())</u>;
        <u>gatewayServer.start();</u>
        System.out.println("gateway server started");
    }
&nbsp;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že konstruktoru třídy
<strong>GatewayServer</strong> je předána instance (libovolné) třídy, která
tvoří vstupní bod (<i>entry point</i>) pro Python. V&nbsp;dalším textu si
ukážeme, že je možné předat i jiný objekt &ndash; v&nbsp;tomto příkladu totiž
může dojít k&nbsp;nepochopení toho, že třída <strong>Gateway1</strong> sice
obsahuje statickou metodu <strong>main</strong>, což ovšem nijak nesouvisí či
nemusí souviset se vstupním bodem.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad a spuštění brány &ndash; nastavení proměnné prostředí <strong>CLASSPATH</strong></h2>

<p>Při překladu je nutné na <i>CLASSPATH</i> přidat i Java archiv
s&nbsp;implementací <strong>py4j</strong>. Pokud je tento archiv
v&nbsp;aktuálním adresáři (což většinou nebude):</p>

<pre>
$ <strong>javac -cp py4j0.10.9.1.jar Gateway1.java</strong>
</pre>

<p>Samozřejmě můžete specifikovat celou cestu ke zmíněnému Java archivu:</p>

<pre>
$ <strong>javac -cp ~/.local/share/py4j/py4j0.10.9.1.jar Gateway1.java</strong>
</pre>

<p>Popř.&nbsp;je možné nastavit proměnnou prostředí <strong>CLASSPATH</strong>,
což je možná nejrozumnější řešení, neboť tuto proměnnou můžete měnit například
i z&nbsp;integrovaných vývojových prostředí atd.:</p>

<pre>
$ <strong>export CLASSPATH=~/.local/share/py4j/py4j0.10.9.1.jar:$CLASSPATH</strong>
$ <strong>javac Gateway1.java</strong>
</pre>

<p>Stejně je tomu při spuštění aplikace. V&nbsp;případě, že na <i>CLASSPATH</i>
není nalezen Java archiv s&nbsp;implementací <i>py4j</i>, dojde k&nbsp;chybě
při pokusu o inicializaci aplikace:</p>

<pre>
$ <strong>java Gateway1</strong>
&nbsp;
Starting gateway server
Exception in thread "main" java.lang.NoClassDefFoundError: py4j/GatewayServer
        at Gateway1.main(Gateway1.java:7)
Caused by: java.lang.ClassNotFoundException: py4j.GatewayServer
        at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        ... 1 more
</pre>

<p>Spuštění s&nbsp;explicitním nastavením <i>CLASSPATH</i>:</p>

<pre>
$ <strong>java -cp ~/.local/share/py4j/py4j0.10.9.1.jar:. Gateway1</strong>
</pre>

<p>Spuštění s&nbsp;upravenou proměnnou prostředí
<strong>CLASSPATH</strong>:</p>

<pre>
$ <strong>export CLASSPATH=~/.local/share/py4j/py4j0.10.9.1.jar:$CLASSPATH</strong>
$ <strong>java Gateway1</strong>
</pre>

<p>Po spuštění by se měla vypsat zpráva o tom, že byl spuštěn server
představující bránu (<i>gateway</i>) pro Pythonovskou část aplikace:</p>

<pre>
Starting gateway server
gateway server started
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Port, který brána používá ve výchozím nastavení</h2>

<p>V&nbsp;úvodních kapitolách jsme si řekli, že pro komunikaci mezi Pythonem a
JVM se používá protokol TCP. Zajímavé tedy bude zjistit, jaké porty jsou po
spuštění javovské části obsazeny. K&nbsp;tomuto účelu použijeme nástroj
<strong>netstat</strong> a necháme si vypsat servery využívající TCP. Aktivní
port vytvořené brány je zvýrazněn tučným písmem:</p>

<pre>
$ <strong>netstat -lt</strong>
&nbsp;
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 localhost:ircu-3        0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:sunrpc          0.0.0.0:*               LISTEN     
tcp        0      0 localhost:domain        0.0.0.0:*               LISTEN     
tcp        0      0 localhost.locald:domain 0.0.0.0:*               LISTEN     
tcp        0      0 localhost.locald:domain 0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN     
tcp6       0      0 [::]:sunrpc             [::]:*                  LISTEN     
tcp6       0      0 <strong>localhost:25333</strong>         [::]:*                  LISTEN     
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN     
</pre>

<p><div class="rs-tip-major">Poznámka: jak uvidíme dále, je tento port plně
konfigurovatelný.</div></p>

<p>Vypsat si můžeme i proces, který daný server spustil:</p>

<pre>
$ <strong>netstat -tlp</strong>
&nbsp;
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 localhost:ircu-3        0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:sunrpc          0.0.0.0:*               LISTEN      -                   
tcp        0      0 localhost:domain        0.0.0.0:*               LISTEN      -                   
tcp        0      0 localhost.locald:domain 0.0.0.0:*               LISTEN      -                   
tcp        0      0 localhost.locald:domain 0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN      -                   
tcp6       0      0 [::]:sunrpc             [::]:*                  LISTEN      -                   
tcp6       0      0 <strong>localhost:25333</strong>         [::]:*                  LISTEN      21828/java          
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN      -                   
</pre>

<p>Informaci o tom, jaké aplikaci odpovídá proces s&nbsp;PID 21828 nám podá
nástroj <strong>jps</strong>:</p>

<pre>
$ <strong>jps</strong>
&nbsp;
29362 Jps
21828 Gateway1
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zavolání metody definované v&nbsp;Javě z&nbsp;Pythonu</h2>

<p>Nyní si ukažme způsob volání metody definované v&nbsp;Javě ze skriptu
napsaného v&nbsp;Pythonu. Vytvoříme si nejprve novou javovskou aplikaci, která
bude mj.&nbsp;obsahovat i metodu nazvanou <strong>getMessage</strong>, která je
bez parametrů, ovšem vracející řetězec. Vstupním bodem bude instance třídy
<strong>Gateway2</strong>, ve které je metoda <strong>getMessage</strong>
deklarována:</p>

<pre>
import py4j.GatewayServer;
&nbsp;
public class <strong>Gateway2</strong> {
&nbsp;
    public String <strong>getMessage</strong>() {
        return "Hello from Java!";
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        System.out.println("Starting gateway server");
        GatewayServer gatewayServer = new GatewayServer(<strong>new Gateway2()</strong>);
        gatewayServer.start();
        System.out.println("gateway server started");
    }
&nbsp;
}
</pre>

<p>Tuto část přeložíme a spustíme naprosto stejným způsobem, jako první
aplikaci.</p>

<p><div class="rs-tip-major">Poznámka: pokud první aplikace stále poběží,
vypíše se chyba informující o tom, že port 25333 je již obsazený.</div></p>

<p>Pythonovský skript bude vypadat takto:</p>

<pre>
from py4j.java_gateway import JavaGateway
&nbsp;
gateway = <strong>JavaGateway()</strong>
&nbsp;
message = gateway.entry_point.<strong>getMessage()</strong>
print(message)
&nbsp;
input("Press Enter to continue...")
</pre>

<p>Ve skriptu je zkonstruován objekt typu <strong>JavaGateway</strong>, který
zajistí komunikaci s&nbsp;JVM. Ihned poté již můžeme zavolat metodu
<strong>getMessage</strong>, a to takovým způsobem, jakoby se jednalo o metodu
objektu <strong>gateway.entry_point</strong>. Výsledkem bude standardní
Pythonovský řetězec &ndash; i když interně muselo dojít k&nbsp;převodům, neboť
řetězce v&nbsp;Pythonu jsou uloženy zcela odlišným způsobem, než je tomu
v&nbsp;Javě (viz též <a
href="https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/">Interní
reprezentace řetězců v různých jazycích: od počítačového pravěku po
současnost</a>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Aplikace s&nbsp;několika otevřenými branami</h2>

<p>Díky tomu, že komunikace mezi Pythonem (resp.&nbsp;přesněji řečeno aplikací
naprogramovanou v&nbsp;Pythonu) a virtuálním strojem jazyka Java probíhá přes
protokol TCP (každá strana zde vystupuje v&nbsp;roli serveru a současně i
klienta), je možné poměrně dynamicky měnit propojení Python &rarr; Java a
naopak. V&nbsp;praxi to například znamená, že jeden skript naprogramovaný
v&nbsp;Pythonu se může připojovat k&nbsp;více virtuálním strojům Javy a
postupně či dokonce v&nbsp;jeden okamžik s&nbsp;nimi komunikovat. A podobně lze
zajistit, aby aplikace psaná v&nbsp;Javě byla ovládána více pythonovskými
skripty, pokaždé na jiném portu a tedy nezávisle na sobě. Musíme samozřejmě
zajistit, aby spolu komunikovaly ty správné části aplikace &ndash; a přesně
k&nbsp;tomu slouží volba portů. Standardně jsou používány dva porty. Port
<strong>25333</strong> je otevírán na straně JVM a připojuje se k&nbsp;němu
skript napsaný v&nbsp;Pythonu. A naopak port <strong>25332</strong> je otevírán
na straně Pythonu a používá se pro komunikaci ze strany javovské aplikace.</p>

<p>Podívejme se nyní na způsob volby portů. Upravíme nejdříve tu stranu
aplikace, která je naprogramovaná v&nbsp;Javě. Volba portu se provádí při
konstrukci brány:</p>

<pre>
GatewayServer gatewayServer1 = new GatewayServer(<strong>new EntryPoint1(), 20001</strong>);
gatewayServer1.start();
</pre>

<p>Upravená aplikace otevře dva porty a pro každý port použije vlastní
<i>gateway</i>, přičemž každá z&nbsp;těchto bran bude mít nakonfigurován jiný
přístupový bod neboli <i>entry point</i>. Zde tedy opět můžeme vidět značnou
flexibilitu použitého řešení:</p>

<pre>
import py4j.GatewayServer;
&nbsp;
class <strong>EntryPoint1</strong> {
    public String getMessage() {
        return "Hello from entrypoint #1";
    }
}
&nbsp;
class <strong>EntryPoint2</strong> {
    public String getMessage() {
        return "Hello from entrypoint #2";
    }
}
&nbsp;
public class <strong>Gateway3</strong> {
&nbsp;
    public static void main(String[] args) {
        System.out.println("Starting two gateway servers");
&nbsp;
        GatewayServer gatewayServer1 = new GatewayServer(<strong>new EntryPoint1(), 20001</strong>);
        gatewayServer1.start();
&nbsp;
        GatewayServer gatewayServer2 = new GatewayServer(<strong>new EntryPoint2(), 20002</strong>);
        gatewayServer2.start();
&nbsp;
        System.out.println("gateway servers started");
    }
&nbsp;
}
</pre>

<p>Nyní tento demonstrační příklad běžným způsobem přeložíme a spustíme (již
známým způsobem).</p>

<p>Zajímavé bude zjistit, jaké porty jsou nyní obsazeny. K&nbsp;tomuto účelu
opět použijeme nástroj <strong>netstat</strong>. Aktivní porty obou bran jsou
zvýrazněny tučným písmem:</p>

<pre>
$ <strong>netstat -ntl</strong>
&nbsp;
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 127.0.0.1:6667          0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN     
tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN     
tcp        0      0 192.168.130.1:53        0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp6       0      0 <strong>127.0.0.1:20001</strong>         :::*                    LISTEN     
tcp6       0      0 <strong>127.0.0.1:20002</strong>         :::*                    LISTEN     
tcp6       0      0 :::111                  :::*                    LISTEN     
tcp6       0      0 :::22                   :::*                    LISTEN     
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
from py4j.java_gateway import JavaGateway, GatewayParameters
&nbsp;
gateway1 = JavaGateway(gateway_parameters=GatewayParameters(port=20001))
gateway2 = JavaGateway(gateway_parameters=GatewayParameters(port=20002))
&nbsp;
message = gateway1.entry_point.getMessage()
print(message)
&nbsp;
message = gateway2.entry_point.getMessage()
print(message)
&nbsp;
input("Press Enter to continue...")
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Alternativní řešení propojení Pythonu s&nbsp;ekosystémem Javy</h2>

<p>Kromě projektu <i>py4j</i> vzniklo i několik dalších projektů, jejichž cílem
je umožnění využití ekosystému programovacího jazyka Java z&nbsp;Pythonu. Tyto
projekty je možné podle použité technologie rozdělit do dvou kategorií. První
kategorii již známe &ndash; je to propojení běžného Pythonu (typicky CPythonu
popř.&nbsp;PyPi) s&nbsp;virtuálním strojem Javy s&nbsp;využitím vhodného
komunikačního mechanismu. Do této kategorie spadá jak již popsaný <i>py4j</i>,
tak i <a href="#k16">dále alespoň ve stručnosti zmíněný</a> projekt nazvaný
<i>JPype</i> (ovšem vlastní komunikace je řešena odlišnými prostředky). A do
druhé kategorie lze zařadit implementaci Pythonu buď přímo pro klasický
virtuální stroj Javy (<i>Jython</i>) nebo jeho úprava pro běh nad
<i>GraalVM</i>, což je podle mého názoru technologie, která by se
v&nbsp;budoucnu měla prosadit do větší míry, než je tomu v&nbsp;současnosti.
Integrace do GraalVM je zmíněna <a href="#k17">v&nbsp;sedmnácté kapitole</a> a
<a href="#k18">v&nbsp;kapitole osmnácté</a> si připomeneme existenci
<i>Jythonu</i>.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. JPype</h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Python na GraalVM</h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Jython</h2>

<p>Jython je jméno implementace programovacího jazyka Python určená pro běh ve virtuálním stroji jazyka Java (<i>JVM &ndash; Java Virtual Machine</i>). A nejenom to &ndash; aplikace psané v&nbsp;Jythonu mohou <i>kooperovat</i> s&nbsp;třídami a rozhraními vytvořenými v&nbsp;Javě, což je pro mnoho aplikací velmi výhodné, protože s&nbsp;rostoucí složitostí moderních aplikací je většinou zapotřebí mít k&nbsp;dispozici vhodný skriptovací jazyk sloužící jako &bdquo;lepidlo&ldquo; (<i>glue</i>) mezi jednotlivými bloky, z&nbsp;nichž se aplikace skládá (viz slavný a ve své době dosti provokující <a href="https://users.ece.utexas.edu/~adnan/top/ousterhout-scripting.pdf">Ousterhoutův článek o skriptovacích jazycích</a>). Jython ovšem samozřejmě není dokonalý. Jednou z&nbsp;jeho nevýhod je fakt, že je stále postaven na dnes již obstarožním Pythonu 2, druhou nevýhodou pak ta skutečnost, že se jedná o dosti pomalý jazyk. Tato pomalost se negativně projeví zejména při výpočtech a někdy i při manipulaci s&nbsp;rozsáhlými datovými strukturami, ovšem u aplikací, v&nbsp;nichž převládají I/O operace se nemusí jednat o kritický nedostatek.</p>

*** image ***
<p><i>Obrázek 7: Logo programovacího jazyka Jython.</i></p>

<p><div class="rs-tip-major">Poznámka: na druhou stranu je nutné poznamenat, že v&nbsp;době, kdy Jython vznikl (pod jménem JPython již v&nbsp;roce 1999, pod novým jménem vydán před dvaceti lety, tedy v&nbsp;roce 2001), se kromě samotné Javy jednalo o nejpropracovanější programovací jazyk určený pro běh na JVM. I z&nbsp;toho důvodu byl relativně často využíván pro skriptování v&nbsp;různých enterprise systémech, například i ve <a href="https://www.informit.com/store/websphere-application-server-administration-using-jython-9780137009527">WebSphere</a>, <a href="https://docs.oracle.com/cd/E12839_01/web.1111/e13715/using_wlst.htm#WLSTG118">Oracle WebLogicu</a> atd. O to problematičtější se zdá být praktické zastavení vývoje Jythonu.</div></p>

<p>V&nbsp;úvodním odstavci jsme se zmínili o tom, že Jython je dosti pomalou variantou Pythonu. To je ostatně možné relativně snadno dokázat sadou benchmarků, které si dnes popíšeme pouze ve velké stručnosti, protože se nejedná o hlavní téma článku. Všechny benchmarky byly spuštěny v&nbsp;těchto interpretrech Pythonu:</p>

<ol>
<li>Jython 2.7.0</li>
<li>Python 2.7.14 (dnes již zastaralý)</li>
<li>Python 3.6.3 (dnes již zastaralý)</li>
</ol>

<p><a href="https://github.com/tisnik/jython-examples/blob/master/benchmark1/mandelbrot.py">První benchmark</a> provádí prakticky jen výpočty s&nbsp;výpisem výsledku výpočtů na standardní výstup. Ten je přesměrován do souboru, protože výsledkem výpočtů jsou bitmapy ve formátu <i>Portable Pixel Map</i> (viz [<a href="https://www.root.cz/clanky/graficke-formaty-ve-znameni-unixu/#k06">1</a>]).

*** image ***
<p><i>Obrázek XX: Výsledky prvního benchmarku vynesené do grafu.</i></p>

<p>Vzhledem k&nbsp;tomu, že <a href="https://docs.python.org/3.5/reference/datamodel.html#the-standard-type-hierarchy">Python podporuje i práci s&nbsp;komplexními čísly</a>, si můžeme benchmark ještě více upravit, a to takovým způsobem, aby se v&nbsp;něm všechny výpočty prováděly právě nad typem <i>complex</i>. Zajímavé bude změření a porovnání rychlosti výpočtů, protože samotný virtuální stroj Javy primitivní typ &bdquo;komplexní číslo&ldquo; nezná a tím pádem ani nepodporuje. Výsledkem bude tento <a href="https://github.com/tisnik/jython-examples/blob/master/benchmark2/mandelbrot_complex.py">zdrojový kód</a>.</p>

*** image ***
<p><i>Obrázek 10: Výsledky druhého benchmarku vynesené do grafu.</i></p>

<p>Ve skutečnosti však mnoho v&nbsp;současnosti provozovaných aplikací neprovádí intenzivní výpočty s&nbsp;numerickými hodnotami, ale většina strojového času se stráví prováděním zcela odlišných operací. Typicky se zpracovávají řetězce popř.&nbsp;se intenzivně pracuje s&nbsp;kolekcemi (v&nbsp;Pythonu typicky se seznamy, slovníky a množinami). Nesmíme zapomenout ani na serializaci a deserializaci dat (JSON, XML) tak typické pro webové služby, aplikace s&nbsp;grafickým uživatelským rozhraním či na přístup k&nbsp;databázím. Pojďme si tedy ukázat další dva odlišně pojaté benchmarky. Ve skutečnosti se jedná o takzvané &bdquo;mikrobenchmarky&ldquo; zaměřené pouze na jedinou operaci, což je samozřejmě odlišné od reálných aplikací, ovšem pro základní porovnání mohou být i mikrobenchmarky použitelné (a to zejména ve chvíli, kdy naměřené hodnoty budou výrazně odlišné).</p>

<p>V&nbsp;pořadí již třetí benchmark je po implementační stránce skutečně velmi jednoduchý. Je v&nbsp;něm totiž deklarována funkce, které se předá celé kladné číslo <strong>n</strong> a výsledkem je řetězec obsahující znaky &bdquo;0 1 2 ... n&ldquo;. Tento benchmark tedy &ndash; alespoň teoreticky &ndash; zkoumá rychlost provádění tří operací:</p>

<ol>
<li>Převod celého čísla na řetězec (provedeno celkem n-krát)</li>
<li>Spojení (konkatenace) dvou řetězců (s&nbsp;kopií znaků druhého řetězce do řetězce prvního, opět provedeno n-krát)</li>
<li>Činnost automatického správce paměti (<i>garbage collector</i>)</li>
</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů určených pro
Python 3 a Javu od verze 1.8 byly uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th>#</th><th>Jméno souboru</th><th>Stručný popis souboru</th><th>Cesta</th></tr>
<tr><td>1</td><td>Gateway1.java</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/Gateway1.java">https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/Gateway1.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>Gateway2.java</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/Gateway2.java">https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/Gateway2.java</a></td></tr>
<tr><td>3</td><td>UseGateway2.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/UseGateway2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/UseGateway2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>Gateway3.java</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/Gateway3.java">https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/Gateway3.java</a></td></tr>
<tr><td>5</td><td>UseGateway3.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/UseGateway3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/UseGateway3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>Gateway4.java</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/Gateway4.java">https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/Gateway4.java</a></td></tr>
<tr><td>7</td><td>UseGateway4.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/UseGateway4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py4j/UseGateway4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Welcome to Py4J<br />
<a href="https://www.py4j.org/index.html">https://www.py4j.org/index.html</a>
</li>

<li>Getting Started with Py4J<br />
<a href="https://www.py4j.org/getting_started.html">https://www.py4j.org/getting_started.html</a>
</li>

<li>py4j 0.10.9.2 na PyPi<br />
<a href="https://pypi.org/project/py4j/">https://pypi.org/project/py4j/</a>
</li>

<li>PATH and CLASSPATH<br />
<a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">https://docs.oracle.com/javase/tutorial/essential/environment/paths.html</a>
</li>

<li>Modern High-Performance Python<br />
<a href="https://www.graalvm.org/python/">https://www.graalvm.org/python/</a>
</li>

<li>Moving from Jython to GraalVM<br />
<a href="https://medium.com/graalvm/moving-from-jython-to-graalvm-cf52c4af6106">https://medium.com/graalvm/moving-from-jython-to-graalvm-cf52c4af6106</a>
</li>

<li>Scripting: Higher Level Programmingfor the 21st Century<br />
<a href="https://users.ece.utexas.edu/~adnan/top/ousterhout-scripting.pdf">https://users.ece.utexas.edu/~adnan/top/ousterhout-scripting.pdf</a>
</li>

<li>Rediscovering  Ousterhout’s  Dichotomy  in  the  21st Century while Developing and Deploying Software for Set-Theoretic Empirical Analysis:From R to Python/Qt to OCaml and Tcl/Tk<br />
<a href="https://www.tcl.tk/community/tcl2019/assets/talk167/Slides.pdf">https://www.tcl.tk/community/tcl2019/assets/talk167/Slides.pdf</a>
</li>

<li>WebSphere Application Server Administration Using Jython<br />
<a href="https://www.informit.com/store/websphere-application-server-administration-using-jython-9780137009527">https://www.informit.com/store/websphere-application-server-administration-using-jython-9780137009527</a>
</li>

<li>Introduction to the Python implementation for GraalVM<br />
<a href="https://medium.com/graalvm/how-to-contribute-to-graalpython-7fd304fe8bb9">https://medium.com/graalvm/how-to-contribute-to-graalpython-7fd304fe8bb9</a>
</li>

<li>GraalVM: Python Quick Start<br />
<a href="https://www.graalvm.org/python/quickstart/">https://www.graalvm.org/python/quickstart/</a>
</li>

<li>GraalVM Python: Interoperability<br />
<a href="https://github.com/oracle/graalpython/blob/master/docs/user/Interoperability.md">https://github.com/oracle/graalpython/blob/master/docs/user/Interoperability.md</a>
</li>

<li>Py4j na Stack Overflow<br />
<a href="https://stackoverflow.com/tags/py4j/info">https://stackoverflow.com/tags/py4j/info</a>
</li>

<li>Py4J 0.8.2.1 Released<br />
<a href="https://py4j.wordpress.com/">https://py4j.wordpress.com/</a>
</li>

<li>PySpark<br />
<a href="https://databricks.com/glossary/pyspark">https://databricks.com/glossary/pyspark</a>
</li>

<li>PySpark Internals (Outdated)<br />
<a href="https://cwiki.apache.org/confluence/display/SPARK/PySpark+Internals">https://cwiki.apache.org/confluence/display/SPARK/PySpark+Internals</a>
</li>

<li>JPype<br />
<a href="http://jpype.sourceforge.net/index.html">http://jpype.sourceforge.net/index.html</a>
</li>

<li>JPype1 1.2.1 na PyPi<br />
<a href="https://pypi.org/project/JPype1/">https://pypi.org/project/JPype1/</a>
</li>

<li>Interní reprezentace řetězců v různých jazycích: od počítačového pravěku po současnost<br />
<a href="https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/">https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

