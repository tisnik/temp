<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Sledování správy paměti v Pythonu s využitím nástroje objgraph</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Sledování správy paměti v Pythonu s využitím nástroje objgraph</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Sledování správy paměti v&nbsp;Pythonu s&nbsp;využitím nástroje objgraph</a></p>
<p><a href="#k02">*** 2. Proměnné v&nbsp;Pythonu: jména versus hodnoty</a></p>
<p><a href="#k03">*** 3. Reference na hodnoty</a></p>
<p><a href="#k04">*** 4. Ukázka zjištění referencí na hodnoty</a></p>
<p><a href="#k05">5. Automatická správa paměti v&nbsp;Pythonu</a></p>
<p><a href="#k06">*** 6. Správa paměti založená na počítání referencí</a></p>
<p><a href="#k07">*** 7. Sledovací algoritmus a rozdělení hodnot do generací</a></p>
<p><a href="#k08">*** 8. Cache pro často používané hodnoty</a></p>
<p><a href="#k09">*** 9. &bdquo;Interning&ldquo; řetězců</a></p>
<p><a href="#k10">10. Prealokace paměti pro prvky seznamů a slovníků</a></p>
<p><a href="#k11">11. Uvolňování paměti při mazání prvků</a></p>
<p><a href="#k12">12. Nástroj objgraph</a></p>
<p><a href="#k13">13. Instalace nástroje objgraph</a></p>
<p><a href="#k14">14. Zobrazení grafu referencí</a></p>
<p><a href="#k15">15. Cykly v&nbsp;grafu</a></p>
<p><a href="#k16">*** 16. Grafy se zpětným zjištěním referencí</a></p>
<p><a href="#k17">*** 17. Zjištění počtu objektů v&nbsp;paměti (podle jejich typu)</a></p>
<p><a href="#k18">*** 18. Sledování nově vytvořených hodnot (podle jejich typu)</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Sledování správy paměti v&nbsp;Pythonu s&nbsp;využitím nástroje objgraph</h2>

<p><div class="rs-tip-major">Poznámka: všechny informace zmíněné v&nbsp;tomto
článku se vztahují ke <a href="https://www.python.org/">&bdquo;klasické&ldquo;
implementaci Pythonu</a>, která se nazývá <i>CPython</i>, protože je
naprogramována v&nbsp;céčku (standardní knihovna pak přímo v&nbsp;Pythonu)
&ndash; viz též <a href="https://github.com/python/cpython">zdrojové kódy
CPythonu dostupné na GitHubu</a>. Existuje i mnoho dalších implementací
Pythonu, u nichž se však může používat zcela odlišný způsob správy paměti.
Příkladem může být <a
href="https://mojefedora.cz/jython-aneb-ponekud-opomijeny-programovaci-jazyk-pro-virtualni-stroj-javy/">Jython</a>,
tedy implementace Pythonu pro JVM založená (pochopitelně) přímo na správě
paměti nabízené přímo virtuálním strojem Javy.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Proměnné v&nbsp;Pythonu: jména versus hodnoty</h2>

<p>Před popisem nástrojů a technik, které je možné využít pro sledování správy
paměti v&nbsp;Pythonu je vhodné si připomenout, jakým způsobem se vlastně
v&nbsp;tomto programovacím jazyce pracuje s&nbsp;proměnnými,
popř.&nbsp;s&nbsp;parametry funkcí a metod.</p>

<p>Začněme velmi stručným popisem práce s&nbsp;proměnnými v&nbsp;jazyku C a
v&nbsp;podobně koncipovaných programovacích jazycích, které jsou staticky
typované, překládané a navíc nemají automatickou správu paměti (se všemi
z&nbsp;toho plynoucími důsledky). V&nbsp;C můžeme deklarovat globální proměnné,
proměnné lokální v&nbsp;rámci funkce nebo proměnné lokální v&nbsp;rámci bloku
(ve funkci):</p>

<pre>
int x = 42;
</pre>

<p>Na základě této informace je proměnná uložena v&nbsp;paměti na místě
vybraném překladačem. Konstanty (<strong>const int y = 10;</strong>) jsou
většinou uloženy v&nbsp;kódovém segmentu (ten se ovšem někdy označuje jako
&bdquo;text&ldquo;). Inicializované statické lokální proměnné (<strong>static
int z = 6502;</strong> a inicializované globální (nekonstantní) proměnné jsou
uloženy v&nbsp;datovém segmentu, protože jeho obsah je součástí spustitelného
kódu a proměnné jsou tedy automaticky inicializovány na uživatelem
specifikovanou hodnotu. Ostatní globální proměnné a statické proměnné, tedy ty,
které nejsou inicializovány, jsou uloženy v&nbsp;bss segmentu (<i>block
starting symbol</i>), který je po spuštění aplikace alokován a následně vymazán
nulami, čímž se zajistí chování odpovídající specifikaci programovacího jazyka
C. Zbývají nám lokální (nestatické) proměnné. Ty jsou uloženy na zásobníkovém
rámci alokovaném ve chvíli, kdy je zavolána odpovídající funkce. To, do jaké
oblasti se proměnná uloží, je informace známá již v&nbsp;době překladu, přičemž
překladač taktéž zná typ proměnné, který se v&nbsp;rámci daného bloku nemůže
změnit (a v&nbsp;jiném bloku se bude jednat o jinou proměnnou). Jediná
&bdquo;dynamika&ldquo; spočívá v&nbsp;tom, že lokální (nestatické) proměnné
jsou automaticky vytvářeny popř.&nbsp;rušeny při vstupu a výstupu
z&nbsp;funkce, kde jsou tyto proměnné deklarovány.</p>

<p>Poslední oblastí paměti je <i>halda</i> neboli <i>heap</i>. V&nbsp;této
oblasti je možné <i>explicitně</i> alokovat bloky paměti a získat ukazatel na
daný blok paměti. Problém spočívá v&nbsp;tom, že v&nbsp;C je nutné se
explicitně postarat i o uvolnění paměti.</p>

*** image ***
<p><i>Obrázek 1: Struktura paměti alokované pro běžící program.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Reference na hodnoty</h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ukázka zjištění referencí na hodnoty</h2>


hodnota proměnné je uložena v paměti na místě vybraném překladačem a známém již v době překladu. překladač tedy ví, jak k hodnotě přistupovat
(registry, zásobník atd.)
čtení a zápis proměnné - bez dalších "skrytých" operací
typ - opět známý překladači

v Pythonu je tomu ovšem jinak, protože se zde používá koncept
jméno-reference-objekt. Jméno reprezentuje skutečně jméno
nějakého objektu uloženého v paměti.
Reference představuje jméno nebo kontejner odkazující na jiný objekt.
A konečně objekt. Jde o datovou strukturu uloženou v operační paměti (konkrétně na haldě), která kromě své hodnoty a typu obsahuje i počet referencí, které na něj odkazují. Toto je velký a navíc i koncepční
rozdíl oproti jazykům typu C, které do paměti ukládají pouze hodnotu.
Typ není zapotřebí (zná ho překladač z kódu) a počet referencí není
nutný protože C nemá automatickou správu paměti.

Příklad:
x = 6502
y = x

x ->
y -> 

type: integer
refcount: 2
value: 6502

Jména vs hodnoty
jména nemají přiřazený typ
hodnoty nemají rozsah platnosti (scope)
lokální proměnná = jméno je navázáno na rozsah fukce nebo metody, nelze
ho přímo použít jinde
ovšem to neplatí pro hodnotu



bash-4.4$ python3
Python 3.6.6 (default, Jul 19 2018, 16:29:00) 
[GCC 7.3.1 20180303 (Red Hat 7.3.1-5)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> x = 6502
>>> sys.getrefcount(x)
2
>>> y = x
>>> sys.getrefcount(x)
3
>>> z = y
>>> sys.getrefcount(x)
4
>>> z = 0
>>> sys.getrefcount(x)
3
>>> del y
>>> sys.getrefcount(x)
2

>>> y = x
>>> id(x)
139646852357712
>>> id(y)
139646852357712
>>> x is y
True
>>> sys.getsizeof(x)
28

>>> x=6502
>>> y=6502
>>> x is y
False
>>> sys.getrefcount(x)
2
>>> sys.getrefcount(y)
2

Cache s často používanými objekty

>>> x=1
>>> y=1
>>> x is y
True
>>> sys.getrefcount(x)
898
>>> sys.getrefcount(y)
898

interning strings
vlastne tabulka s retezci, minimalne vsechny retezce primo zapsne v kodu
attribut trid i objketu


list preallocation
append bez realloc  - nekdy
shrink az u <1/2 alokovaneho prsotoru

memory_profiler

dvě skupiny objektů v pythonu
- jednoduché objekty, čísla, řetězce atd.
- kontejnery, tedy seznamy, slovníky a třídy (i ty definované uživatelem)

del nemaže objekt. pouze sníží počet referencí o jedničku a odstraní jméno, které na objekt odkazuje

tatkéž při opuštění funkce, ve které objekt vznikl (a nevrátili jsme jeho referenci například pomocí return).

co pro globální objekty - jejich refcount nikdy neklesne na nulu pokud se explicitně nevymažou. Proto není vhodné na globální úrovni používat velké objekty (což platí i pro třídy).

Python Names and Values
https://nedbatchelder.com/text/names1.html

finalizery!!!
weak_ref

id

kontejnery v linked listu
cycle detektor je pusteny jednou za cas

v Pythonu se používají dva typy GC
reference counting
tracing

refcounting
jednoduchy
okamzite uvolneni pameti

- nutno uchovavat dalsi atribut
- kazde prirazeni modifikuje minimalne jeden refcount
- neni thread safe
- nelze detekovat cyklické reference

tracing = generational
tri generace



<p><a name="k05"></a></p>
<h2 id="k05">5. Automatická správa paměti v&nbsp;Pythonu</h2>

<p>V&nbsp;Pythonu jsou objekty z&nbsp;operační paměti odstraňovány automaticky.
Abychom činnost správce paměti pochopili, je nutné si znovu uvědomit, že
pracujeme se dvěma typy objektů &ndash; se jmény a s&nbsp;hodnotami. Přitom již
víme, že jménům není přiřazen typ hodnot, ovšem na druhou stranu je známý
jejich rozsah platnosti (viditelnosti). Naproti tomu u hodnot sice známe jejich
typ a velikost, ovšem nikoli rozsah platnosti. Je tomu tak z&nbsp;toho důvodu,
že na jednu hodnotu může existovat (a v&nbsp;naprosté většině případů taktéž
existuje) větší počet referencí, takže rozsah platnosti hodnoty &ndash; tedy do
jakého okamžiku je ještě hodnotu nutné držet v&nbsp;operační paměti &ndash;
není možné zjistit jednoduše odvozením viditelnosti jména.</p>

<p>Tento problém je možné řešit mnoha různými správci paměti. V&nbsp;Pythonu
nalezneme dva z&nbsp;nich. První typ správy paměti je založen na takzvaném
<i>počítání referencí</i> (<i>reference counting</i>), což je velmi jednoduchý
systém, který však má určité nedostatky zmíněné <a
href="#k06">v&nbsp;navazující kapitole</a>. Druhý typ správy paměti je založen
na sledovacím (trasovacím) algoritmu, jenž ještě pro zvýšení své efektivity
rozděluje objekty (zde myšleno ve smyslu hodnot uložených v&nbsp;paměti) do tří
generací. Tento typ správce paměti bude zmíněn <a href="#k07">v&nbsp;sedmé
kapitole</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Správa paměti založená na počítání referencí</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Sledovací algoritmus a rozdělení hodnot do generací</h2>




<p><a name="k08"></a></p>
<h2 id="k08">8. Cache pro často používané hodnoty</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. &bdquo;Interning&ldquo; řetězců</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Prealokace paměti pro prvky seznamů a slovníků</h2>

<p>Seznamy a slovníky slouží jako kontejnery pro uložení referencí na další
hodnoty. Tyto reference poněkud nepřesně nazýváme <i>prvky</i>, i když skutečné
hodnoty prvků nejsou přímo v&nbsp;těchto kontejnerech uloženy. Velmi často se
setkáme s&nbsp;tím, že se prvky do seznamů a slovníků přidávají či naopak
ubírají. Aby se zmenšil počet realokací paměti (a tím pádem i nutnosti přesunu
celého kontejneru), jsou tyto kontejnery vytvořeny tak, aby mohly pojmout
několik dalších prvků bez toho, aby bylo nutné při každém přidání realokaci
použít. Toto chování si můžeme ověřit na jednoduchém příkladu, v&nbsp;němž
začínáme s&nbsp;prázdným seznamem, do kterého postupně přidáváme další
prvky:</p>

<pre>
import sys
&nbsp;
l = []
&nbsp;
for i in range(31):
    print(len(l), sys.getsizeof(l))
    l.append(i)
</pre>

<p>Po spuštění tohoto skriptu můžeme sledovat, jak se velikost paměti alokované
pro seznam zvyšuje skokově a pouze ve chvíli, kdy je volná kapacita
naplněna:</p>

<pre>
0 64
<strong>1 96</strong>
2 96
3 96
4 96
<strong>5 128</strong>
6 128
7 128
8 128
<strong>9 192</strong>
10 192
11 192
12 192
13 192
14 192
15 192
16 192
<strong>17 264</strong>
18 264
19 264
20 264
21 264
22 264
23 264
24 264
25 264
<strong>26 344</strong>
27 344
28 344
29 344
30 344
</pre>

<p><div class="rs-tip-major">Poznámka: podobné chování můžeme najít i
v&nbsp;jiných programovacích jazycích. Příkladem mohou být <a
href="https://www.root.cz/clanky/datove-typy-v-programovacim-jazyku-go/#k12">řezy
(<i>slice</i>)</a> použité <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;programovacím
jazyku Go</a>.</div>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Uvolňování paměti při mazání prvků</h2>

<p>Podobně jako kapacita seznamu skokově roste při přidávání prvků, bude se
&ndash; opět na základě ověřeného algoritmu &ndash; seznam, resp.&nbsp;jeho
volná kapacita, zmenšovat ve chvíli, kdy jsou z&nbsp;něho prvky ubírány. Ovšem
vždy se počítá s&nbsp;tím, že prvky mohou být v&nbsp;dalším kroku i přidány,
takže se udržuje určitá volná kapacita na konci seznamu. I toto chování si
můžeme ověřit na demonstračním příkladu:</p>

<pre>
import sys
&nbsp;
l = []
&nbsp;
for i in range(31):
    l.append(i)
&nbsp;
for i in range(31):
    print(len(l), sys.getsizeof(l))
    del l[-1]
</pre>

<p>Můžeme vidět, že se při mazání prvků zpočátku udržuje původní kapacita
(zhruba až na 1/2 zaplněnosti) a teprve poté dochází k&nbsp;realokaci seznamu
v&nbsp;paměti:</p>

<pre>
31 344
30 344
29 344
28 344
27 344
26 344
25 344
24 344
23 344
22 344
21 344
20 344
19 344
18 344
17 344
<strong>16 256</strong>
15 256
14 256
13 256
12 256
<strong>11 208</strong>
10 208
9 208
<strong>8 160</strong>
7 160
6 160
<strong>5 128</strong>
4 128
<strong>3 112</strong>
<strong>2 104</strong>
1 96
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nástroj objgraph</h2>

<p>Pro zobrazení vzájemných vztahů mezi jmény, referencemi a hodnotami lze
použít až překvapivě propracovaný nástroj nazvaný příznačně <i>objgraph</i>.
Tento nástroj se používá jako běžná knihovna programovacího jazyka Python a
umožňuje v&nbsp;jakékoli chvíli získat informace o struktuře haldy (heapu),
tj.&nbsp;jaké objekty a jakého typu jsou zde uloženy. Získat lze i další
důležité informace, například o tom, které objekty byly vytvořeny
v&nbsp;určitém časovém intervalu (mezi voláním dvou funkcí z&nbsp;knihovny)
atd. Některé příklady použití <i>objgraphu</i> budou ukázány
v&nbsp;navazujících kapitolách.</p>

<p>Nástroj <i>objgraph</i> umí kromě textových informací a tabulek zobrazovat i
grafy se zvýrazněním referencí mezi objekty. Pro tento účel je použit balíček
nástrojů nazvaný <i>Graphviz</i>. V&nbsp;tomto balíčku nalezneme především
utilitu nazvanou <strong>dot</strong>, která na základě textové definice
orientovaného či neorientovaného grafu vytvoří rastrový či vektorový obrázek
s&nbsp;grafem, přičemž je možné si zvolit, jaký algoritmus bude použit pro
rozmístění uzlů a hran na vytvořeném obrázku. Textová definice grafu používá
jednoduchý popisný jazyk, který je v&nbsp;současnosti podporován i několika
dalšími nástroji a stává se tak nepsaným standardem pro mnoho programů
pracujících s&nbsp;grafovými strukturami. Pro utilitu <i>Graphviz</i> existuje
i knihovna určená pro <a href="https://www.root.cz/n/python/">programovací
jazyk Python</a> &ndash; viz též <a
href="https://pypi.org/project/graphviz/">https://pypi.org/project/graphviz/</a>;
tento balíček je používán i nástrojem <i>objgraph</i>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instalace nástroje objgraph</h2>

<p>Samotná instalace nástroje <i>objgraph</i> je stejně snadná, jako instalace
jakéhokoli jiného Pythonovského balíčku nabízeného přes <a
href="https://pypi.org/">Python Package Index</a>. Instalaci můžeme provést pro
celý systém:</p>

<pre>
# <strong>pip install objgraph</strong>
&nbsp;
Collecting objgraph
  Downloading https://files.pythonhosted.org/packages/a9/79/9f47706447b9ba0003c0680da4fed1d502adf410e1d953b4d1a5d3486640/objgraph-3.5.0-py2.py3-none-any.whl
Collecting graphviz
  Downloading https://files.pythonhosted.org/packages/64/72/f4f4205db2a58e7a49e8190c0b49e9669d7ecadf6385b5bcdcf910354a6d/graphviz-0.15-py2.py3-none-any.whl
Installing collected packages: graphviz, objgraph
Successfully installed graphviz-0.15 objgraph-3.5.0
</pre>

<p>Nebo pro právě přihlášeného uživatele:</p>

<pre>
$ <strong>pip install objgraph</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se automaticky
doinstaloval i závislý balíček <i>graphviz</i>.</div></p>

<p>Ověření, že je balíček skutečně dostupný:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.8.6 (default, Sep 25 2020, 00:00:00) 
[GCC 10.2.1 20200723 (Red Hat 10.2.1-1)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import objgraph
&gt;&gt;&gt; help(objgraph)
</pre>

<p>Měla by se zobrazit nápověda:</p>

<pre>
Help on module objgraph:
&nbsp;
NAME
    objgraph - Tools for drawing Python object reference graphs with graphviz.
&nbsp;
DESCRIPTION
    You can find documentation online at https://mg.pov.lt/objgraph/
&nbsp;
    Copyright (c) 2008-2017 Marius Gedminas &lt;marius@pov.lt&gt; and contributors
&nbsp;
    Released under the MIT licence.
&nbsp;
FUNCTIONS
    at(addr)
        Return an object at a given memory address.
&nbsp;  
        The reverse of id(obj):
&nbsp;
            &gt;&gt;&gt; at(id(obj)) is obj
            True
&nbsp;
        Note that this function does not work on objects that are not tracked by
        the GC (e.g. ints or strings).
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zobrazení grafu referencí</h2>

<p>Pravděpodobně nejzajímavější funkcí nástroje <i>objgraph</i> je jeho
schopnost zobrazit orientovaný graf s&nbsp;hranami vedoucími od zadaného jména
(typicky jména proměnné nebo parametru funkce popř.&nbsp;metody) až po
konkrétní hodnoty uložené v&nbsp;paměti (viz též <a href="#k02">druhou
kapitolu</a>):</p>

<pre>
Help on function <strong>show_refs</strong> in module objgraph:
&nbsp;
show_refs(objs, max_depth=3, extra_ignore=(), filter=None, too_many=10, highlight=None, filename=None, extra_info=None, refcounts=False, shortnames=True, output=None, extra_node_attrs=None)
    Generate an object reference graph starting at ``objs``.
&nbsp;
    The graph will show you what objects are reachable from ``objs``, directly
    and indirectly.
&nbsp;
    ``objs`` can be a single object, or it can be a list of objects.  If
    unsure, wrap the single object in a new list.
&nbsp;
    ``filename`` if specified, can be the name of a .dot or a image
    file, whose extension indicates the desired output format; note
    that output to a specific format is entirely handled by GraphViz:
    if the desired format is not supported, you just get the .dot
    file.  If ``filename`` and ``output`` is not specified, ``show_refs`` will
    try to display the graph inline (if you're using IPython), otherwise it'll
    try to produce a .dot file and spawn a viewer (xdot).  If xdot is
    not available, ``show_refs`` will convert the .dot file to a
    .png and print its name.
&nbsp;
    ``output`` if specified, the GraphViz output will be written to this
</pre>

<p>Podívejme se nyní na několik okomentovaných ukázek použití této užitečné
funkce.</p>

<p>Proměnná <strong>z</strong> je referencí na řetězec, proto se při volání
funkce <strong>show_refs</strong> vyhodnotí (a zobrazí asi něco jiného, než
bychom očekávali):</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = "Foo"
y = x
z = y
&nbsp;
<i># zobrazení referencí vedoucích až na řetězec "Foo"</i>
objgraph.show_refs(z, filename='objgraph1.png')
</pre>

*** image ***
<p><i>Obrázek 2: Zobrazí se pouze přímo hodnota s&nbsp;řetězcem.</i></p>

<p>Zobrazit můžeme i objekty, které jsou referencovány ze seznamu:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = "Foo"
y = [x, "bar"]
&nbsp;
<i># zobrazení referencí ze seznamu y</i>
objgraph.show_refs(y, filename='objgraph2.png')
</pre>

*** image ***
<p><i>Obrázek 3: Zobrazí se pouze přímo hodnoty s&nbsp;řetězci.</i></p>

<p>Pokud chceme zobrazit, jaké hodnoty jsou dostupné (referencované) přímo ze
seznamu <strong>y</strong>, musíme tento seznam umístit do složených závorek
(předá se tak vlastně reference na seznam):</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = "Foo"
y = [x, "bar"]
&nbsp;
<i># zobrazení referencí na dva řetězce uložené v seznamu</i>
objgraph.show_refs([y], filename='objgraph3.png')
</pre>

*** image ***
<p><i>Obrázek 4: Hodnoty referencované ze seznamu <strong>y</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: toto je nejběžnější použití funkce
<strong>show_refs</strong>.</div></p>

<p>Již poněkud složitější hierarchie hodnot uložených v&nbsp;operační
paměti:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = "Foo"
y = [x, "bar", [x], (x, x), {"x":x}]
&nbsp;
<i># reference u složitějších datových struktur</i>
objgraph.show_refs([x, y], filename='objgraph4.png')
</pre>

*** image ***
<p><i>Obrázek 5: Složitější hierarchie hodnot uložených v&nbsp;operační
paměti.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Cykly v&nbsp;grafu</h2>

<p>Největší užitečnost funkce <strong>show_refs</strong> (vytvářející snadno
pochopitelné grafy) se projeví ve chvíli, kdy je vzájemná provázanost mezi
proměnnými (jmény) a hodnotami složitější, popř.&nbsp;když obsahuje cykly. A
dosažení cyklu je snadné &ndash; můžeme například použít dvojici slovníků,
které na sebe navzájem odkazují:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = {}
y = {}
&nbsp;
<i># prázdné slovníky</i>
objgraph.show_refs([x, y], filename='objgraph5A.png')
&nbsp;
x["1"] = y
&nbsp;
<i># jedna reference</i>
objgraph.show_refs([x, y], filename='objgraph5B.png')
&nbsp;
y["2"] = x
&nbsp;
<i># cyklická reference</i>
objgraph.show_refs([x, y], filename='objgraph5C.png')
&nbsp;
x["a"] = 10
x["b"] = True
x["c"] = False
x["d"] = None
&nbsp;
y["a"] = False
y["b"] = True
y["c"] = False
y["d"] = None
&nbsp;
<i># přidání dalších referencí</i>
objgraph.show_refs([x, y], filename='objgraph5D.png')
</pre>

<p>Význam předchozího programového kódu je pravděpodobně zřejmý, takže se ihned
podívejme, jaké grafy postupně vznikly:</p>

*** image ***
<p><i>Obrázek 6: Dva prázdné slovníky na začátku skriptu.</i></p>

*** image ***
<p><i>Obrázek 7: Prvek jednoho slovníku obsahuje referenci na druhý
slovník.</i></p>

*** image ***
<p><i>Obrázek 8: Vznik cyklu v&nbsp;grafu.</i></p>

*** image ***
<p><i>Obrázek 9: Přidáním dalších hodnot nic nemění na tom, že graf obsahuje
cyklus (a tedy se musí použít složitější správce paměti).</i></p>

<p>Vztahy mezi referencemi a hodnotami mohou být i složitější, což je ukázáno
na dalším demonstračním příkladu s&nbsp;trojicí slovníků, které se vzájemně
referencují:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = {}
y = {}
z = {}
&nbsp;
<i># cyklické reference N:N</i>
x["-&gt;x"] = x
x["-&gt;y"] = y
x["-&gt;z"] = z
&nbsp;
y["-&gt;x"] = x
y["-&gt;y"] = y
y["-&gt;z"] = z
&nbsp;
z["-&gt;x"] = x
z["-&gt;y"] = y
z["-&gt;z"] = z
&nbsp;
<i># graf s cyklickými referencemi</i>
objgraph.show_refs([x, y, z], filename='objgraph6.png')
</pre>

*** image ***
<p><i>Obrázek 10: Tři slovníky, které se vzájemně referencují.</i></p>

<p>Prakticky téhož výsledku dosáhneme ve chvíli, kdy se vzájemně referencují
objekty, resp.&nbsp;přesněji řečeno, když objekty obsahují atributy
s&nbsp;referencemi na jiné objekty:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
class A():
    def __init__(self, other):
        self.other = other
&nbsp;
<i># tři objekty, které na sebe navzájem ukazují</i>
x = A(None)
y = A(x)
z = A(y)
x.other=z
&nbsp;
<i># cyklické reference mezi objekty</i>
objgraph.show_refs([x, y, z], filename='objgraph7.png')
</pre>

*** image ***
<p><i>Obrázek 11: Tři objekty, které se vzájemně referencují.</i></p>

<p>Cyklus může vést i přes větší množství uzlů. V&nbsp;dalším demonstračním
příkladu se jedná o šest uzlů:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
a = {}
b = {}
c = {}
d = {}
e = {}
f = {}
&nbsp;
a["next"] = b
b["next"] = c
c["next"] = d
d["next"] = e
e["next"] = f
f["next"] = a
&nbsp;
<i># cyklické reference mezi objekty</i>
objgraph.show_refs([a, b, c, d, e, f], filename='objgraph8.png')
</pre>

*** image ***
<p><i>Obrázek 12: Cyklus, který vede přes šest uzlů.</i></p>

<p>A konečně, čistě jen jako demo, si ukažme reference na hodnoty získané
z&nbsp;celého globálního prostoru (jmen, tedy referencí):</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = {}
y = {}
&nbsp;
<i># objekty z celého jmenného prostoru</i>
objgraph.show_refs(globals(), filename='objgraph9.png')
</pre>

<p>S&nbsp;výsledkem:</p>

*** image ***
<p><i>Obrázek 13: Reference na hodnoty získané z&nbsp;celého globálního
prostoru (jmen, tedy referencí).</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Grafy se zpětným zjištěním referencí</h2>

<p></p>

<pre>
Help on function <strong>show_backrefs</strong> in module objgraph:
&nbsp;
show_backrefs(objs, max_depth=3, extra_ignore=(), filter=None, too_many=10, highlight=None, filename=None, extra_info=None, refcounts=False, shortnames=True, output=None, extra_node_attrs=None)
    Generate an object reference graph ending at ``objs``.
 &nbsp;   
    The graph will show you what objects refer to ``objs``, directly and
    indirectly.
&nbsp;
    ``objs`` can be a single object, or it can be a list of objects.  If
    unsure, wrap the single object in a new list.
&nbsp;
    ``filename`` if specified, can be the name of a .dot or a image
    file, whose extension indicates the desired output format; note
    that output to a specific format is entirely handled by GraphViz:
    if the desired format is not supported, you just get the .dot
    file.  If ``filename`` and ``output`` are not specified, ``show_backrefs``
    will try to display the graph inline (if you're using IPython), otherwise
    it'll try to produce a .dot file and spawn a viewer (xdot).  If xdot is
    not available, ``show_backrefs`` will convert the .dot file to a
    .png and print its name.
&nbsp;
    ``output`` if specified, the GraphViz output will be written to this
</pre>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = "Foo"
y = x
z = y

# zobrazení referencí na řetězec "Foo"
objgraph.show_backrefs(x, filename='objgraph1_backrefs.png')
</pre>

*** image ***
<p><i>Obrázek 14: </i></p>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = "Foo"
y = [x, "bar"]

objgraph.show_backrefs(y, filename='objgraph2_backrefs.png')
</pre>

*** image ***
<p><i>Obrázek 15: </i></p>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = "Foo"
y = [x, "bar"]

objgraph.show_backrefs([y], filename='objgraph3_backrefs.png')
</pre>

*** image ***
<p><i>Obrázek 16: </i></p>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = "Foo"
y = [x, "bar", [x], (x, x), {"x":x}]

objgraph.show_backrefs([x, y], filename='objgraph4_backrefs.png')
</pre>

*** image ***
<p><i>Obrázek 17: </i></p>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = {}
y = {}

# prázdné slovníky
objgraph.show_backrefs([x, y], filename='objgraph5A_backrefs.png')

x["1"] = y

# jedna reference
objgraph.show_backrefs([x, y], filename='objgraph5B_backrefs.png')

y["2"] = x

# cyklická reference
objgraph.show_backrefs([x, y], filename='objgraph5C_backrefs.png')

x["a"] = 10
x["b"] = True
x["c"] = False
x["d"] = None

y["a"] = False
y["b"] = True
y["c"] = False
y["d"] = None

# přidání dalších referencí
objgraph.show_backrefs([x, y], filename='objgraph5D_backrefs.png')
</pre>

*** image ***
<p><i>Obrázek 18: </i></p>

"""Grafické zobrazení referencí."""

import objgraph

x = {}
y = {}
z = {}

# cyklické reference N:N
x["->x"] = x
x["->y"] = y
x["->z"] = z

y["->x"] = x
y["->y"] = y
y["->z"] = z

z["->x"] = x
z["->y"] = y
z["->z"] = z

# graf s cyklickými referencemi
objgraph.show_backrefs([x, y, z], filename='objgraph6_backrefs.png')


<p><a name="k17"></a></p>
<h2 id="k17">17. Zjištění počtu objektů v&nbsp;paměti (podle jejich typu)</h2>

<pre>
Help on function <strong>show_growth</strong> in module objgraph:
&nbsp;
show_growth(limit=10, peak_stats=None, shortnames=True, file=None, filter=None)
    Show the increase in peak object counts since last call.
    
    if ``peak_stats`` is None, peak object counts will recorded in
    func `growth`, and your can record the counts by yourself with set
    ``peak_stats`` to a dictionary.
    
    The caveats documented in :func:`growth` apply.
    
    Example:
    
        &gt;&gt;&gt; show_growth()
        wrapper_descriptor       970       +14
        tuple                  12282       +10
        dict                    1922        +7
        ...
    
    .. versionadded:: 1.5
    
    .. versionchanged:: 1.8
       New parameter: ``shortnames``.
</pre>
<p></p>

<pre>
<i>"""Zjištění počtu objektů v paměti."""</i>
&nbsp;
import objgraph
import queue
&nbsp;
x = {}
y = {}
&nbsp;
objgraph.show_growth()
print()
&nbsp;
x["1"] = y
&nbsp;
objgraph.show_growth()
print()
&nbsp;
y["2"] = x
&nbsp;
objgraph.show_growth()
print()
&nbsp;
x = Exception()
y = queue.Queue()
z = queue.LifoQueue()
&nbsp;
objgraph.show_growth()
print()
</pre>

<p></p>

<pre>
function                       2284     +2284
dict                           1250     +1250
tuple                          1020     +1020
wrapper_descriptor              998      +998
weakref                         903      +903
method_descriptor               732      +732
builtin_function_or_method      703      +703
set                             461      +461
getset_descriptor               410      +410
list                            372      +372
</pre>

<p></p>

<pre>
dict     1251        +1
list      373        +1
</pre>

<p></p>

<pre>
dict     1252        +1
</pre>

<p></p>

<pre>
&nbsp;
builtin_function_or_method      715       +12
deque                             8        +7
dict                           1258        +6
Condition                         7        +6
list                            374        +1
Exception                         1        +1
Queue                             1        +1
LifoQueue                         1        +1
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Sledování nově vytvořených hodnot (podle typu)</h2>

<p></p>

<pre>
<i>"""Zjištění konstrukce objektů v paměti."""</i>

import objgraph

x = {}
y = {}

objgraph.get_new_ids()
print()

x["1"] = y

objgraph.get_new_ids()
print()

y["2"] = x

objgraph.get_new_ids()
print()
</pre>

<pre>
==============================================================================
Type                            Old_ids  Current_ids      New_ids Count_Deltas
==============================================================================
function                              0         2262        +2262        +2262
dict                                  0         1243        +1243        +1243
tuple                                 0         1011        +1011        +1011
wrapper_descriptor                    0          998         +998         +998
weakref                               0          898         +898         +898
method_descriptor                     0          732         +732         +732
builtin_function_or_method            0          703         +703         +703
set                                   0          461         +461         +461
getset_descriptor                     0          406         +406         +406
list                                  0          371         +371         +371
==============================================================================

======================================================================
Type                    Old_ids  Current_ids      New_ids Count_Deltas
======================================================================
set                         461          797         +336         +336
list                        371          372           +1           +1
dict                       1243         1244           +1           +1
zipimporter                   1            1           +0           +0
wrapper_descriptor          998          998           +0           +0
weakref                     898          898           +0           +0
uname_result                  1            1           +0           +0
type                        296          296           +0           +0
staticmethod                 39           39           +0           +0
property                    120          120           +0           +0
======================================================================

======================================================================
Type                    Old_ids  Current_ids      New_ids Count_Deltas
======================================================================
dict                       1244         1245           +1           +1
zipimporter                   1            1           +0           +0
wrapper_descriptor          998          998           +0           +0
weakref                     898          898           +0           +0
uname_result                  1            1           +0           +0
type                        296          296           +0           +0
tuple                      1010         1010           +0           +0
staticmethod                 39           39           +0           +0
set                         797          797           +0           +0
property                    120          120           +0           +0
======================================================================
</pre>

<p></p>

<pre>
<i>"""Zjištění konstrukce objektů v paměti."""</i>

import objgraph
import queue

objgraph.get_new_ids()


def foo():
    x = Exception()
    y = queue.Queue()
    z = queue.LifoQueue()
    objgraph.get_new_ids()


foo()
objgraph.get_new_ids()
</pre>

<pre>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů určených pro
Python 3 a nejnovější stabilní verzi knihovny <i>Objgraph</i> byly uloženy do
Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>gc01.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc01.py</a></td></tr>
<tr><td> 2</td><td>gc02.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc02.py</a></td></tr>
<tr><td> 3</td><td>gc03.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc03.py</a></td></tr>
<tr><td> 4</td><td>gc04.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc04.py</a></td></tr>
<tr><td> 5</td><td>gc05.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc05.py</a></td></tr>
<tr><td> 6</td><td>gc06.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc06.py</a></td></tr>
<tr><td> 7</td><td>gc07.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc07.py</a></td></tr>
<tr><td> 8</td><td>gc08.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc08.py</a></td></tr>
<tr><td> 9</td><td>gc09.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc09.py</a></td></tr>
<tr><td>10</td><td>gc10.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc10.py</a></td></tr>
<tr><td>11</td><td>gc11.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc11.py</a></td></tr>
<tr><td>12</td><td>gc12.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc12.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc12.py</a></td></tr>
<tr><td>13</td><td>gc13.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc13.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc13.py</a></td></tr>
<tr><td>14</td><td>gc14.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc14.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc14.py</a></td></tr>
<tr><td>15</td><td>gc15_references.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc15_references.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc15_references.py</a></td></tr>
<tr><td>16</td><td>get_new_ids1.py</td><td>sledování nově vytvořených hodnot (podle typu), základní použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/get_new_ids1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/get_new_ids1.py</a></td></tr>
<tr><td>17</td><td>get_new_ids2.py</td><td>sledování nově vytvořených hodnot (podle typu), příklad s&nbsp;instancemi tříd</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/get_new_ids2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/get_new_ids2.py</a></td></tr>
<tr><td>18</td><td>show_growth.py</td><td>zjištění počtu objektů v&nbsp;paměti (podle typu), příklad s&nbsp;instancemi tříd</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/show_growth.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/show_growth.py</a></td></tr>
<tr><td>19</td><td>objgraph1.py</td><td>grafické zobrazení referencí, jediný uzel představující řetězec v&nbsp;paměti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph1.py</a></td></tr>
<tr><td>20</td><td>objgraph2.py</td><td>grafické zobrazení referencí, dva uzly představující řetězce v&nbsp;paměti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph2.py</a></td></tr>
<tr><td>21</td><td>objgraph3.py</td><td>grafické zobrazení referencí, hodnoty referencované ze seznamu <strong>y</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph3.py</a></td></tr>
<tr><td>22</td><td>objgraph4.py</td><td>grafické zobrazení referencí, složitější hierarchie hodnot uložených v&nbsp;operační paměti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph4.py</a></td></tr>
<tr><td>23</td><td>objgraph5.py</td><td>grafické zobrazení referencí, postupný vznik cyklu v&nbsp;grafu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph5.py</a></td></tr>
<tr><td>24</td><td>objgraph6.py</td><td>grafické zobrazení referencí, tři slovníky, které se vzájemně referencují</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph6.py</a></td></tr>
<tr><td>25</td><td>objgraph7.py</td><td>grafické zobrazení referencí, tři objekty, které se vzájemně referencují</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph7.py</a></td></tr>
<tr><td>26</td><td>objgraph8.py</td><td>grafické zobrazení referencí, cyklus, který vede celkem přes šest uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph8.py</a></td></tr>
<tr><td>27</td><td>objgraph9.py</td><td>grafické zobrazení referencí, reference na hodnoty získané z&nbsp;celého globálního prostoru (jmen, tedy referencí)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph9.py</a></td></tr>
<tr><td>28</td><td>objgraph1_backrefs.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph1_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph1_backrefs.py</a></td></tr>
<tr><td>29</td><td>objgraph2_backrefs.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph2_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph2_backrefs.py</a></td></tr>
<tr><td>30</td><td>objgraph3_backrefs.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph3_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph3_backrefs.py</a></td></tr>
<tr><td>31</td><td>objgraph4_backrefs.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph4_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph4_backrefs.py</a></td></tr>
<tr><td>32</td><td>objgraph5_backrefs.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph5_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph5_backrefs.py</a></td></tr>
<tr><td>33</td><td>objgraph6_backrefs.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph6_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph6_backrefs.py</a></td></tr>
<tr><td>34</td><td>objgraph7_backrefs.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph7_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph7_backrefs.py</a></td></tr>
<tr><td>35</td><td>objgraph8_backrefs.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph8_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph8_backrefs.py</a></td></tr>
<tr><td>36</td><td>objgraph9_backrefs.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph9_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph9_backrefs.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>37</td><td>lsize1.py</td><td>změna alokované paměti pro seznam při postupném přidávání prvků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/lsize1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/lsize1.py</a></td></tr>
<tr><td>38</td><td>lsize2.py</td><td>změna alokované paměti pro seznam při postupném odstraňování prvků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/lsize2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/lsize2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>objgraph 3.5.0 na PyPi<br />
<a href="https://pypi.org/project/objgraph/">https://pypi.org/project/objgraph/</a>
</li>

<li>Python Garbage Collection: What It Is and How It Works<br />
<a href="https://stackify.com/python-garbage-collection/">https://stackify.com/python-garbage-collection/</a>
</li>

<li>The Garbage Collector<br />
<a href="https://pythoninternal.wordpress.com/2014/08/04/the-garbage-collector/">https://pythoninternal.wordpress.com/2014/08/04/the-garbage-collector/</a>
</li>

<li>Nástroje pro tvorbu grafů a diagramů z příkazové řádky<br />
<a href="https://www.root.cz/clanky/nastroje-pro-tvorbu-grafu-a-diagramu-z-prikazove-radky/">https://www.root.cz/clanky/nastroje-pro-tvorbu-grafu-a-diagramu-z-prikazove-radky/</a>
</li>

<li>Graphviz - Graph Visualization Software<br />
<a href="https://www.graphviz.org/">https://www.graphviz.org/</a>
</li>

<li>Manuálová stránka nástroje Graphviz<br />
<a href="https://www.root.cz/man/7/graphviz/">https://www.root.cz/man/7/graphviz/</a>
</li>

<li>Manuálová stránka nástroje dot<br />
<a href="https://www.root.cz/man/1/dot/">https://www.root.cz/man/1/dot/</a>
</li>

<li>Graphviz na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Graphviz">https://en.wikipedia.org/wiki/Graphviz</a>
</li>

<li>Reference counting<br />
<a href="https://en.wikipedia.org/wiki/Reference_counting">https://en.wikipedia.org/wiki/Reference_counting</a>
</li>

<li>Tracing garbage collection<br />
<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a>
</li>

<li>Generational GC (ephemeral GC)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC)">https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC)</a>
</li>

<li>Graphviz pro Python<br />
<a href="https://graphviz.readthedocs.io/en/stable/examples.html">https://graphviz.readthedocs.io/en/stable/examples.html</a>
</li>

<li>Memory Management in Python<br />
<a href="https://www.slideshare.net/VijayKumarBagavathSi/memory-management-in-python">https://www.slideshare.net/VijayKumarBagavathSi/memory-management-in-python</a>
</li>

<li>Memory Management In Python The Basics<br />
<a href="https://www.slideshare.net/nnja/memory-management-in-python-the-basics">https://www.slideshare.net/nnja/memory-management-in-python-the-basics</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>
