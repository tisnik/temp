<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Sledování správy paměti v Pythonu s využitím nástroje objgraph</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Sledování správy paměti v Pythonu s využitím nástroje objgraph</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes se seznámíme se základními vlastnostmi automatického správce paměti použitého v Pythonu, přesněji řečeno v jeho referenční implementaci označované též jako CPython. Druhá část článku je věnována nástroji objgraph, jenž dokáže zobrazit vzájemné vztahy mezi objekty uloženými na haldě.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Sledování správy paměti v&nbsp;Pythonu s&nbsp;využitím nástroje objgraph</a></p>
<p><a href="#k02">2. Proměnné v&nbsp;Pythonu: jména versus hodnoty (objekty)</a></p>
<p><a href="#k03">3. Reference na objekty</a></p>
<p><a href="#k04">4. Ukázka zjištění referencí na objekty</a></p>
<p><a href="#k05">5. Automatická správa paměti v&nbsp;Pythonu</a></p>
<p><a href="#k06">6. Správa paměti založená na počítání referencí</a></p>
<p><a href="#k07">7. Sledovací algoritmus a rozdělení objektů do generací</a></p>
<p><a href="#k08">8. Cache pro často používané objekty</a></p>
<p><a href="#k09">9. &bdquo;Interning&ldquo; řetězců</a></p>
<p><a href="#k10">10. Prealokace paměti pro prvky seznamů a slovníků</a></p>
<p><a href="#k11">11. Uvolňování paměti při mazání prvků</a></p>
<p><a href="#k12">12. Nástroj objgraph</a></p>
<p><a href="#k13">13. Instalace nástroje objgraph</a></p>
<p><a href="#k14">14. Zobrazení grafu referencí</a></p>
<p><a href="#k15">15. Cykly v&nbsp;grafu</a></p>
<p><a href="#k16">16. Grafy se zpětným zjištěním referencí</a></p>
<p><a href="#k17">17. Zjištění počtu objektů v&nbsp;paměti (podle jejich typu)</a></p>
<p><a href="#k18">18. Sledování nově vytvořených objektů (podle jejich typu)</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Sledování správy paměti v&nbsp;Pythonu s&nbsp;využitím nástroje objgraph</h2>

<p>Programovací jazyk Python, podobně jako prakticky všechny další vyšší
programovací jazyky, používá automatickou správu paměti, což znamená, že se
programátor (většinou!) nemusí starat o uvolňování prostředků (objektů)
z&nbsp;operační paměti. V&nbsp;Pythonu se používají dva způsoby detekce již
nepotřebných objektů, a to zejména z&nbsp;toho důvodu, že mezi objekty mohou
vznikat cyklické závislosti, jenž nejsou jednodušším algoritmem správně
vyřešeny a detekovány. V&nbsp;dnešním článku si nejprve ve stručnosti popíšeme,
jak se vlastně v&nbsp;Pythonu pracuje s&nbsp;proměnnými a parametry
funkcí/metod a následně se zaměříme na popis nástroje nazvaného
<i>objgraph</i>, který dokáže zobrazit reference mezi objekty, a to jak
v&nbsp;textové podobě, tak i ve formě snadno pochopitelných grafů.</p>

<p><div class="rs-tip-major">Poznámka: všechny informace zmíněné v&nbsp;tomto
článku se vztahují ke <a href="https://www.python.org/">&bdquo;klasické&ldquo;
implementaci Pythonu</a>, která se nazývá <i>CPython</i>, protože je
naprogramována v&nbsp;céčku (standardní knihovna pak přímo v&nbsp;Pythonu)
&ndash; viz též <a href="https://github.com/python/cpython">zdrojové kódy
CPythonu dostupné na GitHubu</a>. Existuje i mnoho dalších implementací
Pythonu, u nichž se však může používat zcela odlišný způsob správy paměti.
Příkladem může být <a
href="https://mojefedora.cz/jython-aneb-ponekud-opomijeny-programovaci-jazyk-pro-virtualni-stroj-javy/">Jython</a>,
tedy implementace Pythonu pro JVM založená (pochopitelně) přímo na správě
paměti nabízené přímo virtuálním strojem Javy.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Proměnné v&nbsp;Pythonu: jména versus hodnoty (objekty)</h2>

<p>Před popisem nástrojů a technik, které je možné využít pro sledování správy
paměti v&nbsp;Pythonu je vhodné si připomenout, jakým způsobem se vlastně
v&nbsp;tomto programovacím jazyce pracuje s&nbsp;proměnnými,
popř.&nbsp;s&nbsp;parametry funkcí a metod.</p>

<p>Začněme velmi stručným popisem práce s&nbsp;proměnnými v&nbsp;jazyku C a
v&nbsp;podobně koncipovaných programovacích jazycích, které jsou staticky
typované, překládané a navíc nemají automatickou správu paměti (se všemi
z&nbsp;toho plynoucími důsledky). V&nbsp;C můžeme deklarovat globální proměnné,
proměnné lokální v&nbsp;rámci funkce nebo proměnné lokální v&nbsp;rámci bloku
(ve funkci):</p>

<pre>
int x = 42;
</pre>

<p>Na základě této informace je proměnná uložena v&nbsp;paměti na místě
vybraném překladačem. Konstanty (<strong>const int y = 10;</strong>) jsou
většinou uloženy v&nbsp;kódovém segmentu (ten se ovšem někdy označuje jako
&bdquo;text&ldquo;). Inicializované statické lokální proměnné (<strong>static
int z = 6502;</strong> a inicializované globální (nekonstantní) proměnné jsou
uloženy v&nbsp;datovém segmentu, protože jeho obsah je součástí spustitelného
kódu a proměnné jsou tedy automaticky inicializovány na uživatelem
specifikovanou hodnotu. Ostatní globální proměnné a statické proměnné, tedy ty,
které nejsou inicializovány, jsou uloženy v&nbsp;bss segmentu (<i>block
starting symbol</i>), který je po spuštění aplikace alokován a následně vymazán
nulami, čímž se zajistí chování odpovídající specifikaci programovacího jazyka
C. Zbývají nám lokální (nestatické) proměnné. Ty jsou uloženy na zásobníkovém
rámci alokovaném ve chvíli, kdy je zavolána odpovídající funkce. To, do jaké
oblasti se proměnná uloží, je informace známá již v&nbsp;době překladu, přičemž
překladač taktéž zná typ proměnné, který se v&nbsp;rámci daného bloku nemůže
změnit (a v&nbsp;jiném bloku se bude jednat o zcela odlišnou proměnnou). Jediná
&bdquo;dynamika&ldquo; spočívá v&nbsp;tom, že lokální (nestatické) proměnné
jsou automaticky vytvářeny popř.&nbsp;rušeny při vstupu a výstupu
z&nbsp;funkce, kde jsou tyto proměnné deklarovány.</p>

<p>Poslední oblastí paměti je <i>halda</i> neboli <i>heap</i>. V&nbsp;této
oblasti je možné <i>explicitně</i> alokovat bloky paměti a získat ukazatel na
daný blok paměti. Problém spočívá v&nbsp;tom, že v&nbsp;C je nutné se
explicitně postarat i o uvolnění paměti.</p>

<img src="https://i.iinfo.cz/images/193/python-gc-1-1.png" class="image-440136" alt="&#160;" width="222" height="624" />
<p><i>Obrázek 1: Struktura paměti alokované pro běžící program<br />
Zdroj: Wikipedia.</i></p>

<p><div class="rs-tip-major">Poznámka: předchozí popis je značně zjednodušen,
protože ve skutečnosti mohou být (a také jsou) prováděny různé optimalizace a
některé lokální proměnné jsou ukládány pouze do registrů, konstanty taktéž
mohou být vytvořeny specializovanými instrukcemi atd.</div></p>

<p>V&nbsp;Pythonu je ovšem situace značně odlišná, což vede některé uživatele
k&nbsp;tvrzení, že Python vlastně nemá proměnné (viděno optikou céčkařů).
V&nbsp;Pythonu se totiž používá koncept jméno&rarr;reference&rarr;objekt. Jméno
reprezentuje skutečné jméno nějakého objektu uloženého v&nbsp;paměti. Toto
jméno je přes referenci svázáno se skutečným objektem, kterým je buď přímo
hodnota nebo kontejner odkazující na jiný objekt (tedy mající uloženou
referenci). A konečně zde máme bloky v&nbsp;paměti (konkrétně uložené na
haldě), kterým se říká <i>objekty</i>. Jedná se o datové struktury, které kromě
hodnoty (což je důvod, proč objekt vůbec vznikl) obsahuje i typ hodnoty a dále
počet referencí, které na tento objekt odkazují.</p>

<p>Toto je velký a navíc i koncepční rozdíl oproti jazykům typu C, které do
paměti ukládají pouze hodnotu. Typ se neukládá, protože ho zná překladač (a to
pouze v&nbsp;době překladu) a počet referencí není nutný, protože C nemá
automatickou správu paměti.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Reference na objekty</h2>

<p>Na závěr si shrňme základní vlastnosti jmen a objektů v&nbsp;Pythonu:</p>

<ol>
<li>Jména nemají přiřazen typ a v&nbsp;různých místech programu může jedno jméno referencovat hodnoty různých typů</li>
<li>Interpret zná rozsah platnosti (viditelnosti) jména</li>
<li>Hodnoty (objekty) nemají rozsah platnosti, mohou být referencovány přes mnoho jmen</li>
<li>Hodnoty (objekty) mají přiřazen typ, ten je neměnný</li>
<li>Hodnoty (objekty) mají i čítač referencí</li>
</ol>

<p>Reference na objekt vzniká přiřazením:</p>

<pre>
x = 6502
</pre>

<p>(ve skutečnosti byl v&nbsp;tomto případě vytvořen i příslušný objekt).</p>

<p>Pokud nyní zadáme:</p>

<pre>
y = x
</pre>

<p>budou na objekt 6502 uložený v&nbsp;paměti ukazovat dvě reference. Ovšem
stále se bude jednat o týž objekt, o čemž se přesvědčíme funkcí
<strong>id</strong>, která v&nbsp;CPythonu vrací adresu objektu:</p>

<pre>
&gt;&gt;&gt; id(x)
140363521220176
&nbsp;
&gt;&gt;&gt; id(y)
140363521220176
</pre>

<p>Totéž platí pro všechny reference, tedy i reference na kontejnery:</p>

<pre>
&gt;&gt;&gt; l1=[1,2,3]
&gt;&gt;&gt; l2=l1
&nbsp;
&gt;&gt;&gt; id(l1)
140363521208840
&nbsp;
&gt;&gt;&gt; id(l2)
140363521208840
&nbsp;
<i># změna provedená přes l2</i>
&gt;&gt;&gt; l2[1] = "****"
&nbsp;
<i># je pochopitelně viditelná i při použití jména l1</i>
&gt;&gt;&gt; l1
[1, '****', 3]
</pre>

<p>Ke stejným hodnotám (referencím na objekty v&nbsp;seznamu) jsme přistoupili
přes jména <strong>l1</strong> a <strong>l2</strong>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ukázka zjištění referencí na objekt</h2>

<p>Zjištění počtu referencí na objekty můžeme provést přímo z&nbsp;interaktivní
smyčky (REPL) programovacího jazyka Python. Komentáře jsou v&nbsp;tomto případě
přímo součástí &bdquo;sezení&ldquo;:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.6.6 (default, Jul 19 2018, 16:29:00) 
[GCC 7.3.1 20180303 (Red Hat 7.3.1-5)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&nbsp;
&gt;&gt;&gt; <i># budeme potřebovat funkci sys.getrefcount</i>
&gt;&gt;&gt; import sys
&nbsp;
&gt;&gt;&gt; <i># vytvoříme první objekt a navážeme ho na jméno x</i>
&gt;&gt;&gt; x = 6502
&gt;&gt;&gt; <i># zjistíme počet referencí - první referenci vytvořil interpret, druhou my</i>
&gt;&gt;&gt; sys.getrefcount(x)
2
&nbsp;
&gt;&gt;&gt; <i># hodnotu navážeme na další jméno</i>
&gt;&gt;&gt; y = x
&gt;&gt;&gt; <i># počet referencí se zvýší o jedničku</i>
&gt;&gt;&gt; sys.getrefcount(x)
3
&nbsp;
&gt;&gt;&gt; <i># hodnotu navážeme na další jméno</i>
&gt;&gt;&gt; z = y
&gt;&gt;&gt; <i># počet referencí se opět zvýší o jedničku</i>
&gt;&gt;&gt; sys.getrefcount(x)
4
&nbsp;
&gt;&gt;&gt; <i># jméno z navážeme na jinou hodnotu</i>
&gt;&gt;&gt; z = 0
&gt;&gt;&gt; <i># počet referencí se sníží o jedničku</i>
&gt;&gt;&gt; sys.getrefcount(x)
3
&nbsp;
&gt;&gt;&gt; <i># vymažeme jméno, čímž se počet referencí sníží</i>
&gt;&gt;&gt; del y
&gt;&gt;&gt; <i># počet referencí se opět sníží o jedničku</i>
&gt;&gt;&gt; sys.getrefcount(x)
2
&nbsp;
&gt;&gt;&gt; <i># ukazují obě jména na stejný objekt?</i>
&gt;&gt;&gt; id(x)
139646852357712
&gt;&gt;&gt; id(y)
139646852357712
&gt;&gt;&gt; <i># evidentně ano</i>
&gt;&gt;&gt; x is y
True
</pre>

<p>Můžeme si vyzkoušet i další podobně koncipované příklady. Pokud nebudou
spouštěny přímo z&nbsp;REPL, bude počet referencí o jedničku vyšší, protože se
objekty (hodnoty) vytvoří již v&nbsp;době <a
href="https://www.root.cz/clanky/pohled-pod-kapotu-jvm-porovnani-bajtkodu-virtualniho-stroje-javy-s-lua-a-pythonem/#k09">překladu
do bajtkódu</a>:</p>

<pre>
<i>"""Zobrazení počtu referencí řetězce 'Test!'."""</i>
&nbsp;
import sys 
<i># počet referencí na řetězec 'Test!'</i>
print(sys.getrefcount('Test!'))
</pre>

<p>Výsledek:</p>

<pre>
3
</pre>

<pre>
<i>"""Zobrazení počtu referencí řetězce 'Test!'."""</i>
&nbsp;
import sys
&nbsp;
<i># nová reference na řetězec</i>
x = "Test!"
&nbsp;
<i># počet referencí na řetězec 'Test!'</i>
print(sys.getrefcount(x))
</pre>

<p>Výsledek:</p>

<pre>
4
</pre>

<pre>
<i>"""Zobrazení počtu referencí na malé celé číslo."""</i>
&nbsp;
import sys
&nbsp;
<i># nová reference na malé celé číslo (viz další text s vysvětlením)</i>
x = 10
&nbsp;
<i># počet referencí na malé celé číslo</i>
print(sys.getrefcount(x))
</pre>

<p>Výsledek:</p>

<pre>
22
</pre>

<pre>
<i>"""Zobrazení počtu referencí na hodnotu True."""</i>
&nbsp;
import sys
&nbsp;
<i># nová reference na hodnotu True (viz další text s vysvětlením)</i>
x = True
&nbsp;
<i># počet referencí na hodnotu True</i>
print(sys.getrefcount(x))
</pre>

<p>Výsledek:</p>

<pre>
149
</pre>

<pre>
<i>"""Reference na seznam."""</i>
&nbsp;
import sys
&nbsp;
x = []
print(sys.getrefcount(x))
print(sys.getrefcount([]))
</pre>

<p>Výsledek:</p>

<pre>
2
1
</pre>

<pre>
<i>"""Zobrazení počtu referencí na řetězec."""</i>
&nbsp;
import sys

# více referencí na řetězec
x = "Test!"

# počet referencí na řetězec 'Test!'
print(sys.getrefcount(x))

# více referencí na řetězec
y = [x, "Test!"]

# nový počet referencí na řetězec 'Test!'
print(sys.getrefcount(x))

del y[1]

# nový počet referencí na řetězec 'Test!'
print(sys.getrefcount(x))

del y[0]

# nový počet referencí na řetězec 'Test!'
print(sys.getrefcount(x))

x = None

# nový počet referencí na řetězec 'Test!'
print(sys.getrefcount("Test!"))
</pre>

<pre>
"""Zobrazení počtu referencí na řetězec."""

import sys
&nbsp;
<i># více referencí na řetězec</i>
x = "Test!"
print(x)
&nbsp;
<i># počet referencí na řetězec 'Test!'</i>
print(sys.getrefcount(x))
&nbsp;
y = (x, x, x)
print(y)
&nbsp;
<i># počet referencí na řetězec 'Test!'</i>
print(sys.getrefcount(x))
&nbsp;
z = (y, y)
print(z)
&nbsp;
<i># počet referencí na řetězec 'Test!'</i>
print(sys.getrefcount(x))
&nbsp;
y = None
z = None
&nbsp;
<i># nový počet referencí na řetězec 'Test!'</i>
print(sys.getrefcount(x))
</pre>

<p>Výsledek:</p>

<pre>
Test!
4
('Test!', 'Test!', 'Test!')
7
(('Test!', 'Test!', 'Test!'), ('Test!', 'Test!', 'Test!'))
7
4
</pre>

<pre>
<i>"""Zobrazení počtu referencí na řetězec."""</i>
&nbsp;
import sys
&nbsp;
# více referencí na řetězec
x = "Test!"
y = x
z = y
&nbsp;
print(sys.getrefcount("foo"))
print(sys.getrefcount("Test!"))
print(sys.getrefcount(x))
print(sys.getrefcount(y))
print(sys.getrefcount(z))
</pre>

<p>Výsledek:</p>

<pre>
3
6
6
6
6
</pre>

<pre>
<i>"""Zobrazení počtu referencí na řetězec."""</i>
&nbsp;
import sys
&nbsp;
&nbsp;
def foo(ref):
    print(sys.getrefcount(ref))
&nbsp;
&nbsp;
<i># reference na řetězec</i>
x = "Test!"
print(sys.getrefcount(x))
&nbsp;
<i># předání reference</i>
foo(x)
</pre>

<p>Výsledek:</p>

<pre>
4
6
</pre>

<pre>
<i>"""Zobrazení počtu referencí na řetězec."""</i>
&nbsp;
import sys
&nbsp;
&nbsp;
def foo(ref):
    bar(ref)
&nbsp;
&nbsp;
def bar(ref):
    print(sys.getrefcount(ref))
&nbsp;
<i># reference na řetězec</i>
x = "Test!"
print(sys.getrefcount(x))
&nbsp;
<i># předání reference</i>
foo(x)
</pre>

z = (y, y)
print(z)

<pre>
4
8
</pre>

<pre>
<i>"""Reference na různé hodnoty."""</i>
&nbsp;
import sys
&nbsp;
x = "foobar"
y = 0
z = True
w = None
l = []
&nbsp;
print(sys.getrefcount("foo"))
print(sys.getrefcount("foobar"))
&nbsp;
print(sys.getrefcount(x))
print(sys.getrefcount(y))
print(sys.getrefcount(z))
print(sys.getrefcount(w))
print(sys.getrefcount(l))
print(sys.getrefcount([]))
</pre>

<p>Výsledek:</p>

<pre>
3
4
4
509
149
2150
2
1
</pre>

<pre>
<i>"""Cyklické reference na různé hodnoty."""</i>
&nbsp;
import sys
import pprint
&nbsp;
x = {}
y = {}
&nbsp;
pprint.pprint(x)
pprint.pprint(y)
print(sys.getrefcount(x))
print(sys.getrefcount(y))
print()
&nbsp;
x["1"] = y
&nbsp;
pprint.pprint(x)
pprint.pprint(y)
print(sys.getrefcount(x))
print(sys.getrefcount(y))
print()
&nbsp;
y["2"] = x
&nbsp;
pprint.pprint(x)
pprint.pprint(y)
print(sys.getrefcount(x))
print(sys.getrefcount(y))
print()
&nbsp;
del x["1"]
&nbsp;
pprint.pprint(x)
pprint.pprint(y)
print(sys.getrefcount(x))
print(sys.getrefcount(y))
print()
&nbsp;
del y["2"]
&nbsp;
pprint.pprint(x)
pprint.pprint(y)
print(sys.getrefcount(x))
</pre>

<pre>
{}
{}
2
2
&nbsp;
{'1': {}}
{}
2
3
&nbsp;
{'1': {'2': &lt;Recursion on dict with id=140094332450352&gt;}}
{'2': {'1': &lt;Recursion on dict with id=140094332450424&gt;}}
3
3
&nbsp;
{}
{'2': {}}
3
2
&nbsp;
{}
{}
2
2
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Automatická správa paměti v&nbsp;Pythonu</h2>

<p>V&nbsp;Pythonu jsou objekty z&nbsp;operační paměti odstraňovány automaticky.
Abychom činnost správce paměti pochopili, je nutné si znovu uvědomit, že
pracujeme se dvěma skupinami struktur &ndash; se jmény a s&nbsp;objekty. Přitom
již víme, že jménům není přiřazen typ hodnot, ovšem na druhou stranu je známý
jejich rozsah platnosti (viditelnosti). Naproti tomu u objektů sice známe
jejich typ a velikost, ovšem nikoli rozsah platnosti. Je tomu tak z&nbsp;toho
důvodu, že na jeden objekt může existovat (a v&nbsp;naprosté většině případů
taktéž existuje) větší počet referencí, takže rozsah platnosti objektu &ndash;
tedy do jakého okamžiku je ještě objekt nutné držet v&nbsp;operační paměti
&ndash; není možné zjistit jednoduše odvozením viditelnosti jména.</p>

<p>Tento problém je možné řešit mnoha různými správci paměti. V&nbsp;Pythonu
nalezneme dva z&nbsp;nich. První typ správy paměti je založen na takzvaném
<i>počítání referencí</i> (<i>reference counting</i>), což je velmi jednoduchý
systém, který však má určité nedostatky zmíněné <a
href="#k06">v&nbsp;navazující kapitole</a>. Druhý typ správy paměti je založen
na sledovacím (trasovacím) algoritmu, jenž ještě pro zvýšení své efektivity
rozděluje objekty (zde myšleno ve smyslu hodnot uložených v&nbsp;paměti) do tří
generací. Tento typ správce paměti bude zmíněn <a href="#k07">v&nbsp;sedmé
kapitole</a>.</p>

<p><div class="rs-tip-major">Poznámka: z&nbsp;hlediska práce s&nbsp;pamětí
rozlišujeme dvě skupiny objektů. V&nbsp;první řadě se jedná o jednoduché
objekty: čísla, řetězce, pravdivostní hodnoty atd. Ty jsou neměnitelné
(<i>immutable</i>). A ve druhé skupině se jedná o <i>kontejnery</i>, tedy
zejména seznamy, slovníky a třídy (i ty definované uživatelem). Kontejnery jsou
měnitelné (<i>mutable</i>) se všemi z&nbsp;toho plynoucími důsledky. n-tice
leží na hranici mezi oběma skupinami.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Správa paměti založená na počítání referencí</h2>

<p>Víme již, že v&nbsp;Pythonu se používají dva typy správců paměti
(resp.&nbsp;uvolňovačů paměti). První z&nbsp;nich je založený na počítání
referencí. U každého objektu se kromě vlastní hodnoty a typu ukládá i počet
referencí, které na tento objekt ukazují. Ve chvíli, kdy nějaké jméno (typicky
lokální proměnné, ovšem může se jednat i o výsledek příkazu
<strong>del</strong> atd.) zanikne, počet referencí se sníží o jedničku.
Jakmile dosáhne nuly, je možné objekt ihned uvolnit z&nbsp;paměti &ndash; vše
je provedeno prakticky okamžitě (ovšem může se tím spustit kaskáda uvolňování,
když například zaniká obsah celého seznamu nebo objekt).</p>

<p>Počítání referencí (<i>reference counting</i>) je implementačně značně
jednoduchý a nabízí okamžité uvolňování paměti, takže se zdá, že se jedná o
ideální způsob správy paměti. Ovšem nesmíme zapomenout i na některé jeho
negativní vlastnosti:</p>

<ul>

<li>U objektů je nutné uchovávat další atribut, což zvyšuje nároky na obsazení
paměti. A počitadlo se ukládá i u hodnot typu celé číslo atd., takže nárůst
může být v&nbsp;některých případech obrovský.</li>

<li>Každé přiřazení v&nbsp;programu modifikuje minimálně jedno počitadlo
referencí, někdy i více (<strong>a += 1</strong> mění počitadlo u dvou objektů
&ndash; jedno snižuje a druhé zvyšuje!).</li>

<li>Buď je nutné počitadlo modifikovat atomicky (náročné), nebo se vzdát
možnosti souběžného použití více vláken. Ostatně právě existence reference
countingu je jedním z&nbsp;důvodů, proč Python obsahuje a s&nbsp;velkou
pravděpodobností i nadále bude obsahovat neslavně známý <i>GIL &ndash; Global
Interpreter Lock</i>.</li>

<li>Navíc nelze odstraňovat objekty s&nbsp;cyklickými referencemi. Většinou se
nejedná o stav, kdy by objekt referencoval sám sebe, ale spíše se bude jednat o
cyklus přes více objektů (zákazník je objekt referencující objekt typu Firma,
Firma je objekt se seznamem zákazníků atd.)</li>

</ul>

<p>Právě z&nbsp;toho důvodu, aby bylo možné detekovat i cyklické reference,
obsahuje Python i takzvaný sledovací algoritmus zmíněný v&nbsp;navazující
kapitole.</p>

<p><div class="rs-tip-major">Poznámka: zajímavé je v&nbsp;tomto ohledu chování
objektů, které jsou referencovány globálními jmény. Jejich <i>refcount</i>
nikdy neklesne na nulu a proto nejsou uvolněny z&nbsp;paměti, což platí i pro
třídy (což je sice zřejmé, ale v&nbsp;kontextu tohoto článku je dobré si tuto
skutečnost znovu uvědomit, protože mnohdy velké objekty můžeme nalézt i
v&nbsp;často používaných knihovnách typu Matplotlib atd.).</div></p>

<p><div class="rs-tip-major">Poznámka: ještě jednou si připomeňme, že příkaz
<strong>del</strong> nemaže objekt, pouze sníží počet referencí o jedničku a
odstraní jméno, které na objekt odkazuje.</div></p>

<p><a name="k07"></a></p>
<h2 id="k07">7. Sledovací algoritmus a rozdělení objektů do generací</h2>

memory_profiler

del nemaže objekt. pouze sníží počet referencí o jedničku a odstraní jméno, které na objekt odkazuje

tatkéž při opuštění funkce, ve které objekt vznikl (a nevrátili jsme jeho referenci například pomocí return).

co pro globální objekty - jejich refcount nikdy neklesne na nulu pokud se explicitně nevymažou. Proto není vhodné na globální úrovni používat velké objekty (což platí i pro třídy).

<pre>
<i>"""Zjištění základních informací o správci paměti."""</i>
&nbsp;
import gc
&nbsp;
print(gc.get_threshold())
print(gc.get_stats())
</pre>

finalizery!!!
weak_ref

<pre>
(700, 10, 10)
&nbsp;
[{'collections': 17, 'collected': 92, 'uncollectable': 0},
 {'collections': 1, 'collected': 7, 'uncollectable': 0},
 {'collections': 0, 'collected': 0, 'uncollectable': 0}]
</pre>

<p><div class="rs-tip-major">Poznámka: VM Pythonu sice startuje rychleji, než
JVM, ovšem i zde můžeme vidět, že správa paměti proběhla ještě před vlastním
spuštěním skriptu.</div></p>

<p>Spuštění algoritmu si můžete vynutit funkcí <strong>gc.collect()</strong>,
které lze předat i číslo generace (0..2), které se má <i>mark</i> a
<i>sweep</i> týkat.</p>

<p><div class="rs-tip-major">Poznámka: jak již bylo napsáno výše, je možné celý
tento proces zakázat. Taktéž je možné (kde je to možné) namísto běžných
referencí používat takzvané <i>slabé (week)</i> reference, o nichž vyjde
samostatný článek.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Cache pro často používané objekty</h2>

<p>Velmi často používané objekty (tedy hodnoty) jsou uloženy do cache.
Konkrétně se to týká celočíselných hodnot v&nbsp;rozsahu od <a
href="https://github.com/python/cpython/blob/4830f581af57dd305c02c1fd72299ecb5b090eca/Objects/longobject.c#L18-L23">-5
do 257</a>, které jsou interně uloženy do pole <a
href="https://github.com/python/cpython/blob/4830f581af57dd305c02c1fd72299ecb5b090eca/Objects/longobject.c#L40">small_ints</a>.
Pokud v&nbsp;programovém kódu bude použito přiřazení takto malého čísla ke
jménu, bude použit objekt z&nbsp;tohoto pole (a zvýší se počet jeho
referencí):</p>

<pre>
&gt;&gt;&gt; sys.getrefcount(1)
896
&nbsp;
&gt;&gt;&gt; x=1
&gt;&gt;&gt; sys.getrefcount(1)
897
&nbsp;
&gt;&gt;&gt; y=x
&gt;&gt;&gt; sys.getrefcount(1)
898
&nbsp;
&gt;&gt;&gt; x=None
&gt;&gt;&gt; y=None
&gt;&gt;&gt; sys.getrefcount(1)
896
</pre>

Cache s často používanými objekty

&gt;&gt;&gt; x=1
&gt;&gt;&gt; y=1
&gt;&gt;&gt; x is y
True
&nbsp;
&gt;&gt;&gt; id(x)
140520351155200
&nbsp;
&gt;&gt;&gt; id(y)
140520351155200
</pre>

<p>U větších hodnot není tento přístup použit &ndash; jsou vytvořeny dva nové
objekty:</p>

<pre>
&gt;&gt;&gt; x=6502
&gt;&gt;&gt; y=6502
&gt;&gt;&gt; x <strong>is</strong> y
False
&nbsp;
&gt;&gt;&gt; id(x)
139647346708048
&nbsp;
&gt;&gt;&gt; id(y)
139647346707792
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. &bdquo;Interning&ldquo; řetězců</h2>

<p>Ve skriptech psaných v&nbsp;Pythonu se velmi často používají řetězce, a to
například i ve funkci klíčů ve slovnících atd. (je tomu tak z&nbsp;toho důvodu,
že Pythonu chybí datový typ <i>symbol</i>). Aby bylo porovnávání řetězců
rychlé, lze využít takzvaný &bdquo;interning&ldquo;, což znamená, že se řetězce
se stejným obsahem uloží do paměti jen jedenkrát. Porovnání řetězce se
v&nbsp;tomto případě může provést pouze porovnáním jeho adresy (hodnoty
reference) a nikoli pracným porovnáváním znak po znaku. Interning existuje
<i>interní</i> a <i>externí</i>.</p>

<p>Interní interning je proveden automaticky:</p>

<ul>
<li>U řetězců obsahujících jen jediný znak</li>
<li>U starších verzí Pythonu (3.7) u vybraných řetězců do délky 20 znaků</li>
<li>U novějších verzí Pythonu rozhoduje analýza AST a může se jednat o řetězce do délky 4096 znaků</li>
<li>Jména tříd, proměnných atd. jsou &bdquo;internována&ldquo; vždy</li>
</ul>

<p>Explicitní interning lze vynutit zavoláním funkce
<strong>sys.intern</strong>. Výsledkem je menší spotřeba paměti, rychlejší
přístup k&nbsp;prvkům map atd., ovšem vlastní interning je časově náročná
operace, takže se ne vždy musí vyplatit.</p>

<p>Podívejme se na situaci, kdy se interning automaticky <i>ne</i>provede:</p>

<pre>
import sys
&nbsp;
last_letter = "d"
&nbsp;
a = "Hello World"
b = "Hello Worl" + last_letter
&nbsp;
print("The ID of a: {}".format(id(a)))
print("The ID of b: {}".format(id(b)))
print("a is b? {}".format(a is b))
</pre>

<p>Po spuštění skriptu uvidíme, že řetězce sice mají stejný obsah, ovšem jedná
se o samostatné objekty (s&nbsp;rozdílnými referencemi), nikoli o shodné
objekty:</p>

<pre>
The ID of a: 139719026913008
The ID of b: 139719026946224
a is b? False
</pre>

<p>Explicitně vynucený interning:</p>

<pre>
import sys
&nbsp;
last_letter = "d"
&nbsp;
a = sys.intern("Hello World")
b = sys.intern("Hello Worl" + last_letter)
&nbsp;
print("The ID of a: {}".format(id(a)))
print("The ID of b: {}".format(id(b)))
print("a is b? {}".format(a is b))
</pre>

<p>Nyní existuje v&nbsp;paměti jediný řetězec referencovaný jmény
<strong>a</strong> i <strong>b</strong>:</p>

<pre>
The ID of a: 140679980293936
The ID of b: 140679980293936
a is b? True
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Prealokace paměti pro prvky seznamů a slovníků</h2>

<p>Seznamy a slovníky slouží jako kontejnery pro uložení referencí na další
objekty. Tyto reference poněkud nepřesně nazýváme <i>prvky</i>, i když skutečné
hodnoty prvků nejsou přímo v&nbsp;těchto kontejnerech uloženy. Velmi často se
setkáme s&nbsp;tím, že se prvky do seznamů a slovníků přidávají či naopak
ubírají. Aby se zmenšil počet realokací paměti (a tím pádem i nutnosti přesunu
celého kontejneru), jsou tyto kontejnery vytvořeny tak, aby mohly pojmout
několik dalších prvků bez toho, aby bylo nutné při každém přidání realokaci
použít. Toto chování si můžeme ověřit na jednoduchém příkladu, v&nbsp;němž
začínáme s&nbsp;prázdným seznamem, do kterého postupně přidáváme další
prvky:</p>

<pre>
import sys
&nbsp;
l = []
&nbsp;
for i in range(31):
    print(len(l), sys.getsizeof(l))
    l.append(i)
</pre>

<p>Po spuštění tohoto skriptu můžeme sledovat, jak se velikost paměti alokované
pro seznam zvyšuje skokově a pouze ve chvíli, kdy je volná kapacita
naplněna:</p>

<pre>
0 64
<strong>1 96</strong>
2 96
3 96
4 96
<strong>5 128</strong>
6 128
7 128
8 128
<strong>9 192</strong>
10 192
11 192
12 192
13 192
14 192
15 192
16 192
<strong>17 264</strong>
18 264
19 264
20 264
21 264
22 264
23 264
24 264
25 264
<strong>26 344</strong>
27 344
28 344
29 344
30 344
</pre>

<p><div class="rs-tip-major">Poznámka: podobné chování můžeme najít i
v&nbsp;jiných programovacích jazycích. Příkladem mohou být <a
href="https://www.root.cz/clanky/datove-typy-v-programovacim-jazyku-go/#k12">řezy
(<i>slice</i>)</a> použité <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;programovacím
jazyku Go</a>.</div>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Uvolňování paměti při mazání prvků</h2>

<p>Podobně jako kapacita seznamu skokově roste při přidávání prvků, bude se
&ndash; opět na základě ověřeného algoritmu &ndash; seznam, resp.&nbsp;jeho
volná kapacita, zmenšovat ve chvíli, kdy jsou z&nbsp;něho prvky ubírány. Ovšem
vždy se počítá s&nbsp;tím, že prvky mohou být v&nbsp;dalším kroku i přidány,
takže se udržuje určitá volná kapacita na konci seznamu. I toto chování si
můžeme ověřit na demonstračním příkladu:</p>

<pre>
import sys
&nbsp;
l = []
&nbsp;
for i in range(31):
    l.append(i)
&nbsp;
for i in range(31):
    print(len(l), sys.getsizeof(l))
    del l[-1]
</pre>

<p>Můžeme vidět, že se při mazání prvků zpočátku udržuje původní kapacita
(zhruba až na 1/2 zaplněnosti) a teprve poté dochází k&nbsp;realokaci seznamu
v&nbsp;paměti:</p>

<pre>
31 344
30 344
29 344
28 344
27 344
26 344
25 344
24 344
23 344
22 344
21 344
20 344
19 344
18 344
17 344
<strong>16 256</strong>
15 256
14 256
13 256
12 256
<strong>11 208</strong>
10 208
9 208
<strong>8 160</strong>
7 160
6 160
<strong>5 128</strong>
4 128
<strong>3 112</strong>
<strong>2 104</strong>
1 96
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nástroj objgraph</h2>

<p>Pro zobrazení vzájemných vztahů mezi jmény, referencemi a objekty lze použít
až překvapivě propracovaný nástroj nazvaný příznačně <i>objgraph</i>.  Tento
nástroj se používá jako běžná knihovna programovacího jazyka Python a umožňuje
v&nbsp;jakékoli chvíli získat informace o struktuře haldy (heapu),
tj.&nbsp;jaké objekty a jakého typu jsou zde uloženy. Získat lze i další
důležité informace, například o tom, které objekty byly vytvořeny
v&nbsp;určitém časovém intervalu (mezi voláním dvou funkcí z&nbsp;knihovny)
atd. Některé příklady použití <i>objgraphu</i> budou ukázány
v&nbsp;navazujících kapitolách.</p>

<p>Nástroj <i>objgraph</i> umí kromě textových informací a tabulek zobrazovat i
grafy se zvýrazněním referencí mezi objekty. Pro tento účel je použit balíček
nástrojů nazvaný <i>Graphviz</i>. V&nbsp;tomto balíčku nalezneme především
utilitu nazvanou <strong>dot</strong>, která na základě textové definice
orientovaného či neorientovaného grafu vytvoří rastrový či vektorový obrázek
s&nbsp;grafem, přičemž je možné si zvolit, jaký algoritmus bude použit pro
rozmístění uzlů a hran na vytvořeném obrázku. Textová definice grafu používá
jednoduchý popisný jazyk, který je v&nbsp;současnosti podporován i několika
dalšími nástroji a stává se tak nepsaným standardem pro mnoho programů
pracujících s&nbsp;grafovými strukturami. Pro utilitu <i>Graphviz</i> existuje
i knihovna určená pro <a href="https://www.root.cz/n/python/">programovací
jazyk Python</a> &ndash; viz též <a
href="https://pypi.org/project/graphviz/">https://pypi.org/project/graphviz/</a>;
tento balíček je používán i nástrojem <i>objgraph</i>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instalace nástroje objgraph</h2>

<p>Samotná instalace nástroje <i>objgraph</i> je stejně snadná, jako instalace
jakéhokoli jiného Pythonovského balíčku nabízeného přes <a
href="https://pypi.org/">Python Package Index</a>. Instalaci můžeme provést pro
celý systém:</p>

<pre>
# <strong>pip install objgraph</strong>
&nbsp;
Collecting objgraph
  Downloading https://files.pythonhosted.org/packages/a9/79/9f47706447b9ba0003c0680da4fed1d502adf410e1d953b4d1a5d3486640/objgraph-3.5.0-py2.py3-none-any.whl
Collecting graphviz
  Downloading https://files.pythonhosted.org/packages/64/72/f4f4205db2a58e7a49e8190c0b49e9669d7ecadf6385b5bcdcf910354a6d/graphviz-0.15-py2.py3-none-any.whl
Installing collected packages: graphviz, objgraph
Successfully installed graphviz-0.15 objgraph-3.5.0
</pre>

<p>Nebo pro právě přihlášeného uživatele:</p>

<pre>
$ <strong>pip install objgraph</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se automaticky
doinstaloval i závislý balíček <i>graphviz</i>.</div></p>

<p>Ověření, že je balíček skutečně dostupný:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.8.6 (default, Sep 25 2020, 00:00:00) 
[GCC 10.2.1 20200723 (Red Hat 10.2.1-1)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import objgraph
&gt;&gt;&gt; help(objgraph)
</pre>

<p>Měla by se zobrazit nápověda:</p>

<pre>
Help on module objgraph:
&nbsp;
NAME
    objgraph - Tools for drawing Python object reference graphs with graphviz.
&nbsp;
DESCRIPTION
    You can find documentation online at https://mg.pov.lt/objgraph/
&nbsp;
    Copyright (c) 2008-2017 Marius Gedminas &lt;marius@pov.lt&gt; and contributors
&nbsp;
    Released under the MIT licence.
&nbsp;
FUNCTIONS
    at(addr)
        Return an object at a given memory address.
&nbsp;  
        The reverse of id(obj):
&nbsp;
            &gt;&gt;&gt; at(id(obj)) is obj
            True
&nbsp;
        Note that this function does not work on objects that are not tracked by
        the GC (e.g. ints or strings).
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zobrazení grafu referencí</h2>

<p>Pravděpodobně nejzajímavější funkcí nástroje <i>objgraph</i> je jeho
schopnost zobrazit orientovaný graf s&nbsp;hranami vedoucími od zadaného jména
(typicky jména proměnné nebo parametru funkce popř.&nbsp;metody) až po
konkrétní hodnoty uložené v&nbsp;paměti (viz též <a href="#k02">druhou
kapitolu</a>):</p>

<pre>
Help on function <strong>show_refs</strong> in module objgraph:
&nbsp;
show_refs(objs, max_depth=3, extra_ignore=(), filter=None, too_many=10, highlight=None, filename=None, extra_info=None, refcounts=False, shortnames=True, output=None, extra_node_attrs=None)
    Generate an object reference graph starting at ``objs``.
&nbsp;
    The graph will show you what objects are reachable from ``objs``, directly
    and indirectly.
&nbsp;
    ``objs`` can be a single object, or it can be a list of objects.  If
    unsure, wrap the single object in a new list.
&nbsp;
    ``filename`` if specified, can be the name of a .dot or a image
    file, whose extension indicates the desired output format; note
    that output to a specific format is entirely handled by GraphViz:
    if the desired format is not supported, you just get the .dot
    file.  If ``filename`` and ``output`` is not specified, ``show_refs`` will
    try to display the graph inline (if you're using IPython), otherwise it'll
    try to produce a .dot file and spawn a viewer (xdot).  If xdot is
    not available, ``show_refs`` will convert the .dot file to a
    .png and print its name.
&nbsp;
    ``output`` if specified, the GraphViz output will be written to this
</pre>

<p>Podívejme se nyní na několik okomentovaných ukázek použití této užitečné
funkce.</p>

<p>Proměnná <strong>z</strong> je referencí na řetězec, proto se při volání
funkce <strong>show_refs</strong> vyhodnotí (a zobrazí asi něco jiného, než
bychom očekávali):</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = "Foo"
y = x
z = y
&nbsp;
<i># zobrazení referencí vedoucích až na řetězec "Foo"</i>
objgraph.show_refs(z, filename='objgraph1.png')
</pre>

*** image ***
<p><i>Obrázek 2: Zobrazí se pouze přímo hodnota s&nbsp;řetězcem.</i></p>

<p>Zobrazit můžeme i objekty, které jsou referencovány ze seznamu:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = "Foo"
y = [x, "bar"]
&nbsp;
<i># zobrazení referencí ze seznamu y</i>
objgraph.show_refs(y, filename='objgraph2.png')
</pre>

*** image ***
<p><i>Obrázek 3: Zobrazí se pouze přímo hodnoty s&nbsp;řetězci.</i></p>

<p>Pokud chceme zobrazit, jaké hodnoty jsou dostupné (referencované) přímo ze
seznamu <strong>y</strong>, musíme tento seznam umístit do složených závorek
(předá se tak vlastně reference na seznam):</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = "Foo"
y = [x, "bar"]
&nbsp;
<i># zobrazení referencí na dva řetězce uložené v seznamu</i>
objgraph.show_refs([y], filename='objgraph3.png')
</pre>

*** image ***
<p><i>Obrázek 4: Hodnoty referencované ze seznamu <strong>y</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: toto je nejběžnější použití funkce
<strong>show_refs</strong>.</div></p>

<p>Již poněkud složitější hierarchie objektů uložených v&nbsp;operační
paměti:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = "Foo"
y = [x, "bar", [x], (x, x), {"x":x}]
&nbsp;
<i># reference u složitějších datových struktur</i>
objgraph.show_refs([x, y], filename='objgraph4.png')
</pre>

*** image ***
<p><i>Obrázek 5: Složitější hierarchie hodnot uložených v&nbsp;operační
paměti.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Cykly v&nbsp;grafu</h2>

<p>Největší užitečnost funkce <strong>show_refs</strong> (vytvářející snadno
pochopitelné grafy) se projeví ve chvíli, kdy je vzájemná provázanost mezi
proměnnými (jmény) a hodnotami (objekty) složitější, popř.&nbsp;když obsahuje
cykly. A dosažení cyklu je snadné &ndash; můžeme například použít dvojici
slovníků, které na sebe navzájem odkazují:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = {}
y = {}
&nbsp;
<i># prázdné slovníky</i>
objgraph.show_refs([x, y], filename='objgraph5A.png')
&nbsp;
x["1"] = y
&nbsp;
<i># jedna reference</i>
objgraph.show_refs([x, y], filename='objgraph5B.png')
&nbsp;
y["2"] = x
&nbsp;
<i># cyklická reference</i>
objgraph.show_refs([x, y], filename='objgraph5C.png')
&nbsp;
x["a"] = 10
x["b"] = True
x["c"] = False
x["d"] = None
&nbsp;
y["a"] = False
y["b"] = True
y["c"] = False
y["d"] = None
&nbsp;
<i># přidání dalších referencí</i>
objgraph.show_refs([x, y], filename='objgraph5D.png')
</pre>

<p>Význam předchozího programového kódu je pravděpodobně zřejmý, takže se ihned
podívejme, jaké grafy postupně vznikly:</p>

*** image ***
<p><i>Obrázek 6: Dva prázdné slovníky na začátku skriptu.</i></p>

*** image ***
<p><i>Obrázek 7: Prvek jednoho slovníku obsahuje referenci na druhý
slovník.</i></p>

*** image ***
<p><i>Obrázek 8: Vznik cyklu v&nbsp;grafu.</i></p>

*** image ***
<p><i>Obrázek 9: Přidáním dalších hodnot nic nemění na tom, že graf obsahuje
cyklus (a tedy se musí použít složitější správce paměti).</i></p>

<p>Vztahy mezi referencemi a hodnotami mohou být i složitější, což je ukázáno
na dalším demonstračním příkladu s&nbsp;trojicí slovníků, které se vzájemně
referencují:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = {}
y = {}
z = {}
&nbsp;
<i># cyklické reference N:N</i>
x["-&gt;x"] = x
x["-&gt;y"] = y
x["-&gt;z"] = z
&nbsp;
y["-&gt;x"] = x
y["-&gt;y"] = y
y["-&gt;z"] = z
&nbsp;
z["-&gt;x"] = x
z["-&gt;y"] = y
z["-&gt;z"] = z
&nbsp;
<i># graf s cyklickými referencemi</i>
objgraph.show_refs([x, y, z], filename='objgraph6.png')
</pre>

*** image ***
<p><i>Obrázek 10: Tři slovníky, které se vzájemně referencují.</i></p>

<p>Prakticky téhož výsledku dosáhneme ve chvíli, kdy se vzájemně referencují
objekty, resp.&nbsp;přesněji řečeno, když objekty obsahují atributy
s&nbsp;referencemi na jiné objekty:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
class A():
    def __init__(self, other):
        self.other = other
&nbsp;
<i># tři objekty, které na sebe navzájem ukazují</i>
x = A(None)
y = A(x)
z = A(y)
x.other=z
&nbsp;
<i># cyklické reference mezi objekty</i>
objgraph.show_refs([x, y, z], filename='objgraph7.png')
</pre>

*** image ***
<p><i>Obrázek 11: Tři objekty, které se vzájemně referencují.</i></p>

<p>Cyklus může vést i přes větší množství uzlů. V&nbsp;dalším demonstračním
příkladu se jedná o šest uzlů:</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
a = {}
b = {}
c = {}
d = {}
e = {}
f = {}
&nbsp;
a["next"] = b
b["next"] = c
c["next"] = d
d["next"] = e
e["next"] = f
f["next"] = a
&nbsp;
<i># cyklické reference mezi objekty</i>
objgraph.show_refs([a, b, c, d, e, f], filename='objgraph8.png')
</pre>

*** image ***
<p><i>Obrázek 12: Cyklus, který vede přes šest uzlů.</i></p>

<p>A konečně, čistě jen jako demo, si ukažme reference na hodnoty získané
z&nbsp;celého globálního prostoru (jmen, tedy referencí):</p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = {}
y = {}
&nbsp;
<i># objekty z celého jmenného prostoru</i>
objgraph.show_refs(globals(), filename='objgraph9.png')
</pre>

<p>S&nbsp;výsledkem:</p>

<a href="https://www.root.cz/obrazek/440149/"><img src="https://i.iinfo.cz/images/130/python-gc-2-12-prev.png" class="image-440149" alt="&#160;" width="370" height="37" /></a>
<p><i>Obrázek 13: Reference na hodnoty získané z&nbsp;celého globálního
prostoru (jmen, tedy referencí).</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Grafy se zpětným zjištěním referencí</h2>

<p>V&nbsp;mnoha případech budeme potřebovat zjistit, jaké reference na daný
objekt ukazují. K&nbsp;vizuálnímu zobrazení těchto vztahů
(jméno&rarr;reference&rarr;objekt/hodnota) slouží funkce nazvaná
<strong>show_backrefs</strong>:</p>

<pre>
Help on function <strong>show_backrefs</strong> in module objgraph:
&nbsp;
show_backrefs(objs, max_depth=3, extra_ignore=(), filter=None, too_many=10, highlight=None, filename=None, extra_info=None, refcounts=False, shortnames=True, output=None, extra_node_attrs=None)
    Generate an object reference graph ending at ``objs``.
 &nbsp;   
    The graph will show you what objects refer to ``objs``, directly and
    indirectly.
&nbsp;
    ``objs`` can be a single object, or it can be a list of objects.  If
    unsure, wrap the single object in a new list.
&nbsp;
    ``filename`` if specified, can be the name of a .dot or a image
    file, whose extension indicates the desired output format; note
    that output to a specific format is entirely handled by GraphViz:
    if the desired format is not supported, you just get the .dot
    file.  If ``filename`` and ``output`` are not specified, ``show_backrefs``
    will try to display the graph inline (if you're using IPython), otherwise
    it'll try to produce a .dot file and spawn a viewer (xdot).  If xdot is
    not available, ``show_backrefs`` will convert the .dot file to a
    .png and print its name.
&nbsp;
    ``output`` if specified, the GraphViz output will be written to this
</pre>

<p>Ukažme si nyní příklad použití této funkce.</p>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = "Foo"
y = x
z = y

# zobrazení referencí na řetězec "Foo"
objgraph.show_backrefs(x, filename='objgraph1_backrefs.png')
</pre>

*** image ***
<p><i>Obrázek 14: </i></p>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = "Foo"
y = [x, "bar"]

objgraph.show_backrefs(y, filename='objgraph2_backrefs.png')
</pre>

*** image ***
<p><i>Obrázek 15: </i></p>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = "Foo"
y = [x, "bar"]

objgraph.show_backrefs([y], filename='objgraph3_backrefs.png')
</pre>

*** image ***
<p><i>Obrázek 16: </i></p>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = "Foo"
y = [x, "bar", [x], (x, x), {"x":x}]

objgraph.show_backrefs([x, y], filename='objgraph4_backrefs.png')
</pre>

*** image ***
<p><i>Obrázek 17: </i></p>

<pre>
"""Grafické zobrazení referencí."""

import objgraph

x = {}
y = {}

# prázdné slovníky
objgraph.show_backrefs([x, y], filename='objgraph5A_backrefs.png')

x["1"] = y

# jedna reference
objgraph.show_backrefs([x, y], filename='objgraph5B_backrefs.png')

y["2"] = x

# cyklická reference
objgraph.show_backrefs([x, y], filename='objgraph5C_backrefs.png')

x["a"] = 10
x["b"] = True
x["c"] = False
x["d"] = None
&nbsp;
y["a"] = False
y["b"] = True
y["c"] = False
y["d"] = None
&nbsp;
<i># přidání dalších referencí</i>
objgraph.show_backrefs([x, y], filename='objgraph5D_backrefs.png')
</pre>

<img src="https://i.iinfo.cz/images/502/python-gc-3-5.png" class="image-440154" alt="&#160;" width="403" height="299" />
<p><i>Obrázek 18: Postupná změna cyklu v&nbsp;grafu &ndash; prázdné slovníky.</i></p>

<img src="https://i.iinfo.cz/images/502/python-gc-3-6.png" class="image-440155" alt="&#160;" width="415" height="437" />
<p><i>Obrázek 19: Postupná změna cyklu v&nbsp;grafu &ndash; první vazba mezi slovníky.</i></p>

<img src="https://i.iinfo.cz/images/502/python-gc-3-7.png" class="image-440156" alt="&#160;" width="415" height="437" />
<p><i>Obrázek 20: Postupná změna cyklu v&nbsp;grafu &ndash; druhá vazba mezi slovníky.</i></p>

<img src="https://i.iinfo.cz/images/502/python-gc-3-8.png" class="image-440157" alt="&#160;" width="415" height="437" />
<p><i>Obrázek 21: Postupná změna cyklu v&nbsp;grafu &ndash; přidání dalších hodnot.</i></p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
x = {}
y = {}
z = {}
&nbsp;
<i># cyklické reference N:N</i>
x["-&gt;x"] = x
x["-&gt;y"] = y
x["-&gt;z"] = z
&nbsp;
y["-&gt;x"] = x
y["-&gt;y"] = y
y["-&gt;z"] = z
&nbsp;
z["-&gt;x"] = x
z["-&gt;y"] = y
z["-&gt;z"] = z
&nbsp;
<i># graf s cyklickými referencemi</i>
objgraph.show_backrefs([x, y, z], filename='objgraph6_backrefs.png')
</pre>

<img src="https://i.iinfo.cz/images/502/python-gc-3-9.png" class="image-440158" alt="&#160;" width="498" height="576" />
<p><i>Obrázek 22: Vzájemné vazby mezi trojicí slovníků.</i></p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
class A():
    def __init__(self, other):
        self.other = other
&nbsp;
<i># tři objekty, které na sebe navzájem ukazují</i>
x = A(None)
y = A(x)
z = A(y)
x.other=z
&nbsp;
<i># cyklické reference mezi objekty</i>
objgraph.show_backrefs([x, y, z], filename='objgraph7_backrefs.png')
</pre>

<a href="https://www.root.cz/obrazek/440159/"><img src="https://i.iinfo.cz/images/502/python-gc-3-10-prev.png" class="image-440159" alt="&#160;" width="229" height="270" /></a>
<p><i>Obrázek 23: Vzájemné vazby mezi trojicí objektů svázaných přes
atributy.</i></p>

<pre>
<i>"""Grafické zobrazení referencí."""</i>
&nbsp;
import objgraph
&nbsp;
a = {}
b = {}
c = {}
d = {}
e = {}
f = {}
&nbsp;
a["next"] = b
b["next"] = c
c["next"] = d
d["next"] = e
e["next"] = f
f["next"] = a
&nbsp;
<i># cyklické reference mezi objekty</i>
objgraph.show_backrefs([a, b, c, d, e, f], filename='objgraph8_backrefs.png')
</pre>

<img src="https://i.iinfo.cz/images/502/python-gc-3-11.png" class="image-440160" alt="&#160;" width="477" height="892" />
<p><i>Obrázek 24: Cyklická vazba mezi šesticí slovníků.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Zjištění počtu objektů v&nbsp;paměti (podle jejich typu)</h2>

<p>Užitečná je i funkce nazvaná <strong>show_growth</strong> nabízená knihovnou
<i>objgraph</i>. Tato funkce zobrazí informace o tom, kolik objektů na haldě
vzniklo od předchozího volání této funkce. Objekty jsou agregovány na základě
svého typu, což například znamená, že všechny slovníky jsou reprezentovány
jedním řádkem ve výsledku. Pokud je tato funkce volána periodicky, umožňuje
sledovat, co přesně se na haldě děje:</p>

<pre>
Help on function <strong>show_growth</strong> in module objgraph:
&nbsp;
show_growth(limit=10, peak_stats=None, shortnames=True, file=None, filter=None)
    Show the increase in peak object counts since last call.
&nbsp;
    if ``peak_stats`` is None, peak object counts will recorded in
    func `growth`, and your can record the counts by yourself with set
    ``peak_stats`` to a dictionary.
&nbsp;
    The caveats documented in :func:`growth` apply.
    &nbsp;    
    Example:
&nbsp;
        &gt;&gt;&gt; show_growth()
        wrapper_descriptor       970       +14
        tuple                  12282       +10
        dict                    1922        +7
        ...
&nbsp;
    .. versionadded:: 1.5
&nbsp;
    .. versionchanged:: 1.8
       New parameter: ``shortnames``.
</pre>

<p>Podívejme se nyní na jednoduchý demonstrační příklad, v&nbsp;němž vytváříme
nové objekty a mezi těmito operacemi voláme i funkci
<strong>show_growth</strong>:</p>

<pre>
<i>"""Zjištění počtu objektů v paměti."""</i>
&nbsp;
import objgraph
import queue
&nbsp;
x = {}
y = {}
&nbsp;
<strong>objgraph.show_growth()</strong>
print()
&nbsp;
x["1"] = y
&nbsp;
<strong>objgraph.show_growth()</strong>
print()
&nbsp;
y["2"] = x
&nbsp;
<strong>objgraph.show_growth()</strong>
print()
&nbsp;
x = Exception()
y = queue.Queue()
z = queue.LifoQueue()
&nbsp;
<strong>objgraph.show_growth()</strong>
print()
</pre>

<p>První volání vypíše stav na začátku programu a současně si tento stav
zapamatuje (čítače počtu jednotlivých typů objektů):</p>

<pre>
function                       2284     +2284
dict                           1250     +1250
tuple                          1020     +1020
wrapper_descriptor              998      +998
weakref                         903      +903
method_descriptor               732      +732
builtin_function_or_method      703      +703
set                             461      +461
getset_descriptor               410      +410
list                            372      +372
</pre>

<p>Další volání po zápisu reference do prvního slovníku:</p>

<pre>
dict     1251        +1
list      373        +1
</pre>

<p>Třetí volání po zápisu reference do druhého slovníku:</p>

<pre>
dict     1252        +1
</pre>

<p>Vytvoření (konstrukce) tří dalších objektů, mj.&nbsp;i typu
<strong>Exception</strong>, <strong>Queue</strong> a
<strong>LifoQueue</strong>:</p>

<pre>
&nbsp;
builtin_function_or_method      715       +12
deque                             8        +7
dict                           1258        +6
Condition                         7        +6
list                            374        +1
<strong>Exception                         1        +1</strong>
<strong>Queue                             1        +1</strong>
<strong>LifoQueue                         1        +1</strong>
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Sledování nově vytvořených objektů (podle typu)</h2>

<p>Poslední funkcí, o níž se dnes zmíníme, je funkce nazvaná
<strong>get_new_ids</strong>. Tato funkce zjistí a zobrazí počet nově
vytvořených objektů, opět seskupených podle typu. Při prvním zavolání si funkce
zapamatuje počty objektů, takže při dalším volání již dokáže zobrazit relativní
přírůstky:</p>

<pre>
Help on function get_new_ids in module objgraph:
&nbsp;
get_new_ids(skip_update=False, limit=10, sortby='deltas', shortnames=None, file=None, _state={})
    Find and display new objects allocated since last call.
&nbsp;   
    Shows the increase in object counts since last call to this
    function and returns the memory address ids for new objects.
&nbsp;
    Returns a dictionary mapping object type names to sets of object IDs
    that have been created since the last time this function was called.
&nbsp;
    ``skip_update`` (bool): If True, returns the same dictionary that
    was returned during the previous call without updating the internal
    state or examining the objects currently in memory.
&nbsp;
    ``limit`` (int): The maximum number of rows that you want to print
    data for.  Use 0 to suppress the printing.  Use None to print everything.
&nbsp;
    ``sortby`` (str): This is the column that you want to sort by in
    descending order.  Possible values are: 'old', 'current', 'new',
    'deltas'
&nbsp;
    ``shortnames`` (bool): If True, classes with the same name but
</pre>

<p>Ukažme si použití této funkce na jednoduchém příkladu:</p>

<pre>
<i>"""Zjištění konstrukce objektů v paměti."""</i>
&nbsp;
import objgraph
&nbsp;
x = {}
y = {}
&nbsp;
<strong>objgraph.get_new_ids()</strong>
print()
&nbsp;
x["1"] = y
&nbsp;
<strong>objgraph.get_new_ids()</strong>
print()
&nbsp;
y["2"] = x
&nbsp;
<strong>objgraph.get_new_ids()</strong>
print()
</pre>

<p>Při prvním volání se zobrazí tato tabulka &ndash; vychází se z&nbsp;toho, že
funkce si nezapamatovala předchozí hodnoty:</p>

<pre>
==============================================================================
Type                            Old_ids  Current_ids      New_ids Count_Deltas
==============================================================================
function                              0         2262        +2262        +2262
dict                                  0         1243        +1243        +1243
tuple                                 0         1011        +1011        +1011
wrapper_descriptor                    0          998         +998         +998
weakref                               0          898         +898         +898
method_descriptor                     0          732         +732         +732
builtin_function_or_method            0          703         +703         +703
set                                   0          461         +461         +461
getset_descriptor                     0          406         +406         +406
list                                  0          371         +371         +371
==============================================================================
</pre>

<p>Druhé volání ukazuje, že na haldě došlo ke změně:</p>

<pre>
======================================================================
Type                    Old_ids  Current_ids      New_ids Count_Deltas
======================================================================
set                         461          797         <strong>+336         +336</strong>
list                        371          372           <strong>+1           +1</strong>
dict                       1243         1244           <strong>+1           +1</strong>
zipimporter                   1            1           +0           +0
wrapper_descriptor          998          998           +0           +0
weakref                     898          898           +0           +0
uname_result                  1            1           +0           +0
type                        296          296           +0           +0
staticmethod                 39           39           +0           +0
property                    120          120           +0           +0
======================================================================
</pre>

<p>Třetí volání:</p>

<pre>
======================================================================
Type                    Old_ids  Current_ids      New_ids Count_Deltas
======================================================================
dict                       1244         1245           +1           +1
zipimporter                   1            1           +0           +0
wrapper_descriptor          998          998           +0           +0
weakref                     898          898           +0           +0
uname_result                  1            1           +0           +0
type                        296          296           +0           +0
tuple                      1010         1010           +0           +0
staticmethod                 39           39           +0           +0
set                         797          797           +0           +0
property                    120          120           +0           +0
======================================================================
</pre>

<p>Zajímavější bude zjistit, jak se změní počet objektů alokovaných
v&nbsp;rámci jedné funkce &ndash; otestujeme tak, jestli se volá správce paměti
či nikoli při opuštění funkce:</p>

<pre>
<i>"""Zjištění konstrukce objektů v paměti."""</i>
&nbsp;
import objgraph
import queue
&nbsp;
<strong>objgraph.get_new_ids()</strong>
&nbsp;
&nbsp;
def foo():
    x = <u>Exception()</u>
    y = <u>queue.Queue()</u>
    z = <u>queue.LifoQueue()</u>
    <strong>objgraph.get_new_ids()</strong>
&nbsp;
&nbsp;
foo()
<strong>objgraph.get_new_ids()</strong>
</pre>

<p>Zobrazení obsahu haldy po spuštění skriptu:</p>

<pre>
==============================================================================
Type                            Old_ids  Current_ids      New_ids Count_Deltas
==============================================================================
function                              0         2284        +2284        +2284
dict                                  0         1251        +1251        +1251
tuple                                 0         1020        +1020        +1020
wrapper_descriptor                    0          998         +998         +998
weakref                               0          903         +903         +903
method_descriptor                     0          732         +732         +732
builtin_function_or_method            0          703         +703         +703
set                                   0          461         +461         +461
getset_descriptor                     0          410         +410         +410
list                                  0          372         +372         +372
==============================================================================
</pre>

<p>Zjištění obsahu haldy uvnitř funkce s&nbsp;vytvořenými objekty:</p>

<pre>
==============================================================================
Type                            Old_ids  Current_ids      New_ids Count_Deltas
==============================================================================
set                                 461          797         +336         +336
builtin_function_or_method          703          715          +12          +12
dict                               1251         1259           +8           +8
deque                                 1            8           +7           +7
Condition                             1            7           +6           +6
list                                372          374           +2           +2
function                           2284         2285           +1           +1
frame                                 3            4           +2           +1
<strong>Queue                                 0            1           +1           +1</strong>
<strong>LifoQueue                             0            1           +1           +1</strong>
==============================================================================
</pre>

<p>A konečně poslední volání po opuštění funkce:</p>

<pre>
======================================================================
Type                    Old_ids  Current_ids      New_ids Count_Deltas
======================================================================
set                         797          806           +9           +9
zipimporter                   1            1           +0           +0
wrapper_descriptor          998          998           +0           +0
weakref                     903          903           +0           +0
uname_result                  1            1           +0           +0
type                        301          301           +0           +0
tuple                      1017         1017           +0           +0
staticmethod                 39           39           +0           +0
property                    120          120           +0           +0
partial                       1            1           +0           +0
======================================================================
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů určených pro
Python 3 a nejnovější stabilní verzi knihovny <i>Objgraph</i> byly uloženy do
Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>gc01.py</td><td>zobrazení počtu referencí řetězce 'Test!'</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc01.py</a></td></tr>
<tr><td> 2</td><td>gc02.py</td><td>zobrazení počtu referencí řetězce 'Test!'.</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc02.py</a></td></tr>
<tr><td> 3</td><td>gc03.py</td><td>zobrazení počtu referencí na malé celé číslo</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc03.py</a></td></tr>
<tr><td> 4</td><td>gc04.py</td><td>zobrazení počtu referencí na hodnotu True</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc04.py</a></td></tr>
<tr><td> 5</td><td>gc05.py</td><td>zobrazení počtu referencí na prázdný seznam</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc05.py</a></td></tr>
<tr><td> 6</td><td>gc06.py</td><td>zobrazení počtu referencí na řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc06.py</a></td></tr>
<tr><td> 7</td><td>gc07.py</td><td>dynamická změna počtu referencí na řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc07.py</a></td></tr>
<tr><td> 8</td><td>gc08.py</td><td>proměnné sdílející stejnou hodnotu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc08.py</a></td></tr>
<tr><td> 9</td><td>gc09.py</td><td>předání řetězce (reference) do funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc09.py</a></td></tr>
<tr><td>10</td><td>gc10.py</td><td>předání řetězce (reference) do funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc10.py</a></td></tr>
<tr><td>11</td><td>gc11.py</td><td>reference na různé hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc11.py</a></td></tr>
<tr><td>12</td><td>gc12.py</td><td>cyklické reference na různé hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc12.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc12.py</a></td></tr>
<tr><td>13</td><td>gc13.py</td><td>zjištění základních informací o správci paměti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc13.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc13.py</a></td></tr>
<tr><td>14</td><td>gc14.py</td><td>zjištění základních informací o správci paměti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc14.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc14.py</a></td></tr>
<tr><td>15</td><td>gc15_references.py</td><td>předání parametru (reference) do funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc15_references.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/gc15_references.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>get_new_ids1.py</td><td>sledování nově vytvořených hodnot (podle typu), základní použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/get_new_ids1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/get_new_ids1.py</a></td></tr>
<tr><td>17</td><td>get_new_ids2.py</td><td>sledování nově vytvořených hodnot (podle typu), příklad s&nbsp;instancemi tříd</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/get_new_ids2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/get_new_ids2.py</a></td></tr>
<tr><td>18</td><td>show_growth.py</td><td>zjištění počtu objektů v&nbsp;paměti (podle typu), příklad s&nbsp;instancemi tříd</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/show_growth.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/show_growth.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>objgraph1.py</td><td>grafické zobrazení referencí: jediný uzel představující řetězec v&nbsp;paměti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph1.py</a></td></tr>
<tr><td>20</td><td>objgraph2.py</td><td>grafické zobrazení referencí: dva uzly představující řetězce v&nbsp;paměti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph2.py</a></td></tr>
<tr><td>21</td><td>objgraph3.py</td><td>grafické zobrazení referencí: hodnoty referencované ze seznamu <strong>y</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph3.py</a></td></tr>
<tr><td>22</td><td>objgraph4.py</td><td>grafické zobrazení referencí: složitější hierarchie hodnot uložených v&nbsp;operační paměti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph4.py</a></td></tr>
<tr><td>23</td><td>objgraph5.py</td><td>grafické zobrazení referencí: postupný vznik cyklu v&nbsp;grafu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph5.py</a></td></tr>
<tr><td>24</td><td>objgraph6.py</td><td>grafické zobrazení referencí: tři slovníky, které se vzájemně referencují</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph6.py</a></td></tr>
<tr><td>25</td><td>objgraph7.py</td><td>grafické zobrazení referencí: tři objekty, které se vzájemně referencují</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph7.py</a></td></tr>
<tr><td>26</td><td>objgraph8.py</td><td>grafické zobrazení referencí: cyklus, který vede celkem přes šest uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph8.py</a></td></tr>
<tr><td>27</td><td>objgraph9.py</td><td>grafické zobrazení referencí: reference na hodnoty získané z&nbsp;celého globálního prostoru (jmen, tedy referencí)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph9.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>objgraph1_backrefs.py</td><td>grafické zobrazení referencí až k&nbsp;zadanému objektu: na řetězec "Foo"</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph1_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph1_backrefs.py</a></td></tr>
<tr><td>29</td><td>objgraph2_backrefs.py</td><td>grafické zobrazení referencí až k&nbsp;zadanému objektu: na prvky seznamu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph2_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph2_backrefs.py</a></td></tr>
<tr><td>30</td><td>objgraph3_backrefs.py</td><td>grafické zobrazení referencí až k&nbsp;zadanému objektu: na seznam (nevyhodnocený)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph3_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph3_backrefs.py</a></td></tr>
<tr><td>31</td><td>objgraph4_backrefs.py</td><td>grafické zobrazení referencí až k&nbsp;zadanému objektu: na řetězec a seznam</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph4_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph4_backrefs.py</a></td></tr>
<tr><td>32</td><td>objgraph5_backrefs.py</td><td>grafické zobrazení referencí až k&nbsp;zadanému objektu: cyklické závislosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph5_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph5_backrefs.py</a></td></tr>
<tr><td>33</td><td>objgraph6_backrefs.py</td><td>grafické zobrazení referencí až k&nbsp;zadanému objektu: tři slovníky, které se vzájemně referencují</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph6_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph6_backrefs.py</a></td></tr>
<tr><td>34</td><td>objgraph7_backrefs.py</td><td>grafické zobrazení referencí až k&nbsp;zadanému objektu: tři objekty, které se vzájemně referencují</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph7_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph7_backrefs.py</a></td></tr>
<tr><td>35</td><td>objgraph8_backrefs.py</td><td>grafické zobrazení referencí až k&nbsp;zadanému objektu: cyklus, který vede celkem přes šest uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph8_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph8_backrefs.py</a></td></tr>
<tr><td>36</td><td>objgraph9_backrefs.py</td><td>grafické zobrazení referencí až k&nbsp;zadanému objektu: reference na hodnoty získané z&nbsp;celého globálního prostoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph9_backrefs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/objgraph9_backrefs.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>37</td><td>lsize1.py</td><td>změna alokované paměti pro seznam při postupném přidávání prvků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/lsize1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/lsize1.py</a></td></tr>
<tr><td>38</td><td>lsize2.py</td><td>změna alokované paměti pro seznam při postupném odstraňování prvků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/lsize2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/lsize2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>interning1.py</td><td>konstrukce řetězců bez jejich interningu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/interning1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/interning1.py</a></td></tr>
<tr><td>40</td><td>interning2.py</td><td>konstrukce řetězců s&nbsp;jejich explicitním interningem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/interning2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/gc_objgraph/interning2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>objgraph 3.5.0 na PyPi<br />
<a href="https://pypi.org/project/objgraph/">https://pypi.org/project/objgraph/</a>
</li>

<li>Python Garbage Collection: What It Is and How It Works<br />
<a href="https://stackify.com/python-garbage-collection/">https://stackify.com/python-garbage-collection/</a>
</li>

<li>The Garbage Collector<br />
<a href="https://pythoninternal.wordpress.com/2014/08/04/the-garbage-collector/">https://pythoninternal.wordpress.com/2014/08/04/the-garbage-collector/</a>
</li>

<li>Nástroje pro tvorbu grafů a diagramů z příkazové řádky<br />
<a href="https://www.root.cz/clanky/nastroje-pro-tvorbu-grafu-a-diagramu-z-prikazove-radky/">https://www.root.cz/clanky/nastroje-pro-tvorbu-grafu-a-diagramu-z-prikazove-radky/</a>
</li>

<li>Graphviz - Graph Visualization Software<br />
<a href="https://www.graphviz.org/">https://www.graphviz.org/</a>
</li>

<li>Manuálová stránka nástroje Graphviz<br />
<a href="https://www.root.cz/man/7/graphviz/">https://www.root.cz/man/7/graphviz/</a>
</li>

<li>Manuálová stránka nástroje dot<br />
<a href="https://www.root.cz/man/1/dot/">https://www.root.cz/man/1/dot/</a>
</li>

<li>Graphviz na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Graphviz">https://en.wikipedia.org/wiki/Graphviz</a>
</li>

<li>Reference counting<br />
<a href="https://en.wikipedia.org/wiki/Reference_counting">https://en.wikipedia.org/wiki/Reference_counting</a>
</li>

<li>Tracing garbage collection<br />
<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a>
</li>

<li>Generational GC (ephemeral GC)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC)">https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC)</a>
</li>

<li>Graphviz pro Python<br />
<a href="https://graphviz.readthedocs.io/en/stable/examples.html">https://graphviz.readthedocs.io/en/stable/examples.html</a>
</li>

<li>Memory Management in Python<br />
<a href="https://www.slideshare.net/VijayKumarBagavathSi/memory-management-in-python">https://www.slideshare.net/VijayKumarBagavathSi/memory-management-in-python</a>
</li>

<li>Memory Management In Python The Basics<br />
<a href="https://www.slideshare.net/nnja/memory-management-in-python-the-basics">https://www.slideshare.net/nnja/memory-management-in-python-the-basics</a>
</li>

<li>Python execution model<br />
<a href="https://docs.python.org/3.8/reference/executionmodel.html">https://docs.python.org/3.8/reference/executionmodel.html</a>
</li>

<li>Guide to String Interning in Python<br />
<a href="https://stackabuse.com/guide-to-string-interning-in-python/">https://stackabuse.com/guide-to-string-interning-in-python/</a>
</li>

<li>Python Names and Values<br />
<a href="https://nedbatchelder.com/text/names1.html">https://nedbatchelder.com/text/names1.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>
