<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití nástroje Radon pro zjištění cyklomatické složitosti zdrojových kódů</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití nástroje Radon pro zjištění cyklomatické složitosti zdrojových kódů</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku si popíšeme základní vlastnosti nástroje Radon, který je určený pro zjišťování různých metrik zdrojových kódů napsaných v Pythonu. Mezi metriky zjišťované tímto nástrojem patří především cyklomatická složitost (CC) a index udržovatelnosti (MI).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Metriky používané při vývoji a analýze aplikací</a></p>
<p><a href="#k02">2. Cyklomatická složitost (Cyclomatic Complexity)</a></p>
<p><a href="#k03">3. Nástroj Radon</a></p>
<p><a href="#k04">4. Výpočet skóre cyklomatické složitosti jednotlivých programových bloků</a></p>
<p><a href="#k05">5. Instalace nástroje Radon</a></p>
<p><a href="#k06">6. Zjištění cyklomatické složitosti zdrojového kódu nástrojem Radon</a></p>
<p><a href="#k07">7. Čtení výstupu produkovaného nástrojem <i>Radon</i></a></p>
<p><a href="#k08">8. Cyklomatická složitost základních programových konstrukcí</a></p>
<p><a href="#k09">9. Jak probíhal výpočet?</a></p>
<p><a href="#k10">10. Získání informací o cyklomatické složitosti u funkcí s&nbsp;vnořenými smyčkami a podmínkami</a></p>
<p><a href="#k11">11. Cyklomatická složitost nechvalně proslulých zdrojových kódů</a></p>
<p><a href="#k12">12. A na závěr ... cyklomatická složitost nejhoršího kódu a nejnečitelnějšího kódu</a></p>
<p><a href="#k13">13. Cyklomatická složitost != měřítko čitelného kódu</a></p>
<p><a href="#k14">14. Úprava nástroje Radon pro vytvoření HTML stránky s&nbsp;výsledky</a></p>
<p><a href="#k15">15. Zjištění indexu udržovatelnosti (Maintainability Index)</a></p>
<p><a href="#k16">16. Výpočet indexu udržovatelnosti</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Metriky používané při vývoji a analýze aplikací</h2>

<p>Při vývoji nových aplikací popř.&nbsp;při analýze již existujících aplikací
je možné sledovat různé metriky popisující kvalitu celé aplikace. Kromě
klasických metrik, které jsou zaměřeny spíše na výsledný produkt a na jeho
chování při běhu (výkonnost, doba odezvy, střední doba selhání, ...) či na
procesy související s&nbsp;vývojem a údržbou produktu (cena, produktivita, ...)
se v&nbsp;některých případech používají i metriky, které se nějakým způsobem
snaží popsat složitost zdrojových kódů a tím pádem i pracnost opravy chyb či
přidávání nových vlastností. Z&nbsp;hlediska implementace je jednou
z&nbsp;nejjednodušších metrik tohoto typu takzvaná <i>cyklomatická
složitost</i> neboli <i>cyclomatic complexity</i>. Zjednodušeně řešeno se jedná
o číslo, kterým se snažíme vyjádřit složitost programu nebo jednotlivých
logických bloků, typicky funkcí, tříd a metod (popř.&nbsp;celých balíků).
Obecně platí, že čím větší je cyklomatická složitost daného bloku (například
funkce), tím více jednotkových testů je zapotřebí vytvořit a tím složitější
jsou případné další úpravy kódu (či jen jeho prosté pochopení).</p>

<p>Ve vybrané části programu se cyklomatická složitost počítá pomocí grafu toku
řízení toho programu: uzly grafu odpovídají neoddělitelným skupinám
v&nbsp;programu (například tělu cyklu, podmínky). Orientované hrany odpovídají
tomu, v&nbsp;jakém pořadí se skupiny příkazů budou provádět. Cyklomatickou
složitost je možné aplikovat individuálně na vybrané funkce, moduly, metody
nebo třídy [<a
href="https://cs.wikipedia.org/wiki/Cyklomatick%C3%A1_slo%C5%BEitost">1</a>].</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Cyklomatická složitost (Cyclomatic Complexity)</h2>

<p>Implementace měření cyklomatické složitosti je relativně snadná díky tomu,
že se pouze zjišťuje počet možných cest ve zdrojovém kódu, tj.&nbsp;provádí se
statická analýza, která nevyžaduje měření prováděné v&nbsp;běžící aplikaci.
Typicky se nástroje pro měření cyklomatické složitosti zaměřují na zjišťování
počtu rozhodovacích konstrukcí (<strong>if-then</strong>,
<strong>if-then-else</strong>, <strong>switch</strong>), programových smyček
(<strong>while</strong>, <strong>repeat</strong>, <strong>for</strong>,
generátorové notace seznamu), konstrukcí pro zpracování výjimek
(<strong>try-catch-finally/try-except-finally</strong>) a někdy se složitost
zvyšuje i s&nbsp;každou booleovskou operací v&nbsp;podmínce nebo programové
smyčce popř.&nbsp;pro příkaz <strong>assert</strong> (ten totiž také rozvětvuje
běh programu). Tyto informace lze velmi snadno zjistit z&nbsp;abstraktního
syntaktického stromu (<i>AST &ndash; Abstract Syntax Tree</i>), což je i případ
nástroje nazvaného <i>Radon</i>, jehož možnosti budou popsány
v&nbsp;navazujících kapitolách.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nástroj Radon</h2>

<p>Jedním z&nbsp;užitečných a přitom velmi jednoduše použitelných nástrojů
určených pro měření cyklomatické složitosti a současně i indexu udržovatelnosti
zdrojových kódů psaných v&nbsp;Pythonu je aplikace nazvaná <i>Radon</i>. Jedná
se o nástroj ovládaný z&nbsp;příkazové řádky, který je založený na nepřímé
analýze kódu s&nbsp;využitím abstraktního syntaktického stromu (AST). To
znamená, že pokud tento nástroj spustíme nad nějakým projektem, je nejdříve
provedena lexikální analýza zdrojových kódů, následně syntaktická analýza,
jejím výsledkem je AST a cyklomatická složitost je zjišťována při průchodu
tímto stromem. Nástroj <i>Radon</i> rozděluje celý zdrojový kód na bloky
&ndash; funkce, třídy a metody &ndash; a počítá pro každý blok celočíselné
skóre. Taktéž rozděluje bloky do šesti kategorií A-F na základě dosaženého
skóre, takže je možné velmi snadno zjistit, které bloky vyžadují úpravy
(<i>refaktoring</i>).</p>

<p><div class="rs-tip-major">Poznámka: skóre každého bloku je přirozené číslo,
ovšem celková cyklomatická složitost se spočítá jako průměr skóre všech bloků a
tudíž se jedná o reálné číslo větší než 1 (shora neomezeno, prakticky se však
přes 50 nedostanete).</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpočet skóre cyklomatické složitosti jednotlivých programových bloků</h2>

<p>Výchozí skóre každého bloku je nastaveno na jedničku a při procházení AST se
skóre zvyšuje podle toho, jakou programovou konstrukci Radon našel. Všechny
důležité jazykové konstrukce Pythonu jsou vypsány v&nbsp;následující tabulce i
s&nbsp;vysvětlením, kdy a proč je skóre započítáno:</p>

<table>
<tr><th>Konstrukce</th><th>Změna skóre</th><th>Význam</th></tr>
<tr><td>if</td><td>+1</td><td>zvyšuje se počet cest, kterými lze kódem projít</td></tr>
<tr><td>elif</td><td>+1</td><td>zvyšuje se počet cest, kterými lze kódem projít</td></tr>
<tr><td>else</td><td>+0</td><td>nemá žádný význam z&nbsp;hlediska složitosti (je započteno u <strong>if</strong>)</td></tr>
<tr><td>for</td><td>+1</td><td>na začátku programové smyčky je rozhodovací konstrukce</td></tr>
<tr><td>while</td><td>+1</td><td>na začátku programové smyčky je rozhodovací konstrukce</td></tr>
<tr><td>except</td><td>+1</td><td>zvyšuje se počet cest, kterými lze kódem projít</td></tr>
<tr><td>finally</td><td>+0</td><td>žádný význam z&nbsp;hlediska složitosti (provede se vždy)</td></tr>
<tr><td>with</td><td>+1</td><td>zhruba odpovídá bloku <strong>try/except</strong></td></tr>
<tr><td>assert</td><td>+1</td><td>svým chováním odpovídá rozhodovací konstrukci <strong>if</strong></td></tr>
<tr><td>generátorová notace seznamu</td><td>+1</td><td>svým chováním odpovídá smyčce <strong>for</strong></td></tr>
<tr><td>pravdivostní operátor</td><td>+1</td><td>každý binární operátor přidává další bod, v&nbsp;němž se rozhoduje o dalším chování</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: díky jednoduché syntaxi Pythonu nebylo
nutné počítat skóre u bloků typu <strong>switch-case</strong>, což je již
složitější a mnoho vývojářů a testerů nesouhlasí s&nbsp;tím, aby každý blok
<strong>case</strong> zvyšoval skóre o jedničku, protože mnoho rozhodovacích
konstrukcí <strong>switch-case</strong> je velmi přehledných.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instalace nástroje Radon</h2>

<p>Instalace nástroje <i>Radon</i> je snadná, protože se jedná o projekt
naprogramovaný pouze v&nbsp;Pythonu, tj.&nbsp;obejdeme se bez nutnosti překladu
nativních knihoven atd. Samotná instalace bude provedena do domácího adresáře
právě přihlášeného uživatele, což je zajištěno přepínačem
<strong>--user</strong>. Kromě vlastního zdrojového kódu knihovny se ještě
nainstaluje skript nazvaný <strong>radon</strong>, a to většinou do adresáře
<strong>~/.local/bin/</strong>:</p>

<pre>
$ <strong>pip3 install --user radon</strong>
</pre>

<p>Průběh instalace může vypadat následovně (povšimněte si instalace závislých
modulů a knihoven):</p>

<pre>
Downloading/unpacking radon
  Downloading radon-2.2.0-py2.py3-none-any.whl (46kB): 46kB downloaded
Downloading/unpacking colorama&gt;=0.3,&lt;0.4 (from radon)
  Downloading colorama-0.3.9-py2.py3-none-any.whl
Downloading/unpacking mando&gt;=0.6,&lt;0.7 (from radon)
  Downloading mando-0.6.4-py2.py3-none-any.whl
Downloading/unpacking flake8-polyfill (from radon)
  Downloading flake8_polyfill-1.0.2-py2.py3-none-any.whl
Requirement already satisfied (use --upgrade to upgrade): six in /home/tester/.local/lib/python3.4/site-packages (from mando&gt;=0.6,&lt;0.7-&gt;radon)
Downloading/unpacking flake8 (from flake8-polyfill-&gt;radon)
  Downloading flake8-3.5.0-py2.py3-none-any.whl (69kB): 69kB downloaded
Downloading/unpacking mccabe&gt;=0.6.0,&lt;0.7.0 (from flake8-&gt;flake8-polyfill-&gt;radon)
  Downloading mccabe-0.6.1-py2.py3-none-any.whl
Downloading/unpacking pyflakes&gt;=1.5.0,&lt;1.7.0 (from flake8-&gt;flake8-polyfill-&gt;radon)
  Downloading pyflakes-1.6.0-py2.py3-none-any.whl (227kB): 227kB downloaded
Downloading/unpacking pycodestyle&gt;=2.0.0,&lt;2.4.0 (from flake8-&gt;flake8-polyfill-&gt;radon)
  Downloading pycodestyle-2.3.1-py2.py3-none-any.whl (45kB): 45kB downloaded
Installing collected packages: radon, colorama, mando, flake8-polyfill, flake8, mccabe, pyflakes, pycodestyle
Successfully installed radon colorama mando flake8-polyfill flake8 mccabe pyflakes pycodestyle
Cleaning up...
</pre>

<p>To, zda je <i>radon</i> nainstalován korektně, lze zjistit snadno:</p>

<pre>
$ <strong>whereis radon</strong>
&nbsp;
radon: /home/tester/.local/bin/radon
</pre>

<p>V&nbsp;případě, že předchozí příkaz nezobrazí žádný výstup (pouze
&bdquo;radon:&ldquo;), je to většinou způsobeno tím, že adresář
&bdquo;.local/bin&ldquo; není přidán do proměnné prostředí
<strong>PATH</strong>. V&nbsp;případě, že je binární soubor
<strong>radon</strong> skutečně spustitelný, zjistíme přímočaře následujícím
způsobem:</p>

<pre>
$ <strong>radon</strong>
&nbsp;
usage: radon [-h] [-v] {cc,raw,mi} ...
&nbsp;
positional arguments:
  {cc,raw,mi}
    cc           Analyze the given Python modules and compute Cyclomatic
                 Complexity (CC).
    raw          Analyze the given Python modules and compute raw metrics.
    mi           Analyze the given Python modules and compute the
                 Maintainability Index.
&nbsp;
optional arguments:
  -h, --help     show this help message and exit
  -v, --version  show program's version number and exit
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zjištění cyklomatické složitosti zdrojového kódu nástrojem Radon</h2>

<p>Podívejme se nyní na formát výstupu, který je produkovaný nástrojem
<i>Radon</i> při analýze cyklomatické složitosti. Nejprve si naklonujte <a
href="https://github.com/tisnik/radon-examples">repositář s&nbsp;demonstračními
skripty</a>, protože příkaz <strong>radon</strong> budeme pouštět v&nbsp;tomto
repositáři:</p>

<pre>
$ <strong>git clone https://github.com/tisnik/radon-examples.git</strong>
&nbsp;
Cloning into 'radon-examples'...
remote: Counting objects: 18, done.
remote: Compressing objects: 100% (12/12), done.
remote: Total 18 (delta 4), reused 15 (delta 4), pack-reused 0
Unpacking objects: 100% (18/18), done.
Checking connectivity... done.
&nbsp;
$ <strong>cd radon-examples</strong>
</pre>

<p>Pro jednoduchý modul obsahující pouze funkce (a nikoli třídy
s&nbsp;metodami) se cyklomatická složitost získá příkazem <strong>radon cc
.</strong>, kde &bdquo;cc&ldquo; znamená &bdquo;Cyclomatic Complexity&ldquo; a
tečka označuje aktuální adresář:</p>

<pre>
$ <strong>radon cc .</strong>
</pre>

<p>Výstup by měl vypadat přibližně takto:</p>

<pre>
genpassword.py
    F 3:0 genpassword - F
hello_world.py
    F 1:0 hello - A
bubble_sort.py
    F 1:0 bubbleSort - A
control_structures.py
    F 56:0 max2 - A
    F 25:0 if_elif_else - A
    F 34:0 nested_if_else - A
    F 44:0 max1 - A
    F 72:0 fibonacci2 - A
    F 12:0 one_if - A
    F 18:0 one_if_else - A
    F 65:0 fibonacci1 - A
    F 78:0 factorial1 - A
    F 86:0 factorial2 - A
    F 93:0 factorial3 - A
    F 1:0 nothing - A
    F 5:0 simple - A
mandelbrot.py
    F 5:0 calc_mandelbrot - A
v_poradi.py
    F 3:0 vporadi - B
mandelbrot_complex.py
    F 20:0 calc_mandelbrot - A
</pre>

<p>V&nbsp;případě, že se v&nbsp;analyzovaných zdrojových kódech nachází i třídy
s&nbsp;metodami, bude výstup vypadat nepatrně odlišně:</p>

<pre>
cls/dxf_importer.py
    M 185:4 DxfImporter.process_entity - C
    M 103:4 DxfImporter.process_beginning_section - B
    M 163:4 DxfImporter.process_section_entities - B
    M 88:4 DxfImporter.process_beginning - A
    M 227:4 DxfImporter.store_entity - A
    C 22:0 DxfImporter - A
    M 48:4 DxfImporter.dxf_entry - A
    M 142:4 DxfImporter.process_section_blocks - A
    M 152:4 DxfImporter.process_section_block - A
    M 72:4 DxfImporter.import_dxf - A
    M 128:4 DxfImporter.process_section_header - A
    M 135:4 DxfImporter.process_section_tables - A
    M 179:4 DxfImporter.process_section_objects - A
    M 25:4 DxfImporter.__init__ - A
    M 59:4 DxfImporter.init_import - A
    M 239:4 DxfImporter.store_line - A
    M 242:4 DxfImporter.store_circle - A
    M 245:4 DxfImporter.store_arc - A
    M 249:4 DxfImporter.store_text - A
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Čtení výstupu produkovaného nástrojem <i>Radon</i></h2>

<p>Výpis informací o cyklomatické složitosti jednoho programového bloku vypadá
takto:</p>

<pre>
control_structures.py
    F 56:0 max2 - A (5)
</pre>

<p>Vidíme, že se nejdříve zobrazí jméno souboru obsahujícího zdrojový kód.
Soubor je zobrazen i s&nbsp;cestou, což zlepšuje orientaci ve složitěji
strukturovaných aplikacích. Následně se na dalších řádcích zobrazují informace
o nalezených blocích kódu. Nejprve je vypsán typ bloku, což je jeden ze znaků
&bdquo;F&ldquo;, &bdquo;M&ldquo; a &bdquo;C&ldquo; &nbsp;následujícím
významem:</p>

<table>
<tr><th>Označení</th><th>Typ bloku</th></tr>
<tr><td>F</td><td>funkce</td></tr>
<tr><td>M</td><td>metoda</td></tr>
<tr><td>C</td><td>třída</td></tr>
</table>

<p>Dále je vypsáno umístění bloku (v&nbsp;rámci zdrojového kódu) a jméno bloku,
tj.&nbsp;jméno funkce, metody popř.&nbsp;třídy. Za těmito informacemi se již
vypisuje vypočtená kategorie cyklomatické složitosti, což je znak
&bdquo;A&ldquo; až &bdquo;F&ldquo;. Přitom platí, že bloky kategorie
&bdquo;A&ldquo; mají nejnižší složitost (funkce s&nbsp;jednou smyčkou či
podmínkou), zatímco bloky kategorie &bdquo;F&ldquo; jsou velmi složité a
pravděpodobně budou obsahovat potenciálně nestabilní a těžko pochopitelný
kód:</p>

<table>
<tr><th>Skóre</th><th>Kategorie</th><th>Riziko</th></tr>
<tr><td>1 - 5</td><td>A</td><td>nízké, malá komplexita, jednoduché bloky</td></tr>
<tr><td>6 - 10</td><td>B</td><td>nízké, dobrá struktura programu</td></tr>
<tr><td>11 - 20</td><td>C</td><td>průměrné, obsahuje nepatrně složitější bloky kódu</td></tr>
<tr><td>21 - 30</td><td>D</td><td>vyšší, obsahuje složitější bloky kódu</td></tr>
<tr><td>31 - 40</td><td>E</td><td>vyšší, složité bloky kódu nebo složité podmínky</td></tr>
<tr><td>41+</td><td>F</td><td>vysoké, potenciálně nestabilní kód s&nbsp;rizikem zanesení nových chyb</td></tr>
</table>

<p>Kromě kategorie je možné si nechat zobrazit i vypočtené skóre,
tj.&nbsp;vlastní cyklomatickou složitost. To se provede následovně:</p>

<pre>
$ <strong>radon cc -s .</strong>
</pre>

<p>Skóre je zobrazeno v&nbsp;závorce za kategorií:</p>

<pre>
genpassword.py
    F 3:0 genpassword - F (41)
hello_world.py
    F 1:0 hello - A (1)
bubble_sort.py
    F 1:0 bubbleSort - A (4)
control_structures.py
    F 56:0 max2 - A (5)
    F 25:0 if_elif_else - A (3)
    F 34:0 nested_if_else - A (3)
    F 44:0 max1 - A (3)
    F 72:0 fibonacci2 - A (3)
    F 12:0 one_if - A (2)
    F 18:0 one_if_else - A (2)
    F 65:0 fibonacci1 - A (2)
    F 78:0 factorial1 - A (2)
    F 86:0 factorial2 - A (2)
    F 93:0 factorial3 - A (2)
    F 1:0 nothing - A (1)
    F 5:0 simple - A (1)
mandelbrot.py
    F 5:0 calc_mandelbrot - A (5)
v_poradi.py
    F 3:0 vporadi - B (10)
mandelbrot_complex.py
    F 20:0 calc_mandelbrot - A (5)
</pre>

<p>Také je možné si nechat spočítat průměrnou cyklomatickou složitost. Ta se
vypíše na samotném konci:</p>

<pre>
$ <strong>radon cc -s -a .</strong>
&nbsp;
genpassword.py
    F 3:0 genpassword - F (41)
hello_world.py
    F 1:0 hello - A (1)
bubble_sort.py
    F 1:0 bubbleSort - A (4)
control_structures.py
    F 56:0 max2 - A (5)
    F 25:0 if_elif_else - A (3)
    F 34:0 nested_if_else - A (3)
    F 44:0 max1 - A (3)
    F 72:0 fibonacci2 - A (3)
    F 12:0 one_if - A (2)
    F 18:0 one_if_else - A (2)
    F 65:0 fibonacci1 - A (2)
    F 78:0 factorial1 - A (2)
    F 86:0 factorial2 - A (2)
    F 93:0 factorial3 - A (2)
    F 1:0 nothing - A (1)
    F 5:0 simple - A (1)
mandelbrot.py
    F 5:0 calc_mandelbrot - A (5)
v_poradi.py
    F 3:0 vporadi - B (10)
mandelbrot_complex.py
    F 20:0 calc_mandelbrot - A (5)
&nbsp;
19 blocks (classes, functions, methods) analyzed.
Average complexity: B (5.105263157894737)
</pre>

<p>Existují i další varianty, například filtrace jen těch horších hodnot,
například kategorií od B výše:</p>

<pre>
$ <strong>~/.local/bin/radon cc -s -a -n B .</strong>
genpassword.py
    F 3:0 genpassword - F (41)
v_poradi.py
    F 3:0 vporadi - B (10)
cls/dxf_importer.py
    M 185:4 DxfImporter.process_entity - C (17)
    M 103:4 DxfImporter.process_beginning_section - B (7)
    M 163:4 DxfImporter.process_section_entities - B (7)

5 blocks (classes, functions, methods) analyzed.
Average complexity: C (16.4)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Cyklomatická složitost základních programových konstrukcí</h2>

<p>Otestujme si nyní, jak přesně probíhá výpočet cyklomatické složitosti
v&nbsp;nástroji <i>Radon</i>. Začneme příkladem s&nbsp;jedinou funkcí,
v&nbsp;níž se pouze volá jiná funkce <strong>print</strong>, což nijak
nezvyšuje cyklomatickou složitost. Výsledkem by tedy měla být výchozí hodnota
&ndash; 1:</p>

<pre>
def hello():
    print("Hello world!")
&nbsp;
&nbsp;
if __name__ == "__main__":
    hello()
</pre>

<p>Výpočet a výpis kategorie složitosti:</p>

<pre>
$ <strong>radon cc hello_world.py</strong>
&nbsp;
hello_world.py
    F 1:0 hello - A
</pre>

<p>Výpočet a výpis kategorie složitosti i vypočteného skóre:</p>

<pre>
$ <strong>radon cc -s hello_world.py</strong>
&nbsp;
hello_world.py
    F 1:0 hello - A (1)
</pre>

<p>Dtto ovšem navíc se zobrazí i průměrná složitost:</p>

<pre>
$ <strong>radon cc -s -a hello_world.py </strong>
&nbsp;
hello_world.py
    F 1:0 hello - A (1)
&nbsp;
1 blocks (classes, functions, methods) analyzed.
Average complexity: A (1.0)
</pre>

<p>Další příklad již obsahuje větší počet funkcí, od těch zcela jednoduchých
(se složitostí rovnou jedné) až po funkce se smyčkami
popř.&nbsp;s&nbsp;vnořenými podmínkami:</p>

<pre>
def nothing():
    pass
&nbsp;
&nbsp;
def simple():
    print(1)
    print(2)
    print(3)
    print(4)
&nbsp;
&nbsp;
def one_if(x):
    if x &gt; 0:
        return 42
    return None
&nbsp;
&nbsp;
def one_if_else(x):
    if x &gt; 0:
        return 42
    else:
        return None
&nbsp;
&nbsp;
def if_elif_else(x):
    if x &gt; 0:
        return "kladny"
    elif x &lt; 0:
        return "zaporny"
    else:
        return "nula"
&nbsp;
&nbsp;
def nested_if_else(x):
    if x &gt; 0:
        return "kladny"
    else:
        if x &lt; 0:
            return "zaporny"
        else:
            return "nula"
&nbsp;
&nbsp;
def max1(a, b, c):
    maximum = a
&nbsp;
    if b &gt; maximum:
        maximum = b
&nbsp;
    if c &gt; maximum:
        maximum = c
&nbsp;
    return maximum
&nbsp;
&nbsp;
def max2(a, b, c):
    if a &gt; b and a &gt; c:
        return a
    elif b &gt; a and b &gt; c:
        return b
    else:
        return c
&nbsp;
&nbsp;
def fibonacci1(i):
    x, y = 1, 1
    for i in range(i - 1):
        x, y = y, x + y
    return x
&nbsp;
&nbsp;
def fibonacci2(i):
    if i == 1 or i == 2:
        return 1
    return fibonacci2(i-1) + fibonacci2(i-2)
&nbsp;
&nbsp;
def factorial1(n):
    result = 1
    while n &gt;= 1:
        result *= n
        n -= 1
    return result
&nbsp;
&nbsp;
def factorial2(n):
    if n == 0:
        return 1
    else:
        return n * factorial2(n-1)
&nbsp;
&nbsp;
def factorial3(n):
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result
</pre>

<p>Výsledek:</p>

<pre>
$ <strong>radon cc -s -a control_structures.py </strong>
&nbsp;
control_structures.py
    F 1:0 nothing - A (1)
    F 5:0 simple - A (1)
    F 12:0 one_if - A (2)
    F 18:0 one_if_else - A (2)
    F 25:0 if_elif_else - A (3)
    F 34:0 nested_if_else - A (3)
    F 44:0 max1 - A (3)
    F 56:0 max2 - A (5)
    F 65:0 fibonacci1 - A (2)
    F 72:0 fibonacci2 - A (3)
    F 78:0 factorial1 - A (2)
    F 86:0 factorial2 - A (2)
    F 93:0 factorial3 - A (2)
&nbsp;
13 blocks (classes, functions, methods) analyzed.
Average complexity: A (2.3846153846153846)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Jak probíhal výpočet?</h2>

<p>Podívejme se, jakým způsobem vlastně probíhal výpočet cyklomatické
složitosti:</p>

<table>
<tr><th>Funkce</th><th>výchozí skóre</th><th>podmínka</th><th>smyčka</th><th>bool</th><th>Celkem</th><th>Poznámka</th></tr>
<tr><td>nothing</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>jen <strong>pass</strong></td></tr>
<tr><td>simple</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>jednoduché příkazy</td></tr>
<tr><td>one_if</td><td>1</td><td>1</td><td>0</td><td>0</td><td>2</td><td>jediná podmínka</td></tr>
<tr><td>one_if_else</td><td>1</td><td>1</td><td>0</td><td>0</td><td>2</td><td><strong>else</strong> se nezapočítává</td></tr>
<tr><td>if_elif_else</td><td>1</td><td>2</td><td>0</td><td>0</td><td>3</td><td><strong>elif</strong> se započítává jako <strong>if</strong></td></tr>
<tr><td>nested_if_else</td><td>1</td><td>2</td><td>0</td><td>0</td><td>3</td><td><strong>else</strong> se nezapočítává</td></tr>
<tr><td>max1</td><td>1</td><td>2</td><td>0</td><td>0</td><td>3</td><td><strong>if</strong> nejsou vnořeny</td></tr>
<tr><td>max2</td><td>1</td><td>2</td><td>0</td><td>2</td><td>5</td><td>booleovské výrazy zvýšily složitost</td></tr>
<tr><td>fibonacci1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>2</td><td>smyčka</td></tr>
<tr><td>fibonacci2</td><td>1</td><td>1</td><td>0</td><td>1</td><td>3</td><td>podmínka + booleovský výraz</td></tr>
<tr><td>factorial1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>2</td><td>jen smyčka</td></tr>
<tr><td>factorial2</td><td>1</td><td>1</td><td>0</td><td>0</td><td>2</td><td>jen podmínka</td></tr>
<tr><td>factorial3</td><td>1</td><td>0</td><td>1</td><td>0</td><td>2</td><td>jen smyčka</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: jeden z&nbsp;důvodů, proč je metrika
cyklomatické složitosti někdy kritizována, spočívá v&nbsp;tom, že se nikde
nezohledňují rekurzivní volání funkcí, i když se zajisté jedná o komplikaci
programu. To je ostatně vidět i při pohledu na předchozí tabulku, v&nbsp;níž
jsou dvě rekurzivní funkce s&nbsp;velmi malou vypočtenou složitostí.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Získání informací o cyklomatické složitosti u funkcí s&nbsp;vnořenými smyčkami a podmínkami</h2>

<p>Již bez podrobnějších výpočtů se podívejme na poněkud složitější funkce,
které obsahují vnořené programové smyčky a podmínky. Začneme školním příkladem
&ndash; bublinkovým řazením. To lze v&nbsp;Pythonu implementovat například
takto (setříděné prvky &bdquo;probublávají na konec seznamu, proto můžeme
postupně snižovat mezní hodnotu počitadla ve vnitřní smyčce)&ldquo;:</p>

<pre>
def bubbleSort(sequence):
    for i in range(len(sequence)-1, 0, -1):
        for j in range(i):
            if sequence[j] &gt; sequence[j+1]:
                sequence[j], sequence[j+1] = sequence[j+1], sequence[j]
&nbsp;
&nbsp;
numbers = [1, 2, 3, 4, 5]
bubbleSort(numbers)
print(numbers)
&nbsp;
numbers = [5, 4, 3, 2, 1]
bubbleSort(numbers)
print(numbers)
</pre>

<p>Vypočtená cyklomatická složitost je stále relativně nízká &ndash; skóre
dosahuje hodnoty 4, protože se ve funkci nachází dvě smyčky a jedna
podmínka:</p>

<pre>
$ <strong>radon cc -s -a bubble_sort.py </strong>
&nbsp;
bubble_sort.py
    F 1:0 bubbleSort - A (4)
&nbsp;
1 blocks (classes, functions, methods) analyzed.
Average complexity: A (4.0)
</pre>

<p>Složitější je již funkce pro výpočet <a
href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xii/">Mandelbrotovy
množiny</a>, a to bez použití komplexních čísel:</p>

<pre>
import palette_mandmap
from sys import argv, exit
&nbsp;
&nbsp;
def calc_mandelbrot(width, height, maxiter, palette):
    print("P3")
    print("{w} {h}".format(w=width, h=height))
    print("255")
&nbsp;
    cy = -1.5
    for y in range(0, height):
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print("{r} {g} {b}".format(r=r, g=g, b=b))
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        print("usage: python mandelbrot width height maxiter")
        exit(1)
&nbsp;
    width = int(argv[1])
    height = int(argv[2])
    maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p>Alternativně je možné funkci přepsat takovým způsobem, aby <a
href="https://python-reference.readthedocs.io/en/latest/docs/complex/">komplexní
čísla</a> používala:</p>

<pre>
import palette_mandmap
from sys import argv, exit
&nbsp;
&nbsp;
def calc_mandelbrot(width, height, maxiter, palette):
    print("P3")
    print("{w} {h}".format(w=width, h=height))
    print("255")
&nbsp;
    c = 0.0 - 1.5J
    for y in range(0, height):
        c = complex(-2.0, c.imag)
        for x in range(0, width):
            z = 0.0 + 0.0J
            i = 0
            while i &lt; maxiter:
                if abs(z) &gt; 4.0:
                    break
                z = z**2 + c
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print("{r} {g} {b}".format(r=r, g=g, b=b))
            c += 3.0/width
        c += 3.0J/height
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        print("usage: python mandelbrot width height maxiter")
        exit(1)
&nbsp;
    width = int(argv[1])
    height = int(argv[2])
    maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p>Nezávisle na tom, že druhá funkce je nepatrně kratší než funkce první, mají
oba výpočty Mandelbrotovy množiny naprosto stejnou cyklomatickou složitost
(opět nízkou, jen 5), protože obsahují tři vnořené smyčky a jedinou
podmínku:</p>

<pre>
$ <strong>radon cc -s -a mand*</strong>
&nbsp;
mandelbrot_complex.py
    F 20:0 calc_mandelbrot - A (5)
mandelbrot.py
    F 5:0 calc_mandelbrot - A (5)
&nbsp;
2 blocks (classes, functions, methods) analyzed.
Average complexity: A (5.0)
</pre>

<p><div class="rs-tip-major">Tyto funkce ještě není nutné refaktorovat, protože
jsou ještě poměrně krátké, dělají jednu činnost a jejich cyklomatická složitost
stále spadá do kategorie <strong>A</strong>. Ovšem již se nacházíme na hranici
s&nbsp;kategorií <strong>B</strong>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Cyklomatická složitost nechvalně proslulých zdrojových kódů</h2>

<p>Na stránce <a href="http://hovnokod.cz/2744">http://hovnokod.cz/2744</a>
můžeme najít relativně krátkou, ale již docela &bdquo;začmodrchanou&ldquo;
funkci:</p>

<pre>
def vporadi(x,y,z):
    if (x&lt;y) and (x&lt;z):
        if (y&lt;z):
            print(x,y,z)
        else:
            print(x,z,y)
    if (y&lt;x) and (y&lt;z):
        if (x&lt;z):
            print(y,x,z)
        else:
            print(y,z,x)
    if (z&lt;y) and (z&lt;x):
        if (y&lt;x):
            print(z,y,x)
        else:
            print(z,x,y)
</pre>

<p>Pomiňme fakt, že <strong>and</strong> má <a
href="http://www.mathcs.emory.edu/~valerie/courses/fall10/155/resources/op_precedence.html">nižší
prioritu než relační operátory</a>, takže jsou závorky zbytečné a zaměřme se na
výpočet cyklomatické složitosti:</p>

<pre>
$ <strong>radon cc -s -a v_poradi.py </strong>
&nbsp;
v_poradi.py
    F 3:0 vporadi - B (10)
&nbsp;
1 blocks (classes, functions, methods) analyzed.
Average complexity: B (10.0)
</pre>

<p>I takto krátká funkce má cyklomatickou složitost 10, což je na hranici mezi
kategorií B a C.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. A na závěr ... cyklomatická složitost nejhoršího kódu a nejnečitelnějšího kódu</h2>

<p>I další inspiraci jsem získal na slavném serveru, tentokrát na adrese <a
href="http://hovnokod.cz/1429">http://hovnokod.cz/1429</a>. Po nepatrné úpravě
(příkaz <strong>print</strong> &rarr; funkce <strong>print</strong>) vypadá kód
neuvěřitelně:</p>

<pre>
def genpassword(wlc,maxchar,txt,List,verbose):
    word = ""
    i1 = i2 = i3 = i4 = i5 = i6 = i6 = i7 = i8 = i9 = i10 = i11 = i12 = i13 = i14 = i15 = 0
    txtfile = open(txt,'w')
&nbsp;
    i = 0
    mc = int(maxchar) - 1
    lword = [0]
    for i in range(mc):
        lword += [0]  
&nbsp;
    for i1 in range(len(wlc)):
        for i2 in range(len(wlc)):
            for i3 in range(len(wlc)):
                for i4 in range(len(wlc)):
                    for i5 in range(len(wlc)):
                        for i6 in range(len(wlc)):
                            for i7 in range(len(wlc)):
                                for i8 in range(len(wlc)):
                                    for i9 in range(len(wlc)):
                                        for i10 in range(len(wlc)):
                                            for i11 in range(len(wlc)):
                                                for i12 in range(len(wlc)):
                                                    for i13 in range(len(wlc)):
                                                        for i14 in range(len(wlc)):
                                                            for i15 in range(len(wlc)):
                                                                if int(maxchar) == 1 :
                                                                    word = wlc[i15]
                                                                if int(maxchar) == 2 :
                                                                    word = wlc[i14] + wlc[i15]
                                                                if int(maxchar) == 3 :
                                                                    word = wlc[i13] + wlc[i14] + wlc[i15]
&nbsp; 
                                                                if int(maxchar) == 14 :
                                                                    word = wlc[i1] + wlc[i2] + wlc[i3] + wlc[i4] \
                                                                    + wlc[i5] + wlc[i6] + wlc[i7] + wlc[i8] + wlc[i9] \
                                                                    + wlc[i10] + wlc[i11] + wlc[i12] + wlc[i13] \
                                                                    + wlc[i14] + wlc[i15]
&nbsp;
                                                                if int(maxchar) == 15 :
                                                                    word = wlc[i1] + wlc[i2] + wlc[i3] + wlc[i4] \
                                                                    + wlc[i5] + wlc[i6] + wlc[i7] + wlc[i8] + wlc[i9] \
                                                                    + wlc[i10] + wlc[i11] + wlc[i12] + wlc[i13] \
                                                                    + wlc[i14] + wlc[i15]
&nbsp;
                                                                if int(verbose) == 1:
                                                                    print(word)
&nbsp;
                                                                txtfile.writelines(word + "\n")
&nbsp;
                                                                i = 0
                                                                end = 0
                                                                if int(List) == 1 :
                                                                    for i in range(len(word)):
                                                                        lword[i] = "9"
                                                                    if str(lword) == str(list(word)):
                                                                        end = 1
&nbsp;
                                                                if end == 1 : break
                                                            if end == 1 : break
                                                        if end == 1 : break
                                                    if end == 1 : break
                                                if end == 1 : break
                                            if end == 1 : break
                                        if end == 1 : break
                                    if end == 1 : break
                                if end == 1 : break
                            if end == 1 : break
                        if end == 1 : break
                    if end == 1 : break
                if end == 1 : break
            if end == 1 : break
        if end == 1 : break
&nbsp;
    txtfile.close()
</pre>

<p>Cyklomatická složitost je zatím nejvyšší &ndash; skóre dosahuje hodnoty
41(!):</p>

<pre>
$ <strong>radon cc -s -a genpassword.py </strong>
&nbsp;
genpassword.py
    F 3:0 genpassword - F (41)
&nbsp;
1 blocks (classes, functions, methods) analyzed.
Average complexity: F (41.0)
</pre>

<p><div class="rs-tip-major">Není jasné, jestli se jedná o umělý příklad,
školní úlohu nebo ... produkční kód.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Cyklomatická složitost != měřítko čitelného kódu</h2>

<p>Poslední příklad byl získán na adrese <a
href="http://preshing.com/20110926/high-resolution-mandelbrot-in-obfuscated-python/">http://preshing.com/20110926/high-resolution-mandelbrot-in-obfuscated-python/</a>
a opět byl nepatrně upraven tak, aby obsahoval funkci. Příklad je schválně
obfuskovaný (i přesto, že je psán v&nbsp;Pythonu):</p>

<pre>
def x():
    _                                      =   (
                                            255,
                                          lambda
                                   V       ,B,c
                                 :c   and Y(V*V+B,B,  c
                                   -1)if(abs(V)&lt;6)else
                   (              2+c-4*abs(V)**-0.4)/i
                     )  ;v,      x=1500,1000;C=range(v*x
                      );import  struct;P=struct.pack;M,\
                j  ='&lt;QIIHHHH',open('M.bmp','wb').write
    for X in j('BM'+P(M,v*x*3+26,26,12,v,x,1,24))or C:
                i  ,Y=_;j(P('BBB',*(lambda T:(T*80+T**9
                      *i-950*T  **99,T*70-880*T**18+701*
                     T  **9     ,T*i**(1-T**45*2)))(sum(
                   [              Y(0,(A%3/3.+X%v+(X/v+
                                   A/3/3.-x/2)/1j)*2.5
                                 /x   -2.7,i)**2 for  \
                                   A       in C
                                          [:9]])
                                            /9)
                                           )   )
&nbsp;
x()
</pre>

<p>Zajímavé je, že tento nečitelný kód má cyklomatickou složitost jen 6! To
mj.&nbsp;znamená, že cyklomatická složitost nemusí mít nic společného
s&nbsp;čitelností zdrojových kódů:</p>

<pre>
$ <strong>radon cc -s -a mandelbrot_lambda.py </strong>
&nbsp;
mandelbrot_lambda.py
    F 1:0 x - B (6)
&nbsp;
1 blocks (classes, functions, methods) analyzed.
Average complexity: B (6.0)
</pre>

<p><div class="rs-tip-major">Poznámka: tento kód je skutečně funkční a když
několik minut počkáte, získáte BMP obrázek s&nbsp;Mandelbrotovou množinou ve
vyšším rozlišení.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Úprava nástroje Radon pro vytvoření HTML stránky s&nbsp;výsledky</h2>

<p>V&nbsp;této kapitole si ukážeme, jak je možné upravit nástroj <i>Radon</i>
takovým způsobem, aby generoval HTML stránky s&nbsp;obarvenými výsledky.
Příkladem může být tato stránka: <a
href="https://fabric8-analytics.github.io/dashboard/f8a-server-backbone.cc.html">https://fabric8-analytics.github.io/dashboard/f8a-server-backbone.cc.html</a>.</p>

<p>Pokud je <i>Radon</i> spuštěn tak, aby vypočtenou cyklomatickou složitost
zobrazil na standardním výstupu, je takový výstup obarven:</p>

<img src="https://i.iinfo.cz/images/131/radon-1.png" class="image-327403" alt="&#160;" width="548" height="853" />

<p>Pokud je však provedeno jakékoli přesměrování, barvy se ztratí. Proto
upravíme soubor <strong>colors.py</strong> umístěný v&nbsp;adresáři:</p>

<pre>
~/.local/lib/python3.6/site-packages
</pre>

<p>Postačuje zakomentovat volání funkce <strong>colorama.init()</strong>,
popř.&nbsp;upravit konstantu <strong>BRIGHT</strong>, protože světlá písmena
jsou na bílém pozadí špatně čitelná:</p>

<pre>
'''Module holding constants used to format lines that are printed to the
terminal.
'''
&nbsp;
import sys
try:
    import colorama
    <strong># colorama.init(strip=(not sys.stdout.isatty()))</strong>
    <strong># colorama.init()</strong>
    GREEN, YELLOW, RED = (colorama.Fore.GREEN, colorama.Fore.YELLOW,
                          colorama.Fore.RED)
    MAGENTA, CYAN, WHITE = (colorama.Fore.MAGENTA, colorama.Fore.CYAN,
                            colorama.Fore.WHITE)
    BRIGHT, RESET = colorama.Style.BRIGHT, colorama.Style.RESET_ALL
except ImportError:  # pragma: no cover
    # No colorama, so let's fallback to no-color mode
    GREEN = YELLOW = RED = MAGENTA = CYAN = WHITE = BRIGHT = RESET = ''
&nbsp;
RANKS_COLORS = {'A': GREEN, 'B': GREEN,
                'C': YELLOW, 'D': YELLOW,
                'E': RED, 'F': RED}
&nbsp;
LETTERS_COLORS = {'F': MAGENTA,
                  'C': CYAN,
                  'M': GREEN}
&nbsp;
MI_RANKS = {'A': GREEN, 'B': YELLOW, 'C': RED}
TEMPLATE = '{0}{1} {reset}{2}:{3} {4} - {5}{6}{reset}'
</pre>

<p>Výstup je následně možné přesměrovat do skriptu <a
href="https://pypi.org/project/ansi2html/">ansi2html</a> a získaný výstup
podruhé přesměrovat do souboru s&nbsp;koncovkou <strong>.html</strong>:</p>

<pre>
$ <strong>radon cc -s -a . | ansi2html > cc.html</strong>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Zjištění indexu udržovatelnosti (Maintainability Index)</h2>

<p>Pokud nástroj <i>Radon</i> spustíte s&nbsp;příkazem <strong>mi</strong>,
bude se zjišťovat takzvaný index udržovatelnosti (<i>Maintainability
Index</i>). Nejprve se podívejme na příklad:</p>

<pre>
$ <strong>radon mi -s .</strong>
&nbsp;
hello_world.py - A (81.86)
control_structures.py - A (38.27)
bubble_sort.py - A (64.62)
&nbsp;
mandelbrot.py - A (48.27)
mandelbrot_complex.py - A (78.90)
&nbsp;
v_poradi.py - A (72.20)
genpassword.py - A (39.68)
</pre>

<p>Vidíme, že se opět vypisuje kategorie (jeden znak) a skóre. Tentokrát však
mají obě metriky jiný význam a snaží se popsat míru udržovatelnosti zdrojových
kódů. Navíc se skóre a kategorie počítá vždy pro celý zdrojový kód,
resp.&nbsp;přesněji řečeno pro jeden modul:</p>

<table>
<tr><th>Skóre</th><th>Kategorie</th><th>Udržovatelnost</th></tr>
<tr><td>100 - 20</td><td>A</td><td>vysoká</td></tr>
<tr><td> 19 - 10</td><td>B</td><td>střední</td></tr>
<tr><td>  9 -  0</td><td>C</td><td>nízká</td></tr>
</table>

<p>Cílem je tedy získat co nejvyšší skóre, na rozdíl od cyklomatické
složitosti.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Výpočet indexu udržovatelnosti</h2>

<p>Existuje větší množství způsobů výpočtu indexu udržovatelnosti. Nástroj
<i>Radon</i> používá tento heuristický a magickými konstantami oplývající
vzorec:</p>

<img src="https://i.iinfo.cz/images/131/radon-2.png" class="image-327404" alt="&#160;" width="590" height="83" />

<p>kde:</p>

<table>
<tr><th>Člen</th><th>Význam</th></tr>
<tr><td>V</td><td>Halsteadova míra vypočtená dalším vzorcem V=Nlog<sub>2</sub>η na základě počtu operátorů a operandů</td></tr>
<tr><td>G</td><td>cyklomatická složitost</td></tr>
<tr><td>L</td><td>počet řádků se zdrojovým kódem</td></tr>
<tr><td>C</td><td>% zdrojových kódu převedené na radiány (?)</td></tr>
<tr><td>N</td><td>celkový počet operátorů a operandů (pro výpočet V)</td></tr>
<tr><td>η</td><td>počet rozdílných operátorů a operandů (pro výpočet V)</td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy osmi dnes popsaných demonstračních příkladů určených pro
interpret Pythonu 3 byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/radon-examples">https://github.com/tisnik/radon-examples</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem
prozatím velmi malý, doslova několik kilobajtů), můžete namísto toho použít
odkazy na jednotlivé demonstrační příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th>Program/skript</th><th>Adresa</th></tr>
<tr><td>hello_world.py</td><td><a href="https://github.com/tisnik/radon-examples/blob/master/hello_world.py">https://github.com/tisnik/radon-examples/blob/master/hello_world.py</a></td></tr>
<tr><td>control_structures.py</td><td><a href="https://github.com/tisnik/radon-examples/blob/master/control_structures.py">https://github.com/tisnik/radon-examples/blob/master/control_structures.py</a></td></tr>
<tr><td>bubble_sort.py</td><td><a href="https://github.com/tisnik/radon-examples/blob/master/bubble_sort.py">https://github.com/tisnik/radon-examples/blob/master/bubble_sort.py</a></td></tr>
<tr><td>mandelbrot.py</td><td><a href="https://github.com/tisnik/radon-examples/blob/master/mandelbrot.py">https://github.com/tisnik/radon-examples/blob/master/mandelbrot.py</a></td></tr>
<tr><td>mandelbrot_complex.py</td><td><a href="https://github.com/tisnik/radon-examples/blob/master/mandelbrot_complex.py">https://github.com/tisnik/radon-examples/blob/master/mandelbrot_complex.py</a></td></tr>
<tr><td>v_poradi.py</td><td><a href="https://github.com/tisnik/radon-examples/blob/master/v_poradi.py">https://github.com/tisnik/radon-examples/blob/master/v_poradi.py</a></td></tr>
<tr><td>genpassword.py</td><td><a href="https://github.com/tisnik/radon-examples/blob/master/genpassword.py">https://github.com/tisnik/radon-examples/blob/master/genpassword.py</a></td></tr>
<tr><td>dxf_importer.py</td><td><a href="https://github.com/tisnik/radon-examples/blob/master/cls/dxf_importer.py">https://github.com/tisnik/radon-examples/blob/master/cls/dxf_importer.py</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: obfuskovaný kód generující Mandelbrotovu
množinu naleznete na adrese <a
href="http://preshing.com/20110926/high-resolution-mandelbrot-in-obfuscated-python/">http://preshing.com/20110926/high-resolution-mandelbrot-in-obfuscated-python/</a>,
takže ho nebylo nutné přidávat do repositáře.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>Radon na PyPi<br />
<a href="https://pypi.org/project/radon/">https://pypi.org/project/radon/</a>
</li>

<li>Radon na GitHubu<br />
<a href="https://github.com/rubik/radon">https://github.com/rubik/radon</a>
</li>

<li>Radon’s documentation!<br />
<a href="http://radon.readthedocs.io/en/latest/">http://radon.readthedocs.io/en/latest/</a>
</li>

<li>Cyclomatic complexity (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">https://en.wikipedia.org/wiki/Cyclomatic_complexity</a>
</li>

<li>Cyklomatická složitost (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Cyklomatick%C3%A1_slo%C5%BEitost">https://cs.wikipedia.org/wiki/Cyklomatick%C3%A1_slo%C5%BEitost</a>
</li>

<li>What is Cyclomatic Complexity?<br />
<a href="https://www.tutorialspoint.com/software_testing_dictionary/cyclomatic_complexity.htm">https://www.tutorialspoint.com/software_testing_dictionary/cyclomatic_complexity.htm</a>
</li>

<li>The Halstead metrics<br />
<a href="http://www.virtualmachinery.com/sidebar2.htm">http://www.virtualmachinery.com/sidebar2.htm</a>
</li>

<li>Measurement of Halstead Metrics with Testwell CMT++ and CMTJava (Complexity Measures Tool)<br />
<a href="http://www.verifysoft.com/en_halstead_metrics.html">http://www.verifysoft.com/en_halstead_metrics.html</a>
</li>

<li>Halstead complexity measures (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Halstead_complexity_measures">https://en.wikipedia.org/wiki/Halstead_complexity_measures</a>
</li>

<li>Decision-to-decision path<br />
<a href="https://en.wikipedia.org/wiki/Decision-to-decision_path">https://en.wikipedia.org/wiki/Decision-to-decision_path</a>
</li>

<li>Essential complexity<br />
<a href="https://en.wikipedia.org/wiki/Essential_complexity">https://en.wikipedia.org/wiki/Essential_complexity</a>
</li>

<li>Learn Mccabe's Cyclomatic Complexity with Example<br />
<a href="https://www.guru99.com/cyclomatic-complexity.html">https://www.guru99.com/cyclomatic-complexity.html</a>
</li>

<li>ansi2html<br />
<a href="https://github.com/Kronuz/ansi2html">https://github.com/Kronuz/ansi2html</a>
</li>

<li>Komplexita<br />
<a href="https://cs.wikipedia.org/wiki/Komplexita">https://cs.wikipedia.org/wiki/Komplexita</a>
</li>

<li>Think Twice Before Using the “Maintainability Index”<br />
<a href="https://avandeursen.com/2014/08/29/think-twice-before-using-the-maintainability-index/">https://avandeursen.com/2014/08/29/think-twice-before-using-the-maintainability-index/</a>
</li>

<li>Structured testing (kniha)<br />
<a href="https://books.google.cz/books?id=vtNWAAAAMAAJ">https://books.google.cz/books?id=vtNWAAAAMAAJ</a>
</li>

<li>Static program analysis<br />
<a href="https://en.wikipedia.org/wiki/Static_program_analysis">https://en.wikipedia.org/wiki/Static_program_analysis</a>
</li>

<li>Python #2744<br />
<a href="http://hovnokod.cz/2744">http://hovnokod.cz/2744</a>
</li>

<li>Python #1429<br />
<a href="http://hovnokod.cz/1429">http://hovnokod.cz/1429</a>
</li>

<li>Measure complexity of C source<br />
<a href="https://www.gnu.org/software/complexity/manual/complexity.html">https://www.gnu.org/software/complexity/manual/complexity.html</a>
</li>

<li>Using Complexity Measurements to Improve Software Quality<br />
<a href="https://www.infoq.com/news/2014/10/complexity-software-quality">https://www.infoq.com/news/2014/10/complexity-software-quality</a>
</li>

<li>High-Resolution Mandelbrot in Obfuscated Python<br />
<a href="http://preshing.com/20110926/high-resolution-mandelbrot-in-obfuscated-python/">http://preshing.com/20110926/high-resolution-mandelbrot-in-obfuscated-python/</a>
</li>

<li>Penrose Tiling in Obfuscated Python<br />
<a href="http://preshing.com/20110822/penrose-tiling-in-obfuscated-python/">http://preshing.com/20110822/penrose-tiling-in-obfuscated-python/</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Parsing<br />
<a href="https://en.wikipedia.org/wiki/Parsing">https://en.wikipedia.org/wiki/Parsing</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

