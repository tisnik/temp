<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Souběžné a paralelně běžící úlohy naprogramované v Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Souběžné a paralelně běžící úlohy naprogramované v Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s několika balíčky ze standardní knihovny programovacího jazyka Python, které jsou určeny pro spouštění souběžných či dokonce paralelně běžících úloh. Zmíníme se i o způsobech komunikace mezi těmito úlohami.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Souběžné a paralelně běžící úlohy naprogramované v&nbsp;Pythonu</a></p>
<p><a href="#k02">2. Balíček <strong>threading</strong> &ndash; vytvoření a spuštění několika vláken</a></p>
<p><a href="#k03">3. Předání parametrů funkcím spouštěným v&nbsp;nových vláknech</a></p>
<p><a href="#k04">4. Explicitní čekání na dokončení běhu vláken</a></p>
<p><a href="#k05">5. Vlákna s&nbsp;příznakem &bdquo;daemon&ldquo;</a></p>
<p><a href="#k06">6. Čekaní na dokončení vlákna po zvolený časový interval, test, zda vlákno stále běží</a></p>
<p><a href="#k07">7. Komunikace mezi vlákny</a></p>
<p><a href="#k08">8. Standardní synchronizované datové struktury z&nbsp;balíčku <strong>queue</strong></a></p>
<p><a href="#k09">9. Fronta ve funkci komunikačního i synchronizačního mechanismu</a></p>
<p><a href="#k10">10. Klasický vzor producent&ndash;konzument</a></p>
<p><a href="#k11">11. Prioritní fronta</a></p>
<p><a href="#k12">12. Jazyk Python a multiprocessing</a></p>
<p><a href="#k13">13. Spuštění nového procesu</a></p>
<p><a href="#k14">14. Spuštění většího množství procesů, čekání na dokončení těchto procesů</a></p>
<p><a href="#k15">15. Zjednodušení předchozího demonstračního příkladu</a></p>
<p><a href="#k16">16. Komunikace mezi procesy přes <strong>multiprocessing.Queue</strong></a></p>
<p><a href="#k17">17. Komunikace mezi procesy přes obousměrnou rouru (<strong>multiprocessing.Pipe</strong>)</a></p>
<p><a href="#k18">*** 18. Spouštění a řízení paralelně běžících úloh &ndash; <strong>concurrent.futures</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Souběžné a paralelně běžící úlohy naprogramované v&nbsp;Pythonu</h2>

<p>V&nbsp;dnešním článku o <a
href="https://www.root.cz/n/python/">programovacím jazyku Python</a> se
seznámíme s&nbsp;několika balíčky, které je možné nalézt přímo ve standardní
knihovně. Tyto balíčky jsou určeny pro spouštění souběžných či dokonce
paralelně běžících úloh. Konkrétně se jedná o balíčky
<strong>threading</strong>, <strong>multiprocessing</strong> a taktéž o balíček
<strong>concurrent.futures</strong>. Zmíníme se i o vybraných způsobech
komunikace mezi těmito úlohami, protože (alespoň většinou) je vhodnější
zajistit komunikaci s&nbsp;využitím k&nbsp;tomu určených prostředků a nikoli
přes sdílené objekty (což ani u úloh běžících v&nbsp;samostatných procesech
není jednoduše možné).</p>

<p>Na tomto místě je vhodné upozornit na fakt, že v&nbsp;Pythonu sice můžeme
používat všechny dále popisované balíčky, ovšem skutečný paralelní (a
nezávislý) běh několika vláken je ve standardním CPythonu do značné míry omezen
kvůli existenci techniky zvané <i>GIL</i> neboli <i>Global Interpreter Lock</i>
(viz též <a
href="https://wiki.python.org/moin/GlobalInterpreterLock">příslušnou
stránku</a>). Existuje poměrně velké množství návrhů na odstranění GILu, ovšem
prozatím je tato technika v&nbsp;CPythonu stále používána. Naproti tomu <a
href="https://ironpython.net/">IronPython</a> ani <a
href="https://www.jython.org/">Jython</a> tuto techniku nepoužívají; na druhou
stranu je však například vývoj Jythonu prakticky pozastaven (viz též poznámku
pod odstavcem). V&nbsp;případě klasického CPythonu je tedy nutné chápat
především modul <strong>threading</strong>, o němž se zmíníme v&nbsp;dalším
textu, jako řešení algoritmů, které mají běžet <i>souběžně</i>, nikoli nutně
<i>paralelně</i> (paralelně poběží většinou vstupně-výstupní operace,
resp.&nbsp;v&nbsp;tuto chvíli dojde k&nbsp;přepnutí vláken). Skutečně paralelní
běh lze pochopitelně dosáhnout využitím většího množství procesů
popř.&nbsp;některých technik uvedených v&nbsp;navazujícím článku.</p>

<p><div class="rs-tip-major">Poznámka: na druhou stranu je nutné poznamenat, že
v&nbsp;době, kdy Jython vznikl (pod jménem JPython již v&nbsp;roce 1999, pod
novým jménem Jython pak byl vydán před více než před dvaceti lety, konkrétně
v&nbsp;roce 2001), se kromě samotné Javy jednalo o nejpropracovanější
programovací jazyk určený pro běh na JVM. I z&nbsp;toho důvodu byl relativně
často využíván pro skriptování v&nbsp;různých enterprise systémech, například i
ve WebSphere, Oracle WebLogicu atd. O to problematičtější se zdá být praktické
zastavení vývoje Jythonu (protože další ne-Javovské jazyky postavené nad JVM
jsou mnohdy dosti úspěšné, takže nika pro další vývoj zde existuje).</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Balíček <strong>threading</strong> &ndash; vytvoření a spuštění několika vláken</h2>

<p>V&nbsp;první části dnešního článku si ukážeme základní techniky podporované
standardním balíčkem nazvaným <strong>threading</strong>. Dokumentaci
k&nbsp;tomuto balíčku lze najít na stránce <a
href="https://docs.python.org/3/library/threading.html">https://docs.python.org/3/library/threading.html</a>,
kde jsou vypsány i některé postupy, které dnes nebudou popsány. Jedná se
především o použití různých synchronizačních mechanismů a taktéž systémů
událostí (příkladem může být, že jedno vlákno vytvoří událost, na kterou další
vlákno čeká atd.). Tyto již nepatrně komplikovanější postupy budou popsány
v&nbsp;navazujícím článku.</p>

<p>Podívejme se nyní na velmi jednoduchý program, v&nbsp;němž je spuštěno větší
množství vláken. Nejprve vytvoříme zcela běžnou funkci, která v&nbsp;programové
smyčce desetkrát vypíše jméno vlákna, ve kterém je tato funkce spuštěna, dále
vypíše aktuální hodnotu počitadla smyčky a taktéž čas, kdy k&nbsp;tomuto výpisu
došlo. Mezi jednotlivými iteracemi smyčky je vložena přibližně jednosekundová
prodleva, kterou simulujeme reálnou práci (například nějaký výpočet, komunikaci
s&nbsp;databází, provedení HTTP dotazu atd.):</p>

<pre>
def <strong>worker</strong>():
    threadName = threading.current_thread().name
    delay = 1
    n = 10
    for counter in range(1, n+1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
</pre>

<p><div class="rs-tip-major">Poznámka: jméno vlákna je buď explicitně zadáno
programátorem (což uvidíme dále), nebo je vygenerováno automaticky, a to
dokonce i pro vlákno, ve kterém běží hlavní část skriptu. O tom se ostatně
můžeme velmi snadno přesvědčit, a to například přímo v&nbsp;interaktivní smyčce
interpretru jazyka Python:</div></p>

<pre>
&gt;&gt;&gt; import threading
&gt;&gt;&gt; print(threading.current_thread().name)
&nbsp;
MainThread
</pre>

<p>Právě definovanou funkci <strong>worker</strong> ovšem nebudeme spouštět
přímo. Nejprve vytvoříme nové vlákno, specifikujeme, že se v&nbsp;rámci tohoto
vlákna má vykonat právě funkce <strong>worker</strong> a teprve poté toto
vlákno spustíme. Popsanou operaci zopakujeme několikrát, takže se spustí
několik vláken provádějících podobnou činnost (lišit se bude pouze jméno vlákna
vypisované funkcí <strong>worker</strong> a popř.&nbsp;i časy výpisu
zpráv):</p>

<pre>
threading.Thread(target=worker).start()
threading.Thread(target=worker).start()
threading.Thread(target=worker).start()
</pre>

<p>Po provedení těchto tří příkazů se kromě hlavního vlákna spustí ještě další
tři vlákna, která budou prováděna <i>souběžně</i> (ovšem nikoli zcela
paralelně, a to kvůli výše zmíněné existenci GILu). Hlavní vlákno bude čekat na
dokončení ostatních tří vláken, protože tato vlákna nemají nastaven atribut
<i>daemon</i>. Více informací o rozlišení vláken se dozvíme v&nbsp;navazujícím
textu. Ve výpisu si povšimněte, jak jsou vlákna automaticky pojmenována. Dále
je zřejmé, že vlákna skutečně pracují souběžně:</p>

<pre>
Thread-1: 1/10 - Sat Feb 19 09:14:51 2022
Thread-3: 1/10 - Sat Feb 19 09:14:51 2022
Thread-2: 1/10 - Sat Feb 19 09:14:51 2022
Thread-1: 2/10 - Sat Feb 19 09:14:52 2022
Thread-2: 2/10 - Sat Feb 19 09:14:52 2022
Thread-3: 2/10 - Sat Feb 19 09:14:52 2022
Thread-1: 3/10 - Sat Feb 19 09:14:53 2022
Thread-3: 3/10 - Sat Feb 19 09:14:53 2022
Thread-2: 3/10 - Sat Feb 19 09:14:53 2022
Thread-1: 4/10 - Sat Feb 19 09:14:54 2022
Thread-2: 4/10 - Sat Feb 19 09:14:54 2022
Thread-3: 4/10 - Sat Feb 19 09:14:54 2022
Thread-1: 5/10 - Sat Feb 19 09:14:55 2022
Thread-2: 5/10 - Sat Feb 19 09:14:55 2022
Thread-3: 5/10 - Sat Feb 19 09:14:55 2022
Thread-1: 6/10 - Sat Feb 19 09:14:56 2022
Thread-2: 6/10 - Sat Feb 19 09:14:56 2022
Thread-3: 6/10 - Sat Feb 19 09:14:56 2022
Thread-1: 7/10 - Sat Feb 19 09:14:57 2022
Thread-2: 7/10 - Sat Feb 19 09:14:57 2022
Thread-3: 7/10 - Sat Feb 19 09:14:57 2022
Thread-1: 8/10 - Sat Feb 19 09:14:58 2022
Thread-2: 8/10 - Sat Feb 19 09:14:58 2022
Thread-3: 8/10 - Sat Feb 19 09:14:58 2022
Thread-2: 9/10 - Sat Feb 19 09:14:59 2022
Thread-1: 9/10 - Sat Feb 19 09:14:59 2022
Thread-3: 9/10 - Sat Feb 19 09:14:59 2022
Thread-1: 10/10 - Sat Feb 19 09:15:00 2022
Thread-2: 10/10 - Sat Feb 19 09:15:00 2022
Thread-3: 10/10 - Sat Feb 19 09:15:00 2022
</pre>

<p><a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading1.py">Úplný
zdrojový kód</a> dnešního prvního demonstračního příkladu vypadá
následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i>"""Multithreading."""</i>
&nbsp;
import threading
import time
&nbsp;
&nbsp;
def <strong>worker</strong>():
    threadName = threading.current_thread().name
    delay = 1
    n = 10
    for counter in range(1, n+1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
&nbsp;
&nbsp;
<i># vytvoření a spuštění trojice vláken</i>
threading.Thread(target=worker).start()
threading.Thread(target=worker).start()
threading.Thread(target=worker).start()
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Předání parametrů funkcím spouštěným v&nbsp;nových vláknech</h2>

<p>Mnohdy je nutné funkci, která má být zavolána v&nbsp;nově spuštěném vláknu,
předat nějaké parametry. To nelze provést přímo (funkci totiž nevolá přímo
programátor, ale modul <strong>threading</strong>), nicméně parametry do volané
funkce je možné specifikovat, i když nepřímým způsobem. Funkci nejprve upravíme
takovým způsobem, aby akceptovala tři parametry, konkrétně explicitně nastavené
jméno vlákna, čas prodlevy a počet opakování programové smyčky ve vláknu:</p>

<pre>
def <strong>worker</strong>(<u>threadName</u>, <u>delay</u>, <u>n</u>):
    for counter in range(1, n+1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
</pre>

<p>Parametry, které se mají funkci <strong>worker</strong> po jejím zavolání
v&nbsp;novém vláknu předat, se specifikují v&nbsp;parametru
<strong>args</strong> konstruktoru <strong>threading.Thread</strong>, a to
(v&nbsp;tomto případě) formou n-tice (<i>tuple</i>):</p>

<pre>
threading.Thread(target=worker, <u>args=("Thread-1", 0.5, 10)</u>).start()
threading.Thread(target=worker, <u>args=("Thread-2", 1.0, 10)</u>).start()
threading.Thread(target=worker, <u>args=("Thread-3", 1.5, 10)</u>).start()
</pre>

<p>Po spuštění takto upraveného programu je patrné, že kvůli různým časovým
prodlevám mají výpočty ve vláknech různou rychlost a konkrétně to znamená, že
celý výpočet v&nbsp;prvním vláknu doběhne nejrychleji a výpočet ve třetím
vláknu nejpomaleji. Poslední iterace programových smyček ve všech třech
vláknech jsou na následujícím výpisu zvýrazněny:</p>

<pre>
Thread-1: 1/10 - Sat Feb 19 09:21:14 2022
Thread-2: 1/10 - Sat Feb 19 09:21:14 2022
Thread-1: 2/10 - Sat Feb 19 09:21:14 2022
Thread-1: 3/10 - Sat Feb 19 09:21:15 2022
Thread-3: 1/10 - Sat Feb 19 09:21:15 2022
Thread-2: 2/10 - Sat Feb 19 09:21:15 2022
Thread-1: 4/10 - Sat Feb 19 09:21:15 2022
Thread-1: 5/10 - Sat Feb 19 09:21:16 2022
Thread-3: 2/10 - Sat Feb 19 09:21:16 2022
Thread-2: 3/10 - Sat Feb 19 09:21:16 2022
Thread-1: 6/10 - Sat Feb 19 09:21:16 2022
Thread-1: 7/10 - Sat Feb 19 09:21:17 2022
Thread-2: 4/10 - Sat Feb 19 09:21:17 2022
Thread-1: 8/10 - Sat Feb 19 09:21:17 2022
Thread-3: 3/10 - Sat Feb 19 09:21:18 2022
Thread-1: 9/10 - Sat Feb 19 09:21:18 2022
<strong>Thread-1: 10/10 - Sat Feb 19 09:21:18 2022</strong>
Thread-2: 5/10 - Sat Feb 19 09:21:18 2022
Thread-3: 4/10 - Sat Feb 19 09:21:19 2022
Thread-2: 6/10 - Sat Feb 19 09:21:19 2022
Thread-2: 7/10 - Sat Feb 19 09:21:20 2022
Thread-3: 5/10 - Sat Feb 19 09:21:21 2022
Thread-2: 8/10 - Sat Feb 19 09:21:21 2022
Thread-3: 6/10 - Sat Feb 19 09:21:22 2022
Thread-2: 9/10 - Sat Feb 19 09:21:22 2022
<strong>Thread-2: 10/10 - Sat Feb 19 09:21:23 2022</strong>
Thread-3: 7/10 - Sat Feb 19 09:21:24 2022
Thread-3: 8/10 - Sat Feb 19 09:21:25 2022
Thread-3: 9/10 - Sat Feb 19 09:21:27 2022
<strong>Thread-3: 10/10 - Sat Feb 19 09:21:28 2022</strong>
</pre>

<p><a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading2.py">Úplný
zdrojový kód</a> dnešního druhého demonstračního příkladu vypadá
následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i>"""Multithreading."""</i>
&nbsp;
import threading
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    for counter in range(1, n+1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
&nbsp;
&nbsp;
<i># vytvoření a spuštění trojice vláken</i>
threading.Thread(target=worker, args=("Thread-1", 0.5, 10)).start()
threading.Thread(target=worker, args=("Thread-2", 1.0, 10)).start()
threading.Thread(target=worker, args=("Thread-3", 1.5, 10)).start()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Explicitní čekání na dokončení běhu vláken</h2>

<p>V&nbsp;předchozí dvojici demonstračních příkladů byla z&nbsp;hlavního vlákna
spuštěna tři další vlákna. Ovšem hlavní vlákno bylo ihned po provedení těchto
tří operací ukončeno, protože již neobsahovalo žádný další programový kód.
Nicméně i přesto interpret Pythonu počkal na dokončení běhu ostatních vláken,
protože se jedná o běžná &bdquo;nedémonická&ldquo; vlákna. V&nbsp;případě, že
nebudeme chtít, aby se hlavní vlákno automaticky ukončilo, je nutné explicitně
počkat na ostatní vlákna. K&nbsp;tomuto účelu slouží metoda
<strong>Thread.join()</strong>:</p>

<pre>
join(timeout=None) method of threading.Thread instance
    Wait until the thread terminates.
&nbsp;    
    This blocks the calling thread until the thread whose join() method is
    called terminates -- either normally or through an unhandled exception
    or until the optional timeout occurs.
&nbsp;
    When the timeout argument is present and not None, it should be a
    floating point number specifying a timeout for the operation in seconds
    (or fractions thereof). As join() always returns None, you must call
    is_alive() after join() to decide whether a timeout happened -- if the
    thread is still alive, the join() call timed out.
&nbsp;
    When the timeout argument is not present or None, the operation will
    block until the thread terminates.
&nbsp;
    A thread can be join()ed many times.
&nbsp;
    join() raises a RuntimeError if an attempt is made to join the current
    thread as that would cause a deadlock. It is also an error to join() a
    thread before it has been started and attempts to do so raises the same
    exception.
</pre>

<p>Způsob volání metody <strong>join</strong> je jednoduchý, ovšem musíme mít
k&nbsp;dispozici instance třídy <strong>threading.Thread</strong>, což si
vyžádá nepatrnou úpravu zdrojového kódu:</p>

<pre>
<i># vytvoření trojice vláken</i>
t1 = threading.Thread(target=worker, args=("Thread-1", 0.5, 10))
t2 = threading.Thread(target=worker, args=("Thread-2", 1.0, 10))
t3 = threading.Thread(target=worker, args=("Thread-3", 1.5, 10))
&nbsp;
<i># spuštění všech vláken</i>
t1.start()
t2.start()
t3.start()
&nbsp;
<i># čekání na dokončení všech vláken</i>
t1.join()
t2.join()
t3.join()
</pre>

<p>Po spuštění dostaneme velmi podobné výsledky, jako tomu bylo
v&nbsp;předchozím příkladu:</p>

<pre>
Thread-1: 1/10 - Sat Feb 19 09:55:59 2022
Thread-2: 1/10 - Sat Feb 19 09:55:59 2022
Thread-1: 2/10 - Sat Feb 19 09:55:59 2022
Thread-3: 1/10 - Sat Feb 19 09:56:00 2022
Thread-1: 3/10 - Sat Feb 19 09:56:00 2022
Thread-1: 4/10 - Sat Feb 19 09:56:00 2022
Thread-2: 2/10 - Sat Feb 19 09:56:00 2022
Thread-1: 5/10 - Sat Feb 19 09:56:01 2022
Thread-3: 2/10 - Sat Feb 19 09:56:01 2022
Thread-2: 3/10 - Sat Feb 19 09:56:01 2022
Thread-1: 6/10 - Sat Feb 19 09:56:01 2022
Thread-1: 7/10 - Sat Feb 19 09:56:02 2022
Thread-2: 4/10 - Sat Feb 19 09:56:02 2022
Thread-1: 8/10 - Sat Feb 19 09:56:02 2022
Thread-3: 3/10 - Sat Feb 19 09:56:03 2022
Thread-1: 9/10 - Sat Feb 19 09:56:03 2022
Thread-2: 5/10 - Sat Feb 19 09:56:03 2022
Thread-1: 10/10 - Sat Feb 19 09:56:03 2022
Thread-3: 4/10 - Sat Feb 19 09:56:04 2022
Thread-2: 6/10 - Sat Feb 19 09:56:04 2022
Thread-2: 7/10 - Sat Feb 19 09:56:05 2022
Thread-3: 5/10 - Sat Feb 19 09:56:06 2022
Thread-2: 8/10 - Sat Feb 19 09:56:06 2022
Thread-3: 6/10 - Sat Feb 19 09:56:07 2022
Thread-2: 9/10 - Sat Feb 19 09:56:07 2022
Thread-2: 10/10 - Sat Feb 19 09:56:08 2022
Thread-3: 7/10 - Sat Feb 19 09:56:09 2022
Thread-3: 8/10 - Sat Feb 19 09:56:10 2022
Thread-3: 9/10 - Sat Feb 19 09:56:12 2022
Thread-3: 10/10 - Sat Feb 19 09:56:13 2022
Done!
</pre>

<p><a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading3.py">Úplný
zdrojový kód</a> dnešního třetího demonstračního příkladu vypadá
následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i>"""Multithreading."""</i>
&nbsp;
import threading
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    for counter in range(1, n+1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
&nbsp;
&nbsp;
<i># vytvoření trojice vláken</i>
t1 = threading.Thread(target=worker, args=("Thread-1", 0.5, 10))
t2 = threading.Thread(target=worker, args=("Thread-2", 1.0, 10))
t3 = threading.Thread(target=worker, args=("Thread-3", 1.5, 10))
&nbsp;
<i># spuštění všech vláken</i>
t1.start()
t2.start()
t3.start()
&nbsp;
<i># čekání na dokončení všech vláken</i>
t1.join()
t2.join()
t3.join()
&nbsp;
print("Done!")
</pre>

<p>Objekty jsou však uvolněny až po dokončení všech vláken:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i>"""Multithreading."""</i>
&nbsp;
import threading
import time
&nbsp;
class <strong>X</strong>():
&nbsp;
    def <strong>__init__</strong>(self):
        print("X constructed")
&nbsp;
    def <strong>__del__</strong>(self):
        print("X destructed")
&nbsp;
&nbsp;
def <strong>worker</strong>():
    print("thread started")
    time.sleep(10)
    print("thread finished")
&nbsp;
&nbsp;
print("main started")
&nbsp;
x = X()
&nbsp;
<i># vytvoření a spuštění trojice vláken</i>
threading.Thread(target=worker).start()
threading.Thread(target=worker).start()
threading.Thread(target=worker).start()
&nbsp; 
print("main finished")
</pre>

<p>Dobré je sledovat, kdy se zavolá destruktor objektu <strong>x</strong>:</p>

<pre>
main started
<strong>X constructed</strong>
thread started
thread started
thread started
main finished
thread finished
thread finished
thread finished
<strong>X destructed</strong>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vlákna s&nbsp;příznakem &bdquo;daemon&ldquo;</h2>

<p>Vlákna, která jsou vytvářená přes knihovnu <strong>threading</strong>, mohou
mít nastaven příznak &bdquo;daemon&ldquo;. Tato vlákna se liší od standardních
vláken pouze v&nbsp;jediném ohledu &ndash; virtuální stroj Pythonu je ukončen
až ve chvíli, kdy svoji práci dokončí všechna <i>běžná</i> vlákna, zatímco
vlákna s&nbsp;příznakem &bdquo;daemon&ldquo; nejsou do této podmínky zahrnuta.
Toto chování si můžeme snadno otestovat spuštěním následujícího skriptu. Ten
vytvoří tři vlákna s&nbsp;příznakem &bdquo;daemon&ldquo; (viz též podtrženou
část kódu) a poté hlavní vlákno ihned skončí. V&nbsp;tomto okamžiku je ukončen
i běh virtuálního stroje Pythonu, protože už neběží žádná
&bdquo;ne-démonická&ldquo; vlákna:</p>

<pre>
import threading
import time
&nbsp;
&nbsp;
def <strong>worker</strong>():
    threadName = threading.current_thread().name
    delay = 1
    n = 10
    for counter in range(1, n+1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
&nbsp;
&nbsp;
<i># vytvoření a spuštění trojice vláken v režimu daemon</i>
threading.Thread(target=worker, <u>daemon=True</u>).start()
threading.Thread(target=worker, <u>daemon=True</u>).start()
threading.Thread(target=worker, <u>daemon=True</u>).start()
&nbsp;
<i># na dokončení vláken se nečeká!</i>
</pre>

<p>Tento skript (většinou) nic nevypíše, protože než se vlákna stihnout
skutečně spustit, je činnost skriptu ukončena.</p>

<p>Na dokončení &bdquo;démonických&ldquo; vláken je nutné explicitně čekat,
pochopitelně za předpokladu, že to odpovídá logice implementované aplikace:</p>

<pre>
import threading
import time
&nbsp;
&nbsp;
def <strong>worker</strong>():
    threadName = threading.current_thread().name
    delay = 1
    n = 10
    for counter in range(1, n+1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
&nbsp;
&nbsp;
<i># vytvoření a spuštění trojice vláken v režimu daemon</i>
t1 = threading.Thread(target=worker, <u>daemon=True</u>)
t2 = threading.Thread(target=worker, <u>daemon=True</u>)
t3 = threading.Thread(target=worker, <u>daemon=True</u>)
&nbsp;
t1.start()
t2.start()
t3.start()
&nbsp;
<u>t1.join()</u>
<u>t2.join()</u>
<u>t3.join()</u>
</pre>

<p>Výsledek činnosti tohoto skriptu:</p>

<pre>
Thread-1: 1/10 - Sat Feb 19 09:58:02 2022
Thread-2: 1/10 - Sat Feb 19 09:58:02 2022
Thread-3: 1/10 - Sat Feb 19 09:58:02 2022
Thread-2: 2/10 - Sat Feb 19 09:58:03 2022
Thread-1: 2/10 - Sat Feb 19 09:58:03 2022
Thread-3: 2/10 - Sat Feb 19 09:58:03 2022
Thread-3: 3/10 - Sat Feb 19 09:58:04 2022
Thread-1: 3/10 - Sat Feb 19 09:58:04 2022
Thread-2: 3/10 - Sat Feb 19 09:58:04 2022
Thread-3: 4/10 - Sat Feb 19 09:58:05 2022
Thread-1: 4/10 - Sat Feb 19 09:58:05 2022
Thread-2: 4/10 - Sat Feb 19 09:58:05 2022
Thread-3: 5/10 - Sat Feb 19 09:58:06 2022
Thread-1: 5/10 - Sat Feb 19 09:58:06 2022
Thread-2: 5/10 - Sat Feb 19 09:58:06 2022
Thread-3: 6/10 - Sat Feb 19 09:58:07 2022
Thread-1: 6/10 - Sat Feb 19 09:58:07 2022
Thread-2: 6/10 - Sat Feb 19 09:58:07 2022
Thread-2: 7/10 - Sat Feb 19 09:58:08 2022
Thread-1: 7/10 - Sat Feb 19 09:58:08 2022
Thread-3: 7/10 - Sat Feb 19 09:58:08 2022
Thread-3: 8/10 - Sat Feb 19 09:58:09 2022
Thread-2: 8/10 - Sat Feb 19 09:58:09 2022
Thread-1: 8/10 - Sat Feb 19 09:58:09 2022
Thread-3: 9/10 - Sat Feb 19 09:58:10 2022
Thread-1: 9/10 - Sat Feb 19 09:58:10 2022
Thread-2: 9/10 - Sat Feb 19 09:58:10 2022
Thread-1: 10/10 - Sat Feb 19 09:58:11 2022
Thread-3: 10/10 - Sat Feb 19 09:58:11 2022
Thread-2: 10/10 - Sat Feb 19 09:58:11 2022
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Čekaní na dokončení vlákna po zvolený časový interval, test, zda vlákno stále běží</h2>

<p>V&nbsp;některých případech není možné či žádoucí čekat na dokončení nějakého
vlákna po (alespoň teoreticky) neomezený čas. Příkladem mohou být vlákna, která
mají obsluhovat připojení různých klientů &ndash; ve chvíli, kdy se klient
odpojí (resp.&nbsp;přestane reagovat), trvá většinou nějaký čas, než se vlákno
skutečně ukončí. Pro specifikaci maximální doby čekání na ukončení vlákna se
používá metoda <strong>thread.Join</strong>, kterou již známe, pouze jí je
nutné navíc předat parametr <strong>timeout</strong>:</p>

<pre>
t3.join(timeout=5)
</pre>

<p>Tato metoda ovšem programátory neinformuje, zda bylo vlákno ukončeno běžným
způsobem, nebo zda stále běží. V&nbsp;případě, že je tato informace důležitá
(už jen pro potřeby logování), je nutné se dotázat na stav vlákna metodou
<strong>thread.is_alive</strong>:</p>

<pre>
if t3.is_alive():
    print("wait timeout")
else:
    print("t3 has finished")
</pre>

<p>Opět se podívejme na nepatrně upravený demonstrační příklad:</p>

<pre>
import threading
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    for counter in range(1, n+1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
&nbsp;
&nbsp;
<i># vytvoření trojice vláken</i>
t1 = threading.Thread(target=worker, args=("Thread-1", 0.5, 10))
t2 = threading.Thread(target=worker, args=("Thread-2", 1.0, 10))
t3 = threading.Thread(target=worker, args=("Thread-3", 1.5, 10))
&nbsp;
<i># spuštění všech vláken</i>
t1.start()
t2.start()
t3.start()
&nbsp;
<i># čekání na dokončení všech vláken</i>
t3.join(timeout=5)
&nbsp;
if t3.is_alive():
    print("wait timeout")
else:
    print("t3 has finished")
&nbsp;
t2.join()
print("t2 has finished")
&nbsp;
t1.join()
print("t1 has finished")
&nbsp;
&nbsp;
print("Done!")
</pre>

<p>Příklad chování tohoto skriptu po jeho spuštění. Důležité zprávy jsou
zvýrazněny:</p>

<pre>
Thread-1: 1/10 - Sun Feb 20 16:29:40 2022
Thread-2: 1/10 - Sun Feb 20 16:29:40 2022
Thread-1: 2/10 - Sun Feb 20 16:29:40 2022
Thread-3: 1/10 - Sun Feb 20 16:29:41 2022
Thread-1: 3/10 - Sun Feb 20 16:29:41 2022
Thread-2: 2/10 - Sun Feb 20 16:29:41 2022
Thread-1: 4/10 - Sun Feb 20 16:29:41 2022
Thread-1: 5/10 - Sun Feb 20 16:29:42 2022
Thread-2: 3/10 - Sun Feb 20 16:29:42 2022
Thread-3: 2/10 - Sun Feb 20 16:29:42 2022
Thread-1: 6/10 - Sun Feb 20 16:29:42 2022
Thread-1: 7/10 - Sun Feb 20 16:29:43 2022
Thread-2: 4/10 - Sun Feb 20 16:29:43 2022
Thread-1: 8/10 - Sun Feb 20 16:29:43 2022
Thread-3: 3/10 - Sun Feb 20 16:29:44 2022
Thread-1: 9/10 - Sun Feb 20 16:29:44 2022
<strong>wait timeout</strong>
Thread-2: 5/10 - Sun Feb 20 16:29:44 2022
Thread-1: 10/10 - Sun Feb 20 16:29:44 2022
Thread-2: 6/10 - Sun Feb 20 16:29:45 2022
Thread-3: 4/10 - Sun Feb 20 16:29:45 2022
Thread-2: 7/10 - Sun Feb 20 16:29:46 2022
Thread-3: 5/10 - Sun Feb 20 16:29:47 2022
Thread-2: 8/10 - Sun Feb 20 16:29:47 2022
Thread-2: 9/10 - Sun Feb 20 16:29:48 2022
Thread-3: 6/10 - Sun Feb 20 16:29:48 2022
Thread-2: 10/10 - Sun Feb 20 16:29:49 2022
<strong>t2 has finished</strong>
<strong>t1 has finished</strong>
Done!
Thread-3: 7/10 - Sun Feb 20 16:29:50 2022
Thread-3: 8/10 - Sun Feb 20 16:29:51 2022
Thread-3: 9/10 - Sun Feb 20 16:29:53 2022
Thread-3: 10/10 - Sun Feb 20 16:29:54 2022
<i>(až nyní došlo k&nbsp;ukončení třetího vlákna)</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Komunikace mezi vlákny</h2>

<p><i>&bdquo;Don't communicate by sharing memory; share memory by
communicating.&ldquo;</i></p>

<p>Vlákna spouštěná přes standardní balíček <strong>threading</strong> jsou
provozována v&nbsp;rámci jediného virtuálního stroje Pythonu. Z&nbsp;tohoto
důvodu je teoreticky možné pro komunikaci mezi vlákny použít nějaké objekty
(nebo například slovník), jejichž reference se jednotlivým vláknům předá
v&nbsp;parametrech. Nejedná se však ani zdaleka o nejrozumnější řešení, a to
například i kvůli nutnosti zamykání přístupů k&nbsp;těmto objektům,
NEatomičnosti změn atd. Navíc se taková ad-hoc komunikace poměrně špatně ladí.
Výhodnější může být napodobení přístupu, který v&nbsp;současnosti
zpopularizoval programovací jazyk Go &ndash; komunikovat s&nbsp;využitím
kanálů. Kanály bez omezení kapacity, s&nbsp;omezenou kapacitou
(popř.&nbsp;kapacitou nastavenou na jediný prvek) lze realizovat například
s&nbsp;využitím synchronizovaných datových struktur z&nbsp;balíčku
<strong>queue</strong>, které budou zmíněny v&nbsp;navazující kapitole.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Standardní synchronizované datové struktury z&nbsp;balíčku <strong>queue</strong></h2>

<p>V&nbsp;balíčku <strong>queue</strong> nalezneme následující datové
struktury, které je možné použít pro zajištění komunikace mezi vlákny:</p>

<table>
<tr><th>Struktura</th><th>Stručný popis</th></tr>
<tr><td>Queue</td><td>FIFO fronta s&nbsp;nastavitelnou kapacitou</td></tr>
<tr><td>LifoQueue</td><td>nenechte se zmýlit názvem, jedná se o klasický zásobník</td></tr>
<tr><td>PriorityQueue</td><td>prioritní fronta</td></tr>
<tr><td>SimpleQueue</td><td>klasická FIFO fronta s&nbsp;neomezenou kapacitou</td></tr>
</table>

<p>Mezi základní podporované operace patří vložení prvku do fronty metodou
<strong>put</strong> a získání prvku z&nbsp;fronty metodou
<strong>get</strong>. Tyto operace jsou obecně blokující, tj.&nbsp;například
pokud je fronta prázdná, bude operace <strong>get</strong> čekat na její
naplnění alespoň jedním prvkem. Toho lze využít pro posílání úloh
<i>workerovi</i> běžícímu v&nbsp;samostatném vláknu:</p>

<pre>
while True:
    <u>job = q.get()</u>
    print(f'Starting consuming {job}')
    ...
    ...
    ...
    <u>q.task_done()</u>
</pre>

<p>Vytváření úloh:</p>

<pre>
for job in range(10):
    print(f'Producing {job}')
    q.put(job)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Fronta ve funkci komunikačního i synchronizačního mechanismu</h2>

<p>V&nbsp;následujícím demonstračním příkladu je ukázán známý systém
<i>producer-consumer</i>, kde jak producent, tak i konzument každý běží
v&nbsp;samostatném vláknu a komunikují spolu pouze přes sdílenou frontu
<strong>q</strong>:</p>

<pre>
import time
import threading
import queue
&nbsp;
&nbsp;
<i># vytvoření fronty</i>
q = queue.Queue()
&nbsp;
&nbsp;
<i># simulace konzumenta</i>
def <strong>consumer</strong>():
    while True:
        job = q.get()
        print(f'Starting consuming {job}')
        time.sleep(0.4)
        print(f'Consumed {job}')
        q.task_done()
&nbsp;
&nbsp;
<i># spuštění konzumenta</i>
threading.Thread(target=consumer, daemon=True, name="první").start()
&nbsp;
<i># vytvoření úloh v producentovi</i>
for job in range(10):
    print(f'Producing {job}')
    q.put(job)
&nbsp;
<i># čekání na zpracování všech zpráv ve frontě</i>
q.join()
print('Done')
</pre>

<p>Výsledek:</p>

<pre>
Producing 0
Producing 1
Producing 2
Producing 3
Producing 4
Producing 5
Producing 6
Producing 7
Producing 8
Starting consuming 0
Producing 9
Consumed 0
Starting consuming 1
Consumed 1
Starting consuming 2
Consumed 2
Starting consuming 3
Consumed 3
Starting consuming 4
Consumed 4
Starting consuming 5
Consumed 5
Starting consuming 6
Consumed 6
Starting consuming 7
Consumed 7
Starting consuming 8
Consumed 8
Starting consuming 9
Consumed 9
Done
</pre>

<p><div class="rs-tip-major">Poznámka: lepší by bylo referenci na frontu předat
v&nbsp;parametru funkce <strong>worker</strong>.</div></p>

<p>Nic nám ovšem nebrání v&nbsp;tom, abychom spustili větší množství workerů,
kteří se budou o práci dělit:</p>

<pre>
import time
import threading
import queue
&nbsp;
&nbsp;
<i># vytvoření fronty</i>
q = queue.Queue()
&nbsp;
&nbsp;
<i># simulace konzumenta</i>
def <strong>consumer</strong>():
    name = threading.current_thread().name
    while True:
        job = q.get()
        print(f'{name} thread: Starting consuming {job}')
        time.sleep(0.4)
        print(f'{name} thread: Consumed {job}')
        q.task_done()
&nbsp;
&nbsp;
<i># spuštění konzumentů</i>
threading.Thread(target=consumer, daemon=True, name="1st").start()
threading.Thread(target=consumer, daemon=True, name="2nd").start()
threading.Thread(target=consumer, daemon=True, name="3rd").start()
&nbsp;
<i># vytvoření úloh v producentovi</i>
for job in range(10):
    print(f'Producing {job}')
    q.put(job)
&nbsp;
<i># čekání na zpracování všech zpráv ve frontě</i>
q.join()
print('Done')
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si na čekání v&nbsp;metodě
<strong>join</strong> na to, až jsou všechny zprávy potvrzeny.</div></p>

<p>Výsledek:</p>

<pre>
Producing 0
Producing 1
Producing 2
Producing 3
Producing 4
Producing 5
3rd thread: Starting consuming 0
Producing 6
1st thread: Starting consuming 2
Producing 7
2nd thread: Starting consuming 1
Producing 8
Producing 9
3rd thread: Consumed 0
1st thread: Consumed 2
3rd thread: Starting consuming 3
2nd thread: Consumed 1
1st thread: Starting consuming 4
2nd thread: Starting consuming 5
3rd thread: Consumed 3
3rd thread: Starting consuming 6
1st thread: Consumed 4
2nd thread: Consumed 5
1st thread: Starting consuming 7
2nd thread: Starting consuming 8
3rd thread: Consumed 6
3rd thread: Starting consuming 9
2nd thread: Consumed 8
1st thread: Consumed 7
3rd thread: Consumed 9
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Klasický vzor producent&ndash;konzument</h2>

<p>Producentů i konzumentů může být (prakticky) libovolné množství a navíc je
možné je přidávat nebo ubírat na základě požadavků aplikace.
V&nbsp;následujícím demonstračním příkladu spolu komunikují tři producenti a
čtyři konzumenti:</p>

<pre>
import time
import threading
import queue
&nbsp;
&nbsp;
<i># vytvoření fronty</i>
q = queue.Queue()
&nbsp;
&nbsp;
<i># simulace producenta</i>
def <strong>producer</strong>():
    name = threading.current_thread().name
    for job in range(10):
        print(f'{name} thread: Starting producing {job}')
        q.put(job)
        time.sleep(0.3)
        print(f'{name} thread: Produced {job}')
&nbsp;
&nbsp;
<i># simulace konzumenta</i>
def <strong>consumer</strong>():
    name = threading.current_thread().name
    while True:
        job = q.get()
        print(f'{name} thread: Starting consuming {job}')
        time.sleep(0.4)
        print(f'{name} thread: Consumed {job}')
        q.task_done()
&nbsp;
&nbsp;
<i># spuštění konzumentů</i>
threading.Thread(target=consumer, daemon=True, name="1st").start()
threading.Thread(target=consumer, daemon=True, name="2nd").start()
threading.Thread(target=consumer, daemon=True, name="3rd").start()
&nbsp;
<i># spuštění producentů</i>
threading.Thread(target=producer, daemon=True, name="1st").start()
threading.Thread(target=producer, daemon=True, name="2nd").start()
threading.Thread(target=producer, daemon=True, name="3rd").start()
threading.Thread(target=producer, daemon=True, name="3rd").start()
&nbsp;
<i># čekání na zpracování všech zpráv ve frontě</i>
q.join()
print('Done')
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
1st thread: Starting producing 0
1st thread: Starting consuming 0
2nd thread: Starting producing 0
3rd thread: Starting producing 0
2nd thread: Starting consuming 0
3rd thread: Starting producing 0
3rd thread: Starting consuming 0
1st thread: Produced 0
1st thread: Starting producing 1
2nd thread: Produced 0
2nd thread: Starting producing 1
3rd thread: Produced 0
...
...
...
1st thread: Starting consuming 8
2nd thread: Starting consuming 8
3rd thread: Consumed 8
3rd thread: Starting consuming 9
1st thread: Consumed 8
1st thread: Starting consuming 9
2nd thread: Consumed 8
2nd thread: Starting consuming 9
3rd thread: Consumed 9
3rd thread: Starting consuming 9
1st thread: Consumed 9
2nd thread: Consumed 9
3rd thread: Consumed 9
Done
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Prioritní fronta</h2>

<p>V&nbsp;některých situacích může být užitečné použít prioritní frontu
realizovanou třídou <strong>queue.PriorityQueue</strong>. Prvky vkládané do
takové fronty se přitom při výběru (logicky) řadí stejně, jako to dělá funkce
<strong>sorted</strong>. V&nbsp;praxi to znamená, že do fronty lze vkládat
libovolné prvky, ovšem typicky se jedná o dvojice
<strong>(priorita,hodnota)</strong> (dvojice je základním typem Pythonu &ndash;
<i>tuple</i>). Funkce <strong>sorted</strong> řadí dvojice nejdříve podle
jejich prvního prvku, čímž je automaticky zajištěno řazení podle priority:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;  
import queue
import random
&nbsp;  
q = queue.PriorityQueue(40)
&nbsp;  
for item in range(30):
    print("Size", q.qsize())
    print("Empty?", q.empty())
    print("Full?", q.full())
&nbsp;  
    value = random.randint(1, 20)
    print(value)
    q.put("prvek # {:2d}".format(value))
&nbsp;  
&nbsp;  
while not q.empty():
    print("Read item:", q.get())
</pre>

<p>Prvky budou vybrány v&nbsp;tomto pořadí:</p>

<pre>
Read item: prvek #  1
Read item: prvek #  3
Read item: prvek #  3
Read item: prvek #  4
Read item: prvek #  5
...
...
...
Read item: prvek # 20
Read item: prvek # 20
Read item: prvek # 20
Read item: prvek # 20
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Jazyk Python a multiprocessing</h2>

<p>V&nbsp;předchozích kapitolách jsme si popsali základní způsoby rozdělení
výpočtů do většího množství vláken s&nbsp;využitím standardního balíčku
nazvaného <strong>threading</strong>. Ovšem existují i další možnosti tvorby
aplikací, jejichž části mají běžet buď &bdquo;pouze&ldquo; souběžně nebo které
využijí plnou paralelnost nabízenou moderními počítači. Vzhledem
k&nbsp;existenci GILu ve standardním CPythonu je problematické zajistit
paralelní běh v&nbsp;rámci jednoho procesu (tedy vlastně jednoho virtuálního
stroje Pythonu), proto je dalším logickým krokem rozdělení (<i>fork</i>) tohoto
procesu na větší množství plnohodnotných systémových procesů. Ty budou moci
běžet nezávisle na sobě a navíc toto řešení programátora donutí k&nbsp;tomu,
aby explicitně zajistil korektní komunikaci mezi těmito procesy &ndash; zde již
nemůže dojít k&nbsp;chybám typu &bdquo;přístup do objektu vlastněného jiným
vláknem&ldquo; atd. Toto řešení přináší i některé nevýhody &ndash; větší
systémové nároky, pomalejší spouštění procesů (v&nbsp;porovnání se spouštěním
vláken) a v&nbsp;některých případech se projeví i delší doba přepínání mezi
procesy (ovšem to se podle mého názoru u interpretovaného Pythonu ztratí) a
někdy by se skutečně hodilo mít snadný přístup ke sdíleným objektům.</p>

<p>V&nbsp;případě, že se rozhodnete si vyzkoušet spouštění jednotlivých částí
algoritmu v&nbsp;samostatných procesech, můžete využít další standardní modul
(balíček), který se jmenuje příznačně <strong>multiprocessing</strong>. Tento
modul vývojáře do značné míry odstiňuje od nízkoúrovňových operací, tedy od
samotného rozvětvení procesu (<i>fork</i>), spuštění nového interpretru a
specifikace, jaký kód má tento interpret použít. Z&nbsp;pohledu vývojáře je
totiž použití modulu <strong>multiprocessing</strong> velmi přímočaré &ndash;
pouze se zvolí, jaká funkce se má zavolat v&nbsp;novém procesu a jaké mají být
této funkci předány argumenty. Navíc modul <strong>multiprocessing</strong>
programátorům nabízí mechanismy umožňující komunikaci mezi procesy. Zejména se
jedná o frontu (<i>queue</i>) (ovšem jinou frontu, než jsme doposud používali,
i když její API je v&nbsp;některých ohledech prakticky totožné) a taktéž o
oboustrannou rouru (<i>pipe</i>).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Spuštění nového procesu</h2>

<p>Podívejme se nyní na velmi jednoduchý demonstrační příklad, na němž jsou
ukázány základní mechanismy nabízené modulem <strong>multiprocessing</strong>.
Ve skriptu je definována následující funkce, která se má spustit
v&nbsp;samostatném procesu:</p>

<pre>
def <strong>worker</strong>(name):
    print("hello", name)
</pre>

<p>Nový proces se spustí následovně:</p>

<pre>
p = Process(target=worker, args=("foo",))
p.start()
</pre>

<p>Implementovat je možné i čekání na dokončení tohoto procesu:</p>

<pre>
p.join()
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že není požadováno
čekání na dokončení procesu, lze jeho vytvoření a spuštění napsat na jediný
řádek:</div></p>

<pre>
p = Process(target=worker, args=("foo",)).start()
</pre>

<p>Úplný zdrojový kód takto vytvořeného příkladu vypadá následovně:</p>

<pre>
from multiprocessing import Process
&nbsp;
&nbsp;
def <strong>worker</strong>(name):
    print("hello", name)
&nbsp;
&nbsp;
def <strong>main</strong>():
    p = Process(target=worker, args=("foo",))
    p.start()
    p.join()
&nbsp;
&nbsp;
if __name__ == '__main__':
    print("Running main")
    main()
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Spuštění většího množství procesů, čekání na dokončení těchto procesů</h2>

<p>Samozřejmě můžeme spustit větší množství procesů a následně si (například
nástrojem <strong>top</strong> nebo <strong>htop</strong>) tyto procesy
zobrazit. Na dokončení procesů lze počkat metodou <strong>join</strong> &ndash;
jedná se tedy o prakticky stejný koncept, jaký jsme viděli při práci
s&nbsp;větším množstvím vláken:</p>

<pre>
from multiprocessing import Process
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(name):
    print("hello", name)
    time.sleep(5)
    print("done", name)
&nbsp;
&nbsp;
def <strong>main</strong>():
    ps = []
&nbsp;
    for name in ("foo", "bar", "baz", "other"):
        p = Process(target=worker, args=(name,))
        p.start()
        ps.append(p)
&nbsp;
    for p in ps:
        p.join()
&nbsp;
&nbsp;
if __name__ == '__main__':
    print("Running main")
    main()
</pre>

<p>Výpis procesů (včetně dvou nerelevantních procesů):</p>

<pre>
$ <strong>ps ax |grep python</strong>
&nbsp;
  767 ?        Ssl    0:00 /usr/bin/python3 -Es /usr/sbin/firewalld --nofork --nopid
10864 pts/4    S+     0:00 python3 multiprocessing2.py
10865 pts/4    S+     0:00 python3 multiprocessing2.py
10866 pts/4    S+     0:00 python3 multiprocessing2.py
10867 pts/4    S+     0:00 python3 multiprocessing2.py
10868 pts/4    S+     0:00 python3 multiprocessing2.py
10947 pts/6    S+     0:00 grep --color=auto python
</pre>

<p>Zvýraznění forku:</p>

<pre>
$ <strong>pstree -c 10864</strong>
&nbsp;
python3─┬─python3
        ├─python3
        ├─python3
        └─python3
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Zjednodušení předchozího demonstračního příkladu</h2>

<p>Jen pro úplnost si ukažme, jak je možné předchozí demonstrační příklad
nepatrně zjednodušit použitím generátorové notace seznamu:</p>

<pre>
from multiprocessing import Process
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(name):
    print("hello", name)
    time.sleep(5)
    print("done", name)
&nbsp;
&nbsp;
def <strong>main</strong>():
    ps = [Process(target=worker, args=(name,)) for name in ("foo", "bar", "baz", "other")]
&nbsp;
    for p in ps:
        p.start()
&nbsp;
    for p in ps:
        p.join()
&nbsp;
&nbsp;
if __name__ == '__main__':
    print("Running main")
    main()
</pre>

<p><div class="rs-tip-major">Poznámka: mezi procesy <i>nelze</i> (jednoduše)
sdílet objekty, které ve skutečnosti existují pouze v&nbsp;rámci jednoho
virtuálního stroje Pythonu:</div></p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;  
from multiprocessing import Process
import time
&nbsp;  
&nbsp;  
def <strong>worker</strong>(name, dictionary):
    dictionary[name] = "ok"
    print("hello", name)
    time.sleep(5)
    print("done", name)
&nbsp;  
&nbsp;  
def main():
    d = {}
&nbsp;  
    ps = []
&nbsp;  
    for name in ("foo", "bar", "baz", "other"):
        p = Process(target=worker, args=(name, d))
        p.start()
        ps.append(p)
&nbsp;  
    for p in ps:
        p.join()
&nbsp;  
    print(d)
&nbsp;  
&nbsp;  
if __name__ == "__main__":
    print("Running main")
    main()
</pre>

<p>Tento skript na závěr vypíše prázdný slovník, i když by &bdquo;měl&ldquo;
obsahovat čtyři záznamy:</p>

<pre>
Running main
hello foo
hello bar
hello baz
hello other
done foo
done bar
done baz
done other
<strong>{}</strong>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Komunikace mezi procesy přes <strong>multiprocessing.Queue</strong></h2>

<p>I pro komunikaci mezi <i>procesy</i>, podobně jako pro komunikaci mezi
<i>vlákny</i>, lze použít frontu. V&nbsp;tomto případě je ovšem její interní
reprezentace zcela odlišná, protože musí zajistit <i>meziprocesovou</i>
komunikaci, a to s&nbsp;využitím prostředků poskytovaných operačním systémem
(například rourami). Namísto standardní struktury <strong>queue.Queue</strong>
(ta je funkční jen v&nbsp;rámci jediného virtuálního stroje Pythonu) je tedy
nutné použít strukturu <strong>multiprocessing.Queue</strong>, která se
z&nbsp;pohledu programátora chová velmi podobně.</p>

<p>V&nbsp;následujícím demonstračním příkladu posíláme <i>workerům</i>, které
jsou spuštěny v&nbsp;samostatných procesech, úlohy/příkazy, mezi jinými i
příkaz pro jejich ukončení (tento příkaz je nutné poslat třikrát, aby dokázal
zareagovat každý worker):</p>

<pre>
from multiprocessing import Process, Queue
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    while True:
        cmd = q.get()
        print(name, cmd)
        if cmd == "quit":
            print("Quitting")
            return
        time.sleep(1)
&nbsp;
&nbsp;
def <strong>main</strong>():
    q = Queue()
&nbsp;
    ps = [Process(target=worker, args=(name, q)) for name in ("foo", "bar", "baz")]
&nbsp;
    for p in ps:
        p.start()
&nbsp;
    for i in range(10):
        q.put("command {}".format(i))
&nbsp;
    for i in range(3):
        q.put("quit")
&nbsp;
    for p in ps:
        p.join()
&nbsp;
&nbsp;
if __name__ == '__main__':
    print("Running main")
    main()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Komunikace mezi procesy přes obousměrnou rouru (<strong>multiprocessing.Pipe</strong>)</h2>

<p>Alternativně lze pro meziprocesovou komunikaci použít obousměrnou routu
(<i>pipe</i>) s&nbsp;metodami <strong>send</strong> a <strong>recv</strong>.
V&nbsp;následujícím demonstračním příkladu je spuštěn pouze jeden další proces
a proto si vystačíme s&nbsp;jedinou rourou. Druhému procesu posíláme
příkazy/úlohy, na které odpovídá (simulace práce) a taktéž příkaz
<strong>quit</strong>, kterým se tento proces ukončí:</p>

<pre>
from multiprocessing import Process, Pipe
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(name, conn):
    while True:
        cmd = conn.recv()
        print("{} received {}".format(name, cmd))
        if cmd == "quit":
            return
        else:
            conn.send("{} accepted {}".format(name, cmd))
        time.sleep(1)
&nbsp;
&nbsp;
def <strong>main</strong>():
    parent_conn, child_conn = Pipe()
&nbsp;
    p = Process(target=worker, args=("Worker", child_conn))
    p.start()
&nbsp;
    for i in range(10):
        parent_conn.send("command {}".format(i))
        print(parent_conn.recv())
&nbsp;
    parent_conn.send("quit")
&nbsp;
    p.join()
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Spouštění a řízení paralelně běžících úloh &ndash; <strong>concurrent.futures</strong></h2>

<p>V&nbsp;navazujícím článku si mj.&nbsp;popíšeme i třídu
<strong>ThreadPoolExecutor</strong>, kterou lze s&nbsp;výhodou využít ve
chvíli, kdy se mají často spouštět různé asynchronně běžící úlohy:</p>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
&nbsp;
&nbsp;
with ThreadPoolExecutor(max_workers=3) as executor:
    executor.submit(worker, "Thread-1", 0.5, 10)
    executor.submit(worker, "Thread-2", 1.0, 10)
    executor.submit(worker, "Thread-3", 1.5, 10)
&nbsp;
&nbsp;
print("Done!")
</pre>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
    print("{}: DONE!".format(threadName))
&nbsp;
&nbsp;
workers = 10
&nbsp;
with ThreadPoolExecutor(max_workers=3) as executor:
    for w in range(workers):
        executor.submit(worker, "Thread-{}".format(w + 1), 0.5 + w / 10.0, 10)
&nbsp;
&nbsp;
print("Done!")
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>multithreading1.py</td><td>spuštění tří vláken vykonávajících déletrvající činnost</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading1.py</a></td></tr>
<tr><td> 2</td><td>multithreading2.py</td><td>spuštění tří vláken, předání parametrů volaným funkcím</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading2.py</a></td></tr>
<tr><td> 3</td><td>multithreading3.py</td><td>explicitní čekání na dokončení běhu vláken metodou <strong>join</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading3.py</a></td></tr>
<tr><td> 4</td><td>multithreading_join_deamon.py</td><td>čekání na dokončení vláken s&nbsp;příznakem &bdquo;daemon&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_join_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_join_deamon.py</a></td></tr>
<tr><td> 5</td><td>multithreading_no_join_deamon.py</td><td>vlákna s&nbsp;příznakem &bdquo;daemon&ldquo;, na jejichž ukončení se nečeká</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_deamon.py</a></td></tr>
<tr><td> 6</td><td>multithreading_no_join_no_deamon.py</td><td>běžná vlákna bez příznaku &bdquo;daemon&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_no_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_no_deamon.py</a></td></tr>
<tr><td> 7</td><td>multithreading_timeout.py</td><td>specifikace maximální doby čekání na ukončení vlákna</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_timeout.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_timeout.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>multiprocessing1.py</td><td>zavolání funkce spuštěné v&nbsp;rámci dalšího procesu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing1.py</a></td></tr>
<tr><td> 9</td><td>multiprocessing2.py</td><td>spuštění většího množství procesů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing2.py</a></td></tr>
<tr><td>10</td><td>multiprocessing3.py</td><td>nepatrná úprava předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing3.py</a></td></tr>
<tr><td>11</td><td>multiprocessing4.py</td><td>řízení workerů posílanými příkazy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing4.py</a></td></tr>
<tr><td>12</td><td>multiprocessing5.py</td><td>řízení workerů posílanými příkazy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing5.py</a></td></tr>
<tr><td>13</td><td>multiprocessing6.py</td><td>jeden proces a sdílená globální hodnota</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing6.py</a></td></tr>
<tr><td>14</td><td>multiprocessing7.py</td><td>více procesů, které nesdílí hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing7.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>priority_queue_example.py</td><td>prioritní fronta s&nbsp;nastavenou kapacitou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/priority_queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/priority_queue_example.py</a></td></tr>
<tr><td>16</td><td>queue_example.py</td><td>základní operace s&nbsp;frontou s&nbsp;nastavenou kapacitou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queue_example.py</a></td></tr>
<tr><td>17</td><td>queues1.py</td><td>systém producent-konzument založený na použití fronty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues1.py</a></td></tr>
<tr><td>18</td><td>queues2.py</td><td>jeden producent a větší množství konzumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues2.py</a></td></tr>
<tr><td>19</td><td>queues3.py</td><td>větší množství producentů i větší množství konzumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues3.py</a></td></tr>
<tr><td>20</td><td>queues4.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues4.py</a></td></tr>
<tr><td>21</td><td>simple_queue_example.py</td><td>základní operace s&nbsp;frontou bez kapacity</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/simple_queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/simple_queue_example.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace Pythonu: balíček queue<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Dokumentace Pythonu: balíček threading<br />
<a href="https://docs.python.org/3/library/threading.html?">https://docs.python.org/3/library/threading.html?</a>
</li>

<li>Dokumentace Pythonu: balíček multiprocessing<br />
<a href="https://docs.python.org/3/library/multiprocessing.html">https://docs.python.org/3/library/multiprocessing.html</a>
</li>

<li>Dokumentace Pythonu: balíček asyncio<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Synchronization Primitives<br />
<a href="https://docs.python.org/3/library/asyncio-sync.html">https://docs.python.org/3/library/asyncio-sync.html</a>
</li>

<li>Coroutines<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Queues<br />
<a href="https://docs.python.org/3/library/asyncio-queue.html">https://docs.python.org/3/library/asyncio-queue.html</a>
</li>

<li>python-csp<br />
<a href="https://python-csp.readthedocs.io/en/latest/">https://python-csp.readthedocs.io/en/latest/</a>
</li>

<li>TrellisSTM<br />
<a href="http://peak.telecommunity.com/DevCenter/TrellisSTM">http://peak.telecommunity.com/DevCenter/TrellisSTM</a>
</li>

<li>Python Multithreading and Multiprocessing Tutorial<br />
<a href="https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python">https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

