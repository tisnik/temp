<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">2. Instalace knihoven <strong>curio</strong> a <strong>trio</strong></a></p>
<p><a href="#k03">3. Základní konstrukce nabízené knihovnou <strong>curio</strong></a></p>
<p><a href="#k04">4. Předání parametrů synchronně či asynchronně volané korutině</a></p>
<p><a href="#k05">5. Chování programu při spuštění několika korutin funkcí <strong>curio.run</strong></a></p>
<p><a href="#k06">*** 6. Asynchronní spuštění korutin</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p><i>&bdquo;Everything runs parallel except your code&ldquo;<br />
Felix Geisendörfer.</i></p>

<p></p>

event loop
async
await

prime volani = vytvori korutinu object



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace knihoven <strong>curio</strong> a <strong>trio</strong></h2>

<p>Obě knihovny, jimiž se budeme v&nbsp;dnešním článku zabývat, je nejprve
nutné nainstalovat, protože na rozdíl od minule popsané knihovny
<strong>asyncio</strong> nejsou součástí standardních balíčků Pythonu. Jak
<strong>curio</strong> tak i <strong>trio</strong> jsou dostupné na <a
href="https://pypi.org/">PyPI</a>, takže je jejich instalace velmi snadná. Pro
tento účel můžeme použít například nástroj <strong>pip</strong>.</p>

<p>Instalace knihovny <strong>curio</strong> (povšimněte si, že nemá žádné
další závislosti):</p>

<pre>
$ <strong>pip3 install --user curio</strong>
&nbsp;
Collecting curio
  Downloading curio-1.5.tar.gz (234 kB)
     |████████████████████████████████| 234 kB 1.4 MB/s            
  Preparing metadata (setup.py) ... done
Building wheels for collected packages: curio
  Building wheel for curio (setup.py) ... done
  Created wheel for curio: filename=curio-1.5-py3-none-any.whl size=63766 sha256=042c3ba7cb8086cb4778a131bf73d9c35f82f12ff8e94e8d8c2fa673d683fcd1
  Stored in directory: /home/ptisnovs/.cache/pip/wheels/93/ac/0e/8cb82ba7d5f527f27d0b8e06d031a5f7899ef30c4dbf47a313
Successfully built curio
Installing collected packages: curio
Successfully installed curio-1.5
</pre>

<p>A instalace knihovny <strong>trio</strong>:</p>

<pre>
$ <strong>pip3 install --user trio</strong>
&nbsp;
Collecting trio
  Downloading trio-0.20.0-py3-none-any.whl (359 kB)
     |████████████████████████████████| 359 kB 1.4 MB/s            
Collecting sniffio
  Downloading sniffio-1.2.0-py3-none-any.whl (10 kB)
Collecting outcome
  Downloading outcome-1.1.0-py2.py3-none-any.whl (9.7 kB)
Requirement already satisfied: attrs&gt;=19.2.0 in ./.local/lib/python3.8/site-packages (from trio) (21.4.0)
Collecting async-generator&gt;=1.9
  Downloading async_generator-1.10-py3-none-any.whl (18 kB)
Collecting sortedcontainers
  Downloading sortedcontainers-2.4.0-py2.py3-none-any.whl (29 kB)
Requirement already satisfied: idna in /usr/lib/python3/dist-packages (from trio) (2.8)
Installing collected packages: sortedcontainers, sniffio, outcome, async-generator, trio
Successfully installed async-generator-1.10 outcome-1.1.0 sniffio-1.2.0 sortedcontainers-2.4.0 trio-0.20.0
</pre>

<p>Velmi zběžná kontrola, zda jsou obě knihovny dostupné:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.8.10 (default, Mar 15 2022, 12:22:08) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; <strong>import curio</strong>
&gt;&gt;&gt; <strong>import trio</strong>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní konstrukce nabízené knihovnou <strong>curio</strong></h2>

<p>Připomeňme si nejprve náš úplně první pokus o vytvoření úlohy, která bude
reprezentována korutinou. Minule jsme pro tento účel použili knihovnu
<strong>asyncio</strong> a řešení vypadalo následovně: úloha je získána
transformací funkce <strong>task</strong> do plnohodnotné korutiny (přes přímé
volání této funkce), kterou posléze voláme z&nbsp;funkce <strong>main</strong>,
a to konkrétně s&nbsp;využitím programové konstrukce
<strong>await</strong>:</p>

<pre>
import asyncio
import time
&nbsp;
&nbsp;
<u>async</u> def <strong>task</strong>():
    print("task started")
    <u>await</u> asyncio.sleep(5)
    print("task finished")
&nbsp;
&nbsp;
def <strong>main</strong>():
    task1 = asyncio.create_task(task())
    print("task created")
&nbsp;
    <u>await</u> task1
&nbsp;
    print("done")
&nbsp;
&nbsp;
main()
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto konkrétním případě se
korutiny mohou přepínat při volání <strong>asyncio.sleep</strong>.</div></p>

<p>Přepis tohoto programu založeného na korutinách tak, aby se použila knihovna
<strong>curio</strong>, je poměrně přímočarý. Opět použijeme funkci nazvanou
<strong>sleep</strong>, ovšem tentokrát získanou z&nbsp;balíčku
<strong>curio</strong>. Povšimněte si, že se skutečně jedná o korutinu, protože
před jménem funkce je uvedeno klíčové slovo <strong>async</strong> a zavoláním
této funkce získáme objekt představující korutinu:</p>

<pre>
<strong>async sleep(seconds)</strong>
    Sleep for a specified number of seconds.  Sleeping for 0 seconds
    makes a task immediately switch to the next ready task (if any).
    Returns the value of the kernel clock when awakened.
</pre>

<p>Odlišné bude i volání korutiny, protože se pro tento účel použije funkce
nazvaná <strong>run</strong> (opět importovaná z&nbsp;balíčku
<strong>curio</strong>). Povšimněte si, že prvním (a jediným povinným)
parametrem této funkce je korutina, která se má spustit. To mj.&nbsp;znamená,
že se můžeme obejít bez explicitního vytvoření úlohy a jejího následného
volání:</p>

<pre>
<strong>run(corofunc, *args, with_monitor=False, selector=None, debug=None, activations=None, **kernel_extra)</strong>
    Run the curio kernel with an initial task and execute until all
    tasks terminate.  Returns the task's final result (if any). This
    is a convenience function that should primarily be used for
    launching the top-level task of a curio-based application.  It
    creates an entirely new kernel, runs the given task to completion,
    and concludes by shutting down the kernel, releasing all resources used.
&nbsp;    
    Don't use this function if you're repeatedly launching a lot of
    new tasks to run in curio. Instead, create a Kernel instance and
    use its run() method instead.
</pre>

<p>Celý skript se nepatrně zkrátil &ndash; jedná se o odlišný zápis ve funkci
<strong>main</strong>:</p>

<pre>
import curio
&nbsp;
&nbsp;
<u>async</u> def <strong>task</strong>():
    print("task started")
    <u>await</u> curio.sleep(5)
    print("task finished")
&nbsp;
&nbsp;
def <strong>main</strong>():
    print("main started")
    curio.run(task)
    print("done")
&nbsp;
&nbsp;
main()
</pre>

<p>Po spuštění tohoto prozatím velmi jednoduchého programu by se měly na
terminál vypsat následující zprávy:</p>

<pre>
main started
task started
task finished
done
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě sice používáme
korutinu, ovšem čekáme na její dokončení, což je ostatně patrné i z&nbsp;pořadí
vypsaných zpráv &ndash; korutina je spuštěna, počká se na její ukončení a
teprve poté se řízení vrátí zpět do funkce <strong>main</strong>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Předání parametrů synchronně či asynchronně volané korutině</h2>

<p>Korutinám je v&nbsp;naprosté většině případů nutné předávat nějaké
parametry. V&nbsp;případě minule popsané knihovny <strong>asyncio</strong> se
parametry mohly korutině předat v&nbsp;rámci volání funkce
<strong>asyncio.create_task</strong>, takže program, který vytvořil, zavolal a
počkal na dokončení dvou korutin (s&nbsp;parametry) mohl vypadat
následovně:</p>

<pre>
import asyncio
import time
&nbsp;
&nbsp;
<u>async</u> def task(name):
    print(f"{name} task started")
    <u>await</u> asyncio.sleep(5)
    print(f"{name} task finished")
&nbsp;
&nbsp;
<u>async</u> def main():
    task1 = asyncio.create_task(task("first"))
    print("first task created")
&nbsp;
    task2 = asyncio.create_task(task("second"))
    print("second task created")
&nbsp;
    <u>await</u> task1
    <u>await</u> task2
&nbsp;
    print("done")
&nbsp;
&nbsp;
asyncio.run(main())
</pre>

<p>V&nbsp;případě, že je namísto knihovny <strong>asyncio</strong> použita
knihovna <strong>curio</strong>, jsou parametry korutině předány přímo
v&nbsp;rámci funkce <strong>curio.run</strong>. Povšimněte si podstatného
rozdílu &ndash; nevoláme zde přímo korutinu <strong>task</strong> (ve
skutečnosti ani v&nbsp;případě <strong>asyncio</strong> nedochází k&nbsp;jejímu
přímému volání), ale reference na (synchronně či asynchronně) volanou korutinu
se společně s&nbsp;jejími parametry předává funkci
<strong>curio.run</strong>:</p>

<pre>
import curio
&nbsp;
&nbsp;
<u>async</u> def <strong>task</strong>(n, s):
    print("task started")
&nbsp;
    for i in range(n):
        print(f"{i+1}/{n}")
        <u>await</u> curio.sleep(s)
&nbsp;
    print("task finished")
&nbsp;
&nbsp;
def <strong>main</strong>():
    print("main started")
    curio.run(task, 10, 1)
    print("done")
&nbsp;
&nbsp;
main()
</pre>

<p>Po spuštění tohoto příkladu opět dojde k&nbsp;asynchronnímu spuštění
korutiny s&nbsp;čekáním na její dokončení:</p>

<pre>
main started
task started
1/10
2/10
3/10
4/10
5/10
6/10
7/10
8/10
9/10
10/10
task finished
done
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Chování programu při spuštění několika korutin funkcí <strong>curio.run</strong></h2>

<p>Zkusme si nyní spustit následující skript, v&nbsp;němž jsou vytvořeny a
spuštěny celkem tři korutiny. Pro jejich spuštění se používá funkce nazvaná
<strong>curio.run</strong>, s&nbsp;níž jsme se již seznámili v&nbsp;rámci
předchozích dvou kapitol:</p>

<pre>
import curio
&nbsp;
&nbsp;
<u>async</u> def <strong>task</strong>(name, n, s):
    print(f"{name} task started")
&nbsp;
    for i in range(n):
        print(f"{name} {i+1}/{n}")
        <u>await</u> curio.sleep(s)
&nbsp;
    print(f"{name} task finished")
&nbsp;
&nbsp;
def <strong>main</strong>():
    print("main started")
    curio.run(task, "1st", 10, 1)
    curio.run(task, "2nd", 10, 1)
    curio.run(task, "3rd", 10, 1)
    print("done")
&nbsp;
&nbsp;
main()
</pre>

<p>Po spuštění tohoto skriptu získáme následující výstup, který jasně ukazuje,
že i přes volání <strong>await curio.sleep</strong> v&nbsp;korutině nedojde
k&nbsp;přepnutí na další korutinu &ndash; další korutina totiž ještě ani nebyla
vytvořena. To vlastně znamená, že <strong>curio.run</strong> zajišťuje
synchronní volání korutiny (protože se skutečně jedná o korutinu získanou
transformací funkce s&nbsp;využitím konstrukce <strong>async</strong>):</p>

<pre>
main started
1st task started
1st 1/10
1st 2/10
1st 3/10
1st 4/10
1st 5/10
1st 6/10
1st 7/10
1st 8/10
1st 9/10
1st 10/10
1st task finished
2nd task started
2nd 1/10
2nd 2/10
2nd 3/10
2nd 4/10
2nd 5/10
2nd 6/10
2nd 7/10
2nd 8/10
2nd 9/10
2nd 10/10
2nd task finished
3rd task started
3rd 1/10
3rd 2/10
3rd 3/10
3rd 4/10
3rd 5/10
3rd 6/10
3rd 7/10
3rd 8/10
3rd 9/10
3rd 10/10
3rd task finished
done
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Asynchronní spuštění korutin</h2>

<pre>
<strong>async spawn(corofunc, *args, daemon=False)</strong>
    Create a new task, running corofunc(*args). Use the daemon=True
    option if the task runs forever as a background task.
</pre>

<pre>
import curio
&nbsp;
&nbsp;
<u>async</u> def <strong>task</strong>(name, n, s):
    print(f"{name} task started")
&nbsp;
    for i in range(n):
        print(f"{name} {i+1}/{n}")
        <u>await</u> curio.sleep(s)
&nbsp;
    print(f"{name} task finished")
&nbsp;
&nbsp;
def <strong>main</strong>():
    print("main started")
    task1 = curio.spawn(task, "1st", 10, 1)
    task2 = curio.spawn(task, "2nd", 10, 1)
    task3 = curio.spawn(task, "3rd", 10, 1)
    print("done")
&nbsp;
&nbsp;
main()
</pre>

<pre>
main started
done
curio_04.py:22: RuntimeWarning: coroutine 'spawn' was never awaited
  main()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
</pre>

<pre>
import curio
&nbsp;
&nbsp;
<u>async</u> def <strong>task</strong>(name, n, s):
    print(f"{name} task started")
&nbsp;
    for i in range(n):
        print(f"{name} {i+1}/{n}")
        <u>await</u> curio.sleep(s)
&nbsp;
    print(f"{name} task finished")
&nbsp;
&nbsp;
<u>async</u> def <strong>main</strong>():
    print("main started")
    task1 = <u>await</u> curio.spawn(task, "1st", 10, 1)
    task2 = <u>await</u> curio.spawn(task, "2nd", 10, 1)
    task3 = <u>await</u> curio.spawn(task, "3rd", 10, 1)
    print("done")
&nbsp;
&nbsp;
curio.run(main())
</pre>

<pre>
main started
done
1st task started
1st 1/10
2nd task started
2nd 1/10
3rd task started
3rd 1/10
</pre>

<pre>
import curio
&nbsp;
&nbsp;
<u>async</u> def <strong>task</strong>(name, n, s):
    print(f"{name} task started")
&nbsp;
    for i in range(n):
        print(f"{name} {i+1}/{n}")
        <u>await</u> curio.sleep(s)
&nbsp;
    print(f"{name} task finished")
&nbsp;
&nbsp;
<u>async</u> def <strong>main</strong>():
    print("main started")
&nbsp;
    task1 = <u>await</u> curio.spawn(task, "1st", 10, 1)
    task2 = <u>await</u> curio.spawn(task, "2nd", 10, 1)
    task3 = <u>await</u> curio.spawn(task, "3rd", 10, 1)
&nbsp;
    <u>await</u> task1.join()
    <u>await</u> task2.join()
    <u>await</u> task3.join()
&nbsp;
    print("done")
&nbsp;
&nbsp;
curio.run(main())
</pre>

<pre>
main started
1st task started
1st 1/10
2nd task started
2nd 1/10
3rd task started
3rd 1/10
1st 2/10
2nd 2/10
3rd 2/10
1st 3/10
2nd 3/10
3rd 3/10
1st 4/10
2nd 4/10
3rd 4/10
1st 5/10
2nd 5/10
3rd 5/10
1st 6/10
2nd 6/10
3rd 6/10
1st 7/10
2nd 7/10
3rd 7/10
1st 8/10
2nd 8/10
3rd 8/10
1st 9/10
2nd 9/10
3rd 9/10
1st 10/10
2nd 10/10
3rd 10/10
1st task finished
2nd task finished
3rd task finished
done
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
import curio
&nbsp;
&nbsp;
<u>async</u> def <strong>task</strong>(name, n, s):
    print(f"{name} task started")
&nbsp;
    for i in range(n):
        print(f"{name} {i+1}/{n}")
        <u>await</u> curio.sleep(s)
&nbsp;
    print(f"{name} task finished")
&nbsp;
&nbsp;
<u>async</u> def <strong>main</strong>():
    print("main started")
    task1 = <u>await</u> curio.spawn(task, "1st", 10, 5)
    task2 = <u>await</u> curio.spawn(task, "2nd", 10, 5)
    task3 = <u>await</u> curio.spawn(task, "3rd", 10, 5)
&nbsp;
    <u>await</u> task1.join()
    <u>await</u> task2.join()
    <u>await</u> task3.join()
&nbsp;
    print("done")
&nbsp;
&nbsp;
curio.run(main(), with_monitor=True)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<p></p>

<pre>
$ <strong>python3 curio_06.py</strong>
</pre>

<p></p>

<pre>
$ <strong>python3 -m curio.monitor</strong>
</pre>

<p></p>

<pre>
Curio Monitor: 6 tasks running
Type help for commands
curio &gt;
</pre>

<pre>
curio &gt; <strong>help</strong>
Commands:
         ps               : Show task table
         where taskid     : Show stack frames for a task
         cancel taskid    : Cancel an indicated task
         signal signame   : Send a Unix signal
         parents taskid   : List task parents
         quit             : Leave the monitor
</pre>

<p></p>

<pre>
curio &gt; <strong>ps</strong>
&nbsp;
Task   State        Cycles     Timeout Sleep   Task                                               
------ ------------ ---------- ------- ------- --------------------------------------------------
1      READ_WAIT    1          None    None    Kernel._make_kernel_runtime.<locals>._kernel_task 
3      FUTURE_WAIT  1          None    None    Monitor.monitor_task                              
4      TASK_JOIN    1          None    None    main                                              
5      TIME_SLEEP   6          None    3.65660 task                                              
6      TIME_SLEEP   6          None    3.65671 task                                              
7      TIME_SLEEP   6          None    3.65674 task                                              
</pre>

<p></p>

<pre>
curio &gt; <strong>w 6</strong>
&nbsp;
Stack for Task(id=6, name='task', state='TIME_SLEEP') (most recent call last):
  File "curio_06.py", line 9, in task
    await curio.sleep(s)
&nbsp;
curio &gt;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<p></p>

<pre>
import curio


async def task(name, queue):
    while not queue.empty():
        param = await queue.get()
        print(f"Task named {name} started with parameter {param}")
        await curio.sleep(5)
        print(f"{name} task finished")


async def main():
    print("main started")

    queue = curio.Queue()

    for i in range(20):
        await queue.put(i)

    task1 = await curio.spawn(task, "1st", queue)
    task2 = await curio.spawn(task, "2nd", queue)
    task3 = await curio.spawn(task, "3rd", queue)
    task4 = await curio.spawn(task, "4th", queue)

    await task1.join()
    await task2.join()
    await task3.join()
    await task4.join()

    print("done")


curio.run(main(), with_monitor=True)
</pre>


<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<p></p>

<pre>
curio &gt; <strong>ps</strong>
&nbsp;
Task   State        Cycles     Timeout Sleep   Task                                               
------ ------------ ---------- ------- ------- --------------------------------------------------
1      READ_WAIT    1          None    None    Kernel._make_kernel_runtime.&lt;locals&gt;._kernel_task 
3      FUTURE_WAIT  1          None    None    Monitor.monitor_task                              
4      TASK_JOIN    1          None    None    main                                              
5      TIME_SLEEP   1          None    1.47796 task                                              
6      TIME_SLEEP   1          None    1.47797 task                                              
7      TIME_SLEEP   1          None    1.47798 task                                              
8      TIME_SLEEP   1          None    1.47798 task                                              
</pre>

curio &gt; <strong>parents 5</strong>
&nbsp;
5        TIME_SLEEP task
4         TASK_JOIN main

<pre>
import curio
&nbsp;
&nbsp;
async def task(name, queue):
    while not queue.empty():
        param = await queue.get()
        print(f"Task named {name} started with parameter {param}")
        await curio.sleep(1)
        print(f"{name} task finished")
&nbsp;
&nbsp;
async def main():
    print("main started")
&nbsp;
    queue = curio.UniversalQueue()
&nbsp;
    for i in range(20):
        await queue.put(i)
&nbsp;
    task1 = await curio.spawn(task, "1st", queue)
    task2 = await curio.spawn(task, "2nd", queue)
    task3 = await curio.spawn(task, "3rd", queue)
    task4 = await curio.spawn(task, "4th", queue)
&nbsp;
    await task1.join()
    await task2.join()
    await task3.join()
    await task4.join()
&nbsp;
    print("done")
&nbsp;
&nbsp;
curio.run(main(), with_monitor=True)
</pre>

<pre>
main started
Task named 1st started with parameter 0
Task named 2nd started with parameter 1
Task named 3rd started with parameter 2
Task named 4th started with parameter 3
1st task finished
Task named 1st started with parameter 4
2nd task finished
Task named 2nd started with parameter 5
3rd task finished
Task named 3rd started with parameter 6
4th task finished
Task named 4th started with parameter 7
1st task finished
Task named 1st started with parameter 8
2nd task finished
Task named 2nd started with parameter 9
3rd task finished
Task named 3rd started with parameter 10
4th task finished
Task named 4th started with parameter 11
1st task finished
Task named 1st started with parameter 12
2nd task finished
Task named 2nd started with parameter 13
3rd task finished
Task named 3rd started with parameter 14
4th task finished
Task named 4th started with parameter 15
1st task finished
Task named 1st started with parameter 16
2nd task finished
Task named 2nd started with parameter 17
3rd task finished
Task named 3rd started with parameter 18
4th task finished
Task named 4th started with parameter 19
1st task finished
2nd task finished
3rd task finished
4th task finished
done
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<p></p>

<pre>
import curio
&nbsp;
&nbsp;
async def producer(id, queue, n):
    for i in range(n):
        message = f"message #{i} from producer {id}"
        await queue.put(message)
        await curio.sleep(0.3)
&nbsp;
&nbsp;
async def consumer(id, queue):
    print(f"consumer {id} started")
    while True:
        message = await queue.get()
        print(f"consumer {id} received {message}")
        await curio.sleep(0.4)
&nbsp;
&nbsp;
async def main():
    print("main started")
&nbsp;
    queue = curio.Queue()
    async with curio.TaskGroup() as g:
        await g.spawn(producer, 1, queue, 10)
        await g.spawn(producer, 2, queue, 10)
        await g.spawn(producer, 3, queue, 10)
        await g.spawn(consumer, 1, queue)
        await g.spawn(consumer, 2, queue)
        await g.spawn(consumer, 3, queue)
&nbsp;
    print("done")
&nbsp;
&nbsp;
curio.run(main(), with_monitor=True)
</pre>

<pre>
main started
consumer 1 started
consumer 1 received message #0 from producer 1
consumer 2 started
consumer 2 received message #0 from producer 2
consumer 3 started
consumer 3 received message #0 from producer 3
consumer 1 received message #1 from producer 1
consumer 2 received message #1 from producer 2
consumer 3 received message #1 from producer 3
consumer 1 received message #2 from producer 1
consumer 2 received message #2 from producer 2
consumer 3 received message #2 from producer 3
consumer 1 received message #3 from producer 1
consumer 2 received message #3 from producer 2
consumer 3 received message #3 from producer 3
consumer 1 received message #4 from producer 1
consumer 2 received message #4 from producer 2
consumer 3 received message #4 from producer 3
consumer 1 received message #5 from producer 1
consumer 2 received message #5 from producer 2
consumer 3 received message #5 from producer 3
consumer 1 received message #6 from producer 1
consumer 2 received message #6 from producer 2
consumer 3 received message #6 from producer 3
consumer 1 received message #7 from producer 1
consumer 2 received message #7 from producer 2
consumer 3 received message #7 from producer 3
consumer 1 received message #8 from producer 1
consumer 2 received message #8 from producer 2
consumer 3 received message #8 from producer 3
consumer 1 received message #9 from producer 1
consumer 2 received message #9 from producer 2
consumer 3 received message #9 from producer 3
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<p></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<p></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>

<pre>
import dis
&nbsp;
&nbsp;
def <strong>say_hello</strong>():
    print("Hello world")
&nbsp;
&nbsp;
def <strong>main</strong>():
    say_hello()
&nbsp;
&nbsp;
main()
&nbsp;
print("say_hello")
dis.dis(say_hello)
&nbsp;
print("main")
dis.dis(main)
</pre>

<pre>
Hello world
say_hello
  5           0 LOAD_GLOBAL              0 (print)
              2 LOAD_CONST               1 ('Hello world')
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               0 (None)
             10 RETURN_VALUE
main
  9           0 LOAD_GLOBAL              0 (say_hello)
              2 CALL_FUNCTION            0
              4 POP_TOP
              6 LOAD_CONST               0 (None)
              8 RETURN_VALUE
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<pre>
import dis
import asyncio
&nbsp;
&nbsp;
async def <strong>say_hello</strong>():
    print("Hello world")
&nbsp;
&nbsp;
async def <strong>main</strong>():
    t = asyncio.create_task(say_hello())
    await t
&nbsp;
&nbsp;
asyncio.run(main())
&nbsp;
print("say_hello")
dis.dis(say_hello)
&nbsp;
print("main")
dis.dis(main)
</pre>

<pre>
Hello world
say_hello
  6           0 LOAD_GLOBAL              0 (print)
              2 LOAD_CONST               1 ('Hello world')
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               0 (None)
             10 RETURN_VALUE
main
 10           0 LOAD_GLOBAL              0 (asyncio)
              2 LOAD_METHOD              1 (create_task)
              4 LOAD_GLOBAL              2 (say_hello)
              6 CALL_FUNCTION            0
              8 CALL_METHOD              1
             10 STORE_FAST               0 (t)

 11          12 LOAD_FAST                0 (t)
             14 GET_AWAITABLE
             16 LOAD_CONST               0 (None)
             18 YIELD_FROM
             20 POP_TOP
             22 LOAD_CONST               0 (None)
             24 RETURN_VALUE
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů
určených pro programovací jazyk Python 3 byly uloženy do Git repositáře
dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem
stále velmi malý, dnes má velikost zhruba několik desítek kilobajtů),
můžete namísto toho použít odkazy na jednotlivé příklady, které
naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>multithreading1.py</td><td>spuštění tří vláken vykonávajících déletrvající činnost</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading1.py</a></td></tr>
<tr><td> 2</td><td>multithreading2.py</td><td>spuštění tří vláken, předání parametrů volaným funkcím</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading2.py</a></td></tr>
<tr><td> 3</td><td>multithreading3.py</td><td>explicitní čekání na dokončení běhu vláken metodou <strong>join</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading3.py</a></td></tr>
<tr><td> 4</td><td>multithreading4.py</td><td>sdílený objekt</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading4.py</a></td></tr>
<tr><td> 5</td><td>multithreading_join_deamon.py</td><td>čekání na dokončení vláken s&nbsp;příznakem &bdquo;daemon&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_join_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_join_deamon.py</a></td></tr>
<tr><td> 6</td><td>multithreading_no_join_deamon.py</td><td>vlákna s&nbsp;příznakem &bdquo;daemon&ldquo;, na jejichž ukončení se nečeká</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_deamon.py</a></td></tr>
<tr><td> 7</td><td>multithreading_no_join_no_deamon.py</td><td>běžná vlákna bez příznaku &bdquo;daemon&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_no_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_no_deamon.py</a></td></tr>
<tr><td> 8</td><td>multithreading_timeout.py</td><td>specifikace maximální doby čekání na ukončení vlákna</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_timeout.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_timeout.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>multiprocessing1.py</td><td>zavolání funkce spuštěné v&nbsp;rámci dalšího procesu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing1.py</a></td></tr>
<tr><td>10</td><td>multiprocessing2.py</td><td>spuštění většího množství procesů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing2.py</a></td></tr>
<tr><td>11</td><td>multiprocessing3.py</td><td>nepatrná úprava předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing3.py</a></td></tr>
<tr><td>12</td><td>multiprocessing4.py</td><td>řízení workerů posílanými příkazy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing4.py</a></td></tr>
<tr><td>13</td><td>multiprocessing5.py</td><td>řízení workerů posílanými příkazy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing5.py</a></td></tr>
<tr><td>14</td><td>multiprocessing6.py</td><td>jeden proces a sdílená globální hodnota</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing6.py</a></td></tr>
<tr><td>15</td><td>multiprocessing7.py</td><td>více procesů, které nesdílí hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing7.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>queue_example.py</td><td>základní vlastnosti sdílené datové struktury <strong>Queue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queue_example.py</a></td></tr>
<tr><td>17</td><td>simple_queue_example.py</td><td>základní vlastnosti sdílené datové struktury <strong>SimpleQueue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/simple_queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/simple_queue_example.py</a></td></tr>
<tr><td>18</td><td>priority_queue_example.py</td><td>základní vlastnosti sdílené datové struktury <strong>PriorityQueue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/priority_queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/priority_queue_example.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>queues1.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: základní forma</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues1.py</a></td></tr>
<tr><td>20</td><td>queues2.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: více konzumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues2.py</a></td></tr>
<tr><td>21</td><td>queues3.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: více producentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues3.py</a></td></tr>
<tr><td>22</td><td>queues4.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: více producentů i konzumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>thread_pool_1.py</td><td>spuštění tří úloh ve třech vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_1.py</a></td></tr>
<tr><td>24</td><td>thread_pool_2.py</td><td>spuštění deseti úloh v&nbsp;deseti vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_2.py</a></td></tr>
<tr><td>25</td><td>thread_pool_3.py</td><td>omezení počtu vláken na 3 pro celkem deset úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_3.py</a></td></tr>
<tr><td>26</td><td>thread_pool_4.py</td><td>návratová hodnota získaná po spuštění úlohy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_4.py</a></td></tr>
<tr><td>27</td><td>thread_pool_5.py</td><td>získání vypočtených hodnot</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_5.py</a></td></tr>
<tr><td>28</td><td>thread_pool_6.py</td><td>alternativní způsob zápisu předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>process_pool_1.py</td><td>spuštění tří úloh ve vlastních procesech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_1.py</a></td></tr>
<tr><td>30</td><td>process_pool_2.py</td><td>návratové hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_2.py</a></td></tr>
<tr><td>31</td><td>process_pool_3.py</td><td>čekání na dokončení úloh + získání návratových hodnot</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>async_await_1.py</td><td>základní způsob použití <strong>async</strong> a <strong>await</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_1.py</a></td></tr>
<tr><td>33</td><td>async_await_2.py</td><td>funkce <strong>main</strong> volaná asynchronně</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_2.py</a></td></tr>
<tr><td>34</td><td>async_await_3.py</td><td>dvě asynchronně běžící úlohy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_3.py</a></td></tr>
<tr><td>35</td><td>async_await_4.py</td><td>získání výsledků z&nbsp;asynchronně běžících úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_4.py</a></td></tr>
<tr><td>36</td><td>async_queue_1.py</td><td>fronty pro kooperace mezi korutinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_1.py</a></td></tr>
<tr><td>37</td><td>async_queue_2.py</td><td>korektní spuštění většího množství korutin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_2.py</a></td></tr>
<tr><td>38</td><td>async_queue_3.py</td><td>využití <strong>asyncio.gather</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_3.py</a></td></tr>
<tr><td>39</td><td>async_aiohttp_1.py</td><td>použití knihovny <strong>aiohttp</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_1.py</a></td></tr>
<tr><td>40</td><td>async_aiohttp_2.py</td><td>záznam časů trvání jednotlivých operací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_2.py</a></td></tr>
<tr><td>41</td><td>async_aiohttp_3.py</td><td>vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_3.py</a></td></tr>
<tr><td>42</td><td>async_aiohttp_4.py</td><td>využití deseti korutin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>curio_01.py</td><td>základní konstrukce nabízené knihovnou <strong>curio</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_01.py</a></td></tr>
<tr><td>44</td><td>curio_02.py</td><td>předání parametrů asynchronně volané korutině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_02.py</a></td></tr>
<tr><td>45</td><td>curio_03.py</td><td>chování programu při spuštění několika korutin funkcí <strong>curio.run</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_03.py</a></td></tr>
<tr><td>46</td><td>curio_04.py</td><td>asynchronní spuštění korutin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_04.py</a></td></tr>
<tr><td>47</td><td>curio_05.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_05.py</a></td></tr>
<tr><td>48</td><td>curio_06.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_06.py</a></td></tr>
<tr><td>49</td><td>curio_07.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_07.py</a></td></tr>
<tr><td>50</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/</a></td></tr>
<tr><td>51</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/</a></td></tr>
<tr><td>52</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace Pythonu: balíček queue<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Dokumentace Pythonu: balíček threading<br />
<a href="https://docs.python.org/3/library/threading.html?">https://docs.python.org/3/library/threading.html?</a>
</li>

<li>Dokumentace Pythonu: balíček multiprocessing<br />
<a href="https://docs.python.org/3/library/multiprocessing.html">https://docs.python.org/3/library/multiprocessing.html</a>
</li>

<li>Dokumentace Pythonu: balíček asyncio<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Synchronization Primitives<br />
<a href="https://docs.python.org/3/library/asyncio-sync.html">https://docs.python.org/3/library/asyncio-sync.html</a>
</li>

<li>Coroutines<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Queues<br />
<a href="https://docs.python.org/3/library/asyncio-queue.html">https://docs.python.org/3/library/asyncio-queue.html</a>
</li>

<li>python-csp<br />
<a href="https://python-csp.readthedocs.io/en/latest/">https://python-csp.readthedocs.io/en/latest/</a>
</li>

<li>TrellisSTM<br />
<a href="http://peak.telecommunity.com/DevCenter/TrellisSTM">http://peak.telecommunity.com/DevCenter/TrellisSTM</a>
</li>

<li>Python Multithreading and Multiprocessing Tutorial<br />
<a href="https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python">https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python</a>
</li>

<li>ThreadPoolExecutor<br />
<a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor">https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor</a>
</li>

<li>ProcessPoolExecutor<br />
<a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor">https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor</a>
</li>

<li>asyncio — Asynchronous I/O<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Threads vs Async: Has Asyncio Solved Concurrency?<br />
<a href="https://www.youtube.com/watch?v=NZq31Sg8R9E">https://www.youtube.com/watch?v=NZq31Sg8R9E</a>
</li>

<li>Python Asynchronous Programming &ndash; AsyncIO &amp; Async/Await<br />
<a href="https://www.youtube.com/watch?v=t5Bo1Je9EmE">https://www.youtube.com/watch?v=t5Bo1Je9EmE</a>
</li>

<li>AsyncIO &amp; Asynchronous Programming in Python<br />
<a href="https://www.youtube.com/watch?v=6RbJYN7SoRs">https://www.youtube.com/watch?v=6RbJYN7SoRs</a>
</li>

<li>Coroutines and Tasks<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Python async/await Tutorial<br />
<a href="https://stackabuse.com/python-async-await-tutorial/">https://stackabuse.com/python-async-await-tutorial/</a>
</li>

<li>Demystifying Python's Async and Await Keywords<br />
<a href="https://www.youtube.com/watch?v=F19R_M4Nay4">https://www.youtube.com/watch?v=F19R_M4Nay4</a>
</li>

<li>Curio<br />
<a href="https://curio.readthedocs.io/en/latest/">https://curio.readthedocs.io/en/latest/</a>
</li>

<li>Trio: a friendly Python library for async concurrency and I/O<br />
<a href="https://trio.readthedocs.io/en/stable/">https://trio.readthedocs.io/en/stable/</a>
</li>

<li>Curio &ndash; A Tutorial Introduction<br />
<a href="https://curio.readthedocs.io/en/latest/tutorial.html">https://curio.readthedocs.io/en/latest/tutorial.html</a>
</li>

<li>unsync<br />
<a href="https://github.com/alex-sherman/unsync">https://github.com/alex-sherman/unsync</a>
</li>

<li>David Beazley - Die Threads<br />
<a href="https://www.youtube.com/watch?v=xOyJiN3yGfU">https://www.youtube.com/watch?v=xOyJiN3yGfU</a>
</li>

<li>Miguel Grinberg Asynchronous Python for the Complete Beginner PyCon 2017<br />
<a href="https://www.youtube.com/watch?v=iG6fr81xHKA">https://www.youtube.com/watch?v=iG6fr81xHKA</a>
</li>

<li>Build Your Own Async<br />
<a href="https://www.youtube.com/watch?v=Y4Gt3Xjd7G8">https://www.youtube.com/watch?v=Y4Gt3Xjd7G8</a>
</li>

<li>The Other Async (Threads + Async = ❤️)<br />
<a href="https://www.youtube.com/watch?v=x1ndXuw7S0s">https://www.youtube.com/watch?v=x1ndXuw7S0s</a>
</li>

<li>Fear and Awaiting in Async: A Savage Journey to the Heart of the Coroutine Dream<br />
<a href="https://www.youtube.com/watch?v=E-1Y4kSsAFc">https://www.youtube.com/watch?v=E-1Y4kSsAFc</a>
</li>

<li>Keynote David Beazley - Topics of Interest (Python Asyncio)<br />
<a href="https://www.youtube.com/watch?v=ZzfHjytDceU">https://www.youtube.com/watch?v=ZzfHjytDceU</a>
</li>

<li>David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015<br />
<a href="https://www.youtube.com/watch?v=MCs5OvhV9S4">https://www.youtube.com/watch?v=MCs5OvhV9S4</a>
</li>

<li>Python Async basics video (100 million HTTP requests)<br />
<a href="https://www.youtube.com/watch?v=Mj-Pyg4gsPs">https://www.youtube.com/watch?v=Mj-Pyg4gsPs</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

