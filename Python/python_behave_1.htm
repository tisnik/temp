<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Behavior-driven development v Pythonu s využitím knihovny Behave</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Behavior-driven development v Pythonu s využitím knihovny Behave</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>S jazykem Gherkin navrženým takovým způsobem, aby se v něm mohly čitelným a přirozeným způsobem psát testovací scénáře, jsme se již setkali v souvislosti s jazykem Clojure. Ovšem díky existenci knihovny Behave je možné Gherkin použít i v populárním Pythonu.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Behavior-driven development v&nbsp;Pythonu s&nbsp;využitím knihovny Behave</a></p>
<p><a href="#k02">2. Projekt s&nbsp;jedním modulem, který bude testován s&nbsp;využitím knihovny Behave</a></p>
<p><a href="#k03">3. Zdrojový kód testovaného modulu, skript s&nbsp;testovacím scénářem</a></p>
<p><a href="#k04">4. Pomocné soubory v&nbsp;adresáři s&nbsp;projektem</a></p>
<p><a href="#k05">*** 5. Soubor <strong>common.py</strong> s&nbsp;definicí testovacích kroků</a></p>
<p><a href="#k06">6. Spuštění skriptu s&nbsp;testem, výsledek testů</a></p>
<p><a href="#k07">*** 7. Vylepšení implementace kroků testů i vlastního testovacího scénáře</a></p>
<p><a href="#k08">8. Spuštění druhé varianty skriptu s&nbsp;testy, výsledek testů</a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. Projekt, v&nbsp;němž budeme testovat vlastnosti nativní funkce</a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">13. Spuštění skriptu s&nbsp;testy nativní funkce, výsledek testů</a></p>
<p><a href="#k14">14. Spuštění skriptu ve chvíli, kdy není nativní funkce nalezena</a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Behavior-driven development v&nbsp;Pythonu s&nbsp;využitím knihovny Behave</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Projekt s&nbsp;jedním modulem, který bude testován s&nbsp;využitím knihovny Behave</h2>

<p>Jazyk Gherkin je navržen takovým způsobem, aby ho uživatelé (nemusí se totiž
nutně jednat pouze o programátory) mohli začít používat prakticky okamžitě,
tj.&nbsp;bez nutnosti studia sáhodlouhých manuálů. I z&nbsp;toho důvodu si
možnosti tohoto doménově specifického jazyka postupně ukážeme na několika
demonstračních příkladech. První příklad bude (prozatím) velmi jednoduchý,
protože bude obsahovat jediný modul, který budeme chtít otestovat. I přesto se
však bude jednat o plnohodnotný projekt, jehož struktura odpovídá struktuře
projektů složitějších a sofistikovanějších. Adresář s&nbsp;projektem i
s&nbsp;testovacím scénářem by měl vypadat následovně:</p>

<pre>
├── feature_list.txt
├── features
│   ├── adder.feature
│   └── steps
│       └── common.py
├── requirements.in
├── requirements.txt
├── run_tests.sh
└── src
    └── adder.py
&nbsp;
3 directories, 7 files
</pre>

<p>Můžeme zde vidět několik typů souborů:</p>

<table>
<tr><th>Soubor</th><th>Popis</th></tr>
<tr><td>src/adder.py</td><td>vlastní modul, který budeme chtít otestovat</td></tr>
<tr><td>requirements.in/requirements.txt</td><td>soubory pro <strong>pip</strong> (instalátor balíčků)</td></tr>
<tr><td>feature_list.txt</td><td>seznam testovacích scénářů, které se mají spustit</td></tr>
<tr><td>features/*</td><td>adresář obsahující testovací scénáře i implementaci jednotlivých kroků testů</td></tr>
<tr><td>run_tests.sh</td><td>pomocný skript pro spuštění testovacích scénářů</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zdrojový kód testovaného modulu, skript s&nbsp;testovacím scénářem</h2>

<p>Modul <strong>adder.py</strong>, který vlastně tvoří celou testovanou
aplikaci, je velmi stručný, protože obsahuje jedinou funkci nazvanou
<strong>add</strong>, jež &ndash; jak ostatně její název naznačuje &ndash;
slouží k&nbsp;součtu dvou numerických hodnot popř.&nbsp;i pro aplikaci
operátoru + na všechny typy operandů, které tento operátor podporují (řetězce,
seznamy, n-tice, instance uživatelem deklarovaných tříd atd. atd.). Zdrojový
kód tohoto modulu tedy sestává z&nbsp;pouhých dvou řádků:</p>

<pre>
def add(x, y):
    return x + y
</pre>

<p>Druhým důležitým souborem je vlastní testovací scénář
<strong>adder.feature</strong>, který je uložen v&nbsp;podadresáři
<strong>features</strong>. Tento testovací scénář je naprogramován
v&nbsp;jazyku <i>Gherkin</i>, konkrétně v&nbsp;jeho výchozí anglické
&bdquo;mutaci&ldquo; (použitím jiných jazykových mutací se budeme zabývat
příště). V&nbsp;následujícím výpisu jsou klíčová slova rozeznávaná interpretrem
označena tučně:</p>

<pre>
<strong>Feature</strong>: Adder test
&nbsp;
  <strong>Scenario</strong>: Check the function add()
    <strong>Given</strong> The function add is callable
    <strong>When</strong> I call function add with arguments 1 and 2
    <strong>Then</strong> I should get 3 as a result
</pre>

<p><div class="rs-tip-major">Povšimněte si, že Gherkin je z&nbsp;hlediska
sémantiky velmi jednoduchý jazyk. Obsahuje deklarace jednotlivých testovacích
scénářů, počáteční podmínku a potom sérii kroků ve stylu &bdquo;když udělám X,
stane se (očekávám) Y&ldquo;. Syntax je také jednoduchá (alespoň prozatím),
protože první slovo je klíčové a jednotlivé bloky (zde scénáře) jsou odsazeny,
podobně jako v&nbsp;samotném Pythonu či ve formátu YAML.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pomocné soubory v&nbsp;adresáři s&nbsp;projektem</h2>

<p>Další pomocné soubory, které v&nbsp;projektu nalezneme, mají následující
obsah.</p>

<p>Prvním důležitým souborem je soubor pojmenovaný
<strong>feature_list.txt</strong>. V&nbsp;tomto souboru je uložen seznam
testovacích scénářů, které se mají spustit. Prozatím máme vytvořen jen jediný
testovací scénář (popsaný <a href="#k03">v&nbsp;předchozí kapitole</a>), takže
tento soubor bude obsahovat jediný řádek s&nbsp;relativním jménem souboru se
scénářem:</p>

<pre>
features/adder.feature
</pre>

<p><div class="rs-tip-major">Pokud bude soubor obsahovat více scénářů, můžete
použít znak # pro jejich cílené zakomentování, což se může v&nbsp;některých
případech hodit.</div></p>

<p>Další dva soubory <strong>requirements.in</strong> a
<strong>requirements.txt</strong> obsahují seznam modulů (knihoven), které
budeme v&nbsp;systému potřebovat proto, aby bylo možné testovací scénáře
spustit. Prozatím je obsah i těchto souborů dosti minimalistický, protože
budeme potřebovat dvě knihovny (kromě standardních knihoven Pythonu):</p>

<pre>
behave
pytest
</pre>

<p>A konečně následuje soubor pojmenovaný <strong>run_tests.sh</strong>. Ten
slouží ke spuštění testovacích scénářů. Povšimněte si, že na základě obsahu
proměnné <strong>NOVENV</strong> využíváme virtuální prostředí Pythonu, což
mj.&nbsp;znamená, že instalace potřebných knihoven (<strong>pytest</strong> a
<strong>behave</strong>) bude provedena pouze lokálně, bez zásahu do
systémových oblastí souborového systému. Pokud máte všechny moduly
v&nbsp;systému již nainstalované, není nutné virtuální prostředí použít a
proměnná <strong>NOVENV</strong> může zůstat nastavena na hodnotě 1. Skript je
připraven pro Python 3.x, ovšem můžete si ho velmi snadno upravit i pro použití
v&nbsp;Pythonu 2.x:</p>

<pre>
#!/bin/bash -ex
&nbsp;
export NOVENV=1
function prepare_venv() {
    virtualenv -p python3 venv &amp;&amp; source venv/bin/activate &amp;&amp; python3 `which pip3` install -r requirements.txt
}
&nbsp;
[ "$NOVENV" == "1" ] || prepare_venv || exit 1
&nbsp;
PYTHONDONTWRITEBYTECODE=1 python3 `which behave` --tags=-skip -D dump_errors=true @feature_list.txt $@
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Soubor <strong>common.py</strong> s&nbsp;definicí testovacích kroků</h2>

<p>Velmi důležitým souborem, na němž jsou celé testy postaveny, je soubor
<strong>common.py</strong>, který je umístěný v&nbsp;podadresáři
<strong>features/steps/</strong>. V&nbsp;tomto souboru jsou implementovány
jednotlivé kroky testu, tj.&nbsp;implementace řádků začínajících na
<strong>Given</strong>, <strong>When</strong> a <strong>Then</strong>.</p>

<p><div class="rs-tip-major">Ve skutečnosti se tento soubor nemusí jmenovat
<strong>common.py</strong>. Můžeme použít i jiné jméno, například
<strong>steps.py</strong> či <strong>foobar.py</strong>. Dokonce můžete kroky
rozdělit do většího množství souborů, například <strong>foo.py</strong> a
<strong>bar.py</strong>; vše podle vlastního uvážení a potřeb projektu. Jen je
zapotřebí zachovat podadresář, v&nbsp;němž jsou tyto soubory
umístěny.</div></p>

<p>Nejprve se podívejme, jak soubor vypadá, následně si jednotlivé řádky
popíšeme:</p>

<pre>
from behave import given, then, when
from src.adder import add
&nbsp;
&nbsp;
@<strong>given</strong>('The function {function_name} is callable')
def initial_state(context, function_name):
    pass
&nbsp;
&nbsp;
@<strong>when</strong>('I call function {function} with arguments {x:d} and {y:d}')
def call_add(context, function, x, y):
    context.result = add(x, y)
&nbsp;
&nbsp;
@<strong>then</strong>('I should get {expected:d} as a result')
def check_integer_result(context, expected):
    assert context.result == expected, \
        "Wrong result: {r} != {e}".format(r=context.result, e=expected)
</pre>

<p></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Spuštění skriptu s&nbsp;testem, výsledek testů</h2>

<p>Pokud spustíme soubor <strong>run_tests.sh</strong>, měly by se na
standardním výstupu objevit následující řádky (zde se předpokládá, že je
zakázáno použití virtuálního prostředí Pythonu):</p>

<pre>
$ <strong>./run_tests.sh</strong>
&nbsp;
+ export NOVENV=1
+ NOVENV=1
+ '[' 1 == 1 ']'
++ which behave
+ PYTHONDONTWRITEBYTECODE=1
+ LD_LIBRARY_PATH=lib
+ python3 /usr/local/bin/behave --tags=-skip -D dump_errors=true @feature_list.txt
Feature: Adder test # features/adder.feature:1
&nbsp;
  Scenario: Check the function add()                # features/adder.feature:4
    Given The function add is callable              # features/steps/common.py:5 0.000s
    When I call function add with arguments 1 and 2 # features/steps/common.py:10 0.000s
    Then I should get 3 as a result                 # features/steps/common.py:15 0.000s
&nbsp;
1 feature passed, 0 failed, 0 skipped
1 scenario passed, 0 failed, 0 skipped
3 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m0.000s
</pre>

<p>Zprávy jsou implicitně obarveny, takže ve skutečnosti bude výsledek vypadat
spíše takto:</p>

*** image ***
<p><i>Obrázek 1: Terminál s&nbsp;výstupem vytvořeným testovacím scénářem.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vylepšení implementace kroků testů i vlastního testovacího scénáře</h2>

<pre>
from behave import given, then, when
from src.adder import add
&nbsp;
&nbsp;
@<strong>given</strong>('The function {function_name} is callable')
def initial_state(context, function_name):
    g = globals()
    assert function_name in g, "Function is not visible"
    assert callable(g[function_name]), "Not a function"
&nbsp;
&nbsp;
@<strong>when</strong>('I call function {function} with arguments {x:d} and {y:d}')
def call_add(context, function, x, y):
    context.result = add(x, y)
&nbsp;
&nbsp;
@<strong>then</strong>('I should get {expected:d} as a result')
def check_integer_result(context, expected):
    assert context.result == expected, \
        "Wrong result: {r} != {e}".format(r=context.result, e=expected)
</pre>

<p></p>

<pre>
<strong>Feature</strong>: Adder test
&nbsp;
  <strong>Scenario</strong>: Check the function add()
    <strong>Given</strong> The function add is callable
    <strong>When</strong> I call function add with arguments 1 and 2
    <strong>Then</strong> I should get 3 as a result
&nbsp;
  <strong>Scenario Outline</strong>: Thorough checking function add()
    <strong>Given</strong> The function add is callable
    <strong>When</strong> I call function add with arguments &lt;x&gt; and &lt;y&gt;
    <strong>Then</strong> I should get &lt;result&gt; as a result
&nbsp;
     <strong>Examples</strong>: users
     |x|y|result|
     # basic arithmetic
     |          0| 0|          0|
     |          1| 2|          3|
     |          1|-2|         -1|
     # no overflows at 16 bit limits
     |      32767| 1|      32768|
     |      65535| 1|      65536|
     # integer overflow in Python?
     | 2147483648| 1| 2147483649|
     |-2147483647|-1|-2147483648|
     |-2147483648|-1|-2147483649|
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spuštění druhé varianty skriptu s&nbsp;testy, výsledek testů</h2>

<p>Pokud nyní spustíme testovací scénář již známým skriptem
<strong>run_tests.sh</strong>, měl by výsledek vypadat přibližně
následovně:</p>

<pre>
Feature: Adder test # features/adder.feature:1
&nbsp;
  Scenario: Check the function add()                # features/adder.feature:4
    Given The function add is callable              # features/steps/common.py:5
    When I call function add with arguments 1 and 2 # features/steps/common.py:12
    Then I should get 3 as a result                 # features/steps/common.py:17
&nbsp;
  Scenario Outline: Thorough checking function add() -- @1.1 users  # features/adder.feature:17
    Given The function add is callable                              # features/steps/common.py:5
    When I call function add with arguments 0 and 0                 # features/steps/common.py:12
    Then I should get 0 as a result                                 # features/steps/common.py:17
&nbsp;
  Scenario Outline: Thorough checking function add() -- @1.2 users  # features/adder.feature:18
    Given The function add is callable                              # features/steps/common.py:5
    When I call function add with arguments 1 and 2                 # features/steps/common.py:12
    Then I should get 3 as a result                                 # features/steps/common.py:17
&nbsp;
  Scenario Outline: Thorough checking function add() -- @1.3 users  # features/adder.feature:19
    Given The function add is callable                              # features/steps/common.py:5
    When I call function add with arguments 1 and -2                # features/steps/common.py:12
    Then I should get -1 as a result                                # features/steps/common.py:17
&nbsp;
  Scenario Outline: Thorough checking function add() -- @1.4 users  # features/adder.feature:21
    Given The function add is callable                              # features/steps/common.py:5
    When I call function add with arguments 32767 and 1             # features/steps/common.py:12
    Then I should get 32768 as a result                             # features/steps/common.py:17
&nbsp;
  Scenario Outline: Thorough checking function add() -- @1.5 users  # features/adder.feature:22
    Given The function add is callable                              # features/steps/common.py:5
    When I call function add with arguments 65535 and 1             # features/steps/common.py:12
    Then I should get 65536 as a result                             # features/steps/common.py:17
&nbsp;
  Scenario Outline: Thorough checking function add() -- @1.6 users  # features/adder.feature:24
    Given The function add is callable                              # features/steps/common.py:5
    When I call function add with arguments 2147483648 and 1        # features/steps/common.py:12
    Then I should get 2147483649 as a result                        # features/steps/common.py:17
&nbsp;
  Scenario Outline: Thorough checking function add() -- @1.7 users  # features/adder.feature:25
    Given The function add is callable                              # features/steps/common.py:5
    When I call function add with arguments -2147483647 and -1      # features/steps/common.py:12
    Then I should get -2147483648 as a result                       # features/steps/common.py:17
&nbsp;
  Scenario Outline: Thorough checking function add() -- @1.8 users  # features/adder.feature:26
    Given The function add is callable                              # features/steps/common.py:5
    When I call function add with arguments -2147483648 and -1      # features/steps/common.py:12
    Then I should get -2147483649 as a result                       # features/steps/common.py:17
&nbsp;
1 feature passed, 0 failed, 0 skipped
9 scenarios passed, 0 failed, 0 skipped
27 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m0.002s
</pre>

*** image ***
<p><i>Obrázek 2: Terminál s&nbsp;výstupem vytvořeným druhou variantou
testovacího scénáře.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
int add(int x, int y)
{
    return x+y;
}
</pre>

<pre>
gcc -Wall -ansi -c -fPIC adder.c -o adder.o
&nbsp;
gcc -shared -Wl,-soname,libadder.so -o libadder.so adder.o
</pre>

<pre>
import ctypes
&nbsp;
libname = "libadder.so"
&nbsp;
adder = ctypes.CDLL(libname)
&nbsp;
for x in range(0, 6):
    for y in range(0, 6):
        result = adder.add(x,y)
        print("{x} + {y} = {z}".format(x=x, y=y, z=result))
</pre>

<pre>
0 + 0 = 0
0 + 1 = 1
0 + 2 = 2
0 + 3 = 3
0 + 4 = 4
0 + 5 = 5
1 + 0 = 1
1 + 1 = 2
1 + 2 = 3
1 + 3 = 4
1 + 4 = 5
1 + 5 = 6
2 + 0 = 2
2 + 1 = 3
2 + 2 = 4
2 + 3 = 5
2 + 4 = 6
2 + 5 = 7
3 + 0 = 3
3 + 1 = 4
3 + 2 = 5
3 + 3 = 6
3 + 4 = 7
3 + 5 = 8
4 + 0 = 4
4 + 1 = 5
4 + 2 = 6
4 + 3 = 7
4 + 4 = 8
4 + 5 = 9
5 + 0 = 5
5 + 1 = 6
5 + 2 = 7
5 + 3 = 8
5 + 4 = 9
5 + 5 = 10
</pre>

<pre>
Traceback (most recent call last):
  File "call_adder.py", line 5, in <module>
    adder = ctypes.CDLL(libname)
  File "/usr/lib/python3.4/ctypes/__init__.py", line 351, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: libadder.so: cannot open shared object file: No such file or directory
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
.
├── feature_list.txt
├── features
│   ├── environment.py
│   ├── smoketest.feature
│   └── steps
│       └── common.py
├── lib
│   ├── adder.c
│   ├── clean.sh
│   └── make_library.sh
├── requirements.in
├── requirements.txt
└── run_tests.sh

3 directories, 10 files
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
Feature: Smoke test

  @smoketest
  Scenario: Check the function int add(int, int)
    Given The library libadder.so is loaded
    When I call native function add with arguments 1 and 2
    Then I should get 3 as a result

  Scenario Outline: Thorough checking function int add(int, int)
    Given The library libadder.so is loaded
    When I call native function add with arguments <x> and <y>
    Then I should get <result> as a result

     Examples: users
     |x|y|result|
     # basic arithmetic
     |          0| 0|          0|
     |          1| 2|          3|
     |          1|-2|         -1|
     # no overflows at 16 bit limits
     |      32767| 1|      32768|
     |      65535| 1|      65536|
     # integer overflow
     | 2147483648| 1|-2147483647|
     |-2147483647|-1|-2147483648|
     |-2147483648|-1| 2147483647|
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
from behave.log_capture import capture
import ctypes


def _load_library(context, library_name):
    if context.tested_library is None:
        context.tested_library = ctypes.CDLL(library_name)


def before_all(context):
    """Perform setup before the first event."""
    context.tested_library = None
    context.load_library = _load_library
</pre>

<pre>
from behave import given, then, when


@given('The library {library_name} is loaded')
def initial_state(context, library_name):
    context.load_library(context, library_name)


@when('I call native function add with arguments {x:d} and {y:d}')
def call_add(context, x, y):
    context.result = context.tested_library.add(x, y)


@then('I should get {result:d} as a result')
def check_integer_result(context, result):
    assert context.result == result, "Expected result: {e}, returned value: {r}".format(e=result, r=context.result)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Spuštění skriptu s&nbsp;testy nativní funkce, výsledek testů</h2>

<p>Pokud byla nativní funkce korektně přeložena, měly by se po spuštění skriptu
<strong>run_tests.sh</strong> na standardním výstupu objevit následující řádky
produkované knihovnou Behave:</p>

<pre>
</pre>

*** image ***
<p><i>Obrázek 3: Výsledek běhu testovacích scénářů ve chvíli, kdy se nativní
funkce chová podle očekávání.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Spuštění skriptu ve chvíli, kdy není nativní funkce nalezena</h2>

<p>V&nbsp;případě, že jsme vynechali krok překladu nativní funkce popř.&nbsp;se
nepodařilo nativní knihovnu vůbec načíst, bude výsledek testů mnohem delší a
pesimističtější:</p>

<pre>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
Feature: Smoke test

  @smoketest
  Scenario: Check the function int add(int, int)
    Given The library libadder.so is loaded
    When I call native function add with integer arguments 1 and 2
    Then I should get 3 as a result

  Scenario Outline: Thorough checking function int add(int, int)
    Given The library libadder.so is loaded
    When I call native function add with integer arguments <x> and <y>
    Then I should get <result> as a result

     Examples: users
     |x|y|result|
     # basic arithmetic
     |          0| 0|          0|
     |          1| 2|          3|
     |          1|-2|         -1|
     # no overflows at 16 bit limits
     |      32767| 1|      32768|
     |      65535| 1|      65536|
     # integer overflow
     | 2147483648| 1|-2147483647|
     |-2147483647|-1|-2147483648|
     |-2147483648|-1| 2147483647|
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<pre>
from behave import given, then, when


@given('The library {library_name} is loaded')
def initial_state(context, library_name):
    context.load_library(context, library_name)


@when('I call native function {function} with integer arguments {x:d} and {y:d}')
def call_add(context, function, x, y):
    context.result = getattr(context.tested_library, function)(x, y)


@then('I should get {result:d} as a result')
def check_integer_result(context, result):
    assert context.result == result
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny čtyři demonstrační projekty které jsme si dnes popsali, byly
společně s&nbsp;projektem obsahujícím pouze nativní funkci volanou
z&nbsp;Pythonu, uloženy do repositáře, který naleznete na adrese <a
href="https://github.com/tisnik/python-behave-demos">https://github.com/tisnik/python-behave-demos</a>.
V&nbsp;první tabulce jsou zobrazeny odkazy na tyto projekty:</p>

<table>
<tr><th>Projekt</th><th>Cesta</th></tr>
<tr><td>test_python_function1</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/test_python_function1">https://github.com/tisnik/python-behave-demos/tree/master/test_python_function1</a></td></tr>
<tr><td>test_python_function2</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/test_python_function2">https://github.com/tisnik/python-behave-demos/tree/master/test_python_function2</a></td></tr>
<tr><td>native_lib</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/native_lib">https://github.com/tisnik/python-behave-demos/tree/master/native_lib</a></td></tr>
<tr><td>test_native_lib</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/test_native_lib">https://github.com/tisnik/python-behave-demos/tree/master/test_native_lib</a></td></tr>
<tr><td>test_native_lib2</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/test_native_lib2">https://github.com/tisnik/python-behave-demos/tree/master/test_native_lib2</a></td></tr>
</table>

<p>Ve druhé tabulce jsou zobrazeny odkazy na demonstrační příklady, které budou
použity ve druhé části tohoto článku:</p>

<table>
<tr><td>github_test_version1</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/github_test_version1">https://github.com/tisnik/python-behave-demos/tree/master/github_test_version1</a></td></tr>
<tr><td>github_test_version2</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/github_test_version2">https://github.com/tisnik/python-behave-demos/tree/master/github_test_version2</a></td></tr>
<tr><td>github_test_version3</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/github_test_version3">https://github.com/tisnik/python-behave-demos/tree/master/github_test_version3</a></td></tr>
<tr><td>github_test_version4</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/github_test_version4">https://github.com/tisnik/python-behave-demos/tree/master/github_test_version4</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Behave na GitHubu<br />
<a href="https://github.com/behave/behave">https://github.com/behave/behave</a>
</li>

<li>behave 1.2.6 (PyPi)<br />
<a href="https://pypi.python.org/pypi/behave">https://pypi.python.org/pypi/behave</a>
</li>

<li>Dokumentace k Behave<br />
<a href="http://behave.readthedocs.io/en/latest/">http://behave.readthedocs.io/en/latest/</a>
</li>

<li>Příklady použití Behave<br />
<a href="https://github.com/behave/behave.example">https://github.com/behave/behave.example</a>
</li>

<li>Příklady použití Behave použité v&nbsp;dnešním článku<br />
<a href="https://github.com/tisnik/python-behave-demos">https://github.com/tisnik/python-behave-demos</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Behavior-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Behavior-driven_development">https://en.wikipedia.org/wiki/Behavior-driven_development</a>
</li>

<li>Cucumber<br />
<a href="https://cucumber.io/">https://cucumber.io/</a>
</li>

<li>Jasmine<br />
<a href="https://jasmine.github.io/">https://jasmine.github.io/</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>pdb — The Python Debugger<br />
<a href="https://docs.python.org/3.6/library/pdb.html">https://docs.python.org/3.6/library/pdb.html</a>
</li>

<li>pdb – Interactive Debugger<br />
<a href="https://pymotw.com/2/pdb/">https://pymotw.com/2/pdb/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

