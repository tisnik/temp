<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Hacky pro Python: vlastní infixové operátory</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Hacky pro Python: vlastní infixové operátory</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Příručky jazyka Python (zcela správně) doporučují, aby byly zdrojové kódy psány idiomatickým způsobem. To však neznamená, že není možné syntaxi Pythonu "ohnout" a realizovat různé triky. Jedním z těchto triků je i tvorba vlastních operátorů, nikoli pouze přetížení operátorů existujících.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Hacky pro Python: vlastní infixové operátory</a></p>
<p><a href="#k02">2. Přetěžování operátorů v&nbsp;Pythonu</a></p>
<p><a href="#k03">3. Speciální metody použité při přetěžování operátorů</a></p>
<p><a href="#k04">4. Ukázka realizace datového typu &bdquo;komplexní číslo&ldquo;</a></p>
<p><a href="#k05">*** 5. Realizace vlastního infixového operátoru přetížením dvojice standardních operátorů</a></p>
<p><a href="#k06">6. První demonstrační příklad: třída <strong>HackyMul</strong> umožňující realizaci vlastního operátoru součinu</a></p>
<p><a href="#k07">7. Odstranění ladicích informací, výpočet tabulky malé násobilky s&nbsp;využitím nového operátoru součinu</a></p>
<p><a href="#k08">8. Praktičtější příklad: realizace operátoru pro skalární součin</a></p>
<p><a href="#k09">*** 9. Realizace nového operátoru s&nbsp;využitím znaku |</a></p>
<p><a href="#k10">10. Demonstrační příklad: operátor skalární součinu zapisovaný znaky |o|</a></p>
<p><a href="#k11">*** 11. Problematika přetížení operátorů &lt; a &gt;</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Hacky pro Python: vlastní infixové operátory</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Přetěžování operátorů v&nbsp;Pythonu</h2>

<p>Nejprve se ve stručnosti seznámíme s&nbsp;problematikou přetěžování
standardních operátorů v&nbsp;Pythonu, což je technika, která nám umožní měnit
chování operátorů, ovšem již neumožňuje nový operátor přidat. Tento
programovací jazyk nabízí (pro různé datové typy) celou řadu operátorů, které
jsou podle své priority rozděleny do osmnácti kategorií &ndash; od nejvyšší
priority směrem k&nbsp;prioritě nejnižší:</p>

<table>
<tr><th>Pořadí</th><th>Operátory</th></tr>
<tr><td> 1.</td><td>(výrazy...), [výrazy...], {klíč: hodnota...}, {výrazy...}</td></tr>
<tr><td> 2.</td><td>x[index], x[index:index], x(argumenty...), x.atribut</td></tr>
<tr><td> 3.</td><td>await x</td></tr>
<tr><td> 4.</td><td>**</td></tr>
<tr><td> 5.</td><td>+x, -x, ~x (unární)</td></tr>
<tr><td> 6.</td><td>*, @, /, //, %</td></tr>
<tr><td> 7.</td><td>+, -</td></tr>
<tr><td> 8.</td><td>&lt;&lt;, &gt;&gt;</td></tr>
<tr><td> 9.</td><td>&amp;</td></tr>
<tr><td>10.</td><td>^</td></tr>
<tr><td>11.</td><td>|</td><td>`</td></tr>
<tr><td>12.</td><td>in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==</td></tr>
<tr><td>13.</td><td>not x</td></tr>
<tr><td>14.</td><td>and</td></tr>
<tr><td>15.</td><td>or</td></tr>
<tr><td>16.</td><td>if - else</td></tr>
<tr><td>17.</td><td>lambda</td></tr>
<tr><td>18.</td><td>:=</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Speciální metody použité při přetěžování operátorů</h2>

<p>Většinu operátorů zmíněných <a href="#k02">v&nbsp;předchozí kapitole</a> je
možné <i>přetížit</i>, tj.&nbsp;definovat jejich chování (jaký výpočet se
provede) pro různé datové typy. Například je možné si nadefinovat datový typ
představující vektory a definovat pro ně základní operátory (součet prvek po
prvku atd.), totéž udělat pro matice, komplexní čísla atd. Vlastní
předefinování chování operátoru je relativně snadné &ndash; pouze postačuje
vytvořit speciální metodu, která bude zavolána v&nbsp;případě, že je operátor
použit v&nbsp;programovém kódu. Tyto speciální metody mají v&nbsp;některých
případech dvojí variantu &ndash; podle toho, na které straně operátoru se
nachází operand příslušného typu (a toho později využijeme):</p>

<table>
<tr><th>Přetížený operátor</th><th>Název speciální metody</th><th>Varianta s&nbsp;druhým operandem</th></tr>
<tr><td>+ </td><td>__add__</td><td>__radd__</td></tr>
<tr><td>- </td><td>__sub__</td><td>__rsub__</td></tr>
<tr><td>* </td><td>__mul__</td><td>__rmul__</td></tr>
<tr><td>/ </td><td>__truediv__</td><td>__rtruediv__</td></tr>
<tr><td>//</td><td>__floordiv__</td><td>__rfloordiv__</td></tr>
<tr><td>% </td><td>__mod__</td><td>__rmod__</td></tr>
<tr><td>**</td><td>__pow__</td><td>__rpow__</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>+= </td><td>__iadd__</td><td>&nbsp;</td></tr>
<tr><td>-= </td><td>__isub__</td><td>&nbsp;</td></tr>
<tr><td>*= </td><td>__imul__</td><td>&nbsp;</td></tr>
<tr><td>/= </td><td>__itruediv__</td><td>&nbsp;</td></tr>
<tr><td>//=</td><td>__ifloordiv__</td><td>&nbsp;</td></tr>
<tr><td>%= </td><td>__imod__</td><td>&nbsp;</td></tr>
<tr><td>**=</td><td>__ipow__</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>- (unární)</td><td>__neg__</td><td>&nbsp;</td></tr>
<tr><td>+ (unární)</td><td>__pos__</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&lt;  </td><td>__lt__</td><td>&nbsp;</td></tr>
<tr><td>&lt;= </td><td>__le__</td><td>&nbsp;</td></tr>
<tr><td>==    </td><td>__eq__</td><td>&nbsp;</td></tr>
<tr><td>!=    </td><td>__ne__</td><td>&nbsp;</td></tr>
<tr><td>&gt;= </td><td>__ge__</td><td>&nbsp;</td></tr>
<tr><td>&gt;  </td><td>__gt__</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&amp;   </td><td>__and__   </td><td>__rand__</td></tr>
<tr><td>|       </td><td>__or__    </td><td>__ror__</td></tr>
<tr><td>^       </td><td>__xor__   </td><td>__rxor__</td></tr>
<tr><td>&lt;&lt;</td><td>__lshift__</td><td>__rlshift__</td></tr>
<tr><td>&gt;&gt;</td><td>__rshift__</td><td>__rrshift__</td></tr>
<tr><td>~       </td><td>__invert__</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&amp;=   </td><td>__iand__   </td><td>&nbsp;</td></tr>
<tr><td>|=       </td><td>__ior__    </td><td>&nbsp;</td></tr>
<tr><td>^=       </td><td>__ixor__   </td><td>&nbsp;</td></tr>
<tr><td>&lt;&lt;=</td><td>__ilshift__</td><td>&nbsp;</td></tr>
<tr><td>&gt;&gt;=</td><td>__irshift__</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>in</td><td>__contains__</td><td></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: některé další operátory, například
indexování, nejsou v&nbsp;tabulce uvedeny, i když by mohly být zařazeny mezi
operátory binární.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ukázka realizace datového typu &bdquo;komplexní číslo&ldquo;</h2>

<p>Způsob přetížení některých vybraných unárních i binárních operátorů si
ukážeme na příkladu komplexních čísel, přesněji řečeno na třídě
<strong>Complex</strong>. V&nbsp;rámci definice této třídy jsou přetíženy
operátory =, - (unární), +, - a +=. Implementace by měla být ze zdrojového kódu
snadno pochopitelná:</p>

<pre>
class <strong>Complex</strong>:
&nbsp;
    def <strong>__init__</strong>(self, real=0, imag=0):
        self._real = real
        self._imag = imag
&nbsp;
    def <strong>__str__</strong>(self):
        return "{r} + {i}j".format(r=self._real, i=self._imag)
&nbsp;
    def <strong>__eq__</strong>(self, other):
        <i>"""Přetížení binárního operátoru ==."""</i>
        return self._real == other._real and self._imag == other._imag
&nbsp;
    def <strong>__neg__</strong>(self):
        <i>"""Přetížení unárního operátoru -."""</i>
        return Complex(-self._real, -self._imag)
&nbsp;
    def <strong>__add__</strong>(self, other):
        <i>"""Přetížení binárního operátoru +."""</i>
        r = self._real + other._real
        i = self._imag + other._imag
        return Complex(r, i)
&nbsp;
    def <strong>__sub__</strong>(self, other):
        <i>"""Přetížení binárního operátoru -."""</i>
        r = self._real - other._real
        i = self._imag - other._imag
        return Complex(r, i)
&nbsp;
    def <strong>__iadd__</strong>(self, other):
        <i>"""Přetížení binárního operátoru +=."""</i>
        self._real += other._real
        self._imag += other._imag
        return self
&nbsp;
&nbsp;
c1 = Complex(1, 2)
c2 = Complex(10, 20)
c3 = Complex(100)
c4 = Complex()
&nbsp;
print("c1:", c1)
print("c2:", c2)
print("c3:", c3)
print("c4:", c4)
&nbsp;
print()
&nbsp;
print("-c1:", -c1)
print("-c2:", -c2)
&nbsp;
print()
&nbsp;
print("c1 + c2:", c1+c2)
print("c1 + c3:", c1+c3)
print("c1 - c2:", c1-c2)
print("c1 - c3:", c1-c3)
&nbsp;
c2 += c3
print("c2 += c3:", c1)
&nbsp;
print()
&nbsp;
c5 = Complex(1, 2)
print("c1 == c5:", c1 == c5)
print("c2 == c5:", c2 == c5)
print("c3 == c5:", c3 == c5)
</pre>

<p>Vypočtené a vypsané výsledky ukazují, že přetížené operátory pracují
korektně:</p>

<pre>
c1: 1 + 2j
c2: 10 + 20j
c3: 100 + 0j
c4: 0 + 0j
&nbsp;
-c1: -1 + -2j
-c2: -10 + -20j
&nbsp;
c1 + c2: 11 + 22j
c1 + c3: 101 + 2j
c1 - c2: -9 + -18j
c1 - c3: -99 + 2j
c2 += c3: 1 + 2j
&nbsp;
c1 == c5: True
c2 == c5: False
c3 == c5: False
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Realizace vlastního infixového operátoru přetížením dvojice standardních operátorů</h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. První demonstrační příklad: třída <strong>HackyMul</strong> umožňující realizaci vlastního operátoru součinu</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu je ukázán <a href="#k03">výše
popsaný postup</a>, který umožňuje realizaci vlastního operátoru násobení
(resp.&nbsp;přesněji řečeno součinu), který se bude zapisovat pomocí symbolů
<strong>&lt;&lt;x&gt;&gt;</strong> (namísto <strong>x</strong> bude ovšem možné
použít libovolný jiný validní identifikátor). Celý trik, na kterém je tento
příklad postaven, je založen na třídě pojmenované <strong>HackyMul</strong>,
která vhodným způsobem přetíží operátory &lt;&lt; a &gt;&gt; tak, aby se při
aplikaci prvního operátoru zapamatoval levý operand (pravým operandem je
instance této třídy) a aplikací druhého operátoru se vypočte součin, jehož
hodnota se následně vrátí. Ve skutečnosti tedy zápis
<strong>&lt;&lt;x&gt;&gt;</strong> obsahuje dva operátory. Navíc se v&nbsp;obou
speciálních metodách vždy vypíše předaný parametr, aby bylo zřejmé, jak výpočet
interně probíhá:</p>

<pre>
<i># Vlastní infixové operátory v Pythonu</i>
<i>#</i>
<i># - třída HackyMul umožňující definici operátoru typu &lt;&lt;x&gt;&gt; apod.</i>
<i># - při volání speciálních metod se vypisují ladicí informace</i>
&nbsp;
&nbsp;
class <strong>HackyMul</strong>:
&nbsp;
    def <strong>__rlshift__</strong>(self, other):
        print("rlshift:", other)
        self.value = other
        return self
&nbsp;
    def <strong>__rshift__</strong>(self, other):
        print("rshift: ", other)
        return self.value * other
&nbsp;
&nbsp;
x = HackyMul()
print(2 &lt;&lt;x&gt;&gt; 3)
&nbsp;
y = HackyMul()
print(3 &lt;&lt;y&gt;&gt; 3)
&nbsp;
z = HackyMul()
i = 10
j = 20
print(i &lt;&lt;z&gt;&gt; j)
</pre>

<p>Po spuštění skriptu se můžeme přesvědčit, že výsledky skutečně odpovídají
běžnému součinu:</p>

<pre>
rlshift: 2
rshift:  3
6
&nbsp;
rlshift: 3
rshift:  3
9
&nbsp;
rlshift: 10
rshift:  20
200
</pre>

<p><div class="rs-tip-major">Poznámka: jak ovšem uvidíme v&nbsp;dalším textu,
může v&nbsp;praxi nastat hned celá řada problémů, před kterými nás neochrání
ani interpret Pythonu, ani žádné další pomocné nástroje (lintery
atd.).</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Odstranění ladicích informací, výpočet tabulky malé násobilky s&nbsp;využitím nového operátoru součinu</h2>

<p>Funkce <strong>print</strong> byly ve speciálních metodách
<strong>__rlshift__</strong> a <strong>__rshift__</strong> volány pouze
z&nbsp;toho důvodu, abychom si ujasnili, za jakých okolností a s&nbsp;jakými
argumenty jsou tyto metody volány. V&nbsp;praxi se pochopitelně bez těchto
pomocných výpisů většinou obejdeme a proto je ve druhém příkladu
z&nbsp;definice třídy <strong>HackyMul</strong> odstraníme. Aby bylo zřejmé, že
součin je počítán korektně, necháme si v&nbsp;dnešním druhém demonstračním
příkladu vypočítat tabulku malé násobilky. Implementace tohoto demonstračního
příkladu bude vypadat následovně:</p>

<pre>
<i># Vlastní infixové operátory v Pythonu</i>
<i>#</i>
<i># - třída HackyMul umožňující definici operátoru typu &lt;&lt;x&gt;&gt; apod.</i>
<i># - bez výpisu ladicích informací</i>
<i># - výpočet tabulky malé násobilky přes nový "operátor"</i>
&nbsp;
&nbsp;
class <strong>HackyMul</strong>:
&nbsp;
    def <strong>__rlshift__</strong>(self, other):
        self.value = other
        return self
&nbsp;
    def <strong>__rshift__</strong>(self, other):
        return self.value * other
&nbsp;
&nbsp;
x = HackyMul()
&nbsp;
for j in range(1, 11):
    for i in range(1, 11):
        r = i &lt;&lt;x&gt;&gt; j
        print(f"{r:3d}", end=" ")
    print()
</pre>

<p>Z&nbsp;tabulky zobrazené níže je patrné, že výpočty s&nbsp;využitím našeho
operátoru <strong>&lt;&lt;x&gt;&gt;</strong> probíhají korektně:</p>

<pre>
  1   2   3   4   5   6   7   8   9  10 
  2   4   6   8  10  12  14  16  18  20 
  3   6   9  12  15  18  21  24  27  30 
  4   8  12  16  20  24  28  32  36  40 
  5  10  15  20  25  30  35  40  45  50 
  6  12  18  24  30  36  42  48  54  60 
  7  14  21  28  35  42  49  56  63  70 
  8  16  24  32  40  48  56  64  72  80 
  9  18  27  36  45  54  63  72  81  90 
 10  20  30  40  50  60  70  80  90 100 
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Praktičtější příklad: realizace operátoru pro skalární součin</h2>

<p>Realizace vlastního operátoru pro provedení běžného součinu je pochopitelně
pouze ukázka toho, jakým směrem je možné do jisté míry &bdquo;ohnout&ldquo;
syntaxi programovacího jazyka Python. Ukažme si tedy poněkud praktičtější
příklad. Tím bude realizace operátoru pro výpočet skalárního součinu (<i>dot
product</i>). Náš nový speciální operátor bude předpokládat, že na jeho levé i
pravé straně budou jako operandy předány n-tice nebo seznamy mající stejný
počet prvků. Operátor vrátí výsledek skalárního součinu obou operandů (ty jsou
považovány za vektory délky <i>n</i>):</p>

<pre>
<i># Vlastní infixové operátory v Pythonu</i>
<i>#</i>
<i># - třída DotProduct umožňující definici operátoru pro skalární součin</i>
<i># - definice nového operátoru</i>
<i># - otestování nového operátoru</i>
&nbsp;
&nbsp;
class <strong>DotProduct</strong>:
&nbsp;
    def <strong>__rlshift__</strong>(self, other):
        self.value = other
        return self
&nbsp;
    def <strong>__rshift__</strong>(self, other):
        dot_product = 0
        for a, b in zip(self.value, other):
            dot_product += a * b
        return dot_product
&nbsp;
&nbsp;
o = DotProduct()
x = [1, 2, 3]
y = [3, 4, 5]
&nbsp;
print(x &lt;&lt;o&gt;&gt; y)
</pre>

<p>Po spuštění tohoto skriptu si ověříme, zda je výpočet korektní či nikoli.
Měla by se vypsat hodnota 26, která je získána výpočtem
1&times;3+2&times;4+3&times;5=3+8+15:</p>

<pre>
26
</pre>

<p><div class="rs-tip-major">Poznámka: operátor pro výpočet skalárního součinu
je skutečně poměrně praktický, zejména v&nbsp;době velkých jazykových modelů,
neuronových sítí atd. Pokud se ho ovšem chystáte skutečně realizovat, může být
výhodnější pro tento účel přetížit operátor <strong>@</strong>, který je
v&nbsp;jazyce Python sice rezervován (je to skutečný a plnohodnotný operátor),
ale není mu přiřazena žádná funkce. Například v&nbsp;knihovně NumPy je použit
pro maticový součin atd.</div></p>

<p>Způsob přetížení operátoru <strong>@</strong> a
popř.&nbsp;<strong>@=</strong> může vypadat následovně:</p>

<pre>
<i># Operátor maticového násobení:</i>
<i># - přetížení operátoru maticového násobení @</i>
<i># - přetížení operátoru @= kombinujícího maticové násobení s přiřazením</i>
&nbsp;
&nbsp;
class <strong>Test</strong>:
    <i>"""Třída s přetíženými operátory @ a @=."""</i>
&nbsp;
    def <strong>__init__</strong>(self, x):
        <i>"""Konstruktor."""</i>
        self.value = str(x)
&nbsp;
    def <strong>__str__</strong>(self):
        <i>"""Metoda volaná při tisku objektu."""</i>
        return self.value
&nbsp;
    def <strong>__matmul__</strong>(self, other):
        <i>"""Metoda přetěžující operátor @."""</i>
        return Test(f"({self.value} @ {other.value})")
&nbsp;
    def <strong>__imatmul__</strong>(self, other):
        <i>"""Metoda přetěžující operátor @=."""</i>
        return Test(f"({self.value} @ {other.value})")
&nbsp;
&nbsp;
<i># konstrukce několika instancí třídy Test</i>
t1 = Test(1)
print("t1:", t1)
&nbsp;
t2 = Test(2)
print("t2:", t2)
&nbsp;
t3 = Test(3)
print("t3:", t3)
&nbsp;
<i># použití obou přetížených operátorů ve stejném příkazu</i>
t3 @= t1 @ t2
print("t3 @= t1 @ t2:", t3)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Realizace nového operátoru s&nbsp;využitím znaku |</h2>

<p></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Demonstrační příklad: operátor skalární součinu zapisovaný znaky |o|</h2>

<p>V&nbsp;dalším demonstračním příkladu je ukázána realizace nového infixového
operátoru, který bude zapisován s&nbsp;využitím znaků <strong>|o|</strong>. Od
předchozích skriptů se tento příklad odlišuje tím, že jsou definovány speciální
metody <strong>__ror__</strong> a <strong>__or__</strong>. Musí se přitom
definovat obě zmíněné metody, protože první z&nbsp;těchto metod je volána
tehdy, pokud je instance třídy <strong>DotProduct</strong> <i>pravým</i>
operandem a druhá metoda je volána naopak tehdy, pokud je instance
<strong>DotProduct</strong> operandem <i>levým</i>:</p>

<pre>
<i># Vlastní infixové operátory v Pythonu</i>
<i>#</i>
<i># - třída DotProduct umožňující definici operátoru pro skalární součin</i>
<i># - odlišné symboly operátoru</i>
<i># - definice nového operátoru</i>
<i># - otestování nového operátoru</i>
&nbsp;
&nbsp;
class <strong>DotProduct</strong>:
&nbsp;
    def <strong>__ror__</strong>(self, other):
        self.value = other
        return self
&nbsp;
    def <strong>__or__</strong>(self, other):
        dot_product = 0
        for a, b in zip(self.value, other):
            dot_product += a * b
        return dot_product
&nbsp;
&nbsp;
o = DotProduct()
x = [1, 2, 3]
y = [3, 4, 5]
&nbsp;
print(x |o| y)
</pre>

<p>Spuštěním tohoto příkladu si opět ověříme, jestli jsou provedeny korektní
výpočty (mělo by tomu tak být):</p>

<pre>
26
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Problematika přetížení operátorů &lt; a &gt;</h2>

<pre>
# Vlastní infixové operátory v Pythonu
#
# - třída DotProduct umožňující definici operátoru pro skalární součin
# - pokus o redefinici speciálních metod pro operátory < a >
# - nekorektní řešení!


class DotProduct:

    def __lt__(self, other):
        self.value = other
        return self

    def __gt__(self, other):
        dot_product = 0
        for a, b in zip(self.value, other):
            dot_product += a * b
        return dot_product


o = DotProduct()
x = [1, 2, 3]
y = [3, 4, 5]

print(x <o> y)
</pre>

<pre>
Traceback (most recent call last):
  File "/home/ptisnovs/src/most-popular-python-libs/custom_operators/infix_5.py", line 25, in <module>
    print(x <o> y)
          ^^^^^^^
  File "/home/ptisnovs/src/most-popular-python-libs/custom_operators/infix_5.py", line 16, in __gt__
    for a, b in zip(self.value, other):
                    ^^^^^^^^^^
AttributeError: 'DotProduct' object has no attribute 'value'
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
# Vlastní infixové operátory v Pythonu
#
# - třída DotProduct umožňující definici operátoru pro skalární součin
# - redefinice speciální metody pro operátor >
# - korektní řešení


class DotProduct:

    def __init__(self):
        self.value = None

    def __gt__(self, other):
        if self.value is None:
            print("<", other)
            self.value = other
            return self

        print(">", other)
        dot_product = 0
        for a, b in zip(self.value, other):
            dot_product += a * b
        return dot_product


o = DotProduct()

x = [1, 2, 3]
y = [3, 4, 5]

print(x <o> y)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

Python 2

identifier ::=  (letter|"_") (letter | digit | "_")*
letter     ::=  lowercase | uppercase
lowercase  ::=  "a"..."z"
uppercase  ::=  "A"..."Z"
digit      ::=  "0"..."9"

Lu - uppercase letters
Ll - lowercase letters
Lt - titlecase letters
Lm - modifier letters
Lo - other letters
Nl - letter numbers
Mn - nonspacing marks
Mc - spacing combining marks
Nd - decimal numbers
Pc - connector punctuations




<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, které jsme si dnes ukázali, jsou uloženy
v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th>#<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td>1</td><td>infix_1.py</td><td>třída HackyMul umožňující definici operátoru typu &lt;&lt;x&gt;&gt; apod. s&nbsp;výpisem ladicích informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/infix_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/infix_1.py</a></td></tr>
<tr><td>2</td><td>infix_2.py</td><td>třída HackyMul umožňující definici operátoru typu &lt;&lt;x&gt;&gt; apod. bez výpisu ladicích informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/infix_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/infix_2.py</a></td></tr>
<tr><td>3</td><td>infix_3.py</td><td>realizace nového operátoru pro skalární součin, založeno na operátorech &lt;&lt; a &gt;&gt;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/infix_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/infix_3.py</a></td></tr>
<tr><td>4</td><td>infix_4.py</td><td>realizace nového operátoru pro skalární součin, založeno na operátoru |</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/infix_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/infix_4.py</a></td></tr>
<tr><td>5</td><td>infix_5.py</td><td>realizace nového operátoru pro skalární součin, založeno na operátorech &lt; a &gt; (nekorektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/infix_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/infix_5.py</a></td></tr>
<tr><td>6</td><td>infix_6.py</td><td>realizace nového operátoru pro skalární součin, založeno na operátorech &lt; a &gt; (korektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/infix_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/infix_6.py</a></td></tr>
<tr><td>7</td><td>infix_7.py</td><td>implementace třídy pro konstrukci vlastních operátorů (jednodušší varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/infix_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/infix_7.py</a></td></tr>
<tr><td>8</td><td>infix_8.py</td><td>implementace třídy pro konstrukci vlastních operátorů (nepatrně složitější varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/infix_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/infix_8.py</a></td></tr>
<tr><td>9</td><td>complex.py</td><td>implementace komplexních čísel i s&nbsp;přetížením vybraných operátorů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/complex.py">https://github.com/tisnik/most-popular-python-libs/blob/master/complex.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python: defining my own operators?<br />
<a href="https://stackoverflow.com/questions/932328/python-defining-my-own-operators">https://stackoverflow.com/questions/932328/python-defining-my-own-operators</a>
</li>

<li>Infix operators (Python recipe)<br />
<a href="https://web.archive.org/web/20220528202902/https://code.activestate.com/recipes/384122/">https://web.archive.org/web/20220528202902/https://code.activestate.com/recipes/384122/</a>
</li>

<li>Sage: decorators<br />
<a href="https://doc.sagemath.org/html/en/reference/misc/sage/misc/decorators.html">https://doc.sagemath.org/html/en/reference/misc/sage/misc/decorators.html</a>
</li>

<li>make a custom infix operator decorator<br />
<a href="https://github.com/sagemath/sage/issues/6245">https://github.com/sagemath/sage/issues/6245</a>
</li>

<li>Creating Custom Operators in Python 3<br />
<a href="https://dnmtechs.com/creating-custom-operators-in-python-3/">https://dnmtechs.com/creating-custom-operators-in-python-3/</a>
</li>

<li>Allowed characters in Python function names<br />
<a href="https://stackoverflow.com/questions/19482730/allowed-characters-in-python-function-names">https://stackoverflow.com/questions/19482730/allowed-characters-in-python-function-names</a>
</li>

<li>List of Unicode Characters of Category “Other Letter”<br />
<a href="https://www.compart.com/en/unicode/category/Lo">https://www.compart.com/en/unicode/category/Lo</a>
</li>

<li>Python Unicode Variable Names<br />
<a href="https://www.asmeurer.com/python-unicode-variable-names/">https://www.asmeurer.com/python-unicode-variable-names/</a>
</li>

<li>Start characters<br />
<a href="https://www.asmeurer.com/python-unicode-variable-names/start-characters.md">https://www.asmeurer.com/python-unicode-variable-names/start-characters.md</a>
</li>

<li>Continue characters<br />
<a href="https://www.asmeurer.com/python-unicode-variable-names/continue-characters.md">https://www.asmeurer.com/python-unicode-variable-names/continue-characters.md</a>
</li>

<li>Special Methods<br />
<a href="https://www.pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html">https://www.pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html</a>
</li>

<li>3. Data model<br />
<a href="https://docs.python.org/3/reference/datamodel.html">https://docs.python.org/3/reference/datamodel.html</a>
</li>

<li>Special Method Names<br />
<a href="https://diveintopython3.net/special-method-names.html">https://diveintopython3.net/special-method-names.html</a>
</li>

<li>Full list of Python special method names?<br />
<a href="https://stackoverflow.com/questions/51562492/full-list-of-python-special-method-names">https://stackoverflow.com/questions/51562492/full-list-of-python-special-method-names</a>
</li>

<li>Python special methods<br />
<a href="https://pythonforstarters.solomonmarvel.com/object-oriented-programming-in-python/python-special-methods">https://pythonforstarters.solomonmarvel.com/object-oriented-programming-in-python/python-special-methods</a>
</li>

<li>Python's Magic Methods: Leverage Their Power in Your Classes<br />
<a href="https://realpython.com/python-magic-methods/">https://realpython.com/python-magic-methods/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

