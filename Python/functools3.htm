<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Podpora funkcionálního programování v Pythonu a knihovna functools (3. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Podpora funkcionálního programování v Pythonu a knihovna functools (3. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o podpoře funkcionálního programování v jazyku Python si popíšeme většinu funkcí, které nalezneme ve standardní knihovně functools. Taktéž se zmíníme o podpoře takzvaných dekorátorů, což je další funkcionální technika převedená do světa Pythonu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Podpora funkcionálního programování v&nbsp;Pythonu a knihovna functools (3. část)</a></p>
<p><a href="#k02">2. Funkce vyššího řádu <strong>partialmethod</strong></a></p>
<p><a href="#k03">3. Třída s&nbsp;metodou s&nbsp;parametry</a></p>
<p><a href="#k04">4. Metody <strong>enable</strong> a <strong>disable</strong> vzniklé transformací <strong>set_enabled</strong></a></p>
<p><a href="#k05">5. Další příklad použití funkce <strong>partialmethod</strong> &ndash; doplnění většího množství parametrů při transformaci</a></p>
<p><a href="#k06">6. Cache pro výsledky čistých funkcí</a></p>
<p><a href="#k07">7. Klasický výpočet Fibonacciho posloupnosti rekurzivní funkcí</a></p>
<p><a href="#k08">8. LRU cache pro výsledky Fibonacciho posloupnosti pro nejčastěji použité vstupy</a></p>
<p><a href="#k09">9. Přečtení informací o využití LRU cache</a></p>
<p><a href="#k10">10. Programové vymazání LRU cache</a></p>
<p><a href="#k11">11. Cache pro hodnotu vlastnosti objektu</a></p>
<p><a href="#k12">12. Použití standardního dekorátoru <strong>@property</strong></a></p>
<p><a href="#k13">13. Použití dekorátoru <strong>@cached_property</strong></a></p>
<p><a href="#k14">14. Vygenerování metod s&nbsp;implementací relačních operátorů (<strong>total ordering</strong>)</a></p>
<p><a href="#k15">15. Dekorátory</a></p>
<p><a href="#k16">16. Ukázka dekorátoru aplikovaného na funkci</a></p>
<p><a href="#k17">17. Dvojice dekorátorů aplikovaných na jednu funkci</a></p>
<p><a href="#k18">18. Praktické použití dekorátoru &ndash; měření doby trvání funkce označené dekorátorem</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podpora funkcionálního programování v&nbsp;Pythonu a knihovna functools (3. část)</h2>

<p>Na předchozí dva články o podpoře funkcionálního programování v&nbsp;jazyce
Python [<a
href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-pythonu-a-knihovna-functools/">1</a>][<a
href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-pythonu-a-knihovna-functools-2-cast/">2</a>]
dnes navážeme. Popíšeme si další funkce a dekorátory, které nalezneme ve
standardním balíčku <i>functools</i>, zejména funkci
<strong>partialmethod</strong> a dekorátory <strong>@lru_cache</strong>,
<strong>@cached_property</strong> a <strong>@total_ordering</strong>. Společně
s&nbsp;předchozím článkem jsme se tak věnovali prakticky celému obsahu tohoto
potenciálně velmi užitečného balíčku:</p>

<table>
<tr><th>Symbol</th><th>Verze Pythonu</th><th>Popsáno</th></tr>
<tr><td>wraps</td><td>2.5</td><td>&nbsp;</td></tr>
<tr><td>update_wrapper</td><td>2.5</td><td>&nbsp;</td></tr>
<tr><td>partial</td><td>2.5</td><td><a href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-pythonu-a-knihovna-functools-2-cast/#k09">druhý článek, kapitola 9</a></td></tr>
<tr><td>reduce</td><td>3.0</td><td><a href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-pythonu-a-knihovna-functools/#k17">první článek, kapitola 17</a></td></tr>
<tr><td>lru_cache</td><td>3.2</td><td><a href="#k06">dnešní část, kapitola 6</a></td></tr>
<tr><td>total_ordering</td><td>3.2</td><td><a href="#k14">dnešní část, kapitola 14</a></td></tr>
<tr><td>cmp_to_key</td><td>3.2</td><td>&nbsp;</td></tr>
<tr><td>partialmethod</td><td>3.4</td><td><a href="#k02">dnešní část, kapitola 2</a></td></tr>
<tr><td>singledispatch</td><td>3.4</td><td>&nbsp;</td></tr>
<tr><td>cached_property</td><td>3.8</td><td><a href="#k11">dnešní část, kapitola 11</a></td></tr>
<tr><td>singledispatchmethod</td><td>3.8</td><td>&nbsp;</td></tr>
<tr><td>cache</td><td>3.9</td><td>&nbsp;</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Funkce vyššího řádu <strong>partialmethod</strong></h2>

<p><a
href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-pythonu-a-knihovna-functools-2-cast/">V&nbsp;předchozím
článku</a> jsme si poměrně dopodrobna popsali funkci vyššího řádu nazvanou
<strong>partial</strong>, která nějakou funkci s&nbsp;obecně <i>n</i> parametry
transformovala na jinou funkci s&nbsp;obecně <i>n-m</i> parametry tak, že
zbývající parametry (je jich <i>m</i>, typicky však 1) již byly doplněny na
nějakou hodnotu. Připomeňme si následující (poněkud umělý) příklad:</p>

<pre>
from functools import partial
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
print(mul(6, 7))
&nbsp;
print()
&nbsp;
<strong>doubler</strong> = <u>partial(mul, 2)</u>
&nbsp;
&nbsp;
for i in range(11):
    print(i, doubler(i))
</pre>

<p>V&nbsp;balíčku <i>functools</i> kromě <strong>partial</strong> nalezneme i
podobně koncipovanou funkci <strong>partialmethod</strong>, která ovšem &ndash;
jak její název správně napovídá &ndash; bude použitelná pro transformaci
metody, tedy takových funkcí, jejichž prvním argumentem je
<strong>self</strong> (a na něž se aplikují určitá pravidla viditelnosti atd.).
Funkce <strong>partialmethod</strong> je potenciálně velmi užitečná, jak
ostatně uvidíme v&nbsp;dalším textu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Třída s&nbsp;metodou s&nbsp;parametry</h2>

<p>Ještě předtím, než si ukážeme způsob použití funkce
<strong>partialmethod</strong> si ukažme jednoduchou třídu, jejíž instance
obsahují atribut <strong>_enabled</strong>. Tento atribut se nastavuje metodou
pojmenovanou <strong>set_enabled</strong> a jak je z&nbsp;názvu atributu zřejmé
(i bez uvedení typové deklarace), jsou hodnotami tohoto atributu pravdivostní
hodnoty:</p>

<pre>
class <strong>Foo</strong>:
    def <strong>__init__</strong>(self):
        self._enabled = False
&nbsp;
    def <strong>set_enabled</strong>(self, state):
        self._enabled = state
&nbsp;
    def <strong>__str__</strong>(self):
        return "Foo that is " + ("enabled" if self._enabled else "disabled")
&nbsp;
&nbsp;
foo = Foo()
print(foo)
</pre>

<p>Příklad použití:</p>

<pre>
Foo that is disabled
</pre>

<p>Samozřejmě si můžeme bez problémů otestovat i vliv volání metody
<strong>set_enabled</strong> (tedy tolik zatracovaného <i>setteru</i>) na stav
objektu:</p>

<pre>
class <strong>Foo</strong>:
    def <strong>__init__</strong>(self):
        self._enabled = False
&nbsp;
    def <strong>set_enabled</strong>(self, state):
        self._enabled = state
&nbsp;
    def <strong>__str__</strong>(self):
        return "Foo that is " + ("enabled" if self._enabled else "disabled")
&nbsp;
&nbsp;
foo = Foo()
print(foo)
&nbsp;
foo.set_enabled(True)
print(foo)
&nbsp;
foo.set_enabled(False)
print(foo)
</pre>

<p>Výsledkem spuštění tohoto skriptu budou následující zprávy vypsané na
terminál:</p>

<pre>
Foo that is disabled
Foo that is enabled
Foo that is disabled
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Metody <strong>enable</strong> a <strong>disable</strong> vzniklé transformací <strong>set_enabled</strong></h2>

<p>Volání:</p>

<pre>
foo.set_enabled(True)
foo.set_enabled(False)
</pre>

<p>je ve skutečnosti poněkud neohrabané a hodí se jen ve chvíli, kdy se metoda
volá s&nbsp;nějakým výrazem a nikoli s&nbsp;konstantou. Samozřejmě si můžeme
vytvořit pomocné metody <strong>enable</strong> a <strong>disable</strong>, a
to zcela klasickým způsobem &ndash; budeme z&nbsp;nich volat původní metodu
<strong>set_enabled</strong>. Ovšem právě v&nbsp;tomto případě je mnohem
elegantnější použití <strong>partialmethod</strong>, která za nás hodnotu
parametru doplní automaticky. Dvě nové metody do třídy <strong>Foo</strong> lze
tedy přidat i tak, jak je to naznačeno na obou podtržených řádcích:</p>

<pre>
from functools import partialmethod
&nbsp;
&nbsp;
class <strong>Foo</strong>:
    def <strong>__init__</strong>(self):
        self._enabled = False
&nbsp;
    def <strong>set_enabled</strong>(self, state):
        self._enabled = state
&nbsp;
    <u>enable = partialmethod(set_enabled, True)</u>
    <u>disable = partialmethod(set_enabled, False)</u>
&nbsp;
    def <strong>__str__</strong>(self):
        return "Foo that is " + ("enabled" if self._enabled else "disabled")
&nbsp;
&nbsp;
foo = Foo()
print(foo)
&nbsp;
foo.enable()
print(foo)
&nbsp;
foo.disable()
print(foo)
</pre>

<p>Výsledek bude naprosto stejný, jako tomu bylo v&nbsp;předchozím
příkladu:</p>

<pre>
Foo that is disabled
Foo that is enabled
Foo that is disabled
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>partialmethod</strong> tedy
pracuje podobně jako <strong>partial</strong>, ale bere v&nbsp;úvahu specifický
význam prvního parametru <strong>self</strong>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Další příklad použití funkce <strong>partialmethod</strong> &ndash; doplnění většího množství parametrů při transformaci</h2>

<p>V&nbsp;předchozím článku jsme si řekli, že funkci <strong>partial</strong>
můžeme použít i pro doplnění a zapamatování většího množství parametrů. Totéž
ovšem platí i pro <strong>partialmethod</strong>, což znamená, že například
můžeme transformovat metodu <strong>move_to</strong> ze třídy
<strong>Point</strong> se třemi parametry (<strong>self</strong>,
<strong>x</strong> a <strong>y</strong>) na novou metodu pouze
s&nbsp;parametrem <strong>self</strong>, která přesune příslušný bod do počátku
souřadného systému. Výsledek může vypadat následovně:</p>

<pre>
from functools import partialmethod
&nbsp;
&nbsp;
class <strong>Point</strong>:
    def <strong>__init__</strong>(self):
        self._x = 0
        self._y = 0
&nbsp;
    def <strong>move_to</strong>(self, x, y):
        self._x = x
        self._y = y
&nbsp;
    <u>to_origin = partialmethod(move_to, 0, 0)</u>
&nbsp;
    def <strong>__str__</strong>(self):
        return f"Point[{self._x}, {self._y}]"
&nbsp;
&nbsp;
point = Point()
print(point)
&nbsp;
point.move_to(1, 2)
print(point)
&nbsp;
point.to_origin()
print(point)
</pre>

<p>Samozřejmě si můžeme otestovat, jak se bude výsledný skript chovat po svém
spuštění:</p>

<pre>
Point[0, 0]
Point[1, 2]
Point[0, 0]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Cache pro výsledky čistých funkcí</h2>

<p>Připomeňme si, že za <i>čisté funkce</i> resp.&nbsp;<i>čistě funkcionální
funkce</i> považujeme takové funkce, jejichž výsledná hodnota záleží pouze na
hodnotách parametrů a nikoli na nějakém vnitřním stavu, hodnotách externích
proměnných či například výsledku přístupu k&nbsp;nějakým prostředkům se stavem
(databáze, soubory, síťové rozhraní atd.). Jenže když se nad takovými funkcemi
zamyslíme, zjistíme, že je vlastně (alespoň teoreticky) možné nahradit volání
takové funkce nějakou formou mapování resp.&nbsp;slovníku, kde klíči slovníku
budou kombinace hodnot parametrů funkce a hodnotami budou návratové hodnoty
funkce. To je pochopitelně pro většinu funkcí nepraktické, zejména
s&nbsp;ohledem na obrovské množství kombinace hodnot parametrů, s&nbsp;nimiž se
může funkce volat.</p>

<p>Nicméně mnohé funkce jsou často volány se stejnými kombinacemi parametrů. A
takové funkce je možné opatřit (zabalit) vhodnou formou cache pro nejčastěji
vyžadované výsledky. Opět se jedná o funkcionalitu dostupnou díky standardnímu
balíčku <i>functools</i>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Klasický výpočet Fibonacciho posloupnosti rekurzivní funkcí</h2>

<p>Jako ukázku vhodnosti či v&nbsp;některých případech nevhodnosti použití
cache pro funkce si ukažme, jak lze implementovat výpočet Fibonacciho
posloupnosti rekurzivním výpočtem. Jedná se o klasický &bdquo;školní&ldquo;
příklad, který pouze doplníme o změření času trvání výpočtu. Pro zajímavost
budeme výpočet desetkrát opakovat pro stejný vstup:</p>

<pre>
from time import time
&nbsp;
def <strong>fib</strong>(n):
    if n &lt; 2:
        return n
    return fib(n-1) + fib(n-2)
&nbsp;
&nbsp;
max_n = 40
&nbsp;
for _ in range(10):
    start = time()
    result = fib(max_n)
    end = time()
    print(result, end - start)
</pre>

<p>I pro relativně nízkou vstupní hodnotu (40) bude výpočet trvat poměrně
dlouho (minimálně při použití CPythonu):</p>

<pre>
102334155 27.4883930683136
102334155 27.809394598007202
102334155 27.91700768470764
102334155 28.687997817993164
102334155 30.422297954559326
102334155 28.643412351608276
102334155 28.83504009246826
102334155 28.57629656791687
102334155 28.623551607131958
102334155 28.74962282180786
</pre>

<p><div class="rs-tip-major">Poznámka: první sloupec obsahuje vypočtenou
hodnotu, druhý sloupec čas výpočtu v&nbsp;sekundách.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. LRU cache pro výsledky Fibonacciho posloupnosti pro nejčastěji použité vstupy</h2>

<p>Nyní předchozí skript nepatrně upravíme tak, aby se použila cache pro
nejčastěji požadované výsledky (resp.&nbsp;naopak &ndash; ty nejméně často
vyžadované výsledky jsou z&nbsp;cache odstraňovány). Nejprve importujeme funkci
<strong>lru_cache</strong> z&nbsp;balíčku <strong>functools</strong> a následně
před definici funkce pro výpočet Fibonacciho posloupnosti přidáme dekorátor
<strong>@lru_cache</strong>. Žádné další změny nebudou provedeny:</p>

<pre>
from time import time
from functools import lru_cache
&nbsp;
<u>@lru_cache</u>
def <strong>fib</strong>(n):
    if n &lt; 2:
        return n
    return fib(n-1) + fib(n-2)
&nbsp;
&nbsp;
max_n = 40
&nbsp;
for _ in range(10):
    start = time()
    result = fib(max_n)
    end = time()
    print(result, end - start)
</pre>

<p>Nyní ovšem budou výpočty probíhat mnohem rychleji! Pro další opakování
výpočtu pro daný vstup <strong>max_n = 40</strong> je to zřejmé &ndash; LRU
cache již má uložen příslušný výsledek. Ovšem již první volání této funkce bude
rychlejší, a to z&nbsp;toho důvodu, že se pamatují výsledky z&nbsp;jedné větve
rekurzivního výpočtu:</p>

<pre>
102334155 0.0005862712860107422
102334155 4.76837158203125e-07
102334155 7.152557373046875e-07
102334155 4.76837158203125e-07
102334155 4.76837158203125e-07
102334155 4.76837158203125e-07
102334155 4.76837158203125e-07
102334155 4.76837158203125e-07
102334155 4.76837158203125e-07
102334155 2.384185791015625e-07
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si až neuvěřitelného
urychlení z&nbsp;27 sekund na 0,0005 sekundy v&nbsp;prvním případě.
Pochopitelně za to platíme většími nároky na operační paměť.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přečtení informací o využití LRU cache</h2>

<p>Samotná LRU cache (<i>least recently used</i>) nám může poskytnout několik
informací o počtu zapamatovaných výsledků, využití cache atd. Tyto informace
lze získat zavoláním <strong>fib.cache_info()</strong>, což je samo o sobě
zajímavé, protože nám to prozrazuje, že se jedná a atribut funkce obalené
dekorátorem (podrobnosti si řekneme za chvíli). Zkusme si tedy výpočet
Fibonacciho posloupnosti upravit tak, abychom před každým výpočtem zjistili a
vypsali informaci o LRU cache:</p>

<pre>
from time import time
from functools import lru_cache
&nbsp;
<u>@lru_cache</u>
def <strong>fib</strong>(n):
    if n &lt; 2:
        return n
    return fib(n-1) + fib(n-2)
&nbsp;
&nbsp;
max_n = 40
&nbsp;
for _ in range(10):
    print(<u>fib.cache_info()</u>)
    start = time()
    result = fib(max_n)
    end = time()
    print(result, end - start)
</pre>

<p>Získané výsledky prozrazují, jak je cache využita:</p>

<pre>
CacheInfo(hits=0, misses=0, maxsize=128, currsize=0)
102334155 0.0011126995086669922
CacheInfo(hits=38, misses=41, maxsize=128, currsize=41)
102334155 1.1920928955078125e-06
CacheInfo(hits=39, misses=41, maxsize=128, currsize=41)
102334155 9.5367431640625e-07
CacheInfo(hits=40, misses=41, maxsize=128, currsize=41)
102334155 9.5367431640625e-07
CacheInfo(hits=41, misses=41, maxsize=128, currsize=41)
102334155 4.76837158203125e-07
CacheInfo(hits=42, misses=41, maxsize=128, currsize=41)
102334155 4.76837158203125e-07
CacheInfo(hits=43, misses=41, maxsize=128, currsize=41)
102334155 4.76837158203125e-07
CacheInfo(hits=44, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
CacheInfo(hits=45, misses=41, maxsize=128, currsize=41)
102334155 4.76837158203125e-07
CacheInfo(hits=46, misses=41, maxsize=128, currsize=41)
102334155 4.76837158203125e-07
</pre>

<p><div class="rs-tip-major">Poznámka: zobrazené informace dávají smysl. Na
začátku je cache prázdná, po proběhnutí prvního výpočtu obsahuje 41 výsledků
pro parametry 0 až 40 (zcela unikátních a nových), ovšem už po doběhnutí tohoto
výpočtu lze zjistit, že cache byla úspěšně využita celkem 38&times; (jednou
z&nbsp;větví rekurze). A další pokusy o výpočet <strong>fib(40)</strong> již
přímo vrátí hodnotu z&nbsp;cache, čímž se zvýší počitadlo
<strong>hits</strong>, ovšem obsazení cache zůstane stejné (počitadlo
<strong>currsize</strong>).</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Programové vymazání LRU cache</h2>

<p>LRU cache je možné v&nbsp;případě potřeby explicitně vymazat. Příkladem by
mohla být funkce používaná ve výpočtu na více místech, ovšem každý výpočet
začíná s&nbsp;odlišnými vstupními parametry. V&nbsp;případě, že se nechceme
spoléhat na &bdquo;LRU algoritmus&ldquo;, můžeme před takovým výpočtem zavolat
metodu <strong>cache_clear()</strong>, která cache vymaže:</p>

<pre>
fib.cache_clear()
</pre>

<p>Podívejme se nyní na poněkud umělý příklad, v&nbsp;němž opět počítáme n-tý
prvek Fibonacciho posloupnosti s&nbsp;využitím LRU cache, ovšem po proběhnutí
určitého počtu volání funkce <strong>fib</strong> cache explicitně
vymažeme:</p>

<pre>
from time import time
from functools import lru_cache
&nbsp;
<u>@lru_cache</u>
def <strong>fib</strong>(n):
    if n &lt; 2:
        return n
    return fib(n-1) + fib(n-2)
&nbsp;
&nbsp;
max_n = 40
&nbsp;
for i in range(20):
    if i % 5 == 0:
        <u>fib.cache_clear()</u>
    print(<u>fib.cache_info()</u>)
    start = time()
    result = fib(max_n)
    end = time()
    print(result, end - start)
</pre>

<p>Tento skript kromě výsledků výpočtů a času, který byl stráven výpočty,
zobrazuje informaci o využití cache:</p>

<pre>
CacheInfo(hits=0, misses=0, maxsize=128, currsize=0)
102334155 0.0005662441253662109
CacheInfo(hits=38, misses=41, maxsize=128, currsize=41)
102334155 7.152557373046875e-07
CacheInfo(hits=39, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
CacheInfo(hits=40, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
CacheInfo(hits=41, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
<strong>CacheInfo(hits=0, misses=0, maxsize=128, currsize=0)</strong>
102334155 1.5497207641601562e-05
CacheInfo(hits=38, misses=41, maxsize=128, currsize=41)
102334155 4.76837158203125e-07
CacheInfo(hits=39, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
CacheInfo(hits=40, misses=41, maxsize=128, currsize=41)
102334155 4.76837158203125e-07
CacheInfo(hits=41, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
<strong>CacheInfo(hits=0, misses=0, maxsize=128, currsize=0)</strong>
102334155 1.430511474609375e-05
CacheInfo(hits=38, misses=41, maxsize=128, currsize=41)
102334155 4.76837158203125e-07
CacheInfo(hits=39, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
CacheInfo(hits=40, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
CacheInfo(hits=41, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
<strong>CacheInfo(hits=0, misses=0, maxsize=128, currsize=0)</strong>
102334155 1.4066696166992188e-05
CacheInfo(hits=38, misses=41, maxsize=128, currsize=41)
102334155 7.152557373046875e-07
CacheInfo(hits=39, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
CacheInfo(hits=40, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
CacheInfo(hits=41, misses=41, maxsize=128, currsize=41)
102334155 2.384185791015625e-07
</pre>

<p><div class="rs-tip-major">Poznámka: tučně jsou zobrazeny ty stavy výpočtu,
v&nbsp;nichž došlo k&nbsp;vymazání LRU cache.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Cache pro hodnotu vlastnosti objektu</h2>

<p>Výše uvedený dekorátor <strong>@lru_cache</strong> (což je, jak uvidíme
dále, ve skutečnosti vhodně zapsaná funkce vyššího řádu resp.&nbsp;uzávěr), se
používá skutečně pro implementaci cache, jejíž obsah se může postupem času
měnit na základě toho, s&nbsp;jakými parametry se &bdquo;cachovaná&ldquo;
funkce volá. Ve standardní knihovně <i>functools</i> ovšem nalezneme ještě
jeden dekorátor s&nbsp;částečně podobným významem a taktéž s&nbsp;podobným
jménem.</p>

<p>Tento dekorátor se jmenuje <strong>@cached_property</strong> a používá se
v&nbsp;těch místech programového kódu, kde skutečně vyžadujeme vlastnost
(<i>property</i>), která se ovšem (na rozdíl od běžné vlastnosti) vypočte jen
jedenkrát a při každém dalším přístupu k&nbsp;ní (samozřejmě je myšleno čtení)
se přímo vrátí zapamatovaná hodnota. Tato cache tedy slouží pro zapamatování
jediné hodnoty a nemusí být založena na použití algoritmu &bdquo;LRU&ldquo;.
Taktéž může sloužit pro odložení výpočtu, který by se jinak prováděl při
konstrukci a inicializaci objektu.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití standardního dekorátoru <strong>@property</strong></h2>

<p>Ještě než si popíšeme výše zmíněný dekorátor
<strong>@cached_property</strong>, podívejme se pro úplnost na použití
standardního dekorátoru <strong>@property</strong>. Tento dekorátor se zapisuje
před metodu, jejíž název později použijeme pro čtení vlastnosti objektu &ndash;
a to bez toho, aby se metoda explicitně volala. Metoda je tedy dekorátorem
transformována do odlišně se chovající hodnoty:</p>

<pre>
class <strong>Foo</strong>:
    <u>@propety</u>
    def <strong>bar</strong>(self):
        return <i>something</i>
&nbsp;
&nbsp;
x = Foo()
print(x.bar)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že za
<strong>x.bar</strong> nejsou závorky značící volání funkce.</div></p>

<p>Opět se podívejme na příklad založený na výpočtu Fibonacciho posloupnosti.
V&nbsp;konstruktoru si pouze zapamatujeme hodnotu <strong>n</strong> a následně
vypočteme Fib(n) jen ve chvíli, kdy je to skutečně zapotřebí, tj.&nbsp;při
čtení vlastnosti <strong>value</strong> (a pokud se tato vlastnost nebude číst,
výpočet se neprovede vůbec):</p>

<pre>
from time import time
&nbsp;
&nbsp;
class <strong>FibonacciNumber</strong>:
    def <strong>__init__</strong>(self, n):
        self._n = n
&nbsp;
    <u>@property</u>
    def <strong>value</strong>(self):
        return FibonacciNumber.compute(self._n)
&nbsp;
    @staticmethod
    def <strong>compute</strong>(n):
        if n &lt; 2:
            return n
        return FibonacciNumber.compute(n-1) + FibonacciNumber.compute(n-2)
&nbsp;
&nbsp;
f = FibonacciNumber(40)
&nbsp;
for _ in range(10):
    start = time()
    result = f.value
    end = time()
    print(result, end - start)
</pre>

<p>Jak pravděpodobně správně tušíte, bude každé čtení <strong>f.value</strong>
znovu a znovu spouštět dlouhotrvající výpočet:</p>

<pre>
102334155 32.67074537277222
102334155 34.46800398826599
102334155 31.666145086288452
102334155 32.48106145858765
102334155 33.00236797332764
102334155 33.22874307632446
102334155 33.054988384246826
102334155 33.02854561805725
102334155 32.91584897041321
102334155 33.35956025123596
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použití dekorátoru <strong>@cached_property</strong></h2>

<p>V&nbsp;případě, že namísto standardního dekorátoru
<strong>@property</strong> použijeme dekorátor
<strong>@cached_property</strong>, bude se program chovat odlišně &ndash;
výpočet se provede pouze při <i>prvním</i> přístupu k&nbsp;vlastnosti
<strong>value</strong>:</p>

<pre>
from time import time
from functools import cached_property
&nbsp;
&nbsp;
class <strong>FibonacciNumber</strong>:
    def <strong>__init__</strong>(self, n):
        self._n = n
&nbsp;
    <u>@cached_property</u>
    def <strong>value</strong>(self):
        return FibonacciNumber.compute(self._n)
&nbsp;
    @staticmethod
    def <strong>compute</strong>(n):
        if n &lt; 2:
            return n
        return FibonacciNumber.compute(n-1) + FibonacciNumber.compute(n-2)
&nbsp;
&nbsp;
f = FibonacciNumber(40)
&nbsp;
for _ in range(10):
    start = time()
    result = f.value
    end = time()
    print(result, end - start)
</pre>

<p>O tom, že bude výsledek výpočtu skutečně uložen do cache, se přesvědčíme
snadno pohledem na výsledky získané po spuštění skriptu:</p>

<pre>
102334155 32.47180533409119
102334155 9.5367431640625e-07
102334155 2.384185791015625e-07
102334155 2.384185791015625e-07
102334155 0.0
102334155 2.384185791015625e-07
102334155 0.0
102334155 2.384185791015625e-07
102334155 0.0
102334155 0.0
</pre>

<p>Pro další urychlení výpočtu pochopitelně můžeme využít jak
<strong>@cached_property</strong>, tak i <strong>@lru_cache</strong>, a to
konkrétně následujícím způsobem:</p>

<pre>
from time import time
from functools import cached_property, lru_cache
&nbsp;
&nbsp;
class <strong>FibonacciNumber</strong>:
    def __init__(self, n):
        self._n = n
&nbsp;
    <u>@cached_property</u>
    def <strong>value</strong>(self):
        return FibonacciNumber.compute(self._n)
&nbsp;
    <u>@staticmethod</u>
    <u>@lru_cache</u>
    def <strong>compute</strong>(n):
        if n &lt; 2:
            return n
        return FibonacciNumber.compute(n-1) + FibonacciNumber.compute(n-2)
&nbsp;
&nbsp;
f = FibonacciNumber(40)
&nbsp;
for _ in range(10):
    start = time()
    result = f.value
    end = time()
    print(result, end - start)
</pre>

<p>Výsledky nyní budou vypočteny jen jedenkrát a navíc velmi rychle:</p>

<pre>
102334155 0.0005643367767333984
102334155 4.76837158203125e-07
102334155 2.384185791015625e-07
102334155 2.384185791015625e-07
102334155 0.0
102334155 0.0
102334155 2.384185791015625e-07
102334155 0.0
102334155 2.384185791015625e-07
102334155 2.384185791015625e-07
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vygenerování metod s&nbsp;implementací relačních operátorů (<strong>total ordering</strong>)</h2>

<p>Velmi zajímavým dekorátorem, který nalezneme v&nbsp;balíčku
<i>functools</i>, je dekorátor nazvaný <strong>@total_ordering</strong>.
Používá se, resp.&nbsp;může se použít v&nbsp;deklaracích tříd, jejichž instance
(tedy hodnoty) je možné nějakým způsobem jednoznačně uspořádat ve smyslu relace
&bdquo;menší než&ldquo;, &bdquo;rovno&ldquo; atd. Příkladem může být třída
reprezentující sémantickou verzi <strong>major.minor</strong>, kde
<strong>major</strong> i <strong>minor</strong> jsou celá čísla. Všechny možné
verze zapsané tímto způsobem lze zajisté uspořádat a vzniká tedy potřeba
implementace všech šesti relačních operátorů ==, !=, &lt;, &lt;=, &gt; i &gt;=.
A právě v&nbsp;takové situaci je možné použít dekorátor
<strong>@total_ordering</strong>, který dokáže příslušné realizace operátorů
vygenerovat na základě znalosti pouze relace rovnosti a (například)
&bdquo;menší než&ldquo;. Ostatně se podívejme na implementaci, kde dekorátor
aplikujeme nikoli na metodu, ale na celou třídu:</p>

<pre>
from functools import total_ordering
&nbsp;
&nbsp;
<i>@total_ordering</i>
class <strong>Version</strong>:
    def <strong>__init__</strong>(self, major, minor):
        self._major = major
        self._minor = minor
&nbsp;
    def <strong>_is_valid_version</strong>(self, other):
        return (hasattr(other, "_major") and
                hasattr(other, "_major"))
&nbsp;
    def <strong>__eq__</strong>(self, other):
        if not self._is_valid_version(other):
            return NotImplemented
        return (self._major, self._minor) == \
               (other._major, other._minor)
&nbsp;
    def <strong>__lt__</strong>(self, other):
        if not self._is_valid_version(other):
            return NotImplemented
        return (self._major, self._minor) &lt; \
               (other._major, other._minor)
&nbsp;
&nbsp;
v1 = Version(1, 0)
v2 = Version(1, 2)
v3 = Version(1, 2)
v4 = Version(2, 1)
&nbsp;
print(v1==v2)
print(v2==v3)
&nbsp;
print()
&nbsp;
print(v1&lt;v2)
print(v1&lt;v4)
print(v2&lt;v4)
&nbsp;
print(v1&gt;v2)
print(v1&gt;v4)
print(v2&gt;v4)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Dekorátory</h2>

<p>V&nbsp;závěrečné části dnešního článku si na trojici demonstračních příkladů
ukážeme základní způsoby použití takzvaných <i>dekorátorů</i>. Jedná se opět o
funkcionální technologii, která nám umožňuje snadno &bdquo;obalit&ldquo; volání
nějaké funkce dalším kódem a vrátit výsledek jako novou funkci s&nbsp;přidanými
vlastnostmi. Může to vypadat následovně:</p>

<pre>
def <strong>wrapper</strong>1(původní_funkce):
    def <strong>nová_funkce</strong>():
        <i># nějaký kód</i>
        původní_funkce()
        <i># nějaký kód</i>
&nbsp;
    return nová_funkce
</pre>

<p>Důležité je, že ono vlastní &bdquo;obalení&ldquo; původní funkce je
realizováno snadno zapamatovatelnou syntaxí &ndash; před definici funkce se na
samostatný řádek zapíše jméno dekorátoru a jeho případné parametry:</p>

<pre>
@wrapper
def <strong>hello</strong>():
    print("Hello!")
</pre>

<p>Musíme si ovšem uvědomit, že se ve skutečnosti jedná pouze o syntaktický
cukr a podobnou techniku lze použít i v&nbsp;případě, že by dekorátory
v&nbsp;Pythonu neexistovaly.</p>

<p><div class="rs-tip-major">Poznámka: na dekorátory narazíme v&nbsp;Pythonu
prakticky v&nbsp;jakémkoli oboru (třeba i u tvorby testů, REST API atd.). Vždy
je důležité si uvědomit, že se nejedná o žádnou magii, ale o jinak zapsané
volání funkce vyššího řádu.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Ukázka dekorátoru aplikovaného na funkci</h2>

<p>Podívejme se nyní na velmi jednoduchý dekorátor, který původní (libovolnou)
funkci obaluje tak, že před voláním původní funkce zobrazí řádek se znaky
&bdquo;-&ldquo; a po návratu z&nbsp;původní funkce opět vypíše řádek se znaky
&bdquo;-&ldquo;. Kód tohoto příkladu vypadá následovně:</p>

<pre>
def <strong>wrapper</strong>1(function):
    def <strong>inner_function</strong>():
        print("-" * 40)
        function()
        print("-" * 40)
&nbsp;
    return inner_function
&nbsp;
&nbsp;
<u>@wrapper1</u>
def <strong>hello</strong>():
    print("Hello!")
&nbsp;
&nbsp;
hello()
</pre>

<p>Pokud nyní tento příkladu spustíme, vypíše se na terminál následující
trojice zpráv:</p>

<pre>
----------------------------------------
Hello!
----------------------------------------
</pre>

<p>Proč tomu tak je? Ve skutečnosti totiž nevoláme původní funkci
<strong>hello</strong>, protože ta již pod tímto jménem neexistuje &ndash; byla
totiž transformována do nové funkce, kterou si sice nemůžeme jednoduše vypsat
ve formě zdrojového kódu, ale měla by vypadat zhruba takto:</p>

<pre>
def <strong>hello</strong>():
    print("-" * 40)
    původní_hello()()
    print("-" * 40)
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě nyní můžeme začít
experimentovat s&nbsp;předáváním parametrů použitím nelokálních proměnných (a
tím pádem i uzávěrů) atd. atd.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Dvojice dekorátorů aplikovaných na jednu funkci</h2>

<p>Nyní si předchozí příklad upravme do nové podoby. Nejprve si nadefinujeme
dvojici wrapperů (&bdquo;obalovačů&ldquo;), které před i po zavolání původní
funkce vypíšou na terminál buď řadu znaků &bdquo;-&ldquo; nebo řadu znaků
&bdquo;=&ldquo;:</p>

<pre>
def <strong>wrapper1</strong>(function):
    def <strong>inner_function</strong>():
        print("-" * 40)
        function()
        print("-" * 40)
&nbsp;
    return inner_function
&nbsp;
&nbsp;
def <strong>wrapper2</strong>(function):
    def <strong>inner_function</strong>():
        print("=" * 40)
        function()
        print("=" * 40)
&nbsp;
    return inner_function
</pre>

<p>Poté si necháme původní funkci <strong>hello</strong> ztransformovat (tedy
&bdquo;obalit&ldquo;) dvakrát, a to v&nbsp;tomto zapsaném pořadí:</p>

<pre>
@wrapper1
@wrapper2
def <strong>hello</strong>():
    print("Hello!")
</pre>

<p>Výsledek bude vypadat takto:</p>

<pre>
----------------------------------------
========================================
Hello!
========================================
----------------------------------------
</pre>

<p>Co to znamená? Původní funkce <strong>hello</strong> byla nejdříve obalena do přibližně této podoby:</p>

<pre>
def <strong>novější_hello</strong>():
    print("=" * 40)
    původní_hello()()
    print("=" * 40)
</pre>

<p>a potom došlo k&nbsp;dalšímu obalení:</p>

<pre>
def <strong>nejnovější_hello</strong>():
    print("-" * 40)
    novější_hello()()
    print("-" * 40)
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu bude vypadat
následovně:</p>

<pre>
def <strong>wrapper1</strong>(function):
    def <strong>inner_function</strong>():
        print("-" * 40)
        function()
        print("-" * 40)
&nbsp;
    return inner_function
&nbsp;
&nbsp;
def <strong>wrapper2</strong>(function):
    def <strong>inner_function</strong>():
        print("=" * 40)
        function()
        print("=" * 40)
&nbsp;
    return inner_function
&nbsp;
&nbsp;
@wrapper1
@wrapper2
def <strong>hello</strong>():
    print("Hello!")
&nbsp;
&nbsp;
hello()
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Praktické použití dekorátoru &ndash; měření doby trvání funkce označené dekorátorem</h2>

<p>V&nbsp;dnešním posledním demonstračním příkladu je ukázáno jedno
z&nbsp;možných praktických použití dekorátoru. Bude se jednat o dekorátor,
který nám umožní obalit nějakou funkci příkazy sloužícími pro měření doby
jejího trvání. Samotný algoritmus je přitom triviální: zapamatujeme si časové
razítko před spuštěním měřené funkce, měřenou funkci spustíme, vypočteme na
základě nového časového razítka dobu trvání měřené funkce, kterou vytiskneme a
nakonec vrátíme původní návratovou hodnotu z&nbsp;měřené funkce. Jedna
z&nbsp;nejjednodušších implementací tohoto algoritmu může vypadat
následovně:</p>

<pre>
<i># Original code:</i>
<i># https://pythonbasics.org/decorators/#Real-world-examples</i>
&nbsp;
&nbsp;
import time
&nbsp;
&nbsp;
def <strong>measure_time</strong>(func):
    def <strong>wrapper</strong>(*arg):
        t = time.time()
        res = func(*arg)
        print("Function took " + str(time.time() - t) + " seconds to run")
        return res
&nbsp;
    return wrapper
&nbsp;
&nbsp;
<u>@measure_time</u>
def <strong>tested_function</strong>(n):
    time.sleep(n)
&nbsp;
&nbsp;
tested_function(1)
tested_function(2)
</pre>

<p>Z&nbsp;výsledků získaných po spuštění tohoto skriptu vyplývá, že vše pracuje
podle předpokladů (naměřený čas bude pochopitelně poněkud delší než zvolená
jedna či dvě sekundy):</p>

<pre>
Function took 1.00141787529 seconds to run
Function took 2.00236320496 seconds to run
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny Pythonovské skripty, které jsme si ukázali
<a href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-pythonu-a-knihovna-functools/">předminule</a>,
<a href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-pythonu-a-knihovna-functools-2-cast/">minule</a>
i dnes, naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je nutné mít
nainstalovánu některou z&nbsp;podporovaných verzí Pythonu 3, žádné další
balíčky nejsou zapotřebí):</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>binary_operator.py</td><td>ukázka funkce vyššího řádu, která jako parametr akceptuje jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py</a></td></tr>
<tr><td> 2</td><td>get_operator_1.py</td><td>ukázka funkce vyššího řádu, která vrací jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py</a></td></tr>
<tr><td> 3</td><td>get_operator_2.py</td><td>ukázka funkce vyššího řádu, která vrací jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py</a></td></tr>
<tr><td> 4</td><td>standard_operators.py</td><td>použití standardních operátorů přepsaných do formy funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>binary_operator_types.py</td><td>varianta příkladu <strong>binary_operator.py</strong> s&nbsp;plnými typovými deklaracemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py</a></td></tr>
<tr><td> 6</td><td>get_operator_types.py</td><td>varianta příkladu <strong>get_operator_2.py</strong> s&nbsp;plnými typovými deklaracemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>map_1.py</td><td>příklad použití funkce <strong>map</strong>: výpočet délky všech slov v&nbsp;textu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py</a></td></tr>
<tr><td> 8</td><td>map_2.py</td><td>příklad použití funkce <strong>map</strong>: výpočet absolutní hodnoty všech členů posloupnosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py</a></td></tr>
<tr><td> 9</td><td>map_3.py</td><td>příklad použití funkce <strong>map</strong>: aplikace vlastní pojmenované funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_3.py</a></td></tr>
<tr><td>10</td><td>map_4.py</td><td>příklad použití funkce <strong>map</strong>: aplikace vlastního lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>map_list_comprehension_1.py</td><td>přepis skriptu <strong>map_1.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_1.py</a></td></tr>
<tr><td>12</td><td>map_list_comprehension_2.py</td><td>přepis skriptu <strong>map_2.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_2.py</a></td></tr>
<tr><td>13</td><td>map_list_comprehension_3.py</td><td>přepis skriptu <strong>map_3.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_3.py</a></td></tr>
<tr><td>14</td><td>map_list_comprehension_4.py</td><td>přepis skriptu <strong>map_4.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>filter_1.py</td><td>filtrace dat na základě délky řetězce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_1.py</a></td></tr>
<tr><td>16</td><td>filter_2.py</td><td>filtrace numerických dat podle toho, zda se jedná o sudá či lichá čísla</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_2.py</a></td></tr>
<tr><td>17</td><td>filter_3.py</td><td>přepis předchozího příkladu s&nbsp;využitím lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>filter_list_comprehension_1.py</td><td>přepis skriptu <strong>filter_list_comprehension_1.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_1.py</a></td></tr>
<tr><td>19</td><td>filter_list_comprehension_2.py</td><td>přepis skriptu <strong>filter_list_comprehension_2.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_2.py</a></td></tr>
<tr><td>20</td><td>filter_list_comprehension_3.py</td><td>přepis skriptu <strong>filter_list_comprehension_3.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>reduce_1.py</td><td>výpočet faktoriálu s&nbsp;využitím funkce vyššího řádu <strong>reduce</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_1.py</a></td></tr>
<tr><td>22</td><td>reduce_2.py</td><td>přepis předchozího příkladu s&nbsp;využitím lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_2.py</a></td></tr>
<tr><td>23</td><td>reduce_3.py</td><td>tisk tabulky faktoriálů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_3.py</a></td></tr>
<tr><td>24</td><td>reduce_4.py</td><td>přepis předchozího příkladu s&nbsp;využitím lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_4.py</a></td></tr>
<tr><td>25</td><td>reduce_5.py</td><td>přepis předchozího příkladu s&nbsp;využitím generátorové notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>return_function.py</td><td>funkce jako návratová hodnota jiné funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/return_function.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/return_function.py</a></td></tr>
<tr><td>27</td><td>closure_adder1.py</td><td>příklad použití uzávěru &ndash; konstrukce funkce typu <i>adder</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/closure_adder1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/closure_adder1.py</a></td></tr>
<tr><td>28</td><td>counter_closure_1.py</td><td>nekorektní implementace čítače s&nbsp;využitím uzávěrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_1.py</a></td></tr>
<tr><td>29</td><td>counter_closure_2.py</td><td>přístup k&nbsp;nelokálnímu symbolu (Python 2.x i Python 3.x)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_2.py</a></td></tr>
<tr><td>30</td><td>counter_closure_3.py</td><td>přístup k&nbsp;nelokálnímu symbolu (pouze Python 3.x)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>access_nonlocal_symbol.py</td><td>přístup k&nbsp;nelokálnímu symbolu v&nbsp;uzávěru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/access_nonlocal_symbol.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/access_nonlocal_symbol.py</a></td></tr>
<tr><td>32</td><td>functions_and_closures.py</td><td>funkce a uzávěry (umělý příklad)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/functions_and_closures.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/functions_and_closures.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>partial_1.py</td><td>funkce <strong>doubler</strong> odvozená (redukcí) z&nbsp;univerzálnější funkce <strong>mul</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_1.py</a></td></tr>
<tr><td>34</td><td>partial_2.py</td><td>transformace funkce se třemi parametry s&nbsp;využitím <strong>partial</strong> (nekorektní řešení)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_2.py</a></td></tr>
<tr><td>35</td><td>partial_3.py</td><td>transformace funkce se třemi parametry s&nbsp;využitím <strong>partial</strong> (korektní řešení)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_3.py</a></td></tr>
<tr><td>36</td><td>partial_4.py</td><td>transformace funkce s&nbsp;dosazením většího množství parametrů s&nbsp;využitím <strong>partial</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_4.py</a></td></tr>
<tr><td>37</td><td>partial_5.py</td><td>několikanásobná transformace původní funkce na několik nových funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_5.py</a></td></tr>
<tr><td>38</td><td>partial_6.py</td><td>postupná transformace již ztransformovaných funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_6.py</a></td></tr>
<tr><td>39</td><td>partial_7.py</td><td>typ originální funkce i funkcí získaných s&nbsp;využitím transformace pomocí <strong>partial</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_7.py</a></td></tr>
<tr><td>40</td><td>partial_8.py</td><td>jméno funkce, poziční argumenty funkce a pojmenované argumenty funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_8.py</a></td></tr>
<tr><td>41</td><td>partial_9.py</td><td>transformace <strong>reduce</strong> a pojmenované argumenty původní funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_9.py</a></td></tr>
<tr><td>42</td><td>partial_A.py</td><td>získání informací o redukované funkci s&nbsp;pojmenovanými argumenty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_A.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>partial_method_1.py</td><td>třída s&nbsp;metodou s&nbsp;parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_method_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_method_1.py</a></td></tr>
<tr><td>44</td><td>partial_method_2.py</td><td>třída s&nbsp;metodou s&nbsp;parametry &ndash; vliv volání setteru na stav objektu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_method_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_method_2.py</a></td></tr>
<tr><td>45</td><td>partial_method_3.py</td><td>metody <strong>enable</strong> a <strong>disable</strong> vzniklé transformací <strong>set_enabled</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_method_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_method_3.py</a></td></tr>
<tr><td>46</td><td>partial_method_4.py</td><td>další příklad použití funkce <strong>partialmethod</strong> &ndash; doplnění většího množství parametrů při transformaci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_method_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_method_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>47</td><td>lru_cache_1.py</td><td>klasický výpočet Fibonacciho posloupnosti rekurzivní funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/lru_cache_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/lru_cache_1.py</a></td></tr>
<tr><td>48</td><td>lru_cache_2.py</td><td>LRU cache pro výsledky Fibonacciho posloupnosti pro nejčastěji použité vstupy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/lru_cache_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/lru_cache_2.py</a></td></tr>
<tr><td>49</td><td>lru_cache_3.py</td><td>přečtení informací o využití LRU cache</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/lru_cache_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/lru_cache_3.py</a></td></tr>
<tr><td>50</td><td>lru_cache_4.py</td><td>programové vymazání LRU cache</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/lru_cache_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/lru_cache_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>51</td><td>cached_property_1.py</td><td>použití standardního dekorátoru <strong>@property</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/cached_property_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/cached_property_1.py</a></td></tr>
<tr><td>52</td><td>cached_property_2.py</td><td>použití dekorátoru <strong>@cached_property</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/cached_property_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/cached_property_2.py</a></td></tr>
<tr><td>53</td><td>cached_property_3.py</td><td>úprava předchozího příkladu tak, aby se využila LRU cache</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/cached_property_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/cached_property_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>total_ordering.py</td><td>příklad implementace relačních operátorů založených na dekorátoru <strong>@total_ordering</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/total_ordering.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/total_ordering.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>55</td><td>decorators_2.py</td><td>příklad použití jednoho dekorátoru aplikovaného na funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/decorators_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/decorators_2.py</a></td></tr>
<tr><td>56</td><td>decorators_3.py</td><td>příklad použití dvou dekorátorů aplikovaných na funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/decorators_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/decorators_3.py</a></td></tr>
<tr><td>57</td><td>measure_time.py</td><td>praktické použití dekorátoru &ndash; měření doby trvání funkce označené dekorátorem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/measure_time.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/measure_time.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>functools — Higher-order functions and operations on callable objects<br />
<a href="https://docs.python.org/3/library/functools.html">https://docs.python.org/3/library/functools.html</a>
</li>

<li>Functional Programming HOWTO<br />
<a href="https://docs.python.org/3/howto/functional.html">https://docs.python.org/3/howto/functional.html</a>
</li>

<li>Functional Programming in Python: When and How to Use It<br />
<a href="https://realpython.com/python-functional-programming/">https://realpython.com/python-functional-programming/</a>
</li>

<li>Functional Programming With Python<br />
<a href="https://realpython.com/learning-paths/functional-programming/">https://realpython.com/learning-paths/functional-programming/</a>
</li>

<li>Awesome Functional Python<br />
<a href="https://github.com/sfermigier/awesome-functional-python">https://github.com/sfermigier/awesome-functional-python</a>
</li>

<li>Currying<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying in Python &ndash; A Beginner’s Introduction<br />
<a href="https://www.askpython.com/python/examples/currying-in-python">https://www.askpython.com/python/examples/currying-in-python</a>
</li>

<li>Fundamental Concepts in Programming Languages<br />
<a href="https://en.wikipedia.org/wiki/Fundamental_Concepts_in_Programming_Languages">https://en.wikipedia.org/wiki/Fundamental_Concepts_in_Programming_Languages</a>
</li>

<li>When should I use function currying?<br />
<a href="https://stackoverflow.com/questions/24881604/when-should-i-use-function-currying">https://stackoverflow.com/questions/24881604/when-should-i-use-function-currying</a>
</li>

<li>Toolz<br />
<a href="https://github.com/pytoolz/toolz/tree/master">https://github.com/pytoolz/toolz/tree/master</a>
</li>

<li>Coconut: funkcionální jazyk s pattern matchingem kompatibilní s&nbsp;Pythonem<br />
<a href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/</a>
</li>

<li>A HITCHHIKER'S GUIDE TO functools<br />
<a href="https://ep2021.europython.eu/media/conference/slides/a-hitchhikers-guide-to-functools.pdf">https://ep2021.europython.eu/media/conference/slides/a-hitchhikers-guide-to-functools.pdf</a>
</li>

<li>Coconut aneb funkcionální nadstavba nad Pythonem (2.část)<br />
<a href="https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/">https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/</a>
</li>

<li>Knihovny pro zpracování posloupností (sekvencí) v&nbsp;Pythonu<br />
<a href="https://www.root.cz/clanky/knihovny-pro-zpracovani-posloupnosti-sekvenci-v-pythonu/">https://www.root.cz/clanky/knihovny-pro-zpracovani-posloupnosti-sekvenci-v-pythonu/</a>
</li>

<li>clj - repositář s knihovnou<br />
<a href="https://github.com/bfontaine/clj">https://github.com/bfontaine/clj</a>
</li>

<li>clj 0.1.0 &ndash; stránka na PyPi<br />
<a href="https://pypi.python.org/pypi/clj/0.1.0">https://pypi.python.org/pypi/clj/0.1.0</a>
</li>

<li>Coconut: Simple, elegant, Pythonic functional programming<br />
<a href="http://coconut-lang.org/">http://coconut-lang.org/</a>
</li>

<li>coconut (Python package index)<br />
<a href="https://pypi.python.org/pypi/coconut/">https://pypi.python.org/pypi/coconut/</a>
</li>

<li>Coconut Tutorial<br />
<a href="http://coconut.readthedocs.io/en/master/HELP.html">http://coconut.readthedocs.io/en/master/HELP.html</a>
</li>

<li>Coconut FAQ<br />
<a href="http://coconut.readthedocs.io/en/master/FAQ.html">http://coconut.readthedocs.io/en/master/FAQ.html</a>
</li>

<li>Coconut Documentation<br />
<a href="http://coconut.readthedocs.io/en/master/DOCS.html">http://coconut.readthedocs.io/en/master/DOCS.html</a>
</li>

<li>Coconut na Redditu<br />
<a href="https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/">https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/</a>
</li>

<li>Repositář na GitHubu<br />
<a href="https://github.com/evhub/coconut">https://github.com/evhub/coconut</a>
</li>

<li>Object-Oriented Programming — The Trillion Dollar Disaster<br />
<a href="https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7</a>
</li>

<li>Goodbye, Object Oriented Programming<br />
<a href="https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53">https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53</a>
</li>

<li>So You Want to be a Functional Programmer (Part 1)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536</a>
</li>

<li>So You Want to be a Functional Programmer (Part 2)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 3)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7</a>
</li>

<li>So You Want to be a Functional Programmer (Part 4)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49</a>
</li>

<li>So You Want to be a Functional Programmer (Part 5)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 6)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403</a>
</li>

<li>Why Programmers Need Limits<br />
<a href="https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db">https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db</a>
</li>

<li>Infographic showing code complexity vs developer experience<br />
<a href="https://twitter.com/rossipedia/status/1580639227313676288">https://twitter.com/rossipedia/status/1580639227313676288</a>
</li>

<li>Python's reduce(): From Functional to Pythonic Style<br />
<a href="https://realpython.com/python-reduce-function/">https://realpython.com/python-reduce-function/</a>
</li>

<li>What is the problem with reduce()?<br />
<a href="https://stackoverflow.com/questions/181543/what-is-the-problem-with-reduce">https://stackoverflow.com/questions/181543/what-is-the-problem-with-reduce</a>
</li>

<li>The fate of reduce() in Python 3000<br />
<a href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196">https://www.artima.com/weblogs/viewpost.jsp?thread=98196</a>
</li>

<li>Reading 16: Map, Filter, Reduce<br />
<a href="http://web.mit.edu/6.031/www/sp22/classes/16-map-filter-reduce/">http://web.mit.edu/6.031/www/sp22/classes/16-map-filter-reduce/</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Používání funkcí v&nbsp;F#<br />
<a href="https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions">https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions</a>
</li>

<li>Funkce vyššího řádu<br />
<a href="http://naucte-se.haskell.cz/funkce-vyssiho-radu">http://naucte-se.haskell.cz/funkce-vyssiho-radu</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

<li>ML &ndash; funkcionální jazyk s revolučním typovým systémem<br />
<a href="https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/">https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/</a>
</li>

<li>Funkce a typový systém programovacího jazyka ML<br />
<a href="https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/">https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/</a>
</li>

<li>Curryfikace (currying), výjimky a vlastní operátory v jazyku ML<br />
<a href="https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/">https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/</a>
</li>

<li>Primer on Python Decorators<br />
<a href="https://realpython.com/primer-on-python-decorators/">https://realpython.com/primer-on-python-decorators/</a>
</li>

<li>Python Decorators<br />
<a href="https://www.programiz.com/python-programming/decorator">https://www.programiz.com/python-programming/decorator</a>
</li>

<li>PythonDecorators (Python Wiki)<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

