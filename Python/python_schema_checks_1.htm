<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Při vývoji aplikací se mnohdy dostaneme do situace, kdy je nutné validovat datové struktury získávané například ze služeb dostupných přes REST API, z dokumentových databází apod. V Pythonu lze pro validaci těchto mnohdy velmi složitých struktur použít knihovny Schemagic a Schema.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Validace datových struktur v&nbsp;Pythonu pomocí knihoven Schemagic a Schema</a></p>
<p><a href="#k02">2. Základní informace o knihovně Schemagic</a></p>
<p><a href="#k03">3. Vytvoření projektu využívajícího knihovnu Schemagic</a></p>
<p><a href="#k04">4. Popis jednotlivých řádků testu</a></p>
<p><a href="#k05">5. Výsledky validace provedené první verzí testů</a></p>
<p><a href="#k06">6. Automatické konverze prováděné v&nbsp;průběhu validace</a></p>
<p><a href="#k07">7. Vytvoření vlastních validačních funkcí</a></p>
<p><a href="#k08">8. Výsledky třetí verze testů</a></p>
<p><a href="#k09">9. Další vylepšení validačních funkcí</a></p>
<p><a href="#k10">10. Výsledky čtvrté verze testů</a></p>
<p><a href="#k11">11. Validace map (slovníků)</a></p>
<p><a href="#k12">12. Výsledky páté verze testů</a></p>
<p><a href="#k13">13. Přesnější validace map &ndash; kontrola, zda hodnoty odpovídají zadaným kritériím</a></p>
<p><a href="#k14">14. Základní informace o knihovně Schema</a></p>
<p><a href="#k15">15. Instalace knihovny Schema</a></p>
<p><a href="#k16">16. Jednoduchý příklad použití knihovny Schema pro validaci datových struktur</a></p>
<p><a href="#k17">17. Validace obsahu slovníků</a></p>
<p><a href="#k18">18. Druhý příklad používající knihovnu Schema</a></p>
<p><a href="#k19">19. Výsledek druhého příkladu</a></p>
<p><a href="#k20">20. Repositář se všemi demonstračními příklady</a></p>
<p><a href="#k21">21. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Validace datových struktur v&nbsp;Pythonu pomocí knihoven Schemagic a Schema</h2>

<p>V&nbsp;dnešním článku si popíšeme některé (prozatím základní) možnosti
knihoven pojmenovaných <i>Schemagic</i> a <i>Schema</i>. Jedná se o knihovny
vytvořené pro ty programátory, kteří používají jazyk Python. Úkolem těchto
knihoven je validace prakticky libovolně komplikovaných datových struktur, a to
na základě programátorem definovaného schématu. Samotné schéma definované
uživatelem (přesněji řečeno programátorem) má dvě úlohy:</p>

<ol>
<li>Samozřejmě umožňuje samotnou validaci (musíme vědět, jak mají data vypadat)</li>
<li>Současně strukturu dat dokumentuje, a to rigidním způsobem</li>
</ol>

<p>Validaci dat je možné využít v&nbsp;mnoha oblastech. Představme si například
dokumentovou databázi, složitý konfigurační soubor nebo asi nejlépe klasickou
webovou službu, která přijme data ve formátu JSON, převede je knihovní funkcí
do nativní datové struktury (typicky do slovníku seznamů či hierarchicky
uspořádaných slovníků) a následně provede validaci této struktury, ovšem nikoli
programově (testováním jednotlivých atributů), ale na základě deklarativního
popisu této struktury. Například můžeme specifikovat, že v&nbsp;atributu
nazvaném &bdquo;price&ldquo; by mělo být uloženo nezáporné číslo menší než
100000, v&nbsp;atributu pojmenovaném &bdquo;valid_from&ldquo; musí být uložen
řetězec odpovídající skutečnému datu (to už nelze otestovat primitivním
regulárním výrazem, ale složitějším predikátem) a v&nbsp;atributu
&bdquo;login&ldquo; bude buď nick uživatele nebo bude tento atribut obsahovat
<strong>null/None</strong> (popř.&nbsp;alternativně nebude existovat
vůbec).</p>

<p>V&nbsp;případě formátu JSON je samozřejmě možné validaci provádět už nad
vstupními daty přes <a href="http://json-schema.org/">JSON Schema</a>, dtto při
použití jazyka XML pomocí <a
href="https://en.wikipedia.org/wiki/XML_Schema_(W3C)">XML Schema</a> (a dalších
podobných nástrojů), ovšem možnosti těchto nástrojů jsou omezené &ndash; stále
se totiž jedná &bdquo;pouze&ldquo; o DSL, v&nbsp;nichž se složitější kritéria
zapisují velmi složitě a většinou i nečitelně.</p>

<p><div class="rs-tip-major">Poznámka: způsobem validace datových struktur jsme
se již na stránkách Rootu zabývali, a to konkrétně ve dvojici článků <a
href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">Validace
dat s využitím knihovny spec v Clojure 1.9.0</a> a <a
href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0-dokonceni/">Validace
dat s využitím knihovny spec v Clojure 1.9.0 (dokončení)</a>. Tyto články byly
zaměřeny na popis knihovny <strong>spec</strong> určené pro programovací jazyk
Clojure. Dnes se zaměříme výhradně na knihovny použitelné <a
href="https://www.root.cz/n/python/">v&nbsp;programovacím jazyku
Python</a>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní informace o knihovně Schemagic</h2>

<p>První knihovnou určenou pro validaci datových struktur v&nbsp;Pythonu,
kterou si v&nbsp;dnešním článku alespoň ve stručnosti popíšeme, je knihovna
nazvaná <i>Schemagic</i> (název vznikl spojením dvou slov <i>schema</i> +
<i>magic</i>). Tato knihovna je samozřejmě k&nbsp;dispozici <a
href="https://pypi.python.org/pypi/schemagic/0.9.1">ve formě balíčku pro
<strong>pip</strong></a> a její zdrojové kódy naleznete na GitHubu, konkrétně
na adrese <a
href="https://github.com/Mechrophile/schemagic">https://github.com/Mechrophile/schemagic</a>.
Tato knihovna byla inspirována modulem <i>Schema</i> určeným pro programovací
jazyk Clojure, ale nemusíte se bát, že by se při deklaraci schémat či při
validaci nepoužívaly idiomy rozšířené v&nbsp;Pythonu &ndash; <i>Schema</i> byla
jen inspirací, nejedná se o přímou konverzi. Podobně, jako je tomu i u dalších
podobně koncipovaných knihoven, je <i>Schemagic</i> založena na deklaraci
takzvaného schématu, které popisuje, jak má vypadat datová struktura, která je
validována.</p>

<p>Důležité je, že pro zápis schématu se nepoužívá žádný specializovaný <a
href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> (jak je
tomu v&nbsp;případě JSONu či XML), ale běžný zdrojový kód naprogramovaný
v&nbsp;Pythonu, což s&nbsp;sebou přináší některé příjemné stránky (velmi dobrá
podpora v&nbsp;programátorských editorech, integrovaných vývojových
prostředích, linterech, minimální doba zaučení atd.), ale i zápory (napadá mě
prozatímní neexistence nástroje pro vygenerování nápovědy popř.&nbsp;pro
konverzi schématu do jiného jazyka).</p>

<p>Ve skutečnosti však knihovna <i>Schemagic</i> neprovádí pouhou validaci dat
s&nbsp;výsledkem &bdquo;validní&ldquo;/&bdquo;nevalidní&ldquo;, ale současně
umožňuje data konvertovat či dokonce do určité míry transformovat. Je tomu tak
z&nbsp;toho důvodu, že se v&nbsp;připravených schématech nepoužívají klasické
predikáty, ale konverzní funkce, které pro validní vstup provedou konverzi a
pro vstup nevalidní typicky vyhodí výjimku typu <strong>ValueError</strong>,
<strong>TypeError</strong> atd. (může se však jednat i o další typy
výjimek).</p>

<p>Podívejme se na příklad validace &ndash; otestujeme, zda je hodnota 42 celým
číslem (což evidentně je):</p>

<pre>
&gt;&gt;&gt; from schemagic import validate_against_schema
&gt;&gt;&gt; validate_against_schema(<strong>int</strong>, 42)
42
</pre>

<p>Jak jsme si již řekli v&nbsp;předchozím textu, je validace prováděna
s&nbsp;konverzí, takže v&nbsp;následujícím příkladu se celočíselná hodnota 42
převede na číslo <a
href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/">s&nbsp;plovoucí
řádovou čárkou</a>:</p>

<pre>
&gt;&gt;&gt; validate_against_schema(<strong>float</strong>, 42)
42.0
</pre>

<p>Podobně je možné zvalidovat, zda je řetězec "42" parsovatelný na hodnotu
s&nbsp;plovoucí řádovou čárkou:</p>

<pre>
&gt;&gt;&gt; validate_against_schema(float, "42")
42.0
</pre>

<p><div class="rs-tip-major">Poznámka: prováděné konverze mohou být samozřejmě
mnohem složitější, což si ukážeme na příkladu slovníků.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vytvoření projektu využívajícího knihovnu Schemagic</h2>

<p>Nejprve si ukažme, jak by mohl vypadat <a
href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-1">velmi
jednoduchý projekt</a>, který bude pro validaci dat využívat knihovnu
<i>Schemagic</i>. Struktura tohoto projektu bude prozatím triviální, neboť se
bude jednat o pouhé tři soubory:</p>

<ul>
<li>requirements.txt</li>
<li>run.sh</li>
<li>schemagic_test.py</li>
</ul>

<p>Nejstručnější je soubor nazvaný <strong>requirements.txt</strong> [<a
href="https://pip.readthedocs.io/en/1.1/requirements.html">1</a>], neboť ten
obsahuje seznam knihoven, na nichž běh projektu závisí. V&nbsp;našem případě
projekt závisí pouze na jediné knihovně, takže obsah souboru bude
následující:</p>

<pre>
schemagic
</pre>

<p>Druhý soubor, který se jmenuje <strong>run.sh</strong>, bude sloužit pro
spuštění testu. Pokud není nastavena proměnná prostředí
<strong>NOVENV</strong>, nastaví se <a
href="https://realpython.com/python-virtual-environments-a-primer/">virtuální
prostředí Pythonu</a>, do něhož se nainstaluje knihovna <i>Schemagic</i>. Díky
tomu, že se instalace provádí do virtuálního prostředí, není ovlivněna globální
konfigurace systému a uživatel, který skript spouští, ani nemusí mít práva
roota. Pokud naopak nastavíte proměnnou prostředí <strong>NOVENV</strong>,
očekává se, že je knihovna <i>Schemagic</i> již nainstalována pomocí příkazu
<strong>pip3 install schemagic</strong> popř.&nbsp;ještě lépe pomocí příkazu
<strong>pip3 install --user schemagic</strong>:</p>

<pre>
#! /bin/bash
&nbsp;
echo "Create Virtualenv for Python deps ..."
function prepare_venv() {
    VIRTUALENV=`which virtualenv`
    if [ $? -eq 1 ]; then
        # python34 which is in CentOS does not have virtualenv binary
        VIRTUALENV=`which virtualenv-3`
    fi
&nbsp;
    ${VIRTUALENV} -p python3 venv &amp;&amp; source venv/bin/activate &amp;&amp; python3 `which pip3` install -r requirements.txt
}
&nbsp;
[ "$NOVENV" == "1" ] || prepare_venv || exit 1
python schemagic_test.py
</pre>

<p>Při prvním spuštění tohoto skriptu by se mělo inicializovat virtuální
prostředí Pythonu s&nbsp;přibližně následujícím výsledkem (povšimněte si toho,
že je knihovna Schemagic skutečně nainstalována na základě obsahu souboru
<strong>requirements.txt</strong> se seznamem potřebných knihoven a
balíčků):</p>

<pre>
Create Virtualenv for Python deps ...
Running virtualenv with interpreter /usr/bin/python3
Using base prefix '/usr'
New python executable in /home/tester/temp/schemagic/schemagic1/venv/bin/python3
Also creating executable in /home/tester/temp/schemagic/schemagic1/venv/bin/python
Installing setuptools, pip, wheel...done.
Collecting schemagic (from -r <strong>requirements.txt</strong> (line 1))
  Downloading <strong>schemagic-0.9.1-py2.py3-none-any.whl</strong>
Installing collected packages: <strong>schemagic</strong>
Successfully installed <strong>schemagic-0.9.1</strong>
</pre>

<p>Samotný test uložený v&nbsp;souboru <strong>schemagic_test.py</strong> bude
vypadat následovně:</p>

<pre>
import sys
import traceback
from schemagic import validate_against_schema
&nbsp;
&nbsp;
def validate(schema, data):
    try:
        print("\n\n")
        print(schema)
        print(data)
        validate_against_schema(schema, data)
        print("pass")
    except ValueError as e:
        print(e)
        traceback.print_exc(file=sys.stdout)
&nbsp;
&nbsp;
integer_list = [int]
string_list = [str]
&nbsp;
validate(integer_list, [])
validate(integer_list, [1, 2, 3])
validate(integer_list, ["hello", "world", "!"])
&nbsp;
validate(string_list, [])
validate(string_list, [1, 2, 3, 4])
validate(string_list, ["hello", "world", "!"])
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Popis jednotlivých řádků testu</h2>

<p>Celý skript s&nbsp;testem si nyní podrobněji popíšeme. Nejprve jsou
provedeny všechny potřebné importy, zejména pak import funkce nazvané
<strong>validate_against_schema</strong> z&nbsp;modulu pojmenovaného
<strong>schemagic</strong> (později budeme potřebovat naimportovat i další
funkce, nyní to však není nutné). Ostatní dva importované moduly jsou použity
pro zpracování výjimek, které při validaci nastanou:</p>

<pre>
import sys
import traceback
from schemagic import validate_against_schema
</pre>

<p>Následně je v&nbsp;testu definována funkce nazvaná
<strong>validate</strong>, které se předává validační schéma a taktéž data,
která mají být oproti schématu validována. Uvnitř této funkce se volá
<strong>validate_against_schema</strong> a očekává se, že pokud validace
neproběhne v&nbsp;pořádku, vyhodí tato funkce výjimku typu
<strong>ValueError</strong> (opět platí, že později budeme muset reagovat i na
některé další typy výjimek):</p>

<pre>
def validate(schema, data):
    try:
        print("\n\n")
        print(schema)
        print(data)
        <strong>validate_against_schema(schema, data)</strong>
        print("pass")
    except ValueError as e:
        print(e)
        traceback.print_exc(file=sys.stdout)
</pre>

<p>Na navazujících řádcích jsou vytvořena dvě schémata popisující seznam
celočíselných hodnot a seznam řetězců. Povšimněte si, že samotné schéma
v&nbsp;tomto případě vypadá jednoduše &ndash; jedná se o specifikaci
konverzních funkcí uložených v&nbsp;seznamu. Pozor &ndash; skutečně se
v&nbsp;případě <strong>int</strong> a <strong>str</strong> jedná o běžné
konverzní funkce, nikoli i specifikaci datových typů (knihovna <i>Schema</i>
popsaná níže v&nbsp;tomto případě pracuje odlišně):</p>

<pre>
integer_list = <strong>[int]</strong>
string_list = <strong>[str]</strong>
</pre>

<p>A konečně se budeme snažit validovat seznamy s&nbsp;různými hodnotami oproti
oběma schématům:</p>

<pre>
validate(integer_list, [])
validate(integer_list, [1, 2, 3])
validate(integer_list, ["hello", "world", "!"])
&nbsp;
validate(string_list, [])
validate(string_list, [1, 2, 3, 4])
validate(string_list, ["hello", "world", "!"])
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výsledky validace provedené první verzí testů</h2>

<p>Podívejme se nyní na <a
href="https://github.com/tisnik/python-schema-checks/blob/master/schemagic-demo-1/expected_output.txt">výsledky
validace</a>, která byla provedena první verzí testů. Samotnou validaci
spustíme již <a href="#k03">výše popsaným</a> skriptem nazvaným
<strong>run.sh</strong>.</p>

<p>Na začátku můžeme vidět průběh inicializace virtuálního prostředí Pythonu,
což není v&nbsp;kontextu tohoto článku příliš zajímavé:</p>

<pre>
Create Virtualenv for Python deps ...
Using base prefix '/usr'
New python executable in /home/tester/temp/schemagic/schemagic1/venv/bin/python3
Not overwriting existing python script /home/tester/temp/schemagic/schemagic1/venv/bin/python (you must use /home/tester/temp/schemagic/schemagic1/venv/bin/python3)
Installing setuptools, pip, wheel...done.
Running virtualenv with interpreter /usr/bin/python3
Requirement already satisfied: schemagic in ./venv/lib/python3.6/site-packages (from -r requirements.txt (line 1))
</pre>

<p>Validace prázdného seznamu proti schématu očekávajícího seznam celých čísel
proběhne v&nbsp;pořádku (jinými slovy &ndash; žádný prvek prázdného seznamu se
neliší od čísla :-):</p>

<pre>
[&lt;class 'int'&gt;]
[]
pass
</pre>

<p>Další validace, tentokrát skutečně seznamu se třemi čísly, podle očekávání
proběhne taktéž korektně (nedojde k&nbsp;výjimce):</p>

<pre>
[&lt;class 'int'&gt;]
[1, 2, 3]
pass
</pre>

<p>Třetí test skončí s&nbsp;chybou (vyhodí a ihned poté se zachytí výjimka), a
to hned u prvního prvku. Povšimněte si přitom, jak vypadá chybové hlášení
&ndash; chyba vznikla při aplikaci funkce <strong>int</strong> na řetězec:</p>

<pre>
[&lt;class 'int'&gt;]
['hello', 'world', '!']
<strong>invalid literal for int() with base 10: 'hello'</strong>
Traceback (most recent call last):
  File "schemagic_test.py", line 11, in validate
    validate_against_schema(schema, data)
  File "/home/tester/temp/schemagic/schemagic1/venv/lib/python3.6/site-packages/schemagic/core.py", line 81, in &lt;lambda&gt;
    validate_against_schema = lambda schema, value: _validate_against_schema(schema, value)
  File "/home/tester/temp/schemagic/schemagic1/venv/lib/python3.6/site-packages/schemagic/utils.py", line 67, in _fn
    return dispatch_fn(*args, **kwargs)
  File "/home/tester/temp/schemagic/schemagic1/venv/lib/python3.6/site-packages/schemagic/core.py", line 51, in validate_sequence_template
    return list(map(validate_against_schema, itertools.repeat(schema[0], len(value)), value))
  File "/home/tester/temp/schemagic/schemagic1/venv/lib/python3.6/site-packages/schemagic/core.py", line 81, in &lt;lambda&gt;
    validate_against_schema = lambda schema, value: _validate_against_schema(schema, value)
  File "/home/tester/temp/schemagic/schemagic1/venv/lib/python3.6/site-packages/schemagic/utils.py", line 67, in _fn
    return dispatch_fn(*args, **kwargs)
  File "/home/tester/temp/schemagic/schemagic1/venv/lib/python3.6/site-packages/schemagic/core.py", line 80, in &lt;lambda&gt;
    default=lambda schema, value: schema(value))
ValueError: invalid literal for int() with base 10: 'hello'
</pre>

<p>Následuje trojice validačních testů používajících jako schéma seznam
řetězců. První test s&nbsp;prázdným seznamem na vstupu doběhne korektně,
podobně jako tomu bylo u předchozí trojice testů:</p>

<pre>
[&lt;class 'str'&gt;]
[]
pass
</pre>

<p>Další test ovšem vrátí na první pohled možná trošku neočekávané výsledky,
protože vstupní seznam [1, 2, 3] je korektně zvalidován, i když 1, 2 ani 3
evidentně nejsou hodnoty typu řetězec, ale hodnoty typu celé číslo. Proč tomu
tak je? Celá validace probíhá tak, že se na prvky seznamu postupně aplikuje
funkce specifikovaná ve schématu (zde konkrétně funkce <strong>str</strong>) a
tato funkce v&nbsp;Pythonu není predikátem, zde je hodnota řetězcem, ale jedná
se o funkci konverzní (více viz navazující kapitoly):</p>

<pre>
[&lt;class 'str'&gt;]
[1, 2, 3, 4]
pass
</pre>

<p>Třetí test podle očekávání proběhne korektně, neboť funkci
<strong>str</strong> samozřejmě lze aplikovat na řetězec (výsledkem je přitom
totožný objekt, tj.&nbsp;žádná konverze se ve skutečnosti ani neprovede &ndash;
to je výhodné z&nbsp;výkonnostního hlediska):</p>

<pre>
[&lt;class 'str'&gt;]
['hello', 'world', '!']
pass
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Automatické konverze prováděné v&nbsp;průběhu validace</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vytvoření vlastních validačních funkcí</h2>

<p>Zkusme si nyní vytvořit vlastní validační funkce. <a
href="https://github.com/tisnik/python-schema-checks/blob/master/schemagic-demo-3/schemagic_test.py">Skript
s&nbsp;testy</a> začne stejně, jako v&nbsp;předchozích dvou příkladech,
tj.&nbsp;importem potřebných modulů a definicí uživatelské funkce
<strong>validate</strong>:</p>

<pre>
import sys
import traceback
from schemagic import validate_against_schema
&nbsp;
&nbsp;
def validate(schema, data):
    try:
        print("\n\n")
        print(schema)
        print(data)
        print(validate_against_schema(schema, data))
        print("pass")
    except (ValueError, TypeError, AssertionError) as e:
        print(e)
        traceback.print_exc(file=sys.stdout)
</pre>

<p><div class="rs-tip-major">Povšimněte si, že nyní musíme zachytit výjimky
typu <strong>ValueError</strong>, <strong>TypeError</strong> a navíc i
<strong>AssertionError</strong>. Důvod je patrný níže.</div></p>

<p>Následuje definice funkce, která zjistí, zda má hodnota předaná do této
funkce očekávaný datový typ. Pokud tomu tak není, je vyhozena výjimka
<strong>AssertionError</strong>:</p>

<pre>
def <strong>is_type</strong>(value, expected_type):
    assert type(value) is expected_type
</pre>

<p>Funkci pro zjištění datového typu využijeme v&nbsp;dalších dvou
uživatelských funkcích, které v&nbsp;dalších krocích použijeme při deklaraci
schématu:</p>

<pre>
def <strong>is_int</strong>(value):
    is_type(value, int)
&nbsp;
&nbsp;
def <strong>is_float</strong>(value):
    is_type(value, float)
</pre>

<p>Nyní již můžeme naše funkce použít ve schématech:</p>

<pre>
integer_list = [<strong>is_int</strong>]
float_list = [<strong>is_float</strong>]
</pre>

<p>Ve skutečnosti samozřejmě nemusíme explicitně deklarovat pojmenované funkce,
ale můžeme použít funkce anonymní (což vede ke kratšímu, ale poněkud méně
čitelnému zápisu):</p>

<pre>
string_list = [<strong>lambda x: is_type(x, str)</strong>]
</pre>

<p>Nově definovaná schémata lze snadno otestovat, například následujícím
způsobem:</p>

<pre>
validate(integer_list, [1, 2, 3])
validate(integer_list, ["hello", "world", "!"])
validate(integer_list, ["1", 1.5])
&nbsp;
validate(float_list, [1, 2, 3])
validate(float_list, ["hello", "world", "!"])
validate(float_list, ["1", 1.5, "3.1415"])
následovně
validate(string_list, [1, 2, 3, 4])
validate(string_list, ["hello", "world", "!"])
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výsledky třetí verze testů</h2>

<p>Podívejme se nyní na výsledky třetí varianty testů. Povšimněte si především
faktu, že uživatelsky definované validační funkce nevrací žádnou hodnotu, takže
výsledkem úspěšné validace bude vždy seznam obsahující prvky
<strong>None</strong>:</p>

<pre>
[&lt;function is_int at 0x7fe523de6c80&gt;]
[1, 2, 3]
[None, None, None]
pass
</pre>

<p>Nekorektní vstup:</p>




<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výsledky páté verze testů</h2>

<p>Z&nbsp;výsledků testů je patrné, že pouze první a poslední slovník obsahuje
korektní data. U posledního slovníku je tomu tak z&nbsp;toho důvodu, že se
celočíselné hodnoty zkonvertují na řetězec funkcí <strong>str</strong>:</p>

<pre>
{&lt;class 'str'&gt;: &lt;function is_int at 0x7f274d98bc80&gt;}
{'prvni': 1, 'druha': 2, 'treti': 3}
{'prvni': None, 'druha': None, 'treti': None}
pass
&nbsp;
&nbsp;
&nbsp;
{&lt;class 'str'&gt;: &lt;function is_int at 0x7f274d98bc80&gt;}
{'prvni': 1.5, 'druha': '2', 'treti': 3}
Expected type: &lt;class 'int'&gt;, but the value has type &lt;class 'float'&gt;
&nbsp;
&nbsp;
&nbsp;
{&lt;class 'str'&gt;: &lt;function is_int at 0x7f274d98bc80&gt;}
{'prvni': 'x', 'druha': 'y', 'treti': 'z'}
Expected type: &lt;class 'int'&gt;, but the value has type &lt;class 'str'&gt;
&nbsp;
&nbsp;
&nbsp;
{&lt;class 'str'&gt;: &lt;function is_int at 0x7f7fa9bccbf8&gt;}
{1: 'x', 2: 'y', 3: 'z'}
Expected type: &lt;class 'int'&gt;, but the value has type &lt;class 'str'&gt;
&nbsp;
&nbsp;
&nbsp;
{&lt;class 'str'&gt;: &lt;function is_int at 0x7f7fa9bccbf8&gt;}
{1: 1, 2: 2, 3: 3}
pass
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přesnější validace map &ndash; kontrola, zda hodnoty odpovídají zadaným kritériím</h2>

<p>Ukažme si ještě <a
href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-6">poslední
příklad</a> demonstrující možnosti knihovny <i>Schemagic</i>. V&nbsp;tomto
příkladu jsou definovány dvě uživatelské validační funkce. Jedna slouží pro
kontrolu, zda zadaná hodnota odpovídá jménu či příjmení (používáme zde velmi
jednoduchý regulární výraz, ten ovšem nemusí být platný pro všechna
příjmení):</p>

<pre>
def name_str(value):
    if not re.fullmatch("[A-Z][a-z]+", value):
        msg = "Proper name expected, but got '{value}' instead".format(value=value)
        raise TypeError(msg)
</pre>

<p>Druhá funkce otestuje, zda je hodnota celočíselná a současně kladná:</p>

<pre>
def pos_int(value):
    is_type(value, int)
    if value &lt;= 0:
        msg = "Positive number expected, but got {value} instead".format(value=value)
        raise TypeError(msg)
</pre>

<p>Tyto dvě validační funkce použijeme v&nbsp;následujícím schématu:</p>

<pre>
user = {"name": name_str,
        "surname": name_str,
        "id": pos_int}
</pre>

<p>Toto schéma říká, že prvky slovníku musí být tři, jejich klíče musí znít
&bdquo;name&ldquo;, &bdquo;surname&ldquo; a &bdquo;id&ldquo; a konečně jakého
typu mají být hodnoty uložené pod těmito klíči.</p>

<p>Nezbývá, než si popsané funkce i schéma zabudovat do skriptu
s&nbsp;testem:</p>

<pre>
import sys
import traceback
import re
from schemagic import validate_against_schema
&nbsp;
&nbsp;
def validate(schema, data):
    try:
        print("\n\n")
        print(schema)
        print(data)
        print(validate_against_schema(schema, data))
        print("pass")
    except (ValueError, TypeError) as e:
        print(e)
&nbsp;
&nbsp;
def is_type(value, expected_type):
    actual_type = type(value)
    if actual_type is not expected_type:
        msg = "Expected type: {expected}, but the value has type {actual}".format(
            expected=expected_type, actual=actual_type)
        raise TypeError(msg)
&nbsp;
&nbsp;
def name_str(value):
    if not re.fullmatch("[A-Z][a-z]+", value):
        msg = "Proper name expected, but got '{value}' instead".format(value=value)
        raise TypeError(msg)
&nbsp;
&nbsp;
def pos_int(value):
    is_type(value, int)
    if value &lt;= 0:
        msg = "Positive number expected, but got {value} instead".format(value=value)
        raise TypeError(msg)
&nbsp;
&nbsp;
user = {"name": name_str,
        "surname": name_str,
        "id": pos_int}
</pre>

<p>Následuje validace různých slovníků:</p>

<pre>
validate(user, {"name": "Eda",
                "surname": "Wasserfall",
                "id": 1})
&nbsp;
validate(user, {"name": "eda",
                "surname": "Wasserfall",
                "id": 1})
&nbsp;
validate(user, {"name": "E",
                "surname": "Wasserfall",
                "id": 1})
&nbsp;
validate(user, {"name": "Eda",
                "id": 1})
&nbsp;
validate(user, {"name": "Eda",
                "surname": "Wasserfall",
                "id": 0})
</pre>

<p>S&nbsp;očekávanými výsledky (povšimněte si zvýrazněných zpráv):</p>

<pre>
{'name': &lt;function name_str at 0x7f9202b08c80&gt;, 'surname': &lt;function name_str at 0x7f9202b08c80&gt;, 'id': &lt;function pos_int at 0x7f9202b08d08&gt;}
{'name': 'Eda', 'surname': 'Wasserfall', 'id': 1}
{'name': None, 'surname': None, 'id': None}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': &lt;function name_str at 0x7f9202b08c80&gt;, 'surname': &lt;function name_str at 0x7f9202b08c80&gt;, 'id': &lt;function pos_int at 0x7f9202b08d08&gt;}
{'name': 'eda', 'surname': 'Wasserfall', 'id': 1}
<strong>Proper name expected, but got 'eda' instead</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': &lt;function name_str at 0x7f9202b08c80&gt;, 'surname': &lt;function name_str at 0x7f9202b08c80&gt;, 'id': &lt;function pos_int at 0x7f9202b08d08&gt;}
{'name': 'E', 'surname': 'Wasserfall', 'id': 1}
<strong>Proper name expected, but got 'E' instead</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': &lt;function name_str at 0x7f9202b08c80&gt;, 'surname': &lt;function name_str at 0x7f9202b08c80&gt;, 'id': &lt;function pos_int at 0x7f9202b08d08&gt;}
{'name': 'Eda', 'id': 1}
<strong>Missing keys {'surname'} for value {'name': 'Eda', 'id': 1}</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': &lt;function name_str at 0x7f9202b08c80&gt;, 'surname': &lt;function name_str at 0x7f9202b08c80&gt;, 'id': &lt;function pos_int at 0x7f9202b08d08&gt;}
{'name': 'Eda', 'surname': 'Wasserfall', 'id': 0}
<strong>Positive number expected, but got 0 instead</strong>
</pre>

<p><div class="rs-tip-major">Ještě složitější validační kritéria budou ukázána
ve druhé a současně i poslední části tohoto článku.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Základní informace o knihovně Schema</h2>

<p>Druhou knihovnou, o níž se dnes alespoň ve stručnosti zmíníme, je knihovna
nazvaná jednoduše <i>Schema</i>. Tato knihovna taktéž slouží k&nbsp;validaci
dat, a to do značné míry podobně, jako tomu je u výše popsané knihovny
<i>Schemagic</i> &ndash; samotné validační schéma je totiž i zde představováno
plnohodnotným pythonovským zdrojovým kódem. V&nbsp;následujících pěti
kapitolách si ukážeme některé základní možnosti této knihovny, ovšem
podrobnějšímu popisu bude věnován samostatný článek.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Instalace knihovny Schema</h2>

<p>Podívejme se nyní na způsob instalace knihovny <i>Schema</i>. Abychom se
trošku odlišili od předchozích příkladů, bude tato knihovna nainstalována
nikoli do virtuálního prostředí Pythonu, ale do adresářové struktury viditelné
pro všechny procesy spuštěné aktuálně přihlášeným uživatelem (který si knihovnu
nainstaloval). Předpokládáme přitom použití Pythonu 3.x; pokud používáte Python
2.x, stačí nahradit <strong>pip3</strong> a <strong>pip</strong>.</p>

<p>Samotná instalace se provede příkazem:</p>

<pre>
$ <strong>pip3 install --user schema</strong>
&nbsp;
Downloading/unpacking schema
  Downloading schema-0.6.7-py2.py3-none-any.whl
Installing collected packages: schema
Successfully installed schema
Cleaning up...
</pre>

<p>Pro jistotu si můžete nechat vypsat informace o tom, kam (a zda vůbec) byla
knihovna nainstalována:</p>

<pre>
$ <strong>pip3 show schema</strong>
&nbsp;
---
Name: schema
Version: 0.6.7
Location: /home/tester/.local/lib/python3.4/site-packages
Requires: 
</pre>

<p>Pokud vše proběhlo v&nbsp;pořádku, můžeme si vyzkoušet základní možnosti
této knihovny, a to přímo v&nbsp;interaktivní konzoli programovacího jazyka
Python:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.4.3 (default, Nov 28 2017, 16:41:13) 
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from schema import Schema
&nbsp;
&gt;&gt;&gt; Schema(int).validate(42)
42
&nbsp;
&gt;&gt;&gt; Schema([int]).validate([42, 1, 2])
[42, 1, 2]
&nbsp;
&gt;&gt;&gt; Schema((int, )).validate((42, 1, 2))
(42, 1, 2)
&nbsp;
&gt;&gt;&gt; Schema((int, float, str)).validate((3, "1", 3.14))
(3, '1', 3.14)
</pre>

<p><div class="rs-tip-major">Poznámka: pokud jste si knihovnu nainstalovali
příkazem <strong>pip3</strong>, bude dostupná pro interpret Pythonu 3.x. Pokud
naopak použijete <strong>pip</strong>, lze knihovnu použít z&nbsp;Pythonu 2.x
(i když na některých systémech může být <strong>pip</strong> alias pro
<strong>pip3</strong>).</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Jednoduchý příklad použití knihovny Schema pro validaci datových struktur</h2>

<p>V&nbsp;prvním příkladu opět vytvoříme uživatelskou funkci
<strong>validate</strong>, která ovšem nyní bude volat metodu nazvanou
<strong>Schema.validate</strong> a v&nbsp;případě, že validace neproběhne
korektně, se bude očekávat výjimka typu <strong>SchemaError</strong>:</p>

<pre>
from schema import Schema, SchemaError
&nbsp;
&nbsp;
def validate(schema, data):
    try:
        print("\n\n")
        print(schema)
        print(data)
        schema.validate(data)
        print("pass")
    except SchemaError as e:
        print(e)
</pre>

<p>Následuje definice validačních schémat. Povšimněte si syntaktické podobnosti
s&nbsp;knihovnou <i>Schemagic</i>:</p>

<pre>
integer_list = Schema([int])
float_list = Schema([float])
string_list = Schema([str])
</pre>

<p>Nyní si validaci s&nbsp;využitím všech tří schémat vyzkoušíme:</p>

<pre>
validate(integer_list, [1, 2, 3])
validate(integer_list, [1.1, 2.2, 3.3])
validate(integer_list, ["1", "2", "3"])
&nbsp;
validate(float_list, [1, 2, 3])
validate(float_list, [1.1, 2.2, 3.3])
validate(float_list, ["1", "2", "3"])
&nbsp;
validate(string_list, [1, 2, 3])
validate(string_list, [1.1, 2.2, 3.3])
validate(string_list, ["1", "2", "3"])
</pre>

<p>I když způsob zápisu schémat je v&nbsp;<i>Schema</i> syntakticky podobný
knihovně <i>Schemagic</i>, sémantika je odlišná! Je tomu tak z&nbsp;toho
důvodu, že nyní <strong>int</strong>, <strong>str</strong> apod. představuje
zápis datových typů a nikoli konverzních funkcí. Ostatně se o tom lze snadno
přesvědčit spuštěním příkladu.</p>

<p>První validace je shodná:</p>

<pre>
Schema([&lt;class 'int'&gt;])
[1, 2, 3]
pass
</pre>

<p>Nyní ovšem přichází rozdíl &ndash; žádné automatické konverze, ale test
elementů na datový typ:</p>

<pre>
Schema([&lt;class 'int'&gt;])
[1.1, 2.2, 3.3]
Or(&lt;class 'int'&gt;) did not validate 1.1
1.1 should be instance of 'int'
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'int'&gt;])
['1', '2', '3']
Or(&lt;class 'int'&gt;) did not validate '1'
'1' should be instance of 'int'
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'float'&gt;])
[1, 2, 3]
Or(&lt;class 'float'&gt;) did not validate 1
1 should be instance of 'float'
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'float'&gt;])
[1.1, 2.2, 3.3]
pass
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'float'&gt;])
['1', '2', '3']
Or(&lt;class 'float'&gt;) did not validate '1'
'1' should be instance of 'float'
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'str'&gt;])
[1, 2, 3]
Or(&lt;class 'str'&gt;) did not validate 1
1 should be instance of 'str'
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'str'&gt;])
[1.1, 2.2, 3.3]
Or(&lt;class 'str'&gt;) did not validate 1.1
1.1 should be instance of 'str'
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'str'&gt;])
['1', '2', '3']
pass
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Validace obsahu slovníků</h2>

<p>Samozřejmě, že i v&nbsp;knihovně <i>Schema</i> je možné kontrolovat obsahy
slovníků. Pro zajímavost si to vyzkoušejme v&nbsp;interaktivním prostředí
Pythonu:</p>

<pre>
$ <strong>python3</strong>
</pre>

<p>Naimportujeme potřebný modul a nadefinujeme validační schéma:</p>

<pre>
&gt;&gt;&gt; from schema import Schema
&gt;&gt;&gt; s1 = Schema({"name": str, "surname": str})
</pre>

<p>Nyní můžeme schéma snadno použít pro různé slovníky. Povšimněte si, že se
kontroluje i existence všech dvojic klíč+hodnota:</p>

<pre>
&gt;&gt;&gt; s1.validate({"name": "Eda", "surname": "Wasserfall"})
{'name': 'Eda', 'surname': 'Wasserfall'}
&gt;&gt;&gt; s1.validate({"name": "Eda", "surname": ""})
{'name': 'Eda', 'surname': ''}
&gt;&gt;&gt; s1.validate({"name": "Eda"})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/tester/.local/lib/python3.4/site-packages/schema.py", line 290, in validate
    SchemaMissingKeyError('Missing keys: ' + s_missing_keys, e)
schema.SchemaMissingKeyError: Missing keys: 'surname'
</pre>

<p>To však zdaleka není vše, protože pro jednu hodnotu (řekněme pro klíče)
můžeme použít více validačních kritérií. Ty je zapotřebí spojit klauzulí
<strong>And</strong>. I tu si musíme naimportovat:</p>

<pre>
&gt;&gt;&gt; from schema import And
&gt;&gt;&gt; s2 = Schema({"name": And(str, len), "surname": And(str, len)})
</pre>

<p>Zápis <strong>And(str, len)</strong> znamená: pod klíčem &bdquo;name&ldquo;
má být uložena hodnota typu řetězec, jehož délka musí být nenulová (připomeňme
si, že nula v&nbsp;logických výrazech odpovídá hodnotě
<strong>False</strong>).</p>

<p>Opět si nové validační schéma odzkoušíme:</p>

<pre>
&gt;&gt;&gt; s2.validate({"name": "Eda", "surname": ""})
Traceback (most recent call last):
  File "/home/tester/.local/lib/python3.4/site-packages/schema.py", line 316, in validate
    return s.validate(data)
  File "/home/tester/.local/lib/python3.4/site-packages/schema.py", line 96, in validate
    data = s.validate(data)
  File "/home/tester/.local/lib/python3.4/site-packages/schema.py", line 334, in validate
    raise SchemaError('%s(%r) should evaluate to True' % (f, data), e)
schema.SchemaError: len('') should evaluate to True
&nbsp;
During handling of the above exception, another exception occurred:
&nbsp;
Traceback (most recent call last):
  File "/home/tester/.local/lib/python3.4/site-packages/schema.py", line 276, in validate
    ignore_extra_keys=i).validate(value)
  File "/home/tester/.local/lib/python3.4/site-packages/schema.py", line 318, in validate
    raise SchemaError([None] + x.autos, [e] + x.errors)
schema.SchemaError: len('') should evaluate to True
&nbsp;
During handling of the above exception, another exception occurred:
&nbsp;
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/tester/.local/lib/python3.4/site-packages/schema.py", line 279, in validate
    raise SchemaError([k] + x.autos, [e] + x.errors)
schema.SchemaError: Key 'surname' error:
len('') should evaluate to True
</pre>

<p>Nyní je vše v&nbsp;pořádku:</p>

<pre>
&gt;&gt;&gt; s2.validate({"name": "Eda", "surname": "Wasserfall"})
{'name': 'Eda', 'surname': 'Wasserfall'}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Druhý příklad používající knihovnu Schema</h2>

<p>Ve <a
href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-2">druhém
příkladu</a>, který používá knihovnu <i>Schema</i> jsou ukázány některé další
možnosti nabízené touto knihovnou. Zejména si povšimněte, jak se zapisují
uživatelské validační funkce &ndash; ty totiž nemusí (a nemají) vyhazovat
výjimku, ale pouze vracet pravdivostní hodnotu (jedná se tedy o skutečné
predikáty):</p>

<pre>
def pos(value):
    return type(value) is int and value &gt; 0
</pre>

<p>Predikáty lze samozřejmě zapsat i formou anonymní funkce a celý zápis tak
podstatně zkrátit:</p>

<pre>
validate(Schema(lambda value: value &lt; 0), 42)
</pre>

<p>V&nbsp;tomto příkladu taktéž validujeme prvky slovníků tak, jak jsme si to
ukázali v&nbsp;předchozí kapitole.</p>

<p>Úplný zdrojový kód vypadá následovně:</p>

<pre>
from schema import Schema, SchemaError
&nbsp;
&nbsp;
def validate(schema, data):
    try:
        print("\n\n")
        print(schema)
        print(data)
        schema.validate(data)
        print("pass")
    except SchemaError as e:
        print(e)
&nbsp;
&nbsp;
def pos(value):
    return type(value) is int and value &gt; 0
&nbsp;
&nbsp;
number_list = Schema([int, float, complex])
&nbsp;
validate(number_list, [1, 2, 3])
validate(number_list, [1.1, 2.2, 3.3])
validate(number_list, [1+2j, 3+4j, 5j])
validate(number_list, ["1", "2", "3"])
&nbsp;
binary_numbers = Schema([0, 1])
validate(binary_numbers, [0, 0, 0])
validate(binary_numbers, [1, 1, 0])
validate(binary_numbers, [1, 2, 3])
&nbsp;
validate(Schema(pos), 42)
validate(Schema(pos), 0)
validate(Schema(pos), -1)
validate(Schema(pos), 1.5)
&nbsp;
validate(Schema(lambda value: value &lt; 0), 42)
validate(Schema(lambda value: value &lt; 0), 0)
validate(Schema(lambda value: value &lt; 0), -1)
&nbsp;
user = Schema({"name": str,
               "surname": str,
               "id": pos})
&nbsp;
validate(user, {"name": "Eda",
                "surname": "Wasserfall",
                "id": 1})
&nbsp;
validate(user, {"name": "Eda",
                "id": 1})
&nbsp;
validate(user, {"name": "Eda",
                "surname": "Wasserfall",
                "id": 0})
</pre>


<p><a name="k19"></a></p>
<h2 id="k19">19. Výsledek druhého příkladu</h2>

<p>Druhý příklad by měl po svém spuštění vypsat na standardní výstup
následující zprávy odpovídající jednotlivým po sobě jdoucím validacím:</p>

<pre>
Schema([&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;])
[1, 2, 3]
pass
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;])
[1.1, 2.2, 3.3]
pass
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;])
[(1+2j), (3+4j), 5j]
pass
&nbsp;
&nbsp;
&nbsp;
Schema([&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;])
['1', '2', '3']
Or(&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;) did not validate '1'
'1' should be instance of 'complex'
&nbsp;
&nbsp;
&nbsp;
Schema([0, 1])
[0, 0, 0]
pass
&nbsp;
&nbsp;
&nbsp;
Schema([0, 1])
[1, 1, 0]
pass
&nbsp;
&nbsp;
&nbsp;
Schema([0, 1])
[1, 2, 3]
Or(0, 1) did not validate 2
1 does not match 2
&nbsp;
&nbsp;
&nbsp;
Schema(&lt;function pos at 0x7f45c4172bf8&gt;)
42
pass
&nbsp;
&nbsp;
&nbsp;
Schema(&lt;function pos at 0x7f45c4172bf8&gt;)
0
pos(0) should evaluate to True
&nbsp;
&nbsp;
&nbsp;
Schema(&lt;function pos at 0x7f45c4172bf8&gt;)
-1
pos(-1) should evaluate to True
&nbsp;
&nbsp;
&nbsp;
Schema(&lt;function pos at 0x7f45c4172bf8&gt;)
1.5
pos(1.5) should evaluate to True
&nbsp;
&nbsp;
&nbsp;
Schema(&lt;function &lt;lambda&gt; at 0x7f45c40ff730&gt;)
42
&lt;lambda&gt;(42) should evaluate to True
&nbsp;
&nbsp;
&nbsp;
Schema(&lt;function &lt;lambda&gt; at 0x7f45c40ff730&gt;)
0
&lt;lambda&gt;(0) should evaluate to True
&nbsp;
&nbsp;
&nbsp;
Schema(&lt;function &lt;lambda&gt; at 0x7f45c40ff730&gt;)
-1
pass
&nbsp;
&nbsp;
&nbsp;
Schema({'surname': &lt;class 'str'&gt;, 'id': &lt;function pos at 0x7f45c4172bf8&gt;, 'name': &lt;class 'str'&gt;})
{'surname': 'Wasserfall', 'id': 1, 'name': 'Eda'}
pass
&nbsp;
&nbsp;
&nbsp;
Schema({'surname': &lt;class 'str'&gt;, 'id': &lt;function pos at 0x7f45c4172bf8&gt;, 'name': &lt;class 'str'&gt;})
{'id': 1, 'name': 'Eda'}
Missing keys: 'surname'
&nbsp;
&nbsp;
&nbsp;
Schema({'surname': &lt;class 'str'&gt;, 'id': &lt;function pos at 0x7f45c4172bf8&gt;, 'name': &lt;class 'str'&gt;})
{'surname': 'Wasserfall', 'id': 0, 'name': 'Eda'}
Key 'id' error:
pos(0) should evaluate to True
</pre>



<p><a name="k20"></a></p>
<h2 id="k20">20. Repositář se všemi demonstračními příklady</h2>

<p>Všech osm demonstračních projektů, které jsme si v&nbsp;dnešním článku
popsali, bylo uloženo do repositáře, který naleznete na adrese <a
href="https://github.com/tisnik/python-schema-checks">https://github.com/tisnik/python-schema-checks</a>.
V&nbsp;tabulce pod tímto odstavcem jsou vypsány odkazy na všechny tyto
projekty:</p>

<table>
<tr><th>Projekt</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>schemagic-demo-1</td><td>základní vlastnosti knihovny Schemagic</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-1">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-1</a></td></tr>
<tr><td>schemagic-demo-2</td><td>konverze prováděné při validaci</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-2">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-2</a></td></tr>
<tr><td>schemagic-demo-3</td><td>vlastní validační funkce</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-3">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-3</a></td></tr>
<tr><td>schemagic-demo-4</td><td>vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-4">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-4</a></td></tr>
<tr><td>schemagic-demo-5</td><td>validace slovníků</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-5">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-5</a></td></tr>
<tr><td>schemagic-demo-6</td><td>validace slovníků podruhé</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-6">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-6</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>schema-demo-1</td><td>základní vlastnosti knihovny Scheme</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-1">https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-1</a></td></tr>
<tr><td>schema-demo-2</td><td>validace slovníků a dalších typů</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-2">https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-2</a></td></tr>
</table>



<p><a name="k21"></a></p>
<h2 id="k21">21. Odkazy na Internetu</h2>

<ol>

<li>schemagic 0.9.1 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schemagic/0.9.1">https://pypi.python.org/pypi/schemagic/0.9.1</a>
</li>

<li>Schemagic / Schemagic.web (na GitHubu)<br />
<a href="https://github.com/Mechrophile/schemagic">https://github.com/Mechrophile/schemagic</a>
</li>

<li>schema 0.6.7 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schema">https://pypi.python.org/pypi/schema</a>
</li>

<li>schema (na GitHubu)<br />
<a href="https://github.com/keleshev/schema">https://github.com/keleshev/schema</a>
</li>

<li>XML Schema validator and data conversion library for Python<br />
<a href="https://github.com/brunato/xmlschema">https://github.com/brunato/xmlschema</a>
</li>

<li>xmlschema 0.9.7<br />
<a href="https://pypi.python.org/pypi/xmlschema/0.9.7">https://pypi.python.org/pypi/xmlschema/0.9.7</a>
</li>

<li>jsonschema 2.6.0<br />
<a href="https://pypi.python.org/pypi/jsonschema">https://pypi.python.org/pypi/jsonschema</a>
</li>

<li>warlock 1.3.0<br />
<a href="https://pypi.python.org/pypi/warlock">https://pypi.python.org/pypi/warlock</a>
</li>

<li>Python Virtual Environments – A Primer<br />
<a href="https://realpython.com/python-virtual-environments-a-primer/">https://realpython.com/python-virtual-environments-a-primer/</a>
</li>

<li>pip 1.1 documentation: Requirements files<br />
<a href="https://pip.readthedocs.io/en/1.1/requirements.html">https://pip.readthedocs.io/en/1.1/requirements.html</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Unit testing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

