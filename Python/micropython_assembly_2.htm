<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v&nbsp;MicroPythonu (2)</a></p>
<p><a href="#k02">2. Anatomie funkcí s&nbsp;dekorátorem <strong>@micropython.asm_thumb</strong></a></p>
<p><a href="#k03">3. Strojové instrukce v&nbsp;prázdné funkci</a></p>
<p><a href="#k04">4. Instrukce <strong>PUSH</strong> a <strong>POP</strong></a></p>
<p><a href="#k05">5. Instrukce <strong>PUSH</strong> a <strong>POP</strong> v&nbsp;instrukční sadě Thumb</a></p>
<p><a href="#k06">6. Strojové kódy funkcí popsaných minule</a></p>
<p><a href="#k07">7. Instrukce <strong>LDR</strong> a přístup k&nbsp;prvkům polí</a></p>
<p><a href="#k08">8. Instrukce nepodmíněného skoku a pseudoinstrukce <strong>label</strong></a></p>
<p><a href="#k09">9. Překlad instrukce nepodmíněného skoku na zadané návěští</a></p>
<p><a href="#k10">10. Skok zpět</a></p>
<p><a href="#k11">11. Stavové registry na mikroprocesorech s&nbsp;architekturou ARM</a></p>
<p><a href="#k12">12. Příznakové a stavové bity na mikroprocesorech s&nbsp;architekturou ARM</a></p>
<p><a href="#k13">13. Podmínky specifikované u instrukcí skoku (<i>condition codes</i>)</a></p>
<p><a href="#k14">*** 14. Instrukce podmíněného skoku a jednoduchá počítaná programová smyčka</a></p>
<p><a href="#k15">*** 15. Nastavení příznakových bitů u aritmetických instrukcí</a></p>
<p><a href="#k16">*** 16. Zjednodušená programová smyčka</a></p>
<p><a href="#k17">*** 17. Vnořené programové smyčky</a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v&nbsp;MicroPythonu (2)</h2>

<p>Na <a
href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu/">úvodní
článek</a> o využití instrukcí z&nbsp;instrukční sady Thumb a Thumb-2
v&nbsp;MicroPythonu dnes navážeme. Nejdříve si řekneme, jakým způsobem je možné
prozkoumat funkce označené dekorátorem <strong>@micropython.asm_thumb</strong>,
dále si popíšeme specifika zápisu některých funkcí a nakonec
(v&nbsp;navazujícím článku) provedeme benchmarky pro zjištění, zda a
v&nbsp;jakých situacích může být propojení Pythonu s&nbsp;(de facto)
assemblerem výhodné a kdy je to naopak pouze ztráta času vývojáře.</p>

<p>Připomeňme si nejdříve, jaké vlastnosti musí funkce s&nbsp;instrukcemi Thumb
a/nebo Thumb-2 splňovat:</p>

<ol>
<li>Funkce musí být označena dekorátorem <strong>@micropython.asm_thumb</strong></li>
<li>Funkce může být bez parametrů nebo může akceptovat maximálně čtyři celočíselné argumenty</li>
<li>Tyto argumenty musí být pojmenovány <strong>r0</strong> až <strong>r3</strong> (což jsou jména pracovních registrů ARMu)</li>
<li>Návratová hodnota je vždy jedna a je předána v&nbsp;registru <strong>r0</strong> (nepoužívá se příkaz <strong>return</strong>)</li>
<li>Tyto funkce mohou obsahovat pouze symbolicky zapsané instrukce Thumb a Thumb-2 (nelze je tedy kombinovat s&nbsp;Pythonním kódem)</li>
</ol>

<p><div class="rs-tip-major">Poznámka: v&nbsp;žádném případě se nejedná o
samoúčelná omezení, protože jak uvidíme dále, je interní formát těchto funkcí
odlišný od běžných Pythonovských funkcí.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Anatomie funkcí s&nbsp;dekorátorem <strong>@micropython.asm_thumb</strong></h2>

<p>V&nbsp;úvodní části dnešního článku nás bude zajímat, jak vlastně interně
vypadají funkce, které jsou označeny dekorátorem
<strong>@micropython.asm_thumb</strong>. Víme již, že v&nbsp;těle těchto funkcí
mohou být zapsány pouze strojové instrukce a nikoli příkazy Pythonu. Lze tedy
předpokládat, že celá funkce bude přeložena do strojového kódu. Ovšem na
začátku a konci sekvence instrukcí velmi pravděpodobně budou nějaké instrukce
dodané přímo MicroPythonem. Minimálně na konci funkce je totiž nutné zajistit
návrat do funkce volající. A právě pro zjištění, jak vlastně vypadá tělo funkce
přeložené do strojového kódu slouží následující kód, který vznikl úpravou
skriptu zmíněného v&nbsp;této diskuzi <a
href="https://github.com/orgs/micropython/discussions/12257">https://github.com/orgs/micropython/discussions/12257</a>
(ovšem jeho autor je ještě někdo další):</p>

<pre>
import machine
import array
&nbsp;
&nbsp;
def <strong>inspect</strong>(f, nbytes=16):
    baddr = bytes(array.array("O", [f]))
    addr = int.from_bytes(baddr, "little")
    print("function object at: 0x%08x" % addr)
    print("number of args: %u" % machine.mem32[addr + 4])
    code_addr = machine.mem32[addr + 8]
    print("machine code at: 0x%08x" % code_addr)
    print("-- code --")
    for i in range(nbytes):
        print(f"{machine.mem8[code_addr + i]:02x}", end=" ")
    print("\n----------")
</pre>

<p>Tento kód, kterému se předá reference na funkci, nejdříve získá binární
obraz hlavičky funkce, z&nbsp;něhož zjistí dvě důležité informace &ndash; počet
předávaných argumentů (ten je pevný) a taktéž adresu, na níž jsou uloženy
strojové instrukce tvořící tělo funkce. Hodnoty z&nbsp;takto získaného bloku
jsou vypsány v&nbsp;hexadecimálním formátu. Délka těla funkce (počet bajtů)
není zjišťován (pravděpodobně bude součástí hlavičky), ale je vypsán
<i>nbytes</i> bajtů. Délku těla funkce tedy budeme v&nbsp;dalších kapitolách
nejprve odhadovat a teprve poté si funkci <strong>inspect</strong>
vylepšíme, aby konec detekovala.</p>

<p><div class="rs-tip-major">Poznámka: interní struktura přeložených funkcí
není nikde přesně specifikována a může se v&nbsp;dalších verzích MicroPythonu
změnit!</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Strojové instrukce v&nbsp;prázdné funkci</h2>

<p>Prozkoumejme nyní, jaké strojové instrukce bude obsahovat (zdánlivě) zcela
prázdná funkce překládaná do strojového kódu. Taková funkce může být zapsána
následovně:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>no_op():</strong>
    pass
</pre>

<p>Taková funkce je po zápisu do MicroPythonu ihned přeložena, takže její tělo
můžeme velmi snadno prozkoumat. Použijeme přitom pomocnou funkci
<strong>inspect</strong> představenou v&nbsp;rámci <a href="#k02">předchozí
kapitoly</a>:</p>

<pre>
&gt;&gt;&gt; <strong>inspect(no_op, 20)</strong>
</pre>

<p>Výsledek by měl vypadat takto (samozřejmě se budou lišit obě vypsané
adresy):</p>

<pre>
function object at: 0x20014080
number of args: 0
machine code at: 0x20014240
-- code --
f2 b5 f2 bd 00 00 00 00 00 00 00 00 00 00 00 00 de 00 07 00 
----------
</pre>

<p>Výše uvedenou sekvenci bajtů (f2, b5, ...) překopírujeme do online
disassembleru, jenž je dostupný na adrese <a
href="https://armconverter.com/?disasm">https://armconverter.com/?disasm</a>.
V&nbsp;pravé části stránky se zobrazí výsledek disassemblingu pro různé
instrukční sady. Zkusme si tedy překopírovat výše uvedenou sekvenci bajtů a
následně v&nbsp;sekci <i>Thumb</i> uvidíme:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
pop {r1, r4, r5, r6, r7, pc}
movs r0, r0
movs r0, r0
movs r0, r0
movs r0, r0
movs r0, r0
movs r0, r0
lsls r6, r3, #3
movs r7, r0
</pre>

<p>Z&nbsp;tohoto kódu je patrné (resp.&nbsp;bude patrné), že význam mají pouze
první dvě instrukce. Zbylé bajty již do strojového kódu naší funkce
nepatří:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
pop {r1, r4, r5, r6, r7, pc}
</pre>

<p>Prázdná funkce tedy začíná instrukcí <strong>push</strong> a končí instrukcí
<strong>pop</strong>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukce <strong>PUSH</strong> a <strong>POP</strong></h2>

<p>V&nbsp;mnoha ohledech jsou instrukce <strong>PUSH</strong> a
<strong>POP</strong> vůbec nejsložitějšími instrukcemi na architektuře ARM. Je
tomu tak z&nbsp;toho důvodu, že jediná instrukce dokáže uložit na zásobník
(nebo naopak ze zásobníku přečíst) prakticky libovolnou kombinaci pracovních
registrů <strong>r0</strong> až <strong>r15</strong> (s&nbsp;několika omezeními
pro registry SP, PC a LR). Z&nbsp;tohoto důvodu je v&nbsp;původní 32bitové
instrukční sadě ARM v&nbsp;samotném kódu instrukce rezervováno bitové pole
s&nbsp;šestnácti bity: viz též <a
href="https://www.root.cz/obrazek/222284/">již minule uvedený obrázek</a>,
konkrétně jeho šestý řádek. Instrukce poté pro každý registr, jehož bit je
nastaven na jedničku, provede operaci <strong>PUSH</strong> či
<strong>POP</strong> a nakonec příslušně upraví obsah registru
<strong>SP</strong>.</p>

<p><div class="rs-tip-major">Poznámka: to není tak jednoduchá operace, jak by
se mohlo na první pohled zdát, protože mikroprocesor musí reagovat na přerušení
atd.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukce <strong>PUSH</strong> a <strong>POP</strong> v&nbsp;instrukční sadě Thumb</h2>

<p>Původní sémantika instrukcí <strong>PUSH</strong> a <strong>POP</strong>
sice zůstala zachována i v&nbsp;instrukční sadě Thumb, ovšem došlo
k&nbsp;určitým omezením, protože, podobně jako všechny další instrukce
z&nbsp;instrukční sady Thumb, musí být instrukce zakódovány v&nbsp;šestnácti
bitech (tudíž se do instrukčního slova nemůže vejít 16bitové pole).</p>

<p>V&nbsp;případě instrukce <strong>PUSH</strong> lze pracovat se spodními osmi
registry R0 až R7 a taktéž s&nbsp;registrem LR (<i>link register</i>), jenž
obsahuje návratovou adresu:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 0 | 1 | 1 | 0 | 1 | 0 | LR|     bitové pole registrů      |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>To například znamená, že můžeme zakódovat tyto operace:</p>

<table>
<tr><th>Kód instrukce (hex)</th><th>Provedená operace</th></tr>
<tr><td>f2 b4</td><td>push {r1, r4, r5, r6, r7}</td></tr>
<tr><td>f2 b5</td><td>push {r1, r4, r5, r6, r7, lr}</td></tr>
<tr><td>ff b5</td><td>push {r0, r1, r2, r3, r4, r5, r6, r7, lr}</td></tr>
<tr><td>01 b4</td><td>push {r0}</td></tr>
<tr><td>00 b5</td><td>push {lr}</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ovšem minimálně jeden pracovní registr
je nutné vybrat, protože operační kód 00 b4 nemá význam.</div></p>

<p>Instrukce <strong>POP</strong> má nepatrně odlišné kódování a namísto
registru <strong>LR</strong> lze obnovit registr <strong>PC</strong>. Bitové
pole pro spodním osm pracovních registrů však zůstalo zachováno i zde:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 0 | 1 | 1 | 1 | 1 | 0 | PC|     bitové pole registrů      |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Opět se podívejme, jaké konkrétní operace můžeme provést:</p>

<table>
<tr><th>Kód instrukce (hex)</th><th>Provedená operace</th></tr>
<tr><td>00 bd</td><td>pop {pc}</td></tr>
<tr><td>f2 bc</td><td>pop {r1, r4, r5, r6, r7}</td></tr>
<tr><td>f2 bd</td><td>pop {r1, r4, r5, r6, r7, pc}</td></tr>
<tr><td>ff bc</td><td>pop {r0, r1, r2, r3, r4, r5, r6, r7}</td></tr>
<tr><td>ff bd</td><td>pop {r0, r1, r2, r3, r4, r5, r6, r7, pc}</td></tr>
</table>

<p>A opět platí, že 00 bc (tedy neobnovení žádného registru) je neplatnou
operací.</p>

<p>Vraťme se tedy k&nbsp;původním instrukcím, které byly nalezeny
v&nbsp;přeloženém nativním kódu:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
pop {r1, r4, r5, r6, r7, pc}
</pre>

<p>První z&nbsp;těchto instrukcí uloží obsahy pěti specifikovaných pracovních
registrů na zásobník. A taktéž na něj uloží obsah registru <strong>LR</strong>
(<i>link register</i>), jenž obsahuje návratovou adresu. A druhá instrukce,
která bude provedena jako poslední, obnoví všech pět zmíněných pracovních
registrů a poté do registru <strong>PC</strong> (<i>program counter</i>) vloží
adresu, která byla původně uložena v&nbsp;registru <strong>LR</strong> &ndash;
tedy provede automatický návrat z&nbsp;funkce do volajícího kódu!</p>

<p><div class="rs-tip-major">Poznámka: obsah registrů <strong>R2</strong> a
<strong>R3</strong> je tedy ztracen a registr <strong>R0</strong> se neobnovuje
proto, že bude obsahovat návratovou hodnotu z&nbsp;funkce.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Strojové kódy funkcí popsaných minule</h2>

<p>Pro zajímavost se podívejme na způsob překladu funkcí, které jsme si popsali
<a
href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu/">v&nbsp;úvodním
článku</a>. Začneme funkcí, která vrací hodnotu 42 (což se děje přes obsah
pracovního registru R0, jak již dobře víme). Zdrojový kód funkce vypadá
takto:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>return_constant</strong>():
    mov(r0, 42)
</pre>

<p>Strojový kód získaný překladem provedeným MicroPythonem:</p>

<pre>
&gt;&gt;&gt; <strong>inspect(return_constant, 20)</strong>
&nbsp;
function object at: 0x20014a20
number of args: 0
machine code at: 0x20014be0
-- code --
f2 b5 2a 20 f2 bd 00 00 00 00 00 00 00 00 00 00 de 00 07 00 
----------
</pre>

<p>Ve strojovém kódu nalezneme pouze šest bajtů se třemi instrukcemi. První a
poslední z&nbsp;nich již dobře známe, takže přibyla pouze prostřední instrukce
naplňující pracovní registr <strong>r0</strong> konstantou:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
movs r0, #0x2a
pop {r1, r4, r5, r6, r7, pc}
</pre>

<p>Mimochodem, tato instrukce zakódována v&nbsp;této dvojici bajtů:</p>

<pre>
2a 20
</pre>

<p>První bajt obsahuje konstantu 42 a druhý kód instrukce (uložení <i>little
endian</i>):</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |         konstanta             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Což přesně odpovídá formátu, který jsme si uvedli minule:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |operace|   Rd/Rn   |         konstanta             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>V&nbsp;tomto případě je operace zakódována jako 00 (<strong>mov</strong>) a
<strong>Rd</strong> má index 000 neboli <strong>R0</strong>.</p>

<p>Dále prozkoumejme funkci, která sečte své čtyři argumenty. Připomeňme si, že
tato funkce vypadá takto:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>add_four</strong>(r0, r1, r2, r3):
    add(r0, r0, r1)
    add(r0, r0, r2)
    add(r0, r0, r3)
</pre>

<p>Způsob jejího překladu do strojového kódu:</p>

<pre>
&gt;&gt;&gt; <strong>inspect(add_four, 20)</strong>
&nbsp;
function object at: 0x20014fc0
number of args: 4
machine code at: 0x20015180
-- code --
f2 b5 40 18 80 18 c0 18 f2 bd 00 00 00 00 00 00 de 00 07 00 
----------
</pre>

<p>Druhá instrukce je zakódována bajty 40 18, což znamená:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 0 | A |   Rm=R1   |   Rs=R0   |   Rd=R0   |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Třetí instrukce je zakódována bajty 80 18:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 0 | A |   Rm=R2   |   Rs=R0   |   Rd=R0   |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>A konečně čtvrtá instrukce je zakódována bajty c0 18:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 0 | A |   Rm=R3   |   Rs=R0   |   Rd=R0   |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>To zcela přesně odpovídá disassemblované sekvenci instrukcí:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
adds r0, r0, r1
adds r0, r0, r2
adds r0, r0, r3
pop {r1, r4, r5, r6, r7, pc}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce <strong>LDR</strong> a přístup k&nbsp;prvkům polí</h2>

<p>Minule jsme si taktéž ukázali využití instrukce <strong>LDR</strong>
(<i>load register</i>) určené pro naplnění obsahu pracovního registru
libovolnou 32bitovou hodnotou (což nám standardní instrukce
<strong>MOV</strong> neumožňuje). Připomeňme si, že jsme si museli vypomoci
polem s&nbsp;jediným 32bitovým prvkem, jehož adresa byla předána do funkce
s&nbsp;instrukcemi Thumb:</p>

<pre>
from array import array
&nbsp;
control = array('I', [100000])
&nbsp;
&nbsp;
<i>@micropython.asm_thumb</i>
def <strong>return_big_constant</strong>(r0):
    ldr(r0, [r0, 0])
&nbsp;
return_big_constant(control)
</pre>

<p>Vygenerovaný strojový kód získáme opět pomocí <strong>inspect</strong>:</p>

<pre>
&gt;&gt;&gt; <strong>inspect(return_big_constant, 20)</strong>
&nbsp;
function object at: 0x20015670
number of args: 1
machine code at: 0x200158c0
-- code --
f2 b5 00 68 f2 bd 00 00 00 00 00 00 00 00 00 00 de 00 07 00 
----------
</pre>

<p>Tento kód neobsahuje žádné záhady, pouze instrukci <strong>LDR</strong>,
která akceptuje adresu v&nbsp;registru <strong>R0</strong> a 32bitové slovo na
této adrese uloží taktéž do registru <strong>R0</strong>:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
ldr r0, [r0]
pop {r1, r4, r5, r6, r7, pc}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukce nepodmíněného skoku a pseudoinstrukce <strong>label</strong></h2>

<p>Většina strojových instrukcí se zpracovává sekvenčně tak, jak jsou zapsány
za sebou. Výjimkou je instrukce <strong>IT</strong> (ta však například na
<i>Cortex-M0+</i> chybí), a dále instrukce přímo či nepřímo manipulující
s&nbsp;obsahem registru <strong>PC</strong> (<i>Program Counter</i> neboli
programový čítač). Jednu z&nbsp;těchto instrukcí už jsme viděli &ndash; jedná
se o instrukci <strong>POP</strong> v&nbsp;případě, že má nastaven příznakový
bit &bdquo;obnov registr PC&ldquo;. Ovšem kromě toho lze programový čítač
modifikovat i instrukcemi skoku resp.&nbsp;rozeskoku, protože na architektuře
ARM jsou tyto instrukce nazývány <i>branch</i> a nikoli <i>jump</i>.</p>

<p>Nejjednodušší je v&nbsp;tomto ohledu instrukce pojmenovaná jediným písmenem:
<strong>B</strong>. Jedná se o nepodmíněný skok na zadanou adresu.
V&nbsp;instrukčním slovu této instrukce je uložen jedenáctibitový offset, takže
nepodmíněné skoky jsou v&nbsp;tomto ohledu pouze &bdquo;lokální&ldquo;;
konkrétně v&nbsp;rozsahu 2kB. To však většinou nevadí, protože se stejně
neprovádí skoky mimo právě prováděnou proceduru (potom by se jednalo o
instrukci <strong>BL</strong> neboli <i>branch and link</i>.</p>

<p>Formát instrukce <strong>B</strong> již známe:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 |             11bitový offset               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Cíl skoku musí být pojmenovaný. V&nbsp;klasických assemblerech se pro tento
účel používají takzvaná návěští (<i>label</i>), z&nbsp;nichž se
v&nbsp;MicroPythonu stala pseudofunkce pojmenovaná taktéž
<strong>label</strong>. Způsob jejího použití je ukázán v&nbsp;navazující
kapitole.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Překlad instrukce nepodmíněného skoku na zadané návěští</h2>

<p>Kombinaci instrukce <strong>B</strong> s&nbsp;návěštím si ukážeme na velmi
jednoduchém demonstračním příkladu, který obsahuje instrukci skoku, jenž
přeskočí druhou instrukci <strong>MOV</strong> (jakoby byla umístěna do větve
<strong>if False:</strong>). Tento příklad je samozřejmě umělý, ovšem jedná se
o tu nejjednodušší možnost, jak návěští a skok použít:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>branch</strong>():
    mov(r0, 42)
    b(cil_skoku)
    mov(r0, 99)
    label(cil_skoku)
</pre>

<p>V&nbsp;případě, že tuto funkci zavoláme ve smyčce REPL MicroPythonu, měla by
se vypsat hodnota 42 vrácená v&nbsp;pracovním registru <strong>R0</strong>. To
tedy znamená, že instrukce <strong>mov r0, 99</strong> se nespustila:</p>

<pre>
&gt;&gt;&gt; <strong>branch()</strong>
42
</pre>

<p>Zajímavé bude se podívat na způsob překladu výše uvedené sekvence instrukcí
do strojového kódu:</p>

<pre>
&gt;&gt;&gt; <strong>inspect(branch)</strong>
&nbsp;
function object at: 0x20008730
number of args: 0
machine code at: 0x200088c0
-- code --
f2 b5 2a 20 00 e0 63 20 f2 bd 00 00 00 00 00 00 
----------
</pre>

<p>Disassembler v&nbsp;této sekvenci bajtů korektně našel pětici instrukcí.
Povšimněte si hodnoty u instrukce <strong>B</strong>. Tato hodnota značí
absolutní adresu (první instrukce je na adrese 0, druhá na adrese 2, atd.
atd.). Tato hodnota byla dopočítána disassemblerem:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
movs r0, #0x2a
b #8
movs r0, #0x63
pop {r1, r4, r5, r6, r7, pc}
</pre>

<p>Ve skutečnosti je totiž instrukce skoku reprezentována těmito dvěma
bajty:</p>

<pre>
00 e0
</pre>

<p>Což můžeme snadno rozkódovat tak, že zapsaný offset je nulový. Je tomu tak
proto, že PC již při výpočtu cílové adresy obsahuje hodnotu zvýšenou o 4:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 |             11bitový offset               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Abychom si ukázali roli offsetu, zkusme nyní přeskočit nikoli jednu, ale tři
instrukce:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>branch</strong>():
    mov(r0, 42)
    b(cil_skoku)
    mov(r0, 99)
    mov(r0, 0)
    mov(r0, 1)
    label(cil_skoku)
</pre>

<p>Překlad do strojového kódu vypadá následovně:</p>

<pre>
&gt;&gt;&gt; <strong>inspect(branch)</strong>
&nbsp;
function object at: 0x20008ff0
number of args: 0
machine code at: 0x200091b0
-- code --
f2 b5 2a 20 02 e0 63 20 00 20 01 20 f2 bd 00 00 
----------
</pre>

<p>Zpětný překlad disassemblerem ukazuje, že skok bude proveden na adresu 0xc
(opět se tedy počítá s&nbsp;tím, že kód začíná na nule):</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
movs r0, #0x2a
b #0xc
movs r0, #0x63
movs r0, #0
movs r0, #1
pop {r1, r4, r5, r6, r7, pc}
</pre>

<p>Ovšem samotná instrukce skoku je zakódována do následující dvojice
bajtů:</p>

<pre>
02 e0
</pre>

<p>První bajt v&nbsp;tomto případě obsahuje offset (=2), a to z&nbsp;toho
důvodu, že všechny instrukce Thumb jsou 16bitové a nemá tedy smysl počítat
s&nbsp;lichými adresami (dolní bit offsetu tudíž bude vždy nulový a proto ho
není zapotřebí nikde ukládat):</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 |             11bitový offset               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Skok zpět</h2>

<p>Jenže výpočet offsetu nás přivádí k&nbsp;dalšímu problému, a to konkrétně ke
skoku zpět &ndash; na nižší adresy. To je samozřejmě potřebná instrukce
používaná pro implementaci programových smyček atd. Vyzkoušejme si takový
zpětný skok naprogramovat:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>branch</strong>():
    mov(r0, 42)
    b(cil_skoku)
    label(skok_zpet)
    mov(r0, 99)
    <u>b(skok_zpet)</u>
    mov(r0, 1)
    label(cil_skoku)
</pre>

<p>Opět si necháme provést zpětný překlad (disassembling) na základě bajtů se
strojovým kódem:</p>

<pre>
&gt;&gt;&gt; inspect(branch)
&nbsp;
function object at: 0x200095c0
number of args: 0
machine code at: 0x20009780
-- code --
f2 b5 2a 20 02 e0 63 20 fd e7 01 20 f2 bd 00 00 
----------
</pre>

<p>Výsledek disassemblingu ukazuje, že cíle skoku jsou v&nbsp;pořádku, a to i u
druhé instrukce <strong>B</strong> provádějící skok zpět, tj.&nbsp;na nižší
adresy:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
movs r0, #0x2a
b #0xc
movs r0, #0x63
b #6
movs r0, #1
pop {r1, r4, r5, r6, r7, pc}
</pre>

<p>Samotná instrukce druhého skoku je zakódována následovně:</p>

<pre>
fd e7
</pre>

<p>Nyní je offset binárně reprezentován hodnotou 11111111101. Jedná se o
hodnotu v&nbsp;dvojkovém doplňku a tudíž lze snadno spočítat, že desítkový
offset reprezentovaný tímto binárním číslem je -3:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 |             11bitový offset               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Skok zpět na samou instrukci skoku by měl mít offset -2, takže offset=-3
značí skok na instrukci uvedenou těsně <i>před</i> instrukcí skoku.</p>

<p><div class="rs-tip-major">Poznámka: tyto výpočty pochopitelně nemusíme dělat
ručně; právě z&nbsp;tohoto důvodu máme k&nbsp;dispozici pseudofunkci
<strong>label</strong>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Stavové registry na mikroprocesorech s&nbsp;architekturou ARM</h2>

<p>Kromě patnácti 32bitových pracovních registrů a programového čítače obsahují
mikroprocesory s&nbsp;architekturou ARM i registry, v&nbsp;nichž se uchovávají
různé příznaky. V&nbsp;uživatelském režimu se pracuje s&nbsp;příznaky uloženými
v&nbsp;registru nazvaném CPSR (<i>Current Program Status Register</i>) a pro
každý další režim existuje navíc zvláštní registr nazvaný SPSR (<i>Saved
Program Status Register</i>), v&nbsp;němž jsou uchovány původní příznaky ze
CPSR. Podobně jako všechny pracovní registry, mají i registry CPSR a SPSR
shodnou šířku 32 bitů, což má svoje výhody. Mimo jiné i to, že šířka 32 bitů
ponechala konstruktérům procesorů ARM mnoho prostoru pro uložení různých
důležitých informací do registrů CPSR/SPSR, takže se nemuseli uchylovat
k&nbsp;nepříliš promyšleným technikám známým například z&nbsp;platformy x86,
kde se původně šestnáctibitový registr FLAGS (8086) postupně změnil na 32bitový
registr EFLAGS (80386), vedle něho vznikl registr MSW (80286) rozšířený na CR0
atd.</p>

<p><div class="rs-tip-major">Poznámka: na některých mikrořadičích Cortex-M se
používá jen jediný režim a tedy i jediný registr PSR.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Příznakové a stavové bity na mikroprocesorech s&nbsp;architekturou ARM</h2>

<p>Ve výše zmíněných stavových registrech CPSR/SPSR mikroprocesorů ARM jsou
uloženy především příznakové bity nastavované aritmeticko-logickou jednotkou
při provádění základních aritmetických instrukcí či bitových operací, dále pak
bity určující, jakou instrukční sadu mikroprocesor v&nbsp;daný okamžik
zpracovává (ARM, Thumb, Jazelle &ndash; na Cortex-M se nemění), příznak pořadí
zpracovávání bajtů (little/big endian) a taktéž příznaky používané u SIMD
operací. Zdaleka ne všechny mikroprocesory ARM však skutečně pracují se všemi
bity, což je logické, protože například příznak Q je používán jen u
mikroprocesorů podporujících aritmetiku se saturací, příznak J u čipů
s&nbsp;podporou technologie Jazelle atd. Pojďme si tedy jednotlivé příznakové i
stavové bity vypsat:</p>

<table>
<tr><th>Příznak</th><th>Význam zkratky</th><th>Poznámka</th></tr>
<tr><td>N </td><td>negative</td><td>výsledek ALU operace je záporný</td></tr>
<tr><td>V </td><td>overflow</td><td>přetečení (znaménková aritmetika, signed)</td></tr>
<tr><td>Z </td><td>zero</td><td>výsledek je nulový</td></tr>
<tr><td>C </td><td>carry</td><td>přenos (bezznaménková aritmetika, unsigned)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Q </td><td>sticky overflow</td><td>aritmetika se saturací, od ARMv5e výše</td></tr>
<tr><td>I </td><td>interrupt</td><td>zákaz IRQ (přerušení)</td></tr>
<tr><td>F </td><td>fast interrupt</td><td>zákaz FIRQ (rychlého přerušení)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>T </td><td>thumb</td><td>příznak zpracování instrukční sady Thumb (jen u procesorů se znakem "T" v názvu)</td></tr>
<tr><td>J </td><td>jazelle</td><td>příznak zpracování instrukční sady Jazelle (jen u procesorů se znakem "J" v názvu)</td></tr>
<tr><td>E </td><td>endianness</td><td>pořadí bajtů při práci s RAM (big/little endian)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>GE</td><td>4 bity</td><td>použito u SIMD operací (pouze některé čipy)</td></tr>
<tr><td>IF</td><td>5 bitů</td><td>použito u instrukcí Thumb2 (pouze některé čipy)</td></tr>
<tr><td>M </td><td>5 bitů</td><td>režim práce mikroprocesoru (user, IRQ, FIRQ, ...)</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Podmínky specifikované u instrukcí skoku (<i>condition codes</i>)</h2>

<p>U instrukce podmíněného skoku <strong>B(podmínka)</strong> lze uvést 14
různých podmínek (15 pokud počítáme i Any/Always).</p>

<p>První sada podmínkových kódů se používá pro provedení či naopak neprovedení
instrukce na základě hodnoty jednoho z&nbsp;příznakových bitů <i>zero</i>,
<i>overflow</i> či <i>negative</i>. Poslední podmínkový kód z&nbsp;této skupiny
má název <strong>AL</strong> (<i>Any/Always</i>) a značí, že se instrukce
provede v&nbsp;každém případě (ovšem u instrukční sady Thumb nelze použít):</p>

<table>
<tr><th>Kód</th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0000</td><td>EQ</td><td>Z set</td><td> rovnost (či nulový výsledek)</td></tr>
<tr><td>0001</td><td>NE</td><td>Z clear</td><td> nerovnost (či nenulový výsledek)</td></tr>
<tr><td>0100</td><td>MI</td><td>N set</td><td> výsledek je záporný</td></tr>
<tr><td>0101</td><td>PL</td><td>N clear</td><td> výsledek je kladný či 0</td></tr>
<tr><td>0110</td><td>VS</td><td>V set</td><td> nastalo přetečení</td></tr>
<tr><td>0111</td><td>VC</td><td>V clear</td><td> nenastalo přetečení</td></tr>
<tr><td>1110</td><td>AL</td><td>Any/Always</td><td> většinou se nezapisuje, implicitní podmínka</td></tr>
</table>                                           

<p>Další čtyři podmínkové kódy se většinou používají při porovnávání dvou
hodnot bez znaménka (<i>unsigned</i>). V&nbsp;těchto případech se testují stavy
příznakových bitů <i>carry</i> a <i>zero</i>, přesněji řečeno kombinací těchto
bitů:</p>

<table>
<tr><th>Kód</th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0010</td><td>CS/HS</td><td>C set            </td><td>&gt;=</td></tr>
<tr><td>0011</td><td>CC/LO</td><td>C clear          </td><td>&lt; </td></tr>
<tr><td>1000</td><td>HI   </td><td>C set and Z clear</td><td>&gt; </td></tr>
<tr><td>1001</td><td>LS   </td><td>C clear or Z set </td><td>&lt;=</td></tr>
</table>                                           

<p>Poslední čtyři podmínkové kódy se používají pro porovnávání hodnot se
znaménkem (<i>signed</i>). V&nbsp;těchto případech se namísto příznakových bitů
<i>carry</i> a <i>zero</i> testují kombinace bitů <i>negative</i>,
<i>overflow</i> a <i>zero</i>:</p>

<table>
<tr><th>Kód</th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>1010</td><td>GE</td><td>N and V the same</td><td>&gt;=</td></tr>
<tr><td>1011</td><td>LT</td><td>N and V differ  </td><td>&lt; </td></tr>
<tr><td>1100</td><td>GT</td><td>Z clear, N == V </td><td>&gt; </td></tr>
<tr><td>1101</td><td>LE</td><td>Z set, N != V   </td><td>&lt;=</td></tr>
</table>                                           



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce podmíněného skoku a jednoduchá počítaná programová smyčka</h2>

<p>Již minule jsme si řekli, že pro skoky s&nbsp;podmínku je rezervován jen
osmibitový offset, protože celkem čtyři bity zabírají kódy podmínky popsané
v&nbsp;předchozí kapitole:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 1 |   podmínka    |        8bitový offset         |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>



<pre>
@micropython.asm_thumb
def loop():
    mov(r0, 0)
    mov(r1, 100)
    label(loop)
    add(r0, r0, 4)
    sub(r1, r1, 1)
    cmp(r1, 0)
    bne(loop)
</pre>

&gt;&gt;&gt; loop()
400

<pre>
&gt;&gt;&gt; inspect(loop)
function object at: 0x2000ace0
number of args: 0
machine code at: 0x2000af10
-- code --
f2 b5 00 20 64 21 00 1d 49 1e 00 29 fb d1 f2 bd 
----------
</pre>

<pre>
push {r1, r4, r5, r6, r7, lr}
movs r0, #0
movs r1, #0x64
adds r0, r0, #4
subs r1, r1, #1
cmp r1, #0
bne #6
pop {r1, r4, r5, r6, r7, pc}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Nastavení příznakových bitů u aritmetických instrukcí</h2>

<table>
<tr><th>Instrukce</th><th>Nastavované příznaky</th><th>Prováděná operace</th></tr>
<tr><td>ADDS Rd, Rn, #&lt;imm&gt;</td><td>N Z C V</td><td>Rd := Rn + imm</td></tr>
<tr><td>ADDS Rd, Rn, Rm</td><td>N Z C V</td><td>Rd := Rn + Rm</td></tr>
<tr><td>ADD Rd, Rd, Rm</td><td>&nbsp;</td><td>Rd := Rd + Rm</td></tr>
<tr><td>ADDS Rd, Rd, #&lt;imm&gt;</td><td>N Z C V</td><td>Rd := Rd + imm</td></tr>
<tr><td>ADCS Rd, Rd, Rm</td><td>N Z C V</td><td>Rd := Rd + Rm + C-bit</td></tr>
<tr><td>ADD SP, SP, #&lt;imm&gt;</td><td>&nbsp;</td><td>SP := SP + imm</td></tr>
<tr><td>ADD Rd, SP, #&lt;imm&gt;</td><td>&nbsp;</td><td>Rd := SP + imm</td></tr>
<tr><td>ADR Rd, &lt;label&gt;</td><td>&nbsp;</td><td>Rd := label</td></tr>
</table>

<table>
<tr><th>Instrukce</th><th>Nastavované příznaky</th><th>Prováděná operace</th></tr>
<tr><td>SUBS Rd, Rn, Rm</td><td>N Z C V</td><td>Rd := Rn - Rm</td></tr>
<tr><td>SUBS Rd, Rn, #&lt;imm&gt;</td><td>N Z C V</td><td>Rd := Rn - imm</td></tr>
<tr><td>SUBS Rd, Rd, #&lt;imm&gt;</td><td>N Z C V</td><td>Rd := Rd - imm</td></tr>
<tr><td>SBCS Rd, Rd, Rm</td><td>N Z C V</td><td>Rd := Rd - Rm - NOT C-bit</td></tr>
<tr><td>SUB SP, SP, #&lt;imm&gt; </td><td>&nbsp;</td><td>SP := SP - imm</td></tr>
</table>







<pre>
@micropython.asm_thumb
def loop():
    mov(r0, 0)
    mov(r1, 100)
    label(loop)
    add(r0, r0, 4)
    sub(r1, r1, 1)
    bne(loop)
</pre>




<pre>
@micropython.asm_thumb
def loop():
    mov(r0, 0)
    mov(r1, 100)
    label(outer_loop)
    mov(r2, 100)
    label(inner_loop)
    add(r0, r0, 1)
    sub(r2, r2, 1)
    bne(inner_loop)
    sub(r1, r1, 1)
    bne(outer_loop)
</pre>
<p></p>

>>> loop()
10000

>>> inspect(loop, nbytes=20)
function object at: 0x2000bde0
number of args: 0
machine code at: 0x2000bfa0
-- code --
f2 b5 00 20 64 21 64 22 40 1c 52 1e fc d1 49 1e f9 d1 f2 bd 
----------

<pre>
push {r1, r4, r5, r6, r7, lr}
movs r0, #0
movs r1, #0x64
movs r2, #0x64
adds r0, r0, #1
subs r2, r2, #1
bne #8
subs r1, r1, #1
bne #6
pop {r1, r4, r5, r6, r7, pc}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Zjednodušená programová smyčka</h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Vnořené programové smyčky</h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
MicroPython běžící na čipech s&nbsp;architekturou Cortex-M0+
popř.&nbsp;Cortex-M3/M4 (a otestovaných na RP2040) byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th>#</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>return_constant.py</td><td>návratová hodnota z&nbsp;funkce s&nbsp;Thumb instrukcemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_constant.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_constant.py</a></td></tr>
<tr><td>2</td><td>return_big_constant_1.py</td><td>pokus o vrácení příliš velké konstanty (nekorektní)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_1.py</a></td></tr>
<tr><td>3</td><td>return_big_constant_2.py</td><td>pokus o vrácení příliš velké konstanty (nekorektní na Cortex-M0+)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_2.py</a></td></tr>
<tr><td>4</td><td>return_big_constant_3.py</td><td>vrácení 32bitové konstanty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>inc1.py</td><td>předání argumentu do funkce s&nbsp;Thumb instrukcemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc1.py</a></td></tr>
<tr><td>6</td><td>inc2.py</td><td>pokus o předání argumentu v&nbsp;parametru špatného jména</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>add.py</td><td>součet dvou předaných argumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add.py</a></td></tr>
<tr><td>8</td><td>add_four.py</td><td>součet čtyř předaných argumentů (nekorektní)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_four.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_four.py</a></td></tr>
<tr><td>9</td><td>add_five.py</td><td>součet pěti předaných argumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_five.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_five.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>inspect_function.py</td><td>získání strojového kódu přeložených funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function.py</a></td></tr>
<tr><td>11</td><td>no_op.py</td><td>funkce bez příkazů, která se má přeložit do strojového kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/no_op.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/no_op.py</a></td></tr>
<tr><td>12</td><td>branch1.py</td><td>využití instrukce nepodmíněného skoku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch1.py</a></td></tr>
<tr><td>13</td><td>branch2.py</td><td>skok dopředu o několik instrukcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch2.py</a></td></tr>
<tr><td>14</td><td>branch3.py</td><td>skok vzad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch3.py</a></td></tr>
<tr><td>15</td><td>loop1.py</td><td>programová smyčka s&nbsp;počitadlem a podmíněným skokem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop1.py</a></td></tr>
<tr><td>16</td><td>loop2.py</td><td>zjednodušená varianta programové smyčky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop2.py</a></td></tr>
<tr><td>17</td><td>loop3.py</td><td>vnořené programové smyčky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop3.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Online ARM converter<br />
<a href="https://armconverter.com/?disasm">https://armconverter.com/?disasm</a>
</li>

<li>Fast Filters for the Pyboard<br />
<a href="https://github.com/peterhinch/micropython-filters">https://github.com/peterhinch/micropython-filters</a>
</li>

<li>How to load 32 bit constant from assembler with @micropython.asm_thumb<br />
<a href="https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a">https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a</a>
</li>

<li>Pi pico, micropython.asm_thumb: ADR Rd, &lt;label&gt; and LDR Rd, &lt;label&gt; not implemented?<br />
<a href="https://github.com/orgs/micropython/discussions/12257">https://github.com/orgs/micropython/discussions/12257</a>
</li>

<li>MicroPython documentation<br />
<a href="https://docs.micropython.org/en/latest/index.html">https://docs.micropython.org/en/latest/index.html</a>
</li>

<li>Inline assembler for Thumb2 architectures<br />
<a href="https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html">https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html</a>
</li>

<li>Inline assembler in MicroPython<br />
<a href="https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler">https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami (2)<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>Cortex-M0 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M0">https://en.wikipedia.org/wiki/ARM_Cortex-M0</a>
</li>

<li>Cortex-M0+ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B">https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>The Thumb instruction set<br />
<a href="http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf">http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

