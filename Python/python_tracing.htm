<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Trasování aplikací naprogramovaných v Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Trasování aplikací naprogramovaných v Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s trojicí nástrojů určených pro trasování (sledování) aplikací naprogramovaných v Pythonu. Kromě standardního nástroje nazvaného trace se jedná o pomocnou utilitu coverage a především o nástroj pycrunch-pytrace s vlastním GUI.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Krátká lekce z&nbsp;historie: příkazy <strong>TRON</strong> a <strong>TROFF</strong></a></p>
<p><a href="#k02">2. Standardní modul <strong>trace</strong></a></p>
<p><a href="#k03">3. Zjištění počtu průchodů jednotlivými řádky skriptu či skriptů</a></p>
<p><a href="#k04">4. Detekce řádků s&nbsp;&bdquo;mrtvým&ldquo; kódem</a></p>
<p><a href="#k05">5. Tisk seznamu funkcí, které byly zavolány</a></p>
<p><a href="#k06">6. Seznam se vzájemnými vztahy mezi funkcemi (které funkce jsou volány)</a></p>
<p><a href="#k07">7. Úplné trasování, informace o relativních časech při trasování</a></p>
<p><a href="#k08">8. Pomocný nástroj <strong>coverage.py</strong></a></p>
<p><a href="#k09">9. Spuštění aplikace přes nástroj <strong>coverage.py</strong></a></p>
<p><a href="#k10">10. Zobrazení výsledků</a></p>
<p><a href="#k11">11. Anotace zdrojového kódu</a></p>
<p><a href="#k12">12. Export výsledků do formátů JSON a XML</a></p>
<p><a href="#k13">13. Zobrazení výsledků ve formě vygenerovaných HTML stránek</a></p>
<p><a href="#k14">14. Interní struktura s&nbsp;informacemi o trasování (SQLite databáze)</a></p>
<p><a href="#k15">15. Nástroj <strong>pycrunch-pytrace</strong></a></p>
<p><a href="#k16">16. Instalace nástroje <strong>pycrunch-pytrace</strong></a></p>
<p><a href="#k17">17. Úprava trasovaného skriptu a spuštění trasování</a></p>
<p><a href="#k18">18. Prohlédnutí výsledků trasování v&nbsp;GUI</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Krátká lekce z&nbsp;historie: příkazy <strong>TRON</strong> a <strong>TROFF</strong></h2>

<p>Již starodávný interpret BASICu pojmenovaný <i>GW-BASIC</i>, který pochází
z&nbsp;roku 1983, obsahoval základní prostředky použitelné pro ladění aplikací.
Zatímco v&nbsp;současných vývojových prostředích je běžné, že uživatel může
postupně krokovat jednotlivými příkazy laděné aplikace a přitom si vypisovat
obsah proměnných (popř.&nbsp;obsah proměnných měnit či modifikovat vlastní
programový kód), na počátku osmdesátých let minulého století nebyly dostupné
vývojové prostředky na mikropočítačích zdaleka tak dokonalé.
V&nbsp;<i>GW-BASICu</i> bylo samozřejmě možné, podobně jako v&nbsp;prakticky
všech interpretrech <i>BASICu</i>, vypisovat hodnoty proměnných či celých
výrazů, spouštět program od místa kde byl zastaven, provést skok na libovolný
programový řádek atd. Navíc však <i>GW-BASIC</i> obsahoval i velmi užitečný
příkaz <strong>TRON</strong> (<i>trace on</i>), který prováděl přesně to, co
jeho název napovídá &ndash; po spuštění programu vypisoval čísla řádků, kterými
interpret při běhu programu prošel, takže programátor mohl po ukončení (pádu
:-) programu alespoň částečně zrekonstruovat, co jeho aplikace ve skutečnosti
prováděla.</p>

<a href="https://i.iinfo.cz/images/354/pc120-6.png"><img src="https://i.iinfo.cz/images/354/pc120-6-prev.png" width="370" height="231" alt="TROFF"></a>
<p><i>Obrázek 1: Program spuštěný (interpretovaný) běžných způsobem, na
obrazovku vypisuje pouze svůj výstup – sekvenci čísel 1 až 10.</i></p>

<p>Na druhém obrázku je ukázáno, jak se bude běh (tj.&nbsp;ve skutečnosti
interpretace) programu lišit po zadání příkazu <strong>TRON</strong>. Pokud je
tento příkaz aktivní, vypisují se při interpretaci programu do hranatých
závorek čísla programových řádků, kterými program při svém běhu prochází.
V&nbsp;demonstračním příkladu ukázaném na druhém obrázku jsou čísla řádků
prokládána samotným výstupem programu, konkrétně výsledkem příkazu
<strong>PRINT A</strong>. Pokud by program na výstup neposílal žádný text, byla
by výsledkem jeho běhu pouze řada čísel umístěná do hranatých závorek. Příkaz
<strong>TRON</strong> je možné deaktivovat příkazem <strong>TROFF</strong>
(<i>trace off</i>).</p>

<a href="https://i.iinfo.cz/images/354/pc120-7.png"><img src="https://i.iinfo.cz/images/354/pc120-7-prev.png" width="370" height="231" alt="TRON"></a>
<p><i>Obrázek 2: Běh programu po zadání příkazu <strong>TRON</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;některých materiálech se můžeme
dočíst, že název známého filmu <i>TRON</i>, v&nbsp;němž byla jako v&nbsp;jednom
z&nbsp;prvních filmů použita trojrozměrná renderovaná počítačová grafika, je
odvozen právě do BASICovského příkazu <strong>TRON</strong>, ovšem režisér
<i>Steven Lisberger</i> to popírá a tvrdí, že název filmu získal ze slova
&bdquo;elec<strong>tron</strong>ic&ldquo;.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Standardní modul <strong>trace</strong></h2>

<p>Vývojáři používající jazyk Python mají k&nbsp;dispozici hned několik
nástrojů určených pro sledování (trasování) běhu programu. Jeden z&nbsp;těchto
nástrojů se jmenuje příznačně <strong>trace</strong> a jeho nespornou předností
je fakt, že je již součástí standardní knihovny Pythonu (tedy patří do skupiny
nástrojů shrnutých pod heslem &bdquo;batteries included&ldquo;). Příklad
použití tohoto nástroje si ukážeme na velmi jednoduchém skriptu, jenž obsahuje
implementaci rekurzivního algoritmu pro výpočet faktoriálu. Jedná se tedy o
klasický &bdquo;školní&ldquo; algoritmus, který pravděpodobně není nutné
podrobněji popisovat:</p>

<pre>
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
&nbsp;
def <strong>factorial</strong>(n):
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    assert isinstance(n, int), "Integer expected"
&nbsp;
    if n &lt; 0:
        return None
    if n == 0:
        return 1
    result = n * factorial(n-1)
&nbsp;
    assert isinstance(result, int), "Internal error in factorial computation"
    return result
&nbsp;
&nbsp;
def <strong>main</strong>():
    for n in range(0, 11):
        print(n, factorial(n))
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zjištění počtu průchodů jednotlivými řádky skriptu či skriptů</h2>

<p>První informací, kterou s&nbsp;využitím základního modulu
<strong>trace</strong> můžeme zjistit, je počet průchodů jednotlivými řádky
spouštěného skriptu nebo skriptů (pochopitelně psaných v&nbsp;Pythonu). Pokud
například budeme chtít zjistit, kolikrát jsou provedeny (vykonány) řádky ve
skriptu pro výpočet faktoriálu, postačuje použít tento příkaz:</p>

<pre>
$ <strong>python3 -m trace --count -C . factorial.py</strong>
</pre>

<p>Výsledkem by měl být soubor nazvaný <strong>factorial.cover</strong>
s&nbsp;tímto obsahem:</p>

<pre>
    1: """Výpočet faktoriálu."""
&nbsp;
&nbsp;
    1: def factorial(n):
           """Rekurzivní výpočet faktoriálu."""
   66:     assert isinstance(n, int), "Integer expected"
&nbsp;
   66:     if n &lt; 0:
               return None
   66:     if n == 0:
   11:         return 1
   55:     result = n * factorial(n-1)
&nbsp;
   55:     assert isinstance(result, int), "Internal error in factorial computation"
   55:     return result
&nbsp;
&nbsp;
    1: def main():
   12:     for n in range(0, 11):
   11:         print(n, factorial(n))
&nbsp;
&nbsp;
    1: if __name__ == "__main__":
    1:     main()
</pre>

<p>Povšimněte si, že i dokumentační řetězce jsou spuštěny a vyhodnocovány (jde
totiž o výrazy, jejichž výsledek je zahozen). To si ostatně můžeme snadno
ověřit:</p>

<pre>
"""Test."""
# test
"Test."
# test
</pre>

<p>Výsledek trasování tohoto skriptu:</p>

<pre>
    1: """Test."""
       # test
    1: "Test."
       # test
</pre>

<p>Vidíme, že dokumentační i běžné řetězce jsou skutečně považovány za příkazy,
kdežto komentáře nikoli.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Detekce řádků s&nbsp;&bdquo;mrtvým&ldquo; kódem</h2>

<p>Ve výpisu <a href="#k03">z&nbsp;předchozí kapitoly</a> se nachází i jeden
řádek, který nebyl spuštěn ani jednou:</p>

<pre>
    1: """Výpočet faktoriálu."""
&nbsp;
&nbsp;
    1: def factorial(n):
           """Rekurzivní výpočet faktoriálu."""
   66:     assert isinstance(n, int), "Integer expected"
&nbsp;
   66:     if n &lt; 0:
               <strong>return None</strong>
   66:     if n == 0:
   11:         return 1
   55:     result = n * factorial(n-1)
&nbsp;
   55:     assert isinstance(result, int), "Internal error in factorial computation"
   55:     return result
&nbsp;
&nbsp;
    1: def main():
   12:     for n in range(0, 11):
   11:         print(n, factorial(n))
&nbsp;
&nbsp;
    1: if __name__ == "__main__":
    1:     main()
</pre>

<p>V&nbsp;delším skriptu je mnohdy obtížné takové řádky najít; proto modul
<strong>trace</strong> podporuje volbu <strong>-m</strong>, která takové
&bdquo;mrtvé&ldquo; příkazy zvýrazní:</p>

<pre>
$ <strong>python3 -m trace --count -m -C . factorial.py</strong>
</pre>

<p>Nyní vypadá výsledek následovně &ndash; řádek s&nbsp;&bdquo;mrtvým&ldquo;
kódem je zvýrazněn pomocí znaků &gt;&gt;&gt;&gt;&gt;&gt;:</p>

<pre>
    1: """Výpočet faktoriálu."""
&nbsp;
&nbsp;
    1: def factorial(n):
           """Rekurzivní výpočet faktoriálu."""
   66:     assert isinstance(n, int), "Integer expected"
&nbsp;
   66:     if n &lt; 0:
<strong>&gt;&gt;&gt;&gt;&gt;&gt;         return None</strong>
   66:     if n == 0:
   11:         return 1
   55:     result = n * factorial(n-1)
&nbsp;
   55:     assert isinstance(result, int), "Internal error in factorial computation"
   55:     return result
&nbsp;
&nbsp;
    1: def main():
   12:     for n in range(0, 11):
   11:         print(n, factorial(n))
&nbsp;
&nbsp;
    1: if __name__ == "__main__":
    1:     main()
</pre>

<p>Zobrazit je možné i souhrnné informace o skriptech, jejichž řádky byly při
spuštění vyhodnoceny:</p>

<pre>
$ <strong>python3 -m trace --count --summary -C . factorial.py</strong>
</pre>

<p>Po spuštění předchozího příkazu se nejdříve zobrazí výstup produkovaný
samotným skriptem a posléze i souhrnné informace:</p>

<pre>
0 1
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3628800
&nbsp;
lines   cov%   module   (path)
   14   100%   factorial   (factorial.py)
    1   100%   trace   (/usr/lib64/python3.6/trace.py)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tisk seznamu funkcí, které byly zavolány</h2>

<p>Mnohdy nám postačuje znát pouze informace o funkcích (a pochopitelně i o
metodách), které byly při běhu skriptu zavolány. Jedná se o odlišný režim
nástroje <strong>trace</strong>, který se vybírá volbou
<strong>--listfuncs</strong> tak, jak je to ukázáno v&nbsp;dalším příkladu:</p>

<pre>
$ <strong>python3 -m trace --listfuncs -C . factorial.py</strong>
</pre>

<p>Nejprve se opět vypíšou výsledky produkované přímo při výpočtu
faktoriálu:</p>

<pre>
0 1
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3628800
</pre>

<p>Nakonec získáme seznam volaných funkcí, včetně pseudofunkce volané při
vstupu do modulu <strong>factorial</strong>:</p>

<pre>
functions called:
filename: /usr/lib64/python3.6/trace.py, modulename: trace, funcname: _unsettrace
filename: factorial.py, modulename: factorial, funcname: &lt;module&gt;
filename: factorial.py, modulename: factorial, funcname: factorial
filename: factorial.py, modulename: factorial, funcname: main
</pre>

<p><div class="rs-tip-major">Poznámka: zde je počet zobrazených informací
nižší, než v&nbsp;předchozích dvou příkladech, ovšem mnohdy plně
dostačuje.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Seznam se vzájemnými vztahy mezi funkcemi (které funkce jsou volány)</h2>

<p>Další potenciálně velmi užitečnou informací jsou vzájemné vztahy mezi
funkcemi, přesněji řečeno informace o tom, z&nbsp;jaké funkce došlo
k&nbsp;volání jiné či stejné (přímá rekurze) funkce. I tyto informace lze
standardním nástrojem <strong>trace</strong> získat, a to konkrétně při použití
přepínače <strong>--trackcalls</strong>. Opět se podívejme na demonstrační
příklad:</p>

<pre>
$ <strong>python3 -m trace --trackcalls -C . factorial.py</strong>
</pre>

<p>Po již obligátním výpisu tabulky s&nbsp;faktoriály...</p>

<pre>
0 1
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3628800
</pre>

<p>... se zobrazí následující řádky nabízející informace o <i>dynamických</i>
vztazích mezi funkcemi, tedy o vztazích, které mnohdy nelze získat pouhou
<i>statickou</i> analýzou zdrojových kódů:</p>

<pre>
calling relationships:
&nbsp;
*** /usr/lib64/python3.6/trace.py ***
    trace.Trace.runctx -&gt; trace._unsettrace
  --&gt; factorial.py
    trace.Trace.runctx -&gt; factorial.&lt;module&gt;
&nbsp;
*** factorial.py ***
    factorial.&lt;module&gt; -&gt; factorial.main
    factorial.factorial -&gt; factorial.factorial
    factorial.main -&gt; factorial.factorial
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplné trasování, informace o relativních časech při trasování</h2>

<p>Poslední vlastnost modulu <strong>trace</strong>, s&nbsp;níž se dnes
seznámíme, je možnost přímo při běhu skriptu současně vypisovat programové
řádky, které se právě provádí. Jedná se vlastně o vylepšenou variantu příkazu
<strong>TRON</strong>, která v&nbsp;mnoha BASICech vypisovala pouze čísla
řádků. V&nbsp;případě Pythonu a modulu <strong>trace</strong> se vypisují celé
řádky, nikoli jejich číslo (které má mimo BASIC jen omezený význam). Podívejme
se nyní na základní příklad použití:</p>

<pre>
$ <strong>python3 -m trace --trace -C . factorial.py &gt; factorial.trace</strong>
</pre>

<p>Po spuštění takto zapsaného příkazu se postupně začnou jednotlivé spouštěné
řádky vypisovat ve formátu jméno souboru(číslo řádku): programový řádek:</p>

<pre>
 --- modulename: factorial, funcname: &lt;module&gt;
factorial.py(1): """Výpočet faktoriálu."""
factorial.py(4): def factorial(n):
factorial.py(18): def main():
factorial.py(23): if __name__ == "__main__":
factorial.py(24):     main()
 --- modulename: factorial, funcname: main
factorial.py(19):     for n in range(0, 11):
factorial.py(20):         print(n, factorial(n))
 --- modulename: factorial, funcname: factorial
factorial.py(6):     assert isinstance(n, int), "Integer expected"
factorial.py(8):     if n &lt; 0:
factorial.py(10):     if n == 0:
factorial.py(11):         return 1
    ...
    ...
    ...
</pre>

<p><div class="rs-tip-major">Poznámka: celý soubor vygenerovaný předchozím
příkazem je dostupný na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.trace">https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.trace</a>.</div></p>

<p>Navíc je možné ke každému vypsanému řádku přidat i relativní čas
(v&nbsp;sekundách) počítaný od doby spuštění programu:</p>

<pre>
$ <strong>python3 -m trace --trace -g -C . factorial.py &gt; factorial.timing</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
 --- modulename: factorial, funcname: <module>
0.00 factorial.py(1): """Výpočet faktoriálu."""
0.00 factorial.py(4): def factorial(n):
0.00 factorial.py(18): def main():
0.00 factorial.py(23): if __name__ == "__main__":
0.00 factorial.py(24):     main()
 --- modulename: factorial, funcname: main
0.00 factorial.py(19):     for n in range(0, 11):
0.00 factorial.py(20):         print(n, factorial(n))
 --- modulename: factorial, funcname: factorial
0.00 factorial.py(6):     assert isinstance(n, int), "Integer expected"
0.00 factorial.py(8):     if n &lt; 0:
0.00 factorial.py(10):     if n == 0:
0.00 factorial.py(11):         return 1
    ...
    ...
    ...
</pre>

<p><div class="rs-tip-major">Poznámka: celý soubor vygenerovaný předchozím
příkazem je dostupný na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.timing">https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.timing</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pomocný nástroj <strong>coverage.py</strong></h2>

<p>V&nbsp;seriálu o testování v&nbsp;Pythonu jsme se mj.&nbsp;seznámili i
s&nbsp;užitečným nástrojem <strong>pytest-cov</strong>, který dokáže zjistit,
které části kódu jsou pokryté jednotkovými testy (tedy které programové řádky
jsou skutečně zavolány). Podobnou informaci je ovšem možné zjistit i pro běžně
spouštěné skripty &ndash; tedy jde nám o výpis informací o těch řádcích kódu,
které byly skutečně spuštěny a které naopak nebyly, a to buď z&nbsp;toho
důvodu, že nebyly splněny nějaké podmínky, nedošlo k&nbsp;chybě popř.&nbsp;jsou
dané řádky zbytečné z&nbsp;důvodu logické chyby v&nbsp;přepisovaném algoritmu.
Tyto informace lze v&nbsp;přehledné podobě získat s&nbsp;využitím nástroje
<strong>coverage.py</strong>, který existuje i ve výše zmíněné variantě
<strong>pytest-cov</strong>.</p>

<p>Instalace nástroje <strong>coverage.py</strong> je přímočará, protože se
jedná o balíček dostupný na PyPi:</p>

<pre>
$ <strong>pip3 install --user coverage</strong>
</pre>

<p>Průběh instalace:</p>

<pre>
Collecting coverage
  Downloading https://files.pythonhosted.org/packages/5a/0d/a1cb46ee9b9f6369e2bcf72b8277654a806bdf3f17f724be24a3a72afdc3/coverage-5.4-cp38-cp38-manylinux2010_x86_64.whl (245kB)
     |████████████████████████████████| 245kB 1.9MB/s
Installing collected packages: coverage
Successfully installed coverage-5.4
</pre>

<p>Po instalaci se přesvědčíme, že je nástroj <strong>coverage.py</strong>
volatelný přímo z&nbsp;příkazové řádky:</p>

<pre>
$ <strong>coverage help</strong>
&nbsp;
Coverage.py, version 5.4 with C extension
Measure, collect, and report on code coverage in Python programs.
&nbsp;
usage: coverage &lt;command&gt; [options] [args]
&nbsp;
Commands:
    annotate    Annotate source files with execution information.
    combine     Combine a number of data files.
    debug       Display information about the internals of coverage.py
    erase       Erase previously collected coverage data.
    help        Get help on using coverage.py.
    html        Create an HTML report.
    json        Create a JSON report of coverage results.
    report      Report coverage stats on modules.
    run         Run a Python program and measure code execution.
    xml         Create an XML report of coverage results.
&nbsp;
Use "coverage help &lt;command&gt;" for detailed help on any command.
Full documentation is at https://coverage.readthedocs.io
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Spuštění aplikace přes nástroj <strong>coverage.py</strong></h2>

<p>Libovolný skript psaný v&nbsp;Pythonu by nyní mělo být možné spustit nepřímo
příkazem <strong>coverage</strong>, tedy následujícím způsobem:</p>

<pre>
$ <strong>coverage run factorial.py</strong>
</pre>

<p>Skript se zdánlivě spustí naprosto normálním způsobem:</p>

<pre>
0 1
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3628800
</pre>

<p>Ve skutečnosti se ovšem průběžně vytváří soubor <strong>.coverage</strong>,
jehož obsah je dále zpracovatelný, což si ostatně ukážeme v&nbsp;navazujících
kapitolách.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zobrazení výsledků</h2>

<p>Výsledky získané nástrojem <strong>coverage</strong> je možné zobrazit
v&nbsp;několika podobách. Základem je tabulka obsahující jména jednotlivých
souborů se zdrojovými kódy, počet příkazů (<i>statements</i>) v&nbsp;každém
souboru, počet příkazů, které <i>nebyly</i> vykonány a konečně poměr vykonaných
příkazů ke všem příkazům.</p>

<p>Pro náš jednoduchý příklad s&nbsp;jediným skriptem bude výsledek vypadat
následovně:</p>

<pre>
$ <strong>coverage report</strong>
&nbsp;
Name           Stmts   Miss  Cover
----------------------------------
factorial.py      14      1    93%
----------------------------------
TOTAL             14      1    93%
</pre>

<p>Z&nbsp;výsledků můžeme vyčíst informaci, kterou již známe &ndash; jeden
z&nbsp;příkazů nebyl použit.</p>

<p>Pro složitější aplikaci skládající se z&nbsp;několika souborů se zdrojovými
texty bude výsledek vypadat takto:</p>

<pre>
$ <strong>coverage report</strong>
&nbsp;
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/gui/__init__.py                          0      0   100%
src/gui/canvas.py                            7      4    43%
src/gui/dialogs/__init__.py                  0      0   100%
src/gui/dialogs/about_dialog.py              4      1    75%
src/gui/dialogs/fractal_type_dialog.py      28     20    29%
src/gui/dialogs/help_dialog.py              34     28    18%
src/gui/icons.py                            19      8    58%
src/gui/main_window.py                      23     13    43%
src/gui/menubar.py                          36     29    19%
src/icons/__init__.py                        0      0   100%
src/icons/application_exit.py                1      0   100%
src/icons/edit.py                            1      0   100%
src/icons/file_open.py                       1      0   100%
src/icons/file_save.py                       1      0   100%
src/icons/file_save_as.py                    1      0   100%
src/icons/fractal_new.py                     1      0   100%
src/icons/help_about.py                      1      0   100%
src/icons/help_faq.py                        1      0   100%
src/svitava-gui.py                           5      1    80%
------------------------------------------------------------
TOTAL                                      164    104    37%
</pre>

<p>S&nbsp;využitím přepínače <strong>--skip-covered</strong> je navíc možné
vynechat ty soubory, jejichž všechny příkazy jsou alespoň jedenkrát
vykonány:</p>

<pre>
$ <strong>coverage report --skip-covered</strong>
&nbsp;
Name                                     Stmts   Miss  Cover
------------------------------------------------------------
src/gui/canvas.py                            7      4    43%
src/gui/dialogs/about_dialog.py              4      1    75%
src/gui/dialogs/fractal_type_dialog.py      28     20    29%
src/gui/dialogs/help_dialog.py              34     28    18%
src/gui/icons.py                            19      8    58%
src/gui/main_window.py                      23     13    43%
src/gui/menubar.py                          36     29    19%
src/svitava-gui.py                           5      1    80%
------------------------------------------------------------
TOTAL                                      164    104    37%
&nbsp;
11 files skipped due to complete coverage.
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Anotace zdrojového kódu</h2>

<p>Příkazem:</p>

<pre>
$ <strong>coverage annotate</strong>
</pre>

<p>získáme výpis zdrojových kódů, ke kterým jsou přidány informace o tom, který
z&nbsp;příkazů byl alespoň jedenkrát vykonán a který naopak vůbec vykonán
nebyl. Výsledek pro náš demonstrační příklad s&nbsp;faktoriálem vypadá
takto:</p>

<pre>
&gt; """Výpočet faktoriálu."""
&nbsp;
&gt; def factorial(n):
&gt;     """Rekurzivní výpočet faktoriálu."""
&gt;     assert isinstance(n, int), "Integer expected"
&nbsp;
&gt;     if n &lt; 0:
!         return None
&gt;     if n == 0:
&gt;         return 1
&gt;     result = n * factorial(n-1)
&nbsp;
&gt;     assert isinstance(result, int), "Internal error in factorial computation"
&gt;     return result
&nbsp;
&nbsp;
&gt; def main():
&gt;     for n in range(0, 11):
&gt;         print(n, factorial(n))
&nbsp;
&nbsp;
&gt; if __name__ == "__main__":
&gt;     main()
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak jsou odlišeny
vykonané příkazy, nevykonané řádky a zbylé řádky.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Export výsledků do formátů JSON a XML</h2>

<p>Nástroj <strong>coverage.py</strong> podporuje export naměřených výsledků,
tedy přesněji řečeno informací o tom, které programové řádky byly vykonány a
které nikoli, do formátů JSON a XML, což umožňuje relativně snadnou integraci
tohoto nástroje například do integrovaných vývojových prostředí, nástrojů pro
dynamickou analýzu zdrojových kódů atd.</p>

<p>Export do formátu JSON zajišťuje příkaz:</p>

<pre>
$ <strong>coverage json</strong>
</pre>

<p>Výsledkem bude (pro demonstrační příklad obsahující výpočet faktoriálu)
tento soubor:</p>

<pre>
{"meta": {"version": "5.4", "timestamp": "2021-02-05T09:37:22.563357", "branch_coverage": false, "show_contexts": false}, "files": {"factorial.py": {"executed_lines": [1, 3, 5, 7, 9, 10, 11, 13, 14, 17, 18, 19, 22, 23], "summary": {"covered_lines": 13, "num_statements": 14, "percent_covered": 92.85714285714286, "missing_lines": 1, "excluded_lines": 0}, "missing_lines": [8], "excluded_lines": []}}, "totals": {"covered_lines": 13, "num_statements": 14, "percent_covered": 92.85714285714286, "missing_lines": 1, "excluded_lines": 0}}
</pre>

<p>Který můžeme s&nbsp;využitím nástroje <a
href="https://www.root.cz/clanky/zpracovani-dat-reprezentovanych-ve-formatu-json-nastrojem-jq/">jq</a>
převést do čitelnější podoby, z&nbsp;níž je patrné jakým způsobem jsou
informace prezentovány:</p>

<pre>
{
  "meta": {
    "version": "5.4",
    "timestamp": "2021-02-05T09:37:22.563357",
    "branch_coverage": false,
    "show_contexts": false
  },
  "files": {
    "factorial.py": {
      "executed_lines": [
        1,
        3,
        5,
        7,
        9,
        10,
        11,
        13,
        14,
        17,
        18,
        19,
        22,
        23
      ],
      "summary": {
        "covered_lines": 13,
        "num_statements": 14,
        "percent_covered": 92.85714285714286,
        "missing_lines": 1,
        "excluded_lines": 0
      },
      "missing_lines": [
        8
      ],
      "excluded_lines": []
    }
  },
  "totals": {
    "covered_lines": 13,
    "num_statements": 14,
    "percent_covered": 92.85714285714286,
    "missing_lines": 1,
    "excluded_lines": 0
  }
}
</pre>

<p>Podobný příkaz zajišťuje export do formátu XML:</p>

<pre>
$ <strong>coverge xml</strong>
</pre>

<p>Tentokrát je výsledný soubor větší, i když ve skutečnosti obsahuje podobné
informace, pouze jinak prezentované:</p>

<pre>
&lt;?xml version="1.0" ?&gt;
&lt;coverage version="5.4" timestamp="1612601186209" lines-valid="14" lines-covered="13" line-rate="0.9286" branches-covered="0" branches-valid="0" branch-rate="0" complexity="0"&gt;
        &lt;!-- Generated by coverage.py: https://coverage.readthedocs.io --&gt;
        &lt;!-- Based on https://raw.githubusercontent.com/cobertura/web/master/htdocs/xml/coverage-04.dtd --&gt;
        &lt;sources&gt;
                &lt;source&gt;/home/tester&lt;/source&gt;
        &lt;/sources&gt;
        &lt;packages&gt;
                &lt;package name="." line-rate="0.9286" branch-rate="0" complexity="0"&gt;
                        &lt;classes&gt;
                                &lt;class name="factorial.py" filename="factorial.py" complexity="0" line-rate="0.9286" branch-rate="0"&gt;
                                        &lt;methods/&gt;
                                        &lt;lines&gt;
                                                &lt;line number="3" hits="1"/&gt;
                                                &lt;line number="5" hits="1"/&gt;
                                                &lt;line number="7" hits="1"/&gt;
                                                &lt;line number="8" hits="0"/&gt;
                                                &lt;line number="9" hits="1"/&gt;
                                                &lt;line number="10" hits="1"/&gt;
                                                &lt;line number="11" hits="1"/&gt;
                                                &lt;line number="13" hits="1"/&gt;
                                                &lt;line number="14" hits="1"/&gt;
                                                &lt;line number="17" hits="1"/&gt;
                                                &lt;line number="18" hits="1"/&gt;
                                                &lt;line number="19" hits="1"/&gt;
                                                &lt;line number="22" hits="1"/&gt;
                                                &lt;line number="23" hits="1"/&gt;
                                        &lt;/lines&gt;
                                &lt;/class&gt;
                        &lt;/classes&gt;
                &lt;/package&gt;
        &lt;/packages&gt;
&lt;/coverage&gt;
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zobrazení výsledků ve formě vygenerovaných HTML stránek</h2>

<p>Posledním způsobem zobrazení výsledků získaných nástrojem
<strong>coverage.py</strong> je vygenerování HTML stránek s&nbsp;informacemi o
tom, které části zdrojových kódů byly vykonány a které nikoli. Tento výstup
získáme příkazem:</p>

<pre>
$ <strong>coverage html</strong>
</pre>

<p>Výsledkem je několik HTML stránek, CSS souborů a souborů s&nbsp;podpůrnými
funkcemi JavaScriptu, které obsahují jak souhrnné informace o příkazech, které
byly provedeny, tak i podrobnější informace vztažené k&nbsp;jednotlivým
programovým řádků z&nbsp;každého zdrojového souboru.</p>

<img src="https://i.iinfo.cz/images/134/pytrace-1.png" class="image-442576" alt="&#160;" width="482" height="188" />
<p><i>Obrázek 3: Souhrnné informace o celém programu, který byl sledován.</i></p>

<img src="https://i.iinfo.cz/images/134/pytrace-2.png" class="image-442577" alt="&#160;" width="656" height="620" />
<p><i>Obrázek 4: Podrobné informace o příkazech provedených ve vybraném skriptu.</i></p>

<img src="https://i.iinfo.cz/images/134/pytrace-3.png" class="image-442578" alt="&#160;" width="679" height="639" />
<p><i>Obrázek 5: Souhrnné informace pro složitější projekt s&nbsp;více
zdrojovými soubory.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Interní struktura s&nbsp;informacemi o trasování (SQLite databáze)</h2>

<p>Pro úplnost se ještě podívejme na to, jaká data a v&nbsp;jakém formátu
vlastně obsahuje soubor <strong>.coverage</strong>, který je vytvořen ve
chvíli, kdy spustíme sledovaný program pomocí příkazu <strong>coverage
run</strong>. Jedná se o binární soubor:</p>

<pre>
$ <strong>od -t x1 -N 1800 .coverage</strong>
</pre>

<p>Interní struktura nám mnoho neprozradí:</p>

<pre>
0000000 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00
0000020 10 00 01 01 00 40 20 20 00 00 00 0a 00 00 00 0d
0000040 00 00 00 00 00 00 00 00 00 00 00 07 00 00 00 04
0000060 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00
0000100 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000120 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0a
0000140 00 2e 4b 90 0d 0f 56 00 0c 06 96 00 0f 5e 0d 58
0000160 0f 2d 0c a5 0d 2f 0b da 0c 76 09 93 0b a7 07 6a
0000200 09 6c 06 96 00 00 00 00 00 00 00 00 00 00 00 00
0000220 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0003220 00 00 00 00 00 00 81 51 0c 07 17 19 19 01 82 7d
0003240 74 61 62 6c 65 74 72 61 63 65 72 74 72 61 63 65
0003260 72 0d 43 52 45 41 54 45 20 54 41 42 4c 45 20 74
0003300 72 61 63 65 72 20 28 0a 20 20 20 20 2d 2d 20 41
0003320 20 72 6f 77 20 70 65 72 20 66 69 6c 65 20 69 6e
0003340 64 69 63 61 74 69 6e 67 20 74 68 65 20 74 72 61
0003360 63 65 72 20 75 73 65 64 20 66 6f 72 20 74 68 61
0003400 74 20 66 69 6c 65 2e 0a
0003410
</pre>

<p>Ve skutečnosti lze poměrně snadno zjistit, že se jedná o soubor používající
formát souborové databáze SQLite:</p>

<pre>
$ <strong>file .coverage</strong>
&nbsp;
.coverage: SQLite 3.x database, last written using SQLite version 3034000
</pre>

<p>Můžeme tedy obsah tohoto souboru prozkoumat (ovšem pochopitelně s&nbsp;tím
dodatkem, že se jeho formát může v&nbsp;dalších verzích změnit):</p>

<pre>
$ <strong>sqlite3 .coverage</strong>
&nbsp;
SQLite version 3.34.0 2020-12-01 16:14:00
Enter ".help" for usage hints.
</pre>

<p>V&nbsp;databázi nalezneme celkem sedm tabulek:</p>

<pre>
sqlite&gt; <strong>.tables</strong>
&nbsp;
arc              coverage_schema  line_bits        tracer         
context          file             meta           
</pre>

<p>Důležité jsou především tabulky <strong>file</strong>,
<strong>tracer</strong> a <strong>line_bits</strong>, mezi nimiž existují
relační vazby:</p>

<pre>
sqlite&gt; <strong>.schema file</strong>
&nbsp;
CREATE TABLE file (
    -- A row per file measured.
    id integer primary key,
    path text,
    unique (path)
);
&nbsp;
&nbsp;
sqlite&gt; <strong>.schema tracer</strong>
&nbsp;
CREATE TABLE tracer (
    -- A row per file indicating the tracer used for that file.
    file_id integer primary key,
    tracer text,
    foreign key (file_id) references file (id)
);
&nbsp;
&nbsp;
sqlite&gt; <strong>.schema line_bits</strong>
&nbsp;
CREATE TABLE line_bits (
    -- If recording lines, a row per context per file executed.
    -- All of the line numbers for that file/context are in one numbits.
    file_id integer,            -- foreign key to `file`.
    context_id integer,         -- foreign key to `context`.
    numbits blob,               -- see the numbits functions in coverage.numbits
    foreign key (file_id) references file (id),
    foreign key (context_id) references context (id),
    unique (file_id, context_id)
);
</pre>

<p>Samozřejmě si můžeme obsah jednotlivých tabulek zobrazit:</p>

<pre>
sqlite&gt; <strong>select * from file;</strong>
&nbsp;
1|/home/tester/factorial.py
</pre>

<p>Ovšem v&nbsp;případě tabulky <strong>line_bits</strong> je nutné upozornit
na to, že informace o řádcích s&nbsp;vykonanými příkazy jsou uloženy ve formě
bitových množin popsaných na stránce <a
href="https://coverage.readthedocs.io/en/coverage-5.3.1/dbschema.html#numbits">https://coverage.readthedocs.io/en/coverage-5.3.1/dbschema.html#numbits</a>
(a to z&nbsp;důvodu větší efektivity uložení). Získání těchto informací pouze
s&nbsp;využitím SQL příkazů je tedy dosti problematické.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. <strong>Nástroj pycrunch-pytrace</strong></h2>

<p>Třetím nástrojem, se kterým se v&nbsp;dnešním článku setkáme, je nástroj
nazvaný <strong>pycrunch-pytrace</strong> popř.&nbsp;zkráceně pouze
<strong>pytrace</strong> (což je ovšem nepřesné, protože existuje ještě jeden
balíček s&nbsp;tímto jménem, který ovšem pracuje jinak). Tento potenciálně
velmi užitečný nástroj dokáže sledovat a zaznamenávat činnosti prováděné
sledovanou aplikací a následně zobrazit stav aplikace v&nbsp;libovolném čase do
minulosti (a to až na úroveň volání jednotlivých funkcí a jejích parametrů).
Jedná se tedy o jakousi obdobu debuggeru, v&nbsp;němž se ale můžeme pohybovat
nikoli pouze dopředu (typicky příkazy <strong>step</strong> a
<strong>run</strong>), ale i pozpátku. Toto zpětné &bdquo;přetáčení&ldquo;
minulosti aplikace je prováděno v&nbsp;grafickém uživatelském rozhraní běžícím
ve webovém prohlížeči:</p>

<a href="https://www.root.cz/obrazek/442579/"><img src="https://i.iinfo.cz/images/134/pytrace-4-prev.png" class="image-442579" alt="&#160;" width="370" height="52" /></a>
<p><i>Obrázek 4: Grafické uživatelské rozhraní programu, kterým je možné zpětně
sledovat chování aplikace.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Instalace nástroje <strong>pycrunch-pytrace</strong></h2>

<p>Instalace samotného nástroje <strong>pycrunch-pytrace</strong>
(resp.&nbsp;přesněji řečeno jeho &bdquo;trasovací&ldquo; části) je velmi
jednoduchá, neboť se opět jedná o nástroj dostupný na PyPi. Instalaci provedeme
následujícím způsobem:</p>

<pre>
$ <strong>pip install --user pycrunch-trace</strong>
</pre>

<p>Povšimněte si, že jednou ze závislostí tohoto nástroje je i
<strong>Cython</strong>, což je technologie, kterou jsme se zabývali
v&nbsp;článku <a
href="https://www.root.cz/clanky/rpython-vs-cython-aneb-dvoji-pristup-k-prekladu-pythonu-do-nativniho-kodu/#k10">RPython
vs Cython aneb dvojí přístup k překladu Pythonu do nativního kódu</a>:</p>

<pre>
Collecting pycrunch-trace
  Downloading https://files.pythonhosted.org/packages/ef/30/96a3666b1a88399183f8fad6fc930f325fdd16afad837063814005573c80/pycrunch-trace-0.1.5.tar.gz (44kB)
     |████████████████████████████████| 51kB 184kB/s
Collecting Cython
  Downloading https://files.pythonhosted.org/packages/9f/05/959e78f2aeade1c9e85a7adc4c376f454ecaeb4cb6b079ca7a85684b69c1/Cython-0.29.21-cp38-cp38-manylinux1_x86_64.whl (1.9MB)
     |████████████████████████████████| 1.9MB 339kB/s
Collecting jsonpickle
  Downloading https://files.pythonhosted.org/packages/77/a7/c2f527ddce3155ae9e008385963c2325cbfd52969f8b38efa2723e2af4af/jsonpickle-1.5.1-py2.py3-none-any.whl
Collecting PyYAML
  Downloading https://files.pythonhosted.org/packages/70/96/c7245e551b1cb496bfb95840ace55ca60f20d3d8e33d70faf8c78a976899/PyYAML-5.4.1-cp38-cp38-manylinux1_x86_64.whl (662kB)
     |████████████████████████████████| 665kB 4.5MB/s
Collecting protobuf==3.11.3
  Downloading https://files.pythonhosted.org/packages/9a/71/5cdb5ed762a537eac39097ae6ecf8785e276b5044efe99b8e53cb3addd7f/protobuf-3.11.3-cp38-cp38-manylinux1_x86_64.whl (1.3MB)
     |████████████████████████████████| 1.3MB 4.6MB/s
Requirement already satisfied: setuptools in /usr/lib/python3.8/site-packages (from protobuf==3.11.3-&gt;pycrunch-trace) (41.6.0)
Requirement already satisfied: six&gt;=1.9 in /usr/lib/python3.8/site-packages (from protobuf==3.11.3-&gt;pycrunch-trace) (1.14.0)
Installing collected packages: Cython, jsonpickle, PyYAML, protobuf, pycrunch-trace
    Running setup.py install for pycrunch-trace ... done
Successfully installed Cython-0.29.21 PyYAML-5.4.1 jsonpickle-1.5.1 protobuf-3.11.3 pycrunch-trace-0.1.5
</pre>

<p>Základní otestování instalace můžeme provést interaktivně z&nbsp;REPLu
jazyka Python:</p>

<pre>
$ <strong>python</strong>
&nbsp;
Python 3.8.7 (default, Dec 22 2020, 00:00:00) 
[GCC 10.2.1 20201125 (Red Hat 10.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; <strong>import pycrunch_trace</strong>
&gt;&gt;&gt; <strong>help(pycrunch_trace)</strong>
&nbsp;
Help on package pycrunch_trace:
&nbsp;
NAME
    pycrunch_trace
&nbsp;
PACKAGE CONTENTS
    client (package)
    config
    demo (package)
    events (package)
    ...
    ...
    ...
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úprava trasovaného skriptu a spuštění trasování</h2>

<p>Na rozdíl od obou předchozích nástrojů vyžaduje
<strong>pycrunch-trace</strong> úpravu zdrojových kódů sledované aplikace. Ve
skutečnosti je ovšem tato úprava triviální, protože je zapotřebí přidat jeden
příkaz <strong>import</strong>:</p>

<pre>
<strong>from pycrunch_trace.client.api import trace</strong>
</pre>

<p>... a následně použít anotaci <strong>@trace</strong> u té funkce, u níž má
trasování začít. Může se jednat například o funkci <strong>main</strong>:</p>

<pre>
<strong>from pycrunch_trace.client.api import trace</strong>
&nbsp;
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
def factorial(n):
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    assert isinstance(n, int), "Integer expected"
&nbsp;
    if n &lt; 0:
        return None
    if n == 0:
        return 1
    result = n * factorial(n-1)
&nbsp;
    assert isinstance(result, int), "Internal error in factorial computation"
    return result
&nbsp;
&nbsp;
<strong>@trace</strong>
def main():
    for n in range(0, 11):
        print(n, factorial(n))
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
</pre>

<p>Ovšem tuto anotaci můžeme přidat k&nbsp;libovolné funkci, která se interně
volá:</p>

<pre>
<strong>from pycrunch_trace.client.api import trace</strong>
&nbsp;
<i>"""Výpočet faktoriálu."""</i>
&nbsp;
<strong>@trace</strong>
def factorial(n):
    <i>"""Rekurzivní výpočet faktoriálu."""</i>
    assert isinstance(n, int), "Integer expected"
&nbsp;
    if n &lt; 0:
        return None
    if n == 0:
        return 1
    result = n * factorial(n-1)
&nbsp;
    assert isinstance(result, int), "Internal error in factorial computation"
    return result
&nbsp;
&nbsp;
def main():
    for n in range(0, 11):
        print(n, factorial(n))
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
</pre>

<p>Následně je již možné sledovanou aplikaci spustit, a to naprosto běžným
způsobem (což je další rozdíl oproti nástrojům <strong>trace</strong> a
<strong>coverage</strong>):</p>

<pre>
$ <strong>python factorial.py</strong>
</pre>

<p>Sledovaný program by se měl spustit kromě dalších informací vypsat i zprávy
o tom, že bylo zahájeno sledování:</p>

<pre>
/home/tester/.local/lib/python3.8/site-packages/Cython/Compiler/Main.py:369: FutureWarning: Cython directive 'language_level' not set, using 2 for now (Py2). This will change in a later release! File: /home/tester/.local/lib/python3.8/site-packages/pycrunch_trace/client/networking/strategies/native_write_strategy.pyx
  tree = Parsing.p_module(s, pxd, full_module_name)
&nbsp;
----print_timings----
tracing complete, saving results
total_samples - 538
total overhead time - 6 ms
                      6.324903004497173
0.01176 ms avg call time overhead
total events C: 31
main - put_events: so far: 531
finalizing native tracer
queue length 0
got evt EventsSlice
put_file_slice
tracing_did_complete
queue length 0
got evt FileContentSlice
skip_to_free_header_chunk
pos = 12
after pos = 28
queue length 0
got evt StopCommand
skip_to_free_header_chunk
pos = 12
after pos = 52
metadata saved to /home/tester/pycrunch-recordings/main/pycrunch-trace.meta.json
Timeout while waiting for new msg... Thread will stop for now
Thread stopped
</pre>

<p>Výsledkem by měl být soubor <strong>pycrunch-trace.meta.json</strong> a
především pak binární soubor <strong>session.chunked.pycrunch-trace</strong>,
který použijeme v&nbsp;navazující kapitole.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Prohlédnutí výsledků trasování v&nbsp;GUI</h2>

<p>Soubor <strong>session.chunked.pycrunch-trace</strong> je možné nahrát do
webové aplikace dostupné na adrese <a
href="https://pytrace.com/">https://pytrace.com/</a> (popř.&nbsp;si tuto
aplikaci spustit lokálně &ndash; existuje v&nbsp;repositáři <a
href="https://github.com/gleb-sevruk/pycrunch-tracing-webui">https://github.com/gleb-sevruk/pycrunch-tracing-webui</a>).
Měla by se objevit především časová osa, po které je možné se pohybovat a
zobrazit tak stav programu ve vybraném okamžiku. V&nbsp;dolní části je navíc
možné zapnout pseudografické zobrazení volaných funkcí:</p>

<a href="https://www.root.cz/obrazek/442580/"><img src="https://i.iinfo.cz/images/134/pytrace-5-prev.png" class="image-442580" alt="&#160;" width="370" height="189" /></a>
<p><i>Obrázek 7: Načtení souboru s&nbsp;informacemi o sledované aplikaci se
zobrazením právě prováděného příkazu.</i></p>

<a href="https://www.root.cz/obrazek/442581/"><img src="https://i.iinfo.cz/images/134/pytrace-6-prev.png" class="image-442581" alt="&#160;" width="370" height="221" /></a>
<p><i>Obrázek 8: V&nbsp;pravé části jsou zobrazeny informace o parametrech i o
lokálních proměnných.</i></p>

<a href="https://www.root.cz/obrazek/442582/"><img src="https://i.iinfo.cz/images/134/pytrace-7-prev.png" class="image-442582" alt="&#160;" width="370" height="181" /></a>
<p><i>Obrázek 9: Grafické znázornění rekurzivního výpočtu faktoriálu.</i></p>

<a href="https://www.root.cz/obrazek/442583/"><img src="https://i.iinfo.cz/images/134/pytrace-8-prev.png" class="image-442583" alt="&#160;" width="370" height="201" /></a>
<p><i>Obrázek 10: Krokování volanými funkcemi (opět se zobrazují i parametry a
lokální proměnné).</i></p>

<a href="https://www.root.cz/obrazek/442584/"><img src="https://i.iinfo.cz/images/134/pytrace-9-prev.png" class="image-442584" alt="&#160;" width="370" height="163" /></a>
<p><i>Obrázek 11: Odlišná aplikace s&nbsp;GUI.</i></p>

<a href="https://www.root.cz/obrazek/442585/"><img src="https://i.iinfo.cz/images/134/pytrace-10-prev.png" class="image-442585" alt="&#160;" width="370" height="161" /></a></p>
<p><i>Obrázek 12: Vzorová aplikace určená pro otestování možností
pycrunch-trace.</i></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech tří dnes použitých demonstračních příkladů určených pro
Python 3 byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>
(jedná se o několik variant implementace funkce pro výpočet faktoriálu).
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th>#</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>factorial.py</td><td>původní varianta skriptu pro výpočet faktoriálu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.py">https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.py</a></td></tr>
<tr><td>2</td><td>factorial_pycrunch1.py</td><td>úprava pro trasování s&nbsp;využitím pycrunch-trace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial_pycrunch1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial_pycrunch1.py</a></td></tr>
<tr><td>3</td><td>factorial_pycrunch2.py</td><td>alternativní úprava pro trasování s&nbsp;využitím pycrunch-trace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial_pycrunch2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial_pycrunch2.py</a></td></tr>
</table>

<p>K&nbsp;dispozici jsou i datové soubory vytvořené nástrojem
<strong>coverage.py</strong> i standardním nástrojem
<strong>trace</strong>:</p>

<table>
<tr><th>#</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>factorial.cover</td><td>počet přístupů k&nbsp;jednotlivým řádkům kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.cover">https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.cover</a></td></tr>
<tr><td>2</td><td>factorial.trace</td><td>výsledek trasování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.trace">https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.trace</a></td></tr>
<tr><td>3</td><td>factorial.timing</td><td>výsledek trasování + informace o relativním času běhu aplikace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.timing">https://github.com/tisnik/most-popular-python-libs/blob/master/tracing/factorial.timing</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Stránka projektu PyTrace<br />
<a href="https://pytrace.com/">https://pytrace.com/</a>
</li>

<li>Nástroj pycrunch-trace na PyPi<br />
<a href="https://pypi.org/project/pycrunch-trace/">https://pypi.org/project/pycrunch-trace/</a>
</li>

<li>Repositář nástroje pycrunch-trace na GitHubu<br />
<a href="https://github.com/gleb-sevruk/pycrunch-trace">https://github.com/gleb-sevruk/pycrunch-trace</a>
</li>

<li>Repositář serveru pycrunch-tracing-webui na GitHubu<br />
<a href="https://github.com/gleb-sevruk/pycrunch-tracing-webui">https://github.com/gleb-sevruk/pycrunch-tracing-webui</a>
</li>

<li>Server s&nbsp;GUI pro nástroj pycrunch-trace<br />
<a href="https://app.pytrace.com/">https://app.pytrace.com/</a>
</li>

<li>Dokumentace k&nbsp;projektu Coverage.py<br />
<a href="https://coverage.readthedocs.io/en/coverage-5.3.1/index.html">https://coverage.readthedocs.io/en/coverage-5.3.1/index.html</a>
</li>

<li>Projekt coveragepy na GitHubu<br />
<a href="https://github.com/nedbat/coveragepy">https://github.com/nedbat/coveragepy</a>
</li>

<li>Projekt coverage 5.4 na PyPi<br />
<a href="https://pypi.org/project/coverage/">https://pypi.org/project/coverage/</a>
</li>

<li>Coverage.py database schema<br />
<a href="https://coverage.readthedocs.io/en/coverage-5.3.1/dbschema.html">https://coverage.readthedocs.io/en/coverage-5.3.1/dbschema.html</a>
</li>

<li>Numbits<br />
<a href="https://coverage.readthedocs.io/en/coverage-5.3.1/dbschema.html#numbits">https://coverage.readthedocs.io/en/coverage-5.3.1/dbschema.html#numbits</a>
</li>

<li>SQLite Show Tables<br />
<a href="https://www.sqlitetutorial.net/sqlite-tutorial/sqlite-show-tables/">https://www.sqlitetutorial.net/sqlite-tutorial/sqlite-show-tables/</a>
</li>

<li>SQLite Describe Table<br />
<a href="https://www.sqlitetutorial.net/sqlite-tutorial/sqlite-describe-table/">https://www.sqlitetutorial.net/sqlite-tutorial/sqlite-describe-table/</a>
</li>

<li>Trasování a ladění nativních aplikací v Linuxu<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/</a>
</li>

<li>Trasování a ladění nativních aplikací v Linuxu: použití GDB a jeho nadstaveb<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/</a>
</li>

<li>Trasování a ladění nativních aplikací v Linuxu: pokročilejší možnosti nabízené GNU Debuggerem<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pokrocilejsi-moznosti-nabizene-gnu-debuggerem/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pokrocilejsi-moznosti-nabizene-gnu-debuggerem/</a>
</li>

<li>Trasování a ladění nativních aplikací v Linuxu: nástroj SystemTap<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-nastroje-systemtap/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-nastroje-systemtap/</a>
</li>

<li>Trasování a ladění v Linuxu: jazyk používaný SystemTapem<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-v-linuxu-jazyk-pouzivany-systemtapem/">https://www.root.cz/clanky/trasovani-a-ladeni-v-linuxu-jazyk-pouzivany-systemtapem/</a>
</li>

<li>Grafická nadstavba nad GNU Debuggerem gdbgui a její alternativy<br />
<a href="https://www.root.cz/clanky/graficka-nadstavba-nad-gnu-debuggerem-gdbgui-a-jeji-alternativy/">https://www.root.cz/clanky/graficka-nadstavba-nad-gnu-debuggerem-gdbgui-a-jeji-alternativy/</a>
</li>

<li>Debugging C128 BASIC with TRON, TRAP, and More<br />
<a href="https://www.youtube.com/watch?v=D11AuAl5T-s">https://www.youtube.com/watch?v=D11AuAl5T-s</a>
</li>

<li>TRON command<br />
<a href="https://en.wikipedia.org/wiki/TRON_command">https://en.wikipedia.org/wiki/TRON_command</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

