<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Manipulace s binárními datovými strukturami v Pythonu (2. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Manipulace s binárními datovými strukturami v Pythonu (2. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Manipulace s&nbsp;binárními datovými strukturami v&nbsp;Pythonu (2. část)</a></p>
<p><a href="#k02">2. Metoda <strong>Struct.unpack</strong> pro přečtení hodnot z&nbsp;binární struktury</a></p>
<p><a href="#k03">3. Korektní přečtení jedné hodnoty z&nbsp;binárních dat</a></p>
<p><a href="#k04">4. Čtení vícebajtové hodnoty se specifikací pořadí bajtů</a></p>
<p><a href="#k05">5. Binární formáty obsahující více hodnot různých typů</a></p>
<p><a href="#k06">6. Zarovnání a výplně</a></p>
<p><a href="#k07">*** 7. Výpočet velikosti binární struktury se zadaným formátem prvků</a></p>
<p><a href="#k08">*** 8. Velikost binární struktury s&nbsp;výplněmi</a></p>
<p><a href="#k09">*** 9. Doplňkové bajty na konci binární struktury</a></p>
<p><a href="#k10">*** 10. Krátké zopakování z&nbsp;minula: zápis rastrového obrázku do formátu PNG</a></p>
<p><a href="#k11">*** 11. Formát PNG</a></p>
<p><a href="#k12">12. Testovací obrázek, který budeme načítat a analyzovat</a></p>
<p><a href="#k13">*** 13. Čtení hlavičky PNG</a></p>
<p><a href="#k14">*** 14. Načtení hlaviček jednotlivých chunků</a></p>
<p><a href="#k15">*** 15. Přeskok datové části chunku a přečtení kontrolního součtu</a></p>
<p><a href="#k16">16. Úplný zdrojový kód příkladu, který přečte chunky uložené v&nbsp;souboru formátu PNG</a></p>
<p><a href="#k17">*** 17. Načtení informací uložených v&nbsp;chunku <strong>IHDR</strong></a></p>
<p><a href="#k18">18. Úplný zdrojový kód skriptu, který vypíše strukturu PNG souboru i přesné informace z&nbsp;hlavičky</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Manipulace s&nbsp;binárními datovými strukturami v&nbsp;Pythonu (2. část)</h2>

<p><a href="https://www.root.cz/clanky/manipulace-s-binarnimi-datovymi-strukturami-v-pythonu/"></a></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Metoda <strong>Struct.unpack</strong> pro přečtení hodnot z&nbsp;binární struktury</h2>

<p>Pro serializaci hodnot do binárních dat jsme v&nbsp;předchozím článku
používali funkci <strong>unpack</strong> ze standardního balíčku
<strong>struct</strong>. Opačná operace, tj.&nbsp;získání hodnoty určitého typu
z&nbsp;binárních dat, je nepatrně složitější, neboť namísto volání jedné funkce
je nejprve nutné zkonstruovat objekt typu <strong>struct.Struct</strong>
(s&nbsp;předáním požadovaného formátu) a následně zavolat metodu
<strong>unpack</strong>, které se předají binární data (<strong>bytes</strong>,
<strong>bytearray</strong> atd.). Tato metoda z&nbsp;binárních dat získá
požadovanou hodnotu či hodnoty a vrátí je formou n-tice (<i>tuple</i>):</p>

<pre>
<strong>unpack(self, buffer, /) unbound _struct.Struct method</strong>
    Return a tuple containing unpacked values.
&nbsp;
    Unpack according to the format string Struct.format. The buffer's size
    in bytes must be Struct.size.
</pre>

<p>Celý postup si ukážeme na jednoduchém demonstračním příkladu, v&nbsp;němž
nejprve uložíme celočíselnou hodnotu 42 do binárních dat (typ
<strong>bytes</strong>) a pro jistotu si obsah binárních dat vypíšeme. Následně
se zkonstruuje objekt typu <strong>struct.Struct</strong> předáním požadovaného
formátu do konstruktoru (formát &bdquo;b&ldquo; &ndash; jediný bajt). Posledním
krokem je zavolání metody <strong>Struct.unpack()</strong>, které předáme již
dříve vytvořená binární data:</p>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("b", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = <strong>struct.Struct("b")</strong>
from_struct = <strong>s.unpack(bytes)</strong>
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<p>Výsledkem deserializace z&nbsp;binárních dat bude n-tice obsahující jediný
prvek, konkrétně prvek s&nbsp;celočíselnou hodnotou 42:</p>

<pre>
Serialized:   2a
Deserialized: (42,)
Type:         &lt;class 'tuple'&gt;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Korektní přečtení jedné hodnoty z&nbsp;binárních dat</h2>

<p>V&nbsp;případě, že se z&nbsp;binárních dat čte pouze jediný údaj, typicky
znak, celočíselná numerická hodnota, numerická hodnota s&nbsp;plovoucí řádovou
čárkou atd., je řešení velmi jednoduché &ndash; metodou
<strong>Struct.unpack</strong> si necháme vrátit n-tici, která ovšem bude
obsahovat jediný údaj (specifikovaný ve formátu). Následně z&nbsp;n-tice tento
jediný její prvek přečteme a získáme tak hodnotu korektního typu.</p>

<p>Celý postup je snadný a můžeme si ho ověřit na následujícím demonstračním
příkladu:</p>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("b", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = <strong>struct.Struct("b")</strong>
&nbsp;
<i># první prvek z přečtené struktury</i>
from_struct = <strong>s.unpack(bytes)[0]</strong>
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<p>Tento skript by po svém spuštění měl vypsat, že binární data obsahují jediný
bajt s&nbsp;hodnotou 0x2a a následně se navíc vypíše, že byl tento bajt
deserializován do celočíselné hodnoty 42, která má korektní
(resp.&nbsp;přesněji řečeno očekávaný) typ <strong>int</strong>:</p>

<pre>
Serialized:   2a
Deserialized: 42
Type:         &lt;class 'int'&gt;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Čtení vícebajtové hodnoty se specifikací pořadí bajtů</h2>

<p>Již <a
href="https://www.root.cz/clanky/manipulace-s-binarnimi-datovymi-strukturami-v-pythonu/">minule</a>
jsme se setkali s&nbsp;problematikou pořadí bajtů u vícebajtové hodnoty uložené
do binárního bloku. Víme již, že pořadí uložení bajtů lze při serializaci
(tj.&nbsp;při volání funkce <strong>struct.pack</strong>) ovlivnit pomocí znaků
&lt;, &gt;, ! atd. zapisovaných do řetězce s&nbsp;formátem. Tyto znaky se
zapisují na samotný začátek řetězce s&nbsp;formátem:</p>

<table>
<tr><th>Znak</th><th>Význam</th></tr>
<tr><td>@</td><td>podle platformy (ovlivňuje i zarovnání atd.)</td></tr>
<tr><td>=</td><td>podle platformy, ovšem bez zarovnání</td></tr>
<tr><td>&lt;</td><td>little endian</td></tr>
<tr><td>&gt;</td><td>big endian</td></tr>
<tr><td>!</td><td>big endian (zde se ovšem používá označení &bdquo;network&ldquo;)</td></tr>
</table>

<p>Tytéž znaky je možné použít i při konstrukci objektu
<strong>struct.Struct</strong> a zvolit tak, jak budou vícebajtové hodnoty
načteny (deserializovány) z&nbsp;binárních dat. Ukažme si nejprve deserializaci
dvoubajtové hodnoty typu celé číslo v&nbsp;případě, že nebudeme specifikovat
pořadí bajtů:</p>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("h", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = <strong>struct.Struct(<u>"h"</u>)</strong>
&nbsp;
<i># první prvek z přečtené struktury</i>
from_struct = <strong>s.unpack(bytes)[0]</strong>
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<p>Na platformě x86(64) by se měly po spuštění tohoto skriptu zobrazit
následující hodnoty (povšimněte si, že nejdříve je uložen nižší bajt):</p>

<pre>
Serialized:   2a 00
Deserialized: 42
Type:         &lt;class 'int'&gt;
</pre>

<p>Samozřejmě můžeme explicitně nastavit, že budeme číst dvoubajtovou hodnotu
uloženou v&nbsp;pořadí bajtů little endian:</p>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("h", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = <strong>struct.Struct(<u>"&lt;h"</u>)</strong>
&nbsp;
<i># první prvek z přečtené struktury</i>
from_struct = <strong>s.unpack(bytes)[0]</strong>
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<p>Výsledky budou na platformě x86(64) totožné:</p>

<pre>
Serialized:   2a 00
Deserialized: 42
Type:         &lt;class 'int'&gt;
</pre>

<p>Nebo naopak při čtení specifikujeme pořadí bajtů big endian:</p>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("h", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = <strong>struct.Struct(<u>"&gt;h"</u>)</strong>
&nbsp;
<i># první prvek z přečtené struktury</i>
from_struct = <strong>s.unpack(bytes)[0]</strong>
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<p>Nyní se přečte odlišná hodnota, konkrétně hodnota odpovídající
42&times;256:</p>

<pre>
Serialized:   2a 00
Deserialized: 10752
Type:         &lt;class 'int'&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: pořadí bajtů platí vždy pro celou
strukturu, tj.&nbsp;nelze nastavit, že první dva bajty jsou uloženy jako little
endian a další dva jako big endian. Pokud taková situace nastane, je nutné
serializaci/deserializaci provádět po částech.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Binární formáty obsahující více hodnot různých typů</h2>

<p>V&nbsp;praxi se velmi často dostaneme do situace, v&nbsp;níž je nutné
serializovat nebo deserializovat rozsáhlejší datové struktury obsahující
hodnoty různých typů. Připomeňme si například, jakým způsobem se zapsala
hlavička <strong>IHDR</strong> do souboru ve formátu PNG:</p>

<pre>
struct.pack("!2I5B", width, height, 8, 2, 0, 0, 0)
</pre>

<p>V&nbsp;tomto případě se zapíše dvojice čtyřbajtových celých čísel a následně
pětice bajtů.</p>

<p>Ovšem právě u podobných datových struktur je nutné vyřešit zarovnání hodnot
a případnou existenci nebo neexistenci výplňových bajtů na konci takové
struktury. V&nbsp;balíčku <strong>struct</strong> můžeme explicitně určovat, že
se použijí výplňové bajty, s&nbsp;využitím specifikátoru &bdquo;x&ldquo;
(například "4x" značí čtyři výplňové bajty, ukládají se do nich nuly). To je
sice užitečné, ale k&nbsp;dispozici máme ještě jednu možnost &ndash;
specifikovat, že zarovnání a výplně se mají řešit přesně tak, jak to dělají
céčkové překladače na dané platformě. Tím bude zajištěna možnost komunikace
mezi Pythonem a céčkem. Tento režim je povolený v&nbsp;případě, že prvním
znakem v&nbsp;řetězci s&nbsp;formátem je znak &bdquo;@&ldquo;, nebo se zde
žádný specifikátor způsobu uložení nenachází. Navíc tento znak ovlivní i bitové
(a tedy i bajtové) šířky numerických hodnot atd.</p>

<p><div class="rs-tip-major">Poznámka: &bdquo;@&ldquo; je nastaven jako výchozí
formát, pokud není zadáno něco jiného!</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zarovnání a výplně</h2>

<p>Vyzkoušejme si nyní provést serializaci trojice hodnot s&nbsp;formáty
&bdquo;dvoubytové slovo+bajt+dvoubytové slovo&ldquo; do binárního bloku,
přičemž nejprve použijeme výchozí způsob uložení, dále nativní způsob bez
zarovnání a konečně explicitně nastavený nativní způsob se zarovnáním:</p>

<pre>
import struct
&nbsp;
bytes1 = <strong>struct.pack(<u>"hbh"</u>, 1, 2, 3)</strong>
print(type(bytes1))
print(bytes1.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes2 = <strong>struct.pack(<u>"=hbh"</u>, 1, 2, 3)</strong>
print(type(bytes2))
print(bytes2.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes3 = <strong>struct.pack(<u>"@hbh"</u>, 1, 2, 3)</strong>
print(type(bytes3))
print(bytes3.hex(" ", 1))
</pre>

<p>Výsledky serializace budou odlišné, právě kvůli zarovnání u prvního a
posledního formátu:</p>

<pre>
&lt;class 'bytes'&gt;
01 00 02 00 03 00
&nbsp;
&lt;class 'bytes'&gt;
01 00 02 03 00
&nbsp;
&lt;class 'bytes'&gt;
01 00 02 00 03 00
</pre>

<p><div class="rs-tip-major">Poznámka: zde se tedy výstup odlišuje pouze tím,
zda je za prostředním bajtem uložena výplň či nikoli.</div></p>

<p>Otestujme podobný příklad, ovšem nyní s&nbsp;hodnotami odlišných typů. Pro
větší čitelnost výsledků se zde ukládají hodnoty 1, 0xffff (16bitů) a 3. První
a poslední hodnota přitom může být uložena ve čtyřech bajtech (NEnativní
serializace) nebo na některých platformách i v&nbsp;odlišném počtu bajtů
(nativní serializace):</p>

<pre>
import struct
&nbsp;
bytes1 = <strong>struct.pack(<u>"iHi"</u>, 1, 0xffff, 3)</strong>
print(type(bytes1))
print(bytes1.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes2 = <strong>struct.pack(<u>"=iHi"</u>, 1, 0xffff, 3)</strong>
print(type(bytes2))
print(bytes2.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes3 = <strong>struct.pack(<u>"@iHi"</u>, 1, 0xffff, 3)</strong>
print(type(bytes3))
print(bytes3.hex(" ", 1))
</pre>

<p>Na platformě x86(64) dostaneme tyto výsledky:</p>

<pre>
&lt;class 'bytes'&gt;
01 00 00 00 ff ff 00 00 03 00 00 00
&nbsp;
&lt;class 'bytes'&gt;
01 00 00 00 ff ff 03 00 00 00
&nbsp;
&lt;class 'bytes'&gt;
01 00 00 00 ff ff 00 00 03 00 00 00
</pre>

<p><div class="rs-tip-major">Poznámka: opět si povšimněte, že rozdíl spočívá
v&nbsp;tom, zda se za 16bitovou hodnotou použije zarovnání resp.&nbsp;zda se
vlastně uloží 16bitová či 32bitová hodnota (to nemusíme rozlišovat).</div></p>

<p>U nativního způsobu zarovnání většinou platí, že kratší prvky (bajty,
šestnáctibitové hodnoty) jsou zarovnány na stejnou šířku, jako delší prvky
(32bitové a 64bitové hodnoty). Opět si to vyzkoušejme, nyní s&nbsp;krajními
prvky typu &bdquo;i&ldquo;, což může odpovídat 32bitovým či 64bitovým hodnotám
(v&nbsp;NEnativní serializaci jsou to 32bitové hodnoty):</p>

<pre>
import struct
&nbsp;
bytes1 = <strong>struct.pack(<u>"lHl"</u>, 1, 0xffff, 3)</strong>
print(type(bytes1))
print(bytes1.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes2 = <strong>struct.pack(<u>"=lHl"</u>, 1, 0xffff, 3)</strong>
print(type(bytes2))
print(bytes2.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes3 = <strong>struct.pack(<u>"@lHl"</u>, 1, 0xffff, 3)</strong>
print(type(bytes3))
print(bytes3.hex(" ", 1))
</pre>

<p>Výsledky nyní mohou být odlišné v&nbsp;případě, že &bdquo;i&ldquo; bude na
dané platformě chápáno jako 64bitová hodnota nebo hodnota zarovnaná na
64bitů:</p>

<pre>
&lt;class 'bytes'&gt;
01 00 00 00 00 00 00 00 ff ff 00 00 00 00 00 00 03 00 00 00 00 00 00 00
&nbsp;
&lt;class 'bytes'&gt;
01 00 00 00 ff ff 03 00 00 00
&nbsp;
&lt;class 'bytes'&gt;
01 00 00 00 00 00 00 00 ff ff 00 00 00 00 00 00 03 00 00 00 00 00 00 00
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výpočet velikosti binární struktury se zadaným formátem prvků</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Velikost binární struktury s&nbsp;výplněmi</h2>

<pre>
import struct
&nbsp;
def <strong>size_for_format</strong>(format):
    size = struct.calcsize(format)
    print(f"{format:&gt;6}:{size}")
&nbsp;
&nbsp;
size_for_format("b")
&nbsp;
print()
&nbsp;
size_for_format("iBi")
size_for_format("=iBi")
size_for_format("@iBi")
&nbsp;
print()
&nbsp;
size_for_format("lBl")
size_for_format("=lBl")
size_for_format("@lBl")
&nbsp;
print()
&nbsp;
size_for_format("fBf")
size_for_format("=fBf")
size_for_format("@fBf")
&nbsp;
print()
&nbsp;
size_for_format("dBd")
size_for_format("=dBd")
size_for_format("@dBd")
&nbsp;
print()
&nbsp;
size_for_format("dBBd")
size_for_format("=dBBd")
size_for_format("@dBBd")
&nbsp;
print()
&nbsp;
size_for_format("dBBBd")
size_for_format("=dBBBd")
size_for_format("@dBBBd")
</pre>

<pre>
     b:1
&nbsp;
   iBi:12
  =iBi:9
  @iBi:12
&nbsp;
   lBl:24
  =lBl:9
  @lBl:24
&nbsp;
   fBf:12
  =fBf:9
  @fBf:12
&nbsp;
   dBd:24
  =dBd:17
  @dBd:24
&nbsp;
  dBBd:24
 =dBBd:18
 @dBBd:24
&nbsp;
 dBBBd:24
=dBBBd:19
@dBBBd:24
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Doplňkové bajty na konci binární struktury</h2>

<p></p>

<pre>
import struct
&nbsp;
bytes1 = struct.pack("lB", 1, 0xff)
print(type(bytes1))
print(bytes1.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes2 = struct.pack("lB0h", 1, 0xff)
print(type(bytes2))
print(bytes2.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes3 = struct.pack("lB0i", 1, 0xff)
print(type(bytes3))
print(bytes3.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes4 = struct.pack("lB0l", 1, 0xff)
print(type(bytes4))
print(bytes4.hex(" ", 1))
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Krátké zopakování z&nbsp;minula: zápis rastrového obrázku do formátu PNG</h2>

<pre>
<i>""" Zápis rastrového obrázku do formátu PNG."""</i>
&nbsp;
<i># Inspirace:</i>
<i># https://stackoverflow.com/questions/902761/saving-a-numpy-array-as-an-image</i>
&nbsp;
import struct
import zlib
&nbsp;
PNG_SIGNATURE = b'\x89PNG\r\n\x1a\n'
FILTER_TYPE = b'\x00'
&nbsp;
def <strong>prepare_raw_data</strong>(buffer, width, height):
    <i>"""Konverze barev pixelů z bufferu do podoby se specifikací filtru na</i>
    <i>každém řádku."""</i>
    raw_data = bytearray()
    offset = 0
    for _ in range(height):
        <i># nastavit filtr + zkopirovat jeden radek (scanline)</i>
        raw_data += FILTER_TYPE + buffer[offset:offset+width*3]
        <i># na dalsi radek ve zdrojovem bufferu</i>
        offset += width*3
    return raw_data
&nbsp;
&nbsp;
def <strong>png_chunk</strong>(png_tag, chunk_data):
    <i>"""Konstrukce jednoho PNG chunku s tagem i závěrečným kontrolním kódem."""</i>
    chunk_header = png_tag + chunk_data
    return (struct.pack("!I", len(chunk_data)) +
            chunk_header +
            struct.pack("!I", 0xFFFFFFFF &amp; zlib.crc32(chunk_header)))
&nbsp;
&nbsp;
def <strong>write_png</strong>(buffer, width, height):
    <i>"""Uložení rastrového obrázku z bufferu do PNG."""</i>
    raw_data = prepare_raw_data(buffer, width, height)
&nbsp;
    return b''.join([
        PNG_SIGNATURE,
        png_chunk(b'IHDR', struct.pack("!2I5B", width, height, 8, 2, 0, 0, 0)),
        png_chunk(b'IDAT', zlib.compress(raw_data, level=9, wbits=15)),
        png_chunk(b'IEND', b'')])
&nbsp;
&nbsp;
WIDTH = 256
HEIGHT = 256
&nbsp;
<i># buffer pro rastrová data</i>
pixels = bytearray(WIDTH*HEIGHT*3)
&nbsp;
<i># vybarvení testovacího obrázku</i>
index = 0
for i in range(HEIGHT):
    for j in range(WIDTH):
        pixels[index] = 0xff
        index+=1
        pixels[index] = i
        index+=1
        pixels[index] = j
        index+=1
&nbsp;
data = write_png(pixels, WIDTH, HEIGHT)
with open("test.png", 'wb') as fout:
    fout.write(data)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Formát PNG</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Testovací obrázek, který budeme načítat a analyzovat</h2>

<p>Pro otestování dále popsaného programového kódu určeného pro analýzu dat
uložených ve formátu PNG byl vytvořen jednoduchý testovací obrázek dostupný na
adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/test.png">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/test.png</a>,
jenž má délku 132 bajtů. Tento obrázek má rozlišení 1&times;1 pixel a obsahuje
barvovou paletu, informaci o průhledné barvě (<i>transparency</i>) a taktéž
vložený informační text. Podívejme se na hexadecimální výpis obsahu tohoto
souboru. Na pravé straně jsou zobrazeny tisknutelné znaky nalezené
v&nbsp;souboru, z&nbsp;nichž je při podrobnějším zkoumání patrné, kde se
nacházejí jednotlivé chunky nazvané <strong>IHDR</strong>,
<strong>PLTE</strong>, <strong>tRNS</strong>, <strong>IDAT</strong>,
<strong>iTXt</strong> a <strong>IEND</strong>:</p>

<pre>
00000000: 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52  .PNG........IHDR
00000010: 00 00 00 01 00 00 00 01 08 03 00 00 00 28 cb 34  .............(.4
00000020: bb 00 00 00 03 50 4c 54 45 00 00 00 a7 7a 3d da  .....PLTE....z=.
00000030: 00 00 00 01 74 52 4e 53 00 40 e6 d8 66 00 00 00  ....tRNS.@..f...
00000040: 0a 49 44 41 54 08 5b 63 60 00 00 00 02 00 01 62  .IDAT.[c`......b
00000050: 40 4f 68 00 00 00 19 69 54 58 74 6c 69 6e 6b 00  @Oh....iTXtlink.
00000060: 00 00 77 77 77 2e 72 6f 6f 74 2e 63 7a 00 2d 67  ..www.root.cz.-g
00000070: 00 31 2e 30 10 df f9 79 00 00 00 00 49 45 4e 44  .1.0...y....IEND
00000080: ae 42 60 82                                      .B`.
</pre>

<p>Právě z&nbsp;tohoto binárního souboru se budeme pokoušet číst jednotlivé
údaje.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Čtení hlavičky PNG</h2>

<p></p>

<pre>
PNG_SIGNATURE = b"\x89PNG\r\n\x1a\n"
</pre>

<p></p>

<pre>
&nbsp;
with open("test.png", "rb") as fin:
    <i># nacteni signatury</i>
    signature = fin.read(len(PNG_SIGNATURE))
</pre>

<p></p>

<pre>
    <i># kontrola signatury</i>
    assert len(signature) == len(PNG_SIGNATURE)
    assert signature == PNG_SIGNATURE
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Načtení hlaviček jednotlivých chunků</h2>

<pre>
    while True:
        <i># nacteni hlavicky chunku</i>
        chunk_header = fin.read(8)
        if len(chunk_header) &lt; 8:
            print(f"End of file with remaining {len(chunk_header)} bytes")
            break
        <i># hlavicka obsahuje delku (4 bajty) a ctyri znaky se jmenem</i>
        s = <strong>struct.Struct("!I4s")</strong>
        length, png_tag = <strong>s.unpack(chunk_header)</strong>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Přeskok datové části chunku a přečtení kontrolního součtu</h2>

<pre>
    while True:
        <i># nacteni hlavicky chunku</i>
        chunk_header = fin.read(8)
        if len(chunk_header) &lt; 8:
            print(f"End of file with remaining {len(chunk_header)} bytes")
            break
        <i># hlavicka obsahuje delku (4 bajty) a ctyri znaky se jmenem</i>
        s = struct.Struct("!I4s")
        length, png_tag = s.unpack(chunk_header)

        <i># preskocit data chunku</i>
        fin.seek(length, 1)

        <i># nacteni CRC32 chunku</i>
        c = struct.Struct("!I")
        crc_block = fin.read(4)
        if len(crc_block) &lt; 4:
            print("Error: not correct CRC block!")
            break
        crc = c.unpack(crc_block)[0]
        print(f"{png_tag.decode("ASCII")}  {length:5}   {crc:04x}")
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Úplný zdrojový kód příkladu, který přečte chunky uložené v&nbsp;souboru formátu PNG</h2>

<p>Podívejme se nyní na úplný zdrojový kód příkladu, po jehož spuštění se
postupně načte a analyzuje soubor &bdquo;test.png&ldquo;, který obsahuje
obrázek ve formátu PNG. Skript postupně vypíše všechny chunky, které se
v&nbsp;souboru nachází, jejich velikost i kontrolní součet:</p>

<pre>
<i>"""Informace o obrázku uloženého ve formátu PNG."""</i>
&nbsp;
import struct
&nbsp;
PNG_SIGNATURE = b'\x89PNG\r\n\x1a\n'
&nbsp;
with open("test.png", "rb") as fin:
    <i># nacteni signatury</i>
    signature = fin.read(len(PNG_SIGNATURE))
&nbsp;
    <i># kontrola signatury</i>
    assert len(signature) == len(PNG_SIGNATURE)
    assert signature == PNG_SIGNATURE
&nbsp;
    <i># postupne nacteni jednotlivych chunku</i>
    print("Chunk  Length   CRC")
    while True:
        <i># nacteni hlavicky chunku</i>
        chunk_header = fin.read(8)
        if len(chunk_header) &lt; 8:
            print(f"End of file with remaining {len(chunk_header)} bytes")
            break
        <i># hlavicka obsahuje delku (4 bajty) a ctyri znaky se jmenem</i>
        s = struct.Struct("!I4s")
        length, png_tag = s.unpack(chunk_header)
&nbsp;
        <i># preskocit data chunku</i>
        fin.seek(length, 1)
&nbsp;
        <i># nacteni CRC32 chunku</i>
        c = struct.Struct("!I")
        crc_block = fin.read(4)
        if len(crc_block) &lt; 4:
            print("Error: not correct CRC block!")
            break
        crc = c.unpack(crc_block)[0]
        print(f"{png_tag.decode("ASCII")}  {length:5}   {crc:04x}")
</pre>

<p>Zkusme si nyní tento skript spustit, přičemž se v&nbsp;aktuálním adresáři
nachází i soubor &bdquo;test.png&ldquo;. Měli bychom získat tento výstup:</p>

<pre>
Chunk  Length   CRC
IHDR     13   28cb34bb
PLTE      3   a77a3dda
tRNS      1   40e6d866
IDAT     10   62404f68
iTXt     25   10dff979
IEND      0   ae426082
End of file with remaining 0 bytes
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se zdá, že soubor je
korektní, protože na konci nám nezbyly žádné bajty naví &ndash; celý obsah
souboru je tvořen jen hlavičkou PNG, která je následována sérií
chunků.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Načtení informací uložených v&nbsp;chunku <strong>IHDR</strong></h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Úplný zdrojový kód skriptu, který vypíše strukturu PNG souboru i přesné informace z&nbsp;hlavičky</h2>

<p>V&nbsp;samotném závěru dnešního článku je ukázán úplný zdrojový kód skriptu,
který po svém spuštění vypíše nejenom všechny chunky uložené ve formátu PNG,
ale i obsah hlavičky, tj.&nbsp;dat v&nbsp;chunku <strong>IHDR</strong>:</p>

<pre>
<i>"""Informace o obrázku uloženého ve formátu PNG."""</i>
&nbsp;
import struct
&nbsp;
PNG_SIGNATURE = b"\x89PNG\r\n\x1a\n"
&nbsp;
with open("test.png", "rb") as fin:
    <i># nacteni signatury</i>
    signature = fin.read(len(PNG_SIGNATURE))
&nbsp;
    <i># kontrola signatury</i>
    assert len(signature) == len(PNG_SIGNATURE)
    assert signature == PNG_SIGNATURE
&nbsp;
    <i># postupne nacteni jednotlivych chunku</i>
    print("Chunk  Length   CRC")
    while True:
        <i># nacteni hlavicky chunku</i>
        chunk_header = fin.read(8)
        if len(chunk_header) &lt; 8:
            print(f"End of file with remaining {len(chunk_header)} bytes")
            break
        <i># hlavicka obsahuje delku (4 bajty) a ctyri znaky se jmenem</i>
        s = struct.Struct("!I4s")
        length, png_tag = s.unpack(chunk_header)
&nbsp;
        if png_tag == b"IHDR":
            <i># hlavicku nacist celou - ocekava se tento format:</i>
            <i># Width:              4 bytes</i>
            <i># Height:             4 bytes</i>
            <i># Bit depth:          1 byte</i>
            <i># Color type:         1 byte</i>
            <i># Compression method: 1 byte</i>
            <i># Filter method:      1 byte</i>
            <i># Interlace method:   1 byte</i>
            h = struct.Struct("!2I5B")
            chunk_data = fin.read(length)
            width, height, bit_depth, color_type, compression, filter, interlace = (
                h.unpack(chunk_data)
            )
        else:
            <i># preskocit data chunku</i>
            fin.seek(length, 1)
&nbsp;
        <i># nacteni CRC32 chunku</i>
        c = struct.Struct("!I")
        crc_block = fin.read(4)
        if len(crc_block) &lt; 4:
            print("Error: not correct CRC block!")
            break
        crc = c.unpack(crc_block)[0]
        print(f"{png_tag.decode("ASCII")}  {length:5}   {crc:04x}")
&nbsp;
&nbsp;
color_type_desc = [
    "grayscale",
    "unknown",
    "RGB",
    "color palette",
    "grayscale+alpha",
    "RGBA",
]
&nbsp;
&nbsp;
print(f"Resolution:  {width}x{height}")
print(f"Bit depth:   {bit_depth} bpp")
print(f"Color type:  {color_type} = {color_type_desc[color_type]}")
print(f"Compression: {compression}")
print(f"Filter type: {filter}")
print(f"Interlace:   {interlace}")
</pre>

<p>Výsledky, které získáme po spuštění tohoto skriptu, pokud se použije obrázek
&bdquo;test.png&ldquo; z&nbsp;repositáře:</p>

<pre>
Chunk  Length   CRC
IHDR     13   28cb34bb
PLTE      3   a77a3dda
tRNS      1   40e6d866
IDAT     10   62404f68
iTXt     25   10dff979
IEND      0   ae426082
End of file with remaining 0 bytes
Resolution:  1x1
Bit depth:   8 bpp
Color type:  3 = color palette
Compression: 0
Filter type: 0
Interlace:   0
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady využívající standardní knihovnu
<i>struct</i> lze nalézt v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th>#<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td> 1</td><td>bytes_type.py</td><td>konstrukce hodnoty typu <strong>bytes</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_type.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_type.py</a></td></tr>
<tr><td> 2</td><td>bytes_literal.py</td><td>literál popisující hodnotu typu <strong>bytes</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_literal.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_literal.py</a></td></tr>
<tr><td> 3</td><td>bytes_literal_no_ascii.py</td><td>literál s&nbsp;neplatnými znaky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_literal_no_ascii.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_literal_no_ascii.py</a></td></tr>
<tr><td> 4</td><td>bytes_hex.py</td><td>převod hodnoty typu <strong>bytes</strong> na řetězec s&nbsp;hexadecimálními hodnotami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_hex.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_hex.py</a></td></tr>
<tr><td> 5</td><td>bytes_fromhex.py</td><td>převod řetězce s&nbsp;hexadecimálními hodnotami na sekvenci bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_fromhex.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_fromhex.py</a></td></tr>
<tr><td> 6</td><td>bytes_fromhex_err.py</td><td>převod řetězce s&nbsp;nezarovnanými hexadecimálními hodnotami na sekvenci bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_fromhex_err.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_fromhex_err.py</a></td></tr>
<tr><td> 7</td><td>bytes_are_immutable.py</td><td>test, zda jsou hodnoty typu <strong>bytes</strong> skutečně neměnitelné</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_are_immutable.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_are_immutable.py</a></td></tr>
<tr><td> 8</td><td>bytes_encode.py</td><td>převod řetězce do zadaného kódování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_encode.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_encode.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>bytearray_type.py</td><td>konstrukce hodnoty typu <strong>bytearray</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_type.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_type.py</a></td></tr>
<tr><td>10</td><td>bytearray_is_mutable.py</td><td>test, zda jsou hodnoty typu <strong>bytearray</strong> měnitelné</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_is_mutable.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_is_mutable.py</a></td></tr>
<tr><td>11</td><td>bytearray_hex.py</td><td>převod hodnoty typu <strong>bytearray</strong> na řetězec s&nbsp;hexadecimálními hodnotami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_hex.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_hex.py</a></td></tr>
<tr><td>12</td><td>bytearray_fromhex.py</td><td>převod řetězce s&nbsp;hexadecimálními hodnotami na měnitelné pole bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_fromhex.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_fromhex.py</a></td></tr>
<tr><td>13</td><td>bytearray_encode.py</td><td>převod ASCII řetězce do zadaného kódování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_encode.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_encode.py</a></td></tr>
<tr><td>14</td><td>bytearray_encode_2.py</td><td>převod řetězce s&nbsp;nabodeníčky do zadaného kódování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_encode_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_encode_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>string_to_bytes.py</td><td>převod řetězce na sekvenci bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/string_to_bytes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/string_to_bytes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>struct_help.py</td><td>nápověda k&nbsp;balíčku <strong>struct</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/struct_help.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/struct_help.py</a></td></tr>
<tr><td>16</td><td>pack_byte.py</td><td>uložení hodnoty typu <strong>byte</strong> do sekvence bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_byte.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_byte.py</a></td></tr>
<tr><td>17</td><td>pack_byte_negative.py</td><td>pokus o uložení záporné hodnoty jakoby se jednalo o bajt bez znaménka</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_byte_negative.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_byte_negative.py</a></td></tr>
<tr><td>18</td><td>pack_words.py</td><td>uložení celočíselné numerické hodnoty ve formě slova s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_words.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_words.py</a></td></tr>
<tr><td>19</td><td>pack_words_endianess.py</td><td>řízení little/big endian při ukládání slov</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_words_endianess.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_words_endianess.py</a></td></tr>
<tr><td>20</td><td>pack_floats.py</td><td>uložení hodnoty typu <strong>float</strong> do sekvence bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_floats.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_floats.py</a></td></tr>
<tr><td>21</td><td>pack_png_header_1.py</td><td>uložení části hlavičky grafického formátu PNG, první verze</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_png_header_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_png_header_1.py</a></td></tr>
<tr><td>22</td><td>pack_png_header_2.py</td><td>uložení části hlavičky grafického formátu PNG, druhá verze</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_png_header_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_png_header_2.py</a></td></tr>
<tr><td>23</td><td>write_png.py</td><td>zápis bufferu s&nbsp;rastrovým obrázkem do formátu PNG</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/write_png.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/write_png.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>unpack_method.py</td><td>základní použití metody <strong>struct.unpack</strong> pro načtení hodnot z&nbsp;binárních dat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_method.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_method.py</a></td></tr>
<tr><td>25</td><td>unpack_byte.py</td><td>načtení jediného bajtu z&nbsp;binárních dat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_byte.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_byte.py</a></td></tr>
<tr><td>26</td><td>unpack_word_1.py</td><td>vliv endianessu na načtenou vícebajtovou hodnotu, první příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_1.py</a></td></tr>
<tr><td>27</td><td>unpack_word_2.py</td><td>vliv endianessu na načtenou vícebajtovou hodnotu, druhý příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_2.py</a></td></tr>
<tr><td>28</td><td>unpack_word_3.py</td><td>vliv endianessu na načtenou vícebajtovou hodnotu, třetí příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>pack_alignment_1.py</td><td>zarovnání hodnot v&nbsp;binárních datech, první příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_1.py</a></td></tr>
<tr><td>30</td><td>pack_alignment_2.py</td><td>zarovnání hodnot v&nbsp;binárních datech, druhý příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_2.py</a></td></tr>
<tr><td>31</td><td>pack_alignment_3.py</td><td>zarovnání hodnot v&nbsp;binárních datech, třetí příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_3.py</a></td></tr>
<tr><td>32</td><td>calcsize.py</td><td>výpočet velikosti binární struktury na základě zadaného formátu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/calcsize.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/calcsize.py</a></td></tr>
<tr><td>33</td><td>pack_padding.py</td><td>výplň struktury bajty přidanými na konec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_padding.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_padding.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>34</td><td>png_info_1.py</td><td>přečtení základních informací ze souborů typu PNG</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_1.py</a></td></tr>
<tr><td>35</td><td>png_info_2.py</td><td>přečtení celé hlavičky souborů typu PNG</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_2.py</a></td></tr>
<tr><td>36</td><td>png_info_3.py</td><td>kontrola CRC jednotlivých chunků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_3.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python standard types: bytes<br />
<a href="https://docs.python.org/3.8/library/stdtypes.html#bytes">https://docs.python.org/3.8/library/stdtypes.html#bytes</a>
</li>

<li>Python standard types: bytearray<br />
<a href="https://docs.python.org/3.8/library/stdtypes.html#bytearray-objects">https://docs.python.org/3.8/library/stdtypes.html#bytearray-objects</a>
</li>

<li>Bytes and Bytearray Operations<br />
<a href="https://docs.python.org/3.8/library/stdtypes.html#bytes-methods">https://docs.python.org/3.8/library/stdtypes.html#bytes-methods</a>
</li>

<li>Standard encodings<br />
<a href="https://docs.python.org/3.8/library/codecs.html#standard-encodings">https://docs.python.org/3.8/library/codecs.html#standard-encodings</a>
</li>

<li>class memoryview<br />
<a href="https://docs.python.org/3.8/library/stdtypes.html#memoryview">https://docs.python.org/3.8/library/stdtypes.html#memoryview</a>
</li>

<li>struct &ndash; Interpret bytes as packed binary data<br />
<a href="https://docs.python.org/3/library/struct.html">https://docs.python.org/3/library/struct.html</a>
</li>

<li>C-like structures in Python<br />
<a href="https://stackoverflow.com/questions/35988/c-like-structures-in-python">https://stackoverflow.com/questions/35988/c-like-structures-in-python</a>
</li>

<li>python3: bytes vs bytearray, and converting to and from strings<br />
<a href="https://stackoverflow.com/questions/62903377/python3-bytes-vs-bytearray-and-converting-to-and-from-strings">https://stackoverflow.com/questions/62903377/python3-bytes-vs-bytearray-and-converting-to-and-from-strings</a>
</li>

<li>Základní informace o MessagePacku<br />
<a href="https://msgpack.org/">https://msgpack.org/</a>
</li>

<li>Balíček msgpack na PyPi<br />
<a href="https://pypi.org/project/msgpack/">https://pypi.org/project/msgpack/</a>
</li>

<li>MessagePack na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/MessagePack">https://en.wikipedia.org/wiki/MessagePack</a>
</li>

<li>Comparison of data-serialization formats (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a>
</li>

<li>Repositáře msgpacku<br />
<a href="https://github.com/msgpack">https://github.com/msgpack</a>
</li>

<li>Specifikace ukládání různých typů dat<br />
<a href="https://github.com/msgpack/msgpack/blob/master/spec.md">https://github.com/msgpack/msgpack/blob/master/spec.md</a>
</li>

<li>Podpora MessagePacku v&nbsp;různých programovacích jazycích<br />
<a href="https://msgpack.org/#languages">https://msgpack.org/#languages</a>
</li>

<li>Základní implementace formátu msgpack pro programovací jazyk Go<br />
<a href="https://github.com/msgpack/msgpack-go">https://github.com/msgpack/msgpack-go</a>
</li>

<li>go-codec<br />
<a href="https://github.com/ugorji/go">https://github.com/ugorji/go</a>
</li>

<li>Gobs of data (odlišný serializační formát)<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>Formát BSON (odlišný serializační formát)<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Problematika nulových hodnot v Go, aneb proč nil != nil<br />
<a href="https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/">https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/</a>
</li>

<li>IEEE-754 Floating Point Converter<br />
<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a>
</li>

<li>Base Convert: IEEE 754 Floating Point<br />
<a href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a>
</li>

<li>Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Protocol Buffers<br />
<a href="https://protobuf.dev/">https://protobuf.dev/</a>
</li>

<li>Protocol Buffers<br />
<a href="https://en.wikipedia.org/wiki/Protocol_Buffers">https://en.wikipedia.org/wiki/Protocol_Buffers</a>
</li>

<li>What is the difference between Serialization and Marshaling?<br />
<a href="https://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling">https://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling</a>
</li>

<li>Comparison of data-serialization formats<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a>
</li>

<li>PNG (Portable Network Graphics) Specification, Version 1.2<br />
<a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html">http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html</a>
</li>

<li>Data structure alignment<br />
<a href="https://en.wikipedia.org/wiki/Data_structure_alignment">https://en.wikipedia.org/wiki/Data_structure_alignment</a>
</li>

<li>Byte alignment and ordering<br />
<a href="https://www.eventhelix.com/embedded/byte-alignment-and-ordering/">https://www.eventhelix.com/embedded/byte-alignment-and-ordering/</a>
</li>

<li>The Lost Art of Structure Packing<br />
<a href="http://www.catb.org/esr/structure-packing/">http://www.catb.org/esr/structure-packing/</a>
</li>

<li>Padding is hard<br />
<a href="https://dave.cheney.net/2015/10/09/padding-is-hard">https://dave.cheney.net/2015/10/09/padding-is-hard</a>
</li>

<li>Structure Member Alignment, Padding and Data Packing<br />
<a href="https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/">https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/</a>
</li>

<li>C Alignment Cheatsheet<br />
<a href="https://github.com/Q1CHENL/c-alignment-cheatsheet">https://github.com/Q1CHENL/c-alignment-cheatsheet</a>
</li>

<li>Struct padding rules in Rust<br />
<a href="https://stackoverflow.com/questions/70587534/struct-padding-rules-in-rust">https://stackoverflow.com/questions/70587534/struct-padding-rules-in-rust</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

