<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Manipulace s binárními datovými strukturami v Pythonu (2. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Manipulace s binárními datovými strukturami v Pythonu (2. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Manipulace s&nbsp;binárními datovými strukturami v&nbsp;Pythonu (2. část)</a></p>
<p><a href="#k02">2. Metoda <strong>Struct.unpack</strong> pro přečtení hodnot z&nbsp;binární struktury</a></p>
<p><a href="#k03">3. Korektní přečtení jedné hodnoty z&nbsp;binárních dat</a></p>
<p><a href="#k04">*** 4. Čtení vícebajtové hodnoty se specifikací pořadí bajtů</a></p>
<p><a href="#k05">*** 5. Binární formáty obsahující více hodnot různých typů</a></p>
<p><a href="#k06">*** 6. Zarovnání a výplně</a></p>
<p><a href="#k07">*** 7. Výpočet velikosti binární struktury se zadaným formátem prvků</a></p>
<p><a href="#k08">*** 8. Velikost binární struktury s&nbsp;výplněmi</a></p>
<p><a href="#k09">*** 9. Doplňkové bajty na konci binární struktury</a></p>
<p><a href="#k10">*** 10. Krátké zopakování z&nbsp;minula: zápis rastrového obrázku do formátu PNG</a></p>
<p><a href="#k11">*** 11. Formát PNG</a></p>
<p><a href="#k12">12. Testovací obrázek, který budeme načítat a analyzovat</a></p>
<p><a href="#k13">*** 13. Čtení hlavičky PNG</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Manipulace s&nbsp;binárními datovými strukturami v&nbsp;Pythonu (2. část)</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Metoda <strong>Struct.unpack</strong> pro přečtení hodnot z&nbsp;binární struktury</h2>

<p>Pro serializaci hodnot do binárních dat jsme v&nbsp;předchozím článku
používali funkci <strong>unpack</strong> ze standardního balíčku
<strong>struct</strong>. Opačná operace, tj.&nbsp;získání hodnoty určitého typu
z&nbsp;binárních dat, je nepatrně složitější, neboť namísto volání jedné funkce
je nejprve nutné zkonstruovat objekt typu <strong>struct.Struct</strong>
(s&nbsp;předáním požadovaného formátu) a následně zavolat metodu
<strong>unpack</strong>, které se předají binární data (<strong>bytes</strong>,
<strong>bytearray</strong> atd.). Tato metoda z&nbsp;binárních dat získá
požadovanou hodnotu či hodnoty a vrátí je formou n-tice (<i>tuple</i>):</p>

<pre>
<strong>unpack(self, buffer, /) unbound _struct.Struct method</strong>
    Return a tuple containing unpacked values.
&nbsp;
    Unpack according to the format string Struct.format. The buffer's size
    in bytes must be Struct.size.
</pre>

<p>Celý postup si ukážeme na jednoduchém demonstračním příkladu, v&nbsp;němž
nejprve uložíme celočíselnou hodnotu 42 do binárních dat (typ
<strong>bytes</strong>) a pro jistotu si obsah binárních dat vypíšeme. Následně
se zkonstruuje objekt typu <strong>struct.Struct</strong> předáním požadovaného
formátu do konstruktoru (formát &bdquo;b&ldquo; &ndash; jediný bajt). Posledním
krokem je zavolání metody <strong>Struct.unpack()</strong>, které předáme již
dříve vytvořená binární data:</p>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("b", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = struct.Struct("b")
from_struct = s.unpack(bytes)
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<p>Výsledkem deserializace z&nbsp;binárních dat bude n-tice obsahující jediný
prvek, konkrétně prvek s&nbsp;celočíselnou hodnotou 42:</p>

<pre>
Serialized:   2a
Deserialized: (42,)
Type:         &lt;class 'tuple'&gt;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Korektní přečtení jedné hodnoty z&nbsp;binárních dat</h2>

<p>V&nbsp;případě, že se z&nbsp;binárních dat čte pouze jediný údaj, typicky
znak, celočíselná numerická hodnota, numerická hodnota s&nbsp;plovoucí řádovou
čárkou atd., je řešení velmi jednoduché &ndash; metodou
<strong>Struct.unpack</strong> si necháme vrátit n-tici, která ovšem bude
obsahovat jediný údaj (specifikovaný ve formátu). Následně z&nbsp;n-tice tento
jediný její prvek přečteme a získáme tak hodnotu korektního typu.</p>

<p>Celý postup je snadný a můžeme si ho ověřit na následujícím demonstračním
příkladu:</p>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("b", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = struct.Struct("b")
&nbsp;
<i># první prvek z přečtené struktury</i>
from_struct = s.unpack(bytes)[0]
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<p>Tento skript by po svém spuštění měl vypsat, že binární data obsahují jediný
bajt s&nbsp;hodnotou 0x2a a následně se navíc vypíše, že byl tento bajt
deserializován do celočíselné hodnoty 42, která má korektní
(resp.&nbsp;přesněji řečeno očekávaný) typ <strong>int</strong>:</p>

<pre>
Serialized:   2a
Deserialized: 42
Type:         &lt;class 'int'&gt;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Čtení vícebajtové hodnoty se specifikací pořadí bajtů</h2>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("h", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = struct.Struct("h")
&nbsp;
<i># první prvek z přečtené struktury</i>
from_struct = s.unpack(bytes)[0]
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<pre>
Serialized:   2a 00
Deserialized: 42
Type:         &lt;class 'int'&gt;
</pre>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("h", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = struct.Struct("&lt;h")
&nbsp;
<i># první prvek z přečtené struktury</i>
from_struct = s.unpack(bytes)[0]
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<pre>
Serialized:   2a 00
Deserialized: 42
Type:         &lt;class 'int'&gt;
</pre>

<pre>
import struct
&nbsp;
<i># uložení hodnoty bajtu do binární struktury</i>
bytes = struct.pack("h", 42)
print("Serialized:  ", bytes.hex(" ", 1))
&nbsp;
<i># přečtení binární struktury, která obsahuje jediný bajt</i>
s = struct.Struct("&gt;h")
&nbsp;
<i># první prvek z přečtené struktury</i>
from_struct = s.unpack(bytes)[0]
&nbsp;
<i># vypsat přečtenou hodnotu</i>
print("Deserialized:", from_struct)
print("Type:        ", type(from_struct))
</pre>

<pre>
Serialized:   2a 00
Deserialized: 10752
Type:         &lt;class 'int'&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Binární formáty obsahující více hodnot různých typů</h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zarovnání a výplně</h2>

<pre>
import struct
&nbsp;
bytes1 = struct.pack("hbh", 1, 2, 3)
print(type(bytes1))
print(bytes1.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes2 = struct.pack("=hbh", 1, 2, 3)
print(type(bytes2))
print(bytes2.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes3 = struct.pack("@hbh", 1, 2, 3)
print(type(bytes3))
print(bytes3.hex(" ", 1))
</pre>

<pre>
</pre>

<pre>
import struct
&nbsp;
bytes1 = struct.pack("iHi", 1, 0xffff, 3)
print(type(bytes1))
print(bytes1.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes2 = struct.pack("=iHi", 1, 0xffff, 3)
print(type(bytes2))
print(bytes2.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes3 = struct.pack("@iHi", 1, 0xffff, 3)
print(type(bytes3))
print(bytes3.hex(" ", 1))
</pre>

<pre>
</pre>

<pre>
import struct
&nbsp;
bytes1 = struct.pack("lHl", 1, 0xffff, 3)
print(type(bytes1))
print(bytes1.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes2 = struct.pack("=lHl", 1, 0xffff, 3)
print(type(bytes2))
print(bytes2.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes3 = struct.pack("@lHl", 1, 0xffff, 3)
print(type(bytes3))
print(bytes3.hex(" ", 1))
</pre>

<pre>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výpočet velikosti binární struktury se zadaným formátem prvků</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Velikost binární struktury s&nbsp;výplněmi</h2>

<pre>
import struct
&nbsp;
def <strong>size_for_format</strong>(format):
    size = struct.calcsize(format)
    print(f"{format:&gt;6}:{size}")
&nbsp;
&nbsp;
size_for_format("b")
&nbsp;
print()
&nbsp;
size_for_format("iBi")
size_for_format("=iBi")
size_for_format("@iBi")
&nbsp;
print()
&nbsp;
size_for_format("lBl")
size_for_format("=lBl")
size_for_format("@lBl")
&nbsp;
print()
&nbsp;
size_for_format("fBf")
size_for_format("=fBf")
size_for_format("@fBf")
&nbsp;
print()
&nbsp;
size_for_format("dBd")
size_for_format("=dBd")
size_for_format("@dBd")
&nbsp;
print()
&nbsp;
size_for_format("dBBd")
size_for_format("=dBBd")
size_for_format("@dBBd")
&nbsp;
print()
&nbsp;
size_for_format("dBBBd")
size_for_format("=dBBBd")
size_for_format("@dBBBd")
</pre>

<pre>
     b:1
&nbsp;
   iBi:12
  =iBi:9
  @iBi:12
&nbsp;
   lBl:24
  =lBl:9
  @lBl:24
&nbsp;
   fBf:12
  =fBf:9
  @fBf:12
&nbsp;
   dBd:24
  =dBd:17
  @dBd:24
&nbsp;
  dBBd:24
 =dBBd:18
 @dBBd:24
&nbsp;
 dBBBd:24
=dBBBd:19
@dBBBd:24
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Doplňkové bajty na konci binární struktury</h2>

<p></p>

<pre>
import struct
&nbsp;
bytes1 = struct.pack("lB", 1, 0xff)
print(type(bytes1))
print(bytes1.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes2 = struct.pack("lB0h", 1, 0xff)
print(type(bytes2))
print(bytes2.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes3 = struct.pack("lB0i", 1, 0xff)
print(type(bytes3))
print(bytes3.hex(" ", 1))
&nbsp;
print()
&nbsp;
bytes4 = struct.pack("lB0l", 1, 0xff)
print(type(bytes4))
print(bytes4.hex(" ", 1))
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Krátké zopakování z&nbsp;minula: zápis rastrového obrázku do formátu PNG</h2>

<pre>
<i>""" Zápis rastrového obrázku do formátu PNG."""</i>
&nbsp;
<i># Inspirace:</i>
<i># https://stackoverflow.com/questions/902761/saving-a-numpy-array-as-an-image</i>
&nbsp;
import struct
import zlib
&nbsp;
PNG_SIGNATURE = b'\x89PNG\r\n\x1a\n'
FILTER_TYPE = b'\x00'
&nbsp;
def <strong>prepare_raw_data</strong>(buffer, width, height):
    <i>"""Konverze barev pixelů z bufferu do podoby se specifikací filtru na</i>
    <i>každém řádku."""</i>
    raw_data = bytearray()
    offset = 0
    for _ in range(height):
        <i># nastavit filtr + zkopirovat jeden radek (scanline)</i>
        raw_data += FILTER_TYPE + buffer[offset:offset+width*3]
        <i># na dalsi radek ve zdrojovem bufferu</i>
        offset += width*3
    return raw_data
&nbsp;
&nbsp;
def <strong>png_chunk</strong>(png_tag, chunk_data):
    <i>"""Konstrukce jednoho PNG chunku s tagem i závěrečným kontrolním kódem."""</i>
    chunk_header = png_tag + chunk_data
    return (struct.pack("!I", len(chunk_data)) +
            chunk_header +
            struct.pack("!I", 0xFFFFFFFF &amp; zlib.crc32(chunk_header)))
&nbsp;
&nbsp;
def <strong>write_png</strong>(buffer, width, height):
    <i>"""Uložení rastrového obrázku z bufferu do PNG."""</i>
    raw_data = prepare_raw_data(buffer, width, height)
&nbsp;
    return b''.join([
        PNG_SIGNATURE,
        png_chunk(b'IHDR', struct.pack("!2I5B", width, height, 8, 2, 0, 0, 0)),
        png_chunk(b'IDAT', zlib.compress(raw_data, level=9, wbits=15)),
        png_chunk(b'IEND', b'')])
&nbsp;
&nbsp;
WIDTH = 256
HEIGHT = 256
&nbsp;
<i># buffer pro rastrová data</i>
pixels = bytearray(WIDTH*HEIGHT*3)
&nbsp;
<i># vybarvení testovacího obrázku</i>
index = 0
for i in range(HEIGHT):
    for j in range(WIDTH):
        pixels[index] = 0xff
        index+=1
        pixels[index] = i
        index+=1
        pixels[index] = j
        index+=1
&nbsp;
data = write_png(pixels, WIDTH, HEIGHT)
with open("test.png", 'wb') as fout:
    fout.write(data)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Formát PNG</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Testovací obrázek, který budeme načítat a analyzovat</h2>

<p>Pro otestování dále popsaného programového kódu určeného pro analýzu dat
uložených ve formátu PNG byl vytvořen jednoduchý testovací obrázek dostupný na
adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/test.png">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/test.png</a>,
jenž má délku 132 bajtů. Tento obrázek má rozlišení 1&times;1 pixel a obsahuje
barvovou paletu, informaci o průhledné barvě (<i>transparency</i>) a taktéž
vložený informační text. Podívejme se na hexadecimální výpis obsahu tohoto
souboru. Na pravé straně jsou zobrazeny tisknutelné znaky nalezené
v&nbsp;souboru, z&nbsp;nichž je při podrobnějším zkoumání patrné, kde se
nacházejí jednotlivé chunky nazvané <strong>IHDR</strong>,
<strong>PLTE</strong>, <strong>tRNS</strong>, <strong>IDAT</strong>,
<strong>iTXt</strong> a <strong>IEND</strong>:</p>

<pre>
00000000: 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52  .PNG........IHDR
00000010: 00 00 00 01 00 00 00 01 08 03 00 00 00 28 cb 34  .............(.4
00000020: bb 00 00 00 03 50 4c 54 45 00 00 00 a7 7a 3d da  .....PLTE....z=.
00000030: 00 00 00 01 74 52 4e 53 00 40 e6 d8 66 00 00 00  ....tRNS.@..f...
00000040: 0a 49 44 41 54 08 5b 63 60 00 00 00 02 00 01 62  .IDAT.[c`......b
00000050: 40 4f 68 00 00 00 19 69 54 58 74 6c 69 6e 6b 00  @Oh....iTXtlink.
00000060: 00 00 77 77 77 2e 72 6f 6f 74 2e 63 7a 00 2d 67  ..www.root.cz.-g
00000070: 00 31 2e 30 10 df f9 79 00 00 00 00 49 45 4e 44  .1.0...y....IEND
00000080: ae 42 60 82                                      .B`.
</pre>

<p>Právě z&nbsp;tohoto binárního souboru se budeme pokoušet číst jednotlivé
údaje.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Čtení hlavičky PNG</h2>

<p></p>

<pre>
PNG_SIGNATURE = b"\x89PNG\r\n\x1a\n"
</pre>

<p></p>

<pre>
&nbsp;
with open("test.png", "rb") as fin:
    <i># nacteni signatury</i>
    signature = fin.read(len(PNG_SIGNATURE))
</pre>

<p></p>

<pre>
    <i># kontrola signatury</i>
    assert len(signature) == len(PNG_SIGNATURE)
    assert signature == PNG_SIGNATURE
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Načtení hlaviček jednotlivých chunků</h2>

<pre>
    while True:
        # nacteni hlavicky chunku
        chunk_header = fin.read(8)
        if len(chunk_header) &lt; 8:
            print(f"End of file with remaining {len(chunk_header)} bytes")
            break
        # hlavicka obsahuje delku (4 bajty) a ctyri znaky se jmenem
        s = struct.Struct("!I4s")
        length, png_tag = s.unpack(chunk_header)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
"""Informace o obrázku uloženého ve formátu PNG."""

import struct

PNG_SIGNATURE = b'\x89PNG\r\n\x1a\n'

with open("test.png", "rb") as fin:
    # nacteni signatury
    signature = fin.read(len(PNG_SIGNATURE))

    # kontrola signatury
    assert len(signature) == len(PNG_SIGNATURE)
    assert signature == PNG_SIGNATURE

    # postupne nacteni jednotlivych chunku
    print("Chunk  Length   CRC")
    while True:
        # nacteni hlavicky chunku
        chunk_header = fin.read(8)
        if len(chunk_header) &lt; 8:
            print(f"End of file with remaining {len(chunk_header)} bytes")
            break
        # hlavicka obsahuje delku (4 bajty) a ctyri znaky se jmenem
        s = struct.Struct("!I4s")
        length, png_tag = s.unpack(chunk_header)

        # preskocit data chunku
        fin.seek(length, 1)

        # nacteni CRC32 chunku
        c = struct.Struct("!I")
        crc_block = fin.read(4)
        if len(crc_block) &lt; 4:
            print("Error: not correct CRC block!")
            break
        crc = c.unpack(crc_block)[0]
        print(f"{png_tag.decode("ASCII")}  {length:5}   {crc:04x}")
</pre>

<pre>
"""Informace o obrázku uloženého ve formátu PNG."""

import struct

PNG_SIGNATURE = b"\x89PNG\r\n\x1a\n"

with open("test.png", "rb") as fin:
    # nacteni signatury
    signature = fin.read(len(PNG_SIGNATURE))

    # kontrola signatury
    assert len(signature) == len(PNG_SIGNATURE)
    assert signature == PNG_SIGNATURE

    # postupne nacteni jednotlivych chunku
    print("Chunk  Length   CRC")
    while True:
        # nacteni hlavicky chunku
        chunk_header = fin.read(8)
        if len(chunk_header) &lt; 8:
            print(f"End of file with remaining {len(chunk_header)} bytes")
            break
        # hlavicka obsahuje delku (4 bajty) a ctyri znaky se jmenem
        s = struct.Struct("!I4s")
        length, png_tag = s.unpack(chunk_header)

        if png_tag == b"IHDR":
            # hlavicku nacist celou - ocekava se tento format:
            # Width:              4 bytes
            # Height:             4 bytes
            # Bit depth:          1 byte
            # Color type:         1 byte
            # Compression method: 1 byte
            # Filter method:      1 byte
            # Interlace method:   1 byte
            h = struct.Struct("!2I5B")
            chunk_data = fin.read(length)
            width, height, bit_depth, color_type, compression, filter, interlace = (
                h.unpack(chunk_data)
            )
        else:
            # preskocit data chunku
            fin.seek(length, 1)

        # nacteni CRC32 chunku
        c = struct.Struct("!I")
        crc_block = fin.read(4)
        if len(crc_block) &lt; 4:
            print("Error: not correct CRC block!")
            break
        crc = c.unpack(crc_block)[0]
        print(f"{png_tag.decode("ASCII")}  {length:5}   {crc:04x}")


color_type_desc = [
    "grayscale",
    "unknown",
    "RGB",
    "color palette",
    "grayscale+alpha",
    "RGBA",
]


print(f"Resolution:  {width}x{height}")
print(f"Bit depth:   {bit_depth} bpp")
print(f"Color type:  {color_type} = {color_type_desc[color_type]}")
print(f"Compression: {compression}")
print(f"Filter type: {filter}")
print(f"Interlace:   {interlace}")
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady využívající standardní knihovnu
<i>struct</i> lze nalézt v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th>#<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td> 1</td><td>bytes_type.py</td><td>konstrukce hodnoty typu <strong>bytes</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_type.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_type.py</a></td></tr>
<tr><td> 2</td><td>bytes_literal.py</td><td>literál popisující hodnotu typu <strong>bytes</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_literal.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_literal.py</a></td></tr>
<tr><td> 3</td><td>bytes_literal_no_ascii.py</td><td>literál s&nbsp;neplatnými znaky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_literal_no_ascii.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_literal_no_ascii.py</a></td></tr>
<tr><td> 4</td><td>bytes_hex.py</td><td>převod hodnoty typu <strong>bytes</strong> na řetězec s&nbsp;hexadecimálními hodnotami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_hex.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_hex.py</a></td></tr>
<tr><td> 5</td><td>bytes_fromhex.py</td><td>převod řetězce s&nbsp;hexadecimálními hodnotami na sekvenci bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_fromhex.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_fromhex.py</a></td></tr>
<tr><td> 6</td><td>bytes_fromhex_err.py</td><td>převod řetězce s&nbsp;nezarovnanými hexadecimálními hodnotami na sekvenci bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_fromhex_err.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_fromhex_err.py</a></td></tr>
<tr><td> 7</td><td>bytes_are_immutable.py</td><td>test, zda jsou hodnoty typu <strong>bytes</strong> skutečně neměnitelné</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_are_immutable.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_are_immutable.py</a></td></tr>
<tr><td> 8</td><td>bytes_encode.py</td><td>převod řetězce do zadaného kódování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_encode.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytes_encode.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>bytearray_type.py</td><td>konstrukce hodnoty typu <strong>bytearray</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_type.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_type.py</a></td></tr>
<tr><td>10</td><td>bytearray_is_mutable.py</td><td>test, zda jsou hodnoty typu <strong>bytearray</strong> měnitelné</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_is_mutable.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_is_mutable.py</a></td></tr>
<tr><td>11</td><td>bytearray_hex.py</td><td>převod hodnoty typu <strong>bytearray</strong> na řetězec s&nbsp;hexadecimálními hodnotami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_hex.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_hex.py</a></td></tr>
<tr><td>12</td><td>bytearray_fromhex.py</td><td>převod řetězce s&nbsp;hexadecimálními hodnotami na měnitelné pole bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_fromhex.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_fromhex.py</a></td></tr>
<tr><td>13</td><td>bytearray_encode.py</td><td>převod ASCII řetězce do zadaného kódování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_encode.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_encode.py</a></td></tr>
<tr><td>14</td><td>bytearray_encode_2.py</td><td>převod řetězce s&nbsp;nabodeníčky do zadaného kódování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_encode_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/bytearray_encode_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>string_to_bytes.py</td><td>převod řetězce na sekvenci bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/string_to_bytes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/string_to_bytes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>struct_help.py</td><td>nápověda k&nbsp;balíčku <strong>struct</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/struct_help.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/struct_help.py</a></td></tr>
<tr><td>16</td><td>pack_byte.py</td><td>uložení hodnoty typu <strong>byte</strong> do sekvence bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_byte.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_byte.py</a></td></tr>
<tr><td>17</td><td>pack_byte_negative.py</td><td>pokus o uložení záporné hodnoty jakoby se jednalo o bajt bez znaménka</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_byte_negative.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_byte_negative.py</a></td></tr>
<tr><td>18</td><td>pack_words.py</td><td>uložení celočíselné numerické hodnoty ve formě slova s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_words.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_words.py</a></td></tr>
<tr><td>19</td><td>pack_words_endianess.py</td><td>řízení little/big endian při ukládání slov</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_words_endianess.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_words_endianess.py</a></td></tr>
<tr><td>20</td><td>pack_floats.py</td><td>uložení hodnoty typu <strong>float</strong> do sekvence bajtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_floats.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_floats.py</a></td></tr>
<tr><td>21</td><td>pack_png_header_1.py</td><td>uložení části hlavičky grafického formátu PNG, první verze</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_png_header_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_png_header_1.py</a></td></tr>
<tr><td>22</td><td>pack_png_header_2.py</td><td>uložení části hlavičky grafického formátu PNG, druhá verze</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_png_header_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_png_header_2.py</a></td></tr>
<tr><td>23</td><td>write_png.py</td><td>zápis bufferu s&nbsp;rastrovým obrázkem do formátu PNG</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/write_png.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/write_png.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>unpack_method.py</td><td>základní použití metody <strong>struct.unpack</strong> pro načtení hodnot z&nbsp;binárních dat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_method.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_method.py</a></td></tr>
<tr><td>25</td><td>unpack_byte.py</td><td>načtení jediného bajtu z&nbsp;binárních dat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_byte.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_byte.py</a></td></tr>
<tr><td>26</td><td>unpack_word_1.py</td><td>vliv endianessu na načtenou vícebajtovou hodnotu, první příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_1.py</a></td></tr>
<tr><td>27</td><td>unpack_word_2.py</td><td>vliv endianessu na načtenou vícebajtovou hodnotu, druhý příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_2.py</a></td></tr>
<tr><td>28</td><td>unpack_word_3.py</td><td>vliv endianessu na načtenou vícebajtovou hodnotu, třetí příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/unpack_word_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>pack_alignment_1.py</td><td>zarovnání hodnot v&nbsp;binárních datech, první příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_1.py</a></td></tr>
<tr><td>30</td><td>pack_alignment_2.py</td><td>zarovnání hodnot v&nbsp;binárních datech, druhý příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_2.py</a></td></tr>
<tr><td>31</td><td>pack_alignment_3.py</td><td>zarovnání hodnot v&nbsp;binárních datech, třetí příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_alignment_3.py</a></td></tr>
<tr><td>32</td><td>calcsize.py</td><td>výpočet velikosti binární struktury na základě zadaného formátu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/calcsize.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/calcsize.py</a></td></tr>
<tr><td>33</td><td>pack_padding.py</td><td>výplň struktury bajty přidanými na konec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_padding.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/pack_padding.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>34</td><td>png_info_1.py</td><td>přečtení základních informací ze souborů typu PNG</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_1.py</a></td></tr>
<tr><td>35</td><td>png_info_2.py</td><td>přečtení celé hlavičky souborů typu PNG</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_2.py</a></td></tr>
<tr><td>36</td><td>png_info_3.py</td><td>kontrola CRC jednotlivých chunků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/binary_structs/png_info_3.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python standard types: bytes<br />
<a href="https://docs.python.org/3.8/library/stdtypes.html#bytes">https://docs.python.org/3.8/library/stdtypes.html#bytes</a>
</li>

<li>Python standard types: bytearray<br />
<a href="https://docs.python.org/3.8/library/stdtypes.html#bytearray-objects">https://docs.python.org/3.8/library/stdtypes.html#bytearray-objects</a>
</li>

<li>Bytes and Bytearray Operations<br />
<a href="https://docs.python.org/3.8/library/stdtypes.html#bytes-methods">https://docs.python.org/3.8/library/stdtypes.html#bytes-methods</a>
</li>

<li>Standard encodings<br />
<a href="https://docs.python.org/3.8/library/codecs.html#standard-encodings">https://docs.python.org/3.8/library/codecs.html#standard-encodings</a>
</li>

<li>class memoryview<br />
<a href="https://docs.python.org/3.8/library/stdtypes.html#memoryview">https://docs.python.org/3.8/library/stdtypes.html#memoryview</a>
</li>

<li>struct &ndash; Interpret bytes as packed binary data<br />
<a href="https://docs.python.org/3/library/struct.html">https://docs.python.org/3/library/struct.html</a>
</li>

<li>C-like structures in Python<br />
<a href="https://stackoverflow.com/questions/35988/c-like-structures-in-python">https://stackoverflow.com/questions/35988/c-like-structures-in-python</a>
</li>

<li>python3: bytes vs bytearray, and converting to and from strings<br />
<a href="https://stackoverflow.com/questions/62903377/python3-bytes-vs-bytearray-and-converting-to-and-from-strings">https://stackoverflow.com/questions/62903377/python3-bytes-vs-bytearray-and-converting-to-and-from-strings</a>
</li>

<li>Základní informace o MessagePacku<br />
<a href="https://msgpack.org/">https://msgpack.org/</a>
</li>

<li>Balíček msgpack na PyPi<br />
<a href="https://pypi.org/project/msgpack/">https://pypi.org/project/msgpack/</a>
</li>

<li>MessagePack na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/MessagePack">https://en.wikipedia.org/wiki/MessagePack</a>
</li>

<li>Comparison of data-serialization formats (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a>
</li>

<li>Repositáře msgpacku<br />
<a href="https://github.com/msgpack">https://github.com/msgpack</a>
</li>

<li>Specifikace ukládání různých typů dat<br />
<a href="https://github.com/msgpack/msgpack/blob/master/spec.md">https://github.com/msgpack/msgpack/blob/master/spec.md</a>
</li>

<li>Podpora MessagePacku v&nbsp;různých programovacích jazycích<br />
<a href="https://msgpack.org/#languages">https://msgpack.org/#languages</a>
</li>

<li>Základní implementace formátu msgpack pro programovací jazyk Go<br />
<a href="https://github.com/msgpack/msgpack-go">https://github.com/msgpack/msgpack-go</a>
</li>

<li>go-codec<br />
<a href="https://github.com/ugorji/go">https://github.com/ugorji/go</a>
</li>

<li>Gobs of data (odlišný serializační formát)<br />
<a href="https://blog.golang.org/gobs-of-data">https://blog.golang.org/gobs-of-data</a>
</li>

<li>Formát BSON (odlišný serializační formát)<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Problematika nulových hodnot v Go, aneb proč nil != nil<br />
<a href="https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/">https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/</a>
</li>

<li>IEEE-754 Floating Point Converter<br />
<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a>
</li>

<li>Base Convert: IEEE 754 Floating Point<br />
<a href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a>
</li>

<li>Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

<li>Marshalling (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">https://en.wikipedia.org/wiki/Marshalling_(computer_science)</a>
</li>

<li>Protocol Buffers<br />
<a href="https://protobuf.dev/">https://protobuf.dev/</a>
</li>

<li>Protocol Buffers<br />
<a href="https://en.wikipedia.org/wiki/Protocol_Buffers">https://en.wikipedia.org/wiki/Protocol_Buffers</a>
</li>

<li>What is the difference between Serialization and Marshaling?<br />
<a href="https://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling">https://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling</a>
</li>

<li>Comparison of data-serialization formats<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a>
</li>

<li>PNG (Portable Network Graphics) Specification, Version 1.2<br />
<a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html">http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html</a>
</li>

<li>Data structure alignment<br />
<a href="https://en.wikipedia.org/wiki/Data_structure_alignment">https://en.wikipedia.org/wiki/Data_structure_alignment</a>
</li>

<li>Byte alignment and ordering<br />
<a href="https://www.eventhelix.com/embedded/byte-alignment-and-ordering/">https://www.eventhelix.com/embedded/byte-alignment-and-ordering/</a>
</li>

<li>The Lost Art of Structure Packing<br />
<a href="http://www.catb.org/esr/structure-packing/">http://www.catb.org/esr/structure-packing/</a>
</li>

<li>Padding is hard<br />
<a href="https://dave.cheney.net/2015/10/09/padding-is-hard">https://dave.cheney.net/2015/10/09/padding-is-hard</a>
</li>

<li>Structure Member Alignment, Padding and Data Packing<br />
<a href="https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/">https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/</a>
</li>

<li>C Alignment Cheatsheet<br />
<a href="https://github.com/Q1CHENL/c-alignment-cheatsheet">https://github.com/Q1CHENL/c-alignment-cheatsheet</a>
</li>

<li>Struct padding rules in Rust<br />
<a href="https://stackoverflow.com/questions/70587534/struct-padding-rules-in-rust">https://stackoverflow.com/questions/70587534/struct-padding-rules-in-rust</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

