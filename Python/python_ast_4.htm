<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Překlad modulu do bajtkódu, obsah vygenerovaného binárního souboru</a></p>
<p><a href="#k03">3. Překlad aritmetických výrazů do bajtkódu</a></p>
<p><a href="#k04">4. Zásobníkový efekt (<i>stack effect</i>)</a></p>
<p><a href="#k05">*** 5. Naznačení operací prováděných virtuálním strojem Pythonu zásobníkovým efektem</a></p>
<p><a href="#k06">6. Porovnání s&nbsp;bajtkódem virtuálního stroje jazyka Lua</a></p>
<p><a href="#k07">7. Překlad výrazů s&nbsp;Booleovskými operátory</a></p>
<p><a href="#k08">8. Překlad výrazů s&nbsp;relačními operátory</a></p>
<p><a href="#k09">9. Překlad řídicí struktury typu <strong>if-then</strong></a></p>
<p><a href="#k10">10. Překlad řídicí struktury typu <strong>if-then-else</strong></a></p>
<p><a href="#k11">11. Jednoduchá programová smyčka typu <strong>while</strong></a></p>
<p><a href="#k12">12. Programová smyčka typu <strong>while</strong> se složitějším tělem</a></p>
<p><a href="#k13">*** 13. Dvě vnořené smyčky typu <strong>while</strong> &ndash; výpis řady prvočísel</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">15. Příloha A: základní instrukce pro manipulaci se zásobníkem</a></p>
<p><a href="#k16">16. Příloha B: aritmetické a logické operace</a></p>
<p><a href="#k17">17. Příloha C: podmíněné a nepodmíněné skoky, větvení kódu</a></p>
<p><a href="#k18">*** 18. Příloha D: Tabulka všech operačních kódů instrukcí Python VM</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<pre>
import dis
dis.dis("1+2*3")
  1           0 LOAD_CONST               0 (7)
              2 RETURN_VALUE

def <strong>add</strong>(x,y):
...     return x+y
...
dis.dis(add)
  2           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 BINARY_ADD
              6 RETURN_VALUE

>>> print(dis.code_info(add))
Name:              add
Filename:          <stdin>
Argument count:    2
Positional-only arguments: 0
Kw-only arguments: 0
Number of locals:  2
Stack size:        2
Flags:             OPTIMIZED, NEWLOCALS, NOFREE
Constants:
   0: None
Variable names:
   0: x
   1: y
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Překlad modulu do bajtkódu, obsah vygenerovaného binárního souboru</h2>

<p>Díky existenci modulu <strong>py_compile</strong> je možné si </p>

<pre>
$ <strong>python3 -m py_compile dis_0.py</strong>
</pre>

<p></p>

<p>Po překladu do bajtkódu získáme binární soubor nazvaný
<strong>dis_0.{python_version}.pyc</strong>, jehož obsah si můžeme prohlédnout
libovolným <a
href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">hexa
prohlížečem</a>. Standardním hexa prohlížečem na Linuxu je nástroj
<strong>od</strong> (nenechte se zmást jeho jménem, které klame &ndash; jedná
se <strong>i</strong> o hexa prohlížeč):</p>

<pre>
$ <strong>od -t x1 dis_0.cpython-38.pyc</strong>
&nbsp;
0000000 55 0d 0d 0a 00 00 00 00 ac 9b 00 63 3c 00 00 00
0000020 e3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000040 00 02 00 00 00 40 00 00 00 73 0c 00 00 00 64 00
0000060 64 01 84 00 5a 00 64 02 53 00 29 03 63 02 00 00
0000100 00 00 00 00 00 00 00 00 00 03 00 00 00 02 00 00
0000120 00 43 00 00 00 73 0c 00 00 00 7c 00 7c 01 17 00
0000140 7d 02 7c 02 53 00 29 01 4e a9 00 29 03 da 01 78
0000160 da 01 79 da 06 72 65 73 75 6c 74 72 01 00 00 00
0000200 72 01 00 00 00 fa 08 64 69 73 5f 30 2e 70 79 da
0000220 0b 61 64 64 5f 6e 75 6d 62 65 72 73 01 00 00 00
0000240 73 04 00 00 00 00 01 08 01 72 06 00 00 00 4e 29
0000260 01 72 06 00 00 00 72 01 00 00 00 72 01 00 00 00
0000300 72 01 00 00 00 72 05 00 00 00 da 08 3c 6d 6f 64
0000320 75 6c 65 3e 01 00 00 00 f3 00 00 00 00
0000335
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad aritmetických výrazů do bajtkódu</h2>

<p>Nyní se již pojďme věnovat poněkud praktičtějšímu tématu &ndash; konkrétně
způsobu překladu různých typických programových konstrukcí do bajtkódu
virtuálního stroje jazyka Python. V&nbsp;této kapitole si ukážeme, jak se
konkrétně překládají základní aritmetické výrazy, a to zejména z&nbsp;toho
důvodu, že právě na překladu aritmetických výrazů bude patrný největší rozdíl
mezi virtuálními stroji založenými na zásobníku (Python VM) a operacích
s&nbsp;operandy uloženými na tomto zásobníku na jedné straně a
s&nbsp;virtuálními stroji založenými na sadě registrů na straně druhé (Lua
VM).</p>

<p>Budeme analyzovat bajtkód tohoto programu napsaného v&nbsp;Pythonu:</p>

<pre>
<i>#</i>
<i># Modul s nekolika jednoduchymi funkcemi</i>
<i># pro otestovani zakladnich vlastnosti bajtkodu jazyka Python</i>
<i># prekladu aritmetickych vyrazu.</i>
<i>#</i>
&nbsp; 
def <strong>vyraz1</strong>(x, y):
    result = x + y
    return result
&nbsp;
&nbsp;
def <strong>vyraz2</strong>(x, y):
    result = x - y
    return result
&nbsp;
&nbsp;
def <strong>vyraz3</strong>(x, y):
    result = x * y
    return result
&nbsp;
&nbsp;
def <strong>vyraz4</strong>(x, y):
    result = x / y
    return result
&nbsp;
&nbsp;
def <strong>vyraz5</strong>(x, y):
    result = x % y
    return result
&nbsp;
&nbsp;
def <strong>vyraz6</strong>(x, y, z):
    result = x + y * z
    return result
&nbsp;
&nbsp;
def <strong>vyraz7</strong>(x, y, z, w):
    result = x + y * z + w
    return result
&nbsp;
&nbsp;
def <strong>vyraz8</strong>(x, y, z, w):
    result = 2 * (x + y) * (z + w) * ((x + z) / (y + w))
    return result
&nbsp;
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(vyraz1(4, 3))
    print(vyraz2(4, 3))
    print(vyraz3(4, 3))
    print(vyraz4(4, 3))
    print(vyraz5(4, 3))
    print(vyraz6(4, 3, 2))
    print(vyraz7(4, 3, 2, 1))
    print(vyraz8(4, 3, 2, 1))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nvyraz1:")
    dis(vyraz1)
&nbsp;
    print("\nvyraz2:")
    dis(vyraz2)
&nbsp;
    print("\nvyraz3:")
    dis(vyraz3)
&nbsp;
    print("\nvyraz4:")
    dis(vyraz4)
&nbsp;
    print("\nvyraz5:")
    dis(vyraz5)
&nbsp;
    print("\nvyraz6:")
    dis(vyraz6)
&nbsp;
    print("\nvyraz7:")
    dis(vyraz7)
&nbsp;
    print("\nvyraz8:")
    dis(vyraz8)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>V&nbsp;Pythonu je použit, jak zajisté po přečtení předchozí části tohoto
miniseriálu očekáváte, zásobníkový kód. Pro aritmetické operace se tedy
nejdříve načtou oba operandy na zásobník instrukcí <strong>LOAD_FAST</strong>,
provede se příslušná binární operace <strong>BINARY_?</strong> a následně se
hodnota uloží zpět do lokální proměnné instrukcí
<strong>STORE_FAST</strong>:</p>

<pre>
vyraz1:
  8           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
  9           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz2:
 13           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_SUBTRACT</strong>                          <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 14           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz3:
 18           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 19           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz4:
 23           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_TRUE_DIVIDE</strong>                       <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 24           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz5:
 28           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_MODULO</strong>                            <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 29           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz6:
 33           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 LOAD_FAST                2 (z)           <i>; uložení třetího parametru na zásobník operandů</i>
              6 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
              8 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             10 STORE_FAST               3 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 34          12 LOAD_FAST                3 (result)      <i>; načtení hodnoty lokální proměnné</i>
             14 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz7:
 38           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 LOAD_FAST                2 (z)           <i>; uložení třetího parametru na zásobník operandů</i>
              6 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
              8 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             10 LOAD_FAST                3 (w)           <i>; uložení čtvrtého parametru na zásobník operandů</i>
             12 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             14 STORE_FAST               4 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 39          16 LOAD_FAST                4 (result)      <i>; načtení hodnoty lokální proměnné</i>
             18 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz8:
 43           0 LOAD_CONST               1 (2)           <i>; uložení konstanty na zásobník operandů</i>
              2 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              4 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              6 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
              8 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
             10 LOAD_FAST                2 (z)           <i>; uložení třetího parametru na zásobník operandů</i>
             12 LOAD_FAST                3 (w)           <i>; uložení čtvrtého parametru na zásobník operandů</i>
             14 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             16 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
             18 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
             20 LOAD_FAST                2 (z)           <i>; uložení třetího parametru na zásobník operandů</i>
             22 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             24 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
             26 LOAD_FAST                3 (w)           <i>; uložení čtvrtého parametru na zásobník operandů</i>
             28 <strong>BINARY_ADD</strong>
             30 <strong>BINARY_TRUE_DIVIDE</strong>
             32 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
             34 STORE_FAST               4 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 44          36 LOAD_FAST                4 (result)      <i>; načtení hodnoty lokální proměnné</i>
             38 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zásobníkový efekt (<i>stack effect</i>)</h2>

<p>Už před několika desítkami let programátoři píšící aplikace <a
href="https://www.root.cz/serialy/programovaci-jazyk-forth/">v&nbsp;programovacím
jazyku Forth</a> používali pro popis vlivu slov (příkazů) na položky uložené na
zásobníku takzvaný zásobníkový efekt (<i>stack effect</i>). Pro další čtení je
užitečné si čtení zásobníkového efektu osvojit.</p>

<p>Nejedná se v&nbsp;podstatě o nic složitého: uvnitř kulatých závorek, které
ve Forthu ale i Factoru značí začátek a konec poznámky se zásobníkovým efektem,
je symbolicky zapsán stav části zásobníku před provedením operace a po dvojici
znaků &bdquo;&ndash;&ldquo; stav zásobníku po provedení dané operace. Vzhledem
k&nbsp;tomu, že na zásobníku může být uloženo teoreticky libovolné množství
hodnot a daná operace většinou ovlivňuje pouze hodnoty umístěné blízko jeho
vrcholu, je zásobníkový efekt zapsán pouze pro ty pozice na zásobníku, které
jsou operací nějakým způsobem dotčeny, tj.&nbsp;operace tyto hodnoty přečte,
zruší či modifikuje. Položky umístěné níže nemá cenu zapisovat, jen by zápis
zbytečně komplikovaly. Položka umístěná nejvíce vlevo je ve skutečnosti uložena
na spodnějších místech zásobníku, než položky napravo od ní.</p>

<p>Následuje jednoduchý příklad zápisu zásobníkového efektu pro operaci součtu
dvou čísel. Nejprve je zapsán název operace, v&nbsp;tomto případě nazvané plus.
Poté je zapsána otevírací kulatá závorka značící začátek poznámky, za níž
následuje stav nejvyšších položek zásobníku před provedením operace (tedy těch
položek, které jsou operací dotčeny &ndash; ale můžeme jich zapsat i více). Po
oddělovači představovaném dvojicí znaků &bdquo;&ndash;&ldquo; je uveden stav
nejvyšších položek po provedení operace, za nímž následuje uzavírací kulatá
závorka značící konec poznámky (ve skutečnosti jsou i kulaté závorky běžnými
slovy jazyka a proto musí být od okolních slov odděleny alespoň jednou
mezerou).</p>

<p>Vzhledem k&nbsp;tomu, že operace sčítání načte dvě hodnoty ze zásobníku a
zpět vloží jejich součet, jsou použity odlišné symboly <strong>x</strong>,
<strong>y</strong> a <strong>z</strong>, přičemž samozřejmě platí, že
z=x+y:</p>

<pre>
# "hlavička" operátoru plus
plus ( x y -- z ) 
</pre>

<p>Pokud by nějaká operace například prohazovala hodnoty uložené na zásobníku,
ale jinak by je žádným způsobem neměnila, byly by použity stejné symboly, což
je případ operátoru swap či rot (což mohou být i instrukce bajtkódu):</p>

<pre>
# "hlavička" operátorů swap a rot
swap ( x y -- y x )
rot  ( x y z -- y z x ) 
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Naznačení operací prováděných virtuálním strojem Pythonu zásobníkovým efektem</h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. Porovnání s&nbsp;bajtkódem virtuálního stroje jazyka Lua</h2>

<p>Pro zajímavost se podívejme, jak bude podobný zdrojový kód přeložen
v&nbsp;jazyku Lua, jehož bajtkód není založen na zásobníkovém stroji, ale na
stroji registrovém:</p>

<pre>
<i>--</i>
<i>-- Modul s nekolika jednoduchymi funkcemi</i>
<i>-- pro otestovani zakladnich vlastnosti bajtkodu jazyka Lua</i>
<i>-- prekladu aritmetickych vyrazu.</i>
<i>--</i>
&nbsp;
function <strong>vyraz1</strong>(x, y)
    local result = x + y
    return result
end
&nbsp;
function <strong>vyraz2</strong>(x, y)
    local result = x - y
    return result
end
&nbsp;
function <strong>vyraz3</strong>(x, y)
    local result = x * y
    return result
end
&nbsp;
function <strong>vyraz4</strong>(x, y)
    local result = x / y
    return result
end
&nbsp;
function <strong>vyraz5</strong>(x, y)
    local result = x % y
    return result
end
&nbsp;
function <strong>vyraz6</strong>(x, y, z)
    local result = x + y * z
    return result
end
&nbsp;
function <strong>vyraz7</strong>(x, y, z, w)
    local result = x + y * z + w
    return result
end
&nbsp;
function <strong>vyraz8</strong>(x, y, z, w)
    local result = 2 * (x + y) * (z + w) * ((x + z) / (y + w))
    return result
end
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
function <strong>main</strong>()
    print(vyraz1(4, 3))
    print(vyraz2(4, 3))
    print(vyraz3(4, 3))
    print(vyraz4(4, 3))
    print(vyraz5(4, 3))
    print(vyraz6(4, 3, 2))
    print(vyraz7(4, 3, 2, 1))
    print(vyraz8(4, 3, 2, 1))
end
&nbsp;
main()
</pre>

<p>Ve virtuálním stroji jazyka Lua je použit kód využívající
&bdquo;registry&ldquo; virtuálního stroje a proto je počet instrukcí menší, než
u kódu zásobníkového. Za tuto efektivitu platíme omezeným počtem registrů (což
v&nbsp;praxi nemusí vadit):</p>

<pre>
function &lt;Test2.lua:7,10&gt; (3 instructions at 0x9e07c88)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [8]     ADD             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [9]     RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [10]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:12,15&gt; (3 instructions at 0x9e07f20)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [13]    SUB             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [14]    RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [15]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:17,20&gt; (3 instructions at 0x9e080f0)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [18]    MUL             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [19]    RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [20]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:22,25&gt; (3 instructions at 0x9e07ec8)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [23]    DIV             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [24]    RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [25]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:27,30&gt; (3 instructions at 0x9e084f8)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [28]    MOD             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [29]    RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [30]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:32,35&gt; (4 instructions at 0x9e07e18)
3 params, 4 slots, 0 upvalues, 4 locals, 0 constants, 0 functions
        1       [33]    MUL             3 1 2  <i>; provést aritmetickou operaci s parametrem 1 a 2</i>
        2       [33]    ADD             3 0 3  <i>; provést aritmetickou operaci s parametrem 0 a lokální proměnnou 3</i>
        3       [34]    RETURN          3 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 3</i>
        4       [35]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:37,40&gt; (5 instructions at 0x9e08458)
4 params, 5 slots, 0 upvalues, 5 locals, 0 constants, 0 functions
        1       [38]    MUL             4 1 2  <i>; provést aritmetickou operaci s parametrem 1 a 2</i>
        2       [38]    ADD             4 0 4  <i>; provést další aritmetickou operaci s parametrem 0 a lokální proměnnou 4</i>
        3       [38]    ADD             4 4 3  <i>; provést další aritmetickou operaci s parametrem 3 a lokální proměnnou 4</i>
        4       [39]    RETURN          4 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 4</i>
        5       [40]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:42,45&gt; (10 instructions at 0x9e08720)
4 params, 7 slots, 0 upvalues, 5 locals, 1 constant, 0 functions
        1       [43]    ADD             4 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [43]    MUL             4 -1 4  ; 2 - <i>; zde se adresuje konstanta -2 !!!</i>
        3       [43]    ADD             5 2 3  <i>; provést další aritmetickou operaci, výsledek do lok. proměnné 5</i>
        4       [43]    MUL             4 4 5
        5       [43]    ADD             5 0 2
        6       [43]    ADD             6 1 3
        7       [43]    DIV             5 5 6
        8       [43]    MUL             4 4 5
        9       [44]    RETURN          4 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 4</i>
        10      [45]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad výrazů s&nbsp;Booleovskými operátory</h2>

<p>Booleovské (logické) výrazy se v&nbsp;bajtkódu programovacího jazyka Python
většinou překládají s&nbsp;využitím podmíněného skoku. Před samotnou instrukcí
skoku se vyhodnotí podmínka, v&nbsp;našem případě první část logického výrazu,
a na základě této podmínky se zjistí hodnota druhé části logického výrazu
(pokud se samozřejmě jedná o operace se dvěma operandy). Podívejme se nyní na
způsob překladu výrazů obsahujících negaci, logický součet, logický součin,
operaci nonekvivalence a různé kombinace těchto operací:</p>

<pre>
<i>#</i>
<i># Modul s nekolika jednoduchymi funkcemi</i>
<i># pro otestovani zakladnich vlastnosti bajtkodu jazyka Python</i>
<i># prekladu Booleovskych vyrazu.</i>
<i>#</i>
&nbsp;
def <strong>vyraz1</strong>(x):
    result = not x
    return result
&nbsp;
def <strong>vyraz2</strong>(x, y):
    result = x and y
    return result
&nbsp;
def <strong>vyraz3</strong>(x, y):
    result = x or y
    return result
&nbsp;
def <strong>vyraz4</strong>(x, y):
    result = x ^ y
    return result
&nbsp;
def <strong>vyraz5</strong>(x, y, z):
    result = x or y and z
    return result
&nbsp;
def <strong>vyraz6</strong>(x, y, z, w):
    result = (x or y) and (z or w)
    return result
&nbsp;
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(vyraz1(True))
    print(vyraz2(True, False))
    print(vyraz3(True, False))
    print(vyraz4(True, False))
    print(vyraz5(True, False, True))
    print(vyraz6(True, False, True, False))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nvyraz1:")
    dis(vyraz1)
&nbsp;
    print("\nvyraz2:")
    dis(vyraz2)
&nbsp;
    print("\nvyraz3:")
    dis(vyraz3)
&nbsp;
    print("\nvyraz4:")
    dis(vyraz4)
&nbsp;
    print("\nvyraz5:")
    dis(vyraz5)
&nbsp;
    print("\nvyraz6:")
    dis(vyraz6)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Povšimněte si, že se kromě první funkce (negace) skutečně používají
podmíněné skoky, tj.&nbsp;instrukce <strong>JUMP_IF_?</strong>, s&nbsp;nimiž se
ostatně setkáme i v&nbsp;navazujícím textu:</p>

<pre>
vyraz1:
  8           0 LOAD_FAST                0 (x)
              2 <strong>UNARY_NOT</strong>
              4 STORE_FAST               1 (result)
&nbsp;
  9           6 LOAD_FAST                1 (result)
              8 RETURN_VALUE
&nbsp;
vyraz2:
 12           0 LOAD_FAST                0 (x)
              2 <strong>JUMP_IF_FALSE_OR_POP</strong>     6
              4 LOAD_FAST                1 (y)
        &gt;&gt;    6 STORE_FAST               2 (result)
&nbsp;
 13           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz3:
 16           0 LOAD_FAST                0 (x)
              2 <strong>JUMP_IF_TRUE_OR_POP</strong>      6
              4 LOAD_FAST                1 (y)
        &gt;&gt;    6 STORE_FAST               2 (result)
&nbsp;
 17           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz4:
 20           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>BINARY_XOR</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 21           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz5:
 24           0 LOAD_FAST                0 (x)
              2 <strong>JUMP_IF_TRUE_OR_POP</strong>     10
              4 LOAD_FAST                1 (y)
              6 <strong>JUMP_IF_FALSE_OR_POP</strong>    10
              8 LOAD_FAST                2 (z)
        &gt;&gt;   10 STORE_FAST               3 (result)

 25          12 LOAD_FAST                3 (result)
             14 RETURN_VALUE
&nbsp;
vyraz6:
 28           0 LOAD_FAST                0 (x)
              2 <strong>POP_JUMP_IF_TRUE</strong>         8
              4 LOAD_FAST                1 (y)
              6 <strong>JUMP_IF_FALSE_OR_POP</strong>    14
        &gt;&gt;    8 LOAD_FAST                2 (z)
             10 <strong>JUMP_IF_TRUE_OR_POP</strong>     14
             12 LOAD_FAST                3 (w)
        &gt;&gt;   14 STORE_FAST               4 (result)
&nbsp;
 29          16 LOAD_FAST                4 (result)
             18 RETURN_VALUE
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Překlad výrazů s&nbsp;relačními operátory</h2>

<p>Výrazy s&nbsp;relačními operátory se překládají do značné míry stejným
způsobem, jako aritmetické výrazy (jen se používají odlišné binární instrukce),
o čemž se ostatně přesvědčíme po pohledu na bajtkód vygenerovaný pro
následující skript:</p>

<pre>
<i>#</i>
<i># Modul s nekolika jednoduchymi funkcemi</i>
<i># pro otestovani zakladnich vlastnosti bajtkodu jazyka Python</i>
<i># prekladu relacnich vyrazu.</i>
<i>#</i>
&nbsp;
def <strong>vyraz1</strong>(x, y):
    result = x &lt;= y
    return result
&nbsp;
def <strong>vyraz2</strong>(x, y):
    result = x &lt; y
    return result
&nbsp;
def <strong>vyraz3</strong>(x, y):
    result = x == y
    return result
&nbsp;
def <strong>vyraz4</strong>(x, y):
    result = x != y
    return result
&nbsp;
def <strong>vyraz5</strong>(x, y):
    result = x &gt;= y
    return result
&nbsp;
def <strong>vyraz6</strong>(x, y):
    result = x &gt; y
    return result
&nbsp;
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(vyraz1(1, 2))
    print(vyraz2(1, 2))
    print(vyraz3(1, 2))
    print(vyraz4(1, 2))
    print(vyraz5(1, 2))
    print(vyraz6(1, 2))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nvyraz1:")
    dis(vyraz1)
&nbsp;
    print("\nvyraz2:")
    dis(vyraz2)
&nbsp;
    print("\nvyraz3:")
    dis(vyraz3)
&nbsp;
    print("\nvyraz4:")
    dis(vyraz4)
&nbsp;
    print("\nvyraz5:")
    dis(vyraz5)
&nbsp;
    print("\nvyraz6:")
    dis(vyraz6)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Z&nbsp;bajtkódu je patrné, že se používá &bdquo;univerzální&ldquo; instrukce
<strong>COMPARE_OP</strong>, jejímž celočíselným parametrem je číslo (index)
prováděné operace:</p>

<pre>
vyraz1:
  8           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               1 (&lt;=)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
  9           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz2:
 12           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               0 (&lt;)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 13           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz3:
 16           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               2 (==)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 17           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz4:
 20           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               3 (!=)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 21           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz5:
 24           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               5 (&gt;=)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 25           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz6:
 28           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               4 (&gt;)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 29           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Překlad řídicí struktury typu <strong>if-then</strong></h2>

<p>Nyní se již konečně dostáváme k&nbsp;mnohem zajímavějšímu tématu &ndash;
konkrétně k&nbsp;podmíněným skokům, kterými jsou realizovány strukturované
příkazy (rozeskoky) typu <strong>if-then</strong> a samozřejmě i úplné
rozhodovací konstrukce typu <strong>if-then-else</strong>. Jedná se o tak časté
programové konstrukce, že pro ně byly v&nbsp;bajtkódu vyhrazeny speciální
operace. Nejprve se podívejme na zdrojový kód dvou funkcí, jejichž bajtkód
budeme zkoumat:</p>

<pre>
def <strong>prikaz1</strong>(x):
    if x:
        return 10
    return 20
&nbsp;
def <strong>prikaz2</strong>(x, y):
    if x:
        if y:
            return 10
    return 20
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(prikaz1(True))
    print(prikaz1(False))
    print(prikaz2(True, True))
    print(prikaz2(True, False))
    print(prikaz2(False, True))
    print(prikaz2(False, False))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nprikaz1:")
    dis(prikaz1)
&nbsp;
    print("\nprikaz2:")
    dis(prikaz2)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Nejzajímavější částí bajtkódu jsou v&nbsp;tomto případě instrukce
<strong>POP_JUMP_IF_FALSE</strong>
(resp.&nbsp;<strong>POP_JUMP_IF_TRUE</strong>), které načtou hodnotu a pokud je
rovna False (tedy vlastně 0), provede se podmíněný skok na konec
rozvětvení:</p>

<pre>
prikaz1:
  8           0 LOAD_FAST                0 (x)
              2 <strong>POP_JUMP_IF_FALSE</strong>        8
&nbsp;
  9           4 LOAD_CONST               1 (10)
              6 RETURN_VALUE
&nbsp;
 10     &gt;&gt;    8 LOAD_CONST               2 (20)
             10 RETURN_VALUE
&nbsp;
prikaz2:
 13           0 LOAD_FAST                0 (x)
              2 <strong>POP_JUMP_IF_FALSE</strong>       12
&nbsp;
 14           4 LOAD_FAST                1 (y)
              6 <strong>POP_JUMP_IF_FALSE</strong>       12
&nbsp;
 15           8 LOAD_CONST               1 (10)
             10 RETURN_VALUE
&nbsp;
 16     &gt;&gt;   12 LOAD_CONST               2 (20)
             14 RETURN_VALUE
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Překlad řídicí struktury typu <strong>if-then-else</strong></h2>

<p>Úplná programová konstrukce <strong>if-then-else</strong> vznikne
z&nbsp;neúplné konstrukce typu <strong>if-then</strong> doplněním programové
větve <strong>else</strong>, což je samozřejmě podporováno i bajtkódem
virtuálního stroje Pythonu &ndash; musí se jednat o úplné rozvětvení a tedy
typicky o kombinaci podmíněného skoku se skokem nepodmíněným:</p>

<pre>
def <strong>prikaz1</strong>(x):
    if x:
        return 10
    else:
        return 20
&nbsp;
def <strong>prikaz2</strong>(x, y):
    if x:
        if y:
            return 10
        else:
            return 20
    else:
        return 30
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(prikaz1(True))
    print(prikaz1(False))
    print(prikaz2(True, True))
    print(prikaz2(True, False))
    print(prikaz2(False, True))
    print(prikaz2(False, False))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nprikaz1:")
    dis(prikaz1)
&nbsp;
    print("\nprikaz2:")
    dis(prikaz2)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>V&nbsp;bajtkódu nyní uvidíme dvě možnosti. První variantou je plný rozeskok,
přičemž každá větev končí instrukcí <strong>RETURN_VALUE</strong>:</p>

<pre>
prikaz1:
  8           0 LOAD_FAST                0 (x)
              2 POP_JUMP_IF_FALSE        8
&nbsp;
  9           4 LOAD_CONST               1 (10)
              6 RETURN_VALUE
&nbsp;
 11     &gt;&gt;    8 LOAD_CONST               2 (20)
             10 RETURN_VALUE
             12 LOAD_CONST               0 (None)
             14 RETURN_VALUE
</pre>

<p>Druhá varianta spočívá ve využití již výše zmíněné kombinace podmíněného a
nepodmíněného skoku, tedy zde konkrétně instrukcí
<strong>POP_JUMP_IF_FALSE</strong> a <strong>JUMP_FORWARD</strong>:</p>

<pre>
prikaz2:
 14           0 LOAD_FAST                0 (x)
              2 <strong>POP_JUMP_IF_FALSE</strong>       18
&nbsp;
 15           4 LOAD_FAST                1 (y)
              6 <strong>POP_JUMP_IF_FALSE</strong>       12
&nbsp;
 16           8 LOAD_CONST               1 (10)
             10 RETURN_VALUE
&nbsp;
 18     &gt;&gt;   12 LOAD_CONST               2 (20)
             14 RETURN_VALUE
             16 <strong>JUMP_FORWARD</strong>             4 (to 22)
&nbsp;
 20     &gt;&gt;   18 LOAD_CONST               3 (30)
             20 RETURN_VALUE
        &gt;&gt;   22 LOAD_CONST               0 (None)
             24 RETURN_VALUE
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Jednoduchá programová smyčka typu <strong>while</strong></h2>

<p>Základním a ve skutečnosti i univerzálním typem smyčky je ve strukturovaném
programování smyčka typu <strong>while</strong>. U tohoto typu smyčky se
podmínka pro ukončení smyčky kontroluje vždy na začátku každé iterace, což
mj.&nbsp;znamená, že se tělo smyčky nemusí provést ani jednou, a to
v&nbsp;případě, kdy podmínka není splněna již před provedením první iterace,
tj.&nbsp;před vstupem do smyčky. Z&nbsp;tohoto důvodu se konstrukce
<strong>while</strong> používá například v&nbsp;situacích, kdy se mají
zpracovávat vstupní data (čtená ze souboru, z&nbsp;databázové tabulky atd.), u
nichž není zřejmé, kolik údajů se bude načítat a zda se vůbec nějaký údaj na
vstupu bude nacházet. Zajímavé je, že ostatní typy smyček lze většinou přepsat
právě na programovou smyčku typu <strong>while</strong>, i když &ndash; jak
uvidíme na příkladu <i>Pythonu</i> &ndash; se nemusí vždy jednat o elegantní
řešení. Pojďme si tedy na velmi jednoduchých příkladech ukázat způsob překladu
této programové smyčky do bajtkódu virtuálního stroje Pythonu. Nejprve si
ukážeme překlad smyčky, v&nbsp;níž se pouze snižuje hodnota počitadla
kontrolovaného v&nbsp;podmínce pro další iteraci.</p>

<pre>
def <strong>loop</strong>(x):
    while x &gt; 0:
        x = x - 1
    return x
&nbsp;
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(loop(10))
&nbsp;
<i>#</i>
<i># Vypsani bajkkodu testovane funkce</i>
<i>#</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nloop:")
    dis(loop)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Bajtkód vytvořený pro virtuální stroj Pythonu je kupodivu poměrně dlouhý
(což prakticky znamená i pomalejší vyhodnocení v&nbsp;porovnání s&nbsp;Luou).
Můžeme zde vidět jak nepodmíněný skok <strong>JUMP_ABSOLUTE</strong>, tak i
podmíněný skok <strong>JUMP_IF_FALSE</strong>, pro nějž se podmínka vyhodnocuje
instrukcí <strong>COMPARE_OP</strong> (již známe). Povšimněte si taktéž
nutnosti použití instrukce <strong>POP_TOP</strong> sloužící pro
&bdquo;uklizení&ldquo; obsahu zásobníku operandů:</p>

<pre>
loop:
  8     &gt;&gt;    0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (0)
              4 <strong>COMPARE_OP</strong>               4 (&gt;)
              6 <strong>POP_JUMP_IF_FALSE</strong>       18
&nbsp;
  9           8 LOAD_FAST                0 (x)
             10 LOAD_CONST               2 (1)
             12 BINARY_SUBTRACT
             14 STORE_FAST               0 (x)
             16 <strong>JUMP_ABSOLUTE</strong>            0
&nbsp;
 10     &gt;&gt;   18 LOAD_FAST                0 (x)
             20 RETURN_VALUE
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Programová smyčka typu <strong>while</strong> se složitějším tělem</h2>

<p>Pro zajímavost se ještě podívejme na poněkud složitější demonstrační
příklady, v&nbsp;nichž je opět použita programová smyčka typu
<strong>while</strong>. Tyto příklady slouží k&nbsp;výpočtu exponenciální
funkce <i>2<sup>x</sup></i>, popř.&nbsp;<i>y2<sup>x</sup></i> (což je
v&nbsp;Pythonu vlastně zbytečné protože pro tuto operaci máme k&nbsp;dispozici
operátor **). Vzhledem k&nbsp;tomu, že hodnoty <i>x</i> a <i>y</i> nejsou
dopředu známé, nemůže překladač provádět prakticky žádné optimalizace smyčky
(to mohl teoreticky udělat v&nbsp;předchozím příkladu, což se však, jak již
víme, ve skutečnosti nestalo, alespoň nikoli na úrovni bajtkódu).</p>

<pre>
def <strong>loop</strong>(x, y):
    while x &gt; 0:
        x = x - 1
        y = y * 2
    return y
&nbsp;
&nbsp; 
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(loop(10, 1))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nloop:")
    dis(loop)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Opět můžeme vidět, že se test na ukončení smyčky provádí v&nbsp;úvodní části
kódu (porovnání+podmíněný skok), zatímco na konci smyčky je použit nepodmíněný
skok na začátek:</p>

<pre>
loop:
  8     &gt;&gt;    0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (0)
              4 <strong>COMPARE_OP</strong>               4 (&gt;)
              6 <strong>POP_JUMP_IF_FALSE</strong>       26
&nbsp;
  9           8 LOAD_FAST                0 (x)
             10 LOAD_CONST               2 (1)
             12 BINARY_SUBTRACT
             14 STORE_FAST               0 (x)
&nbsp;
 10          16 LOAD_FAST                1 (y)
             18 LOAD_CONST               3 (2)
             20 BINARY_MULTIPLY
             22 STORE_FAST               1 (y)
             24 <strong>JUMP_ABSOLUTE</strong>            0
&nbsp;
 11     &gt;&gt;   26 LOAD_FAST                1 (y)
             28 RETURN_VALUE
</pre>

<p><div class="rs-tip-major">Poznámka: překlad do bajtkódu je v&nbsp;případě
Pythonu poměrně přímočará mechanická záležitost; žádné složitější optimalizace
zde nejsou patrné.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Dvě vnořené smyčky typu <strong>while</strong> &ndash; výpis řady prvočísel</h2>

<p>Nastává čas ukázat si způsob překladu algoritmu, v&nbsp;němž se používají
dvě vnořené programové smyčky typu <strong>while</strong>. Zde je již situace
zajímavější, protože delší zdrojový kód dává překladači alespoň teoretickou
možnost provedení různých optimalizací. Jako příklad jsem vybral výpočet řady
prvočísel od 2 do zadané maximální hodnoty, přičemž se pro výpočet používá ta
nejjednodušší a současně i nejpomalejší :-) metoda založená na postupném
zjišťování, zda je zadaná hodnota <i>n</i> dělitelná nějakým celým číslem
v&nbsp;rozsahu <i>2..n-1</i> (teoreticky je možné smyčku ukončit dříve, ovšem
nechtěl jsem zbytečně do demonstračního algoritmu přidávat volání funkcí).</p>

<p>V&nbsp;Pythonu je možné tento algoritmus zapsat následujícím způsobem:</p>

<pre>
def <strong>primeNumbers</strong>(min, max):
    i = min
    while i &lt;= max:        <i># projit vsechny hodnoty od min do max</i>
        j = 2
        while j &lt; i:       <i># (lze optimalizovat a zkratit smycku!)</i>
            if i % j == 0: <i># je mozne celociselne delit?</i>
                break      <i># - pak ovsem nejde o prvocislo</i>
            j = j + 1      <i># vyzkouset dalsiho kandidata na celociselne deleni</i>
        if j == i:         <i># pokud jsme dosli az k cislu i</i>
            print(i)       <i># nedoslo nikdy k celociselnemu deleni</i>
        i = i + 1          <i># dalsi hodnota v posloupnosti</i>
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    primeNumbers(2, 1000)
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nprimeNumbers:")
    dis(primeNumbers)
&nbsp;
main()
&nbsp; 
disassemble()
</pre>

<p></p>

<pre>
primeNumbers:
  9           0 LOAD_FAST                0 (min)
              2 STORE_FAST               2 (i)
&nbsp;
 10     &gt;&gt;    4 LOAD_FAST                2 (i)
              6 LOAD_FAST                1 (max)
              8 COMPARE_OP               1 (&lt;=)
             10 POP_JUMP_IF_FALSE       74
&nbsp;
 11          12 LOAD_CONST               1 (2)
             14 STORE_FAST               3 (j)
&nbsp;
 12     &gt;&gt;   16 LOAD_FAST                3 (j)
             18 LOAD_FAST                2 (i)
             20 COMPARE_OP               0 (&lt;)
             22 POP_JUMP_IF_FALSE       48
&nbsp;
 13          24 LOAD_FAST                2 (i)
             26 LOAD_FAST                3 (j)
             28 BINARY_MODULO
             30 LOAD_CONST               2 (0)
             32 COMPARE_OP               2 (==)
             34 POP_JUMP_IF_FALSE       38
&nbsp;
 14          36 JUMP_ABSOLUTE           48
&nbsp;
 15     &gt;&gt;   38 LOAD_FAST                3 (j)
             40 LOAD_CONST               3 (1)
             42 BINARY_ADD
             44 STORE_FAST               3 (j)
             46 JUMP_ABSOLUTE           16
&nbsp;
 16     &gt;&gt;   48 LOAD_FAST                3 (j)
             50 LOAD_FAST                2 (i)
             52 COMPARE_OP               2 (==)
             54 POP_JUMP_IF_FALSE       64
&nbsp;
 17          56 LOAD_GLOBAL              0 (print)
             58 LOAD_FAST                2 (i)
             60 CALL_FUNCTION            1
             62 POP_TOP
&nbsp;
 18     &gt;&gt;   64 LOAD_FAST                2 (i)
             66 LOAD_CONST               3 (1)
             68 BINARY_ADD
             70 STORE_FAST               2 (i)
             72 JUMP_ABSOLUTE            4
        &gt;&gt;   74 LOAD_CONST               0 (None)
             76 RETURN_VALUE
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
def loop(x):
    while True:
        x = x - 1
        if x <= 0: break
    return x
 
#
# Vse je nutne otestovat.
#
def main():
    print(loop(10))
 
#
# Vypsani bajkkodu testovane funkce
#
def disassemble():
    from dis import dis
 
    print("\nloop:")
    dis(loop)
 
main()
 
disassemble()
</pre>

<pre>
loop:
 10     >>    0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (1)
              4 BINARY_SUBTRACT
              6 STORE_FAST               0 (x)

 11           8 LOAD_FAST                0 (x)
             10 LOAD_CONST               2 (0)
             12 COMPARE_OP               1 (<=)
             14 POP_JUMP_IF_FALSE        0
             16 JUMP_ABSOLUTE           20
             18 JUMP_ABSOLUTE            0

 12     >>   20 LOAD_FAST                0 (x)
             22 RETURN_VALUE
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Příloha A: základní instrukce pro manipulaci se zásobníkem</h2>

<p>Před provedením aritmetických, logických i bitových instrukcí jakož i před
zavoláním jiné funkce popř.&nbsp;metody je mnohdy nutné data vložit do vhodných
registrů a/nebo na správné místo v&nbsp;zásobníku operandů. K&nbsp;tomu slouží
instrukce popsané v&nbsp;této příloze.</p>

<p>Python VM je zásobníkový virtuální stroj, proto jeho instrukční sada
obsahuje několik instrukcí, které se nápadně podobají <i>slovům</i> používaným
v&nbsp;programovacím jazyku <i>Forth</i> (ono se ostatně není čemu divit,
protože se jedná skutečně o základní &bdquo;zásobníkové&ldquo; instrukce).
Důležité je, že tyto instrukce již nepotřebují být rozděleny podle toho
s&nbsp;jakými daty pracují, protože každému prvku uloženém na <i>zásobníku
operandů</i> je stejně přiřazen datový <i>tag</i>, který je těmito instrukcemi
využíván:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>POP_TOP</td><td>implicitní</td><td>implicitní</td><td>odstraní jednu položku z&nbsp;vrcholu zásobníku operandů</td></tr>
<tr><td>2</td><td>ROT_TWO</td><td>implicitní</td><td>implicitní</td><td>rotace (<i>swap</i>) dvou položek</td></tr>
<tr><td>3</td><td>ROT_THREE</td><td>implicitní</td><td>implicitní</td><td>rotace (<i>roll</i>) tří položek</td></tr>
<tr><td>4</td><td>ROT_FOUR </td><td>implicitní</td><td>implicitní</td><td>rotace čtyř položek</td></tr>
<tr><td>5</td><td>DUP_TOP</td><td>implicitní</td><td>implicitní</td><td>duplikace položky na zásobníku operandů</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Příloha B: aritmetické a logické operace</h2>

<p>Začněme popisem aritmetických instrukcí, které jsou velmi jednoduché a
snadno pochopitelné.</p>

<p>Aritmetické instrukce pracují s&nbsp;hodnotami umístěnými na zásobníku
operandů, podobně jako je tomu například i v&nbsp;JVM. Všechny instrukce navíc
mohou pracovat i pro různé typy objektů (to odpovídá přetížení příslušných
operandů):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>BINARY_ADD</td><td>číslo/objekt</td><td>číslo/objekt</td><td>součet</td></tr>
<tr><td>2</td><td>BINARY_SUBTRACT</td><td>číslo/objekt</td><td>číslo/objekt</td><td>rozdíl</td></tr>
<tr><td>3</td><td>BINARY_MULTIPLY</td><td>číslo/objekt</td><td>číslo/objekt</td><td>součin</td></tr>
<tr><td>4</td><td>BINARY_DIVIDE</td><td>číslo/objekt</td><td>číslo/objekt</td><td>podíl</td></tr>
<tr><td>5</td><td>BINARY_MODULO</td><td>číslo/objekt</td><td>číslo/objekt</td><td>podíl modulo</td></tr>
<tr><td>6</td><td>BINARY_POWER</td><td>číslo/objekt</td><td>číslo/objekt</td><td>umocnění</td></tr>
<tr><td>7</td><td>UNARY_NEGATIVE</td><td>číslo/objekt</td><td>&times;</td><td>změna znaménka</td></tr>
</table>

<p>Druhou skupinou instrukcí jsou instrukce, pomocí nichž se implementují téměř
všechny základní bitové a logické operace.</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>BINARY_AND</td><td>číslo/objekt</td><td>číslo/objekt</td><td>bitový/logický součin</td></tr>
<tr><td>2</td><td>BINARY_OR </td><td>číslo/objekt</td><td>číslo/objekt</td><td>bitový/logický součet</td></tr>
<tr><td>3</td><td>BINARY_XOR</td><td>číslo/objekt</td><td>číslo/objekt</td><td>bitová/logická nonekvivalence</td></tr>
<tr><td>7</td><td>UNARY_NOT</td><td>číslo/objekt</td><td>&times;</td><td>negace</td></tr>
</table>

<p>V&nbsp;Python VM nalezneme i následující instrukce pro posuny (pro
celočíselné operandy se jedná o aritmetický posun doleva a doprava):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>BINARY_LSHIFT</td><td>číslo/objekt</td><td>číslo/objekt</td><td>posun doleva</td></tr>
<tr><td>2</td><td>BINARY_RSHIFT</td><td>číslo/objekt</td><td>číslo/objekt</td><td>posun doprava</td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příloha C: podmíněné a nepodmíněné skoky, větvení kódu</h2>

<p>Ve virtuálním stroji programovacího jazyka Python nalezneme celkem šest
základních instrukcí skoku &ndash; konkrétně dvě instrukce určené pro provedení
nepodmíněných skoků a tři instrukce pro provedení skoků podmíněných:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operand 1</th><th>Operand 2</th><th>Prováděná operace</th></tr>
<tr><td>1</td><td>JUMP_ABSOLUTE</td><td>index instrukce, na kterou skok vede</td><td>&times;</td><td>skok na zadaný index (lokální adresu)</td></tr>
<tr><td>2</td><td>JUMP_FORWARD</td><td>index instrukce, na kterou skok vede</td><td>&times;</td><td>skok na relativní index (je zadána delta oproti současné adrese)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>POP_JUMP_IF_TRUE</td><td>index instrukce, na kterou skok vede</td><td>&times;</td><td>podmíněný skok na základě obsahu TOS; obsah TOS je odstraněn</td></tr>
<tr><td>4</td><td>POP_JUMP_IF_FALSE</td><td>index instrukce, na kterou skok vede</td><td>&times;</td><td>podmíněný skok na základě obsahu TOS (opačná podmínka); obsah TOS je odstraněn</td></tr>
<tr><td>5</td><td>JUMP_IF_TRUE_OR_POP</td><td>index instrukce, na kterou skok vede</td><td>&times;</td><td>pokud TOS==true, provede se skok, v opačném případě se TOS odstraní</td></tr>
<tr><td>6</td><td>JUMP_IF_FALSE_OR_POP</td><td>index instrukce, na kterou skok vede</td><td>&times;</td><td>opačné chování, než je tomu v&nbsp;předchozí instrukci</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha D: Tabulka všech operačních kódů instrukcí Python VM</h2>

<p>Virtuální stroj programovacího jazyka Python využívá v&nbsp;bajtkódu
instrukce, jejichž operační kód má šířku osmi bitů (jeden bajt). To znamená, že
je teoreticky možné využít 256 různých instrukcí. Ve skutečnosti jsou však
některé operační kódy neobsazeny, což je ostatně patrné i při pohledu na
tabulku se seznamem všech (v&nbsp;současnosti používaných) instrukcí Python
VM:</p>

<table>
<tr><th>Operační kód</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0x00</td><td>STOP_CODE</td><td>konec bajtkódu, není využito interpretrem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x01</td><td>POP_TOP</td><td>odstraní položku ze zásobníku operandů</td></tr>
<tr><td>0x02</td><td>ROT_TWO</td><td>rotace (swap) dvou položek</td></tr>
<tr><td>0x03</td><td>ROT_THREE</td><td>rotace (roll) tří položek</td></tr>
<tr><td>0x04</td><td>DUP_TOP</td><td>duplikace položky na zásobníku operandů</td></tr>
<tr><td>0x05</td><td>ROT_FOUR</td><td>rotace čtyř položek</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x06</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x07</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x08</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x09</td><td>NOP</td><td>žádná operace (výplň)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x0a</td><td>UNARY_POSITIVE</td><td>unární operátor +</td></tr>
<tr><td>0x0b</td><td>UNARY_NEGATIVE</td><td>změna znaménka</td></tr>
<tr><td>0x0c</td><td>UNARY_NOT</td><td>negace</td></tr>
<tr><td>0x0d</td><td>UNARY_CONVERT</td><td>implementace konstrukce backtick (`)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x0e</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x0f</td><td>UNARY_INVERT</td><td>bitová negace</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x10</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x11</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x12</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x13</td><td>BINARY_POWER</td><td>umocnění</td></tr>
<tr><td>0x14</td><td>BINARY_MULTIPLY</td><td>součin</td></tr>
<tr><td>0x15</td><td>BINARY_DIVIDE</td><td>podíl</td></tr>
<tr><td>0x16</td><td>BINARY_MODULO</td><td>podíl modulo</td></tr>
<tr><td>0x17</td><td>BINARY_ADD</td><td>součet</td></tr>
<tr><td>0x18</td><td>BINARY_SUBTRACT</td><td>rozdíl</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x19</td><td>BINARY_SUBSCR</td><td>přístup k prvkům složeného datového typu (řetězec, seznam, n-tice)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1a</td><td>BINARY_FLOOR_DIVIDE</td><td>podíl (//)</td></tr>
<tr><td>0x1b</td><td>BINARY_TRUE_DIVIDE</td><td>podíl</td></tr>
<tr><td>0x1c</td><td>INPLACE_FLOOR_DIVIDE</td><td>podíl (odlišný přístup k prvkům na zásobníku)</td></tr>
<tr><td>0x1d</td><td>INPLACE_TRUE_DIVIDE</td><td>podíl (odlišný přístup k prvkům na zásobníku)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x28</td><td>STORE_SLICE+0</td><td>přístup k prvkům složeného datového typu (typicky seznamu)</td></tr>
<tr><td>0x29</td><td>STORE_SLICE+1</td><td>přístup k prvkům složeného datového typu (typicky seznamu)</td></tr>
<tr><td>0x2a</td><td>STORE_SLICE+2</td><td>přístup k prvkům složeného datového typu (typicky seznamu)</td></tr>
<tr><td>0x2b</td><td>STORE_SLICE+3</td><td>přístup k prvkům složeného datového typu (typicky seznamu)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2c</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x2d</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x2e</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x2f</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x30</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x31</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x32</td><td>DELETE_SLICE+0</td><td>přístup k prvkům složeného datového typu (typicky seznamu)</td></tr>
<tr><td>0x33</td><td>DELETE_SLICE+1</td><td>přístup k prvkům složeného datového typu (typicky seznamu)</td></tr>
<tr><td>0x34</td><td>DELETE_SLICE+2</td><td>přístup k prvkům složeného datového typu (typicky seznamu)</td></tr>
<tr><td>0x35</td><td>DELETE_SLICE+3</td><td>přístup k prvkům složeného datového typu (typicky seznamu)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x36</td><td>STORE_MAP</td><td>uloží do mapy další dvojici klíč:hodnota</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x37</td><td>INPLACE_ADD</td><td>varianta instrukce BINARY_ADD (odlišný přístup k prvkům na zásobníku)</td></tr>
<tr><td>0x38</td><td>INPLACE_SUBTRACT</td><td>varianta instrukce BINARY_SUBTRACT (odlišný přístup k prvkům na zásobníku)</td></tr>
<tr><td>0x39</td><td>INPLACE_MULTIPLY</td><td>varianta instrukce BINARY_MULTIPLY (odlišný přístup k prvkům na zásobníku)</td></tr>
<tr><td>0x3a</td><td>INPLACE_DIVIDE</td><td>varianta instrukce BINARY_DIVIDE (odlišný přístup k prvkům na zásobníku)</td></tr>
<tr><td>0x3b</td><td>INPLACE_MODULO</td><td>varianta instrukce BINARY_MODULO (odlišný přístup k prvkům na zásobníku)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3c</td><td>STORE_SUBSCR</td><td>přístup k prvkům n-tice, seznamu či řetězce</td></tr>
<tr><td>0x3d</td><td>DELETE_SUBSCR</td><td>vymazání prvku složeného datového typu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3e</td><td>BINARY_LSHIFT</td><td>posun doleva</td></tr>
<tr><td>0x3f</td><td>BINARY_RSHIFT</td><td>posun doprava</td></tr>
<tr><td>0x40</td><td>BINARY_AND</td><td>bitový/logický součin</td></tr>
<tr><td>0x41</td><td>BINARY_XOR</td><td>bitová/logická nonekvivalence</td></tr>
<tr><td>0x42</td><td>BINARY_OR</td><td>bitový/logický součet</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x43</td><td>INPLACE_POWER</td><td>operace **</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x44</td><td>GET_ITER</td><td>získání iterátoru pro prvek uložený na TOS</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x45</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x46</td><td>PRINT_EXPR</td><td>tisk výrazu</td></tr>
<tr><td>0x47</td><td>PRINT_ITEM</td><td>tisk jedné hodnoty</td></tr>
<tr><td>0x48</td><td>PRINT_NEWLINE</td><td>tisk konce řádku</td></tr>
<tr><td>0x49</td><td>PRINT_ITEM_TO</td><td>tisk jedné hodnoty do souboru</td></tr>
<tr><td>0x4a</td><td>PRINT_NEWLINE_TO</td><td>tisk konce řádku do souboru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x4b</td><td>INPLACE_LSHIFT</td><td>posun doleva</td></tr>
<tr><td>0x4c</td><td>INPLACE_RSHIFT</td><td>posun doprava</td></tr>
<tr><td>0x4d</td><td>INPLACE_AND</td><td>bitový/logický součin</td></tr>
<tr><td>0x4e</td><td>INPLACE_XOR</td><td>bitová/logická nonekvivalence</td></tr>
<tr><td>0x4f</td><td>INPLACE_OR</td><td>bitový/logický součet</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x50</td><td>BREAK_LOOP</td><td>přerušení programové smyčky</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x51</td><td>WITH_CLEANUP</td><td>vymazání zásobníku při ukončení bloku with</td></tr>
<tr><td>0x52</td><td>LOAD_LOCALS</td><td>použito při definici tříd</td></tr>
<tr><td>0x53</td><td>RETURN_VALUE</td><td>návrat z funkce a vrácení hodnoty z TOS</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x54</td><td>IMPORT_STAR</td><td>nahraje všechny (nelokální) symboly do jmenného prostoru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x55</td><td>EXEC_STMT</td><td>volá exec</td></tr>
<tr><td>0x56</td><td>YIELD_VALUE</td><td>použito v generátoru pro vrácení (další) hodnoty</td></tr>
<tr><td>0x57</td><td>POP_BLOCK</td><td>odstraní blok ze zásobníku (konec smyčky atd.)</td></tr>
<tr><td>0x58</td><td>END_FINALLY</td><td>ukončí klauzuli finally</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x59</td><td>BUILD_CLASS</td><td>vytvoří novou třídu</td></tr>
<tr><td>0x5a</td><td>STORE_NAME</td><td>práce se jmény uloženými v co_names</td></tr>
<tr><td>0x5b</td><td>DELETE_NAME</td><td>práce se jmény uloženými v co_names</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x5c</td><td>UNPACK_SEQUENCE</td><td>rozdělení sekvence na jednotlivé prvky a jejich uložení na zásobník</td></tr>
<tr><td>0x5d</td><td>FOR_ITER</td><td>použito při implementaci programové smyčky</td></tr>
<tr><td>0x5e</td><td>LIST_APPEND</td><td>volá list.append()</td></tr>
<tr><td>0x5f</td><td>STORE_ATTR</td><td>práce se jmény uloženými v co_names</td></tr>
<tr><td>0x60</td><td>DELETE_ATTR</td><td>práce se jmény uloženými v co_names</td></tr>
<tr><td>0x61</td><td>STORE_GLOBAL</td><td>práce s globálními jmény</td></tr>
<tr><td>0x62</td><td>DELETE_GLOBAL</td><td>práce s globálními jmény</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x63</td><td>DUP_TOPX</td><td>instrukce DUP opakovaná 1&times; až 5&times;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x64</td><td>LOAD_CONST</td><td>práce s hodnotami uloženými v co_const</td></tr>
<tr><td>0x65</td><td>LOAD_NAME</td><td>práce s hodnotami uloženými v co_names</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x66</td><td>BUILD_TUPLE</td><td>vytvoření nové n-tice</td></tr>
<tr><td>0x67</td><td>BUILD_LIST</td><td>vytvoření nového seznamu</td></tr>
<tr><td>0x68</td><td>BUILD_SET</td><td>vytvoření nové množiny</td></tr>
<tr><td>0x69</td><td>BUILD_MAP</td><td>vytvoření nové mapy</td></tr>
<tr><td>0x6a</td><td>LOAD_ATTR</td><td>přečtení atributu objektu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x6b</td><td>COMPARE_OP</td><td>provedení zvolené Booleovské operace</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x6c</td><td>IMPORT_NAME</td><td>import modulu</td></tr>
<tr><td>0x6d</td><td>IMPORT_FROM</td><td>import modulu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x6e</td><td>JUMP_FORWARD</td><td>skok na relativní index (je zadána delta oproti současné adrese)</td></tr>
<tr><td>0x6f</td><td>JUMP_IF_FALSE_OR_POP</td><td>opačné chování, než je tomu v&nbsp;předchozí instrukci</td></tr>
<tr><td>0x70</td><td>JUMP_IF_TRUE_OR_POP</td><td>pokud TOS==true, provede se skok, v opačném případě se TOS odstraní</td></tr>
<tr><td>0x71</td><td>JUMP_ABSOLUTE</td><td>skok na zadaný index (lokální adresu)</td></tr>
<tr><td>0x72</td><td>POP_JUMP_IF_FALSE</td><td>podmíněný skok na základě obsahu TOS; obsah TOS je odstraněn</td></tr>
<tr><td>0x73</td><td>POP_JUMP_IF_TRUE</td><td>podmíněný skok na základě obsahu TOS (opačná podmínka); obsah TOS je odstraněn</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x74</td><td>LOAD_GLOBAL</td><td>uložení zvoleného globálního jména na TOS</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x75</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x76</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x77</td><td>CONTINUE_LOOP</td><td>implementace příkazu continue</td></tr>
<tr><td>0x78</td><td>SETUP_LOOP</td><td>příprava programové smyčky (vytvoření bloku atd.)</td></tr>
<tr><td>0x79</td><td>SETUP_EXCEPT</td><td>vytvoření kopie bloku try na zásobníku</td></tr>
<tr><td>0x7a</td><td>SETUP_FINALLY</td><td>vytvoření kopie bloku try na zásobníku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7b</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7c</td><td>LOAD_FAST</td><td>uložení reference lokální proměnné na zásobník</td></tr>
<tr><td>0x7d</td><td>STORE_FAST</td><td>uložení hodnoty do lokální proměnné z TOS</td></tr>
<tr><td>0x7e</td><td>DELETE_FAST</td><td>vymazání lokální proměnné</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7f</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x80</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x81</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x82</td><td>RAISE_VARARGS</td><td>vyhození výjimky</td></tr>
<tr><td>0x83</td><td>CALL_FUNCTION</td><td>volání funkce</td></tr>
<tr><td>0x84</td><td>MAKE_FUNCTION</td><td>uložení reference na novou funkci na TOS</td></tr>
<tr><td>0x85</td><td>BUILD_SLICE</td><td>implementace funkce slice()</td></tr>
<tr><td>0x86</td><td>MAKE_CLOSURE</td><td>vytvoření uzávěru</td></tr>
<tr><td>0x87</td><td>LOAD_CLOSURE</td><td>uloží referenci na uzávěr</td></tr>
<tr><td>0x88</td><td>LOAD_DEREF</td><td>práce s uzávěry a/nebo objekty</td></tr>
<tr><td>0x89</td><td>STORE_DEREF</td><td>práce s uzávěry a/nebo objekty</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8a</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x8b</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8c</td><td>CALL_FUNCTION_VAR</td><td>zavolání funkce s&nbsp;proměnným počtem argumentů</td></tr>
<tr><td>0x8d</td><td>CALL_FUNCTION_KW</td><td>zavolání funkce s&nbsp;pojmenovanými argumenty</td></tr>
<tr><td>0x8e</td><td>CALL_FUNCTION_VAR_KW</td><td>zavolání funkce &ndash; kombinace obou předchozích variant</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8f</td><td>SETUP_WITH</td><td>začátek bloku with</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x90</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x91</td><td>EXTENDED_ARG</td><td>podpora pro argumenty funkcí, jichž je více než 65535</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x92</td><td>SET_ADD</td><td>rozšíření bajtkódu: práce s množinou</td></tr>
<tr><td>0x93</td><td>MAP_ADD</td><td>rozšíření bajtkódu: práce s mapou</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x94</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x95</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x96</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x97</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x98</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x99</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x9a</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x9b</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x9c</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x9d</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x9e</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0x9f</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa0</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa1</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa2</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa3</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa4</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa5</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa6</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa7</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa8</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xa9</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xaa</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xab</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xac</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xad</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xae</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xaf</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb0</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb1</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb2</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb3</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb4</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb5</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb6</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb7</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb8</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xb9</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xba</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xbb</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xbc</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xbd</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xbe</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xbf</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc0</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc1</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc2</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc3</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc4</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc5</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc6</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc7</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc8</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xc9</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xca</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xcb</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xcc</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xcd</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xce</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xcf</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd0</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd1</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd2</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd3</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd4</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd5</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd6</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd7</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd8</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xd9</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xda</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xdb</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xdc</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xdd</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xde</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xdf</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe0</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe1</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe2</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe3</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe4</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe5</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe6</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe7</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe8</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xe9</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xea</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xeb</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xec</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xed</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xee</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xef</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf0</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf1</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf2</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf3</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf4</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf5</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf6</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf7</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf8</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xf9</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xfa</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xfb</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xfc</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xfd</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xfe</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
<tr><td>0xff</td><td>neobsazeno</td><td>(neobsazeno)</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 (některé přímo pro Python 3.10) byly uloženy do Git
repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující jednoduchý výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py</a></td></tr>
<tr><td> 2</td><td>err_expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující chybný výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py</a></td></tr>
<tr><td> 3</td><td>async.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující async a await</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py</a></td></tr>
<tr><td> 4</td><td>primes.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující výpočet celočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>print_tokens.py</td><td>výpis všech typů a hodnot tokenů pro aktuální verzi Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py</a></td></tr>
<tr><td> 6</td><td>tokenize_expression_1.py</td><td>tokenizace výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py</a></td></tr>
<tr><td> 7</td><td>tokenize_expression_2.py</td><td>tokenizace výrazu, alternativní způsob otevření zdrojového souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py</a></td></tr>
<tr><td> 8</td><td>tokenize_expression_3.py</td><td>tokenizace výrazu s&nbsp;více operátory</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py</a></td></tr>
<tr><td> 9</td><td>tokenize_expression_4.py</td><td>tokenizace výrazu s&nbsp;více operátory, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py</a></td></tr>
<tr><td>10</td><td>tokenize_async.py</td><td>tokenizace zdrojového kódu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py</a></td></tr>
<tr><td>11</td><td>tokenize_primes.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py</a></td></tr>
<tr><td>12</td><td>tokenize_primes_2.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong>, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>parse_expression.py</td><td>parsing zdrojového kódu s&nbsp;výrazem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py</a></td></tr>
<tr><td>14</td><td>parse_expression_3_10.py</td><td>parsing zdrojového kódu s&nbsp;výrazem, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py</a></td></tr>
<tr><td>15</td><td>parse_async.py</td><td>parsing zdrojového kodu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py</a></td></tr>
<tr><td>16</td><td>parse_async_3_10.py</td><td>parsing zdrojového kodu <strong>async.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py</a></td></tr>
<tr><td>17</td><td>parse_primes.py</td><td>parsing zdrojového kodu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py</a></td></tr>
<tr><td>18</td><td>parse_primes_3_10.py</td><td>parsing zdrojového kodu <strong>primes.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>traverse_expression_1.py</td><td>průchod AST, nejjednodušší varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py</a></td></tr>
<tr><td>20</td><td>traverse_expression_2.py</td><td>průchod AST, vzor <i>Visitor</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py</a></td></tr>
<tr><td>21</td><td>traverse_expression_3.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py</a></td></tr>
<tr><td>22</td><td>traverse_expression_4.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py</a></td></tr>
<tr><td>23</td><td>traverse_expression_5.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py</a></td></tr>
<tr><td>24</td><td>traverse_expression_5.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů, vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>ifs1.py</td><td>zdrojový kód s&nbsp;několika zanořenými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py</a></td></tr>
<tr><td>26</td><td>ifs2.py</td><td>zdrojový kód s&nbsp;několika zanořenými úplnými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py</a></td></tr>
<tr><td>27</td><td>tokenize_ifs1.py</td><td>tokenizace zdrojového kódu &bdquo;ifs1.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py</a></td></tr>
<tr><td>28</td><td>tokenize_ifs2.py</td><td>tokenizace zdrojového kódu &bdquo;ifs2.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>compile_tree.py</td><td>překlad a spuštění AST</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>sprites.py</td><td>zdrojový kód, jehož AST se bude zkoumat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/sprites.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/sprites.py</a></td></tr>
<tr><td>31</td><td>traverse_code_1.py</td><td>průchod AST pro zvolený zdrojový kód</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_1.py</a></td></tr>
<tr><td>32</td><td>traverse_code_2.py</td><td>průchod AST, filtrace uzlů s&nbsp;definicí funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_2.py</a></td></tr>
<tr><td>33</td><td>traverse_code_3.py</td><td>průchod AST, filtrace uzlů s&nbsp;definicí modulu, třídy a funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_3.py</a></td></tr>
<tr><td>34</td><td>traverse_code_4.py</td><td>průchod AST, filtrace uzlů se smyčkou for</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>35</td><td>dis_0.py</td><td>překlad jednoduché funkce do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_0.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_0.py</a></td></tr>
<tr><td>36</td><td>dis_1.py</td><td>překlad aritmetických výrazů do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_1.py</a></td></tr>
<tr><td>37</td><td>dis_2.py</td><td>překlad výrazů s&nbsp;Booleovskými operátory do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_2.py</a></td></tr>
<tr><td>38</td><td>dis_3.py</td><td>překlad výrazů s&nbsp;relačními operátory do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_3.py</a></td></tr>
<tr><td>39</td><td>dis_4.py</td><td>překlad řídicí struktury typu <strong>if-then</strong> do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_4.py</a></td></tr>
<tr><td>40</td><td>dis_5.py</td><td>překlad řídicí struktury typu <strong>if-then-else</strong> do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_5.py</a></td></tr>
<tr><td>41</td><td>dis_6.py</td><td>jednoduchá programová smyčka typu <strong>while</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_6.py</a></td></tr>
<tr><td>42</td><td>dis_7.py</td><td>programová smyčka typu <strong>while</strong> se složitějším tělem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_7.py</a></td></tr>
<tr><td>43</td><td>dis_8.py</td><td>dvě vnořené smyčky typu <strong>while</strong> &ndash; výpis řady prvočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_8.py</a></td></tr>
<tr><td>44</td><td>dis_9.py</td><td>pokus o simulaci programové smyčky typu <strong>do-while</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_9.py</a></td></tr>
<tr><td>45</td><td>dis_a.py</td><td>programový kód s&nbsp;klíčovými slovy <strong>async</strong> a <strong>await</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_a.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_a.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Inside The Python Virtual Machine<br />
<a href="https://leanpub.com/insidethepythonvirtualmachine">https://leanpub.com/insidethepythonvirtualmachine</a>
</li>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>SymbolTable<br />
<a href="https://docs.python.org/3.8/library/symtable.html">https://docs.python.org/3.8/library/symtable.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Pygments - Python syntax highlighter<br />
<a href="http://pygments.org/">http://pygments.org/</a>
</li>

<li>Pygments (dokumentace)<br />
<a href="http://pygments.org/docs/">http://pygments.org/docs/</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Jazyky podporované knihovnou Pygments<br />
<a href="http://pygments.org/languages/">http://pygments.org/languages/</a>
</li>

<li>Pygments FAQ<br />
<a href="http://pygments.org/faq/">http://pygments.org/faq/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

<!--
     8:00 70000
     9:00 71000
    10:00 72000
    11:00 73000
    12:00 74000
    13:00 75000
    14:00 76000
    -->
