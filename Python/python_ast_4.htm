<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Překlad modulu do bajtkódu</a></p>
<p><a href="#k03">3. Překlad aritmetických výrazů do bajtkódu</a></p>
<p><a href="#k04">*** 4. Zásobníkový efekt (<i>stack effect</i>)</a></p>
<p><a href="#k05">5. Porovnání s&nbsp;bajtkódem virtuálního stroje jazyka Lua</a></p>
<p><a href="#k06">6. Překlad výrazů s&nbsp;Booleovskými operátory</a></p>
<p><a href="#k07">7. Překlad výrazů s&nbsp;relačními operátory</a></p>
<p><a href="#k08">8. Překlad řídicí struktury typu <strong>if-then</strong></a></p>
<p><a href="#k09">9. Překlad řídicí struktury typu <strong>if-then-else</strong></a></p>
<p><a href="#k10">10. Jednoduchá programová smyčka typu <strong>while</strong></a></p>
<p><a href="#k11">11. Programová smyčka typu <strong>while</strong> se složitějším tělem</a></p>
<p><a href="#k12">*** 12. Dvě vnořené smyčky typu <strong>while</strong> &ndash; výpis řady prvočísel</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<pre>
import dis
dis.dis("1+2*3")
  1           0 LOAD_CONST               0 (7)
              2 RETURN_VALUE

def <strong>add</strong>(x,y):
...     return x+y
...
dis.dis(add)
  2           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 BINARY_ADD
              6 RETURN_VALUE

>>> print(dis.code_info(add))
Name:              add
Filename:          <stdin>
Argument count:    2
Positional-only arguments: 0
Kw-only arguments: 0
Number of locals:  2
Stack size:        2
Flags:             OPTIMIZED, NEWLOCALS, NOFREE
Constants:
   0: None
Variable names:
   0: x
   1: y
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Překlad modulu do bajtkódu</h2>

<p></p>

<pre>
$ <strong>python3 -m py_compile dis_0.py</strong>
</pre>

<p></p>

<p>Po překladu do bajtkódu získáme binární soubor nazvaný
<strong>dis_0.{python_version}.pyc</strong>, jehož obsah si můžeme prohlédnout
libovolným <a
href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">hexa
prohlížečem</a>. Standardním hexa prohlížečem na Linuxu je nástroj
<strong>od</strong> (nenechte se zmást jeho jménem, které klame &ndash; jedná
se <strong>i</strong> o hexa prohlížeč):</p>

<pre>
$ <strong>od -t x1 dis_0.cpython-38.pyc</strong>
&nbsp;
0000000 55 0d 0d 0a 00 00 00 00 ac 9b 00 63 3c 00 00 00
0000020 e3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000040 00 02 00 00 00 40 00 00 00 73 0c 00 00 00 64 00
0000060 64 01 84 00 5a 00 64 02 53 00 29 03 63 02 00 00
0000100 00 00 00 00 00 00 00 00 00 03 00 00 00 02 00 00
0000120 00 43 00 00 00 73 0c 00 00 00 7c 00 7c 01 17 00
0000140 7d 02 7c 02 53 00 29 01 4e a9 00 29 03 da 01 78
0000160 da 01 79 da 06 72 65 73 75 6c 74 72 01 00 00 00
0000200 72 01 00 00 00 fa 08 64 69 73 5f 30 2e 70 79 da
0000220 0b 61 64 64 5f 6e 75 6d 62 65 72 73 01 00 00 00
0000240 73 04 00 00 00 00 01 08 01 72 06 00 00 00 4e 29
0000260 01 72 06 00 00 00 72 01 00 00 00 72 01 00 00 00
0000300 72 01 00 00 00 72 05 00 00 00 da 08 3c 6d 6f 64
0000320 75 6c 65 3e 01 00 00 00 f3 00 00 00 00
0000335
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad aritmetických výrazů do bajtkódu</h2>

<p>Nyní se již pojďme věnovat poněkud praktičtějšímu tématu &ndash; konkrétně
způsobu překladu různých typických programových konstrukcí do bajtkódu
virtuálního stroje jazyka Python. V&nbsp;této kapitole si ukážeme, jak se
konkrétně překládají základní aritmetické výrazy, a to zejména z&nbsp;toho
důvodu, že právě na překladu aritmetických výrazů bude patrný největší rozdíl
mezi virtuálními stroji založenými na zásobníku (Python VM) a operacích
s&nbsp;operandy uloženými na tomto zásobníku na jedné straně a
s&nbsp;virtuálními stroji založenými na sadě registrů na straně druhé (Lua
VM).</p>

<p>Budeme analyzovat bajtkód tohoto programu napsaného v&nbsp;Pythonu:</p>

<pre>
<i>#</i>
<i># Modul s nekolika jednoduchymi funkcemi</i>
<i># pro otestovani zakladnich vlastnosti bajtkodu jazyka Python</i>
<i># prekladu aritmetickych vyrazu.</i>
<i>#</i>
&nbsp; 
def <strong>vyraz1</strong>(x, y):
    result = x + y
    return result
&nbsp;
&nbsp;
def <strong>vyraz2</strong>(x, y):
    result = x - y
    return result
&nbsp;
&nbsp;
def <strong>vyraz3</strong>(x, y):
    result = x * y
    return result
&nbsp;
&nbsp;
def <strong>vyraz4</strong>(x, y):
    result = x / y
    return result
&nbsp;
&nbsp;
def <strong>vyraz5</strong>(x, y):
    result = x % y
    return result
&nbsp;
&nbsp;
def <strong>vyraz6</strong>(x, y, z):
    result = x + y * z
    return result
&nbsp;
&nbsp;
def <strong>vyraz7</strong>(x, y, z, w):
    result = x + y * z + w
    return result
&nbsp;
&nbsp;
def <strong>vyraz8</strong>(x, y, z, w):
    result = 2 * (x + y) * (z + w) * ((x + z) / (y + w))
    return result
&nbsp;
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(vyraz1(4, 3))
    print(vyraz2(4, 3))
    print(vyraz3(4, 3))
    print(vyraz4(4, 3))
    print(vyraz5(4, 3))
    print(vyraz6(4, 3, 2))
    print(vyraz7(4, 3, 2, 1))
    print(vyraz8(4, 3, 2, 1))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nvyraz1:")
    dis(vyraz1)
&nbsp;
    print("\nvyraz2:")
    dis(vyraz2)
&nbsp;
    print("\nvyraz3:")
    dis(vyraz3)
&nbsp;
    print("\nvyraz4:")
    dis(vyraz4)
&nbsp;
    print("\nvyraz5:")
    dis(vyraz5)
&nbsp;
    print("\nvyraz6:")
    dis(vyraz6)
&nbsp;
    print("\nvyraz7:")
    dis(vyraz7)
&nbsp;
    print("\nvyraz8:")
    dis(vyraz8)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>V&nbsp;Pythonu je použit, jak zajisté po přečtení předchozí části tohoto
miniseriálu očekáváte, zásobníkový kód. Pro aritmetické operace se tedy
nejdříve načtou oba operandy na zásobník instrukcí <strong>LOAD_FAST</strong>,
provede se příslušná binární operace <strong>BINARY_?</strong> a následně se
hodnota uloží zpět do lokální proměnné instrukcí
<strong>STORE_FAST</strong>:</p>

<pre>
vyraz1:
  8           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
  9           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz2:
 13           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_SUBTRACT</strong>                          <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 14           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz3:
 18           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 19           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz4:
 23           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_TRUE_DIVIDE</strong>                       <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 24           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz5:
 28           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 <strong>BINARY_MODULO</strong>                            <i>; provedení zvolené binární operace</i>
              6 STORE_FAST               2 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 29           8 LOAD_FAST                2 (result)      <i>; načtení hodnoty lokální proměnné</i>
             10 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz6:
 33           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 LOAD_FAST                2 (z)           <i>; uložení třetího parametru na zásobník operandů</i>
              6 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
              8 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             10 STORE_FAST               3 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 34          12 LOAD_FAST                3 (result)      <i>; načtení hodnoty lokální proměnné</i>
             14 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz7:
 38           0 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              2 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              4 LOAD_FAST                2 (z)           <i>; uložení třetího parametru na zásobník operandů</i>
              6 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
              8 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             10 LOAD_FAST                3 (w)           <i>; uložení čtvrtého parametru na zásobník operandů</i>
             12 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             14 STORE_FAST               4 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 39          16 LOAD_FAST                4 (result)      <i>; načtení hodnoty lokální proměnné</i>
             18 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
&nbsp;
vyraz8:
 43           0 LOAD_CONST               1 (2)           <i>; uložení konstanty na zásobník operandů</i>
              2 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
              4 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
              6 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
              8 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
             10 LOAD_FAST                2 (z)           <i>; uložení třetího parametru na zásobník operandů</i>
             12 LOAD_FAST                3 (w)           <i>; uložení čtvrtého parametru na zásobník operandů</i>
             14 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             16 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
             18 LOAD_FAST                0 (x)           <i>; uložení prvního parametru na zásobník operandů</i>
             20 LOAD_FAST                2 (z)           <i>; uložení třetího parametru na zásobník operandů</i>
             22 <strong>BINARY_ADD</strong>                               <i>; provedení zvolené binární operace</i>
             24 LOAD_FAST                1 (y)           <i>; uložení druhého parametru na zásobník operandů</i>
             26 LOAD_FAST                3 (w)           <i>; uložení čtvrtého parametru na zásobník operandů</i>
             28 <strong>BINARY_ADD</strong>
             30 <strong>BINARY_TRUE_DIVIDE</strong>
             32 <strong>BINARY_MULTIPLY</strong>                          <i>; provedení zvolené binární operace, výsledek se uloží na zásobník</i>
             34 STORE_FAST               4 (result)      <i>; přečtení vypočteného výsledku s jeho uložením do lokální proměnné</i>
&nbsp;
 44          36 LOAD_FAST                4 (result)      <i>; načtení hodnoty lokální proměnné</i>
             38 RETURN_VALUE                             <i>; která bude současně návratovou hodnotou funkce</i>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zásobníkový efekt (<i>stack effect</i>)</h2>

<p>Už před několika desítkami let programátoři píšící aplikace <a
href="https://www.root.cz/serialy/programovaci-jazyk-forth/">v&nbsp;programovacím
jazyku Forth</a> používali pro popis vlivu slov (příkazů) na položky uložené na
zásobníku takzvaný zásobníkový efekt (<i>stack effect</i>). Pro další čtení je
užitečné si čtení zásobníkového efektu osvojit.</p>

<p>Nejedná se v&nbsp;podstatě o nic složitého: uvnitř kulatých závorek, které
ve Forthu ale i Factoru značí začátek a konec poznámky se zásobníkovým efektem,
je symbolicky zapsán stav části zásobníku před provedením operace a po dvojici
znaků &bdquo;&ndash;&ldquo; stav zásobníku po provedení dané operace. Vzhledem
k&nbsp;tomu, že na zásobníku může být uloženo teoreticky libovolné množství
hodnot a daná operace většinou ovlivňuje pouze hodnoty umístěné blízko jeho
vrcholu, je zásobníkový efekt zapsán pouze pro ty pozice na zásobníku, které
jsou operací nějakým způsobem dotčeny, tj.&nbsp;operace tyto hodnoty přečte,
zruší či modifikuje. Položky umístěné níže nemá cenu zapisovat, jen by zápis
zbytečně komplikovaly. Položka umístěná nejvíce vlevo je ve skutečnosti uložena
na spodnějších místech zásobníku, než položky napravo od ní.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Porovnání s&nbsp;bajtkódem virtuálního stroje jazyka Lua</h2>

<p>Pro zajímavost se podívejme, jak bude podobný zdrojový kód přeložen
v&nbsp;jazyku Lua, jehož bajtkód není založen na zásobníkovém stroji, ale na
stroji registrovém:</p>

<pre>
<i>--</i>
<i>-- Modul s nekolika jednoduchymi funkcemi</i>
<i>-- pro otestovani zakladnich vlastnosti bajtkodu jazyka Lua</i>
<i>-- prekladu aritmetickych vyrazu.</i>
<i>--</i>
&nbsp;
function <strong>vyraz1</strong>(x, y)
    local result = x + y
    return result
end
&nbsp;
function <strong>vyraz2</strong>(x, y)
    local result = x - y
    return result
end
&nbsp;
function <strong>vyraz3</strong>(x, y)
    local result = x * y
    return result
end
&nbsp;
function <strong>vyraz4</strong>(x, y)
    local result = x / y
    return result
end
&nbsp;
function <strong>vyraz5</strong>(x, y)
    local result = x % y
    return result
end
&nbsp;
function <strong>vyraz6</strong>(x, y, z)
    local result = x + y * z
    return result
end
&nbsp;
function <strong>vyraz7</strong>(x, y, z, w)
    local result = x + y * z + w
    return result
end
&nbsp;
function <strong>vyraz8</strong>(x, y, z, w)
    local result = 2 * (x + y) * (z + w) * ((x + z) / (y + w))
    return result
end
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
function <strong>main</strong>()
    print(vyraz1(4, 3))
    print(vyraz2(4, 3))
    print(vyraz3(4, 3))
    print(vyraz4(4, 3))
    print(vyraz5(4, 3))
    print(vyraz6(4, 3, 2))
    print(vyraz7(4, 3, 2, 1))
    print(vyraz8(4, 3, 2, 1))
end
&nbsp;
main()
</pre>

<p>Ve virtuálním stroji jazyka Lua je použit kód využívající
&bdquo;registry&ldquo; virtuálního stroje a proto je počet instrukcí menší, než
u kódu zásobníkového. Za tuto efektivitu platíme omezeným počtem registrů (což
v&nbsp;praxi nemusí vadit):</p>

<pre>
function &lt;Test2.lua:7,10&gt; (3 instructions at 0x9e07c88)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [8]     ADD             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [9]     RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [10]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:12,15&gt; (3 instructions at 0x9e07f20)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [13]    SUB             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [14]    RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [15]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:17,20&gt; (3 instructions at 0x9e080f0)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [18]    MUL             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [19]    RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [20]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:22,25&gt; (3 instructions at 0x9e07ec8)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [23]    DIV             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [24]    RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [25]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:27,30&gt; (3 instructions at 0x9e084f8)
2 params, 3 slots, 0 upvalues, 3 locals, 0 constants, 0 functions
        1       [28]    MOD             2 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [29]    RETURN          2 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 2</i>
        3       [30]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:32,35&gt; (4 instructions at 0x9e07e18)
3 params, 4 slots, 0 upvalues, 4 locals, 0 constants, 0 functions
        1       [33]    MUL             3 1 2  <i>; provést aritmetickou operaci s parametrem 1 a 2</i>
        2       [33]    ADD             3 0 3  <i>; provést aritmetickou operaci s parametrem 0 a lokální proměnnou 3</i>
        3       [34]    RETURN          3 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 3</i>
        4       [35]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:37,40&gt; (5 instructions at 0x9e08458)
4 params, 5 slots, 0 upvalues, 5 locals, 0 constants, 0 functions
        1       [38]    MUL             4 1 2  <i>; provést aritmetickou operaci s parametrem 1 a 2</i>
        2       [38]    ADD             4 0 4  <i>; provést další aritmetickou operaci s parametrem 0 a lokální proměnnou 4</i>
        3       [38]    ADD             4 4 3  <i>; provést další aritmetickou operaci s parametrem 3 a lokální proměnnou 4</i>
        4       [39]    RETURN          4 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 4</i>
        5       [40]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
&nbsp;
function &lt;Test2.lua:42,45&gt; (10 instructions at 0x9e08720)
4 params, 7 slots, 0 upvalues, 5 locals, 1 constant, 0 functions
        1       [43]    ADD             4 0 1  <i>; provést aritmetickou operaci s parametrem 0 a 1</i>
        2       [43]    MUL             4 -1 4  ; 2 - <i>; zde se adresuje konstanta -2 !!!</i>
        3       [43]    ADD             5 2 3  <i>; provést další aritmetickou operaci, výsledek do lok. proměnné 5</i>
        4       [43]    MUL             4 4 5
        5       [43]    ADD             5 0 2
        6       [43]    ADD             6 1 3
        7       [43]    DIV             5 5 6
        8       [43]    MUL             4 4 5
        9       [44]    RETURN          4 2    <i>; návrat z funkce a vrácení hodnoty lokální proměnné 4</i>
        10      [45]    RETURN          0 1    <i>; automaticky vkládaná instrukce návratu z funkce</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překlad výrazů s&nbsp;Booleovskými operátory</h2>

<p>Booleovské (logické) výrazy se v&nbsp;bajtkódu programovacího jazyka Python
většinou překládají s&nbsp;využitím podmíněného skoku. Před samotnou instrukcí
skoku se vyhodnotí podmínka, v&nbsp;našem případě první část logického výrazu,
a na základě této podmínky se zjistí hodnota druhé části logického výrazu
(pokud se samozřejmě jedná o operace se dvěma operandy). Podívejme se nyní na
způsob překladu výrazů obsahujících negaci, logický součet, logický součin,
operaci nonekvivalence a různé kombinace těchto operací:</p>

<pre>
<i>#</i>
<i># Modul s nekolika jednoduchymi funkcemi</i>
<i># pro otestovani zakladnich vlastnosti bajtkodu jazyka Python</i>
<i># prekladu Booleovskych vyrazu.</i>
<i>#</i>
&nbsp;
def <strong>vyraz1</strong>(x):
    result = not x
    return result
&nbsp;
def <strong>vyraz2</strong>(x, y):
    result = x and y
    return result
&nbsp;
def <strong>vyraz3</strong>(x, y):
    result = x or y
    return result
&nbsp;
def <strong>vyraz4</strong>(x, y):
    result = x ^ y
    return result
&nbsp;
def <strong>vyraz5</strong>(x, y, z):
    result = x or y and z
    return result
&nbsp;
def <strong>vyraz6</strong>(x, y, z, w):
    result = (x or y) and (z or w)
    return result
&nbsp;
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(vyraz1(True))
    print(vyraz2(True, False))
    print(vyraz3(True, False))
    print(vyraz4(True, False))
    print(vyraz5(True, False, True))
    print(vyraz6(True, False, True, False))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nvyraz1:")
    dis(vyraz1)
&nbsp;
    print("\nvyraz2:")
    dis(vyraz2)
&nbsp;
    print("\nvyraz3:")
    dis(vyraz3)
&nbsp;
    print("\nvyraz4:")
    dis(vyraz4)
&nbsp;
    print("\nvyraz5:")
    dis(vyraz5)
&nbsp;
    print("\nvyraz6:")
    dis(vyraz6)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Povšimněte si, že se kromě první funkce (negace) skutečně používají
podmíněné skoky, tj.&nbsp;instrukce <strong>JUMP_IF_?</strong>, s&nbsp;nimiž se
ostatně setkáme i v&nbsp;navazujícím textu:</p>

<pre>
vyraz1:
  8           0 LOAD_FAST                0 (x)
              2 <strong>UNARY_NOT</strong>
              4 STORE_FAST               1 (result)
&nbsp;
  9           6 LOAD_FAST                1 (result)
              8 RETURN_VALUE
&nbsp;
vyraz2:
 12           0 LOAD_FAST                0 (x)
              2 <strong>JUMP_IF_FALSE_OR_POP</strong>     6
              4 LOAD_FAST                1 (y)
        &gt;&gt;    6 STORE_FAST               2 (result)
&nbsp;
 13           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz3:
 16           0 LOAD_FAST                0 (x)
              2 <strong>JUMP_IF_TRUE_OR_POP</strong>      6
              4 LOAD_FAST                1 (y)
        &gt;&gt;    6 STORE_FAST               2 (result)
&nbsp;
 17           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz4:
 20           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>BINARY_XOR</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 21           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz5:
 24           0 LOAD_FAST                0 (x)
              2 <strong>JUMP_IF_TRUE_OR_POP</strong>     10
              4 LOAD_FAST                1 (y)
              6 <strong>JUMP_IF_FALSE_OR_POP</strong>    10
              8 LOAD_FAST                2 (z)
        &gt;&gt;   10 STORE_FAST               3 (result)

 25          12 LOAD_FAST                3 (result)
             14 RETURN_VALUE
&nbsp;
vyraz6:
 28           0 LOAD_FAST                0 (x)
              2 <strong>POP_JUMP_IF_TRUE</strong>         8
              4 LOAD_FAST                1 (y)
              6 <strong>JUMP_IF_FALSE_OR_POP</strong>    14
        &gt;&gt;    8 LOAD_FAST                2 (z)
             10 <strong>JUMP_IF_TRUE_OR_POP</strong>     14
             12 LOAD_FAST                3 (w)
        &gt;&gt;   14 STORE_FAST               4 (result)
&nbsp;
 29          16 LOAD_FAST                4 (result)
             18 RETURN_VALUE
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad výrazů s&nbsp;relačními operátory</h2>

<p>Výrazy s&nbsp;relačními operátory se překládají do značné míry stejným
způsobem, jako aritmetické výrazy (jen se používají odlišné binární instrukce),
o čemž se ostatně přesvědčíme po pohledu na bajtkód vygenerovaný pro
následující skript:</p>

<pre>
<i>#</i>
<i># Modul s nekolika jednoduchymi funkcemi</i>
<i># pro otestovani zakladnich vlastnosti bajtkodu jazyka Python</i>
<i># prekladu relacnich vyrazu.</i>
<i>#</i>
&nbsp;
def <strong>vyraz1</strong>(x, y):
    result = x &lt;= y
    return result
&nbsp;
def <strong>vyraz2</strong>(x, y):
    result = x &lt; y
    return result
&nbsp;
def <strong>vyraz3</strong>(x, y):
    result = x == y
    return result
&nbsp;
def <strong>vyraz4</strong>(x, y):
    result = x != y
    return result
&nbsp;
def <strong>vyraz5</strong>(x, y):
    result = x &gt;= y
    return result
&nbsp;
def <strong>vyraz6</strong>(x, y):
    result = x &gt; y
    return result
&nbsp;
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(vyraz1(1, 2))
    print(vyraz2(1, 2))
    print(vyraz3(1, 2))
    print(vyraz4(1, 2))
    print(vyraz5(1, 2))
    print(vyraz6(1, 2))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nvyraz1:")
    dis(vyraz1)
&nbsp;
    print("\nvyraz2:")
    dis(vyraz2)
&nbsp;
    print("\nvyraz3:")
    dis(vyraz3)
&nbsp;
    print("\nvyraz4:")
    dis(vyraz4)
&nbsp;
    print("\nvyraz5:")
    dis(vyraz5)
&nbsp;
    print("\nvyraz6:")
    dis(vyraz6)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Z&nbsp;bajtkódu je patrné, že se používá &bdquo;univerzální&ldquo; instrukce
<strong>COMPARE_OP</strong>, jejímž celočíselným parametrem je číslo (index)
prováděné operace:</p>

<pre>
vyraz1:
  8           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               1 (&lt;=)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
  9           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz2:
 12           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               0 (&lt;)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 13           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz3:
 16           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               2 (==)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 17           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz4:
 20           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               3 (!=)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 21           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz5:
 24           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               5 (&gt;=)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 25           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
&nbsp;
vyraz6:
 28           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 <strong>COMPARE_OP               4 (&gt;)</strong>
              6 STORE_FAST               2 (result)
&nbsp;
 29           8 LOAD_FAST                2 (result)
             10 RETURN_VALUE
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Překlad řídicí struktury typu <strong>if-then</strong></h2>

<p>Nyní se již konečně dostáváme k&nbsp;mnohem zajímavějšímu tématu &ndash;
konkrétně k&nbsp;podmíněným skokům, kterými jsou realizovány strukturované
příkazy (rozeskoky) typu <strong>if-then</strong> a samozřejmě i úplné
rozhodovací konstrukce typu <strong>if-then-else</strong>. Jedná se o tak časté
programové konstrukce, že pro ně byly v&nbsp;bajtkódu vyhrazeny speciální
operace. Nejprve se podívejme na zdrojový kód dvou funkcí, jejichž bajtkód
budeme zkoumat:</p>

<pre>
def <strong>prikaz1</strong>(x):
    if x:
        return 10
    return 20
&nbsp;
def <strong>prikaz2</strong>(x, y):
    if x:
        if y:
            return 10
    return 20
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(prikaz1(True))
    print(prikaz1(False))
    print(prikaz2(True, True))
    print(prikaz2(True, False))
    print(prikaz2(False, True))
    print(prikaz2(False, False))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nprikaz1:")
    dis(prikaz1)
&nbsp;
    print("\nprikaz2:")
    dis(prikaz2)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Nejzajímavější částí bajtkódu jsou v&nbsp;tomto případě instrukce
<strong>POP_JUMP_IF_FALSE</strong>
(resp.&nbsp;<strong>POP_JUMP_IF_TRUE</strong>), které načtou hodnotu a pokud je
rovna False (tedy vlastně 0), provede se podmíněný skok na konec
rozvětvení:</p>

<pre>
prikaz1:
  8           0 LOAD_FAST                0 (x)
              2 <strong>POP_JUMP_IF_FALSE</strong>        8
&nbsp;
  9           4 LOAD_CONST               1 (10)
              6 RETURN_VALUE
&nbsp;
 10     &gt;&gt;    8 LOAD_CONST               2 (20)
             10 RETURN_VALUE
&nbsp;
prikaz2:
 13           0 LOAD_FAST                0 (x)
              2 <strong>POP_JUMP_IF_FALSE</strong>       12
&nbsp;
 14           4 LOAD_FAST                1 (y)
              6 <strong>POP_JUMP_IF_FALSE</strong>       12
&nbsp;
 15           8 LOAD_CONST               1 (10)
             10 RETURN_VALUE
&nbsp;
 16     &gt;&gt;   12 LOAD_CONST               2 (20)
             14 RETURN_VALUE
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Překlad řídicí struktury typu <strong>if-then-else</strong></h2>

<p>Úplná programová konstrukce <strong>if-then-else</strong> vznikne
z&nbsp;neúplné konstrukce typu <strong>if-then</strong> doplněním programové
větve <strong>else</strong>, což je samozřejmě podporováno i bajtkódem
virtuálního stroje Pythonu &ndash; musí se jednat o úplné rozvětvení a tedy
typicky o kombinaci podmíněného skoku se skokem nepodmíněným:</p>

<pre>
def <strong>prikaz1</strong>(x):
    if x:
        return 10
    else:
        return 20
&nbsp;
def <strong>prikaz2</strong>(x, y):
    if x:
        if y:
            return 10
        else:
            return 20
    else:
        return 30
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(prikaz1(True))
    print(prikaz1(False))
    print(prikaz2(True, True))
    print(prikaz2(True, False))
    print(prikaz2(False, True))
    print(prikaz2(False, False))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nprikaz1:")
    dis(prikaz1)
&nbsp;
    print("\nprikaz2:")
    dis(prikaz2)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>V&nbsp;bajtkódu nyní uvidíme dvě možnosti. První variantou je plný rozeskok,
přičemž každá větev končí instrukcí <strong>RETURN_VALUE</strong>:</p>

<pre>
prikaz1:
  8           0 LOAD_FAST                0 (x)
              2 POP_JUMP_IF_FALSE        8
&nbsp;
  9           4 LOAD_CONST               1 (10)
              6 RETURN_VALUE
&nbsp;
 11     &gt;&gt;    8 LOAD_CONST               2 (20)
             10 RETURN_VALUE
             12 LOAD_CONST               0 (None)
             14 RETURN_VALUE
</pre>

<p>Druhá varianta spočívá ve využití již výše zmíněné kombinace podmíněného a
nepodmíněného skoku, tedy zde konkrétně instrukcí
<strong>POP_JUMP_IF_FALSE</strong> a <strong>JUMP_FORWARD</strong>:</p>

<pre>
prikaz2:
 14           0 LOAD_FAST                0 (x)
              2 <strong>POP_JUMP_IF_FALSE</strong>       18
&nbsp;
 15           4 LOAD_FAST                1 (y)
              6 <strong>POP_JUMP_IF_FALSE</strong>       12
&nbsp;
 16           8 LOAD_CONST               1 (10)
             10 RETURN_VALUE
&nbsp;
 18     &gt;&gt;   12 LOAD_CONST               2 (20)
             14 RETURN_VALUE
             16 <strong>JUMP_FORWARD</strong>             4 (to 22)
&nbsp;
 20     &gt;&gt;   18 LOAD_CONST               3 (30)
             20 RETURN_VALUE
        &gt;&gt;   22 LOAD_CONST               0 (None)
             24 RETURN_VALUE
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Jednoduchá programová smyčka typu <strong>while</strong></h2>

<p>Základním a ve skutečnosti i univerzálním typem smyčky je ve strukturovaném
programování smyčka typu <strong>while</strong>. U tohoto typu smyčky se
podmínka pro ukončení smyčky kontroluje vždy na začátku každé iterace, což
mj.&nbsp;znamená, že se tělo smyčky nemusí provést ani jednou, a to
v&nbsp;případě, kdy podmínka není splněna již před provedením první iterace,
tj.&nbsp;před vstupem do smyčky. Z&nbsp;tohoto důvodu se konstrukce
<strong>while</strong> používá například v&nbsp;situacích, kdy se mají
zpracovávat vstupní data (čtená ze souboru, z&nbsp;databázové tabulky atd.), u
nichž není zřejmé, kolik údajů se bude načítat a zda se vůbec nějaký údaj na
vstupu bude nacházet. Zajímavé je, že ostatní typy smyček lze většinou přepsat
právě na programovou smyčku typu <strong>while</strong>, i když &ndash; jak
uvidíme na příkladu <i>Pythonu</i> &ndash; se nemusí vždy jednat o elegantní
řešení. Pojďme si tedy na velmi jednoduchých příkladech ukázat způsob překladu
této programové smyčky do bajtkódu virtuálního stroje Pythonu. Nejprve si
ukážeme překlad smyčky, v&nbsp;níž se pouze snižuje hodnota počitadla
kontrolovaného v&nbsp;podmínce pro další iteraci.</p>

<pre>
def <strong>loop</strong>(x):
    while x &gt; 0:
        x = x - 1
    return x
&nbsp;
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(loop(10))
&nbsp;
<i>#</i>
<i># Vypsani bajkkodu testovane funkce</i>
<i>#</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nloop:")
    dis(loop)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Bajtkód vytvořený pro virtuální stroj Pythonu je kupodivu poměrně dlouhý
(což prakticky znamená i pomalejší vyhodnocení v&nbsp;porovnání s&nbsp;Luou).
Můžeme zde vidět jak nepodmíněný skok <strong>JUMP_ABSOLUTE</strong>, tak i
podmíněný skok <strong>JUMP_IF_FALSE</strong>, pro nějž se podmínka vyhodnocuje
instrukcí <strong>COMPARE_OP</strong> (již známe). Povšimněte si taktéž
nutnosti použití instrukce <strong>POP_TOP</strong> sloužící pro
&bdquo;uklizení&ldquo; obsahu zásobníku operandů:</p>

<pre>
loop:
  8     &gt;&gt;    0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (0)
              4 <strong>COMPARE_OP</strong>               4 (&gt;)
              6 <strong>POP_JUMP_IF_FALSE</strong>       18
&nbsp;
  9           8 LOAD_FAST                0 (x)
             10 LOAD_CONST               2 (1)
             12 BINARY_SUBTRACT
             14 STORE_FAST               0 (x)
             16 <strong>JUMP_ABSOLUTE</strong>            0
&nbsp;
 10     &gt;&gt;   18 LOAD_FAST                0 (x)
             20 RETURN_VALUE
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Programová smyčka typu <strong>while</strong> se složitějším tělem</h2>

<p>Pro zajímavost se ještě podívejme na poněkud složitější demonstrační
příklady, v&nbsp;nichž je opět použita programová smyčka typu
<strong>while</strong>. Tyto příklady slouží k&nbsp;výpočtu exponenciální
funkce <i>2<sup>x</sup></i>, popř.&nbsp;<i>y2<sup>x</sup></i> (což je
v&nbsp;Pythonu vlastně zbytečné protože pro tuto operaci máme k&nbsp;dispozici
operátor **). Vzhledem k&nbsp;tomu, že hodnoty <i>x</i> a <i>y</i> nejsou
dopředu známé, nemůže překladač provádět prakticky žádné optimalizace smyčky
(to mohl teoreticky udělat v&nbsp;předchozím příkladu, což se však, jak již
víme, ve skutečnosti nestalo, alespoň nikoli na úrovni bajtkódu).</p>

<pre>
def <strong>loop</strong>(x, y):
    while x &gt; 0:
        x = x - 1
        y = y * 2
    return y
&nbsp;
&nbsp; 
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    print(loop(10, 1))
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nloop:")
    dis(loop)
&nbsp;
main()
&nbsp;
disassemble()
</pre>

<p>Opět můžeme vidět, že se test na ukončení smyčky provádí v&nbsp;úvodní části
kódu (porovnání+podmíněný skok), zatímco na konci smyčky je použit nepodmíněný
skok na začátek:</p>

<pre>
loop:
  8     &gt;&gt;    0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (0)
              4 <strong>COMPARE_OP</strong>               4 (&gt;)
              6 <strong>POP_JUMP_IF_FALSE</strong>       26
&nbsp;
  9           8 LOAD_FAST                0 (x)
             10 LOAD_CONST               2 (1)
             12 BINARY_SUBTRACT
             14 STORE_FAST               0 (x)
&nbsp;
 10          16 LOAD_FAST                1 (y)
             18 LOAD_CONST               3 (2)
             20 BINARY_MULTIPLY
             22 STORE_FAST               1 (y)
             24 <strong>JUMP_ABSOLUTE</strong>            0
&nbsp;
 11     &gt;&gt;   26 LOAD_FAST                1 (y)
             28 RETURN_VALUE
</pre>

<p><div class="rs-tip-major">Poznámka: překlad do bajtkódu je v&nbsp;případě
Pythonu poměrně přímočará mechanická záležitost; žádné složitější optimalizace
zde nejsou patrné.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Dvě vnořené smyčky typu <strong>while</strong> &ndash; výpis řady prvočísel</h2>

<p>Nastává čas ukázat si způsob překladu algoritmu, v&nbsp;němž se používají
dvě vnořené programové smyčky typu <strong>while</strong>. Zde je již situace
zajímavější, protože delší zdrojový kód dává překladači alespoň teoretickou
možnost provedení různých optimalizací. Jako příklad jsem vybral výpočet řady
prvočísel od 2 do zadané maximální hodnoty, přičemž se pro výpočet používá ta
nejjednodušší a současně i nejpomalejší :-) metoda založená na postupném
zjišťování, zda je zadaná hodnota <i>n</i> dělitelná nějakým celým číslem
v&nbsp;rozsahu <i>2..n-1</i> (teoreticky je možné smyčku ukončit dříve, ovšem
nechtěl jsem zbytečně do demonstračního algoritmu přidávat volání funkcí).</p>

<p>V&nbsp;Pythonu je možné tento algoritmus zapsat následujícím způsobem:</p>

<pre>
def <strong>primeNumbers</strong>(min, max):
    i = min
    while i &lt;= max:        <i># projit vsechny hodnoty od min do max</i>
        j = 2
        while j &lt; i:       <i># (lze optimalizovat a zkratit smycku!)</i>
            if i % j == 0: <i># je mozne celociselne delit?</i>
                break      <i># - pak ovsem nejde o prvocislo</i>
            j = j + 1      <i># vyzkouset dalsiho kandidata na celociselne deleni</i>
        if j == i:         <i># pokud jsme dosli az k cislu i</i>
            print(i)       <i># nedoslo nikdy k celociselnemu deleni</i>
        i = i + 1          <i># dalsi hodnota v posloupnosti</i>
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    primeNumbers(2, 1000)
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nprimeNumbers:")
    dis(primeNumbers)
&nbsp;
main()
&nbsp; 
disassemble()
</pre>

<p></p>

<pre>
primeNumbers:
  9           0 LOAD_FAST                0 (min)
              2 STORE_FAST               2 (i)
&nbsp;
 10     &gt;&gt;    4 LOAD_FAST                2 (i)
              6 LOAD_FAST                1 (max)
              8 COMPARE_OP               1 (&lt;=)
             10 POP_JUMP_IF_FALSE       74
&nbsp;
 11          12 LOAD_CONST               1 (2)
             14 STORE_FAST               3 (j)
&nbsp;
 12     &gt;&gt;   16 LOAD_FAST                3 (j)
             18 LOAD_FAST                2 (i)
             20 COMPARE_OP               0 (&lt;)
             22 POP_JUMP_IF_FALSE       48
&nbsp;
 13          24 LOAD_FAST                2 (i)
             26 LOAD_FAST                3 (j)
             28 BINARY_MODULO
             30 LOAD_CONST               2 (0)
             32 COMPARE_OP               2 (==)
             34 POP_JUMP_IF_FALSE       38
&nbsp;
 14          36 JUMP_ABSOLUTE           48
&nbsp;
 15     &gt;&gt;   38 LOAD_FAST                3 (j)
             40 LOAD_CONST               3 (1)
             42 BINARY_ADD
             44 STORE_FAST               3 (j)
             46 JUMP_ABSOLUTE           16
&nbsp;
 16     &gt;&gt;   48 LOAD_FAST                3 (j)
             50 LOAD_FAST                2 (i)
             52 COMPARE_OP               2 (==)
             54 POP_JUMP_IF_FALSE       64
&nbsp;
 17          56 LOAD_GLOBAL              0 (print)
             58 LOAD_FAST                2 (i)
             60 CALL_FUNCTION            1
             62 POP_TOP
&nbsp;
 18     &gt;&gt;   64 LOAD_FAST                2 (i)
             66 LOAD_CONST               3 (1)
             68 BINARY_ADD
             70 STORE_FAST               2 (i)
             72 JUMP_ABSOLUTE            4
        &gt;&gt;   74 LOAD_CONST               0 (None)
             76 RETURN_VALUE
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
def loop(x):
    while True:
        x = x - 1
        if x <= 0: break
    return x
 
#
# Vse je nutne otestovat.
#
def main():
    print(loop(10))
 
#
# Vypsani bajkkodu testovane funkce
#
def disassemble():
    from dis import dis
 
    print("\nloop:")
    dis(loop)
 
main()
 
disassemble()
</pre>

<pre>
loop:
 10     >>    0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (1)
              4 BINARY_SUBTRACT
              6 STORE_FAST               0 (x)

 11           8 LOAD_FAST                0 (x)
             10 LOAD_CONST               2 (0)
             12 COMPARE_OP               1 (<=)
             14 POP_JUMP_IF_FALSE        0
             16 JUMP_ABSOLUTE           20
             18 JUMP_ABSOLUTE            0

 12     >>   20 LOAD_FAST                0 (x)
             22 RETURN_VALUE
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 (některé přímo pro Python 3.10) byly uloženy do Git
repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující jednoduchý výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py</a></td></tr>
<tr><td> 2</td><td>err_expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující chybný výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py</a></td></tr>
<tr><td> 3</td><td>async.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující async a await</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py</a></td></tr>
<tr><td> 4</td><td>primes.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující výpočet celočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>print_tokens.py</td><td>výpis všech typů a hodnot tokenů pro aktuální verzi Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py</a></td></tr>
<tr><td> 6</td><td>tokenize_expression_1.py</td><td>tokenizace výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py</a></td></tr>
<tr><td> 7</td><td>tokenize_expression_2.py</td><td>tokenizace výrazu, alternativní způsob otevření zdrojového souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py</a></td></tr>
<tr><td> 8</td><td>tokenize_expression_3.py</td><td>tokenizace výrazu s&nbsp;více operátory</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py</a></td></tr>
<tr><td> 9</td><td>tokenize_expression_4.py</td><td>tokenizace výrazu s&nbsp;více operátory, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py</a></td></tr>
<tr><td>10</td><td>tokenize_async.py</td><td>tokenizace zdrojového kódu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py</a></td></tr>
<tr><td>11</td><td>tokenize_primes.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py</a></td></tr>
<tr><td>12</td><td>tokenize_primes_2.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong>, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>parse_expression.py</td><td>parsing zdrojového kódu s&nbsp;výrazem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py</a></td></tr>
<tr><td>14</td><td>parse_expression_3_10.py</td><td>parsing zdrojového kódu s&nbsp;výrazem, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py</a></td></tr>
<tr><td>15</td><td>parse_async.py</td><td>parsing zdrojového kodu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py</a></td></tr>
<tr><td>16</td><td>parse_async_3_10.py</td><td>parsing zdrojového kodu <strong>async.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py</a></td></tr>
<tr><td>17</td><td>parse_primes.py</td><td>parsing zdrojového kodu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py</a></td></tr>
<tr><td>18</td><td>parse_primes_3_10.py</td><td>parsing zdrojového kodu <strong>primes.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>traverse_expression_1.py</td><td>průchod AST, nejjednodušší varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py</a></td></tr>
<tr><td>20</td><td>traverse_expression_2.py</td><td>průchod AST, vzor <i>Visitor</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py</a></td></tr>
<tr><td>21</td><td>traverse_expression_3.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py</a></td></tr>
<tr><td>22</td><td>traverse_expression_4.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py</a></td></tr>
<tr><td>23</td><td>traverse_expression_5.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py</a></td></tr>
<tr><td>24</td><td>traverse_expression_5.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů, vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>ifs1.py</td><td>zdrojový kód s&nbsp;několika zanořenými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py</a></td></tr>
<tr><td>26</td><td>ifs2.py</td><td>zdrojový kód s&nbsp;několika zanořenými úplnými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py</a></td></tr>
<tr><td>27</td><td>tokenize_ifs1.py</td><td>tokenizace zdrojového kódu &bdquo;ifs1.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py</a></td></tr>
<tr><td>28</td><td>tokenize_ifs2.py</td><td>tokenizace zdrojového kódu &bdquo;ifs2.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>compile_tree.py</td><td>překlad a spuštění AST</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>sprites.py</td><td>zdrojový kód, jehož AST se bude zkoumat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/sprites.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/sprites.py</a></td></tr>
<tr><td>31</td><td>traverse_code_1.py</td><td>průchod AST pro zvolený zdrojový kód</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_1.py</a></td></tr>
<tr><td>32</td><td>traverse_code_2.py</td><td>průchod AST, filtrace uzlů s&nbsp;definicí funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_2.py</a></td></tr>
<tr><td>33</td><td>traverse_code_3.py</td><td>průchod AST, filtrace uzlů s&nbsp;definicí modulu, třídy a funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_3.py</a></td></tr>
<tr><td>34</td><td>traverse_code_4.py</td><td>průchod AST, filtrace uzlů se smyčkou for</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>35</td><td>dis_0.py</td><td>překlad jednoduché funkce do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_0.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_0.py</a></td></tr>
<tr><td>36</td><td>dis_1.py</td><td>překlad aritmetických výrazů do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_1.py</a></td></tr>
<tr><td>37</td><td>dis_2.py</td><td>překlad výrazů s&nbsp;Booleovskými operátory do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_2.py</a></td></tr>
<tr><td>38</td><td>dis_3.py</td><td>překlad výrazů s&nbsp;relačními operátory do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_3.py</a></td></tr>
<tr><td>39</td><td>dis_4.py</td><td>překlad řídicí struktury typu <strong>if-then</strong> do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_4.py</a></td></tr>
<tr><td>40</td><td>dis_5.py</td><td>překlad řídicí struktury typu <strong>if-then-else</strong> do bajtkódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_5.py</a></td></tr>
<tr><td>41</td><td>dis_6.py</td><td>jednoduchá programová smyčka typu <strong>while</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_6.py</a></td></tr>
<tr><td>42</td><td>dis_7.py</td><td>programová smyčka typu <strong>while</strong> se složitějším tělem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_7.py</a></td></tr>
<tr><td>43</td><td>dis_8.py</td><td>dvě vnořené smyčky typu <strong>while</strong> &ndash; výpis řady prvočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_8.py</a></td></tr>
<tr><td>44</td><td>dis_9.py</td><td>pokus o simulaci programové smyčky typu <strong>do-while</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_9.py</a></td></tr>
<tr><td>45</td><td>dis_a.py</td><td>programový kód s&nbsp;klíčovými slovy <strong>async</strong> a <strong>await</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_a.py">https://github.com/tisnik/most-popular-python-libs/blob/master/bytecode/dis_a.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>SymbolTable<br />
<a href="https://docs.python.org/3.8/library/symtable.html">https://docs.python.org/3.8/library/symtable.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Pygments - Python syntax highlighter<br />
<a href="http://pygments.org/">http://pygments.org/</a>
</li>

<li>Pygments (dokumentace)<br />
<a href="http://pygments.org/docs/">http://pygments.org/docs/</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Jazyky podporované knihovnou Pygments<br />
<a href="http://pygments.org/languages/">http://pygments.org/languages/</a>
</li>

<li>Pygments FAQ<br />
<a href="http://pygments.org/faq/">http://pygments.org/faq/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

