<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Čtyři způsoby zpracování XML v Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Čtyři způsoby zpracování XML v Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Čtyři způsoby zpracování XML v&times;Pythonu</a></p>
<p><a href="#k02">2. Testovací data ve formátu XML</a></p>
<p><a href="#k03">3. Knihovna <strong>lxml</strong></a></p>
<p><a href="#k04">4. Příklad použití knihovny <strong>lxml</strong></a></p>
<p><a href="#k05">5. Přístup k&nbsp;atributům a poduzlům naparsovaného dokumentu</a></p>
<p><a href="#k06">6. Knihovna <strong>xmltodict</strong></a></p>
<p><a href="#k07">7. Načtení XML s&nbsp;převodem do slovníku</a></p>
<p><a href="#k08">8. Zpracování dat uložených ve slovníku</a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Čtyři způsoby zpracování XML v&nbsp;Pythonu</h2>

<p>Existuje poměrně velké množství způsobů a knihoven, jakými je možné
v&nbsp;programovacím jazyku <a href="https://www.root.cz/n/python/">Python</a>
manipulovat s&nbsp;daty uloženými ve formátu XML. Pokusme se tedy tyto mnohé
přístupy rozdělit do čtyř skupin podle toho, o jak rozsáhlá data se jedná,
protože některé z&nbsp;dále uvedených způsobů jsou sice po programátorské
stránce velmi příjemné na použití (s&nbsp;XML se například dá pracovat jako
s&nbsp;běžným pythonovským slovníkem popř.&nbsp;dokonce jako
s&nbsp;plnohodnotným objektem), ovšem pro větší množství dat zcela nevhodné, a
to kvůli vysokým kvůli nárokům na objem operační paměti popř.&nbsp;na
požadovaný výkon mikroprocesoru(ů):</p>

<ol>

<li>Velmi často se setkáme s&nbsp;průběžným &bdquo;proudovým&ldquo; zpracováním
dat načítaných z&nbsp;XML, resp.&nbsp;přesněji řečeno jednotlivých uzlů
(elementů) tak, jak je získává XML parser. Informace o jednotlivých uzlech jsou
do uživatelského kódu většinou posílány formou událostí (<i>events</i>), které
jsou zpracovávány zaregistrovanými funkcemi nebo metodami. Tento přístup se
nazývá <i>Simple API for XML</i> neboli zkráceně <i>SAX</i> (toto jméno
naznačuje, že se jedná o formalizovaný přístup, ovšem není tomu tak &ndash;
v&nbsp;každém jazyku může být způsob proudového zpracování XML realizován
odlišně). Tímto způsobem lze zpracovávat údaje uložené v&nbsp;XML
s&nbsp;prakticky neomezenou velikostí.</li>

<li>Vytvoření reprezentace celého XML souboru ve formě obecného stromu, přičemž
pro přístup k&nbsp;jednotlivým uzlům lze použít <i>Document Object Model</i>
neboli <i>DOM</i> (podobně jako při manipulaci s&nbsp;obsahem HTML stránek).
Nároky na potřebnou kapacitu operační paměti jsou v&nbsp;tomto případě vyšší,
než v&nbsp;předchozím případě, takže se tento způsob využívá především ve
chvíli, kdy je nutné &bdquo;náhodně&ldquo; přistupovat k&nbsp;uzlům stromu,
popř.&nbsp;kdy je zapotřebí použít nějaké složitější mechanismy pro výběr
většího množství uzlů.</li>

<li>Načtení XML a jeho následná transformace do podoby slovníku
(<i>dictionary</i>) jazyka Python. Jedná se o velmi podobný přístup, jaký je
například použit při deserializaci dat uložených ve formátu <i>JSON</i>. Může
se jednat o vhodný způsob ve chvíli, kdy má například nějaká služba akceptovat
a zpracovávat poměrně malé objemy dat ve formátech XML i JSON (například
některé webové služby akceptují popř.&nbsp;produkují oba tyto formáty).
Popř.&nbsp;je možné tímto způsobem zpracovávat konfigurační soubory atd.</li>

<li>Načtení XML a jeho následná transformace do podoby objektu (<i>object</i>)
jazyka Python. Tento objekt typicky obsahuje informace o kořenovém uzlu XML a
navíc i atributy s&nbsp;nejbližšími poduzly a atributy samotného kořenového
uzlu. Jedná se o ideální způsob použitelný ve chvíli, kdy je nutné pracovat
s&nbsp;relativně malými konfiguračními soubory atd. (&bdquo;relativně
malé&ldquo; přitom označuje velikost, která se v&nbsp;praxi neustále
zvětšuje).</li>

</ol>

<p>V&nbsp;dnešním článku si ve stručnosti představíme všechny čtyři způsoby
zpracování dat uložených v&nbsp;XML souborech. Navážeme tak na dvojici článků o
knihovně LXML.</p>

<p><div class="rs-tip-major">Poznámka: existují ještě další způsoby rozdělení
přístupu k&nbsp;datům uložených v&nbsp;souborech XML. Zejména je nutné odlišit
zpracování validních XML, dále XML nevalidních (ale po syntaktické stránce
korektních), XML bez schématu, XML s&nbsp;větším množstvím jmenných prostorů
atd.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Testovací data ve formátu XML</h2>

<p>V&nbsp;demonstračním příkladech budeme používat několik XML souborů. Zejména
vývojáři pracující s&nbsp;programovacím jazykem Java a systémem Maven se určitě
již mnohokrát setkali se soubory nazvanými <strong>pom.xml</strong>. Jen ve
stručnosti si řekněme, že tyto soubory obsahují informace o projektu a
samozřejmě i konfiguraci celého projektu, popř.&nbsp;další informace používané
některými Maven pluginy. Tyto soubory jsou primárně využívané nástrojem
<i>Apache Maven</i>, přičemž zkratka <i>POM</i> znamená <i>Project Object
Model</i>. Ve skutečnosti ovšem s&nbsp;těmito soubory pracuje i mnoho dalších
nástrojů, ať již se jedná o integrovaná vývojová prostředí či o
specializovanější nástroje určené pro kontrolu závislých knihoven, licencí
použitých v&nbsp;knihovnách atd. atd.</p>

<pre>
&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.tisnik.uberproject.test&lt;/groupId&gt;
  &lt;artifactId&gt;test-app-junit-dependency&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;foo&lt;/groupId&gt;
      &lt;artifactId&gt;foo&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;bar&lt;/groupId&gt;
      &lt;artifactId&gt;bar&lt;/artifactId&gt;
      &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: tento soubor naleznete na GitHubu,
konkrétně na adrese <a
href="https://github.com/tisnik/lxml-examples/blob/master/pom.xml">https://github.com/tisnik/lxml-examples/blob/master/pom.xml</a>.</div></p>

<p>Druhý soubor založený na XML obsahuje reprezentaci jednoduchého stromu
s&nbsp;kořenem, třemi uzly navázanými na kořen, kde každý z&nbsp;těchto uzlů
obsahuje tři listy. Všechny uzly v&nbsp;XML přitom mají nastaveny atributy,
k&nbsp;nimž budeme programově přistupovat:</p>

<pre>
&lt;root atribut1="1" attribut2="2" popis="koren"&gt;
  &lt;left popis="levy vnitrni poduzel"&gt;
    &lt;left popis="list zcela nalevo"/&gt;
    &lt;middle popis="list"/&gt;
    &lt;right popis="list"/&gt;
  &lt;/left&gt;
  &lt;middle popis="prostredni vnitrni poduzel"&gt;
    &lt;left popis="list"/&gt;
    &lt;middle popis="prostredni list"/&gt;
    &lt;right popis="list"/&gt;
  &lt;/middle&gt;
  &lt;right popis="pravy vnitrni poduzel"&gt;
    &lt;left popis="list"/&gt;
    &lt;middle popis="list"/&gt;
    &lt;right popis="list zcela napravo"/&gt;
  &lt;/right&gt;
&lt;/root&gt;
</pre>

<p>A konečně třetí XML soubor obsahuje popis databázového schématu vygenerovaný
<a
href="https://www.root.cz/clanky/automaticke-vytvoreni-dokumentace-k-databazi-s-vyuzitim-nastroje-schemaspy/">nástrojem
SchemaSpy</a>. Jedná se o velmi jednoduchou databázi se třemi tabulkami:</p>

<pre>
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;database name="test1" schema="public" type="PostgreSQL - 9.6.10"&gt;
   &lt;tables&gt;
      &lt;table name="department" numRows="0" remarks="" schema="public" type="TABLE"&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="20" type="varchar" typeCode="12"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="2" name="location" nullable="false" remarks="" size="20" type="varchar" typeCode="12"/&gt;
      &lt;/table&gt;
      &lt;table name="employee" numRows="0" remarks="" schema="public" type="TABLE"&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="20" type="varchar" typeCode="12"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="2" name="job" nullable="false" remarks="" size="20" type="varchar" typeCode="12"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="3" name="manager" nullable="true" remarks="" size="10" type="int4" typeCode="4"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="4" name="hiredate" nullable="false" remarks="" size="13" type="date" typeCode="91"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="5" name="salary" nullable="false" remarks="" size="10" type="int4" typeCode="4"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="6" name="comment" nullable="true" remarks="" size="10" type="int4" typeCode="4"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="7" name="department" nullable="false" remarks="" size="10" type="int4" typeCode="4"/&gt;
      &lt;/table&gt;
      &lt;table name="project" numRows="0" remarks="" schema="public" type="TABLE"&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="1" name="employee" nullable="false" remarks="" size="10" type="int4" typeCode="4"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="2" name="startdate" nullable="false" remarks="" size="13" type="date" typeCode="91"/&gt;
         &lt;column autoUpdated="false" defaultValue="null" digits="0" id="3" name="enddate" nullable="false" remarks="" size="13" type="date" typeCode="91"/&gt;
      &lt;/table&gt;
   &lt;/tables&gt;
&lt;/database&gt;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Knihovna <strong>lxml</strong></h2>

<p>Na úvod si připomeneme některé možnosti nabízené knihovnou
<strong>lxml</strong>. Tato knihovna, s&nbsp;jejímiž základy se v&nbsp;této
kapitole seznámíme, slouží k&nbsp;načítání (parsování) XML souborů, dále pro
přístup k&nbsp;jednotlivým prvkům výsledného stromu, tvorbě a zapisování nových
XML a v&nbsp;případě potřeby lze tuto knihovnu použít i pro zpracování HTML
stránek. Zajímavé je, že se tato knihovna poměrně dobře hodí i pro práci
s&nbsp;nevalidními XML, XML bez schématu, XML s&nbsp;více jmennými prostory
atd. &ndash; tj.&nbsp;se soubory, které může být obtížné zpracovat
v&nbsp;jiných nástrojích. Vývojářům jsou v&nbsp;případě potřeby
k&nbsp;dispozici i další zajímavé technologie, zejména XPath (zjednodušeně:
přístup k&nbsp;elementům a jejich atributům přes doménově specifický jazyk) a
již výše zmíněný SAX, tj.&nbsp;možnost zpracovávat XML jako sekvenci elementů,
což je přístup mnohem méně náročný na paměť. Navíc se většinou jedná o
rychlejší způsob práce s&nbsp;XML.</p>

<p>Na knihovnu <strong>lxml</strong> se můžeme dívat jako na vhodný doplněk ke
knihovnám <strong>libxml2</strong> a <strong>libxslt</strong>, pro které
samozřejmě existují příslušná rozhraní pro Python. Tyto knihovny jsou především
rychlé a nabízí prakticky všechny užitečné operace pro práci s&nbsp;XML. Na
druhou stranu se jedná o spíše nízkoúrovňové knihovny poměrně přesně kopírující
céčkové rozhraní, což některým uživatelům Pythonu nemusí plně vyhovovat. Navíc
&ndash; jelikož se skutečně jedná o relativně tenkou vrstvu mezi programovacím
jazykem C a Pythonem &ndash; může poměrně snadno dojít k&nbsp;pádům celé
aplikace (<i>segfault</i>), což je velmi nepříjemné, zejména při produkčním
nasazení. Mj.&nbsp;i z&nbsp;těchto dvou důvodů vznikla knihovna
<strong>lxml</strong>, která je více &bdquo;pythonovská&ldquo; a tudíž snadněji
použitelná. Za snadnost použití však někdy zaplatíme pomalejším zpracováním
XML, takže záleží na tom, jak velké soubory a v&nbsp;jakém množství se mají
zpracovávat.</p>

<p>V&nbsp;případě, že v&nbsp;Pythonu vytváříte aplikace používající další
moduly (knihovny), máte již s&nbsp;velkou pravděpodobností knihovnu
<strong>lxml</strong> ve svém systému nainstalovanou. O tom, zda je knihovna
skutečně nainstalovaná a dostupná (interpret ji nalezne), se můžete snadno
přesvědčit, a to buď příkazem <strong>pip3 show lxml</strong> nebo <strong>pip3
list | grep lxml</strong> (což ovšem není tak přesné):</p>

<pre>
$ <strong>pip3 show lxml</strong>
&nbsp;
---
Name: lxml
Version: 3.3.3
Location: /usr/lib/python3/dist-packages
Requires: 
</pre>

<p>Jen pro zajímavost (<strong>pip3 show</strong> je ovšem lepší řešení):</p>

<pre>
$ <strong>pip3 list | grep lxml</strong>
lxml (3.3.3)
</pre>

<p><div class="rs-tip-major">Poznámka: mimochodem &ndash; verze 3.3.3 zobrazená
na výpisu nahoře je již dnes zastará, takže by se měl provést update na verzi
4.x.x (nejnovější <a href="https://pypi.org/project/lxml/">stabilní verze je
v&nbsp;současnosti verze 4.7.1</a>):</div></p>

<pre>
$ <strong>sudo pip3 install lxml -U</strong>
Collecting lxml
  Downloading https://files.pythonhosted.org/packages/03/a4/9eea8035fc7c7670e5eab97f34ff2ef0ddd78a491bf96df5accedb0e63f5/lxml-4.7.1-cp38-cp38m-manylinux1_x86_64.whl (5.8MB)
    100% |████████████████████████████████| 5.8MB 273kB/s 
Installing collected packages: lxml
  Found existing installation: lxml 3.3.3
    Uninstalling lxml-3.3.3:
      Successfully uninstalled lxml-3.3.3
Successfully installed lxml-4.7.1
</pre>

<p>Nyní znovu zkontrolujeme verzi nainstalované knihovny:</p>

<pre>
$ <strong>pip3 show lxml</strong>
&nbsp;
Name: lxml
Version: 4.7.1
Summary: Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API.
Home-page: http://lxml.de/
Author: lxml dev team
Author-email: lxml-dev@lxml.de
License: BSD
Location: /usr/lib64/python3.8/site-packages
Requires: 
</pre>

<p>Pokud z&nbsp;nějakého důvodu není knihovna <strong>lxml</strong>
nainstalovaná, je její instalace většinou otázkou několika sekund. Na výpisu
níže je ukázána instalace této knihovny určené pro Python 2 (používá se tedy
příkaz <strong>pip</strong> a nikoli <strong>pip3</strong>):</p>

<pre>
$ <strong>pip install --user lxml</strong>
&nbsp;
  Downloading https://files.pythonhosted.org/packages/e5/14/f4343239f955442da9da1919a99f7311bc5627522741bada61b2349c8def/lxml-4.7.1-cp27-cp27mu-manylinux1_x86_64.whl (5.8MB)
    100% |████████████████████████████████| 5.8MB 89kB/s 
Installing collected packages: lxml
Successfully installed lxml-4.7.1
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příklad použití knihovny <strong>lxml</strong></h2>

<p>Podívejme se nyní na velmi jednoduchý příklad použití knihovny
<strong>lxml</strong>. V&nbsp;následujícím skriptu využijeme soubor
&bdquo;test5.xml&ldquo;, který byl popsán <a href="#k02">ve druhé kapitole</a>.
Tento soubor obsahuje strom s&nbsp;kořenem a třemi dalšími uzly, z&nbsp;nichž
každý obsahuje tři koncové uzly a mělo by být možné ho knihovnou lxml bez
problémů načíst a zpracovat. Výsledkem bude objekt představující rekonstruovaný
strom:</p>

<pre>
import lxml.etree as ET
&nbsp;
xml = "test5.xml"
tree = ET.parse(xml)
&nbsp;
root = tree.getroot()
print(ET.tostring(root))
</pre>

<p>Takto se vypíše rekonstruovaný strom začínající kořenovým uzlem, který jsme
získali metodou <strong>getroot</strong>::</p>

<pre>
b'&lt;root atribut1="1" attribut2="2" popis="koren"&gt;&lt;left popis="levy vnitrni poduzel"&gt;&lt;left popis="list zcela nalevo"/&gt;&lt;right popis="list"/&gt;&lt;/left&gt;&lt;right popis="pravy vnitrni poduzel"&gt;&lt;left popis="list"/&gt;&lt;right popis="list zcela napravo"/&gt;&lt;/right&gt;&lt;/root&gt;'
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Přístup k&nbsp;atributům a poduzlům naparsovaného dokumentu</h2>

<p>Ve chvíli, kdy máme k&nbsp;dispozici objekt představující kořen stromu
vzniklého parsingem XML souboru, je možné postupně začít získávat atributy
kořenového uzlu, jeho text a samozřejmě i potomky, tj.&nbsp;uzly ležící o jednu
úroveň níže. Přístup k&nbsp;atributům:</p>

<pre>
print(root.get("atribut1"))
print(root.get("popis"))
</pre>

<p>Získání potomků:</p>

<pre>
children = root.getchildren()
</pre>

<p>Tato metoda obecně vrací sekvenci, takže se k&nbsp;jednotlivým potomkům
dostaneme například přes programovou smyčku typu <i>for-each</i>:</p>

<pre>
for child in children:
    print(child.get("popis"))
</pre>

<p>Celý demonstrační příklad, který zpracuje jednoduchý XML soubor a vypíše
atributy kořenového uzlu i jeho potomky (resp.&nbsp;přesněji řečeno atribut
&bdquo;popis&ldquo; potomků), bude vypadat následovně:</p>

<pre>
import lxml.etree as ET
&nbsp;
xml = "test5.xml"
tree = ET.parse(xml)
&nbsp;
root = tree.getroot()
<i># print(ET.tostring(root))</i>
&nbsp;
print(root.get("atribut1"))
print(root.get("popis"))
&nbsp;
children = root.getchildren()
&nbsp;
for child in children:
    print(child.get("popis"))
</pre>

<p>Výsledkem bude následujících pět řádků vypsaných na standardní výstup:</p>

<pre>
1
koren
levy vnitrni poduzel
prostredni vnitrni poduzel
pravy vnitrni poduzel
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Knihovna <strong>xmltodict</strong></h2>

<p>Jak jsme si již řekli <a href="#k01">v&nbsp;úvodní kapitole</a>, je možné
data uložená v&nbsp;souborech ve formátu XML zpracovávat několika různými
způsoby. Nyní si ukážeme způsob, který se do značné míry podobá deserializaci
dat uložených ve formátu JSON. Tento způsob spočívá v&nbsp;tom, že se obsah XML
načte a postupně ztransformuje do slovníku (<i>dictionary</i>), což je jedna ze
základních datových struktur programovacího jazyka Python. Velká přednost
tohoto přístupu spočívá ve snadnosti práce s&nbsp;výsledným slovníkem,
nevýhodou pak obecně větší paměťové nároky (v&nbsp;porovnání se SAX, viz další
text) a taktéž fakt, že korespondence mezi původním XML a výsledným slovníkem
nemusí být pro vývojáře zcela zřejmá (protože vyjadřovací schopnosti XML jsou
v&nbsp;tomto ohledu vyšší, než je tomu v&nbsp;případě JSONu, což je výhoda a
nevýhoda současně).</p>

<p>Pro načtení XML do slovníku slouží knihovna pojmenovaná
<strong>xmltodict</strong>, která není součástí standardní knihovny
programovacího jazyka Python, takže ji budeme muset doinstalovat:</p>

<pre>
$ <strong>pip3 install --user xmltodict</strong>
&nbsp;
Collecting xmltodict
  Downloading xmltodict-0.12.0-py2.py3-none-any.whl (9.2 kB)
Installing collected packages: xmltodict
Successfully installed xmltodict-0.12.0
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Načtení XML s&nbsp;převodem do slovníku</h2>

<p>Po instalaci se můžeme pokusit načíst soubor <strong>test5.xml</strong>,
který jsme v&nbsp;rámci předchozích kapitol zpracovali knihovnou
<strong>lxml</strong>. Celý skript bude nyní značně krátký, protože pouze
postačuje otevřít soubor s&nbsp;XML a následně použít funkci
<strong>parse</strong> z&nbsp;balíčku <strong>xmltodict</strong>:</p>

<pre>
import xmltodict
&nbsp;
with open("test5.xml", "r") as fin:
    s=xmltodict.parse(fin.read())
&nbsp;
    print(s)
</pre>

<p>Výsledek bude vypadat následovně:</p>

<pre>
OrderedDict([('root', OrderedDict([('@atribut1', '1'), ('@attribut2', '2'),
('@popis', 'koren'), ('left', OrderedDict([('@popis', 'levy vnitrni poduzel'),
('left', OrderedDict([('@popis', 'list zcela nalevo')])), ('middle',
OrderedDict([('@popis', 'list')])), ('right', OrderedDict([('@popis',
'list')]))])), ('middle', OrderedDict([('@popis', 'prostredni vnitrni
poduzel'), ('left', OrderedDict([('@popis', 'list')])), ('middle',
OrderedDict([('@popis', 'prostredni list')])), ('right',
OrderedDict([('@popis', 'list')]))])), ('right', OrderedDict([('@popis', 'pravy
vnitrni poduzel'), ('left', OrderedDict([('@popis', 'list')])), ('middle',
OrderedDict([('@popis', 'list')])), ('right', OrderedDict([('@popis', 'list
zcela napravo')]))]))]))])
</pre>

<p>Což zajisté není příliš čitelné, takže si pomůžeme standardní knihovnou <strong>pprint</strong>:</p>

<pre>
import xmltodict
import pprint
&nbsp;
with open("pom.xml", "r") as fin:
    s=xmltodict.parse(fin.read())
&nbsp;
    pprint.pprint(s)
</pre>

<p>S&nbsp;následujícím výsledkem:</p>

<pre>
OrderedDict([('root',
              OrderedDict([('@atribut1', '1'),
                           ('@attribut2', '2'),
                           ('@popis', 'koren'),
                           ('left',
                            OrderedDict([('@popis', 'levy vnitrni poduzel'),
                                         ('left',
                                          OrderedDict([('@popis',
                                                        'list zcela nalevo')])),
                                         ('middle',
                                          OrderedDict([('@popis', 'list')])),
                                         ('right',
                                          OrderedDict([('@popis', 'list')]))])),
                           ('middle',
                            OrderedDict([('@popis',
                                          'prostredni vnitrni poduzel'),
                                         ('left',
                                          OrderedDict([('@popis', 'list')])),
                                         ('middle',
                                          OrderedDict([('@popis',
                                                        'prostredni list')])),
                                         ('right',
                                          OrderedDict([('@popis', 'list')]))])),
                           ('right',
                            OrderedDict([('@popis', 'pravy vnitrni poduzel'),
                                         ('left',
                                          OrderedDict([('@popis', 'list')])),
                                         ('middle',
                                          OrderedDict([('@popis', 'list')])),
                                         ('right',
                                          OrderedDict([('@popis',
                                                        'list zcela '
                                                        'napravo')]))]))]))])
</pre>

<p><div class="rs-tip-major">Poznámka: vidíme, že se používá datový typ <a
href="https://docs.python.org/3/library/collections.html#collections.OrderedDict">OrderedDict</a>
ze standardní knihovny Pythonu.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zpracování dat uložených ve slovníku</h2>

<p>Přístup ke konkrétnímu uzlu se provádí běžným výběrem ze slovníku:</p>

<pre>
import xmltodict
import pprint
&nbsp;
with open("test5.xml", "r") as fin:
    s = xmltodict.parse(fin.read())
&nbsp;
    p = s["root"]
    m = p["middle"]
&nbsp;
    pprint.pprint(m)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
OrderedDict([('@popis', 'prostredni vnitrni poduzel'),
             ('left', OrderedDict([('@popis', 'list')])),
             ('middle', OrderedDict([('@popis', 'prostredni list')])),
             ('right', OrderedDict([('@popis', 'list')]))])
</pre>

<p>Nyní jsme tedy získali obsah uzlu <strong>middle</strong>, který je navázán
na kořenový uzel. Uzel <strong>middle</strong> obsahuje atribut
<strong>popis</strong> a tři další poduzly. Povšimněte si, jakým způsobem jsou
atributy a poduzly uloženy ve slovníku &ndash; formou dvojice, přičemž jméno
atributu začíná zavináčem (ten v&nbsp;XML běžně není součástí značky). Přístup
přímo k&nbsp;atributu <strong>popis</strong> je tedy triviální:</p>

<pre>
import xmltodict
&nbsp;
with open("test5.xml", "r") as fin:
    s = xmltodict.parse(fin.read())
&nbsp;
    p = s["root"]["middle"]["@popis"]
&nbsp;
    print(p)
</pre>

<p>S&nbsp;očekávaným výsledkem:</p>

<pre>
prostredni vnitrni poduzel
</pre>

<p>Atribut tedy rozeznáme snadno:</p>

<ol>
<li>Jméno (první prvek dvojice) začíná znakem zavináče</li>
<li>Hodnotou je řetězec a nikoli vnořený <strong>OrderedDict</strong></li>
</ol>

<p>Zcela stejným způsobem můžeme zpracovat soubor <strong>pom.xml</strong>,
který byl taktéž popsán ve druhé kapitole:</p>

<pre>
import xmltodict
import pprint
&nbsp;
with open("pom.xml", "r") as fin:
    s=xmltodict.parse(fin.read())
&nbsp;
    pprint.pprint(s)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
import pprint
pprint.pprint(s)
OrderedDict([('project',
              OrderedDict([('modelVersion', '4.0.0'),
                           ('groupId', 'org.tisnik.uberproject.test'),
                           ('artifactId', 'test-app-junit-dependency'),
                           ('version', '1.0'),
                           ('dependencies',
                            OrderedDict([('dependency',
                                          [OrderedDict([('groupId', 'junit'),
                                                        ('artifactId', 'junit'),
                                                        ('version', '3.8.1')]),
                                           OrderedDict([('groupId', 'foo'),
                                                        ('artifactId', 'foo'),
                                                        ('version', '1.0.0')]),
                                           OrderedDict([('groupId', 'bar'),
                                                        ('artifactId', 'bar'),
                                                        ('version',
                                                         '1.2.3')])])]))]))])
</pre>

<p>Zde narážíme na jinou vlastnost knihovny <strong>xmltodict</strong>, a to
konkrétně na způsob uložení textu umístěného v&nbsp;elementech. Konkrétně se to
textů v&nbsp;elementech <strong>groupId</strong>, <strong>artifactId</strong> a
<strong>version</strong>. To, že se jedná o elementy se pozná snadno:</p>

<ol>
<li>Jméno (první prvek dvojice) <strong>ne</strong>začíná znakem zavináče</li>
<li>Hodnotou je řetězec a nikoli vnořený <strong>OrderedDict</strong></li>
</ol>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
import json
print(json.dumps(s, indent=4))
{
    "project": {
        "modelVersion": "4.0.0",
        "groupId": "org.tisnik.uberproject.test",
        "artifactId": "test-app-junit-dependency",
        "version": "1.0",
        "dependencies": {
            "dependency": [
                {
                    "groupId": "junit",
                    "artifactId": "junit",
                    "version": "3.8.1"
                },
                {
                    "groupId": "foo",
                    "artifactId": "foo",
                    "version": "1.0.0"
                },
                {
                    "groupId": "bar",
                    "artifactId": "bar",
                    "version": "1.2.3"
                }
            ]
        }
    }
}
</pre>








$ pip3 install --user untangle
Collecting untangle
  Downloading untangle-1.1.1.tar.gz (3.1 kB)
  Preparing metadata (setup.py) ... done
Building wheels for collected packages: untangle
  Building wheel for untangle (setup.py) ... done
  Created wheel for untangle: filename=untangle-1.1.1-py3-none-any.whl size=3410 sha256=4484f6e2d03f09ed217264afa0f55c82bc75d7f1ab8cfa40cd6fb73f04d61c7e
  Stored in directory: /home/ptisnovs/.cache/pip/wheels/7f/c5/cc/22e3fc6b9f951bbd4dfdc0ebd1aceb3b9ce4dee7d7780e270a
Successfully built untangle
Installing collected packages: untangle
Successfully installed untangle-1.1.1



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

import untangle
o = untangle.parse("pom.xml")
o
Element(name = None, attributes = None, cdata = )


dir(o)
['project']

p=o.project
dir(p)
['artifactId', 'dependencies', 'groupId', 'modelVersion', 'version']

p.groupId.cdata
'org.tisnik.uberproject.test'

p.get_elements()
[Element(name = modelVersion, attributes = {}, cdata = 4.0.0), Element(name = groupId, attributes = {}, cdata = org.tisnik.uberproject.test), Element(name = artifactId, attributes = {}, cdata = test-app-junit-dependency), Element(name = version, attributes = {}, cdata = 1.0), Element(name = dependencies, attributes = {}, cdata = 
    
    
    
  )]


len(p.dependencies)
3

d=p.dependencies
dir(d)
['dependency', 'dependency', 'dependency']


for dep in d.dependency:
    dir(dep)

['artifactId', 'groupId', 'version']
['artifactId', 'groupId', 'version']
['artifactId', 'groupId', 'version']

for dep in d.dependency:
    print(dep.artifactId.cdata)

junit
foo
bar



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

s=untangle.parse("test5.xml")
s
Element(name = None, attributes = None, cdata = )
s.root
Element(name = root, attributes = {'atribut1': '1', 'attribut2': '2', 'popis': 'koren'}, cdata = )
s.root.get_attribute("atribut1")
'1'

dir(s.root)
['left', 'middle', 'right']

s.root.left.get_attribute("popis")
'levy vnitrni poduzel'



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
import xml.sax
&nbsp;
&nbsp;
class <strong>XmlHandler</strong>(xml.sax.ContentHandler):
    def <strong>startElement</strong>(self, name, attributes):
        print("Node:", name)
&nbsp;
&nbsp;
parser = xml.sax.make_parser()
parser.setContentHandler(XmlHandler())
&nbsp;
with open("db.public.xml", "r") as fin:
    parser.parse(fin)
</pre>

<pre>
Node: database
Node: tables
Node: table
Node: column
Node: column
Node: column
Node: table
Node: column
Node: column
Node: column
Node: column
Node: column
Node: column
Node: column
Node: column
Node: table
Node: column
Node: column
Node: column
Node: column
</pre>

<pre>
import xml.sax
&nbsp;
&nbsp;
class <strong>XmlHandler</strong>(xml.sax.ContentHandler):
    def <strong>startElement</strong>(self, name, attributes):
        print("Node:", name)
        for (k,v) in attributes.items():
            print("\t", k, v)
&nbsp;
&nbsp;
parser = xml.sax.make_parser()
parser.setContentHandler(XmlHandler())
&nbsp;
with open("db.public.xml", "r") as fin:
    parser.parse(fin)
</pre>

<pre>
Node: database
         name test1
         schema public
         type PostgreSQL - 9.6.10
Node: tables
Node: table
         name department
         numRows 0
         remarks 
         schema public
         type TABLE
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 0
         name id
         nullable false
         remarks 
         size 10
         type int4
         typeCode 4
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 1
         name name
         nullable false
         remarks 
         size 20
         type varchar
         typeCode 12
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 2
         name location
         nullable false
         remarks 
         size 20
         type varchar
         typeCode 12
Node: table
         name employee
         numRows 0
         remarks 
         schema public
         type TABLE
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 0
         name id
         nullable false
         remarks 
         size 10
         type int4
         typeCode 4
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 1
         name name
         nullable false
         remarks 
         size 20
         type varchar
         typeCode 12
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 2
         name job
         nullable false
         remarks 
         size 20
         type varchar
         typeCode 12
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 3
         name manager
         nullable true
         remarks 
         size 10
         type int4
         typeCode 4
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 4
         name hiredate
         nullable false
         remarks 
         size 13
         type date
         typeCode 91
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 5
         name salary
         nullable false
         remarks 
         size 10
         type int4
         typeCode 4
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 6
         name comment
         nullable true
         remarks 
         size 10
         type int4
         typeCode 4
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 7
         name department
         nullable false
         remarks 
         size 10
         type int4
         typeCode 4
Node: table
         name project
         numRows 0
         remarks 
         schema public
         type TABLE
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 0
         name id
         nullable false
         remarks 
         size 10
         type int4
         typeCode 4
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 1
         name employee
         nullable false
         remarks 
         size 10
         type int4
         typeCode 4
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 2
         name startdate
         nullable false
         remarks 
         size 13
         type date
         typeCode 91
Node: column
         autoUpdated false
         defaultValue null
         digits 0
         id 3
         name enddate
         nullable false
         remarks 
         size 13
         type date
         typeCode 91
</pre>

<pre>
import xml.sax
&nbsp;
&nbsp;
class <strong>XmlHandler</strong>(xml.sax.ContentHandler):
&nbsp;
    def <strong>startElement</strong>(self, name, attributes):
        if name == "table":
            print("Node:", name)
            for (k,v) in attributes.items():
                print("\t", k, v)
&nbsp;
&nbsp;
parser = xml.sax.make_parser()
parser.setContentHandler(XmlHandler())
&nbsp;
with open("db.public.xml", "r") as fin:
    parser.parse(fin)
</pre>

<pre>
Node: table
         name department
         numRows 0
         remarks 
         schema public
         type TABLE
Node: table
         name employee
         numRows 0
         remarks 
         schema public
         type TABLE
Node: table
         name project
         numRows 0
         remarks 
         schema public
         type TABLE
</pre>

<pre>
import xml.sax
&nbsp;
&nbsp;
class <strong>XmlHandler</strong>(xml.sax.ContentHandler):
&nbsp;
    def <strong>__init__</strong>(self):
        self.in_table = False
&nbsp;
    def <strong>startElement</strong>(self, name, attributes):
        if name == "table":
            print("Found table:", attributes["name"])
            self.in_table = True
&nbsp;
        if self.in_table and name == "column":
            print("\tColumn:", attributes["name"])
            for (k,v) in attributes.items():
                print("\t\t", k, v)
&nbsp;
    def <strong>endElement</strong>(self, name):
        if name == "table":
            self.in_table = False
&nbsp;
&nbsp;
parser = xml.sax.make_parser()
parser.setContentHandler(XmlHandler())
&nbsp;
with open("db.public.xml", "r") as fin:
    parser.parse(fin)
</pre>

<pre>
Found table: department
        Column: id
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 0
                 name id
                 nullable false
                 remarks 
                 size 10
                 type int4
                 typeCode 4
        Column: name
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 1
                 name name
                 nullable false
                 remarks 
                 size 20
                 type varchar
                 typeCode 12
        Column: location
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 2
                 name location
                 nullable false
                 remarks 
                 size 20
                 type varchar
                 typeCode 12
Found table: employee
        Column: id
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 0
                 name id
                 nullable false
                 remarks 
                 size 10
                 type int4
                 typeCode 4
        Column: name
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 1
                 name name
                 nullable false
                 remarks 
                 size 20
                 type varchar
                 typeCode 12
        Column: job
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 2
                 name job
                 nullable false
                 remarks 
                 size 20
                 type varchar
                 typeCode 12
        Column: manager
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 3
                 name manager
                 nullable true
                 remarks 
                 size 10
                 type int4
                 typeCode 4
        Column: hiredate
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 4
                 name hiredate
                 nullable false
                 remarks 
                 size 13
                 type date
                 typeCode 91
        Column: salary
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 5
                 name salary
                 nullable false
                 remarks 
                 size 10
                 type int4
                 typeCode 4
        Column: comment
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 6
                 name comment
                 nullable true
                 remarks 
                 size 10
                 type int4
                 typeCode 4
        Column: department
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 7
                 name department
                 nullable false
                 remarks 
                 size 10
                 type int4
                 typeCode 4
Found table: project
        Column: id
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 0
                 name id
                 nullable false
                 remarks 
                 size 10
                 type int4
                 typeCode 4
        Column: employee
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 1
                 name employee
                 nullable false
                 remarks 
                 size 10
                 type int4
                 typeCode 4
        Column: startdate
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 2
                 name startdate
                 nullable false
                 remarks 
                 size 13
                 type date
                 typeCode 91
        Column: enddate
                 autoUpdated false
                 defaultValue null
                 digits 0
                 id 3
                 name enddate
                 nullable false
                 remarks 
                 size 13
                 type date
                 typeCode 91
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>lxml - XML and HTML with Python<br />
<a href="https://lxml.de/index.html">https://lxml.de/index.html</a>
</li>

<li>lxml FAQ - Frequently Asked Questions<br />
<a href="https://lxml.de/FAQ.html">https://lxml.de/FAQ.html</a>
</li>

<li>Knihovna lxml na PyPi<br />
<a href="https://pypi.org/project/lxml/">https://pypi.org/project/lxml/</a>
</li>

<li>ElementTree and lxml<br />
<a href="https://wiki.python.org/moin/Tutorials%20on%20XML%20processing%20with%20Python">https://wiki.python.org/moin/Tutorials%20on%20XML%20processing%20with%20Python</a>
</li>

<li>ElementTree Overview<br />
<a href="http://effbot.org/zone/element-index.htm">http://effbot.org/zone/element-index.htm</a>
</li>

<li>Elements and Element Trees<br />
<a href="http://effbot.org/zone/element.htm">http://effbot.org/zone/element.htm</a>
</li>

<li>Python XML processing with lxml<br />
<a href="http://infohost.nmt.edu/tcc/help/pubs/pylxml/web/index.html">http://infohost.nmt.edu/tcc/help/pubs/pylxml/web/index.html</a>
</li>

<li>Dive into Python 3: XML<br />
<a href="http://www.diveintopython3.net/xml.html">http://www.diveintopython3.net/xml.html</a>
</li>

<li>XML Tutorial na zvon.org<br />
<a href="http://www.zvon.org/comp/r/tut-XML.html">http://www.zvon.org/comp/r/tut-XML.html</a>
</li>

<li>Extensible Markup Language (XML) 1.0 (Fifth Edition)<br />
<a href="https://www.w3.org/TR/REC-xml/">https://www.w3.org/TR/REC-xml/</a>
</li>

<li>XML Processing Modules (pro Python)<br />
<a href="https://docs.python.org/3/library/xml.html">https://docs.python.org/3/library/xml.html</a>
</li>

<a href="https://en.wikipedia.org/wiki/XML">https://en.wikipedia.org/wiki/XML</a>
</li>

<li>Extensible Markup Language<br />
<a href="https://cs.wikipedia.org/wiki/Extensible_Markup_Language">https://cs.wikipedia.org/wiki/Extensible_Markup_Language</a>
</li>

<li>Slabikář XML – odkazy<br />
<a href="https://www.interval.cz/clanky/slabikar-xml-odkazy/">https://www.interval.cz/clanky/slabikar-xml-odkazy/</a>
</li>

<li>XML editors<br />
<a href="http://www.xml-dev.com/">http://www.xml-dev.com/</a>
</li>

<li>lxml FAQ - Frequently Asked Questions<br />
<a href="https://lxml.de/FAQ.html">https://lxml.de/FAQ.html</a>
</li>

<li>XML pro začátečníky - 1. část<br />
<a href="http://programujte.com/clanek/2007030501-xml-pro-zacatecniky-1-cast/">http://programujte.com/clanek/2007030501-xml-pro-zacatecniky-1-cast/</a>
</li>

<li>XML pro web aneb od teorie k praxi, 2.díl<br />
<a href="https://www.zive.cz/clanky/xml-pro-web-aneb-od-teorie-k-praxi-2dil/sc-3-a-109709/default.aspx">https://www.zive.cz/clanky/xml-pro-web-aneb-od-teorie-k-praxi-2dil/sc-3-a-109709/default.aspx</a>
</li>

<li>XML Schema<br />
<a href="https://cs.wikipedia.org/wiki/XML_Schema">https://cs.wikipedia.org/wiki/XML_Schema</a>
</li>

<li>Meaning of - &lt;?xml version=“1.0” encoding=“utf-8”?&gt;<br />
<a href="https://stackoverflow.com/questions/13743250/meaning-of-xml-version-1-0-encoding-utf-8#27398439">https://stackoverflow.com/questions/13743250/meaning-of-xml-version-1-0-encoding-utf-8#27398439</a>
</li>

<li>Beautiful Soup<br />
<a href="https://www.crummy.com/software/BeautifulSoup/">https://www.crummy.com/software/BeautifulSoup/</a>
</li>

<li>Web scraping<br />
<a href="https://en.wikipedia.org/wiki/Web_scraping">https://en.wikipedia.org/wiki/Web_scraping</a>
</li>

<li>XPath examples<br />
<a href="https://www.w3schools.com/xml/xpath_examples.asp">https://www.w3schools.com/xml/xpath_examples.asp</a>
</li>

<li>XPath Axes<br />
<a href="https://www.w3schools.com/xml/xpath_axes.asp">https://www.w3schools.com/xml/xpath_axes.asp</a>
</li>

<li>Guide to naming conventions on groupId, artifactId, and version<br />
<a href="http://maven.apache.org/guides/mini/guide-naming-conventions.html">http://maven.apache.org/guides/mini/guide-naming-conventions.html</a>
</li>

<li>What is meaning of .// in XPath?<br />
<a href="https://stackoverflow.com/questions/31375091/what-is-meaning-of-in-xpath">https://stackoverflow.com/questions/31375091/what-is-meaning-of-in-xpath</a>
</li>

<li>Using "//" And ".//" Expressions In XPath XML<br />
<a href="https://www.bennadel.com/blog/2142-using-and-expressions-in-xpath-xml-search-directives-in-coldfusion.htm">https://www.bennadel.com/blog/2142-using-and-expressions-in-xpath-xml-search-directives-in-coldfusion.htm</a>
</li>

<li>Using parent dot notation in xpath to find another branch in the XML tree<br />
<a href="https://stackoverflow.com/questions/5370544/using-parent-dot-notation-in-xpath-to-find-another-branch-in-the-xml-tree#5370817">https://stackoverflow.com/questions/5370544/using-parent-dot-notation-in-xpath-to-find-another-branch-in-the-xml-tree#5370817</a>
</li>

<li>xml.sax — Support for SAX2 parsers<br />
<a href="https://docs.python.org/3/library/xml.sax.html">https://docs.python.org/3/library/xml.sax.html</a>
</li>

<li>Well Formed XML<br />
<a href="https://www.w3resource.com/xml/well-formed.php">https://www.w3resource.com/xml/well-formed.php</a>
</li>

<li>XML Tutorial<br />
<a href="https://www.w3resource.com/xml/xml.php">https://www.w3resource.com/xml/xml.php</a>
</li>

<li>Why use JSON over XML?<br />
<a href="https://www.sitepoint.com/json-vs-xml/">https://www.sitepoint.com/json-vs-xml/</a>
</li>

<li>XML and XPath<br />
<a href="https://www.w3schools.com/XML/xml_xpath.asp">https://www.w3schools.com/XML/xml_xpath.asp</a>
</li>

<li>XPath (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/XPath">https://en.wikipedia.org/wiki/XPath</a>
</li>

<li>RFC7159<br />
<a href="https://www.ietf.org/rfc/rfc7159.txt">https://www.ietf.org/rfc/rfc7159.txt</a>
</li>

<li>Python &ndash; XML Processing<br />
<a href="https://www.tutorialspoint.com/python/python_xml_processing.htm">https://www.tutorialspoint.com/python/python_xml_processing.htm</a>
</li>

<li>How to Process XML in Python &ndash; Element Tree Library<br />
<a href="https://www.javatpoint.com/how-to-process-xml-in-python">https://www.javatpoint.com/how-to-process-xml-in-python</a>
</li>

<li>XML Frequently Asked Questions<br />
<a href="http://www.hwg.org/resources/faqs/xmlFAQ.html">http://www.hwg.org/resources/faqs/xmlFAQ.html</a>
</li>

<li>OrderedDict<br />
<a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict">https://docs.python.org/3/library/collections.html#collections.OrderedDict</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

