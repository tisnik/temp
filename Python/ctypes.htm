<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Propojení Pythonu s nativními knihovnami s využitím balíčku ctypes</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Propojení Pythonu s nativními knihovnami s využitím balíčku ctypes</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na těchto stránkách jsme se již několikrát setkali s propojením Pythonu s nativními knihovnami naprogramovanými (například) v C. Použili jsme přitom balíček cffi. Ovšem v některých případech může být užitečné využít namísto toho standardní balíček ctypes.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Propojení Pythonu s&nbsp;nativními knihovnami s&nbsp;využitím balíčku <i>ctypes</i></a></p>
<p><a href="#k02">2. Řešený problém</a></p>
<p><a href="#k03">3. Základní informace o knihovně Pygame</a></p>
<p><a href="#k04">4. Vykreslení jednotlivých pixelů v&nbsp;rastrovém obrázku typu <i>Image</i> v&nbsp;Pythonu</a></p>
<p><a href="#k05">5. Limity předchozího řešení</a></p>
<p><a href="#k06">6. Realizace nativní funkce, která vyplní obrázek jednoduchým testovacím vzorkem</a></p>
<p><a href="#k07">7. Překlad nativní funkce do dynamicky linkované knihovny</a></p>
<p><a href="#k08">8. Zavolání nativní funkce z&nbsp;Pythonu</a></p>
<p><a href="#k09">9. Předání barvové palety do nativní funkce</a></p>
<p><a href="#k10">10. Přednosti propojení Pythonu s&nbsp;jazykem C</a></p>
<p><a href="#k11">11. Výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;jazyce C</a></p>
<p><a href="#k12">12. Zavolání nativních funkci pro výpočet Mandelbrotovy a Juliovy množiny z&nbsp;Pythonu</a></p>
<p><a href="#k13">13. Mandelbrotova množina jako &bdquo;mapa&ldquo; všech Juliových množin</a></p>
<p><a href="#k14">*** 14. Interaktivní určení konstanty <i>c</i> v&nbsp;Mandelbrotově množině</a></p>
<p><a href="#k15">15. Výsledná podoba demonstračního příkladu</a></p>
<p><a href="#k16">16. Buffer sdílený oběma rastrovými obrázky</a></p>
<p><a href="#k17">17. Oprava předchozího postupu: použití dvou bufferů bez kopie pixelů</a></p>
<p><a href="#k18">18. Přístup k&nbsp;pixelům obrázku po 32bitových slovech</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Propojení Pythonu s&nbsp;nativními knihovnami s&nbsp;využitím balíčku <i>ctypes</i></h2>

<p>Na stránkách Roota, konkrétně v&nbsp;článcích [<a
href=https://www.root.cz/clanky/propojeni-pythonu-s-nativnimi-knihovnami-s-vyuzitim-balicku-cffi/"">1</a>]
[<a
href="https://www.root.cz/clanky/propojeni-pythonu-s-nativnimi-knihovnami-s-vyuzitim-balicku-cffi-2/">2</a>]
a [<a
href="https://www.root.cz/clanky/propojeni-pythonu-s-nativnimi-knihovnami-s-vyuzitim-balicku-cffi-3/">3</a>],
jsme se již zabývali problematikou propojení vysokoúrovňového programovacího
jazyka <a href="https://www.root.cz/n/python/">Python</a> s&nbsp;nativními
knihovnami naprogramovanými například v&nbsp;jazyku C (ovšem může se jednat i o
<a
href="https://www.root.cz/clanky/programovaci-jazyk-rust-rozhrani-mezi-rustem-a-pythonem/">Rust</a>,
C++ a pokud si dáme pozor, tak i <a
href="https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes/">Go</a>).
Poměrně jednoduchá je situace, kdy se pouze z&nbsp;Pythonu volají nativní
funkce, kterým se předávají již naalokované objekty. Pro tento účel jsme
v&nbsp;předchozích článcích využili především knihovnu <i>cffi</i> (viz též <a
href="https://cffi.readthedocs.io/en/latest/overview.html">Overview</a>). Dnes
si naproti tomu ukážeme použití standardního balíčku <i>ctypes</i> (viz též <a
href="https://docs.python.org/3/library/ctypes.html">dokumentaci</a>).</p>

<p>Základní postup přitom zůstává stále stejný. Zdrojový kód napsaný
v&nbsp;jazyku C (C++, Rustu, Go, ...) je nejprve přeložen do nativní dynamické
knihovny, tedy konkrétně do souboru s&nbsp;koncovkou &bdquo;.so&ldquo; na
Linuxu a &bdquo;.dll&ldquo; v&nbsp;systému Microsoft Windows. Aplikace psaná
v&nbsp;Pythonu tuto dynamickou knihovnu načte a přes balíček <i>ctypes</i>
umožní volání funkcí naprogramovaných v&nbsp;C/C++ atd. Zpočátku se může zdát,
že se jedná o bezproblémové řešení, ovšem v&nbsp;praxi musíme vyřešit především
dva problémy: vlastnictví předávaných hodnot (tedy která strana alokuje paměť a
která ji může dealokovat) a taktéž korektní předání hodnot různých typů. První
problém musí vyřešit programátor, ovšem druhý problém může &ndash; i když pouze
částečně &ndash; řešit i balíček realizující volání nativních funkcí
z&nbsp;Pythonu. A právě zde nalezneme největší rozdíly mezi <i>ctypes</i>,
<i>cffi</i> i dalšími balíčky určenými pro stejný účel. V&nbsp;tomto ohledu
jsou možnosti <i>ctypes</i> dosti omezené, ovšem jedná se o standardní balíček,
který navíc může pro některé účely plně vyhovovat.</p>

<p><div class="rs-tip-major">Poznámka: název <i>ctypes</i> a vlastně i
<i>cffi</i> evokuje jazyk C. Ovšem jak již bylo napsáno výše, lze nativní část
vytvořit i v&nbsp;jiných jazycích; pouze se v&nbsp;takovém případě dříve či
později setkáme s&nbsp;obtížemi, které v&nbsp;C nenastávají (práce
s&nbsp;objekty, správce paměti v&nbsp;nativní knihovně atd.).</div></p>

<a href="https://www.root.cz/obrazek/1092946/"><img src="https://i.iinfo.cz/images/85/c-prev.png" class="image-1092946" data-prev-filename="https://i.iinfo.cz/images/85/c-prev.png" data-prev-width="192" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/85/c-large.png" data-large-width="374" data-large-height="525" alt="&#160;" title="Autor: Prentice Hall, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="192" height="270" /></a>
<p><i>Obrázek 1: Programovací jazyk C je prozatím ve své nice prakticky
nenahraditelný, i když už vzniklo několik jeho nástupců (Zig, D, částečně
Rust).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Řešený problém</h2>

<p>V&nbsp;rámci navazujících kapitol se pokusíme o vytvoření jednoduché
aplikace, která zobrazí Mandelbrotovu množinu a umožní uživateli interaktivní
výběr souřadnice v&nbsp;této množině (což je komplexní číslo <i>C</i>), které
bude ihned využito při vykreslení Juliovy množiny:</p>

*** image ***
<p><i>Obrázek 2: Výsledná aplikace. Uživatel může v&nbsp;Mandelbrotově množině
(levá část) vybrat hodnotu komplexního čísla C. To se ihned projeví
v&nbsp;pravé části na tvaru Juliovy množiny.</i></p>

*** image ***
<p><i>Obrázek 3: Juliova množina pro odlišnou hodnotu C (reálná část je nulová).</i></p>

*** image ***
<p><i>Obrázek 4: Juliova množina pro odlišnou hodnotu C.</i></p>

*** image ***
<p><i>Obrázek 5: Juliova množina pro odlišnou hodnotu C (imaginární část je nulová).</i></p>

<p>Samotné (minimalisticky pojaté) grafické uživatelské prostředí aplikace bude
naprogramováno s&nbsp;využitím populární knihovny <a
href="https://www.pygame.org/docs/">Pygame</a>, výpočet Mandelbrotovy množiny a
Juliovy množiny bude realizován v&nbsp;ANSI C a pro jednoduchost nebude
algoritmus nijak optimalizován (výsledný nativní kód však je možné
optimalizovat).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní informace o knihovně Pygame</h2>

<p<i>Pygame</i> je knihovna určená pro programovací jazyk Python, která interně
volá funkce nativní knihovny SDL a několika dalších podpůrných knihoven.
Myšlenka, na níž je <i>Pygame</i> postavena, je v&nbsp;mnoha ohledech podobná
myšlence výše systému <i>LÖVE</i> (kde se ovšem používá jazyk Lua) &ndash;
implementace nízkoúrovňových operací nechť je vytvořena odborníky
v&nbsp;programovacích jazycích C a C++; pokud budou tyto operace implementovány
dostatečně rychle, je již možné zbytek hry naprogramovat ve vysokoúrovňovém
jazyku Python. A ukazuje se, že je tato myšlenka &ndash; a obecně systém
rozdělení aplikace mezi dva programovací jazyky (kompilovaný a skriptovací)
&ndash; poměrně úspěšná, neboť v&nbsp;<i>Pygame</i> již vzniklo mnoho
zajímavých her i dalších aplikací.</p>

<img src="https://i.iinfo.cz/images/100/pygame-zero-1-26.png" class="image-417511" alt="&#160;" width="393" height="130" />
<p><i>Obrázek 6: Logo knihovny Pygame.</i></p>

<p>Pro naše účely využijeme jen několik typů objektů knihovny Pygame. Jedná se
o:</p>

<ul>
<li><a href="https://www.pygame.org/docs/ref/display.html">display</a>: objekt představující plochu okna, do něhož se provádí vykreslování celé scény</li>
<li><a href="https://www.pygame.org/docs/ref/event.html">event</a>: událost, která vznikne například při stisku tlačítka myši, pohybem myši, stiskem klávesy, zavřením okna atd.</li>
<li><a href="https://www.pygame.org/docs/ref/image.html">image</a>: objekt s&nbsp;rastrovým obrázkem (s&nbsp;paletou či plnobarevným)</li>
<li><a href="https://www.pygame.org/docs/ref/time.html#pygame.time.Clock">clock</a>: hodiny, které nám umožní například zajistit maximální frekvenci obnovování obsahu okna atd.</li>
</ul>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vykreslení jednotlivých pixelů v&nbsp;rastrovém obrázku typu <i>Image</i> v&nbsp;Pythonu</h2>

<p>S&nbsp;využitím knihovny Pygame nyní vytvoříme jednoduchou aplikaci, která
po svém spuštění otevře okno se zadanými rozměry a vykreslí do něj dvojici
rastrových obrázků s&nbsp;různými barvovými vzorky. První funkce otevře nové
okno, vyplní ho zadanou barvou pozadí a vytvoří objekt typu
&bdquo;hodiny&ldquo; (ten použijeme v&nbsp;pozdějších verzích příkladu):</p>

<pre>
def <strong>initialize_ui</strong>(title, width, height):
    <i>"""Initialize Pygame display, drawing surface, and clocks."""</i>
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
</pre>

<p>Druhá funkce je již komplikovanější. Jedná se o realizaci programové smyčky
reagující na události čtené z&nbsp;fronty. Pokud se uživatel pokusí zavřít okno
aplikace, dojde k&nbsp;vytvoření události typu <strong>QUIT</strong>. A pokud
stiskne klávesu <i>Escape</i>, bude se jednat o událost typu
<strong>KEYDOWN</strong>, přičemž bude nastavený atribut <strong>key</strong>
na kód klávesy <i>Escape</i>. Po zpracování všech událostí vykreslíme na
displej dvojici rastrových obrázků operací <strong>display.blit</strong>,
necháme překreslit displej (resp.&nbsp;obsah okna) a počkáme určitý časový
interval:</p>

<pre>
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
</pre>

<p>Dále je v&nbsp;programu realizována funkce, která do předaného obrázku (typu
<strong>Image</strong>) vykreslí testovací vzorek. Povšimněte si, že musíme
vypočítat hodnotu barvy ze všech tří barvových složek RGB (posunem složek o 8 a
16 bitů) a že se hodnota pixelu nastavuje metodou
<strong>Image.set_at</strong>:</p>

<pre>
def <strong>render_test_rgb_image</strong>(image, green):
    width, height = image.get_size()
    for y in range(height):
        for x in range(width):
            color = (x&lt;&lt;16) + (green&lt;&lt;8) + y
            image.set_at((x, y), color)
</pre>

<p>A nakonec následuje inicializace okna, obrázků a vstup do těla smyčky pro
zpracování událostí:</p>

<pre>
def <strong>main</strong>():
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
    image1 = pygame.Surface([IMAGE_WIDTH, IMAGE_HEIGHT])
    image2 = pygame.Surface([IMAGE_WIDTH, IMAGE_HEIGHT])
&nbsp;
    render_test_rgb_image(image1, 0)
    render_test_rgb_image(image2, 255)
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
</pre>

<p>Úplný zdrojový kód bude vypadat následovně:</p>

<pre>
import sys
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Raster image"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    <i>"""Initialize Pygame display, drawing surface, and clocks."""</i>
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>render_test_rgb_image</strong>(image, green):
    width, height = image.get_size()
    for y in range(height):
        for x in range(width):
            color = (x&lt;&lt;16) + (green&lt;&lt;8) + y
            image.set_at((x, y), color)
&nbsp;
&nbsp;
def <strong>main</strong>():
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
    image1 = pygame.Surface([IMAGE_WIDTH, IMAGE_HEIGHT])
    image2 = pygame.Surface([IMAGE_WIDTH, IMAGE_HEIGHT])
&nbsp;
    render_test_rgb_image(image1, 0)
    render_test_rgb_image(image2, 255)
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
# finito
</pre>

<p>Po spuštění této funkce by se mělo na desktopu zobrazit nové okno
s&nbsp;následujícím obsahem:</p>

*** image ***
<p><i>Obrázek 7: Okno s&nbsp;dvojicí testovacích rastrových obrázků.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Limity předchozího řešení</h2>

<p>Dnešní první demonstrační příklad, který byl popsán <a
href="#k04">v&nbsp;předchozí kapitole</a>, je sice plně funkční, ovšem má jednu
vadu &ndash; samotné vykreslování (resp.&nbsp;přesněji řečeno obarvování)
pixelů přímo v&nbsp;Pythonu metodou <strong>set_at</strong> je velmi pomalé. Je
tomu tak z&nbsp;toho důvodu, že je neustále nutné počítat adresu pixelu (i když
obrázek vykreslujeme postupně po pixelech a potom po řádcích) a taktéž samotný
výpočet barvy je pomalejší. A navíc je většinou (interně) nutné pole
s&nbsp;rastrovými daty (tedy s&nbsp;jednotlivými pixely) zamykat. Pro naše
relativně malé obrázky je sice vykreslení na moderním HW dostatečně rychlé, ale
ukážeme si řešení založené na nativní funkci naprogramované v&nbsp;céčku. Toto
řešení má výhodu v&nbsp;tom, že je velmi snadno rozšiřitelné i pro účely
výpočtu Mandelbrotovy množiny a Juliovy množiny (množin).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Realizace nativní funkce, která vyplní obrázek jednoduchým testovacím vzorkem</h2>

<p>Nyní se podívejme na to, jakým způsobem by mohla být vytvořena funkce
naprogramovaná v&nbsp;jazyku C, které se předá ukazatel na data rastrového
obrázku společně s&nbsp;rozměry tohoto obrázku. Funkce následně obrázek vyplní
testovacím vzorkem. Budeme předpokládat, že každý pixel obrázku je uložen ve
čtyřech po sobě jdoucích bajtech (viz předchozí kapitolu) a že mezi
jednotlivými obrazovými řádky nejsou žádné vyplňovací bajty (což by souviselo
s&nbsp;hodnotou <i>stride</i>). Za těchto podmínek je vyplnění rastrového
obrázku RGB vzorkem velmi jednoduché, což ostatně můžeme vidět i
z&nbsp;realizace této funkce. Povšimněte si především toho, že pixel je
skutečně uložen ve čtyřech bajtech, jeden bajt však není použit (je při zápisu
zcela přeskočen):</p>

<pre>
void <strong>render_test_rgb_image</strong>(unsigned int width, unsigned int height,
                           unsigned char *pixels, unsigned char green) {
    unsigned int i, j;
    unsigned char *p = pixels;
&nbsp;
    for (j = 0; j &lt; height; j++) {
        for (i = 0; i &lt; width; i++) {
            *p++ = i;
            *p++ = green;
            *p++ = j;
            p++;
        }
    }
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad nativní funkce do dynamicky linkované knihovny</h2>

<p>Zdrojový kód s&nbsp;touto funkcí musíme přeložit tak, aby vznikla dynamicky
linkovaná knihovna (.so, .dll). Pro operační systém Linux bude příslušný
<strong>Makefile</strong> soubor realizující překlad vypadat v&nbsp;té
nejjednodušší podobě následovně:</p>

<pre>
.PHONY: all clean
&nbsp;
CC=gcc
CFLAGS=-Wall -pedantic -ansi
&nbsp;
all: renderer.so
&nbsp;
clean:
        rm -f renderer.so
&nbsp;
renderer.so:    renderer.c
        $(CC) $(CFLAGS) -shared -Wl,-soname,renderer -o $@ -fPIC $&lt;
</pre>

<p>Překlad s&nbsp;následným vytvořením dynamicky linkované knihovny provedeme
příkazem:</p>

<pre>
$ <strong>make</strong>
</pre>

<p>Překladem by měl vzniknout soubor <strong>renderer.so</strong>, v&nbsp;němž
mj.&nbsp;najdeme i naši funkci <strong>render_test_rgb_image</strong>:</p>

<pre>
$ <strong>nm renderer.so </strong>
&nbsp;
0000000000004008 b completed.0
                 w __cxa_finalize@GLIBC_2.2.5
0000000000001040 t deregister_tm_clones
00000000000010b0 t __do_global_dtors_aux
0000000000003de8 d __do_global_dtors_aux_fini_array_entry
0000000000003df0 d __dso_handle
0000000000003df8 d _DYNAMIC
000000000000117c t _fini
00000000000010f0 t frame_dummy
0000000000003de0 d __frame_dummy_init_array_entry
0000000000002080 r __FRAME_END__
0000000000003fe8 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
0000000000002000 r __GNU_EH_FRAME_HDR
0000000000001000 t _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
0000000000001070 t register_tm_clones
<strong>00000000000010f9 T render_test_rgb_image</strong>
0000000000004008 d __TMC_END__
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zavolání nativní funkce z&nbsp;Pythonu</h2>

<p>Otestujme si nyní, jak lze nativní funkci <a href="#k07">z&nbsp;předchozí
kapitoly</a> zavolat z&nbsp;Pythonu. Nejdříve musíme načíst dynamicky
linkovanou knihovnu, což zajistí tyto řádky:</p>

<pre>
from ctypes import CDLL
&nbsp;
renderer = CDLL("./renderer.so")
</pre>

<p>Následně si necháme (přímo v&nbsp;Pythonu) naalokovat buffer o takové
velikosti, aby do něj bylo možné uložit všechny pixely obrázku. Každý pixel je
uložen ve čtyřech bajtech, takže velikost bude rovna <strong>4 * IMAGE_WIDTH *
IMAGE_HEIGHT</strong>. Pro alokaci bufferu použijeme funkci
<strong>create_string_buffer</strong>, která však (i přes své jméno) akceptuje
velikost v&nbsp;bajtech:</p>

<pre>
from ctypes import create_string_buffer
&nbsp;
buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
</pre>

<p>Nyní již můžeme naši nativní funkci zavolat a předat jí rozměry obrázku i
právě naalokovaný buffer:</p>

<pre>
from ctypes import c_int
&nbsp;
renderer.render_test_rgb_image(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), buffer, 0)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak se předají
celočíselné parametry přes pomocnou funkci <strong>c_int</strong>.</div></p>

<p>Nakonec musíme hodnoty pixelů z&nbsp;bufferu převést na obrázek,
k&nbsp;čemuž slouží funkce <strong>pygame.image.frombytes</strong>. Ta kromě
bufferu s&nbsp;hodnotami pixelů potřebuje znát i velikost obrázku (předává se
formou dvojice) a jeho formát (pro naše účely RGBX):</p>

<pre>
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
</pre>

<p>Úplný zdrojový kód takto upraveného demonstračního příkladu vypadá
následovně:</p>

<pre>
import sys
from ctypes import CDLL, c_int, create_string_buffer
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    """Initialize Pygame display, drawing surface, and clocks."""
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
def <strong>main</strong>():
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    <i># try to load dynamically linked library</i>
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    renderer.render_test_rgb_image(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), buffer, 0)
    image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    renderer.render_test_rgb_image(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), buffer, 255)
    image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
# finito
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Předání barvové palety do nativní funkce</h2>

<p>V&nbsp;dalším kroku se pokusíme o předání barvové palety do nativní funkce.
Barvová paleta bude obsahovat 256 barev, přičemž každá barva je reprezentována
třemi bajty &ndash; každý bajt totiž obsahuje hodnotu jedné barvové složky
<i>red</i>, <i>green</i> nebo <i>blue</i>. Celkem je tedy nutné do nativní
funkce předat 256&times;3 = 768 bajtů. Ovšem vzhledem k&nbsp;tomu, že barvová
paleta nebude ve funkci měněna, můžeme ji předat ukazatelem, což znamená, že
namísto 768 bajtů se předají čtyři bajty nebo osm bajtů (podle šířky
ukazatele).</p>

<p>Připomeňme si, že původní nativní funkce určená pro vykreslení testovacího
vzorku do rastrového obrázku vypadala následovně:</p>

<pre>
void <strong>render_test_rgb_image</strong>(unsigned int width, unsigned int height,
                           unsigned char *pixels, unsigned char green) {
    unsigned int i, j;
    unsigned char *p = pixels;
&nbsp;
    for (j = 0; j &lt; height; j++) {
        for (i = 0; i &lt; width; i++) {
            *p++ = i;
            *p++ = green;
            *p++ = j;
            p++;
        }
    }
}
</pre>

<p>Tato funkce nepoužívala barvovou paletu pro přepočet nějaké celočíselné
hodnoty na barvu z&nbsp;palety. Provedeme tedy následující úpravy:</p>

<ol>
<li>Funkce bude nově akceptovat ukazatel na první barvu v&nbsp;barvové paletě</li>
<li>Namísto přímého výpočtu složek R, G, B použijeme barvovou paletu ve funkci LUT (<i>look-up table</i>)</li>
</ol>

<p>Pro jednoduchost odvodíme index barvy pixelu pouze z&nbsp;jeho x-ové složky.
Výsledná funkce bude vypadat následovně:</p>

<pre>
void <strong>render_test_palette_image</strong>(unsigned int width, unsigned int height,
                               const unsigned char *palette,
                               unsigned char *pixels) {
    unsigned int i, j;
    unsigned char *p = pixels;
&nbsp;
    for (j = 0; j &lt; height; j++) {
        for (i = 0; i &lt; width; i++) {
            int color = i * 3;
            *p++ = palette[color];
            *p++ = palette[color + 1];
            *p++ = palette[color + 2];
            p++;
        }
    }
}
</pre>

<p>Výsledkem by měl obrázek z&nbsp;pravé části screenshotu:</p>

*** image ***
<p><i>Obrázek 8: Pravý obrázek je vykreslen s&nbsp;využitím barvové palety.</i></p>

<p>Upravená Pythonní část, která bude volat výše uvedenou funkci, bude vypadat
následovně:</p>

<pre>
import sys
from ctypes import CDLL, c_int, create_string_buffer
&nbsp;
from palette_mandmap import palette
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    """Initialize Pygame display, drawing surface, and clocks."""
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>palette_to_buffer</strong>(p):
    s = create_string_buffer(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
def <strong>main</strong>():
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    <i># try to load dynamically linked library</i>
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    renderer.render_test_rgb_image(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), buffer, 0)
    image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    renderer.render_test_palette_image(
        c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer
    )
    image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
# finito
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Přednosti propojení Pythonu s&nbsp;jazykem C</h2>

<p>Propojení programovacího jazyka Python s&nbsp;jazykem C
(popř.&nbsp;s&nbsp;Rustem nebo jazykem Zig) přináší zajímavé možnosti.
V&nbsp;první řadě to umožňuje relativně snadné volání funkcí ze systémových
knihoven, ale i dalších funkcí dostupných formou dynamicky sdílených knihoven.
Díky tomu lze spojit snadnost tvorby aplikací v&nbsp;Pythonu (vysokoúrovňový
jazyk s&nbsp;relativně velkou mírou abstrakce) s&nbsp;optimalizovaným nativním
kódem. Dobrým příkladem takového propojení je projekt <i>Numpy</i>, v&nbsp;němž
se výpočetně náročné části realizují nativními funkcemi. A příkladem propojení
Pythonu s&nbsp;Rustem může být projekt <i>Polars</i>, se kterým jsme se na
stránkách Roota taktéž již setkali v&nbsp;článcích <a
href="https://www.root.cz/clanky/knihovna-polars-vykonnejsi-alternativa-ke-knihovne-pandas/">Knihovna
Polars: výkonnější alternativa ke knihovně Pandas</a> a <a
href="https://www.root.cz/clanky/knihovna-polars-vykonnejsi-alternativa-ke-knihovne-pandas-datove-ramce/">Knihovna
Polars: výkonnější alternativa ke knihovně Pandas (datové rámce)</a>.</p>

<p>Již v&nbsp;několika předchozích článcích o Pythonu [<a
href="https://www.root.cz/clanky/interpret-pythonu-bez-gilu-vyplati-se-odstraneni-velkeho-zamku/">1</a>]
[<a
href="https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/">2</a>]
[<a
href="https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu-2/">3</a>]
jsme pro některé benchmarky použili výpočet Mandelbrotovy množiny. Dnes si
tento výpočet, doplněný navíc o výpočet Juliovy množiny, převedeme do céčka,
čímž bychom měli dosáhnout menšího času výpočtu v&nbsp;porovnání s&nbsp;řešením
v&nbsp;Pythonu (za předpokladu, že se nevyužije více jader mikroprocesoru).</p>

<p><div class="rs-tip-major">Poznámka: nejvíce bezbolestné propojení zajistíme
tak, že se o alokace a (automatické) dealokace paměti bude starat interpret
Pythonu. Pokud bude jak pythonní kód, tak i kód psaný v&nbsp;jazyce C, alokovat
paměť svými prostředky bude výsledek poměrně špatně odladitelný.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;jazyce C</h2>

<p>V&nbsp;rámci této kapitoly si přepíšeme funkce pro výpočet Mandelbrotovy
množiny a Juliovy množiny z&nbsp;Pythonu do programovacího jazyka C (pro větší
zajímavost do ANSI C, takže nepoužijeme typ <i>komplexní číslo</i>).
V&nbsp;Pythonu lze oba výpočty realizovat velmi snadno:</p>

<pre>
def <strong>mandelbrot</strong>(cx, cy, maxiter):
    <i>"""Calculate number of iterations for given complex number to escape from set."""</i>
    c = complex(cx, cy)
    z = 0
    for i in range(0, maxiter):
        if abs(z) &lt; 2:
            return i
        z = z * z + c
    return 0
&nbsp;
&nbsp;
def <strong>recalc_mandelbrot</strong>(image, palette, xmin, ymin, xmax, ymax, maxiter=100):
    <i>"""Recalculate the whole fractal and render the set into given image."""</i>
    width, height = image.get_size()  # rozmery obrazku
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height
&nbsp;
    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            i = mandelbrot(x1, y1, maxiter)
            i = 3 * i % 256
            color = palette[i][2] + (palette[i][1] &lt;&lt; 8) + (palette[i][0] &lt;&lt; 16)
            image.set_at((x, y), color)
            x1 += stepx
        y1 += stepy
&nbsp;
&nbsp;
def <strong>julia</strong>(zx0, zy0, cx, cy, maxiter):
    <i>"""Calculate number of iterations for given complex numbers Z and C to escape from set."""</i>
    c = complex(cx, cy)
    z = complex(zx0, zy0)
    for i in range(0, maxiter):
        if abs(z) &gt; 2:
            return i
        z = z * z + c
    return 0
&nbsp;
&nbsp;
def <strong>recalc_julia</strong>(image, palette, xmin, ymin, xmax, ymax, cx, cy, maxiter=1000):
    <i>"""Recalculate the whole fractal and render the set into given image."""</i>
    width, height = image.get_size()  # rozmery obrazku
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height
&nbsp;
    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            i = julia(x1, y1, cx, cy, maxiter)
            i = 3 * i % 256
            color = palette[i][2] + (palette[i][1] &lt;&lt; 8) + (palette[i][0] &lt;&lt; 16)
            image.set_at((x, y), color)
            x1 += stepx
        y1 += stepy
</pre>

<p>Výše uvedené výpočty budou velmi pomalé, zejména při použití standardního
CPythonu. Příslušné funkce přepsané do programovacího jazyka C současně provádí
i vykreslení s&nbsp;využitím předané barvové palety, tedy podobně, jako tomu
bylo v&nbsp;Pythonu:</p>

<pre>
void <strong>render_mandelbrot</strong>(unsigned int width, unsigned int height,
                       const unsigned char *palette, unsigned char *pixels) {
    int x, y;
    double cx, cy;
    double xmin = -2.0, ymin = -1.5, xmax = 1.0, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    cy = ymin;
    for (y = 0; y &lt; height; y++) {
        cx = xmin;
        for (x = 0; x &lt; width; x++) {
            double zx = 0.0;
            double zy = 0.0;
            unsigned int i = 0;
            while (i &lt; 150) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            {
                unsigned char * pal = (unsigned char *)palette + (unsigned char)(i * 3);
&nbsp;
                *p++ = *pal++;
                *p++ = *pal++;
                *p++ = *pal;
                p++;
            }
            cx += (xmax - xmin) / width;
        }
        cy += (ymax - ymin) / height;
    }
}

void <strong>render_julia</strong>(unsigned int width, unsigned int height,
                  const unsigned char *palette, unsigned char *pixels,
                  double cx, double cy) {
    int x, y;
    double zx0, zy0;
    double xmin = -1.5, ymin = -1.5, xmax = 1.5, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    zy0 = ymin;
    for (y = 0; y &lt; height; y++) {
        zx0 = xmin;
        for (x = 0; x &lt; width; x++) {
            double zx = zx0;
            double zy = zy0;
            unsigned int i = 0;
            while (i &lt; 150) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            {
                unsigned char * pal = (unsigned char *)palette + (unsigned char)(i * 3);
&nbsp;
                *p++ = *pal++;
                *p++ = *pal++;
                *p++ = *pal;
                p++;
            }
            zx0 += (xmax - xmin) / width;
        }
        zy0 += (ymax - ymin) / height;
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: tento kód je nepatrně delší než obdobný
kód v&nbsp;Pythonu, protože výpočty s&nbsp;komplexními čísly byly přepsány do
explicitních výpočtů se složkami komplexních čísel (reálná, imaginární).
Nicméně rychlost výpočtů je pochopitelně mnohem vyšší.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zavolání nativních funkci pro výpočet Mandelbrotovy a Juliovy množiny z&nbsp;Pythonu</h2>

<p>Volání funkcí pro výpočet Mandelbrotovy a Juliovy množiny, které byly
vypsány <a href="#k11">v&nbsp;předchozí kapitole</a>, lze v&nbsp;Pythonu
realizovat poměrně snadno. Je zde ovšem novinka &ndash; předání komplexní
konstanty <i>c</i> do funkce pro výpočet Juliovy množiny vyžaduje použití
<strong>c_double</strong>, což je opět funkce definovaná v&nbsp;knihovně
<strong>ctypes</strong>. Načtení dynamicky linkované knihovny, vytvoření
pomocného bufferu a zavolání funkcí pro výpočet obou fraktálů může vypadat
následovně:</p>

<pre>
<i># try to load dynamically linked library</i>
renderer = CDLL("./renderer.so")
&nbsp;
<i># create buffer for raster image</i>
buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
renderer.render_mandelbrot(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer)
image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
renderer.render_julia(
    c_int(IMAGE_WIDTH),
    c_int(IMAGE_HEIGHT),
    pal,
    buffer,
    c_double(0.285),
    c_double(0.01),
)
image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
</pre>

*** image ***
<p><i>Obrázek 9: Výsledek výpočtu Mandelbrotovy a Juliovy množiny.</i></p>

<p>A takto bude vypadat úplný zdrojový kód upraveného demonstračního příkladu
(resp.&nbsp;přesněji řečeno jeho Pythonovská část):</p>

<pre>
import sys
from ctypes import CDLL, c_double, c_int, create_string_buffer
&nbsp;
from palette_mandmap import palette
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    """Initialize Pygame display, drawing surface, and clocks."""
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>palette_to_buffer</strong>(p):
    s = create_string_buffer(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
def <strong>main</strong>():
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    <i># try to load dynamically linked library</i>
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    renderer.render_mandelbrot(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer)
    image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    renderer.render_julia(
        c_int(IMAGE_WIDTH),
        c_int(IMAGE_HEIGHT),
        pal,
        buffer,
        c_double(0.285),
        c_double(0.01),
    )
    image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
# finito
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Mandelbrotova množina jako &bdquo;mapa&ldquo; všech Juliových množin</h2>

<p>Juliových množin existuje nekonečné množství. Liší se od sebe hodnotou
<i>c</i>, která je použita při výpočtu bodů ležících uvnitř množiny (do nativní
funkce jsme předávali reálnou a imaginární složku odděleně, a to
v&nbsp;parametrech <strong>cx</strong> a <strong>cy</strong>). Juliovy množiny
lze v&nbsp; závislosti na hodnotě c rozdělit na tři typy:</p>

<ol>

<li>Pro některé hodnoty <i>c</i> tvoří body ležící v&nbsp;Juliově množině
spojitou oblast. To znamená, že každé dva body v&nbsp;takovéto Juliově množině
je možné navzájem spojit určitou křivkou tak, že celá křivka leží uvnitř
Juliovy množiny. Tato oblast je vždy jedna, neexistují tedy například navzájem
izolované &bdquo;ostrovy&ldquo;.</li>

<li>Pro jiné hodnoty <i>c</i> jsou jednotlivé body tvořící Juliovu množinu
zcela izolovány, tj.&nbsp;v&nbsp;jejich okolí neexistuje další bod, který by
ležel v&nbsp;Juliově množině. Taková &bdquo;rozložená&ldquo; Juliova množina se
nazývá Fatouův prach (<i>Fatou dust</i>) nebo také Cantorův prach (<i>Cantor
dust</i>).</li>

<li>Třetí možnost leží na hranici obou předchozích. Body ležící uvnitř Juliovy
množiny sice nejsou vzájemně izolovány, ale současně netvoří žádnou plochu
(body na úsečce také nejsou izolovány, ale úsečka má nulovou plochu).</li>

</ol>

<p>Vztah mezi hodnotou komplexní konstanty <i>c</i> a typem Juliovy množiny je
velmi složitý a při jeho detailním zkoumání byla nalezena &bdquo;mapa&ldquo;
všech Juliových množin &ndash; je jí již dnes několikrát zmíněná Mandelbrotova
množina. Body ležící uvnitř Mandelbrotovy množiny představují komplexní hodnoty
<i>c</i>, pro které je příslušná Juliova množina spojitá (a naopak). To tedy
vlastně znamená, že můžeme interaktivně měnit bod uvnitř Mandelbrotovy množiny
a vykreslit pro něj odpovídající Juliovu množinu. A právě tento interaktivní
postup je uplatněn v&nbsp;dalším demonstračním příkladu.</p>

*** image ***
<p><i>Obrázek 10: Spojitá Juliova množina (pravý obrázek).</i></p>

*** image ***
<p><i>Obrázek 11: Nespojitá Juliova množina.</i></p>

*** image ***
<p><i>Obrázek 12: Hraniční případ.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Interaktivní určení konstanty <i>c</i> v&nbsp;Mandelbrotově množině</h2>

<p>Jak ale vůbec </p>

<pre>
first_draw = False
scale_x = (XMAX - XMIN) / image1.get_width()
scale_y = (YMAX - YMIN) / image1.get_height()
&nbsp;
cx = cx_scr * scale_x + XMIN
cy = cy_scr * scale_x + YMIN
</pre>

<p></p>

<pre>
cx_scr += cx_scr_delta
cy_scr += cy_scr_delta
</pre>

<p></p>

<pre>
if event.type == pygame.locals.KEYDOWN:
    if event.key == pygame.locals.K_ESCAPE:
        pygame.quit()
        sys.exit()
    if event.key == pygame.locals.K_RETURN:
        pygame.quit()
        sys.exit()
    if event.key == pygame.locals.K_LEFT:
        cx_scr_delta = -1
    if event.key == pygame.locals.K_RIGHT:
        cx_scr_delta = 1
    if event.key == pygame.locals.K_UP:
        cy_scr_delta = -1
    if event.key == pygame.locals.K_DOWN:
        cy_scr_delta = 1
</pre>

<p>Po puštění klávesy pochopitelně musíme pohyb zastavit. Opět vše
naprogramujeme takovým způsobem, aby byl možný i diagonální pohyb a zastavení
tohoto pohybu. Budeme tedy každou kurzorovou klávesu řešit samostatně:</p>

<pre>
if event.type == pygame.locals.KEYUP:
    if event.key == pygame.locals.K_LEFT:
        cx_scr_delta = 0
    if event.key == pygame.locals.K_RIGHT:
        cx_scr_delta = 0
    if event.key == pygame.locals.K_UP:
        cy_scr_delta = 0
    if event.key == pygame.locals.K_DOWN:
        cy_scr_delta = 0
</pre>

<p>V&nbsp;posledním kroku do plochy prvního obrázku (což je Mandelbrotova
množina) vykreslíme &bdquo;záměrný kříž&ldquo;, který ukazuje pozici hodnoty
<i>c</i> v&nbsp;komplexní rovině:</p>

<pre>
pygame.draw.line(
    display,
    WHITE,
    (XSTART + cx_scr, YSTART),
    (XSTART + cx_scr, YSTART + image1.get_height() - 1),
)
pygame.draw.line(
    display,
    WHITE,
    (XSTART, YSTART + cy_scr),
    (XSTART + image1.get_width() - 1, YSTART + cy_scr),
)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výsledná podoba demonstračního příkladu</h2>

<p>Demonstrační příklad upravený tak, že umožňuje interaktivní změnu konstanty
<i>c</i>, vypadá následovně (resp.&nbsp;přesněji řečeno je uveden kód
v&nbsp;Pythonu, zatímco výpočet obou množin v&nbsp;céčkové funkci zůstal zcela
nezměněn):</p>

<pre>
import sys
from ctypes import CDLL, c_double, c_int, create_string_buffer
&nbsp;
from palette_mandmap import palette
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
<i># Mandelbrot fractal parameters</i>
XMIN = -2.0
XMAX = 1.0
YMIN = -1.5
YMAX = 1.5
MAXITER = 100
&nbsp;
XSTART = 30
YSTART = 20
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    """Initialize Pygame display, drawing surface, and clocks."""
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock, pal, renderer, buffer):
    cx_scr = image1.get_width() / 2 - 1 + 32
    cy_scr = image1.get_width() / 2 - 1 - 42 * 2
    cx_scr_delta = 0
    cy_scr_delta = 0
    first_draw = True
&nbsp;
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                if event.key == pygame.locals.K_RETURN:
                    pygame.quit()
                    sys.exit()
                if event.key == pygame.locals.K_LEFT:
                    cx_scr_delta = -1
                if event.key == pygame.locals.K_RIGHT:
                    cx_scr_delta = 1
                if event.key == pygame.locals.K_UP:
                    cy_scr_delta = -1
                if event.key == pygame.locals.K_DOWN:
                    cy_scr_delta = 1
            if event.type == pygame.locals.KEYUP:
                if event.key == pygame.locals.K_LEFT:
                    cx_scr_delta = 0
                if event.key == pygame.locals.K_RIGHT:
                    cx_scr_delta = 0
                if event.key == pygame.locals.K_UP:
                    cy_scr_delta = 0
                if event.key == pygame.locals.K_DOWN:
                    cy_scr_delta = 0
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
&nbsp;
        <i># keep moving C</i>
        cx_scr += cx_scr_delta
        cy_scr += cy_scr_delta
&nbsp;
        <i># check for limits</i>
        if cx_scr &lt; 0:
            cx_scr = 0
        if cx_scr &gt; image1.get_width() - 1:
            cx_scr = image1.get_width() - 1
        if cy_scr &lt; 0:
            cy_scr = 0
        if cy_scr &gt; image1.get_height() - 1:
            cy_scr = image1.get_height() - 1
&nbsp;
        <i># recalculate Julia set if needed</i>
        if cx_scr_delta != 0 or cy_scr_delta != 0 or first_draw:
            first_draw = False
            scale_x = (XMAX - XMIN) / image1.get_width()
            scale_y = (YMAX - YMIN) / image1.get_height()
&nbsp;
            cx = cx_scr * scale_x + XMIN
            cy = cy_scr * scale_x + YMIN
&nbsp;
            renderer.render_julia(
                c_int(IMAGE_WIDTH),
                c_int(IMAGE_HEIGHT),
                pal,
                buffer,
                c_double(cx),
                c_double(cy),
            )
            image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
        <i># display Mandelbrot set and Julia se</i>
        display.blit(image1, (XSTART, YSTART))
        display.blit(image2, (60 + image1.get_width(), YSTART))
&nbsp;
        <i># display C coordinates</i>
        WHITE = (255, 255, 255)
        pygame.draw.line(
            display,
            WHITE,
            (XSTART + cx_scr, YSTART),
            (XSTART + cx_scr, YSTART + image1.get_height() - 1),
        )
        pygame.draw.line(
            display,
            WHITE,
            (XSTART, YSTART + cy_scr),
            (XSTART + image1.get_width() - 1, YSTART + cy_scr),
        )
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>palette_to_buffer</strong>(p):
    s = create_string_buffer(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
def <strong>main</strong>():
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    renderer.render_mandelbrot(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer)
    image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    image2 = pygame.Surface([IMAGE_WIDTH, IMAGE_HEIGHT])
&nbsp;
    event_loop(display, image1, image2, clock, pal, renderer, buffer)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
# finito
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Buffer sdílený oběma rastrovými obrázky</h2>

<p>V&nbsp;předchozích demonstračních příkladech jsme buffer s&nbsp;pixely
vybarvenými nativní funkcí přenesli do rastrového obrázku s&nbsp;využitím této
pomocné funkce:</p>

<pre>
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
</pre>

<p>Tato funkce ve skutečnosti provedla kopii všech pixelů, což může být časově
náročnější operace (u našich malých obrázků nikoli, ale u větších scén již
ano). Proto se nabízí otázka, zda namísto toho nevyužít funkci
<strong>pygame.image.frombytes</strong>, která kopii pixelů neprovádí. Upravme
tedy zdrojový kód našeho příkladu do následující podoby (ukazuji jen změněné
části):</p>

<pre>
import pygame
import pygame.image as image
import pygame.locals
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock, pal, renderer, buffer):
&nbsp;
    ...
    ...
    ...
            renderer.render_julia(
                c_int(IMAGE_WIDTH),
                c_int(IMAGE_HEIGHT),
                pal,
                buffer,
                c_double(cx),
                c_double(cy),
            )
            <strong>image2 = image.frombuffer(buffer, (IMAGE_WIDTH, IMAGE_HEIGHT), "RGBX")</strong>
    ...
    ...
    ...
&nbsp;
&nbsp;
def <strong>main</strong>():
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    renderer.render_mandelbrot(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer)
    image1 = <strong>image.frombuffer(buffer, (IMAGE_WIDTH, IMAGE_HEIGHT), "RGBX")</strong>
&nbsp;
    image2 = <strong>pygame.Surface([IMAGE_WIDTH, IMAGE_HEIGHT])</strong>
&nbsp;
    event_loop(display, image1, image2, clock, pal, renderer, buffer)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
</pre>

<p>Po spuštění takto upraveného příkladu je patrné, že je buffer skutečně
sdílen mezi oběma obrázky a že tedy původní Mandelbrotova množina byla již
v&nbsp;prvním snímku překreslena Juliovou množinou:</p>

*** image ***
<p><i>Obrázek 13: Výsledek použití sdíleného bufferu pro oba rastrové obrázky.</i></p>

*** image ***
<p><i>Obrázek 14: Výsledek použití sdíleného bufferu pro oba rastrové obrázky.</i></p>

*** image ***
<p><i>Obrázek 15: Výsledek použití sdíleného bufferu pro oba rastrové obrázky.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Oprava předchozího postupu: použití dvou bufferů bez kopie pixelů</h2>

<p>Ve skutečnosti pochopitelně stále můžeme využít rychlejší vykreslování bez
opakované kopie pixelů. Musíme provést jen jedinou změnu &ndash; pro každý
obrázek (tedy v&nbsp;našem případě pro obrázek Mandelbrotovy množiny a pro
obrázek množiny Juliovy) je nutné alokovat a následně i použít vlastní buffer.
Změn ve zdrojovém kódu je zapotřebí provést jen několik, což je ostatně patrné
i z&nbsp;následujícího výpisu (změny jsou zde zvýrazněny):</p>

<pre>
def <strong>main</strong>():
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffers for raster image</i>
    <strong>buffer1 = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)</strong>
    <strong>buffer2 = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)</strong>
&nbsp;
    renderer.render_mandelbrot(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer1)
    image1 = image.frombuffer(<strong>buffer1</strong>, (IMAGE_WIDTH, IMAGE_HEIGHT), "RGBX")
&nbsp;
    image2 = pygame.Surface([IMAGE_WIDTH, IMAGE_HEIGHT])
&nbsp;
    event_loop(display, image1, image2, clock, pal, renderer, <strong>buffer2</strong>)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
</pre>

<p>Výsledky získané po spuštění takto upraveného příkladu:</p>

*** image ***
<p><i>Obrázek 16: Výsledek použití unikátního bufferu pro každý rastrový obrázek.</i></p>

*** image ***
<p><i>Obrázek 17: Výsledek použití unikátního bufferu pro každý rastrový obrázek.</i></p>

*** image ***
<p><i>Obrázek 18: Výsledek použití unikátního bufferu pro každý rastrový obrázek.</i></p>

<p>Výsledná podoba zdrojového kódu:</p>

<pre>
import sys
from ctypes import CDLL, c_double, c_int, create_string_buffer
&nbsp;
from palette_mandmap import palette
&nbsp;
import pygame
import pygame.image as image
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
# Mandelbrot fractal parameters
XMIN = -2.0
XMAX = 1.0
YMIN = -1.5
YMAX = 1.5
MAXITER = 100
&nbsp;
XSTART = 30
YSTART = 20
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    """Initialize Pygame display, drawing surface, and clocks."""
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock, pal, renderer, buffer):
    cx_scr = image1.get_width() / 2 - 1 + 32
    cy_scr = image1.get_width() / 2 - 1 - 42 * 2
    cx_scr_delta = 0
    cy_scr_delta = 0
    first_draw = True
&nbsp;
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                if event.key == pygame.locals.K_RETURN:
                    pygame.quit()
                    sys.exit()
                if event.key == pygame.locals.K_LEFT:
                    cx_scr_delta = -1
                if event.key == pygame.locals.K_RIGHT:
                    cx_scr_delta = 1
                if event.key == pygame.locals.K_UP:
                    cy_scr_delta = -1
                if event.key == pygame.locals.K_DOWN:
                    cy_scr_delta = 1
            if event.type == pygame.locals.KEYUP:
                if event.key == pygame.locals.K_LEFT:
                    cx_scr_delta = 0
                if event.key == pygame.locals.K_RIGHT:
                    cx_scr_delta = 0
                if event.key == pygame.locals.K_UP:
                    cy_scr_delta = 0
                if event.key == pygame.locals.K_DOWN:
                    cy_scr_delta = 0
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
&nbsp;
        <i># keep moving C</i>
        cx_scr += cx_scr_delta
        cy_scr += cy_scr_delta
&nbsp;
        <i># check for limits</i>
        if cx_scr &lt; 0:
            cx_scr = 0
        if cx_scr &gt; image1.get_width() - 1:
            cx_scr = image1.get_width() - 1
        if cy_scr &lt; 0:
            cy_scr = 0
        if cy_scr &gt; image1.get_height() - 1:
            cy_scr = image1.get_height() - 1
&nbsp;
        <i># recalculate Julia set if needed</i>
        if cx_scr_delta != 0 or cy_scr_delta != 0 or first_draw:
            first_draw = False
            scale_x = (XMAX - XMIN) / image1.get_width()
            scale_y = (YMAX - YMIN) / image1.get_height()
&nbsp;
            cx = cx_scr * scale_x + XMIN
            cy = cy_scr * scale_x + YMIN
&nbsp;
            renderer.render_julia(
                c_int(IMAGE_WIDTH),
                c_int(IMAGE_HEIGHT),
                pal,
                buffer,
                c_double(cx),
                c_double(cy),
            )
            image2 = image.frombuffer(buffer, (IMAGE_WIDTH, IMAGE_HEIGHT), "RGBX")
&nbsp;
        <i># display Mandelbrot set and Julia se</i>
        display.blit(image1, (XSTART, YSTART))
        display.blit(image2, (60 + image1.get_width(), YSTART))
&nbsp;
        <i># display C coordinates</i>
        WHITE = (255, 255, 255)
        pygame.draw.line(
            display,
            WHITE,
            (XSTART + cx_scr, YSTART),
            (XSTART + cx_scr, YSTART + image1.get_height() - 1),
        )
        pygame.draw.line(
            display,
            WHITE,
            (XSTART, YSTART + cy_scr),
            (XSTART + image1.get_width() - 1, YSTART + cy_scr),
        )
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>palette_to_buffer</strong>(p):
    s = create_string_buffer(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
def <strong>main</strong>():
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffers for raster image</i>
    buffer1 = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
    buffer2 = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    renderer.render_mandelbrot(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer1)
    image1 = image.frombuffer(buffer1, (IMAGE_WIDTH, IMAGE_HEIGHT), "RGBX")
&nbsp;
    image2 = pygame.Surface([IMAGE_WIDTH, IMAGE_HEIGHT])
&nbsp;
    event_loop(display, image1, image2, clock, pal, renderer, buffer2)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
# finito
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Přístup k&nbsp;pixelům obrázku po 32bitových slovech</h2>

<p>Prozatím jsme ve všech nativních funkcích k&nbsp;barvám pixelů přistupovali
po bajtech, což znamenalo, že se každá barvová složka měnila jedním zápisem
(bajtu). Ovšem kromě toho pochopitelně můžeme k&nbsp;pixelům bez problémů
přistupovat i po 32bitových slovech, přičemž horních osm bitů tohoto slova
nebude využito (což zajišťuje formát &bdquo;RGBX&ldquo;). Z&nbsp;pohledu
Pythonu k&nbsp;žádné změně nedojde, protože se do nativní funkce stále předává
ukazatel na buffer, ovšem v&nbsp;nativní funkci bude tento ukazatel typu
<strong>uint32_t *</strong> a nikoli <strong>unsigned char *</strong>. A zápis
barvy se v&nbsp;tomto případě provede jedinou operací. Na druhou stranu musíme
skládat barvy pixelů s&nbsp;využitím bitových posunů, takže reálné rychlosti
zápisu se nebudou příliš odlišovat (jiné to bude ve chvíli, kdy budeme mít
korektně připravenou barvovou paletu &ndash; to je relativně jednoduchá změna,
kterou ponechám jako úkol pro vážené čtenáře):</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
void <strong>render_test_rgb_image</strong>(unsigned int width, unsigned int height,
                           uint32_t *pixels, unsigned char green) {
    unsigned int i, j;
    unsigned int *p = pixels;
&nbsp;
    for (j = 0; j &lt; height; j++) {
        for (i = 0; i &lt; width; i++) {
            unsigned int color = (i &lt;&lt; 16) + (green &lt;&lt; 8) + j;
            *p++ = color;
        }
    }
}
</pre>

<p>Výsledné obrázky by měly vypadat stejně, jako tomu bylo v&nbsp;dnešním
prvním demonstračním příkladu:</p>

*** image ***
<p><i>Obrázek 19: Obrázky s&nbsp;testovacím vzorkem vyplněné zde popsanou
nativní funkcí.</i></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;dnešním článku popsané demonstrační příklady naleznete na
GitHubu:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>&nbsp;</td><th>1</th><th>Vyplnění rastrových obrázků vzorkem přímo z&nbsp;Pythonu</th><th>&nbsp;</th></tr>
<tr><td> 1</td><td>show.py</td><td>Vyplnění rastrových obrázků vzorkem přímo z&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>2</th><th>Zavolání nativní funkce pro vyplnění obrázku vzorkem</th><th>&nbsp;</th></tr>
<tr><td> 1</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/Makefile</a></td></tr>
<tr><td> 2</td><td>renderer.c</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/renderer.c</a></td></tr>
<tr><td> 3</td><td>show.py</td><td>zobrazení dvojice testovacích obrázků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>3</th><th>Vyplnění rastrového obrázku s&nbsp;využitím barvové palety</th><th>&nbsp;</th></tr>
<tr><td> 5</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/Makefile</a></td></tr>
<tr><td> 5</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/palette_mandmap.py</a></td></tr>
<tr><td> 6</td><td>renderer.c</td><td>vyplnění rastrového obrázku s&nbsp;využitím barvové palety</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/renderer.c</a></td></tr>
<tr><td> 7</td><td>show.py</td><td>zobrazení testovacího obrázku s&nbsp;paletou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>4</th><th>Výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;jazyku C</th><th>&nbsp;</th></tr>
<tr><td> 8</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/Makefile</a></td></tr>
<tr><td> 9</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/palette_mandmap.py</a></td></tr>
<tr><td>10</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/renderer.c</a></td></tr>
<tr><td>11</td><td>show.py</td><td>realizace výpočtu a zobrazení Mandelbrotovy a Juliovy množiny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>5</th><th>Interaktivní změna tvaru Juliovy množiny</th><th>&nbsp;</th></tr>
<tr><td>12</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/Makefile</a></td></tr>
<tr><td>13</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/palette_mandmap.py</a></td></tr>
<tr><td>14</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/renderer.c</a></td></tr>
<tr><td>15</td><td>show.py</td><td>interaktivní změna hodnoty C při výpočtu Juliovy množiny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>6</th><th>Využití jednoho (sdíleného) bufferu pro oba obrázky</th><th>&nbsp;</th></tr>
<tr><td>16</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/Makefile</a></td></tr>
<tr><td>17</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/palette_mandmap.py</a></td></tr>
<tr><td>18</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/renderer.c</a></td></tr>
<tr><td>19</td><td>show.py</td><td>využití jednoho (sdíleného) bufferu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>7</th><th>Využití dvojice bufferů, jeden buffer pro každý obrázek</th><th>&nbsp;</th></tr>
<tr><td>20</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/Makefile</a></td></tr>
<tr><td>21</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/palette_mandmap.py</a></td></tr>
<tr><td>22</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/renderer.c</a></td></tr>
<tr><td>23</td><td>show.py</td><td>využití dvojice rozličných bufferů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>8</th><th>Přístup k&nbsp;pixelům obrázku po 32bitových slovech</th><th>&nbsp;</th></tr>
<tr><td>24</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/Makefile</a></td></tr>
<tr><td>25</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/palette_mandmap.py</a></td></tr>
<tr><td>26</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/renderer.c</a></td></tr>
<tr><td>27</td><td>show.py</td><td>využití dvojice rozličných bufferů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/show.py</a></td></tr>
</table>

<p>Navíc si pro úplnost uveďme demonstrační příklady použité v&nbsp;článcích o
knihovně <i>cffi</i>. I v&nbsp;těchto článcích jsme se totiž o <i>ctypes</i>
zmiňovali:</p>

<table>
<tr><th>  #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>  1</td><td>adder/adder.c</td><td>funkce psaná v&nbsp;C, která sečte své dva celočíselné parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/adder.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/adder.c</a></td></tr>
<tr><td>  2</td><td>adder/call_via_cffi1.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;korektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi1.py</a></td></tr>
<tr><td>  3</td><td>adder/call_via_cffi2.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi2.py</a></td></tr>
<tr><td>  4</td><td>adder/call_via_cffi3.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi3.py</a></td></tr>
<tr><td>  5</td><td>adder/call_via_cffi.sh</td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi.sh</a></td></tr>
<tr><td>  6</td><td>adder/call_via_ctypes1.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;korektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes1.py</a></td></tr>
<tr><td>  7</td><td>adder/call_via_ctypes2.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes2.py</a></td></tr>
<tr><td>  8</td><td>adder/call_via_ctypes3.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes3.py</a></td></tr>
<tr><td>  9</td><td>adder/call_via_ctypes.sh </td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes.sh</a></td></tr>
<tr><td> 10</td><td>adder/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/make_library.sh</a></td></tr>
<tr><td> 11</td><td>adder/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 12</td><td>greeter/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/greeter.c</a></td></tr>
<tr><td> 13</td><td>greeter/call_via_cffi1.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;nekorektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi1.py</a></td></tr>
<tr><td> 14</td><td>greeter/call_via_cffi2.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi2.py</a></td></tr>
<tr><td> 15</td><td>greeter/call_via_cffi3.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi3.py</a></td></tr>
<tr><td> 16</td><td>greeter/call_via_cffi.sh</td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi.sh</a></td></tr>
<tr><td> 17</td><td>greeter/call_via_ctypes1.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;nekorektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes1.py</a></td></tr>
<tr><td> 18</td><td>greeter/call_via_ctypes2.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes2.py</a></td></tr>
<tr><td> 19</td><td>greeter/call_via_ctypes3.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes3.py</a></td></tr>
<tr><td> 20</td><td>greeter/call_via_ctypes.sh</td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes.sh</a></td></tr>
<tr><td> 21</td><td>greeter/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/make_library.sh</a></td></tr>
<tr><td> 22</td><td>greeter/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 23</td><td>swapper/swapper.c</td><td>céčkovská funkce prohazující obsah svých dvou parametrů předávaných referencí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/swapper.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/swapper.c</a></td></tr>
<tr><td> 24</td><td>swapper/call_via_cffi1.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python (korektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi1.py</a></td></tr>
<tr><td> 25</td><td>swapper/call_via_cffi2.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python (nekorektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi2.py</a></td></tr>
<tr><td> 26</td><td>swapper/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi.sh</a></td></tr>
<tr><td> 27</td><td>swapper/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/make_library.sh</a></td></tr>
<tr><td> 28</td><td>swapper/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 29</td><td>filler/filler.c</td><td>céčkovská funkce pro vyplnění části pole zadanou hodnotou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/filler.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/filler.c</a></td></tr>
<tr><td> 30</td><td>filler/call_via_cffi.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.py</a></td></tr>
<tr><td> 31</td><td>filler/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.sh</a></td></tr>
<tr><td> 32</td><td>filler/make_library.sh </td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/make_library.sh</a></td></tr>
<tr><td> 32</td><td>filler/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 33</td><td>greeter_h/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/greeter.c</a></td></tr>
<tr><td> 34</td><td>greeter_h/greeter.h</td><td>prototyp (předběžná deklarace) funkce <i>greeter</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/greeter.h</a></td></tr>
<tr><td> 35</td><td>greeter_h/call_via_cffi4.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/call_via_cffi4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/call_via_cffi4.py</a></td></tr>
<tr><td> 36</td><td>greeter_h/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/call_via_cffi.sh</a></td></tr>
<tr><td> 37</td><td>greeter_h/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/make_library.sh</a></td></tr>
<tr><td> 38</td><td>greeter_h/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 39</td><td>greeter_h_2/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/greeter.c</a></td></tr>
<tr><td> 40</td><td>greeter_h_2/greeter.h</td><td>prototyp (předběžná deklarace) funkce <i>greeter</i> obalená v&nbsp;testu na existenci symbolu/makra</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/greeter.h</a></td></tr>
<tr><td> 41</td><td>greeter_h_2/call_via_cffi5.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/call_via_cffi5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/call_via_cffi5.py</a></td></tr>
<tr><td> 42</td><td>greeter_h_2/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/call_via_cffi.sh</a></td></tr>
<tr><td> 43</td><td>greeter_h_2/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/make_library.sh</a></td></tr>
<tr><td> 44</td><td>greeter_h_2/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 45</td><td>greeter_h_3/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/greeter.c</a></td></tr>
<tr><td> 46</td><td>greeter_h_3/greeter.h</td><td>test na existenci symbolu/makra, pokud makro neexistuje, provede se vložení dalšího souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/greeter.h</a></td></tr>
<tr><td> 47</td><td>greeter_h_3/_greeter.h</td><td>prototyp (předběžná deklarace) funkce <i>greeter</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/_greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/_greeter.h</a></td></tr>
<tr><td> 48</td><td>greeter_h_3/call_via_cffi5.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/call_via_cffi5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/call_via_cffi5.py</a></td></tr>
<tr><td> 49</td><td>greeter_h_3/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/call_via_cffi.sh</a></td></tr>
<tr><td> 50</td><td>greeter_h_3/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/make_library.sh</a></td></tr>
<tr><td> 51</td><td>greeter_h_3/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 52</td><td>greeter_build/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/greeter.c</a></td></tr>
<tr><td> 53</td><td>greeter_build/greeter.h</td><td>prototyp (předběžná deklarace) funkce <i>greeter</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/greeter.h</a></td></tr>
<tr><td> 54</td><td>greeter_build/call_via_cffi7.py</td><td>skript pro překlad céčkovské funkce, vytvoření dynamicky linkované knihovny a zavolání funkce z&nbsp;této knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/call_via_cffi7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/call_via_cffi7.py</a></td></tr>
<tr><td> 55</td><td>greeter_build/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 56</td><td>vector_printer/vector_printer.c</td><td>funkce psaná v&nbsp;C, která akceptuje jako svůj parametr strukturu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/vector_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/vector_printer.c</a></td></tr>
<tr><td> 57</td><td>vector_printer/vector_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_vector</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/vector_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/vector_printer.h</a></td></tr>
<tr><td> 58</td><td>vector_printer/call_via_cffi.sh</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/call_via_cffi.sh</a></td></tr>
<tr><td> 59</td><td>vector_printer/call_via_cffi.py</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/call_via_cffi.py</a></td></tr>
<tr><td> 60</td><td>vector_printer/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/make_library.sh</a></td></tr>
<tr><td> 61</td><td>vector_printer/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 62</td><td>vector_printer_2/vector_printer.c</td><td>funkce psaná v&nbsp;C, která akceptuje jako svůj parametr ukazatel na strukturu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/vector_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/vector_printer.c</a></td></tr>
<tr><td> 63</td><td>vector_printer_2/vector_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_vector</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/vector_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/vector_printer.h</a></td></tr>
<tr><td> 64</td><td>vector_printer_2/call_via_cffi.sh</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/call_via_cffi.sh</a></td></tr>
<tr><td> 65</td><td>vector_printer_2/call_via_cffi.py</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/call_via_cffi.py</a></td></tr>
<tr><td> 66</td><td>vector_printer_2/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/make_library.sh</a></td></tr>
<tr><td> 67</td><td>vector_printer_2/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 68</td><td>array_printer_1/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/array_printer.c</a></td></tr>
<tr><td> 69</td><td>array_printer_1/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/array_printer.h</a></td></tr>
<tr><td> 70</td><td>array_printer_1/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/call_via_cffi.sh</a></td></tr>
<tr><td> 71</td><td>array_printer_1/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/call_via_cffi.py</a></td></tr>
<tr><td> 72</td><td>array_printer_1/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/make_library.sh</a></td></tr>
<tr><td> 73</td><td>array_printer_1/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 74</td><td>array_printer_2/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/array_printer.c</a></td></tr>
<tr><td> 75</td><td>array_printer_2/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/array_printer.h</a></td></tr>
<tr><td> 76</td><td>array_printer_2/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/call_via_cffi.sh</a></td></tr>
<tr><td> 77</td><td>array_printer_2/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/call_via_cffi.py</a></td></tr>
<tr><td> 78</td><td>array_printer_2/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/make_library.sh</a></td></tr>
<tr><td> 79</td><td>array_printer_2/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 80</td><td>array_printer_3/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/array_printer.c</a></td></tr>
<tr><td> 81</td><td>array_printer_3/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/array_printer.h</a></td></tr>
<tr><td> 82</td><td>array_printer_3/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/call_via_cffi.sh</a></td></tr>
<tr><td> 83</td><td>array_printer_3/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/call_via_cffi.py</a></td></tr>
<tr><td> 84</td><td>array_printer_3/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/make_library.sh</a></td></tr>
<tr><td> 85</td><td>array_printer_3/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 86</td><td>array_printer_4/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/array_printer.c</a></td></tr>
<tr><td> 87</td><td>array_printer_4/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/array_printer.h</a></td></tr>
<tr><td> 88</td><td>array_printer_4/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/call_via_cffi.sh</a></td></tr>
<tr><td> 89</td><td>array_printer_4/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/call_via_cffi.py</a></td></tr>
<tr><td> 90</td><td>array_printer_4/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/make_library.sh</a></td></tr>
<tr><td> 91</td><td>array_printer_4/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 92</td><td>array_printer_5/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>vector_t</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/array_printer.c</a></td></tr>
<tr><td> 93</td><td>array_printer_5/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/array_printer.h</a></td></tr>
<tr><td> 94</td><td>array_printer_5/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/call_via_cffi.sh</a></td></tr>
<tr><td> 95</td><td>array_printer_5/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/call_via_cffi.py</a></td></tr>
<tr><td> 96</td><td>array_printer_5/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/make_library.sh</a></td></tr>
<tr><td> 97</td><td>array_printer_5/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 92</td><td>array_printer_6/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje dvourozměrné pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/array_printer.c</a></td></tr>
<tr><td> 93</td><td>array_printer_6/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/array_printer.h</a></td></tr>
<tr><td> 94</td><td>array_printer_6/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/call_via_cffi.sh</a></td></tr>
<tr><td> 95</td><td>array_printer_6/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/call_via_cffi.py</a></td></tr>
<tr><td> 96</td><td>array_printer_6/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/make_library.sh</a></td></tr>
<tr><td> 97</td><td>array_printer_6/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 98</td><td>array_printer_7/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje dvourozměrné pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/array_printer.c</a></td></tr>
<tr><td> 99</td><td>array_printer_7/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/array_printer.h</a></td></tr>
<tr><td>100</td><td>array_printer_7/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/call_via_cffi.sh</a></td></tr>
<tr><td>101</td><td>array_printer_7/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/call_via_cffi.py</a></td></tr>
<tr><td>102</td><td>array_printer_7/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/make_library.sh</a></td></tr>
<tr><td>103</td><td>array_printer_7/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/clean.sh</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>ctypes &ndash; A foreign function library for Python<br />
<a href="https://docs.python.org/3/library/ctypes.html">https://docs.python.org/3/library/ctypes.html</a>
</li>

<li>Pygame: display<br />
<a href="https://www.pygame.org/docs/ref/display.html">https://www.pygame.org/docs/ref/display.html</a>
</li>

<li>Pygame: event<br />
<a href="https://www.pygame.org/docs/ref/event.html">https://www.pygame.org/docs/ref/event.html</a>
</li>

<li>Pygame: image<br />
<a href="https://www.pygame.org/docs/ref/image.html">https://www.pygame.org/docs/ref/image.html</a>
</li>

<li>Pygame: clock<br />
<a href="https://www.pygame.org/docs/ref/time.html#pygame.time.Clock">https://www.pygame.org/docs/ref/time.html#pygame.time.Clock</a>
</li>

<li>Fraktály v&nbsp;počítačové grafice XII<br />
<a href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xii/">https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xii/</a>
</li>

<li>Fraktály v&nbsp;počítačové grafice XIII<br />
<a href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xiii/">https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xiii/</a>
</li>

<li>Fraktály v&nbsp;počítačové grafice XIV<br />
<a href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xiv/">https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xiv/</a>
</li>

<li>CFFI documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>cffi 1.15.1 na PyPi<br />
<a href="https://pypi.org/project/cffi/">https://pypi.org/project/cffi/</a>
</li>

<li>Python Bindings: Calling C or C++ From Python<br />
<a href="https://realpython.com/python-bindings-overview/">https://realpython.com/python-bindings-overview/</a>
</li>

<li>Interfacing with C/C++ Libraries<br />
<a href="https://docs.python-guide.org/scenarios/clibs/">https://docs.python-guide.org/scenarios/clibs/</a>
</li>

<li>Cython, pybind11, cffi – which tool should you choose?<br />
<a href="http://blog.behnel.de/posts/cython-pybind11-cffi-which-tool-to-choose.html">http://blog.behnel.de/posts/cython-pybind11-cffi-which-tool-to-choose.html</a>
</li>

<li>Python FFI with ctypes and cffi<br />
<a href="https://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi">https://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi</a>
</li>

<li>Propojení Go s&nbsp;Pythonem s&nbsp;využitím cgo a ctypes<br />
<a href="https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes/">https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes/</a>
</li>

<li>Propojení Go s&nbsp;Pythonem s&nbsp;využitím cgo a ctypes (2. část)<br />
<a href="https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes-2-cast/">https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes-2-cast/</a>
</li>

<li>Programovací jazyk Rust: použití FFI pro volání funkcí z&nbsp;nativních knihoven<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven/">https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven/</a>
</li>

<li>Programovací jazyk Rust: použití FFI při předávání struktur<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pri-predavani-struktur/">https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pri-predavani-struktur/</a>
</li>

<li>Programovací jazyk Rust: použití FFI pro volání funkcí z&nbsp;nativních knihoven (2. část)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven-2-cast/">https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven-2-cast/</a>
</li>

<li>Dynamic-link library<br />
<a href="https://en.wikipedia.org/wiki/Dynamic-link_library">https://en.wikipedia.org/wiki/Dynamic-link_library</a>
</li>

<li>Úvod do jazyka C: Deklarace funkcí<br />
<a href="https://www.fi.muni.cz/usr/jkucera/pb071/sl5.htm">https://www.fi.muni.cz/usr/jkucera/pb071/sl5.htm</a>
</li>

<li>Using standard library headers with CFFI<br />
<a href="https://stackoverflow.com/questions/57481873/using-standard-library-headers-with-cffi">https://stackoverflow.com/questions/57481873/using-standard-library-headers-with-cffi</a>
</li>

<li>Preparing and Distributing modules<br />
<a href="https://cffi.readthedocs.io/en/latest/cdef.html">https://cffi.readthedocs.io/en/latest/cdef.html</a>
</li>

<li>C Arrays<br />
<a href="https://www.programiz.com/c-programming/c-arrays">https://www.programiz.com/c-programming/c-arrays</a>
</li>

<li>C Arrays<br />
<a href="https://www.w3schools.com/c/c_arrays.php">https://www.w3schools.com/c/c_arrays.php</a>
</li>

<li>Array of Structures in C<br />
<a href="https://overiq.com/c-programming-101/array-of-structures-in-c/#google_vignette">https://overiq.com/c-programming-101/array-of-structures-in-c/#google_vignette</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

