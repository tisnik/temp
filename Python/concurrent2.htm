<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Souběžné a paralelně běžící úlohy naprogramované v Pythonu (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Souběžné a paralelně běžící úlohy naprogramované v Pythonu (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Souběžné a paralelně běžící úlohy naprogramované v&nbsp;Pythonu (2)</a></p>
<p><a href="#k02">2. Třída <strong>ThreadPoolExecutor</strong></a></p>
<p><a href="#k03">3. Omezení celkového množství vláken dostupného workerům</a></p>
<p><a href="#k04">4. Návratové hodnoty z&nbsp;jednotlivých úloh</a></p>
<p><a href="#k05">5. Získání vypočtených hodnot</a></p>
<p><a href="#k06">6. Od ThreadPoolExecutor k&nbsp;ProcessPoolExecutor</a></p>
<p><a href="#k07">7. Použití třídy <strong>ProcessPoolExecutor</strong></a></p>
<p><a href="#k08">8. Získání výsledků z&nbsp;paralelně běžících procesů</a></p>
<p><a href="#k09">*** 9. Souběžně běžící úlohy a konstrukce <strong>async</strong> a <strong>await</strong></a></p>
<p><a href="#k10">10. Základní použití konstrukcí <strong>async</strong> a <strong>await</strong></a></p>
<p><a href="#k11">11. Vytvoření a spuštění dvou korutin s&nbsp;čekáním na jejich dokončení</a></p>
<p><a href="#k12">12. Získání výsledků z&nbsp;korutin</a></p>
<p><a href="#k13">*** 13. Fronta jako komunikační kanál</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">16. Knihovna <strong>aiohttp</strong> &ndash; asynchronní operace přes protokol HTTP</a></p>
<p><a href="#k17">17. Příklad použití knihovny <strong>aiohttp</strong></a></p>
<p><a href="#k18">18. Doba trvání dotazů vs.&nbsp;celková doba běhu programu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Souběžné a paralelně běžící úlohy naprogramované v&nbsp;Pythonu (2)</h2>

<p>Na článek <a
href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">&bdquo;Souběžné
a paralelně běžící úlohy naprogramované v&nbsp;Pythonu&ldquo;</a> dnes
navážeme. Ukážeme si totiž, jakým způsobem je možné zajistit souběžné či
dokonce paralelní zpracování úloh s&nbsp;využitím několika navzájem zcela
odlišných technologií. <a href="#k02">V&nbsp;první části článku</a> bude
popsána třída <strong>ThreadPoolExecutor</strong> (souběžný běh několika
vláken), <a href="#k06">v&nbsp;části další</a> pak
<strong>ProcessPoolExecutor</strong> (paralelní běh několika procesů) a konečně
se <a href="#k09">ve třetí části článku</a> zmíníme o knihovnách
<strong>asyncio</strong> a <strong>aiohttp</strong>, s&nbsp;nimiž do značné
míry souvisejí i programové konstrukce <strong>async</strong> a
<strong>await</strong>. Pochopitelně si řekneme i to, jak lze zajistit
předávání parametrů úlohám a získávání jejich výsledků.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je vhodné znovu upozornit
na fakt, že v&nbsp;Pythonu sice můžeme používat všechny dále popisované balíčky
a knihovny, ovšem skutečný paralelní (a nezávislý) běh několika vláken je ve
standardním CPythonu do značné míry omezen kvůli existenci techniky zvané
<i>GIL</i> neboli <i>Global Interpreter Lock</i> (viz též <a
href="https://wiki.python.org/moin/GlobalInterpreterLock">příslušnou
stránku</a>). V&nbsp;mnoha projektech, zejména tehdy, pokud převažují I/O
operace, to vadit nemusí, ale při požadavku na rychlé a paralelní výpočty již
ano.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Třída <strong>ThreadPoolExecutor</strong></h2>

<p>V&nbsp;úvodní části dnešního článku si popíšeme třídu nazvanou
<strong>ThreadPoolExecutor</strong>, kterou lze s&nbsp;výhodou využít ve
chvíli, kdy se mají často spouštět různé asynchronně běžící úlohy.
V&nbsp;případě, že se takové úlohy spouštějí často a navíc pokud je délka
jejich trvání relativně krátká, může být limitujícím faktorem čas na vytvoření
zcela nového vlákna. Navíc pokud si programátor vlákna vytváří sám, neexistuje
centrální mechanismus pro omezení jejich počtu atd. Oba tyto problémy jsou
řešeny třídou <strong>ThreadPoolExecutor</strong> z&nbsp;balíčku
<strong>concurrent.futures.thread</strong>. Při konstrukci této třídy je možné
zvolit, kolik vláken může běžet současně a následně jsou tato vlákna
přidělována jednotlivým úlohám. Zcela typický příklad použití pro tři vlákna a
tři úlohy může vypadat následovně &ndash; povšimněte si použití idomu
založeného na konstrukci <strong>with</strong>:</p>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
&nbsp;
&nbsp;
<strong>with ThreadPoolExecutor(max_workers=3) as executor</strong>:
    <strong>executor.submit</strong>(worker, "Thread-1", 0.5, 10)
    <strong>executor.submit</strong>(worker, "Thread-2", 1.0, 10)
    <strong>executor.submit</strong>(worker, "Thread-3", 1.5, 10)
&nbsp;
&nbsp;
print("Done!")
</pre>

<p>Po spuštění tohoto demonstračního příkladu je patrné, že se skutečně využívá
trojice vláken:</p>

<pre>
$ <strong>python3 thread_pool_1.py </strong>
&nbsp;
Thread-1: 1/10 - Mon Mar 14 18:14:52 2022
Thread-2: 1/10 - Mon Mar 14 18:14:52 2022
Thread-1: 2/10 - Mon Mar 14 18:14:52 2022
Thread-3: 1/10 - Mon Mar 14 18:14:53 2022
Thread-1: 3/10 - Mon Mar 14 18:14:53 2022
Thread-2: 2/10 - Mon Mar 14 18:14:53 2022
Thread-1: 4/10 - Mon Mar 14 18:14:53 2022
Thread-1: 5/10 - Mon Mar 14 18:14:54 2022
Thread-2: 3/10 - Mon Mar 14 18:14:54 2022
Thread-3: 2/10 - Mon Mar 14 18:14:54 2022
Thread-1: 6/10 - Mon Mar 14 18:14:54 2022
Thread-1: 7/10 - Mon Mar 14 18:14:55 2022
Thread-2: 4/10 - Mon Mar 14 18:14:55 2022
Thread-1: 8/10 - Mon Mar 14 18:14:55 2022
Thread-3: 3/10 - Mon Mar 14 18:14:56 2022
Thread-1: 9/10 - Mon Mar 14 18:14:56 2022
Thread-2: 5/10 - Mon Mar 14 18:14:56 2022
Thread-1: 10/10 - Mon Mar 14 18:14:56 2022
Thread-2: 6/10 - Mon Mar 14 18:14:57 2022
Thread-3: 4/10 - Mon Mar 14 18:14:57 2022
Thread-2: 7/10 - Mon Mar 14 18:14:58 2022
Thread-3: 5/10 - Mon Mar 14 18:14:59 2022
Thread-2: 8/10 - Mon Mar 14 18:14:59 2022
Thread-3: 6/10 - Mon Mar 14 18:15:00 2022
Thread-2: 9/10 - Mon Mar 14 18:15:00 2022
Thread-2: 10/10 - Mon Mar 14 18:15:01 2022
Thread-3: 7/10 - Mon Mar 14 18:15:02 2022
Thread-3: 8/10 - Mon Mar 14 18:15:03 2022
Thread-3: 9/10 - Mon Mar 14 18:15:05 2022
Thread-3: 10/10 - Mon Mar 14 18:15:06 2022
Done!
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Omezení celkového množství vláken dostupného workerům</h2>

<p>Nyní si zkusme předchozí příklad nepatrně upravit, a to takovým způsobem, že
zvětšíme množství dostupných vláken na deset. Taktéž zvýšíme celkové množství
úloh, které se mají souběžně vykonat, a to taktéž na hodnotu deset. Takto
upravený příklad bude vypadat následovně:</p>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
    print("{}: DONE!".format(threadName))
&nbsp;
&nbsp;
workers = 10
&nbsp;
with ThreadPoolExecutor(max_workers=workers) as executor:
    for w in range(workers):
        executor.submit(worker, "Thread-{}".format(w + 1), 0.5 + w / 10.0, 10)
&nbsp;
&nbsp;
print("Done!")
</pre>

<p>Po spuštění demonstračního příkladu je patrné, že každému dostupnému vláknu
byla přiřazena přesně jedna úloha a že všechna vlákna byla spuštěna
souběžně:</p>

<pre>
Thread-1: 1/10 - Mon Mar 14 18:16:59 2022
Thread-2: 1/10 - Mon Mar 14 18:16:59 2022
Thread-3: 1/10 - Mon Mar 14 18:16:59 2022
Thread-4: 1/10 - Mon Mar 14 18:16:59 2022
Thread-5: 1/10 - Mon Mar 14 18:16:59 2022
Thread-1: 2/10 - Mon Mar 14 18:16:59 2022
...
...
...
Thread-7: DONE!
Thread-10: 8/10 - Mon Mar 14 18:17:09 2022
Thread-9: 9/10 - Mon Mar 14 18:17:10 2022
Thread-8: 10/10 - Mon Mar 14 18:17:10 2022
Thread-8: DONE!
Thread-10: 9/10 - Mon Mar 14 18:17:11 2022
Thread-9: 10/10 - Mon Mar 14 18:17:11 2022
Thread-9: DONE!
Thread-10: 10/10 - Mon Mar 14 18:17:12 2022
Thread-10: DONE!
Done!
</pre>

<p>Nástrojem <strong>time</strong> lze snadno zjistit, že celý skript byl
dokončen za přibližně 14 sekund:</p>

<pre>
real    0m14,058s
user    0m0,051s
sys     0m0,010s
</pre>

<p>V&nbsp;praxi je ovšem situace, kdy počet dostupných (resp.&nbsp;přesněji
řečeno volných) vláken přesně odpovídá počtu úloh, které se mají zpracovat,
dosti nepravděpodobná. Často se setkáme se situací, kdy je množství vláken
pevně dané a typicky odvozené od počtu jader mikroprocesoru. Pokud bude počet
úloh přesahovat počet vláken, budou některé úlohy (pochopitelně) čekat na
dokončení předchozích úloh, tedy na situaci, kdy se nějaké vlákno uvolní a
vrátí do <i>poolu</i>. Podívejme se tedy nyní na způsob naplánování deseti
úloh, z&nbsp;nichž ovšem souběžně poběží maximálně pouze tři:</p>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
    print("{}: DONE!".format(threadName))
&nbsp;
&nbsp;
<u>workers = 10</u>
&nbsp;
with ThreadPoolExecutor(<u>max_workers=3</u>) as executor:
    for w in range(workers):
        executor.submit(worker, "Thread-{}".format(w + 1), 0.5 + w / 10.0, 10)
&nbsp;
&nbsp;
print("Done!")
</pre>

<p>Nyní skutečně souběžně poběží pouze tři úlohy (tedy budou se opakovat řádky
se jmény Thread-1 až Thread-3):</p>

<pre>
Thread-1: 1/10 - Mon Mar 14 18:17:42 2022
Thread-2: 1/10 - Mon Mar 14 18:17:42 2022
Thread-3: 1/10 - Mon Mar 14 18:17:42 2022
Thread-1: 2/10 - Mon Mar 14 18:17:43 2022
Thread-2: 2/10 - Mon Mar 14 18:17:43 2022
Thread-3: 2/10 - Mon Mar 14 18:17:43 2022
...
...
...
Thread-10: 2/10 - Mon Mar 14 18:18:08 2022
Thread-8: 10/10 - Mon Mar 14 18:18:09 2022
Thread-8: DONE!
Thread-9: 8/10 - Mon Mar 14 18:18:09 2022
Thread-10: 3/10 - Mon Mar 14 18:18:10 2022
Thread-9: 9/10 - Mon Mar 14 18:18:10 2022
Thread-10: 4/10 - Mon Mar 14 18:18:11 2022
Thread-9: 10/10 - Mon Mar 14 18:18:12 2022
Thread-9: DONE!
Thread-10: 5/10 - Mon Mar 14 18:18:13 2022
Thread-10: 6/10 - Mon Mar 14 18:18:14 2022
Thread-10: 7/10 - Mon Mar 14 18:18:15 2022
Thread-10: 8/10 - Mon Mar 14 18:18:17 2022
Thread-10: 9/10 - Mon Mar 14 18:18:18 2022
Thread-10: 10/10 - Mon Mar 14 18:18:20 2022
Thread-10: DONE!
Done!
</pre>

<p>A navíc budou (opět podle očekávání) všechny úlohy dokončeny až po delší
době, zde konkrétně namísto 14 sekund až za 38 sekund:</p>

<pre>
real    0m38,084s
user    0m0,041s
sys     0m0,013s
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Návratové hodnoty z&nbsp;jednotlivých úloh</h2>

<p>Úlohy spouštěné ve vláknech získaných z&nbsp;<i>poolu</i> mnohdy musí vracet
výsledky své činnosti (tedy výpočtů atd.). Vzhledem k&nbsp;tomu, že každá úloha
je reprezentována běžnou funkcí, můžeme se samozřejmě pokusit vrátit hodnotu či
hodnoty příkazem <strong>return</strong>. Ovšem funkce představující jednu
úlohu se nevolá přímo (to by pochopitelně neběžela souběžně, ale přímo
v&nbsp;hlavním vláknu). Úlohy voláme, resp.&nbsp;přesněji řečeno plánujeme,
přes <strong>ThreadPoolExecutor.Submit</strong>. Pokusme se tedy zjistit, jakou
hodnotu vlastně tímto způsobem získáme a zda se bude skutečně jednat o
návratovou hodnotu dokončené úlohy:</p>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    result = 0
&nbsp;
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
        result += delay
&nbsp;
    print("{}: DONE!".format(threadName))
    <u>return result</u>
&nbsp;
&nbsp;
workers = 10
&nbsp;
with ThreadPoolExecutor(max_workers=3) as executor:
    for w in range(workers):
        <u>result = executor.submit(worker, "Thread-{}".format(w + 1), 0.5 + w / 10.0, 10)</u>
        print(w, result)
&nbsp;
&nbsp;
print("Done!")
</pre>

<p>Pokud tento příklad spustíme, vypíše se (alespoň většinou) nejdříve těchto
deset řádků:</p>

<pre>
0 &lt;Future at 0x7f0e8162bc40 state=running&gt;
1 &lt;Future at 0x7f0e814f6a00 state=running&gt;
2 &lt;Future at 0x7f0e814f6d90 state=running&gt;
3 &lt;Future at 0x7f0e814fe190 state=pending&gt;
4 &lt;Future at 0x7f0e814fe310 state=pending&gt;
5 &lt;Future at 0x7f0e814fe430 state=pending&gt;
6 &lt;Future at 0x7f0e814fe550 state=pending&gt;
7 &lt;Future at 0x7f0e814fe670 state=pending&gt;
8 &lt;Future at 0x7f0e814fe790 state=pending&gt;
9 &lt;Future at 0x7f0e814fe8b0 state=pending&gt;
</pre>

<p>Následuje již běžné spuštění našich deseti úloh:</p>

<pre>
Thread-1: 1/10 - Wed Mar 16 09:12:52 2022
Thread-2: 1/10 - Wed Mar 16 09:12:52 2022
Thread-3: 1/10 - Wed Mar 16 09:12:52 2022
Thread-1: 2/10 - Wed Mar 16 09:12:53 2022
Thread-2: 2/10 - Wed Mar 16 09:12:53 2022
Thread-3: 2/10 - Wed Mar 16 09:12:53 2022
Thread-1: 3/10 - Wed Mar 16 09:12:53 2022
Thread-2: 3/10 - Wed Mar 16 09:12:54 2022
Thread-1: 4/10 - Wed Mar 16 09:12:54 2022
...
...
...
</pre>

<p>Ovšem nás bude v&nbsp;tuto chvíli zajímat prvních deset řádků, které
odpovídají hodnotám vraceným z:</p>

<pre>
<u>result = executor.submit(worker, "Thread-{}".format(w + 1), 0.5 + w / 10.0, 10)</u>
print(w, result)
</pre>

<p>Toto volání tedy nevrátilo přímo výsledek úlohy, což je ovšem očekávatelné
&ndash; na výsledky bychom museli postupně čekat a opět by se nejednalo o
souběžné výpočty. Namísto toho je vrácena hodnota, které se říká <i>future</i>.
Co se však vlastně pod pojmem future skrývá? Kromě názvu jednoho typu
finančního derivátu :-) představuje future(s) výpočet, který běží asynchronně
(tedy většinou souběžně nebo paralelně) k&nbsp;hlavnímu vláknu aplikace.
Uživatel pouze daný výpočet spustí a teprve ve chvíli, kdy potřebuje pracovat
s&nbsp;výsledkem tohoto výpočtu, začne systém řešit, jakým způsobem má
asynchronní výpočet ukončit, tj.&nbsp;jak má provést synchronizaci obou vláken
nebo získání výsledku z&nbsp;nějaké k&nbsp;tomu určené (synchronizované) datové
struktury. V&nbsp;ideálním případě je výpočet již dokončen, takže se přímo
použije zaznamenaný výsledek, v&nbsp;případě opačném se až při čtení výsledku
počká na dokončení výpočtu. V&nbsp;obou případech však operujeme
s&nbsp;výslednou hodnotou nepřímo.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Získání vypočtených hodnot</h2>

<p>V&nbsp;případě, že budeme chtít získat skutečně vypočtené hodnoty (a to
většinou budeme požadovat), je nutné postupovat nepatrně odlišným způsobem.
Nejdříve se vytvoří kontejner určený pro uložení výsledků:</p>

<pre>
results = []
</pre>

<p>Dále všechny úlohy spustíme a zapamatujeme si vrácené <i>futures</i> (tedy
&bdquo;obaly&ldquo; pro později vypočtené hodnoty):</p>

<pre>
for w in range(workers):
    result = executor.submit(worker, "Thread-{}".format(w + 1), 0.5 + w / 10.0, 10)
    results.append(result)
</pre>

<p>Následně můžeme čekat na dokončení všech úloh. Nejedná se o ideální řešení,
lepší by pravděpodobně bylo využití fronty (viz další text):</p>

<pre>
for result in results:
    print(result.result())
</pre>

<p>Úplný zdrojový kód takto upraveného demonstračního příkladu vypadá
následovně:</p>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    result = 0
&nbsp;
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
        result += delay
&nbsp;
    print("{}: DONE!".format(threadName))
    return result
&nbsp;
&nbsp;
workers = 10
&nbsp;
results = []
&nbsp;
with ThreadPoolExecutor(max_workers=3) as executor:
    for w in range(workers):
        result = executor.submit(worker, "Thread-{}".format(w + 1), 0.5 + w / 10.0, 10)
        results.append(result)
        print(w, result)
&nbsp;
&nbsp;
print("Computing finished")
&nbsp;
for result in results:
    print(result.result())
&nbsp;
print("Done!")
</pre>

<p>Po spuštění se nejdříve vypíšou hodnoty (futures) vrácené po zavolání
<strong>executor.submit</strong>:</p>

<pre>
0 &lt;Future at 0x7f26e648bc40 state=running&gt;
1 &lt;Future at 0x7f26e6357a00 state=running&gt;
2 &lt;Future at 0x7f26e6357d90 state=running&gt;
3 &lt;Future at 0x7f26e635e190 state=pending&gt;
4 &lt;Future at 0x7f26e635e310 state=pending&gt;
5 &lt;Future at 0x7f26e635e430 state=pending&gt;
6 &lt;Future at 0x7f26e635e550 state=pending&gt;
7 &lt;Future at 0x7f26e635e670 state=pending&gt;
8 &lt;Future at 0x7f26e635e790 state=pending&gt;
9 &lt;Future at 0x7f26e635e8b0 state=pending&gt;
</pre>

<p>Ihned poté by se měly zobrazit průběžné informace o probíhajících
výpočtech:</p>

<pre>
Thread-1: 1/10 - Wed Mar 16 09:13:41 2022
Thread-2: 1/10 - Wed Mar 16 09:13:41 2022
Thread-3: 1/10 - Wed Mar 16 09:13:41 2022
Thread-1: 2/10 - Wed Mar 16 09:13:41 2022
Thread-2: 2/10 - Wed Mar 16 09:13:41 2022
Thread-3: 2/10 - Wed Mar 16 09:13:42 2022
Thread-1: 3/10 - Wed Mar 16 09:13:42 2022
</pre>

<p>Dokončení všech výpočtů:</p>

<pre>
Thread-9: 10/10 - Wed Mar 16 09:14:10 2022
Thread-9: DONE!
Thread-10: 5/10 - Wed Mar 16 09:14:11 2022
Thread-10: 6/10 - Wed Mar 16 09:14:13 2022
Thread-10: 7/10 - Wed Mar 16 09:14:14 2022
Thread-10: 8/10 - Wed Mar 16 09:14:15 2022
Thread-10: 9/10 - Wed Mar 16 09:14:17 2022
Thread-10: 10/10 - Wed Mar 16 09:14:18 2022
Thread-10: DONE!
Computing finished
</pre>

<p>A následně se zobrazí hodnoty získané po čekání na dokončení výpočtů:</p>

<pre>
5.0
5.999999999999999
7.000000000000001
7.999999999999999
9.000000000000002
10.0
10.999999999999998
11.999999999999998
13.000000000000002
14.000000000000002
Done!
</pre>

<p>Zdrojový kód předchozího příkladu je možné přepsat do idiomatičtější formy
následovně:</p>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(threadName, delay, n):
    result = 0
&nbsp;
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(threadName, counter, n, time.ctime(time.time())))
        result += delay
&nbsp;
    print("{}: DONE!".format(threadName))
    return result
&nbsp;
&nbsp;
workers = 10
&nbsp;
with ThreadPoolExecutor(max_workers=3) as executor:
    results = [executor.submit(worker, "Thread-{}".format(w + 1), 0.5 + w / 10.0, 10) for w in range(workers)]
&nbsp;
print("Computing finished")
&nbsp;
for result in results:
    print(result.result())

print("Done!")
</pre>

<p>Zprávy vypisované při spuštění:</p>

<pre>
Process-1: 1/10 - Wed Mar 16 09:17:49 2022
Process-2: 1/10 - Wed Mar 16 09:17:49 2022
Process-3: 1/10 - Wed Mar 16 09:17:49 2022
Process-4: 1/10 - Wed Mar 16 09:17:49 2022
Process-5: 1/10 - Wed Mar 16 09:17:49 2022
Process-1: 2/10 - Wed Mar 16 09:17:49 2022
</pre>

<p>Dokončení úloh:</p>

<pre>
Process-10: DONE!
Computing finished
</pre>

<p>Výpis získaných výsledků:</p>

<pre>
5.0
5.999999999999999
7.000000000000001
7.999999999999999
9.000000000000002
10.0
10.999999999999998
11.999999999999998
13.000000000000002
14.000000000000002
Done!
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Od ThreadPoolExecutor k&nbsp;ProcessPoolExecutor</h2>

<p>Již <a
href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">v&nbsp;úvodním
článku</a> jsme si řekli, že souběžné vykonání úloh (resp.&nbsp;operací) lze
realizovat mnoha různými způsoby, zejména použitím korutin, dále
s&nbsp;využitím vláken (<i>threads</i>) nebo spuštěním většího množství procesů
(<i>processes</i>) spravovaných operačním systémem. V&nbsp;předchozích
kapitolách byl ukázán jeden ze způsobů využití vláken získávaných
z&nbsp;<i>poolu</i> s&nbsp;omezenou kapacitou. Prakticky stejný koncept však
můžeme použít i ve chvíli, kdy mají být jednotlivé výpočty realizovány
v&nbsp;samostatně běžících procesech. Pro tento účel se používá třída nazvaná
<strong>ProcessPoolExecutor</strong> z&nbsp;balíčku
<strong>concurrent.futures</strong>. V&nbsp;navazujících kapitolách si ukážeme
základní způsoby využití této třídy.</p>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že tímto způsobem můžeme
obejít GIL, ovšem za tu cenu, že bude spuštěno větší množství virtuálních
strojů Pythonu, což je náročnější s&nbsp;ohledem na dostupné systémové
prostředky.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Použití třídy <strong>ProcessPoolExecutor</strong></h2>

<p>Základní způsob použití třídy <strong>ProcessPoolExecutor</strong> se
(z&nbsp;pohledu programátora) vlastně žádným zásadním způsobem neodlišuje od
použití třídy <strong>ThreadPoolExecutor</strong>. Ostatně následující
demonstrační příklad vypadá velmi podobně, jako příklady uvedené
v&nbsp;předchozích kapitolách:</p>

<pre>
from concurrent.futures import ProcessPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(processName, delay, n):
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(processName, counter, n, time.ctime(time.time())))
&nbsp;
&nbsp;
<strong>with ProcessPoolExecutor(max_workers=3) as executor</strong>:
    <strong>executor.submit</strong>(worker, "Process-1", 0.5, 10)
    <strong>executor.submit</strong>(worker, "Process-2", 1.0, 10)
    <strong>executor.submit</strong>(worker, "Process-3", 1.5, 10)
&nbsp;
&nbsp;
print("Done!")
</pre>

<p>Po spuštění je patrné, že úlohy jsou vykonány v&nbsp;dalších třech
procesech:</p>

<pre>
Process-1: 1/10 - Wed Mar 16 09:16:53 2022
Process-2: 1/10 - Wed Mar 16 09:16:53 2022
Process-1: 2/10 - Wed Mar 16 09:16:53 2022
Process-3: 1/10 - Wed Mar 16 09:16:54 2022
Process-1: 3/10 - Wed Mar 16 09:16:54 2022
Process-2: 2/10 - Wed Mar 16 09:16:54 2022
Process-1: 4/10 - Wed Mar 16 09:16:54 2022
Process-1: 5/10 - Wed Mar 16 09:16:55 2022
Process-3: 2/10 - Wed Mar 16 09:16:55 2022
Process-2: 3/10 - Wed Mar 16 09:16:55 2022
...
...
...
</pre>

<p>O tom, kolik procesů je vlastně spuštěno, se můžeme velmi snadno přesvědčit:</p>

<pre>
$ <strong>ps ax |grep python</strong>
</pre>

<p>V&nbsp;mém konkrétním případě je nutné ignorovat první tři procesy, které
s&nbsp;příkladem nijak nesouvisí. Důležitý je až proces s&nbsp;PID 671007,
který spustil další tři procesy:</p>

<pre>
    598 ?        Ss     0:00 /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers
   1613 ?        S      0:01 /usr/bin/python3 /usr/share/system-config-printer/applet.py
   1653 ?        S      0:00 python3 /usr/lib/blueberry/safechild /usr/sbin/rfkill event
 671007 pts/1    Sl+    0:00 python3 process_pool_1.py
 671008 pts/1    S+     0:00 python3 process_pool_1.py
 671009 pts/1    S+     0:00 python3 process_pool_1.py
 671010 pts/1    S+     0:00 python3 process_pool_1.py
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Získání výsledků z&nbsp;paralelně běžících procesů</h2>

<p>I třída <strong>ProcessPoolExecutor</strong>, podobně jako třída
<strong>ThreadPoolExecutor</strong>, podporuje přístup k&nbsp;výsledkům úloh
s&nbsp;využitím <i>future(s)</i> (interně se ovšem musí používat odlišné
techniky, od nichž jsme jako programátoři odstíněni). Podívejme se tedy, jakým
způsobem lze získat (a ihned vypsat) hodnoty typu <i>future</i>:</p>

<pre>
from concurrent.futures import ProcessPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(processName, delay, n):
    result = 0
&nbsp;
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(processName, counter, n, time.ctime(time.time())))
        result += delay
&nbsp;
    print("{}: DONE!".format(processName))
    return result
&nbsp;
&nbsp;
workers = 10
&nbsp;
<strong>with ProcessPoolExecutor(max_workers=workers) as executor</strong>:
    for w in range(workers):
        print(<strong>executor.submit(worker, "Process-{}".format(w + 1), 0.5 + w / 10.0, 10)</strong>)
&nbsp;
print("Computing finished")
&nbsp;
print("Done!")
</pre>

<p>Chování tohoto demonstračního příkladu po jeho spuštění:</p>

<pre>
&lt;Future at 0x7f875948c340 state=running&gt;
&lt;Future at 0x7f8759493370 state=pending&gt;
&lt;Future at 0x7f8759493820 state=pending&gt;
&lt;Future at 0x7f8759493940 state=pending&gt;
&lt;Future at 0x7f8759493a60 state=pending&gt;
&lt;Future at 0x7f8759493b80 state=pending&gt;
&lt;Future at 0x7f8759493cd0 state=pending&gt;
&lt;Future at 0x7f8759493e80 state=pending&gt;
&lt;Future at 0x7f8759493fa0 state=pending&gt;
&lt;Future at 0x7f8758417100 state=pending&gt;
Process-1: 1/10 - Wed Mar 16 09:17:24 2022
Process-2: 1/10 - Wed Mar 16 09:17:24 2022
Process-3: 1/10 - Wed Mar 16 09:17:24 2022
Process-4: 1/10 - Wed Mar 16 09:17:24 2022
Process-5: 1/10 - Wed Mar 16 09:17:25 2022
Process-1: 2/10 - Wed Mar 16 09:17:25 2022
...
...
...
</pre>

<p>Pro vyhodnocení výsledků je nutné počkat na dokončení příslušných úloh a
poté nad objekty/hodnotami typu <i>future</i> zavolat metodu
<strong>result</strong> (což v&nbsp;případě, že úloha není ještě dokončena,
zajistí čekání na její dokončení):</p>

<pre>
from concurrent.futures import ProcessPoolExecutor
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(processName, delay, n):
    result = 0
&nbsp;
    for counter in range(1, n + 1):
        time.sleep(delay)
        print("{}: {}/{} - {}".format(processName, counter, n, time.ctime(time.time())))
        result += delay
&nbsp;
    print("{}: DONE!".format(processName))
    return result
&nbsp;
&nbsp;
workers = 10
&nbsp;
with ProcessPoolExecutor(max_workers=workers) as executor:
    results = [executor.submit(worker, "Process-{}".format(w + 1), 0.5 + w / 10.0, 10) for w in range(workers)]
&nbsp;
print("Computing finished")
&nbsp;
for result in results:
    print(result.result())
&nbsp;
print("Done!")
</pre>

<p>Otestování příkladu:</p>

<pre>
Process-1: 1/10 - Mon Mar 21 15:46:06 2022
Process-2: 1/10 - Mon Mar 21 15:46:06 2022
Process-3: 1/10 - Mon Mar 21 15:46:06 2022
Process-4: 1/10 - Mon Mar 21 15:46:06 2022
Process-5: 1/10 - Mon Mar 21 15:46:06 2022
Process-1: 2/10 - Mon Mar 21 15:46:06 2022
Process-6: 1/10 - Mon Mar 21 15:46:06 2022
Process-7: 1/10 - Mon Mar 21 15:46:07 2022
Process-2: 2/10 - Mon Mar 21 15:46:07 2022
Process-8: 1/10 - Mon Mar 21 15:46:07 2022
Process-9: 1/10 - Mon Mar 21 15:46:07 2022
Process-3: 2/10 - Mon Mar 21 15:46:07 2022
Process-10: 1/10 - Mon Mar 21 15:46:07 2022
Process-1: 3/10 - Mon Mar 21 15:46:07 2022
Process-4: 2/10 - Mon Mar 21 15:46:07 2022
...
...
...
Process-8: 10/10 - Mon Mar 21 15:46:17 2022
Process-8: DONE!
Process-10: 9/10 - Mon Mar 21 15:46:18 2022
Process-9: 10/10 - Mon Mar 21 15:46:18 2022
Process-9: DONE!
Process-10: 10/10 - Mon Mar 21 15:46:19 2022
Process-10: DONE!
Computing finished
5.0
5.999999999999999
7.000000000000001
7.999999999999999
9.000000000000002
10.0
10.999999999999998
11.999999999999998
13.000000000000002
14.000000000000002
Done!
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Souběžně běžící úlohy a konstrukce <strong>async</strong> a <strong>await</strong></h2>

<p></p>
korutina



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní použití konstrukcí <strong>async</strong> a <strong>await</strong></h2>

<p>První pokus o vytvoření úlohy, která bude reprezentována korutinou, může
vypadat následovně. Úloha je získána transformací funkce <strong>task</strong>
do korutiny, kterou posléze voláme z&nbsp;funkce <strong>main</strong>:</p>

<pre>
import asyncio
import time
&nbsp;
&nbsp;
<strong>async</strong> def task():
    print("task started")
    <strong>await</strong> asyncio.sleep(5)
    print("task finished")
&nbsp;
&nbsp;
def main():
    task1 = asyncio.create_task(task())
    print("task created")
&nbsp;
    <strong>await</strong> task1
&nbsp;
    print("done")
&nbsp;
&nbsp;
main()
</pre>

<p>Tento zápis však není syntakticky korektní, na což nás Python upozorní.
Problém spočívá v&nbsp;tom, že konstrukci <strong>await</strong> lze použít
pouze ve funkci ztransformované na korutinu slovem <strong>async</strong>:</p>

<pre>
  File "async_await_1.py", line 15
    await task1
    ^
SyntaxError: 'await' outside async function
</pre>

<p>Korektní zápis bude vypadat následovně. Povšimněte si, že korutinu
<strong>main</strong> (tedy nikoli již funkci) musíme volat nepřímo přes
<strong>asyncio.run</strong>:</p>

<pre>
import asyncio
import time
&nbsp;
&nbsp;
<strong>async</strong> def task():
    print("task started")
    <strong>await</strong> asyncio.sleep(5)
    print("task finished")
&nbsp;
&nbsp;
<strong>async</strong> def main():
    task1 = asyncio.create_task(task())
    print("task created")
&nbsp;
    <strong>await</strong> task1
&nbsp;
    print("done")
&nbsp;
&nbsp;
asyncio.run(main())
</pre>

<p>Nyní by již výsledek měl odpovídat očekávání:</p>

<pre>
task created
task started
task finished
done
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vytvoření a spuštění dvou korutin s&nbsp;čekáním na jejich dokončení</h2>

<p>Ve druhém příkladu je ukázáno, jak se vytvoří a ihned spustí dvě korutiny,
které simulují činnost synchronním voláním <strong>sleep</strong>. Na dokončení
obou korutin se čeká v&nbsp;konstrukci <strong>await</strong> (přesněji řečeno
se čeká na dokončení první korutiny a teprve poté na dokončení korutiny
druhé):</p>

<pre>
import asyncio
import time
&nbsp;
&nbsp;
<strong>async</strong> def task(name):
    print(f"{name} task started")
    <strong>await</strong> asyncio.sleep(5)
    print(f"{name} task finished")
&nbsp;
&nbsp;
<strong>async</strong> def main():
    task1 = asyncio.create_task(task("first"))
    print("first task created")
&nbsp;
    task2 = asyncio.create_task(task("second"))
    print("second task created")
&nbsp;
    <strong>await</strong> task1
    <strong>await</strong> task2
&nbsp;
    print("done")
&nbsp;
&nbsp;
asyncio.run(main())
</pre>

<p>Výsledek získaný po spuštění:</p>

<pre>
first task created
second task created
first task started
second task started
first task finished
second task finished
done
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Získání výsledků z&nbsp;korutin</h2>

<p>Konstrukci <strong>await</strong> lze použít pro získání (přečtení) výsledků
z&nbsp;korutin, což je hodnota/hodnoty vrácené přes <strong>return</strong>.
Opět si ukažme velmi jednoduchý způsob použití:</p>

<pre>
import asyncio
import time
&nbsp;
&nbsp;
<strong>async</strong> def task(name):
    print(f"{name} task started")
    <strong>await</strong> asyncio.sleep(5)
    print(f"{name} task finished")
    return name[::-1]
&nbsp;
&nbsp;
<strong>async</strong> def main():
    task1 = asyncio.create_task(task("first"))
    print("first task created")
&nbsp;
    task2 = asyncio.create_task(task("second"))
    print("second task created")
&nbsp;
    task3 = asyncio.create_task(task("third"))
    print("third task created")
&nbsp;
    print("result of task #1:", <strong>await</strong> task1)
    print("result of task #2:", <strong>await</strong> task2)
    print("result of task #3:", <strong>await</strong> task3)
&nbsp;
    print("done")
&nbsp;
&nbsp;
asyncio.run(main())
</pre>

<p>Jednotlivé korutiny po určité době vrátí své jméno, ovšem znaky jsou uvedeny
v&nbsp;opačném pořadí:</p>

<pre>
first task created
second task created
third task created
first task started
second task started
third task started
first task finished
second task finished
third task finished
result of task #1: tsrif
result of task #2: dnoces
result of task #3: driht
done
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Fronta jako komunikační kanál</h2>

<pre>
import asyncio
import time
&nbsp;
&nbsp;
<strong>async</strong> def task(name, queue):
    while not queue.empty():
        param = <strong>await</strong> queue.get()
        print(f"Task named {name} started with parameter {param}")
        <strong>await</strong> asyncio.sleep(5)
        print(f"{name} task finished")
&nbsp;
&nbsp;
<strong>async</strong> def main():
    queue = asyncio.Queue()
&nbsp;
    for i in range(20):
        <strong>await</strong> queue.put(i)
&nbsp;
    for n in range(1, 2):
        asyncio.create_task(task(f"{n}", queue))
&nbsp;
&nbsp;
asyncio.run(main())
</pre>

<pre>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
import asyncio
import time


<strong>async</strong> def task(name, queue):
    while not queue.empty():
        param = <strong>await</strong> queue.get()
        print(f"Task named {name} started with parameter {param}")
        <strong>await</strong> asyncio.sleep(5)
        print(f"{name} task finished")


<strong>async</strong> def main():
    queue = asyncio.Queue()

    for i in range(20):
        <strong>await</strong> queue.put(i)

    for n in range(1, 2):
        <strong>await</strong> asyncio.gather(asyncio.create_task(task(f"{n}", queue)))


asyncio.run(main())
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
import asyncio
import time


<strong>async</strong> def task(name, queue):
    while not queue.empty():
        param = <strong>await</strong> queue.get()
        print(f"Task named {name} started with parameter {param}")
        <strong>await</strong> asyncio.sleep(5)
        print(f"{name} task finished")


<strong>async</strong> def main():
    queue = asyncio.Queue()

    for i in range(20):
        <strong>await</strong> queue.put(i)

    <strong>await</strong> asyncio.gather(
            asyncio.create_task(task(1, queue)),
            asyncio.create_task(task(2, queue)),
            asyncio.create_task(task(3, queue)),
            asyncio.create_task(task(4, queue)))


asyncio.run(main())
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Knihovna <strong>aiohttp</strong> &ndash; asynchronní operace přes protokol HTTP</h2>

<p>V&nbsp;závěrečné části dnešního článku se zmíníme o knihovně
<strong>aiohttp</strong>. Tato knihovna podporuje asynchronní operace (GET, PUT
atd.) prováděné přes protokol HTTP a může tak sloužit jako alternativa ke známé
knihovně <i>Requests</i>. Knihovnu <strong>aiohttp</strong> samozřejmě musíme
před prvním použitím nainstalovat:</p>

<pre>
$ <strong>pip3 install --user aiohttp</strong>
&nbsp;
Collecting aiohttp
  Downloading aiohttp-3.8.1-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (1.3 MB)
     |████████████████████████████████| 1.3 MB 834 kB/s            
Collecting frozenlist&gt;=1.1.1
  Downloading frozenlist-1.3.0-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl (158 kB)
     |████████████████████████████████| 158 kB 936 kB/s            
Collecting multidict&lt;7.0,&gt;=4.5
  Downloading multidict-6.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (121 kB)
     |████████████████████████████████| 121 kB 953 kB/s            
Collecting yarl&lt;2.0,&gt;=1.0
  Downloading yarl-1.7.2-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (308 kB)
     |████████████████████████████████| 308 kB 987 kB/s            
Collecting charset-normalizer&lt;3.0,&gt;=2.0
  Downloading charset_normalizer-2.0.12-py3-none-any.whl (39 kB)
Collecting attrs&gt;=17.3.0
  Downloading attrs-21.4.0-py2.py3-none-any.whl (60 kB)
     |████████████████████████████████| 60 kB 817 kB/s            
Collecting aiosignal&gt;=1.1.2
  Downloading aiosignal-1.2.0-py3-none-any.whl (8.2 kB)
Collecting async-timeout&lt;5.0,&gt;=4.0.0a3
  Downloading async_timeout-4.0.2-py3-none-any.whl (5.8 kB)
Requirement already satisfied: idna&gt;=2.0 in /usr/lib/python3/dist-packages (from yarl&lt;2.0,&gt;=1.0-&gt;aiohttp) (2.8)
Installing collected packages: multidict, frozenlist, yarl, charset-normalizer, attrs, async-timeout, aiosignal, aiohttp
Successfully installed aiohttp-3.8.1 aiosignal-1.2.0 async-timeout-4.0.2 attrs-21.4.0 charset-normalizer-2.0.12 frozenlist-1.3.0 multidict-6.0.2 yarl-1.7.2
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příklad použití knihovny <strong>aiohttp</strong></h2>

<p>V&nbsp;prvním příkladu, v&nbsp;němž je knihovna <strong>aiohttp</strong>
použita, je ukázán způsob souběžného stahování (resp.&nbsp;přístupu) na několik
webových stránek. Jedná se o typickou úlohu, v&nbsp;níž mají velký význam I/O
operace (čekání na odpověď) a tedy je žádoucí, aby tyto operace probíhaly
souběžně. V&nbsp;příkladu je pro naplánování úloh použita knihovna
<strong>asyncio</strong> a pro komunikaci fronta reprezentovaná třídou
<strong>asyncio.Queue</strong>. Samotný přístup k&nbsp;webovým stránkám
zajišťuje knihovna <strong>aiohttp</strong> &ndash; nejprve se vytvoří sezení
(<i>session</i>) a následně se zavolá metoda <strong>session.get</strong> pro
přístup k&nbsp;webové stránce:</p>

<pre>
import asyncio
import aiohttp
import time
&nbsp;
&nbsp;
<strong>async</strong> def download(name, queue):
    <strong>async</strong> with aiohttp.ClientSession() as session:
        while not queue.empty():
            url = <strong>await</strong> queue.get()
            print(f"Task named {name} getting URL: {url}")
            <strong>async</strong> with session.get(url) as response:
                t = <strong>await</strong> response.text()
                print(f"Task named {name} downloaded {len(t)} characters")
            print(f"Task named {name} finished")
&nbsp;
&nbsp;
<strong>async</strong> def main():
    queue = asyncio.Queue()
&nbsp;
    for url in (
        "http://www.root.cz",
        "http://duckduckgo.com",
        "http://seznam.com",
        "https://www.root.cz/programovaci-jazyky/",
        "https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/",
        "https://github.com/"
    ):
        <strong>await</strong> queue.put(url)
&nbsp;
    <strong>await</strong> asyncio.gather(
            asyncio.create_task(download(1, queue)),
            asyncio.create_task(download(2, queue)))
&nbsp;
&nbsp;
asyncio.run(main())
</pre>

<p>Ukázka souběžného přístupu ke dvěma stránkám po spuštění příkladu:</p>

<pre>
Task named 1 getting URL: http://www.root.cz
Task named 2 getting URL: http://duckduckgo.com
Task named 2 downloaded 5775 characters
Task named 2 finished
Task named 2 getting URL: http://seznam.com
Task named 1 downloaded 249826 characters
Task named 1 finished
Task named 1 getting URL: https://www.root.cz/programovaci-jazyky/
Task named 1 downloaded 251068 characters
Task named 1 finished
Task named 1 getting URL: https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/
Task named 2 downloaded 1555 characters
Task named 2 finished
Task named 2 getting URL: https://github.com/
Task named 2 downloaded 209166 characters
Task named 2 finished
Task named 1 downloaded 235800 characters
Task named 1 finished
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Doba trvání dotazů vs.&nbsp;celková doba běhu programu</h2>

<p>Nepatrnou úpravou předchozího zdrojového kódu si můžeme nechat vypsat dobu
trvání jednotlivých dotazů i celkovou dobu běhu demonstračního příkladu. Přitom
budeme předpokládat, že celková doba běhu bude kratší než součet doby vyřízení
jednotlivých dotazů (resp.&nbsp;doby mezi posláním dotazu a získáním odpovědi).
Prozatím budeme vypočtené časy pouze vypisovat na standardní výstup:</p>

<pre>
import asyncio
import aiohttp
import time
&nbsp;
&nbsp;
<strong>async</strong> def download(name, queue):
    <strong>async</strong> with aiohttp.ClientSession() as session:
        while not queue.empty():
            url = <strong>await</strong> queue.get()
            t1 = time.time()
            print(f"Task named {name} getting URL: {url}")
            <strong>async</strong> with session.get(url) as response:
                t = <strong>await</strong> response.text()
                t2 = time.time()
                print(f"Task named {name} downloaded {len(t)} characters in {t2-t1} seconds")
            print(f"Task named {name} finished")
&nbsp;
&nbsp;
<strong>async</strong> def main():
    queue = asyncio.Queue()
&nbsp;
    t1 = time.time()
&nbsp;
    for url in (
        "http://www.root.cz",
        "http://duckduckgo.com",
        "http://seznam.com",
        "https://www.root.cz/programovaci-jazyky/",
        "https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/",
        "https://www.root.cz/clanky/pywebio-interaktivni-webove-dialogy-a-formulare-v-cistem-pythonu/",
        "https://streamlit.io/",
        "https://pglet.io/",
        "https://www.root.cz/serialy/graficke-uzivatelske-rozhrani-v-pythonu/",
        "https://github.com/"
    ):
        <strong>await</strong> queue.put(url)
&nbsp;
    <strong>await</strong> asyncio.gather(
            asyncio.create_task(download(1, queue)),
            asyncio.create_task(download(2, queue)),
            asyncio.create_task(download(3, queue)))
&nbsp;
    t2 = time.time()
    print(f"Total time: {t2-t1} seconds")
&nbsp;
asyncio.run(main())
</pre>

<p>A takto může vypadat výsledek:</p>

<pre>
Task named 1 getting URL: http://www.root.cz
Task named 2 getting URL: http://duckduckgo.com
Task named 3 getting URL: http://seznam.com
Task named 2 downloaded 5775 characters in 0.3052408695220947 seconds
Task named 2 finished
Task named 2 getting URL: https://www.root.cz/programovaci-jazyky/
Task named 1 downloaded 249910 characters in 0.4537777900695801 seconds
Task named 1 finished
Task named 1 getting URL: https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/
Task named 3 downloaded 1555 characters in 0.4831697940826416 seconds
Task named 3 finished
Task named 3 getting URL: https://www.root.cz/clanky/pywebio-interaktivni-webove-dialogy-a-formulare-v-cistem-pythonu/
Task named 2 downloaded 251382 characters in 0.5078389644622803 seconds
Task named 2 finished
Task named 2 getting URL: https://streamlit.io/
Task named 1 downloaded 236297 characters in 0.4007532596588135 seconds
Task named 1 finished
Task named 1 getting URL: https://pglet.io/
Task named 3 downloaded 236033 characters in 0.4225172996520996 seconds
Task named 3 finished
Task named 3 getting URL: https://www.root.cz/serialy/graficke-uzivatelske-rozhrani-v-pythonu/
Task named 2 downloaded 444341 characters in 0.42142748832702637 seconds
Task named 2 finished
Task named 2 getting URL: https://github.com/
Task named 1 downloaded 10145 characters in 0.5715913772583008 seconds
Task named 1 finished
Task named 3 downloaded 263715 characters in 0.521721601486206 seconds
Task named 3 finished
Task named 2 downloaded 209167 characters in 0.22428131103515625 seconds
Task named 2 finished
Total time: 1.4610064029693604 seconds
</pre>

<p><div class="rs-tip-major">Poznámka: vidíme, že celková doba běhu je rovna
1,46 sekund, zatímco je evidentní, že součet času mezi jednotlivými dotazy a
odpovědmi je mnohem větší.</div></p>

<p>Na závěr si ukažme ještě jednu úpravu tohoto příkladu. Nyní budeme časy mezi
dotazem a odpovědí jednotlivých korutin ukládat do fronty
<strong>results</strong>, což nám na závěr umožní vypočítat součet všech časů
dotaz-odpověď:</p>

<pre>
import asyncio
import aiohttp
import time
&nbsp;
&nbsp;
<strong>async</strong> def download(name, queue, results):
    <strong>async</strong> with aiohttp.ClientSession() as session:
        while not queue.empty():
            url = <strong>await</strong> queue.get()
            t1 = time.time()
            print(f"Task named {name} getting URL: {url}")
            <strong>async</strong> with session.get(url) as response:
                t = <strong>await</strong> response.text()
                t2 = time.time()
                print(f"Task named {name} downloaded {len(t)} characters in {t2-t1} seconds")
                <strong>await</strong> results.put(t2-t1)
            print(f"Task named {name} finished")
&nbsp;
&nbsp;
<strong>async</strong> def main():
    queue = asyncio.Queue()
    results = asyncio.Queue()
&nbsp;
    t1 = time.time()
&nbsp;
    for url in (
        "http://www.root.cz",
        "http://duckduckgo.com",
        "http://seznam.com",
        "https://www.root.cz/programovaci-jazyky/",
        "https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/",
        "https://www.root.cz/clanky/pywebio-interaktivni-webove-dialogy-a-formulare-v-cistem-pythonu/",
        "https://streamlit.io/",
        "https://pglet.io/",
        "https://www.root.cz/serialy/graficke-uzivatelske-rozhrani-v-pythonu/",
        "https://github.com/"
    ):
        <strong>await</strong> queue.put(url)
&nbsp;
    <strong>await</strong> asyncio.gather(
            asyncio.create_task(download(1, queue, results)),
            asyncio.create_task(download(2, queue, results)),
            asyncio.create_task(download(3, queue, results)))
&nbsp;
    process_time = 0
    while not results.empty():
        process_time += <strong>await</strong> results.get()
&nbsp;
    print(f"Process time: {process_time} seconds")
&nbsp;
    t2 = time.time()
    print(f"Total time:   {t2-t1} seconds")
&nbsp;
asyncio.run(main())
</pre>

<p>Výsledky:</p>

<pre>
Task named 1 getting URL: http://www.root.cz
Task named 2 getting URL: http://duckduckgo.com
Task named 3 getting URL: http://seznam.com
Task named 2 downloaded 5775 characters in 0.31725001335144043 seconds
Task named 2 finished
Task named 2 getting URL: https://www.root.cz/programovaci-jazyky/
Task named 3 downloaded 1555 characters in 0.43852806091308594 seconds
Task named 3 finished
Task named 3 getting URL: https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/
Task named 1 downloaded 249707 characters in 0.535081148147583 seconds
Task named 1 finished
Task named 1 getting URL: https://www.root.cz/clanky/pywebio-interaktivni-webove-dialogy-a-formulare-v-cistem-pythonu/
Task named 2 downloaded 251515 characters in 0.3788483142852783 seconds
Task named 2 finished
Task named 2 getting URL: https://streamlit.io/
Task named 1 downloaded 235679 characters in 0.2868804931640625 seconds
Task named 1 finished
Task named 1 getting URL: https://pglet.io/
Task named 3 downloaded 236045 characters in 0.41786885261535645 seconds
Task named 3 finished
Task named 3 getting URL: https://www.root.cz/serialy/graficke-uzivatelske-rozhrani-v-pythonu/
Task named 2 downloaded 444341 characters in 0.3120858669281006 seconds
Task named 2 finished
Task named 2 getting URL: https://github.com/
Task named 1 downloaded 10145 characters in 0.21546196937561035 seconds
Task named 1 finished
Task named 3 downloaded 263683 characters in 0.29593372344970703 seconds
Task named 3 finished
Task named 2 downloaded 209173 characters in 0.28455424308776855 seconds
Task named 2 finished
<strong>Process time: 3.482492685317993 seconds</strong>
<strong>Total time:   1.2949903011322021 seconds</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: nyní je z&nbsp;vypsaných výsledků zcela
zřejmé, že namísto cca 3,5 sekundy se nám díky korutinám podařilo celkovou dobu
běhu programu snížit na cca 1,3 sekundy. Je však možné i další snížení
celkového času, a to zvětšením počtu korutin, například na deset:</div></p>

<pre>
Task named 1 getting URL: http://www.root.cz
Task named 2 getting URL: http://duckduckgo.com
Task named 3 getting URL: http://seznam.com
Task named 4 getting URL: https://www.root.cz/programovaci-jazyky/
Task named 5 getting URL: https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/
Task named 6 getting URL: https://www.root.cz/clanky/pywebio-interaktivni-webove-dialogy-a-formulare-v-cistem-pythonu/
Task named 7 getting URL: https://streamlit.io/
Task named 8 getting URL: https://pglet.io/
Task named 9 getting URL: https://www.root.cz/serialy/graficke-uzivatelske-rozhrani-v-pythonu/
Task named 10 getting URL: https://github.com/
Task named 8 downloaded 10145 characters in 0.2201550006866455 seconds
Task named 8 finished
Task named 10 downloaded 209167 characters in 0.26105284690856934 seconds
Task named 10 finished
Task named 7 downloaded 444341 characters in 0.31197690963745117 seconds
Task named 7 finished
Task named 2 downloaded 5775 characters in 0.3665473461151123 seconds
Task named 2 finished
Task named 4 downloaded 252883 characters in 0.41240453720092773 seconds
Task named 4 finished
Task named 9 downloaded 265455 characters in 0.41875481605529785 seconds
Task named 9 finished
Task named 3 downloaded 1555 characters in 0.46982383728027344 seconds
Task named 3 finished
Task named 6 downloaded 235728 characters in 0.4692232608795166 seconds
Task named 6 finished
Task named 1 downloaded 250629 characters in 0.4968068599700928 seconds
Task named 1 finished
Task named 5 downloaded 236190 characters in 0.5269002914428711 seconds
Task named 5 finished
<strong>Process time: 3.953645706176758 seconds</strong>
<strong>Total time:   0.529677152633667 seconds</strong>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech <a
href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">minule</a>
i dnes popsaných demonstračních příkladů určených pro programovací jazyk Python
3 byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>multithreading1.py</td><td>spuštění tří vláken vykonávajících déletrvající činnost</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading1.py</a></td></tr>
<tr><td> 2</td><td>multithreading2.py</td><td>spuštění tří vláken, předání parametrů volaným funkcím</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading2.py</a></td></tr>
<tr><td> 3</td><td>multithreading3.py</td><td>explicitní čekání na dokončení běhu vláken metodou <strong>join</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading3.py</a></td></tr>
<tr><td> 4</td><td>multithreading4.py</td><td>sdílený objekt</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading4.py</a></td></tr>
<tr><td> 5</td><td>multithreading_join_deamon.py</td><td>čekání na dokončení vláken s&nbsp;příznakem &bdquo;daemon&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_join_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_join_deamon.py</a></td></tr>
<tr><td> 6</td><td>multithreading_no_join_deamon.py</td><td>vlákna s&nbsp;příznakem &bdquo;daemon&ldquo;, na jejichž ukončení se nečeká</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_deamon.py</a></td></tr>
<tr><td> 7</td><td>multithreading_no_join_no_deamon.py</td><td>běžná vlákna bez příznaku &bdquo;daemon&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_no_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_no_deamon.py</a></td></tr>
<tr><td> 8</td><td>multithreading_timeout.py</td><td>specifikace maximální doby čekání na ukončení vlákna</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_timeout.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_timeout.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>multiprocessing1.py</td><td>zavolání funkce spuštěné v&nbsp;rámci dalšího procesu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing1.py</a></td></tr>
<tr><td>10</td><td>multiprocessing2.py</td><td>spuštění většího množství procesů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing2.py</a></td></tr>
<tr><td>11</td><td>multiprocessing3.py</td><td>nepatrná úprava předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing3.py</a></td></tr>
<tr><td>12</td><td>multiprocessing4.py</td><td>řízení workerů posílanými příkazy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing4.py</a></td></tr>
<tr><td>13</td><td>multiprocessing5.py</td><td>řízení workerů posílanými příkazy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing5.py</a></td></tr>
<tr><td>14</td><td>multiprocessing6.py</td><td>jeden proces a sdílená globální hodnota</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing6.py</a></td></tr>
<tr><td>15</td><td>multiprocessing7.py</td><td>více procesů, které nesdílí hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing7.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>queue_example.py</td><td>základní vlastnosti sdílené datové struktury <strong>Queue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queue_example.py</a></td></tr>
<tr><td>17</td><td>simple_queue_example.py</td><td>základní vlastnosti sdílené datové struktury <strong>SimpleQueue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/simple_queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/simple_queue_example.py</a></td></tr>
<tr><td>18</td><td>priority_queue_example.py</td><td>základní vlastnosti sdílené datové struktury <strong>PriorityQueue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/priority_queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/priority_queue_example.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>queues1.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: základní forma</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues1.py</a></td></tr>
<tr><td>20</td><td>queues2.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: více konzumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues2.py</a></td></tr>
<tr><td>21</td><td>queues3.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: více producentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues3.py</a></td></tr>
<tr><td>22</td><td>queues4.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: více producentů i konzumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>thread_pool_1.py</td><td>spuštění tří úloh ve třech vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_1.py</a></td></tr>
<tr><td>24</td><td>thread_pool_2.py</td><td>spuštění deseti úloh v&nbsp;deseti vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_2.py</a></td></tr>
<tr><td>25</td><td>thread_pool_3.py</td><td>omezení počtu vláken na 3 pro celkem deset úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_3.py</a></td></tr>
<tr><td>26</td><td>thread_pool_4.py</td><td>návratová hodnota získaná po spuštění úlohy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_4.py</a></td></tr>
<tr><td>27</td><td>thread_pool_5.py</td><td>získání vypočtených hodnot</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_5.py</a></td></tr>
<tr><td>28</td><td>thread_pool_6.py</td><td>alternativní způsob zápisu předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>process_pool_1.py</td><td>spuštění tří úloh ve vlastních procesech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_1.py</a></td></tr>
<tr><td>30</td><td>process_pool_2.py</td><td>návratové hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_2.py</a></td></tr>
<tr><td>31</td><td>process_pool_3.py</td><td>čekání na dokončení úloh + získání návratových hodnot</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>async_await_1.py</td><td>základní způsob použití <strong>async</strong> a <strong>await</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_1.py</a></td></tr>
<tr><td>33</td><td>async_await_2.py</td><td>funkce <strong>main</strong> volaná asynchronně</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_2.py</a></td></tr>
<tr><td>34</td><td>async_await_3.py</td><td>dvě asynchronně běžící úlohy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_3.py</a></td></tr>
<tr><td>35</td><td>async_await_4.py</td><td>získání výsledků z&nbsp;asynchronně běžících úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_4.py</a></td></tr>
<tr><td>36</td><td>async_queue_1.py</td><td>fronty pro kooperace mezi korutinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_1.py</a></td></tr>
<tr><td>37</td><td>async_queue_2.py</td><td>korektní spuštění většího množství korutin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_2.py</a></td></tr>
<tr><td>38</td><td>async_queue_3.py</td><td>využití <strong>asyncio.gather</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_3.py</a></td></tr>
<tr><td>39</td><td>async_aiohttp_1.py</td><td>použití knihovny <strong>aiohttp</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_1.py</a></td></tr>
<tr><td>40</td><td>async_aiohttp_2.py</td><td>záznam časů trvání jednotlivých operací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_2.py</a></td></tr>
<tr><td>41</td><td>async_aiohttp_3.py</td><td>vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_3.py</a></td></tr>
<tr><td>42</td><td>async_aiohttp_4.py</td><td>využití deseti korutin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_4.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace Pythonu: balíček queue<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Dokumentace Pythonu: balíček threading<br />
<a href="https://docs.python.org/3/library/threading.html?">https://docs.python.org/3/library/threading.html?</a>
</li>

<li>Dokumentace Pythonu: balíček multiprocessing<br />
<a href="https://docs.python.org/3/library/multiprocessing.html">https://docs.python.org/3/library/multiprocessing.html</a>
</li>

<li>Dokumentace Pythonu: balíček asyncio<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Synchronization Primitives<br />
<a href="https://docs.python.org/3/library/asyncio-sync.html">https://docs.python.org/3/library/asyncio-sync.html</a>
</li>

<li>Coroutines<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Queues<br />
<a href="https://docs.python.org/3/library/asyncio-queue.html">https://docs.python.org/3/library/asyncio-queue.html</a>
</li>

<li>python-csp<br />
<a href="https://python-csp.readthedocs.io/en/latest/">https://python-csp.readthedocs.io/en/latest/</a>
</li>

<li>TrellisSTM<br />
<a href="http://peak.telecommunity.com/DevCenter/TrellisSTM">http://peak.telecommunity.com/DevCenter/TrellisSTM</a>
</li>

<li>Python Multithreading and Multiprocessing Tutorial<br />
<a href="https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python">https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python</a>
</li>

<li>ThreadPoolExecutor<br />
<a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor">https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor</a>
</li>

<li>ProcessPoolExecutor<br />
<a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor">https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor</a>
</li>

<li>asyncio — Asynchronous I/O<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Threads vs Async: Has Asyncio Solved Concurrency?<br />
<a href="https://www.youtube.com/watch?v=NZq31Sg8R9E">https://www.youtube.com/watch?v=NZq31Sg8R9E</a>
</li>

<li>Python Asynchronous Programming &ndash; AsyncIO &amp; Async/Await<br />
<a href="https://www.youtube.com/watch?v=t5Bo1Je9EmE">https://www.youtube.com/watch?v=t5Bo1Je9EmE</a>
</li>

<li>AsyncIO &amp; Asynchronous Programming in Python<br />
<a href="https://www.youtube.com/watch?v=6RbJYN7SoRs">https://www.youtube.com/watch?v=6RbJYN7SoRs</a>
</li>

<li>Coroutines and Tasks<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Python async/await Tutorial<br />
<a href="https://stackabuse.com/python-async-await-tutorial/">https://stackabuse.com/python-async-await-tutorial/</a>
</li>

<li>Demystifying Python's Async and Await Keywords<br />
<a href="https://www.youtube.com/watch?v=F19R_M4Nay4">https://www.youtube.com/watch?v=F19R_M4Nay4</a>
</li>

<li>Curio<br />
<a href="https://curio.readthedocs.io/en/latest/">https://curio.readthedocs.io/en/latest/</a>
</li>

<li>Trio: a friendly Python library for async concurrency and I/O<br />
<a href="https://trio.readthedocs.io/en/stable/">https://trio.readthedocs.io/en/stable/</a>
</li>

<li>Curio &ndash; A Tutorial Introduction<br />
<a href="https://curio.readthedocs.io/en/latest/tutorial.html">https://curio.readthedocs.io/en/latest/tutorial.html</a>
</li>

<li>unsync<br />
<a href="https://github.com/alex-sherman/unsync">https://github.com/alex-sherman/unsync</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

