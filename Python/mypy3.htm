<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o statických typových kontrolách v Pythonu založených na nástroji Mypy si ukážeme, jak se používá striktní režim Mypy i to, jak se pracuje s generickými datovými typy. Taktéž si popíšeme způsob výpisu typů zvolených symbolů či všech lokálních proměnných v průběhu statické typové analýzy a zmíníme se o neměnitelných hodnotách.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)</a></p>
<p><a href="#k02">2. Duplikace u specifikací datových typů</a></p>
<p><a href="#k03">3. Definice nových datových typů</a></p>
<p><a href="#k04">4. Upravený kód demonstračního příkladu s&nbsp;definicí vlastního datového typu</a></p>
<p><a href="#k05">5. Striktní kontrola typů nástrojem Mypy</a></p>
<p><a href="#k06">6. Použití typově bezpečného generického datového typu</a></p>
<p><a href="#k07">7. Seznam či sekvence spritů?</a></p>
<p><a href="#k08">8. Zpětná kompatibilita se staršími verzemi Pythonu</a></p>
<p><a href="#k09">9. Upravený kód demonstračního příkladu, který již projde striktní typovou kontrolou</a></p>
<p><a href="#k10">10. Selektivní zjištění typu proměnné či třídy nástrojem Mypy</a></p>
<p><a href="#k11">11. Selektivní zjištění typu funkce nástrojem Mypy</a></p>
<p><a href="#k12">12. Typová inference</a></p>
<p><a href="#k13">13. Explicitní definice typu versus typová inference</a></p>
<p><a href="#k14">14. Zjištění typů všech lokálních proměnných</a></p>
<p><a href="#k15">15. Podpora neměnitelných hodnot (<i>immutable</i>)</a></p>
<p><a href="#k16">16. Příloha 1: základní dostupné datové typy</a></p>
<p><a href="#k17">17. Příloha 2: dostupné generické typy</a></p>
<p><a href="#k18">18. Příloha 3: rozdíly mezi Pythonem &lt; 3.9 a novějšími verzemi</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)</h2>

<p>Ve třetím článku o statických typových kontrolách v&nbsp;Pythonu založených
na nástroji <i>Mypy</i> navážeme na <a
href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/">předchozí
článek</a>, v&nbsp;němž jsme si mj.&nbsp;ukázali, jakým způsobem je možné
postupně do existujících zdrojových kódů psaných v&nbsp;Pythonu přidávat typové
informace. Připomeňme si, že poslední zdrojový kód, který jsme si minule
ukázali, byl doplněn o většinu typových informací, byly v&nbsp;něm opraveny
nalezené chyby a výsledek vypadal následovně:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from typing import Tuple, List
&nbsp;
import pygame
import sys
&nbsp;
<i># Nutno importovat kvůli konstantám QUIT atd.</i>
from pygame.locals import *
&nbsp;
<i># Velikost okna aplikace</i>
WIDTH = 320
HEIGHT = 240
&nbsp;
<i># Konstanty s n-ticemi představujícími základní barvy</i>
BLACK: Tuple[int, int, int] = (0, 0, 0)
RED: Tuple[int, int, int] = (255, 0, 0)
GRAY: Tuple[int, int, int] = (128, 128, 128)
YELLOW: Tuple[int, int, int] = (255, 255, 0)
&nbsp;
CAPTION = "Sprites in Pygame"
&nbsp;
&nbsp;
<i># Třída představující sprite zobrazený jako jednobarevný čtverec.</i>
class <strong>BlockySprite</strong>(pygame.sprite.Sprite):
    <i># Konstruktor</i>
    def <strong>__init__</strong>(self, color: Tuple[int, int, int], size: int, x: int, y: int):
        <i># Nejprve je nutné zavolat konstruktor předka,</i>
        <i># tj. konstruktor třídy pygame.sprite.Sprite:</i>
        pygame.sprite.Sprite.__init__(self)
&nbsp;
        <i># Vytvoření obrázku představujícího vizuální obraz spritu:</i>
        self.image = pygame.Surface([size, size])
        self.image.fill(color)
&nbsp;
        <i># Vytvoření obalového obdélníku</i>
        <i># (velikost se získá z rozměru obrázku)</i>
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
&nbsp;
        <i># Počáteční rychlost spritu</i>
        self.speed_x = 0
        self.speed_y = 0
&nbsp;
    <i># Nastavení barvy spritu, který kolidoval s hráčem</i>
    def <strong>yellowColor</strong>(self) -&gt; None:
        self.image.fill(YELLOW)
&nbsp;
    <i># Nastavení barvy spritu, který nekolidoval s hráčem</i>
    def <strong>grayColor</strong>(self) -&gt; None:
        self.image.fill(GRAY)
&nbsp;
&nbsp;
def <strong>initDisplay</strong>(caption: str) -&gt; pygame.Surface:
    <i># Vytvoření okna pro vykreslování</i>
    display = pygame.display.set_mode([WIDTH, HEIGHT])
&nbsp;
    <i># Nastavení titulku okna</i>
    pygame.display.set_caption(caption)
&nbsp;
    return display
&nbsp;
&nbsp;
def <strong>createSprites</strong>() -&gt; Tuple[pygame.sprite.Group, pygame.sprite.Group, BlockySprite]:
    <i># Objekt sdružující všechny sprity</i>
    all_sprites: pygame.sprite.Group = pygame.sprite.Group()
&nbsp;
    <i># Objekt sdružující všechny sprity kromě hráče</i>
    all_sprites_but_player: pygame.sprite.Group = pygame.sprite.Group()
&nbsp;
    <i># Vytvoření několika typů spritů</i>
    <i>#                    barva  x   y velikost</i>
    wall1 = BlockySprite(GRAY, 50, 10, 10)
    wall2 = BlockySprite(GRAY, 15, 100, 100)
    wall3 = BlockySprite(GRAY, 15, 100, 150)
    wall4 = BlockySprite(GRAY, 15, 200, 100)
    wall5 = BlockySprite(GRAY, 15, 200, 150)
    wall6 = BlockySprite(GRAY, 15, 150, 100)
    wall7 = BlockySprite(GRAY, 15, 150, 150)
    player = BlockySprite(RED, 40, WIDTH // 2 - 20, HEIGHT // 2 - 20)
&nbsp;
    <i># Přidání několika dalších spritů do seznamu</i>
    <i># (jen jeden sprite - ten poslední - bude ve skutečnosti pohyblivý)</i>
    all_sprites.add(wall1)
    all_sprites.add(wall2)
    all_sprites.add(wall3)
    all_sprites.add(wall4)
    all_sprites.add(wall5)
    all_sprites.add(wall6)
    all_sprites.add(wall7)
    all_sprites.add(player)
&nbsp;
    <i># Seznam všech nepohyblivých spritů</i>
    all_sprites_but_player.add(wall1)
    all_sprites_but_player.add(wall2)
    all_sprites_but_player.add(wall3)
    all_sprites_but_player.add(wall4)
    all_sprites_but_player.add(wall5)
    all_sprites_but_player.add(wall6)
    all_sprites_but_player.add(wall7)
&nbsp;
    return all_sprites, all_sprites_but_player, player
&nbsp;
&nbsp;
<i># Posun všech spritů ve skupině na základě jejich rychlosti</i>
def <strong>move_sprites</strong>(sprite_group: pygame.sprite.Group, playground_width: int, playground_height:int) -&gt; None:
    for sprite in sprite_group:
        <i># Posun spritu</i>
        sprite.rect.x = sprite.rect.x + sprite.speed_x
        sprite.rect.y = sprite.rect.y + sprite.speed_y
        <i># Kontrola, zda sprite nenarazil do okrajů okna</i>
        if sprite.rect.x &lt; 0:
            sprite.rect.x = 0
            sprite.speed_x = 0
        if sprite.rect.x + sprite.rect.width &gt; playground_width:
            sprite.rect.x = playground_width - sprite.rect.width
            sprite.speed_x = 0
        if sprite.rect.y &lt; 0:
            sprite.rect.y = 0
            sprite.speed_y = 0
        if sprite.rect.y + sprite.rect.height &gt; playground_height:
            sprite.rect.y = playground_height - sprite.rect.height
            sprite.speed_y = 0
&nbsp;
&nbsp;
<i># Vykreslení celé scény na obrazovku</i>
def <strong>draw_scene</strong>(display: pygame.Surface, background_color: Tuple[int, int, int], sprite_group: pygame.sprite.Group) -&gt; None:
    <i># Vyplnění plochy okna černou barvou</i>
    display.fill(background_color)
    <i># Vykreslení celé skupiny spritů do bufferu</i>
    sprite_group.draw(display)
    <i># Obnovení obsahu obrazovky (překlopení zadního a předního bufferu)</i>
    pygame.display.update()
&nbsp;
&nbsp;
<i># Změna barvy spritu na základě kolize s hráčem</i>
def <strong>change_colors</strong>(sprite_group: pygame.sprite.Group, hit_list: List[pygame.sprite.Sprite]) -&gt; None:
    <i># Projít všemi sprity ze skupiny, kterou detekovala kolizní funkce</i>
    for sprite in sprite_group:
        if sprite in hit_list:
            sprite.yellowColor()
        else:
            sprite.grayColor()
&nbsp;
&nbsp;
<i># Zjistí kolize spritu se "stěnami" (nepohyblivými sprity)</i>
def <strong>check_collisions</strong>(player: BlockySprite, sprite_group: pygame.sprite.Group) -&gt; None:
    <i># Vytvoření seznamu spritů, které kolidují s hráčem</i>
    hit_list = pygame.sprite.spritecollide(player, sprite_group, False)
    <i># Změna barev kolidujících spritů</i>
    change_colors(sprite_group, hit_list)
    collisions = len(hit_list)
    <i># Přenastavení titulku okna</i>
    caption = CAPTION + ": collisions " + str(collisions)
    pygame.display.set_caption(caption)
&nbsp;
&nbsp;
def <strong>mainLoop</strong>(display: pygame.Surface, clock: pygame.time.Clock,
        all_sprites: pygame.sprite.Group,
        all_sprites_but_player: pygame.sprite.Group, player: BlockySprite) -&gt; None:
    while True:
        <i># Načtení a zpracování všech událostí z fronty</i>
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                <i># Stiskem kurzorových kláves je možné měnit směr pohybu spritu</i>
                elif event.key == pygame.K_LEFT:
                    player.speed_x = -3
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = +3
                elif event.key == pygame.K_UP:
                    player.speed_y = -3
                elif event.key == pygame.K_DOWN:
                    player.speed_y = +3
            if event.type == KEYUP:
                <i># Puštění kurzorových kláves vede k zastavení pohybu spritu</i>
                if event.key == pygame.K_LEFT:
                    player.speed_x = 0
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = 0
                elif event.key == pygame.K_UP:
                    player.speed_y = 0
                elif event.key == pygame.K_DOWN:
                    player.speed_y = 0
&nbsp;
        move_sprites(all_sprites, display.get_width(), display.get_height())
        check_collisions(player, all_sprites_but_player)
        draw_scene(display, BLACK, all_sprites)
        clock.tick(20)
&nbsp;
&nbsp;
def <strong>main</strong>() -&gt; None:
    <i># Inicializace knihovny Pygame</i>
    pygame.init()
&nbsp;
    clock = pygame.time.Clock()
    display = initDisplay(CAPTION)
&nbsp;
    all_sprites, all_sprites_but_player, player = createSprites()
&nbsp;
    mainLoop(display, clock, all_sprites, all_sprites_but_player, player)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
<i># finito</i>
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Duplikace u specifikací datových typů</h2>

<p>V&nbsp;předchozím zdrojovém kódu je možné najít hned několik míst, u nichž
specifikujeme shodný datový typ, resp.&nbsp;přesněji řečeno shodný typ
z&nbsp;hlediska typového systému Pythonu &ndash; například jiný typový systém
by tato místa považoval za specifikaci zcela unikátních a nekompatibilních
typů:</p>

<pre>
BLACK: <strong>Tuple[int, int, int]</strong> = (0, 0, 0)
RED: <strong>Tuple[int, int, int]</strong> = (255, 0, 0)
GRAY: <strong>Tuple[int, int, int]</strong> = (128, 128, 128)
YELLOW: <strong>Tuple[int, int, int]</strong> = (255, 255, 0)
&nbsp;
def __init__(self, color: <strong>Tuple[int, int, int]</strong>, size: int, x: int, y: int):
&nbsp;
def draw_scene(display: pygame.Surface, background_color: <strong>Tuple[int, int, int]</strong>, sprite_group: pygame.sprite.Group) -&gt; None:
</pre>

<p>Je možné nějakým způsobem tyto opakující se části kódu sjednotit?
V&nbsp;jiných programovacích jazycích se statickým typovým systémem se tato
operace provádí jednoduše &ndash; definicí nového datového typu. V&nbsp;Mypy
tomu je podobně, i když způsob definice nového datového typu nám může připadat
poněkud neobvyklý.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Definice nových datových typů</h2>

<p>Pro definici nového datového typu se v&nbsp;Pythonu (Mypy) nepoužívá
speciální syntaxe (ta prozatím neexistuje). Namísto toho se volá funkce
<strong>NewType</strong>:</p>

<pre>
NewType(name, tp)
    NewType creates simple unique types with almost zero
    runtime overhead. NewType(name, tp) is considered a subtype of tp
    by static type checkers. At runtime, NewType(name, tp) returns
    a dummy function that simply returns its argument. Usage::
&nbsp;
        UserId = NewType('UserId', int)
&nbsp;
        def name_by_id(user_id: UserId) -&gt; str:
            ...
&nbsp;
        UserId('user')          # Fails type check
&nbsp;
        name_by_id(42)          # Fails type check
        name_by_id(UserId(42))  # OK
&nbsp;
        num = UserId(5) + 1     # type: int
</pre>

<p>Prvním parametrem této funkce je tedy jméno nově definovaného typu
(použitého pro Mypy), druhým parametrem pak nadtyp, z&nbsp;něhož je nový datový
typ odvozen. Vrácenou hodnotou je funkce, která pouze vrací svůj argument:</p>

<pre>
&gt;&gt;&gt; real = <strong>NewType</strong>("real", float)
&nbsp;
&gt;&gt;&gt; real(3.14)
3.14
&nbsp;
&gt;&gt;&gt; type(real(3.14))
&lt;class 'float'&gt;
&nbsp;
&gt;&gt;&gt; type(real("foo"))
&lt;class 'str'&gt;
</pre>

<p>V&nbsp;našem konkrétním případě si vytvoříme nový datový typ, který se bude
jmenovat RGB:</p>

<pre>
<i># Definice nových datových typů</i>
RGB = NewType("RGB", Tuple[int, int, int])
</pre>

<p>Tento nový typ použijeme na následujících řádcích:</p>

<pre>
RGB = NewType("RGB", Tuple[int, int, int])
BLACK: <strong>RGB</strong> = <strong>RGB</strong>((0, 0, 0))
RED: <strong>RGB</strong> = <strong>RGB</strong>((255, 0, 0))
GRAY: <strong>RGB</strong> = <strong>RGB</strong>((128, 128, 128))
YELLOW: <strong>RGB</strong> = <strong>RGB</strong>((255, 255, 0))
&nbsp;
def __init__(self, color: <strong>RGB</strong>, size: int, x: int, y: int):
&nbsp;
def draw_scene(display: pygame.Surface, background_color: <strong>RGB</strong>, sprite_group: pygame.sprite.Group) -&gt; None:
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Upravený kód demonstračního příkladu s&nbsp;definicí vlastního datového typu</h2>

<p>Upravený kód předchozího demonstračního příkladu, nyní ovšem s&nbsp;definicí
a použitím nového datového typu, lze získat na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites5.py</a>.
Tento kód vypadá následovně:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from typing import NewType, Tuple, List
&nbsp;
import pygame
import sys
&nbsp;
<i># Nutno importovat kvůli konstantám QUIT atd.</i>
from pygame.locals import *
&nbsp;
<i># Velikost okna aplikace</i>
WIDTH = 320
HEIGHT = 240
&nbsp;
<i># Definice nových datových typů</i>
RGB = <strong>NewType</strong>("RGB", Tuple[int, int, int])
&nbsp;
<i># Konstanty s n-ticemi představujícími základní barvy</i>
BLACK: RGB = RGB((0, 0, 0))
RED: RGB = RGB((255, 0, 0))
GRAY: RGB = RGB((128, 128, 128))
YELLOW: RGB = RGB((255, 255, 0))
&nbsp;
CAPTION = "Sprites in Pygame"
&nbsp;
&nbsp;
<i># Třída představující sprite zobrazený jako jednobarevný čtverec.</i>
class <strong>BlockySprite</strong>(pygame.sprite.Sprite):
    <i># Konstruktor</i>
    def <strong>__init__</strong>(self, color: RGB, size: int, x: int, y: int):
        <i># Nejprve je nutné zavolat konstruktor předka,</i>
        <i># tj. konstruktor třídy pygame.sprite.Sprite:</i>
        pygame.sprite.Sprite.__init__(self)
&nbsp;
        <i># Vytvoření obrázku představujícího vizuální obraz spritu:</i>
        self.image = pygame.Surface([size, size])
        self.image.fill(color)
&nbsp;
        <i># Vytvoření obalového obdélníku</i>
        <i># (velikost se získá z rozměru obrázku)</i>
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
&nbsp;
        <i># Počáteční rychlost spritu</i>
        self.speed_x = 0
        self.speed_y = 0
&nbsp;
    <i># Nastavení barvy spritu, který kolidoval s hráčem</i>
    def <strong>yellowColor</strong>(self) -&gt; None:
        self.image.fill(YELLOW)
&nbsp;
    <i># Nastavení barvy spritu, který nekolidoval s hráčem</i>
    def <strong>grayColor</strong>(self) -&gt; None:
        self.image.fill(GRAY)
&nbsp;
&nbsp;
def <strong>initDisplay</strong>(caption: str) -&gt; pygame.Surface:
    <i># Vytvoření okna pro vykreslování</i>
    display = pygame.display.set_mode([WIDTH, HEIGHT])
&nbsp;
    <i># Nastavení titulku okna</i>
    pygame.display.set_caption(caption)
&nbsp;
    return display
&nbsp;
&nbsp;
def <strong>createSprites</strong>() -&gt; Tuple[pygame.sprite.Group, pygame.sprite.Group, BlockySprite]:
    <i># Objekt sdružující všechny sprity</i>
    all_sprites: pygame.sprite.Group = pygame.sprite.Group()
&nbsp;
    <i># Objekt sdružující všechny sprity kromě hráče</i>
    all_sprites_but_player: pygame.sprite.Group = pygame.sprite.Group()
&nbsp;
    <i># Vytvoření několika typů spritů</i>
    <i>#                    barva  x   y velikost</i>
    wall1 = BlockySprite(GRAY, 50, 10, 10)
    wall2 = BlockySprite(GRAY, 15, 100, 100)
    wall3 = BlockySprite(GRAY, 15, 100, 150)
    wall4 = BlockySprite(GRAY, 15, 200, 100)
    wall5 = BlockySprite(GRAY, 15, 200, 150)
    wall6 = BlockySprite(GRAY, 15, 150, 100)
    wall7 = BlockySprite(GRAY, 15, 150, 150)
    player = BlockySprite(RED, 40, WIDTH // 2 - 20, HEIGHT // 2 - 20)
&nbsp;
    <i># Přidání několika dalších spritů do seznamu</i>
    <i># (jen jeden sprite - ten poslední - bude ve skutečnosti pohyblivý)</i>
    all_sprites.add(wall1)
    all_sprites.add(wall2)
    all_sprites.add(wall3)
    all_sprites.add(wall4)
    all_sprites.add(wall5)
    all_sprites.add(wall6)
    all_sprites.add(wall7)
    all_sprites.add(player)
&nbsp;
    <i># Seznam všech nepohyblivých spritů</i>
    all_sprites_but_player.add(wall1)
    all_sprites_but_player.add(wall2)
    all_sprites_but_player.add(wall3)
    all_sprites_but_player.add(wall4)
    all_sprites_but_player.add(wall5)
    all_sprites_but_player.add(wall6)
    all_sprites_but_player.add(wall7)
&nbsp;
    return all_sprites, all_sprites_but_player, player
&nbsp;
&nbsp;
<i># Posun všech spritů ve skupině na základě jejich rychlosti</i>
def <strong>move_sprites</strong>(sprite_group: pygame.sprite.Group, playground_width: int, playground_height:int) -&gt; None:
    for sprite in sprite_group:
        <i># Posun spritu</i>
        sprite.rect.x = sprite.rect.x + sprite.speed_x
        sprite.rect.y = sprite.rect.y + sprite.speed_y
        <i># Kontrola, zda sprite nenarazil do okrajů okna</i>
        if sprite.rect.x &lt; 0:
            sprite.rect.x = 0
            sprite.speed_x = 0
        if sprite.rect.x + sprite.rect.width &gt; playground_width:
            sprite.rect.x = playground_width - sprite.rect.width
            sprite.speed_x = 0
        if sprite.rect.y &lt; 0:
            sprite.rect.y = 0
            sprite.speed_y = 0
        if sprite.rect.y + sprite.rect.height &gt; playground_height:
            sprite.rect.y = playground_height - sprite.rect.height
            sprite.speed_y = 0
&nbsp;
&nbsp;
<i># Vykreslení celé scény na obrazovku</i>
def <strong>draw_scene</strong>(display: pygame.Surface, background_color: RGB, sprite_group: pygame.sprite.Group) -&gt; None:
    <i># Vyplnění plochy okna černou barvou</i>
    display.fill(background_color)
    <i># Vykreslení celé skupiny spritů do bufferu</i>
    sprite_group.draw(display)
    <i># Obnovení obsahu obrazovky (překlopení zadního a předního bufferu)</i>
    pygame.display.update()
&nbsp;
&nbsp;
<i># Změna barvy spritu na základě kolize s hráčem</i>
def <strong>change_colors</strong>(sprite_group: pygame.sprite.Group, hit_list: List[pygame.sprite.Sprite]) -&gt; None:
    <i># Projít všemi sprity ze skupiny, kterou detekovala kolizní funkce</i>
    for sprite in sprite_group:
        if sprite in hit_list:
            sprite.yellowColor()
        else:
            sprite.grayColor()
&nbsp;
&nbsp;
<i># Zjistí kolize spritu se "stěnami" (nepohyblivými sprity)</i>
def <strong>check_collisions</strong>(player: BlockySprite, sprite_group: pygame.sprite.Group) -&gt; None:
    <i># Vytvoření seznamu spritů, které kolidují s hráčem</i>
    hit_list = pygame.sprite.spritecollide(player, sprite_group, False)
    <i># Změna barev kolidujících spritů</i>
    change_colors(sprite_group, hit_list)
    collisions = len(hit_list)
    <i># Přenastavení titulku okna</i>
    caption = CAPTION + ": collisions " + str(collisions)
    pygame.display.set_caption(caption)
&nbsp;
&nbsp;
def <strong>mainLoop</strong>(display: pygame.Surface, clock: pygame.time.Clock,
        all_sprites: pygame.sprite.Group,
        all_sprites_but_player: pygame.sprite.Group, player: BlockySprite) -&gt; None:
    while True:
        <i># Načtení a zpracování všech událostí z fronty</i>
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                <i># Stiskem kurzorových kláves je možné měnit směr pohybu spritu</i>
                elif event.key == pygame.K_LEFT:
                    player.speed_x = -3
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = +3
                elif event.key == pygame.K_UP:
                    player.speed_y = -3
                elif event.key == pygame.K_DOWN:
                    player.speed_y = +3
            if event.type == KEYUP:
                <i># Puštění kurzorových kláves vede k zastavení pohybu spritu</i>
                if event.key == pygame.K_LEFT:
                    player.speed_x = 0
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = 0
                elif event.key == pygame.K_UP:
                    player.speed_y = 0
                elif event.key == pygame.K_DOWN:
                    player.speed_y = 0
&nbsp;
        move_sprites(all_sprites, display.get_width(), display.get_height())
        check_collisions(player, all_sprites_but_player)
        draw_scene(display, BLACK, all_sprites)
        clock.tick(20)
&nbsp;
&nbsp;
def <strong>main</strong>() -&gt; None:
    <i># Inicializace knihovny Pygame</i>
    pygame.init()
&nbsp;
    clock = pygame.time.Clock()
    display = initDisplay(CAPTION)
&nbsp;
    all_sprites, all_sprites_but_player, player = createSprites()
&nbsp;
    mainLoop(display, clock, all_sprites, all_sprites_but_player, player)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
<i># finito</i>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Striktní kontrola typů nástrojem Mypy</h2>

<p>Nyní je již zdrojový kód zdánlivě typově zcela bezpečný. Pokusme se tedy
otestovat, zda je tomu tak i ve skutečnosti. Zavoláme nástroj
<strong>mypy</strong> s&nbsp;parametrem <strong>--strict</strong>:</p>

<pre>
$ <strong>mypy --strict sprites5.py</strong>
</pre>

<p>V&nbsp;kódu bylo nalezeno celkem devět chyb, které se týkají stejného
datového typu <strong>Group</strong> resp.&nbsp;přesněji řečeno
<strong>pygame.sprite.Group</strong>:</p>

<pre>
sprites5.py:69: error: Missing type parameters for generic type "Group"  [type-arg]
sprites5.py:71: error: Missing type parameters for generic type "Group"  [type-arg]
sprites5.py:74: error: Missing type parameters for generic type "Group"  [type-arg]
sprites5.py:111: error: Missing type parameters for generic type "Group"  [type-arg]
sprites5.py:132: error: Missing type parameters for generic type "Group"  [type-arg]
sprites5.py:142: error: Missing type parameters for generic type "Group"  [type-arg]
sprites5.py:152: error: Missing type parameters for generic type "Group"  [type-arg]
sprites5.py:164: error: Missing type parameters for generic type "Group"  [type-arg]
sprites5.py:165: error: Missing type parameters for generic type "Group"  [type-arg]
Found 9 errors in 1 file (checked 1 source file)
</pre>

<p>Chyby byly nalezeny z&nbsp;toho důvodu, že
<strong>pygame.sprite.Group</strong> je kontejnerem, který může obsahovat
sprity. Jde tedy o generický datový typ, u něhož by bylo vhodné specifikovat
typy prvků. Rychlá, ale nedokonalá oprava spočívá v&nbsp;tom, že jako hodnoty
prvků použijeme typ <strong>Any</strong>:</p>

<pre>
pygame.sprite.Group[Any]
</pre>

<p>To však není typově bezpečné (vlastně jen obcházíme typový systém a přitom
se tváříme, jak dobře ho využíváme). Pokud se zamyslíme nad logikou programu,
zjistíme, že skupiny spritů budou vždy obsahovat instance třídy
<strong>BlockySprite</strong> a můžeme tedy psát:</p>

<pre>
pygame.sprite.Group[BlockySprite]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití typově bezpečného generického datového typu</h2>

<p>Úpravu zdrojového kódu příkladu je nutné provést pouze na několika místech,
která jsou zvýrazněna pod tímto odstavcem:</p>

<pre>
def createSprites() -&gt; Tuple[<strong>pygame.sprite.Group[BlockySprite]</strong>, <strong>pygame.sprite.Group[BlockySprite]</strong>, BlockySprite]:
    all_sprites: <strong>pygame.sprite.Group[BlockySprite]</strong> = pygame.sprite.Group()
    all_sprites_but_player: <strong>pygame.sprite.Group[BlockySprite]</strong> = pygame.sprite.Group()
def move_sprites(sprite_group: <strong>pygame.sprite.Group[BlockySprite]</strong>, playground_width: int, playground_height:int) -&gt; None:
def draw_scene(display: pygame.Surface, background_color: RGB, sprite_group: <strong>pygame.sprite.Group[BlockySprite</strong>]) -&gt; None:
def change_colors(sprite_group: <strong>pygame.sprite.Group[BlockySprite]</strong>, hit_list: List[pygame.sprite.Sprite]) -&gt; None:
def check_collisions(player: BlockySprite, sprite_group: <strong>pygame.sprite.Group[BlockySprite]</strong>) -&gt; None:
        all_sprites: <strong>pygame.sprite.Group[BlockySprite]</strong>,
        all_sprites_but_player: <strong>pygame.sprite.Group[BlockySprite]</strong>, player: BlockySprite) -&gt; None:
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Seznam či sekvence spritů?</h2>

<p>V&nbsp;programovém kódu navíc provedeme ještě dvě úpravy. V&nbsp;prvním
kroku nahradíme seznam spritů (<strong>List[pygame.sprite.Sprite]</strong>) za
sekvenci spritů, tedy za <strong>Sequence[pygame.sprite.Sprite]</strong>, čímž
efektivně zamezíme modifikaci sekvence spritů (tu stejně nechceme dělat):</p>

<pre>
from typing import NewType, Tuple, List, Sequence
def change_colors(sprite_group: pygame.sprite.Group[BlockySprite], hit_list: <strong>Sequence[pygame.sprite.Sprite]</strong>) -&gt; None:
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o doporučeníhodný přístup
&ndash; nahradit měnitelný seznam za neměnitelnou sekvenci ve všech místech
kódu, kde to dává význam.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zpětná kompatibilita se staršími verzemi Pythonu</h2>

<p>Ve druhém kroku jako první import uvedeme:</p>

<pre>
from __future__ import annotations
</pre>

<p>Tento programový řádek zamezí runtime chybám po spuštění programu ve
starších verzích Pythonu. Pokud bude řádek chybět a použijeme například Python
3.8, běh programu skončí s&nbsp;touto chybou:</p>

<pre>
pygame 2.4.0 (SDL 2.26.4, Python 3.8.10)
Hello from the pygame community. https://www.pygame.org/contribute.html
Traceback (most recent call last):
  File "sprites6.py", line 69, in <module>
    def createSprites() -&gt; Tuple[pygame.sprite.Group[BlockySprite], pygame.sprite.Group[BlockySprite], BlockySprite]:
TypeError: 'type' object is not subscriptable
&nbsp;
shell returned 1
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Upravený kód demonstračního příkladu, který již projde striktní typovou kontrolou</h2>

<p>Upravený kód předchozího demonstračního příkladu, nyní ovšem upraveného do
takové podoby, že projde striktní typovou kontrolou, je možné získat na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites6.py</a>.
Tento kód vypadá následovně:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from __future__ import annotations
from typing import NewType, Tuple, List, Sequence
&nbsp;
import pygame
import sys
&nbsp;
<i># Nutno importovat kvůli konstantám QUIT atd.</i>
from pygame.locals import *
&nbsp;
<i># Velikost okna aplikace</i>
WIDTH = 320
HEIGHT = 240
&nbsp;
<i># Definice nových datových typů</i>
RGB = <strong>NewType</strong>("RGB", Tuple[int, int, int])
&nbsp;
<i># Konstanty s n-ticemi představujícími základní barvy</i>
BLACK: RGB = RGB((0, 0, 0))
RED: RGB = RGB((255, 0, 0))
GRAY: RGB = RGB((128, 128, 128))
YELLOW: RGB = RGB((255, 255, 0))
&nbsp;
CAPTION = "Sprites in Pygame"
&nbsp;
&nbsp;
<i># Třída představující sprite zobrazený jako jednobarevný čtverec.</i>
class <strong>BlockySprite</strong>(pygame.sprite.Sprite):
    <i># Konstruktor</i>
    def <strong>__init__</strong>(self, color: RGB, size: int, x: int, y: int):
        <i># Nejprve je nutné zavolat konstruktor předka,</i>
        <i># tj. konstruktor třídy pygame.sprite.Sprite:</i>
        pygame.sprite.Sprite.__init__(self)
&nbsp;
        <i># Vytvoření obrázku představujícího vizuální obraz spritu:</i>
        self.image = pygame.Surface([size, size])
        self.image.fill(color)
&nbsp;
        <i># Vytvoření obalového obdélníku</i>
        <i># (velikost se získá z rozměru obrázku)</i>
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
&nbsp;
        <i># Počáteční rychlost spritu</i>
        self.speed_x = 0
        self.speed_y = 0
&nbsp;
    <i># Nastavení barvy spritu, který kolidoval s hráčem</i>
    def <strong>yellowColor</strong>(self) -&gt; None:
        self.image.fill(YELLOW)
&nbsp;
    <i># Nastavení barvy spritu, který nekolidoval s hráčem</i>
    def <strong>grayColor</strong>(self) -&gt; None:
        self.image.fill(GRAY)
&nbsp;
&nbsp;
def <strong>initDisplay</strong>(caption: str) -&gt; pygame.Surface:
    <i># Vytvoření okna pro vykreslování</i>
    display = pygame.display.set_mode([WIDTH, HEIGHT])
&nbsp;
    <i># Nastavení titulku okna</i>
    pygame.display.set_caption(caption)
&nbsp;
    return display
&nbsp;
&nbsp;
def <strong>createSprites</strong>() -&gt; Tuple[pygame.sprite.Group[BlockySprite], pygame.sprite.Group[BlockySprite], BlockySprite]:
    <i># Objekt sdružující všechny sprity</i>
    all_sprites: pygame.sprite.Group[BlockySprite] = pygame.sprite.Group()
&nbsp;
    <i># Objekt sdružující všechny sprity kromě hráče</i>
    all_sprites_but_player: pygame.sprite.Group[BlockySprite] = pygame.sprite.Group()
&nbsp;
    <i># Vytvoření několika typů spritů</i>
    <i>#                    barva  x   y velikost</i>
    wall1 = BlockySprite(GRAY, 50, 10, 10)
    wall2 = BlockySprite(GRAY, 15, 100, 100)
    wall3 = BlockySprite(GRAY, 15, 100, 150)
    wall4 = BlockySprite(GRAY, 15, 200, 100)
    wall5 = BlockySprite(GRAY, 15, 200, 150)
    wall6 = BlockySprite(GRAY, 15, 150, 100)
    wall7 = BlockySprite(GRAY, 15, 150, 150)
    player = BlockySprite(RED, 40, WIDTH // 2 - 20, HEIGHT // 2 - 20)
&nbsp;
    <i># Přidání několika dalších spritů do seznamu</i>
    <i># (jen jeden sprite - ten poslední - bude ve skutečnosti pohyblivý)</i>
    all_sprites.add(wall1)
    all_sprites.add(wall2)
    all_sprites.add(wall3)
    all_sprites.add(wall4)
    all_sprites.add(wall5)
    all_sprites.add(wall6)
    all_sprites.add(wall7)
    all_sprites.add(player)
&nbsp;
    <i># Seznam všech nepohyblivých spritů</i>
    all_sprites_but_player.add(wall1)
    all_sprites_but_player.add(wall2)
    all_sprites_but_player.add(wall3)
    all_sprites_but_player.add(wall4)
    all_sprites_but_player.add(wall5)
    all_sprites_but_player.add(wall6)
    all_sprites_but_player.add(wall7)
&nbsp;
    return all_sprites, all_sprites_but_player, player
&nbsp;
&nbsp;
<i># Posun všech spritů ve skupině na základě jejich rychlosti</i>
def <strong>move_sprites</strong>(sprite_group: pygame.sprite.Group[BlockySprite], playground_width: int, playground_height:int) -&gt; None:
    for sprite in sprite_group:
        <i># Posun spritu</i>
        sprite.rect.x = sprite.rect.x + sprite.speed_x
        sprite.rect.y = sprite.rect.y + sprite.speed_y
        <i># Kontrola, zda sprite nenarazil do okrajů okna</i>
        if sprite.rect.x &lt; 0:
            sprite.rect.x = 0
            sprite.speed_x = 0
        if sprite.rect.x + sprite.rect.width &gt; playground_width:
            sprite.rect.x = playground_width - sprite.rect.width
            sprite.speed_x = 0
        if sprite.rect.y &lt; 0:
            sprite.rect.y = 0
            sprite.speed_y = 0
        if sprite.rect.y + sprite.rect.height &gt; playground_height:
            sprite.rect.y = playground_height - sprite.rect.height
            sprite.speed_y = 0
&nbsp;
&nbsp;
<i># Vykreslení celé scény na obrazovku</i>
def <strong>draw_scene</strong>(display: pygame.Surface, background_color: RGB, sprite_group: pygame.sprite.Group[BlockySprite]) -&gt; None:
    <i># Vyplnění plochy okna černou barvou</i>
    display.fill(background_color)
    <i># Vykreslení celé skupiny spritů do bufferu</i>
    sprite_group.draw(display)
    <i># Obnovení obsahu obrazovky (překlopení zadního a předního bufferu)</i>
    pygame.display.update()
&nbsp;
&nbsp;
<i># Změna barvy spritu na základě kolize s hráčem</i>
def <strong>change_colors</strong>(sprite_group: pygame.sprite.Group[BlockySprite], hit_list: Sequence[pygame.sprite.Sprite]) -&gt; None:
    <i># Projít všemi sprity ze skupiny, kterou detekovala kolizní funkce</i>
    for sprite in sprite_group:
        if sprite in hit_list:
            sprite.yellowColor()
        else:
            sprite.grayColor()
&nbsp;
&nbsp;
<i># Zjistí kolize spritu se "stěnami" (nepohyblivými sprity)</i>
def <strong>check_collisions</strong>(player: BlockySprite, sprite_group: pygame.sprite.Group[BlockySprite]) -&gt; None:
    <i># Vytvoření seznamu spritů, které kolidují s hráčem</i>
    hit_list = pygame.sprite.spritecollide(player, sprite_group, False)
    <i># Změna barev kolidujících spritů</i>
    change_colors(sprite_group, hit_list)
    collisions = len(hit_list)
    <i># Přenastavení titulku okna</i>
    caption = CAPTION + ": collisions " + str(collisions)
    pygame.display.set_caption(caption)
&nbsp;
&nbsp;
def <strong>mainLoop</strong>(display: pygame.Surface, clock: pygame.time.Clock,
        all_sprites: pygame.sprite.Group[BlockySprite],
        all_sprites_but_player: pygame.sprite.Group[BlockySprite], player: BlockySprite) -&gt; None:
    while True:
        <i># Načtení a zpracování všech událostí z fronty</i>
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                <i># Stiskem kurzorových kláves je možné měnit směr pohybu spritu</i>
                elif event.key == pygame.K_LEFT:
                    player.speed_x = -3
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = +3
                elif event.key == pygame.K_UP:
                    player.speed_y = -3
                elif event.key == pygame.K_DOWN:
                    player.speed_y = +3
            if event.type == KEYUP:
                <i># Puštění kurzorových kláves vede k zastavení pohybu spritu</i>
                if event.key == pygame.K_LEFT:
                    player.speed_x = 0
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = 0
                elif event.key == pygame.K_UP:
                    player.speed_y = 0
                elif event.key == pygame.K_DOWN:
                    player.speed_y = 0
&nbsp;
        move_sprites(all_sprites, display.get_width(), display.get_height())
        check_collisions(player, all_sprites_but_player)
        draw_scene(display, BLACK, all_sprites)
        clock.tick(20)
&nbsp;
&nbsp;
def <strong>main</strong>() -&gt; None:
    <i># Inicializace knihovny Pygame</i>
    pygame.init()
&nbsp;
    clock = pygame.time.Clock()
    display = initDisplay(CAPTION)
&nbsp;
    all_sprites, all_sprites_but_player, player = createSprites()
&nbsp;
    mainLoop(display, clock, all_sprites, all_sprites_but_player, player)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
<i># finito</i>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Selektivní zjištění typu proměnné či třídy nástrojem Mypy</h2>

<p>V&nbsp;mnoha případech nastává situace, kdy není (mj.&nbsp;i díky dále
zmíněné typové inferenci) zcela zřejmé, jakého typu je nějaká proměnná či
třída. Nástroj Mypy pro tyto účely podporuje použití (pseudo)funkce nazvané
<strong>reveal_type</strong>, která dokáže vypsat typ objektu. Má to ovšem dva
háčky: jedná se o kód, který je zavolán v&nbsp;průběhu statické typové kontroly
nástrojem Mypy a současně se nejedná o skutečnou funkci (proto ji ani
neimportujeme). Při spuštění programu v&nbsp;interpretru Pythonu dojde
k&nbsp;chybě, protože se jedná o neznámý symbol (tuto pseudofunkci tedy musíme
z&nbsp;produkčního kódu odstranit).</p>

<p>Podívejme se nyní na jednoduchý příklad, v&nbsp;němž
<strong>reveal_type</strong> použijeme pro zjištění typu libovolné hodnoty:</p>

<pre>
x = 42
<strong>reveal_type(x)</strong>
&nbsp;
y = "foo"
<strong>reveal_type(y)</strong>
&nbsp;
z = (1, "abc", 3.14, True)
<strong>reveal_type(z)</strong>
&nbsp;
class X():
    pass
&nbsp;
w = X()
<strong>reveal_type(w)</strong>
</pre>

<p>Nástroj Mypy vypíše následující informace s&nbsp;přesnými informacemi o
typech tak, jak je lze zjistit statickou analýzou:</p>

<pre>
$ <strong>mypy reveal_type1.py</strong>
&nbsp;
reveal_type1.py:2: note: Revealed type is "builtins.int"
reveal_type1.py:5: note: Revealed type is "builtins.str"
reveal_type1.py:8: note: Revealed type is "Tuple[builtins.int, builtins.str, builtins.float, builtins.bool]"
reveal_type1.py:14: note: Revealed type is "reveal_type1.X"
Success: no issues found in 1 source file
</pre>

<p>Naproti tomu pokud volání <strong>reveal_type</strong> neodstraníme, nebude
možné tento kód běžnými prostředky spustit:</p>

<pre>
$ <strong>python3 reveal_type1.py</strong>
&nbsp;
Traceback (most recent call last):
  File "reveal_type1.py", line 2, in <module>
    reveal_type(x)
NameError: name 'reveal_type' is not defined
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Selektivní zjištění typu funkce nástrojem Mypy</h2>

<p>Nejvíce problémů se v&nbsp;souvislosti s&nbsp;datovými typy řeší u funkcí a
metod (a to mj.&nbsp;i díky kontravarianci atd.). Podívejme se tedy na to, jak
lze <strong>reveal_type</strong> použít pro typ funkce:</p>

<pre>
def <strong>add</strong>(a:int, b:int) -&gt; int:
    return a+b
&nbsp;
reveal_type(add)
reveal_type(add(1, 2))
</pre>

<p>Zjištění typu funkce a typu návratové hodnoty této funkce, a to pochopitelně
bez jejího volání &ndash; jedná se o statickou typovou kontrolu:</p>

<pre>
$ <strong>mypy reveal_type2.py </strong>
&nbsp;
reveal_type2.py:4: note: Revealed type is "def (a: builtins.int, b: builtins.int) -&gt; builtins.int"
reveal_type2.py:5: note: Revealed type is "builtins.int"
</pre>

<p>Tentýž příklad, ovšem nyní pro funkci bez explicitního uvedení typů:</p>

<pre>
def <strong>add</strong>(a, b):
    return a+b
&nbsp;
reveal_type(add)
reveal_type(add(1, 2))
</pre>

<p>Výsledek ukazuje, že se nepoužila typová inference, ale všude, kde je to
možné, byl dosazen univerzální datový typ <strong>Any</strong>:</p>

<pre>
$ <strong>mypy reveal_typeX.py </strong>
&nbsp;
reveal_type2.py:4: note: Revealed type is "def (a: Any, b: Any) -&gt; Any"
reveal_type2.py:5: note: Revealed type is "Any"
</pre>

<p>A konečně si vyzkoušejme poněkud složitější funkci, resp.&nbsp;přesněji
řečeno funkci se složitějšími typy a návratovými hodnotami:</p>

<pre>
from typing import List, Set
&nbsp;
def <strong>add</strong>(a:List[Set[int]], b:List[Set[int]]) -&gt; List[Set[int]]:
    return a+b
&nbsp;
&nbsp;
reveal_type(add)
</pre>

<p>Výsledek:</p>

<pre>
func.py:7: note: Revealed type is "def (a: builtins.list[builtins.set[builtins.int]], b: builtins.list[builtins.set[builtins.int]]) -&gt; builtins.list[builtins.set[builtins.int]]"
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Typová inference</h2>

<p>Díky existenci pseudofunkce <strong>reveal_type</strong> si můžeme ověřit,
jakým způsobem Mypy automaticky odvozuje datové typy proměnných. Jedná se o
technologii nazvanou <i>typová inference</i>. Nejprve vytvoříme slovník se
třemi dvojicemi klíč:hodnota, přičemž klíči budou vždy řetězce a hodnotami vždy
celá čísla:</p>

<pre>
d = {}
&nbsp;
d["foo"] = 1
d["bar"] = 3
d["baz"] = 10
&nbsp;
<strong>reveal_type(d)</strong>
</pre>

<p>Pseudofunkcí <strong>reveal_type</strong> si necháme vypsat typ, který Mypy
odvodil:</p>

<pre>
$ <strong>mypy reveal_type3.py</strong>
&nbsp;
reveal_type3.py:7: note: Revealed type is "builtins.dict[builtins.str, builtins.int]"
Success: no issues found in 1 source file
</pre>

<p>Druhý příklad bude z&nbsp;pohledu Mypy složitější, protože klíči slovníků
nyní budou jak řetězce, tak i celá čísla a i hodnoty budou různého typu:</p>

<pre>
d = {}
&nbsp;
<strong>reveal_type(d)</strong>
&nbsp;
d["foo"] = 1
d["bar"] = 3.14
&nbsp;
<strong>reveal_type(d)</strong>
&nbsp;
d[10] = 10
d[42] = "answer"
&nbsp;
<strong>reveal_type(d)</strong>
</pre>

<p>Opět si necháme zobrazit, jaký typ slovníku Mypy v&nbsp;tomto případě
odvodil:</p>

<pre>
$ <strong>mypy reveal_type4.py</strong>
&nbsp;
reveal_type4.py:1: error: Need type annotation for "d" (hint: "d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")  [var-annotated]
reveal_type4.py:3: note: Revealed type is "builtins.dict[Any, Any]"
reveal_type4.py:6: error: Incompatible types in assignment (expression has type "float", target has type "int")  [assignment]
reveal_type4.py:8: note: Revealed type is "builtins.dict[builtins.str, builtins.int]"
reveal_type4.py:10: error: Invalid index type "int" for "Dict[str, int]"; expected type "str"  [index]
reveal_type4.py:11: error: Invalid index type "int" for "Dict[str, int]"; expected type "str"  [index]
reveal_type4.py:11: error: Incompatible types in assignment (expression has type "str", target has type "int")  [assignment]
reveal_type4.py:13: note: Revealed type is "builtins.dict[builtins.str, builtins.int]"
Found 5 errors in 1 file (checked 1 source file)
</pre>

<p><div class="rs-tip-major">Poznámka: pravděpodobně by v&nbsp;praxi bylo lepší
využít typ <strong>Union</strong>, protože po prvním odvození typu (řádek 3 na
výstupu) už se pochopitelně typ slovníku nemůže měnit.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Explicitní definice typu versus typová inference</h2>

<p>Samozřejmě nám nic nebrání (spíše naopak) explicitně zapsat typ slovníku,
tj.&nbsp;typ klíčů i typ hodnot. Například můžeme specifikovat, že typ klíčů
bude vždy řetězec a typ hodnot buď celé číslo, číslo s&nbsp;plovoucí řádovou
čárkou nebo řetězec:</p>

<pre>
from typing import Dict, Union
&nbsp;
d:Dict[str, Union[int, float, str]] = {}
&nbsp;
<strong>reveal_type(d)</strong>
&nbsp;
d["foo"] = 1
d["bar"] = 3.14
d["baz"] = "*"
&nbsp;
<strong>reveal_type(d)</strong>
&nbsp;
d[10] = 10
d[42] = "answer"
&nbsp;
<strong>reveal_type(d)</strong>
</pre>

<p>A takto bude vypadat výsledek statické typové kontroly nástrojem Mypy. Podle
očekávání budou detekovány chyby na posledních dvou přiřazeních do
slovníku (řádky 13 a 14):</p>

<pre>
$ <strong>mypy reveal_type5.py</strong>
&nbsp;
reveal_type5.py:5: note: Revealed type is "builtins.dict[builtins.str, Union[builtins.int, builtins.float, builtins.str]]"
reveal_type5.py:11: note: Revealed type is "builtins.dict[builtins.str, Union[builtins.int, builtins.float, builtins.str]]"
reveal_type5.py:13: error: Invalid index type "int" for "Dict[str, Union[int, float, str]]"; expected type "str"  [index]
reveal_type5.py:14: error: Invalid index type "int" for "Dict[str, Union[int, float, str]]"; expected type "str"  [index]
reveal_type5.py:16: note: Revealed type is "builtins.dict[builtins.str, Union[builtins.int, builtins.float, builtins.str]]"
Found 2 errors in 1 file (checked 1 source file)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zjištění typů všech lokálních proměnných</h2>

<p>Kromě výše popsané pseudofunkce <strong>reveal_type</strong> můžeme při
vývoji použít další pseudofunkci nazvanou <strong>releal_locals</strong>. Jak
název této pseudofunkce napovídá, zobrazí se v&nbsp;místě jejího použití při
statické typové kontrole typy všech lokálních proměnných resp.&nbsp;přesněji
řečeno proměnných z&nbsp;daného bloku. Ostatně si tuto funkcionalitu nástroje
Mypy můžeme ukázat na několika demonstračních příkladech. Začneme proměnnými
globálními v&nbsp;rámci daného balíčku:</p>

<pre>
x = 42
&nbsp;
y = "foo"
&nbsp;
z = (1, "abc", 3.14, True)
&nbsp;
class X():
    pass
&nbsp;
&nbsp;
w = X()
<strong>reveal_locals()</strong>
</pre>

<p>Výsledek vyprodukovaný nástrojem Mypy:</p>

<pre>
$ <strong>mypy reveal_locals1.py</strong>
&nbsp;
reveal_locals1.py:12: note: Revealed local types are:
reveal_locals1.py:12: note:     w: reveal_locals1.X
reveal_locals1.py:12: note:     x: builtins.int
reveal_locals1.py:12: note:     y: builtins.str
reveal_locals1.py:12: note:     z: Tuple[builtins.int, builtins.str, builtins.float, builtins.bool]
Success: no issues found in 1 source file
</pre>

<p>Zobrazení typů parametrů a lokálních proměnných ve funkci:</p>

<pre>
def add(a:int, b:int) -&gt; int:
    <strong>reveal_locals()</strong>
    return a+b
&nbsp;
reveal_type(add)
reveal_type(add(1, 2))
</pre>

<p>Nyní bude výsledek následující:</p>

<pre>
$ <strong>mypy reveal_locals2.py</strong>
&nbsp;
reveal_locals2.py:2: note: Revealed local types are:
reveal_locals2.py:2: note:     a: builtins.int
reveal_locals2.py:2: note:     b: builtins.int
reveal_locals2.py:5: note: Revealed type is "def (a: builtins.int, b: builtins.int) -&gt; builtins.int"
reveal_locals2.py:6: note: Revealed type is "builtins.int"
Success: no issues found in 1 source file
</pre>

<p>A konečně si ukažme ještě nepatrně složitější příklad s&nbsp;funkcí vyššího
řádu, konkrétně s&nbsp;funkcí, která jako svůj parametr akceptuje jinou
funkci:</p>

<pre>
from typing import Callable
&nbsp;
&nbsp;
def printIsPositive(condition:Callable[[int], bool]) -&gt; None:
    <strong>reveal_locals()</strong>
    if condition(5):
        print("Positive")
    else:
        print("Negative")
&nbsp;
&nbsp;
def positiveFloat(x:float) -&gt; bool:
    return x &gt; 0.0
&nbsp;
&nbsp;
def positiveInt(x:int) -&gt; bool:
    return x &gt; 0
&nbsp;
&nbsp;
printIsPositive(positiveFloat)
printIsPositive(positiveInt)
</pre>

<p>Výsledky budou v&nbsp;tomto případě vypadat následovně:</p>

<pre>
$ <strong>mypy reveal_locals3.py</strong>
&nbsp;
reveal_locals3.py:5: note: Revealed local types are:
reveal_locals3.py:5: note:     condition: def (builtins.int) -&gt; builtins.bool
Success: no issues found in 1 source file
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Podpora neměnitelných hodnot (<i>immutable</i>)</h2>

<p>Již minule jsme se, i když jen okrajově, zmínili o podpoře neměnitelných
(<i>immutable</i>) hodnot, přesněji řečeno typů, u nichž je specifikováno, že
se jejich hodnoty nebudou měnit. Konkrétně je možné použít kvalifikátor
<strong>Final</strong>, o němž se podrobněji zmíníme příště, nebo
v&nbsp;případě seznamů lze seznamy nahradit za typ <strong>Sequence</strong> a
slovníky za typ <strong>Mapping</strong>. Jak <strong>Sequence</strong> tak i
<strong>Mapping</strong> při statické typové kontrole představují immutable
hodnoty, ovšem při běhu (<i>runtime</i>) se jedná o běžné seznamy nebo
slovníky!</p>

<p>Ostatně si to můžeme velmi snadno ověřit. Začneme seznamy a typem
<strong>Sequence</strong>:</p>

<pre>
from typing import List, Sequence
&nbsp;
l1: List[bool] = [True, False]
&nbsp;
l1.append(True)
l1.append(False)
&nbsp;
print(l1)
&nbsp;
l2: Sequence[bool] = [True, False]
&nbsp;
l2.append(True)
l2.append(False)
&nbsp;
print(l2)
</pre>

<p>Výsledek po spuštění v&nbsp;interpretru Pythonu neukáže žádný podstatný
rozdíl:</p>

<pre>
$ <strong>python3 list_sequence.py</strong>
&nbsp;
[True, False, True, False]
[True, False, True, False]
</pre>

<p>Výsledek statické typové kontroly ovšem již rozdíly pochopitelně
ukazuje:</p>

<pre>
$ <strong>mypy list_sequence.py</strong>
&nbsp;
list_sequence.py:12: error: "Sequence[bool]" has no attribute "append"  [attr-defined]
list_sequence.py:13: error: "Sequence[bool]" has no attribute "append"  [attr-defined]
Found 2 errors in 1 file (checked 1 source file)
</pre>

<p>Prakticky totéž platí pro slovníky a typ <strong>Mapping</strong>:</p>

<pre>
from typing import Dict, Mapping
&nbsp;
d1:Dict[str, float] = {}
&nbsp;
d1["foo"] = 1
d1["bar"] = 3.14
d1["baz"] = 0.0
&nbsp;
print(d1)
&nbsp;
d2:Mapping[str, float] = {}
&nbsp;
d2["foo"] = 1
d2["bar"] = 3.14
d2["baz"] = 0.0
&nbsp;
print(d2)
</pre>

<p>Výsledek po spuštění v&nbsp;interpretru Pythonu opět neukáže žádný podstatný
rozdíl:</p>

<pre>
$ <strong>python3 dict_mapping.py</strong>
&nbsp;
{'foo': 1, 'bar': 3.14, 'baz': 0.0}
{'foo': 1, 'bar': 3.14, 'baz': 0.0}
</pre>

<p>Výsledek statické typové kontroly ovšem již rozdíly pochopitelně
ukazuje:</p>

<pre>
$ <strong>mypy dict_mapping.py</strong>
&nbsp;
dict_mapping.py:13: error: Unsupported target for indexed assignment ("Mapping[str, float]")  [index]
dict_mapping.py:14: error: Unsupported target for indexed assignment ("Mapping[str, float]")  [index]
dict_mapping.py:15: error: Unsupported target for indexed assignment ("Mapping[str, float]")  [index]
Found 3 errors in 1 file (checked 1 source file)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Příloha 1: základní dostupné datové typy</h2>

<p>V&nbsp;Mypy je definováno sedm základních datových typů, z&nbsp;nichž se
mohou odvozovat další datové typy popř.&nbsp;lze tyto typy zkombinovat
s&nbsp;generickými typy vypsanými v&nbsp;navazující kapitole:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Stručný popis</th><th>Podtyp z</th></tr>
<tr><td>1</td><td>int</td><td>celá čísla</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>float</td><td>čísla s&nbsp;plovoucí řádovou čárkou</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>bool</td><td>pravdivostní hodnoty</td><td>int</td></tr>
<tr><td>4</td><td>str</td><td>sekvence Unicode znaků</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>bytes</td><td>sekvence bajtů</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>object</td><td>libovolný objekt</td><td>object (bázová třída)</td></tr>
<tr><td>7</td><td>Any</td><td>libovolný typ</td><td>&nbsp;</td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příloha 2: dostupné generické typy</h2>

<p>Základní datové typy popsané <a href="#k16">v&nbsp;předchozí kapitole</a> je
možné zkombinovat se standardními generickými datovými typy, které jsou,
společně s&nbsp;příklady, vypsány v&nbsp;následující tabulce. Většinu těchto
typů již známe z&nbsp;předešlých článků:</p>

<table>
<tr><th> #</th><th>Generický typ</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>list[str]</td><td>seznam hodnot typu řetězec</td></tr>
<tr><td> 2</td><td>list[Any]</td><td>seznam hodnot libovolného typu</td></tr>
<tr><td> 3</td><td>tuple[int, int]</td><td>dvojice hodnot typu celé číslo</td></tr>
<tr><td> 4</td><td>tuple[int, str]</td><td>dvojice hodnot, první hodnotou bude celé číslo, druhou hodnotou řetězec</td></tr>
<tr><td> 5</td><td>tuple[()]</td><td>prázdná n-tice</td></tr>
<tr><td> 6</td><td>tuple[int, ...]</td><td>n-tice s&nbsp;libovolným množstvím hodnot typu int</td></tr>
<tr><td> 7</td><td>dict[str, int]</td><td>slovník s&nbsp;klíči typu řetězec a hodnotami typu celé číslo</td></tr>
<tr><td> 8</td><td>dict[str, Any]</td><td>slovník s&nbsp;klíči typu řetězec a hodnotami libovolného typu</td></tr>
<tr><td> 9</td><td>Iterable[int]</td><td>objekt, který je &bdquo;iterovatelný&ldquo; (lze jím procházet s&nbsp;využitím for-each)</td></tr>
<tr><td>10</td><td>Sequence[int]</td><td>obdoba seznamů, ovšem neměnitelná (<i>immutable</i>)</td></tr>
<tr><td>11</td><td>Mapping[str, int]</td><td>obdoba slovníků, ovšem neměnitelná (<i>immutable</i>)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této tabulce byly použity
identifikátory zavedené v&nbsp;Pythonu 3.9 a pochopitelně podporované i
v&nbsp;Pythonu 3.10 a 3.11. Na jednu stranu se používají názvy
<strong>list</strong>, <strong>tuple</strong> a <strong>dict</strong>, které
není zapotřebí importovat, na stranu druhou zde můžeme vidět různé jmenné
nekonzistence, například mezi názvem <strong>list</strong> a
<strong>Sequence</strong>.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha 3: rozdíly mezi Pythonem &lt; 3.9 a novějšími verzemi</h2>

<p>Již několikrát jsme se setkali s&nbsp;rozdílným způsobem zápisu typů
v&nbsp;Pythonu 3.9 a jakékoli vyšší verze na jedné straně a staršími verzemi
Pythonu 3 na straně druhé. Tyto rozdíly jsou zvýrazněny v&nbsp;následující
tabulce (přičemž platí, že typy začínající velkým písmenem je nutné importovat
z&nbsp;balíčku <strong>typing</strong>):</p>

<table>
<tr><th>Původní zápis typu</th><th>Nový zápis typu</th></tr>
<tr><td>List[str]</td><td>list[str]</td></tr>
<tr><td>Tuple[int, int]</td><td>tuple[int, int]</td></tr>
<tr><td>Tuple[int, ...]</td><td>tuple[int, ...]</td></tr>
<tr><td>Dict[str, int]</td><td>dict[str, int]</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: všechny ostatní typy se zapisují stejně
v&nbsp;jakékoli verzi Pythonu 3.x (konkrétně od verze 3.7 výše).</div></p>

<p>Další rozdíl spočívá v&nbsp;zápisu &bdquo;složeného&ldquo; typu
<strong>Union</strong> a <strong>Optional</strong>:</p>

<table>
<tr><th>Původní zápis typu</th><th>Nový zápis typu</th></tr>
<tr><td>Union[int, str]</td><td>int | str</td></tr>
<tr><td>Optional[int, str]</td><td>int | None</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: záleží pochopitelně na vás, kterému
způsobu zápisu dáváte přednost. Starší způsob je stále podporován.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny Pythonovské skripty, které jsme si v&nbsp;dnešním článku (i
v&nbsp;obou předchozích článcích) ukázali, naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je pochopitelně
nutné mít nainstalován balíček <i>mypy</i> společně s&nbsp;Pythonem alespoň
3.7):</p>

<table>
<tr><th>#<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td> 1</td><td>adder1.py</td><td>funkce <strong>add</strong> bez typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder1.py</a></td></tr>
<tr><td> 2</td><td>adder2.py</td><td>funkce <strong>add</strong> s&nbsp;typovými anotacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder2.py</a></td></tr>
<tr><td> 3</td><td>adder3.py</td><td>funkce <strong>add</strong> volaná s&nbsp;hodnotami <strong>True</strong> a <strong>False</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder3.py</a></td></tr>
<tr><td> 4</td><td>adder4.py</td><td>funkce <strong>add</strong> akceptující hodnoty typu <strong>bool</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder4.py</a></td></tr>
<tr><td> 5</td><td>adder5.py</td><td>zobrazení typových informací pro funkci bez typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder5.py</a></td></tr>
<tr><td> 6</td><td>adder6.py</td><td>zobrazení typových informací pro funkci s&nbsp;typovými anotacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>exec_problem_1.py</td><td>funkce <strong>add</strong> s&nbsp;typovými anotacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_1.py</a></td></tr>
<tr><td> 6</td><td>exec_problem_2.py</td><td>korektní detekce volání funkce <strong>add</strong> s&nbsp;nekompatibilními hodnotami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_2.py</a></td></tr>
<tr><td> 7</td><td>exec_problem_3.py</td><td>příkaz použitý v&nbsp;<strong>exec</strong> není statickým analyzátorem zachycen</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>list_type1.py</td><td>typ seznam, s&nbsp;inicializací (bez prvků), pro Python 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type1.py</a></td></tr>
<tr><td> 9</td><td>list_type2.py</td><td>typ seznam, s&nbsp;inicializací (bez prvků), pro starší verze Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type2.py</a></td></tr>
<tr><td>10</td><td>list_type3.py</td><td>typ seznam, s&nbsp;inicializací (s&nbsp;prvky), pro starší verze Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type3.py</a></td></tr>
<tr><td>11</td><td>list_type4.py</td><td>typ seznam, kontrola použití prvků s&nbsp;nekorektními typy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type4.py</a></td></tr>
<tr><td>12</td><td>list_type5.py</td><td>typ seznam, kontrola použití prvků s&nbsp;korektními typy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type5.py</a></td></tr>
<tr><td>13</td><td>list_type6.py</td><td>typ seznam, kontrola použití prvků s&nbsp;korektními typy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>tuple_type1.py</td><td>typ n-tice (nekorektní specifikace typu)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type1.py</a></td></tr>
<tr><td>15</td><td>tuple_type2.py</td><td>typ n-tice (korektní specifikace typu)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type2.py</a></td></tr>
<tr><td>16</td><td>tuple_type3.py</td><td>typ n-tice, v&nbsp;níž má každý prvek odlišný typ</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type3.py</a></td></tr>
<tr><td>17</td><td>tuple_type4.py</td><td>typ n-tice, v&nbsp;níž má každý prvek odlišný typ</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>json_check.py</td><td>delší kód v&nbsp;Pythonu bez typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/json_check.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/json_check.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>Variance1.java</td><td>variance v&nbsp;Javě &ndash; korektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.java">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.java</a></td></tr>
<tr><td>20</td><td>Variance2.java</td><td>variance v&nbsp;Javě &ndash; nekorektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.java">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>Variance1.py</td><td>variance v&nbsp;Pythonu &ndash; korektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.py</a></td></tr>
<tr><td>22</td><td>Variance2.py</td><td>variance v&nbsp;Pythonu &ndash; nekorektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.py</a></td></tr>
<tr><td>23</td><td>Variance3.py</td><td>variance v&nbsp;Pythonu &ndash; nekorektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance3.py</a></td></tr>
<tr><td>24</td><td>Variance4.py</td><td>použití typu <strong>Sequence</strong> namísto <strong>List</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>view_pyc.py</td><td>jednoduchá prohlížečka souborů .pyc</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/view_pyc.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/view_pyc.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>callable1.py</td><td>funkce s&nbsp;typovými informacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable1.py</a></td></tr>
<tr><td>27</td><td>callable2.py</td><td>variance funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable2.py</a></td></tr>
<tr><td>28</td><td>callable3.py</td><td>variance funkcí (nekorektní příklad)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable3.py</a></td></tr>
<tr><td>29</td><td>callable4.py</td><td>korektní řešení problému z&nbsp;kódu <strong>callable3.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>dict_type1.py</td><td>slovník bez specifikace informací o typech (homogenní struktura)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type1.py</a></td></tr>
<tr><td>31</td><td>dict_type2.py</td><td>slovník bez specifikace informací o typech (heterogenní struktura)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type2.py</a></td></tr>
<tr><td>32</td><td>dict_type3.py</td><td>typově silný slovník (heterogenní struktura)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type3.py</a></td></tr>
<tr><td>33</td><td>dict_type4.py</td><td>typově silný slovník (homogenní struktura)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type4.py</a></td></tr>
<tr><td>34</td><td>dict_type5.py</td><td>použití typu <strong>Union</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type5.py</a></td></tr>
<tr><td>35</td><td>dict_type6.py</td><td>použití typu <strong>Union</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type6.py</a></td></tr>
<tr><td>36</td><td>dict_type7.py</td><td>použití typu <strong>Optional</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type7.py</a></td></tr>
<tr><td>37</td><td>dict_type8.py</td><td>použití typu <strong>Optional</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type8.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>38</td><td>sprites1.py</td><td>původní kód před refaktoringem a bez typových informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites1.py</a></td></tr>
<tr><td>39</td><td>sprites2.py</td><td>refaktoring kódu <strong>sprites1.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites2.py</a></td></tr>
<tr><td>40</td><td>sprites3.py</td><td>přidání typových informací do kódu <strong>sprites2.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites3.py</a></td></tr>
<tr><td>41</td><td>sprites4.py</td><td>oprava chyb nalezených v&nbsp;kódu <strong>sprites3.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites4.py</a></td></tr>
<tr><td>42</td><td>sprites5.py</td><td>doplnění generických typů pro volbu <strong>--strict</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites5.py</a></td></tr>
<tr><td>43</td><td>sprites6.py</td><td>definice a použití nového datového typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>44</td><td>reveal_type1.py</td><td>selektivní zjištění typu proměnné či třídy nástrojem Mypy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type1.py</a></td></tr>
<tr><td>45</td><td>reveal_type2.py</td><td>selektivní zjištění typu funkce nástrojem Mypy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type2.py</a></td></tr>
<tr><td>46</td><td>reveal_type3.py</td><td>typová inference</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type3.py</a></td></tr>
<tr><td>47</td><td>reveal_type4.py</td><td>typová inference</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type4.py</a></td></tr>
<tr><td>48</td><td>reveal_type5.py</td><td>explicitní definice typu versus typová inference</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>reveal_locals1.py</td><td>zjištění typů všech lokálních proměnných</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals1.py</a></td></tr>
<tr><td>50</td><td>reveal_locals2.py</td><td>zjištění typů všech lokálních proměnných</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals2.py</a></td></tr>
<tr><td>51</td><td>reveal_locals3.py</td><td>zjištění typů všech lokálních proměnných</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>list_sequence.py</td><td>měnitelné seznamy vs. neměnitelné sekvence</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_sequence.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_sequence.py</a></td></tr>
<tr><td>53</td><td>dict_mapping.py</td><td>měnitelné slovníky vs. neměnitelné mapování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_mapping.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_mapping.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>mypy homepage<br />
<a href="https://www.mypy-lang.org/">https://www.mypy-lang.org/</a>
</li>

<li>mypy documentation<br />
<a href="https://mypy.readthedocs.io/en/stable/">https://mypy.readthedocs.io/en/stable/</a>
</li>

<li>Mypy na PyPi Optional static typing for Python<br />
<a href="https://pypi.org/project/mypy/">https://pypi.org/project/mypy/</a>
</li>

<li>5 Reasons Why You Should Use Type Hints In Python<br />
<a href="https://www.youtube.com/watch?v=dgBCEB2jVU0">https://www.youtube.com/watch?v=dgBCEB2jVU0</a>
</li>

<li>Python Typing &ndash; Type Hints &amp; Annotations<br />
<a href="https://www.youtube.com/watch?v=QORvB-_mbZ0">https://www.youtube.com/watch?v=QORvB-_mbZ0</a>
</li>

<li>What Problems Can TypeScript Solve?<br />
<a href="https://www.typescriptlang.org/why-create-typescript">https://www.typescriptlang.org/why-create-typescript</a>
</li>

<li>How to find code that is missing type annotations?<br />
<a href="https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations">https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations</a>
</li>

<li>Do type annotations in Python enforce static type checking?<br />
<a href="https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking">https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking</a>
</li>

<li>Understanding type annotation in Python<br />
<a href="https://blog.logrocket.com/understanding-type-annotation-python/">https://blog.logrocket.com/understanding-type-annotation-python/</a>
</li>

<li>Static type checking with Mypy — Perfect Python<br />
<a href="https://www.youtube.com/watch?v=9gNnhNxra3E">https://www.youtube.com/watch?v=9gNnhNxra3E</a>
</li>

<li>Static Type Checker for Python<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Differences Between Pyright and Mypy<br />
<a href="https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md">https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md</a>
</li>

<li>4 Python type checkers to keep your code clean<br />
<a href="https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html">https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html</a>
</li>

<li>Pyre: A performant type-checker for Python 3<br />
<a href="https://pyre-check.org/">https://pyre-check.org/</a>
</li>

<li>"Typing the Untyped: Soundness in Gradual Type Systems" by Ben Weissmann<br />
<a href="https://www.youtube.com/watch?v=uJHD2xyv7xo">https://www.youtube.com/watch?v=uJHD2xyv7xo</a>
</li>

<li>Covariance and contravariance (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a>
</li>

<li>Functional Programming: Type Systems<br />
<a href="https://www.youtube.com/watch?v=hy1wjkcIBCU">https://www.youtube.com/watch?v=hy1wjkcIBCU</a>
</li>

<li>A Type System From Scratch – Robert Widmann<br />
<a href="https://www.youtube.com/watch?v=IbjoA5xVUq0">https://www.youtube.com/watch?v=IbjoA5xVUq0</a>
</li>

<li>"Type Systems - The Good, Bad and Ugly" by Paul Snively and Amanda Laucher<br />
<a href="https://www.youtube.com/watch?v=SWTWkYbcWU0">https://www.youtube.com/watch?v=SWTWkYbcWU0</a>
</li>

<li>Type Systems: Covariance, Contravariance, Bivariance, and Invariance explained<br />
<a href="https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8">https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8</a>
</li>

<li>Statická vs. dynamická typová kontrola<br />
<a href="https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/">https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/</a>
</li>

<li>Typový systém<br />
<a href="https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m">https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m</a>
</li>

<li>Comparison of programming languages by type system<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system</a>
</li>

<li>Flow<br />
<a href="https://flow.org/">https://flow.org/</a>
</li>

<li>TypeScript<br />
<a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a>
</li>

<li>Sorbet<br />
<a href="https://sorbet.org/">https://sorbet.org/</a>
</li>

<li>Pyright<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Mypy: Type hints cheat sheet<br />
<a href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html</a>
</li>

<li>PEP 484 – Type Hints<br />
<a href="https://peps.python.org/pep-0484/">https://peps.python.org/pep-0484/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

