<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovny pro zpracování posloupností (sekvencí) v Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovny pro zpracování posloupností (sekvencí) v Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Knihovny pro zpracování posloupností (sekvencí) v&nbsp;Pythonu</a></p>
<p><a href="#k02">*** 2. Sekvence a lazy sekvence v&nbsp;programovacím jazyku Clojure</a></p>
<p><a href="#k03">*** 3. Instalace knihovny <strong>clj</strong></a></p>
<p><a href="#k04">*** 4. Základní funkce pro práci se sekvencemi</a></p>
<p><a href="#k05">*** 5. První demonstrační příklad &ndash; použití základních funkcí pro konstrukci sekvencí a pro přístup k&nbsp;prvkům sekvence</a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovny pro zpracování posloupností (sekvencí) v&nbsp;Pythonu</h2>

<p></p>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Sekvence a lazy sekvence v&nbsp;programovacím jazyku Clojure</h2>

Mnoho funkcí a maker, které nalezneme ve standardní knihovně programovacího jazyka Clojure souvisí s&nbsp;takzvanými <i>sekvencemi</i>. Tímto termínem se označuje programové rozhraní, které svými základními možnostmi zhruba odpovídá iterátorům známým z programovacího jazyka Java. V&nbsp;Clojure existuje velké množství funkcí, které dokážou pracovat se sekvencemi, ať již se jedná o běžné sekvence (jejichž prvky jsou přímo uloženy v paměti), nebo takzvané líné sekvence (lazy sekvence), které nové prvky vytváří či zjišťují až při konkrétním přístupu na tyto prvky. Mezi tyto funkce patří například sort, sort-by, reverse či flatten. Díky tomu, že všechny kolekce (seznamy, vektory, ...) jsou současně i sekvencemi, lze tyto funkce aplikovat i na kolekce, ovšem ve skutečnosti jsou sekvencemi i další typy objektů – I/O proudy (je možná škoda, že se tímto směrem nevyvinulo API Javy, které je zrovna v případě I/O operací dosti složité), řetězce (což jsou sekvence znaků) atd.

Naprostý základ pro práci se sekvencemi tvoří trojice funkcí nazvaných first, rest a next. Funkce first vrací první prvek v sekvenci, popř.  speciální hodnotu nil v případě, že je sekvence prázdná. Funkce rest i next vrací zbylé prvky v sekvenci, ovšem liší se tím, jaká hodnota se vrátí ve chvíli, kdy již v sekvenci nezbyly žádné prvky (kromě prvního). V tomto případě vrátí rest prázdnou sekvenci (například prázdný seznam), zatímco funkce next vrátí hodnotu nil. U běžných sekvencí, například seznamů, jsou tyto funkce implementovány přímočaře, ovšem v případě lazy sekvencí se prvky vrácené pomocí funkce first vyhodnocují až za běhu, například pomocí nějaké generátorové funkce. Tímto způsobem je možné pracovat i s nekonečnými sekvencemi, u nichž už z principu nelze dopředu znát celkový počet prvků atd.

Velmi dobrým příkladem lazy sekvence je funkce range, která dokonce existuje v několika podobách, jež se od sebe z hlediska programátora-uživatele liší především různým počtem parametrů. Pokud se této funkci nepředá žádný parametr, vrátí funkce range sekvenci celých čísel od nuly do nekonečna. Zde je patrné, proč se musí jednat o lazy sekvenci – nekonečnou řadu celých čísel by samozřejmě v případě normální sekvence nebylo možné uložit do operační paměti. Pokud se funkci range předá pouze jediný parametr (kterým musí být celé číslo – je kontrolováno v runtime), je vrácena sekvence celých čísel od 0 do zadané hodnoty-1. Opět se jedná o nefalšovanou lazy sekvenci, takže se nemusíte bát používat i velké n. Dále již následují v podstatě jen kosmetické úpravy – volání funkce range se dvěma parametry m, n vytvoří sekvenci celých čísel od m do n-1 a pokud je použit ještě třetí parametr, určuje se jím krok, který může být i záporný. Vše si ukážeme na demonstračních příkladech:



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace knihovny <strong>clj</strong></h2>

<pre>
$ <strong>pip3 install --user clj</strong>
Collecting clj
  Downloading https://files.pythonhosted.org/packages/46/de/6d06743f2327f070602eb1f6dff525c92397de17fb418e206b13945e8468/clj-0.1.0.tar.gz
Installing collected packages: clj
  Running setup.py install for clj ... done
Successfully installed clj-0.1.0
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Základní funkce pro práci se sekvencemi</h2>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>count</td><td>vrátí počet prvků v&nbsp;sekvenci</td></tr>
<tr><td>2</td><td>cons</td><td>vrátí novou kolekci s&nbsp;přidaným prvkem (odkaz jazyka LISP)</td></tr>
<tr><td>3</td><td>concat</td><td>spojení dvou sekvencí (rozdílné od cons!)</td></tr>
<tr><td>4</td><td>first</td><td>první prvek sekvence</td></tr>
<tr><td>5</td><td>second</td><td>druhý prvek sekvence</td></tr>
<tr><td>6</td><td>rest</td><td>sekvence bez prvního prvku</td></tr>
<tr><td>7</td><td>nth</td><td>získání n-tého prvku sekvence</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. První demonstrační příklad &ndash; použití základních funkcí pro konstrukci sekvencí a pro přístup k&nbsp;prvkům sekvence</h2>

<pre>
(def s [1 2 3 1 2 3])
&nbsp;
(println "Count:")
(println (count s))
(println)
&nbsp;
(println "Reversed:")
(println (reverse s))
&nbsp;
(println "First:")
(println (first s))
(println "Second:")
(println (second s))
(println "Rest:")
(println (rest s))
&nbsp;
(println "Distinct items:")
&nbsp;
(println (distinct s))
&nbsp;
(println "Cons 1:")
(def new_sequence (cons s ["A" "B" "C"]))
(println new_sequence)
&nbsp;
(println "Cons 2:")
(def new_sequence_2 (cons ["A" "B" "C"] s))
(println new_sequence_2)
&nbsp;
(println "Concat 1:")
(def new_sequence (concat s ["A" "B" "C"])) 
(println new_sequence)
&nbsp;
(println "Concat 2:")
(def new_sequence_2 (concat ["A" "B" "C"] s))
(println new_sequence_2)
</pre>

<pre>
Count:
6
&nbsp;
Reversed:
(3 2 1 3 2 1)
&nbsp;
First:
1
&nbsp;
Second:
2
&nbsp;
Rest:
(2 3 1 2 3)
&nbsp;
Distinct items:
(1 2 3)
&nbsp;
Cons 1:
([1 2 3 1 2 3] A B C)
&nbsp;
Cons 2:
([A B C] 1 2 3 1 2 3)
&nbsp;
Concat 1:
(1 2 3 1 2 3 A B C)
&nbsp;
Concat 2:
(A B C 1 2 3 1 2 3)
</pre>

<p></p>

<pre>
from clj.seqs import count, first, second, rest, cons, concat, distinct
&nbsp;
&nbsp;
def hr():
    print(40*"-")
    print()
&nbsp;
&nbsp;
def print_sequence(sequence):
    for item in sequence:
        print(item)
    hr()
&nbsp;
&nbsp;
sequence = [1, 2, 3, 1, 2, 3]
&nbsp;
print("Original:")
print_sequence(sequence)
&nbsp;
# puvodni funkce len() a nova funkce count()
print("Len and count:")
print(len(sequence))
print(count(sequence))
hr()
&nbsp;
# puvodni (standardni) funkce reversed()
print("Reversed:")
print_sequence(reversed(sequence))
&nbsp;
# funkce first(), second() a rest()
print("First:")
print(first(sequence))
print("Second:")
print(second(sequence))
print("Rest:")
print(rest(sequence))
print_sequence(rest(sequence))
&nbsp;
# nova funkce distinct()
print("Distinct items:")
&nbsp;
print(distinct(sequence))
print_sequence(distinct(sequence))
&nbsp;
# prevod sekvence zpet na seznam
print(list(distinct(sequence)))
&nbsp;
# cons
print("Cons 1:")
new_sequence = cons(sequence, ["A", "B", "C"])
print_sequence(new_sequence)
&nbsp;
print("Cons 2:")
new_sequence_2 = cons(["A", "B", "C"], sequence)
print_sequence(new_sequence_2)
&nbsp;
# Concat
print("Concat 1:")
new_sequence = concat(sequence, ["A", "B", "C"])
print_sequence(new_sequence)
&nbsp;
print("Concat 2:")
new_sequence_2 = concat(["A", "B", "C"], sequence)
print_sequence(new_sequence_2)
</pre>

<pre>
Original:
1
2
3
1
2
3
----------------------------------------

Len and count:
6
6
----------------------------------------

Reversed:
3
2
1
3
2
1
----------------------------------------

First:
1
Second:
2
Rest:
<generator object drop at 0x7f255594b678>
2
3
1
2
3
----------------------------------------

Distinct items:
<generator object distinct at 0x7f255594b678>
1
2
3
----------------------------------------

[1, 2, 3]
Cons 1:
[1, 2, 3, 1, 2, 3]
A
B
C
----------------------------------------

Cons 2:
['A', 'B', 'C']
1
2
3
1
2
3
----------------------------------------

Concat 1:
1
2
3
1
2
3
A
B
C
----------------------------------------

Concat 2:
A
B
C
1
2
3
1
2
3
----------------------------------------
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<pre>
from clj.seqs import remove


def hr():
    print(40*"-")
    print()


def print_sequence(sequence):
    for item in sequence:
        print(item)
    hr()


sequence = range(1, 10)

print("Original:")
print_sequence(sequence)

filtered = filter(lambda x: x % 3 == 0, sequence)
print("Filtered:")
print_sequence(filtered)

removed = remove(lambda x: x % 3 == 0, sequence)
print("Removed:")
print_sequence(removed)

filtered = filter(lambda _: True, sequence)
print("Filtered:")
print_sequence(filtered)

removed = remove(lambda _: True, sequence)
print("Removed:")
print_sequence(removed)
</pre>

<pre>
Original:
1
2
3
4
5
6
7
8
9
----------------------------------------

Filtered:
3
6
9
----------------------------------------

Removed:
1
2
4
5
7
8
----------------------------------------
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
from clj.seqs import group_by

sequence = range(1, 100)

print(group_by(lambda x: x % 3, sequence))

groups = group_by(lambda x: x % 3, sequence)

keys = sorted(groups.keys())

for key in keys:
    print(key, groups[key])
</pre>

<pre>
{1: [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58, 61, 64, 67, 70, 73, 76, 79, 82, 85, 88, 91, 94, 97], 2: [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59, 62, 65, 68, 71, 74, 77, 80, 83, 86, 89, 92, 95, 98], 0: [3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]}
0 [3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]
1 [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58, 61, 64, 67, 70, 73, 76, 79, 82, 85, 88, 91, 94, 97]
2 [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59, 62, 65, 68, 71, 74, 77, 80, 83, 86, 89, 92, 95, 98]
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
from clj.seqs import interleave, repeat

def hr():
    print(40*"-")
    print()


def print_sequence(sequence):
    for item in sequence:
        print(item)
    hr()


sequence1 = range(1, 10)
sequence2 = ["red", "blue", "green", "yellow", "orange", "cyan", "white", "black"]

print("Two sequences interleaved:")
print_sequence(interleave(sequence1, sequence2))

print("Three sequences interleaved:")
print_sequence(interleave(sequence1, sequence2, repeat("*", 10)))
</pre>

<pre>
Two sequences interleaved:
1
red
2
blue
3
green
4
yellow
5
orange
6
cyan
7
white
8
black
----------------------------------------

Three sequences interleaved:
1
red
*
2
blue
*
3
green
*
4
yellow
*
5
orange
*
6
cyan
*
7
white
*
8
black
*
----------------------------------------
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
(def my-sequence (range))

(println (take-while #(< % 10) my-sequence))

(println (take-while #(< % 10) my-sequence))
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

V některých případech nám bude užitečná i poněkud komplikovanější funkce, která je nazvaná take-while. Zatímco u funkce take se přímo zadával počet prvků lazy sekvence, která se má vrátit, je v případě funkce take-while namísto konstantního počtu prvků výsledné sekvence předán predikát, tj. funkce s (v tomto případě) jedním parametrem, jejímž výsledkem by měla být pravdivostní hodnota true nebo false (asi si již nemusíme připomínat, že funkce lze v Clojure použít na stejném místě, jako jiné typy hodnot, tedy i funkce lze bez problémů předat jako parametr do jiné funkce).

Návratovou hodnotou funkce take-while je opět lazy sekvence získaná ze vstupní sekvence, ovšem vráceno je pouze prvních n prvků, pro něž predikát vrací hodnotu true. Nejedná se však o klasický filtr (viz též další kapitoly), protože ihned ve chvíli, kdy predikát poprvé vrátí hodnotu false, je lazy sekvence ukončena. Pokud vrátí predikát hodnotu false již při prvním volání, je výsledkem prázdná sekvence, pokud naopak vrací hodnotu true vždy, vrátí se potenciálně nekonečná lazy sekvence (což však někdy nemusí vadit, pokud se tedy nebudeme snažit o výpis všech prvků). Vzhledem k určitým omezením take-while je nutné, aby měl predikát pouze jeden parametr, což většinou znamená, že si musíme vypomoci novou funkcí (popř. anonymní funkcí).

<pre>
from clj.seqs import count, range, take_while, remove


def hr():
    print(40*"-")
    print()


def print_sequence(sequence):
    for item in sequence:
        print(item)
    hr()


sequence = range()

# toto NE: print(count(sequence))

new_sequence_1 = take_while(lambda x: x < 10, sequence)
print_sequence(new_sequence_1)


def podminka(x):
    return x < 10


sequence = range()

new_sequence_2 = take_while(podminka, sequence)
print_sequence(new_sequence_2)


# nekonecna lazy sekvence
sequence = range()

# lze ji filtrovat
filtered = filter(lambda x: x % 3 == 0, sequence)

# a vybrat n prvku z nekonecneho poctu
new_sequence = take_while(lambda x: x < 100, filtered)
print_sequence(new_sequence)


print()


# nekonecna lazy sekvence
sequence = range()

# lze ji filtrovat
removed = remove(lambda x: x % 3 != 0, sequence)

# a vybrat n prvku z nekonecneho poctu
new_sequence = take_while(lambda x: x < 100, removed)
print_sequence(new_sequence)
</pre>

0
1
2
3
4
5
6
7
8
9
----------------------------------------

0
1
2
3
4
5
6
7
8
9
----------------------------------------

0
3
6
9
12
15
18
21
24
27
30
33
36
39
42
45
48
51
54
57
60
63
66
69
72
75
78
81
84
87
90
93
96
99
----------------------------------------


0
3
6
9
12
15
18
21
24
27
30
33
36
39
42
45
48
51
54
57
60
63
66
69
72
75
78
81
84
87
90
93
96
99
----------------------------------------



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

Při práci s lazy sekvencemi, které obsahují nekonečný počet prvků, si musíme dát pozor na to, aby se náhodou nespustilo vyhodnocení celé (nekonečné) sekvence. V reálných programech k tomuto problému v naprosté většině případů nedochází, už jen z toho důvodu, že například funkce map jako svůj parametr akceptuje lazy sekvenci a jejím výsledkem je taktéž lazy sekvence.

My ovšem v následujících kapitolách budeme muset zjistit a vypsat hodnotu alespoň několika prvků nekonečných lazy sekvencí. K tomuto účelu nám dobře poslouží funkce nth, take a někdy taktéž poněkud složitější funkce take-while zmíněna v&nbsp;textu výše. Nejjednodušší z této trojice funkcí je funkce nth, jež – jak jste již asi z jejího názvu uhodli – vrací n-tý prvek sekvence, což většinou znamená, že se vyhodnotí i předchozích n-1 prvků (ovšem ve skutečnosti se výsledky ukládají do vyrovnávací paměti, takže někdy k vyhodnocení nedochází):

user=&gt; <strong>(def s (range))</strong>
#'user/s
user=&gt; <strong></strong>

user=&gt; <strong>(println (nth s 10))</strong>
10

user=&gt; <strong>(println (nth s 10))</strong>
10

user=&gt; <strong>(println (nth s 10))</strong>
10

Zatímco funkce nth vrátí konkrétní prvek z lazy sekvence, je další užitečná funkce – take – poněkud obecnější, neboť ta vrací prvních n prvků lazy sekvence. Ovšem výsledkem není vektor či seznam těchto prvků, ale taktéž lazy sekvence, což znamená, že k vyhodnocení (získání) prvků dochází později a někdy taktéž vůbec ne. My ovšem v našich příkladech budeme výsledek funkce take vypisovat pomocí REPL, takže k vyhodnocení dojde vždy:

(user=&gt; <strong>(println (take 10 s))</strong>
(0 1 2 3 4 5 6 7 8 9)

user=&gt; <strong>(println (take 5 (drop  10 s)))</strong>
(10 11 12 13 14)

user=&gt; <strong>(->> (range) (drop 10) (take 5) println)</strong>
(10 11 12 13 14)



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes zmíněných demonstračních příkladů byly uloženy do
Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/lisps-for-python-vm">https://github.com/tisnik/lisps-for-python-vm</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, stále doslova několik kilobajtů), můžete namísto toho použít odkazy
na jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Adresa</th></tr>
<tr><td>1</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>2</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>3</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>4</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>5</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>6</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>7</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
</table>

<p>Alternativní (a přibližně ekvivalentní) příklady naprogramované přímo
v&nbsp;Clojure:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Adresa</th></tr>
<tr><td>1</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>2</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>3</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>4</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>5</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>6</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
<tr><td>7</td><td></td><td><a href="https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/">https://github.com/tisnik/lisps-for-python-vm/blob/master/clj-library/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>clj - repositář s knihovnou<br />
<a href="https://github.com/bfontaine/clj">https://github.com/bfontaine/clj</a>
</li>

<li>clj 0.1.0 - stránka na PyPi<br />
<a href="https://pypi.python.org/pypi/clj/0.1.0">https://pypi.python.org/pypi/clj/0.1.0</a>
</li>

<li>Clojure aneb jazyk umožňující tvorbu bezpečných vícevláknových aplikací pro JVM (4.část - kolekce, sekvence a lazy sekvence) <br />
<a href="https://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">https://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure a bezpečné aplikace pro JVM: sekvence, lazy sekvence a paralelní programy <br />
<a href="https://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">https://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Python becomes a platform<br />
<a href="https://khinsen.wordpress.com/2012/03/15/python-becomes-a-platform/">https://khinsen.wordpress.com/2012/03/15/python-becomes-a-platform/</a>
</li>

<li>Python becomes a platform. Thoughts on the release of clojure-py<br />
<a href="https://news.ycombinator.com/item?id=3708974">https://news.ycombinator.com/item?id=3708974</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Making Clojure Lazier<br />
<a href="https://clojure.org/reference/lazy">https://clojure.org/reference/lazy</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>Clojure<br />
<a href="https://en.wikipedia.org/wiki/Clojure">https://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojars<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>Emacs LISP<br />
<a href="https://www.root.cz/clanky/historie-vyvoje-textovych-editoru-eine-zwei-emacs/#k08">https://www.root.cz/clanky/historie-vyvoje-textovych-editoru-eine-zwei-emacs/#k08</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Speciální formy, lambda výrazy a makra v programovacím jazyku LISP <br />
<a href="https://www.root.cz/clanky/specialni-formy-lambda-vyrazy-a-makra-v-programovacim-jazyku-lisp/">https://www.root.cz/clanky/specialni-formy-lambda-vyrazy-a-makra-v-programovacim-jazyku-lisp/</a>
</li>

<li>Programovací jazyky používané (nejen) v SSSR (část 3 – LISP)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-nejen-v-nbsp-sssr-cast-3-ndash-lisp/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-nejen-v-nbsp-sssr-cast-3-ndash-lisp/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>
