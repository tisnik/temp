<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Rychlost CPythonu 3.11 a 3.12 v porovnání s JIT a AOT překladači Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Rychlost CPythonu 3.11 a 3.12 v porovnání s JIT a AOT překladači Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Standardní interpret Pythonu verze 3.11 (CPython 3.11) je na základě benchmarků rychlejší, než předchozí verze. Naskýtá se tedy otázka, jak dobrý je CPython v porovnání s existujícími JIT a AOT překladači Pythonu. Proto dnes provedeme měření rychlosti provádění FP výpočtů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Rychlost CPythonu 3.11 a 3.12 v&nbsp;porovnání s&nbsp;JIT a AOT překladači Pythonu</a></p>
<p><a href="#k02">2. JIT a AOT překladače Pythonu</a></p>
<p><a href="#k03">3. AOT překladač <i>mypyc</i></a></p>
<p><a href="#k04">4. Instalace a první spuštění překladače <i>mypyc</i></a></p>
<p><a href="#k05">5. Příklad použití překladače <i>mypyc</i></a></p>
<p><a href="#k06">6. Spuštění kódu</a></p>
<p><a href="#k07">7. Zjištění, které části kódu bylo možné přeložit optimálním způsobem</a></p>
<p><a href="#k08">8. Doplnění všech typových informací</a></p>
<p><a href="#k09">9. Poznámka k&nbsp;hodnotě <strong>__name__</strong></a></p>
<p><a href="#k10">10. JIT a AOT překladač Numba</a></p>
<p><a href="#k11">11. (Mikro)benchmark: výpočty s&nbsp;využitím FP hodnot</a></p>
<p><a href="#k12">12. Nativní varianta benchmarku přepsaná do ANSI C</a></p>
<p><a href="#k13">13. Varianty upravené pro Mypyc</a></p>
<p><a href="#k14">14. Varianty upravené pro Numbu</a></p>
<p><a href="#k15">15. Výsledky benchmarků: rychlost výpočtů</a></p>
<p><a href="#k16">16. Výsledky benchmarků: spotřeba operační paměti</a></p>
<p><a href="#k17">17. Zdrojové kódy benchmarků použitých v&nbsp;dnešním článku</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady pro nástroj Numba</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady pro nástroj Mypy</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Rychlost Pythonu 3.11 a 3.12 v&nbsp;porovnání s&nbsp;JIT a AOT překladači Pythonu</h2>

<p><a href="https://www.root.cz/n/python/">Programovací jazyk Python</a>
zajisté není zapotřebí čtenářům Roota podrobně představovat. V&nbsp;současnosti
se jedná o jeden z&nbsp;nejpoužívanějších a současně i nejpopulárnějších (což
ovšem ani zdaleka není totéž) programovacích jazyků a v&nbsp;praxi se používá
jak pro psaní jednorázových skriptů, tak i mnohdy velmi rozsáhlých aplikací.
Jednou z&nbsp;nevýhod Pythonu je resp.&nbsp;byl relativně pomalý běh aplikací
psaných v&nbsp;tomto jazyku. Řekněme si to na rovinu: z&nbsp;mainstreamových
jazyků vycházel klasický CPython většinou jako nejpomalejší technologie. Ovšem
v&nbsp;současnosti již není situace vůbec špatná, protože existují JIT (<i>just
in time</i>) i AOT (<i>ahead of time</i>) překladače Pythonu. A navíc i
klasický CPython je neustále vylepšován, přičemž poměrně velký výkonnostní skok
se odehrál u Python verze 3.11 (a některá vylepšení nalezneme i u verze
3.12).</p>

<p>V&nbsp;dnešním článku se přesvědčíme, jak rychlý či naopak pomalý je
klasický CPython (verze 3.8 až 3.12) při provádění FP operací v&nbsp;porovnání
s&nbsp;JIT překladačem <i>Numba</i> a taktéž v&nbsp;porovnání s&nbsp;AOT
překladačem <i>mypyc</i> (což je nástroj, který je součástí Mypy). JIT
překladačem Numba jsme se již na stránkách Roota zabývali, a to konkrétně
v&nbsp;článcích <a
href="https://www.root.cz/clanky/projekt-numba-aneb-dalsi-pristup-k-prekladu-pythonu-do-nativniho-kodu/">Projekt
Numba aneb další přístup k překladu Pythonu do nativního kódu</a> a <a
href="https://www.root.cz/clanky/just-in-time-preklad-programu-psanych-v-pythonu-nastrojem-numba/">Just
in time překlad programů psaných v Pythonu nástrojem Numba</a>. Nástroj
<i>mypy</i> prozatím nebyl popsán, takže se v&nbsp;navazujících kapitolách
alespoň ve stručnosti zmíníme o jeho základních vlastnostech. Navážeme přitom
na následující články o Mypy:</p>

<ol>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/</a>
</a>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (2.část)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/</a>
</a>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/</a>
</a>

</ol>

<p><div class="rs-tip-major">Poznámka: důvodem, proč se zaměříme na CPython
verze 3.8 až 3.12 a nikoli na starší verze Pythonu, je ten, že starší verze již
oficiálně nejsou podporovány &ndash; viz též přehledná tabulka
s&nbsp;podporovanými a nepodporovanými verzemi Pythonu, kterou lze najít na
adrese <a
href="https://devguide.python.org/versions/">https://devguide.python.org/versions/</a>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. JIT a AOT překladače Pythonu</h2>

<p>Klasický CPython byl původně navržen jako interpret bajtkódu virtuálního
stroje Pythonu. Zdrojové kódy se před spuštěním přeložily do bajtkódu a ten byl
interpretován, což je (podle očekávání) poměrně pomalé. Proto postupně vznikly
překladače zajišťující překlad zdrojových kódu Pythonu do nativního kódu.
Takový překlad lze provést v&nbsp;jediném kroku nebo ve více fázích (frontend a
backend překladače). Navíc se od sebe překladače liší podle toho, zda je
překlad proveden ještě před spuštěním aplikace (<i>AOT</i> &ndash; <i>Ahead of
Time</i>) nebo ve chvíli, kdy se načítají jednotlivé balíčky nebo když se
detekuje &bdquo;horká&ldquo; část kódu (<i>JIT</i> &ndash; <i>Just in
Time</i>). Každý ze zmíněných způsobů, tedy interpretace, JIT překlad a AOT
překlad, má své výhody a zápory a obecně asi není možné říci, který z&nbsp;nich
je obecně výhodnější (záleží na konkrétním způsobu použití).</p>

<p>Bez dalších podrobností si můžeme jednotlivé AOT a JIT překladače
vypsat:</p>

<table>
<tr><th>Překladač</th><th>Typ</th><th>Poznámka</th></tr>
<tr><td>Cython</td><td>AOT</td><td>nadmnožina Pythonu</td></tr>
<tr><td>Numba</td><td>JIT (+AOT)</td><td>viz další text</td></tr>
<tr><td>PyPy</td><td>JIT</td><td>&nbsp;</td></tr>
<tr><td>mypyc</td><td>AOT</td><td>nepovinné typové informace</td></tr>
<tr><td>Psyco</td><td>JIT</td><td>již neudržován, zmíněn pouze pro úplnost</td></tr>
<tr><td>Unladen Swallow</td><td>JIT pro CPython</td><td>již nevyvíjen, některé vlastnosti jsou přímo v&nbsp;CPythonu</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. AOT překladač <i>mypyc</i></h2>

<p>Příkladem AOT překladače Pythonu je nástroj nazvaný <strong>mypyc</strong>.
Ten je součástí instalace <i>Mypy</i>. Nástroj <strong>mypyc</strong> pracuje
následujícím způsobem:</p>

<ol>
<li>Je provedena analýza původního Pythonovského kódu s&nbsp;jeho překladem do AST</li>
<li>Na základě AST (s&nbsp;typy) je vygenerován zdrojový kód v&nbsp;jazyku C</li>
<li>Tento kód je přeložen překladačem céčka (typicky gcc)</li>
<li>Výsledkem je sdílená knihovna strukturovaná takovým způsobem, že ji lze využít jako C-extension jazyka Python</li>
</ol>

<p>Výslednou sdílenou knihovnu (<i>so</i> &ndash; <i>shared object</i>) lze
naimportovat do Pythonovského skriptu (odpovídá totiž specifikaci C-extension).
Na rozdíl od dalších AOT překladačů tedy není výsledkem přímo spustitelný
soubor, což opět přináší některé přednosti, ale i zápory.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace a první spuštění překladače <i>mypyc</i></h2>

<p>Překladač <i>mypyc</i> je součástí balíčku <i>Mypy</i> (podpora a kontrola
typových informací v&nbsp;Pythonu). Samotná instalace je snadná (předpokladem
ovšem je, že je již nainstalován CPython verze 3.5 či vyšší):</p>

<pre>
$ <strong>pip3 install --user mypy</strong>
&nbsp;
Collecting mypy
  Downloading mypy-1.3.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (12.2 MB)
     |████████████████████████████████| 12.2 MB 779 kB/s 
Requirement already satisfied: typing-extensions&gt;=3.10 in ./.local/lib/python3.8/site-packages (from mypy) (4.4.0)
Collecting tomli&gt;=1.1.0; python_version &lt; "3.11"
  Downloading tomli-2.0.1-py3-none-any.whl (12 kB)
Collecting mypy-extensions&gt;=1.0.0
  Downloading mypy_extensions-1.0.0-py3-none-any.whl (4.7 kB)
Installing collected packages: tomli, mypy-extensions, mypy
Successfully installed mypy-1.3.0 mypy-extensions-1.0.0 tomli-2.0.1
</pre>

<p>Většinou je ovšem ještě nutné provést upgrade balíčku nazvaného
<strong>typing_extensions</strong>:</p>

<pre>
$ pip3 install --upgrade --user typing_extensions
&nbsp;
Collecting typing_extensions
  Downloading typing_extensions-4.6.3-py3-none-any.whl (31 kB)
Installing collected packages: typing-extensions
  Attempting uninstall: typing-extensions
    Found existing installation: typing-extensions 4.4.0
    Uninstalling typing-extensions-4.4.0:
      Successfully uninstalled typing-extensions-4.4.0
Successfully installed typing-extensions-4.6.3
</pre>

<p>Otestování, zda je Mypy spustitelný:</p>

<pre>
$ <strong>mypy --version</strong>
&nbsp;
mypy 1.3.0 (compiled: yes)
</pre>

<p>Nás ovšem dnes bude zajímat především <strong>mypyc</strong>. I ten by měl
být dostupný:</p>

<pre>
$ <strong>mypyc --help</strong>
&nbsp;
usage: mypy [-h] [-v] [-V] [more options; see below]
            [-m MODULE] [-p PACKAGE] [-c PROGRAM_TEXT] [files ...]
&nbsp;
Mypy is a program that will type check your Python code.
&nbsp;
Pass in any files or folders you want to type check. Mypy will
recursively traverse any provided folders to find .py files:
&nbsp;
    $ mypy my_program.py my_src_folder
&nbsp;
For more information on getting started, see:
&nbsp;
- https://mypy.readthedocs.io/en/stable/getting_started.html
&nbsp;
For more details on both running mypy and using the flags below, see:
...
...
...
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Příklad použití překladače <i>mypyc</i></h2>

<p>Podívejme se nyní na způsob použití AOT překladače <i>mypyc</i>. Necháme si
přeložit výpočet Mandelbrotovy množiny (podrobnosti budou uvedeny níže).
Výpočet přitom není nijak optimalizován a prozatím AOT překladači ani nijak
&bdquo;nepomůžeme&ldquo; specifikací datových typů. Už dopředu je možné
naznačit, že kvůli chybějícím typovým informacím nebude výsledek ideální, ovšem
úpravy (přidání typových informací) kupodivu v&nbsp;tomto případě nebudou nijak
složité:</p>

<pre>
import palette_mandmap
from sys import argv
&nbsp;
def calc_mandelbrot(width, height, maxiter, palette):
    print("P3")
    print("{w} {h}".format(w=width, h=height))
    print("255")
&nbsp;
    cy = -1.5
    for y in range(0, height):
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print("{r} {g} {b}".format(r=r, g=g, b=b))
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
&nbsp;
if len(argv) &lt; 4:
    width = 512
    height = 512
    maxiter = 255
else:
    width = int(argv[1])
    height = int(argv[2])
    maxiter = int(argv[3])
calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p>AOT překlad se provede takto:</p>

<pre>
$ <strong>mypyc mandelbrot_5.py</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;názvu souboru nepoužívejte
pomlčku ani další znaky, které mají v&nbsp;céčku speciální význam!</div></p>

<p>Samotný překlad je relativně rychlý:</p>

<pre>
running build_ext
building 'mandelbrot_5' extension
creating build/temp.linux-x86_64-cpython-311
creating build/temp.linux-x86_64-cpython-311/build
gcc -Wsign-compare -DDYNAMIC_ANNOTATIONS_ENABLED=1 -DNDEBUG -O2 -fexceptions -g -grecord-gcc-switches -pipe -Wall -Werror=format-security -Wp,-U_FORTIFY_SOURCE,-D_FORTIFY_SOURCE=3 -Wp,-D_GLIBCXX_ASSERTIONS -fstack-protector-strong -m64 -mtune=generic -fasynchronous-unwind-tables -fstack-clash-protection -fcf-protection -O2 -fexceptions -g -grecord-gcc-switches -pipe -Wall -Werror=format-security -Wp,-U_FORTIFY_SOURCE,-D_FORTIFY_SOURCE=3 -Wp,-D_GLIBCXX_ASSERTIONS -fstack-protector-strong -m64 -mtune=generic -fasynchronous-unwind-tables -fstack-clash-protection -fcf-protection -O2 -fexceptions -g -grecord-gcc-switches -pipe -Wall -Werror=format-security -Wp,-U_FORTIFY_SOURCE,-D_FORTIFY_SOURCE=3 -Wp,-D_GLIBCXX_ASSERTIONS -fstack-protector-strong -m64 -mtune=generic -fasynchronous-unwind-tables -fstack-clash-protection -fcf-protection -fPIC -I/usr/local/lib64/python3.11/site-packages/mypyc/lib-rt -I/usr/include/python3.11 -c build/__native.c -o build/temp.linux-x86_64-cpython-311/build/__native.o -O3 -g1 -Werror -Wno-unused-function -Wno-unused-label -Wno-unreachable-code -Wno-unused-variable -Wno-unused-command-line-argument -Wno-unknown-warning-option -Wno-unused-but-set-variable -Wno-ignored-optimization-argument -Wno-cpp
creating build/lib.linux-x86_64-cpython-311
gcc -shared -Wl,-z,relro -Wl,--as-needed -Wl,-z,now -Wl,--build-id=sha1 -Wl,-z,relro -Wl,--as-needed -Wl,-z,now -Wl,--build-id=sha1 build/temp.linux-x86_64-cpython-311/build/__native.o -L/usr/lib64 -o build/lib.linux-x86_64-cpython-311/mandelbrot_5.cpython-311-x86_64-linux-gnu.so
copying build/lib.linux-x86_64-cpython-311/mandelbrot_5.cpython-311-x86_64-linux-gnu.so -&gt;
</pre>

<p>Výsledkem by měl být tento soubor (koncovka napovídá, že se jedná o sdílenou
knihovnu):</p>

<pre>
-rwxrwxr-x   1 ptisnovs ptisnovs  366664 Nov 18 10:22 mandelbrot_5.cpython-38-x86_64-linux-gnu.so
</pre>

<p>Současně se v&nbsp;průběhu překladu vytvořil i podadresář
<strong>build</strong>, který však nebudeme dále potřebovat. Použít ho lze ve
chvíli, kdy je nutné výše zmíněnou knihovnu nainstalovat (což však nebudeme
potřebovat):</p>

<pre>
build
├── lib.linux-x86_64-cpython-311
│   └── mandelbrot_5.cpython-311-x86_64-linux-gnu.so
├── __native.c
├── __native.h
├── __native_internal.h
├── ops.txt
├── setup.py
└── temp.linux-x86_64-cpython-311
    └── build
        └── __native.o
&nbsp;
4 directories, 8 files
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Spuštění kódu</h2>

<p>Samotné spuštění kódu, který by měl vykreslit Mandelbrotou množinu, se
provede takto:</p>

<pre>
$ <strong>python3 -c "import mandelbrot_5" 400 400 255 > mandelbrot.ppm</strong>
</pre>

<p>Výsledkem by měl být tento obrázek:</p>

<img src="https://i.iinfo.cz/images/327/mypyc-1.webp" class="image-1110093" width="400" height="400" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 1: Výsledek běhu programu, jenž vznikl AOT překladem
Pythonovského kódu.</i></p>

<p>O tom, že výše uvedený příkaz nebude importovat soubor
<strong>mandelbrot_5.py</strong>, ale nativní sdílenou knihovnu, se můžeme
přesvědčit například použitím nástroje <strong>strace</strong>:</p>

<pre>
$ <strong>strace python3 -c "import mandelbrot_5" 400 400 255 > mandelbrot.ppm</strong>
</pre>

<p>V&nbsp;zobrazených zprávách lze najít mj.&nbsp;i tyto informace ukazující,
že se skutečně načetla sdílená knihovna:</p>

<pre>
execve("/usr/bin/python3", ["python3", "-c", "import mandelbrot_5"], 0x7ffd0f6a5670 /* 60 vars */) = 0
...
...
...
stat(<strong>"/tmp/ramdisk/mandelbrot_5.cpython-38-x86_64-linux-gnu.so"</strong>, {st_mode=S_IFREG|0775, st_size=366664, ...}) = 0
futex(0x7f4d65b320c8, FUTEX_WAKE_PRIVATE, 2147483647) = 0
openat(AT_FDCWD, "/tmp/ramdisk/mandelbrot_5.cpython-38-x86_64-linux-gnu.so", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\0\205\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0775, st_size=366664, ...}) = 0
mmap(NULL, 248488, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f4d64fbf000
mmap(0x7f4d64fc6000, 192512, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x7000) = 0x7f4d64fc6000
mmap(0x7f4d64ff5000, 20480, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x36000) = 0x7f4d64ff5000
mmap(0x7f4d64ffa000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x3a000) = 0x7f4d64ffa000
close(3)                                = 0
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zjištění, které části kódu bylo možné přeložit optimálním způsobem</h2>

<p>Překladač <i>mypyc</i> se snaží o překlad veškerého zdrojového kódu, který
je mu předán. Ovšem pokud nemá k&nbsp;dispozici typové informace, nebude
výsledek optimální. Proto je vhodné zjistit, které části kódu nejsou přeloženy
optimálně kvůli tomu, že jsme AOT překladači nedodali všechny důležité typové
informace. Toto zjištění je snadné a můžeme ho získat v&nbsp;několika formátech
(textový, HTML, formát kompatibilní s&nbsp;Coberturou atd.).</p>

<p>Celkový přehled lze získat příkaze:</p>

<pre>
$ <strong>mypyc --txt-report report mandelbrot_5.py</strong>
</pre>

<p>Výsledkem bude tato tabulka:</p>

<pre>
Mypy Type Check Coverage Summary
================================
&nbsp;
Script: index
&nbsp;
+--------------+-------------------+--------+
| Module       | Imprecision       | Lines  |
+--------------+-------------------+--------+
| mandelbrot_5 |  63.41% imprecise | 41 LOC |
+--------------+-------------------+--------+
| Total        |  63.41% imprecise | 41 LOC |
+--------------+-------------------+--------+
</pre>

<p>Podrobnější čitelný výsledek získáme příkazem:</p>

<pre>
$ <strong>mypyc --html-report html mandelbrot_5.py</strong>
</pre>

<p>Výsledkem bude HTML stránka, kde jsou zvýrazněny řádky přeložené optimálně i
ty řádky, které nebylo možné optimálně přeložit:</p>

<a href="https://www.root.cz/obrazek/1110094/"><img src="https://i.iinfo.cz/images/327/mypyc-2-prev.webp" class="image-1110094" width="197" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-2-prev.webp" data-prev-width="197" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-2-large.webp" data-large-width="383" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 2: Optimálně a neoptimálně přeložené řádky původního skriptu.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Doplnění všech typových informací</h2>

<p>Ve skutečnosti je doplnění typových informací v&nbsp;našem konkrétním
případě relativně snadné a změny se týkají pouze hlavičky funkce
s&nbsp;výpočtem fraktálu. Náš kód bude po úpravách vypadat takto (změna se týká
jen zvýrazněného řádku):</p>

<pre>
import palette_mandmap
from sys import argv
&nbsp;
from typing import Tuple
&nbsp;
&nbsp;
<strong>def calc_mandelbrot(width: int, height: int, maxiter: int, palette: Tuple[Tuple[int, int, int], ...]) -&gt; None:</strong>
    print("P3")
    print("{w} {h}".format(w=width, h=height))
    print("255")
&nbsp;
    cy = -1.5
    for y in range(0, height):
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print("{r} {g} {b}".format(r=r, g=g, b=b))
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
&nbsp;
if len(argv) &lt; 4:
    width = 512
    height = 512
    maxiter = 255
else:
    width = int(argv[1])
    height = int(argv[2])
    maxiter = int(argv[3])
calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p>Snadno lze zjistit, že je nyní optimálně přeložen veškerý kód:</p>

<pre>
Mypy Type Check Coverage Summary
================================
&nbsp;
Script: index
&nbsp;
+--------------+-------------------+--------+
| Module       | Imprecision       | Lines  |
+--------------+-------------------+--------+
| mandelbrot_6 |   0.00% imprecise | 44 LOC |
+--------------+-------------------+--------+
| Total        |   0.00% imprecise | 44 LOC |
+--------------+-------------------+--------+
</pre>

<a href="https://www.root.cz/obrazek/1110095/"><img src="https://i.iinfo.cz/images/327/mypyc-3-prev.webp" class="image-1110095" width="303" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-3-prev.webp" data-prev-width="303" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-3-large.webp" data-large-width="589" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 3: Všechny řádky jsou nyní přeloženy optimálním způsobem.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Poznámka k&nbsp;hodnotě <strong>__name__</strong></h2>

<p>Při AOT překladu již existujících skriptů můžeme narazit na jeden problém,
který je ovšem snadno řešitelný (a vlastně se nejedná o problém, ale o
potenciálně výhodnou vlastnost). Týká se to hodnoty <strong>__name__</strong>,
která má při běžném spuštění Pythonovského skriptu hodnotu
<strong>__main__</strong>, o čemž se můžeme snadno přesvědčit spuštěním
následujícího jednořádkového skriptu:</p>

<pre>
print(__name__)
</pre>

<p>Při přímém spuštění (interpretaci) tohoto skriptu dostaneme
očekávaný výstup:</p>

<pre>
$ <strong>python3 print_name.py</strong>
&nbsp;
__main__
</pre>

<p>Při importu se ovšem vypíše odlišné jméno:</p>

<pre>
$ <strong>python3 -c "import print_name"</strong>
&nbsp;
print_name
</pre>

<p>Totéž ovšem platí po AOT překladu, protože výslednou sdílenou knihovnu nelze &bdquo;spustit&ldquo; ale importovat:</p>

<pre>
$ <strong>mypyc print_name.py</strong>
running build_ext
copying build/lib.linux-x86_64-3.8/print_name.cpython-38-x86_64-linux-gnu.so -&gt;
&nbsp;
$ <strong>rm print_name.py</strong>
&nbsp;
$ <strong>python3 -c "import print_name"</strong>
&nbsp;
print_name
</pre>

<p>Co to znamená v&nbsp;praxi? Skripty, jejichž kód, který se má spustit, je
&bdquo;schovaný&ldquo; před importem, budou pouze importovány, ale takový kód
se nespustí:</p>

<pre>
def main():
    ...
    ...
    ...
&nbsp;
if __name__ == "__main__":
    main() <i># nespustí se</i>
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;tohoto důvodu benchmarky použité
dnes tento způsob nepoužívají.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. JIT a AOT překladač Numba</h2>

<p>Nástroj Numba podporuje překlad vybraných částí kódu aplikace psané
v&nbsp;Pythonu do nativního kódu cílové platformy (x86-64 apod.), přičemž
cílovou platformou může být i GPU (přes CUDA). Jedná se tedy o takzvaný <a
href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT</a> neboli o
<i>just-in-time</i> překladač, který má tu výhodu, že dokáže odvodit datové
typy proměnných a argumentů funkcí na základě skutečného chování aplikace, tedy
na základě typů předávaných parametrů a kontextu. To samozřejmě neznamená, že
by JIT již při prvním volání funkce přesně věděl, jak má funkci přeložit.</p>

<p>Ve skutečnosti se dozví pouze informace o jediné konkrétní větvi, kterou
může přeložit. V&nbsp;případě, že bude ta samá funkce později volána
s&nbsp;odlišnými typy parametrů, popř.&nbsp;se její chování změní jiným
způsobem (Python je velmi dynamický jazyk), provede se just-in-time překlad
znovu, takže zde zaplatíme za vyšší výpočetní výkon poněkud většími paměťovými
nároky a pomalejším během prvních volání funkce. Na druhou stranu mnoho
náročných výpočtů používá Numpy a Numba s&nbsp;Numpy dokáže spolupracovat velmi
dobře.</p>

<p>Z&nbsp;pohledu běžného vývojáře je největší předností tohoto způsobu
překladu fakt, že není zapotřebí samotný zdrojový kód měnit (až na uvedení
anotace před funkci). Nepříjemný je přesun času překladu do runtime, což sice
nevadí u aplikací, které běží delší dobu, ovšem u jednorázových skriptů může
být použití JITu spíše kontraproduktivní &ndash; vliv JIT překladu ostatně
uvidíme na výsledku benchmarků.</p>

<p>Samotný překlad je prováděn na několika úrovních, přičemž Numba na nižších
úrovních využívá možností nabízených LLVM. Jedná se o relativně složitou
problematiku, které se budeme věnovat v&nbsp;samostatném článku.</p>

<p>Pro účely benchmarků si nainstalujeme i nástroj Numba:</p>

<pre>
$ <strong>sudo python3 -m pip install --upgrade pip</strong>
&nbsp;
Collecting pip
  Downloading https://files.pythonhosted.org/packages/a4/6d/6463d49a933f547439d6b5b98b46af8742cc03ae83543e4d7688c2420f8b/pip-21.3.1-py3-none-any.whl (1.7MB)
    100% |████████████████████████████████| 1.7MB 764kB/s 
Installing collected packages: pip
  Found existing installation: pip 9.0.3
    Uninstalling pip-9.0.3:
      Successfully uninstalled pip-9.0.3
Successfully installed pip-21.3.1
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. (Mikro)benchmark: výpočty s&nbsp;využitím FP hodnot</h2>

<p>Vzhledem k&nbsp;tomu, že se v&nbsp;dnešním benchmarku budeme do značné míry
snažit vyhnout měření rychlosti knihovních funkcí, bude celý benchmark ve
skutečnosti provádět prakticky jen výpočty s&nbsp;výpisem výsledku výpočtů na
standardní výstup. Ten bude přesměrován do souboru, protože výsledkem výpočtů
budou bitmapy ve formátu <i>Portable Pixel Map</i> (viz [<a
href="https://www.root.cz/clanky/graficke-formaty-ve-znameni-unixu/#k06">1</a>]).
Samozřejmě, že i výpis hodnot na standardní výstup znamená nutnost volání
knihovních funkcí, ovšem oproti počtu numerických operací se bude jednat o
minimální čas, což je možné zjistit například profilerem, popř.&nbsp;úplným
zákazem výstupu (to však nechceme &ndash; musíme i optimalizující překladač
donutit, aby volání funkcí z&nbsp;kódu zcela neodstranil).</p>

<p>Celý benchmark spočívá ve výpočtu barev pixelů <a
href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xii/">Mandelbrotovy
množiny</a>, přičemž rozlišení výsledného rastrového obrázku i maximální počet
iterací bude možné zvolit z&nbsp;příkazového řádku. Budeme testy měřit kód
s&nbsp;vnořenými smyčkami, podmínkou ve smyčce, FP výpočty atd. a nikoli
například rychlost implementace přidávání prvků do seznamu či zjišťování, zda
řetězec odpovídá regulárnímu výrazu (k&nbsp;tomu se můžeme dostat později).
Následuje výpis zdrojového kódu benchmarku. Kód je přitom napsán tak, aby byl
kompatibilní s&nbsp;Pythonem 3.x, Jythonem, mypyc i s&nbsp;Numbou:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import palette_mandmap
from sys import argv, exit
&nbsp;
def calc_mandelbrot(width, height, maxiter, palette):
    print("P3")
    print("{w} {h}".format(w=width, h=height))
    print("255")
&nbsp;
    cy = -1.5
    for y in range(0, height):
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print("{r} {g} {b}".format(r=r, g=g, b=b))
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        width = 512
        height = 512
        maxiter = 255
    else:
        width = int(argv[1])
        height = int(argv[2])
        maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p>V&nbsp;benchmarku se používá i další modul nazvaný
<strong>palette_mandmap.py</strong>, který obsahuje barvovou paletu
(<i>palette, color map</i>). Paleta byla získána ze známého (a dnes již vlastně
historického) programu <i>Fractint</i> a obsahuje 256 trojic hodnot R, G, B.
Samotná paleta nemá prakticky žádný vliv na naměřené hodnoty, ale výsledné
obrázky jsou díky ní hezčí.</p>

<p><div class="rs-tip-major">Poznámka: prozatím nebudeme řešit, jak by bylo
možné výpočet urychlit například paralelním vykonáním výpočtů. Tomuto tématu se
budeme věnovat v&nbsp;samostatném článku.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nativní varianta benchmarku přepsaná do ANSI C</h2>

<p>Jen pro zajímavost (a taktéž kvůli benchmarkům) se podívejme na to, jak je
možné totožný algoritmus implementovat v&nbsp;ANSI C. Jedná se z&nbsp;velké
části o přímý přepis původního algoritmu bez dalších optimalizací, které céčko
umožňuje:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
#include "palette_mandmap.h"
&nbsp;
void <strong>calc_mandelbrot</strong>(unsigned int width, unsigned int height, unsigned int maxiter, unsigned char palette[][3])
{
    puts("P3");
    printf("%d %d\n", width, height);
    puts("255");
&nbsp;
    double cy = -1.5;
    int y;
    for (y=0; y&lt;height; y++) {
        double cx = -2.0;
        int x;
        for (x=0; x&lt;width; x++) {
            double zx = 0.0;
            double zy = 0.0;
            unsigned int i = 0;
            while (i &lt; maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            unsigned char *color = palette[i];
            unsigned char r = *color++;
            unsigned char g = *color++;
            unsigned char b = *color;
            printf("%d %d %d\n", r, g, b);
            cx += 3.0/width;
        }
        cy += 3.0/height;
    }
}
&nbsp;
int <strong>main</strong>(int argc, char **argv)
{
    if (argc &lt; 4) {
        puts("usage: ./mandelbrot width height maxiter");
        return 1;
    }
    int width = atoi(argv[1]);
    int height = atoi(argv[2]);
    int maxiter = atoi(argv[3]);
    calc_mandelbrot(width, height, maxiter, palette);
    return 0;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Varianty upravené pro Mypyc</h2>

<p><a href="#k11">Výše uvedený</a> pythonovský skript byl pro potřeby
<strong>mypyc</strong> upraven jen minimálně. Pouze došlo k&nbsp;tomu, že se
výpočet přímo spustí i v&nbsp;případě importu skriptu (nebo jeho varianty
přeložené do nativního kódu). Takto upravený zdrojový kód byl vypsán <a
href="#k05">v&nbsp;páté kapitole</a>. Druhá úprava spočívá v&nbsp;přidání
typových informací. Takto upravený zdrojový kód byl vypsán <a
href="#k08">v&nbsp;osmé kapitole</a> a opět ho tedy nebudeme znovu uvádět.
Žádné další úpravy specifické pro <strong>mypyc</strong> nebyly provedeny.</p>

<a href="https://www.root.cz/obrazek/1110096/"><img src="https://i.iinfo.cz/images/327/mypyc-4-prev.webp" class="image-1110096" width="317" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-4-prev.webp" data-prev-width="317" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-4.webp" data-large-width="484" data-large-height="412" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 4: Detail Mandelbrotovy množiny vypočtené skriptem přeloženým
nástrojem Mypyc do nativního kódu.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Varianty upravené pro Numbu</h2>

<p>Nepatrné úpravy zdrojového kódu benchmarku si vyžaduje i nástroj Numba (opět
platí &ndash; v&nbsp;IT nedostaneme prakticky nic zadarmo).</p>

<p>Prvním krokem při praktickém použití nástroje Numba je zápis anotace
<strong>@jit</strong> před funkcí, u které potřebujeme, aby ji překladač
optimalizoval v&nbsp;čase běhu. Nejdříve musíme do příslušného modulu anotaci
naimportovat, což je snadné:</p>

<pre>
from numba import jit
</pre>

<p>Následně tuto anotaci použijeme &ndash; žádné další kroky není zapotřebí
provést:</p>

<pre>
<strong>@jit</strong>
def calc_mandelbrot(width, height, maxiter, palette):
    ...
    ...
    ...
</pre>

<p>Jedním z&nbsp;potenciálně problematických prvků našeho benchmarku je použití
standardní pythonovské funkce <strong>print</strong>. Při JIT překladu totiž
může Numba použít dvě varianty této funkce &ndash; původní
&bdquo;univerzální&ldquo; pythonovskou variantu s&nbsp;téměř nepřebernými
možnostmi formátování a volitelnými parametry nebo zjednodušenou variantu
umožňující tisk číselných hodnot nebo řetězců (více info o nativních funkcích
Numby je uvedeno na stránce
<a
href="https://numba.pydata.org/numba-doc/dev/reference/pysupported.html">https://numba.pydata.org/numba-doc/dev/reference/pysupported.html</a>).
Obecně platí, že pokud použijeme zjednodušenou variantu funkce
<strong>print</strong>, bude JIT schopen přeložit celou JITovanou funkci do
strojového kódu.</p>

<p>Náš kód tedy na dvou místech nepatrně upravíme a využijeme tak velké
flexibility formátu PNM, v&nbsp;němž je možné použít jako oddělovač buď konec
řádku nebo libovolný bílý znak (jednou z&nbsp;nepříjemných vlastností nativní
varianty <strong>printu</strong> je to, že se vždy tiskne konec řádku).</p>

<p>Původní kód:</p>

<pre>
print("P3")
print("{w} {h}".format(w=width, h=height))
print("255")
</pre>

<p>Nový kód:</p>

<pre>
print("P3")
print(width)
print(height)
print("255")
</pre>

<p>Původní kód:</p>

<pre>
r = palette[i][0]
g = palette[i][1]
b = palette[i][2]
print("{r} {g} {b}".format(r=r, g=g, b=b))
</pre>

<p>Nový kód:</p>

<pre>
r = palette[i][0]
g = palette[i][1]
b = palette[i][2]
print(r)
print(g)
print(b)
</pre>

<p><div class="rs-tip-major">Poznámka: to, jaká varianta funkce
<strong>print</strong> se zvolí, nemusíme explicitně zadávat; JIT výběr provede
za nás.</div></p>

<p>Nová podoba benchmarku tedy bude následující:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import palette_mandmap
from sys import argv, exit
&nbsp;
from numba import jit
&nbsp;
&nbsp;
@jit
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
    print("P3")
    print(width)
    print(height)
    print("255")
&nbsp;
    cy = -1.5
    for y in range(0, height):
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print(r)
            print(g)
            print(b)
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        width = 512
        height = 512
        maxiter = 255
    else:
        width = int(argv[1])
        height = int(argv[2])
        maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p>JIT ve skutečnosti může pracovat ve dvou režimech, které se nazývají
<i>object mode</i> a <i>nopython mode</i>. V&nbsp;prvním režimu je kód
vytvářený JITem schopný zpracovat libovolné objekty (resp.&nbsp;reference na
ně) a v&nbsp;případě potřeby se v&nbsp;kódu volá C API Pythonu pro zpracování
těchto objektů. Pokud je tento režim použit, nebude se rychlost výsledného
programu příliš odlišovat od běhu interpretru. Z&nbsp;tohoto důvodu se většinou
budeme chtít tomuto režimu vyhnout &ndash; pokud to půjde. Naproti tomu druhý
režim (<i>nopython mode</i>) generuje kód, v&nbsp;němž se C API nevolá a
všechny proměnné a argumenty nesou hodnoty nativních typů (int, double atd.).
Tento režim si můžeme vynutit anotací <strong>@jit(nopython=True)</strong>,
ovšem s&nbsp;několika omezeními, které se týkají například výše zmíněné funkce
<strong>print</strong> (ostatně si zkuste sami vyzkoušet, co se stane, pokud
tuto anotaci přidáme do prvního příkladu).</p>

<p>Benchmark upravíme následujícím způsobem:</p>

<pre>
@jit(nopython=True)
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
</pre>

<p>Pro jistotu si uveďme celý kód, jak s&nbsp;novou anotací, tak i
s&nbsp;použitím zjednodušené nativní funkce <strong>print</strong>:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import palette_mandmap
from sys import argv, exit
&nbsp;
from numba import jit
&nbsp;
&nbsp;
@jit(nopython=True)
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
    print("P3")
    print(width)
    print(height)
    print("255")
&nbsp;
    cy = -1.5
    for y in range(0, height):
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print(r)
            print(g)
            print(b)
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        width = 512
        height = 512
        maxiter = 255
    else:
        width = int(argv[1])
        height = int(argv[2])
        maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výsledky benchmarků: rychlost výpočtů</h2>

<p>Nyní již máme hned několik variant zdrojových kódů benchmarků:</p>

<ol>
<li>Původní zdrojový kód pro klasický interpret Pythonu</li>
<li>Kód přepsaný do ANSI C</li>
<li>Kód určený pro AOT překlad nástrojem mypyc bez typových informací (liší se způsobem spuštění)</li>
<li>Kód určený pro AOT překlad nástrojem mypyc s&nbsp;přidanými typovými informacemi</li>
<li>Numba: kód, do něhož byla pouze přidána anotace <strong>@jit</strong></li>
<li>Numba: varianta s&nbsp;jednodušší (nativní) funkcí <strong>print</strong></li>
<li>Numba: varianta s&nbsp;jednodušší (nativní) funkcí <strong>print</strong> a anotací <strong>@jit(nopython=True)</strong></li>
</ol>

<p>Tyto zdrojové kódy použijeme pro spuštění celkem dvanácti benchmarků,
jejichž označení a význam je zapsán v&nbsp;tabulce:</p>

<table>
<tr><th>Označení</th><th>Stručný popis benchmarku</th></tr>
<tr><td>native</td><td>benchmark přepsaný do ANSI C, překlad bez optimalizací</td></tr>
<tr><td>native optim</td><td>benchmark přepsaný do ANSI C, překlad s&nbsp;optimalizacemi</td></tr>
<tr><td>python 3.8</td><td>benchmark spuštěný standardním CPythonem verze 3.8</td></tr>
<tr><td>python 3.9</td><td>benchmark spuštěný standardním CPythonem verze 3.9</td></tr>
<tr><td>python 3.10</td><td>benchmark spuštěný standardním CPythonem verze 3.10</td></tr>
<tr><td>python 3.11</td><td>benchmark spuštěný standardním CPythonem verze 3.11</td></tr>
<tr><td>python 3.12</td><td>benchmark spuštěný standardním CPythonem verze 3.12</td></tr>
<tr><td>mypyc no type hints</td><td>kód určený pro AOT překlad nástrojem mypyc bez typových informací</td></tr>
<tr><td>mypyc with type hints</td><td>kód určený pro AOT překlad nástrojem mypyc s&nbsp;přidanými typovými informacemi</td></tr>
<tr><td>numba 2</td><td>Numba: kód, do něhož byla pouze přidána anotace <strong>@jit</strong></td></tr>
<tr><td>numba 3</td><td>Numba: varianta s&nbsp;jednodušší (nativní) funkcí <strong>print</strong></td></tr>
<tr><td>numba 4</td><td>Numba: varianta s&nbsp;jednodušší (nativní) funkcí <strong>print</strong> a anotací <strong>@jit(nopython=True)</strong></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: optimalizovaný nativní kód jako jediný
neprodukuje totožné výsledky! Je tomu tak kvůli použití
<strong>-ffast-math</strong>, takže FP operace přesně neodpovídají IEEE 754.
Všechny ostatní kódy produkují výsledky, které jsou naprosto totožné
(z&nbsp;pohledu výsledné bitmapy s&nbsp;vypočteným obrázkem).</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: dnes se soustředíme jen na
test rychlosti běhu programu v&nbsp;jediném procesu a jediném vláknu.
Nevyužijeme zde tedy možností nabízených nástrojem Numba
v&nbsp;(polo)automatické paralelizaci běhu kódu.</div></p>

<p>První graf ukazuje časy běhu všech benchmarků. Zvolil jsem liniový graf,
který naznačuje, jak dobré či špatné jsou jednotlivé implementace nejenom pro
dlouhé výpočty, ale i při započítání času inicializace procesu. Na horizontální
osu jsou vyneseny velikosti bitmap (x&times;y pixelů), na vertikální osu pak
doby běhu v&nbsp;sekundách:</p>

<a href="https://www.root.cz/obrazek/1110097/"><img src="https://i.iinfo.cz/images/327/mypyc-5-prev.webp" class="image-1110097" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-5-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-5-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 5: Časy běhu všech benchmarků v&nbsp;závislosti na požadovaném
rozlišení výsledné bitmapy.</i></p>

<p><div class="rs-tip-major">Poznámka: z&nbsp;grafu plyne minimálně jedno
poučení &ndash; nepoužívejte nástroj Numba bez dalších úprav zdrojových kódů!
Zejména ne tehdy, pokud Numba vypisuje varování, že používá &bdquo;objektový
režim&ldquo;.</div></p>

<p>Na druhém grafu jsou zobrazeny časy běhu benchmarků pro malé bitmapy. Právě
zde nehrají výpočty prakticky žádnou významnou roli, mnohem více se zde projeví
inicializace procesu. To v&nbsp;případě nástroje Numba znamená JIT překlad. Jak
je patrné, ten trvá přibližně 4 sekundy:</p>

<a href="https://www.root.cz/obrazek/1110098/"><img src="https://i.iinfo.cz/images/327/mypyc-6-prev.webp" class="image-1110098" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-6-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-6-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 6: Časy běhu benchmarků pro malé bitmapy. Zde se nejvíce projeví
čas inicializace procesu.</i></p>

<p><div class="rs-tip-major">Poznámka: další poučení &ndash; pro velmi krátké
skripty není použití nástroje Numba ideální, a to kvůli času, který se tráví
JITováním kódu.</div></p>

<p>Pro větší velikosti bitmap se již kromě času JITování projeví i časy
výpočtů. Stále se však pohybujeme v&nbsp;celkovém času dosahujícím jednotky
sekund, takže JITování zde hraje spíše negativní roli:</p>

<a href="https://www.root.cz/obrazek/1110099/"><img src="https://i.iinfo.cz/images/327/mypyc-7-prev.webp" class="image-1110099" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-7-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-7-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 7: Časy běhu benchmarků pro středně velké bitmapy.</i></p>

<p>Pro ještě větší bitmapy však dostaneme zcela odlišné výsledky, protože
JITovaný kód zde překonává jak klasické interpretry (což se dalo čekat), tak i
Mypy!:</p>

<a href="https://www.root.cz/obrazek/1110100/"><img src="https://i.iinfo.cz/images/327/mypyc-8-prev.webp" class="image-1110100" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-8-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-8-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 8: Časy běhu benchmarků pro velké bitmapy.</i></p>

<p><div class="rs-tip-major">Poznámka: poučení &ndash; JIT realizovaný
v&nbsp;nástroji Numba je ve skutečnosti účinný, ale jen pro déletrvající
výpočty (desítky sekund v&nbsp;původním interpretru). Další poučení &ndash;
výsledky mypyc nejsou nijak oslňující, a to i v&nbsp;porovnání
s&nbsp;klasickými interpretry! (což mě osobně dosti překvapilo)</div></p>

<p>Ještě se podívejme na pohled na &bdquo;sweet spot&ldquo;, kde rychlost
JITovaného kódu překročí rychlost kódu interpretovaného:</p>

<a href="https://www.root.cz/obrazek/1110101/"><img src="https://i.iinfo.cz/images/327/mypyc-9-prev.webp" class="image-1110101" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-9-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-9-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 9: Oblast, v&nbsp;níž se JITovaný kód stává rychlejším, než kód
interpretovaný.</i></p>

<p>V&nbsp;úvodní části článku jsme se taktéž zmínili o tom, že Python 3.11 (a
3.12) je obecně rychlejší, než předchozí interpretry Pythonu &ndash; tedy
alespoň podle tvrzení tvůrců. Podívejme se, zda je tomu skutečně tak:</p>

<a href="https://www.root.cz/obrazek/1110102/"><img src="https://i.iinfo.cz/images/327/mypyc-10-prev.webp" class="image-1110102" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-10-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-10-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 10: Porovnání rychlostí interpretrů Pythonu (CPython 3.x).</i></p>

<p><div class="rs-tip-major">Poznámka: zde je poučení jednoznačné &ndash;
Python 3.11 a Python 3.12 jsou skutečně značně rychlejší, než předchozí verze.
Nejedná se sice o řádové vylepšení, ale o cca 50% nárůst výpočetního výkonu
v&nbsp;tomto mikrobenchmarku zaměřeného na FP operace. Zde se vyplatí přejít co
nejrychleji :-)</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Výsledky benchmarků: spotřeba operační paměti</h2>

<p>V&nbsp;dnešním článku jsme se sice primárně zaměřili na měření rychlosti FP
výpočtů (v&nbsp;jediném vláknu), ale možná stojí zato se podívat i na spotřebu
operační paměti pro jednotlivé skupiny benchmarků. Zde je situace snadná,
protože všechny benchmarky lze zhruba rozdělit do dvou kategorií &ndash;
nativní kód, kód běžící v&nbsp;libovolné verzi CPythonu a nativní kód přeložený
pomocí <i>mypyc</i> na straně jedné a benchmarky JITované nástrojem Numba na
straně druhé:</p>

<a href="https://www.root.cz/obrazek/1110103/"><img src="https://i.iinfo.cz/images/327/mypyc-11-prev.webp" class="image-1110103" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-11-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-11-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 11: Spotřeba operační paměti.</i></p>

<p><div class="rs-tip-major">Poznámka: Numba má až překvapivě vysoké nároky na
spotřebu operační paměti. Ta neroste s&nbsp;velikostí úlohy (ostatně nic
nealokujeme), ale je závislá na velikosti JIT překladače i na velikosti
JITovaného kódu, který je díky rozbalení smyček poměrně rozsáhlý.</div></p>

<p>Víme již, že Python 3.11 a Python 3.12 je rychlejší, než jeho předchůdci. Na
druhou stranu mají tyto dvě nejnovější verze nepatrně větší spotřebu operační
paměti. Nejedná se ovšem o nic podstatného, jak je to ostatně patrné
z&nbsp;dalšího grafu (ovšem pro porovnání Numbou porovnejte s&nbsp;grafem
předchozím):</p>

<a href="https://www.root.cz/obrazek/1110104/"><img src="https://i.iinfo.cz/images/327/mypyc-12-prev.webp" class="image-1110104" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/327/mypyc-12-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/327/mypyc-12-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 12: Spotřeba operační paměti, zaměřeno na klasické interpretry
Pythonu.</i></p>

<p><div class="rs-tip-major">Poznámka na závěr: tyto mikrobenchmarky ovšem
neukazují další vlastnosti nástrojů mypyc a především pak Numby &ndash; možnost
paralelizace kódu. Jedná se o &bdquo;detail&ldquo; s&nbsp;velkým praktickým
dopadem, kterému se budeme věnovat příště.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Zdrojové kódy benchmarků použitých v&nbsp;dnešním článku</h2>

<p>Pro změření výkonnosti různých variant spuštění projektů naprogramovaných
v&nbsp;Pythonu bylo použito celkem sedm verzí zdrojových kódů benchmarku. První
verze je určena pro klasický CPython (my jsme využili verze 3.8 až 3.12), další
tři verze jsou určeny pro použití společně s&nbsp;JIT překladačem Numba.
Následují dvě verze určené pro AOT překladač Mypy a konečně poslední verze byla
přepsána do ANSI C, abychom mohli porovnat, jak může být sémanticky totožný kód
rychlejší při použití odlišného ekosystému:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>mandelbrot-v1</td><td>benchmark, v&nbsp;němž se nepoužívají anotace projektu Numba (čistý CPython)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v1/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v1/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>mandelbrot-v2</td><td>použití anotace <strong>@jit</strong> (Numba) ve funkci, v&nbsp;níž se provádí mnoho výpočtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v2/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v2/</a></td></tr>
<tr><td>3</td><td>mandelbrot-v3</td><td>volání zjednodušených variant funkce <strong>print</strong> (Numba)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v3/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v3/</a></td></tr>
<tr><td>4</td><td>mandelbrot-v4</td><td>použití anotace <strong>@jit</strong> s&nbsp;parametrem <strong>nopython</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v4/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v4/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>mandelbrot-v5</td><td>varianta benchmarku určená pro překlad s&nbsp;využitím <strong>mypyc</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot_5.py</a></td></tr>
<tr><td>6</td><td>mandelbrot-v6</td><td>přidání typových informací využitelných AOT překladačem <strong>mypyc</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>mandelbrot.c</td><td>varianta benchmarku naprogramovaná v&nbsp;ANSI C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot.c">https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot.c</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady pro nástroj Numba</h2>

<p>Všechny demonstrační příklady ukazující vlastnosti nástroje Numba naleznete
v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>sum1.py</td><td>funkce pro výpočet součtu dvou prvků, které je volána s&nbsp;argumenty typu <strong>int64</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum1.py</a></td></tr>
<tr><td> 2</td><td>sum2.py</td><td>funkce pro výpočet součtu dvou prvků, které je volána s&nbsp;argumenty typu <strong>double/float64</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum2.py</a></td></tr>
<tr><td> 3</td><td>sum3.py</td><td>funkce pro výpočet součtu dvou prvků volaná s&nbsp;argumenty různých typů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum3.py</a></td></tr>
<tr><td> 4</td><td>sum4.py</td><td>součet dvou polí z&nbsp;balíčku <i>Numpy</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum4.py</a></td></tr>
<tr><td> 5</td><td>sum5.py</td><td>porovnání různých variant součtu dvou polí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum5.py</a></td></tr>
<tr><td> 6</td><td>sum6.py</td><td>dtto, ale pro větší počet volání funkce pro provedení součtu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>sum_array.py</td><td>explicitní zápis součtu všech prvků pole</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_array.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_array.py</a></td></tr>
<tr><td> 8</td><td>range_loop.py</td><td>využití funkce <strong>range</strong> ve smyčce <strong>for</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/range_loop.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/range_loop.py</a></td></tr>
<tr><td> 9</td><td>prange_loop.py</td><td>paralelní varianta funkce <strong>range</strong> ve smyčce <strong>for</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/prange_loop.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/prange_loop.py</a></td></tr>
<tr><td>10</td><td>sum_sqrts1.py</td><td>výpočet prováděný ve smyčce s&nbsp;akumulací výsledku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts1.py</a></td></tr>
<tr><td>11</td><td>sum_sqrts2.py</td><td>dtto, ovšem provedení v&nbsp;režimu <strong>nopython</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts2.py</a></td></tr>
<tr><td>12</td><td>sum_sqrts3.py</td><td>zapnutí režimu <i>fast array</i> při výpočtech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts3.py</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady pro nástroj Mypy</h2>

<p>Všechny Pythonovské skripty, které jsme si popsali v&nbsp;článcích o Mypy,
naleznete opět na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je pochopitelně
nutné mít nainstalován balíček <i>mypy</i> společně s&nbsp;Pythonem alespoň
3.7):</p>

<table>
<tr><th>#<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td> 1</td><td>adder1.py</td><td>funkce <strong>add</strong> bez typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder1.py</a></td></tr>
<tr><td> 2</td><td>adder2.py</td><td>funkce <strong>add</strong> s&nbsp;typovými anotacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder2.py</a></td></tr>
<tr><td> 3</td><td>adder3.py</td><td>funkce <strong>add</strong> volaná s&nbsp;hodnotami <strong>True</strong> a <strong>False</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder3.py</a></td></tr>
<tr><td> 4</td><td>adder4.py</td><td>funkce <strong>add</strong> akceptující hodnoty typu <strong>bool</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder4.py</a></td></tr>
<tr><td> 5</td><td>adder5.py</td><td>zobrazení typových informací pro funkci bez typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder5.py</a></td></tr>
<tr><td> 6</td><td>adder6.py</td><td>zobrazení typových informací pro funkci s&nbsp;typovými anotacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>exec_problem_1.py</td><td>funkce <strong>add</strong> s&nbsp;typovými anotacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_1.py</a></td></tr>
<tr><td> 6</td><td>exec_problem_2.py</td><td>korektní detekce volání funkce <strong>add</strong> s&nbsp;nekompatibilními hodnotami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_2.py</a></td></tr>
<tr><td> 7</td><td>exec_problem_3.py</td><td>příkaz použitý v&nbsp;<strong>exec</strong> není statickým analyzátorem zachycen</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>list_type1.py</td><td>typ seznam, s&nbsp;inicializací (bez prvků), pro Python 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type1.py</a></td></tr>
<tr><td> 9</td><td>list_type2.py</td><td>typ seznam, s&nbsp;inicializací (bez prvků), pro starší verze Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type2.py</a></td></tr>
<tr><td>10</td><td>list_type3.py</td><td>typ seznam, s&nbsp;inicializací (s&nbsp;prvky), pro starší verze Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type3.py</a></td></tr>
<tr><td>11</td><td>list_type4.py</td><td>typ seznam, kontrola použití prvků s&nbsp;nekorektními typy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type4.py</a></td></tr>
<tr><td>12</td><td>list_type5.py</td><td>typ seznam, kontrola použití prvků s&nbsp;korektními typy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type5.py</a></td></tr>
<tr><td>13</td><td>list_type6.py</td><td>typ seznam, kontrola použití prvků s&nbsp;korektními typy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>tuple_type1.py</td><td>typ n-tice (nekorektní specifikace typu)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type1.py</a></td></tr>
<tr><td>15</td><td>tuple_type2.py</td><td>typ n-tice (korektní specifikace typu)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type2.py</a></td></tr>
<tr><td>16</td><td>tuple_type3.py</td><td>typ n-tice, v&nbsp;níž má každý prvek odlišný typ</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type3.py</a></td></tr>
<tr><td>17</td><td>tuple_type4.py</td><td>typ n-tice, v&nbsp;níž má každý prvek odlišný typ</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>json_check.py</td><td>delší kód v&nbsp;Pythonu bez typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/json_check.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/json_check.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>Variance1.java</td><td>variance v&nbsp;Javě &ndash; korektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.java">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.java</a></td></tr>
<tr><td>20</td><td>Variance2.java</td><td>variance v&nbsp;Javě &ndash; nekorektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.java">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>Variance1.py</td><td>variance v&nbsp;Pythonu &ndash; korektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.py</a></td></tr>
<tr><td>22</td><td>Variance2.py</td><td>variance v&nbsp;Pythonu &ndash; nekorektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.py</a></td></tr>
<tr><td>23</td><td>Variance3.py</td><td>variance v&nbsp;Pythonu &ndash; nekorektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance3.py</a></td></tr>
<tr><td>24</td><td>Variance4.py</td><td>použití typu <strong>Sequence</strong> namísto <strong>List</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>view_pyc.py</td><td>jednoduchá prohlížečka souborů .pyc</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/view_pyc.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/view_pyc.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>callable1.py</td><td>funkce s&nbsp;typovými informacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable1.py</a></td></tr>
<tr><td>27</td><td>callable2.py</td><td>variance funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable2.py</a></td></tr>
<tr><td>28</td><td>callable3.py</td><td>variance funkcí (nekorektní příklad)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable3.py</a></td></tr>
<tr><td>29</td><td>callable4.py</td><td>korektní řešení problému z&nbsp;kódu <strong>callable3.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/callable4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>dict_type1.py</td><td>slovník bez specifikace informací o typech (homogenní struktura)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type1.py</a></td></tr>
<tr><td>31</td><td>dict_type2.py</td><td>slovník bez specifikace informací o typech (heterogenní struktura)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type2.py</a></td></tr>
<tr><td>32</td><td>dict_type3.py</td><td>typově silný slovník (heterogenní struktura)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type3.py</a></td></tr>
<tr><td>33</td><td>dict_type4.py</td><td>typově silný slovník (homogenní struktura)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type4.py</a></td></tr>
<tr><td>34</td><td>dict_type5.py</td><td>použití typu <strong>Union</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type5.py</a></td></tr>
<tr><td>35</td><td>dict_type6.py</td><td>použití typu <strong>Union</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type6.py</a></td></tr>
<tr><td>36</td><td>dict_type7.py</td><td>použití typu <strong>Optional</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type7.py</a></td></tr>
<tr><td>37</td><td>dict_type8.py</td><td>použití typu <strong>Optional</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_type8.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>38</td><td>sprites1.py</td><td>původní kód před refaktoringem a bez typových informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites1.py</a></td></tr>
<tr><td>39</td><td>sprites2.py</td><td>refaktoring kódu <strong>sprites1.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites2.py</a></td></tr>
<tr><td>40</td><td>sprites3.py</td><td>přidání typových informací do kódu <strong>sprites2.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites3.py</a></td></tr>
<tr><td>41</td><td>sprites4.py</td><td>oprava chyb nalezených v&nbsp;kódu <strong>sprites3.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites4.py</a></td></tr>
<tr><td>42</td><td>sprites5.py</td><td>doplnění generických typů pro volbu <strong>--strict</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites5.py</a></td></tr>
<tr><td>43</td><td>sprites6.py</td><td>definice a použití nového datového typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>44</td><td>reveal_type1.py</td><td>selektivní zjištění typu proměnné či třídy nástrojem Mypy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type1.py</a></td></tr>
<tr><td>45</td><td>reveal_type2.py</td><td>selektivní zjištění typu funkce nástrojem Mypy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type2.py</a></td></tr>
<tr><td>46</td><td>reveal_type3.py</td><td>typová inference</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type3.py</a></td></tr>
<tr><td>47</td><td>reveal_type4.py</td><td>typová inference</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type4.py</a></td></tr>
<tr><td>48</td><td>reveal_type5.py</td><td>explicitní definice typu versus typová inference</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_type5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>reveal_locals1.py</td><td>zjištění typů všech lokálních proměnných</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals1.py</a></td></tr>
<tr><td>50</td><td>reveal_locals2.py</td><td>zjištění typů všech lokálních proměnných</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals2.py</a></td></tr>
<tr><td>51</td><td>reveal_locals3.py</td><td>zjištění typů všech lokálních proměnných</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/reveal_locals3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>list_sequence.py</td><td>měnitelné seznamy vs. neměnitelné sekvence</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_sequence.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_sequence.py</a></td></tr>
<tr><td>53</td><td>dict_mapping.py</td><td>měnitelné slovníky vs. neměnitelné mapování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_mapping.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/dict_mapping.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python 3.12: More Faster and More Efficient Python<br />
<a href="https://medium.com/@HeCanThink/python-3-12-more-faster-and-more-efficient-python-b636f00b047">https://medium.com/@HeCanThink/python-3-12-more-faster-and-more-efficient-python-b636f00b047</a>
</a>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/</a>
</a>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (2.část)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/</a>
</a>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/</a>
</a>

<li>mypy homepage<br />
<a href="https://www.mypy-lang.org/">https://www.mypy-lang.org/</a>
</li>

<li>mypy documentation<br />
<a href="https://mypy.readthedocs.io/en/stable/">https://mypy.readthedocs.io/en/stable/</a>
</li>

<li>Mypy na PyPi Optional static typing for Python<br />
<a href="https://pypi.org/project/mypy/">https://pypi.org/project/mypy/</a>
</li>

<li>5 Reasons Why You Should Use Type Hints In Python<br />
<a href="https://www.youtube.com/watch?v=dgBCEB2jVU0">https://www.youtube.com/watch?v=dgBCEB2jVU0</a>
</li>

<li>Python Typing &ndash; Type Hints &amp; Annotations<br />
<a href="https://www.youtube.com/watch?v=QORvB-_mbZ0">https://www.youtube.com/watch?v=QORvB-_mbZ0</a>
</li>

<li>What Problems Can TypeScript Solve?<br />
<a href="https://www.typescriptlang.org/why-create-typescript">https://www.typescriptlang.org/why-create-typescript</a>
</li>

<li>How to find code that is missing type annotations?<br />
<a href="https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations">https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations</a>
</li>

<li>Do type annotations in Python enforce static type checking?<br />
<a href="https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking">https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking</a>
</li>

<li>Understanding type annotation in Python<br />
<a href="https://blog.logrocket.com/understanding-type-annotation-python/">https://blog.logrocket.com/understanding-type-annotation-python/</a>
</li>

<li>Static type checking with Mypy — Perfect Python<br />
<a href="https://www.youtube.com/watch?v=9gNnhNxra3E">https://www.youtube.com/watch?v=9gNnhNxra3E</a>
</li>

<li>Static Type Checker for Python<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Differences Between Pyright and Mypy<br />
<a href="https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md">https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md</a>
</li>

<li>4 Python type checkers to keep your code clean<br />
<a href="https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html">https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html</a>
</li>

<li>Pyre: A performant type-checker for Python 3<br />
<a href="https://pyre-check.org/">https://pyre-check.org/</a>
</li>

<li>"Typing the Untyped: Soundness in Gradual Type Systems" by Ben Weissmann<br />
<a href="https://www.youtube.com/watch?v=uJHD2xyv7xo">https://www.youtube.com/watch?v=uJHD2xyv7xo</a>
</li>

<li>Covariance and contravariance (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a>
</li>

<li>Functional Programming: Type Systems<br />
<a href="https://www.youtube.com/watch?v=hy1wjkcIBCU">https://www.youtube.com/watch?v=hy1wjkcIBCU</a>
</li>

<li>A Type System From Scratch – Robert Widmann<br />
<a href="https://www.youtube.com/watch?v=IbjoA5xVUq0">https://www.youtube.com/watch?v=IbjoA5xVUq0</a>
</li>

<li>"Type Systems - The Good, Bad and Ugly" by Paul Snively and Amanda Laucher<br />
<a href="https://www.youtube.com/watch?v=SWTWkYbcWU0">https://www.youtube.com/watch?v=SWTWkYbcWU0</a>
</li>

<li>Type Systems: Covariance, Contravariance, Bivariance, and Invariance explained<br />
<a href="https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8">https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8</a>
</li>

<li>Statická vs. dynamická typová kontrola<br />
<a href="https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/">https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/</a>
</li>

<li>Typový systém<br />
<a href="https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m">https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m</a>
</li>

<li>Comparison of programming languages by type system<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system</a>
</li>

<li>Flow<br />
<a href="https://flow.org/">https://flow.org/</a>
</li>

<li>TypeScript<br />
<a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a>
</li>

<li>Sorbet<br />
<a href="https://sorbet.org/">https://sorbet.org/</a>
</li>

<li>Pyright<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Mypy: Type hints cheat sheet<br />
<a href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html</a>
</li>

<li>PEP 484 – Type Hints<br />
<a href="https://peps.python.org/pep-0484/">https://peps.python.org/pep-0484/</a>
</li>

<li>Numba<br />
<a href="http://numba.pydata.org/">http://numba.pydata.org/</a>
</li>

<li>numba 0.57.0<br />
<a href="https://pypi.org/project/numba/">https://pypi.org/project/numba/</a>
</li>

<li>Pushing Python toward C speeds with SIMD <br />
<a href="https://laurenar.net/posts/python-simd/">https://laurenar.net/posts/python-simd/</a>
</li>

<li>Retrieve generated LLVM from Numba<br />
<a href="https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba">https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba</a>
</li>

<li>Numba documentation<br />
<a href="http://numba.pydata.org/numba-doc/latest/index.html">http://numba.pydata.org/numba-doc/latest/index.html</a>
</li>

<li>Numba na GitHubu<br />
<a href="https://github.com/numba/numba">https://github.com/numba/numba</a>
</li>

<li>First Steps with numba<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html</a>
</li>

<li>Numba and types<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html</a>
</li>

<li>Just-in-time compilation<br />
<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">https://en.wikipedia.org/wiki/Just-in-time_compilation</a>
</li>

<li>Cython (home page)<br />
<a href="http://cython.org/">http://cython.org/</a>
</li>

<li>Cython (wiki)<br />
<a href="https://github.com/cython/cython/wiki">https://github.com/cython/cython/wiki</a>
</li>

<li>Cython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cython">https://en.wikipedia.org/wiki/Cython</a>
</li>

<li>Cython (GitHub)<br />
<a href="https://github.com/cython/cython">https://github.com/cython/cython</a>
</li>

<li>Python Implementations: Compilers<br />
<a href="https://wiki.python.org/moin/PythonImplementations#Compilers">https://wiki.python.org/moin/PythonImplementations#Compilers</a>
</li>

<li>EmbeddingCython<br />
<a href="https://github.com/cython/cython/wiki/EmbeddingCython">https://github.com/cython/cython/wiki/EmbeddingCython</a>
</li>

<li>The Basics of Cython<br />
<a href="http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html">http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html</a>
</li>

<li>Overcoming Python's GIL with Cython<br />
<a href="https://lbolla.info/python-threads-cython-gil">https://lbolla.info/python-threads-cython-gil</a>
</li>

<li>GlobalInterpreterLock<br />
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>
</li>

<li>The Magic of RPython<br />
<a href="https://refi64.com/posts/the-magic-of-rpython.html">https://refi64.com/posts/the-magic-of-rpython.html</a>
</li>

<li>RPython: Frequently Asked Questions<br />
<a href="http://rpython.readthedocs.io/en/latest/faq.html">http://rpython.readthedocs.io/en/latest/faq.html</a>
</li>

<li>RPython’s documentation<br />
<a href="http://rpython.readthedocs.io/en/latest/index.html">http://rpython.readthedocs.io/en/latest/index.html</a>
</li>

<li>RPython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/PyPy#RPython">https://en.wikipedia.org/wiki/PyPy#RPython</a>
</li>

<li>Getting Started with RPython<br />
<a href="http://rpython.readthedocs.io/en/latest/getting-started.html">http://rpython.readthedocs.io/en/latest/getting-started.html</a>
</li>

<li>PyPy (home page)<br />
<a href="https://pypy.org/">https://pypy.org/</a>
</li>

<li>PyPy (dokumentace)<br />
<a href="http://doc.pypy.org/en/latest/">http://doc.pypy.org/en/latest/</a>
</li>

<li>Localized Type Inference of Atomic Types in Python (2005)<br />
<a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231</a>
</li>

<li>Tutorial: Writing an Interpreter with PyPy, Part 1<br />
<a href="https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html">https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html</a>
</li>

<li>List of numerical analysis software<br />
<a href="https://en.wikipedia.org/wiki/List_of_numerical_analysis_software">https://en.wikipedia.org/wiki/List_of_numerical_analysis_software</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>The future can be written in RPython now (článek z&nbsp;roku 2010)<br />
<a href="http://blog.christianperone.com/2010/05/the-future-can-be-written-in-rpython-now/">http://blog.christianperone.com/2010/05/the-future-can-be-written-in-rpython-now/</a>
</li>

<li>PyPy is the Future of Python (článek z&nbsp;roku 2010)<br />
<a href="https://alexgaynor.net/2010/may/15/pypy-future-python/">https://alexgaynor.net/2010/may/15/pypy-future-python/</a>
</li>

<li>Portal:Python programming<br />
<a href="https://en.wikipedia.org/wiki/Portal:Python_programming">https://en.wikipedia.org/wiki/Portal:Python_programming</a>
</li>

<li>RPython Frontend and C Wrapper Generator<br />
<a href="http://www.codeforge.com/article/383293">http://www.codeforge.com/article/383293</a>
</li>

<li>PyPy’s Approach to Virtual Machine Construction<br />
<a href="https://bitbucket.org/pypy/extradoc/raw/tip/talk/dls2006/pypy-vm-construction.pdf">https://bitbucket.org/pypy/extradoc/raw/tip/talk/dls2006/pypy-vm-construction.pdf</a>
</li>

<li>Tutorial: Writing an Interpreter with PyPy, Part 1<br />
<a href="https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html">https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html</a>
</li>

<li>A simple interpreter from scratch in Python (part 1)<br />
<a href="http://www.jayconrod.com/posts/37/a-simple-interpreter-from-scratch-in-python-part-1">http://www.jayconrod.com/posts/37/a-simple-interpreter-from-scratch-in-python-part-1</a>
</li>

<li>Brainfuck Interpreter in Python<br />
<a href="https://helloacm.com/brainfuck-interpreter-in-python/">https://helloacm.com/brainfuck-interpreter-in-python/</a>
</li>

<li>Interpretry, překladače, JIT překladače a transpřekladače programovacího jazyka Lua<br />
<a href="https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/">https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>Nuitka<br />
<a href="https://github.com/Nuitka/Nuitka">https://github.com/Nuitka/Nuitka</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

