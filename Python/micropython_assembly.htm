<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Zápis funkcí obsahujících instrukce ze sady Thumb-2 v MicroPythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Zápis funkcí obsahujících instrukce ze sady Thumb-2 v MicroPythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Tento týden se již podruhé setkáme s MicroPythonem. Zatímco v předchozím článku jsme si ukázali, jak lze MicroPython použít pro webový front end, dnes se zaměříme opačnou stranu spektra - na podporu pro zápis funkcí obsahujících instrukce pro instrukční sadu Thumb-2.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Zápis funkcí obsahujících instrukce ze sady Thumb-2 v&nbsp;MicroPythonu</a></p>
<p><a href="#k02">2. Mikroprocesory a mikrořadiče ARM</a></p>
<p><a href="#k03">3. Mikrořadiče Cortex-M</a></p>
<p><a href="#k04">4. Podrobnější pohled na 32bitová jádra Cortex-M</a></p>
<p><a href="#k05">5. Mikrořadiče Cortex-M0 a Cortex-M0+</a></p>
<p><a href="#k06">6. Instrukční sada mikrořadičů Cortex-M0+</a></p>
<p><a href="#k07">7. Od instrukční sady A32 k&nbsp;instrukční sadě Thumb-2</a></p>
<p><a href="#k08">8. Malá odbočka: proč vznikla instrukční sada Thumb-2?</a></p>
<p><a href="#k09">*** 9. Instrukce rozpoznávané mikrořadiči Cortex-M0, M0+, M1 a M23</a></p>
<p><a href="#k10">10. Aritmetické a logické instrukce</a></p>
<p><a href="#k11">11. Skoky a vyvolání SW přerušení</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. Podpora instrukcí Thumb-2 v&nbsp;MicroPythonu</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Zápis funkcí obsahujících instrukce ze sady Thumb-2 v&nbsp;MicroPythonu</h2>

<p>Jak již bylo napsáno v&nbsp;perexu článku, setkáme se na stránkách Roota
tento týden již podruhé s&nbsp;projektem <i>MicroPython</i>. Zatímco
v&nbsp;předchozím článku jsme si ukázali, jakým způsobem je možné MicroPython
použít pro webový front end (jako náhradu za JavaScript), zaměříme se
v&nbsp;dnešním článku na zcela opačnou stranu spektra programovacích technik a
úrovní abstrakce. Řekneme si totiž, jakým způsobem MicroPython podporuje zápis
funkcí obsahujících symbolicky zapsané strojové instrukce z&nbsp;instrukční
sady <i>Thumb</i> a <i>Thumb-2</i>. Díky této technologii je možné zkombinovat
vysokoúrovňový kód v&nbsp;Pythonu se strojovým kódem, a to bez nutnosti použití
<i>assembleru</i> a <i>linkeru</i> (a vůbec znalosti předávání parametrů
subrutinám atd.). A vzhledem k&nbsp;tomu, že MicroPython lze provozovat
například na jednodeskových mikropočítačích s&nbsp;oblíbeným čipem RP2040
(Pico, Pico W, Nano RP2040 Connect atd.), se jedná podle mého názoru o velmi
užitečnou pomůcku a taktéž o první krok pro seznámení se s&nbsp;instrukčními
sadami ARMovských čipů.</p>

<p><img src="https://i.iinfo.cz/images/586/micropython-logo.webp" class="image-1114645" width="400" height="128" alt="&#160;" title="Autor: MicroPython project, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></p>
<p><i>Obrázek 1: Logo projektu MicroPython.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Mikroprocesory a mikrořadiče ARM</h2>

<p>Instrukční sady <i>Thumb</i> a <i>Thumb-2</i> jsou spojeny
s&nbsp;mikroprocesory a především s&nbsp;mikrořadiči ARM. Tyto čipy za sebou
mají velmi dlouhou dobu vývoje, takže není divu, že postupně vznikaly různé
generace těchto čipů, které se odlišovaly jak svým výpočetním výkonem, tak i
různými změnami v&nbsp;instrukční sadě, uspořádáním cache, počtem řezů
(pipeline), použitými submoduly (hardwarová násobička, dělička, jednotka pro
SIMD operace, FP koprocesor) atd. Čipy ARM je možné rozlišit podle
architektury, přičemž základní dělení je naznačeno v&nbsp;následující
tabulce:</p> 

<table>
<tr><th>#</th><th>Architektura</th><th>Adresová/datová sběrnice</th><th>Jádro</th><th>Poznámka/profil (u Cortex)</th></tr>
<tr><td>1</td><td>ARMv1</td><td>26/32 bitů</td><td>ARM1</td><td>první implementace, de facto technologické demo</td></tr>
<tr><td>2</td><td>ARMv2</td><td>26/32 bitů</td><td>ARM2, ARM250, ARM3</td><td>přidána HW násobička a MMU</td></tr>
<tr><td>3</td><td>ARMv3</td><td>26/32 bitů</td><td>ARM6, ARM7</td><td></td></tr>
<tr><td>4</td><td>ARMv4</td><td>26/32 bitů</td><td>ARM8</td><td>patří sem mj.&nbsp;i kdysi oblíbená řada čipů StrongARM</td></tr>
<tr><td>5</td><td>ARMv5</td><td>32 bitů</td><td>ARM7EJ, ARM9E, ARM10E</td><td>lze najít ve starších zařízeních</td></tr>
<tr><td>6</td><td>ARMv6</td><td>32 bitů</td><td>ARM11</td><td>dodnes používaná jádra</td></tr>
<tr><td>7</td><td>ARMv6-M</td><td>32 bitů</td><td>Cortex-M0, Cortex-M0+, Cortex-M1</td><td>mikrořadiče (M v&nbsp;názvu)</td></tr>
<tr><td>8</td><td>ARMv7-M</td><td>32 bitů</td><td>Cortex-M3</td><td>mikrořadiče (M v&nbsp;názvu)</td></tr>
<tr><td>9</td><td>ARMv7E-M</td><td>32 bitů</td><td>Cortex-M4, Cortex-M7</td><td>mikrořadiče (M v&nbsp;názvu)</td></tr>
<tr><td>10</td><td>ARMv7-R</td><td>32 bitů</td><td>Cortex-R4, Cortex-R5, Cortex-R7</td><td>realtime aplikace</td></tr>
<tr><td>11</td><td>ARMv7-A</td><td>32 bitů</td><td>Cortex-A5, Cortex-A7, Cortex-A8, Cortex-A9, Cortex-A12, Cortex-A15, Cortex-A17</td><td>smartphony atd.</td></tr>
<tr><td>12</td><td>ARMv8-A</td><td>32/64 bitů</td><td>Cortex-A35, A35, A57, A72 a A73</td><td>smartphony atd.</td></tr>
<tr><td>13</td><td>ARMv8.2-A</td><td>32/64 bitů</td><td>Cortex-A55, A75, A76 a A77</td><td>smartphony, PC atd.</td></tr>
<tr><td>14</td><td>ARMv8.4-A</td><td>32/64 bitů</td><td>ARM Neoverse V1</td><td>produkty Apple</td></tr>
<tr><td>15</td><td>ARMv9.0</td><td>64 bitů</td><td>Cortex-A510, A710 atd.</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>ARMv9.2-A</td><td>64 bitů</td><td>Cortex-A520, A720 atd.</td><td>&nbsp;</td></tr>
</table>

<img src="http://i.iinfo.cz/images/188/arm1.jpg" class="image-222275" alt="&#160;" height="220" width="220" />
<p><i>Obrázek 2: Čipy StrongARM založené na architektuře ARMv4 byly
v&nbsp;minulosti velmi oblíbené. Zajímavé je, že původně tyto čipy vyvinula
společnost Digital Equipment Corporation (DEC) ve spolupráci s&nbsp;firmou ARM
a později byla tato technologie prodána Intelu.</i></p>

<p>Poznámky k&nbsp;informacím uvedeným v&nbsp;předchozí tabulce:</p>

<ul>

<li>U čipů prvních dvou architektur ARMv1 a ARMv2 nebyly použity cache (ani
paměťová ani datová), ovšem i samotné CPU byly relativně pomalé (hodinová
frekvence 8MHz) v&nbsp;porovnání s&nbsp;rychlostmi přístupu k&nbsp;RAM, takže
se tehdy nejednalo o úzké hrdlo systému.</li>

<li>Můžeme zde vidět dělení na &bdquo;klasická&ldquo; jádra a
&bdquo;Cortex&ldquo; jádra.</li>

<li>V&nbsp;nových elektronických zařízeních se již s&nbsp;prvními čtyřmi
generacemi čipů většinou nesetkáme. Na druhou stranu ARMv6 je stále
používán.</li>

<li>ARM11 je (poněkud zjednodušeně řečeno) poslední doposud masově používané
&bdquo;klasické&ldquo; jádro a současně i základ pro velké množství čipů
používaných v&nbsp;různých mobilních zařízeních.</li>

<li>Nové mikroprocesory a mikrořadiče ARM jsou děleny do třech skupin:
<u>A</u>pplication, <u>R</u>ealtime, <u>M</u>icrocontroller (název první
skupiny pravděpodobně vznikl ze snahy o její &bdquo;napasování&ldquo; na
zkratku ARM).</li>

<li>Populární mikropočítač Raspberry ve svých prvních variantách používal čip
s&nbsp;mikroarchitekturou ARM1176JZF-S, kde prefix ARM1176 značí třetí typ
jádra ARM11.</li>

<li>Právě ARM11 se některými svými vlastnostmi blíží čipům Cortex-M0 a
Cortex-M0+, jimiž se dnes budeme zabývat (ARM11 je však určen pro výkonnější
aplikace, opět si připomeňme Raspberry a podobná zařízení).</li>

<li>Poslední dva řádky obsahují čistě 64bitové architektury.</li>

</ul>

<img src="http://i.iinfo.cz/images/566/arm2.jpg" class="image-222276" alt="&#160;" height="394" width="350" />
<p><i>Obrázek 3: Dnes již historický kousek: osobní mikropočítač vybavený
mikroprocesorem s&nbsp;architekturou ARM.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Mikrořadiče Cortex-M</h2>

<p>Již při letmém pohledu na druhou polovinu tabulky, kterou jsme si ukázali <a
href="#k02">v&nbsp;předchozí kapitole</a>, je patrné, že novější architektury
ARM tvoří základ pro jádra třech navzájem odlišných typů čipů. Jedná se o řadu
<i>Cortex-M</i>, kde většinou nalezneme mikroprocesorová jádra určená především
pro použití v&nbsp;mikrořadičích (s&nbsp;různým výpočetním výkonem a taktéž
různými energetickými nároky), dále pak o řadu <i>Cortex-R</i> určenou pro
realtime aplikace (tato jádra jsou mnohdy vybavena instrukcemi typu SIMD) a
konečně o řadu <i>Cortex-A</i>, kam patří jak relativně málo výkonné čipy
použitelné například v&nbsp;set-top boxech, tak i čipy určené pro výkonné
servery apod. (tato jádra jsou mnohdy vybavena i matematickým koprocesorem,
podporou pro kooperaci většího množství jader, podporou pro adresování až
jednoho terabajtu RAM atd.). Nejnovější Cortexy-A už dokonce opustily 32bitový
režim a jedná se tak o čistě 64bitové architektury (těmi se však dnes nebudeme
zabývat).</p>

<p>Pojďme se nyní zaměřit především na řadu <i>Cortex-M</i>, tedy na rodinu
jader určených především pro použití v&nbsp;různě výkonných mikrořadičích.
Takových jader existuje celá řada:</p>

<table>
<tr><th>#</th><th>Jádro     </th><th>Architektura ARM</th><th>Architektura CPU/MCU</th><th>MPU</th></tr>
<tr><td>1</td><td>Cortex-M0 </td><td>ARMv6-M</td><td>Von Neumann</td><td>ne</td></tr>
<tr><td>2</td><td>Cortex-M0+</td><td>ARMv6-M</td><td>Von Neumann</td><td>volitelná</td></tr>
<tr><td>3</td><td>Cortex-M1 </td><td>ARMv6-M</td><td>Von Neumann</td><td>ne</td></tr>
<tr><td>4</td><td>Cortex-M3 </td><td>ARMv7-M</td><td>Harvardská</td><td>volitelná</td></tr>
<tr><td>5</td><td>Cortex-M4 </td><td>ARMv7E-M</td><td>Harvardská</td><td>volitelná</td></tr>
<tr><td>6</td><td>Cortex-M7 </td><td>ARMv7E-M</td><td>Harvardská</td><td>volitelná</td></tr>
<tr><td>7</td><td>Cortex-M23</td><td>ARMv8-M</td><td>Harvardská/Von Neumann</td><td>volitelná</td></tr>
<tr><td>8</td><td>Cortex-M33</td><td>ARMv8-M</td><td>Harvardská</td><td>volitelná</td></tr>
<tr><td>9</td><td>Cortex-M35</td><td>ARMv8-M</td><td>Harvardská</td><td>volitelná</td></tr>
<tr><td>10</td><td>Cortex-M52</td><td>ARMv8.1-M</td><td>Harvardská</td><td>volitelná</td></tr>
<tr><td>11</td><td>Cortex-M55</td><td>ARMv8.1-M</td><td>Harvardská</td><td>volitelná</td></tr>
<tr><td>12</td><td>Cortex-M85</td><td>ARMv8.1-M</td><td>Harvardská</td><td>volitelná</td></tr>
</table>

<p>Vidíme, že do řady <i>Cortex-M</i> spadá několik odlišných typů jader, která
jsou založena na architektuře ARMv6-M, ARMv7-M, ARMv7E-M, ARMv8-M a ARMv8.1-M.
Důležité je si uvědomit, že každá z&nbsp;těchto architektur má odlišné
vlastnosti a obecně i odlišnou instrukční sadu, z&nbsp;čehož také vyplývá, že
například mikrořadiče postavené na jádru <i>Cortex-M3</i> nebudou plně binárně
kompatibilní s&nbsp;mikrořadiči s&nbsp;jádrem <i>Cortex-M0</i> atd. To však
v&nbsp;dnešní době nepředstavuje závažný problém, minimálně ne tak velký, jako
je tomu (či ještě nedávno bylo) na platformě Wintel.</p>

<p><div class="rs-tip-major">Poznámka: MPU zde má skutečně význam jednotky pro
ochranu vybraných oblastí (regionů) paměti. Nejedná se tedy většinou o jednotku
zajišťující virtualizaci paměti (někdy se totiž tyto dvě funkce realizují
společně).</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Podrobnější pohled na 32bitová jádra Cortex-M</h2>

<p>Podívejme se nyní podrobněji na to, co mají jednotlivá jádra z&nbsp;řady
<i>Cortex-M</i> společného a čím se od sebe naopak odlišují. Zaměříme se přitom
na 32bitová jádra, s&nbsp;nimiž se můžeme setkat v&nbsp;mnoha jednodeskových
mikropočítačích, ale samozřejmě i v&nbsp;průmyslovém nasazení. Pravděpodobně
nejdůležitější společnou vlastností těchto jader je, že <i>Cortex-M</i>
nepodporuje původní 32bitovou RISCovou instrukční sadu (v&nbsp;tomto článku
označovanou A32, i když existují i další způsoby značení). Namísto toho je
podporována instrukční sada <i>Thumb</i> a u některých jader i <i>Thumb-2</i>
(buď všechny instrukce nebo jen vybraná část instrukcí). Jednodušší jádra
nemají hardwarovou děličku ani modul pro DSP operace. Všechny tyto vlastnosti
jsou (doufejme že přehledně) vypsány v&nbsp;další tabulce:</p>

<table>
<tr><th> #</th><th>Jádro     </th><th>Dělička</th><th>DSP</th><th>A32</th><th>Thumb</th><th>Thumb-2</th></tr>
<tr><td> 1</td><td>Cortex-M0 </td><td>ne </td><td>ne   </td><td>ne</td><td>kromě 3 instrukcí</td><td>jen částečně (6 instrukcí)</td></tr>
<tr><td> 2</td><td>Cortex-M0+</td><td>ne </td><td>ne   </td><td>ne</td><td>kromě 3 instrukcí</td><td>jen částečně (6 instrukcí)</td></tr>
<tr><td> 3</td><td>Cortex-M1 </td><td>ne </td><td>ne   </td><td>ne</td><td>kromě 3 instrukcí</td><td>jen částečně (6 instrukcí)</td></tr>
<tr><td> 4</td><td>Cortex-M3 </td><td>ano</td><td>ne   </td><td>ne</td><td>kompletně</td><td>kompletně</td></tr>
<tr><td> 5</td><td>Cortex-M4 </td><td>ano</td><td>ano  </td><td>ne</td><td>kompletně</td><td>kompletně</td></tr>
<tr><td> 6</td><td>Cortex-M7 </td><td>ano</td><td>ano  </td><td>ne</td><td>kompletně</td><td>kompletně</td></tr>
<tr><td> 7</td><td>Cortex-M23</td><td>ano</td><td>ne   </td><td>ne</td><td>kromě 1 instrukce</td><td>jen částečně (6 instrukcí)</td></tr>
<tr><td> 8</td><td>Cortex-M33</td><td>ano</td><td>výběr</td><td>ne</td><td>kompletně</td><td>kompletně</td></tr>
<tr><td> 9</td><td>Cortex-M35</td><td>ano</td><td>výběr</td><td>ne</td><td>kompletně</td><td>kompletně</td></tr>
<tr><td>10</td><td>Cortex-M52</td><td>ano</td><td>ano  </td><td>ne</td><td>kompletně</td><td>kompletně</td></tr>
<tr><td>11</td><td>Cortex-M55</td><td>ano</td><td>ano  </td><td>ne</td><td>kompletně</td><td>kompletně</td></tr>
<tr><td>12</td><td>Cortex-M85</td><td>ano</td><td>ano  </td><td>ne</td><td>kompletně</td><td>kompletně</td></tr>
</table>

<p>Jak je tomu se vzájemnou binární kompatibilitou? Program přeložený pro jádra
Cortex-M0 či Cortex-M0+ bude možné provozovat i na vyšších jádrech bez nutnosti
jeho modifikace (za předpokladu volby stejného pořadí bajtů &ndash; little či
big endian). Podobně strojový kód určený pro Cortex-M3 lze spustit na čipech
s&nbsp;jádrem Cortex-M4 či Cortex-M7. Žádný z&nbsp;těchto čipů ovšem
pochopitelně nedokáže pracovat s&nbsp;kódem používajícím instrukce A32 či
s&nbsp;kódem, který používá například rozšíření Neon (SIMD), Jazelle (Java
bajtkód), ThumbEE (dtto) atd.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti se binární kompatibilita
ve světě ARMu příliš neřeší, už jen kvůli současné existenci 32bitové i
64bitové architektury atd.</div></p>

<a href="http://www.root.cz/obrazek/222278/"><img src="http://i.iinfo.cz/images/61/arm4-prev.jpg" class="image-222278" alt="&#160;" height="262" width="370" /></a>
<p><i>Obrázek 4: Čipy s&nbsp;jádrem ARM nalezneme i v&nbsp;některých herních
konzolích.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Mikrořadiče Cortex-M0 a Cortex-M0+</h2>

<p>Jádro <i>Cortex-M0</i> tvoří základ pro čipy, u kterých je žádoucí dosáhnout
co nejnižší výrobní ceny, malých rozměrů a v&nbsp;neposlední řadě i malého
příkonu (s&nbsp;tím ovšem pochopitelně souvisí i příslušně nízký výpočetní
výkon). Tato jádra by měla postupně nahrazovat některé aplikace, v&nbsp;nichž
se nyní používají osmibitové mikrořadiče (PIC, starý &bdquo;dobrý&ldquo; 8051,
Motorola 68HC11 atd.), což se taktéž postupně děje.</p>

<p>Malé plochy čipu se skutečně podařilo dosáhnout, protože nejmenší vyráběný
integrovaný obvod s&nbsp;jádrem <i>Cortex-M0</i> má plochu přibližně
1,6&times;2 mm. I spotřeba je velmi nízká, protože dosahuje 12.5µW na každý MHz
při použití napětí 1,2V a 64µW na každý MHz při napětí 1,8V (teoreticky roste
spotřeba s&nbsp;hodinovou frekvencí lineárně a s&nbsp;napětím kvadraticky,
mimochodem hodinová frekvence těchto jader dosahuje podle provedení až několika
desítek až stovek MHz, typicky 48 MHz, 80 MHz či 120 MHz). Toto jádro je
naprogramované ve Verilogu a po technologické stránce je zajímavé tím, že se
interně používá pipeline se třemi řezy, na rozdíl od jádra <i>Cortex-M0+</i>
popsaného v&nbsp;navazujícím textu.</p>

<img src="http://i.iinfo.cz/images/47/arm5.jpg" class="image-222279" alt="&#160;" height="234" width="390" />
<p><i>Obrázek 5: Čipy XMC4000 založené na jádru Cortex-M4.<br />
Autor původní fotky: Davewave88.</i></p>

<p>Vzhledem k&nbsp;tomu, že jádra <i>Cortex-M0</i> jsou používána
v&nbsp;aplikacích, kde se požaduje velmi nízký příkon CPU (například různá
zařízení s&nbsp;baterií či monočlánkem), podporují tyto čipy hned několik
režimů &bdquo;uspání&ldquo; (<i>sleep mode</i>). V&nbsp;základním režimu
<i>sleep</i> se jednoduše sníží hodinová frekvence až na 0 Hz, ovšem kromě toho
lze použít i režim nazvaný <i>deep sleep</i>, při jehož aktivaci se od napájení
odpojí i flash paměť atd. Při práci s&nbsp;různými režimy CPU slouží i
instrukce <strong>WFI</strong> (<i>Wait For Interrupt</i>) a
<strong>WFE</strong> a (<i>Wait for Event</i>). První instrukce čeká na vznik
výjimky, přerušení či signálu od debuggeru, druhá instrukce pak na nemaskovanou
výjimku, událost přijatou od některého koprocesoru či opět na signál od
debuggeru.</p>

<p>O tom, že jádro <i>Cortex-M0</i> je skutečně navrženo takovým způsobem, aby
mohlo spotřebou energie a částečně i cenou soutěžit s&nbsp;jednoduššími a
levnějšími mikrořadiči, svědčí i způsob vyřešení násobičky. V&nbsp;instrukční
sadě Thumb nalezneme mj.&nbsp;i instrukci MULS určenou pro násobení dvou
32bitových operandů, přičemž výsledek je taktéž 32bitový (zapamatuje se jen
spodních 32bitů výsledku). Při implementaci mikroprocesoru je možné zvolit,
jakým typem násobičky se tato instrukce bude provádět. Pokud se má jednat o
výkonnější čip (a aplikace operaci násobení skutečně využije), může se použít
rychlá násobička, která celou operaci dokáže provést v&nbsp;jediném taktu
(samozřejmě se měření provádí při postupně zaplňované pipeline). Pokud se ovšem
má jednat o levnější a méně výkonný čip, lze násobení implementovat po krocích,
což sice trvá celých 32 taktů, ovšem potřebná plocha čipu a i energetická
náročnost je mnohem menší, než v&nbsp;případě jednocyklové násobičky.</p>

<img src="http://i.iinfo.cz/images/610/arm7.jpg" class="image-222281" alt="&#160;" height="344" width="390" />
<p><i>Obrázek 6: Mezi další čipy založené na jádru Cortex-M0 patří integrované
obvody STM32 F0.</i></p>

<p>Na mikrořadiče <i>Cortex-M0+</i> se můžeme dívat jako na vylepšení původních
jader <i>Cortex-M0</i>. Interně se ovšem jedná o odlišně navržená jádra,
protože <i>Cortex-M0+</i> obsahuje pipeline pouze se dvěma řezy a nikoli
s&nbsp;řezy třemi (vlastně se tak vracíme na samotný začátek platformy ARM). Co
je však pro případné uživatele důležitější &ndash; i díky zmenšenému počtu řezů
pipeline se podařilo dále snížit spotřebu a přitom zachovat obousměrnou
kompatibilitu s&nbsp;původními jádry <i>Cortex-M0</i>. Spotřeba klesá až na
hodnoty 9.8µW na MHz, takže tato jádra mohou nalézt uplatnění i v&nbsp;chytrých
hodinkách apod. Opět je možné si zvolit způsob implementace násobičky (rychlá
versus energeticky nenáročná) a nově i to, zda se má použít jednotka MPU. Čipů
s&nbsp;tímto jádrem existuje celá řada, například je vyrábí firmy Atmel,
Freescale, STMicroelectronics, NXP Semiconductors apod. Na tomto jádru je
založen i čip RP2040, na němž budeme testovat dnešní demonstrační příklady.</p>

<p><div class="rs-tip-major">Poznámka: dnes se setkáme i s&nbsp;čipy, které
obsahují více jader Cortex-M0+. Příkladem je již výše zmíněný čip RP2040 se
dvěma jádry (to naznačuje první číslice 2 v&nbsp;označení čipu).</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukční sada mikrořadičů Cortex-M0+</h2>

<p>Mikroprocesory <i>ARM</i> byly zpočátku vybaveny jedinou instrukční sadou,
v&nbsp;níž se nacházely instrukce o konstantní šířce 32 bitů. Postupně však
byly navrženy a implementovány i další instrukční sady, které bylo u mnoha čipů
možné použít společně s&nbsp;původní 32bitovou instrukční sadou. Jedná se o
rozšíření <i>Thumb</i> následované vylepšenou variantou nazvanou
<i>Thumb-2</i>. Dále nesmíme zapomenout na 64bitovou architekturu ARM, která se
nazývá AArch64 a která používá jak novou množinu pracovních registrů, tak i
v&nbsp;mnoha ohledech změněnou instrukční sadu:</p>

<ul>
<li>Původní 32bitová instrukční sada ARM</li>
<li>Rozšíření Thumb</li>
<li>Rozšíření Thumb-2</li>
<li>Nová instrukční sada používaná u mikroprocesorů s&nbsp;architekturou AArch64</li>
</ul>

<p>Z&nbsp;předchozího textu již víme, že jádra <i>Cortex-M0</i> nedokážou
správně dekódovat instrukce z&nbsp;původní 32bitové instrukční sady ARM (dnes
se označuje jako A32). Namísto toho je podporována instrukční sada
<i>Thumb</i>, z&nbsp;níž byly odstraněny jen tři instrukce:
<strong>CBZ</strong>, <strong>CBNZ</strong> a <strong>IT</strong> (zejména tato
poslední instrukce by však byla velmi užitečná, nicméně její zařazení by
pravděpodobně komplikovalo návrh čipu, popř.&nbsp;jeho plochu a příkon).</p>

<a href="https://microchipdeveloper.com/xwiki/bin/download/products/mcu-mpu/32bit-mcu/sam/arm-cortex-m0/instructions/WebHome/instructions.png?rev=1.1">Instrukce Cortex-M0(+)</a><br />
<p><i>Obrázek 7: Všechny instrukce jader s&nbsp;architekturou Cortex-M0(+).
Instrukce Thumb-2 jsou vykresleny s&nbsp;dvojnásobnou šířkou, kvůli svému
kódování.</i></p>

<p>Zajímavé je, že tato jádra navíc rozpoznají i šest instrukcí
z&nbsp;instrukční sady Thumb-2. Konkrétně se jedná o instrukce
<strong>BL</strong>, <strong>DMB</strong>, <strong>DSB</strong>,
<strong>ISB</strong>, <strong>MRS</strong> a <strong>MSR</strong> (ještě se
k&nbsp;nim později vrátíme). Důvod, proč se tvůrci přiklonili k&nbsp;instrukční
sadě Thumb, je pochopitelný &ndash; je tak možné dosáhnout větší hustoty kódu,
což je zejména na mikrořadičích, kde jsou kapacity RAM a (Flash)ROM relativně
malé, poměrně kritická vlastnost. Díky relativně velké ortogonalitě instrukční
sady Thumb se navíc může dosáhnout větší hustoty kódu, než je tomu u některých
osmibitových mikrořadičů! (typické je to zejména v&nbsp;porovnání s&nbsp;řadou
8051, která je kupodivu stále používána).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Od instrukční sady A32 k&nbsp;instrukční sadě Thumb-2</h2>

<p>Původní instrukční sada procesorů ARM používá převážně &bdquo;RISCové&ldquo;
instrukce o konstantní šířce 32 bitů. Vzhledem k&nbsp;tomu, že šířka externí
datové sběrnice byla rovna taktéž 32 bitům a instrukce musely být zarovnané na
celá slova, znamenalo to, že se celá instrukce vždy načetla jedinou operací,
což je velký rozdíl oproti typickým mikroprocesorům s&nbsp;architekturou
<i>CISC</i>, u nichž je délka instrukcí proměnná a mnohdy může přesahovat
hranici slov (což ve svém důsledku vedlo k&nbsp;nutnosti vytvoření takzvané
&bdquo;fronty instrukcí&ldquo;, jejíž vlastnosti se mj.&nbsp;využívaly či spíše
zneužívaly při tvorbě virů, které nešlo odhalit debuggerem).</p>

<a href="http://www.root.cz/obrazek/222284/"><img src="http://i.iinfo.cz/images/409/arm9-prev.png" class="image-222284" alt="&#160;" height="270" width="356" /></a>
<p><i>Obrázek 8: Kódování instrukcí u &bdquo;klasické&ldquo; 32bitové RISCové
architektury.</i></p>

<p>Tuto instrukční sadu lze na mnoha procesorech <i>ARM</i> používat dodnes
(s&nbsp;výjimkou některých čipů <i>Cortex-M</i> &ndash; ty nás ovšem zajímají
nejvíce, a taktéž s&nbsp;výjimkou čistě 64bitových čipů) a její největší
předností je možnost uvést u <strong>každé</strong> instrukce podmínku, při
jejímž splnění se má instrukce provést. Díky tomuto řešení je možné eliminovat
velké množství skoků, jejichž provedení je samozřejmě problematické, a to
nejenom na architektuře <i>RISC</i>, ale i na procesorech <i>CISC</i>.</p>

<a href="http://www.root.cz/obrazek/222282/"><img src="http://i.iinfo.cz/images/560/arm8-prev.png" class="image-222282" alt="&#160;" height="220" width="370" /></a>
<p><i>Obrázek 9: Kódování instrukcí v&nbsp;sadě Thumb.</i></p>

<p>I přes mnohé přednosti 32bitové instrukční sady <i>ARM</i> se však
v&nbsp;některých případech projevují její nevýhody. Jedná se především o to, že
použití 32bitových instrukcí může zmenšovat &bdquo;hustotu&ldquo; kódu, což se
projevuje větší délkou binárních souborů, větší pravděpodobností výpadku
stránky z&nbsp;vyrovnávací paměti a taktéž (obecně) vyšší cenou za zařízení
v&nbsp;případě, že je mikroprocesor použit ve funkci mikrořadiče (zde se již
může projevit cena za každý ušetřený kilobajt paměti ROM/EPROM/Flash
s&nbsp;programovým kódem). Navíc nutnost vyhodnocení podmínky znamená zpoždění
v&nbsp;pipeline &ndash; což zpočátku byl relativně malý problém, dnes se však
jedná o závažný nedostatek.</p>

<p>Z&nbsp;tohoto důvodu jsou mikrořadiče <i>Cortex-M</i> vybaveny instrukční
sadou pojmenovanou <i>Thumb</i>. Jedná se o instrukční sadu obsahující
podmnožinu instrukcí vybranou na základě analýzy strojových programů
generovaných překladači jazyků C a C++. Dále se v&nbsp;této instrukční sadě
neobjevují bity určené pro podmíněné provádění instrukcí, což znamená, že je
nutné se vrátit k&nbsp;použití klasických podmíněných skoků. Na druhou stranu
se však délka <i>všech</i> instrukcí zkrátila na šestnáct bitů, což dovoluje
dosažení větší &bdquo;hustoty&ldquo; kódu.</p>

<p>Zavedení nové instrukční sady není v&nbsp;tomto případě tak složité, jak by
se možná mohlo zdát, protože převod instrukce <i>Thumb</i> na původní instrukci
<i>ARM</i> je záležitostí jednoduchého dekodéru, který může být například
umístěn v&nbsp;interní paměti ROM či přímo &bdquo;zadrátován&ldquo; na čipu.
Jedná se tedy o řádově jednodušší technologii, než jaká je použita na
procesorech <i>x86</i> pro překlad <i>CISC</i> instrukcí do sekvence interních
RISC-like instrukcí (zde se může jediná instrukce CISC rozložit na sekvenci
několika instrukcí RISC, popř.&nbsp;dokonce na celý podprogram).</p>

<p>A ta nejlepší zpráva na konec &ndash; s&nbsp;využitím speciální instrukce
skoku je možné se na některých čipech (ovšem nikoli na Cortex-M) přepínat mezi
instrukční sadou <i>Thumb</i> a původní instrukční sadou <i>ARM</i>, a to
dokonce i v&nbsp;rámci jednotlivých funkcí. Programátor či překladač tedy může
využívat předností obou instrukčních sad. Poznámka: tato možnost u Cortex-M
chybí a dále se jí nebudeme zabývat).</p>

<p>Třetí instrukční sada, kterou nalezneme u mnoha mikroprocesorů ARM, se
jmenuje <i>Thumb-2</i>. Tato instrukční sada se v&nbsp;sobě snaží sdružit jak
přednosti původní 32bitové &bdquo;RISCové&ldquo; instrukční sady <i>ARM</i>,
tak i přednosti šestnáctibitové instrukční sady <i>Thumb</i>. Sada
<i>Thumb-2</i> díky tomu na jedné straně dosahuje jak velké hustoty kódu
(<i>code density</i>), tak i velkého výpočetního výkonu. Zmíněný výpočetní
výkon dosahovaný v&nbsp;reálných aplikacích totiž byl u sady <i>Thumb</i>
v&nbsp;některých případech menší, protože mnohé operace musely být provedeny
pomocí většího množství instrukcí &ndash; instrukce <i>Thumb</i> totiž vždy
vykonávaly jen jednu operaci, na rozdíl od instrukcí <i>ARM</i>, které
obsahovaly jak podmínkové bity, tak i v&nbsp;mnoha případech
&bdquo;podoperaci&ldquo; pro bitový posun či rotaci jednoho z&nbsp;operandů
vstupujícího do aritmeticko-logické jednotky.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je možná vhodné
poznamenat, že i instrukční sada <i>Thumb-2</i> odpovídá základnímu charakteru
RISCových mikroprocesorů, na nichž je implementována, tj.&nbsp;stále se jedná o
instrukční sadu s&nbsp;operacemi prováděnými především nad sadou pracovních
registrů, pouze s&nbsp;omezenou možností přístupu do paměti přes instrukce typu
Load &amp; Store a s&nbsp;jednoduchými adresovacími režimy.</div></p>

<img src="http://i.iinfo.cz/images/526/arm10.gif" class="image-222283" alt="&#160;" height="427" width="250" />
<p><i>Obrázek 10: Pracovní a řídicí registry: rozdíl mezi RISCovým režimem ARM
a režimem Thumb. Ve skutečnosti není tento obrázek zcela korektní, protože i
v&nbsp;režimu Thumb lze využít všechny pracovní registry, ovšem přístup
k&nbsp;horním osmi registrům je více omezen (jen na některé instrukce).</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Malá odbočka: proč vznikla instrukční sada Thumb-2?</h2>

<p>Sami konstruktéři mikroprocesorů <i>ARM</i> se vyjádřili k&nbsp;tomu,
z&nbsp;jakého důvodu vlastně instrukční sada <i>Thumb-2</i> vznikla. Při jejím
návrhu měli na mysli čtyři parametry, které se navzájem ovlivňují a vylepšení
jednoho z&nbsp;parametrů většinou v&nbsp;důsledku vede ke zhoršení zbývajících
třech parametrů (což není v&nbsp;IT nic nového &ndash; zde skutečně není žádné
jídlo zdarma). Jedná se o následující parametry:</p>

<ol>

<li>Cenu vlastního mikroprocesoru nebo mikrořadiče, která je kromě jiných
okolností ovlivněna i jeho složitostí (existence prediktorů skoků,
spekulativního provádění instrukcí, ...), počtem aritmeticko-logických jednotek
(obecně zda jde o skalární či superskalární procesor), velikostí potřebných
vyrovnávacích pamětí atd.</li>

<li>Dosahovaný výpočetní výkon v&nbsp;<strong>reálných</strong> aplikacích.
V&nbsp;praxi to znamená, že hodnota udávaná v&nbsp;jednotkách MIPS nebo MFLOPS
nemusí být vždy směrodatná: je to právě příklad jednodušších instrukcí
<i>Thumb</i> v&nbsp;porovnání s&nbsp;obecně výkonnějšími instrukcemi <i>ARM</i>
(tedy lze mít mikroprocesor provádějící obrovské množství instrukcí za časovou
jednotku, které ale nebudou provádět příliš mnoho reálných operací).</li>

<li>Nutný energetický příkon procesoru (závisí na technologii výroby, napájecím
napětí, hodinové frekvenci, počtu ALU, velikosti vyrovnávacích paměti
atd.).</li>

<li>Cenu za vývoj a optimalizaci aplikací (tu ovlivňuje složitost instrukční
sady, nedostatky v&nbsp;instrukční sadě: například nutnost provádění
neefektivních skoků, složitost při načítání konstant do pracovních registrů
atd.).</li>

</ol>

<p>Důvodů pro vznik nové instrukční sady tedy bylo více než dost, takže se nyní
podívejme na to, co se jejím tvůrcům podařilo splnit a co naopak nikoli.
V&nbsp;následujícím textu budou uvedeny výsledky měření prezentované samotnou
společností <i>ARM</i>. V&nbsp;první tabulce je porovnána &bdquo;hustota&ldquo;
binárního strojového kódu měřená jeho délkou. Ve všech případech se jednalo o
stejný algoritmus, který byl poprvé implementován s&nbsp;využitím instrukční
sady <i>ARM</i>, podruhé s&nbsp;pomocí sady <i>Thumb</i> a potřetí byla použita
instrukční sada <i>Thumb-2</i>. Za základ je přitom brána délka původního kódu
používajícího instrukce <i>ARM</i> (tento kód odpovídá sto procentům, čím menší
číslo, tím menší je i výsledný binární program):</p>

<table>
<tr><th>Instrukční sada</th><th>Délka kódu</th></tr>
<tr><td>ARM    </td><td>100%</td></tr>
<tr><td>Thumb  </td><td> 70%</td></tr>
<tr><td>Thumb-2</td><td> 74%</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: asi není překvapivé, že původní kód byl
nejméně &bdquo;hustý&ldquo; vzhledem k&nbsp;tomu, že prakticky každá instrukce
má čtyři bity určeny pro zápis podmínky (ne vždy se využijí) a instrukce pro
operace nad registry navíc obsahují bitové pole pro posuny (taktéž se často
nevyužijí).</div></p>

<p>Ve druhé tabulce je uveden relativní výpočetní výkon přeloženého binárního
programu, přičemž 100% odpovídá nejrychlejší implementaci a 75% implementaci
nejpomalejší:</p>

<table>
<tr><th>Instrukční sada</th><th>Relativní výpočetní výkon</th></tr>
<tr><td>ARM    </td><td>100%</td></tr>
<tr><td>Thumb  </td><td> 75%</td></tr>
<tr><td>Thumb-2</td><td> 98%</td></tr>
</table>

<p>Z&nbsp;výsledků, které jsou prezentovány v&nbsp;předešlých dvou tabulkách
tedy vyplývá, že pro testovanou aplikaci se díky použití instrukční sady
<i>Thumb-2</i> podařilo zmenšit velikost kódu na tři čtvrtiny původní velikosti
a přitom výpočetní výkon poklesl pouze o zhruba 2% (zde se samozřejmě projevila
i nižší pravděpodobnost výpadku instrukční cache, která ovšem byla nižší i u
implementace využívající instrukce <i>Thumb</i>).</p>

<p><div class="rs-tip-major">Poznámka: jako u všech podobných měření je
samozřejmě nutné mít na paměti, že se jedná pouze o (reprezentativní) vzorek,
který může ale taktéž nemusí odpovídat jinému typu algoritmu. Vždy záleží jen
na konkrétní aplikaci, konkrétním vývojáři, jeho rozpočtu a času, zda si
podobné měření udělá i v&nbsp;případě jím vyvíjené aplikace, nebo zda se
spolehne na cizí statistiku (to ovšem platí i pro výběr procesoru: opět záleží
na mnoha okolnostech, včetně dosavadních zkušeností vývojáře, ceně za vývojové
nástroje atd.).</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instrukce rozpoznávané mikrořadiči Cortex-M0, M0+, M1 a M23</h2>

<p></p>

<p>Ovšem menší šířka instrukcí znamená větší i menší omezení instrukční sady, která tak přestala být elegantní a je ryze pragmatická. Zcela zmizely podmínkové kódy, které zůstaly zachovány jen u instrukce podmíněného skoku.  Taktéž se možnost použití <i>barrel shifteru</i> omezila jen na určitou skupinu instrukcí. Ovšem asi největší změnou bylo to, že se sada pracovních registrů <strong>R0-R15</strong> rozdělila na spodní polovinu <strong>R0-R7</strong> (<i>Lo registers</i>) a horní polovinu <strong>R8-R15</strong> (<i>Hi registers</i>), přičemž většina instrukcí dokáže pracovat pouze s&nbsp;prvními osmi registry, zatímco některé registry z&nbsp;horní skupiny mají speciální význam (čítač instrukcí, ukazatel na vrchol zásobníku atd.).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Aritmetické a logické instrukce</h2>

<p>Výše zmíněné rozdělení pracovních registrů na dvě poloviny o různých
významech je patrné i na těch instrukcích, pomocí nichž se realizují základní
aritmetické a logické operace. Tyto operace jsou zakódovány několika způsoby.
Nejdříve se podívejme na instrukce pracující s&nbsp;dvojicí registrů: jednoho
registru cílového a registru zdrojového, přičemž u většiny registrů je cílový
registr současně použit i jako první vstupní operand.</p>

<p>Šestnáctibitové instrukční slovo je u těchto instrukcí rozděleno na čtyři
části: šestibitový prefix mající binární hodnotu <strong>010000</strong>,
čtyřbitový kód prováděné aritmetické či logické operace, tříbitový index
druhého zdrojového registru <strong>Rs</strong> a taktéž tříbitový index
prvního zdrojového registru <strong>Rd</strong>, který je současně i registrem
cílovým, tj.&nbsp;registrem, do nějž se uloží výsledek operace (výjimku tvoří
instrukce komparace a testu, u nichž se výsledek porovnání nikam neukládá). Zde
je ostatně patrné i další omezení šestnáctibitové instrukční sady <i>Thumb</i>,
kdy do úzkého instrukčního slova není možné vložit indexy tří registrů, ale
pouze registrů dvou, což potenciálně zvyšuje četnost přesunů dat mezi registry
a navíc se i snižuje účinnost některých optimalizačních technik prováděných buď
přímo programátory v&nbsp;assembleru nebo překladači:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 0 | 0 | 0 |    operace    |    Rs     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Podporováno je celkem šestnáct aritmetických a logických operací (+ operací
bitového posunu a rotace) určených bity 6 až 9 instrukčního slova. Tyto operace
jsou vypsány v&nbsp;tabulce pod tímto odstavcem. Ve třetím sloupci tabulky je
pro ilustraci uvedena ekvivalentní instrukce dostupná v&nbsp;režimu ARM):</p>

<table>
<tr><th>Kód</th><th>Operace</th><th>Ekvivalent ARM</th><th>Význam</th></tr>
<tr><td>0000</td><td>AND Rd, Rs</td><td>ANDS Rd, Rd, Rs</td><td>Rd:= Rd AND Rs</td></tr>
<tr><td>0001</td><td>EOR Rd, Rs</td><td>EORS Rd, Rd, Rs</td><td>Rd:= Rd EOR Rs (EOR=XOR)</td></tr>
<tr><td>0010</td><td>LSL Rd, Rs</td><td>MOVS Rd, Rd, LSL Rs</td><td>Rd := Rd &lt;&lt; Rs (bitový posun)</td></tr>
<tr><td>0011</td><td>LSR Rd, Rs</td><td>MOVS Rd, Rd, LSR Rs</td><td>Rd := Rd &gt;&gt; Rs (bitový posun)</td></tr>
<tr><td>0100</td><td>ASR Rd, Rs</td><td>MOVS Rd, Rd, ASR Rs</td><td>Rd := Rd ASR Rs (aritmetický posun)</td></tr>
<tr><td>0101</td><td>ADC Rd, Rs</td><td>ADCS Rd, Rd, Rs</td><td>Rd := Rd + Rs + C-bit</td></tr>
<tr><td>0110</td><td>SBC Rd, Rs</td><td>SBCS Rd, Rd, Rs</td><td>Rd := Rd - Rs - NOT C-bit</td></tr>
<tr><td>0111</td><td>ROR Rd, Rs</td><td>MOVS Rd, Rd, ROR Rs</td><td>Rd := Rd ROR Rs (rotace)</td></tr>
<tr><td>1000</td><td>TST Rd, Rs</td><td>TST Rd, Rs</td><td>Nastavení příznaků podle operace Rd AND Rs</td></tr>
<tr><td>1001</td><td>NEG Rd, Rs</td><td>RSBS Rd, Rs, #0</td><td>Rd = -Rs</td></tr>
<tr><td>1010</td><td>CMP Rd, Rs</td><td>CMP Rd, Rs</td><td>Nastavení příznaků podle operace Rd - Rs</td></tr>
<tr><td>1011</td><td>CMN Rd, Rs</td><td>CMN Rd, Rs</td><td>Nastavení příznaků podle operace Rd + Rs</td></tr>
<tr><td>1100</td><td>ORR Rd, Rs</td><td>ORRS Rd, Rd, Rs</td><td>Rd := Rd OR Rs</td></tr>
<tr><td>1101</td><td>MUL Rd, Rs</td><td>MULS Rd, Rs, Rd</td><td>Rd := Rs * Rd</td></tr>
<tr><td>1110</td><td>BIC Rd, Rs</td><td>BICS Rd, Rd, Rs</td><td>Rd := Rd AND NOT Rs</td></tr>
<tr><td>1111</td><td>MVN Rd, Rs</td><td>MVNS Rd, Rs</td><td>Rd := NOT Rs</td></tr>
</table>

<p>Speciálně u instrukcí pro součet a rozdíl existují další možnosti
zakódování, které kombinují trojici pracovních registrů R0 až R7. Zde se
rozlišuje jen mezi operací <strong>ADD</strong> a <strong>SUB</strong>:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 0 | A |    Rm     |    Rs     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Varianta s&nbsp;krátkou konstantou 0 až 7 zakódovanou přímo
v&nbsp;instrukčním slovu vypadá takto:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 1 | A | konstanta |    Rs     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Existuje taktéž varianta s&nbsp;delší osmibitovou konstantou a jediným
registrem. Tato varianta je používána jen instrukcemi <strong>ADD</strong>,
<strong>SUB</strong>, <strong>CMP</strong> a <strong>MOV</strong>:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |operace| Rd/Rn |             konstanta             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Aritmetické a bitové posuny existují taktéž ve vlastní variantě, kdy je
počet bitů 0..31 zakódován přímo v&nbsp;instrukčním slovu:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 |operace| posun 0-31 bitů   |    Rs     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Skoky a vyvolání SW přerušení</h2>

<p>Skok bez podmínky je realizován instrukcí <strong>B</strong>, která
v&nbsp;instrukčním slovu používá 11bitový offset (rozsah 2kB):</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 |             11bitový offset               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>I základní varianta skoku do subrutiny (<i>branch and link</i>) používá
11bitový offset, ovšem prvních pět bitů je odlišných (pokud je H==1, je použit
skok odvozený od registru LR, tato instrukce je provedena ve dvou krocích,
s&nbsp;H==0 a H==1):</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | H |             11bitový offset               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Pro skoky s&nbsp;podmínku je rezervován jen osmibitový offset, protože
celkem čtyři bity zabírají kódy podmínky:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 1 |   podmínka    |        8bitový offset         |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>A konečně poslední de facto skoková instrukce slouží k&nbsp;vyvolání SW
přerušení:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 |       8bitová konstanta       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si prvních čtyři bitů &ndash;
používá se stejné kódování, jako u podmíněného skoku.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>


<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb-2/">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb-2/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>MicroPython documentation<br />
<a href="https://docs.micropython.org/en/latest/index.html">https://docs.micropython.org/en/latest/index.html</a>
</li>

<li>Inline assembler for Thumb2 architectures<br />
<a href="https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html">https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html</a>
</li>

<li>Inline assembler in MicroPython<br />
<a href="https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler">https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami (2)<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>Cortex-M0 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M0">https://en.wikipedia.org/wiki/ARM_Cortex-M0</a>
</li>

<li>Cortex-M0+ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B">https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>The Thumb instruction set<br />
<a href="http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf">http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

