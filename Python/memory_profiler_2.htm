<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Sledování využití paměti Pythonovských aplikací nástrojem Memory profiler</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Sledování využití paměti Pythonovských aplikací nástrojem Memory profiler</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku si ukážeme, jakým způsobem lze využít nástroj nazvaný Memory profiler pro sledování využití paměti aplikacemi, které jsou naprogramovány v jazyku Python. Tento nástroj dokáže sledovat i synovské procesy vytvořené v měřené aplikaci.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Sledování využití paměti Pythonovských aplikací nástrojem Memory profiler</a></p>
<p><a href="#k02">2. Instalace nástroje Memory profiler</a></p>
<p><a href="#k03">3. Sledované demonstrační aplikace</a></p>
<p><a href="#k04">4. Spuštění aplikace se sledováním práce s&nbsp;pamětí</a></p>
<p><a href="#k05">5. Vyhodnocení a vizualizace obsazení paměti sledovanou aplikací</a></p>
<p><a href="#k06">6. Analýza grafu</a></p>
<p><a href="#k07">7. Sledování a analýza druhé i třetí aplikace</a></p>
<p><a href="#k08">8. Analýza grafu</a></p>
<p><a href="#k09">9. Získání informací o alokované paměti na úrovni programových řádků</a></p>
<p><a href="#k10">10. Výsledky analýzy</a></p>
<p><a href="#k11">11. Úprava aplikace přidávající a ubírající prvky ze seznamu</a></p>
<p><a href="#k12">12. Výsledky analýzy</a></p>
<p><a href="#k13">*** 13. Měření spotřeby paměti u složitější aplikace</a></p>
<p><a href="#k14">*** 14. Výsledky měření</a></p>
<p><a href="#k15">15. Spotřeba paměti u aplikací běžících ve větším množství procesů</a></p>
<p><a href="#k16">16. Ukázka jednoduché aplikace, která spouští více souběžně běžících procesů</a></p>
<p><a href="#k17">17. Výsledky analýzy: celková spotřeba operační paměti</a></p>
<p><a href="#k18">18. Výsledky analýzy: spotřeba rozdělená podle jednotlivých procesů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Sledování využití paměti Pythonovských aplikací nástrojem Memory profiler</h2>

<p>V&nbsp;dnešním článku si ukážeme, jakým způsobem lze využít nástroj nazvaný
<i>Memory profiler</i> pro sledování využití paměti aplikacemi, které jsou
naprogramovány <a href="https://www.root.cz/n/python/">v&nbsp;jazyku
Python</a>. Navážeme tak na předchozí článek nazvaný <a
href="https://www.root.cz/clanky/detekce-velikosti-hodnot-ulozenych-v-operacni-pameti-a-spravovanych-interpretrem-pythonu/">Detekce
velikosti hodnot uložených v&nbsp;operační paměti a spravovaných interpretrem
Pythonu</a>, který byl zaměřen na nástroje (resp.&nbsp;přesněji řečeno balíčky)
<i>Pympler</i> a taktéž <i>Guppy</i>.</p>

<p>Připomeňme si, že jak <i>Pympler</i>, tak i <i>Guppy</i> dokážou poměrně
přesně zjistit, jaké hodnoty (objekty) a s&nbsp;jakou velikostí jsou
<i>v&nbsp;daný okamžik</i> používány interpretrem Pythonu. Dnes popisovaný
nástroj <i>Memory profiler</i> je poněkud odlišný, protože navíc umožňuje, aby
se informace o obsazené paměti získávala kontinuálně po celou dobu běhu
aplikace, s&nbsp;následnou vizualizací obsazení paměti ve formě jednoduchých
grafů. Navíc je možné do jednoho grafu vykreslit několik průběhů získaných
během několika běhů sledované aplikace (například s&nbsp;nastavením různých
parametrů, s&nbsp;přepnutím algoritmů atd.). Navíc je možné získat informace o
spotřebě paměti s&nbsp;velmi dobrou přesností (resp.&nbsp;granularitou) &ndash;
až na úrovni jednotlivých programových řádků (můžeme tedy velmi snadno
detekovat ty programové řádky, v&nbsp;nichž se alokují velké paměťové bloky
&ndash; což budou typicky operace s&nbsp;objemnými objekty).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace nástroje Memory profiler</h2>

<p>Díky tomu, že je balíček s&nbsp;nástrojem <i>Memory profiler</i>
zaregistrovaný na <i>PyPi</i>, je instalace tohoto balíčku triviální a můžeme
ji provést (pro právě přihlášeného uživatele) následujícím příkazem:</p>

<pre>
$ <strong>pip3 install --user memory_profiler</strong>
</pre>

<p>Samotná instalace proběhne prakticky okamžitě:</p>

<pre>
Collecting memory_profiler
  Downloading memory_profiler-0.61.0-py3-none-any.whl (31 kB)
Requirement already satisfied: psutil in /usr/lib/python3/dist-packages (from memory_profiler) (5.5.1)
Installing collected packages: memory-profiler
Successfully installed memory-profiler-0.61.0
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě je možné instalaci provést i
do virtuálního prostředí Pythonu, pokud je to zapotřebí.</div></p>

<p>Součástí instalace nástroje <i>Memory Profiler</i> by měl být i spustitelný
soubor nazvaný <strong>mprof</strong>, takže si otestujme, zda existuje a je
skutečně spustitelný:</p>

<pre>
$ <strong>whereis mprof</strong>
&nbsp;
mprof: /home/ptisnovs/.local/bin/mprof
</pre>

<p>Pokud byl soubor nalezen, můžeme ho spustit a vypsat si nápovědu:</p>

<pre>
$ <strong>mprof</strong>
&nbsp;
Usage: mprof &lt;command&gt; &lt;options&gt; &lt;arguments&gt;
&nbsp;
Available commands:
&nbsp;
    run      run a given command or python file
    attach   alias for 'run --attach': attach to an existing process by pid or name
    rm       remove a given file generated by mprof
    clean    clean the current directory from files created by mprof
    list     display existing profiles, with indices
    plot     plot memory consumption generated by mprof run
    peak     print the maximum memory used by an mprof run
&nbsp;
Type mprof &lt;command&gt; --help for usage help on a specific command.
For example, mprof plot --help will list all plotting options.
</pre>

<p><div class="rs-tip-major">Poznámka: aby bylo možné <strong>mprof</strong>
spustit i bez nutnosti uvedení cesty k&nbsp;němu, musí být
<strong>./local/bin</strong> přidáno do proměnné prostředí
<strong>PATH</strong>. I tuto skutečnost si můžeme velmi snadno
ověřit:</div></p>

<pre>
$ <strong>echo $PATH</strong>
&nbsp;
/home/ptisnovs/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/opt/go/bin/:/home/ptisnovs/go/bin/:<u>/home/ptisnovs/.local/bin</u>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Sledované demonstrační aplikace</h2>

<p>V&nbsp;navazujících kapitolách si základní možnosti nabízené nástrojem
<i>Memory profiler</i> ukážeme na několika demonstračních
&bdquo;aplikacích&ldquo;, které v&nbsp;průběhu své činnosti provádí alokaci
paměti popř.&nbsp;(i když v&nbsp;Pythonu nepřímo) její dealokaci. Mezi
jednotlivé operace je vždy vložen příkaz <strong>sleep(2)</strong>, což nám
umožní lépe sledovat vliv jednotlivých příkazů na spotřebu operační paměti na
grafech, které <i>Memory profiler</i> dokáže vykreslit.</p>

<p>První aplikace nejdříve v&nbsp;programové smyčce vytvoří delší řetězec, na
který (po uplynutí dvou sekund) ztratí referenci, protože se do původní
proměnné vloží odlišná hodnota (připomeňme si, že v&nbsp;proměnných jsou
uloženy pouze reference na hodnoty, nikoli samotné hodnoty). Následně se
provede alokace pole bajtů (<i>bytearray</i>) a po uplynutí dvou sekund
ztratíme referenci i na toto pole. Úplný zdrojový kód této aplikace lze nalézt
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app1.py</a>:</p>

<pre>
from time import sleep
&nbsp;
sleep(2)
&nbsp;
x = "*foo*"
&nbsp;
sleep(2)
&nbsp;
y = ""
for i in range(200000):
    y += x
&nbsp;
print(len(y))
&nbsp;
sleep(2)
&nbsp;
x = 0
y = 0
&nbsp;
sleep(2)
&nbsp;
x = bytearray(1000000)
&nbsp;
sleep(2)
&nbsp;
x = 0
&nbsp;
sleep(2)
</pre>

<p>Ve druhé demonstrační aplikaci se taktéž provádí konstrukce řetězce
(z&nbsp;kratších částí) i konstrukce pole bajtů, ovšem tentokrát lokálně,
v&nbsp;rámci funkcí. To znamená, že reference na řetězec resp.&nbsp;na pole
bajtů existuje pouze pro lokální proměnnou viditelnou uvnitř funkce.
V&nbsp;praxi to znamená, že po opuštění funkce je reference ztracena a daná
hodnota (objekt) může být z&nbsp;paměti odstraněna. Úplný zdrojový kód této
aplikace lze nalézt na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app2.py</a>:</p>

<pre>
from time import sleep
&nbsp;
&nbsp;
def <strong>foo_construct</strong>():
    x = "*foo*"
&nbsp;
    sleep(2)
&nbsp;
    y = ""
    for i in range(20000000):
        y += x
&nbsp;
    print(len(y))
&nbsp;
&nbsp;
def <strong>bar_construct</strong>():
    x = bytearray(100000000)
    print(len(x))
    sleep(2)
&nbsp;
&nbsp;
sleep(2)
foo_construct()
sleep(2)
bar_construct()
sleep(2)
</pre>

<p>Ve třetí demonstrační aplikaci se v&nbsp;rámci funkce (tedy opět lokálně)
vytvoří seznam, do kterého se postupně přidávají nové prvky. Posléze začnou být
prvky ze seznamu odstraňovány příkazem <strong>del</strong>. Úplný zdrojový kód
této aplikace lze nalézt na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app3.py</a>:</p>

<pre>
from time import sleep
&nbsp;
&nbsp;
def <strong>foo_construct</strong>():
    l = []
    for i in range(10000000):
        l.append(i)
        if i % 100000 == 0:
            sleep(0.05)
&nbsp;
    for i in range(10000000, 0, -1):
        del l[i-1]
        if i % 100000 == 0:
            sleep(0.05)
&nbsp;
    sleep(2)
&nbsp;
&nbsp;
sleep(2)
foo_construct()
sleep(2)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Spuštění aplikace se sledováním práce s&nbsp;pamětí</h2>

<p>Nástroj <i>Memory profiler</i> je možné využít několika různými způsoby. Ten
nejjednodušší způsob spočívá v&nbsp;tom, že se sledovaná aplikace nespustí
přímo (tedy přesněji řečeno se nespustí její &bdquo;vstupní&ldquo; Pythonovský
skript), ale je spuštěna přes <strong>mprof</strong>. Memory profiler
v&nbsp;takovém případě začne sledovat paměť, kterou virtuální stroj Pythonu
alokuje a tuto informaci bude postupně ukládat do automaticky vytvořeného
textového souboru:</p>

<pre>
$ <strong>mprof run app1.py</strong>
&nbsp;
mprof: Sampling memory every 0.1s
running new process
running as a Python program...
1000000
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že časová granularita
sledování je (pro většinu po delší dobu běžících aplikací) velmi dobrá &ndash;
velikost obsazené paměti se získá a zapamatuje každých 100
milisekund.</div></p>

<p>Po doběhnutí aplikace by se měl v&nbsp;adresáři, z&nbsp;něhož bylo sledování
spuštěno, objevit soubor, jehož název odpovídá globu
&bdquo;mprofile_*.dat&ldquo;, kde se za hvězdičku doplňuje časové razítko
spuštění aplikace ve formátu YYYYMMDDhhmmss. To v&nbsp;mém konkrétním případě
znamená, že soubor s&nbsp;názvem <strong>mprofile_20230512085526</strong> byl
získán při sledování aplikace, která byla spuštěna 12.5.2023 v&nbsp;8:55:26.
Jedná se o textový soubor, který obsahuje informace o alokované paměti, přičemž
každý řádek byl do souboru přidán přibližně každých 100 milisekund.</p>

<p>Tento soubor si pochopitelně můžeme prohlédnout, ovšem nebudeme ho muset
zpracovávat přímo, protože pro zpracování nám nástroj <i>Memory profiler</i>
poskytuje několik technik:</p>

<pre>
$ <strong>head mprofile_20230512085526.dat</strong>
&nbsp;
CMDLINE /usr/bin/python3 app1.py
MEM 3.687500 1683874526.4900
MEM 18.460938 1683874526.5908
MEM 18.460938 1683874526.6918
MEM 18.460938 1683874526.7928
MEM 18.460938 1683874526.8935
MEM 18.460938 1683874526.9946
MEM 18.460938 1683874527.0954
MEM 18.460938 1683874527.1963
MEM 18.460938 1683874527.2973
...
...
...
$ <strong>tail mprofile_20230512085526.dat</strong>
MEM 19.316406 1683874537.5908
MEM 19.316406 1683874537.6915
MEM 19.316406 1683874537.7925
MEM 19.316406 1683874537.8932
MEM 19.316406 1683874537.9942
MEM 19.316406 1683874538.0951
MEM 19.316406 1683874538.1961
MEM 19.316406 1683874538.2971
MEM 19.316406 1683874538.3981
MEM 19.316406 1683874538.4991
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vyhodnocení a vizualizace obsazení paměti sledovanou aplikací</h2>

<p>První informací, kterou můžeme velmi snadno získat, je nejvyšší obsazená
kapacita operační paměti. Tuto informaci nám poskytne příkaz <strong>mprof
peak</strong>, který nalezne všechny soubory vygenerované <i>Memory
profilerem</i> a zobrazí informace z&nbsp;posledního souboru:</p>

<pre>
$ <strong>mprof peak</strong>
&nbsp;
Using last profile data.
mprofile_20230512085526.dat     19.801 MiB
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti si můžete vynutit získání
stejné informace ze všech souborů vygenerovaných Memory profilerem, a to
následujícím příkazem:</div></p>

<pre>
$ <strong>mprof peak *.dat</strong>
mprofile_20230512085526.dat     19.801 MiB
mprofile_20230512090927.dat     114.148 MiB
mprofile_20230512092839.dat     405.219 MiB
</pre>

<p>Vraťme se ovšem zpět k&nbsp;našemu jedinému souboru vytvořenému Memory
profilerem. Víme již, že tento soubor obsahuje informace o objemu obsazené
paměti s&nbsp;granularitou 0,1 sekundy a přesně tyto informace lze vizualizovat
do podoby jednoduchého grafu:</p>

<pre>
$ <strong>mprof plot</strong>
&nbsp;
Using last profile data.
</pre>

<p>Výsledek by měl vypadat následovně:</p>

*** image ***
<p><i>Obrázek 1: Výsledek vizualizace obsazení paměti sledovanou
aplikací.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Analýza grafu</h2>

<p>Povšimněte si, jak průběh grafu uvedeného <a href="#k05">v&nbsp;předchozí
kapitole</a> koresponduje se zdrojovým kódem testované aplikace (uvádím
zjednodušený výpis bez zbytečných importů atd.):</p>

<pre>
sleep(2)
&nbsp;
x = "*foo*"
&nbsp;
sleep(2)
&nbsp;
y = ""
for i in range(200000):
    y += x
&nbsp;
sleep(2)
&nbsp;
x = 0
y = 0
&nbsp;
sleep(2)
&nbsp;
x = bytearray(1000000)
&nbsp;
sleep(2)
&nbsp;
x = 0
&nbsp;
sleep(2)
</pre>

<p>Příkazy <strong>sleep</strong>, které aplikaci pozastaví na dvě sekundy, nám
umožňují zjistit, kdy a v&nbsp;jakém objemu došlo k&nbsp;alokaci paměti, ovšem
s&nbsp;tím, že prvotní nárůst na cca 18,46 MiB jde na vrub samotnému
interpretru Pythonu a jeho infrastruktuře. Pokusme se tedy jednotlivé části
kódu spojit s&nbsp;grafem:</p>

*** image ***
<p><i>Obrázek 2: Části kódu spuštěné na začátku každé &bdquo;periody&ldquo;
viditelné v&nbsp;grafu.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Sledování a analýza druhé i třetí aplikace</h2>

<p>Podívejme se nyní na analýzu druhé aplikace, v&nbsp;níž se provádí alokace
paměti lokálně, v&nbsp;rámci funkcí. Konkrétně je paměť alokována pro objekty,
které jsou lokální a můžeme tedy počítat s&nbsp;tím, že po opuštění dané funkce
dojde i k&nbsp;uvolnění příslušného paměťového bloku (ovšem tento předpoklad
nemusí být splněn, což uvidíme dále):</p>

<pre>
from time import sleep
&nbsp;
&nbsp;
def foo_construct():
    x = "*foo*"
&nbsp;
    sleep(2)
&nbsp;
    y = ""
    for i in range(20000000):
        y += x
&nbsp;
    print(len(y))
&nbsp;
&nbsp;
def bar_construct():
    x = bytearray(100000000)
    print(len(x))
    sleep(2)
&nbsp;
&nbsp;
sleep(2)
foo_construct()
sleep(2)
bar_construct()
sleep(2)
</pre>

<p>Aplikaci spustíme společně s&nbsp;jejím sledováním následovně:</p>

<pre>
$ <strong>mprof run app2.py</strong>
&nbsp;
mprof: Sampling memory every 0.1s
running new process
running as a Python program...
100000000
100000000
</pre>

<p>Nyní bude nejvyšší obsazená kapacita operační paměti již mnohem vyšší, než
tomu bylo u aplikace první:</p>

<pre>
$ <strong>mprof peak</strong>
&nbsp;
Using last profile data.
mprofile_20230512090927.dat     114.148 MiB
</pre>

<p>Mnohem lépe bude tento nárůst viditelný na grafu:</p>

<pre>
$ <strong>mprof plot</strong>
&nbsp;
Using last profile data.
</pre>

<p>Výsledek bude výsledek vypadat zcela odlišně:</p>

*** image ***
<p><i>Obrázek 3: Obsazení operační paměti druhou testovanou aplikací.</i></p>

<p>Podobně lze analyzovat aplikaci, v&nbsp;níž se postupně do seznamu přidávají
prvky a poté se opět ubírají (od konce seznamu &ndash; jinak se výsledku
nedočkáte :-):</p>

<pre>
from time import sleep
&nbsp;
&nbsp;
def <strong>foo_construct</strong>():
    l = []
    for i in range(10000000):
        l.append(i)
        if i % 100000 == 0:
            sleep(0.05)
&nbsp;
    for i in range(10000000, 0, -1):
        del l[i-1]
        if i % 100000 == 0:
            sleep(0.05)
&nbsp;
    sleep(2)
&nbsp;
&nbsp;
sleep(2)
foo_construct()
sleep(2)
</pre>

<p>Naměřený výsledek na mém počítači vypadá takto:</p>

*** image ***
<p><i>Obrázek 4: Obsazení operační paměti třetí testovanou aplikací.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Analýza grafu</h2>

<p>Analýza grafu zobrazeného <a href="#k07">v&nbsp;sedmé kapitole</a> na třetím
obrázku je nepatrně složitější, a to z&nbsp;toho důvodu, že programová
smyčka:</p>

<pre>
y = ""
for i in range(20000000):
    y += x
</pre>

<p>nebyla provedena ihned, ale trvala přibližně jednu sekundu. Vliv
jednotlivých příkazů na potřebnou kapacitu operační paměti bude
následující:</p>

*** image ***
<p><i>Obrázek 5: Vliv jednotlivých příkazů ve druhé testované aplikaci na
kapacitu obsazené operační paměti.</i></p>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak přesně odpovídají
zobrazené výsledky našemu očekávání. Znamená to, že správce paměti virtuálního
stroje Pythonu měl dostatek času na uvolnění alokované paměti a nemusel (na
pozadí) čekat na &bdquo;vhodnou příležitost&ldquo;.</div></p>

<p>Analýza grafu zobrazeného na čtvrtém obrázku je naproti tomu triviální:</p>

*** image ***
<p><i>Obrázek 6: Vliv jednotlivých příkazů ve třetí testované aplikaci na
kapacitu obsazené operační paměti.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Získání informací o alokované paměti na úrovni programových řádků</h2>

<p>Nástroj <i>Memory profiler</i> dokáže získat informace o tom, jakým způsobem
je paměť obsazována či naopak uvolňována, až na úrovni jednotlivých
programových řádků. Výsledky sice nebývají zcela dobře pochopitelné (jak
ostatně uvidíme dále), ovšem alespoň upozorní na ty části programového kódu, na
něž se může vývojář při optimalizacích zaměřit. Vzhledem k&nbsp;tomu, že se
jedná o již velmi detailní informace (jejichž získání je relativně zdlouhavé),
je nutné označit celé funkce nebo metody, jejichž analýza nás zajímá, anotací
<strong>@profile</strong>. Můžeme si například upravit první testovací příklad
následujícím způsobem, kterým se označí obě funkce ve skriptu:</p>

<pre>
from time import sleep
&nbsp;
&nbsp;
<u>@profile</u>
def <strong>foo_construct</strong>():
    x = "*foo*"
&nbsp;
    y = ""
    for i in range(200000):
        y += x
&nbsp;
    print(len(y))
&nbsp;
    del x
    del y
&nbsp;
&nbsp;
<u>@profile</u>
def <strong>bar_construct</strong>():
    x = bytearray(10000000)
    print(len(x))
    del x
&nbsp;
&nbsp;
foo_construct()
bar_construct()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výsledky analýzy</h2>

<p>Nyní je nutné aplikaci spustit takovým způsobem, že se jí předá jméno modulu
Memory profileru (to proto, aby byla načtena definice anotace
<strong>@profile</strong>). Konkrétně vypadá spuštění naší testovací aplikace
následovně:</p>

<pre>
$ <strong>python3 -m memory_profiler app4.py</strong>
&nbsp;
1000000
10000000
</pre>

<p>Výsledkem bude po dokončení běhu aplikace následující tabulka, v&nbsp;níž je
patrné, jak se měnila obsazená kapacita operační paměti po provedení
jednotlivých řádků. Navíc se zobrazí i celkový počet opakování daného
řádku:</p>

<pre>
Filename: app4.py
&nbsp;
Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     4   18.332 MiB   18.332 MiB           1   @profile
     5                                         def foo_construct():
     6   18.332 MiB    0.000 MiB           1       x = "*foo*"
     7                                         
     8   18.332 MiB    0.000 MiB           1       y = ""
     9   22.137 MiB -85881.301 MiB      200001       for i in range(200000):
    10   22.137 MiB -85877.496 MiB      200000           y += x
    11                                         
    12   22.004 MiB   -0.133 MiB           1       print(len(y))
    13                                         
    14   22.004 MiB    0.000 MiB           1       del x
    15   19.570 MiB   -2.434 MiB           1       del y
&nbsp;
&nbsp;
Filename: app4.py
&nbsp;
Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    18   19.570 MiB   19.570 MiB           1   @profile
    19                                         def bar_construct():
    20   29.105 MiB    9.535 MiB           1       x = bytearray(10000000)
    21   29.105 MiB    0.000 MiB           1       print(len(x))
    22   19.570 MiB   -9.535 MiB           1       del x
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si &bdquo;divných&ldquo;
hodnot ve sloupci <strong>Increment</strong>. Hodnotu v&nbsp;prvním řádku každé
funkce je možné ignorovat &ndash; anotace je zpracovávána již při načítání
skriptu a inicializaci virtuálního stroje Pythonu, který v&nbsp;tomto případě
vyžaduje přibližně 19 MiB pro svůj běh. Záporné hodnoty na řádcích 9-10 jsou
poněkud zavádějící, ale souvisí s&nbsp;tím, že se zde skutečně na pozadí
uvolňují řetězce, konkrétně předchozí hodnoty referencované z&nbsp;proměnné
<strong>y</strong>. Současně je však ze sloupce <strong>Mem usage</strong>
patrné, že se celková spotřeba paměti zvyšuje, nikoli snižuje (tento způsob
reportingu Memory profileru není zcela přehledný, nicméně obrovský objem
hlášený ve sloupci <strong>Increment</strong> by již měl dostačovat
k&nbsp;tomu, aby těmto řádkům vývojář věnoval pozornost).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Úprava aplikace přidávající a ubírající prvky ze seznamu</h2>

<p>Naprosto stejnou úpravu provedeme i u naší třetí testovací aplikace, která
postupně přidává prvky do seznamu a posléze je zase odebírá. Úprava je ve
skutečnosti triviální &ndash; postačuje totiž pouze přidat anotaci
<strong>@profile</strong> před testovanou funkcí:</p>

<pre>
from time import sleep
&nbsp;
&nbsp;
<u>@profile</u>
def <strong>foo_construct</strong>():
    l = []
    for i in range(100000):
        l.append(i)
&nbsp;
    for i in range(100000, 0, -1):
        del l[i-1]
&nbsp;
&nbsp;
foo_construct()
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód této miniaplikace naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app5.py</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výsledky analýzy</h2>

<p>Výsledky analýzy provedené <i>Memory profilerem</i> opět mohou být poněkud
matoucí (zejména sloupec <strong>Increment</strong>), ovšem i tak dobře
naznačují, na kterých řádcích zdrojového kódu se provádí alokace paměti
(přidávání prvků do seznamu) a její dealokace (odstraňování prvků z&nbsp;konce
seznamu):</p>

<pre>
$ <strong>python3 -m memory_profiler app5.py </strong>
&nbsp;
Filename: app5.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     4   18.312 MiB   18.312 MiB           1   @profile
     5                                         def foo_construct():
     6   18.312 MiB    0.000 MiB           1       l = []
     7   22.664 MiB    0.008 MiB      100001       for i in range(100000):
     8   22.664 MiB    4.344 MiB      100000           l.append(i)
     9                                         
    10   22.664 MiB -147352.746 MiB      100001       for i in range(100000, 0, -1):
    11   22.664 MiB -147352.746 MiB      100000           del l[i-1]
</pre>

<p><div class="rs-tip-major">Poznámka: oproti původní aplikaci byl počet
přidávaných a odebíraných prvků snížen, ovšem pro zajímavost si můžeme
otestovat chování i pro větší množství prvků (a tedy větší seznam), například
pro milion přidávaných a odebíraných prvků:</div></p>

<pre>
$ <strong>python3 -m memory_profiler app5.py </strong>
&nbsp;
Filename: app5.py
&nbsp;
Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     4   18.211 MiB   18.211 MiB           1   @profile
     5                                         def foo_construct():
     6   18.211 MiB    0.000 MiB           1       l = []
     7   57.199 MiB    0.117 MiB     1000001       for i in range(1000000):
     8   57.199 MiB   38.871 MiB     1000000           l.append(i)
     9                                         
    10   57.199 MiB -17654430.246 MiB     1000001       for i in range(1000000, 0, -1):
    11   57.199 MiB -17654430.246 MiB     1000000           del l[i-1]
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Měření spotřeby paměti u složitější aplikace</h2>

<p></p>

<pre>
&nbsp;
<i># Nutno importovat kvůli konstantám QUIT atd.</i>
from pygame.locals import *
&nbsp;
<i># Velikost okna aplikace</i>
WIDTH = 320
HEIGHT = 240
&nbsp;
&nbsp;
<i># Třída představující sprite zobrazený jako jednobarevný čtverec.</i>
class BlockySprite(pygame.sprite.Sprite):
    <i># Konstruktor</i>
    def __init__(self, color, size, x, y):
        <i># Nejprve je nutné zavolat konstruktor předka,</i>
        <i># tj. konstruktor třídy pygame.sprite.Sprite:</i>
        pygame.sprite.Sprite.__init__(self)
&nbsp;
        <i># Vytvoření obrázku představujícího vizuální obraz spritu:</i>
        self.image = pygame.Surface([size, size])
        self.image.fill(color)
&nbsp;
        <i># Vytvoření obalového obdélníku</i>
        <i># (velikost se získá z rozměru obrázku)</i>
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
&nbsp;
        <i># Počáteční rychlost spritu</i>
        self.speed_x = 0
        self.speed_y = 0
&nbsp;
    <i># Nastavení barvy spritu, který kolidoval s hráčem</i>
    def yellowColor(self):
        self.image.fill(YELLOW)
&nbsp;
    <i># Nastavení barvy spritu, který nekolidoval s hráčem</i>
    def grayColor(self):
        self.image.fill(GRAY)
&nbsp;
&nbsp;
<i># Inicializace knihovny Pygame</i>
pygame.init()
&nbsp;
clock = pygame.time.Clock()
&nbsp;
<i># Vytvoření okna pro vykreslování</i>
display = pygame.display.set_mode([WIDTH, HEIGHT])
&nbsp;
<i># Nastavení titulku okna</i>
pygame.display.set_caption("Pygame test <i>#22")</i>
&nbsp;
<i># Konstanty s n-ticemi představujícími základní barvy</i>
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GRAY = (128, 128, 128)
YELLOW = (255, 255, 0)
&nbsp;
<i># Objekt sdružující všechny sprity</i>
all_sprites = pygame.sprite.Group()
<i># Objekt sdružující všechny sprity kromě hráče</i>
all_sprites_but_player = pygame.sprite.Group()
&nbsp;
<i># Vytvoření několika typů spritů</i>
<i>#                    barva  x   y velikost</i>
wall1 = BlockySprite(GRAY, 50, 10, 10)
wall2 = BlockySprite(GRAY, 15, 100, 100)
wall3 = BlockySprite(GRAY, 15, 100, 150)
wall4 = BlockySprite(GRAY, 15, 200, 100)
wall5 = BlockySprite(GRAY, 15, 200, 150)
wall6 = BlockySprite(GRAY, 15, 150, 100)
wall7 = BlockySprite(GRAY, 15, 150, 150)
player = BlockySprite(RED, 40, WIDTH / 2 - 20, HEIGHT / 2 - 20)
&nbsp;
<i># Přidání několika dalších spritů do seznamu</i>
<i># (jen jeden sprite - ten poslední - bude ve skutečnosti pohyblivý)</i>
all_sprites.add(wall1)
all_sprites.add(wall2)
all_sprites.add(wall3)
all_sprites.add(wall4)
all_sprites.add(wall5)
all_sprites.add(wall6)
all_sprites.add(wall7)
all_sprites.add(player)
&nbsp;
<i># Seznam všech nepohyblivých spritů</i>
all_sprites_but_player.add(wall1)
all_sprites_but_player.add(wall2)
all_sprites_but_player.add(wall3)
all_sprites_but_player.add(wall4)
all_sprites_but_player.add(wall5)
all_sprites_but_player.add(wall6)
all_sprites_but_player.add(wall7)
&nbsp;
&nbsp;
<i># Posun všech spritů ve skupině na základě jejich rychlosti</i>
@profile
def move_sprites(sprite_group, playground_width, playground_height):
    for sprite in sprite_group:
        <i># Posun spritu</i>
        sprite.rect.x = sprite.rect.x + sprite.speed_x
        sprite.rect.y = sprite.rect.y + sprite.speed_y
        <i># Kontrola, zda sprite nenarazil do okrajů okna</i>
        if sprite.rect.x &lt; 0:
            sprite.rect.x = 0
            sprite.speed_x = 0
        if sprite.rect.x + sprite.rect.width &gt; playground_width:
            sprite.rect.x = playground_width - sprite.rect.width
            sprite.speed_x = 0
        if sprite.rect.y &lt; 0:
            sprite.rect.y = 0
            sprite.speed_y = 0
        if sprite.rect.y + sprite.rect.height &gt; playground_height:
            sprite.rect.y = playground_height - sprite.rect.height
            sprite.speed_y = 0
&nbsp;
&nbsp;
<i># Vykreslení celé scény na obrazovku</i>
@profile
def draw_scene(display, background_color, sprite_group):
    <i># Vyplnění plochy okna černou barvou</i>
    display.fill(background_color)
    <i># Vykreslení celé skupiny spritů do bufferu</i>
    sprite_group.draw(display)
    <i># Obnovení obsahu obrazovky (překlopení zadního a předního bufferu)</i>
    pygame.display.update()
&nbsp;
&nbsp;
<i># Změna barvy spritu na základě kolize s hráčem</i>
@profile
def change_colors(sprite_group, hit_list):
    <i># Projít všemi sprity ze skupiny, kterou detekovala kolizní funkce</i>
    for sprite in sprite_group:
        if sprite in hit_list:
            sprite.yellowColor()
        else:
            sprite.grayColor()
&nbsp;
&nbsp;
<i># Zjistí kolize spritu se "stěnami" (nepohyblivými sprity)</i>
@profile
def check_collisions(player, sprite_group):
    <i># Vytvoření seznamu spritů, které kolidují s hráčem</i>
    hit_list = pygame.sprite.spritecollide(player, sprite_group, False)
    <i># Změna barev kolidujících spritů</i>
    change_colors(sprite_group, hit_list)
    collisions = len(hit_list)
    <i># Přenastavení titulku okna</i>
    caption = "Pygame test <i>#22: collisions " + str(collisions)</i>
    pygame.display.set_caption(caption)
&nbsp;
&nbsp;
@profile
def mainLoop():
    while True:
        <i># Načtení a zpracování všech událostí z fronty</i>
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                <i># Stiskem kurzorových kláves je možné měnit směr pohybu spritu</i>
                elif event.key == pygame.K_LEFT:
                    player.speed_x = -3
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = +3
                elif event.key == pygame.K_UP:
                    player.speed_y = -3
                elif event.key == pygame.K_DOWN:
                    player.speed_y = +3
            if event.type == KEYUP:
                <i># Puštění kurzorových kláves vede k zastavení pohybu spritu</i>
                if event.key == pygame.K_LEFT:
                    player.speed_x = 0
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = 0
                elif event.key == pygame.K_UP:
                    player.speed_y = 0
                elif event.key == pygame.K_DOWN:
                    player.speed_y = 0
&nbsp;
        move_sprites(all_sprites, display.get_width(), display.get_height())
        check_collisions(player, all_sprites_but_player)
        draw_scene(display, BLACK, all_sprites)
        clock.tick(20)
&nbsp;
&nbsp;
mainLoop()
&nbsp;
<i># finito</i>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výsledky měření</h2>

<p></p>

<pre>
pygame 2.4.0 (SDL 2.26.4, Python 3.8.10)
Hello from the pygame community. https://www.pygame.org/contribute.html
Filename: sprites.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   105   87.551 MiB 10934.941 MiB         125   @profile
   106                                         def move_sprites(sprite_group, playground_width, playground_height):
   107   87.551 MiB    0.000 MiB        1125       for sprite in sprite_group:
   108                                                 # Posun spritu
   109   87.551 MiB    0.000 MiB        1000           sprite.rect.x = sprite.rect.x + sprite.speed_x
   110   87.551 MiB    0.000 MiB        1000           sprite.rect.y = sprite.rect.y + sprite.speed_y
   111                                                 # Kontrola, zda sprite nenarazil do okrajů okna
   112   87.551 MiB    0.000 MiB        1000           if sprite.rect.x &lt; 0:
   113                                                     sprite.rect.x = 0
   114                                                     sprite.speed_x = 0
   115   87.551 MiB    0.000 MiB        1000           if sprite.rect.x + sprite.rect.width &gt; playground_width:
   116                                                     sprite.rect.x = playground_width - sprite.rect.width
   117                                                     sprite.speed_x = 0
   118   87.551 MiB    0.000 MiB        1000           if sprite.rect.y &lt; 0:
   119                                                     sprite.rect.y = 0
   120                                                     sprite.speed_y = 0
   121   87.551 MiB    0.000 MiB        1000           if sprite.rect.y + sprite.rect.height &gt; playground_height:
   122                                                     sprite.rect.y = playground_height - sprite.rect.height
   123                                                     sprite.speed_y = 0


Filename: sprites.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   127   87.551 MiB 10934.941 MiB         125   @profile
   128                                         def draw_scene(display, background_color, sprite_group):
   129                                             # Vyplnění plochy okna černou barvou
   130   87.551 MiB    0.000 MiB         125       display.fill(background_color)
   131                                             # Vykreslení celé skupiny spritů do bufferu
   132   87.551 MiB    0.000 MiB         125       sprite_group.draw(display)
   133                                             # Obnovení obsahu obrazovky (překlopení zadního a předního bufferu)
   134   87.551 MiB    0.355 MiB         125       pygame.display.update()


Filename: sprites.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   138   87.551 MiB 10934.941 MiB         125   @profile
   139                                         def change_colors(sprite_group, hit_list):
   140                                             # Projít všemi sprity ze skupiny, kterou detekovala kolizní funkce
   141   87.551 MiB    0.000 MiB        1000       for sprite in sprite_group:
   142   87.551 MiB    0.000 MiB         875           if sprite in hit_list:
   143   87.551 MiB    0.000 MiB         111               sprite.yellowColor()
   144                                                 else:
   145   87.551 MiB    0.000 MiB         764               sprite.grayColor()


Filename: sprites.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   149   87.551 MiB 10934.941 MiB         125   @profile
   150                                         def check_collisions(player, sprite_group):
   151                                             # Vytvoření seznamu spritů, které kolidují s hráčem
   152   87.551 MiB    0.000 MiB         125       hit_list = pygame.sprite.spritecollide(player, sprite_group, False)
   153                                             # Změna barev kolidujících spritů
   154   87.551 MiB 10934.941 MiB         125       change_colors(sprite_group, hit_list)
   155   87.551 MiB    0.000 MiB         125       collisions = len(hit_list)
   156                                             # Přenastavení titulku okna
   157   87.551 MiB    0.000 MiB         125       caption = "Pygame test #22: collisions " + str(collisions)
   158   87.551 MiB    0.000 MiB         125       pygame.display.set_caption(caption)


Filename: sprites.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   161   87.195 MiB   87.195 MiB           1   @profile
   162                                         def mainLoop():
   163                                             while True:
   164                                                 # Načtení a zpracování všech událostí z fronty
   165   87.551 MiB    0.000 MiB         149           for event in pygame.event.get():
   166   87.551 MiB    0.000 MiB          24               if event.type == QUIT:
   167                                                         pygame.quit()
   168                                                         sys.exit()
   169   87.551 MiB    0.000 MiB          24               if event.type == KEYDOWN:
   170   87.551 MiB    0.000 MiB           7                   if event.key == K_ESCAPE:
   171   86.102 MiB   -1.449 MiB           1                       pygame.quit()
   172   86.102 MiB    0.000 MiB           1                       sys.exit()
   173                                                         # Stiskem kurzorových kláves je možné měnit směr pohybu spritu
   174   87.551 MiB    0.000 MiB           6                   elif event.key == pygame.K_LEFT:
   175   87.551 MiB    0.000 MiB           1                       player.speed_x = -3
   176   87.551 MiB    0.000 MiB           5                   elif event.key == pygame.K_RIGHT:
   177   87.551 MiB    0.000 MiB           2                       player.speed_x = +3
   178   87.551 MiB    0.000 MiB           3                   elif event.key == pygame.K_UP:
   179   87.551 MiB    0.000 MiB           1                       player.speed_y = -3
   180   87.551 MiB    0.000 MiB           2                   elif event.key == pygame.K_DOWN:
   181   87.551 MiB    0.000 MiB           2                       player.speed_y = +3
   182   87.551 MiB    0.000 MiB          23               if event.type == KEYUP:
   183                                                         # Puštění kurzorových kláves vede k zastavení pohybu spritu
   184   87.551 MiB    0.000 MiB           6                   if event.key == pygame.K_LEFT:
   185   87.551 MiB    0.000 MiB           1                       player.speed_x = 0
   186   87.551 MiB    0.000 MiB           5                   elif event.key == pygame.K_RIGHT:
   187   87.551 MiB    0.000 MiB           2                       player.speed_x = 0
   188   87.551 MiB    0.000 MiB           3                   elif event.key == pygame.K_UP:
   189   87.551 MiB    0.000 MiB           1                       player.speed_y = 0
   190   87.551 MiB    0.000 MiB           2                   elif event.key == pygame.K_DOWN:
   191   87.551 MiB    0.000 MiB           2                       player.speed_y = 0
   192                                         
   193   87.551 MiB 10934.941 MiB         125           move_sprites(all_sprites, display.get_width(), display.get_height())
   194   87.551 MiB 10934.941 MiB         125           check_collisions(player, all_sprites_but_player)
   195   87.551 MiB 10935.297 MiB         125           draw_scene(display, BLACK, all_sprites)
   196   87.551 MiB    0.000 MiB         125           clock.tick(20)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Spotřeba paměti u aplikací běžících ve větším množství procesů</h2>

<p>V&nbsp;závěrečné části dnešního článku si ukážeme, jakým způsobem je možné
nástrojem <i>Memory Profiler</i> sledovat spotřebu operační paměti
v&nbsp;případě, že Pythonovská aplikace (skript) spouští nějaké další procesy.
V&nbsp;takovém případě se sleduje buď celková spotřeba operační paměti
v&nbsp;daném okamžiku nebo individuální spotřeba jednotlivých procesů.
<i>Memory Profiler</i> podporuje, jak ostatně uvidíme v&nbsp;dalších třech
kapitolách, obě zmíněné možnosti.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Ukázka jednoduché aplikace, která spouští více souběžně běžících procesů</h2>

<p>V&nbsp;článku <a
href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">Souběžné
a paralelně běžící úlohy naprogramované v&nbsp;Pythonu</a> jsme si
mj.&nbsp;popsali i standardní modul pojmenovaný
<strong>multiprocesses</strong>. Tento modul vývojáře do značné míry odstiňuje
od nízkoúrovňových operací, tedy od samotného rozvětvení procesu (<i>fork</i>),
spuštění nového interpretru a specifikace, jaký kód má tento interpret použít.
Z&nbsp;pohledu vývojáře je totiž použití modulu
<strong>multiprocessing</strong> velmi přímočaré &ndash; pouze se zvolí, jaká
funkce se má zavolat v&nbsp;novém procesu a jaké mají být této funkci předány
argumenty. Navíc modul <strong>multiprocessing</strong> programátorům nabízí
mechanismy umožňující komunikaci mezi procesy a v&nbsp;neposlední řadě taktéž
čekání na dokončení spuštěného synovského procesu.</p>

<p>A právě tento modul využijeme v&nbsp;dalším demonstračním příkladu, který
v&nbsp;samostatných souběžně běžících synovských procesech spustí úlohy, které
již známe &ndash; postupnou konstrukci řetězce z&nbsp;kratších částí, což je
z&nbsp;hlediska spotřeby paměti velmi náročná operace. Navíc se (metoda
<strong>join</strong>) čeká na dokončení těchto procesů:</p>

<pre>
from multiprocessing import Process
from time import sleep
&nbsp;
&nbsp;
def <strong>worker</strong>(r):
    x = "*foo*"
&nbsp;
    y = ""
    for i in range(r):
        y += x
&nbsp;
    print(len(y))
    sleep(1)
    del y
    sleep(1)
&nbsp;
&nbsp;
def <strong>main</strong>():
    ps = []
&nbsp;
    for r in (10000000, 20000000, 30000000, 10000000):
        p = Process(target=worker, args=(r,))
        p.start()
        ps.append(p)
        sleep(0.2)
&nbsp;
    for p in ps:
        p.join()
&nbsp;
    sleep(2)
&nbsp;
&nbsp;
if __name__ == "__main__":
    print("Running main")
    main()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výsledky analýzy: celková spotřeba operační paměti</h2>

<p><a href="#k16">Výše uvedený</a> program po svém spuštění využil poměrně
velké množství operační paměti, ovšem tato paměť nebyla alokována původním
procesem, ale procesy synovskými (původní program vyžaduje přibližně 18 MiB pro
virtuální stroj Pythonu, ovšem mnohem více paměti vyžadují pro svůj běh
synovské procesy). Celkovou spotřebu paměti, což je důležitý údaj zejména pro
administrátory, zjistíme <i>Memory Profilerem</i> při použití přepínače
<strong>--include-children</strong>, který zajistí, že se spotřeba paměti pro
celý strom procesů v&nbsp;dané okamžiky měření sečte:</p>

<pre>
$ <strong>mprof run --include-children multiprocesses.py</strong>
&nbsp;
mprof: Sampling memory every 0.1s
running new process
running as a Python program...
Running main
50000000
50000000
100000000
150000000
</pre>

<p>Výsledky si opět necháme vykreslit do grafu:</p>

<pre>
$ <strong>mprof plot mprofile_20230513190727.dat</strong>
</pre>

<p>Výsledkem bude tento graf, z&nbsp;něhož je patrné, že <i>celková</i>
spotřeba operační paměti dosahuje 400 MiB. Daný bod největší spotřeby paměti
&ndash; <i>peak</i> &ndash; je na grafu zvýrazněn:</p>

*** image ***
<p><i>Obrázek 7: Celková spotřeba operační paměti zobrazená na grafu.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Výsledky analýzy: spotřeba rozdělená podle jednotlivých procesů</h2>

<p>Graf s&nbsp;celkovou spotřebou operační paměti lze použít ve chvíli, kdy je
zapotřebí změřit paměťové požadavky nasazované aplikace. Ovšem pro vývojáře
může být mnohem užitečnější zjištění, jakou spotřebu paměti mají jednotlivé
synovské procesy (a navíc v&nbsp;jakém čase). I tuto informaci lze
s&nbsp;využitím <i>Memory Profileru</i> změřit, pouze je zapotřebí použít
přepínač <strong>--multiprocess</strong>:</p>

<pre>
$ <strong>mprof run --multiprocess multiprocesses.py</strong>
&nbsp;
mprof: Sampling memory every 0.1s
running new process
Running main
50000000
50000000
100000000
150000000
</pre>

<p>Výsledkem nyní bude datový soubor obsahující odlišně zapsané informace
(povšimněte si nových řádků začínajících na &bdquo;CHLD&ldquo;):</p>

<pre>
CMDLINE /usr/bin/python3 multiprocesses.py
MEM 1.683594 1683997647.0138
MEM 10.714844 1683997647.1216
CHLD 21871 12.796875 1683997647.1277
MEM 10.714844 1683997647.2279
CHLD 21871 19.632812 1683997647.2337
MEM 10.718750 1683997647.3340
CHLD 21871 26.343750 1683997647.3401
CHLD 21872 13.832031 1683997647.3401
MEM 10.718750 1683997647.4405
CHLD 21871 32.804688 1683997647.4464
CHLD 21872 20.675781 1683997647.4464
...
...
...
</pre>

<p>Z&nbsp;grafu, který Memory Profiler vytvoří, je nyní patrné, že každý
synovský proces dosáhne nějaké maximální spotřeby paměti, v&nbsp;tomto stavu
počká sekundu, dále je naalokovaný řetězec smazán (a paměť se uvolní), počká se
další sekundu a až poté je proces následně je ukončen:</p>

*** image ***
<p><i>Obrázek 8: Spotřeba paměti rodičovského procesu i všech synovských
procesů.</i></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>getsizeof1.py</td><td>získání nápovědy k&nbsp;funkci <strong>getsizeof</strong> z&nbsp;balíčku <strong>sys</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof1.py</a></td></tr>
<tr><td> 2</td><td>getsizeof2.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof2.py</a></td></tr>
<tr><td> 3</td><td>getsizeof3.py</td><td>získání a tisk velikosti kontejnerů Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof3.py</a></td></tr>
<tr><td> 4</td><td>getsizeof4.py</td><td>získání a tisk velikosti funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof4.py</a></td></tr>
<tr><td> 5</td><td>getsizeof5.py</td><td>získání a tisk velikosti tříd a objektů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof5.py</a></td></tr>
<tr><td> 6</td><td>getsizeof6.py</td><td>získání a tisk velikosti tříd a objektů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof6.py</a></td></tr>
<tr><td> 7</td><td>getsizeof7.py</td><td>velikost kolekcí obsahujících velké prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof7.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>asizeof01.py</td><td>získání nápovědy k&nbsp;balíčku <strong>pympler.asizeof</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof01.py</a></td></tr>
<tr><td> 9</td><td>asizeof02.py</td><td>všechny veřejné atributy balíčku <strong>pympler.asizeof</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof02.py</a></td></tr>
<tr><td>10</td><td>asizeof03.py</td><td>získání nápovědy k&nbsp;funkci <strong>asizeof</strong> z&nbsp;balíčku <strong>pympler.asizeof</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof03.py</a></td></tr>
<tr><td>11</td><td>asizeof04.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof04.py</a></td></tr>
<tr><td>12</td><td>asizeof05.py</td><td>získání a tisk velikosti kontejnerů Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof05.py</a></td></tr>
<tr><td>13</td><td>asizeof06.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu se statistikou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof06.py</a></td></tr>
<tr><td>14</td><td>asizeof07.py</td><td>získání a tisk velikosti kontejnerů Pythonu se statistikou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof07.py</a></td></tr>
<tr><td>15</td><td>asizeof08.py</td><td>získání a tisk velikosti funkcí bez parametru <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof08.py</a></td></tr>
<tr><td>16</td><td>asizeof09.py</td><td>získání a tisk velikosti funkcí s&nbsp;parametrem <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof09.py</a></td></tr>
<tr><td>17</td><td>asizeof10.py</td><td>získání a tisk velikosti tříd a objektů bez parametru <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof10.py</a></td></tr>
<tr><td>18</td><td>asizeof11.py</td><td>získání a tisk velikosti tříd a objektů s&nbsp;parametrem <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py</a></td></tr>
<tr><td>19</td><td>asizeof12.py</td><td>velikost kolekcí obsahujících velké prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>app1.py</td><td>aplikace alokující velké řetězce a bytové pole</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app1.py</a></td></tr>
<tr><td>21</td><td>app2.py</td><td>lokální proměnné s&nbsp;velkými řetězci a bytovými poli</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app2.py</a></td></tr>
<tr><td>22</td><td>app3.py</td><td>přidávání a ubírání prvků do rozsáhlých seznamů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app3.py</a></td></tr>
<tr><td>23</td><td>app4.py</td><td>příklad použití anotace @profile</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app4.py</a></td></tr>
<tr><td>24</td><td>app5.py</td><td>příklad použití anotace @profile</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>sprites.py</td><td>sprity a knihovna Pygame</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/sprites.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/sprites.py</a></td></tr>
<tr><td>26</td><td>multiprocesses.py</td><td>skript, který spustí několik souběžně běžících synovských procesů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/multiprocesses.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/multiprocesses.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Top 5 Python Memory Profilers<br />
<a href="https://stackify.com/top-5-python-memory-profilers/">https://stackify.com/top-5-python-memory-profilers/</a>
</li>

<li>Pympler na GitHubu<br />
<a href="https://github.com/pympler/pympler">https://github.com/pympler/pympler</a>
</li>

<li>Pympler na PyPI<br />
<a href="https://pypi.org/project/Pympler/">https://pypi.org/project/Pympler/</a>
</li>

<li>Dokumentace k&nbsp;balíčku Pympler<br />
<a href="https://pympler.readthedocs.io/en/latest/">https://pympler.readthedocs.io/en/latest/</a>
</li>

<li>Guppy 3 na GitHubu<br />
<a href="https://github.com/zhuyifei1999/guppy3/">https://github.com/zhuyifei1999/guppy3/</a>
</li>

<li>Guppy 3 na PyPI<br />
<a href="https://pypi.org/project/guppy3/">https://pypi.org/project/guppy3/</a>
</li>

<li>Memory Profiler na GitHubu<br />
<a href="https://github.com/pythonprofilers/memory_profiler">https://github.com/pythonprofilers/memory_profiler</a>
</li>

<li>Memory Profiler na PyPI<br />
<a href="https://pypi.org/project/memory-profiler/">https://pypi.org/project/memory-profiler/</a>
</li>

<li>How to use guppy/heapy for tracking down memory usage<br />
<a href="https://smira.ru/wp-content/uploads/2011/08/heapy.html">https://smira.ru/wp-content/uploads/2011/08/heapy.html</a>
</li>

<li>Identifying memory leaks<br />
<a href="https://pympler.readthedocs.io/en/latest/muppy.html#muppy">https://pympler.readthedocs.io/en/latest/muppy.html#muppy</a>
</li>

<li>How do I determine the size of an object in Python?<br />
<a href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python</a>
</li>

<li>Why is bool a subclass of int?<br />
<a href="https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int">https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int</a>
</li>

<li>Memory Management in Python<br />
<a href="https://realpython.com/python-memory-management/">https://realpython.com/python-memory-management/</a>
</li>

<li>Why do ints require three times as much memory in Python?<br />
<a href="https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python">https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python</a>
</li>

<li>cpython/Include/cpython/longintrepr.h<br />
<a href="https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64">https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64</a>
</li>

<li>sys — System-specific parameters and functions<br />
<a href="https://docs.python.org/3/library/sys.html">https://docs.python.org/3/library/sys.html</a>
</li>

<li>Python 3.3 s&nbsp;flexibilní reprezentací řetězců<br />
<a href="https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/#k17">https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/#k17</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

