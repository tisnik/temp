<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Sledování využití paměti Pythonovských aplikací nástrojem Memory profiler</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Sledování využití paměti Pythonovských aplikací nástrojem Memory profiler</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Sledování využití paměti Pythonovských aplikací nástrojem Memory profiler</a></p>
<p><a href="#k02">2. Instalace nástroje Memory profiler</a></p>
<p><a href="#k03">3. Sledované demonstrační aplikace</a></p>
<p><a href="#k04">4. Spuštění aplikace se sledováním práce s&nbsp;pamětí</a></p>
<p><a href="#k05">5. Vyhodnocení a vizualizace obsazení paměti sledovanou aplikací</a></p>
<p><a href="#k06">6. Analýza grafu</a></p>
<p><a href="#k07">7. Sledování a analýza druhé aplikace</a></p>
<p><a href="#k08">8. Analýza grafu</a></p>
<p><a href="#k09">*** 9. Získání informací o alokované paměti na úrovni programových řádků</a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Sledování využití paměti Pythonovských aplikací nástrojem Memory profiler</h2>

<p>V&nbsp;dnešním článku si ukážeme, jakým způsobem lze využít nástroj nazvaný
<i>Memory profiler</i> pro sledování využití paměti aplikacemi, které jsou
naprogramovány <a href="https://www.root.cz/n/python/">v&nbsp;jazyku
Python</a>. Navážeme tak na předchozí článek nazvaný <a
href="https://www.root.cz/clanky/detekce-velikosti-hodnot-ulozenych-v-operacni-pameti-a-spravovanych-interpretrem-pythonu/">Detekce
velikosti hodnot uložených v&nbsp;operační paměti a spravovaných interpretrem
Pythonu</a>, který byl zaměřen na nástroje (resp.&nbsp;přesněji řečeno balíčky)
<i>Pympler</i> a taktéž <i>Guppy</i>.</p>

<p>Připomeňme si, že jak <i>Pympler</i>, tak i <i>Guppy</i> dokážou poměrně
přesně zjistit, jaké hodnoty (objekty) a s&nbsp;jakou velikostí jsou
<i>v&nbsp;daný okamžik</i> používány interpretrem Pythonu. Dnes popisovaný
nástroj <i>Memory profiler</i> je poněkud odlišný, protože navíc umožňuje, aby
se informace o obsazené paměti získávala kontinuálně po celou dobu běhu
aplikace, s&nbsp;následnou vizualizací obsazení paměti ve formě jednoduchých
grafů. Navíc je možné do jednoho grafu vykreslit několik průběhů získaných
během několika běhů sledované aplikace (například s&nbsp;nastavením různých
parametrů, s&nbsp;přepnutím algoritmů atd.). Navíc je možné získat informace o
spotřebě paměti s&nbsp;velmi dobrou přesností (resp.&nbsp;granularitou) &ndash;
až na úrovni jednotlivých programových řádků (můžeme tedy velmi snadno
detekovat ty programové řádky, v&nbsp;nichž se alokují velké paměťové bloky
&ndash; což budou typicky operace s&nbsp;objemnými objekty).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace nástroje Memory profiler</h2>

<p>Díky tomu, že je balíček s&nbsp;nástrojem <i>Memory profiler</i>
zaregistrovaný na <i>PyPi</i>, je instalace tohoto balíčku triviální a můžeme
ji provést (pro právě přihlášeného uživatele) následujícím příkazem:</p>

<pre>
$ <strong>pip3 install --user memory_profiler</strong>
</pre>

<p>Samotná instalace proběhne prakticky okamžitě:</p>

<pre>
Collecting memory_profiler
  Downloading memory_profiler-0.61.0-py3-none-any.whl (31 kB)
Requirement already satisfied: psutil in /usr/lib/python3/dist-packages (from memory_profiler) (5.5.1)
Installing collected packages: memory-profiler
Successfully installed memory-profiler-0.61.0
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě je možné instalaci provést i
do virtuálního prostředí Pythonu, pokud je to zapotřebí.</div></p>

<p>Součástí instalace nástroje <i>Memory Profiler</i> by měl být i spustitelný
soubor nazvaný <strong>mprof</strong>, takže si otestujme, zda existuje a je
skutečně spustitelný:</p>

<pre>
$ <strong>whereis mprof</strong>
&nbsp;
mprof: /home/ptisnovs/.local/bin/mprof
</pre>

<p>Pokud byl soubor nalezen, můžeme ho spustit a vypsat si nápovědu:</p>

<pre>
$ <strong>mprof</strong>
&nbsp;
Usage: mprof &lt;command&gt; &lt;options&gt; &lt;arguments&gt;
&nbsp;
Available commands:
&nbsp;
    run      run a given command or python file
    attach   alias for 'run --attach': attach to an existing process by pid or name
    rm       remove a given file generated by mprof
    clean    clean the current directory from files created by mprof
    list     display existing profiles, with indices
    plot     plot memory consumption generated by mprof run
    peak     print the maximum memory used by an mprof run
&nbsp;
Type mprof &lt;command&gt; --help for usage help on a specific command.
For example, mprof plot --help will list all plotting options.
</pre>

<p><div class="rs-tip-major">Poznámka: aby bylo možné <strong>mprof</strong>
spustit i bez nutnosti uvedení cesty k&nbsp;němu, musí být
<strong>./local/bin</strong> přidáno do proměnné prostředí
<strong>PATH</strong>. I tuto skutečnost si můžeme velmi snadno
ověřit:</div></p>

<pre>
$ <strong>echo $PATH</strong>
&nbsp;
/home/ptisnovs/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/opt/go/bin/:/home/ptisnovs/go/bin/:<u>/home/ptisnovs/.local/bin</u>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Sledované demonstrační aplikace</h2>

<p>V&nbsp;navazujících kapitolách si základní možnosti nabízené nástrojem
<i>Memory profiler</i> ukážeme na několika demonstračních
&bdquo;aplikacích&ldquo;, které v&nbsp;průběhu své činnosti provádí alokaci
paměti popř.&nbsp;(i když v&nbsp;Pythonu nepřímo) její dealokaci. Mezi
jednotlivé operace je vždy vložen příkaz <strong>sleep(2)</strong>, což nám
umožní lépe sledovat vliv jednotlivých příkazů na spotřebu operační paměti na
grafech, které <i>Memory profiler</i> dokáže vykreslit.</p>

<p>První aplikace nejdříve v&nbsp;programové smyčce vytvoří delší řetězec, na
který (po uplynutí dvou sekund) ztratí referenci, protože se do původní
proměnné vloží odlišná hodnota (připomeňme si, že v&nbsp;proměnných jsou
uloženy pouze reference na hodnoty, nikoli samotné hodnoty). Následně se
provede alokace pole bajtů (<i>bytearray</i>) a po uplynutí dvou sekund
ztratíme referenci i na toto pole. Úplný zdrojový kód této aplikace lze nalézt
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app1.py</a>:</p>

<pre>
from time import sleep
&nbsp;
sleep(2)
&nbsp;
x = "*foo*"
&nbsp;
sleep(2)
&nbsp;
y = ""
for i in range(200000):
    y += x
&nbsp;
print(len(y))
&nbsp;
sleep(2)
&nbsp;
x = 0
y = 0
&nbsp;
sleep(2)
&nbsp;
x = bytearray(1000000)
&nbsp;
sleep(2)
&nbsp;
x = 0
&nbsp;
sleep(2)
</pre>

<p>Ve druhé demonstrační aplikaci se taktéž provádí konstrukce řetězce
(z&nbsp;kratších částí) i konstrukce pole bajtů, ovšem tentokrát lokálně,
v&nbsp;rámci funkcí. To znamená, že reference na řetězec resp.&nbsp;na pole
bajtů existuje pouze pro lokální proměnnou viditelnou uvnitř funkce.
V&nbsp;praxi to znamená, že po opuštění funkce je reference ztracena a daná
hodnota (objekt) může být z&nbsp;paměti odstraněna. Úplný zdrojový kód této
aplikace lze nalézt na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app2.py</a>:</p>

<pre>
from time import sleep
&nbsp;
&nbsp;
def <strong>foo_construct</strong>():
    x = "*foo*"
&nbsp;
    sleep(2)
&nbsp;
    y = ""
    for i in range(20000000):
        y += x
&nbsp;
    print(len(y))
&nbsp;
&nbsp;
def <strong>bar_construct</strong>():
    x = bytearray(100000000)
    print(len(x))
    sleep(2)
&nbsp;
&nbsp;
sleep(2)
foo_construct()
sleep(2)
bar_construct()
sleep(2)
</pre>

<p>Ve třetí demonstrační aplikaci se v&nbsp;rámci funkce (tedy opět lokálně)
vytvoří seznam, do kterého se postupně přidávají nové prvky. Posléze začnou být
prvky ze seznamu odstraňovány příkazem <strong>del</strong>. Úplný zdrojový kód
této aplikace lze nalézt na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app3.py</a>:</p>

<pre>
from time import sleep
&nbsp;
&nbsp;
def <strong>foo_construct</strong>():
    l = []
    for i in range(10000000):
        l.append(i)
        if i % 100000 == 0:
            sleep(0.05)
&nbsp;
    for i in range(10000000, 0, -1):
        del l[i-1]
        if i % 100000 == 0:
            sleep(0.05)
&nbsp;
    sleep(2)
&nbsp;
&nbsp;
sleep(2)
foo_construct()
sleep(2)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Spuštění aplikace se sledováním práce s&nbsp;pamětí</h2>

<p>Nástroj <i>Memory profiler</i> je možné využít několika různými způsoby. Ten
nejjednodušší způsob spočívá v&nbsp;tom, že se sledovaná aplikace nespustí
přímo (tedy přesněji řečeno se nespustí její &bdquo;vstupní&ldquo; Pythonovský
skript), ale je spuštěna přes <strong>mprof</strong>. Memory profiler
v&nbsp;takovém případě začne sledovat paměť, kterou virtuální stroj Pythonu
alokuje a tuto informaci bude postupně ukládat do automaticky vytvořeného
textového souboru:</p>

<pre>
$ <strong>mprof run app1.py</strong>
&nbsp;
mprof: Sampling memory every 0.1s
running new process
running as a Python program...
1000000
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že časová granularita
sledování je (pro většinu po delší dobu běžících aplikací) velmi dobrá &ndash;
velikost obsazené paměti se získá a zapamatuje každých 100
milisekund.</div></p>

<p>Po doběhnutí aplikace by se měl v&nbsp;adresáři, z&nbsp;něhož bylo sledování
spuštěno, objevit soubor, jehož název odpovídá globu
&bdquo;mprofile_*.dat&ldquo;, kde se za hvězdičku doplňuje časové razítko
spuštění aplikace ve formátu YYYYMMDDhhmmss. To v&nbsp;mém konkrétním případě
znamená, že soubor s&nbsp;názvem <strong>mprofile_20230512085526</strong> byl
získán při sledování aplikace, která byla spuštěna 12.5.2023 v&nbsp;8:55:26.
Jedná se o textový soubor, který obsahuje informace o alokované paměti, přičemž
každý řádek byl do souboru přidán přibližně každých 100 milisekund.</p>

<p>Tento soubor si pochopitelně můžeme prohlédnout, ovšem nebudeme ho muset
zpracovávat přímo, protože pro zpracování nám nástroj <i>Memory profiler</i>
poskytuje několik technik:</p>

<pre>
$ <strong>head mprofile_20230512085526.dat</strong>
&nbsp;
CMDLINE /usr/bin/python3 app1.py
MEM 3.687500 1683874526.4900
MEM 18.460938 1683874526.5908
MEM 18.460938 1683874526.6918
MEM 18.460938 1683874526.7928
MEM 18.460938 1683874526.8935
MEM 18.460938 1683874526.9946
MEM 18.460938 1683874527.0954
MEM 18.460938 1683874527.1963
MEM 18.460938 1683874527.2973
...
...
...
$ <strong>tail mprofile_20230512085526.dat</strong>
MEM 19.316406 1683874537.5908
MEM 19.316406 1683874537.6915
MEM 19.316406 1683874537.7925
MEM 19.316406 1683874537.8932
MEM 19.316406 1683874537.9942
MEM 19.316406 1683874538.0951
MEM 19.316406 1683874538.1961
MEM 19.316406 1683874538.2971
MEM 19.316406 1683874538.3981
MEM 19.316406 1683874538.4991
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vyhodnocení a vizualizace obsazení paměti sledovanou aplikací</h2>

<p>První informací, kterou můžeme velmi snadno získat, je nejvyšší obsazená
kapacita operační paměti. Tuto informaci nám poskytne příkaz <strong>mprof
peak</strong>, který nalezne všechny soubory vygenerované <i>Memory
profilerem</i> a zobrazí informace z&nbsp;posledního souboru:</p>

<pre>
$ <strong>mprof peak</strong>
&nbsp;
Using last profile data.
mprofile_20230512085526.dat     19.801 MiB
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti si můžete vynutit získání
stejné informace ze všech souborů vygenerovaných Memory profilerem, a to
následujícím příkazem:</div></p>

<pre>
$ <strong>mprof peak *.dat</strong>
mprofile_20230512085526.dat     19.801 MiB
mprofile_20230512090927.dat     114.148 MiB
mprofile_20230512092839.dat     405.219 MiB
</pre>

<p>Vraťme se ovšem zpět k&nbsp;našemu jedinému souboru vytvořenému Memory
profilerem. Víme již, že tento soubor obsahuje informace o objemu obsazené
paměti s&nbsp;granularitou 0,1 sekundy a přesně tyto informace lze vizualizovat
do podoby jednoduchého grafu:</p>

<pre>
$ <strong>mprof plot</strong>
&nbsp;
Using last profile data.
</pre>

<p>Výsledek by měl vypadat následovně:</p>

*** image ***
<p><i>Obrázek 1: Výsledek vizualizace obsazení paměti sledovanou
aplikací.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Analýza grafu</h2>

<p>Povšimněte si, jak průběh grafu uvedeného <a href="#k05">v&nbsp;předchozí
kapitole</a> koresponduje se zdrojovým kódem testované aplikace (uvádím
zjednodušený výpis bez zbytečných importů atd.):</p>

<pre>
sleep(2)
&nbsp;
x = "*foo*"
&nbsp;
sleep(2)
&nbsp;
y = ""
for i in range(200000):
    y += x
&nbsp;
sleep(2)
&nbsp;
x = 0
y = 0
&nbsp;
sleep(2)
&nbsp;
x = bytearray(1000000)
&nbsp;
sleep(2)
&nbsp;
x = 0
&nbsp;
sleep(2)
</pre>

<p>Příkazy <strong>sleep</strong>, které aplikaci pozastaví na dvě sekundy, nám
umožňují zjistit, kdy a v&nbsp;jakém objemu došlo k&nbsp;alokaci paměti, ovšem
s&nbsp;tím, že prvotní nárůst na cca 18,46 MiB jde na vrub samotnému
interpretru Pythonu a jeho infrastruktuře. Pokusme se tedy jednotlivé části
kódu spojit s&nbsp;grafem:</p>

*** image ***
<p><i>Obrázek 2: Části kódu spuštěné na začátku každé &bdquo;periody&ldquo;
viditelné v&nbsp;grafu.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Sledování a analýza druhé aplikace</h2>

<p>Podívejme se nyní na analýzu druhé aplikace, v&nbsp;níž se provádí alokace
paměti lokálně, v&nbsp;rámci funkcí. Konkrétně je paměť alokována pro objekty,
které jsou lokální a můžeme tedy počítat s&nbsp;tím, že po opuštění dané funkce
dojde i k&nbsp;uvolnění příslušného paměťového bloku (ovšem tento předpoklad
nemusí být splněn, což uvidíme dále):</p>

<pre>
from time import sleep
&nbsp;
&nbsp;
def foo_construct():
    x = "*foo*"
&nbsp;
    sleep(2)
&nbsp;
    y = ""
    for i in range(20000000):
        y += x
&nbsp;
    print(len(y))
&nbsp;
&nbsp;
def bar_construct():
    x = bytearray(100000000)
    print(len(x))
    sleep(2)
&nbsp;
&nbsp;
sleep(2)
foo_construct()
sleep(2)
bar_construct()
sleep(2)
</pre>

<p>Aplikaci spustíme společně s&nbsp;jejím sledováním následovně:</p>

<pre>
$ <strong>mprof run app2.py</strong>
&nbsp;
mprof: Sampling memory every 0.1s
running new process
running as a Python program...
100000000
100000000
</pre>

<p>Nyní bude nejvyšší obsazená kapacita operační paměti již mnohem vyšší, než
tomu bylo u aplikace první:</p>

<pre>
$ <strong>mprof peak</strong>
&nbsp;
Using last profile data.
mprofile_20230512090927.dat     114.148 MiB
</pre>

<p>Mnohem lépe bude tento nárůst viditelný na grafu:</p>

<pre>
$ <strong>mprof plot</strong>
&nbsp;
Using last profile data.
</pre>

<p>Výsledek bude výsledek vypadat zcela odlišně:</p>

*** image ***
<p><i>Obrázek 3: Obsazení operační paměti druhou testovanou aplikací.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Analýza grafu</h2>

<p>Analýza grafu zobrazeného <a href="#k07">v&nbsp;sedmé kapitole</a> je
nepatrně složitější, a to z&nbsp;toho důvodu, že programová smyčka:</p>

<pre>
y = ""
for i in range(20000000):
    y += x
</pre>

<p>nebyla provedena ihned, ale trvala přibližně jednu sekundu. Vliv
jednotlivých příkazů na potřebnou kapacitu operační paměti bude
následující:</p>

*** image ***
<p><i>Obrázek 4: Vliv jednotlivých příkazů v&nbsp;testované aplikaci na
kapacitu obsazené operační paměti.</i></p>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak přesně odpovídají
zobrazené výsledky našemu očekávání. Znamená to, že správce paměti virtuálního
stroje Pythonu měl dostatek času na uvolnění alokované paměti a nemusel (na
pozadí) čekat na &bdquo;vhodnou příležitost&ldquo;.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Získání informací o alokované paměti na úrovni programových řádků</h2>

<p></p>

<pre>
from time import sleep
&nbsp;
&nbsp;
<u>@profile</u>
def <strong>foo_construct</strong>():
    x = "*foo*"
&nbsp;
    y = ""
    for i in range(200000):
        y += x
&nbsp;
    print(len(y))
&nbsp;
    del x
    del y
&nbsp;
&nbsp;
<u>@profile</u>
def <strong>bar_construct</strong>():
    x = bytearray(10000000)
    print(len(x))
    del x
&nbsp;
&nbsp;
foo_construct()
bar_construct()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<p></p>

<pre>
$ <strong>python3 -m memory_profiler app4.py </strong>
1000000
10000000
</pre>

<pre>
Filename: app4.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     4   18.332 MiB   18.332 MiB           1   @profile
     5                                         def foo_construct():
     6   18.332 MiB    0.000 MiB           1       x = "*foo*"
     7                                         
     8   18.332 MiB    0.000 MiB           1       y = ""
     9   22.137 MiB -85881.301 MiB      200001       for i in range(200000):
    10   22.137 MiB -85877.496 MiB      200000           y += x
    11                                         
    12   22.004 MiB   -0.133 MiB           1       print(len(y))
    13                                         
    14   22.004 MiB    0.000 MiB           1       del x
    15   19.570 MiB   -2.434 MiB           1       del y


Filename: app4.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    18   19.570 MiB   19.570 MiB           1   @profile
    19                                         def bar_construct():
    20   29.105 MiB    9.535 MiB           1       x = bytearray(10000000)
    21   29.105 MiB    0.000 MiB           1       print(len(x))
    22   19.570 MiB   -9.535 MiB           1       del x
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<p></p>

<pre>
from time import sleep


@profile
def foo_construct():
    l = []
    for i in range(100000):
        l.append(i)

    for i in range(100000, 0, -1):
        del l[i-1]


foo_construct()
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
$ <strong>python3 -m memory_profiler app5.py </strong>
&nbsp;
Filename: app5.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     4   18.312 MiB   18.312 MiB           1   @profile
     5                                         def foo_construct():
     6   18.312 MiB    0.000 MiB           1       l = []
     7   22.664 MiB    0.008 MiB      100001       for i in range(100000):
     8   22.664 MiB    4.344 MiB      100000           l.append(i)
     9                                         
    10   22.664 MiB -147352.746 MiB      100001       for i in range(100000, 0, -1):
    11   22.664 MiB -147352.746 MiB      100000           del l[i-1]
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
#!/usr/bin/python
# vim: set fileencoding=utf-8

import pygame
import sys

# Nutno importovat kvůli konstantám QUIT atd.
from pygame.locals import *

# Velikost okna aplikace
WIDTH = 320
HEIGHT = 240


# Třída představující sprite zobrazený jako jednobarevný čtverec.
class BlockySprite(pygame.sprite.Sprite):
    # Konstruktor
    def __init__(self, color, size, x, y):
        # Nejprve je nutné zavolat konstruktor předka,
        # tj. konstruktor třídy pygame.sprite.Sprite:
        pygame.sprite.Sprite.__init__(self)

        # Vytvoření obrázku představujícího vizuální obraz spritu:
        self.image = pygame.Surface([size, size])
        self.image.fill(color)

        # Vytvoření obalového obdélníku
        # (velikost se získá z rozměru obrázku)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

        # Počáteční rychlost spritu
        self.speed_x = 0
        self.speed_y = 0

    # Nastavení barvy spritu, který kolidoval s hráčem
    def yellowColor(self):
        self.image.fill(YELLOW)

    # Nastavení barvy spritu, který nekolidoval s hráčem
    def grayColor(self):
        self.image.fill(GRAY)


# Inicializace knihovny Pygame
pygame.init()

clock = pygame.time.Clock()

# Vytvoření okna pro vykreslování
display = pygame.display.set_mode([WIDTH, HEIGHT])

# Nastavení titulku okna
pygame.display.set_caption("Pygame test #22")

# Konstanty s n-ticemi představujícími základní barvy
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GRAY = (128, 128, 128)
YELLOW = (255, 255, 0)

# Objekt sdružující všechny sprity
all_sprites = pygame.sprite.Group()
# Objekt sdružující všechny sprity kromě hráče
all_sprites_but_player = pygame.sprite.Group()

# Vytvoření několika typů spritů
#                    barva  x   y velikost
wall1 = BlockySprite(GRAY, 50, 10, 10)
wall2 = BlockySprite(GRAY, 15, 100, 100)
wall3 = BlockySprite(GRAY, 15, 100, 150)
wall4 = BlockySprite(GRAY, 15, 200, 100)
wall5 = BlockySprite(GRAY, 15, 200, 150)
wall6 = BlockySprite(GRAY, 15, 150, 100)
wall7 = BlockySprite(GRAY, 15, 150, 150)
player = BlockySprite(RED, 40, WIDTH / 2 - 20, HEIGHT / 2 - 20)

# Přidání několika dalších spritů do seznamu
# (jen jeden sprite - ten poslední - bude ve skutečnosti pohyblivý)
all_sprites.add(wall1)
all_sprites.add(wall2)
all_sprites.add(wall3)
all_sprites.add(wall4)
all_sprites.add(wall5)
all_sprites.add(wall6)
all_sprites.add(wall7)
all_sprites.add(player)

# Seznam všech nepohyblivých spritů
all_sprites_but_player.add(wall1)
all_sprites_but_player.add(wall2)
all_sprites_but_player.add(wall3)
all_sprites_but_player.add(wall4)
all_sprites_but_player.add(wall5)
all_sprites_but_player.add(wall6)
all_sprites_but_player.add(wall7)


# Posun všech spritů ve skupině na základě jejich rychlosti
@profile
def move_sprites(sprite_group, playground_width, playground_height):
    for sprite in sprite_group:
        # Posun spritu
        sprite.rect.x = sprite.rect.x + sprite.speed_x
        sprite.rect.y = sprite.rect.y + sprite.speed_y
        # Kontrola, zda sprite nenarazil do okrajů okna
        if sprite.rect.x < 0:
            sprite.rect.x = 0
            sprite.speed_x = 0
        if sprite.rect.x + sprite.rect.width > playground_width:
            sprite.rect.x = playground_width - sprite.rect.width
            sprite.speed_x = 0
        if sprite.rect.y < 0:
            sprite.rect.y = 0
            sprite.speed_y = 0
        if sprite.rect.y + sprite.rect.height > playground_height:
            sprite.rect.y = playground_height - sprite.rect.height
            sprite.speed_y = 0


# Vykreslení celé scény na obrazovku
@profile
def draw_scene(display, background_color, sprite_group):
    # Vyplnění plochy okna černou barvou
    display.fill(background_color)
    # Vykreslení celé skupiny spritů do bufferu
    sprite_group.draw(display)
    # Obnovení obsahu obrazovky (překlopení zadního a předního bufferu)
    pygame.display.update()


# Změna barvy spritu na základě kolize s hráčem
@profile
def change_colors(sprite_group, hit_list):
    # Projít všemi sprity ze skupiny, kterou detekovala kolizní funkce
    for sprite in sprite_group:
        if sprite in hit_list:
            sprite.yellowColor()
        else:
            sprite.grayColor()


# Zjistí kolize spritu se "stěnami" (nepohyblivými sprity)
@profile
def check_collisions(player, sprite_group):
    # Vytvoření seznamu spritů, které kolidují s hráčem
    hit_list = pygame.sprite.spritecollide(player, sprite_group, False)
    # Změna barev kolidujících spritů
    change_colors(sprite_group, hit_list)
    collisions = len(hit_list)
    # Přenastavení titulku okna
    caption = "Pygame test #22: collisions " + str(collisions)
    pygame.display.set_caption(caption)


@profile
def mainLoop():
    while True:
        # Načtení a zpracování všech událostí z fronty
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                # Stiskem kurzorových kláves je možné měnit směr pohybu spritu
                elif event.key == pygame.K_LEFT:
                    player.speed_x = -3
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = +3
                elif event.key == pygame.K_UP:
                    player.speed_y = -3
                elif event.key == pygame.K_DOWN:
                    player.speed_y = +3
            if event.type == KEYUP:
                # Puštění kurzorových kláves vede k zastavení pohybu spritu
                if event.key == pygame.K_LEFT:
                    player.speed_x = 0
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = 0
                elif event.key == pygame.K_UP:
                    player.speed_y = 0
                elif event.key == pygame.K_DOWN:
                    player.speed_y = 0

        move_sprites(all_sprites, display.get_width(), display.get_height())
        check_collisions(player, all_sprites_but_player)
        draw_scene(display, BLACK, all_sprites)
        clock.tick(20)


mainLoop()

# finito
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>getsizeof1.py</td><td>získání nápovědy k&nbsp;funkci <strong>getsizeof</strong> z&nbsp;balíčku <strong>sys</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof1.py</a></td></tr>
<tr><td> 2</td><td>getsizeof2.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof2.py</a></td></tr>
<tr><td> 3</td><td>getsizeof3.py</td><td>získání a tisk velikosti kontejnerů Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof3.py</a></td></tr>
<tr><td> 4</td><td>getsizeof4.py</td><td>získání a tisk velikosti funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof4.py</a></td></tr>
<tr><td> 5</td><td>getsizeof5.py</td><td>získání a tisk velikosti tříd a objektů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof5.py</a></td></tr>
<tr><td> 6</td><td>getsizeof6.py</td><td>získání a tisk velikosti tříd a objektů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof6.py</a></td></tr>
<tr><td> 7</td><td>getsizeof7.py</td><td>velikost kolekcí obsahujících velké prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof7.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>asizeof01.py</td><td>získání nápovědy k&nbsp;balíčku <strong>pympler.asizeof</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof01.py</a></td></tr>
<tr><td> 9</td><td>asizeof02.py</td><td>všechny veřejné atributy balíčku <strong>pympler.asizeof</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof02.py</a></td></tr>
<tr><td>10</td><td>asizeof03.py</td><td>získání nápovědy k&nbsp;funkci <strong>asizeof</strong> z&nbsp;balíčku <strong>pympler.asizeof</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof03.py</a></td></tr>
<tr><td>11</td><td>asizeof04.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof04.py</a></td></tr>
<tr><td>12</td><td>asizeof05.py</td><td>získání a tisk velikosti kontejnerů Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof05.py</a></td></tr>
<tr><td>13</td><td>asizeof06.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu se statistikou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof06.py</a></td></tr>
<tr><td>14</td><td>asizeof07.py</td><td>získání a tisk velikosti kontejnerů Pythonu se statistikou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof07.py</a></td></tr>
<tr><td>15</td><td>asizeof08.py</td><td>získání a tisk velikosti funkcí bez parametru <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof08.py</a></td></tr>
<tr><td>16</td><td>asizeof09.py</td><td>získání a tisk velikosti funkcí s&nbsp;parametrem <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof09.py</a></td></tr>
<tr><td>17</td><td>asizeof10.py</td><td>získání a tisk velikosti tříd a objektů bez parametru <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof10.py</a></td></tr>
<tr><td>18</td><td>asizeof11.py</td><td>získání a tisk velikosti tříd a objektů s&nbsp;parametrem <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py</a></td></tr>
<tr><td>19</td><td>asizeof12.py</td><td>velikost kolekcí obsahujících velké prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>app1.py</td><td>aplikace alokující velké řetězce a bytové pole</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app1.py</a></td></tr>
<tr><td>21</td><td>app2.py</td><td>lokální proměnné s&nbsp;velkými řetězci a bytovými poli</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app2.py</a></td></tr>
<tr><td>22</td><td>app3.py</td><td>přidávání a ubírání prvků do rozsáhlých seznamů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app3.py</a></td></tr>
<tr><td>23</td><td>app4.py</td><td>příklad použití anotace @profile</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app4.py</a></td></tr>
<tr><td>24</td><td>app5.py</td><td>příklad použití anotace @profile</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/app5.py</a></td></tr>
<tr><td>25</td><td>sprites.py</td><td>sprity a knihovna Pygame</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/sprites.py">https://github.com/tisnik/most-popular-python-libs/blob/master/memory_profiler/sprites.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Top 5 Python Memory Profilers<br />
<a href="https://stackify.com/top-5-python-memory-profilers/">https://stackify.com/top-5-python-memory-profilers/</a>
</li>

<li>Pympler na GitHubu<br />
<a href="https://github.com/pympler/pympler">https://github.com/pympler/pympler</a>
</li>

<li>Pympler na PyPI<br />
<a href="https://pypi.org/project/Pympler/">https://pypi.org/project/Pympler/</a>
</li>

<li>Dokumentace k&nbsp;balíčku Pympler<br />
<a href="https://pympler.readthedocs.io/en/latest/">https://pympler.readthedocs.io/en/latest/</a>
</li>

<li>Guppy 3 na GitHubu<br />
<a href="https://github.com/zhuyifei1999/guppy3/">https://github.com/zhuyifei1999/guppy3/</a>
</li>

<li>Guppy 3 na PyPI<br />
<a href="https://pypi.org/project/guppy3/">https://pypi.org/project/guppy3/</a>
</li>

<li>Memory Profiler na GitHubu<br />
<a href="https://github.com/pythonprofilers/memory_profiler">https://github.com/pythonprofilers/memory_profiler</a>
</li>

<li>Memory Profiler na PyPI<br />
<a href="https://pypi.org/project/memory-profiler/">https://pypi.org/project/memory-profiler/</a>
</li>

<li>How to use guppy/heapy for tracking down memory usage<br />
<a href="https://smira.ru/wp-content/uploads/2011/08/heapy.html">https://smira.ru/wp-content/uploads/2011/08/heapy.html</a>
</li>

<li>Identifying memory leaks<br />
<a href="https://pympler.readthedocs.io/en/latest/muppy.html#muppy">https://pympler.readthedocs.io/en/latest/muppy.html#muppy</a>
</li>

<li>How do I determine the size of an object in Python?<br />
<a href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python</a>
</li>

<li>Why is bool a subclass of int?<br />
<a href="https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int">https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int</a>
</li>

<li>Memory Management in Python<br />
<a href="https://realpython.com/python-memory-management/">https://realpython.com/python-memory-management/</a>
</li>

<li>Why do ints require three times as much memory in Python?<br />
<a href="https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python">https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python</a>
</li>

<li>cpython/Include/cpython/longintrepr.h<br />
<a href="https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64">https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64</a>
</li>

<li>sys — System-specific parameters and functions<br />
<a href="https://docs.python.org/3/library/sys.html">https://docs.python.org/3/library/sys.html</a>
</li>

<li>Python 3.3 s&nbsp;flexibilní reprezentací řetězců<br />
<a href="https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/#k17">https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/#k17</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

