<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V závěrečné části článku o využití instrukcí z instrukční sady Thumb a Thumb-2 v MicroPythonu si popíšeme zbývající podporované instrukce i způsob jejich použití. Taktéž si porovnáme rychlost výpočtů realizovaných přímo strojovými instrukcemi v porovnání s Pythonem.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Neférový benchmark na úvod: rychlost realizace vnořených programových smyček</a></p>
<p><a href="#k02">2. Vylepšený způsob zobrazení strojového kódu přeložené funkce</a></p>
<p><a href="#k03">3. Počítaná programová smyčka s&nbsp;testem provedeným na začátku</a></p>
<p><a href="#k04">4. Zbývající instrukce ze sady Thumb implementované a podporované MicroPythonem</a></p>
<p><a href="#k05">5. Zpracování osmibitových a šestnáctibitových dat</a></p>
<p><a href="#k06">6. Bitové operace</a></p>
<p><a href="#k07">7. Ukázka použití vybraných bitových operací</a></p>
<p><a href="#k08">8. Bitové posuny a rotace</a></p>
<p><a href="#k09">9. Ukázka použití operací posunu a rotace</a></p>
<p><a href="#k10">10. Operace součinu</a></p>
<p><a href="#k11">11. Rychlost instrukce <strong>mul</strong></a></p>
<p><a href="#k12">12. Porovnání rychlosti výpočtu součinu MicroPythonem</a></p>
<p><a href="#k13">13. Instrukce pro porovnání dvou hodnot</a></p>
<p><a href="#k14">14. Zbylé instrukce pro práci na úrovni jednotlivých bitů</a></p>
<p><a href="#k15">15. Prefix IT v&nbsp;instrukční sadě Thumb-2</a></p>
<p><a href="#k16">16. Realizace prefixu IT v&nbsp;MicroPythonu</a></p>
<p><a href="#k17">17. Speciální instrukce</a></p>
<p><a href="#k18">18. Popsané instrukce a způsob jejich zápisu v&nbsp;MicroPythonu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Neférový benchmark na úvod: rychlost realizace vnořených programových smyček</h2>

<p>Hned na začátku tohoto článku se pokusíme porovnat rychlost dvou
implementací vnořených programových smyček. První implementaci jsme si již
ukázali minule &ndash; je založena na podmíněných skocích. Připomeňme si, že se
v&nbsp;tomto případě jedná o smyčky, jejichž počitadla jsou uložena
v&nbsp;registrech <strong>R1</strong> a <strong>R2</strong>. Tělo vnitřní
smyčky se vykoná 100&times;100=10000 krát, což znamená, že návratovou hodnotou
této funkce bude taktéž hodnota 10000 (návratová hodnota je předána
v&nbsp;pracovním registru <strong>R0</strong>):</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>loop</strong>():
    mov(r0, 0)
    mov(r1, 100)        <i># počáteční hodnota počitadla vnější smyčky</i>
    label(outer_loop)   <i># označení začátku vnější programové smyčky</i>
    mov(r2, 100)        <i># počáteční hodnota počitadla vnitřní smyčky</i>
    label(inner_loop)   <i># označení začátku vnitřní programové smyčky</i>
    add(r0, r0, 1)      <i># tělo smyčky</i>
    sub(r2, r2, 1)      <i># snížení hodnoty počitadla + nastavení příznaků</i>
    bne(inner_loop)     <i># opakování vnitřní smyčky</i>
    sub(r1, r1, 1)      <i># snížení hodnoty počitadla + nastavení příznaků</i>
    bne(outer_loop)     <i># opakování vnější smyčky</i>
</pre>

<p>Dobu trvání si necháme změřit v&nbsp;mikrosekundách:</p>

<pre>
import utime
t1 = utime.ticks_us()
loop()
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
4704
</pre>

<p>Druhá verze benchmarku je naprogramována v&nbsp;čistém a idiomatickém
Pythonu, a to bez použití optimalizací:</p>

<pre>
def <strong>loop</strong>():
    x = 0
    for i in range(100):
        for j in range(100):
            x+=1
    return x
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
loop()
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>Výsledkem je v&nbsp;tomto případě kód, který je přibližně 12&times;
pomalejší:</p>

<pre>
59022
</pre>

<p><div class="rs-tip-major">Poznámka: to je kupodivu velmi dobrý výsledek,
který ukazuje kvalitu překladu MicroPythonu. Musíme si totiž uvědomit, že
výpočty v&nbsp;Pythonu obecně probíhají s&nbsp;neomezenými celočíselnými
hodnotami, takže ve skutečnosti je druhý benchmark realizován mnohem obecnějším
kódem. Podrobnosti si vysvětlíme v&nbsp;samostatném článku věnovaném
<i>Viperu</i>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vylepšený způsob zobrazení strojového kódu přeložené funkce</h2>

<p>V&nbsp;předchozím článku jsme si taktéž ukázali funkci sloužící
k&nbsp;zobrazení strojového kódu přeložené funkce, což má význam zejména pro
funkce s&nbsp;dekorátorem <strong>@micropython.asm_thumb</strong>. Připomeňme
si, že takové funkce vždy začínají instrukcí:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
</pre>

<p>a končí instrukcí:</p>

<pre>
pop {r1, r4, r5, r6, r7, pc}
</pre>

<p>Důležitá je druhá instrukce, která je zakódována do dvojice bajtů:</p>

<pre>
f2 bd
</pre>

<p>Tyto dva bajty budeme hledat v&nbsp;paměťovém bloku se strojovým kódem.
Nemáme totiž k&nbsp;dispozici jinou informaci o tom, na které adrese strojový
kód končí (tato informace bude existovat, ovšem s&nbsp;verzemi Pythonu se
mění). Upravená varianta pomocné funkce sloužící pro analýzu a výpis funkce
přeložené do strojového kódu tedy může vypadat například takto (realizací je
samozřejmě větší množství):</p>

<pre>
import machine
import array
&nbsp;
&nbsp;
def <strong>inspect</strong>(f):
    baddr = bytes(array.array("O", [f]))
    addr = int.from_bytes(baddr, "little")
    print("function object at: 0x%08x" % addr)
    print("number of args:     %u" % machine.mem32[addr + 4])
    code_addr = machine.mem32[addr + 8]
    print("machine code at:    0x%08x" % code_addr)
&nbsp;
    previous = -1
    size = 0
    while True:
        current = machine.mem8[code_addr + size]
        size += 1
        if current == 0xbd and previous == 0xf2:
            break
        previous = current
&nbsp;
    print(f"machine code size:  {size} bytes")
&nbsp;
    print("-- code --")
    for i in range(size):
        print(f"{machine.mem8[code_addr + i]:02x}", end=" ")
    print("\n----------")
</pre>

<p><div class="rs-tip-major">Poznámka: minimální délka strojového kódu by měla
být rovna čtyřem bajtům.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Počítaná programová smyčka s&nbsp;testem provedeným na začátku</h2>

<p>Navažme nyní na téma, kterému jsme se věnovali na konci předchozího článku.
Ukážeme si další počítanou programovou smyčku, v&nbsp;níž se ovšem test na
ukončení bude pro změnu provádět na jejím začátku ihned po odečtení jedničky od
počitadla (a samozřejmě se otočí podmínka ve skoku &ndash; nyní bude skok
proveden při nulovém počitadle). Tento příklad je vlastně v&nbsp;mnoha ohledech
totožný s&nbsp;původní smyčkou s&nbsp;testem na konci:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>loop</strong>():
    mov(r0, 0)
    mov(r1, 100)    <i># počáteční hodnota počitadla</i>
    label(loop)     <i># označení začátku programové smyčky</i>
    add(r0, r0, 4)  <i># tělo smyčky</i>
    sub(r1, r1, 1)  <i># snížení hodnoty počitadla + nastavení příznaků</i>
    bne(loop)       <i># skok v případě že se nedosáhlo nuly</i>
</pre>

<p>Ovšem vzhledem k&nbsp;tomu, že změna stavu počitadla (snížení jeho hodnoty o
jedničku) a následný test je proveden na začátku smyčky, je nutné při
inicializaci počitadla do něj vložit hodnotu 101 a nikoli 100:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>loop</strong>():
    mov(r0, 0)
    mov(r1, 101)    <i># počáteční hodnota počitadla + 1</i>
    label(loop)     <i># označení začátku programové smyčky</i>
    sub(r1, r1, 1)  <i># snížení hodnoty počitadla + nastavení příznaků</i>
    beq(break_loop) <i># skok v případě že se dosáhlo nuly</i>
    add(r0, r0, 4)  <i># tělo smyčky</i>
    b(loop)
    label(break_loop)
</pre>

<p>Pokud si jsme jisti, že hodnota počitadla před vstupem do smyčky nebude
nulová, lze dokonce i snížení hodnoty počitadla (s&nbsp;nastavením příznaků)
přenést na konec smyčky. Smyčka v&nbsp;tomto případě tedy skutečně začíná
podmíněným skokem:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>loop</strong>():
    mov(r0, 0)
    mov(r1, 101)    <i># počáteční hodnota počitadla + 1</i>
    label(loop)     <i># označení začátku programové smyčky</i>
    beq(break_loop) <i># skok v případě že se dosáhlo nuly</i>
    add(r0, r0, 4)  <i># tělo smyčky</i>
    sub(r1, r1, 1)  <i># snížení hodnoty počitadla + nastavení příznaků</i>
    b(loop)
    label(break_loop)
</pre>

<p>Výsledek si ověříme přímo v&nbsp;REPLu MicroPythonu. Měla by se vypsat
hodnota 400, protože se stokrát zvýší hodnota v&nbsp;registru
<strong>R0</strong> o 4:</p>

<pre>
&gt;&gt;&gt; <strong>loop()</strong>
400
</pre>

<p>Překlad do strojového kódu vypadá takto:</p>

<pre>
&gt;&gt;&gt; <strong>inspect(loop)</strong>
function object at: 0x20008f20
number of args:     0
machine code at:    0x200090e0
machine code size:  16 bytes
-- code --
f2 b5 00 20 65 21 49 1e 01 d0 00 1d fb e7 f2 bd 
----------
</pre>

<p>Jedná se o strojový kód s&nbsp;osmi instrukcemi Thumb uloženými
v&nbsp;šestnácti bajtech.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zbývající instrukce ze sady Thumb implementované a podporované MicroPythonem</h2>

<p>V&nbsp;navazujících kapitolách si popíšeme všechny další instrukce ze sady
Thumb, které jsou podporované MicroPythonem. U některých instrukcí si ukážeme
demonstrační příklady, další instrukce budou pouze popsány (v&nbsp;případě, že
se podobají instrukcím jiným). Na tomto místě je vhodné doplnit, že mapování
mezi strojovými instrukcemi sady Thumb a MicroPythonem není ve všech případech
stoprocentní, protože se například odlišuje způsob zápisu operandů apod. Na
tyto rozdíly pochopitelně upozorníme.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zpracování osmibitových a šestnáctibitových dat</h2>

<p>Poměrně často se v&nbsp;programech manipuluje s&nbsp;osmibitovými či
šestnáctibitovými hodnotami (ASCII znaky, zvukové vzorky atd.). To je pro čistě
32bitové čipy, mezi něž patří i mikrořadiče Cortex-M, poměrně problematické,
protože většina operací je provedena s&nbsp;32bitovými registry. Ovšem máme
k&nbsp;dispozici alespoň specializované instrukce určené pro načtení osmibitové
či šestnáctibitové hodnoty, přičemž zbytek 32bitového registru je vynulován.
Podobně existují i instrukce pro uložení pouze osmi či šestnácti bitů původně
32bitového registru:

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>ldrb(Rt, [Rn, imm5])</td><td>načtení bajtu, zbylých 24 bitů se vynuluje</td></tr>
<tr><td>ldrh(Rt, [Rn, imm6])</td><td>načtení 16bitového slova, zbylých 16 bitů se vynuluje</td></tr>
<tr><td>ldr(Rt, [Rn, imm7]) </td><td>načtení celého 32bitového slova (již známe)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>strb(Rt, [Rn, imm5])</td><td>uložení bajtu (spodních 8 bitů registru)</td></tr>
<tr><td>strh(Rt, [Rn, imm6])</td><td>uložení 16bitového slova (spodních 16 bitů registru)</td></tr>
<tr><td>str(Rt, [Rn, imm7])</td><td>uložení celého 32bitového slova</td></tr>
</table>

<p>Vyzkoušejme si tedy, jak se načte jediný bajt, nezávisle na původním obsahu
registru (tj.&nbsp;do osmi nejnižších bitů registru se načte hodnota bajtu a
zbylých 24 bitů bude vynulováno):</p>

<pre>
from array import array
&nbsp;
control = array('B', [255, 255, 100, 255, 255])
&nbsp;
&nbsp;
<i>@micropython.asm_thumb</i>
def <strong>load_byte</strong>(r0):
    mov(r1, 0)         <i># vynulujeme R1</i>
    mvn(r1, r1)        <i># nyni bude R1 obsahovat same jednicky</i>
    ldrb(r1, [r0, 2])  <i># nacteme jediny bajt z pole (ten s hodnotou 100)</i>
    mov(r0, r1)        <i># navratova hodnota</i>
&nbsp;
&nbsp;
load_byte(control)
</pre>

<p>Tento prográmek po svém spuštění vypíše hodnotu 100. To znamená, že
z&nbsp;pole, které obsahuje bajty s&nbsp;různými hodnotami, se načte skutečně
pouze jediný bajt, a to konkrétně bajt s&nbsp;offsetem 2 (schválně jsou okolo
tohoto bajtu další hodnoty 255 a nikoli nulové hodnoty).</p>

<p>Podobně lze realizovat načtení šestnáctibitového slova:</p>

<pre>
from array import array
&nbsp;
control = array('B', [255, 255, 100, 0, 255, 255])
&nbsp;
&nbsp;
<i>@micropython.asm_thumb</i>
def <strong>load_halfword</strong>(r0):
    mov(r1, 0)         <i># vynulujeme R1</i>
    mvn(r1, r1)        <i># nyni bude R1 obsahovat same jednicky</i>
    ldrh(r1, [r0, 2])  <i># nacteme jedine 16bitove slova z pole (to s hodnotou 100 + 0*256)</i>
    mov(r0, r1)
&nbsp;
&nbsp;
load_halfword(control)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Bitové operace</h2>

<p>Další skupinou instrukcí, které nalezneme v&nbsp;instrukční sadě Thumb a
které jsou podporovány i MicroPythonem, jsou instrukce určené pro provádění
základních bitových operací. Všechny tyto instrukce mají jednotný formát
s&nbsp;dvojicí vstupních registrů, přičemž jeden z&nbsp;těchto registrů bude
obsahovat i výsledek výpočtu &ndash; nejedná se tedy o &bdquo;tříadresový
kód&ldquo;, který jsme mohli vidět zejména u instrukcí <strong>ADD</strong> a
<strong>SUB</strong>:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 0 | 0 | 0 |    operace    |    Rs     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Jedná se o tyto instrukce:</p>

<table>
<tr><th>Kód</th><th>Operace</th><th>Ekvivalent ARM</th><th>Význam</th></tr>
<tr><td>0000</td><td>AND Rd, Rs</td><td>ANDS Rd, Rd, Rs</td><td>Rd:= Rd AND Rs</td></tr>
<tr><td>1100</td><td>ORR Rd, Rs</td><td>ORRS Rd, Rd, Rs</td><td>Rd := Rd OR Rs</td></tr>
<tr><td>0001</td><td>EOR Rd, Rs</td><td>EORS Rd, Rd, Rs</td><td>Rd:= Rd EOR Rs (EOR=XOR)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>1000</td><td>TST Rd, Rs</td><td>TST Rd, Rs</td><td>Nastavení příznaků podle operace Rd AND Rs</td></tr>
<tr><td>1110</td><td>BIC Rd, Rs</td><td>BICS Rd, Rd, Rs</td><td>Rd := Rd AND NOT Rs</td></tr>
<tr><td>1111</td><td>MVN Rd, Rs</td><td>MVNS Rd, Rs</td><td>Rd := NOT Rs</td></tr>
</table>

<p>Způsob zápisu těchto instrukcí v&nbsp;MicroPythonu je následující:</p>

<table>
<tr><th>Instrukce</th><th>Zápis v&nbsp;MicroPythonu</th></tr>
<tr><td>AND Rd, Rs</td><td>and_(Rd, Rs)</td></tr>
<tr><td>ORR Rd, Rs</td><td>orr(Rd, Rs)</td></tr>
<tr><td>EOR Rd, Rs</td><td>eor(Rd, Rs)</td></tr>
<tr><td>TST Rd, Rs</td><td>tst(Rd, Rs)</td></tr>
<tr><td>BIC Rd, Rs</td><td>bic(Rd, Rs)</td></tr>
<tr><td>MVN Rd, Rs</td><td>mvn(Rd, Rs)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že u instrukce
<strong>AND</strong> je nutné v&nbsp;MicroPythonu použít pseudofunkci
<strong>and_</strong> s&nbsp;podtržítkem na konci. Je tomu tak z&nbsp;toho
důvodu, že <strong>and</strong> je v&nbsp;Pythonu klíčovým slovem.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Ukázka použití vybraných bitových operací</h2>

<p>Některé <a href="#k06">z&nbsp;výše popsaných</a> bitových operací si
otestujeme na jednoduchých příkladech.</p>

<p>Instrukce <strong>AND</strong>:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>and_operation</strong>(r0, r1):
    and_(r0, r1)
&nbsp;
&nbsp;
print(hex(and_operation(0x00, 0x00)))
print(hex(and_operation(0xff, 0xaa)))
print(hex(and_operation(0x18, 0xf0)))
print(hex(and_operation(0x18, 0x0f)))
</pre>

<p>Výsledky:</p>

<pre>
0x0
0xaa
0x10
0x8
</pre>

<p>Instrukce <strong>ORR</strong>:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>or_operation</strong>(r0, r1):
    orr(r0, r1)
&nbsp;
&nbsp;
print(hex(or_operation(0x00, 0x00)))
print(hex(or_operation(0xff, 0xaa)))
print(hex(or_operation(0x18, 0xf0)))
print(hex(or_operation(0x18, 0x0f)))
</pre>

<p>Výsledky:</p>

<pre>
0x0
0xff
0xf8
0x1f
</pre>

<p>Instrukce <strong>BIC</strong>:</p>

<pre>
<strong>@micropython.asm_thumb</strong>
def <strong>bic_operation</strong>(r0, r1):
    bic(r0, r1)
&nbsp;
&nbsp;
print(hex(bic_operation(0x00, 0x00)))
print(hex(bic_operation(0xff, 0xaa)))
print(hex(bic_operation(0x18, 0xf0)))
print(hex(bic_operation(0x18, 0x0f)))
</pre>

<p>Výsledky:</p>

<pre>
0x0
0x55
0x8
0x10
</pre>

<p>A konečně instrukce <strong>MVN</strong>:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>mvn_operation</strong>(r0):
    mvn(r0, r0)
&nbsp;
&nbsp;
print(hex(mvn_operation(0x00)))
print(hex(mvn_operation(0xff)))
print(hex(mvn_operation(0x18)))
print(hex(mvn_operation(0x0f)))
</pre>

<p>Výsledky:</p>

<pre>
-0x1
-0x100
-0x19
-0x10
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Bitové posuny a rotace</h2>

<p>Do další skupiny instrukcí patří instrukce provádějící bitové posuny a
rotace. Nalezneme zde čtveřici instrukcí, a to konkrétně bitový posun doleva i
doprava, dále aritmetický posun doprava (zachová se hodnota znaménka) a taktéž
bitovou rotaci. Všechny čtyři zmíněné instrukce existují ve variantě
s&nbsp;jedním cílovým registrem a dvěma zdrojovými registry, přičemž jeden ze
zdrojových registrů je současně i registrem cílovým. Tento formát instrukcí již
známe:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 0 | 0 | 0 |    operace    |    Rs     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Konkrétně se jedná o tyto instrukce:</p>

<table>
<tr><th>Kód</th><th>Operace</th><th>Ekvivalent ARM</th><th>Význam</th></tr>
<tr><td>0010</td><td>LSL Rd, Rs</td><td>MOVS Rd, Rd, LSL Rs</td><td>Rd := Rd &lt;&lt; Rs (bitový posun)</td></tr>
<tr><td>0011</td><td>LSR Rd, Rs</td><td>MOVS Rd, Rd, LSR Rs</td><td>Rd := Rd &gt;&gt; Rs (bitový posun)</td></tr>
<tr><td>0100</td><td>ASR Rd, Rs</td><td>MOVS Rd, Rd, ASR Rs</td><td>Rd := Rd ASR Rs (aritmetický posun)</td></tr>
<tr><td>0111</td><td>ROR Rd, Rs</td><td>MOVS Rd, Rd, ROR Rs</td><td>Rd := Rd ROR Rs (rotace)</td></tr>
</table>

<table>
<tr><th>Instrukce</th><th>Zápis v&nbsp;MicroPythonu</th></tr>
<tr><td>LSL Rd, Rs</td><td>lsl(Rd, Rs)</td></tr>
<tr><td>LSR Rd, Rs</td><td>lsr(Rd, Rs)</td></tr>
<tr><td>ASR Rd, Rs</td><td>asr(Rd, Rs)</td></tr>
<tr><td>ROR Rd, Rs</td><td>ror(Rd, Rs)</td></tr>
</table>

<p>Aritmetické a bitové posuny (ovšem nikoli rotace) existují taktéž ve vlastní
variantě, kdy je počet bitů 0..31 zakódován přímo v&nbsp;instrukčním slovu:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 |operace| posun 0-31 bitů   |    Rs     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Konkrétně se jedná o tyto instrukce:</p>

<table>
<tr><th>Operace</th><th>Význam</th></tr>
<tr><td>LSL Rd, Rs, #shift</td><td>Rd := Rs &lt;&lt; #shift (bitový posun)</td></tr>
<tr><td>LSR Rd, Rs, #shift</td><td>Rd := Rs &gt;&gt; #shift (bitový posun)</td></tr>
<tr><td>ASR Rd, Rs, #shift</td><td>Rd := Rs ASR #shift (aritmetický posun)</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Ukázka použití operací posunu a rotace</h2>

<p>Opět si ukažme, jaký vliv mají <a href="#k08">výše popsané instrukce</a> na
hodnoty předané do testovacích funkcí.</p>

<p>Logický posun doleva:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>lsl_operation</strong>(r0, r1):
    lsl(r0, r1)
&nbsp;
&nbsp;
print(hex(lsl_operation(0x01, 0)))
print(hex(lsl_operation(0x01, 1)))
print(hex(lsl_operation(0x01, 2)))
print(hex(lsl_operation(0x01, 3)))
</pre>

<p>Výsledky (jedná se o násobení mocninami dvojky):</p>

<pre>
0x1
0x2
0x4
0x8
</pre>

<p>Logický posun doprava:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>lsr_operation</strong>(r0, r1):
    lsr(r0, r1)
&nbsp;
&nbsp;
print(hex(lsr_operation(0x100, 0)))
print(hex(lsr_operation(0x100, 1)))
print(hex(lsr_operation(0x100, 2)))
print(hex(lsr_operation(0x100, 3)))
</pre>

<p>Výsledky (jedná se o dělení mocninami dvojky):</p>

<pre>
0x100
0x80
0x40
0x20
</pre>

<p>Aritmetický posun doprava:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>asr_operation</strong>(r0, r1):
    asr(r0, r1)
&nbsp;
&nbsp;
print(hex(asr_operation(-0x100, 0)))
print(hex(asr_operation(-0x100, 1)))
print(hex(asr_operation(-0x100, 2)))
print(hex(asr_operation(-0x100, 3)))
</pre>

<p>Výsledky (jedná se o dělení mocninami dvojky se zachováním znaménka):</p>

<pre>
-0x100
-0x80
-0x40
-0x20
</pre>

<p>A konečně rotace doprava či doleva (podle znaménka druhého operandu):</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>ror_operation</strong>(r0, r1):
    ror(r0, r1)
&nbsp;
&nbsp;
print(hex(ror_operation(1, -3)))
print(hex(ror_operation(1, -2)))
print(hex(ror_operation(1, -1)))
print(hex(ror_operation(1, 0)))
print(hex(ror_operation(1, 1)))
print(hex(ror_operation(1, 2)))
print(hex(ror_operation(1, 3)))
</pre>

<p>Výsledky (první tři rotace jsou de facto doleva, poslední tři doprava):</p>

<pre>
0x8
0x4
0x2
0x1
-0x80000000
0x40000000
0x20000000
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Operace součinu</h2>

<p>V&nbsp;instrukční sadě Thumb se nachází i instrukce provádějící operaci
součinu. Tato instrukce se jmenuje <strong>MUL</strong> a je zajímavá ve třech
ohledech:</p>

<ol>

<li>násobí se dvě 32bitové hodnoty, ovšem výsledkem je taktéž pouze 32bitová
hodnota (horních 32 bitů je tedy useknuto, 64bitové výsledky produkuje
instrukce, která na jádrech Cortex-M0+ atd. není dostupná)</li>

<li>cílový registr Rd je totožný se druhým zdrojovým registrem (to platí i pro
mnoho dalších ALU operací kromě součtu a rozdílu)</li>

<li>nastavují se příznaky N a Z, nikoli C a V (přitom C by měl svůj
význam)</li>

</ol>

<p>Pozor ovšem na to, že instrukce <strong>MUL</strong> se v&nbsp;MicroPythonu
musí zapsat jen se dvěma operandy, protože první registr je současně registrem
zdrojovým i cílovým:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>mul</strong>(r0, r1):
    mul(r0, r1)
</pre>

<p>Způsob překladu této funkce do strojového kódu vypadá následovně:</p>

<pre>
push {r1, r4, r5, r6, r7, lr}
muls r0, r1, r0
pop {r1, r4, r5, r6, r7, pc}
</pre>

<p>Ověřme si, jaké výsledky instrukce <strong>MUL</strong> produkuje.</p>

<p>Násobení nulou:</p>

<pre>
&gt;&gt;&gt; <strong>mul(0, 0)</strong>
0
&nbsp;
&gt;&gt;&gt; <strong>mul(0, 1000)</strong>
0
&nbsp;
&gt;&gt;&gt; <strong>mul(1000, 0)</strong>
0
</pre>

<p>Kladné a záporné činitele:</p>

<pre>
&nbsp;
&gt;&gt;&gt; <strong>mul(2, 3)</strong>
6
&nbsp;
&gt;&gt;&gt; <strong>mul(-2, 3)</strong>
-6
&nbsp;
&gt;&gt;&gt; <strong>mul(2, -3)</strong>
-6
&nbsp;
&gt;&gt;&gt; <strong>mul(-2, -3)</strong>
6
</pre>

<p>Přetečení výsledků přes 32 bitů:</p>

<pre>
&gt;&gt;&gt; <strong>mul(1&lt;&lt;29, 2)</strong>
1073741824
&nbsp;
&gt;&gt;&gt; <strong>mul(1&lt;&lt;30, 2)</strong>
-2147483648
&nbsp;
&gt;&gt;&gt; <strong>mul(1&lt;&lt;31, 2)</strong>
0
&gt;&gt;&gt; <strong>mul(1&lt;&lt;29, -2)</strong>
-1073741824
&nbsp;
&gt;&gt;&gt; <strong>mul(1&lt;&lt;30, -2)</strong>
-2147483648
&nbsp;
&gt;&gt;&gt; <strong>mul(1&lt;&lt;31, -2)</strong>
0
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rychlost instrukce <strong>mul</strong></h2>

<p>V&nbsp;úvodním článku o MicroPythonu a instrukční sadě Thumb jsme si
mj.&nbsp;řekli, že v&nbsp;instrukční sadě Thumb nalezneme i instrukci MULS
určenou pro násobení dvou 32bitových operandů, přičemž výsledek je taktéž
32bitový (zapamatuje se jen spodních 32bitů výsledku &ndash; to jsme si ostatně
již prakticky ukázali před chvílí). Při implementaci mikroprocesoru je možné
zvolit, jakým typem násobičky se tato instrukce bude provádět. V&nbsp;případě,
že se má jednat o výkonnější čip (a aplikace operaci násobení skutečně
využije), může se použít rychlá násobička, která celou operaci dokáže provést
v&nbsp;jediném taktu (samozřejmě se měření provádí při postupně zaplňované
pipeline). Pokud se ovšem má jednat o levnější a méně výkonný čip, lze násobení
implementovat po krocích, což sice trvá celých 32 taktů, ovšem potřebná plocha
čipu a i energetická náročnost je mnohem menší, než v&nbsp;případě jednocyklové
násobičky.</p>

<p>Zkusme si tedy změřit rychlost instrukce <strong>MULS</strong>. Víme již, že
dvojice vnořených smyček, v&nbsp;jejichž těle se provádí stotisíckrát součet,
trvá přibližně 4704 mikrosekund. Nahraďme tedy instrukci <strong>ADDS</strong>
za <strong>MULS</strong> (s&nbsp;tím, že měříme i dobu trvání instrukcí
zajišťujících iteraci atd.):</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>loop_mul</strong>():
    mov(r0, 10)
    mov(r1, 100)        <i># počáteční hodnota počitadla vnější smyčky</i>
    label(outer_loop)   <i># označení začátku vnější programové smyčky</i>
    mov(r2, 100)        <i># počáteční hodnota počitadla vnitřní smyčky</i>
    label(inner_loop)   <i># označení začátku vnitřní programové smyčky</i>
    mul(r0, r0)         <i># tělo smyčky</i>
    sub(r2, r2, 1)      <i># snížení hodnoty počitadla + nastavení příznaků</i>
    bne(inner_loop)     <i># opakování vnitřní smyčky</i>
    sub(r1, r1, 1)      <i># snížení hodnoty počitadla + nastavení příznaků</i>
    bne(outer_loop)     <i># opakování vnější smyčky</i>
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
loop_mul()
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>V&nbsp;případě běhu na RP2040 bude výsledek prakticky totožný (v&nbsp;rámci
přesnosti měření času):</p>

<pre>
4676
</pre>

<p>Z&nbsp;toho plyne, že operace <strong>MULS</strong> je na tomto konkrétním
čipu provedena stejně rychle jako instrukce <strong>ADDS</strong>. Pokud by
<strong>MULS</strong> trvala významně déle, bylo by to patrné na výsledku
měření, a to i přesto, že měříme i čas trvání <strong>SUBS</strong> a
podmíněného skoku <strong>BNE</strong>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Porovnání rychlosti výpočtu součinu MicroPythonem</h2>

<p>Opět se pokusme přepsat opakující se operaci násobení do MicroPythonu.
Nejedná se o příliš férové srovnání, protože kód není optimalizován. Na druhou
stranu je však napsán idiomaticky:</p>

<pre>
def <strong>loop_mul</strong>():
    x = 10
    for i in range(100):
        for j in range(100):
            x*=1
    return x
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
loop_mul()
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>Výsledek bude získán za 63364 časových jednotek:</p>

<pre>
63364
</pre>

<p>To vlastně odpovídá srovnání rychlosti operací součtu: 4704 vs 59022.</p>

<p><div class="rs-tip-major">Poznámka: Pythonní verze ve skutečnosti provádí i
další operace, například podporuje čísla s&nbsp;de facto neomezeným rozsahem
atd. Ostatně pokud změníte operaci násobení na <strong>x*=2</strong>, nejenže
se nemusíte dočkat výsledku, ale může dojít i k&nbsp;zaplnění celé operační
paměti.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce pro porovnání dvou hodnot</h2>

<p>S&nbsp;instrukcí <strong>CMP</strong> určenou pro porovnání dvou hodnot jsme
se již setkali. Tato instrukce ve skutečnosti existuje ve dvou variantách
&ndash; porovnání dvou registrů a porovnání registru s&nbsp;krátkou osmibitovou
konstantou (což se velmi často využije, protože se typicky porovnává
s&nbsp;nulou či jedničkou). A zajímavá je i existence instrukce pro součet
obsahu dvou registrů a nastavení všech příznaků:</p>

<table>
<tr><th>Instrukce</th><th>Zápis v&nbsp;MicroPythonu</th><th>Význam</th></tr>
<tr><td>CMP Rd, #konstanta</td><td>cmp(Rd, konstanta)</td><td>porovnání dvou hodnot s&nbsp;nastavením příznaků</td></tr>
<tr><td>CMP Rd, Rs</td><td>cmp(Rd, Rs)</td><td>porovnání dvou hodnot s&nbsp;nastavením příznaků</td></tr>
<tr><td>CMN Rd, Rs</td><td>cmn(Rd, Rs)</td><td>součet dvou 32bitových hodnot s&nbsp;nastavením příznaků</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zbylé instrukce pro práci na úrovni jednotlivých bitů</h2>

<p>V&nbsp;MicroPythonu nalezneme i dvě instrukce ze sady Thumb-2, které pracují
na úrovni jednotlivých bitů. Jedná se o tyto instrukce:</p>

<table>
<tr><th>Instrukce</th><th>Zápis v&nbsp;MicroPythonu</th><th>Význam</th></tr>
<tr><td>CLZ Rd, Rn</td><td>clz(Rd, Rn)</td><td>detekce délky sekvence nulových bitů v&nbsp;registru (hledáno od nejvyššího bitu)</td></tr>
<tr><td>RBIT Rd, Rn</td><td>rbit(Rd, Rn)</td><td>otočení bitů v&nbsp;předaném vstupním registru</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: tyto instrukce nebudou dostupné na
čipech s&nbsp;jádrem Cortex-M0(+) či Cortex-M1.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Prefix IT v&nbsp;instrukční sadě Thumb-2</h2>

<p>Tvůrci instrukční sady <i>Thumb-2</i> se taktéž snažili nějakým způsobem
nahradit kdysi populární kombinaci příznakových bitů, které byly součástí
většiny instrukcí klasické RISCové instrukční sady A32. Z&nbsp;tohoto důvodu do
instrukční sady <i>Thumb-2</i> přidali jednu z&nbsp;nejzajímavějších instrukcí,
které kdy pro RISCové mikroprocesory vznikly (a otázkou je, do jaké míry se
jedná o RISCovou instrukci).</p>

<p>Jedná se vlastně o instrukční prefix nazvaný <strong>IT</strong> podle
sousloví <i>if-then</i>. Tento prefix může být aplikován na jednu až čtyři
instrukce následující za prefixem. Ihned za prefixem <strong>IT</strong> se
(bez mezery) udává, zda má být daná instrukce provedena při splnění podmínky
(<strong>T</strong> &ndash; <i>then</i>) či naopak při jejím nesplnění
(<strong>E</strong> &ndash; <i>else</i>). U první instrukce je automaticky
předpokládáno <strong>T</strong>, tudíž se uvádí maximálně tři kombinace znaků
T/E. Samozřejmě je taktéž nutné zapsat i testovanou podmínku &ndash; může se
jednat o kódy používané jak u podmíněných skoků (<i>Thumb</i>, <i>AArch64</i>),
tak i v&nbsp;podmínkových bitech (<i>ARM32</i>):</p>

<table>
<tr><th>Kód</th><th>Význam</th><th>Předchozí operace porovnání</th></tr>
<tr><td>EQ</td><td>Z==1 (rovno)</td><td>signed i unsigned</td></tr>
<tr><td>NE</td><td>Z==0 (nerovno)</td><td>signed i unsigned</td></tr>
<tr><td>CS</td><td>C==1 (větší nebo rovno)</td><td>unsigned</td></tr>
<tr><td>CC</td><td>C==0 (menší než)</td><td>unsigned</td></tr>
<tr><td>MI</td><td>N==1 (záporný výsledek)</td><td>signed</td></tr>
<tr><td>PL</td><td>N==0 (kladný nebo nulový výsledek)</td><td>signed</td></tr>
<tr><td>VS</td><td>V==1 (přetečení)</td><td>signed</td></tr>
<tr><td>VC</td><td>V==0 (nedošlo k přetečení)</td><td>signed</td></tr>
<tr><td>HI</td><td>C==1 &amp; Z==0 (vetší než)</td><td>unsigned</td></tr>
<tr><td>LS</td><td>C==0 | Z==1 (menší nebo rovno)</td><td>unsigned</td></tr>
<tr><td>GE</td><td>N==V (větší nebo rovno)</td><td>signed</td></tr>
<tr><td>LT</td><td>N!=V (menší než)</td><td>signed</td></tr>
<tr><td>GT</td><td>Z==0 &amp; N==V (větší než)</td><td>signed</td></tr>
<tr><td>LE</td><td>Z==1 N!=V (menší nebo rovno)</td><td>signed</td></tr>
</table>

<p>V&nbsp;praxi to může znamenat, že zápis v&nbsp;assembleru:</p>

<pre>
ITEEE EQ
</pre>

<p>značí, že pokud je nastaven příznak <i>zero</i> (rovnost), je provedena jen
první instrukce následující za prefixem, kdežto další tři instrukce nebudou
provedeny (třikrát &bdquo;else&ldquo;).</p>

<p>Pokud by se měly provést tři instrukce v&nbsp;případě kladného výsledku
předchozího porovnání, použil by se zápis:</p>

<pre>
ITTT PL
</pre>

<p>Porovnejme si nyní tři identické algoritmy. První z&nbsp;nich je
implementovaný s&nbsp;využitím instrukcí <i>A32</i> s&nbsp;podmínkovými
bity:</p>

<pre>
        LDREQ r0,[r1]      <i>; if EQ then LDR</i>
        LDRNE r0,[r2]      <i>; if NE then LDR</i>
        ADDEQ r0, r3, r0   <i>; if EQ then ADD</i>
        ADDNE r0, r4, r0   <i>; if NE then ADD</i>
</pre>

<p>V&nbsp;případě použití instrukční sady <i>Thumb</i> musíme využít podmíněné
skoky se všemi nepříjemnostmi, které z&nbsp;toho plynou:</p>

<pre>
        BNE L1             <i>; opačná podmínka - přeskočení instrukce</i>
        LDR r0, [r1]
        ADD r0, r3, r0     <i>; máme štěstí: můžeme prohodit pořadí operandů</i>
        B L2
L1                         
        LDR r0, [r2]
        ADD r0, r4, r0
L2
</pre>

<p>U instrukční sady <i>Thumb-2</i> lze v&nbsp;tomto případu s&nbsp;výhodou
použít prefixovou instrukci <strong>IT</strong>:</p>

<pre>
        ITETE EQ
        LDR r0, [r1]
        LDR r0, [r2]
        ADD r0, r3, r0
        ADD r0, r4, r0
</pre>

<p>Na závěr si ještě všechny tři implementace pro zajímavost porovnáme, a to
jak z&nbsp;hlediska velikosti programového kódu, tak i z&nbsp;hlediska celkové
doby trvání výpočtu:</p>

<table>
<tr><th>Instrukční sada</th><th>Velikost kódu</th><th>Počet cyklů</th></tr>
<tr><td>ARM (RISC)</td><td>16 bajtů</td><td>4 cykly</td></tr>
<tr><td>Thumb     </td><td>12 bajtů</td><td>4-20 cyklů</td></tr>
<tr><td>Thumb-2   </td><td>10 bajtů</td><td>4-5 cyklů</td></tr>
</table>

<p>Výsledek: pokud máme kvalitní překladač, bude instrukční sada <i>Thumb-2</i>
s&nbsp;velkou pravděpodobností lepší, než snaha o implementaci A32. Tento
rozdíl bude ještě více patrný na mikrořadičích a tedy i jádrech
<i>Cortex-M</i>, protože zde může být program uložen v&nbsp;relativně pomalé
Flash ROM.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Realizace prefixu IT v&nbsp;MicroPythonu</h2>

<p>MicroPython prefix <strong>IT</strong> podporuje, a to ve všech variantách,
tedy například:</p>

<pre>
ite
itt
itee
itete
iteee
ittte
</pre>

<p>atd.</p>

<p>Do zvoleného prefixu se zapíše podmínka:</p>

<pre>
ite(eq)
ite(lt)
ittte(ne)
</pre>

<p>A potom již následuje jedna až čtyři instrukce vykonané v&nbsp;případě, že
podmínka je či naopak není splněna. Například můžeme vrátit výsledek 100 či 200
na základě porovnání dvou argumentů funkce:</p>

<pre>
cmp(r0, r1)
ite(eq)
mov(r0, 100) # if r0 == r1
mov(r0, 200) # if r0 != r1
</pre>

<p><div class="rs-tip-major">Poznámka: je ovšem nutné mít na paměti, že
populární mikrořadiče s&nbsp;jádry <i>Cortex-M0+</i> tuto instrukci
nepodporují.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Speciální instrukce</h2>

<p>A konečně nám zbývá několik speciálních instrukcí resp.&nbsp;instrukcí,
které nespadají do žádné výše uvedené kategorie:</p>

<table>
<tr><th>Instrukce</th><th>Zápis v&nbsp;MicroPythonu</th><th>Význam</th></tr>
<tr><td>NOP</td><td>nop()</td><td>pouze zvýšení PC (pseudoinstrukce)</td></tr>
<tr><td>WFI</td><td>wfi()</td><td>pozastavení MCU dokud nepřijde přerušení</td></tr>
<tr><td>CPSID příznaky</td><td>cpsid(příznaky)</td><td>zákaz přerušení</td></tr>
<tr><td>CPSIE příznaky</td><td>cpsie(příznaky)</td><td>povolení přerušení</td></tr>
<tr><td>MRS(Rd, APRS/PSR)</td><td>mrs(Rd, special_reg)</td><td>přesun obsahu speciálního registru do pracovního registru</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: poslední instrukci lze použít například
pro sledování, jak aritmetické a logické instrukce nastavují příznakové
registry. Ty jsou totiž uloženy ve speciálním registru PSR.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Doposud popsané instrukce a způsob jejich zápisu v&nbsp;MicroPythonu</h2>

<p>Prozatím jsme se seznámili se zápisem následujících instrukcí
v&nbsp;MicroPythonu. I když se to nezdá, jedná se o většinu instrukcí ze sady
Thumb:</p>

<table>
<tr><th>Instrukce</th><th>Zápis v&nbsp;MicroPythonu</th><th>Stručný popis</th></tr>
<tr><td>MOV r0, #0 </td><td>mov(r0, 0)</td><td>uložení krátké konstanty do pracovního registru</td></tr>
<tr><td>MOVW r0, #1000</td><td>movw(r0, 1000)</td><td>uložení 16bitového slova do pracovního registru</td></tr>
<tr><td>LDR r0, [r0, 0] či ldr r0, =adresa</td><td>ldr(r0, [r0, 0])</td><td>přečtení 32bitového slova ze zadané adresy</td></tr>
<tr><td>LDRB r0, [r0, 0] či ldrb r0, =adresa</td><td>ldrb(r0, [r0, 0])</td><td>přečtení bajtu ze zadané adresy</td></tr>
<tr><td>LDRW r0, [r0, 0] či ldrw r0, =adresa</td><td>ldrw(r0, [r0, 0])</td><td>přečtení 16bitového slova ze zadané adresy</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ADDS r1, r1, #1</td><td>add(r0, r0, 1)</td><td>součet registru s&nbsp;konstantou, zápis do obecně jiného registru</td></tr>
<tr><td>SUBS r1, r1, #1</td><td>sub(r1, r1, 1)</td><td>rozdíl, zde konkrétně snížení hodnoty registru R1 o jedničku s&nbsp;nastavením příznaků</td></tr>
<tr><td>CMP Rd, #konstanta</td><td>cmp(Rd, konstanta)</td><td>porovnání dvou hodnot s&nbsp;nastavením příznaků</td></tr>
<tr><td>CMP Rd, Rs</td><td>cmp(Rd, Rs)</td><td>porovnání dvou hodnot s&nbsp;nastavením příznaků</td></tr>
<tr><td>CMN Rd, Rs</td><td>cmn(Rd, Rs)</td><td>součet dvou 32bitových hodnot s&nbsp;nastavením příznaků</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>AND Rd, Rs</td><td>and_(Rd, Rs)</td><td>operace logického součinu bit po bitu</td></tr>
<tr><td>ORR Rd, Rs</td><td>orr(Rd, Rs)</td><td>operace logického součtu bit po bitu</td></tr>
<tr><td>EOR Rd, Rs</td><td>eor(Rd, Rs)</td><td>operace nonekvivalence bit po bitu</td></tr>
<tr><td>TST Rd, Rs</td><td>tst(Rd, Rs)</td><td>nastavení příznaků podle operace logického součinu bit po bitu</td></tr>
<tr><td>BIC Rd, Rs</td><td>bic(Rd, Rs)</td><td>operace AND NOT</td></tr>
<tr><td>MVN Rd, Rs</td><td>mvn(Rd, Rs)</td><td>negace všech bitů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>LSL Rd, Rs</td><td>lsl(Rd, Rs)</td><td>bitový posun doleva</td></tr>
<tr><td>LSR Rd, Rs</td><td>lsr(Rd, Rs)</td><td>bitový posun doprava</td></tr>
<tr><td>ASR Rd, Rs</td><td>asr(Rd, Rs)</td><td>aritmetický posun doprava</td></tr>
<tr><td>ROR Rd, Rs</td><td>ror(Rd, Rs)</td><td>rotace</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CLZ Rd, Rn</td><td>clz(Rd, Rn)</td><td>detekce délky sekvence nulových bitů v&nbsp;registru (hledáno od nejvyššího bitu)</td></tr>
<tr><td>RBIT Rd, Rn</td><td>rbit(Rd, Rn)</td><td>otočení bitů v&nbsp;předaném vstupním registru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>B cil_skoku</td><td>b(cil_skoku)</td><td>nepodmíněný skok na zadanou adresu (omezený rozsah, typicky pro jednu funkci/subrutinu)</td></tr>
<tr><td>BNE cil_skoku či b.ne cil_skoku</td><td>bne(cil_skoku)</td><td>podmíněný skok za podmínky, že příznak Z (<i>zero</i>) není nastaven</td></tr>
<tr><td>BEQ cil_skoku či b.ne cil_skoku</td><td>bne(cil_skoku)</td><td>podmíněný skok za podmínky, že příznak Z (<i>zero</i>) je nastaven</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>PUSH {registry}</td><td>push({registry})</td><td>uložení vybraných pracovních registrů na zásobník</td></tr>
<tr><td>POP {registry}</td><td>push({registry})</td><td>obnovení vybraných pracovních registrů ze zásobníku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>NOP</td><td>nop()</td><td>pouze zvýšení PC (pseudoinstrukce)</td></tr>
<tr><td>WFI</td><td>wfi()</td><td>pozastavení MCU dokud nepřijde přerušení</td></tr>
<tr><td>CPSID příznaky</td><td>cpsid(příznaky)</td><td>zákaz přerušení</td></tr>
<tr><td>CPSIE příznaky</td><td>cpsie(příznaky)</td><td>povolení přerušení</td></tr>
<tr><td>MRS(Rd, APRS/PSR)</td><td>mrs(Rd, special_reg)</td><td>přesun obsahu speciálního registru do pracovního registru</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
MicroPython běžící na čipech s&nbsp;architekturou Cortex-M0+
popř.&nbsp;Cortex-M3/M4 (a otestovaných na RP2040) byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th>#</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>return_constant.py</td><td>návratová hodnota z&nbsp;funkce s&nbsp;Thumb instrukcemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_constant.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_constant.py</a></td></tr>
<tr><td>2</td><td>return_big_constant_1.py</td><td>pokus o vrácení příliš velké konstanty (nekorektní)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_1.py</a></td></tr>
<tr><td>3</td><td>return_big_constant_2.py</td><td>pokus o vrácení příliš velké konstanty (nekorektní na Cortex-M0+)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_2.py</a></td></tr>
<tr><td>4</td><td>return_big_constant_3.py</td><td>vrácení 32bitové konstanty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>inc1.py</td><td>předání argumentu do funkce s&nbsp;Thumb instrukcemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc1.py</a></td></tr>
<tr><td>6</td><td>inc2.py</td><td>pokus o předání argumentu v&nbsp;parametru špatného jména</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>add.py</td><td>součet dvou předaných argumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add.py</a></td></tr>
<tr><td>8</td><td>add_four.py</td><td>součet čtyř předaných argumentů (nekorektní)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_four.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_four.py</a></td></tr>
<tr><td>9</td><td>add_five.py</td><td>součet pěti předaných argumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_five.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_five.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>inspect_function.py</td><td>získání strojového kódu přeložených funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function.py</a></td></tr>
<tr><td>11</td><td>no_op.py</td><td>funkce bez příkazů, která se má přeložit do strojového kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/no_op.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/no_op.py</a></td></tr>
<tr><td>12</td><td>branch1.py</td><td>využití instrukce nepodmíněného skoku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch1.py</a></td></tr>
<tr><td>13</td><td>branch2.py</td><td>skok dopředu o několik instrukcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch2.py</a></td></tr>
<tr><td>14</td><td>branch3.py</td><td>skok vzad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch3.py</a></td></tr>
<tr><td>15</td><td>loop1.py</td><td>programová smyčka s&nbsp;počitadlem a podmíněným skokem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop1.py</a></td></tr>
<tr><td>16</td><td>loop2.py</td><td>zjednodušená varianta programové smyčky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop2.py</a></td></tr>
<tr><td>17</td><td>loop3.py</td><td>vnořené programové smyčky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop3.py</a></td></tr>
<tr><td>18</td><td>loop4.py</td><td>benchmark: vnořené smyčky naprogramované v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop4.py</a></td></tr>
<tr><td>19</td><td>loop5.py</td><td>benchmark: vnořené smyčky naprogramované v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>inspect_function_2.py</td><td>získání strojového kódu přeložených funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function_2.py</a></td></tr>
<tr><td>21</td><td>loop6.py</td><td>programová smyčka s&nbsp;testem na začátku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop6.py</a></td></tr>
<tr><td>22</td><td>loop7.py</td><td>programová smyčka s&nbsp;testem na začátku (další varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop7.py</a></td></tr>
<tr><td>23</td><td>mul.py</td><td>instrukce součinu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/mul.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/mul.py</a></td></tr>
<tr><td>24</td><td>loop_mul_1.py</td><td>benchmark: rychlost násobení (strojové instrukce)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop_mul_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop_mul_1.py</a></td></tr>
<tr><td>25</td><td>loop_mul_2.py</td><td>benchmark: rychlost násobení (Python)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop_mul_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop_mul_2.py</a></td></tr>
<tr><td>26</td><td>ldrb.py</td><td>načtení jediného bajtu s&nbsp;rozšířením hodnoty na 32 bitů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ldrb.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ldrb.py</a></td></tr>
<tr><td>27</td><td>ldrh.py</td><td>načtení jediného 16bitového slova s&nbsp;rozšířením hodnoty na 32 bitů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ldrh.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ldrh.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>and.py</td><td>ukázka použití strojové instrukce <strong>AND</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/and.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/and.py</a></td></tr>
<tr><td>29</td><td>or.py</td><td>ukázka použití strojové instrukce <strong>OR</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/or.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/or.py</a></td></tr>
<tr><td>30</td><td>bic.py</td><td>ukázka použití strojové instrukce <strong>BIC</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/bic.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/bic.py</a></td></tr>
<tr><td>31</td><td>mvn.py</td><td>ukázka použití strojové instrukce <strong>MVN</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/mvn.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/mvn.py</a></td></tr>
<tr><td>32</td><td>lsl.py</td><td>ukázka použití strojové instrukce <strong>LSL</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/lsl.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/lsl.py</a></td></tr>
<tr><td>33</td><td>lsr.py</td><td>ukázka použití strojové instrukce <strong>LSR</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/lsr.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/lsr.py</a></td></tr>
<tr><td>34</td><td>asr.py</td><td>ukázka použití strojové instrukce <strong>ASR</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/asr.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/asr.py</a></td></tr>
<tr><td>35</td><td>ror.py</td><td>ukázka použití strojové instrukce <strong>ROR</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ror.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ror.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Online ARM converter<br />
<a href="https://armconverter.com/?disasm">https://armconverter.com/?disasm</a>
</li>

<li>Fast Filters for the Pyboard<br />
<a href="https://github.com/peterhinch/micropython-filters">https://github.com/peterhinch/micropython-filters</a>
</li>

<li>How to load 32 bit constant from assembler with @micropython.asm_thumb<br />
<a href="https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a">https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a</a>
</li>

<li>Pi pico, micropython.asm_thumb: ADR Rd, &lt;label&gt; and LDR Rd, &lt;label&gt; not implemented?<br />
<a href="https://github.com/orgs/micropython/discussions/12257">https://github.com/orgs/micropython/discussions/12257</a>
</li>

<li>MicroPython documentation<br />
<a href="https://docs.micropython.org/en/latest/index.html">https://docs.micropython.org/en/latest/index.html</a>
</li>

<li>Inline assembler for Thumb2 architectures<br />
<a href="https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html">https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html</a>
</li>

<li>Inline assembler in MicroPython<br />
<a href="https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler">https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami (2)<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>Cortex-M0 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M0">https://en.wikipedia.org/wiki/ARM_Cortex-M0</a>
</li>

<li>Cortex-M0+ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B">https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>The Thumb instruction set<br />
<a href="http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf">http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

