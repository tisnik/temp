<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Balíček array ze standardní knihovny Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Balíček array ze standardní knihovny Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Balíček <strong>array</strong> ze standardní knihovny Pythonu</a></p>
<p><a href="#k02">2. Konstrukce pole s&nbsp;určením typů jeho prvků</a></p>
<p><a href="#k03">3. Podporované typy prvků</a></p>
<p><a href="#k04">4. Obsazení operační paměti Pythonovským objektem</a></p>
<p><a href="#k05">5. Balíček <i>Pympler</i> pro přesnější informace o obsazení paměti Pythonem</a></p>
<p><a href="#k06">6. Obsazení paměti prázdným seznamem popř.&nbsp;prázdným polem</a></p>
<p><a href="#k07">7. Obsazení paměti seznamem popř.&nbsp;polem se sto prvky a 10000 prvky</a></p>
<p><a href="#k08">8. Sekvenční přístup k&nbsp;prvkům seznamů a polí</a></p>
<p><a href="#k09">9. Vložení hodnoty do seznamu či pole na určené místo (operace <i>insert</i>)</a></p>
<p><a href="#k10">*** 10. Interní struktura prvků polí</a></p>
<p><a href="#k11">*** 11. Uložení obsahu polí do souboru</a></p>
<p><a href="#k12">*** 12. Načtení obsahu polí z&nbsp;binárních souborů</a></p>
<p><a href="#k13">*** 13. Teoretická a praktická rychlost přístupu k&nbsp;prvkům polí</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. Interní způsob uložení pole v&nbsp;paměti</a></p>
<p><a href="#k16">*** 16. Algoritmus pro alokaci paměti pro zvětšující a zmenšující se pole</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Balíček <strong>array</strong> ze standardní knihovny Pythonu</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Konstrukce pole s&nbsp;určením typů jeho prvků</h2>

<p>Homogenní jednorozměrné pole se při použití standardního balíčku
<strong>array</strong> vytváří konstruktorem nazvaným taktéž
<strong>array</strong>. Tomuto konstruktoru se musí předat jednoznakový kód
typu prvků (viz tabulka zobrazená níže) a popř.&nbsp;hodnota, z&nbsp;níž se
odvodí prvky pole. Touto hodnotou může být seznam popř.&nbsp;hodnota typu
<strong>bytes</strong> nebo <strong>bytearray</strong>, tj.&nbsp;neměnitelné
popř.&nbsp;naopak měnitelné sekvence bajtů (připomeňme si, že hodnotu typu
<strong>bytes</strong> můžeme v&nbsp;případě potřeby zapsat formou
b"znaky").</p>

<p>Příklad konstrukce prázdného pole:</p>

<pre>
from array import array
&nbsp;
a1 = array(kód_typu_prvků)
</pre>

<p>Příklad konstrukce pole se specifikací hodnoty prvků seznamem:</p>

<pre>
from array import array
&nbsp;
a1 = array(kód_typu_prvků, [1, 2, 3, 4])
</pre>

<p>popř.</p>

<pre>
from array import array
&nbsp;
a1 = array("B", range(100))
</pre>

<p>Odlišný příklad konstrukce pole se specifikací hodnoty prvků sekvencí
bajtů:</p>

<pre>
from array import array
&nbsp;
a2 = array(kód_typu_prvků, b"ABCDEFGH")
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě musí být počet
bajtů v&nbsp;sekvenci celočíselně dělitelný velikostí prvku. Například pro
čtyřbajtové prvky (typicky <i>signed int</i> či <i>unsigned int</i>) musí být
počet bajtů dělitelný čtyřmi. Ostatně si to můžeme velmi snadno ověřit tak, že
budeme vyžadovat vytvoření pole s&nbsp;16bitovými hodnotami, ale předáme mu
v&nbsp;konstruktoru sekvenci bajtů, jejíž délka není celočíselně dělitelná
dvěma:</div></p>

<pre>
from array import array
&nbsp;
a2 = array("h", b"ABCDEFG")
</pre>

<p>V&nbsp;tomto případě dojde k&nbsp;vyhození výjimky:</p>

<pre>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: bytes length not a multiple of item size
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Podporované typy prvků</h2>

<p>Typ prvků je zakódován v&nbsp;jednoznakovém řetězci, který je předán jako
první parametr do konstruktoru <strong>array.array</strong>. Podporovány jsou
následující kódy, které vždy odpovídají jednomu datovému typu jazyka C a a mají
(tak) i specifikovánu minimální velikost v&nbsp;bajtech:</p>

<table>
<tr><th>Zápis typu</th><th>Odpovídající typ v C</th><th>Minimální velikost v&nbsp;B</th></tr>
<tr><td>"b"</td><td>signed char</td><td>1</td></tr>
<tr><td>"B"</td><td>unsigned char</td><td>1</td></tr>
<tr><td>"h"</td><td>signed short</td><td>2</td></tr>
<tr><td>"H"</td><td>unsigned short</td><td>2</td></tr>
<tr><td>"i"</td><td>signed int</td><td>2</td></tr>
<tr><td>"I"</td><td>unsigned int</td><td>2</td></tr>
<tr><td>"l"</td><td>signed long</td><td>4</td></tr>
<tr><td>"L"</td><td>unsigned long</td><td>4</td></tr>
<tr><td>"q"</td><td>signed long long</td><td>8</td></tr>
<tr><td>"Q"</td><td>unsigned long long</td><td>8</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>"f"</td><td>float</td><td>4</td></tr>
<tr><td>"d"</td><td>double</td><td>8</td></tr>
</table>

<p>Jen pro zajímavost se podívejme, jaké typy prvků jsou podporovány
v&nbsp;knihovně NumPy při konstrukci n-rozměrných polí. Jedná se sice o interně
odlišnou datovou strukturu s&nbsp;jiným způsobem použití, ale mnoho kódů je
shodných:</p>

<table>
<tr><th>Zápis typu</th><th>Odpovídající typ v C</th></tr>
<tr><td>"b"</td><td>signed char</td></tr>
<tr><td>"B"</td><td>unsigned char</td></tr>
<tr><td>"h"</td><td>signed short</td></tr>
<tr><td>"H"</td><td>unsigned short</td></tr>
<tr><td>"i"</td><td>signed int</td></tr>
<tr><td>"I"</td><td>unsigned int</td></tr>
<tr><td>"l"</td><td>signed long</td></tr>
<tr><td>"L"</td><td>unsigned long</td></tr>
<tr><td>"q"</td><td>signed long long</td></tr>
<tr><td>"Q"</td><td>unsigned long long</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>"e"</td><td>half float</td></tr>
<tr><td>"f"</td><td>float</td></tr>
<tr><td>"d"</td><td>double</td></tr>
<tr><td>"g"</td><td>long double</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>"F"</td><td>complex float</td></tr>
<tr><td>"D"</td><td>complex double</td></tr>
<tr><td>"G"</td><td>complex long double</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Obsazení operační paměti Pythonovským objektem</h2>

<p>Největší předností (a pravděpodobně i jedinou předností) balíčku
<strong>array</strong> je jeho schopnost efektivně uložit prvky určitého
datového typu do kontinuálního bloku operační paměti. To vede resp.&nbsp;mělo
by to vést k&nbsp;velkým paměťovým úsporám. Ovšem toto tvrzení je vhodné si
ověřit v&nbsp;praxi. Konkrétně tedy budeme porovnávat celkovou velikost seznamu
s&nbsp;n-položkami s&nbsp;jednotlivými poli realizovanými balíčkem
<strong>array</strong>.</p>

<p>Velikost, kterou nějaká hodnota zabírá v&nbsp;operační paměti, můžeme získat
s&nbsp;využitím standardní funkce <strong>sys.getsizeof</strong>. Největší (a
možná i jedinou) předností této funkce je fakt, že se jedná o funkci ze
standardní knihovny <strong>sys</strong>. To mj.&nbsp;znamená, že tuto funkci
je možné zavolat prakticky kdykoli a kdekoli, a to bez nutnosti instalace
nějakých dalších balíčků.</p>

<p>Ovšem na tomto místě je vhodné upozornit na to, že tato funkce není příliš
dokonalá, protože například neumožňuje zjistit velikost hodnot v&nbsp;operační
paměti po zarovnání, protože alokátor paměti alokuje nové bloky vždy na
adresách dělitelných nějakou konstantou 4, 8 či 16 (podle použitého operačního
systému a architektury mikroprocesoru) a tudíž vlastně nebudou využity bajty
umístěné těsně za koncem bloku v&nbsp;případě, že velikost bloku není dělitelná
výše uvedenou konstantou. A navíc má tato standardní funkce problémy se
zjištěním velikosti tříd a objektů, protože automaticky nezapočítává velikosti
jednotlivých atributů atd. A totéž platí i pro kolekce, mezi jinými i pro
seznamy.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Balíček <i>Pympler</i> pro přesnější informace o obsazení paměti Pythonem</h2>

<p>Existují však i další (ovšem nutno dodat, že již nestandardní) balíčky,
které &bdquo;opravují&ldquo; chování funkce <strong>sys.getsizeof</strong> a
navíc nabízí uživatelům i další zajímavou a potenciálně užitečnou
funkcionalitu. Tyto balíčky je však pochopitelně nutné nejdříve nainstalovat.
Prvním z&nbsp;balíčků, o nichž se dnes alespoň ve stručnosti zmíníme, je
balíček nazvaný <strong>Pympler</strong>. Vzhledem k&nbsp;tomu, že je
zaregistrovaný na <i>PyPi</i>, je instalace tohoto balíčku triviální a můžeme
ji provést (pro právě přihlášeného uživatele) tímto příkazem:</p>

<pre>
$ <strong>pip install --user pympler</strong>
</pre>

<p>Alternativně pro systémy, které ještě mají paralelní instalaci Pythonu 2 a
Pythonu 3, použijeme příkaz:</p>

<pre>
$ <strong>pip3 install --user pympler</strong>
</pre>

<p>Samotná instalace proběhne prakticky okamžitě:</p>

<pre>
Collecting pympler
  Downloading Pympler-1.0.1-py3-none-any.whl (164 kB)
     |████████████████████████████████| 164 kB 1.5 MB/s 
Installing collected packages: pympler
Successfully installed pympler-1.0.1
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě můžete provést instalaci i
tohoto balíčku v&nbsp;rámci virtuálního prostředí Pythonu atd.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Obsazení paměti prázdným seznamem popř.&nbsp;prázdným polem</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu zjistíme, jak velkou kapacitu
operační paměti musíme použít pro uložení prázdného seznamu (což je standardní
kolekce Pythonu) nebo prázdného pole s&nbsp;prvky zvoleného typu. Vytvoříme
tedy prázdný seznam konstruktorem:</p>

<pre>
l1 = []
</pre>

<p>a několik prázdných polí určených pro uložení prvků různého typu:</p>

<pre>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
</pre>

<p>Následně si s&nbsp;využitím funkce <strong>asizeof.asizeof</strong> necháme
vypočítat velikost obsazené paměti:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from pympler.asizeof import asizeof
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># výpis skutečných velikostí</i>
print("List:             ", asizeof(l1))
print("Array of bytes:   ", asizeof(a1))
print("Array of shorts:  ", asizeof(a2))
print("Array of ints:    ", asizeof(a3))
print("Array of longs:   ", asizeof(a4))
print("Array of quads:   ", asizeof(a5))
print("Array of floats:  ", asizeof(a6))
print("Array of doubles: ", asizeof(a7))
</pre>

<p>Výsledky budou vypadat následovně (hodnoty jsou reprezentovány
v&nbsp;bajtech):</p>

<pre>
List:              56
Array of bytes:    64
Array of shorts:   64
Array of ints:     64
Array of longs:    64
Array of quads:    64
Array of floats:   64
Array of doubles:  64
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě sice vyhrál
klasický seznam, ovšem stále se jedná o prázdné kolekce, takže tato výhra
v&nbsp;praxi většinou nic neznamená. Navíc se později zmíníme o tom, jak je
vlastně alokována paměť pro pole &ndash; zde se skrývá několik zajímavých
detailů.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Obsazení paměti seznamem popř.&nbsp;polem se sto prvky a 10000 prvky</h2>

<p>Nyní se pokusíme zjistit, kolik paměti bude obsazeno seznamem a poli se sto
prvky a posléze s&nbsp;tisíci prvky. Zdrojový kód příkladu upravíme
následujícím způsobem (povšimněte si, jak se do polí přidávají další
prvky):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from pympler.asizeof import asizeof
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    l1.append(i)
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
<i># výpis skutečných velikostí</i>
print("List:             ", asizeof(l1))
print("Array of bytes:   ", asizeof(a1))
print("Array of shorts:  ", asizeof(a2))
print("Array of ints:    ", asizeof(a3))
print("Array of longs:   ", asizeof(a4))
print("Array of quads:   ", asizeof(a5))
print("Array of floats:  ", asizeof(a6))
print("Array of doubles: ", asizeof(a7))
</pre>

<p>Výsledky pro stoprvkové kolekce:</p>

<pre>
List:              4096
Array of bytes:    168
Array of shorts:   272
Array of ints:     472
Array of longs:    880
Array of quads:    880
Array of floats:   472
Array of doubles:  880
</pre>

<p>Pro pole s&nbsp;tisíci hodnotami nepatrně upravíme programový kód určený pro
vkládání prvků, protože do polí s&nbsp;hodnotami typu bajt je možné uložit jen
hodnoty s&nbsp;omezeným rozsahem (127 resp.&nbsp;255):</p>

<pre>
for i in range(10000):
    l1.append(i)
    a1.append(i % 100)
    a2.append(i % 100)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
</pre>

<p>Výsledky pro kolekce s&nbsp;10000 prvky:</p>

<pre>
List:              407608
Array of bytes:    10152
Array of shorts:   20240
Array of ints:     40408
Array of longs:    80744
Array of quads:    80744
Array of floats:   40408
Array of doubles:  80744
</pre>

<p>Z&nbsp;výsledků je patrné, že u seznamů roste spotřeba paměti poměrně
výrazně, což by ale nemělo být překvapivé, protože hodnoty jsou zde boxovány.
Zajímavé ovšem je, že i u polí je obsazená paměť větší, než by to odpovídalo
výpočtu <i>počet_prvků&times;velikost_jednoho prvku</i>. U rozsáhlejších polí
je &bdquo;nadbytečná&ldquo; spotřeba paměti rovna přibližně jednomu až třem
procentům, takže se většinou nejedná o výrazný problém. A opět si ještě
řekneme, proč tomu tak je.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Sekvenční přístup k&nbsp;prvkům seznamů a polí</h2>

<p>V&nbsp;případě, že použijeme standardní seznamy, je sekvenční průchod prvky
seznamů v&nbsp;Pythonu realizován tímto idiomatickým zápisem:</p>

<pre>
lst = ["foo", "bar", "baz"]
&nbsp;
for item in lst:
    print(item)
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně je možné použít i další
způsoby, ovšem ty nejsou příliš často k&nbsp;vidění.</div></p>

<p>Naprosto stejným způsobem je možné procházet i prvky polí, což je velmi
rozumné. Příkladem může být průchod polem se čtyřmi prvky typu
&bdquo;bajt&ldquo;:</p>

<pre>
arr = array("B", [1, 2, 3, 4])
&nbsp;
for item in arr:
    print(item)
</pre>

<p>Všemi typy polí se prochází naprosto stejným způsobem, nezávisle na typu
jejich prvků:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    l1.append(i)
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
&nbsp;
def <strong>print_all_items</strong>(name, struct):
    <i>"""Vytištění všech prvků uložených ve struktuře."""</i>
    print(name)
    for item in struct:
        print(item, end=" ")
    print("\n")
&nbsp;
&nbsp;
print_all_items("List:", l1)
print_all_items("Array of bytes:", a1)
print_all_items("Array of shorts:", a2)
print_all_items("Array of ints:", a3)
print_all_items("Array of longs:", a4)
print_all_items("Array of quads:", a5)
print_all_items("Array of floats:", a6)
print_all_items("Array of doubles:", a7)
</pre>

<p>Výsledky zobrazené tímto příkladem na terminálu:</p>

<pre>
List:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of bytes:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of shorts:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of ints:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of longs:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of quads:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of floats:
0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0 19.0 20.0 21.0 22.0 23.0 24.0 25.0 26.0 27.0 28.0 29.0 30.0 31.0 32.0 33.0 34.0 35.0 36.0 37.0 38.0 39.0 40.0 41.0 42.0 43.0 44.0 45.0 46.0 47.0 48.0 49.0 50.0 51.0 52.0 53.0 54.0 55.0 56.0 57.0 58.0 59.0 60.0 61.0 62.0 63.0 64.0 65.0 66.0 67.0 68.0 69.0 70.0 71.0 72.0 73.0 74.0 75.0 76.0 77.0 78.0 79.0 80.0 81.0 82.0 83.0 84.0 85.0 86.0 87.0 88.0 89.0 90.0 91.0 92.0 93.0 94.0 95.0 96.0 97.0 98.0 99.0 
&nbsp;
Array of doubles:
0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0 19.0 20.0 21.0 22.0 23.0 24.0 25.0 26.0 27.0 28.0 29.0 30.0 31.0 32.0 33.0 34.0 35.0 36.0 37.0 38.0 39.0 40.0 41.0 42.0 43.0 44.0 45.0 46.0 47.0 48.0 49.0 50.0 51.0 52.0 53.0 54.0 55.0 56.0 57.0 58.0 59.0 60.0 61.0 62.0 63.0 64.0 65.0 66.0 67.0 68.0 69.0 70.0 71.0 72.0 73.0 74.0 75.0 76.0 77.0 78.0 79.0 80.0 81.0 82.0 83.0 84.0 85.0 86.0 87.0 88.0 89.0 90.0 91.0 92.0 93.0 94.0 95.0 96.0 97.0 98.0 99.0 
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vložení hodnoty do seznamu či pole na určené místo (operace <i>insert</i>)</h2>

<p>V&nbsp;předchozích demonstračních příkladech jsme prvky do seznamu a polí
<i>připojovali</i>, což je u obou zmíněných datových struktur realizováno
operací se stejným jménem &ndash; <strong>append</strong>. Díky tomu, že prvky
byly připojovány vždy až na konec pole (přesněji řečeno <i>za</i> konec pole),
nebylo nutné specifikovat index přidávaného prvku. Ovšem jinak je tomu u
operace <i>vkládaní</i> neboli <strong>insert</strong>. V&nbsp;tomto případě
specifikujeme index, do kterého bude nový prvek přidán (a zbytek prvků bude
odsunut). Pravděpodobně je zřejmé, že se jedná o obecně časově náročnou
operaci, která může vyžadovat jak realokaci samotného pole, tak i přesuny
prvků. I operace <strong>insert</strong> má stejnou sémantiku pro seznamy i pro
pole včetně kontroly hodnoty indexu, možnosti použití záporných indexů (pro
indexování zprava) atd.</p>

<p>Seznamy:</p>

<pre>
<strong>l = ["foo", "bar"]</strong>
&nbsp;
<strong>l.insert(0, "baz")</strong>
<strong>print(l)</strong>
['baz', 'foo', 'bar']
&nbsp;
<strong>l.insert(3, "END")</strong>
<strong>print(l)</strong>
['baz', 'foo', 'bar', 'END']
&nbsp;
<strong>l.insert(-1, ".")</strong>
<strong>print(l)</strong>
['baz', 'foo', 'bar', '.', 'END']
&nbsp;
<strong>l.insert(1000, "not-possible?")</strong>
<strong>print(l)</strong>
['baz', 'foo', 'bar', '.', 'END', 'not-possible?']
</pre>

<p>Pole:</p>

<pre>
<strong>a = array("B", [10, 20])</strong>
&nbsp;
<strong>a.insert(0, 5)</strong>
<strong>print(a)</strong>
array('B', [5, 10, 20])
&nbsp;
<strong>a.insert(3, 30)</strong>
<strong>print(a)</strong>
array('B', [5, 10, 20, 30])
&nbsp;
<strong>a.insert(-1, 0)</strong>
<strong>print(a)</strong>
array('B', [5, 10, 20, 0, 30])
&nbsp;
<strong>a.insert(10000, 40)</strong>
<strong>print(a)</strong>
array('B', [5, 10, 20, 0, 30, 40])
</pre>

<p>To znamená, že jak pole tak seznamy můžeme naplnit operací &bdquo;připojení
zleva&ldquo;, protože sémantika <strong>insert(0, hodnota)</strong> vlastně
odpovídá sémantice <strong>append(hodnota)</strong> v&nbsp;případě, pokud by se
prvky připojovaly <i>před začátek</i> sekvence a nikoli <i>za konec</i>
sekvence:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    l1.insert(0, i)
    a1.insert(0, i)
    a2.insert(0, i)
    a3.insert(0, i)
    a4.insert(0, i)
    a5.insert(0, i)
    a6.insert(0, i)
    a7.insert(0, i)
&nbsp;
&nbsp;
def <strong>print_all_items</strong>(name, struct):
    <i>"""Vytištění všech prvků uložených ve struktuře."""</i>
    print(name)
    for item in struct:
        print(item, end=" ")
    print("\n")
&nbsp;
&nbsp;
print_all_items("List:", l1)
print_all_items("Array of bytes:", a1)
print_all_items("Array of shorts:", a2)
print_all_items("Array of ints:", a3)
print_all_items("Array of longs:", a4)
print_all_items("Array of quads:", a5)
print_all_items("Array of floats:", a6)
print_all_items("Array of doubles:", a7)
</pre>

<p>S&nbsp;výsledky, které nejsou ničím překvapující:</p>

<pre>
List:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of bytes:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of shorts:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of ints:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of longs:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of quads:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of floats:
99.0 98.0 97.0 96.0 95.0 94.0 93.0 92.0 91.0 90.0 89.0 88.0 87.0 86.0 85.0 84.0 83.0 82.0 81.0 80.0 79.0 78.0 77.0 76.0 75.0 74.0 73.0 72.0 71.0 70.0 69.0 68.0 67.0 66.0 65.0 64.0 63.0 62.0 61.0 60.0 59.0 58.0 57.0 56.0 55.0 54.0 53.0 52.0 51.0 50.0 49.0 48.0 47.0 46.0 45.0 44.0 43.0 42.0 41.0 40.0 39.0 38.0 37.0 36.0 35.0 34.0 33.0 32.0 31.0 30.0 29.0 28.0 27.0 26.0 25.0 24.0 23.0 22.0 21.0 20.0 19.0 18.0 17.0 16.0 15.0 14.0 13.0 12.0 11.0 10.0 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0 
&nbsp;
Array of doubles:
99.0 98.0 97.0 96.0 95.0 94.0 93.0 92.0 91.0 90.0 89.0 88.0 87.0 86.0 85.0 84.0 83.0 82.0 81.0 80.0 79.0 78.0 77.0 76.0 75.0 74.0 73.0 72.0 71.0 70.0 69.0 68.0 67.0 66.0 65.0 64.0 63.0 62.0 61.0 60.0 59.0 58.0 57.0 56.0 55.0 54.0 53.0 52.0 51.0 50.0 49.0 48.0 47.0 46.0 45.0 44.0 43.0 42.0 41.0 40.0 39.0 38.0 37.0 36.0 35.0 34.0 33.0 32.0 31.0 30.0 29.0 28.0 27.0 26.0 25.0 24.0 23.0 22.0 21.0 20.0 19.0 18.0 17.0 16.0 15.0 14.0 13.0 12.0 11.0 10.0 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0 
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Interní struktura prvků polí</h2>

<p></p>

<pre>
def <strong>print_all_items_as_hex</strong>(name, struct):
    print(name)
    print(struct.tobytes().hex(" "))
    print()
</pre>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(10):
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
&nbsp;
def <strong>print_all_items_as_hex</strong>(name, struct):
    print(name)
    print(struct.tobytes().hex(" "))
    print()
&nbsp;
&nbsp;
print_all_items_as_hex("Array of bytes:", a1)
print_all_items_as_hex("Array of shorts:", a2)
print_all_items_as_hex("Array of ints:", a3)
print_all_items_as_hex("Array of longs:", a4)
print_all_items_as_hex("Array of quads:", a5)
print_all_items_as_hex("Array of floats:", a6)
print_all_items_as_hex("Array of doubles:", a7)
</pre>

<pre>
Array of bytes:
00 01 02 03 04 05 06 07 08 09

Array of shorts:
00 00 01 00 02 00 03 00 04 00 05 00 06 00 07 00 08 00 09 00

Array of ints:
00 00 00 00 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 05 00 00 00 06 00 00 00 07 00 00 00 08 00 00 00 09 00 00 00

Array of longs:
00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 05 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 07 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 09 00 00 00 00 00 00 00

Array of quads:
00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 05 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 07 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 09 00 00 00 00 00 00 00

Array of floats:
00 00 00 00 00 00 80 3f 00 00 00 40 00 00 40 40 00 00 80 40 00 00 a0 40 00 00 c0 40 00 00 e0 40 00 00 00 41 00 00 10 41

Array of doubles:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 f0 3f 00 00 00 00 00 00 00 40 00 00 00 00 00 00 08 40 00 00 00 00 00 00 10 40 00 00 00 00 00 00 14 40 00 00 00 00 00 00 18 40 00 00 00 00 00 00 1c 40 00 00 00 00 00 00 20 40 00 00 00 00 00 00 22 40
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Uložení obsahu polí do souboru</h2>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
&nbsp;
def export_to_file(filename, struct):
    """Export celé struktury do souboru."""
    with open(filename, "wb") as f:
        struct.tofile(f)
&nbsp;
&nbsp;
export_to_file("bytes.bin", a1)
export_to_file("shorts.bin", a2)
export_to_file("ints.bin", a3)
export_to_file("longs.bin", a4)
export_to_file("quads.bin", a5)
export_to_file("floats.bin", a6)
export_to_file("doubles.bin", a7)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Načtení obsahu polí z&nbsp;binárních souborů</h2>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
&nbsp;
def <strong>import_from_file</strong>(filename, struct):
    <i>"""Import celé struktury ze souboru."""</i>
    with open(filename, "rb") as f:
        struct.fromfile(f, 100)
    return struct
&nbsp;
&nbsp;
print(import_from_file("bytes.bin", a1))
print(import_from_file("shorts.bin", a2))
print(import_from_file("ints.bin", a3))
print(import_from_file("longs.bin", a4))
print(import_from_file("quads.bin", a5))
print(import_from_file("floats.bin", a6))
print(import_from_file("doubles.bin", a7))
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Teoretická a praktická rychlost přístupu k&nbsp;prvkům polí</h2>

<pre>
from time import perf_counter
import random
&nbsp;
size = 10000
&nbsp;
a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
t1 = perf_counter()
&nbsp;
for i in range(size - 1, 0, -1):
    for j in range(0, i):
        if a[j] &gt; a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Sorted in {t2-t1} seconds:")
&nbsp;
print("\nBegins with:")
print(a[:100])
&nbsp;
print("\nEnds with:")
print(a[-100:])
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
from time import perf_counter
from array import array
import random
&nbsp;
size = 10000
&nbsp;
a = array("I", [random.randrange(0, 10000) for i in range(size)])
&nbsp;
t1 = perf_counter()
&nbsp;
for i in range(size - 1, 0, -1):
    for j in range(0, i):
        if a[j] &gt; a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Sorted in {t2-t1} seconds:")
&nbsp;
print("\nBegins with:")
print(a[:100])
&nbsp;
print("\nEnds with:")
print(a[-100:])
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Interní způsob uložení pole v&nbsp;paměti</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Algoritmus pro alokaci paměti pro zvětšující a zmenšující se pole</h2>

 

<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Odkazy na jednotlivé příklady jsou uvedeny v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>empty_structs.py</td><td>inicializace prázdných struktur (seznamu a polí) a získání jejich velikosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/empty_structs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/empty_structs.py</a></td></tr>
<tr><td> 2</td><td>hundred_items.py</td><td>přidání 100 prvků do každé struktury a získání jejich velikosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/hundred_items.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/hundred_items.py</a></td></tr>
<tr><td> 3</td><td>10000_items.py</td><td>přidání 10000 prvků do každé struktury a získání jejich velikosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/10000_items.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/10000_items.py</a></td></tr>
<tr><td> 4</td><td>read_values.py</td><td>čtení hodnot prvků ze seznamů a polí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/read_values.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/read_values.py</a></td></tr>
<tr><td> 5</td><td>insert_item.py</td><td>operace pro vložení prvku na zvolený index</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/insert_item.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/insert_item.py</a></td></tr>
<tr><td> 6</td><td>tobytes.py</td><td>konverze polí na hodnotu typu <strong>bytes</strong> s&nbsp;jejím tiskem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/tobytes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/tobytes.py</a></td></tr>
<tr><td> 7</td><td>export_to_file.py</td><td>export polí do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/export_to_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/export_to_file.py</a></td></tr>
<tr><td> 8</td><td>import_from_file.py</td><td>import polí z&nbsp;binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/import_from_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/import_from_file.py</a></td></tr>
<tr><td> 9</td><td>bubble_sort_1.py </td><td>algoritmus bublinkového řazení realizovaný nad seznamy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_1.py</a></td></tr>
<tr><td>10</td><td>bubble_sort_2.py </td><td>algoritmus bublinkového řazení realizovaný nad polem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>array — Efficient arrays of numeric values<br />
<a href="https://docs.python.org/3/library/array.html">https://docs.python.org/3/library/array.html</a>
</li>

<li>Top 5 Python Memory Profilers<br />
<a href="https://stackify.com/top-5-python-memory-profilers/">https://stackify.com/top-5-python-memory-profilers/</a>
</li>

<li>Pympler na GitHubu<br />
<a href="https://github.com/pympler/pympler">https://github.com/pympler/pympler</a>
</li>

<li>Pympler na PyPI<br />
<a href="https://pypi.org/project/Pympler/">https://pypi.org/project/Pympler/</a>
</li>

<li>Dokumentace k&nbsp;balíčku Pympler<br />
<a href="https://pympler.readthedocs.io/en/latest/">https://pympler.readthedocs.io/en/latest/</a>
</li>

<li>Guppy 3 na GitHubu<br />
<a href="https://github.com/zhuyifei1999/guppy3/">https://github.com/zhuyifei1999/guppy3/</a>
</li>

<li>Guppy 3 na PyPI<br />
<a href="https://pypi.org/project/guppy3/">https://pypi.org/project/guppy3/</a>
</li>

<li>Memory Profiler na GitHubu<br />
<a href="https://github.com/pythonprofilers/memory_profiler">https://github.com/pythonprofilers/memory_profiler</a>
</li>

<li>Memory Profiler na PyPI<br />
<a href="https://pypi.org/project/memory-profiler/">https://pypi.org/project/memory-profiler/</a>
</li>

<li>How to use guppy/heapy for tracking down memory usage<br />
<a href="https://smira.ru/wp-content/uploads/2011/08/heapy.html">https://smira.ru/wp-content/uploads/2011/08/heapy.html</a>
</li>

<li>Identifying memory leaks<br />
<a href="https://pympler.readthedocs.io/en/latest/muppy.html#muppy">https://pympler.readthedocs.io/en/latest/muppy.html#muppy</a>
</li>

<li>How do I determine the size of an object in Python?<br />
<a href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python</a>
</li>

<li>Why is bool a subclass of int?<br />
<a href="https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int">https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int</a>
</li>

<li>Memory Management in Python<br />
<a href="https://realpython.com/python-memory-management/">https://realpython.com/python-memory-management/</a>
</li>

<li>Why do ints require three times as much memory in Python?<br />
<a href="https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python">https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python</a>
</li>

<li>cpython/Include/cpython/longintrepr.h<br />
<a href="https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64">https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64</a>
</li>

<li>sys — System-specific parameters and functions<br />
<a href="https://docs.python.org/3/library/sys.html">https://docs.python.org/3/library/sys.html</a>
</li>

<li>Stránky projektu Numpy<br />
<a href="https://numpy.org/">https://numpy.org/</a>
</li>

<li>Numpy na GitHubu<br />
<a href="https://github.com/numpy/numpy">https://github.com/numpy/numpy</a>
</li>

<li>NumPy documentation<br />
<a href="https://numpy.org/doc/stable/">https://numpy.org/doc/stable/</a>
</li>

<li>The N-dimensional array (ndarray)<br />
<a href="https://numpy.org/doc/stable/reference/arrays.ndarray.html">https://numpy.org/doc/stable/reference/arrays.ndarray.html</a>
</li>

<li>numpy.ndarray<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html">https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

