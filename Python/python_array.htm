<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">2. Konstrukce pole s&nbsp;určením typů jeho prvků</a></p>
<p><a href="#k03">3. Obsazení operační paměti Pythonovským objektem</a></p>
<p><a href="#k04">4. Balíček <i>Pympler</i> pro přesnější informace o obsazení paměti Pythonem</a></p>
<p><a href="#k05">5. Obsazení paměti prázdným seznamem popř.&nbsp;prázdným polem</a></p>
<p><a href="#k06">6. Obsazení paměti seznamem popř.&nbsp;polem se sto prvky a 10000 prvky</a></p>
<p><a href="#k07">*** 7. Sekvenční přístup k&nbsp;prvkům seznamů a polí</a></p>
<p><a href="#k08">*** 8. Vložení hodnoty do seznamu či pole na určené místo (operace <i>insert</i>)</a></p>
<p><a href="#k09">*** 9. Interní struktura polí</a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Konstrukce pole s&nbsp;určením typů jeho prvků</h2>

<p>Homogenní jednorozměrné pole se při použití standardního balíčku
<strong>array</strong> vytváří konstruktorem nazvaným taktéž
<strong>array</strong>. Tomuto konstruktoru se musí předat jednoznakový kód
typu prvků (viz tabulka zobrazená níže) a popř.&nbsp;hodnota, z&nbsp;níž se
odvodí prvky pole. Touto hodnotou může být seznam popř.&nbsp;hodnota typu
<strong>bytes</strong> nebo <strong>bytearray</strong>, tj.&nbsp;neměnitelné
popř.&nbsp;naopak měnitelné sekvence bajtů (připomeňme si, že hodnotu typu
<strong>bytes</strong> můžeme v&nbsp;případě potřeby zapsat formou
b"znaky").</p>

<p>Příklad konstrukce prázdného pole:</p>

<pre>
from array import array
&nbsp;
a1 = array(kód_typu_prvků)
</pre>

<p>Příklad konstrukce pole se specifikací hodnoty prvků seznamem:</p>

<pre>
from array import array
&nbsp;
a1 = array(kód_typu_prvků, [1, 2, 3, 4])
</pre>

<p>Odlišný příklad konstrukce pole se specifikací hodnoty prvků sekvencí
bajtů:</p>

<pre>
from array import array
&nbsp;
a2 = array(kód_typu_prvků, b"ABCDEFGH")
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě musí být počet
bajtů v&nbsp;sekvenci celočíselně dělitelný velikostí prvku. Například pro
čtyřbajtové prvky (typicky <i>signed int</i> či <i>unsigned int</i>) musí být
počet bajtů dělitelný čtyřmi.</div></p>

<p>Typ prvků je zakódován v&nbsp;jednoznakovém řetězci. Podporovány jsou
následující kódy, které vždy odpovídají jednomu datovému typu jazyka C a a mají
(tak) i specifikovánu minimální velikost v&nbsp;bajtech:</p>

<table>
<tr><th>Zápis typu</th><th>Odpovídající typ v C</th><th>Minimální velikost v&nbsp;B</th></tr>
<tr><td>"b"</td><td>signed char</td><td>1</td></tr>
<tr><td>"B"</td><td>unsigned char</td><td>1</td></tr>
<tr><td>"h"</td><td>signed short</td><td>2</td></tr>
<tr><td>"H"</td><td>unsigned short</td><td>2</td></tr>
<tr><td>"i"</td><td>signed int</td><td>2</td></tr>
<tr><td>"I"</td><td>unsigned int</td><td>2</td></tr>
<tr><td>"l"</td><td>signed long</td><td>4</td></tr>
<tr><td>"L"</td><td>unsigned long</td><td>4</td></tr>
<tr><td>"q"</td><td>signed long long</td><td>8</td></tr>
<tr><td>"Q"</td><td>unsigned long long</td><td>8</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>"f"</td><td>float</td><td>4</td></tr>
<tr><td>"d"</td><td>double</td><td>8</td></tr>
</table>

<p>Jen pro zajímavost se podívejme, jaké typy prvků jsou podporovány
v&nbsp;knihovně NumPy při konstrukci n-rozměrných polí. Jedná se sice o interně
odlišnou strukturu s&nbsp;jiným způsobem použití, ale mnoho kódů je
shodných:</p>

<table>
<tr><th>Zápis typu</th><th>Odpovídající typ v C</th></tr>
<tr><td>"b"</td><td>signed char</td></tr>
<tr><td>"B"</td><td>unsigned char</td></tr>
<tr><td>"h"</td><td>signed short</td></tr>
<tr><td>"H"</td><td>unsigned short</td></tr>
<tr><td>"i"</td><td>signed int</td></tr>
<tr><td>"I"</td><td>unsigned int</td></tr>
<tr><td>"l"</td><td>signed long</td></tr>
<tr><td>"L"</td><td>unsigned long</td></tr>
<tr><td>"q"</td><td>signed long long</td></tr>
<tr><td>"Q"</td><td>unsigned long long</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>"e"</td><td>half float</td></tr>
<tr><td>"f"</td><td>float</td></tr>
<tr><td>"d"</td><td>double</td></tr>
<tr><td>"g"</td><td>long double</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>"F"</td><td>complex float</td></tr>
<tr><td>"D"</td><td>complex double</td></tr>
<tr><td>"G"</td><td>complex long double</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Obsazení operační paměti Pythonovským objektem</h2>

<p>Největší předností (a pravděpodobně i jedinou předností) balíčku
<strong>array</strong> je jeho schopnost efektivně uložit prvky určitého
datového typu do kontinuálního bloku operační paměti. To vede resp.&nbsp;mělo
by to vést k&nbsp;velkým paměťovým úsporám. Ovšem toto tvrzení je vhodné si
ověřit v&nbsp;praxi. Konkrétně tedy budeme porovnávat celkovou velikost seznamu
s&nbsp;n-položkami s&nbsp;jednotlivými poli realizovanými balíčkem
<strong>array</strong>.</p>

<p>Velikost, kterou nějaká hodnota zabírá v&nbsp;operační paměti, můžeme získat
s&nbsp;využitím standardní funkce <strong>sys.getsizeof</strong>. Největší (a
možná i jedinou) předností této funkce je fakt, že se jedná o funkci ze
standardní knihovny <strong>sys</strong>. To mj.&nbsp;znamená, že tuto funkci
je možné zavolat prakticky kdykoli a kdekoli, a to bez nutnosti instalace
nějakých dalších balíčků.</p>

<p>Ovšem na tomto místě je vhodné upozornit na to, že tato funkce není příliš
dokonalá, protože například neumožňuje zjistit velikost hodnot v&nbsp;operační
paměti po zarovnání, protože alokátor paměti alokuje nové bloky vždy na
adresách dělitelných nějakou konstantou 4, 8 či 16 (podle použitého operačního
systému a architektury mikroprocesoru) a tudíž vlastně nebudou využity bajty
umístěné těsně za koncem bloku v&nbsp;případě, že velikost bloku není dělitelná
výše uvedenou konstantou. A navíc má tato standardní funkce problémy se
zjištěním velikosti tříd a objektů, protože automaticky nezapočítává velikosti
jednotlivých atributů atd. A totéž platí i pro kolekce, mezi jinými i pro
seznamy.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Balíček <i>Pympler</i> pro přesnější informace o obsazení paměti Pythonem</h2>

<p>Existují však i další (ovšem nutno dodat, že již nestandardní) balíčky,
které &bdquo;opravují&ldquo; chování funkce <strong>sys.getsizeof</strong> a
navíc nabízí uživatelům i další zajímavou a potenciálně užitečnou
funkcionalitu. Tyto balíčky je však pochopitelně nutné nejdříve nainstalovat.
Prvním z&nbsp;balíčků, o nichž se dnes alespoň ve stručnosti zmíníme, je
balíček nazvaný <strong>Pympler</strong>. Vzhledem k&nbsp;tomu, že je
zaregistrovaný na <i>PyPi</i>, je instalace tohoto balíčku triviální a můžeme
ji provést (pro právě přihlášeného uživatele) tímto příkazem:</p>

<pre>
$ <strong>pip install --user pympler</strong>
</pre>

<p>Alternativně pro systémy, které ještě mají paralelní instalaci Pythonu 2 a
Pythonu 3, použijeme příkaz:</p>

<pre>
$ <strong>pip3 install --user pympler</strong>
</pre>

<p>Samotná instalace proběhne prakticky okamžitě:</p>

<pre>
Collecting pympler
  Downloading Pympler-1.0.1-py3-none-any.whl (164 kB)
     |████████████████████████████████| 164 kB 1.5 MB/s 
Installing collected packages: pympler
Successfully installed pympler-1.0.1
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě můžete provést instalaci i
tohoto balíčku v&nbsp;rámci virtuálního prostředí Pythonu atd.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Obsazení paměti prázdným seznamem popř.&nbsp;prázdným polem</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu zjistíme, jak velkou kapacitu
operační paměti musíme použít pro uložení prázdného seznamu (což je standardní
kolekce Pythonu) nebo prázdného pole s&nbsp;prvky zvoleného typu. Vytvoříme
tedy prázdný seznam konstruktorem:</p>

<pre>
l1 = []
</pre>

<p>a několik prázdných polí určených pro uložení prvků různého typu:</p>

<pre>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
</pre>

<p>Následně si s&nbsp;využitím funkce <strong>asizeof.asizeof</strong> necháme
vypočítat velikost obsazené paměti:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from pympler.asizeof import asizeof
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># výpis skutečných velikostí</i>
print("List:             ", asizeof(l1))
print("Array of bytes:   ", asizeof(a1))
print("Array of shorts:  ", asizeof(a2))
print("Array of ints:    ", asizeof(a3))
print("Array of longs:   ", asizeof(a4))
print("Array of quads:   ", asizeof(a5))
print("Array of floats:  ", asizeof(a6))
print("Array of doubles: ", asizeof(a7))
</pre>

<p>Výsledky budou vypadat následovně (hodnoty jsou reprezentovány
v&nbsp;bajtech):</p>

<pre>
List:              56
Array of bytes:    64
Array of shorts:   64
Array of ints:     64
Array of longs:    64
Array of quads:    64
Array of floats:   64
Array of doubles:  64
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě sice vyhrál
klasický seznam, ovšem stále se jedná o prázdné kolekce, takže tato výhra
v&nbsp;praxi většinou nic neznamená.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Obsazení paměti seznamem popř.&nbsp;polem se sto prvky a 10000 prvky</h2>

<p>Nyní se pokusíme zjistit, kolik paměti bude obsazeno seznamem a poli se sto
prvky a posléze s&nbsp;tisíci prvky. Zdrojový kód příkladu upravíme
následujícím způsobem (povšimněte si, jak se do polí přidávají další
prvky):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from pympler.asizeof import asizeof
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    l1.append(i)
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
<i># výpis skutečných velikostí</i>
print("List:             ", asizeof(l1))
print("Array of bytes:   ", asizeof(a1))
print("Array of shorts:  ", asizeof(a2))
print("Array of ints:    ", asizeof(a3))
print("Array of longs:   ", asizeof(a4))
print("Array of quads:   ", asizeof(a5))
print("Array of floats:  ", asizeof(a6))
print("Array of doubles: ", asizeof(a7))
</pre>

<p>Výsledky pro stoprvkové kolekce:</p>

<pre>
List:              4096
Array of bytes:    168
Array of shorts:   272
Array of ints:     472
Array of longs:    880
Array of quads:    880
Array of floats:   472
Array of doubles:  880
</pre>

<p>Pro pole s&nbsp;tisíci hodnotami nepatrně upravíme programový kód určený pro
vkládání prvků, protože do polí s&nbsp;hodnotami typu bajt je možné uložit jen
hodnoty s&nbsp;omezeným rozsahem (127 resp.&nbsp;255):</p>

<pre>
for i in range(10000):
    l1.append(i)
    a1.append(i % 100)
    a2.append(i % 100)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
</pre>

<p>Výsledky pro kolekce s&nbsp;10000 prvky:</p>

<pre>
List:              407608
Array of bytes:    10152
Array of shorts:   20240
Array of ints:     40408
Array of longs:    80744
Array of quads:    80744
Array of floats:   40408
Array of doubles:  80744
</pre>

<p>Z&nbsp;výsledků je patrné, že u seznamů roste spotřeba paměti poměrně
výrazně, což by ale nemělo být překvapivé, protože hodnoty jsou zde boxovány.
Zajímavé ovšem je, že i u polí je obsazená paměť větší, než by to odpovídalo
výpočtu <i>počet_prvků&times;velikost_jednoho prvku</i>. U rozsáhlejších polí
je &bdquo;nadbytečná&ldquo; spotřeba paměti rovna přibližně jednomu až třem
procentům, takže se většinou nejedná o výrazný problém.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Sekvenční přístup k&nbsp;prvkům seznamů a polí</h2>

<p></p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    l1.append(i)
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
&nbsp;
def <strong>print_all_items</strong>(name, struct):
    <i>"""Vytištění všech prvků uložených ve struktuře."""</i>
    print(name)
    for item in struct:
        print(item, end=" ")
    print("\n")
&nbsp;
&nbsp;
print_all_items("List:", l1)
print_all_items("Array of bytes:", a1)
print_all_items("Array of shorts:", a2)
print_all_items("Array of ints:", a3)
print_all_items("Array of longs:", a4)
print_all_items("Array of quads:", a5)
print_all_items("Array of floats:", a6)
print_all_items("Array of doubles:", a7)
</pre>

<pre>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vložení hodnoty do seznamu či pole na určené místo (operace <i>insert</i>)</h2>

<p>V&nbsp;předchozích demonstračních příkladech jsme prvky do seznamu a polí <i>připojovali</i>, což je u obou zmíněných datových struktur realizováno operací se stejným jménem &ndash; <strong>append</strong>. Díky tomu, že prvky byly připojovány na konec pole, nebylo nutné specifikovat index přidávaného prvku. Ovšem jinak je tomu u operace <i>vkládaní</i> neboli <strong>insert</strong>.</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    l1.insert(0, i)
    a1.insert(0, i)
    a2.insert(0, i)
    a3.insert(0, i)
    a4.insert(0, i)
    a5.insert(0, i)
    a6.insert(0, i)
    a7.insert(0, i)
&nbsp;
&nbsp;
def print_all_items(name, struct):
    """Vytištění všech prvků uložených ve struktuře."""
    print(name)
    for item in struct:
        print(item, end=" ")
    print("\n")
&nbsp;
&nbsp;
print_all_items("List:", l1)
print_all_items("Array of bytes:", a1)
print_all_items("Array of shorts:", a2)
print_all_items("Array of ints:", a3)
print_all_items("Array of longs:", a4)
print_all_items("Array of quads:", a5)
print_all_items("Array of floats:", a6)
print_all_items("Array of doubles:", a7)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Interní struktura polí</h2>

<p></p>

<pre>
def <strong>print_all_items_as_hex</strong>(name, struct):
    print(name)
    print(struct.tobytes().hex(" "))
    print()
</pre>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(10):
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
&nbsp;
def <strong>print_all_items_as_hex</strong>(name, struct):
    print(name)
    print(struct.tobytes().hex(" "))
    print()
&nbsp;
&nbsp;
print_all_items_as_hex("Array of bytes:", a1)
print_all_items_as_hex("Array of shorts:", a2)
print_all_items_as_hex("Array of ints:", a3)
print_all_items_as_hex("Array of longs:", a4)
print_all_items_as_hex("Array of quads:", a5)
print_all_items_as_hex("Array of floats:", a6)
print_all_items_as_hex("Array of doubles:", a7)
</pre>

<pre>
Array of bytes:
00 01 02 03 04 05 06 07 08 09

Array of shorts:
00 00 01 00 02 00 03 00 04 00 05 00 06 00 07 00 08 00 09 00

Array of ints:
00 00 00 00 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 05 00 00 00 06 00 00 00 07 00 00 00 08 00 00 00 09 00 00 00

Array of longs:
00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 05 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 07 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 09 00 00 00 00 00 00 00

Array of quads:
00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 05 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 07 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 09 00 00 00 00 00 00 00

Array of floats:
00 00 00 00 00 00 80 3f 00 00 00 40 00 00 40 40 00 00 80 40 00 00 a0 40 00 00 c0 40 00 00 e0 40 00 00 00 41 00 00 10 41

Array of doubles:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 f0 3f 00 00 00 00 00 00 00 40 00 00 00 00 00 00 08 40 00 00 00 00 00 00 10 40 00 00 00 00 00 00 14 40 00 00 00 00 00 00 18 40 00 00 00 00 00 00 1c 40 00 00 00 00 00 00 20 40 00 00 00 00 00 00 22 40
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
&nbsp;
def export_to_file(filename, struct):
    """Export celé struktury do souboru."""
    with open(filename, "wb") as f:
        struct.tofile(f)
&nbsp;
&nbsp;
export_to_file("bytes.bin", a1)
export_to_file("shorts.bin", a2)
export_to_file("ints.bin", a3)
export_to_file("longs.bin", a4)
export_to_file("quads.bin", a5)
export_to_file("floats.bin", a6)
export_to_file("doubles.bin", a7)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
&nbsp;
def <strong>import_from_file</strong>(filename, struct):
    <i>"""Import celé struktury ze souboru."""</i>
    with open(filename, "rb") as f:
        struct.fromfile(f, 100)
    return struct
&nbsp;
&nbsp;
print(import_from_file("bytes.bin", a1))
print(import_from_file("shorts.bin", a2))
print(import_from_file("ints.bin", a3))
print(import_from_file("longs.bin", a4))
print(import_from_file("quads.bin", a5))
print(import_from_file("floats.bin", a6))
print(import_from_file("doubles.bin", a7))
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
from time import perf_counter
import random
&nbsp;
size = 10000
&nbsp;
a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
t1 = perf_counter()
&nbsp;
for i in range(size - 1, 0, -1):
    for j in range(0, i):
        if a[j] &gt; a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Sorted in {t2-t1} seconds:")
&nbsp;
print("\nBegins with:")
print(a[:100])
&nbsp;
print("\nEnds with:")
print(a[-100:])
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
from time import perf_counter
from array import array
import random
&nbsp;
size = 10000
&nbsp;
a = array("I", [random.randrange(0, 10000) for i in range(size)])
&nbsp;
t1 = perf_counter()
&nbsp;
for i in range(size - 1, 0, -1):
    for j in range(0, i):
        if a[j] &gt; a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Sorted in {t2-t1} seconds:")
&nbsp;
print("\nBegins with:")
print(a[:100])
&nbsp;
print("\nEnds with:")
print(a[-100:])
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

 

<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Odkazy na jednotlivé příklady jsou uvedeny v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>empty_structs.py</td><td>inicializace prázdných struktur (seznamu a polí) a získání jejich velikosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/empty_structs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/empty_structs.py</a></td></tr>
<tr><td> 2</td><td>hundred_items.py</td><td>přidání 100 prvků do každé struktury a získání jejich velikosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/hundred_items.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/hundred_items.py</a></td></tr>
<tr><td> 3</td><td>10000_items.py</td><td>přidání 10000 prvků do každé struktury a získání jejich velikosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/10000_items.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/10000_items.py</a></td></tr>
<tr><td> 4</td><td>read_values.py</td><td>čtení hodnot prvků ze seznamů a polí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/read_values.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/read_values.py</a></td></tr>
<tr><td> 5</td><td>insert_item.py</td><td>operace pro vložení prvku na zvolený index</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/insert_item.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/insert_item.py</a></td></tr>
<tr><td> 6</td><td>tobytes.py</td><td>konverze polí na hodnotu typu <strong>bytes</strong> s&nbsp;jejím tiskem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/tobytes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/tobytes.py</a></td></tr>
<tr><td> 7</td><td>export_to_file.py</td><td>export polí do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/export_to_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/export_to_file.py</a></td></tr>
<tr><td> 8</td><td>import_from_file.py</td><td>import polí z&nbsp;binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/import_from_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/import_from_file.py</a></td></tr>
<tr><td> 9</td><td>bubble_sort_1.py </td><td>algoritmus bublinkového řazení realizovaný nad seznamy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_1.py</a></td></tr>
<tr><td>10</td><td>bubble_sort_2.py </td><td>algoritmus bublinkového řazení realizovaný nad polem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>array — Efficient arrays of numeric values<br />
<a href="https://docs.python.org/3/library/array.html">https://docs.python.org/3/library/array.html</a>
</li>

<li>Top 5 Python Memory Profilers<br />
<a href="https://stackify.com/top-5-python-memory-profilers/">https://stackify.com/top-5-python-memory-profilers/</a>
</li>

<li>Pympler na GitHubu<br />
<a href="https://github.com/pympler/pympler">https://github.com/pympler/pympler</a>
</li>

<li>Pympler na PyPI<br />
<a href="https://pypi.org/project/Pympler/">https://pypi.org/project/Pympler/</a>
</li>

<li>Dokumentace k&nbsp;balíčku Pympler<br />
<a href="https://pympler.readthedocs.io/en/latest/">https://pympler.readthedocs.io/en/latest/</a>
</li>

<li>Guppy 3 na GitHubu<br />
<a href="https://github.com/zhuyifei1999/guppy3/">https://github.com/zhuyifei1999/guppy3/</a>
</li>

<li>Guppy 3 na PyPI<br />
<a href="https://pypi.org/project/guppy3/">https://pypi.org/project/guppy3/</a>
</li>

<li>Memory Profiler na GitHubu<br />
<a href="https://github.com/pythonprofilers/memory_profiler">https://github.com/pythonprofilers/memory_profiler</a>
</li>

<li>Memory Profiler na PyPI<br />
<a href="https://pypi.org/project/memory-profiler/">https://pypi.org/project/memory-profiler/</a>
</li>

<li>How to use guppy/heapy for tracking down memory usage<br />
<a href="https://smira.ru/wp-content/uploads/2011/08/heapy.html">https://smira.ru/wp-content/uploads/2011/08/heapy.html</a>
</li>

<li>Identifying memory leaks<br />
<a href="https://pympler.readthedocs.io/en/latest/muppy.html#muppy">https://pympler.readthedocs.io/en/latest/muppy.html#muppy</a>
</li>

<li>How do I determine the size of an object in Python?<br />
<a href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python</a>
</li>

<li>Why is bool a subclass of int?<br />
<a href="https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int">https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int</a>
</li>

<li>Memory Management in Python<br />
<a href="https://realpython.com/python-memory-management/">https://realpython.com/python-memory-management/</a>
</li>

<li>Why do ints require three times as much memory in Python?<br />
<a href="https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python">https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python</a>
</li>

<li>cpython/Include/cpython/longintrepr.h<br />
<a href="https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64">https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64</a>
</li>

<li>sys — System-specific parameters and functions<br />
<a href="https://docs.python.org/3/library/sys.html">https://docs.python.org/3/library/sys.html</a>
</li>

<li>Stránky projektu Numpy<br />
<a href="https://numpy.org/">https://numpy.org/</a>
</li>

<li>Numpy na GitHubu<br />
<a href="https://github.com/numpy/numpy">https://github.com/numpy/numpy</a>
</li>

<li>NumPy documentation<br />
<a href="https://numpy.org/doc/stable/">https://numpy.org/doc/stable/</a>
</li>

<li>The N-dimensional array (ndarray)<br />
<a href="https://numpy.org/doc/stable/reference/arrays.ndarray.html">https://numpy.org/doc/stable/reference/arrays.ndarray.html</a>
</li>

<li>numpy.ndarray<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html">https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

