<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Balíček array ze standardní knihovny Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Balíček array ze standardní knihovny Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Balíček <strong>array</strong> ze standardní knihovny Pythonu</a></p>
<p><a href="#k02">2. Konstrukce pole s&nbsp;určením typů jeho prvků</a></p>
<p><a href="#k03">3. Podporované typy prvků</a></p>
<p><a href="#k04">4. Obsazení operační paměti Pythonovským objektem</a></p>
<p><a href="#k05">5. Balíček <i>Pympler</i> pro přesnější informace o obsazení paměti Pythonem</a></p>
<p><a href="#k06">6. Obsazení paměti prázdným seznamem popř.&nbsp;prázdným polem</a></p>
<p><a href="#k07">7. Obsazení paměti seznamem popř.&nbsp;polem se sto prvky a 10000 prvky</a></p>
<p><a href="#k08">8. Sekvenční přístup k&nbsp;prvkům seznamů a polí</a></p>
<p><a href="#k09">9. Vložení hodnoty do seznamu či pole na určené místo (operace <i>insert</i>)</a></p>
<p><a href="#k10">10. Interní struktura prvků polí</a></p>
<p><a href="#k11">11. Uložení obsahu polí do souboru</a></p>
<p><a href="#k12">12. Načtení obsahu polí z&nbsp;binárních souborů</a></p>
<p><a href="#k13">13. Složitěji strukturované binární soubory</a></p>
<p><a href="#k14">14. Teoretická a praktická rychlost přístupu k&nbsp;prvkům polí</a></p>
<p><a href="#k15">15. Tentýž výpočet, ovšem realizovaný s&nbsp;využitím polí</a></p>
<p><a href="#k16">*** 16. Interní způsob uložení pole v&nbsp;paměti</a></p>
<p><a href="#k17">*** 17. Algoritmus pro alokaci paměti pro zvětšující a zmenšující se pole</a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Balíček <strong>array</strong> ze standardní knihovny Pythonu</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Konstrukce pole s&nbsp;určením typů jeho prvků</h2>

<p>Homogenní jednorozměrné pole se při použití standardního balíčku
<strong>array</strong> vytváří konstruktorem nazvaným taktéž
<strong>array</strong>. Tomuto konstruktoru se musí předat jednoznakový kód
typu prvků (viz tabulka zobrazená níže) a popř.&nbsp;hodnota, z&nbsp;níž se
odvodí prvky pole. Touto hodnotou může být seznam popř.&nbsp;hodnota typu
<strong>bytes</strong> nebo <strong>bytearray</strong>, tj.&nbsp;neměnitelné
popř.&nbsp;naopak měnitelné sekvence bajtů (připomeňme si, že hodnotu typu
<strong>bytes</strong> můžeme v&nbsp;případě potřeby zapsat formou
b"znaky").</p>

<p>Příklad konstrukce prázdného pole:</p>

<pre>
from array import array
&nbsp;
a1 = array(kód_typu_prvků)
</pre>

<p>Příklad konstrukce pole se specifikací hodnoty prvků seznamem:</p>

<pre>
from array import array
&nbsp;
a1 = array(kód_typu_prvků, [1, 2, 3, 4])
</pre>

<p>popř.</p>

<pre>
from array import array
&nbsp;
a1 = array("B", range(100))
</pre>

<p>Odlišný příklad konstrukce pole se specifikací hodnoty prvků sekvencí
bajtů:</p>

<pre>
from array import array
&nbsp;
a2 = array(kód_typu_prvků, b"ABCDEFGH")
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě musí být počet
bajtů v&nbsp;sekvenci celočíselně dělitelný velikostí prvku. Například pro
čtyřbajtové prvky (typicky <i>signed int</i> či <i>unsigned int</i>) musí být
počet bajtů dělitelný čtyřmi. Ostatně si to můžeme velmi snadno ověřit tak, že
budeme vyžadovat vytvoření pole s&nbsp;16bitovými hodnotami, ale předáme mu
v&nbsp;konstruktoru sekvenci bajtů, jejíž délka není celočíselně dělitelná
dvěma:</div></p>

<pre>
from array import array
&nbsp;
a2 = array("h", b"ABCDEFG")
</pre>

<p>V&nbsp;tomto případě dojde k&nbsp;vyhození výjimky:</p>

<pre>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: bytes length not a multiple of item size
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Podporované typy prvků</h2>

<p>Typ prvků je zakódován v&nbsp;jednoznakovém řetězci, který je předán jako
první parametr do konstruktoru <strong>array.array</strong>. Podporovány jsou
následující kódy, které vždy odpovídají jednomu datovému typu jazyka C a a mají
(tak) i specifikovánu minimální velikost v&nbsp;bajtech:</p>

<table>
<tr><th>Zápis typu</th><th>Odpovídající typ v C</th><th>Minimální velikost v&nbsp;B</th></tr>
<tr><td>"b"</td><td>signed char</td><td>1</td></tr>
<tr><td>"B"</td><td>unsigned char</td><td>1</td></tr>
<tr><td>"h"</td><td>signed short</td><td>2</td></tr>
<tr><td>"H"</td><td>unsigned short</td><td>2</td></tr>
<tr><td>"i"</td><td>signed int</td><td>2</td></tr>
<tr><td>"I"</td><td>unsigned int</td><td>2</td></tr>
<tr><td>"l"</td><td>signed long</td><td>4</td></tr>
<tr><td>"L"</td><td>unsigned long</td><td>4</td></tr>
<tr><td>"q"</td><td>signed long long</td><td>8</td></tr>
<tr><td>"Q"</td><td>unsigned long long</td><td>8</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>"f"</td><td>float</td><td>4</td></tr>
<tr><td>"d"</td><td>double</td><td>8</td></tr>
</table>

<p>Jen pro zajímavost se podívejme, jaké typy prvků jsou podporovány
v&nbsp;knihovně NumPy při konstrukci n-rozměrných polí. Jedná se sice o interně
odlišnou datovou strukturu s&nbsp;jiným způsobem použití, ale mnoho kódů je
shodných:</p>

<table>
<tr><th>Zápis typu</th><th>Odpovídající typ v C</th></tr>
<tr><td>"b"</td><td>signed char</td></tr>
<tr><td>"B"</td><td>unsigned char</td></tr>
<tr><td>"h"</td><td>signed short</td></tr>
<tr><td>"H"</td><td>unsigned short</td></tr>
<tr><td>"i"</td><td>signed int</td></tr>
<tr><td>"I"</td><td>unsigned int</td></tr>
<tr><td>"l"</td><td>signed long</td></tr>
<tr><td>"L"</td><td>unsigned long</td></tr>
<tr><td>"q"</td><td>signed long long</td></tr>
<tr><td>"Q"</td><td>unsigned long long</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>"e"</td><td>half float</td></tr>
<tr><td>"f"</td><td>float</td></tr>
<tr><td>"d"</td><td>double</td></tr>
<tr><td>"g"</td><td>long double</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>"F"</td><td>complex float</td></tr>
<tr><td>"D"</td><td>complex double</td></tr>
<tr><td>"G"</td><td>complex long double</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Obsazení operační paměti Pythonovským objektem</h2>

<p>Největší předností (a pravděpodobně i jedinou předností) balíčku
<strong>array</strong> je jeho schopnost efektivně uložit prvky určitého
datového typu do kontinuálního bloku operační paměti. To vede resp.&nbsp;mělo
by to vést k&nbsp;velkým paměťovým úsporám. Ovšem toto tvrzení je vhodné si
ověřit v&nbsp;praxi. Konkrétně tedy budeme porovnávat celkovou velikost seznamu
s&nbsp;n-položkami s&nbsp;jednotlivými poli realizovanými balíčkem
<strong>array</strong>.</p>

<p>Velikost, kterou nějaká hodnota zabírá v&nbsp;operační paměti, můžeme získat
s&nbsp;využitím standardní funkce <strong>sys.getsizeof</strong>. Největší (a
možná i jedinou) předností této funkce je fakt, že se jedná o funkci ze
standardní knihovny <strong>sys</strong>. To mj.&nbsp;znamená, že tuto funkci
je možné zavolat prakticky kdykoli a kdekoli, a to bez nutnosti instalace
nějakých dalších balíčků.</p>

<p>Ovšem na tomto místě je vhodné upozornit na to, že tato funkce není příliš
dokonalá, protože například neumožňuje zjistit velikost hodnot v&nbsp;operační
paměti po zarovnání, protože alokátor paměti alokuje nové bloky vždy na
adresách dělitelných nějakou konstantou 4, 8 či 16 (podle použitého operačního
systému a architektury mikroprocesoru) a tudíž vlastně nebudou využity bajty
umístěné těsně za koncem bloku v&nbsp;případě, že velikost bloku není dělitelná
výše uvedenou konstantou. A navíc má tato standardní funkce problémy se
zjištěním velikosti tříd a objektů, protože automaticky nezapočítává velikosti
jednotlivých atributů atd. A totéž platí i pro kolekce, mezi jinými i pro
seznamy.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Balíček <i>Pympler</i> pro přesnější informace o obsazení paměti Pythonem</h2>

<p>Existují však i další (ovšem nutno dodat, že již nestandardní) balíčky,
které &bdquo;opravují&ldquo; chování funkce <strong>sys.getsizeof</strong> a
navíc nabízí uživatelům i další zajímavou a potenciálně užitečnou
funkcionalitu. Tyto balíčky je však pochopitelně nutné nejdříve nainstalovat.
Prvním z&nbsp;balíčků, o nichž se dnes alespoň ve stručnosti zmíníme, je
balíček nazvaný <strong>Pympler</strong>. Vzhledem k&nbsp;tomu, že je
zaregistrovaný na <i>PyPi</i>, je instalace tohoto balíčku triviální a můžeme
ji provést (pro právě přihlášeného uživatele) tímto příkazem:</p>

<pre>
$ <strong>pip install --user pympler</strong>
</pre>

<p>Alternativně pro systémy, které ještě mají paralelní instalaci Pythonu 2 a
Pythonu 3, použijeme příkaz:</p>

<pre>
$ <strong>pip3 install --user pympler</strong>
</pre>

<p>Samotná instalace proběhne prakticky okamžitě:</p>

<pre>
Collecting pympler
  Downloading Pympler-1.0.1-py3-none-any.whl (164 kB)
     |████████████████████████████████| 164 kB 1.5 MB/s 
Installing collected packages: pympler
Successfully installed pympler-1.0.1
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě můžete provést instalaci i
tohoto balíčku v&nbsp;rámci virtuálního prostředí Pythonu atd.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Obsazení paměti prázdným seznamem popř.&nbsp;prázdným polem</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu zjistíme, jak velkou kapacitu
operační paměti musíme použít pro uložení prázdného seznamu (což je standardní
kolekce Pythonu) nebo prázdného pole s&nbsp;prvky zvoleného typu. Vytvoříme
tedy prázdný seznam konstruktorem:</p>

<pre>
l1 = []
</pre>

<p>a několik prázdných polí určených pro uložení prvků různého typu:</p>

<pre>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
</pre>

<p>Následně si s&nbsp;využitím funkce <strong>asizeof.asizeof</strong> necháme
vypočítat velikost obsazené paměti:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from pympler.asizeof import asizeof
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># výpis skutečných velikostí</i>
print("List:             ", asizeof(l1))
print("Array of bytes:   ", asizeof(a1))
print("Array of shorts:  ", asizeof(a2))
print("Array of ints:    ", asizeof(a3))
print("Array of longs:   ", asizeof(a4))
print("Array of quads:   ", asizeof(a5))
print("Array of floats:  ", asizeof(a6))
print("Array of doubles: ", asizeof(a7))
</pre>

<p>Výsledky budou vypadat následovně (hodnoty jsou reprezentovány
v&nbsp;bajtech):</p>

<pre>
List:              56
Array of bytes:    64
Array of shorts:   64
Array of ints:     64
Array of longs:    64
Array of quads:    64
Array of floats:   64
Array of doubles:  64
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě sice vyhrál
klasický seznam, ovšem stále se jedná o prázdné kolekce, takže tato výhra
v&nbsp;praxi většinou nic neznamená. Navíc se později zmíníme o tom, jak je
vlastně alokována paměť pro pole &ndash; zde se skrývá několik zajímavých
detailů.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Obsazení paměti seznamem popř.&nbsp;polem se sto prvky a 10000 prvky</h2>

<p>Nyní se pokusíme zjistit, kolik paměti bude obsazeno seznamem a poli se sto
prvky a posléze s&nbsp;tisíci prvky. Zdrojový kód příkladu upravíme
následujícím způsobem (povšimněte si, jak se do polí přidávají další
prvky):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from pympler.asizeof import asizeof
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    l1.append(i)
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
<i># výpis skutečných velikostí</i>
print("List:             ", asizeof(l1))
print("Array of bytes:   ", asizeof(a1))
print("Array of shorts:  ", asizeof(a2))
print("Array of ints:    ", asizeof(a3))
print("Array of longs:   ", asizeof(a4))
print("Array of quads:   ", asizeof(a5))
print("Array of floats:  ", asizeof(a6))
print("Array of doubles: ", asizeof(a7))
</pre>

<p>Výsledky pro stoprvkové kolekce:</p>

<pre>
List:              4096
Array of bytes:    168
Array of shorts:   272
Array of ints:     472
Array of longs:    880
Array of quads:    880
Array of floats:   472
Array of doubles:  880
</pre>

<p>Pro pole s&nbsp;tisíci hodnotami nepatrně upravíme programový kód určený pro
vkládání prvků, protože do polí s&nbsp;hodnotami typu bajt je možné uložit jen
hodnoty s&nbsp;omezeným rozsahem (127 resp.&nbsp;255):</p>

<pre>
for i in range(10000):
    l1.append(i)
    a1.append(i % 100)
    a2.append(i % 100)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
</pre>

<p>Výsledky pro kolekce s&nbsp;10000 prvky:</p>

<pre>
List:              407608
Array of bytes:    10152
Array of shorts:   20240
Array of ints:     40408
Array of longs:    80744
Array of quads:    80744
Array of floats:   40408
Array of doubles:  80744
</pre>

<p>Z&nbsp;výsledků je patrné, že u seznamů roste spotřeba paměti poměrně
výrazně, což by ale nemělo být překvapivé, protože hodnoty jsou zde boxovány.
Zajímavé ovšem je, že i u polí je obsazená paměť větší, než by to odpovídalo
výpočtu <i>počet_prvků&times;velikost_jednoho prvku</i>. U rozsáhlejších polí
je &bdquo;nadbytečná&ldquo; spotřeba paměti rovna přibližně jednomu až třem
procentům, takže se většinou nejedná o výrazný problém. A opět si ještě
řekneme, proč tomu tak je.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Sekvenční přístup k&nbsp;prvkům seznamů a polí</h2>

<p>V&nbsp;případě, že použijeme standardní seznamy, je sekvenční průchod prvky
seznamů v&nbsp;Pythonu realizován tímto idiomatickým zápisem:</p>

<pre>
lst = ["foo", "bar", "baz"]
&nbsp;
for item in lst:
    print(item)
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně je možné použít i další
způsoby, ovšem ty nejsou příliš často k&nbsp;vidění.</div></p>

<p>Naprosto stejným způsobem je možné procházet i prvky polí, což je velmi
rozumné. Příkladem může být průchod polem se čtyřmi prvky typu
&bdquo;bajt&ldquo;:</p>

<pre>
arr = array("B", [1, 2, 3, 4])
&nbsp;
for item in arr:
    print(item)
</pre>

<p>Všemi typy polí se prochází naprosto stejným způsobem, nezávisle na typu
jejich prvků:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    l1.append(i)
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
&nbsp;
def <strong>print_all_items</strong>(name, struct):
    <i>"""Vytištění všech prvků uložených ve struktuře."""</i>
    print(name)
    for item in struct:
        print(item, end=" ")
    print("\n")
&nbsp;
&nbsp;
print_all_items("List:", l1)
print_all_items("Array of bytes:", a1)
print_all_items("Array of shorts:", a2)
print_all_items("Array of ints:", a3)
print_all_items("Array of longs:", a4)
print_all_items("Array of quads:", a5)
print_all_items("Array of floats:", a6)
print_all_items("Array of doubles:", a7)
</pre>

<p>Výsledky zobrazené tímto příkladem na terminálu:</p>

<pre>
List:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of bytes:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of shorts:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of ints:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of longs:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of quads:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 
&nbsp;
Array of floats:
0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0 19.0 20.0 21.0 22.0 23.0 24.0 25.0 26.0 27.0 28.0 29.0 30.0 31.0 32.0 33.0 34.0 35.0 36.0 37.0 38.0 39.0 40.0 41.0 42.0 43.0 44.0 45.0 46.0 47.0 48.0 49.0 50.0 51.0 52.0 53.0 54.0 55.0 56.0 57.0 58.0 59.0 60.0 61.0 62.0 63.0 64.0 65.0 66.0 67.0 68.0 69.0 70.0 71.0 72.0 73.0 74.0 75.0 76.0 77.0 78.0 79.0 80.0 81.0 82.0 83.0 84.0 85.0 86.0 87.0 88.0 89.0 90.0 91.0 92.0 93.0 94.0 95.0 96.0 97.0 98.0 99.0 
&nbsp;
Array of doubles:
0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0 19.0 20.0 21.0 22.0 23.0 24.0 25.0 26.0 27.0 28.0 29.0 30.0 31.0 32.0 33.0 34.0 35.0 36.0 37.0 38.0 39.0 40.0 41.0 42.0 43.0 44.0 45.0 46.0 47.0 48.0 49.0 50.0 51.0 52.0 53.0 54.0 55.0 56.0 57.0 58.0 59.0 60.0 61.0 62.0 63.0 64.0 65.0 66.0 67.0 68.0 69.0 70.0 71.0 72.0 73.0 74.0 75.0 76.0 77.0 78.0 79.0 80.0 81.0 82.0 83.0 84.0 85.0 86.0 87.0 88.0 89.0 90.0 91.0 92.0 93.0 94.0 95.0 96.0 97.0 98.0 99.0 
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vložení hodnoty do seznamu či pole na určené místo (operace <i>insert</i>)</h2>

<p>V&nbsp;předchozích demonstračních příkladech jsme prvky do seznamu a polí
<i>připojovali</i>, což je u obou zmíněných datových struktur realizováno
operací se stejným jménem &ndash; <strong>append</strong>. Díky tomu, že prvky
byly připojovány vždy až na konec pole (přesněji řečeno <i>za</i> konec pole),
nebylo nutné specifikovat index přidávaného prvku. Ovšem jinak je tomu u
operace <i>vkládaní</i> neboli <strong>insert</strong>. V&nbsp;tomto případě
specifikujeme index, do kterého bude nový prvek přidán (a zbytek prvků bude
odsunut). Pravděpodobně je zřejmé, že se jedná o obecně časově náročnou
operaci, která může vyžadovat jak realokaci samotného pole, tak i přesuny
prvků. I operace <strong>insert</strong> má stejnou sémantiku pro seznamy i pro
pole včetně kontroly hodnoty indexu, možnosti použití záporných indexů (pro
indexování zprava) atd.</p>

<p>Seznamy:</p>

<pre>
<strong>l = ["foo", "bar"]</strong>
&nbsp;
<strong>l.insert(0, "baz")</strong>
<strong>print(l)</strong>
['baz', 'foo', 'bar']
&nbsp;
<strong>l.insert(3, "END")</strong>
<strong>print(l)</strong>
['baz', 'foo', 'bar', 'END']
&nbsp;
<strong>l.insert(-1, ".")</strong>
<strong>print(l)</strong>
['baz', 'foo', 'bar', '.', 'END']
&nbsp;
<strong>l.insert(1000, "not-possible?")</strong>
<strong>print(l)</strong>
['baz', 'foo', 'bar', '.', 'END', 'not-possible?']
</pre>

<p>Pole:</p>

<pre>
<strong>a = array("B", [10, 20])</strong>
&nbsp;
<strong>a.insert(0, 5)</strong>
<strong>print(a)</strong>
array('B', [5, 10, 20])
&nbsp;
<strong>a.insert(3, 30)</strong>
<strong>print(a)</strong>
array('B', [5, 10, 20, 30])
&nbsp;
<strong>a.insert(-1, 0)</strong>
<strong>print(a)</strong>
array('B', [5, 10, 20, 0, 30])
&nbsp;
<strong>a.insert(10000, 40)</strong>
<strong>print(a)</strong>
array('B', [5, 10, 20, 0, 30, 40])
</pre>

<p>To znamená, že jak pole tak seznamy můžeme naplnit operací &bdquo;připojení
zleva&ldquo;, protože sémantika <strong>insert(0, hodnota)</strong> vlastně
odpovídá sémantice <strong>append(hodnota)</strong> v&nbsp;případě, pokud by se
prvky připojovaly <i>před začátek</i> sekvence a nikoli <i>za konec</i>
sekvence:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
l1 = []
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    l1.insert(0, i)
    a1.insert(0, i)
    a2.insert(0, i)
    a3.insert(0, i)
    a4.insert(0, i)
    a5.insert(0, i)
    a6.insert(0, i)
    a7.insert(0, i)
&nbsp;
&nbsp;
def <strong>print_all_items</strong>(name, struct):
    <i>"""Vytištění všech prvků uložených ve struktuře."""</i>
    print(name)
    for item in struct:
        print(item, end=" ")
    print("\n")
&nbsp;
&nbsp;
print_all_items("List:", l1)
print_all_items("Array of bytes:", a1)
print_all_items("Array of shorts:", a2)
print_all_items("Array of ints:", a3)
print_all_items("Array of longs:", a4)
print_all_items("Array of quads:", a5)
print_all_items("Array of floats:", a6)
print_all_items("Array of doubles:", a7)
</pre>

<p>S&nbsp;výsledky, které nejsou ničím překvapující:</p>

<pre>
List:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of bytes:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of shorts:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of ints:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of longs:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of quads:
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
&nbsp;
Array of floats:
99.0 98.0 97.0 96.0 95.0 94.0 93.0 92.0 91.0 90.0 89.0 88.0 87.0 86.0 85.0 84.0 83.0 82.0 81.0 80.0 79.0 78.0 77.0 76.0 75.0 74.0 73.0 72.0 71.0 70.0 69.0 68.0 67.0 66.0 65.0 64.0 63.0 62.0 61.0 60.0 59.0 58.0 57.0 56.0 55.0 54.0 53.0 52.0 51.0 50.0 49.0 48.0 47.0 46.0 45.0 44.0 43.0 42.0 41.0 40.0 39.0 38.0 37.0 36.0 35.0 34.0 33.0 32.0 31.0 30.0 29.0 28.0 27.0 26.0 25.0 24.0 23.0 22.0 21.0 20.0 19.0 18.0 17.0 16.0 15.0 14.0 13.0 12.0 11.0 10.0 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0 
&nbsp;
Array of doubles:
99.0 98.0 97.0 96.0 95.0 94.0 93.0 92.0 91.0 90.0 89.0 88.0 87.0 86.0 85.0 84.0 83.0 82.0 81.0 80.0 79.0 78.0 77.0 76.0 75.0 74.0 73.0 72.0 71.0 70.0 69.0 68.0 67.0 66.0 65.0 64.0 63.0 62.0 61.0 60.0 59.0 58.0 57.0 56.0 55.0 54.0 53.0 52.0 51.0 50.0 49.0 48.0 47.0 46.0 45.0 44.0 43.0 42.0 41.0 40.0 39.0 38.0 37.0 36.0 35.0 34.0 33.0 32.0 31.0 30.0 29.0 28.0 27.0 26.0 25.0 24.0 23.0 22.0 21.0 20.0 19.0 18.0 17.0 16.0 15.0 14.0 13.0 12.0 11.0 10.0 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0 
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Interní struktura prvků polí</h2>

<p>Všechny prvky pole tak, jak jsou uloženy v&nbsp;paměti, je možné si nechat
vypsat ve formě sekvence hexadecimálních hodnot. Tak například zjistíme, jakým
způsobem jsou uloženy celočíselné hodnoty širší než jeden bajt, jak jsou
uloženy hodnoty s&nbsp;plovoucí řádovou čárkou a samozřejmě je taktéž možné
rozlišit mezi způsoby uložení vícebajtových hodnot: <i>little endian</i> či
<i>big endian</i>. Vytvoříme si tedy pomocnou funkci, která získá jako svůj
parametr libovolné pole a následně vypíše jeho obsah v&nbsp;hexadecimální formě
na standardní výstup:</p>

<pre>
def <strong>print_all_items_as_hex</strong>(name, struct):
    print(name)
    print(struct.tobytes().hex(" "))
    print()
</pre>

<p>Tuto funkci následně zavoláme a postupně jí předáme pole všech typů, abychom
mohli prozkoumat případné rozdíly:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(10):
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
&nbsp;
def <strong>print_all_items_as_hex</strong>(name, struct):
    print(name)
    print(struct.tobytes().hex(" "))
    print()
&nbsp;
&nbsp;
print_all_items_as_hex("Array of bytes:", a1)
print_all_items_as_hex("Array of shorts:", a2)
print_all_items_as_hex("Array of ints:", a3)
print_all_items_as_hex("Array of longs:", a4)
print_all_items_as_hex("Array of quads:", a5)
print_all_items_as_hex("Array of floats:", a6)
print_all_items_as_hex("Array of doubles:", a7)
</pre>

<p>Pole bajtů je nejjednodušší &ndash; prvky jsou uloženy za sebou bez
jakýchkoli výplní:</p>

<pre>
Array of bytes:
00 01 02 03 04 05 06 07 08 09
</pre>

<p>U polí obsahujících &bdquo;širší&ldquo; celočíselné hodnoty je patrné, že je
na počítači s&nbsp;architekturou x86-64 použit <i>little endian</i>:</p>

<pre>
Array of shorts:
00 00 01 00 02 00 03 00 04 00 05 00 06 00 07 00 08 00 09 00
&nbsp;
Array of ints:
00 00 00 00 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00
05 00 00 00 06 00 00 00 07 00 00 00 08 00 00 00 09 00 00 00
&nbsp;
Array of longs:
00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 02 00 00 00
00 00 00 00 03 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00
05 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 07 00 00 00
00 00 00 00 08 00 00 00 00 00 00 00 09 00 00 00 00 00 00 00
&nbsp;
Array of quads:
00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 02 00 00 00
00 00 00 00 03 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00
05 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 07 00 00 00
00 00 00 00 08 00 00 00 00 00 00 00 09 00 00 00 00 00 00 00
</pre>

<p>A konečně jsou vypsány i prvky typu <i>float</i> a <i>double</i>:</p>

<pre>
Array of floats:
00 00 00 00 00 00 80 3f 00 00 00 40 00 00 40 40 00 00 80 40
00 00 a0 40 00 00 c0 40 00 00 e0 40 00 00 00 41 00 00 10 41
&nbsp;
Array of doubles:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 f0 3f 00 00 00 00
00 00 00 40 00 00 00 00 00 00 08 40 00 00 00 00 00 00 10 40
00 00 00 00 00 00 14 40 00 00 00 00 00 00 18 40 00 00 00 00
00 00 1c 40 00 00 00 00 00 00 20 40 00 00 00 00 00 00 22 40
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Uložení obsahu polí do souboru</h2>

<p>Obsah polí lze uložit (serializovat) do souboru. Jako výsledek získáme
binární soubory, které nebudou obsahovat žádnou hlavičku, výplně, ani žádné
další doplňují struktury. To znamená, že velikost výsledného binárního souboru
bude striktně odpovídat počtu prvků vynásobenou šířkou prvků v&nbsp;bajtech.
Ostatně se o tom můžeme velmi snadno přesvědčit. Pro uložení pole do souboru
použijeme metodu <strong>tofile</strong>, které se předá <i>handle</i>
otevřeného souboru:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    a1.append(i)
    a2.append(i)
    a3.append(i)
    a4.append(i)
    a5.append(i)
    a6.append(i)
    a7.append(i)
&nbsp;
&nbsp;
def <strong>export_to_file</strong>(filename, struct):
    <i>"""Export celé struktury do souboru."""</i>
    with open(filename, "wb") as f:
        struct.tofile(f)
&nbsp;
&nbsp;
export_to_file("bytes.bin", a1)
export_to_file("shorts.bin", a2)
export_to_file("ints.bin", a3)
export_to_file("longs.bin", a4)
export_to_file("quads.bin", a5)
export_to_file("floats.bin", a6)
export_to_file("doubles.bin", a7)
</pre>

<p>Podívejme se nyní na velikosti výsledných souborů. Pro větší přehlednost
jsme si nechali soubory seřadit podle jejich délky:</p>

<pre>
$ <strong>ls -lSr *.bin</strong>
</pre>

<p>Výsledky:</p>

<pre>
-rw-rw-r-- 1 ptisnovs ptisnovs 100 Dec 29 16:05 bytes.bin
-rw-rw-r-- 1 ptisnovs ptisnovs 200 Dec 29 16:05 shorts.bin
-rw-rw-r-- 1 ptisnovs ptisnovs 400 Dec 29 16:05 ints.bin
-rw-rw-r-- 1 ptisnovs ptisnovs 400 Dec 29 16:05 floats.bin
-rw-rw-r-- 1 ptisnovs ptisnovs 800 Dec 29 16:05 quads.bin
-rw-rw-r-- 1 ptisnovs ptisnovs 800 Dec 29 16:05 longs.bin
-rw-rw-r-- 1 ptisnovs ptisnovs 800 Dec 29 16:05 doubles.bin
</pre>

<p>Pro zajímavost si prohlédněme alespoň soubor <strong>shorts.bin</strong>,
který obsahuje pole se 100 prvky typu <i>short</i> (šestnáctibitové
hodnoty):</p>

<pre>
$ <strong>od -tx1 shorts.bin </strong>
&nbsp;
0000000 00 00 01 00 02 00 03 00 04 00 05 00 06 00 07 00
0000020 08 00 09 00 0a 00 0b 00 0c 00 0d 00 0e 00 0f 00
0000040 10 00 11 00 12 00 13 00 14 00 15 00 16 00 17 00
0000060 18 00 19 00 1a 00 1b 00 1c 00 1d 00 1e 00 1f 00
0000100 20 00 21 00 22 00 23 00 24 00 25 00 26 00 27 00
0000120 28 00 29 00 2a 00 2b 00 2c 00 2d 00 2e 00 2f 00
0000140 30 00 31 00 32 00 33 00 34 00 35 00 36 00 37 00
0000160 38 00 39 00 3a 00 3b 00 3c 00 3d 00 3e 00 3f 00
0000200 40 00 41 00 42 00 43 00 44 00 45 00 46 00 47 00
0000220 48 00 49 00 4a 00 4b 00 4c 00 4d 00 4e 00 4f 00
0000240 50 00 51 00 52 00 53 00 54 00 55 00 56 00 57 00
0000260 58 00 59 00 5a 00 5b 00 5c 00 5d 00 5e 00 5f 00
0000300 60 00 61 00 62 00 63 00
0000310
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;tohoto výsledku je patrné, že i
zde je použito uspořádání bajtů <i>little endian</i>, což může způsobit
problémy při zpracování těchto binárních souborů na architekturách
s&nbsp;uspořádáním bajtů <i>big endian</i>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Načtení obsahu polí z&nbsp;binárních souborů</h2>

<p>Opakem operace pro uložení pole do binárního souboru je pochopitelně
operace, která toto pole naopak ze souboru načte. Pro tento účel je nejdříve
nutné pole zkonstruovat (může být ovšem i prázdné) a následně jeho obsah načíst
ze souboru metodou <strong>fromfile</strong>. Této metodě se kromě
<i>handle</i> otevřeného souboru předává i počet prvků, které se mají načíst.
Soubor musí obsahovat potřebná data; v&nbsp;opačném případě dojde
k&nbsp;vyhození výjimky:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
a3 = array("I")
a4 = array("L")
a5 = array("Q")
a6 = array("f")
a7 = array("d")
&nbsp;
&nbsp;
def <strong>import_from_file</strong>(filename, struct):
    <i>"""Import celé struktury ze souboru."""</i>
    with open(filename, "rb") as f:
        struct.fromfile(f, 100)
    return struct
&nbsp;
&nbsp;
print(import_from_file("bytes.bin", a1))
print(import_from_file("shorts.bin", a2))
print(import_from_file("ints.bin", a3))
print(import_from_file("longs.bin", a4))
print(import_from_file("quads.bin", a5))
print(import_from_file("floats.bin", a6))
print(import_from_file("doubles.bin", a7))
</pre>

<p>Z&nbsp;vypsaných výsledků je patrné, že se všechna pole korektně načetla:</p>

<pre>
array('B', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])
&nbsp;
array('H', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])
&nbsp;
array('I', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])
&nbsp;
array('L', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])
&nbsp;
array('Q', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])
&nbsp;
array('f', [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0,
11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0,
22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0,
33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0,
44.0, 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0,
55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0,
66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0,
77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0,
88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0])
&nbsp;
array('d', [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0,
11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0,
22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0,
33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0,
44.0, 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0,
55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0,
66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0,
77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0,
88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0])
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Složitěji strukturované binární soubory</h2>

<p>Tím, že metody <strong>array.tofile</strong> a
<strong>array.fromfile</strong> vyžadují předání <i>handle</i> souboru, jenž
musí být otevřený pro zápis resp.&nbsp;pro čtení (a ideálně navíc
v&nbsp;binárním režimu), je umožněna více či méně sofistikovaná práce se
složitěji strukturovanými binárními soubory. V&nbsp;takových souborech můžeme
kombinovat různé sekce, využít nástroj <i>pickle</i> apod. V&nbsp;dalším
příkladu je ukázána tvorba binárního souboru, který obsahuje pět částí:</p>

<ol>
<li>Hlavička o délce sedmi bajtů</li>
<li>Pole se 100 prvky typu bajt (celkem 100 bajtů)</li>
<li>Rozdělovací prvek o délce deseti bajtů</li>
<li>Pole se 100 prvky typu short (celkem 200 bajtů)</li>
<li>Patička o délce tří bajtů</li>
</ol>

<p>Celková velikost výsledného binárního souboru by měla být:</p>

<pre>
7 + 100 + 10 + 200 + 3 = 320 bajtů
</pre>

<p>Realizace zápisu takového souboru může vypadat následovně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from array import array
&nbsp;
<i># prázdné struktury</i>
a1 = array("B")
a2 = array("H")
&nbsp;
<i># naplnit daty</i>
for i in range(100):
    a1.append(i)
    a2.append(i)
&nbsp;
&nbsp;
with open("structured.bin", "wb") as f:
    f.write(b"HEADER\n")
    a1.tofile(f)
    f.write(b"\nsplitter\n")
    a2.tofile(f)
    f.write(b"END")
</pre>

<p>Po spuštění skriptu zjistíme celkovou velikost souboru:</p>

<pre>
$ <strong>ls -l structured.bin </strong>
&nbsp;
-rw-rw-r-- 1 ptisnovs ptisnovs 320 Jan 12 12:25 structured.bin
</pre>

<p>Skutečně má délku očekávaných 320 bajtů.</p>

<p>Obsah souboru, umístění hlavičky atd. nám prozradí nástroj
<strong>hd</strong>:</p>

<pre>
$ <strong>hd structured.bin </strong>
&nbsp;
00000000  48 45 41 44 45 52 0a 00  01 02 03 04 05 06 07 08  |HEADER..........|
00000010  09 0a 0b 0c 0d 0e 0f 10  11 12 13 14 15 16 17 18  |................|
00000020  19 1a 1b 1c 1d 1e 1f 20  21 22 23 24 25 26 27 28  |....... !"#$%&amp;'(|
00000030  29 2a 2b 2c 2d 2e 2f 30  31 32 33 34 35 36 37 38  |)*+,-./012345678|
00000040  39 3a 3b 3c 3d 3e 3f 40  41 42 43 44 45 46 47 48  |9:;&lt;=&gt;?@ABCDEFGH|
00000050  49 4a 4b 4c 4d 4e 4f 50  51 52 53 54 55 56 57 58  |IJKLMNOPQRSTUVWX|
00000060  59 5a 5b 5c 5d 5e 5f 60  61 62 63 0a 73 70 6c 69  |YZ[\]^_`abc.spli|
00000070  74 74 65 72 0a 00 00 01  00 02 00 03 00 04 00 05  |tter............|
00000080  00 06 00 07 00 08 00 09  00 0a 00 0b 00 0c 00 0d  |................|
00000090  00 0e 00 0f 00 10 00 11  00 12 00 13 00 14 00 15  |................|
000000a0  00 16 00 17 00 18 00 19  00 1a 00 1b 00 1c 00 1d  |................|
000000b0  00 1e 00 1f 00 20 00 21  00 22 00 23 00 24 00 25  |..... .!.".#.$.%|
000000c0  00 26 00 27 00 28 00 29  00 2a 00 2b 00 2c 00 2d  |.&amp;.'.(.).*.+.,.-|
000000d0  00 2e 00 2f 00 30 00 31  00 32 00 33 00 34 00 35  |.../.0.1.2.3.4.5|
000000e0  00 36 00 37 00 38 00 39  00 3a 00 3b 00 3c 00 3d  |.6.7.8.9.:.;.&lt;.=|
000000f0  00 3e 00 3f 00 40 00 41  00 42 00 43 00 44 00 45  |.&gt;.?.@.A.B.C.D.E|
00000100  00 46 00 47 00 48 00 49  00 4a 00 4b 00 4c 00 4d  |.F.G.H.I.J.K.L.M|
00000110  00 4e 00 4f 00 50 00 51  00 52 00 53 00 54 00 55  |.N.O.P.Q.R.S.T.U|
00000120  00 56 00 57 00 58 00 59  00 5a 00 5b 00 5c 00 5d  |.V.W.X.Y.Z.[.\.]|
00000130  00 5e 00 5f 00 60 00 61  00 62 00 63 00 45 4e 44  |.^._.`.a.b.c.END|
00000140
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Teoretická a praktická rychlost přístupu k&nbsp;prvkům polí</h2>

<p>V&nbsp;tomto článku jsme již na několika místech porovnávali klasický seznam
s&nbsp;poli realizovanými ve standardním balíčku <strong>array</strong>.
Vzhledem k&nbsp;tomu, že prvky pole jsou v&nbsp;této datové struktuře uloženy
přímo, tj.&nbsp;bez výplní a <i>boxingu</i>, je spotřeba operační paměti polem
menší, než je tomu v&nbsp;případě seznamů. To je vlastně jediná výhoda této
datové struktury. Samotné čtení hodnoty prvky či zápis hodnoty prvku je ve
skutečnosti časově náročnější, protože je nutné provádět <i>boxing</i> při
čtení a <i>unboxing</i> při zápisu (to jsou operace, které obalí hodnotu
&bdquo;objektem&ldquo;, protože v&nbsp;Pythonu se se všemi hodnotami pracuje
jako s&nbsp;objekty).</p>

<p>Větší časovou náročnost čtení a zápisu prvků pole si můžeme ověřit na
libovolném algoritmu, který s&nbsp;prvky pole či seznamu intenzivně pracuje.
Pro měření a jako jednoduchý benchmark budeme realizovat již několikrát zmíněný
algoritmus bublinkového řazení (skutečně se v&nbsp;češtině takto označuje). Ten
lze pochopitelně realizovat nad seznamy, a to velmi snadno:</p>

<pre>
from time import perf_counter
import random
&nbsp;
size = 10000
&nbsp;
a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
t1 = perf_counter()
&nbsp;
for i in range(size - 1, 0, -1):
    for j in range(0, i):
        if a[j] &gt; a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Sorted in {t2-t1} seconds:")
&nbsp;
print("\nBegins with:")
print(a[:100])
&nbsp;
print("\nEnds with:")
print(a[-100:])
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Tentýž výpočet, ovšem realizovaný s&nbsp;využitím polí</h2>

<p>Zápis algoritmu <a href="#k14">z&nbsp;předchozí kapitoly</a> je možné velmi
jednoduše upravit do takové podoby, aby se namísto seznamů požívalo pole.
Použijeme pole celých čísel typu <i>integer</i> bez znaménka, které mají
minimální rozsah hodnot 0..65535. Povšimněte si, že samotná výkonná část
algoritmu (dvojice vnořených smyček a podmínka) zůstala totožná, to díky tomu,
že pro seznamy i pro pole se používá stejný zápis operátoru indexování:</p>

<pre>
from time import perf_counter
from array import array
import random
&nbsp;
size = 10000
&nbsp;
a = array("I", [random.randrange(0, 10000) for i in range(size)])
&nbsp;
t1 = perf_counter()
&nbsp;
for i in range(size - 1, 0, -1):
    for j in range(0, i):
        if a[j] &gt; a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Sorted in {t2-t1} seconds:")
&nbsp;
print("\nBegins with:")
print(a[:100])
&nbsp;
print("\nEnds with:")
print(a[-100:])
</pre>

<p>Nyní začíná nejzajímavější část &ndash; porovnání rychlosti běhu obou
implementací:</p>

<table>
<tr><th>Implementace</th><th>Čas běhu</th></tr>
<tr><td>seznam</td><td>10,3 s</td></tr>
<tr><td>pole</td><td>12,5 s</td></tr>
</table>

<p>Z&nbsp;výsledků je patrné, že &ndash; i když to je neintuitivní &ndash; je
čtení a zápis prvků do seznamů rychlejší, než provedení týchž operací
s&nbsp;polem (primitivních) hodnot. Opět tedy zopakujme &ndash; pole
<strong>array</strong> jsou výhodná pouze co se týče ušetření obsazení operační
paměti, nikoli z&nbsp;důvodu větší rychlosti.</p>

<p><div class="rs-tip-major">Poznámka: totéž platí i pro <i>nd-array</i>
z&nbsp;knihovny <i>NumPy</i> v&nbsp;případě, že se operace provádí přímo
v&nbsp;Pythonu a nikoli v&nbsp;NumPy (příkladem je výpočet sumy &ndash; buď
programově smyčkou, nebo zavoláním <strong>array.sum()</strong>).</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Interní způsob uložení pole v&nbsp;paměti</h2>

<p>Na závěr se podívejme pod kapotu Pythonu, konkrétně na to, jak vlastně
vypadá interní způsob uložení pole v&nbsp;operační paměti. Příslušné zdrojový
kódy je možné nalézt v&nbsp;souboru <strong>Modules/arraymodule.c</strong>.</p>

<p>První datovou strukturou, o které se zmíníme, je struktura nazvaná
<strong>arraydescr</strong>. Ta slouží pro popis jednotlivých typů pole
resp.&nbsp;typů prvků, které jsou do zkonstruovaného pole vkládány:</p>

<pre>
struct <strong>arraydescr</strong> {
    char typecode;
    int itemsize;
    PyObject * (*getitem)(struct arrayobject *, Py_ssize_t);
    int (*setitem)(struct arrayobject *, Py_ssize_t, PyObject *);
    int (*compareitems)(const void *, const void *, Py_ssize_t);
    const char *formats;
    int is_integer_type;
    int is_signed;
};
</pre>

<pre>
static const struct arraydescr <strong>descriptors</strong>[] = {
    {'b', 1, b_getitem, b_setitem, b_compareitems, "b", 1, 1},
    {'B', 1, BB_getitem, BB_setitem, BB_compareitems, "B", 1, 0},
    {'u', sizeof(wchar_t), u_getitem, u_setitem, u_compareitems, "u", 0, 0},
    {'h', sizeof(short), h_getitem, h_setitem, h_compareitems, "h", 1, 1},
    {'H', sizeof(short), HH_getitem, HH_setitem, HH_compareitems, "H", 1, 0},
    {'i', sizeof(int), i_getitem, i_setitem, i_compareitems, "i", 1, 1},
    {'I', sizeof(int), II_getitem, II_setitem, II_compareitems, "I", 1, 0},
    {'l', sizeof(long), l_getitem, l_setitem, l_compareitems, "l", 1, 1},
    {'L', sizeof(long), LL_getitem, LL_setitem, LL_compareitems, "L", 1, 0},
    {'q', sizeof(long long), q_getitem, q_setitem, q_compareitems, "q", 1, 1},
    {'Q', sizeof(long long), QQ_getitem, QQ_setitem, QQ_compareitems, "Q", 1, 0},
    {'f', sizeof(float), f_getitem, f_setitem, NULL, "f", 0, 0},
    {'d', sizeof(double), d_getitem, d_setitem, NULL, "d", 0, 0},
    {'\0', 0, 0, 0, 0, 0, 0} /* Sentinel */
};
</pre>

<pre>
typedef struct <strong>arrayobject</strong> {
    PyObject_VAR_HEAD
    char *ob_item;
    Py_ssize_t allocated;
    const struct arraydescr *ob_descr;
    PyObject *weakreflist; /* List of weak references */
    Py_ssize_t ob_exports;  /* Number of exported buffers */
} <strong>arrayobject</strong>;
</pre>

<pre>
static PyObject *
<strong>newarrayobject</strong>(PyTypeObject *type, Py_ssize_t size, const struct arraydescr *descr)
{
    arrayobject *op;
    size_t nbytes;
&nbsp;
    if (size &lt; 0) {
        PyErr_BadInternalCall();
        return NULL;
    }
&nbsp;
    /* Check for overflow */
    if (size &gt; PY_SSIZE_T_MAX / descr-&gt;itemsize) {
        return PyErr_NoMemory();
    }
    nbytes = size * descr-&gt;itemsize;
    op = (arrayobject *) type-&gt;tp_alloc(type, 0);
    if (op == NULL) {
        return NULL;
    }
    op-&gt;ob_descr = descr;
    op-&gt;allocated = size;
    op-&gt;weakreflist = NULL;
    Py_SET_SIZE(op, size);
    if (size &lt;= 0) {
        op-&gt;ob_item = NULL;
    }
    else {
        op-&gt;ob_item = PyMem_NEW(char, nbytes);
        if (op-&gt;ob_item == NULL) {
            Py_DECREF(op);
            return PyErr_NoMemory();
        }
    }
    op-&gt;ob_exports = 0;
    return (PyObject *) op;
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Algoritmus pro alokaci paměti pro zvětšující a zmenšující se pole</h2>

<pre>
static int
<strong>array_resize</strong>(arrayobject *self, Py_ssize_t newsize)
{
    char *items;
    size_t _new_size;
&nbsp;
    if (self-&gt;ob_exports &gt; 0 &amp;&amp; newsize != Py_SIZE(self)) {
        PyErr_SetString(PyExc_BufferError,
            "cannot resize an array that is exporting buffers");
        return -1;
    }
&nbsp;
    /* Bypass realloc() when a previous overallocation is large enough
       to accommodate the newsize.  If the newsize is 16 smaller than the
       current size, then proceed with the realloc() to shrink the array.
    */
&nbsp;
    if (self-&gt;allocated &gt;= newsize &amp;&amp;
        Py_SIZE(self) &lt; newsize + 16 &amp;&amp;
        self-&gt;ob_item != NULL) {
        Py_SET_SIZE(self, newsize);
        return 0;
    }
&nbsp;
    if (newsize == 0) {
        PyMem_Free(self-&gt;ob_item);
        self-&gt;ob_item = NULL;
        Py_SET_SIZE(self, 0);
        self-&gt;allocated = 0;
        return 0;
    }
&nbsp;
    /* This over-allocates proportional to the array size, making room
     * for additional growth.  The over-allocation is mild, but is
     * enough to give linear-time amortized behavior over a long
     * sequence of appends() in the presence of a poorly-performing
     * system realloc().
     * The growth pattern is:  0, 4, 8, 16, 25, 34, 46, 56, 67, 79, ...
     * Note, the pattern starts out the same as for lists but then
     * grows at a smaller rate so that larger arrays only overallocate
     * by about 1/16th -- this is done because arrays are presumed to be more
     * memory critical.
     */
&nbsp;
    _new_size = (newsize &gt;&gt; 4) + (Py_SIZE(self) &lt; 8 ? 3 : 7) + newsize;
    items = self-&gt;ob_item;
    /* XXX The following multiplication and division does not optimize away
       like it does for lists since the size is not known at compile time */
    if (_new_size &lt;= ((~(size_t)0) / self-&gt;ob_descr-&gt;itemsize))
        PyMem_RESIZE(items, char, (_new_size * self-&gt;ob_descr-&gt;itemsize));
    else
        items = NULL;
    if (items == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    self-&gt;ob_item = items;
    Py_SET_SIZE(self, newsize);
    self-&gt;allocated = _new_size;
    return 0;
}
</pre>

 

<p><a name="k18"></a></p>
<h2 id="k18">18. Průběh alokace</h2>

<pre>
21:37 $ python3.9 alloc_details.py 
    0     80     +8      0-0   
    8     88     +8      0-8   
   16    104    +16      8-16  
   25    112     +8     16-25  
   34    120     +8     25-34  
   44    128     +8     34-44  
   54    144    +16     44-54  
   65    152     +8     54-65  
   77    168    +16     65-77  
   89    176     +8     77-89  
  102    192    +16     89-102 
  116    208    +16    102-116 
  131    224    +16    116-131 
  147    240    +16    131-147 
  164    256    +16    147-164 
  182    280    +24    164-182 
  201    296    +16    182-201 
  221    320    +24    201-221 
  242    344    +24    221-242 
  265    368    +24    242-265 
  289    392    +24    265-289 
  315    416    +24    289-315 
  342    448    +32    315-342 
  371    480    +32    342-371 
  402    512    +32    371-402 
  435    544    +32    402-435 
  470    584    +40    435-470 
  507    624    +40    470-507 
  546    664    +40    507-546 
  588    704    +40    546-588 
  632    752    +48    588-632 
  679    808    +56    632-679 
  729    856    +48    679-729 
  782    912    +56    729-782 
  838    976    +64    782-838 
  898   1040    +64    838-898 
  962   1104    +64    898-962 
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Odkazy na jednotlivé příklady jsou uvedeny v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>empty_structs.py</td><td>inicializace prázdných struktur (seznamu a polí) a získání jejich velikosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/empty_structs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/empty_structs.py</a></td></tr>
<tr><td> 2</td><td>hundred_items.py</td><td>přidání 100 prvků do každé struktury a získání jejich velikosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/hundred_items.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/hundred_items.py</a></td></tr>
<tr><td> 3</td><td>10000_items.py</td><td>přidání 10000 prvků do každé struktury a získání jejich velikosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/10000_items.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/10000_items.py</a></td></tr>
<tr><td> 4</td><td>read_values.py</td><td>čtení hodnot prvků ze seznamů a polí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/read_values.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/read_values.py</a></td></tr>
<tr><td> 5</td><td>insert_item.py</td><td>operace pro vložení prvku na zvolený index</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/insert_item.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/insert_item.py</a></td></tr>
<tr><td> 6</td><td>tobytes.py</td><td>konverze polí na hodnotu typu <strong>bytes</strong> s&nbsp;jejím tiskem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/tobytes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/tobytes.py</a></td></tr>
<tr><td> 7</td><td>export_to_file.py</td><td>export polí do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/export_to_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/export_to_file.py</a></td></tr>
<tr><td> 8</td><td>import_from_file.py</td><td>import polí z&nbsp;binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/import_from_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/import_from_file.py</a></td></tr>
<tr><td> 9</td><td>bubble_sort_1.py </td><td>algoritmus bublinkového řazení realizovaný nad seznamy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_1.py</a></td></tr>
<tr><td>10</td><td>bubble_sort_2.py </td><td>algoritmus bublinkového řazení realizovaný nad polem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/bubble_sort_2.py</a></td></tr>
<tr><td>11</td><td>structured_file.py </td><td>zápis polí do souboru se strukturou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/array/structured_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/array/structured_file.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>array — Efficient arrays of numeric values<br />
<a href="https://docs.python.org/3/library/array.html">https://docs.python.org/3/library/array.html</a>
</li>

<li>Top 5 Python Memory Profilers<br />
<a href="https://stackify.com/top-5-python-memory-profilers/">https://stackify.com/top-5-python-memory-profilers/</a>
</li>

<li>Pympler na GitHubu<br />
<a href="https://github.com/pympler/pympler">https://github.com/pympler/pympler</a>
</li>

<li>Pympler na PyPI<br />
<a href="https://pypi.org/project/Pympler/">https://pypi.org/project/Pympler/</a>
</li>

<li>Dokumentace k&nbsp;balíčku Pympler<br />
<a href="https://pympler.readthedocs.io/en/latest/">https://pympler.readthedocs.io/en/latest/</a>
</li>

<li>Guppy 3 na GitHubu<br />
<a href="https://github.com/zhuyifei1999/guppy3/">https://github.com/zhuyifei1999/guppy3/</a>
</li>

<li>Guppy 3 na PyPI<br />
<a href="https://pypi.org/project/guppy3/">https://pypi.org/project/guppy3/</a>
</li>

<li>Memory Profiler na GitHubu<br />
<a href="https://github.com/pythonprofilers/memory_profiler">https://github.com/pythonprofilers/memory_profiler</a>
</li>

<li>Memory Profiler na PyPI<br />
<a href="https://pypi.org/project/memory-profiler/">https://pypi.org/project/memory-profiler/</a>
</li>

<li>How to use guppy/heapy for tracking down memory usage<br />
<a href="https://smira.ru/wp-content/uploads/2011/08/heapy.html">https://smira.ru/wp-content/uploads/2011/08/heapy.html</a>
</li>

<li>Identifying memory leaks<br />
<a href="https://pympler.readthedocs.io/en/latest/muppy.html#muppy">https://pympler.readthedocs.io/en/latest/muppy.html#muppy</a>
</li>

<li>How do I determine the size of an object in Python?<br />
<a href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python</a>
</li>

<li>Why is bool a subclass of int?<br />
<a href="https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int">https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int</a>
</li>

<li>Memory Management in Python<br />
<a href="https://realpython.com/python-memory-management/">https://realpython.com/python-memory-management/</a>
</li>

<li>Why do ints require three times as much memory in Python?<br />
<a href="https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python">https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python</a>
</li>

<li>cpython/Include/cpython/longintrepr.h<br />
<a href="https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64">https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64</a>
</li>

<li>sys — System-specific parameters and functions<br />
<a href="https://docs.python.org/3/library/sys.html">https://docs.python.org/3/library/sys.html</a>
</li>

<li>Stránky projektu Numpy<br />
<a href="https://numpy.org/">https://numpy.org/</a>
</li>

<li>Numpy na GitHubu<br />
<a href="https://github.com/numpy/numpy">https://github.com/numpy/numpy</a>
</li>

<li>NumPy documentation<br />
<a href="https://numpy.org/doc/stable/">https://numpy.org/doc/stable/</a>
</li>

<li>The N-dimensional array (ndarray)<br />
<a href="https://numpy.org/doc/stable/reference/arrays.ndarray.html">https://numpy.org/doc/stable/reference/arrays.ndarray.html</a>
</li>

<li>numpy.ndarray<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html">https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

