<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Podpora funkcionálního programování v Pythonu a knihovna functools (2. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Podpora funkcionálního programování v Pythonu a knihovna functools (2. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Podpora funkcionálního programování v&nbsp;Pythonu a knihovna functools (2. část)</a></p>
<p><a href="#k02">2. Funkce jakožto plnohodnotný datový typ</a></p>
<p><a href="#k03">3. Další nutný důsledek &ndash; uzávěry</a></p>
<p><a href="#k04">4. Uzávěry v&nbsp;Pythonu</a></p>
<p><a href="#k05">5. Nekorektní implementace čítače založeného na uzávěru</a></p>
<p><a href="#k06">6. Korektní implementace čítače &ndash; přístup k&nbsp;nelokální proměnné</a></p>
<p><a href="#k07">7. Nelokální funkce a uzávěry (umělý příklad)</a></p>
<p><a href="#k08">8. Curryfikace (<i>currying</i>) a částečně vyhodnocené funkce</a></p>
<p><a href="#k09">9. Funkce <strong>partial</strong> z&nbsp;balíčku <strong>functools</strong></a></p>
<p><a href="#k10">10. Příklad základního použití funkce <strong>partial</strong></a></p>
<p><a href="#k11">11. Transformace funkce se třemi parametry s&nbsp;využitím <strong>partial</strong></a></p>
<p><a href="#k12">12. Transformace funkce s&nbsp;dosazením většího množství parametrů s&nbsp;využitím <strong>partial</strong></a></p>
<p><a href="#k13">13. Několikanásobná transformace původní funkce na několik nových funkcí</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podpora funkcionálního programování v&nbsp;Pythonu a knihovna functools (2. část)</h2>

<p>Na <a
href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-pythonu-a-knihovna-functools/">úvodní
článek</a> o podpoře funkcionálního programování v&nbsp;jazyku Python dnes
navážeme. Již minule jsme se zmínili o existenci standardní knihovny nazvané <a
href="https://docs.python.org/3/library/functools.html">functools</a>, která
vývojářům nabízí některé funkcionální techniky. Konkrétně jsme se seznámili
s&nbsp;funkcí vyššího řádu <strong>reduce</strong>, která je zde definována
(což je ostatně zajímavé, protože její &bdquo;sesterské&ldquo; funkce
<strong>map</strong> a <strong>filter</strong> jsou umístěny ve výchozím
jmenném prostoru Pythonu a není je tedy nutné importovat &ndash; jednoduše se
dají přímo zavolat).</p>

<p>Dnes se seznámíme s&nbsp;dalšími funkcemi, které v&nbsp;balíčku
<strong>functools</strong> nalezneme. Ostatně přímo z&nbsp;interaktivního
shellu jazyka Python (tedy z&nbsp;<i>REPLu</i>) lze snadno získat jména
veřejných symbolů, které v&nbsp;tomto balíčku existují. Je to snadné (a pro
zajímavost zde použijeme generátorovou notaci):</p>

<pre>
import functools
&nbsp;
print("\n".join(name for name in dir(functools) if name[0]!="_"))
</pre>

<p>Výsledek by mohl vypadat následovně:</p>

<pre>
RLock
WRAPPER_ASSIGNMENTS
WRAPPER_UPDATES
cached_property
cmp_to_key
get_cache_token
lru_cache
namedtuple
partial
partialmethod
recursive_repr
reduce
singledispatch
singledispatchmethod
total_ordering
update_wrapper
wraps
</pre>

<p><div class="rs-tip-major">Poznámka: balíček <strong>functools</strong> se ve
skutečnosti neustále rozšiřuje, takže vypsaný seznam nemusí být na vašem
počítači naprosto stejný. Příklad nově přidaných symbolů:</div></p>

<table>
<tr><th>Symbol</th><th>Verze Pythonu</th></tr>
<tr><td>wraps, update_wrapper, partial</td><td>2.5</td></tr>
<tr><td>reduce</td><td>3.0</td></tr>
<tr><td>total_ordering, cmp_to_key</td><td>3.2</td></tr>
<tr><td>partialmethod, singledispatch</td><td>3.4</td></tr>
<tr><td>cached_property, singledispatchmethod</td><td>3.8</td></tr>
<tr><td>cache</td><td>3.9</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Funkce jakožto plnohodnotný datový typ</h2>

<p>Již několikrát jsme si v&nbsp;předchozím článku řekli, že ve funkcionálních
programovacích jazycích jsou funkce plnohodnotnými datovými typy. Stejně je
tomu tak i v&nbsp;případě Pythonu. Ovšem co toto tvrzení znamená v&nbsp;praxi?
V&nbsp;případě Pythonu poměrně velké množství vlastností, které z&nbsp;tohoto
tvrzení přímo či nepřímo vycházejí. Pokusme se vyjmenovat alespoň ty
nejdůležitější vlastnosti:</p>

<ol>

<li>Funkce je možné mít přístupné přes globální symbol (v&nbsp;daném jmenném
prostoru). To je zcela jistě nejznámější způsob definice (pojmenovaných) funkcí
a v&nbsp;Pythonu pro tento účel existuje vyhrazené slovo <strong>def</strong>
(některé funkcionální jazyky ovšem speciální klíčové slovo nepotřebují).</li>

<li>Funkce je ovšem možné deklarovat i lokálně, tj.&nbsp;v&nbsp;nějakém bloku.
Viditelnost takové funkce se řídí stejnými pravidly, jako viditelnost jakékoli
jiné hodnoty.</li>

<li>Navíc je ovšem možné přistupovat k&nbsp;nelokální funkci (v&nbsp;Pythonu
pro přístup resp.&nbsp;modifikaci nelokálních symbolů existuje klíčové slovo
<strong>nonlocal</strong>), což se pravděpodobně nepoužívá (alespoň jsme to
nikde v&nbsp;praxi neviděl), ale sémantika Pythonu to umožňuje.</li>

<li>Funkce může být předána jako parametr jiné funkci. To již dobře známe,
protože jsme si popsali například funkce vyššího řádu <strong>map</strong>,
<strong>filter</strong> a <strong>reduce</strong>, které skutečně akceptují
jako svůj parametr jinou funkci.</li>

<li>Funkce může být vrácena jako návratová hodnota jiné funkce. To již opět
známe, protože jsme na toto téma měli několik demonstračních příkladů (výpočet
výsledku na základě zvoleného operátoru atd.).</li>

<li>Funkce může být uložena do atributu třídy. V&nbsp;OOP potom mluvíme o
metodách.</li>

<li>Funkce může být uložena do atributu objektu.</li>

<li>Funkce může být uložena do libovolného kontejneru (n-tice, seznam, množina,
slovník).</li>

</ol>

<p>Některé funkcionální jazyky navíc umožňují další, řekněme pokročilejší,
manipulace s&nbsp;funkcemi. Jedná se o formy transformace funkcí (což umožňují
zejména jazyky postavené na LISPu), dále o vytváření nových funkcí
s&nbsp;využitím jejich <i>kompozice</i>, obalení funkce nějakou formou
<i>cache</i> a v&nbsp;neposlední řadě některé programovací jazyky podporují
takzvaný <i>currying</i>, s&nbsp;jehož variantou pro Python se seznámíme
v&nbsp;navazujícím textu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Další nutný důsledek &ndash; uzávěry</h2>

<p>Pojďme dále &ndash; víme, že funkce jsou plnohodnotné typy a tedy mohou být
vytvořeny lokálně (tím vznikne hodnota). A v&nbsp;Pythonu můžeme
<i>jakoukoli</i> hodnotu z&nbsp;funkce vrátit konstrukcí
<strong>return</strong>. To není nic nového, takže si to můžeme vyzkoušet:</p>

<pre>
def <strong>foo</strong>():
    def <strong>bar</strong>():
        print("BAR")
    return bar
&nbsp;
x = foo()
x()
</pre>

<p>Po spuštění tohoto příkladu se podle očekávání vypíše &bdquo;BAR&ldquo;.</p>

<pre>
BAR
</pre>

<p>Jenže ve většině programovacích jazyků, a to včetně Pythonu, platí, že
z&nbsp;vnitřního bloku (a tedy i z&nbsp;lokální funkce) se můžeme odkazovat na
proměnné deklarované ve vnějším bloku. A můžeme tedy psát například:</p>

<pre>
def <strong>foo</strong>():
    message = "FOO-BAR"
&nbsp;
    def <strong>bar</strong>():
        print(message)
    return bar
&nbsp;
x = foo()
x()
</pre>

<p>Funkce <strong>bar</strong>, která je vrácena z&nbsp;funkce
<strong>foo</strong>, si &bdquo;pamatuje&ldquo; hodnotu lokální proměnné
<strong>message</strong> a dokáže ji využít (a jak uvidíme dále, tak i měnit
&ndash; což je z&nbsp;mnoha důvodů problematické). Toto navázání funkce na své
prostředí se nazývá <i>uzávěr</i> neboli <i>closure</i>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Uzávěry v&nbsp;Pythonu</h2>

<p>Samotné použití uzávěrů je sice v&nbsp;dnes již starodávném Pythonu 2.x
poněkud problematické (což ostatně uvidíme v&nbsp;navazujícím textu), ovšem
v&nbsp;Pythonu 3.x je již tento nedostatek související se sémantikou rozpoznání
lokálních a nelokálních proměnných odstraněn a tak mají uzávěry v&nbsp;Pythonu
prakticky stejnou vyjadřovací sílu, jako například v&nbsp;programovacích
jazycích Lua či JavaScript; nehledě již na většinu funkcionálních jazyků, které
samozřejmě práci s&nbsp;uzávěry ve většině případů taktéž podporují (zde byly
&bdquo;objeveny&ldquo;). Uzávěry jsou navíc tak důležitou součástí Pythonu, že
pro jejich implementaci jsou v&nbsp;bajtkódu Python VM rezervovány dvě
instrukce nazvané <strong>LOAD_CLOSURE</strong> a
<strong>MAKE_CLOSURE</strong>.</p>

<p>První demonstrační příklad s&nbsp;uzávěrem je velmi prostý, protože je zde
funkce (která tvoří základ uzávěru) navázána na hodnotu parametru předaného do
funkce, v&nbsp;níž se uzávěr vytváří. Pro lepší čitelnost je funkce tvořící
základ uzávěru pojmenována, ve skutečnosti by však bylo možné
v&nbsp;jednodušších případech použít i anonymní funkce vytvořené
s&nbsp;využitím klíčového slova <strong>lambda</strong> (zde však programovací
jazyk Python omezuje těla takových funkcí na jediný výraz, což může být někdy
příliš striktní, ostatně právě proto si ukazujeme použití vnitřní neanonymní
funkce):</p>

<pre>
def <strong>dummyAdder</strong>(delta):
    def <strong>add</strong>(n):
        return delta + n
    return add
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Spusteni testu.</i>
<i>#</i>
def <strong>main</strong>():
    adder1 = dummyAdder(0)
    adder2 = dummyAdder(42)
    for i in range(1,11):
        result1 = adder1(i)
        result2 = adder2(i)
        print("Iteration #%d" % i)
        print("    Adder1: %d" % result1)
        print("    Adder2: %d" % result2)
</pre>

<p>Po spuštění tohoto demonstračního příkladu je patrné, že se skutečně každý
uzávěr navázal na jinou hodnotu parametru předaného do funkce vytvářející
uzávěr:</p>

<pre>
Iteration #1
    Adder1: 1
    Adder2: 43
Iteration #2
    Adder1: 2
    Adder2: 44
Iteration #3
    Adder1: 3
    Adder2: 45
Iteration #4
    Adder1: 4
    Adder2: 46
Iteration #5
    Adder1: 5
    Adder2: 47
Iteration #6
    Adder1: 6
    Adder2: 48
Iteration #7
    Adder1: 7
    Adder2: 49
Iteration #8
    Adder1: 8
    Adder2: 50
Iteration #9
    Adder1: 9
    Adder2: 51
Iteration #10
    Adder1: 10
    Adder2: 52
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nekorektní implementace čítače založeného na uzávěru</h2>

<p>Pokusme se nyní uzávěr využít pro implementaci čítače, tedy funkce, která po
svém zavolání vrátí celé číslo, které se bude s&nbsp;každým voláním postupně
zvyšovat. Bude se tedy jednat o funkci se stavem:</p>

<pre>
def <strong>createCounter</strong>():
    counter = 0
    def <strong>next</strong>():
        counter += 1
        return counter
    return next
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Spusteni testu.</i>
<i>#</i>
def <strong>main</strong>():
    counter1 = createCounter()
    counter2 = createCounter()
    for i in range(1,11):
        result1 = counter1()
        result2 = counter2()
        print("Iteration #%d" % i)
        print("    Counter1: %d" % result1)
        print("    Counter2: %d" % result2)
</pre>

<p>Ve skutečnosti však takto naprogramovaný uzávěr nebude funkční, protože
k&nbsp;vázané proměnné <strong>counter</strong> sice může uzávěr přistupovat
při čtení, ale nikoli už při zápisu (modifikaci). Proč dojde k&nbsp;chybě lze
zjednodušeně řečeno vysvětlit tak, že interpret Pythonu musí mít informaci o
tom, že proměnná <strong>counter</strong> není interní proměnnou uzávěru, ale
vázanou (tedy nelokální) proměnnou. Z&nbsp;tohoto důvodu při spuštění tohoto
příkladu dojde k&nbsp;běhové výjimce. Proto je zapotřebí dávat pozor na to, že
ne všechny uzávěry implementované v&nbsp;programovacích jazycích jakými jsou
Lua či JavaScript lze bez problémů (resp.&nbsp;bez přemýšlení) přímo přepsat do
Pythonu:</p>

<pre>
Traceback (most recent call last):
  File "counter_clojure_1.py", line 24, in <module>
    main()
  File "counter_clojure_1.py", line 17, in main
    result1 = counter1()
  File "counter_clojure_1.py", line 4, in next
    counter += 1
UnboundLocalError: local variable 'counter' referenced before assignment
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Korektní implementace čítače &ndash; přístup k&nbsp;nelokální proměnné</h2>

<p>Aby bylo možné vytvářet plnohodnotné uzávěry s&nbsp;modifikovatelným
prostředím (<i>environment</i>) i v&nbsp;Pythonu, bylo do verze 3.x přidáno
nové klíčové slovo <strong>nonlocal</strong>. Tímto klíčovým slovem je možné ve
vnitřní funkci &ndash; tedy ve vlastním &bdquo;jádru&ldquo; uzávěru &ndash;
označit proměnnou, která nemá být chápána jako proměnná lokální, ale ke které
chceme přistupovat. Ovšem ve skutečnosti můžeme uzávěr implementující čítač
vytvořit i v&nbsp;Pythonu 2, a to pomocí malého triku: namísto skalární
(celočíselné) proměnné se použije jednorozměrný seznam.  Zde již interpret
nebude mít problém s&nbsp;rozeznáním lokální proměnné od proměnné vázané, neboť
význam řádků <strong>counter += 1</strong> a <strong>counter[0] += 1</strong>
je sémanticky odlišný (interpret si je ve druhém případě jistý, že se
<u>ne</u>jedná o deklaraci nové lokální proměnné):</p>

<pre>
<i>#</i>
<i># Jednoduchy uzaver v Pythonu.</i>
<i>#</i>
def <strong>createCounter</strong>():
    counter = [0]
    def <strong>next</strong>():
        counter[0] += 1
        return counter[0]
    return next
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Spusteni testu.</i>
<i>#</i>
def <strong>main</strong>():
    counter1 = createCounter()
    counter2 = createCounter()
    for i in range(1,11):
        result1 = counter1()
        result2 = counter2()
        print("Iteration #%d" % i)
        print("    Counter1: %d" % result1)
        print("    Counter2: %d" % result2)
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Ukazka disasembleru.</i>
<i># (prekladu funkci do bajtkodu Python VM).</i>
<i>#</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\ncreateCounter():")
    dis(createCounter)
&nbsp;
    print("\nmain():")
    dis(main)
&nbsp;
&nbsp;
&nbsp;
main()
</pre>

<p>Z&nbsp;následujícího výpisu je patrné, že tento demonstrační příklad
skutečně funguje, a to i v&nbsp;Pythonu 2:</p>

<pre>
Iteration #1
    Counter1: 1
    Counter2: 1
Iteration #2
    Counter1: 2
    Counter2: 2
Iteration #3
    Counter1: 3
    Counter2: 3
Iteration #4
    Counter1: 4
    Counter2: 4
Iteration #5
    Counter1: 5
    Counter2: 5
Iteration #6
    Counter1: 6
    Counter2: 6
Iteration #7
    Counter1: 7
    Counter2: 7
Iteration #8
    Counter1: 8
    Counter2: 8
Iteration #9
    Counter1: 9
    Counter2: 9
Iteration #10
    Counter1: 10
    Counter2: 10
</pre>

<p>A pro úplnost se podívejme na způsob použití již zmíněného klíčového slova
<strong>nonlocal</strong>:</p>

<pre>
def <strong>createCounter</strong>():
    counter = 0
    def next():
        <u>nonlocal counter</u>
        counter += 1
        return counter
    return next
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Spusteni testu.</i>
<i>#</i>
def <strong>main</strong>():
    counter1 = createCounter()
    counter2 = createCounter()
    for i in range(1,11):
        result1 = counter1()
        result2 = counter2()
        print("Iteration #%d" % i)
        print("    Counter1: %d" % result1)
        print("    Counter2: %d" % result2)
&nbsp;
&nbsp;
main()
</pre>

<p>Výsledek je totožný:</p>

<pre>
Iteration #1
    Counter1: 1
    Counter2: 1
Iteration #2
    Counter1: 2
    Counter2: 2
Iteration #3
    Counter1: 3
    Counter2: 3
Iteration #4
    Counter1: 4
    Counter2: 4
Iteration #5
    Counter1: 5
    Counter2: 5
Iteration #6
    Counter1: 6
    Counter2: 6
Iteration #7
    Counter1: 7
    Counter2: 7
Iteration #8
    Counter1: 8
    Counter2: 8
Iteration #9
    Counter1: 9
    Counter2: 9
Iteration #10
    Counter1: 10
    Counter2: 10
</pre>

<p><div class="rs-tip-major">Poznámka: jen na okraj &ndash; povšimněte si, jak
nám měnitelnost (mutabilita) hodnot komplikuje život; a to dokonce na
syntaktické a sémantické úrovni jazyka.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nelokální funkce a uzávěry (umělý příklad)</h2>

<p>V&nbsp;předchozích čtyřech kapitolách jsme si vypsali několik vlastností
programovacího jazyka Python, které souvisí s&nbsp;funkcemi. Mnohé
z&nbsp;těchto vlastností si můžeme ukázat na zcela umělém demonstračním
příkladu, který je založen na použití uzávěrů (<i>closure</i>), lokálně
definovaných funkcí i na možnosti vrácení funkce z&nbsp;jiné funkce
s&nbsp;využitím návratové hodnoty (tedy tak, jak bychom to udělali
s&nbsp;jakoukoli jinou návratovou hodnotou). Nejdříve se podívejme na zdrojový
kód tohoto příkladu (opět připomínám &ndash; jedná se o zcela umělou
konstrukci, kterou s&nbsp;velkou pravděpodobností v&nbsp;takové podobě nikdy
nepoužijete):</p>

<pre>
def <strong>foo</strong>():
&nbsp;
   def <strong>bar</strong>():
       print("original BAR")
&nbsp;
   def <strong>other_bar</strong>():
       print("modified BAR")
&nbsp;
   def <strong>baz</strong>(modify):
       nonlocal bar
       if modify:
           bar = other_bar
       return bar
   return baz
&nbsp;
x = foo()
&nbsp;
print(x)
x(False)()
x(True)()
</pre>

<p>Povšimněte si, že hodnoty uložené do symbolů <strong>bar</strong>,
<strong>other_bar</strong> a <strong>baz</strong> nejsou zapomenuty při odchodu
z&nbsp;funkce <strong>foo</strong>, protože celé prostředí (<i>environment</i>)
může být použito později. Jedná se tedy o uzávěr, tedy o konstrukci, s&nbsp;níž
jsme se seznámili v&nbsp;předchozí kapitole.</p>

<p>Pojďme si nyní otestovat, co se stane po spuštění tohoto skriptu
v&nbsp;interpretru Pythonu:</p>

<pre>
&lt;function foo.&lt;locals&gt;.baz at 0x7f56cecf7950&gt;
original BAR
modified BAR
</pre>

<p>Jak je z&nbsp;předchozích tří vypsaných řádků patrné, došlo ke třem
operacím:</p>

<ol>

<li>Zavoláním funkce <strong>foo</strong> se lokálně vytvořily tři funkce
<strong>bar</strong>, <strong>other_bar</strong> a <strong>baz</strong>. Došlo
k&nbsp;vrácení funkce <strong>baz</strong>.</li>

<li>Zavoláním funkce <strong>x(False)</strong> se ve skutečnosti zavolala
funkce <strong>baz</strong> a její návratovou hodnotou je lokální funkce
<strong>bar</strong>, která byla zavolána a vypsala &bdquo;original
BAR&ldquo;.</li>

<li>Zavoláním funkce <strong>x(True)</strong> se ve skutečnosti zavolala funkce
<strong>baz</strong>, která změnila nelokální hodnotu uloženou do
<strong>bar</strong> a její návratovou hodnotou je lokální funkce
<strong>other_bar</strong>, která byla zavolána a vypsala &bdquo;modified
BAR&ldquo;.</li>

</ol>



<p><a name="k08"></a></p>
<h2 id="k08">8. Curryfikace (<i>currying</i>) a částečně vyhodnocené funkce</h2>

<p><i>&bdquo;Typically, developers learn new languages by applying what they
know about existing languages. But learning a new paradigm is difficult &ndash;
you must learn to see different solutions to familiar problems.&ldquo;</i></p>

<p>Ve druhé části dnešního článku si ukážeme, jakým způsobem se
v&nbsp;programovacím jazyku Python provádí takzvaná <i>curryfikace</i>
(anglicky <i>currying</i>). Pod tímto termínem se v&nbsp;teorii programovacích
jazyků (ovšem i obecně v&nbsp;matematice) označuje proces, jímž se transformuje
funkce, která má více než jeden parametr, do řady vložených funkcí, přičemž
každá z&nbsp;nich má jen jediný parametr (jen na okraj &ndash; čistou funkci
bez parametrů lze nahradit konstantou). Curryfikaci si můžeme představit jako
postupnou transformaci funkce s&nbsp;<i>n</i> parametry na jinak zkonstruovanou
funkci s&nbsp;<i>n-1</i> parametry atd. až rekurzivně dojdeme k&nbsp;funkci
s&nbsp;jediným parametrem:</p>

<pre>
x = f(a,b,c) &rarr;
    h = g(a)
    i = h(b)
    x = i(c)
</pre>

<p>Nebo na jediném řádku:</p>

<pre>
x = f(a,b,c) &rarr; g(a)(b)(c)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že funkce
<strong>g</strong> a <strong>h</strong> musí v&nbsp;tomto případě vracet jinou
funkci.</div></p>

<p>To zní sice velmi složitě, ale v&nbsp;praxi je (například v&nbsp;jazyku ML,
ale i dalších jazycích) proces curryfikace realizován z&nbsp;pohledu
programátora automaticky již samotným zápisem funkce s&nbsp;větším množstvím
parametrů. To nám umožňuje realizovat <i>částečné vyhodnocení funkce</i>
(<i>partial application)</i>, konkrétně zavoláním nějaké funkce (například
funkce akceptující dva parametry) ve skutečnosti pouze s&nbsp;jediným
parametrem. Jenže &ndash; co má být výsledkem volání takové funkce? Určitě ne
výsledek implementované operace, protože nám chybí jeden parametr pro to, aby
byl výsledek vypočten a vrácen volajícím kódu. Ovšem můžeme provést částečný
výpočet dosazením (jediného) předaného parametru a výsledek &ndash; tento
částečný výpočet &ndash; vrátit. Výsledkem je tedy obecně částečně aplikovaná
funkce (tedy například funkce, které byly v&nbsp;předchozím příkladu označeny
symboly <strong>g</strong> a <strong>h</strong>). Jedná se o jeden ze způsobů,
jak programově (za běhu aplikace) vytvářet nové funkce.</p>

<p><div class="rs-tip-major">Poznámka: curryfikace/currying se tedy ve
skutečnosti poněkud liší od tvorby částečně aplikovaných funkcí (i když se
mnohdy oba termíny zaměňují, nebo používají současně, což je ostatně i případ
předchozího odstavce).</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: název <i>currying</i> je
odvozen od jména známého matematika Haskella Curryho, po kterém je ostatně
pojmenován i další programovací jazyk Haskell (ten se s&nbsp;výše zmíněným
jazykem ML v&nbsp;mnoha ohledech podobá, právě i v&nbsp;kontextu curryingu a
s&nbsp;ním souvisejícím faktem, že funkce akceptují jeden parametr). Ve
skutečnosti však Haskell tento proces nevymyslel. Za původní myšlenkou tohoto
procesu stojí Moses Schönfinkel, takže se uvažovalo, že se tento proces bude
nazývat &bdquo;Schönfinkelisation&ldquo;.  To by bylo asi férovější, ovšem
uznejte sami, že se nejedná o tak snadno zapamatovatelný název, jakým je
currying.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Funkce <strong>partial</strong> z&nbsp;balíčku <strong>functools</strong></h2>

<p>V&nbsp;programovacím jazyku Python je částečné vyhodnocení funkce
realizováno funkcí nazvanou <strong>partial</strong>, kterou nalezneme
v&nbsp;balíčku <strong>functools</strong>. Funkce <strong>partial</strong> je
funkcí vyššího řádu, protože se jí předává původní funkce (například definovaná
uživatelem) a <i>některé</i> parametry této funkce. Výsledkem bude nová funkce,
ve které jsou již tyto parametry &bdquo;zapamatovány&ldquo; a tudíž se jí už
nemusí a vlastně ani nemohou předávat. To znamená, že z&nbsp;nějaké více
univerzální funkce touto transformací vytvoříme specializovanější funkci
s&nbsp;menším množstvím parametrů. Interně bude funkce <strong>partial</strong>
vypadat <i>přibližně</i> takto (ve skutečnosti je to ovšem nepatrně
složitější):</p>

<pre>
def <strong>partial</strong>(func, /, *args, **keywords):
&nbsp;
    def <strong>newfunc</strong>(*fargs, **fkeywords):
        newkeywords = {**keywords, **fkeywords}
        return func(*args, *fargs, **newkeywords)
&nbsp;
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Příklad základního použití funkce <strong>partial</strong></h2>

<p>Funkce <strong>partial</strong> sice může zpočátku vypadat poněkud
komplikovaně, ovšem práce s&nbsp;ní je relativně přímočará. Abychom pochopili
všechny vlastnosti <strong>partial</strong>, ukážeme si několik demonstračních
příkladů, které vlastnosti <strong>partial</strong> ukazují v&nbsp;různých
podobách.</p>

<p>V&nbsp;prvním demonstračním příkladu můžeme vidět definici funkce nazvané
<strong>mul</strong>, která akceptuje dva parametry. Tyto parametry jsou
vynásobeny a výsledek tohoto součinu je současně i návratovou hodnotou funkce
<strong>mul</strong>. S&nbsp;využitím <strong>partial</strong> se tato funkce
se dvěma parametry transformuje na novou funkci pojmenovanou
<strong>doubler</strong>, která ovšem již akceptuje pouze jediný parametr
<strong>y</strong>, neboť původní první parametr <strong>x</strong> byl
nahrazen za dvojku. Následně se již funkce <strong>doubler</strong> volá
s&nbsp;jediným parametrem:</p>

<pre>
from functools import partial
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
print(mul(6, 7))
&nbsp;
print()
&nbsp;
<strong>doubler</strong> = <u>partial(mul, 2)</u>
&nbsp;
&nbsp;
for i in range(11):
    print(i, doubler(i))
</pre>

<p>Tento příklad si samozřejmě můžeme velmi snadno otestovat:</p>

<pre>
42
&nbsp;
0 0
1 2
2 4
3 6
4 8
5 10
6 12
7 14
8 16
9 18
10 20
</pre>

<p>Z&nbsp;tohoto výpisu je patrné, že funkce <strong>doubler</strong> skutečně
pracuje podle předpokladů.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Transformace funkce se třemi parametry s&nbsp;využitím <strong>partial</strong></h2>

<p>Transformace funkcí s&nbsp;využitím <strong>partial</strong> ve skutečnosti
není omezeno pouze na funkce se dvěma parametry. Můžeme se pokusit například o
transformaci funkce se třemi parametry. V&nbsp;následujícím demonstračním
příkladu se pokoušíme o transformaci funkce <strong>mul</strong> se třemi
parametry <strong>x</strong>, <strong>y</strong> a <strong>z</strong> tak, že
za první parametr <strong>x</strong> se v&nbsp;nové funkci doplní hodnota
2:</p>

<pre>
from functools import partial
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y, z):
    return x * y * z
&nbsp;
&nbsp;
print(mul(2, 3, 7))
&nbsp;
print()
&nbsp;
<strong>doubler</strong> = <u>partial(mul, 2)</u>
&nbsp;
&nbsp;
for i in range(11):
    print(i, doubler(i))
</pre>

<p>Ve skutečnosti funkci <strong>double</strong> voláme špatně &ndash;
s&nbsp;jediným parametrem <strong>y</strong>, i když se očekávají dva parametry
<strong>y</strong> a <strong>z</strong>. Na tento problém nás pochopitelně
upozorní interpret programovacího jazyka Python:</p>

<pre>
42
&nbsp;
Traceback (most recent call last):
  File "partial_2.py", line 16, in &lt;module&gt;
    print(i, doubler(i))
TypeError: mul() missing 1 required positional argument: 'z'
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se v&nbsp;chybovém
hlášení opět &bdquo;magicky&ldquo; objevuje funkce
<strong>mul</strong>.</div></p>

<p>Korektní způsob použití by mohl vypadat například následovně &ndash; funkci
<strong>doubler</strong> nyní namísto jediného parametru předáváme dva
parametry, které jsou vynásobeny mezi sebou a navíc je výsledek zdvojnásoben
(resp.&nbsp;přesněji řečeno je pořadí operací odlišné, to nás však nyní nemusí
příliš trápit):</p>

<pre>
from functools import partial
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y, z):
    return x * y * z
&nbsp;
&nbsp;
print(mul(2, 3, 7))
&nbsp;
print()
&nbsp;
<strong>doubler</strong> = <u>partial(mul, 2)</u>
&nbsp;
&nbsp;
for i in range(11):
    print(i, doubler(i, 10))
</pre>

<p>Výsledky získané po spuštění tohoto příkladu:</p>

<pre>
42
&nbsp;
0 0
1 20
2 40
3 60
4 80
5 100
6 120
7 140
8 160
9 180
10 200
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Transformace funkce s&nbsp;dosazením většího množství parametrů s&nbsp;využitím <strong>partial</strong></h2>

<p>Prozatím jsme si ukázali, jakým způsobem je možné transformovat funkci se
dvěma či třemi (obecně tedy s&nbsp;<i>n</i>) parametry na jinou funkci
s&nbsp;jedním či dvěma (obecně s&nbsp;<i>n-1</i> parametry). Ve skutečnosti
však můžeme s&nbsp;využitím <strong>partial</strong> dosadit i větší množství
parametrů. Tato možnost je ukázána v&nbsp;následujícím demonstračním příkladu,
v&nbsp;němž vytváříme (resp.&nbsp;přesněji řečeno transformujeme) funkci
<strong>mul</strong> na funkci <strong>doubleDoubler</strong>, a to dosazením
dvou parametrů. Navíc je v&nbsp;tomto demonstračním příkladu ukázáno, že
původní funkce může akceptovat libovolný a předem neznámý počet parametrů (a
ještě k&nbsp;tomu jsme se vrátili k&nbsp;funkci vyššího řádu
<strong>reduce</strong>):</p>

<pre>
import operator
from functools import partial, reduce
&nbsp;
&nbsp;
def <strong>mul</strong>(*args):
    return reduce(operator.mul, args, 1)
&nbsp;
&nbsp;
print(mul(2, 3, 7))
&nbsp;
&nbsp;
print()
&nbsp;
&nbsp;
<strong>doubler</strong> = <u>partial(mul, 2)</u>
&nbsp;
&nbsp;
for i in range(11):
    print(i, doubler(i, 10))
&nbsp;
&nbsp;
print()
&nbsp;
&nbsp;
<strong>doubleDoubler</strong> = <u>partial(mul, 2, 2)</u>
&nbsp;
&nbsp;
for i in range(11):
    print(i, doubleDoubler(i, 10))
</pre>

<p>Výsledky získané po spuštění tohoto demonstračního příkladu ukazují
funkčnost celého řešení:</p>

<pre>
42
&nbsp;
0 0
1 20
2 40
3 60
4 80
5 100
6 120
7 140
8 160
9 180
10 200
&nbsp;
0 0
1 40
2 80
3 120
4 160
5 200
6 240
7 280
8 320
9 360
10 400
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Několikanásobná transformace původní funkce na několik nových funkcí</h2>

<p>Původní funkce není transformací s&nbsp;využitím <strong>partial</strong>
nijak dotčena; z&nbsp;tohoto pohledu je neměnitelná (<i>immutable</i>). To nám
umožňuje původní funkci <strong>mul</strong> (nyní upravenou do podoby
akceptující čtveřici parametrů) transformovat vícekrát, pokaždé s&nbsp;jiným
počtem doplněných parametrů:</p>

<pre>
from functools import partial
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y, z, w):
    return x * y * z * w
&nbsp;
&nbsp;
f1 = mul
print(f1)
&nbsp;
f2 = <u>partial(mul, 2)</u>
print(f2)
&nbsp;
f3 = <u>partial(mul, 2, 3)</u>
print(f3)
&nbsp;
f4 = <u>partial(mul, 2, 3, 4)</u>
print(f4)
&nbsp;
f5 = <u>partial(mul, 2, 3, 4, 5)</u>
print(f5)
&nbsp;
f6 = <u>partial(mul, 2, 3, 4, 5, 6)</u>
print(f6)
&nbsp;
print()
&nbsp;
print(f1(2, 3, 4, 5))
print(f2(3, 4, 5))
print(f3(4, 5))
print(f4(5))
print(f5())
print(f6())
</pre>

<p>Tento skript po svém spuštění nejdříve vypíše sedm hodnot typu
<i>funkce</i>, což bude fungovat podle očekávání:</p>

<pre>
&lt;function mul at 0x7fa22791fea0&gt;
functools.partial(&lt;function mul at 0x7fa22791fea0&gt;, 2)
functools.partial(&lt;function mul at 0x7fa22791fea0&gt;, 2, 3)
functools.partial(&lt;function mul at 0x7fa22791fea0&gt;, 2, 3, 4)
functools.partial(&lt;function mul at 0x7fa22791fea0&gt;, 2, 3, 4, 5)
functools.partial(&lt;function mul at 0x7fa22791fea0&gt;, 2, 3, 4, 5, 6)
</pre>

<p>Následně budeme jak původní funkci, tak i funkce získané transformacemi
volat. To se ovšem nepovede u funkce <strong>f6</strong>, neboť až v&nbsp;této
chvíli Python zjistí, že původní funkci <strong>mul</strong> předáváme pět
parametrů, i když se očekávají jen čtyři parametry:</p>

<pre>
120
120
120
120
120
Traceback (most recent call last):
  File "partial_5.py", line 33, in &lt;module&gt;
    print(f6())
TypeError: mul() takes 4 positional arguments but 5 were given
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
from functools import partial, reduce


def <strong>mul</strong>(x, y, z, w):
    return x * y * z * w


f1 = mul
print(f1)

f2 = <u>partial(f1, 2)</u>
print(f2)

f3 = <u>partial(f2, 3)</u>
print(f3)

f4 = <u>partial(f3, 4)</u>
print(f4)

f5 = <u>partial(f4, 5)</u>
print(f5)

f6 = <u>partial(f5, 6)</u>
print(f6)

print()

print(f1(2, 3, 4, 5))
print(f2(3, 4, 5))
print(f3(4, 5))
print(f4(5))
print(f5())
print(f6())
</pre>

<pre>
from functools import partial, reduce


def <strong>mul</strong>(x, y, z, w):
    return x * y * z * w


f1 = mul
reveal_type(f1)

f2 = partial(mul, 2)
reveal_type(f2)

f3 = partial(mul, 2, 3)
reveal_type(f3)

f4 = partial(mul, 2, 3, 4)
reveal_type(f4)

f5 = partial(mul, 2, 3, 4, 5)
reveal_type(f5)

f6 = partial(mul, 2, 3, 4, 5, 6)
reveal_type(f6)
</pre>

<pre>
from functools import partial, reduce


def <strong>mul</strong>(x, y, z, w):
    return x * y * z * w


def <strong>displayInfo</strong>(name, obj):
    print(name)
    print(obj.func)
    print(obj.args)
    print(obj.keywords)
    print()


f2 = partial(mul, 2)
displayInfo("f2", f2)

f3 = partial(mul, 2, 3)
displayInfo("f3", f3)

f4 = partial(mul, 2, 3, 4)
displayInfo("f4", f4)

f5 = partial(mul, 2, 3, 4, 5)
displayInfo("f5", f5)

f6 = partial(mul, 2, 3, 4, 5, 6)
displayInfo("f6", f6)
</pre>

<pre>
from functools import partial, reduce


def <strong>mul</strong>(x=1, y=1, z=1, w=1):
    return x * y * z * w


f1 = mul
print(f1())

f2 = partial(mul, x=2)
print(f2())

f3 = partial(mul, y=2)
print(f3())

f4 = partial(mul, y=2, z=2)
print(f4())

f5 = partial(mul, x=2, y=2, z=2)
print(f5())

f6 = partial(mul, x=2, y=2, z=2, w=2)
print(f6())
</pre>

<pre>
from functools import partial, reduce


def <strong>mul</strong>(x=1, y=1, z=1, w=1):
    return x * y * z * w


def <strong>displayInfo</strong>(name, obj):
    print(name)
    print(obj.func)
    print(obj.args)
    print(obj.keywords)
    print()


#f1 = mul
#displayInfo(f1())

f2 = partial(mul, x=2)
displayInfo("f2", f2)

f3 = partial(mul, y=2)
displayInfo("f3", f3)

f4 = partial(mul, y=2, z=2)
displayInfo("f4", f4)

f5 = partial(mul, x=2, y=2, z=2)
displayInfo("f5", f5)

f6 = partial(mul, x=2, y=2, z=2, w=2)
displayInfo("f6", f6)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny Pythonovské skripty, které jsme si ukázali <a
href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-pythonu-a-knihovna-functools/">minule</a>
i dnes, naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je nutné mít
nainstalovánu některou z&nbsp;podporovaných verzí Pythonu 3, žádné další
balíčky nejsou zapotřebí):</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>binary_operator.py</td><td>ukázka funkce vyššího řádu, která jako parametr akceptuje jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py</a></td></tr>
<tr><td> 2</td><td>get_operator_1.py</td><td>ukázka funkce vyššího řádu, která vrací jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py</a></td></tr>
<tr><td> 3</td><td>get_operator_2.py</td><td>ukázka funkce vyššího řádu, která vrací jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py</a></td></tr>
<tr><td> 4</td><td>standard_operators.py</td><td>použití standardních operátorů přepsaných do formy funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>binary_operator_types.py</td><td>varianta příkladu <strong>binary_operator.py</strong> s&nbsp;plnými typovými deklaracemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py</a></td></tr>
<tr><td> 6</td><td>get_operator_types.py</td><td>varianta příkladu <strong>get_operator_2.py</strong> s&nbsp;plnými typovými deklaracemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>map_1.py</td><td>příklad použití funkce <strong>map</strong>: výpočet délky všech slov v&nbsp;textu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py</a></td></tr>
<tr><td> 8</td><td>map_2.py</td><td>příklad použití funkce <strong>map</strong>: výpočet absolutní hodnoty všech členů posloupnosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py</a></td></tr>
<tr><td> 9</td><td>map_3.py</td><td>příklad použití funkce <strong>map</strong>: aplikace vlastní pojmenované funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_3.py</a></td></tr>
<tr><td>10</td><td>map_4.py</td><td>příklad použití funkce <strong>map</strong>: aplikace vlastního lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>map_list_comprehension_1.py</td><td>přepis skriptu <strong>map_1.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_1.py</a></td></tr>
<tr><td>12</td><td>map_list_comprehension_2.py</td><td>přepis skriptu <strong>map_2.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_2.py</a></td></tr>
<tr><td>13</td><td>map_list_comprehension_3.py</td><td>přepis skriptu <strong>map_3.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_3.py</a></td></tr>
<tr><td>14</td><td>map_list_comprehension_4.py</td><td>přepis skriptu <strong>map_4.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>filter_1.py</td><td>filtrace dat na základě délky řetězce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_1.py</a></td></tr>
<tr><td>16</td><td>filter_2.py</td><td>filtrace numerických dat podle toho, zda se jedná o sudá či lichá čísla</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_2.py</a></td></tr>
<tr><td>17</td><td>filter_3.py</td><td>přepis předchozího příkladu s&nbsp;využitím lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>filter_list_comprehension_1.py</td><td>přepis skriptu <strong>filter_list_comprehension_1.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_1.py</a></td></tr>
<tr><td>19</td><td>filter_list_comprehension_2.py</td><td>přepis skriptu <strong>filter_list_comprehension_2.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_2.py</a></td></tr>
<tr><td>20</td><td>filter_list_comprehension_3.py</td><td>přepis skriptu <strong>filter_list_comprehension_3.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>reduce_1.py</td><td>výpočet faktoriálu s&nbsp;využitím funkce vyššího řádu <strong>reduce</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_1.py</a></td></tr>
<tr><td>22</td><td>reduce_2.py</td><td>přepis předchozího příkladu s&nbsp;využitím lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_2.py</a></td></tr>
<tr><td>23</td><td>reduce_3.py</td><td>tisk tabulky faktoriálů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_3.py</a></td></tr>
<tr><td>24</td><td>reduce_4.py</td><td>přepis předchozího příkladu s&nbsp;využitím lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_4.py</a></td></tr>
<tr><td>25</td><td>reduce_5.py</td><td>přepis předchozího příkladu s&nbsp;využitím generátorové notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>return_function.py</td><td>funkce jako návratová hodnota jiné funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/return_function.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/return_function.py</a></td></tr>
<tr><td>27</td><td>closure_adder1.py</td><td>příklad použití uzávěru &ndash; konstrukce funkce typu <i>adder</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/closure_adder1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/closure_adder1.py</a></td></tr>
<tr><td>28</td><td>counter_closure_1.py</td><td>nekorektní implementace čítače s&nbsp;využitím uzávěrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_1.py</a></td></tr>
<tr><td>29</td><td>counter_closure_2.py</td><td>přístup k&nbsp;nelokálnímu symbolu (Python 2.x i Python 3.x)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_2.py</a></td></tr>
<tr><td>30</td><td>counter_closure_3.py</td><td>přístup k&nbsp;nelokálnímu symbolu (pouze Python 3.x)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/counter_closure_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>access_nonlocal_symbol.py</td><td>přístup k&nbsp;nelokálnímu symbolu v&nbsp;uzávěru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/access_nonlocal_symbol.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/access_nonlocal_symbol.py</a></td></tr>
<tr><td>32</td><td>functions_and_closures.py</td><td>funkce a uzávěry (umělý příklad)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/functions_and_closures.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/functions_and_closures.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>partial_1.py</td><td>funkce <strong>doubler</strong> odvozená (redukcí) z&nbsp;univerzálnější funkce <strong>mul</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_1.py</a></td></tr>
<tr><td>34</td><td>partial_2.py</td><td>transformace funkce se třemi parametry s&nbsp;využitím <strong>partial</strong> (nekorektní řešení)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_2.py</a></td></tr>
<tr><td>35</td><td>partial_3.py</td><td>transformace funkce se třemi parametry s&nbsp;využitím <strong>partial</strong> (korektní řešení)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_3.py</a></td></tr>
<tr><td>36</td><td>partial_4.py</td><td>transformace funkce s&nbsp;dosazením většího množství parametrů s&nbsp;využitím <strong>partial</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_4.py</a></td></tr>
<tr><td>37</td><td>partial_5.py</td><td>několikanásobná transformace původní funkce na několik nových funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_5.py</a></td></tr>
<tr><td>38</td><td>partial_6.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_6.py</a></td></tr>
<tr><td>39</td><td>partial_7.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_7.py</a></td></tr>
<tr><td>40</td><td>partial_8.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_8.py</a></td></tr>
<tr><td>41</td><td>partial_9.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_9.py</a></td></tr>
<tr><td>42</td><td>partial_A.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/partial_A.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>functools — Higher-order functions and operations on callable objects<br />
<a href="https://docs.python.org/3/library/functools.html">https://docs.python.org/3/library/functools.html</a>
</li>

<li>Functional Programming HOWTO<br />
<a href="https://docs.python.org/3/howto/functional.html">https://docs.python.org/3/howto/functional.html</a>
</li>

<li>Functional Programming in Python: When and How to Use It<br />
<a href="https://realpython.com/python-functional-programming/">https://realpython.com/python-functional-programming/</a>
</li>

<li>Functional Programming With Python<br />
<a href="https://realpython.com/learning-paths/functional-programming/">https://realpython.com/learning-paths/functional-programming/</a>
</li>

<li>Awesome Functional Python<br />
<a href="https://github.com/sfermigier/awesome-functional-python">https://github.com/sfermigier/awesome-functional-python</a>
</li>

<li>Currying<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying in Python &ndash; A Beginner’s Introduction<br />
<a href="https://www.askpython.com/python/examples/currying-in-python">https://www.askpython.com/python/examples/currying-in-python</a>
</li>

<li>Fundamental Concepts in Programming Languages<br />
<a href="https://en.wikipedia.org/wiki/Fundamental_Concepts_in_Programming_Languages">https://en.wikipedia.org/wiki/Fundamental_Concepts_in_Programming_Languages</a>
</li>

<li>When should I use function currying?<br />
<a href="https://stackoverflow.com/questions/24881604/when-should-i-use-function-currying">https://stackoverflow.com/questions/24881604/when-should-i-use-function-currying</a>
</li>

<li>Toolz<br />
<a href="https://github.com/pytoolz/toolz/tree/master">https://github.com/pytoolz/toolz/tree/master</a>
</li>

<li>Coconut: funkcionální jazyk s pattern matchingem kompatibilní s&nbsp;Pythonem<br />
<a href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/</a>
</li>

<li>A HITCHHIKER'S GUIDE TO functools<br />
<a href="https://ep2021.europython.eu/media/conference/slides/a-hitchhikers-guide-to-functools.pdf">https://ep2021.europython.eu/media/conference/slides/a-hitchhikers-guide-to-functools.pdf</a>
</li>

<li>Coconut aneb funkcionální nadstavba nad Pythonem (2.část)<br />
<a href="https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/">https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/</a>
</li>

<li>Knihovny pro zpracování posloupností (sekvencí) v&nbsp;Pythonu<br />
<a href="https://www.root.cz/clanky/knihovny-pro-zpracovani-posloupnosti-sekvenci-v-pythonu/">https://www.root.cz/clanky/knihovny-pro-zpracovani-posloupnosti-sekvenci-v-pythonu/</a>
</li>

<li>clj - repositář s knihovnou<br />
<a href="https://github.com/bfontaine/clj">https://github.com/bfontaine/clj</a>
</li>

<li>clj 0.1.0 &ndash; stránka na PyPi<br />
<a href="https://pypi.python.org/pypi/clj/0.1.0">https://pypi.python.org/pypi/clj/0.1.0</a>
</li>

<li>Coconut: Simple, elegant, Pythonic functional programming<br />
<a href="http://coconut-lang.org/">http://coconut-lang.org/</a>
</li>

<li>coconut (Python package index)<br />
<a href="https://pypi.python.org/pypi/coconut/">https://pypi.python.org/pypi/coconut/</a>
</li>

<li>Coconut Tutorial<br />
<a href="http://coconut.readthedocs.io/en/master/HELP.html">http://coconut.readthedocs.io/en/master/HELP.html</a>
</li>

<li>Coconut FAQ<br />
<a href="http://coconut.readthedocs.io/en/master/FAQ.html">http://coconut.readthedocs.io/en/master/FAQ.html</a>
</li>

<li>Coconut Documentation<br />
<a href="http://coconut.readthedocs.io/en/master/DOCS.html">http://coconut.readthedocs.io/en/master/DOCS.html</a>
</li>

<li>Coconut na Redditu<br />
<a href="https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/">https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/</a>
</li>

<li>Repositář na GitHubu<br />
<a href="https://github.com/evhub/coconut">https://github.com/evhub/coconut</a>
</li>

<li>Object-Oriented Programming — The Trillion Dollar Disaster<br />
<a href="https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7</a>
</li>

<li>Goodbye, Object Oriented Programming<br />
<a href="https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53">https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53</a>
</li>

<li>So You Want to be a Functional Programmer (Part 1)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536</a>
</li>

<li>So You Want to be a Functional Programmer (Part 2)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 3)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7</a>
</li>

<li>So You Want to be a Functional Programmer (Part 4)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49</a>
</li>

<li>So You Want to be a Functional Programmer (Part 5)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 6)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403</a>
</li>

<li>Why Programmers Need Limits<br />
<a href="https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db">https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db</a>
</li>

<li>Infographic showing code complexity vs developer experience<br />
<a href="https://twitter.com/rossipedia/status/1580639227313676288">https://twitter.com/rossipedia/status/1580639227313676288</a>
</li>

<li>Python's reduce(): From Functional to Pythonic Style<br />
<a href="https://realpython.com/python-reduce-function/">https://realpython.com/python-reduce-function/</a>
</li>

<li>What is the problem with reduce()?<br />
<a href="https://stackoverflow.com/questions/181543/what-is-the-problem-with-reduce">https://stackoverflow.com/questions/181543/what-is-the-problem-with-reduce</a>
</li>

<li>The fate of reduce() in Python 3000<br />
<a href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196">https://www.artima.com/weblogs/viewpost.jsp?thread=98196</a>
</li>

<li>Reading 16: Map, Filter, Reduce<br />
<a href="http://web.mit.edu/6.031/www/sp22/classes/16-map-filter-reduce/">http://web.mit.edu/6.031/www/sp22/classes/16-map-filter-reduce/</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Používání funkcí v&nbsp;F#<br />
<a href="https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions">https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions</a>
</li>

<li>Funkce vyššího řádu<br />
<a href="http://naucte-se.haskell.cz/funkce-vyssiho-radu">http://naucte-se.haskell.cz/funkce-vyssiho-radu</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

<li>ML &ndash; funkcionální jazyk s revolučním typovým systémem<br />
<a href="https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/">https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/</a>
</li>

<li>Funkce a typový systém programovacího jazyka ML<br />
<a href="https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/">https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/</a>
</li>

<li>Curryfikace (currying), výjimky a vlastní operátory v jazyku ML<br />
<a href="https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/">https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

