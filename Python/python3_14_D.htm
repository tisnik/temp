<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Nové vlastnosti Pythonu 3.14 v praxi: rychlost a paměťové nároky aplikací využívajících více souběžných úloh</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Nové vlastnosti Pythonu 3.14 v praxi: rychlost a paměťové nároky aplikací využívajících více více souběžných úloh</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V předchozím článku jsme si ukázali realizaci souběžných (a někdy i paralelních) úloh v Pythonu 3.14: multiprocesing, multithreading, asynchronní volání a samostatné interpretry. Dnes tato řešení porovnáme z pohledu rychlosti a spotřeby paměti. Výsledky budou překvapující.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: rychlost a paměťové nároky aplikací využívajících více souběžných úloh</a></p>
<p><a href="#k02">2. Základní podoba benchmarků</a></p>
<p><a href="#k03">3. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více vláknech</a></p>
<p><a href="#k04">4. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více procesech</a></p>
<p><a href="#k05">5. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více interpretrech</a></p>
<p><a href="#k06">6. Benchmark zjišťující vlastnosti výpočtů realizovaných asynchronními úlohami</a></p>
<p><a href="#k07">7. Výsledky benchmarků</a></p>
<p><a href="#k08">8. Doba vykonání 100 krátkodobých úloh při nastavení úrovně souběžnosti na 100</a></p>
<p><a href="#k09">9. Doba vykonání 100 déletrvajících úloh při nastavení úrovně souběžnosti na 10</a></p>
<p><a href="#k10">10. Doba vykonání 1000 krátkodobých úloh při nastavení úrovně souběžnosti na 100</a></p>
<p><a href="#k11">11. Doba vykonání 1000 déletrvajících úloh při nastavení úrovně souběžnosti na 100</a></p>
<p><a href="#k12">12. Paměťové nároky všech čtyř variant benchmarků</a></p>
<p><a href="#k13">13. Změřené výsledky: paměťové nároky benchmarků</a></p>
<p><a href="#k14">14. Benchmarky provádějící náročnější výpočty bez I/O operací</a></p>
<p><a href="#k15">15. Zdrojové kódy všech čtyř upravených benchmarků</a></p>
<p><a href="#k16">16. Změřené výsledky</a></p>
<p><a href="#k17">17. Shrnutí</a></p>
<p><a href="#k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: rychlost a paměťové nároky aplikací využívajících více více souběžných úloh</h2>

<p><a
href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-komunikace-mezi-interpretry/">V&nbsp;předchozím
článku</a> o Pythonu 3.14 (tedy o nejnovější v&nbsp;současnosti oficiálně
dostupné verzi CPythonu) jsme se zaměřili na popis realizace souběžných a
v&nbsp;některých případech i paralelních úloh. Připomeňme si ve stručnosti, že
pro realizaci takových úloh je možné využít čtyři rozdílné technologie:</p>

<ol>

<li>Spuštění úloh asynchronně, což například umožní, aby se (z&nbsp;pohledu
času) překrývaly například vstupně-výstupní operace atd. Pro tento účel slouží
v&nbsp;Pythonu klíčová slova <strong>async</strong> a <strong>await</strong>,
které byly přidány již do Pythonu 3.5 (a <strong>asyncio.run</strong>
v&nbsp;Pythonu 3.7).</li>

<li>Spuštění úloh v&nbsp;samostatných vláknech. Konkrétní chování a způsob
provedení souběžných výpočtů závisí do značné míry na tom, zda je Python 3.14
přeložen s&nbsp;vestavěným GILem či nikoli. Pokud je GIL použit (standardní
interpret), budou úlohy GILem synchronizovány při provádění mnoha operací.</li>

<li>Spuštění úloh v&nbsp;samostatných procesech. Zde se již jedná o řešení,
které není omezeno GILem, protože procesy řídí samotné jádro operačního
systému, ovšem pravděpodobně za možnost paralelizace zaplatíme větší spotřebou
paměti a pomalejším spouštěním úloh.</li>

<li>A konečně spuštění úloh v&nbsp;samostatných interpretrech, přičemž každý
interpret poběží v&nbsp;samostatném vláknu. Teoreticky by se mělo toto řešení
nacházet na pomezí mezi výše zmíněným multithreadingem a multiprocesingem. Toto
řešení je dostupné až od Pythonu 3.14.</li>

</ol>

<p>V&nbsp;dnešním článku se tato řešení pokusíme porovnat z&nbsp;pohledu
celkové rychlosti, rychlosti inicializace a spuštění úloh i z&nbsp;hlediska
celkové spotřeby operační paměti.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní podoba benchmarků</h2>

<p>Pro porovnání všech čtyř výše zmíněných technologií určených pro spouštění
většího množství souběžných či paralelně běžících úloh nejprve použijeme čtyři
základní benchmarky, které budou simulovat skutečné výpočty zavoláním funkce
<strong>time.sleep</strong> popř.&nbsp;její asynchronní varianty. Ve všech
benchmarcích budou parametry spouštěných úloh předávány s&nbsp;využitím sdílené
fronty (<i>queue</i>) a fronta bude použita i pro ukončení činnosti
jednotlivých <i>workerů</i>. Pokaždé je sice fronta realizována jinou
technologií, ovšem z&nbsp;pohledu programátora je její chování podobné.</p>

<p>Všechny čtyři benchmarky jsem se snažil vytvořit takovým způsobem, aby se i
přes odlišnou technologii spouštění úloh jejich zápis do značné míry podobal.
Řízení benchmarků se provádí změnou čtyř globálních proměnných:</p>

<pre>
<i># počet souběžně spuštěných vláken, procesů, asychronních úloh nebo interpretrů</i>
CONCURRENCY_LEVEL = 100
&nbsp;
<i># celkový počet úloh, které je nutné vypočítat</i>
TASKS = 1000
&nbsp;
<i># má se na konci benchmarku čekat na stisk klávesy? (například pro zjištění obsazené paměti)</i>
WAIT_FOR_KEY = False
&nbsp;
<i># simulace reálné práce &ndash; na tuto dobu bude pozastaveno vlákno,</i>
<i># proces, asynchronní úloha nebo interpret</i>
SLEEP_AMOUNT = 1
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více vláknech</h2>

<p>První implementace benchmarku je založena na vykonání úloh ve větším
množství vláken &ndash; jedná se tedy o klasický <i>multithreading</i>. Vlákna
jsou nejdříve vytvořena a poté je v&nbsp;rámci každého z&nbsp;nich spuštěna
funkce <strong>worker</strong>. Parametry úloh jsou předávány přes frontu a
předáním příkazu/parametru &bdquo;quit&ldquo; je <i>worker</i> ukončen:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových vláknech</i>
<i># - komunikace mezi vlákny s využitím fronty</i>
&nbsp;
CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1
&nbsp;
&nbsp;
from queue import Queue
from threading import Thread
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných vláknech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            return
        if SLEEP_AMOUNT &gt; 0:
            time.sleep(SLEEP_AMOUNT)
&nbsp;
&nbsp;
if __name__ == "__main__":
    t1 = time.time()
&nbsp;
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi vlákny</i>
    q = Queue()
&nbsp;
    ts = []
    <i># vytvoření procesů</i>
    for i in range(CONCURRENCY_LEVEL):
        name = f"Thread #{i}"
        ts.append(Thread(target=worker, daemon=True, name=name, args=[name, q]))
&nbsp;
    <i># spuštění vláken</i>
    for t in ts:
        t.start()
&nbsp;
    print("Sending data to other threads")
&nbsp;
    <i># komunikace s vlákny přes frontu</i>
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    if WAIT_FOR_KEY:
        input()
&nbsp;
    print("Asking other threads to finish")
&nbsp;
    <i># příkaz pro ukončení vláken</i>
    for i in range(CONCURRENCY_LEVEL):
        q.put("quit")
&nbsp;
    print("Waiting for other threads")
&nbsp;
    <i># čekání na zpracování všech zpráv ve frontě</i>
    for t in ts:
        t.join()
&nbsp;
    print("All work done!")
&nbsp;
    t2 = time.time()
&nbsp;
    print(f"Elapsed time: {t2-t1}")
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více procesech</h2>

<p>Druhá varianta benchmarku používá namísto většího množství vláken pro
spuštění <i>workerů</i> samostatné procesy. V&nbsp;takovém případě je přepínání
mezi procesy prováděno operačním systémem a procesy by měly běžet do značné
míry nezávisle na sobě (ovšem pochopitelně se provádí synchronizace při
komunikaci pomocí fronty). Takto upravený benchmark vypadá následovně:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových procesech</i>
<i># - komunikace mezi procesy s využitím fronty</i>
&nbsp;
CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1
&nbsp;
&nbsp;
import time
from multiprocessing import Process, Queue, freeze_support
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných procesech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Process '{name}' is about to quit")
            return
        if SLEEP_AMOUNT &gt; 0:
            time.sleep(SLEEP_AMOUNT)
&nbsp;
&nbsp;
if __name__ == "__main__":
    t1 = time.time()
&nbsp;
    print("Starting")
    freeze_support()
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi procesy</i>
    q = Queue()
&nbsp;
    ps = []
    <i># vytvoření procesů</i>
    for i in range(CONCURRENCY_LEVEL):
        name = f"Process #{i}"
        ps.append(Process(target=worker, args=(name, q)))
&nbsp;
    <i># spuštění procesů</i>
    for p in ps:
        p.start()
&nbsp;
    print("Sending data to other processes")
&nbsp;
    <i># komunikace s procesy přes frontu</i>
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    if WAIT_FOR_KEY:
        input()
&nbsp;
    print("Asking other processes to finish")
&nbsp;
    <i># příkaz pro ukončení procesů</i>
    for i in range(CONCURRENCY_LEVEL):
        q.put("quit")
&nbsp;
    print("Waiting for other processes")
&nbsp;
    <i># čekání na ukončení procesů</i>
    for p in ps:
        p.join()
&nbsp;
    print("All work done!")
&nbsp;
    t2 = time.time()
&nbsp;
    print(f"Elapsed time: {t2-t1}")
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více interpretrech</h2>

<p>Třetí varianta benchmarku bude funkční pouze v&nbsp;Pythonu 3.14. Úlohy jsou
spouštěny v&nbsp;rámci samostatných interpretů, přičemž každý interpret běží
v&nbsp;samostatném vlákně. A pro komunikaci mezi <i>workery</i> se pochopitelně
opět používá fronta (která ovšem interně vypadá odlišně, než fronty
z&nbsp;předchozích dvou benchmarků):</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových interpretrech</i>
<i># - komunikace mezi interpretry s využitím fronty</i>
&nbsp;
CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1
&nbsp;
&nbsp;
import time
from concurrent import interpreters
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných interpretrech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Interpreter '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Interpreter '{name}' is about to quit")
            return
        if SLEEP_AMOUNT &gt; 0:
            time.sleep(SLEEP_AMOUNT)
&nbsp;
&nbsp;
if __name__ == "__main__":
    t1 = time.time()
&nbsp;
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi interpretry</i>
    q = interpreters.create_queue()
&nbsp;
    ins = []
    <i># vytvoření interpretrů</i>
    for i in range(CONCURRENCY_LEVEL):
        name = f"Interpreter #{i}"
        ins.append(interpreters.create().call_in_thread(worker, name, q))
&nbsp;
    print("Sending data to other interpreters")
&nbsp;
    <i># komunikace s interpretry přes frontu</i>
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    print("Asking other interpreters to finish")
&nbsp;
    <i># příkaz pro ukončení procesů</i>
    for i in range(CONCURRENCY_LEVEL):
        q.put("quit")
&nbsp;
    if WAIT_FOR_KEY:
        input()
&nbsp;
    print("Waiting for other interpreters")
&nbsp;
    <i># čekání na ukončení interpretrů</i>
    for i in ins:
        i.join()
&nbsp;
    print("All work done!")
&nbsp;
    t2 = time.time()
&nbsp;
    print(f"Elapsed time: {t2-t1}")
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Benchmark zjišťující vlastnosti výpočtů realizovaných asynchronními úlohami</h2>

<p>Poslední benchmark je naprogramován odlišným způsobem, protože v&nbsp;něm
využíváme <i>workery</i> spouštěné v&nbsp;asynchronním kódu. Je zde tedy nutné
používat klíčová slova <strong>async</strong> a <strong>await</strong> a i
hlavní program je realizován asynchronní funkcí. I &bdquo;čekání&ldquo; na
dokončení úlohy je realizováno asynchronní operací <strong>sleep</strong> (to
ovšem není férové, proto si ještě ukážeme nepatrně komplikovanější
benchmarky):</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh asynchronně</i>
<i># - komunikace mezi procesy s využitím fronty</i>
&nbsp;
CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1
&nbsp;
from asyncio import Queue, sleep, run, gather, create_task
import time
&nbsp;
&nbsp;
async def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát asynchronně."""</i>
    while not q.empty():
        <i># čtení příkazů z fronty</i>
        cmd = await q.get()
        print(f"Task '{name}' received command '{cmd}'")
        await sleep(SLEEP_AMOUNT)
&nbsp;
&nbsp;
async def <strong>main</strong>():
    t1 = time.time()
&nbsp;
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi úlohami</i>
    queue = Queue()
&nbsp;
    print("Sending data to async tasks")
&nbsp;
    <i># komunikace s úlohami přes frontu</i>
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        await queue.put("command {}".format(i))
&nbsp;
    print("Waiting for all tasks")
&nbsp;
    aws = [create_task(worker(f"Task #{i}", queue)) for i in range(CONCURRENCY_LEVEL)]
    await gather(*aws)
&nbsp;
    if WAIT_FOR_KEY:
        input()
&nbsp;
    print("All work done!")
&nbsp;
    t2 = time.time()
&nbsp;
    print(f"Elapsed time: {t2-t1}")
&nbsp;
run(main())
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledky benchmarků</h2>

<p>Podívejme se nyní na výsledky benchmarků pro různé nastavení celkového počtu
úloh, které se mají vykonat, počtu souběžně pracujících workerů a navíc i
minimální doby trvání úloh. Tím si ověříme způsob chování Pythonu
v&nbsp;případě, že workery běží v&nbsp;samostatných procesech, ve vláknech,
v&nbsp;samostatných interpretrech či jako asynchronní úlohy. Posléze benchmarky
upravíme do takové podoby, aby se namísto pouhého čekání (operace
<strong>sleep</strong>) vykonával skutečný výpočet.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Doba vykonání 100 krátkodobých úloh při nastavení úrovně souběžnosti na 100</h2>

<p>Nejprve všechny benchmarky nastavíme tak, aby se vykonalo pouze 100 úloh,
které navíc trvají co nejkratší dobu. Úroveň souběžnosti/paralelnosti je
nastavena taktéž na hodnotu 100, což znamená, že podle benchmarku je:</p>

<ol>
<li>každá úloha vykonána ve svém vlastním vláknu</li>
<li>každá úloha vykonána ve svém vlastním procesu</li>
<li>každá úloha vykonána ve své vlastní asynchronní funkci</li>
<li>každá úloha vykonána ve svém vlastním interpretu</li>
</ol>

<p>Tyto benchmarky tedy měří primárně rychlost vytvoření <i>workerů</i>.</p>

<p>Nastavení všech benchmarků:</p>

<pre>
CONCURRENCY_LEVEL = 100
TASKS = 100
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 0
</pre>

<p>Výsledky:</p>

<table>
<tr><th>Typ souběžnosti</th><th>Celkový čas vykonání</th></tr>
<tr><td>Async</td><td>0,0115</td></tr>
<tr><td>Interpreters</td><td>3,9117</td></tr>
<tr><td>Processes</td><td>0,1410</td></tr>
<tr><td>Threads</td><td>0,0620</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: to, že asynchronní úlohy byly vykonány
nejdříve, není překvapující, protože tato technologie je zcela nenáročná a
umožňuje v&nbsp;praxi realizovat i statisíce úloh běžících souběžně.
Překvapující ani není to, že multithreading je rychlejší než multiprocesing
&ndash; vytvoření nového threadu je totiž po technologické stránce jednodušší
úloha.  Ovšem konstrukce a spuštění 100 interpretrů trvalo skoro 4 sekundy, což
tento způsob činí zcela nejpomalejší (a je to dosti překvapivé zejména
v&nbsp;porovnání s&nbsp;multiprocesingem).</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Doba vykonání 100 déletrvajících úloh při nastavení úrovně souběžnosti na 10</h2>

<p>V&nbsp;dalším kroku konfiguraci benchmarků změníme. Bude se sice opět
provádět celkem sto úloh, ovšem úroveň souběžnosti se zmenší na 10
vláken/procesů/interpetů/asychronních funkcí a každá úloha bude trvat přibližně
jednu sekundu. Takto nastavené benchmarky tedy měří spíše to, do jaké míry běží
úlohy paralelně. Teoretická ideální doba běhu bude rovna 100/10=10 sekund.</p>

<p>Nastavení všech benchmarků:</p>

<pre>
CONCURRENCY_LEVEL = 10
TASKS = 100
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1
</pre>

<p>Výsledky:</p>

<table>
<tr><th>Typ souběžnosti</th><th>Celkový čas vykonání</th></tr>
<tr><td>Async</td><td>10,0192</td></tr>
<tr><td>Interpreters</td><td>10,3868</td></tr>
<tr><td>Processes</td><td>10,1612</td></tr>
<tr><td>Threads</td><td>10,01469</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: celkové doby běhu jsou prakticky
totožné, což znamená, že Python 3.14 bez GILu dokáže spouštět kód ve vláknech
velmi efektivně &ndash; minimálně tehdy, pokud vlákna pouze čekají na dokončení
<strong>time.sleep()</strong>. Stále však vidíme, že spuštění deseti
interpretrů trvalo přibližně 0,38 sekundy (což do značné míry odpovídá
předchozímu benchmarku, který spouštěl desetkrát tolik interpretrů).</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Doba vykonání 1000 krátkodobých úloh při nastavení úrovně souběžnosti na 100</h2>

<p>Nyní se pokusíme počet úloh zvýšit na jeden tisíc, ovšem úroveň souběžnosti
(počet vláken/procesů/interpretrů/asynchronních úloh) bude omezena na 100.
Jednotlivé úlohy budou prováděny velmi rychle &ndash; prakticky bez čekání.
Pouze u benchmarku s&nbsp;asynchronními úlohami se čeká na dokončení operace
<strong>sleep(0)</strong>, což umožní přepnutí úloh:</p>

<table>
<tr><th>Typ souběžnosti</th><th>Celkový čas vykonání</th></tr>
<tr><td>Async</td><td>0,0122</td></tr>
<tr><td>Interpreters</td><td>3,8573</td></tr>
<tr><td>Processes</td><td>0,5456</td></tr>
<tr><td>Threads</td><td>0,1016</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: opět zde můžeme vidět především dlouhý
čas nutný pro spuštění 100 interpretrů. Ostatní výsledky jsou dle očekávání
seřazeny (vzestupně) takto: asynchronní úlohy, vlákna a nakonec
procesy.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Doba vykonání 1000 déletrvajících úloh při nastavení úrovně souběžnosti na 100</h2>

<p>Poslední variantou konfigurace benchmarků bude jejich nastavení takovým
způsobem, aby se provedlo tisíc úloh s&nbsp;nastavením úrovně souběžnosti na
100. To znamená, že by každý worker (bude jich připraveno celkem 100) měl
provést deset úloh. Každá úloha poběží minimálně jednu sekundu, čímž se
simuluje reálná práce (tedy s&nbsp;výjimkou asynchronních úloh, kde čekání vede
k&nbsp;přepnutí úlohy):</p>

<p>Výsledky benchmarků:</p>

<table>
<tr><th>Typ souběžnosti</th><th>Celkový čas vykonání</th></tr>
<tr><td>Async</td><td>10,03398</td></tr>
<tr><td>Interpreters</td><td>13,7186</td></tr>
<tr><td>Processes</td><td>10,5159</td></tr>
<tr><td>Threads</td><td>10,0677</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: stále je patrné, že kromě pomalejší
konstrukce a spuštění interpretrů jsou všechny benchmarky vykonány prakticky ve
stejném čase: přibližně deset sekund pro vykonání deseti úloh v&nbsp;každém
workerovi, kteří běží souběžně (a v&nbsp;kontextu tohoto benchmarku i
paralelně).</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Paměťové nároky všech čtyř variant benchmarků</h2>

<p>Prozatím jsme změřili, jak dlouho trvá vykonání určitého počtu úloh při
použití různých technologií. Zajímavé (a popravdě řečeno i dost neočekávané)
je, že spouštění úloh v&nbsp;samostatných interpretrech, což je nová
technologie Pythonu 3.14, prozatím vychází nejhůře. Je to způsobeno tím, že
nejvíce času se stráví inicializací interpretrů &ndash; je zde tedy prostor (a
to dosti velký) pro další vylepšování v&nbsp;dalších verzích Pythonu.</p>

<p>Ovšem ještě budeme muset změřit paměťové nároky jednotlivých variant
benchmarků, protože v&nbsp;praxi se může jednat taktéž o limitující faktor. Dá
se předpokládat, že největší paměťové nároky bude mít řešení s&nbsp;větším
množstvím procesů, ovšem zajímavé bude zjištění, jaké paměťové nároky má
technologie více interpretrů.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Změřené výsledky: paměťové nároky benchmarků</h2>

<p>Otázkou je, jakým způsobem se mají paměťové nároky měřit. Můžeme například
zjistit alokovanou oblast virtuální paměti nebo RSS (což je hodnota, která je
asi nejbližší skutečně využívané paměti). Spotřeba paměti bude vyšší u
benchmarků s&nbsp;multiprocesingem, protože každý proces znamená nastartování
nového interpretru Pythonu. Úlohy spouštěné ve vláknech běží v&nbsp;rámci
jednoho procesu a totéž platí i pro úlohy spouštěné ve vlastních interpretrech
&ndash; každý interpret běží ve vláknu v&nbsp;rámci jediného procesu.</p>

<p>Výsledky pro benchmark s&nbsp;asynchronními úlohami. Bylo naalokováno 1259MB
virtuální paměti, ovšem RSS je jen 23,6 MB. Běží, podle očekávání, jen jediný
proces Pythonu:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 720px"><a href="https://www.root.cz/obrazek/1239762/"><img src="https://i.iinfo.cz/images/487/python-3-14-c-1-large.png" class="image-1239762" width="720" height="71" data-prev-filename="https://i.iinfo.cz/images/487/python-3-14-c-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/487/python-3-14-c-1-prev.webp" data-prev-width="370" data-prev-height="36" data-large-filename="https://i.iinfo.cz/images/487/python-3-14-c-1-large.png" data-large-filename-webp="https://i.iinfo.cz/images/487/python-3-14-c-1-large.webp" data-large-width="720" data-large-height="71" alt="Sledování běžícího benchmarku" data-description="Sledování běžícího benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 720px" /></a><p>Sledování běžícího benchmarku<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>Výsledky pro benchmark s&nbsp;úlohami běžícími v&nbsp;samostatných vláknech.
RSS (jediného procesu) je kupodivu pouze 14,2 MB. Na screenshotu jsou zeleně
zobrazena vlákna, nikoli procesy:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 720px"><a href="https://www.root.cz/obrazek/1239765/"><img src="https://i.iinfo.cz/images/487/python-3-14-c-2-large.png" class="image-1239765" width="720" height="121" data-prev-filename="https://i.iinfo.cz/images/487/python-3-14-c-2-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/487/python-3-14-c-2-prev.webp" data-prev-width="370" data-prev-height="62" data-large-filename="https://i.iinfo.cz/images/487/python-3-14-c-2-large.png" data-large-filename-webp="https://i.iinfo.cz/images/487/python-3-14-c-2-large.webp" data-large-width="720" data-large-height="121" alt="Sledování běžícího benchmarku" data-description="Sledování běžícího benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 720px" /></a><p>Sledování běžícího benchmarku<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>Výsledky pro benchmark s&nbsp;úlohami běžícími v&nbsp;samostatných
procesech. Nyní již vidíme mnoho nových procesů s&nbsp;vlastní alokovanou
pamětí (17MB pro každý takový proces) a navíc ještě dva další procesy, které
vše koordinují. Spotřeba paměti je v&nbsp;tomto případě mnohem vyšší, než u
dalších benchmarků:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 720px"><a href="https://www.root.cz/obrazek/1239768/"><img src="https://i.iinfo.cz/images/487/python-3-14-c-3-large.png" class="image-1239768" width="720" height="143" data-prev-filename="https://i.iinfo.cz/images/487/python-3-14-c-3-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/487/python-3-14-c-3-prev.webp" data-prev-width="370" data-prev-height="73" data-large-filename="https://i.iinfo.cz/images/487/python-3-14-c-3-large.png" data-large-filename-webp="https://i.iinfo.cz/images/487/python-3-14-c-3-large.webp" data-large-width="720" data-large-height="143" alt="Sledování běžícího benchmarku" data-description="Sledování běžícího benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 720px" /></a><p>Sledování běžícího benchmarku<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>A konečně výsledky benchmarku pro deset interpretrů běžících
v&nbsp;samostatných vláknech. Nyní sice běží jen jeden proces, ovšem jeho
paměťové nároky jsou 79MB, což je více, než u běžného multithreadingu (zeleně
jsou opět zobrazena jednotlivá vlákna):</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 720px"><a href="https://www.root.cz/obrazek/1239771/"><img src="https://i.iinfo.cz/images/487/python-3-14-c-4-large.png" class="image-1239771" width="720" height="171" data-prev-filename="https://i.iinfo.cz/images/487/python-3-14-c-4-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/487/python-3-14-c-4-prev.webp" data-prev-width="370" data-prev-height="88" data-large-filename="https://i.iinfo.cz/images/487/python-3-14-c-4-large.png" data-large-filename-webp="https://i.iinfo.cz/images/487/python-3-14-c-4-large.webp" data-large-width="720" data-large-height="171" alt="Sledování běžícího benchmarku" data-description="Sledování běžícího benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 720px" /></a><p>Sledování běžícího benchmarku<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<table>
<tr><th>Typ souběžnosti</th><th>Celková RSS</th></tr>
<tr><td>Async</td><td>23,6 MB</td></tr>
<tr><td>Interpreters</td><td>79,0 MB</td></tr>
<tr><td>Processes</td><td>204 MB (přibližný výpočet)</td></tr>
<tr><td>Threads</td><td>14,2 MB</td></tr>
</table>

<p>V&nbsp;tomto ohledu tedy může být použití více interpretrů výhodnější, než
klasický multiprocesing.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Benchmarky provádějící náročnější výpočty bez I/O operací</h2>

<p>Nyní naše čtyři benchmarky nepatrně upravíme, a to takovým způsobem, aby se
v&nbsp;nich prováděly nějaké intenzivnější výpočty. Přitom zajistíme, aby se
NEpoužívaly vstupně-výstupní operace ani operace <strong>sleep</strong>, která
sice z&nbsp;pohledu jediné úlohy skutečně simuluje práci, ovšem například
v&nbsp;případě asynchronních úloh umožní přepínání bez vykonání skutečné
činnosti. Výpočtem, které budou benchmarky provádět, je realizace algoritmu pro
bublinkové řazení. Tento algoritmus je implementačně jednoduchý, s&nbsp;velkou
pravděpodobností nevyužívá SIMD operace (takže procesor nebude zpomalován
&ndash; viz Intel :-) a skutečně vytíží procesorové jádro nebo jádra:</p>

<pre>
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Zdrojové kódy všech čtyř upravených benchmarků</h2>

<h3>Bubble sort: asynchronní verze</h3>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh asynchronně</i>
<i># - komunikace mezi procesy s využitím fronty</i>
&nbsp;
CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
&nbsp;
&nbsp;
import random
from asyncio import Queue, sleep, run, gather, create_task
import time
&nbsp;
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
&nbsp;
async def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát asynchronně."""</i>
    while not q.empty():
        <i># čtení příkazů z fronty</i>
        cmd = await q.get()
        print(f"Task '{name}' received command '{cmd}'")
        bubble_sort(1000)
&nbsp;
&nbsp;
async def <strong>main</strong>():
    t1 = time.time()
&nbsp;
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi úlohami</i>
    queue = Queue()
&nbsp;
    print("Sending data to async tasks")
&nbsp;
    <i># komunikace s úlohami přes frontu</i>
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        await queue.put("command {}".format(i))
&nbsp;
    print("Waiting for all tasks")
&nbsp;
    aws = [create_task(worker(f"Task #{i}", queue)) for i in range(CONCURRENCY_LEVEL)]
    await gather(*aws)
&nbsp;
    print("All work done!")
&nbsp;
    t2 = time.time()
&nbsp;
    print(f"Elapsed time: {t2-t1}")
&nbsp;
run(main())
</pre>

<h3>Bubble sort: verze s&nbsp;více interpretry běžícími v&nbsp;samostatných vláknech</h3>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových interpretrech</i>
<i># - komunikace mezi interpretry s využitím fronty</i>
&nbsp;
CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
&nbsp;
&nbsp;
import random
import time
from concurrent import interpreters
&nbsp;
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných interpretrech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Interpreter '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Interpreter '{name}' is about to quit")
            return
        bubble_sort(1000)
&nbsp;
&nbsp;
if __name__ == "__main__":
    t1 = time.time()
&nbsp;
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi interpretry</i>
    q = interpreters.create_queue()
&nbsp;
    ins = []
    <i># vytvoření interpretrů</i>
    for i in range(CONCURRENCY_LEVEL):
        name = f"Interpreter #{i}"
        ins.append(interpreters.create().call_in_thread(worker, name, q))
&nbsp;
    print("Sending data to other interpreters")
&nbsp;
    <i># komunikace s interpretry přes frontu</i>
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    print("Asking other interpreters to finish")
&nbsp;
    <i># příkaz pro ukončení procesů</i>
    for i in range(CONCURRENCY_LEVEL):
        q.put("quit")
&nbsp;
    print("Waiting for other interpreters")
&nbsp;
    <i># čekání na ukončení interpretrů</i>
    for i in ins:
        i.join()
&nbsp;
    print("All work done!")
&nbsp;
    t2 = time.time()
&nbsp;
    print(f"Elapsed time: {t2-t1}")
</pre>

<h3>Bubble sort: verze běžící ve více procesech</h3>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových procesech</i>
<i># - komunikace mezi procesy s využitím fronty</i>
&nbsp;
CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1
&nbsp;
&nbsp;
import random
import time
from multiprocessing import Process, Queue, freeze_support
&nbsp;
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných procesech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Process '{name}' is about to quit")
            return
        bubble_sort(1000)
&nbsp;
&nbsp;
if __name__ == "__main__":
    t1 = time.time()
&nbsp;
    print("Starting")
    freeze_support()
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi procesy</i>
    q = Queue()
&nbsp;
    ps = []
    <i># vytvoření procesů</i>
    for i in range(CONCURRENCY_LEVEL):
        name = f"Process #{i}"
        ps.append(Process(target=worker, args=(name, q)))
&nbsp;
    <i># spuštění procesů</i>
    for p in ps:
        p.start()
&nbsp;
    print("Sending data to other processes")
&nbsp;
    <i># komunikace s procesy přes frontu</i>
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    if WAIT_FOR_KEY:
        input()
&nbsp;
    print("Asking other processes to finish")
&nbsp;
    <i># příkaz pro ukončení procesů</i>
    for i in range(CONCURRENCY_LEVEL):
        q.put("quit")
&nbsp;
    print("Waiting for other processes")
&nbsp;
    <i># čekání na ukončení procesů</i>
    for p in ps:
        p.join()
&nbsp;
    print("All work done!")
&nbsp;
    t2 = time.time()
&nbsp;
    print(f"Elapsed time: {t2-t1}")
</pre>

<h3>Bubble sort: verze běžící ve více vláknech</h3>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových vláknech</i>
<i># - komunikace mezi vlákny s využitím fronty</i>
&nbsp;
CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1
&nbsp;
&nbsp;
import random
from queue import Queue
from threading import Thread
import time
&nbsp;
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných vláknech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            return
        bubble_sort(1000)
&nbsp;
&nbsp;
if __name__ == "__main__":
    t1 = time.time()
&nbsp;
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi vlákny</i>
    q = Queue()
&nbsp;
    ts = []
    <i># vytvoření procesů</i>
    for i in range(CONCURRENCY_LEVEL):
        name = f"Thread #{i}"
        ts.append(Thread(target=worker, daemon=True, name=name, args=[name, q]))
&nbsp;
    <i># spuštění vláken</i>
    for t in ts:
        t.start()
&nbsp;
    print("Sending data to other threads")
&nbsp;
    <i># komunikace s vlákny přes frontu</i>
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    if WAIT_FOR_KEY:
        input()
&nbsp;
    print("Asking other threads to finish")
&nbsp;
    <i># příkaz pro ukončení vláken</i>
    for i in range(CONCURRENCY_LEVEL):
        q.put("quit")
&nbsp;
    print("Waiting for other threads")
&nbsp;
    <i># čekání na zpracování všech zpráv ve frontě</i>
    for t in ts:
        t.join()
&nbsp;
    print("All work done!")
&nbsp;
    t2 = time.time()
&nbsp;
    print(f"Elapsed time: {t2-t1}")
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Změřené výsledky</h2>

<p>V&nbsp;tabulce jsou zobrazeny časy běhu benchmarků zaokrouhlených na celé
sekundy. První tři benchmarky vykazují při opakovaném spuštění prakticky stejné
hodnoty (jsou stabilní), ovšem řešení založené na více vláknech dosti
podstatným způsobem kolísá &ndash; ovšem jen tehdy, pokud se použije Python
3.14 s&nbsp;vypnutým GILem. Synchronizační mechanismy použité při zakázaném
GILu se z&nbsp;tohoto pohledu chovají dosti nedeterministicky. Dále je &ndash;
což je pochopitelné &ndash; čas asynchronní varianty nejpomalejší, neboť se
vlastně úlohy provádí sekvenčně. A tento čas je shodný s&nbsp;benchmarkem
založeným na použití více vláken, pokud je povolený GIL (který výpočet
&bdquo;serializuje&ldquo;):</p>

<table>
<tr><th>Typ souběžnosti</th><th>Celkový čas vykonání (bez GILu)</th><th>Celkový čas vykonání (s&nbsp;GILem)</th></tr>
<tr><td>Async</td><td>54</td><td>54</td></tr>
<tr><td>Interpreters</td><td>13</td><td>40</td></tr>
<tr><td>Processes</td><td>10</td><th>10</th></tr>
<tr><td>Threads</td><td>21-45</td><th>54</th></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Shrnutí</h2>

<p>Nová technologie umožňující spouštění výpočtů v&nbsp;izolovaných
interpretrech, z&nbsp;nichž každý běží ve vlastním vlákně, má v&nbsp;současné
verzi Pythonu tyto vlastnosti, ke kterým je nutné přihlížet:</p>

<ul>

<li>Inicializace a spuštění interpretrů je dosti pomalé, a to i
v&nbsp;porovnání se spuštěním více procesů. Tento stav by se však měl postupně
zlepšovat.</li>

<li>Výkon při zakázaném GILu je stabilní a kupodivu vyšší, než při použití
klasického multithreadingu, což je poměrně překvapující zjištění.</li>

<li>Paměťové nároky jsou nižší, než při použití více procesů (logicky), ale
vyšší, než u klasického multithreadingu.</li>

<li>(Asynchronní úlohy jsou vhodné jen pro oblasti s&nbsp;velkým množstvím I/O
operací, nikoli pro výpočty).</li>

</ul>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</h2>

<p>Na stránkách <a href="https://www.root.cz">Roota</a> jsme se již několikrát
setkali s&nbsp;problematikou souběžnosti (<i>concurrency</i>), paralelnosti
(<i>parallel run</i>) a asynchronního běhu úloh naprogramovaných
v&nbsp;Pythonu. Různé varianty spouštění a řízení více vláken, procesů a
asynchronních úloh naleznete v&nbsp;následujících článcích (všechny
v&nbsp;článcích uvedené demonstrační příklady by měly být spustitelné i
v&nbsp;interpretru Pythonu 3.14 bez povoleného GILu):</p>

<ol>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – Curio a Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – závěrečné zhodnocení<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/</a>
</li>

<li>Interpret Pythonu bez GILu: vyplatí se odstranění velkého zámku?<br />
<a href="https://www.root.cz/clanky/interpret-pythonu-bez-gilu-vyplati-se-odstraneni-velkeho-zamku/">https://www.root.cz/clanky/interpret-pythonu-bez-gilu-vyplati-se-odstraneni-velkeho-zamku/</a>
</li>

<li>Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: vliv odstranění GIL a využití více interpretrů<br />
<a href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/</a>
</li>

<li>Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: komunikace mezi interpretry<br />
<a href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-komunikace-mezi-interpretry/">https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-komunikace-mezi-interpretry/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, které byly popsány v&nbsp;dnešním článku,
naleznete na adresách:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td>1</td><td>multiple-threads.py</td><td>benchmark založený na vykonávání úloh v&nbsp;samostatných vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/multiple-threads.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/multiple-threads.py</a></td></tr>
<tr><td>2</td><td>multiple-processes.py</td><td>benchmark založený na vykonávání úloh v&nbsp;samostatných procesech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/multiple-processes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/multiple-processes.py</a></td></tr>
<tr><td>3</td><td>multiple-interpreters.py</td><td>benchmark založený na vykonávání úloh v&nbsp;samostatných interpretech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/multiple-interpreters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/multiple-interpreters.py</a></td></tr>
<tr><td>4</td><td>multiple-async.py</td><td>benchmark založený na vykonávání asynchronních úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/multiple-async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/multiple-async.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>bubble-threads.py</td><td>benchmark založený na vykonávání úloh v&nbsp;samostatných vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/bubble-threads.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/bubble-threads.py</a></td></tr>
<tr><td>6</td><td>bubble-processes.py</td><td>benchmark založený na vykonávání úloh v&nbsp;samostatných procesech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/bubble-processes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/bubble-processes.py</a></td></tr>
<tr><td>7</td><td>bubble-interpreters.py</td><td>benchmark založený na vykonávání úloh v&nbsp;samostatných interpretech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/bubble-interpreters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/bubble-interpreters.py</a></td></tr>
<tr><td>8</td><td>bubble-async.py</td><td>benchmark založený na vykonávání asynchronních úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/bubble-async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/benchmarks/bubble-async.py</a></td></tr>
</table>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-komunikace-mezi-interpretry/">z&nbsp;předchozího
článku</a> jsou vypsány v&nbsp;další tabulce:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td>1</td><td>interpreters/queue-interpreters-1.py</td><td>poslání zprávy mezi úlohami, které běží v&nbsp;různých interpretrech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-1.py</a></td></tr>
<tr><td>2</td><td>interpreters/queue-interpreters-2.py</td><td>realizace programu pro zpracování úloh v&nbsp;samostatně běžících interpretrech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-2.py</a></td></tr>
<tr><td>3</td><td>interpreters/queue-async.py</td><td>plně asynchronní volání úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-async.py</a></td></tr>
<tr><td>4</td><td>interpreters/queue-multiprocessing.py</td><td>poslání zprávy mezi úlohami, které běží v&nbsp;různých procesech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multiprocessing.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multiprocessing.py</a></td></tr>
<tr><td>5</td><td>interpreters/queue-multithreading-1.py</td><td>poslání zprávy mezi úlohami, které běží v&nbsp;různých vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-1.py</a></td></tr>
<tr><td>6</td><td>interpreters/queue-multithreading-2.py</td><td>poslání zprávy mezi úlohami, které běží v&nbsp;různých vláknech, odlišné čekání na dokončení úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-2.py</a></td></tr>
<tr><td>7</td><td>interpreters/queue-multithreading-3.py</td><td>varianta s&nbsp;několika producenty a několika konzumenty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-3.py</a></td></tr>
</table>

<p>Všechny <a
href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">předminule</a>
popsané demonstrační příklady jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td> 1</td><td>bubble-sort/bubble_sort_seq.py</td><td>benchmark provádějící sekvenční volání algoritmu pro bublinkové řazení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_seq.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_seq.py</a></td></tr>
<tr><td> 2</td><td>bubble-sort/bubble_sort_parallel.py</td><td>benchmark provádějící souběžné volání algoritmu pro bublinkové řazení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_parallel.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_parallel.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>julia-renderer/julia_seq_anim.py</td><td>sekvenční výpočet animace Juliových množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_seq_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_seq_anim.py</a></td></tr>
<tr><td> 4</td><td>julia-renderer/julia_parallel_anim.py</td><td>souběžný popř.&nbsp;paralelní výpočet animace Juliových množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_parallel_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_parallel_anim.py</a></td></tr>
<tr><td> 5</td><td>julia-renderer/palette_mandmap.py</td><td>pomocný soubor s&nbsp;barvovou mapou použitý dvěma předchozími benchmarky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/palette_mandmap.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>interpreters/list-interpreters.py</td><td>výpis seznamu inicializovaných interpretrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/list-interpreters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/list-interpreters.py</a></td></tr>
<tr><td> 7</td><td>interpreters/new-interpreter.py</td><td>konstrukce nového interpretru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/new-interpreter.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/new-interpreter.py</a></td></tr>
<tr><td> 8</td><td>interpreters/exec.py</td><td>zavolání funkce ve zvoleném interpretru (ve stejném vlákně)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/exec.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/exec.py</a></td></tr>
<tr><td> 9</td><td>interpreters/call_in_thread.py</td><td>zavolání funkce ve zvoleném interpretru (v&nbsp;novém vlákně)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/call_in_thread.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/call_in_thread.py</a></td></tr>
<tr><td>10</td><td>interpreters/shared-variables.py</td><td>jsou proměnné sdíleny mezi interpretry?</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/shared-variables.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/shared-variables.py</a></td></tr>
<tr><td>11</td><td>interpreters/behaviour_exec.py</td><td>chování dvou interpretrů v&nbsp;čase běhu (metoda <strong>exec</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_exec.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_exec.py</a></td></tr>
<tr><td>12</td><td>interpreters/behaviour_call_in_thread.py</td><td>chování dvou interpretrů v&nbsp;čase běhu (metoda <strong>call_in_thread</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_call_in_thread.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_call_in_thread.py</a></td></tr>
<tr><td>13</td><td>interpreters/interpreter_exception_1.py </td><td>chování interpretrů při vyhození nezachycené výjimky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_1.py</a></td></tr>
<tr><td>14</td><td>interpreters/interpreter_exception_2.py </td><td>chování interpretrů při vyhození nezachycené výjimky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_2.py</a></td></tr>
</table>

<p>Demonstrační příklady vytvořené pro Python verze 3.14 a popsané
v&nbsp;prvním článku najdete v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs/">https://github.com/tisnik/most-popular-python-libs/</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>argparse_test.py</td><td>skript s&nbsp;definicí přepínačů použitelných na příkazovém řádku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/argparse_test.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/argparse_test.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>syntax_error_1.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_1.py</a></td></tr>
<tr><td> 2</td><td>syntax_error_2.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_2.py</a></td></tr>
<tr><td> 3</td><td>syntax_error_3.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_3.py</a></td></tr>
<tr><td> 4</td><td>syntax_error_4.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_4.py</a></td></tr>
<tr><td> 5</td><td>syntax_error_5.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>primes.py</td><td>realizace výpočtu prvočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/primes.py</a></td></tr>
<tr><td> 7</td><td>test_primes.py</td><td>jednotkové testy pro modul <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/test_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/test_primes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>pep-758-motivation-1.py</td><td>zachycení většího množství výjimek v&nbsp;bloku <strong>except</strong> &ndash; motivační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-1.py</a></td></tr>
<tr><td> 9</td><td>pep-758-motivation-2.py</td><td>zachycení většího množství výjimek v&nbsp;bloku <strong>except</strong> &ndash; motivační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-2.py</a></td></tr>
<tr><td>10</td><td>pep-758-usage.py</td><td>nový způsob zachycení výjimek definovaný v&nbsp;PEP-758</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage.py</a></td></tr>
<tr><td>11</td><td>pep-758-usage-as.py</td><td>klauzule <strong>as</strong> a nový způsob zachycení výjimek definovaný v&nbsp;PEP-758</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage-as.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage-as.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>pep-765-motivation-1.py</td><td>detekce opuštění bloku <strong>finally</strong>, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-1.py</a></td></tr>
<tr><td>13</td><td>pep-765-motivation-2.py</td><td>detekce opuštění bloku <strong>finally</strong>, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-2.py</a></td></tr>
<tr><td>14</td><td>pep-765-motivation-3.py</td><td>detekce opuštění bloku <strong>finally</strong>, třetí demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-3.py</a></td></tr>
<tr><td>15</td><td>pep-765-motivation-4.py</td><td>detekce opuštění bloku <strong>finally</strong>, čtvrtý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>f-string-1.py</td><td>rozdíl mezi f-řetězci a t-řetězci, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-1.py</a></td></tr>
<tr><td>17</td><td>t-string-1.py</td><td>rozdíl mezi f-řetězci a t-řetězci, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-1.py</a></td></tr>
<tr><td>18</td><td>f-string-2.py</td><td>rozdíl mezi f-řetězci a t-řetězci, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-2.py</a></td></tr>
<tr><td>19</td><td>t-string-2.py</td><td>rozdíl mezi f-řetězci a t-řetězci, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python 3.14.0<br />
<a href="https://test.python.org/downloads/release/python-3140/">https://test.python.org/downloads/release/python-3140/</a>
</li>

<li>PEP 765 – Disallow return/break/continue that exit a finally block<br />
<a href="https://peps.python.org/pep-0765/">https://peps.python.org/pep-0765/</a>
</li>

<li>PEP 758 – Allow except and except* expressions without parentheses<br />
<a href="https://peps.python.org/pep-0758/">https://peps.python.org/pep-0758/</a>
</li>

<li>What’s new in Python 3.14 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.14.html">https://docs.python.org/3/whatsnew/3.14.html</a>
</li>

<li>What’s New In Python 3.13 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.13.html">https://docs.python.org/3/whatsnew/3.13.html</a>
</li>

<li>What’s New In Python 3.12 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.12.html">https://docs.python.org/3/whatsnew/3.12.html</a>
</li>

<li>What’s New In Python 3.11 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.11.html">https://docs.python.org/3/whatsnew/3.11.html</a>
</li>

<li>What’s New In Python 3.12<br />
<a href="https://dev.to/mahiuddindev/python-312-4n43">https://dev.to/mahiuddindev/python-312-4n43</a></li>

<li>PEP 698 – Override Decorator for Static Typing<br />
<a href="https://peps.python.org/pep-0698/">https://peps.python.org/pep-0698/</a>
</li>

<li>PEP 484 -- Type Hints<br />
<a href="https://www.python.org/dev/peps/pep-0484/">https://www.python.org/dev/peps/pep-0484/</a>
</li>

<li>What’s New In Python 3.5<br />
<a href="https://docs.python.org/3.5/whatsnew/3.5.html">https://docs.python.org/3.5/whatsnew/3.5.html</a>
</li>

<li>26.1. typing — Support for type hints<br />
<a href="https://docs.python.org/3.5/library/typing.html#module-typing">https://docs.python.org/3.5/library/typing.html#module-typing</a>
</li>

<li>Type Hints - Guido van Rossum - PyCon 2015 (youtube)<br />
<a href="https://www.youtube.com/watch?v=2wDvzy6Hgxg">https://www.youtube.com/watch?v=2wDvzy6Hgxg</a>
</li>

<li>Python 3.5 is on its way<br />
<a href="https://lwn.net/Articles/650904/">https://lwn.net/Articles/650904/</a>
</li>

<li>Type hints<br />
<a href="https://lwn.net/Articles/640359/">https://lwn.net/Articles/640359/</a>
</li>

<li>Stránka projektu PDM<br />
<a href="https://pdm.fming.dev/latest/">https://pdm.fming.dev/latest/</a>
</li>

<li>PDF na GitHubu<br />
<a href="https://github.com/pdm-project/pdm">https://github.com/pdm-project/pdm</a>
</li>

<li>PEP 582 &ndash; Python local packages directory<br />
<a href="https://peps.python.org/pep-0582/">https://peps.python.org/pep-0582/</a>
</li>

<li>PDM na PyPi<br />
<a href="https://pypi.org/project/pdm/">https://pypi.org/project/pdm/</a>
</li>

<li>Which Python package manager should you use?<br />
<a href="https://towardsdatascience.com/which-python-package-manager-should-you-use-d0fd0789a250">https://towardsdatascience.com/which-python-package-manager-should-you-use-d0fd0789a250</a>
</li>

<li>How to Use PDM to Manage Python Dependencies without a Virtual Environment<br />
<a href="https://www.youtube.com/watch?v=qOIWNSTYfcc">https://www.youtube.com/watch?v=qOIWNSTYfcc</a>
</li>

<li>What are the best Python package managers?<br />
<a href="https://www.slant.co/topics/2666/~best-python-package-managers">https://www.slant.co/topics/2666/~best-python-package-managers</a>
</li>

<li>PEP 621 &ndash; Storing project metadata in pyproject.toml<br />
<a href="https://peps.python.org/pep-0621/">https://peps.python.org/pep-0621/</a>
</li>

<li>Pick a Python Lockfile and Improve Security<br />
<a href="https://blog.phylum.io/pick-a-python-lockfile-and-improve-security/">https://blog.phylum.io/pick-a-python-lockfile-and-improve-security/</a>
</li>

<li>PyPA specifications<br />
<a href="https://packaging.python.org/en/latest/specifications/">https://packaging.python.org/en/latest/specifications/</a>
</li>

<li>Creation of virtual environments<br />
<a href="https://docs.python.org/3/library/venv.html">https://docs.python.org/3/library/venv.html</a>
</a>

<li>How to Use virtualenv in Python<br />
<a href="https://learnpython.com/blog/how-to-use-virtualenv-python/">https://learnpython.com/blog/how-to-use-virtualenv-python/</a>
</a>

<li>Python Virtual Environments: A Primer<br />
<a href="https://realpython.com/python-virtual-environments-a-primer/">https://realpython.com/python-virtual-environments-a-primer/</a>
</a>

<li>virtualenv Cheatsheet<br />
<a href="https://aaronlelevier.github.io/virtualenv-cheatsheet/">https://aaronlelevier.github.io/virtualenv-cheatsheet/</a>
</a>

<li>Installing Python Modules<br />
<a href="https://docs.python.org/3/installing/index.html">https://docs.python.org/3/installing/index.html</a>
</a>

<li>Python: The Documentary | An origin story<br />
<a href="https://www.youtube.com/watch?v=GfH4QL4VqJ0">https://www.youtube.com/watch?v=GfH4QL4VqJ0</a>
</li>

<li>History of Python<br />
<a href="https://en.wikipedia.org/wiki/History_of_Python">https://en.wikipedia.org/wiki/History_of_Python</a>
</li>

<li>History of Python<br />
<a href="https://www.geeksforgeeks.org/python/history-of-python/">https://www.geeksforgeeks.org/python/history-of-python/</a>
</li>

<li>IPython: jedno z nejpropracovanějších interaktivních prostředí pro práci s&nbsp;Pythonem<br />
<a href="https://www.root.cz/clanky/ipython-jedno-z-nejpropracova-nejsich-interaktivnich-prostredi-pro-praci-s-pythonem/">https://www.root.cz/clanky/ipython-jedno-z-nejpropracova-nejsich-interaktivnich-prostredi-pro-praci-s-pythonem/</a>
</li>

<li>Další kulaté výročí v IT: dvacet let existence Pythonu 2<br />
<a href="https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/">https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/</a>
</li>

<li>PEP 684 – A Per-Interpreter GIL<br />
<a href="https://peps.python.org/pep-0684/">https://peps.python.org/pep-0684/</a>
</li>

<li>What Is the Python Global Interpreter Lock (GIL)?<br />
<a href="https://realpython.com/python-gil/">https://realpython.com/python-gil/</a>
</li>

<li>PEP 703 – Making the Global Interpreter Lock Optional in CPython<br />
<a href="https://peps.python.org/pep-0703/">https://peps.python.org/pep-0703/</a>
</li>

<li>GlobalInterpreterLock<br />
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>
</li>

<li>What is the Python Global Interpreter Lock (GIL)<br />
<a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/">https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/</a>
</li>

<li>Let's remove the Global Interpreter Lock<br />
<a href="https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html">https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html</a>
</li>

<li>Global interpreter lock<br />
<a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">https://en.wikipedia.org/wiki/Global_interpreter_lock</a>
</li>

<li>Rychlost CPythonu 3.11 a 3.12 v&nbsp;porovnání s JIT a AOT překladači<br />
<a href="https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/">https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/</a>
</li>

<li>Dokumentace Pythonu: balíček queue<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Dokumentace Pythonu: balíček threading<br />
<a href="https://docs.python.org/3/library/threading.html?">https://docs.python.org/3/library/threading.html?</a>
</li>

<li>Dokumentace Pythonu: balíček multiprocessing<br />
<a href="https://docs.python.org/3/library/multiprocessing.html">https://docs.python.org/3/library/multiprocessing.html</a>
</li>

<li>Dokumentace Pythonu: balíček asyncio<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Synchronization Primitives<br />
<a href="https://docs.python.org/3/library/asyncio-sync.html">https://docs.python.org/3/library/asyncio-sync.html</a>
</li>

<li>Coroutines<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Queues<br />
<a href="https://docs.python.org/3/library/asyncio-queue.html">https://docs.python.org/3/library/asyncio-queue.html</a>
</li>

<li>python-csp<br />
<a href="https://python-csp.readthedocs.io/en/latest/">https://python-csp.readthedocs.io/en/latest/</a>
</li>

<li>TrellisSTM<br />
<a href="http://peak.telecommunity.com/DevCenter/TrellisSTM">http://peak.telecommunity.com/DevCenter/TrellisSTM</a>
</li>

<li>Python Multithreading and Multiprocessing Tutorial<br />
<a href="https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python">https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

