<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Nové vlastnosti Pythonu 3.14 v praxi: rychlost a paměťové nároky aplikací využívajících více interpretrů</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Nové vlastnosti Pythonu 3.14 v praxi: rychlost a paměťové nároky aplikací využívajících více interpretrů</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: rychlost a paměťové nároky aplikací využívajících více interpretrů</a></p>
<p><a href="#k02">*** 2. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více vláknech</a></p>
<p><a href="#k03">*** 3. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více procesech</a></p>
<p><a href="#k04">*** 4. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více interpretrech</a></p>
<p><a href="#k05">*** 5. Benchmark zjišťující vlastnosti výpočtů realizovaných asynchronními úlohami</a></p>
<p><a href="#k06">*** 6. Výsledky benchmarků: doba vykonání 100 krátkodobých úloh při nastavení úrovně souběžnosti na 10</a></p>
<p><a href="#k07">*** 7. Výsledky benchmarků: doba vykonání 100 déletrvajících úloh při nastavení úrovně souběžnosti na 10</a></p>
<p><a href="#k08">*** 8. Výsledky benchmarků: doba vykonání 1000 krátkodobých úloh při nastavení úrovně souběžnosti na 100</a></p>
<p><a href="#k09">*** 9. Paměťové nároky všech tří variant benchmarků</a></p>
<p><a href="#k10">*** 10. Změřené výsledky: paměťové nároky benchmarků</a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: rychlost a paměťové nároky aplikací využívajících více interpretrů</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více vláknech</h2>

<pre>
# Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh v nových vláknech
# - komunikace mezi vlákny s využitím fronty

CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1


from queue import Queue
from threading import Thread
import time


def worker(name, q):
    """Worker spuštěný několikrát v samostatných vláknech."""
    while True:
        # čtení příkazů z fronty
        cmd = q.get()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            return
        if SLEEP_AMOUNT &gt; 0:
            time.sleep(SLEEP_AMOUNT)


if __name__ == "__main__":
    t1 = time.time()

    print("Starting")

    # vytvoření fronty pro komunikaci mezi vlákny
    q = Queue()

    ts = []
    # vytvoření procesů
    for i in range(CONCURRENCY_LEVEL):
        name = f"Thread #{i}"
        ts.append(Thread(target=worker, daemon=True, name=name, args=[name, q]))

    # spuštění vláken
    for t in ts:
        t.start()

    print("Sending data to other threads")

    # komunikace s vlákny přes frontu
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))

    if WAIT_FOR_KEY:
        input()

    print("Asking other threads to finish")

    # příkaz pro ukončení vláken
    for i in range(CONCURRENCY_LEVEL):
        q.put("quit")

    print("Waiting for other threads")

    # čekání na zpracování všech zpráv ve frontě
    for t in ts:
        t.join()

    print("All work done!")

    t2 = time.time()

    print(f"Elapsed time: {t2-t1}")
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více procesech</h2>

<pre>
# Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh v nových procesech
# - komunikace mezi procesy s využitím fronty

CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1


import time
from multiprocessing import Process, Queue, freeze_support


def worker(name, q):
    """Worker spuštěný několikrát v samostatných procesech."""
    while True:
        # čtení příkazů z fronty
        cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Process '{name}' is about to quit")
            return
        if SLEEP_AMOUNT &gt; 0:
            time.sleep(SLEEP_AMOUNT)


if __name__ == "__main__":
    t1 = time.time()

    print("Starting")
    freeze_support()

    # vytvoření fronty pro komunikaci mezi procesy
    q = Queue()

    ps = []
    # vytvoření procesů
    for i in range(CONCURRENCY_LEVEL):
        name = f"Process #{i}"
        ps.append(Process(target=worker, args=(name, q)))

    # spuštění procesů
    for p in ps:
        p.start()

    print("Sending data to other processes")

    # komunikace s procesy přes frontu
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))

    if WAIT_FOR_KEY:
        input()

    print("Asking other processes to finish")

    # příkaz pro ukončení procesů
    for i in range(CONCURRENCY_LEVEL):
        q.put("quit")

    print("Waiting for other processes")

    # čekání na ukončení procesů
    for p in ps:
        p.join()

    print("All work done!")

    t2 = time.time()

    print(f"Elapsed time: {t2-t1}")
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Benchmark zjišťující vlastnosti výpočtů realizovaných ve více interpretrech</h2>

<pre>
# Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh v nových interpretrech
# - komunikace mezi interpretry s využitím fronty

CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1


import time
from concurrent import interpreters


def worker(name, q):
    """Worker spuštěný několikrát v samostatných interpretrech."""
    while True:
        # čtení příkazů z fronty
        cmd = q.get()
        print(f"Interpreter '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Interpreter '{name}' is about to quit")
            return
        if SLEEP_AMOUNT &gt; 0:
            time.sleep(SLEEP_AMOUNT)


if __name__ == "__main__":
    t1 = time.time()

    print("Starting")

    # vytvoření fronty pro komunikaci mezi interpretry
    q = interpreters.create_queue()

    ins = []
    # vytvoření interpretrů
    for i in range(CONCURRENCY_LEVEL):
        name = f"Interpreter #{i}"
        ins.append(interpreters.create().call_in_thread(worker, name, q))

    print("Sending data to other interpreters")

    # komunikace s interpretry přes frontu
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))

    print("Asking other interpreters to finish")

    # příkaz pro ukončení procesů
    for i in range(CONCURRENCY_LEVEL):
        q.put("quit")

    print("Waiting for other interpreters")

    # čekání na ukončení interpretrů
    for i in ins:
        i.join()

    print("All work done!")

    t2 = time.time()

    print(f"Elapsed time: {t2-t1}")
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Benchmark zjišťující vlastnosti výpočtů realizovaných asynchronními úlohami</h2>

<pre>
# Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh asynchronně
# - komunikace mezi procesy s využitím fronty

CONCURRENCY_LEVEL = 100
TASKS = 1000
WAIT_FOR_KEY = False
SLEEP_AMOUNT = 1

from asyncio import Queue, sleep, run, gather, create_task
import time


async def worker(name, q):
    """Worker spuštěný několikrát asynchronně."""
    while not q.empty():
        # čtení příkazů z fronty
        cmd = await q.get()
        print(f"Task '{name}' received command '{cmd}'")
        if SLEEP_AMOUNT &gt; 0:
            await sleep(SLEEP_AMOUNT)


async def main():
    t1 = time.time()

    print("Starting")

    # vytvoření fronty pro komunikaci mezi úlohami
    queue = Queue()

    print("Sending data to async tasks")

    # komunikace s úlohami přes frontu
    for i in range(TASKS):
        print(f"Sending 'command {i}'")
        await queue.put("command {}".format(i))

    print("Waiting for all tasks")

    aws = [create_task(worker(f"Task #{i}", queue)) for i in range(CONCURRENCY_LEVEL)]
    await gather(*aws)

    print("All work done!")

    t2 = time.time()

    print(f"Elapsed time: {t2-t1}")

run(main())
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledky benchmarků: doba vykonání 100 krátkodobých úloh při nastavení úrovně souběžnosti na 10</h2>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</table>




