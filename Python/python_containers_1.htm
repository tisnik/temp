<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Kontejnery v Pythonu: zdaleka nejde jen o n-tice, seznamy, množiny a slovníky</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Kontejnery v Pythonu: zdaleka nejde jen o n-tice, seznamy, množiny a slovníky</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s vybranými kontejnery (containers), které je možné použít při tvorbě aplikací v programovacím jazyku Python. Kontejnerů přitom existuje velké množství a zdaleka se nejedná jen o n-tice, seznamy, množiny a slovníky.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Kontejnery v&nbsp;Pythonu: zdaleka nejde jen o n-tice, seznamy, množiny a slovníky</a></p>
<p><a href="#k02">2. Kontejnery v&nbsp;kontextu programovacího jazyka Python</a></p>
<p><a href="#k03">3. n-tice</a></p>
<p><a href="#k04">4. Seznamy</a></p>
<p><a href="#k05">5. Standardní množiny a jejich varianty</a></p>
<p><a href="#k06">6. Standardní slovníky a jejich varianty</a></p>
<p><a href="#k07">7. Obousměrné fronty</a></p>
<p><a href="#k08">8. Přidání prvku do fronty zleva či zprava, vložení prvku do libovolného místa fronty</a></p>
<p><a href="#k09">9. Odstranění nejlevějšího či nejpravějšího prvku z&nbsp;fronty</a></p>
<p><a href="#k10">10. Metody <strong>reverse</strong> a <strong>rotate</strong></a></p>
<p><a href="#k11">11. Multimnožiny (<i>multiset</i>)</a></p>
<p><a href="#k12">12. Multislovníky (<i>multidict</i>)</a></p>
<p><a href="#k13">13. Balíček <strong>python-box</strong> zajišťující výběr hodnot s&nbsp;využitím klíčů nebo atributů</a></p>
<p><a href="#k14">14. Instalace balíčku <strong>python-box</strong></a></p>
<p><a href="#k15">15. Datová struktura <strong>Box</strong> je kontejnerem</a></p>
<p><a href="#k16">16. Příklady využití datové struktury <strong>Box</strong></a></p>
<p><a href="#k17">17. Praktická ukázka: získání hodnot z&nbsp;několikanásobně vnořené datové struktury načtené z&nbsp;JSONu</a></p>
<p><a href="#k18">18. Klíč složený z&nbsp;několika selektorů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Kontejnery v&nbsp;Pythonu: zdaleka nejde jen o n-tice, seznamy, množiny a slovníky</h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;vybranými <i>kontejnery</i>
(<i>containers</i>), které je možné použít při tvorbě aplikací
v&nbsp;programovacím jazyku Python. Kontejnerů přitom existuje velké množství.
Kromě notoricky známé čtveřice n-tice (<i>tuple</i>), seznam (<i>list</i>),
množina (<i>set</i>) a slovník (<i>dict</i>) existují i ve standardní knihovně
další typy kontejnerů a jiné lze doinstalovat (a pravděpodobně již některé
z&nbsp;nich máte nainstalovány jako tranzitivní závislost jiné knihovny,
například knihovny <strong>requests</strong> apod.).</p>

<p>V&nbsp;poměrně velkém množství zdrojových kódů, které mi chodí na review, se
přitom používají kontejnery, jejichž vlastnosti přesně neodpovídají potřebám
řešeného problému. To vede k&nbsp;tomu, že je nutné explicitně znovu a znovu
provádět operace, jež by v&nbsp;případě použití odlišného (vhodnějšího) typu
kontejneru byly vyřešeny &bdquo;zadarmo&ldquo;, protože je zajistí samotný
kontejner. Asi nejtypičtějším příkladem jsou algoritmy, v&nbsp;nichž se
používají unikátní hodnoty. V&nbsp;takovém případě může být výhodné použít
množiny (<i>set</i>) a nikoli z&nbsp;nějakého důvodu často nasazované seznamy
(<i>list</i>). Mezi další dva příklady, s&nbsp;nimž se často setkávám, patří
snaha o realizaci kontejneru, který je znám pod označením <i>multidict</i> a
taktéž explicitní programování chování kontejneru <i>Counter</i>.
V&nbsp;některých případech je taktéž nutné pracovat s&nbsp;oboustranným
mapováním (jednostranné mapování zajišťují slovníky).</p>

<p>V&nbsp;dnešním článku se nejprve ve stručnosti seznámíme s&nbsp;těmi
kontejnery, které jsou součástí standardní knihovny Pythonu &ndash; a nejedná
se v&nbsp;žádném případě pouze o známou čtveřici n-tice, seznam, množina a
slovník. Posléze si ovšem popíšeme i některé další typy kontejnerů realizované
v&nbsp;modulech (balíčcích), které je nutné doinstalovat. A na konec si ukážeme
základní vlastnosti modulu nazvaného <i>Box</i> (či <i>python-box</i>), který
umožňuje namísto klasických <i>selektorů</i> (u slovníků) použít tečkovou
notaci tak, jakoby prvky byly uloženy formou atributů. Ostatně tento koncept
(řekněme dualitu mezi selektorem a jménem atributu) není nijak nový a <a
href="https://www.root.cz/clanky/operatory-a-asociativni-pole-v-jazyku-lua/#k08">vidět
jsme ho mohli</a> například <a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">v&nbsp;programovacím
jazyku Lua</a>, v&nbsp;němž je použit při práci s&nbsp;kontejnerem nazvaným
<i>tabulka</i> (<i>table</i>), což je kombinace pole a slovníku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Kontejnery v&nbsp;kontextu programovacího jazyka Python</h2>

<p>Na tomto místě je možná vhodné si ve stručnosti připomenout, co vlastně
v&nbsp;kontextu programovacího jazyka Python znamená označení <i>kontejner</i>.
Jedná se o datovou strukturu, kterou lze využít k&nbsp;uložení dalších hodnot
s&nbsp;tím, že jsou většinou zajištěny některé další vlastnosti, jež se mohou
lišit podle typu kontejneru. Například u seznamů je zaručeno pořadí uložených
hodnot, u množin pak unikátnost hodnot atd. Existuje ale ještě striktnější
definice kontejneru, která je ovšem platná právě pouze v&nbsp;kontextu jazyka
Python. Kontejner (tedy <i>container</i>) je taková třída, která implementuje
metodu <strong>__contains__</strong>. Z&nbsp;tohoto pohledu do této kategorie
skutečně patří všechny čtyři základní kontejnery, o čemž se ostatně můžeme
velmi snadno přesvědčit přímo v&nbsp;interaktivní smyčce interpretru
programovacího jazyka Python výpisem metod a atributů tříd
<strong>list</strong>, <strong>tuple</strong>, <strong>set</strong> a
<strong>dict</strong>:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.11.8 (main, Feb  7 2024, 00:00:00) [GCC 13.2.1 20231011 (Red Hat 13.2.1-4)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&nbsp;
&gt;&gt;&gt; <strong>dir(list)</strong>
['__add__', '__class__', '__class_getitem__', '<u>__contains__</u>', '__delattr__',
'__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
'__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__',
'__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__',
'__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__',
'__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__',
'__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear',
'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse',
'sort']
&nbsp;
&gt;&gt;&gt; <strong>dir(tuple)</strong>
['__add__', '__class__', '__class_getitem__', '<u>__contains__</u>', '__delattr__',
'__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
'__getitem__', '__getnewargs__', '__getstate__', '__gt__', '__hash__',
'__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__',
'__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__',
'count', 'index']
&nbsp;
&gt;&gt;&gt; <strong>dir(set)</strong>
['__and__', '__class__', '__class_getitem__', '<u>__contains__</u>', '__delattr__',
'__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
'__getstate__', '__gt__', '__hash__', '__iand__', '__init__',
'__init_subclass__', '__ior__', '__isub__', '__iter__', '__ixor__', '__le__',
'__len__', '__lt__', '__ne__', '__new__', '__or__', '__rand__', '__reduce__',
'__reduce_ex__', '__repr__', '__ror__', '__rsub__', '__rxor__', '__setattr__',
'__sizeof__', '__str__', '__sub__', '__subclasshook__', '__xor__', 'add',
'clear', 'copy', 'difference', 'difference_update', 'discard', 'intersection',
'intersection_update', 'isdisjoint', 'issubset', 'issuperset', 'pop', 'remove',
'symmetric_difference', 'symmetric_difference_update', 'union', 'update']
&nbsp;
&gt;&gt;&gt; <strong>dir(dict)</strong>
['__class__', '__class_getitem__', '<u>__contains__</u>', '__delattr__',
'__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
'__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__',
'__init__', '__init_subclass__', '__ior__', '__iter__', '__le__', '__len__',
'__lt__', '__ne__', '__new__', '__or__', '__reduce__', '__reduce_ex__',
'__repr__', '__reversed__', '__ror__', '__setattr__', '__setitem__',
'__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys',
'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. n-tice</h2>

<p>Základním a současně i velmi důležitým a často používaným kontejnerem jsou
v&nbsp;Pythonu n-tice. Na rozdíl od dále zmíněných seznamů jsou n-tice
neměnitelné (<i>immutable</i>) se všemi z&nbsp;toho plynoucími důsledky &ndash;
obecně platí, že n-tice lze použít jako klíče slovníků, lze je bez problémů
použít pro specifikaci výchozí hodnoty parametru funkce/metody (na rozdíl od
slovníků) atd.</p>

<p>Při konstrukci n-tice je nutné si pouze dát pozor na to, jak zapisovat
jednoprvkovou n-tici, protože samotné kulaté závorky mají v&nbsp;Pythonu hned
několik významů:</p>

<pre>
<i># tříprvková n-tice</i>
t1 = (1, 2, 3)
&nbsp;
<i># jednoprvková n-tice</i>
t2 = (4,)
&nbsp;
<i># pozor - není tuple!</i>
t3 = (5)
&nbsp;
<i># nehomogenní n-tice</i>
t4 = (4, 3.14, "string", [])
&nbsp;
<i># prázdná n-tice</i>
t5 = ()
&nbsp;
print(t1)
print(t2)
print(t3)
print(t4)
print(t5)
</pre>

<p>n-tice lze spojovat operátorem +, který v&nbsp;tomto případě pochopitelně
není komutativní:</p>

<pre>
x = (1, 2, 3)
y = (3, 4, 5)
&nbsp;
print(x + y)
print(y + x)
</pre>

<p>Taktéž můžeme použít operátor * pro vytvoření nové n-tice, ve které se
několikrát opakuje n-tice původní:</p>

<pre>
x = (1, 2, 3)
y = x * 3
&nbsp;
print(x)
print(y)
</pre>

<p><div class="rs-tip-major">Poznámka: pokud n-tici opakujeme nulakrát, bude
výsledkem prázdná n-tice.</div></p>

<p>A u n-tic lze použít operátor <strong>in</strong>, podobně jako u všech
dalších typů kontejnerů:</p>

<pre>
x = (1, 2, 3)
y = (3, 4, 5)
z = x + y
&nbsp;
print(1 in z)
print(10 in z)
print("foobar" in z)
</pre>

<p>U n-tic vzniká ještě jeden drobný syntaktický problém. Očekávali bychom, že
Python jako do jisté míry ortogonální programovací jazyk, bude podporovat
generátorovou notaci i pro n-tice. Jenže jak je vlastně možné takový výraz
zapsat, když samotné kulaté závorky jsou použity přímo pro generátorovou notaci
a ostatní typy závorek jsou již &bdquo;obsazeny&ldquo; pro seznamy, množiny a
slovníky? Teoreticky by sice bylo možné použít úhlové závorky &lt; a &gt;,
ovšem tyto znaky se v&nbsp;Pythonu pro zápis závorek nepoužívají, což je asi
z&nbsp;hlediska celkové čitelnosti jen dobře.</p>

<p>Nebo lze alternativně použít následující trik &ndash; zapsat hvězdičku na
začátek výrazu a čárku na jeho konec. Jedná se o zápis operace rozbalení
(<i>unpack</i>) popsanou v&nbsp;PEP-448 a zavedenou v&nbsp;Pythonu 3.5. Zápis
výrazu, jehož výsledkem je skutečně n-tice, tedy může vypadat takto (nesmíme
ovšem zapomenout na čárku na konci):</p>

<pre>
t = *(x*2 for x in range(11) if x%3 != 0),
&nbsp;
print(t)
</pre>

<p>Výsledkem v&nbsp;tomto případě bude:</p>

<pre>
(2, 4, 8, 10, 14, 16, 20)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Seznamy</h2>

<p>Pravděpodobně nejčastěji používaným kontejnerem v&nbsp;Pythonu jsou seznamy
(<i>list</i>). Ty jsou na rozdíl od n-tic měnitelné (<i>mutable</i>), což při
některých operacích může programátora, který s&nbsp;Pythonem začíná, překvapit.
Nejznámější problém způsobuje specifikace výchozí hodnoty nepovinného parametru
funkce:</p>

<pre>
&gt;&gt;&gt; def foo(l=[]):
...     l.append(".")
...     print(l)
... 
&nbsp;
&gt;&gt;&gt; <strong>foo()</strong>
['.']
&nbsp;
&gt;&gt;&gt; <strong>foo()</strong>
['.', '.']
&nbsp;
&gt;&gt;&gt; <strong>foo()</strong>
['.', '.', '.']
</pre>

<p>Prvky seznamů se vybírají přes celočíselné indexy, přičemž záporné hodnoty
lze použít pro přístup od konce seznamu. Mazání prvků zajišťuje příkaz (ano,
příkaz, ne metoda), <strong>del</strong>:</p>

<pre>
seznam = [1, 2, 3, 4]
&nbsp;
print(seznam[0])
print(seznam[1])
print(seznam[-1])
print(seznam[-2])
&nbsp;
seznam.append(5)
seznam.append(6)
&nbsp;
seznam.insert(0, -10)
seznam.insert(0, -100)
&nbsp;
print(seznam)
&nbsp;
del seznam[0]
print(seznam)
del seznam[-1]
print(seznam)
</pre>

<p>I seznamy lze spojovat nekomutativním operátorem +, stejně jako n-tice:</p>

<pre>
seznam1 = [1, 2, 3]
seznam2 = [4, 5, 6]
&nbsp;
seznam3 = seznam1 + seznam2
&nbsp;
print(seznam3)
</pre>

<p>Vytvoření nového seznamu získaného opakováním vstupního seznam pomocí
nekomutativního operátoru *:</p>

<pre>
seznam1 = [1, 2, 3]
&nbsp;
seznam2 = seznam1 * 3
print(seznam2)
</pre>

<p>Řazení prvků v&nbsp;seznamu je další operací, která může začínající
programátory v&nbsp;Pythonu překvapit. K&nbsp;dispozici je totiž <i>metoda</i>
<strong>sort</strong>, která prvky řadí in-situ (mění seznam) a <i>funkce</i>
<strong>sorted</strong>, která naopak vrací nový seřazený seznam:</p>

<pre>
seznam = [5, 4, 1, 3, 4, 100, -1]
print(seznam)
&nbsp;
seznam.sort()
print(seznam)
&nbsp;
seznam = [5, 4, 1, 3, 4, 100, -1]
print(seznam)
&nbsp;
seznam2 = sorted(seznam)
print(seznam)
print(seznam2)
</pre>

<p>Prvky seznamu lze v&nbsp;případě potřeby otočit metodou
<strong>reverse</strong>, která taktéž pracuje in-situ (mění seznam):</p>

<pre>
seznam = [5, 4, 1, 3, 4, 100, -1]
print(seznam)
&nbsp;
seznam.reverse()
print(seznam)
</pre>

<p>A konečně se podívejme na takzvanou generátorovou notaci, která umožňuje
zápis &bdquo;funkcionálních&ldquo; operací typu <i>map</i> a <i>filter</i>
idiomatickým způsobem (pro Python):</p>

<pre>
seznam = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&nbsp;
seznam2 = [item * 2 for item in seznam]
&nbsp;
seznam3 = [item for item in seznam if item % 3 == 0]
&nbsp;
print(seznam)
print(seznam2)
print(seznam3)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Standardní množiny a jejich varianty</h2>

<p>Seznamy zmíněné <a href="#k04">v&nbsp;předchozí kapitole</a> jsou mnohdy
využívány i v&nbsp;těch částech programového kódu, v&nbsp;nichž by bylo
výhodnější použít spíše množiny (<i>set</i>). U klasických množin je zaručena
unikátnost prvků a jedná se o měnitelnou datovou strukturu, pro kterou platí
podobná pravidla a určitá omezení, jako pro seznamy. Nejprve se podívejme na
konstrukci množin, přičemž pozor je nutné dát především na prázdnou množinu,
kterou je nutné zkonstruovat zavoláním <strong>set</strong> a nikoli zápisem
prázdných složených závorek (to by vznikl slovník). Taktéž si ukážeme
modifikaci množin metodami <strong>add</strong> a <strong>update</strong>:</p>

<pre>
s = {1, 2, 3, 4}
print(s)
&nbsp;
s2 = {"hello", "world", "!", 0}
print(s2)
&nbsp;
s3 = set()
print(s3)
&nbsp;
s3.add(1)
s3.add(2)
print(s3)
&nbsp;
s3.update([3, 4, 5])
print(s3)
</pre>

<p>Podporovány jsou všechny standardní množinové operace zapisované operátory |
(sjednocení), &amp; (průnik), - (diference) a ^ (symetrická diference). A
množiny jsou kontejnery, takže podporují operátor <strong>in</strong> pro test
na existenci prvku:</p>

<pre>
s1 = {1, 2, 3, 4}
s2 = {3, 4, 5, 6}
&nbsp;
print(s1)
print(s2)
&nbsp;
print(s1 | s2)
print(s1 &amp; s2)
print(s1 - s2)
print(s2 - s1)
print(s1 ^ s2)
&nbsp;
print(1 in s1)
print(10 in s1)
</pre>

<p>Množinové operace představují silný výrazový prostředek, který dokáže
nahradit explicitně zapsané smyčky či generátorovou notaci. Patrné je to
z&nbsp;následujícího příkladu získaného z&nbsp;dokumentace:</p>

<pre>
engineers = {"John", "Jane", "Jack", "Janice"}
programmers = {"Jack", "Sam", "Susan", "Janice"}
managers = {"Jane", "Jack", "Susan", "Zack"}
&nbsp;
employees = engineers | programmers | managers
engineering_management = engineers &amp; managers
fulltime_management = managers - engineers - programmers
&nbsp;
print(engineers)
print(programmers)
print(managers)
print(employees)
print(engineering_management)
print(fulltime_management)
</pre>

<p>Výsledky množinových operací, které posloužily pro zjištění různých skupin
zaměstnanců, přičemž se tyto skupiny prolínají:</p>

<pre>
{'Janice', 'Jack', 'John', 'Jane'}
{'Janice', 'Jack', 'Susan', 'Sam'}
{'Zack', 'Jack', 'Susan', 'Jane'}
{'Jack', 'John', 'Janice', 'Zack', 'Susan', 'Sam', 'Jane'}
{'Jack', 'Jane'}
{'Zack'}
</pre>

<p>Odstranění prvků z&nbsp;množiny lze provést metodami
<strong>discard</strong> a <strong>remove</strong>. Tyto metody se od sebe liší
testem (či absencí testu) na existenci prvku. Metoda <strong>discard</strong>
pro neexistující prvek neprovede žádnou operaci zatímco metoda
<strong>remove</strong> v&nbsp;takovém případě vyhodí výjimku:</p>

<pre>
s1 = {1, 2, 3, 4}
print(s1)
&nbsp;
s1.discard(2)
print(s1)
&nbsp;
s1.discard(1000)
print(s1)
&nbsp;
s1.remove(3)
print(s1)
&nbsp;
s1.remove(1000)
print(s1)
</pre>

<p>Na závěr se podívejme na zápis generátorové notace množin. Zapisuje se
prakticky stejně, jako v&nbsp;případě seznamů, ovšem závorky okolo výrazu jsou
složené a ne hranaté:</p>

<pre>
s = {x*2 for x in range(11)}
&nbsp;
print(s)
</pre>

<p>Alternativou k&nbsp;typu <strong>set</strong> je <strong>frozenset</strong>,
což je neměnitelná varianta množin.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Standardní slovníky a jejich varianty</h2>

<p>Čtvrtým základním kontejnerem v&nbsp;programovacím jazyku Python jsou
slovníky (<i>dict</i>). Opět se jedná o měnitelné datové struktury,
v&nbsp;nichž jsou hodnoty vybírány na základě klíče a nikoli indexu. Každý
prvek uložený ve slovníku se tedy skládá z&nbsp;dvojice klíč+hodnota, přičemž
klíč je unikátní (později se ovšem setkáme s&nbsp;multislovníky, kde tomu tak
není).</p>

<p>Konstrukci slovníku a výběr prvků s&nbsp;využitím klíče asi není zapotřebí
podrobně popisovat:</p>

<pre>
d = {"id": 1, "name": "Eda", "surname": "Wasserfall"}
&nbsp;
print(d)
&nbsp;
print(d["name"])
&nbsp;
d["hra"] = "Svestka"
&nbsp;
print(d)
</pre>

<p>Vymazání prvku ze slovníku je provedeno příkazem <strong>del</strong>:</p>

<pre>
d = {"id": 1, "name": "Eda", "surname": "Wasserfall"}
&nbsp;
print(d)
&nbsp;
print(d["name"])
&nbsp;
d["hra"] = "Svestka"
&nbsp;
print(d)
&nbsp;
del d["id"]
&nbsp;
print(d)
</pre>

<p>V&nbsp;případě, že prvek s&nbsp;daným klíčem neexistuje, je při pokusu o
jeho čtení či vymazání vyhozena výjimka <strong>KeyError</strong>:</p>

<pre>
d = {"id": 1, "name": "Eda", "surname": "Wasserfall"}
&nbsp;
del d["id"]
del d["foo"]
del d["bar"]
&nbsp;
print(d)
</pre>

<p>U všech předchozích kontejnerů existovala nějaká operace pro jejich spojení.
U slovníků tomu tak není, takže si musíme pomoci operací
<strong>unpack</strong>, což ovšem není příliš čitelné a mohou nastat problémy
v&nbsp;případě vícenásobného použití stejných klíčů:</p>

<pre>
d1 = {"id": 1, "name": "Eda", "surname": "Wasserfall"}
d2 = {"foo": "F", "bar": "B", "baz": "Z"}
&nbsp;
d = {**d1, **d2}
&nbsp;
print(d)
</pre>

<p>Generátorová notace slovníku se zapisuje následujícím způsobem:</p>

<pre>
d = {x: x*2 for x in range(11) if x%3 != 0}
&nbsp;
print(d)
</pre>

<p>Ke standardním slovníkům (které se navíc mohou chovat v&nbsp;různých verzích
Pythonu odlišně) existuje velké množství variant s&nbsp;různými vlastnostmi,
včetně multislovníků a obousměrných mapování.  Některé z&nbsp;těchto variant si
popíšeme příště.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Obousměrné fronty</h2>

<p>Dalším &bdquo;klasickým&ldquo; kontejnerem podporovaným ve standardní
knihovně Pythonu, o němž se v&nbsp;dnešním článku zmíníme, je kontejner nazvaný
<i>deque</i>, což je jedna z&nbsp;možných implementací obousměrné fronty
(<i>double ended queue</i>). Jedná se tedy o kontejner, který podporuje operace
připojení nového prvku k&nbsp;oběma koncům fronty popř.&nbsp;naopak
k&nbsp;získání (a odstranění) prvku z&nbsp;libovolného konce. Podporovány jsou
ovšem navíc i dvě operace, které typicky u implementací obousměrných front
nenajdeme. Jedná se o operaci určenou pro rotaci prvků uložených ve frontě a
taktéž o operaci, která vede k&nbsp;otočení fronty, tj.&nbsp;ke změně pořadí
všech prvků, které jsou ve frontě uloženy.</p>

<p><div class="rs-tip-major">Poznámka: obousměrnou frontu je možné pochopitelně
použít i ve funkci zásobníku (<i>stack</i>), zde konkrétně persistentního
zásobníku. Z&nbsp;tohoto důvodu v&nbsp;Pyrsistent nenalezneme přímo kontejner
<i>stack</i> resp.&nbsp;<i>pstack</i>.</div></p>

<p>O tom, jestli je obousměrná fronta plnohodnotným kontejnerem, se přesvědčíme
stejným způsobem, jako u standardních kontejnerů &ndash; zjištěním zda
implementuje metodu <strong>__contains__</strong>:</p>

<pre>
&gt;&gt;&gt; <strong>from collections import deque</strong>
&nbsp;
&gt;&gt;&gt; <strong>dir(deque)</strong>
['__add__', '__class__', '__class_getitem__', '<i>__contains__</i>', '__copy__',
'__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__',
'__ge__', '__getattribute__', '__getitem__', '__getstate__', '__gt__',
'__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__',
'__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__',
'__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',
'__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__',
'append', 'appendleft', 'clear', 'copy', 'count', 'extend', 'extendleft',
'index', 'insert', 'maxlen', 'pop', 'popleft', 'remove', 'reverse', 'rotate']
</pre>

<p>Obousměrná fronta se vytváří konstruktorem <strong>deque</strong>, přičemž
již konstruktoru lze předat prvky, které se mají do fronty uložit. Tyto prvky
jsou předány ve formě n-tice, seznamu či množiny.</p>

<p>Využití seznamu pro konstrukci fronty:</p>

<pre>
from collections import deque
&nbsp;
d = deque(["foo", "bar", "baz"])
&nbsp;
print(d)
</pre>

<p>Výsledek:</p>

<pre>
deque(['foo', 'bar', 'baz'])
</pre>

<p>Využití n-tice pro konstrukci fronty:</p>

<pre>
from collections import deque
&nbsp;
d = deque(("foo", "bar", "baz"))
&nbsp;
print(d)
</pre>

<p>Výsledek by měl být totožný s&nbsp;předchozím příkladem:</p>

<pre>
deque(['foo', 'bar', 'baz'])
</pre>

<p>Využití množin pro konstrukci fronty:</p>

<pre>
from collections import deque
&nbsp;
d = deque({"foo", "bar", "baz"})
&nbsp;
print(d)
</pre>

<p>Výsledek by opět měl být totožný s&nbsp;předchozími dvěma příklady:</p>

<pre>
deque(['baz', 'bar', 'foo'])
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Přidání prvku do fronty zleva či zprava, vložení prvku do libovolného místa fronty</h2>

<p>V&nbsp;souvislosti s&nbsp;obousměrnými frontami je nutné nějakým způsobem
označit resp.&nbsp;pojmenovat oba konce fronty. V&nbsp;některých dokumentech
nebo knihovnách se setkáme s&nbsp;označením &bdquo;first&ldquo; a
&bdquo;last&ldquo; popř.&nbsp;&bdquo;head&ldquo; a &bdquo;tail&ldquo;, což však
může být matoucí. Namísto toho se Pythonu spíše setkáme s&nbsp;použitím slov
&bdquo;left&ldquo; a &bdquo;right&ldquo;, tj.&nbsp;jeden z&nbsp;konců fronty je
&bdquo;levý&ldquo; a druhý &bdquo;pravý&ldquo;.</p>

<p>Pro přidání prvku do fronty zprava slouží metoda <strong>append</strong>
(protože v&nbsp;jiných strukturách <strong>append</strong> přidává prvky na
konec, tedy v&nbsp;naší kultuře doprava):</p>

<pre>
from collections import deque
&nbsp;
d = deque(["a", "b", "c"])
print(d)
&nbsp;
d.append("bar")
print(d)
&nbsp;
d.append("baz")
print(d)
</pre>

<p>Výsledky ukazují, že se prvky přidaly do frontyzprava:</p>

<pre>
deque(['a', 'b', 'c'])
deque(['a', 'b', 'c', 'bar'])
deque(['a', 'b', 'c', 'bar', 'baz'])
</pre>

<p>Pro přidání prvku na levý konec fronty je určena metoda pojmenovaná
<strong>appendleft</strong>:</p>

<pre>
from collections import deque
&nbsp;
d = deque(["a", "b", "c"])
print(d)
&nbsp;
d.appendleft("bar")
print(d)
&nbsp;
d.appendleft("baz")
print(d)
</pre>

<p>Nyní budou prvky přidány zleva:</p>

<pre>
deque(['a', 'b', 'c'])
deque(['bar', 'a', 'b', 'c'])
deque(['baz', 'bar', 'a', 'b', 'c'])
</pre>

<p>Pro vložení prvku do libovolného místa ve frontě slouží metoda
<strong>insert</strong>, které je navíc nutné předat index prvku:</p>

<pre>
from collections import deque
&nbsp;
d = deque(["a", "b", "c"])
print(d)
&nbsp;
d.insert(1, "bar")
print(d)
&nbsp;
d.insert(3, "baz")
print(d)
</pre>

<p>V&nbsp;tomto případě budou prvky vloženy na druhé a čtvrté místo ve frontě
(prvky se indexují od nuly):</p>

<pre>
deque(['a', 'b', 'c'])
deque(['a', 'bar', 'b', 'c'])
deque(['a', 'bar', 'b', 'baz', 'c'])
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odstranění nejlevějšího či nejpravějšího prvku z&nbsp;fronty</h2>

<p><a href="#k08">V&nbsp;předchozí kapitole</a> jsme si ukázali, jak lze
přidávat prvky do obousměrné fronty. Opakem této operace je odebrání prvku
zleva nebo zprava. Tyto operace se jmenují <strong>pop</strong> a
<strong>popleft</strong>. Nejprve si ukažme vliv metody
<strong>pop</strong>:</p>

<pre>
from collections import deque
&nbsp;
d = deque(["foo", "bar", "baz"])
print(d)
&nbsp;
d.pop()
print(d)
&nbsp;
d.pop()
print(d)
</pre>

<p>Fronta se postupně zmenší tak, že se odstraní prvky zprava:</p>

<pre>
deque(['foo', 'bar', 'baz'])
deque(['foo', 'bar'])
deque(['foo'])
</pre>

<p>O odstranění prvků zleva se stará metoda pojmenovaná
<strong>popleft</strong>:</p>

<pre>
from collections import deque
&nbsp;
d = deque(["foo", "bar", "baz"])
print(d)
&nbsp;
d.popleft()
print(d)
&nbsp;
d.popleft()
print(d)
</pre>

<p>Povšimněte si rozdílů ve výsledcích oproti předchozímu skriptu:</p>

<pre>
deque(['foo', 'bar', 'baz'])
deque(['bar', 'baz'])
deque(['baz'])
</pre>

<p>V&nbsp;tomto případě jsou tedy prvky odstraňovány zleva (od začátku
fronty).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Metody <strong>reverse</strong> a <strong>rotate</strong></h2>

<p>Poslední dvě metody, s&nbsp;nimiž se v&nbsp;souvislosti se standardní
obousměrnou frontou seznámíme, jsou metody pro otočení všech prvků ve frontě a
taktéž pro rotaci prvků ve frontě (fronta se tedy bude chovat tak, jakoby se
jednalo o kruhový buffer &ndash; <i>ring buffer</i>). Obě zmíněné metody
modifikují původní frontu.</p>

<p>Otočení prvků ve frontě se provádí metodou <strong>reverse</strong>:</p>

<pre>
from collections import deque
&nbsp;
d = deque(["foo", "bar", "baz"])
print(d)
&nbsp;
d.reverse()
print(d)
</pre>

<p>Výsledkem bude fronta modifikovaná tak, že bude obsahovat stejné prvky, ale
v&nbsp;opačném pořadí:</p>

<pre>
deque(['foo', 'bar', 'baz'])
deque(['baz', 'bar', 'foo'])
</pre>

<p>Rotace prvků ve frontě je zajištěna metodou nazvanou
<strong>rotate</strong>:</p>

<pre>
from collections import deque
&nbsp;
d = deque(["foo", "bar", "baz"])
print(d)
&nbsp;
d.rotate()
print(d)
</pre>

<p>A takto vypadá výsledek:</p>

<pre>
deque(['foo', 'bar', 'baz'])
deque(['baz', 'foo', 'bar'])
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Multimnožiny (<i>multiset</i>)</h2>

<p>Jednou z&nbsp;nestandardních datových struktur sloužících pro uložení a
uchování hodnot, je takzvaná multimnožina (<i>multiset</i>). Jedná se o
upravenou formu klasického typu <strong>set</strong>, který byl popsán
v&nbsp;předchozích kapitolách. Ovšem zatímco u běžné množiny je zaručeno, že
každý prvek je v&nbsp;ní uložen maximálně jedenkrát, protože prvky musí být
unikátní, u multimnožin se pamatuje nejenom to, zda nějaký prvek obsahuje či
nikoli, ale navíc i počet uložených prvků se stejnou hodnotou. To je vlastnost,
kterou se multimnožina přibližuje standardnímu kontejneru
<strong>Counter</strong>. Jak multimnožinou, tak i právě zmíněným kontejnerem
<strong>Counter</strong> se budeme podrobněji zabývat v&nbsp;navazujícím
článku. Jedná se přitom o důležité kontejnery, protože poměrně ve velkém
množství kódů můžeme vidět snahu o novou implementaci multimnožiny či čítače
s&nbsp;využitím slovníků atd. (což je většinou zbytečné plýtvání časem).</p>

<p>Na závěr této kapitoly si ještě uveďme důkaz, že multimnožina je
z&nbsp;pohledu programovacího jazyka Python skutečným kontejnerem, tj.&nbsp;že
implementuje metodu <strong>__contains__</strong> (a tím pádem podporuje
operátor <strong>in</strong>):</p>

<pre>
&gt;&gt;&gt; <strong>from multiset import Multiset</strong>
&nbsp;
&gt;&gt;&gt; <strong>dir(Multiset)</strong>
&nbsp;
['__add__', '__and__', '__bool__', '__class__', <u>'__contains__'</u>,
'__copy__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__',
'__format__', '__ge__', '__getattribute__', '__getitem__', '__getstate__',
'__gt__', '__hash__', '__iand__', '__imul__', '__init__', '__init_subclass__',
'__ior__', '__isub__', '__iter__', '__ixor__', '__le__', '__len__', '__lt__',
'__module__', '__mul__', '__ne__', '__new__', '__or__', '__radd__', '__rand__',
'__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__ror__', '__rsub__',
'__rxor__', '__setattr__', '__setitem__', '__setstate__', '__sizeof__',
'__slots__', '__str__', '__sub__', '__subclasshook__', '__xor__',
'_as_mapping', '_as_multiset', '_elements', '_issubset', '_issuperset',
'_total', 'add', 'clear', 'combine', 'copy', 'difference', 'difference_update',
'discard', 'distinct_elements', 'from_elements', 'get', 'intersection',
'intersection_update', 'isdisjoint', 'issubset', 'issuperset', 'items',
'multiplicities', 'pop', 'remove', 'setdefault', 'symmetric_difference',
'symmetric_difference_update', 'times', 'times_update', 'union',
'union_update', 'update', 'values']
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Multislovníky (<i>multidict</i>)</h2>

<p>S&nbsp;multimnožinou do určité míry souvisí i další nestandardní typ
kontejneru, který se nazývá multislovník (<i>multidict</i>). Tento kontejner se
liší od běžných slovníků, v&nbsp;nichž je zaručena jednoznačnost klíčů, což
znamená, že klíč lze použít ve formě <i>selektoru</i> jediné hodnoty
(popř.&nbsp;samozřejmě klíč resp.&nbsp;dvojice klíč+hodnota vůbec nemusí ve
slovníku existovat). V&nbsp;multislovnících je tomu ovšem jinak, protože může
existovat větší množství dvojic klíč+hodnota se stejným klíčem.</p>

<p>I když to tak možná nemusí na první pohled vypadat, mají multislovníky
poměrně důležitou funkci, protože například mohou sloužit pro uložení HTTP
hlaviček posílaných společně s&nbsp;dotazem (či odpovědí) popř.&nbsp;pro
uložení parametrů dotazu, protože zde se může vyskytnout několik hodnot pod
stejným jménem. I s&nbsp;tímto datovým typem se podrobněji seznámíme
v&nbsp;navazujícím článku. Zde si jen pro úplnost ukažme, že i multislovník je
z&nbsp;pohledu programovacího jazyka Python skutečným kontejnerem:</p>

<pre>
&gt;&gt;&gt; <strong>from multidict import MultiDict</strong>
&nbsp;
&gt;&gt;&gt; <strong>dir(MultiDict)</strong>
['__class__', '__class_getitem__', '<u>__contains__</u>', '__delattr__',
'__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
'__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__',
'__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__',
'__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',
'__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'add', 'clear',
'copy', 'extend', 'get', 'getall', 'getone', 'items', 'keys', 'pop', 'popall',
'popitem', 'popone', 'setdefault', 'update', 'values']
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Balíček <strong>python-box</strong> zajišťující výběr hodnot s&nbsp;využitím klíčů nebo atributů</h2>

<p>V&nbsp;závěrečné části dnešního článku si popíšeme velmi užitečný balíček,
který se jmenuje <strong>python-box</strong>. Jedná se o balíček
s&nbsp;definicí třídy <strong>Box</strong>, která do značné míry napodobuje
chování standardního slovníku. Ovšem navíc umožňuje výběr hodnot ze slovníku
nikoli jen s&nbsp;využitím klíče, ale tak, jakoby se jednalo o atribut objektu.
To tedy znamená, že k&nbsp;hodnotě uložené v&nbsp;Boxu se jménem
<strong>b</strong> pod klíčem <strong>&bdquo;foo&ldquo;</strong> je možné
přistupovat následujícími dvěma způsoby:</p>

<pre>
b["foo"]
&nbsp;
b.foo
</pre>

<p>Jedná se o chování, které můžeme nalézt v&nbsp;programovacím jazyku Lua,
v&nbsp;němž je možné k&nbsp;prvkům uloženým k&nbsp;tabulkách taktéž přistupovat
přes klíč či přes atribut:</p>

<pre>
t = {}
&nbsp;
t.foo = 1
print(t.foo)
&nbsp;
t["foo"] = 2
print(t.foo)
&nbsp;
t.foo = nil
print(t["foo"])
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že oba způsoby zápisu
selektoru jsou v&nbsp;tomto případě ekvivalentní.</div></p>

<p>Na tomto místě vás asi napadlo, jak tento koncept může fungovat
v&nbsp;případě, že klíč neodpovídá syntaxi Pythonu. Python například
neumožňuje, aby atribut měl jméno &bdquo;0&ldquo;, &bdquo;my-test&ldquo; atd.
Kontejner <strong>Box</strong> dokáže tento problém řešit, i když jen do určité
míry, což si ukážeme v&nbsp;demonstračních příkladech.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instalace balíčku <strong>python-box</strong></h2>

<p>Vzhledem k&nbsp;tomu, že kontejner <strong>Box</strong> nepatří mezi
kontejnery definované ve standardní knihovně programovacího jazyka Python, je
nutné příslušný balíček doinstalovat. Není to nic složitého, protože nemá žádné
další závislosti:</p>

<pre>
$ <strong>pip3 install python-box</strong>
&nbsp;
Defaulting to user installation because normal site-packages is not writeable
Collecting python-box
  Downloading python_box-7.1.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (4.3 MB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 4.3/4.3 MB 3.4 MB/s eta 0:00:00
Installing collected packages: python-box
Successfully installed python-box-7.1.1
</pre>

<p>V&nbsp;interaktivní smyčce jazyka Python se přesvědčíme, že lze modul
<strong>box</strong> naimportovat a zobrazit si nápovědu ke třídě
<strong>Box</strong>:</p>

<pre>
Help on class Box in module box.box:
&nbsp;
class Box(builtins.dict)
 |  Box(*args: 'Any', default_box: 'bool' = False, default_box_attr: 'Any' = &lt;object object at 0x7f5254b84750&gt;, default_box_none_transform: 'bool' = True, default_box_create_on_get: 'bool' = True, frozen_box: 'bool' = False, camel_killer_box: 'bool' = False, conversion_box: 'bool' = True, modify_tuples_box: 'bool' = False, box_safe_prefix: 'str' = 'x', box_duplicates: 'str' = 'ignore', box_intact_types: 'Union[Tuple, List]' = (), box_recast: 'Optional[Dict]' = None, box_dots: 'bool' = False, box_class: "Optional[Union[Dict, Type['Box']]]" = None, box_namespace: 'Union[Tuple[str, ...], Literal[False]]' = (), **kwargs: 'Any')
 |  
 |  Improved dictionary access through dot notation with additional tools.
 |  
 |  :param default_box: Similar to defaultdict, return a default value
 |  :param default_box_attr: Specify the default replacement.
 |      WARNING: If this is not the default 'Box', it will not be recursive
 |  :param default_box_none_transform: When using default_box, treat keys with none values as absent. True by default
 |  :param default_box_create_on_get: On lookup of a key that doesn't exist, create it if missing
 |  :param frozen_box: After creation, the box cannot be modified
 |  :param camel_killer_box: Convert CamelCase to snake_case
 |  :param conversion_box: Check for near matching keys as attributes
 |  :param modify_tuples_box: Recreate incoming tuples with dicts into Boxes
 |  :param box_safe_prefix: Conversion box prefix for unsafe attributes
 |  :param box_duplicates: "ignore", "error" or "warn" when duplicates exists in a conversion_box
 |  :param box_intact_types: tuple of types to ignore converting
 |  :param box_recast: cast certain keys to a specified type
 |  :param box_dots: access nested Boxes by period separated keys in string
 |  :param box_class: change what type of class sub-boxes will be created as
 |  :param box_namespace: the namespace this (possibly nested) Box lives within
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Datová struktura <strong>Box</strong> je kontejnerem</h2>

<p>Na tomto místě už pravděpodobně nebude větším překvapením, že
<strong>Box</strong> je z&nbsp;pohledu programovacího jazyka Python
kontejnerem:</p>

<pre>
&gt;&gt;&gt; <strong>from box import Boxfrom box import Box</strong>
&gt;&gt;&gt; <strong>dir(Box)</strong>
['_Box__box_config', '_Box__convert_and_store', '_Box__get_default',
'_Box__recast', '__add__', '__annotations__', '__class__', '__class_getitem__',
'<u>__contains__</u>', '__copy__', '__deepcopy__', '__delattr__', '__delitem__',
'__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
'__getattr__', '__getattribute__', '__getitem__', '__getstate__', '__gt__',
'__hash__', '__iadd__', '__init__', '__init_subclass__', '__ior__', '__iter__',
'__le__', '__len__', '__lt__', '__module__', '__ne__', '__new__', '__or__',
'__radd__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__',
'__ror__', '__setattr__', '__setitem__', '__setstate__', '__sizeof__',
'__str__', '__sub__', '__subclasshook__', '__weakref__', '_conversion_checks',
'_protected_keys', '_safe_attr', 'clear', 'copy', 'from_json', 'from_msgpack',
'from_toml', 'from_yaml', 'fromkeys', 'get', 'items', 'keys', 'merge_update',
'pop', 'popitem', 'setdefault', 'to_dict', 'to_json', 'to_msgpack', 'to_toml',
'to_yaml', 'update', 'values']
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Příklady využití datové struktury <strong>Box</strong></h2>

<p>Podívejme se nyní na některé demonstrační příklady, které ukazují použití
kontejneru <strong>Box</strong> v&nbsp;praxi. Samotná konstrukce tohoto
kontejneru s&nbsp;předáním prvků může být realizována například tak, že se
konstruktoru předá existující (již zkonstruovaný) slovník:</p>

<pre>
from box import Box
&nbsp;
b = Box({"foo": 1, "bar": 2, "baz": None})
print(b)
</pre>

<p>Nyní, když již máme Box vytvořený, si můžeme otestovat, že k&nbsp;hodnotám
lze skutečně přistupovat jak přes klíč, tak i přes atribut:</p>

<pre>
from box import Box
&nbsp;
b = Box({"foo": 1, "bar": 2, "baz": None})
&nbsp;
print(b["foo"])
print(b.foo)
print()
&nbsp;
print(b["bar"])
print(b.bar)
print()
&nbsp;
print(b["baz"])
print(b.baz)
print()
</pre>

<p>Jak se bude Box chovat v&nbsp;případě, že se pokusíme o přístup
k&nbsp;neexistující hodnotě? Nejprve si vyzkoušejme čtení přes klíč:</p>

<pre>
from box import Box
&nbsp;
b = Box({"foo": 1, "bar": 2, "baz": None})
&nbsp;
print(b["unknown"])
</pre>

<p>To podle očekávání povede k&nbsp;vyhození výjimky, zde konkrétně výjimky
<strong>KeyError</strong>:</p>

<pre>
KeyError: 'unknown'
&nbsp;
The above exception was the direct cause of the following exception:
&nbsp;
Traceback (most recent call last):
  File "/home/ptisnovs/src/most-popular-python-libs/containers/box_03.py", line 5, in &lt;module&gt;
    print(b["unknown"])
          ~^^^^^^^^^^^
  File "box/box.py", line 619, in box.box.Box.__getitem__
box.exceptions.BoxKeyError: "'unknown'"
</pre>

<p>Příklad nyní pozměníme tak, že budeme přistupovat k&nbsp;neexistujícímu
prvku přes atribut:</p>

<pre>
from box import Box
&nbsp;
b = Box({"foo": 1, "bar": 2, "baz": None})
&nbsp;
print(b.unknown)
</pre>

<p>Opět dojde k&nbsp;vyhození výjimky, tentokrát ovšem typu
<strong>AttributeError</strong> a nikoli <strong>KeyError</strong>:</p>

<pre>
AttributeError: 'Box' object has no attribute 'unknown'
&nbsp;
The above exception was the direct cause of the following exception:
&nbsp;
Traceback (most recent call last):
  File "/home/ptisnovs/src/most-popular-python-libs/containers/box_04.py", line 5, in &lt;module&gt;
    print(b.unknown)
          ^^^^^^^^^
  File "box/box.py", line 647, in box.box.Box.__getattr__
box.exceptions.BoxKeyError: "'Box' object has no attribute 'unknown'"
</pre>

<p>Ve chvíli, kdy jména klíčů nelze převést na korektní jméno atributu, se může
zdát, že třídu Box není možné využít. Příkladem mohou být klíče uložené jako
celá čísla. Taková jména atributů ovšem není možné v&nbsp;Pythonu použít:</p>

<pre>
from box import Box
&nbsp;
b = Box({0: "foo", 1: "bar", 2: "baz"})
&nbsp;
print(b[0])
print(b[1])
print(b[2])
&nbsp;
print(b.0)
print(b.1)
print(b.2)
</pre>

<p>Ve skutečnosti ovšem atributy pro výběr prvků použít lze, ovšem je nutné
před problematická jména zapsat prefix. Výchozím prefixem je znak
&bdquo;x&ldquo;, takže následující demonstrační příklad je zcela korektní:</p>

<pre>
from box import Box
&nbsp;
b = Box({0: "foo", 1: "bar", 2: "baz"})
&nbsp;
print(b[0])
print(b[1])
print(b[2])
&nbsp;
print(b.x0)
print(b.x1)
print(b.x2)
</pre>

<p>Prefix si můžete zvolit, a to při konstrukci Boxu zadáním nepovinného
pojmenovaného parametru <strong>box_safe_prefix</strong>. Následující
demonstrační příklad je tedy opět zcela korektní:</p>

<pre>
from box import Box
&nbsp;
b = Box({0: "foo", 1: "bar", 2: "baz"}, box_safe_prefix="index_")
&nbsp;
print(b[0])
print(b[1])
print(b[2])
&nbsp;
print(b.index_0)
print(b.index_1)
print(b.index_2)
</pre>

<p>Ještě si ukažme průchod všemi hodnotami uloženými v&nbsp;boxu. Používá se
zde naprosto stejný přístup, jako v&nbsp;případě klasického slovníku:</p>

<pre>
from box import Box
&nbsp;
b = Box({"foo": 1, "bar": 2, "baz": None})
&nbsp;
for key, value in b.items():
    print(key, value)
</pre>

<p>Výsledky:</p>

<pre>
foo 1
bar 2
baz None
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Praktická ukázka: získání hodnot z&nbsp;několikanásobně vnořené datové struktury načtené z&nbsp;JSONu</h2>

<p>Podívejme se nyní na praktickou ukázku využití kontejneru Box. Budeme
potřebovat načíst následující datovou strukturu z&nbsp;JSONu a získat z&nbsp;ní
například jméno použité licence, což je atribut <strong>name</strong>
z&nbsp;podstruktury <strong>license</strong>, která je vnořená do struktury
<strong>info</strong>:</p>

<pre>
{
    "openapi": "3.0.0",
    "servers": [
        {
            "url": ""
        }
    ],
    "info": {
        "description": "A very simple REST API service",
        "version": "1.0.0",
        "title": "REST API Service",
        "termsOfService": "",
        "contact": {
            "name": "Pavel Tisnovsky"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        }
    },
    "tags": [],
    "paths": {
        "/": {
            "get": {
                "summary": "Returns valid HTTP 200 ok status when the service is ready",
                "description": "",
                "parameters": [],
                "operationId": "main",
                "responses": {
                    "default": {
                        "description": "Default response"
                    }
                }
            }
        },
        "/client/cluster": {
            "x-temp": {
                "summary": "Read list of all clusters from database and return it to a client",
                "description": "",
                "parameters": [],
                "operationId": "getClusters",
                "responses": {
                    "default": {
                        "description": "Default response"
                    }
                }
            },
            "get": {
                "summary": "Read list of all clusters from database and return it to a client",
                "description": "",
                "parameters": [],
                "operationId": "getClusters",
                "responses": {
                    "default": {
                        "description": "Default response"
                    }
                }
            }
        },
        "/client/cluster/{name}": {
            "get": {
                "summary": "Read cluster specified by its ID and return it to a client",
                "description": "",
                "parameters": [],
                "operationId": "getClusterById",
                "responses": {
                    "default": {
                        "description": "Default response"
                    }
                }
            },
            "post": {
                "summary": "Create a record with new cluster in a database. The updated list of all clusters is returned to client",
                "description": "",
                "parameters": [],
                "operationId": "newCluster",
                "responses": {
                    "default": {
                        "description": "Default response"
                    }
                }
            },
            "delete": {
                "summary": "Delete a cluster specified by its ID",
                "description": "",
                "parameters": [],
                "operationId": "deleteCluster",
                "responses": {
                    "default": {
                        "description": "Default response"
                    }
                }
            }
        },
        "/client/cluster/search": {
            "get": {
                "summary": "Search for a cluster specified by its ID or name",
                "description": "",
                "parameters": [
                    {
                        "name": "id",
                        "in": "query",
                        "required": false,
                        "schema": {
                            "type": "string"
                        },
                        "description": "Cluster ID",
                        "allowEmptyValue": true
                    },
                    {
                        "name": "name",
                        "in": "query",
                        "required": false,
                        "schema": {
                            "type": "string"
                        },
                        "description": "Cluster name",
                        "allowEmptyValue": true
                    }
                ],
                "operationId": "searchCluster",
                "responses": {
                    "default": {
                        "description": "Default response"
                    }
                }
            }
        }
    },
    "externalDocs": {
        "description": "Please see foo bar baz",
        "url": "https://godoc.org/..."
    },
    "security": []
}
</pre>

<p>Soubor ve formátu JSON načteme s&nbsp;využitím <strong>json.load</strong> a
následně můžeme takto získaný slovník předat konstruktoru <strong>Box</strong>.
V&nbsp;dalším kroku již lze přistoupit k&nbsp;potřebnému atributu, a to buď
s&nbsp;využitím klíčů v&nbsp;roli selektorů nebo pomocí tečkové notace (a tedy
atributů):</p>

<pre>
from json import load
from box import Box
&nbsp;
with open("openapi.json") as fin:
    j = load(fin)
&nbsp;
print(j)
print()
&nbsp;
b = Box(j)
&nbsp;
print(b["info"]["license"]["name"])
print(b.info.license.name)
</pre>

<p>Výsledkem by měly být následující dva řádky s&nbsp;totožným obsahem:</p>

<pre>
Apache 2.0
Apache 2.0
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Klíč složený z&nbsp;několika selektorů</h2>

<p>V&nbsp;případě, že do konstruktoru <strong>Box</strong> předáme nepovinný
argument <strong>box_dots</strong> nastavený na hodnotu <strong>True</strong>,
bude možné používat &bdquo;složený klíč&ldquo;. Takový klíč obsahuje několik
selektorů (pro vnořené struktury), přičemž tyto selektory jsou v&nbsp;klíči
odděleny tečkou. Samotný klíč je ovšem stále realizován jediným řetězcem:</p>

<pre>
from json import load
from box import Box
&nbsp;
with open("openapi.json") as fin:
    j = load(fin)
&nbsp;
print(j)
print()
&nbsp;
b = Box(j, box_dots=True)
&nbsp;
print(b["info"]["license"]["name"])
print(b.info.license.name)
print(b["info.license.name"])
</pre>

<p>Výsledkem bude v&nbsp;tomto případě opět jméno licence, tentokrát získané
třemi způsoby (a pochopitelně stále stejné):</p>

<pre>
Apache 2.0
Apache 2.0
Apache 2.0
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Odkazy na jednotlivé příklady jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>std_tuple_01.py</td><td>konstrukce n-tic</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_01.py</a></td></tr>
<tr><td> 2</td><td>std_tuple_02.py</td><td>spojování n-tic operátorem +</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_02.py</a></td></tr>
<tr><td> 3</td><td>std_tuple_03.py</td><td>opakování obsahu n-tice operátorem *</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_03.py</a></td></tr>
<tr><td> 4</td><td>std_tuple_04.py</td><td>operátor <strong>in</strong> a n-tice</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_04.py</a></td></tr>
<tr><td> 5</td><td>std_tuple_05.py</td><td>generátorová notace a n-tice</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_tuple_05.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>std_list_01.py</td><td>konstrukce seznamů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_01.py</a></td></tr>
<tr><td> 7</td><td>std_list_02.py</td><td>spojování seznamů operátorem +</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_02.py</a></td></tr>
<tr><td> 8</td><td>std_list_03.py</td><td>opakování obsahu seznamu operátorem *</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_03.py</a></td></tr>
<tr><td> 9</td><td>std_list_04.py</td><td>řazení prvků seznamu: funkcionální a imperativní přístup</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_04.py</a></td></tr>
<tr><td>10</td><td>std_list_05.py</td><td>otočení prvků v&nbsp;seznamu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_05.py</a></td></tr>
<tr><td>11</td><td>std_list_06.py</td><td>generátorová notace seznamů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_list_06.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>std_set_01.py</td><td>konstrukce množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_01.py</a></td></tr>
<tr><td>13</td><td>std_set_02.py</td><td>operace nad množinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_02.py</a></td></tr>
<tr><td>14</td><td>std_set_03.py</td><td>operace nad množinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_03.py</a></td></tr>
<tr><td>15</td><td>std_set_04.py</td><td>rozdíl mezi operacemi <strong>discard</strong> a <strong>remove</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_04.py</a></td></tr>
<tr><td>16</td><td>std_set_05.py</td><td>generátorová notace množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_set_05.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>std_dict_01.py</td><td>konstrukce slovníků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_01.py</a></td></tr>
<tr><td>18</td><td>std_dict_02.py</td><td>selektory, operace <strong>del</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_02.py</a></td></tr>
<tr><td>19</td><td>std_dict_03.py</td><td>chování v&nbsp;případě, že mazaný prvek ve slovníku neexistuje</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_03.py</a></td></tr>
<tr><td>20</td><td>std_dict_04.py</td><td>spojení dvou slovníků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_04.py</a></td></tr>
<tr><td>21</td><td>std_dict_05.py</td><td>generátorová notace slovníků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_dict_05.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>std_deque_01.py</td><td>konstrukce obousměrné fronty ze seznamu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_01.py</a></td></tr>
<tr><td>23</td><td>std_deque_02.py</td><td>konstrukce obousměrné fronty z&nbsp;n-tice</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_02.py</a></td></tr>
<tr><td>24</td><td>std_deque_03.py</td><td>konstrukce obousměrné fronty z&nbsp;množiny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_03.py</a></td></tr>
<tr><td>25</td><td>std_deque_04.py</td><td>operace <strong>append</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_04.py</a></td></tr>
<tr><td>26</td><td>std_deque_05.py</td><td>operace <strong>appendleft</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_05.py</a></td></tr>
<tr><td>27</td><td>std_deque_06.py</td><td>operace <strong>insert</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_06.py</a></td></tr>
<tr><td>28</td><td>std_deque_07.py</td><td>operace <strong>pop</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_07.py</a></td></tr>
<tr><td>29</td><td>std_deque_08.py</td><td>operace <strong>popleft</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_08.py</a></td></tr>
<tr><td>30</td><td>std_deque_09.py</td><td>otočení prvků ve frontě</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_09.py</a></td></tr>
<tr><td>31</td><td>std_deque_10.py</td><td>rotace prvků ve frontě</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/std_deque_10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>box_01.py</td><td>konstrukce boxu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_01.py</a></td></tr>
<tr><td>33</td><td>box_02.py</td><td>přístup k&nbsp;prvkům boxu přes klíč i atribut</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_02.py</a></td></tr>
<tr><td>34</td><td>box_03.py</td><td>chování při pokusu o přístup k&nbsp;neexistující hodnotě přes klíč</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_03.py</a></td></tr>
<tr><td>35</td><td>box_04.py</td><td>chování při pokusu o přístup k&nbsp;neexistující hodnotě přes atribut</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_04.py</a></td></tr>
<tr><td>36</td><td>box_05.py</td><td>chování při použití klíčů, které nejsou platnými názvy atributů v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_05.py</a></td></tr>
<tr><td>37</td><td>box_06.py</td><td>náhrada nekorektních názvů klíčů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_06.py</a></td></tr>
<tr><td>38</td><td>box_07.py</td><td>explicitní prefix u nekorektních názvů klíčů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_07.py</a></td></tr>
<tr><td>39</td><td>box_08.py</td><td>načtení datového souboru, přístup k&nbsp;prvkům přes klíče i atributy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_08.py</a></td></tr>
<tr><td>40</td><td>box_09.py</td><td>využití klíče s&nbsp;tečkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_09.py</a></td></tr>
<tr><td>41</td><td>box_10.py</td><td>iterace přes prvky uložené do boxu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/box_10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>42</td><td>openapi.json</td><td>datový soubor používaný v&nbsp;některých demonstračních příkladech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/containers/openapi.json">https://github.com/tisnik/most-popular-python-libs/blob/master/containers/openapi.json</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>collections — Container datatypes<br />
<a href="https://docs.python.org/3/library/collections.html">https://docs.python.org/3/library/collections.html</a>
</li>

<li>Balíček multidict na PyPi<br />
<a href="https://pypi.org/project/multidict/">https://pypi.org/project/multidict/</a>
</li>

<li>Balíček multiset na PyPi<br />
<a href="https://pypi.org/project/multiset/">https://pypi.org/project/multiset/</a>
</li>

<li>Repositář balíčku multidict<br />
<a href="https://github.com/aio-libs/multidict">https://github.com/aio-libs/multidict</a>
</li>

<li>Repositář balíčku bidict<br />
<a href="https://github.com/jab/bidict">https://github.com/jab/bidict</a>
</li>

<li>Dokumentace k&nbsp;balíčku bidict<br />
<a href="https://bidict.readthedocs.io/en/main/">https://bidict.readthedocs.io/en/main/</a>
</li>

<li>Repositář balíčku DottedDict<br />
<a href="https://github.com/carlosescri/DottedDict">https://github.com/carlosescri/DottedDict</a>
</li>

<li>Repositář balíčku Box<br />
<a href="https://github.com/cdgriffith/Box">https://github.com/cdgriffith/Box</a>
</li>

<li>Wiki (dokumentace) balíčku Box<br />
<a href="https://github.com/cdgriffith/Box/wiki">https://github.com/cdgriffith/Box/wiki</a>
</li>

<li>Persistent data structure<br />
<a href="https://en.wikipedia.org/wiki/Persistent_data_structure">https://en.wikipedia.org/wiki/Persistent_data_structure</a>
</li>

<li>Collections (Python)<br />
<a href="https://docs.python.org/3/library/collections.abc.html">https://docs.python.org/3/library/collections.abc.html</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Operátory a asociativní pole v&nbsp;jazyku Lua<br />
<a href="https://www.root.cz/clanky/operatory-a-asociativni-pole-v-jazyku-lua/">https://www.root.cz/clanky/operatory-a-asociativni-pole-v-jazyku-lua/</a>
</li>

<li>Python MultiDict Example: Map a Key to Multiple Values<br />
<a href="https://howtodoinjava.com/python-datatypes/python-multidict-examples/">https://howtodoinjava.com/python-datatypes/python-multidict-examples/</a>
</li>

<li>Immutable object<br />
<a href="https://en.wikipedia.org/wiki/Immutable_object">https://en.wikipedia.org/wiki/Immutable_object</a>
</li>

<li>pyrsistent na PyPi<br />
<a href="https://pypi.org/project/pyrsistent/">https://pypi.org/project/pyrsistent/</a>
</li>

<li>pyrsistent na GitHubu<br />
<a href="https://github.com/tobgu/pyrsistent">https://github.com/tobgu/pyrsistent</a>
</li>

<li>Dokumentace knihovny pyrsistent<br />
<a href="https://pyrsistent.readthedocs.io/en/latest/index.html">https://pyrsistent.readthedocs.io/en/latest/index.html</a>
</li>

<li>pyrthon na GitHubu<br />
<a href="https://github.com/tobgu/pyrthon/">https://github.com/tobgu/pyrthon/</a>
</li>

<li>Mori na GitHubu<br />
<a href="https://github.com/swannodette/mori">https://github.com/swannodette/mori</a>
</li>

<li>Mori: popis API (dokumentace)<br />
<a href="http://swannodette.github.io/mori/">http://swannodette.github.io/mori/</a>
</li>

<li>Mori: Benchmarking<br />
<a href="https://github.com/swannodette/mori/wiki/Benchmarking">https://github.com/swannodette/mori/wiki/Benchmarking</a>
</li>

<li>Functional data structures in JavaScript with Mori<br />
<a href="http://sitr.us/2013/11/04/functional-data-structures.html">http://sitr.us/2013/11/04/functional-data-structures.html</a>
</li>

<li>Immutable.js<br />
<a href="https://facebook.github.io/immutable-js/">https://facebook.github.io/immutable-js/</a>
</li>

<li>Understanding Clojure's Persistent Vectors, pt. 1<br />
<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">http://hypirion.com/musings/understanding-persistent-vector-pt-1</a>
</li>

<li>Hash array mapped trie (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">https://en.wikipedia.org/wiki/Hash_array_mapped_trie</a>
</li>

<li>Java theory and practice: To mutate or not to mutate?<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html">http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html</a>
</li>

<li>Efficient persistent (immutable) data structures<br />
<a href="https://persistent.codeplex.com/">https://persistent.codeplex.com/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

