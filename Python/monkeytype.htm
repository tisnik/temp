<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Typová inference v&nbsp;Pythonu prováděná v&nbsp;runtime</a></p>
<p><a href="#k02">2. Princip činnosti nástroje <i>MonkeyType</i></a></p>
<p><a href="#k03">3. Instalace nástroje <i>MonkeyType</i></a></p>
<p><a href="#k04">4. Modul, který budeme zkoumat</a></p>
<p><a href="#k05">5. Zavolání funkcí z&nbsp;analyzovaného modulu</a></p>
<p><a href="#k06">6. Výsledky analýzy uložené v&nbsp;databázi</a></p>
<p><a href="#k07">*** 7. Vygenerování stub souboru, automatické přidání typových informací do analyzovaného modulu</a></p>
<p><a href="#k08">*** 8. Volání funkcí z&nbsp;analyzovaného modulu s&nbsp;různými parametry</a></p>
<p><a href="#k09">*** 9. Automatické přidání typů k&nbsp;algoritmu výpočtu Ackermannovy funkce</a></p>
<p><a href="#k10">10. Postup při manuální nebo automatizované úpravě stávajících projektů bez typových anotací</a></p>
<p><a href="#k11">11. Zdrojový kód po základním refaktoringu, ovšem bez typových informací</a></p>
<p><a href="#k12">*** 12. Analýza projektu</a></p>
<p><a href="#k13">*** 13. Výsledek po přidání typových informací</a></p>
<p><a href="#k14">*** 14. Kontrola nástrojem Mypy</a></p>
<p><a href="#k15">*** 15. Problematické chování nástroje <i>MonkeyType</i></a></p>
<p><a href="#k16">*** 16. n-tice s&nbsp;mnoha prvky</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na další články o typových anotacích v&nbsp;Pythonu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Typová inference v&nbsp;Pythonu prováděná v&nbsp;runtime</h2>

<p>Na stránkách Roota jsme se již několikrát zabývali problematikou typových
anotací (<i>type annotations</i>, <i>type hints</i>) v&nbsp;programovacím
jazyku Python (viz též odkazy na příslušné články uvedené <a
href="#k19">v&nbsp;devatenácté kapitole</a>). Připomeňme si, že se jedná o
rozšíření jazyka Python o novou syntaxi i sémantiku, která umožňuje
<i>dobrovolně</i> (a klidně jen na určitých místech v&nbsp;programovém kódu)
specifikovat typy proměnných, argumentů funkcí a metod, návratové typy funkcí a
metod, ale i generické typy vztažené ke třídám a funkcím. Tyto přidané typové
informace se, i když je standardní CPython prakticky ignoruje, již dnes
používají k&nbsp;několika účelům. Především k&nbsp;zajištění korektnosti
zdrojových kódů z&nbsp;pohledu typového systému (do funkce akceptující řetězec
nelze předat celé číslo atd.), ale taktéž k&nbsp;lepším optimalizacím, které
díky těmto poměrně důležitým informacím mohou provádět AOT (<i>ahead of
time</i>) a JIT (<i>just in time</i>) překladače Pythonu. A v&nbsp;neposlední
řadě je informace o typech užitečným prvkem samodokumentujícího se kódu a
využívají ji některá integrovaná vývojová prostředí (a LSP).</p>

<p>Taktéž jsme si již v&nbsp;předchozích článcích řekli, že nástroje typu
<i>Mypy</i> do jisté míry dokážou provádět <i>typovou inferenci</i>,
tj.&nbsp;zjištění, jakého typu mají být například argumenty funkcí nebo metod
na základě detekce, s&nbsp;jakými parametry (resp.&nbsp;jejich typy) je funkce
volána. Ovšem tato typová inference je v&nbsp;Mypy omezena na statickou
analýzu. Zejména pro starší zdrojové kódy, které neobsahují typové anotace, by
však bylo zajímavé a užitečné použít nějaký nástroj, který tyto typové anotace
dokáže do zdrojového kódu automaticky či alespoň poloautomaticky přidat, a to
na základě analýzy provedené za běhu aplikace (<i>runtime</i>). Tímto způsobem
by bylo možné zjistit, jak je programový kód používaný reálně. A právě taková
funkcionalita je realizována v&nbsp;nástroji <i>MonkeyType</i>, s&nbsp;nímž se
seznámíme v&nbsp;dnešním článku.</p>

<p><div class="rs-tip-major">Poznámka: hned na úvod je nutné předeslat, že
výsledky analýzy provedené nástrojem <i>MonkeyType</i> nemusí být vždy dokonalé
nebo ucelené a mnohdy je tedy nutné provést ruční úpravy. Ostatně i v&nbsp;IT
platí, že nic není zcela zadarmo.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Princip činnosti nástroje <i>MonkeyType</i></h2>

<p>Pojďme si nyní alespoň ve stručnosti naznačit, jak vlastně nástroj
<i>MonkeyType</i> pracuje. Není to ve skutečnosti nic složitého (minimálně ne
v&nbsp;ekosystému Pythonu, který nabízí plnohodnotnou introspekci). Nástroji
<i>MonkeyType</i> je nutné předat jméno skriptu, který se má spustit. Skript
(což může být spouštěcí skript i rozsáhlého projektu) je následně skutečně
spuštěn, ovšem MonkeyType přitom sleduje volání všech funkcí a metod. Průběžně
si zaznamenává jak konkrétní typy předaných hodnot, tak i typy návratových
hodnot. Tyto informace jsou uloženy do lokální databáze SQLite, z&nbsp;níž se
posléze mohou přečíst, analyzovat a dále zpracovat. Jakmile je skript dokončen
(lze ho totiž pochopitelně spustit vícekrát, například s&nbsp;odlišnými
parametry atd.), můžeme MonkeyType nechat provést tři operace:</p>

<ol>

<li>Vypsat si jména všech modulů, jejichž funkce a metody byly volány.</li>

<li>Nechat si vygenerovat takzvaný <i>stub</i> soubor s&nbsp;informacemi o
typech parametrů atd. Tento soubor je možné zpracovat dalšími nástroji
(například ho podporuje i výše zmíněný <i>Mypy</i> atd.), popř.&nbsp;se může
stát součástí projektu &ndash; typové informace tedy budou odděleny od
programového kódu.</li>

<li>Alternativně je možné si nechat přidat informace o typech přímo do
originálních zdrojových kódů. Výsledek je pochopitelně možné upravit či
v&nbsp;některých případech je spíše bude nutné opravit. A výsledek by měl
projít (striktní) statickou analýzou nástrojem <i>Mypy</i>.</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace nástroje <i>MonkeyType</i></h2>

<p>Ve druhé části článku si ukážeme činnost <i>MonkeyType</i> prakticky, na
několika demonstračních příkladech. Samotná instalace tohoto nástroje je snadná
a rychlá, protože má jen minimum závislostí. Pro jeho instalaci můžeme použít
standardní utilitu <strong>pip</strong> popř.&nbsp;<strong>pip3</strong> (na
systémech s&nbsp;více instalacemi Pythonu) a provést instalaci pouze pro
aktivního uživatele (přepínač <strong>--user</strong>):</p>

<pre>
$ <strong>pip3 install --user monkeytype</strong>
&nbsp;
Collecting monkeytype
  Downloading MonkeyType-23.3.0-py3-none-any.whl (40 kB)
     |████████████████████████████████| 40 kB 1.2 MB/s 
Requirement already satisfied: mypy-extensions in ./.local/lib/python3.8/site-packages (from monkeytype) (1.0.0)
Collecting libcst&gt;=0.4.4
  Downloading libcst-1.1.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.2 MB)
     |████████████████████████████████| 3.2 MB 1.2 MB/s 
Requirement already satisfied: typing-extensions&gt;=3.7.4.2 in ./.local/lib/python3.8/site-packages (from libcst&gt;=0.4.4-&gt;monkeytype) (4.7.1)
Requirement already satisfied: pyyaml&gt;=5.2 in /usr/lib/python3/dist-packages (from libcst&gt;=0.4.4-&gt;monkeytype) (5.3.1)
Collecting typing-inspect&gt;=0.4.0
  Downloading typing_inspect-0.9.0-py3-none-any.whl (8.8 kB)
Installing collected packages: typing-inspect, libcst, monkeytype
Successfully installed libcst-1.1.0 monkeytype-23.3.0 typing-inspect-0.9.0
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se mj.&nbsp;jako
tranzitivní závislost instaluje i balíček nazvaný <strong>libcst</strong>.
Jedná se o velmi zajímavou a užitečnou knihovnu používanou pro transformaci
zdrojových kódů, ke které se ještě vrátíme v&nbsp;samostatném článku.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Modul, který budeme zkoumat</h2>

<p>První modul naprogramovaný v&nbsp;jazyce Python, který budeme zkoumat a
zjišťovat, s&nbsp;jakými typy parametrů jsou volané v&nbsp;něm definované
funkce, je velmi malý (až triviální). Obsahuje pouze dvě funkce nazvané
<strong>add</strong> a <strong>inc</strong>. U těchto funkcí nejsou uvedeny
žádné typové informace (což je v&nbsp;Pythonu stále obvyklé), což znamená, že
například první funkci můžeme volat s&nbsp;parametry typu celé číslo,
s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou, seznamy, řetězci, libovolnými
objekty, v&nbsp;jejichž třídě je přetížen operátor <strong>+</strong> atd.:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
&nbsp;
def <strong>add</strong>(a, b):
    return a + b
&nbsp;
&nbsp;
def <strong>inc</strong>(a):
    return a + 1
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;rámci dalších kapitol budeme
pochopitelně zkoumat složitější zdrojový kód, který navíc bude obsahovat různé
datové typy.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zavolání funkcí z&nbsp;analyzovaného modulu</h2>

<p>Modul <strong>adder</strong> je uložen v&nbsp;samostatném adresáři se
stejným jménem (tedy obsahuje jen dvojici souborů
<strong>adder/__init.py__</strong> a <strong>adder/adder.py</strong>).
V&nbsp;aktuálním adresáři vytvoříme nějaký pomocný skript, například
pojmenovaný <strong>test_adder_1.py</strong>. V&nbsp;tomto skriptu
naimportujeme volané funkce z&nbsp;modulu <strong>adder</strong> a posléze tyto
funkce skutečně zavoláme. Povšimněte si, že volaným funkcím předáváme hodnoty
typu <strong>int</strong> (celá čísla):</p>

<pre>
from adder.adder import add, inc
&nbsp;
print(add(1, 2))
print(inc(41))
</pre>

<p>Nyní nastává důležitý okamžik. Spustíme tento testovací skript, ale nikoli
přímo (<strong>python test_adder_1.py</strong>), ale nepřímo přes nástroj
<i>MonkeyType</i> příkazem <strong>run</strong>:</p>

<pre>
$ <strong>monkeytype run test_adder_1.py</strong>
</pre>

<p>Skript se zdánlivě spustí obvyklým způsobem; ostatně vypíše i očekávané
výsledky:</p>

<pre>
3
42
</pre>

<p>Ovšem povšimněte si, že kromě toho vznikl v&nbsp;aktuálním adresáři i soubor
<strong>monkeytype.sqlite3</strong>. Ten využijeme v&nbsp;dalších krocích.</p>

<p><div class="rs-tip-major">Poznámka: je zde ještě jeden rozdíl &ndash;
analyzovaná aplikace běží pomaleji, v&nbsp;některých případech až o řád
pomaleji, než bez použití <i>MonkeyType</i>!</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledky analýzy uložené v&nbsp;databázi</h2>

<p>Příkazem <strong>list-modules</strong> předaného nástroji <i>MonkeyType</i>
si můžeme nechat vypsat plná jména všech modulů, jejichž funkce a metody byly
při analýze skriptu (projektu) volány. V&nbsp;našem konkrétním případě bychom
měli získat pouze jméno jediného modulu:</p>

<pre>
$ <strong>monkeytype list-modules</strong>
&nbsp;
adder.adder
</pre>

<p>Informace o volaných funkcích a metodách (včetně jejich modulu) jsou uloženy
v&nbsp;lokální SQLite databázi, konkrétně v&nbsp;souboru se jménem
<strong>monkeytype.sqlite3</strong>. Nic nám pochopitelně nebrání v&nbsp;tom si
obsah této databáze prohlédnout. Použijeme k&nbsp;tomu klienta
<strong>sqlite3</strong>. Nejprve databázový soubor otevřeme:</p>

<pre>
$ <strong>sqlite3 monkeytype.sqlite3</strong>
&nbsp;
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
</pre>

<p>Dále si necháme vypsat jména všech tabulek v&nbsp;databázi:</p>

<pre>
sqlite&gt; <strong>.tables</strong>
&nbsp;
monkeytype_call_traces
</pre>

<p>Vidíme, že zde existuje jen jediná tabulka, jejíž schéma je do značné míry
samopopisné:</p>

<pre>
sqlite&gt; <strong>.schema monkeytype_call_traces</strong>
&nbsp;
CREATE TABLE monkeytype_call_traces (
  created_at  TEXT,
  module      TEXT,
  qualname    TEXT,
  arg_types   TEXT,
  return_type TEXT,
  yield_type  TEXT);
</pre>

<p>Vypišme si obsah této tabulky:</p>

<pre>
sqlite&gt; <strong>select * from monkeytype_call_traces ;</strong>
&nbsp;
2023-12-30 14:16:19.170512|adder.adder|add|{"a": {"module": "builtins", "qualname": "int"}, "b": {"module": "builtins", "qualname": "int"}}|{"module": "builtins", "qualname": "int"}|
2023-12-30 14:16:19.170533|adder.adder|inc|{"a": {"module": "builtins", "qualname": "int"}}|{"module": "builtins", "qualname": "int"}|
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalších verzích nástroje
<i>MonkeyType</i> se schéma databáze může měnit. Už nyní existuje patch, který
se snaží schéma databáze normalizovat a taktéž omezit duplicitní záznamy (které
běžně vznikají).</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vygenerování stub souboru, automatické přidání typových informací do analyzovaného modulu</h2>

<p>S&nbsp;obsahem databáze však většinou není zapotřebí manipulovat přímo,
protože příslušné operace jsou již implementovány v&nbsp;nástroji
<i>MonkeyType</i>. Nejdříve si necháme vygenerovat takzvaný <i>stub</i> soubor,
který obsahuje pouze informace o datových typech proměnných a funkcí, nikoli
však jejich těla:</p>

<pre>
$ <strong>monkeytype stub adder.adder</strong>
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
def <strong>add</strong>(a: int, b: int) -&gt; int: ...
&nbsp;
&nbsp;
def <strong>inc</strong>(a: int) -&gt; int: ...
</pre>

<p><div class="rs-tip-major">Poznámka: </div></p>

<pre>
$ <strong>monkeytype apply adder.adder</strong>
</pre>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
def <strong>add</strong>(a: int, b: int) -&gt; int:
    return a+b
&nbsp;
def <strong>inc</strong>(a: int) -&gt; int:
    return a+1
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Volání funkcí z&nbsp;analyzovaného modulu s&nbsp;různými parametry</h2>

<p></p>

<pre>
from adder.adder import add, inc
&nbsp;
print(add(1, 2))
print(add("foo", "bar"))
print(add([1, 2, 3], [4, 5, 6]))
&nbsp;
print(inc(41))
print(inc(1.5))
</pre>

<p></p>

<pre>
sqlite&gt; <strong>select * from monkeytype_call_traces ;</strong>
&nbsp;
2023-12-30 14:19:27.525313|adder.adder|add|{"a": {"module": "builtins", "qualname": "int"}, "b": {"module": "builtins", "qualname": "int"}}|{"module": "builtins", "qualname": "int"}|
2023-12-30 14:19:27.525338|adder.adder|add|{"a": {"module": "builtins", "qualname": "str"}, "b": {"module": "builtins", "qualname": "str"}}|{"module": "builtins", "qualname": "str"}|
2023-12-30 14:19:27.525373|adder.adder|add|{"a": {"elem_types": [{"module": "builtins", "qualname": "int"}], "module": "typing", "qualname": "List"}, "b": {"elem_types": [{"module": "builtins", "qualname": "int"}], "module": "typing", "qualname": "List"}}|{"elem_types": [{"module": "builtins", "qualname": "int"}], "module": "typing", "qualname": "List"}|
2023-12-30 14:19:27.525387|adder.adder|inc|{"a": {"module": "builtins", "qualname": "int"}}|{"module": "builtins", "qualname": "int"}|
2023-12-30 14:19:27.525401|adder.adder|inc|{"a": {"module": "builtins", "qualname": "float"}}|{"module": "builtins", "qualname": "float"}|
</pre>


$ <strong>monkeytype stub adder.adder</strong>

<pre>
from typing import (
    List,
    Union,
)


def <strong>add</strong>(a: Union[int, List[int], str], b: Union[int, List[int], str]) -&gt; Union[int, List[int], str]: ...


def <strong>inc</strong>(a: Union[int, float]) -&gt; Union[int, float]: ...
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Automatické přidání typů k&nbsp;algoritmu výpočtu Ackermannovy funkce</h2>

<pre>
<i># Výpočet Ackermannovy funkce, založeno na konstrukci if</i>
&nbsp;
def <strong>A</strong>(m, n):
    <i>"""Ackermannova funkce."""</i>
    if m == 0:
        return n + 1
    if n == 0:
        return A(m - 1, 1)
    return A(m - 1, A(m, n - 1))
&nbsp;
&nbsp;
<i># otestování korektnosti výpočtu Ackermannovy funkce</i>
for m in range(4):
    for n in range(5):
        print(m, n, A(m, n))
</pre>

<pre>
import ackermann
&nbsp;
ackermann.A(3, 3)
</pre>

<pre>
<i># Výpočet Ackermannovy funkce, založeno na konstrukci if</i>
&nbsp;
def <strong>A</strong>(m: int, n: int) -&gt; int:
    <i>"""Ackermannova funkce."""</i>
    if m == 0:
        return n + 1
    if n == 0:
        return A(m - 1, 1)
    return A(m - 1, A(m, n - 1))
&nbsp;
&nbsp;
<i># otestování korektnosti výpočtu Ackermannovy funkce</i>
for m in range(4):
    for n in range(5):
        print(m, n, A(m, n))
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Postup při manuální nebo automatizované úpravě stávajících projektů bez typových anotací</h2>

<p>V&nbsp;článcích o knihovně Mypy jsme si ukázali, jakým způsobem by se mohlo
postupovat při úpravě stávajících projektů napsaných v&nbsp;Pythonu, které
prozatím nepoužívají typové anotace. Celý postup jsme shrnuli do několika
bodů:</p>

<ol>
<li>Refaktoring, ideálně tak, aby se nepoužívaly globální proměnné a globální kód</li>
<li>Použití Mypy pro nalezení chybějících typových anotací</li>
<li>Postupné doplnění typových anotací</li>
<li>Odstranění reálných chyb nalezených nástrojem Mypy</li>
</ol>

<p>Druhý, třetí i čtvrtý bod lze do značné míry automatizovat s&nbsp;využitím
nástroje <i>MonkeyType</i>. Ukážeme si to na stejném demonstračním příkladu, do
jakého jsme <i>ručně</i> přidávali typové informace. Nyní tuto operaci
ponecháme na nástroji <i>MonkeyType</i> a porovnáme výsledek s&nbsp;ruční
prací.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zdrojový kód po základním refaktoringu, ovšem bez typových informací</h2>

<p>Původní zdrojový kód demonstračního příkladu tak, jak byl kdysi ukázán
v&nbsp;článku o knihovně Pygame, naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/sprites1.py</a>.
Tento kód pochopitelně neobsahuje žádné typové informace (anotace) a bude ho
zapotřebí poněkud refaktorovat.</p>

<p>Při refaktoringu postupně některé části zdrojového kódu vložíme do funkcí a
zajistíme, aby se nepoužívaly globální proměnné (pouze globální
&bdquo;konstanty&ldquo;, i když koncept pravých konstant v&nbsp;Pythonu není).
Refaktorovaný kód sice stále nepoužívá typové anotace, ale už je na tuto
důležitou změnu již náležitě připraven:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import pygame
import sys
&nbsp;
<i># Nutno importovat kvůli konstantám QUIT atd.</i>
from pygame.locals import *
&nbsp;
<i># Velikost okna aplikace</i>
WIDTH = 320
HEIGHT = 240
&nbsp;
<i># Konstanty s n-ticemi představujícími základní barvy</i>
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GRAY = (128, 128, 128)
YELLOW = (255, 255, 0)
&nbsp;
CAPTION = "Sprites in Pygame"
&nbsp;
&nbsp;
<i># Třída představující sprite zobrazený jako jednobarevný čtverec.</i>
class <strong>BlockySprite</strong>(pygame.sprite.Sprite):
    <i># Konstruktor</i>
    def <strong>__init__</strong>(self, color, size, x, y):
        <i># Nejprve je nutné zavolat konstruktor předka,</i>
        <i># tj. konstruktor třídy pygame.sprite.Sprite:</i>
        pygame.sprite.Sprite.__init__(self)
&nbsp;
        <i># Vytvoření obrázku představujícího vizuální obraz spritu:</i>
        self.image = pygame.Surface([size, size])
        self.image.fill(color)
&nbsp;
        <i># Vytvoření obalového obdélníku</i>
        <i># (velikost se získá z rozměru obrázku)</i>
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
&nbsp;
        <i># Počáteční rychlost spritu</i>
        self.speed_x = 0
        self.speed_y = 0
&nbsp;
    <i># Nastavení barvy spritu, který kolidoval s hráčem</i>
    def <strong>yellowColor</strong>(self):
        self.image.fill(YELLOW)
&nbsp;
    <i># Nastavení barvy spritu, který nekolidoval s hráčem</i>
    def <strong>grayColor</strong>(self):
        self.image.fill(GRAY)
&nbsp;
&nbsp;
def <strong>initDisplay</strong>(caption):
    <i># Vytvoření okna pro vykreslování</i>
    display = pygame.display.set_mode([WIDTH, HEIGHT])
&nbsp;
    <i># Nastavení titulku okna</i>
    pygame.display.set_caption(caption)
&nbsp;
    return display
&nbsp;
&nbsp;
def <strong>createSprites</strong>():
    <i># Objekt sdružující všechny sprity</i>
    all_sprites = pygame.sprite.Group()
&nbsp;
    <i># Objekt sdružující všechny sprity kromě hráče</i>
    all_sprites_but_player = pygame.sprite.Group()
&nbsp;
    <i># Vytvoření několika typů spritů</i>
    <i>#                    barva  x   y velikost</i>
    wall1 = BlockySprite(GRAY, 50, 10, 10)
    wall2 = BlockySprite(GRAY, 15, 100, 100)
    wall3 = BlockySprite(GRAY, 15, 100, 150)
    wall4 = BlockySprite(GRAY, 15, 200, 100)
    wall5 = BlockySprite(GRAY, 15, 200, 150)
    wall6 = BlockySprite(GRAY, 15, 150, 100)
    wall7 = BlockySprite(GRAY, 15, 150, 150)
    player = BlockySprite(RED, 40, WIDTH / 2 - 20, HEIGHT / 2 - 20)
&nbsp;
    <i># Přidání několika dalších spritů do seznamu</i>
    <i># (jen jeden sprite - ten poslední - bude ve skutečnosti pohyblivý)</i>
    all_sprites.add(wall1)
    all_sprites.add(wall2)
    all_sprites.add(wall3)
    all_sprites.add(wall4)
    all_sprites.add(wall5)
    all_sprites.add(wall6)
    all_sprites.add(wall7)
    all_sprites.add(player)
&nbsp;
    <i># Seznam všech nepohyblivých spritů</i>
    all_sprites_but_player.add(wall1)
    all_sprites_but_player.add(wall2)
    all_sprites_but_player.add(wall3)
    all_sprites_but_player.add(wall4)
    all_sprites_but_player.add(wall5)
    all_sprites_but_player.add(wall6)
    all_sprites_but_player.add(wall7)
&nbsp;
    return all_sprites, all_sprites_but_player, player
&nbsp;
&nbsp;
<i># Posun všech spritů ve skupině na základě jejich rychlosti</i>
def <strong>move_sprites</strong>(sprite_group, playground_width, playground_height):
    for sprite in sprite_group:
        <i># Posun spritu</i>
        sprite.rect.x = sprite.rect.x + sprite.speed_x
        sprite.rect.y = sprite.rect.y + sprite.speed_y
        <i># Kontrola, zda sprite nenarazil do okrajů okna</i>
        if sprite.rect.x &lt; 0:
            sprite.rect.x = 0
            sprite.speed_x = 0
        if sprite.rect.x + sprite.rect.width &gt; playground_width:
            sprite.rect.x = playground_width - sprite.rect.width
            sprite.speed_x = 0
        if sprite.rect.y &lt; 0:
            sprite.rect.y = 0
            sprite.speed_y = 0
        if sprite.rect.y + sprite.rect.height &gt; playground_height:
            sprite.rect.y = playground_height - sprite.rect.height
            sprite.speed_y = 0
&nbsp;
&nbsp;
<i># Vykreslení celé scény na obrazovku</i>
def <strong>draw_scene</strong>(display, background_color, sprite_group):
    <i># Vyplnění plochy okna černou barvou</i>
    display.fill(background_color)
    <i># Vykreslení celé skupiny spritů do bufferu</i>
    sprite_group.draw(display)
    <i># Obnovení obsahu obrazovky (překlopení zadního a předního bufferu)</i>
    pygame.display.update()
&nbsp;
&nbsp;
<i># Změna barvy spritu na základě kolize s hráčem</i>
def <strong>change_colors</strong>(sprite_group, hit_list):
    <i># Projít všemi sprity ze skupiny, kterou detekovala kolizní funkce</i>
    for sprite in sprite_group:
        if sprite in hit_list:
            sprite.yellowColor()
        else:
            sprite.grayColor()
&nbsp;
&nbsp;
<i># Zjistí kolize spritu se "stěnami" (nepohyblivými sprity)</i>
def <strong>check_collisions</strong>(player, sprite_group):
    <i># Vytvoření seznamu spritů, které kolidují s hráčem</i>
    hit_list = pygame.sprite.spritecollide(player, sprite_group, False)
    <i># Změna barev kolidujících spritů</i>
    change_colors(sprite_group, hit_list)
    collisions = len(hit_list)
    <i># Přenastavení titulku okna</i>
    caption = CAPTION + ": collisions " + str(collisions)
    pygame.display.set_caption(caption)
&nbsp;
&nbsp;
def <strong>mainLoop</strong>(display, clock, all_sprites, all_sprites_but_player, player):
    while True:
        <i># Načtení a zpracování všech událostí z fronty</i>
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                <i># Stiskem kurzorových kláves je možné měnit směr pohybu spritu</i>
                elif event.key == pygame.K_LEFT:
                    player.speed_x = -3
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = +3
                elif event.key == pygame.K_UP:
                    player.speed_y = -3
                elif event.key == pygame.K_DOWN:
                    player.speed_y = +3
            if event.type == KEYUP:
                <i># Puštění kurzorových kláves vede k zastavení pohybu spritu</i>
                if event.key == pygame.K_LEFT:
                    player.speed_x = 0
                elif event.key == pygame.K_RIGHT:
                    player.speed_x = 0
                elif event.key == pygame.K_UP:
                    player.speed_y = 0
                elif event.key == pygame.K_DOWN:
                    player.speed_y = 0
&nbsp;
        move_sprites(all_sprites, display.get_width(), display.get_height())
        check_collisions(player, all_sprites_but_player)
        draw_scene(display, BLACK, all_sprites)
        clock.tick(20)
&nbsp;
&nbsp;
def <strong>main</strong>():
    <i># Inicializace knihovny Pygame</i>
    pygame.init()
&nbsp;
    clock = pygame.time.Clock()
    display = initDisplay(CAPTION)
&nbsp;
    all_sprites, all_sprites_but_player, player = createSprites()
&nbsp;
    mainLoop(display, clock, all_sprites, all_sprites_but_player, player)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
<i># finito</i>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny Pythonovské skripty, které jsme si v&nbsp;dnešním článku ukázali,
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady. Pro analýzu kódů je pochopitelně nutné
mít nainstalovaný i nástroj <i>monkeytype</i>:</p>

<table>
<tr><th> #<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td> 1</td><td>adder</td><td>modul obsahující dvojici funkcí bez uvedení typových informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/adder">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/adder</a></td></tr>
<tr><td> 2</td><td>test_adder_1.py</td><td>zavolání funkcí z&nbsp;modulu <strong>adder</strong> s&nbsp;parametry jednoho typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/test_adder_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/test_adder_1.py</a></td></tr>
<tr><td> 3</td><td>test_adder_2.py</td><td>zavolání funkcí z&nbsp;modulu <strong>adder</strong> s&nbsp;parametry více typů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/test_adder_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/test_adder_2.py</a></td></tr>
<tr><td> 4</td><td>run_ackermann.py</td><td>skript pro spuštění výpočtu Ackermannovy funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/run_ackermann.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/run_ackermann.py</a></td></tr>
<tr><td> 5</td><td>ackermann.py</td><td>výpočet Ackermannovy funkce bez uvedení typových informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/ackermann.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/ackermann.py</a></td></tr>
<tr><td> 6</td><td>ackermann_patched.py</td><td>výpočet Ackermannovy funkce s&nbsp;automaticky přidanými typovými informacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/ackermann_patched.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/ackermann_patched.py</a></td></tr>
<tr><td> 7</td><td>run_sprites.py</td><td>skript pro spuštění projektu založeného na knihovně Pygame</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/run_sprites.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/run_sprites.py</a></td></tr>
<tr><td> 8</td><td>sprites.py</td><td>projekt založený na knihovně Pygame bez uvedení typových informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/sprites.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/sprites.py</a></td></tr>
<tr><td> 9</td><td>sprites_patched.py</td><td>projekt založený na knihovně Pygame s&nbsp;automaticky připojenými typovými informacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/sprites_patched.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/sprites_patched.py</a></td></tr>
<tr><td>10</td><td>run_callable.py</td><td>skript volající funkci vyššího řádku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/run_callable.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/run_callable.py</a></td></tr>
<tr><td>11</td><td>callable.py</td><td>funkce vyššího řádu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/callable.py">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/callable.py</a></td></tr>
<tr><td>12</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/">https://github.com/tisnik/most-popular-python-libs/blob/master/monkeytype/</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na další články o typových anotacích v&nbsp;Pythonu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na články, které již na Rootu vyšly
a ve kterých jsme se zabývali problematikou typového systému programovacího
jazyka Python:</p>

<ol>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (2.část)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/</a>
</li>

<li>Novinky v&nbsp;typovém systému přidané do Pythonu 3.12<br />
<a href="https://www.root.cz/clanky/novinky-v-typovem-systemu-pridane-do-pythonu-3-12/">https://www.root.cz/clanky/novinky-v-typovem-systemu-pridane-do-pythonu-3-12/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>What’s New In Python 3.12 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.12.html">https://docs.python.org/3/whatsnew/3.12.html</a>
</li>

<li>What’s New In Python 3.12<br />
<a href="https://dev.to/mahiuddindev/python-312-4n43">https://dev.to/mahiuddindev/python-312-4n43</a></li>

<li>PEP 698 – Override Decorator for Static Typing<br />
<a href="https://peps.python.org/pep-0698/">https://peps.python.org/pep-0698/</a>
</li>

<li>typing.override<br />
<a href="https://docs.python.org/3/library/typing.html#typing.override">https://docs.python.org/3/library/typing.html#typing.override</a>
</li>

<li>Type Hinting<br />
<a href="https://realpython.com/lessons/type-hinting/">https://realpython.com/lessons/type-hinting/</a>
</li>

<li>mypy homepage<br />
<a href="https://www.mypy-lang.org/">https://www.mypy-lang.org/</a>
</li>

<li>mypy documentation<br />
<a href="https://mypy.readthedocs.io/en/stable/">https://mypy.readthedocs.io/en/stable/</a>
</li>

<li>Mypy na PyPi Optional static typing for Python<br />
<a href="https://pypi.org/project/mypy/">https://pypi.org/project/mypy/</a>
</li>

<li>5 Reasons Why You Should Use Type Hints In Python<br />
<a href="https://www.youtube.com/watch?v=dgBCEB2jVU0">https://www.youtube.com/watch?v=dgBCEB2jVU0</a>
</li>

<li>Python Typing &ndash; Type Hints &amp; Annotations<br />
<a href="https://www.youtube.com/watch?v=QORvB-_mbZ0">https://www.youtube.com/watch?v=QORvB-_mbZ0</a>
</li>

<li>What Problems Can TypeScript Solve?<br />
<a href="https://www.typescriptlang.org/why-create-typescript">https://www.typescriptlang.org/why-create-typescript</a>
</li>

<li>How to find code that is missing type annotations?<br />
<a href="https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations">https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations</a>
</li>

<li>Do type annotations in Python enforce static type checking?<br />
<a href="https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking">https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking</a>
</li>

<li>Understanding type annotation in Python<br />
<a href="https://blog.logrocket.com/understanding-type-annotation-python/">https://blog.logrocket.com/understanding-type-annotation-python/</a>
</li>

<li>Static type checking with Mypy — Perfect Python<br />
<a href="https://www.youtube.com/watch?v=9gNnhNxra3E">https://www.youtube.com/watch?v=9gNnhNxra3E</a>
</li>

<li>Static Type Checker for Python<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Differences Between Pyright and Mypy<br />
<a href="https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md">https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md</a>
</li>

<li>4 Python type checkers to keep your code clean<br />
<a href="https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html">https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html</a>
</li>

<li>Pyre: A performant type-checker for Python 3<br />
<a href="https://pyre-check.org/">https://pyre-check.org/</a>
</li>

<li>"Typing the Untyped: Soundness in Gradual Type Systems" by Ben Weissmann<br />
<a href="https://www.youtube.com/watch?v=uJHD2xyv7xo">https://www.youtube.com/watch?v=uJHD2xyv7xo</a>
</li>

<li>Covariance and contravariance (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a>
</li>

<li>Functional Programming: Type Systems<br />
<a href="https://www.youtube.com/watch?v=hy1wjkcIBCU">https://www.youtube.com/watch?v=hy1wjkcIBCU</a>
</li>

<li>A Type System From Scratch – Robert Widmann<br />
<a href="https://www.youtube.com/watch?v=IbjoA5xVUq0">https://www.youtube.com/watch?v=IbjoA5xVUq0</a>
</li>

<li>"Type Systems - The Good, Bad and Ugly" by Paul Snively and Amanda Laucher<br />
<a href="https://www.youtube.com/watch?v=SWTWkYbcWU0">https://www.youtube.com/watch?v=SWTWkYbcWU0</a>
</li>

<li>Type Systems: Covariance, Contravariance, Bivariance, and Invariance explained<br />
<a href="https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8">https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8</a>
</li>

<li>Statická vs. dynamická typová kontrola<br />
<a href="https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/">https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/</a>
</li>

<li>Typový systém<br />
<a href="https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m">https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m</a>
</li>

<li>Comparison of programming languages by type system<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system</a>
</li>

<li>Flow<br />
<a href="https://flow.org/">https://flow.org/</a>
</li>

<li>TypeScript<br />
<a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a>
</li>

<li>Sorbet<br />
<a href="https://sorbet.org/">https://sorbet.org/</a>
</li>

<li>Pyright<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Mypy: Type hints cheat sheet<br />
<a href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html</a>
</li>

<li>PEP 484 – Type Hints<br />
<a href="https://peps.python.org/pep-0484/">https://peps.python.org/pep-0484/</a>
</li>

<li>What is the use of stub files (.pyi ) in python?<br />
<a href="https://stackoverflow.com/questions/59051631/what-is-the-use-of-stub-files-pyi-in-python">https://stackoverflow.com/questions/59051631/what-is-the-use-of-stub-files-pyi-in-python</a>
</li>

<li>PEP 561 – Distributing and Packaging Type Information<br />
<a href="https://peps.python.org/pep-0561/">https://peps.python.org/pep-0561/</a>
</li>

<li>What does "i" represent in Python .pyi extension?<br />
<a href="https://stackoverflow.com/questions/41734836/what-does-i-represent-in-python-pyi-extension">https://stackoverflow.com/questions/41734836/what-does-i-represent-in-python-pyi-extension</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

