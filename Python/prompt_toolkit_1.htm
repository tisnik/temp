<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Tvorba aplikací s příkazovým řádkem v Pythonu s využitím knihoven GNU Readline a prompt_toolkit</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Tvorba aplikací s příkazovým řádkem v Pythonu s využitím knihoven GNU Readline a prompt_toolkit</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Využití funkce <strong>input()</strong> bez dalších rozšíření</a></p>
<p><a href="#k02">2. Rozhraní mezi Pythonem a knihovnou GNU Readline</a></p>
<p><a href="#k03">3. Ukázka základního použití knihovny <strong>readline</strong></a></p>
<p><a href="#k04">4. Jednoduché automatické doplňování příkazů</a></p>
<p><a href="#k05">5. Vylepšení automatického doplňování příkazů</a></p>
<p><a href="#k06">*** 6. Použití parametru <strong>state</strong> v&nbsp;okamžiku většího množství dostupných příkazů</a></p>
<p><a href="#k07">7. Konfigurace knihovny GNU Readline &ndash; soubor <strong>.inputrc</strong></a></p>
<p><a href="#k08">8. Knihovna <strong>prompt_toolkit</strong></a></p>
<p><a href="#k09">9. Instalace knihovny <strong>prompt_toolkit</strong></a></p>
<p><a href="#k10">10. Využití funkce <strong>prompt_toolkit.prompt</strong></a></p>
<p><a href="#k11">11. Režim zápisu hesla</a></p>
<p><a href="#k12">12. Objekt typu <strong>PromptSession</strong></a></p>
<p><a href="#k13">13. Automatické doplňování příkazů s&nbsp;využitím třídy <strong>WordCompleter</strong></a></p>
<p><a href="#k14">14. Režim emulující příkazy editorů Vi a Vim</a></p>
<p><a href="#k15">15. Režim emulující příkazy editoru Emacs</a></p>
<p><a href="#k16">16. Použití objektu <strong>PromptSession</strong> v&nbsp;režimu zadávání hesla</a></p>
<p><a href="#k17">*** 17. Standardní klávesové zkratky použité knihovnou GNU Readline v&nbsp;režimu Emacs</a></p>
<p><a href="#k18">*** 18. Standardní klávesové zkratky použité knihovnou GNU Readline v&nbsp;režimu Vi</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití funkce <strong>input()</strong> bez dalších rozšíření</h2>

<p>Popis možností Pythonu při čtení dat z&nbsp;příkazové řádky začneme tou
nejzákladnější funkcí, která je součástí standardního modulu Pythonu (a není ji
tedy zapotřebí importovat). Tato funkce se v&nbsp;Pythonu 3.x jmenuje
<strong>input()</strong> a slouží k&nbsp;načtení řetězce ze standardního
vstupu, ovšem s&nbsp;tím, že se z&nbsp;řetězce odstraní znak konce řádku. Této
funkci je možné předat nepovinný řetězec, který bude zobrazen jako výzva
(<i>prompt</i>) na terminálu:</p>

<pre>
&gt;&gt;&gt; <strong>help("input")</strong>
&nbsp;
Help on built-in function input in module builtins:
&nbsp;
input(...)
    input([prompt]) -&gt; string
&nbsp;
    Read a string from standard input.  The trailing newline is stripped.
    If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.
    On Unix, GNU readline is used if enabled.  The prompt string, if given,
    is printed without a trailing newline before reading.
</pre>

<p>V&nbsp;Pythonu 2.x je situace nepatrně složitější, protože stejnou činnost
vykonává funkce nazvaná <strong>raw_input()</strong>. Funkce
<strong>input()</strong>, která taktéž v&nbsp;Pythonu 2.x existuje, se navíc
snaží řetězec zapsaný na standardní vstup zpracovat funkcí
<strong>eval()</strong> (a tedy například naparsovat celé číslo, seznam atd.),
což většinou není činnost, kterou v&nbsp;praxi vyžadujeme:</p>

<pre>
&gt;&gt;&gt; <strong>help("input")</strong>
&nbsp;
input(...)
    input([prompt]) -&gt; value
&nbsp;    
    Equivalent to eval(raw_input(prompt)).
</pre>

<p>V&nbsp;dalším textu budeme předpokládat použití Pythonu 3.x. Následující
příklad je skutečně velmi jednoduchý a ukazuje, jakým způsobem lze použít
funkci <strong>input()</strong> pro načtení příkazu (prozatím se tento příkaz
pouze vytiskne zpět na terminál a dále s&nbsp;ním nebudeme pracovat):</p>

<pre>
cmd = <strong>input("Command: ")</strong>
print(cmd)
</pre>

<p><div class="rs-tip-major">Poznámka: sami si vyzkoušejte, že základní chování
funkce <strong>input()</strong> je velmi primitivní &ndash; z&nbsp;editovacích
příkazů bude fungovat pouze klávesa <strong>Delete</strong> a dokonce ani
nebude možné využít kurzorové šipky. Chování se ovšem změní při zavolání této
funkce přímo ze smyčky REPL. Důvod je vysvětlen <a href="#k02">ve druhé
kapitole</a>.</div></p>

<p>Druhý příklad je nepatrně složitější, protože v&nbsp;něm vytváříme kostru
&bdquo;aplikace&ldquo;, která postupně načítá příkazy ze svého příkazového
řádku a nějakým způsobem na ně reaguje. Prvotní verze této aplikace pouze
rozpoznává trojici příkazů &bdquo;quit&ldquo;, &bdquo;exit&ldquo; a
&bdquo;eval&ldquo;, popř.&nbsp;jejich zkrácené varianty. Zpracování příkazů je
realizováno v&nbsp;nekonečné smyčce ukončení až zadáním příkazu
&bdquo;quit&ldquo; popř.&nbsp;jiným násilným ukončením aplikace (Ctrl+D
atd.):</p>

<pre>
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
while True:
    cmd = <strong>input("Command: ")</strong>
    if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozhraní mezi Pythonem a knihovnou GNU Readline</h2>

<p>Již v&nbsp;nápovědě vypsané <a href="#k01">v&nbsp;úvodní kapitole</a>
k&nbsp;funkci <strong>input()</strong> jsme si mohli přečíst zmínku o knihovně
GNU Readline. Tuto knihovnu je totiž možné využít pro vylepšení vlastností
funkce <strong>input()</strong>, především pak pro přidání těchto
vlastností:</p>

<ol>

<li>Možnost použití kurzorových šipek pro pohyb na řádku se zapisovaným
vstupním textem</li>

<li>Příkazy do určité míry emulující editory Emacs či Vi (v&nbsp;Emacs režimu
například Ctrl+A pro přechod na začátek řádku, Ctrl+W pro smazání slova
atd.)</li>

<li>Doplňování příkazů (vstupních dat), což je téma, které si popíšeme <a
href="#k04">ve čtvrté kapitole</a></li>

<li>Vyhledávání v&nbsp;historii již zadaných příkazů (vstupních dat)</li>

</ol>

<p>I o podpoře GNU Readline v&nbsp;Pythonu se dozvíme přímo z&nbsp;integrované
nápovědy. Tentokrát se bude nápověda týkat modulu nazvaného
<strong>readline</strong>. K&nbsp;nápovědě k&nbsp;tomuto modulu se lze dostat
několika způsoby. První způsob využívá přechodu do režimu nápovědy zavoláním
funkce <strong>help()</strong> z&nbsp;interaktivní smyčky REPL:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.4.3 (default, Nov 28 2017, 16:41:13) 
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
&nbsp;
&nbsp;
&gt;&gt;&gt; <strong>help()</strong>
&nbsp;
Welcome to Python 3.4's help utility!
&nbsp;
&nbsp;
help&gt; <strong>readline</strong>
&nbsp;
Help on module readline:
&nbsp;
NAME
...
...
...
</pre>

<p>Druhý způsob přímo vyvolá nápovědu k&nbsp;modulu, a to bez přechodu do
režimu nápovědy:</p>

<pre>
&gt;&gt;&gt; <strong>help("readline")</strong>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázka základního použití knihovny <strong>readline</strong></h2>

<p>Aby došlo &ndash; a to prakticky zcela automaticky &ndash; k&nbsp;rozšíření
možností funkce <strong>input()</strong> o většinu výše uvedených vlastností
(plně editovatelný vstupní řádek, historie zadaných dat atd.), postačuje
doplnit náš demonstrační příklad o jediný řádek:</p>

<pre>
import readline
</pre>

<p>V&nbsp;průběhu importu tohoto modulu dojde k&nbsp;inicializaci knihovny GNU
Readline a po spuštění příkladu již bude možné použít kurzorové šipky a další
dále popsané editační operace, historii již zadaných vstupních dat (příkazů) a
vyhledávání v&nbsp;této historii. Žádné další úpravy v&nbsp;příkladu přitom
není nutné provádět:</p>

<pre>
<strong>import readline</strong>
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
while True:
    cmd = <strong>input("Command: ")</strong>
    if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>

<p>Interně nyní bude funkce <strong>input()</strong> používat například
historii dat zapsaných do vstupního řádku atd., takže bude možné využít
kurzorových šipek pro průchod historií, vyhledání v&nbsp;historii atd.</p>

<p><div class="rs-tip-major">Poznámka: knihovna GNU Readline je použita i
v&nbsp;interaktivní smyčce REPL Pythonu, což způsobuje odlišné chování funkce
<strong>input()</strong> v&nbsp;případě, že je z&nbsp;REPL zavolána.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Jednoduché automatické doplňování příkazů</h2>

<p>Jedna z&nbsp;nejužitečnějších vlastností knihovny GNU Readline spočívá
v&nbsp;možnosti naprogramování automatického doplňování příkazů (nebo jiných
vstupních dat) po stisku klávesy <strong>Tab</strong>. Tuto funkci
pravděpodobně znáte z&nbsp;shellu popř.&nbsp;přímo z&nbsp;REPLu Pythonu (do
dokonalosti je dovedena v&nbsp;IPythonu). Technologie automatického doplňování
je založena na volání callback funkce nazývané <i>completer</i> přímo
z&nbsp;knihovny GNU Readline. Této funkci se předávají dva údaje &ndash; již
zapsaný (částečný) text a celočíselná hodnota <i>state</i>, jejíž význam bude
vysvětlen v&nbsp;navazujících kapitolách. Pokud <i>completer</i> vrátí nějaký
text, bude si ho knihovna GNU Readline pamatovat jako jedno z&nbsp;možných slov
pro automatické doplnění. Pokud naopak vrátí hodnotu <strong>None</strong>,
znamená to, že další volání této callback funkce již nemá význam a bude
ukončeno.</p>

<p>Podívejme se nyní na jednu (prozatím značně primitivní) implementaci
<i>completeru</i>. Tato implementace bude pracovat následovně: pokud je hodnota
<strong>state</strong> nastavena na hodnotu 0 (první volání <i>completeru</i>),
bude vstupní text analyzován a pokud bude odpovídat začátku nějakého známého
příkazu, vrátí se jeho plná podoba. Tj.&nbsp;například při vstupu
&bdquo;qu&ldquo; se vrátí text &bdquo;quit&ldquo; atd. Při druhém volání
<i>completeru</i> se již pouze vrátí hodnota <strong>None</strong> znamenající,
že GNU Readline vždy zkompletuje celý příkaz a nikdy nenabídne více než jednu
možnost (alternativní implementaci si uvedeme v&nbsp;dalším textu):</p>

<pre>
def <strong>completer</strong>(text, state):
    <i># print(text, state)</i>
    if state &gt;= 1:
        return None
    if text in {"q", "qu", "qui"}:
        return "quit"
    elif text in {"e", "ex", "exi"}:
        return "exit"
    elif text in {"h", "he", "hel"}:
        return "help"
    else:
        return text
</pre>

<p>Povolení doplňování příkazů a nastavení <i>completeru</i> se provede takto.
První řádek nastaví <i>completer</i>, druhý řádek pro jistotu nastaví mapování
klávesy <strong>Tab</strong> na operaci &bdquo;complete&ldquo;:</p>

<pre>
readline.set_completer(completer)
readline.parse_and_bind("tab: complete")
</pre>

<p>Úplný zdrojový text příkladu, který podporuje automatické doplňování jmen
tří příkazů, bude vypadat následovně:</p>

<pre>
import readline
&nbsp;
&nbsp;
def <strong>completer</strong>(text, state):
    <i># print(text, state)</i>
    if state &gt;= 1:
        return None
    if text in {"q", "qu", "qui"}:
        return "quit"
    elif text in {"e", "ex", "exi"}:
        return "exit"
    elif text in {"h", "he", "hel"}:
        return "help"
    else:
        return text
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
readline.set_completer(completer)
readline.parse_and_bind("tab: complete")
&nbsp;
while True:
    cmd = <strong>input("Command: ")</strong>
    if cmd in {"quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vylepšení automatického doplňování příkazů</h2>

<p>Předchozí implementace <i>completeru</i> nebyla příliš efektivní, a to
minimálně ze dvou důvodů. První důvod spočíval v&nbsp;tom, že bylo nutné
postupně zadávat všechny možné zkrácené tvary příkazů a navíc byly tyto tvary
přímo součástí těla příslušné callback funkce. Ovšem <i>completer</i> lze
relativně snadno vylepšit. Nejdříve všechny dostupné příkazy (nikoli jejich
zkrácené tvary!) uložíme do proměnné mimo vlastní callback funkci, takže je
bude možné snadno modifikovat nebo načíst z&nbsp;konfiguračního souboru:</p>

<pre>
WORDS = ("quit", "exit", "eval", "help")
</pre>

<p>Dále vlastní implementaci <i>completeru</i> upravíme takovým způsobem, aby
se na základě částečného textu zadaného uživatelem našel první vyhovující
příkaz. Je to snadné &ndash; budeme procházet n-ticí <strong>WORDS</strong>
s&nbsp;příkazy a pokud zadaný <i>n</i>-znakový text bude odpovídat prvním
<i>n</i> znakům příkazu, vrátíme přímo úplný tvar příkazu. Případné
nejednoznačnosti typu &bdquo;e&rarr;exit&ldquo; a &bdquo;e&rarr;eval&ldquo;
jsou vyřešeny pořadím příkazů (vrátí se první nalezený):</p>

<pre>
def <strong>completer</strong>(text, state):
    <i># print(text, state)</i>
    if state &gt;= 1:
        return None
    n = len(text)
    for word in WORDS:
        if text == word[:n]:
            return word
    else:
        return text
</pre>

<p>Opět si ukažme plnou verzi zdrojového kódu tohoto demonstračního
příkladu:</p>

<pre>
import readline
&nbsp;
&nbsp;
WORDS = ("quit", "exit", "eval", "help")
&nbsp;
&nbsp;
def <strong>completer</strong>(text, state):
    <i># print(text, state)</i>
    if state &gt;= 1:
        return None
    n = len(text)
    for word in WORDS:
        if text == word[:n]:
            return word
    else:
        return text
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
readline.set_completer(completer)
readline.parse_and_bind("tab: complete")
&nbsp;
while True:
    cmd = input("Command: ")
    if cmd in {"quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití parametru <strong>state</strong> v&nbsp;okamžiku většího množství dostupných příkazů</h2>

<p></p>

<pre>
def <strong>completer</strong>(text, state):
    <i># print(text, state)</i>
    matches = []
    n = len(text)
    for word in WORDS:
        if text == word[:n]:
            matches.append(word)
    if len(matches) &gt;= state:
        return matches[state]
    else:
        return None
</pre>

<p></p>

<pre>
import readline
&nbsp;
&nbsp;
WORDS = ("quit", "exit", "eval", "help")
&nbsp;
&nbsp;
def <strong>completer</strong>(text, state):
    <i># print(text, state)</i>
    matches = []
    n = len(text)
    for word in WORDS:
        if text == word[:n]:
            matches.append(word)
    if len(matches) &gt;= state:
        return matches[state]
    else:
        return None
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
readline.set_completer(completer)
readline.parse_and_bind("tab: complete")
&nbsp;
while True:
    cmd = input("Command: ")
    if cmd in {"quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Konfigurace knihovny GNU Readline &ndash; soubor <strong>.inputrc</strong></h2>

<p>Chování knihovny <i>GNU Readline</i> je možné ovlivnit parametry, které jsou
zapisovány do souboru nazvaného <strong>.inputrc</strong>, jenž je umístěn
v&nbsp;domácím adresáři uživatele a popř.&nbsp;ze souboru
<strong>/etc/inputrc</strong> (tyto volby budou mít globální platnost). Tento
soubor ve skutečnosti může obsahovat jak již zmíněné volby ovlivňující chování
GNU Readline, tak i například tzv.&nbsp;makra, což jsou ovšem většinou pouhé
expanze kódů kláves posílaných terminálem (typicky escape sekvence) na příkazy
typu &bdquo;přesun kurzoru na začátek zapisovaného textu&ldquo;. Následuje
příklad obsahu <strong>~/.inputrc</strong> v&nbsp;případě, že uživatel
požaduje, aby se ve všech aplikacích používajících GNU Readline používal režim
emulující textové editory Vi/Vim:</p>

<pre>
set editing-mode vi
</pre>

<p>Více příkladů, včetně maker, nalezneme v&nbsp;souboru
<strong>/usr/share/readline</strong> popř.&nbsp;v&nbsp;již zmíněném globálním
konfiguračním souboru <strong>/etc/inputrc</strong>. Podívejme se jen na
několik příkladů s&nbsp;mapováním escape sekvencí některých kláves na příkazy,
které GNU Readline rozpoznává:</p>

<pre>
<i># Be 8 bit clean.</i>
set input-meta on
set output-meta on
&nbsp;
<i># allow the use of the Home/End keys</i>
"\e[1~": beginning-of-line
"\e[4~": end-of-line
&nbsp;
<i># allow the use of the Delete/Insert keys</i>
"\e[3~": delete-char
"\e[2~": quoted-insert
&nbsp;
<i># mappings for "page up" and "page down" to step to the beginning/end</i>
<i># of the history</i>
<i># "\e[5~": beginning-of-history</i>
<i># "\e[6~": end-of-history</i>
&nbsp;
<i># alternate mappings for "page up" and "page down" to search the history</i>
<i># "\e[5~": history-search-backward</i>
<i># "\e[6~": history-search-forward</i>
&nbsp;
<i># mappings for Ctrl-left-arrow and Ctrl-right-arrow for word moving</i>
"\e[1;5C": forward-word
"\e[1;5D": backward-word
"\e[5C": forward-word
"\e[5D": backward-word
"\e\e[C": forward-word
"\e\e[D": backward-word
</pre>

<p><div class="rs-tip-major">Poznámka: přesný význam jednotlivých příkazů,
například <strong>forward-word</strong>, naleznete v&nbsp;manuálové stránce
<strong>readline</strong>:</div></p>

<pre>
$ <strong>man readline</strong>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Knihovna <strong>prompt_toolkit</strong></h2>

<p>Druhou knihovnou, s&nbsp;jejímiž základními vlastnostmi se v&nbsp;dnešním
článku alespoň ve stručnosti seznámíme, je knihovna, která se jmenuje
<strong>prompt_toolkit</strong>. Název této knihovny sice naznačuje, že slouží
pro implementaci vstupního (či příkazového) řádku do aplikací, to však není
vše. Tato knihovna například umožňuje využít víceřádkový vstupní text, dovoluje
použití myši (kromě implicitní funkce myši v&nbsp;terminálu pro operace copy
&amp; paste) a dokonce obsahuje sadu prvků uživatelského rozhraní (takzvaných
<i>widgetů</i>), mezi něž patří například toolbary, menu, checkboxy, tlačítka,
či dialogy. Díky tomu lze tuto knihovnu použít i pro tvorbu aplikací
s&nbsp;plnohodnotným textovým uživatelským rozhraním (ne nepodobným
starodávnému <i>TurboVision</i>). Dnes si sice ukážeme jen nepatrnou část
funkcionality této knihovny, ovšem jejím dalším schopnostem bude později
věnován samostatný článek.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instalace knihovny <strong>prompt_toolkit</strong></h2>

<p>Instalaci knihovny <strong>prompt_toolkit</strong> provedeme pomocí nástroje
<strong>pip</strong> nebo <strong>pip3</strong> (podle zvolené verze Pythonu).
Díky použití parametru <strong>--user</strong> je zajištěno, že se instalace
provede do adresáře <strong>~/.local/</strong> (pro aktivního uživatele) a
tudíž nemusí mít uživatel rootovská práva:</p>

<pre>
$ <strong>pip3 install --user prompt_toolkit</strong>
&nbsp;
Downloading/unpacking prompt-toolkit
  Downloading prompt_toolkit-2.0.3-py3-none-any.whl (322kB): 322kB downloaded
Downloading/unpacking wcwidth (from prompt-toolkit)
  Downloading wcwidth-0.1.7-py2.py3-none-any.whl
Requirement already satisfied (use --upgrade to upgrade): six&gt;=1.9.0 in ./.local/lib/python3.4/site-packages (from prompt-toolkit)
Installing collected packages: prompt-toolkit, wcwidth
Successfully installed prompt-toolkit wcwidth
Cleaning up...
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Využití funkce <strong>prompt_toolkit.prompt</strong></h2>

<p>Ukažme si nyní základní způsob použití funkce
<strong>prompt_toolkit.prompt</strong>, která efektivně nahrazuje výše popsanou
standardní funkci <strong>input</strong>. Pokud nebudeme vyžadovat žádné další
pokročilejší schopnosti (kromě plnohodnotné editace vstupního řádku!), může se
funkce <strong>prompt</strong> použít následujícím způsobem:</p>

<pre>
from prompt_toolkit import prompt
&nbsp;
cmd = <strong>prompt("Command: ")</strong>
print("Entered: '{cmd}'".format(cmd=cmd))
</pre>

<p>Tuto funkci můžeme velmi snadno přidat do našeho demonstračního příkladu
akceptujícího trojici příkazů a nahradit tak volání <strong>input</strong> a
současně i přímé použití knihovny GNU Readline:</p>

<pre>
from prompt_toolkit import prompt
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
while True:
    cmd = <strong>prompt("Command: ")</strong>
    if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Režim zápisu hesla</h2>

<p>V&nbsp;některých případech je nutné zajistit, aby se při zadávání údajů na
vstupní řádku neprováděl opis (takzvané <i>echo</i>) zapisovaných znaků, ale
aby se namísto skutečně zapisovaných znaků pouze ukazoval nějaký zástupný znak,
typicky hvězdička. Tento režim se používá například při zadávání hesel a můžeme
ho velmi snadno zapnout využitím nepovinného parametru
<strong>is_password</strong>, který musí mít nastavenou hodnotu
<strong>True</strong>. Použití tohoto režimu je snadné, což ostatně dokládá
zdrojový kód další varianty našeho demonstračního příkladu:</p>

<pre>
from prompt_toolkit import prompt
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
while True:
    cmd = <strong>prompt("Command: ", is_password=True)</strong>
    if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Objekt typu <strong>PromptSession</strong></h2>

<p>Funkce <strong>prompt_toolkit.prompt</strong>, kterou jsme si ukázali
v&nbsp;předchozích dvou kapitolách, pracuje skutečně jako &bdquo;pouhá&ldquo;
funkce bez vnitřního stavu, což v&nbsp;důsledku znamená, že nedokáže zajistit
práci s&nbsp;historií již zadaných příkazů (vstupních dat). Pokud podporu pro
historii skutečně budeme potřebovat &ndash; a mnohdy se jedná o velmi užitečnou
vlastnost &ndash; musíme namísto funkce <strong>prompt_toolkit.prompt</strong>
využít třídu <strong>PromptSession</strong>, resp.&nbsp;přesněji řečeno
instanci této třídy. Díky tomu, že se namísto funkce
<strong>prompt_toolkit.prompt</strong> bude volat metoda
<strong>PromptSession.prompt</strong>, bude možné (a to bez našeho dalšího
zásahu) pracovat s&nbsp;historií vstupního řádku, tj.&nbsp;například listovat
historií s&nbsp;využitím kurzorových šipek. Podívejme se na upravený příklad,
v&nbsp;němž se objekt typu <strong>PromptSession</strong> konstruuje a
používá:</p>

<pre>
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
<strong>s = PromptSession()</strong>
&nbsp;
while True:
    cmd = <strong>s.prompt("Command: ")</strong>
    if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Automatické doplňování příkazů s&nbsp;využitím třídy <strong>WordCompleter</strong></h2>

<p>Jednou z&nbsp;předností knihovny <strong>prompt_toolkit</strong> je
existence předpřipravených tříd, které lze použít pro automatické doplňování
slov nebo výrazů na vstupním řádku. Tříd existuje několik z&nbsp;toho důvodu,
že kromě ve své podstatě primitivního doplňování slov na základě připraveného
slovníku je možné naprogramovat například doplňování názvů metod v&nbsp;určeném
kontextu apod. Dnes si představíme nejjednodušší z&nbsp;těchto tříd &ndash;
<strong>WordCompleter</strong>. Tato třída slouží k&nbsp;pouhému automatickému
doplňování slov na základě slovníku, tj.&nbsp;ke stejnému účelu, jaký jsme již
použili v&nbsp;knihovně GNU Readline. Konstrukce instance třídy
<strong>WordCompleter</strong> je snadná &ndash; konstruktoru předáme seznam
slov a popř.&nbsp;nepovinný parametr informující o tom, zda se má nebo naopak
nemá ignorovat velikost písmen:</p>

<pre>
c = WordCompleter(["quit", "exit", "help", "eval"], ignore_case=True)
</pre>

<p>Následně při konstrukci instance třídy <strong>PromptSession</strong>
použijeme nepovinný parametr <strong>completer</strong>, kterému předáme
referenci na dříve vytvořený objekt:</p>

<pre>
s = PromptSession(completer=c)
</pre>

<p>To jsou ve skutečnosti jediné dvě změny, které je nutné provést, aby
automatické doplňování příkazů fungovalo, a to včetně zobrazení menu
s&nbsp;nabídkou možností ve chvíli, kdy není doplnění jednoznačné. Ukažme si
tedy úplný zdrojový kód upraveného demonstračního příkladu:</p>

<pre>
from prompt_toolkit import PromptSession
from prompt_toolkit.completion import WordCompleter
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
c = <strong>WordCompleter(["quit", "exit", "help", "eval"], ignore_case=True)</strong>
s = <strong>PromptSession(completer=c)</strong>
&nbsp;
while True:
    cmd = <strong>s.prompt("Command: ")</strong>
    if cmd in {"quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Režim emulující příkazy editorů Vi a Vim</h2>

<p>Další pro mnohé uživatele (zejména programátory či administrátory) užitečnou
vlastností knihovny <strong>prompt_toolkit</strong> je možnost emulace příkazů
textových editorů Vi a Vim. Tyto editory jsou modální, přičemž při jejich
emulaci se knihovna implicitně nachází v&nbsp;režimu vstupu (<i>insert
mode</i>), takže pro přechod do normálního režimu (<i>normal mode</i>) je nutné
stisknout klávesu <strong>Esc</strong>. Jedna z&nbsp;variant přepnutí knihovny
<strong>prompt_toolkit</strong> do režimu emulace Vi/Vim vypadá takto:</p>

<pre>
s = PromptSession(completer=c, vi_mode=True)
</pre>

<p>Celý demonstrační příklad:</p>

<pre>
from prompt_toolkit import PromptSession
from prompt_toolkit.completion import WordCompleter
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
c = <strong>WordCompleter(["quit", "exit", "help", "eval"], ignore_case=True)</strong>
s = <strong>PromptSession(completer=c, vi_mode=True)</strong>
&nbsp;
while True:
    cmd = <strong>s.prompt("Command: ")</strong>
    if cmd in {"quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>

<p>Druhá možnost využívá nepovinného parametru <strong>editing_mode</strong>
předaného konstruktoru třídy <strong>PromptSession</strong>. Hodnota tohoto
parametru se importuje z&nbsp;modulu <strong>enums</strong>:</p>

<pre>
s = PromptSession(completer=c, editing_mode=enums.EditingMode.VI)
</pre>

<p>Opět si ukažme celý demonstrační příklad:</p>

<pre>
from prompt_toolkit import PromptSession
from prompt_toolkit import enums
from prompt_toolkit.completion import WordCompleter
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
c = <strong>WordCompleter(["quit", "exit", "help", "eval"], ignore_case=True)</strong>
s = <strong>PromptSession(completer=c, editing_mode=enums.EditingMode.VI)</strong>
&nbsp;
while True:
    cmd = <strong>s.prompt("Command: ")</strong>
    if cmd in {"quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Režim emulující příkazy editoru Emacs</h2>

<p>Do režimu emulujícího některé základní příkazy editoru Emacs je možné se
přepnout použitím pojmenovaného parametru <strong>editing_mode</strong>, který
musí obsahovat konstantu <strong>EditingMode.EMACS</strong> naimportovanou
z&nbsp;modulu <strong>enums</strong>. Následující příklad je až na odlišný
režim editace totožný s&nbsp;příkladem předchozím, takže jen krátce:</p>

<pre>
from prompt_toolkit import PromptSession
from prompt_toolkit import enums
from prompt_toolkit.completion import WordCompleter
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
c = WordCompleter(["quit", "exit", "help", "eval"], ignore_case=True)
s = <strong>PromptSession(completer=c, editing_mode=enums.EditingMode.EMACS)</strong>
&nbsp;
while True:
    cmd = <strong>s.prompt("Command: ")</strong>
    if cmd in {"quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Použití objektu <strong>PromptSession</strong> v&nbsp;režimu zadávání hesla</h2>

<p>Jen pro úplnost si na závěr ukažme, že parametry funkce
<strong>prompt</strong> a metody <strong>PromptSession.prompt</strong> jsou
skutečně do značné míry shodné. V&nbsp;dnešním posledním příkladu vytvoříme
objekt typu <strong>PromptSession</strong> a při zadávání vstupních dat zvolíme
režim zápisu hesla, což se podobá situaci <a href="#k11">z&nbsp;jedenácté
kapitoly</a>:</p>

<pre>
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def show_help():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
s = <strong>PromptSession()</strong>
&nbsp;
while True:
    cmd = <strong>s.prompt("Command: ", is_password=True)</strong>
    if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Standardní klávesové zkratky použité knihovnou GNU Readline v&nbsp;režimu Emacs</h2>

<p></p>

<h4></h4>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>

<h4></h4>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>

<h4></h4>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Standardní klávesové zkratky použité knihovnou GNU Readline v&nbsp;režimu Vi</h2>

<p></p>

<h4></h4>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>

<h4></h4>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>

<h4></h4>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly uloženy do Git repositáře
dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již poměrně rozsáhlý) repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>1</td><td>input1.py</td><td>použití input()</td><td><a href="https://github.com/tisnik/presentations/blob/master/python_readline/input1.py">https://github.com/tisnik/presentations/blob/master/python_readline/input1.py</a></td></tr>
<tr><td>2</td><td>input_command_line.py</td><td>input() jako základ CLI aplikace</td><td><a href="https://github.com/tisnik/presentations/blob/master/python_readline/input_command_line.py">https://github.com/tisnik/presentations/blob/master/python_readline/input_command_line.py</a></td></tr>
<tr><td>3</td><td>readline_command_line.py</td><td>povolení použití GNU Readline</td><td><a href="https://github.com/tisnik/presentations/blob/master/python_readline/readline_command_line.py">https://github.com/tisnik/presentations/blob/master/python_readline/readline_command_line.py</a></td></tr>
<tr><td>4</td><td>readline_completer.py</td><td>první verze automatického doplňování</td><td><a href="https://github.com/tisnik/presentations/blob/master/python_readline/readline_completer.py">https://github.com/tisnik/presentations/blob/master/python_readline/readline_completer.py</a></td></tr>
<tr><td>5</td><td>readline_completer2.py</td><td>druhá verze automatického doplňování</td><td><a href="https://github.com/tisnik/presentations/blob/master/python_readline/readline_completer2.py">https://github.com/tisnik/presentations/blob/master/python_readline/readline_completer2.py</a></td></tr>
<tr><td>6</td><td>readline_completer3.py</td><td>třetí verze automatického doplňování</td><td><a href="https://github.com/tisnik/presentations/blob/master/python_readline/readline_completer3.py">https://github.com/tisnik/presentations/blob/master/python_readline/readline_completer3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>prompt1_basic_usage.py</td><td>základní použití knihovny prompt_toolkit</td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt1_basic_usage.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt1_basic_usage.py</a></td></tr>
<tr><td>7</td><td>prompt2_command_line.py</td><td>prompt_toolkit v&nbsp;CLI aplikaci</td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt2_command_line.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt2_command_line.py</a></td></tr>
<tr><td>7</td><td>prompt3_password_mode.py</td><td>režim zadávání hesla</td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt3_password_mode.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt3_password_mode.py</a></td></tr>
<tr><td>7</td><td>prompt4_PromptSession.py</td><td>objekt typu PromptSession</td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt4_PromptSession.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt4_PromptSession.py</a></td></tr>
<tr><td>7</td><td>prompt5_WordCompleter.py</td><td>doplňování příkazů pomocí WordCompleteru</td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt5_WordCompleter.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt5_WordCompleter.py</a></td></tr>
<tr><td>7</td><td>prompt6_vi_mode.py</td><td>přepnutí do režimu emulace Vi (varianta A)</td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt6_vi_mode.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt6_vi_mode.py</a></td></tr>
<tr><td>7</td><td>prompt7_vi_mode_B.py</td><td>přepnutí do režimu emulace Vi (varianta B)</td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt7_vi_mode_B.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt7_vi_mode_B.py</a></td></tr>
<tr><td>7</td><td>prompt8_Emacs_mode.py</td><td>přepnutí do režimu emulace Emacsu</td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt8_Emacs_mode.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt8_Emacs_mode.py</a></td></tr>
<tr><td>8</td><td>prompt9_PromptSession_password_mode.py</td><td>režim zápisu hesla</td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt9_PromptSession_password_mode.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt9_PromptSession_password_mode.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

