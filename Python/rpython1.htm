<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>RPython: překvapivě výkonný dialekt Pythonu na němž je založen PyPy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>RPython: překvapivě výkonný dialekt Pythonu na němž je založen PyPy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>S alternativní implementací Pythonu nazvanou PyPy se již pravděpodobně přímo či nepřímo setkal každý vývojář, který tento jazyk používá. Projekt PyPy je mj. založen na transpřekladači RPythonu, s jehož základními vlastnostmi se dnes seznámíme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. RPython: překvapivě výkonný dialekt Pythonu na němž je založen PyPy</a></p>
<p><a href="#k02">2. Použití RPythonu</a></p>
<p><a href="#k03">3. Instalace nástroje RPython</a></p>
<p><a href="#k04">4. První demonstrační příklad: &bdquo;Hello world!&ldquo; připravený pro RPython</a></p>
<p><a href="#k05">5. Překlad demonstračního příkladu do nativního kódu</a></p>
<p><a href="#k06">6. Výsledek překladu</a></p>
<p><a href="#k07">7. Ukončení překladu ve funkci <strong>target</strong></a></p>
<p><a href="#k08">8. Volba jiné funkce použité v&nbsp;<i>runtime</i> pro vstup do programu</a></p>
<p><a href="#k09">9. Zpracování argumentů předaných z&nbsp;příkazového řádku v&nbsp;<i>runtime</i></a></p>
<p><a href="#k10">10. Analýza bajtkódu a &bdquo;líný&ldquo; překlad</a></p>
<p><a href="#k11">11. Základní omezení kladená RPythonem</a></p>
<p><a href="#k12">12. Chování globálních proměnných</a></p>
<p><a href="#k13">13. Rychlost výsledného nativního kódu produkovaného RPythonem</a></p>
<p><a href="#k14">14. Příprava jednoduchého mikrobenchmarku orientovaného na numerické výpočty</a></p>
<p><a href="#k15">15. Úprava kódu takovým způsobem, aby byl kompatibilní s&nbsp;RPythonem</a></p>
<p><a href="#k16">16. Skripty pro spuštění benchmarku se zvoleným interpretrem a parametry</a></p>
<p><a href="#k17">17. Malá odbočka &ndash; implementace totožného algoritmu v&nbsp;ANSI C</a></p>
<p><a href="#k18">18. Výsledky benchmarků &ndash; porovnání s&nbsp;Pythonem 2, Pythonem 3, Jythonem a ANSI C</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. RPython: překvapivě výkonný dialekt Pythonu na němž je založen PyPy</h2>

<p><i>&bdquo;RPython is half-Python, half-not-Python, and Python&ldquo;</i></p>

<p>S&nbsp;projektem <a href="http://pypy.org/">PyPy</a> se již s&nbsp;velkou
pravděpodobností setkalo mnoho programátorů používajících pro vývoj
programovací jazyk Python. Jen ve stručnosti si řekněme, že se jedná o jednu
z&nbsp;(dnes již velkého množství) implementací Pythonu, která je založena na
interpretru (podobně jako klasický CPython) zkombinovaném s&nbsp;just-in-time
překladačem (<i>JITem</i>). Samotný projekt PyPy je přitom z&nbsp;velké části
napsán ve dvou jazycích &ndash; běžném Pythonu a navíc i v&nbsp;RPythonu, což
je programovací jazyk, jehož základní vlastnosti si dnes představíme. RPython
získal své jméno ze sousloví &bdquo;Restricted Python&ldquo;, přičemž všechna
omezení, která RPython zavádí, jsou pečlivě vybrána z&nbsp;toho důvodu, aby se
zjednodušila či vůbec umožnila analýza (R)pythonovského kódu, který je
překládán do nativního (objektového) kódu.</p>

<p>Tím se dostáváme k&nbsp;základní vlastnosti RPythonu &ndash; ten totiž není
interpretován, ale skutečně překládán do objektového kódu a z&nbsp;výsledku se
vytváří spustitelná aplikace. Celý proces zpracování je poměrně komplikovaný a
zdlouhavý, ale ve stručnosti ho lze popsat několika body:</p>

<ol>

<li>Na vstupu se nachází zdrojové kódy naprogramované v&nbsp;RPythonu
(<strong>.py</strong>)</li>

<li>Nejprve je ze zdrojových kódů vytvořen bajtkód (<strong>.pyc</strong>)</li>

<li>Z&nbsp;bajtkódu se vygeneruje <a
href="https://en.wikipedia.org/wiki/Control_flow_graph">CFG</a> a ten se
následně analyzuje</li>

<li>Grafovou strukturou se prochází a mj.&nbsp;se provádí anotace proměnných
(odvození typů, viditelnosti apod.)</li>

<li>Následuje několik konverzí, které se mohou lišit podle toho, pro jakou
platformu se generuje výsledek a jaké optimalizace jsou povoleny (inlining,
rozbalení smyček atd.)</li>

<li>Dále se do mezivýsledku vkládají i instrukce pro GC</li>

<li>Z&nbsp;grafové struktury se vygeneruje zdrojový kód pro výslednou platformu
(typicky pro překladače ANSI C, což je platforma, která nás zajímá dnes)</li>

<li>Pro naši platformu: překladačem ANSI C se provede překlad do objektového
kódu</li>

<li>Nakonec se provede slinkování a vytvoření výsledného spustitelného souboru
(nebo dynamické knihovny)</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Použití RPythonu</h2>

<p>S&nbsp;RPythonem jsme se již nepřímo setkali v&nbsp;článku <a
href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">Pixie:
lehký skriptovací jazyk s „kouzelnými“ schopnostmi</a>. A skutečně &ndash;
RPython se typicky používá pro psaní interpretrů dalších programovacích jazyků,
protože pro toto použití nabízí platforma PyPy dobré nástroje. Ve skutečnosti
je však možné RPython použít i pro vlastní projekty, ovšem musíme se smířit
s&nbsp;některými omezeními a problémy při snaze používat celý ekosystém
postavený okolo Pythonu. Ovšem například v&nbsp;situaci, kdy máme naprogramován
a odladěn nějaký výpočet v&nbsp;Pythonu může být zajímavé ho přeložit RPythonem
a využít tak toho, že výsledek je relativně dobře optimalizovaný nativní kód
(ostatně se můžete podívat na benchmark popsaný níže).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace nástroje RPython</h2>

<p>Pro instalaci RPythonu je možné použít nástroj <i>pip</i>, a to konkrétně
<i>pip2</i> ve verzi určené pro Python 2.x a nikoli <i>pip3</i>, který je
určený pro Python 3 (v&nbsp;tomto případě by se totiž již při instalaci hlásily
chyby kvůli nekompatibilitě Python 2 vs. Python 3). Samotný proces instalace
není časově náročný, protože na většině počítačů jsou již nainstalovány všechny
závislé balíky, především překladač ANSI C:</p>

<pre>
$ <strong>pip install --user rpython</strong>
&nbsp;
Collecting rpython
...
...
...
Installing collected packages: py, pytest, rpython
Successfully installed py-1.5.3 pytest-2.9.2 rpython-0.2.1
</pre>

<p>Základní kontrola instalace:</p>

<pre>
$ <strong>rpython</strong>
&nbsp;
RPython translation usage:
&nbsp;
rpython &lt;translation options&gt; target &lt;targetoptions&gt;
&nbsp;
run with --help for more information
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. První demonstrační příklad: &bdquo;Hello world!&ldquo; připravený pro RPython</h2>

<p>Ukažme si nyní, jak vypadá klasický příklad, který se dnes již tradičně
(vlastně už od dob slavné <a
href="https://en.wikipedia.org/wiki/The_C_Programming_Language">The C
Programming Language</a>) objevuje v&nbsp;prakticky každé knížce popisující
nový programovací jazyk. Jedná se samozřejmě o program vypisující na obrazovku
&bdquo;Hello world!&ldquo;. V&nbsp;klasickém Pythonu by se jednalo o
jednořádkový problém:</p>

<pre>
print("Hello world!")
</pre>

<p>V&nbsp;RPythonu to ovšem není tak jednoduché, protože se v&nbsp;něm, na
rozdíl od klasického interpretru, ostře rozlišují dvě fáze spuštění kódu:</p>

<ol>
<li>Fáze překladu (<i>compile time</i>)</li>
<li>Fáze běhu (<i>runtime</i>)</li>
</ol>

<p>Ve fázi překladu se (poněkud zjednodušeně řečeno) spouští funkce nazvaná
<strong>target</strong> (<a
href="https://bitbucket.org/pypy/pypy/src/tip/rpython/translator/goal/targetrpystonex.py?fileviewer=file-view-default">definice</a>),
v&nbsp;níž může programátor ovlivnit způsob překladu, předat další parametry
tzv.&nbsp;driveru apod. Funkce <strong>target</strong> v&nbsp;tom
nejjednodušším případě vrací dvě hodnoty: především referenci na funkci, která
se má spustit v&nbsp;čase běhu programu (<i>runtime</i>) a typy argumentů
předané této funkci (vstupní bod do programu). Funkce spouštěná
v&nbsp;<i>runtime</i> bývá tradičně pojmenována <strong>entry_point</strong>.
Celý zdrojový kód je tedy poněkud složitější a navíc je chování obou v&nbsp;něm
definovaných funkcí zcela odlišné (<i>compile time</i> &times;
<i>runtime</i>):</p>

<pre>
def <strong>entry_point</strong>(argv):
    print "Hello world!"
    return 0
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že pro jistotu používám
syntaxi Pythonu 2.x.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad demonstračního příkladu do nativního kódu</h2>

<p>Překlad demonstračního příkladu, jehož zdrojový kód jsme si uvedli <a
href="#k04">v&nbsp;předchozí kapitole</a>, se provede takto:</p>

<pre>
$ <strong>rpython rpython_basic.py</strong>
</pre>

<p>Celý překlad je rozdělen na několik fází zmíněných v&nbsp;navazujících
kapitolách. Navíc se v&nbsp;žádném případě nejedná o rychlou operaci, protože
například na mém postarším notebooku s&nbsp;mikroprocesorem i5 (čtyřjádro) se
všechny fáze provedly v&nbsp;25 sekundách, což skutečně není nezanedbatelná
doba (je to jedna z&nbsp;věcí, která vás může od použití RPythonu odradit). Na
začátku výpisu si povšimněte zprávy &bdquo;*** target ***&ldquo;, kterou jsme
vložili do funkce <strong>target</strong>:</p>

<pre>
[translation:info] 2.7.6 (default, Nov 23 2017, 15:49:48) 
[GCC 4.8.4]
[platform:msg] Set platform with 'host' cc=None, using cc='gcc', version='Unknown'
[translation:info] Translating target as defined by rpython_basic
<strong>*** target ***</strong>
...
...
...
starting source_c
[c:writing] structdef.h
[c:writing] forwarddecl.h
[c:writing] preimpl.h
[c:writing] data_rpython_flowspace.c
[c:writing] data_rpython_memory_gc.c
[c:writing] data_rpython_memory_gctransform.c
[c:writing] data_rpython_rlib.c
[c:writing] data_rpython_rtyper.c
[c:writing] data_rpython_rtyper_lltypesystem.c
[c:writing] data_rpython_translator_c.c
[c:writing] nonfuncnodes.c
[c:writing] data_rpython_memory_gc_1.c
[c:writing] data_rpython_rlib_1.c
[c:writing] data_rpython_rtyper_lltypesystem_1.c
[c:writing] implement.c
[c:writing] rpython_flowspace.c
[c:writing] rpython_memory.c
[c:writing] rpython_memory_gc.c
[c:writing] rpython_memory_gctransform.c
[c:writing] rpython_rlib.c
[c:writing] rpython_rtyper.c
[c:writing] rpython_rtyper_lltypesystem.c
[c:writing] rpython_translator.c
[c:writing] rpython_translator_c.c
[translation:info] written: /tmp/usession-unknown-5/testing_1/testing_1.c
[5ff] translation-task}
[translation:info] Compiling c source...
[5ff] {translation-task
starting compile_c
[platform:execute] make -j 3 in /tmp/usession-unknown-5/testing_1
[translation:info] created: /home/tester/temp/rpython_basic-c
[600] translation-task}
[translation:info] usession directory: /tmp/usession-unknown-5
[Timer] Timings:
[Timer] annotate                       ---  6.1 s
[Timer] rtype_lltype                   ---  0.5 s
[Timer] backendopt_lltype              ---  0.2 s
[Timer] stackcheckinsertion_lltype     ---  0.0 s
[Timer] database_c                     --- 12.8 s
[Timer] source_c                       ---  1.6 s
[Timer] compile_c                      ---  4.0 s
[Timer] =========================================
[Timer] Total:                         --- 25.1 s
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je výpis mnohem delší,
uvedl jsem jen jeho závěr s&nbsp;výslednými časy.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledek překladu</h2>

<p>V&nbsp;adresáři, z&nbsp;něhož jsme spustili RPython, by se měl po již
zmíněných přibližně 25 sekundách objevit nový spustitelný soubor nazvaný
<strong>rpython_basic-c</strong>. Ihned si ho samozřejmě můžeme otestovat:</p>

<pre>
$ <strong>./rpython_basic-c</strong>
&nbsp;
Hello world!
</pre>

<p>Popř.&nbsp;se ujistit, že se skutečně jedná o nativní (spustitelný) soubor:</p>

<pre>
$ <strong>file rpython_basic-c</strong>
&nbsp;
rpython_basic-c: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=e7d1b7a4c9612a82abc07f29752e9d29e4f83ab7, not stripped
</pre>

<p>Samotný soubor je relativně velký (například v&nbsp;porovnání
s&nbsp;&bdquo;Hello world!&ldquo; napsaným v&nbsp;céčku), ovšem na tomto místě
je zapotřebí říct, že jeho velikost poroste s&nbsp;rozsáhlejší aplikací poměrně
pomalu. Důvodem pro tento poměrně velký objem je přidání GC a dalších nástrojů
do binárního výsledku:</p>

<pre>
$ <strong>ls -l rpython_basic-c</strong>
&nbsp;
-rwxr-xr-x 1 tester tester 275126 čen  9 20:58 rpython_basic-c
</pre>

<p>Nepatrně pomůže utilitka <strong>strip</strong>:</p>

<pre>
$ <strong>strip rpython_basic-c </strong>
</pre>

<p>S&nbsp;výslednou velikostí přibližně 210 kB:</p>

<pre>
$ <strong>ls -l rpython_basic-c</strong>
&nbsp;
-rwxr-xr-x 1 tester tester 218224 čen  9 21:01 rpython_basic-c
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;adresáři <strong>/tmp</strong> se
při překladu vytváří podadresáře s&nbsp;mezisoubory (*.c, *.o atd.). Tyto
podadresáře jsou poměrně rozsáhlé, takže si nezapomeňte nastavit systém tak,
aby je postupně promazával popř.&nbsp;je &bdquo;likvidujte&ldquo; sami.
V&nbsp;těchto podadresářích naleznete i další generované soubory, například
flow diagram apod.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Ukončení překladu ve funkci <strong>target</strong></h2>

<p><a href="#k04">Ve čtvrté kapitole</a> jsme si řekli, že funkce
<strong>target</strong> je volaná v&nbsp;čase překladu (<i>compile time</i>) a
typicky se používá pro ovlivnění vlastního překladu i pro specifikaci vstupního
bodu do výsledného programu. Co se ovšem stane, když v&nbsp;této funkci
jednoduše zavoláme <strong>exit</strong>? Můžeme si to samozřejmě vyzkoušet.
Celý program zkrátíme na jedinou funkci:</p>

<pre>
def <strong>target</strong>(driver, args):
    print "*** target ***"
    exit(0)
</pre>

<p>A vyzkoušíme překlad:</p>

<pre>
$ <strong>rpython rpython_stop_compile.py</strong>
&nbsp;
[version:WARNING] Errors getting Mercurial information: Not running from a Mercurial repository!
[translation:info] 2.7.6 (default, Nov 23 2017, 15:49:48) 
[GCC 4.8.4]
[platform:msg] Set platform with 'host' cc=None, using cc='gcc', version='Unknown'
[translation:info] Translating target as defined by rpython_stop_compile
*** target ***
</pre>

<p>Vidíme, že překlad byl skutečně ukončen již v&nbsp;jeho počáteční fázi.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Volba jiné funkce použité v&nbsp;<i>runtime</i> pro vstup do programu</h2>

<p>Funkce, která bude v&nbsp;čase běhu (<i>runtime</i>) použita jako vstup do
výsledného programu, se samozřejmě nemusí jmenovat
<strong>entry_point</strong>, ale můžeme si ji pojmenovat zcela libovolně;
samozřejmě ovšem tak, aby odpovídala jmenným konvencím Pythonu:</p>

<pre>
def <strong>muj_vstupni_bod_do_aplikace</strong>(argv):
    print "Hello world!"
    return 0
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return <strong>muj_vstupni_bod_do_aplikace</strong>, None
</pre>

<p><div class="rs-tip-major">Poznámka: nemusíte si vůbec dělat starosti se
jmennými konvencemi, resp.&nbsp;mezi jejich rozdíly v&nbsp;Pythonu a C. Tyto
rozdíly transpřekladač automaticky vyřeší.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zpracování argumentů předaných z&nbsp;příkazového řádku v&nbsp;<i>runtime</i></h2>

<p>Pro úplnost se ještě podívejme na způsob zpracování argumentů (přepínačů
atd.), které jsou aplikaci předány v&nbsp;době běhu (<i>runtime</i>).
V&nbsp;tomto případě použijeme <strong>argv</strong> s&nbsp;nímž se pracuje
naprosto stejně, jako s&nbsp;jakoukoli jinou sekvencí. S&nbsp;dalším použitím
se setkáme při popisu benchmarků o několik kapitol níže:</p>

<pre>
def <strong>entry_point</strong>(argv):
    print "Command line arguments:"
    for arg in argv:
        print arg
    return 0
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>

<p>Pokud nyní aplikaci přeložíme a následně spustíme výsledný binární soubor
s&nbsp;několika parametry (libovolnými):</p>

<pre>
$ <strong>./rpython_cli_arguments-c prvni druhy --help --foo=bar</strong>
</pre>

<p>Získáme tento výsledek:</p>

<pre>
Command line arguments:
./rpython_cli_arguments-c
prvni
druhy
--help
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Analýza bajtkódu a &bdquo;líný&ldquo; překlad</h2>

<p>Velmi zajímavou vlastností RPythonu je to, že provádí takzvaný
&bdquo;líný&ldquo; překlad (což není přesný terminus technicus, ale dobře se
pamatuje :-). Díky tomu, že RPython nejprve přeloží Pythonovský zdrojový kód do
bajtkódu a následně analyzuje tento bajtkód, dokáže (většinou) zkonstruovat
orientovaný graf, v&nbsp;němž je jednoznačně určeno vzájemné volání funkcí.
Zjednodušený graf může vypadat následovně:</p>

<a href="https://www.root.cz/obrazek/332084/"><img src="https://i.iinfo.cz/images/450/rpython1-1-prev.png" class="image-332084" alt="&#160;" width="370" height="168" /></a>
<p><i>Obrázek 1: Graf volání funkcí.</i></p>

<p><div class="rs-tip-major">Ve skutečnosti je možné graf prohlížet
interaktivně po zadání volby <strong>--view</strong>, což si popíšeme
příště.</div></p>

<p>Z&nbsp;grafu je možné vyčíst všechny funkce, které jsou volány. To vlastně
znamená, že ty funkce, které v&nbsp;grafu nenalezneme, nejsou volány a tudíž se
nemusí překládat. Zda je tomu skutečně tak si můžeme snadno otestovat na
následujícím příkladu, v&nbsp;němž jsou definovány tři funkce tisknoucí dlouhé
řetězce. Ovšem ve skutečnosti se volá jen jediná z&nbsp;těchto funkcí:</p>

<pre>
def <strong>foo</strong>():
    print "FOO FOO FOO FOO FOO FOO FOO FOO FOO"
&nbsp;
&nbsp;
def <strong>bar</strong>():
    print "BAR BAR BAR BAR BAR BAR BAR BAR BAR"
&nbsp;
&nbsp;
def <strong>baz</strong>():
    print "BAZ BAZ BAZ BAZ BAZ BAZ BAZ BAZ BAZ"
&nbsp;
&nbsp;
def <strong>entry_point</strong>(argv):
    print "Hello world!"
    foo()
    return 0
&nbsp;
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>

<p>Po překladu zdrojového kódu získáme spustitelný soubor nazvaný
<strong>rpython_lazy_compile</strong> a můžeme ho prozkoumat, například
jednoduchou utilitkou <strong>strings</strong> určenou pro hledání řetězců:</p>

<pre>
$ <strong>strings rpython_lazy_compile-c | grep FOO</strong>
FOO FOO FOO FOO FOO FOO FOO FOO FOO
&nbsp;
$ <strong>strings rpython_lazy_compile-c | grep BAR</strong>
&nbsp;
$ <strong>strings rpython_lazy_compile-c | grep BAZ</strong>
&nbsp;
</pre>

<p>Vidíme, že se našel jen první řetězec, zatímco další dva nejsou do
výsledného binárního souboru přidány (a ani těla příslušných funkcí).</p>

<p>Samozřejmě si vše můžeme vyzkoušet na složitějším příkladu se třemi volanými
funkcemi tisknoucími řetězec a třemi funkcemi, které se nikde volat
nebudou:</p>

<pre>
def <strong>foo</strong>():
    print "FOO FOO FOO FOO FOO FOO FOO FOO FOO"
    bar()
    baz()
&nbsp;
&nbsp;
def <strong>bar</strong>():
    print "BAR BAR BAR BAR BAR BAR BAR BAR BAR"
    baz()
&nbsp;
&nbsp;
def <strong>baz</strong>():
    print "BAZ BAZ BAZ BAZ BAZ BAZ BAZ BAZ BAZ"
&nbsp;
&nbsp;
def <strong>aaa</strong>():
    print "AAA AAA AAA AAA AAA AAA AAA AAA AAA"
&nbsp;
&nbsp;
def <strong>bbb</strong>():
    print "BBB BBB BBB BBB BBB BBB BBB BBB BBB"
&nbsp;
&nbsp;
def <strong>ccc</strong>():
    print "CCC CCC CCC CCC CCC CCC CCC CCC CCC"
&nbsp;
&nbsp;
def <strong>entry_point</strong>(argv):
    print "Hello world!"
    foo()
    return 0
&nbsp;
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>

<p><div class="rs-tip-major">RPython ve skutečnosti dokáže zpracovat i funkce
volané v&nbsp;podmíněné větvi atd. To ovšem klade větší nároky na samotného
programátora, protože všechny podmínky musí mít známé typy operandů, které do
nich vstupují apod.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Základní omezení kladená RPythonem</h2>

<p>RPython získal své jméno ze sousloví &bdquo;Restricted Python&ldquo;,
protože některé konstrukce buď vůbec nepodporuje, nebo pouze v&nbsp;takové
podobě, aby byl umožněn korektní překlad do nativního kódu. Jedním
z&nbsp;omezení je, že v&nbsp;každém řídicím bodu programu, například těsně pod
spojením dvou větví, musí být zcela jednoznačný typ hodnot uložených do
proměnných. Zatímco klasický Python je v&nbsp;tomto ohledu velmi dynamický,
následující kód není možné v&nbsp;RPythonu použít:</p>

<pre>
def <strong>entry_point</strong>(argv):
    if len(argv) == 1:
        x = "one"
    else:
        x = 42
    print x
    return 0
&nbsp;
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>

<p>Při pokusu o překlad se zobrazí chybové hlášení:</p>

<pre>
[translation:ERROR] UnionError: 
&nbsp;
Offending annotations:
  SomeInteger(const=0, knowntype=int, nonneg=True, unsigned=False)
  SomeString(const='one', no_nul=True)
&nbsp;
In &lt;FunctionGraph of (rpython_types:1)entry_point at 0x7f6742ec1750&gt;:
Happened at file rpython_types.py line 6
&nbsp;
        print x
</pre>

<p>Naproti tomu je následující kód přeložitelný, a to proto, že se jedna větev
už při překladu eliminuje (<i>compile-time optimization</i>), takže RPython ví,
že k&nbsp;žádnému větvení vůbec nedošlo:</p>

<pre>
def <strong>entry_point</strong>(argv):
    if True:
        x = "one"
    else:
        x = 42
    print x
    return 0
&nbsp;
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Chování globálních proměnných</h2>

<p>Globální proměnné se chovají jako konstanty, resp.&nbsp;přesněji řečeno
RPython hlídá, zda se je nesnažíme přímo měnit. Příklad kódu, který je korektní
v&nbsp;Pythonu, ovšem RPython ho nepřeloží:</p>

<pre>
x = 42
&nbsp;
def <strong>entry_point</strong>(argv):
    global x
    print x
    x *= 1
    return 0
&nbsp;
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>

<p>Chyba při překladu:</p>

<pre>
[translation:ERROR] FlowingError: 
&nbsp;
Attempting to modify global variable  'x'.
&nbsp;
In &lt;FunctionGraph of (rpython_globals:3)entry_point at 0x7fac55b30810&gt;:
Happened at file rpython_globals.py line 6
&nbsp;
        x *= 1
</pre>

<p>Totéž omezení platí i ve chvíli, kdy se budeme snažit měnit nikoli hodnotu
navázanou na proměnnou, ale stav této hodnoty (například seznamu). Následující
kód se sice přeloží (neměl by :-), ovšem po spuštění získáme nekonzistentní
výsledek (v&nbsp;našem případě dva prázdné seznamy):</p>

<pre>
x = []
&nbsp;
def <strong>entry_point</strong>(argv):
    global x
    print x
    x.append(10)
    print x
    return 0
&nbsp;
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>

<p>Spuštění:</p>

<pre>
$ <strong>./rpython_globals_2-c</strong>
&nbsp;
[]
[]
</pre>

<p>Další omezení si popíšeme příště.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Rychlost výsledného nativního kódu produkovaného RPythonem</h2>

<p>Jedním z&nbsp;hlavních důvodů, proč může být u některých projektů vůbec
užitečné uvažovat o praktickém použití RPythonu, je relativně velký výpočetní
výkon výsledného nativního kódu. Ten sice většinou nedosahuje rychlosti
dosažené při přepsání celé aplikace do jazyka C nebo C++ popř.&nbsp;do Rustu,
jehož překladač se neustále vylepšuje (o assembleru ani nemluvě, to však již
vyžaduje velké znalosti cílové architektury), ovšem výhody jazyka odvozeného od
vysokoúrovňového Pythonu mohou v&nbsp;mnoha případech převažovat. Klasický
CPython, a to jak verze 2.x tak i 3.x, totiž skutečně <a
href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/python3-gcc.html">velkou
rychlostí výsledného interpretovaného kódu neoplývá</a> a například Jython je
v&nbsp;mnoha případech dokonce ještě pomalejší než CPython, což může být
překvapující, neboť v&nbsp;Jythonu se provádí překlad do bajtkódu JVM, který je
průběžně JITován (a JIT v&nbsp;JVM vůbec není špatný).</p>

<p>Tento problém se většinou týká programů, které jsou zaměřeny na výpočty; u
typických serverových aplikací s&nbsp;databází, messagingem atd. se jedná o
méně závažné omezení (zde více záleží na tom, jak se nám podaří odstranit
potřebu synchronizace vláken). Zkusme si nyní vytvořit prozatím velmi
jednoduchý (mikro)benchmark určený pro porovnání rychlosti Jythonu, CPythonu
2.x, CPythonu 3.x a RPythonu se zaměřením na výpočty (další benchmarky se
zpracováním datových struktur budou popsány příště). Všechny benchmarky byly
spuštěny na Fedoře 27 a použity byly následující verze Pythonu:</p>

<ol>
<li>Jython 2.7.0</li>
<li>Python 2.7.14</li>
<li>Python 3.6.3</li>
</ol>

<p><div class="rs-tip-major">Poznámka: celý benchmark je napsán takovým
způsobem, aby nevyžadoval použití externích knihoven. V&nbsp;praxi bychom ovšem
mohli použít například <i>numpy</i>, čímž by se část výpočtu automaticky
prováděla v&nbsp;nativním kódu (ostatně právě vylepšená podpora <i>numpy</i>
v&nbsp;PyPy a tím pádem i v&nbsp;RPythonu je součástí vývoje další verze
PyPy).</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: pro zajímavost ještě
benchmark přepíšeme do ANSI C a porovnáme rychlost běhu této
implementace.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Příprava jednoduchého mikrobenchmarku orientovaného na numerické výpočty</h2>

<p>Vzhledem k&nbsp;tomu, že se v&nbsp;dnešním benchmarku budeme do značné míry
snažit vyhnout měření rychlosti knihovních funkcí, bude <a
href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/mandelbrot_python.py">celý
benchmark</a> skutečně provádět prakticky jen výpočty s&nbsp;výpisem výsledku
výpočtů na standardní výstup. Ten bude přesměrován do souboru, protože
výsledkem výpočtů budou bitmapy ve formátu <i>Portable Pixel Map</i> (viz [<a
href="https://www.root.cz/clanky/graficke-formaty-ve-znameni-unixu/#k06">1</a>]).
Samozřejmě, že i výpis hodnot na standardní výstup znamená nutnost volání
knihovních funkcí, ovšem oproti počtu numerických operací se bude jednat o
minimální čas, což je možné zjistit například profilerem, popř.&nbsp;úplným
zákazem výstupu (to však nechceme &ndash; musíme i optimalizující překladač
donutit, aby volání funkcí z&nbsp;kódu zcela neodstranil).</p>

<p><div class="rs-tip-major">Poznámka: ukazuje se, že čas strávený I/O
operacemi se viditelně projeví prakticky jen u RPythonu, protože ostatní
interpretry jsou tak pomalé, že I/O tvoří nepatrné procento celkového
času.</div></p>

<p>Celý benchmark spočívá ve výpočtu barev pixelů <a
href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xii/">Mandelbrotovy
množiny</a>, přičemž rozlišení výsledného rastrového obrázku i maximální počet
iterací bude možné zvolit z&nbsp;příkazového řádku. Následuje výpis zdrojového
kódu benchmarku (kód je napsán tak, aby byl kompatibilní s&nbsp;Pythonem 2.x,
Pythonem 3.x i Jythonem, ovšem prozatím nikoli s&nbsp;RPythonem):</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import palette_mandmap
from sys import argv, exit
&nbsp;
&nbsp;
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
    print("P3")
    print("{w} {h}".format(w=width, h=height))
    print("255")
&nbsp;
    cy = -1.5
    for y in range(0, height):
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print("{r} {g} {b}".format(r=r, g=g, b=b))
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        print("usage: python mandelbrot width height maxiter")
        exit(1)
&nbsp;
    width = int(argv[1])
    height = int(argv[2])
    maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p>V&nbsp;benchmarku se používá i další modul nazvaný
<strong>palette_mandmap.py</strong>, který obsahuje barvovou paletu
(<i>palette, color map</i>). Paleta byla získána ze známého (a dnes již vlastně
historického) programu <i>Fractint</i> a obsahuje 256 trojic hodnot R, G, B.
Samotná paleta nemá prakticky žádný vliv na naměřené hodnoty, ale výsledné
obrázky jsou díky ní hezčí:</p>

<pre>
<i># taken from Fractint</i>
palette = (
        (255, 255, 255), (224, 224, 224), (216, 216, 216), (208, 208, 208),
        (200, 200, 200), (192, 192, 192), (184, 184, 184), (176, 176, 176),
        (168, 168, 168), (160, 160, 160), (152, 152, 152), (144, 144, 144),
        (136, 136, 136), (128, 128, 128), (120, 120, 120), (112, 112, 112),
        (104, 104, 104),  (96,  96,  96),  (88,  88,  88),  (80,  80,  80),
        (72,   72,  72),  (64,  64,  64),  (56,  56,  56),  (48,  48,  56),
        (40,   40,  56),  (32,  32,  56),  (24,  24,  56),  (16,  16,  56),
        (8,     8,  56), (000, 000,  60), (000, 000,  64), (000, 000,  72),
        (000, 000,  80), (000, 000,  88), (000, 000,  96), (000, 000, 104),
        (000, 000, 108), (000, 000, 116), (000, 000, 124), (000, 000, 132),
        (000, 000, 140), (000, 000, 148), (000, 000, 156), (000, 000, 160),
        (000, 000, 168), (000, 000, 176), (000, 000, 184), (000, 000, 192),
        (000, 000, 200), (000, 000, 204), (000, 000, 212), (000, 000, 220),
        (000, 000, 228), (000, 000, 236), (000, 000, 244), (000, 000, 252),
        (000,   4, 252),   (4,  12, 252),   (8,  20, 252),  (12,  28, 252),
        (16,   36, 252),  (20,  44, 252),  (20,  52, 252),  (24,  60, 252),
        (28,   68, 252),  (32,  76, 252),  (36,  84, 252),  (40,  92, 252),
        (40,  100, 252),  (44, 108, 252),  (48, 116, 252),  (52, 120, 252),
        (56,  128, 252),  (60, 136, 252),  (60, 144, 252),  (64, 152, 252),
        (68,  160, 252),  (72, 168, 252),  (76, 176, 252),  (80, 184, 252),
        (80,  192, 252),  (84, 200, 252),  (88, 208, 252),  (92, 216, 252),
        (96,  224, 252), (100, 232, 252), (100, 228, 248),  (96, 224, 244),
        (92,  216, 240),  (88, 212, 236),  (88, 204, 232),  (84, 200, 228),
        (80,  192, 220),  (76, 188, 216),  (76, 180, 212),  (72, 176, 208),
        (68,  168, 204),  (64, 164, 200),  (64, 156, 196),  (60, 152, 188),
        (56,  144, 184),  (52, 140, 180),  (52, 132, 176),  (48, 128, 172),
        (44,  120, 168),  (40, 116, 160),  (40, 108, 156),  (36, 104, 152),
        (32,   96, 148),  (28,  92, 144),  (28,  84, 140),  (24,  80, 136),
        (20,   72, 128),  (16,  68, 124),  (16,  60, 120),  (12,  56, 116),
        (8,    48, 112),   (4,  44, 108), (000,  36, 100),   (4,  36, 104),
        (12,   40, 108),  (16,  44, 116),  (24,  48, 120),  (28,  52, 128),
        (36,   56, 132),  (40,  60, 140),  (48,  64, 144),  (52,  64, 148),
        (60,   68, 156),  (64,  72, 160),  (72,  76, 168),  (76,  80, 172),
        (84,   84, 180),  (88,  88, 184),  (96,  92, 192), (104, 100, 192),
        (112, 112, 196), (124, 120, 200), (132, 132, 204), (144, 140, 208),
        (152, 152, 212), (164, 160, 216), (172, 172, 220), (180, 180, 224),
        (192, 192, 228), (200, 200, 232), (212, 212, 236), (220, 220, 240),
        (232, 232, 244), (240, 240, 248), (252, 252, 252), (252, 240, 244),
        (252, 224, 232), (252, 208, 224), (252, 192, 212), (252, 176, 204),
        (252, 160, 192), (252, 144, 184), (252, 128, 172), (252, 112, 164),
        (252,  96, 152), (252,  80, 144), (252,  64, 132), (252,  48, 124),
        (252,  32, 112), (252,  16, 104), (252, 000,  92), (236, 000,  88),
        (228, 000,  88), (216,   4,  84), (204,   4,  80), (192,   8,  76),
        (180,   8,  76), (168,  12,  72), (156,  16,  68), (144,  16,  64),
        (132,  20,  60), (124,  20,  60), (112,  24,  56), (100,  24,  52),
        (88,   28,  48),  (76,  32,  44),  (64,  32,  44),  (52,  36,  40),
        (40,   36,  36),  (28,  40,  32),  (16,  44,  28),  (20,  52,  32),
        (24,   60,  36),  (28,  68,  44),  (32,  76,  48),  (36,  88,  56),
        (40,   96,  60),  (44, 104,  64),  (48, 112,  72),  (52, 120,  76),
        (56,  132,  84),  (48, 136,  84),  (40, 144,  80),  (52, 148,  88),
        (68,  156, 100),  (80, 164, 112),  (96, 168, 124), (108, 176, 136),
        (124, 184, 144), (136, 192, 156), (152, 196, 168), (164, 204, 180),
        (180, 212, 192), (192, 220, 200), (208, 224, 212), (220, 232, 224),
        (236, 240, 236), (252, 248, 248), (252, 252, 252), (252, 252, 240),
        (252, 252, 228), (252, 252, 216), (248, 248, 204), (248, 248, 192),
        (248, 248, 180), (248, 248, 164), (244, 244, 152), (244, 244, 140),
        (244, 244, 128), (244, 244, 116), (240, 240, 104), (240, 240,  92),
        (240, 240,  76), (240, 240,  64), (236, 236,  52), (236, 236,  40),
        (236, 236,  28), (236, 236,  16), (232, 232,   0), (232, 232,  12),
        (232, 232,  28), (232, 232,  40), (236, 236,  56), (236, 236,  68),
        (236, 236,  84), (236, 236,  96), (240, 240, 112), (240, 240, 124),
        (240, 240, 140), (244, 244, 152), (244, 244, 168), (244, 244, 180),
        (244, 244, 196), (248, 248, 208), (248, 248, 224), (248, 248, 236),
        (252, 252, 252), (248, 248, 248), (240, 240, 240), (232, 232, 232))
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Úprava kódu takovým způsobem, aby byl kompatibilní s&nbsp;RPythonem</h2>

<p>Programový kód původně připravený pro Python nepůjde přímo použít
v&nbsp;RPythonu. Změn, které je nutné provést, je hned několik, i když nejsou
příliš zásadní (alespoň v&nbsp;případě našeho benchmarku). Samozřejmě se bude
odlišovat především samotný vstupní bod do aplikace, který bude vypadat
takto:</p>

<pre>
def <strong>entry_point</strong>(argv):
    if len(argv) &lt; 4:
        print("usage: ./mandelbrot width height maxiter")
        return 1
&nbsp;
    width = int(argv[1])
    height = int(argv[2])
    maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
    return 0
</pre>

<p>Deklarace vstupního bodu &ndash; to již dobře známe:</p>

<pre>
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>

<p>Dále jsou úpravy nepatrné, pouze změníme funkci <strong>print</strong> za
příkaz <strong>print</strong> a odstraníme formátování výstupu (to sice jde
udělat, ale nepatrně komplikovaněji):</p>

<pre>
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
    print "P3"
    print width, height
    print "255"
    ...
    ...
    ...
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print r, g, b
    ...
    ...
    ...
</pre>

<p>Výsledný zdrojový kód připravený pro překlad s&nbsp;využitím RPythonu vypadá
následovně:</p>

<pre>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import palette_mandmap
from sys import argv, exit
&nbsp;
&nbsp;
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
    print "P3"
    print width, height
    print "255"
&nbsp;
    cy = -1.5
    for y in range(0, height):
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            print r, g, b
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
&nbsp;
def <strong>entry_point</strong>(argv):
    if len(argv) &lt; 4:
        print("usage: ./mandelbrot width height maxiter")
        return 1
&nbsp;
    width = int(argv[1])
    height = int(argv[2])
    maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
    return 0
&nbsp;
&nbsp;
def <strong>target</strong>(driver, args):
    print "*** target ***"
    return entry_point, None
</pre>

<p>Zajímavé je, že RPython neumožňuje indexování prvků v&nbsp;n-tici ve chvíli,
kdy je index neznámý v&nbsp;čase překladu. Jinými slovy si RPython není jistý,
jestli bude index za všech okolností korektní (0..velikost n-tice) a proto je
nutné změnit i kód s&nbsp;paletou. Zde je řešení jednoduché &ndash; namísto
n-tice použijeme starý dobrý seznam, jehož prvky ovšem již mohou být n-tice,
protože ty ve zdrojovém indexujeme přímo indexy 0, 1 a 2 (což RPython
pozná):</p>

<pre>
<i># taken from Fractint</i>
palette = [
        (255, 255, 255), (224, 224, 224), (216, 216, 216), (208, 208, 208),
        (200, 200, 200), (192, 192, 192), (184, 184, 184), (176, 176, 176),
        (168, 168, 168), (160, 160, 160), (152, 152, 152), (144, 144, 144),
        (136, 136, 136), (128, 128, 128), (120, 120, 120), (112, 112, 112),
        (104, 104, 104),  (96,  96,  96),  (88,  88,  88),  (80,  80,  80),
        (72,   72,  72),  (64,  64,  64),  (56,  56,  56),  (48,  48,  56),
        (40,   40,  56),  (32,  32,  56),  (24,  24,  56),  (16,  16,  56),
        (8,     8,  56), (000, 000,  60), (000, 000,  64), (000, 000,  72),
        (000, 000,  80), (000, 000,  88), (000, 000,  96), (000, 000, 104),
        (000, 000, 108), (000, 000, 116), (000, 000, 124), (000, 000, 132),
        (000, 000, 140), (000, 000, 148), (000, 000, 156), (000, 000, 160),
        (000, 000, 168), (000, 000, 176), (000, 000, 184), (000, 000, 192),
        (000, 000, 200), (000, 000, 204), (000, 000, 212), (000, 000, 220),
        (000, 000, 228), (000, 000, 236), (000, 000, 244), (000, 000, 252),
        (000,   4, 252),   (4,  12, 252),   (8,  20, 252),  (12,  28, 252),
        (16,   36, 252),  (20,  44, 252),  (20,  52, 252),  (24,  60, 252),
        (28,   68, 252),  (32,  76, 252),  (36,  84, 252),  (40,  92, 252),
        (40,  100, 252),  (44, 108, 252),  (48, 116, 252),  (52, 120, 252),
        (56,  128, 252),  (60, 136, 252),  (60, 144, 252),  (64, 152, 252),
        (68,  160, 252),  (72, 168, 252),  (76, 176, 252),  (80, 184, 252),
        (80,  192, 252),  (84, 200, 252),  (88, 208, 252),  (92, 216, 252),
        (96,  224, 252), (100, 232, 252), (100, 228, 248),  (96, 224, 244),
        (92,  216, 240),  (88, 212, 236),  (88, 204, 232),  (84, 200, 228),
        (80,  192, 220),  (76, 188, 216),  (76, 180, 212),  (72, 176, 208),
        (68,  168, 204),  (64, 164, 200),  (64, 156, 196),  (60, 152, 188),
        (56,  144, 184),  (52, 140, 180),  (52, 132, 176),  (48, 128, 172),
        (44,  120, 168),  (40, 116, 160),  (40, 108, 156),  (36, 104, 152),
        (32,   96, 148),  (28,  92, 144),  (28,  84, 140),  (24,  80, 136),
        (20,   72, 128),  (16,  68, 124),  (16,  60, 120),  (12,  56, 116),
        (8,    48, 112),   (4,  44, 108), (000,  36, 100),   (4,  36, 104),
        (12,   40, 108),  (16,  44, 116),  (24,  48, 120),  (28,  52, 128),
        (36,   56, 132),  (40,  60, 140),  (48,  64, 144),  (52,  64, 148),
        (60,   68, 156),  (64,  72, 160),  (72,  76, 168),  (76,  80, 172),
        (84,   84, 180),  (88,  88, 184),  (96,  92, 192), (104, 100, 192),
        (112, 112, 196), (124, 120, 200), (132, 132, 204), (144, 140, 208),
        (152, 152, 212), (164, 160, 216), (172, 172, 220), (180, 180, 224),
        (192, 192, 228), (200, 200, 232), (212, 212, 236), (220, 220, 240),
        (232, 232, 244), (240, 240, 248), (252, 252, 252), (252, 240, 244),
        (252, 224, 232), (252, 208, 224), (252, 192, 212), (252, 176, 204),
        (252, 160, 192), (252, 144, 184), (252, 128, 172), (252, 112, 164),
        (252,  96, 152), (252,  80, 144), (252,  64, 132), (252,  48, 124),
        (252,  32, 112), (252,  16, 104), (252, 000,  92), (236, 000,  88),
        (228, 000,  88), (216,   4,  84), (204,   4,  80), (192,   8,  76),
        (180,   8,  76), (168,  12,  72), (156,  16,  68), (144,  16,  64),
        (132,  20,  60), (124,  20,  60), (112,  24,  56), (100,  24,  52),
        (88,   28,  48),  (76,  32,  44),  (64,  32,  44),  (52,  36,  40),
        (40,   36,  36),  (28,  40,  32),  (16,  44,  28),  (20,  52,  32),
        (24,   60,  36),  (28,  68,  44),  (32,  76,  48),  (36,  88,  56),
        (40,   96,  60),  (44, 104,  64),  (48, 112,  72),  (52, 120,  76),
        (56,  132,  84),  (48, 136,  84),  (40, 144,  80),  (52, 148,  88),
        (68,  156, 100),  (80, 164, 112),  (96, 168, 124), (108, 176, 136),
        (124, 184, 144), (136, 192, 156), (152, 196, 168), (164, 204, 180),
        (180, 212, 192), (192, 220, 200), (208, 224, 212), (220, 232, 224),
        (236, 240, 236), (252, 248, 248), (252, 252, 252), (252, 252, 240),
        (252, 252, 228), (252, 252, 216), (248, 248, 204), (248, 248, 192),
        (248, 248, 180), (248, 248, 164), (244, 244, 152), (244, 244, 140),
        (244, 244, 128), (244, 244, 116), (240, 240, 104), (240, 240,  92),
        (240, 240,  76), (240, 240,  64), (236, 236,  52), (236, 236,  40),
        (236, 236,  28), (236, 236,  16), (232, 232,   0), (232, 232,  12),
        (232, 232,  28), (232, 232,  40), (236, 236,  56), (236, 236,  68),
        (236, 236,  84), (236, 236,  96), (240, 240, 112), (240, 240, 124),
        (240, 240, 140), (244, 244, 152), (244, 244, 168), (244, 244, 180),
        (244, 244, 196), (248, 248, 208), (248, 248, 224), (248, 248, 236),
        (252, 252, 252), (248, 248, 248), (240, 240, 240), (232, 232, 232)]
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Skripty pro spuštění benchmarku se zvoleným interpretrem a parametry</h2>

<p>Pro spuštění výše popsaného benchmarku použijeme čtveřici prakticky shodných
skriptů, které budou postupně zvětšovat rozlišení výsledného rastrového
obrázku. Pro malý počet iterací se tedy bude spíše měřit rychlost nastartování
interpretru Pythonu popř.&nbsp;virtuálního stroje Javy, ovšem u vyšších
rozlišení (přibližně od 128&times;128 pixelů) již začne převládat samotná doba
výpočtu a vliv startu interpretru/JVM tak bude jen marginální.</p>



<h3>Skript pro Python 2.x</h3>

<p>Tento skript pochopitelně vyžaduje nainstalovaný Python 2, což však na
prakticky žádné distribuci nebude problém:</p>

<pre>
sizes="16 24 32 48 64 96 128 192 256 384 512 768 1024 1536 2048 3072 4096"
&nbsp;
OUTFILE="python2.times"
PREFIX="python2"
&nbsp;
rm $OUTFILE
&nbsp;
for size in $sizes
do
    echo $size
    echo -n "$size " &gt;&gt; $OUTFILE
    /usr/bin/time --output $OUTFILE --append --format "%e %M" python2 -B mandelbrot.py $size $size 255 &gt; "${PREFIX}_${size}_${size}.ppm"
done
</pre>



<h3>Skript pro Python 3.x</h3>

<p>Druhý skript používá interpret Pythonu 3:</p>

<pre>
sizes="16 24 32 48 64 96 128 192 256 384 512 768 1024 1536 2048 3072 4096"
&nbsp;
OUTFILE="python3.times"
PREFIX="python3"
&nbsp;
rm $OUTFILE
&nbsp;
for size in $sizes
do
    echo $size
    echo -n "$size " &gt;&gt; $OUTFILE
    /usr/bin/time --output $OUTFILE --append --format "%e %M" python3 -B mandelbrot.py $size $size 255 &gt; "${PREFIX}_${size}_${size}.ppm"
done
</pre>



<h3>Skript pro Jython</h3>

<p>V&nbsp;pořadí třetí skript pro svoji korektní činnost vyžaduje, aby se
v&nbsp;aktuálním adresáři nacházel Java archiv s&nbsp;Jythonem popř.&nbsp;jen
symbolický link na tento archiv:</p>

<pre>
sizes="16 24 32 48 64 96 128 192 256 384 512 768 1024 1536 2048 3072 4096"
&nbsp;
OUTFILE="jython.times"
PREFIX="jython"
&nbsp;
rm $OUTFILE
&nbsp;
for size in $sizes
do
    echo $size
    echo -n "$size " &gt;&gt; $OUTFILE
    /usr/bin/time --output $OUTFILE --append --format "%e %M" java -jar jython-standalone-2.7.0.jar mandelbrot.py $size $size 255 &gt; "${PREFIX}_${size}_${size}.ppm"
done
</pre>

<p><div class="rs-tip-major">Instalace Jythonu je snadná: postačuje si stáhnout
Java archiv z&nbsp;adresy <a
href="http://search.maven.org/remotecontent?filepath=org/python/jython-standalone/2.7.0/jython-standalone-2.7.0.jar">http://search.maven.org/remotecontent?filepath=org/python/jython-standalone/2.7.0/jython-standalone-2.7.0.jar</a>,
například takto:</div></p>

<pre>
$ <strong>wget -O jython-standalone-2.7.0.jar http://search.maven.org/remotecontent?filepath=org/python/jython-standalone/2.7.0/jython-standalone-2.7.0.jar</strong>
</pre>



<h3>Skript pro RPython</h3>

<p>Aby bylo možné tento skript korektně spustit, musí se v&nbsp;aktuálním
adresáři nacházet nativní spustitelný soubor
<strong>mandelbrot_rpython-c</strong>, který vznikl překladem zdrojového kódu
<strong>mandelbrot_rpython.py</strong>, jenž jsme si popsali v&nbsp;předchozích
dvou kapitolách:</p>

<pre>
sizes="16 24 32 48 64 96 128 192 256 384 512 768 1024 1536 2048"
&nbsp;
OUTFILE="rpyton.times"
PREFIX="rpython"
&nbsp;
rm $OUTFILE
&nbsp;
for size in $sizes
do
    echo $size
    echo -n "$size " &gt;&gt; $OUTFILE
    /usr/bin/time --output $OUTFILE --append --format "%e %M" ./mandelbrot_rpython-c $size $size 255 &gt; "${PREFIX}_${size}_${size}.ppm"
done
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Malá odbočka &ndash; implementace totožného algoritmu v&nbsp;ANSI C</h2>

<p>Jen pro zajímavost (a taktéž kvůli benchmarkům) se podívejme na to, jak je
možné totožný algoritmus implementovat v&nbsp;ANSI C. Jedná se z&nbsp;velké
části o přímý přepis původního algoritmu bez dalších optimalizací, které céčko
umožňuje:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
#include "palette_mandmap.h"
&nbsp;
void <strong>calc_mandelbrot</strong>(unsigned int width, unsigned int height, unsigned int maxiter, unsigned char palette[][3])
{
    puts("P3");
    printf("%d %d\n", width, height);
    puts("255");
&nbsp;
    double cy = -1.5;
    int y;
    for (y=0; y&lt;height; y++) {
        double cx = -2.0;
        int x;
        for (x=0; x&lt;width; x++) {
            double zx = 0.0;
            double zy = 0.0;
            unsigned int i = 0;
            while (i &lt; maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;

<p><a name="k18"></a></p>
<h2 id="k18">18. Výsledky benchmarků &ndash; porovnání s&nbsp;Pythonem 2, Pythonem 3, Jythonem a ANSI C</h2>




<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, které jsme si v&nbsp;dnešním článku ukázali,
naleznete na adrese <a
href="https://github.com/tisnik/rpython-examples">https://github.com/tisnik/rpython-examples</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je nutné mít
nainstalován RPython a jeho závislosti, především tedy překladač céčka,
benchmark používající Jython samozřejmě vyžaduje i tento interpret):</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Adresa</th></tr>
<tr><td> 1</td><td>rpython_basic.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_basic.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_basic.py</a></td></tr>
<tr><td> 2</td><td>rpython_stop_compile.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_stop_compile.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_stop_compile.py</a></td></tr>
<tr><td> 3</td><td>rpython_custom_runtime_function.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_custom_runtime_function.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_custom_runtime_function.py</a></td></tr>
<tr><td> 4</td><td>rpython_cli_arguments.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_cli_arguments.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_cli_arguments.py</a></td></tr>
<tr><td> 5</td><td>rpython_lazy_compile.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_lazy_compile.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_lazy_compile.py</a></td></tr>
<tr><td> 6</td><td>rpython_lazy_compile_dis.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_lazy_compile_dis.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_lazy_compile_dis.py</a></td></tr>
<tr><td> 7</td><td>rpython_lazy_compile_2.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_lazy_compile_2.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_lazy_compile_2.py</a></td></tr>
<tr><td> 8</td><td>rpython_types.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_types.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_types.py</a></td></tr>
<tr><td> 9</td><td>rpython_types_2.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_types_2.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_types_2.py</a></td></tr>
<tr><td>10</td><td>rpython_globals.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_globals.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_globals.py</a></td></tr>
<tr><td>11</td><td>rpython_globals_2.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_globals_2.py">https://github.com/tisnik/rpython-examples/blob/master/examples/rpython_globals_2.py</a></td></tr>
</table>



<h4>Benchmark napsaný pro Python 2.x, Python 3.x i pro Jython</h4>

<table>
<tr><th>#</th><th>Soubor</th><th>Adresa</th></tr>
<tr><td>1</td><td>mandelbrot_python.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/mandelbrot_python.py">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/mandelbrot_python.py</a></td></tr>
<tr><td>2</td><td>palette_mandmap.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/palette_mandmap.py">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/palette_mandmap.py</a></td></tr>
<tr><td>3</td><td>test_jython.sh</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/test_jython.sh">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/test_jython.sh</a></td></tr>
<tr><td>4</td><td>test_python2.sh</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/test_python2.sh">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/test_python2.sh</a></td></tr>
<tr><td>5</td><td>test_python3.sh</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/test_python3.sh">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/python/test_python3.sh</a></td></tr>
</table>

<h4>Benchmark napsaný výhradně pro RPython</h4>

<table>
<tr><th>#</th><th>Soubor</th><th>Adresa</th></tr>
<tr><td>1</td><td>mandelbrot_rpython.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/rpython/mandelbrot_rpython.py">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/rpython/mandelbrot_rpython.py</a></td></tr>
<tr><td>2</td><td>palette_mandmap.py</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/rpython/palette_mandmap.py">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/rpython/palette_mandmap.py</a></td></tr>
<tr><td>3</td><td>test_rpython.sh</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/rpython/test_rpython.sh">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/rpython/test_rpython.sh</a></td></tr>
</table>

<h4>Benchmark napsaný v&nbsp;ANSI C</h4>

<table>
<tr><th>#</th><th>Soubor</th><th>Adresa</th></tr>
<tr><td>1</td><td>mandelbrot.c</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/c/mandelbrot.c">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/c/mandelbrot.c</a></td></tr>
<tr><td>2</td><td>palette_mandmap.h</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/c/palette_mandmap.h">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/c/palette_mandmap.h</a></td></tr>
<tr><td>3</td><td>test_c.sh</td><td><a href="https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/c/test_c.sh">https://github.com/tisnik/rpython-examples/blob/master/benchmarks/mandelbrot/c/test_c.sh</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Magic of RPython<br />
<a href="https://refi64.com/posts/the-magic-of-rpython.html">https://refi64.com/posts/the-magic-of-rpython.html</a>
</li>

<li>RPython: Frequently Asked Questions<br />
<a href="http://rpython.readthedocs.io/en/latest/faq.html">http://rpython.readthedocs.io/en/latest/faq.html</a>
</li>

<li>RPython’s documentation<br />
<a href="http://rpython.readthedocs.io/en/latest/index.html">http://rpython.readthedocs.io/en/latest/index.html</a>
</li>

<li>RPython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/PyPy#RPython">https://en.wikipedia.org/wiki/PyPy#RPython</a>
</li>

<li>Getting Started with RPython<br />
<a href="http://rpython.readthedocs.io/en/latest/getting-started.html">http://rpython.readthedocs.io/en/latest/getting-started.html</a>
</li>

<li>PyPy (home page)<br />
<a href="https://pypy.org/">https://pypy.org/</a>
</li>

<li>PyPy (dokumentace)<br />
<a href="http://doc.pypy.org/en/latest/">http://doc.pypy.org/en/latest/</a>
</li>

<li>Cython (home page)<br />
<a href="http://cython.org/">http://cython.org/</a>
</li>

<li>Cython (wiki)<br />
<a href="https://github.com/cython/cython/wiki">https://github.com/cython/cython/wiki</a>
</li>

<li>Cython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cython">https://en.wikipedia.org/wiki/Cython</a>
</li>

<li>Cython (GitHub)<br />
<a href="https://github.com/cython/cython">https://github.com/cython/cython</a>
</li>

<li>Localized Type Inference of Atomic Types in Python (2005)<br />
<a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231</a>
</li>

<li>Numba<br />
<a href="http://numba.pydata.org/">http://numba.pydata.org/</a>
</li>

<li>Tutorial: Writing an Interpreter with PyPy, Part 1<br />
<a href="https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html">https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html</a>
</li>

<li>List of numerical analysis software<br />
<a href="https://en.wikipedia.org/wiki/List_of_numerical_analysis_software">https://en.wikipedia.org/wiki/List_of_numerical_analysis_software</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>The future can be written in RPython now (článek z&nbsp;roku 2010)<br />
<a href="http://blog.christianperone.com/2010/05/the-future-can-be-written-in-rpython-now/">http://blog.christianperone.com/2010/05/the-future-can-be-written-in-rpython-now/</a>
</li>

<li>PyPy is the Future of Python (článek z&nbsp;roku 2010)<br />
<a href="https://alexgaynor.net/2010/may/15/pypy-future-python/">https://alexgaynor.net/2010/may/15/pypy-future-python/</a>
</li>

<li>Portal:Python programming<br />
<a href="https://en.wikipedia.org/wiki/Portal:Python_programming">https://en.wikipedia.org/wiki/Portal:Python_programming</a>
</li>

<li>Python Implementations: Compilers<br />
<a href="https://wiki.python.org/moin/PythonImplementations#Compilers">https://wiki.python.org/moin/PythonImplementations#Compilers</a>
</li>

<li>RPython Frontend and C Wrapper Generator<br />
<a href="http://www.codeforge.com/article/383293">http://www.codeforge.com/article/383293</a>
</li>

<li>PyPy’s Approach to Virtual Machine Construction<br />
<a href="https://bitbucket.org/pypy/extradoc/raw/tip/talk/dls2006/pypy-vm-construction.pdf">https://bitbucket.org/pypy/extradoc/raw/tip/talk/dls2006/pypy-vm-construction.pdf</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

