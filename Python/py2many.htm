<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Transpiling &ndash; překlad zdrojových kódů Pythonu do dalších programovacích jazyků</a></p>
<p><a href="#k02">2. Projekt <strong>py2many</strong></a></p>
<p><a href="#k03">3. Syntaktické a sémantické rozdíly mezi podporovanými jazyky</a></p>
<p><a href="#k04">4. Python vs.&nbsp;ostatní jazyky</a></p>
<p><a href="#k05">5. Instalace transpřekladače <strong>py2many</strong></a></p>
<p><a href="#k06">6. Podpůrné nástroje pro naformátování výsledných zdrojových kódů podle zvyklostí cílového programovacího jazyka</a></p>
<p><a href="#k07">7. Transpřeklad programu typu &bdquo;Hello, world!&ldquo;</a></p>
<p><a href="#k08">8. Program obsahující pouze definici jediné funkce</a></p>
<p><a href="#k09">9. Definice funkce s&nbsp;voláním této funkce</a></p>
<p><a href="#k10">10. Výpočet faktoriálu realizovaný funkcí bez typových informací</a></p>
<p><a href="#k11">11. Ackermannova funkce definovaná bez použití datových typů</a></p>
<p><a href="#k12">12. Ackermannova funkce definovaná s&nbsp;využitím typových informací</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Transpiling &ndash; překlad zdrojových kódů Pythonu do dalších programovacích jazyků</h2>

<p>Na stránkách <a href="https://www.root.cz/">Roota</a> jsme se již několikrát
setkali s&nbsp;projekty, ve kterých byla realizována nějaká forma
<i>transpilace</i> (nebo <i>transkompilace</i>). Takže si jen ve stručnosti
připomeňme, že takzvaný <i>transcompiler</i> popř.&nbsp;zkráceně
<i>transpiler</i> slouží k&nbsp;převodu zdrojového kódu z&nbsp;jednoho
programovacího jazyka do jazyka jiného, na rozdíl od běžných překladačů
(<i>compiler</i>), které provádí překlad buď do nativního kódu nebo do bajtkódu
(<i>bytecode</i>). Překladače do nativního kódu asi netřeba představovat
&ndash; patří sem totiž klasické překladače céčka, Rustu, Go atd. (což ve
skutečnosti je nepatrně složitější v&nbsp;případě LLVM, to je však téma na
samostatný článek). A ani překladače do bajtkódu nejsou ve světě moderní
informatiky neznámé (spíš naopak), protože z&nbsp;používaných prostředků sem
spadá především Java, Python (soubory <strong>.pyc</strong>) a překladače
podporující <i>WebAssemly</i> (<i>WASM</i>).</p>

<p>Aktivně používaných transpilerů taktéž v&nbsp;současnosti existuje celá
řada, přičemž některé z&nbsp;nich mají za úkol &bdquo;snížení úrovně
abstrakce&ldquo;, tedy například transpilaci z&nbsp;Pythonu či jiného
vysokoúrovňového jazyka do programovacího jazyka C s&nbsp;následným překladem
výsledného kódu s&nbsp;využitím nějakého kvalitního a optimalizujícího
překladače céčka (příkladem může být projekt <i>Cython</i>, který již taktéž
známe). Další transpilery vznikly pro podporu dalších programovacích jazyků
v&nbsp;těch ekosystémech, které jsou (z&nbsp;různých důvodů) navázány na jediný
programovací jazyk. Dnes je naprosto nejtypičtějším příkladem takového
ekosystému svět webových prohlížečů, který se ustálil na podpoře JavaScriptu a
projekty psané v&nbsp;jiných programovacích jazycích je tak nutné buď
transpilovat právě do JavaScriptu (popř.&nbsp;do jeho podmnožiny &ndash; sem
spadá projekt <i>ams.js</i>) nebo mít v&nbsp;JavaScriptu či WASM naprogramovaný
interpret daného jazyka se všemi z&nbsp;toho plynoucími důsledky (rychlost,
objem stahovaných dat apod.).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Projekt <strong>py2many</strong></h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;projektem nazvaným
<strong>py2many</strong>, který si klade zajímavý cíl. Tímto cílem je umožnění
transpilace zdrojových kódů z&nbsp;jazyka Python do několika dalších
programovacích jazyků, tedy nikoli pouze do jediného cílového jazyka.
V&nbsp;současnosti v&nbsp;tomto projektu existuje podpora pro několik cílových
jazyků. Zejména zde nalezneme Rust a C++, na které se soustřeďuje další vývoj
(zejména na Rust, to ostatně uvidíme i v&nbsp;demonstračních příkladech), ovšem
nalezneme zde i další cílové jazyky, a to konkrétně programovací jazyky Go,
Julia, Kotlin, Nim, Dart a taktéž jazyk V.</p>

<p>Ovšem jak uvidíme v&nbsp;dalším textu, podpora nějakého cílového jazyka
neznamená, že by bylo možné vzít složitý projekt psaný v&nbsp;Pythonu,
transpřeložit ho do (řekněme) zdrojových kódů psaných v&nbsp;Go a poté ho bez
problémů přeložit překladačem Go a spustit. Na cestě stojí několik více či méně
závažných překážek, ale i přesto může být tento projekt zajímavý a to především
proto, že programovací jazyk Python (resp.&nbsp;jeho &bdquo;osekaná&ldquo;
varianta) je dnes často používán v&nbsp;učebnicích, odborných článcích atd. pro
zápis popisovaných algoritmů; Python zde tedy vystupuje v&nbsp;roli
abstraktního jazyka vhodného pro tyto účely, tedy pro zápis <i>pseudokódu</i>
(ale opět &ndash; jedná se typicky o Python &bdquo;osekaný&ldquo; o některé
nové vlastnosti). A díky <strong>py2many</strong> je možné takový algoritmus ve
více či méně korektní podobě získat i pro další konkrétní programovací
jazyk.</p>

<p><div class="rs-tip-major">Poznámka: nenechte se zmást číslicí 2 v&nbsp;názvu
<strong>py2many</strong>. Ta nemá nic společného s&nbsp;Pythonem verze 2
(vzpomínáme...) ale jedná se o v&nbsp;IT poměrně často používanou slovní hříčku
&bdquo;py t(w)o many&ldquo;.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Syntaktické a sémantické rozdíly mezi podporovanými jazyky</h2>

<p>Ještě předtím, než si ukážeme demonstrační příklady, na nichž budou patrné
vlastnosti (a především nedostatky) projektu <strong>py2many</strong>, je dobré
si uvědomit, jak odlišné jsou programovací jazyky, do nichž je programový kód
napsaný v&nbsp;Pythonu transpilován. Liší se pochopitelně syntaxe, klíčová
slova, pravidla pro psaní závorek a středníků atd. To však není vlastně příliš
důležité, protože mnohem větší rozdíly nalezneme v&nbsp;sémantice použitých
programovacích jazyků.</p>

<p>Začněme Pythonem, což je programovací jazyk, v&nbsp;němž nalezneme podporu
pro funkce jako plnohodnotných datových typů, je možné používat uzávěry, funkce
mohou mít proměnný počet parametrů, funkce mohou akceptovat <i>keyword</i>
parametry, Python podporuje objektově orientované programování založené na
třídách, lze vytvářet konstrukce pro zachytávání výjimek, podporován je
<i>pattern matching</i>, aplikace dekorátorů a v&nbsp;neposlední řadě i
asynchronní programování realizované mj.&nbsp;i klíčovými slovy
<strong>async</strong> a <strong>await</strong>. A navíc Python podporuje i
zdánlivou maličkost &ndash; přímý zápis příkazů, které nemusí být umístěny
v&nbsp;žádné funkci nebo v&nbsp;metodě.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Python vs.&nbsp;ostatní jazyky</h2>

<p>Naproti tomu u prakticky všech programovacích jazyků, do nichž nástroj
<strong>py2many</strong> dokáže Python transpilovat, některou z&nbsp;těchto
vlastností nenalezneme (resp.&nbsp;většinou jich nenalezneme větší množství).
Z&nbsp;těchto důvodů si v&nbsp;praktické části dnešního článku postupně
ukážeme, jak dobře, špatně, či dokonce vůbec jsou některé jazykové konstrukce
Pythonu překládány do dalších jazyků. Trošku sice předběhneme výsledky, ke
kterým postupně dospějeme, ale ukazuje se, že nejlépe je podporován <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">programovací jazyk
Rust</a>. To může vypadat zvláštně, protože Rust nepodporuje například klasické
objektově orientované programování realizované třídami nebo programovou
konstrukci typu <strong>try-catch-finally</strong>. Pro další konstrukce je
korektní (trans)překlad i do <a
href="https://www.root.cz/serialy/programovaci-jazyk-julia/">programovacího
jazyka Julia</a>, ovšem například C++ či Go dopadají v&nbsp;tomto porovnání
poněkud hůře (a to se nesnažím být příliš kritický).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instalace transpřekladače <strong>py2many</strong></h2>

<p>Samotný nástroj <strong>py2many</strong> může být nainstalován a spouštěn i
bez toho, aby byly k&nbsp;dispozici nainstalované cílové programovací jazyky,
ovšem v&nbsp;některých případech nebudou určité operace provedeny (například
naformátování výsledného kódu). Nejprve si tedy <strong>py2many</strong>
nainstalujeme, což je ve skutečnosti velmi snadné, protože má jen minimální
závislosti a lze ho nainstalovat standardním nástrojem <strong>pip</strong>
z&nbsp;ekosystému programovacího jazyka Python:</p>

<pre>
$ <strong>pip3 install --user py2many</strong>
</pre>

<p>Průběh instalace naznačuje, že závislosti na dalších balíčcích Pythonu jsou
jen minimální:</p>

<pre>
Collecting py2many
  Downloading py2many-0.4.tar.gz (231 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 231.8/231.8 kB 2.1 MB/s eta 0:00:00
  Preparing metadata (setup.py) ... done
Collecting toposort
  Downloading toposort-1.10-py3-none-any.whl (8.5 kB)
Building wheels for collected packages: py2many
  Building wheel for py2many (setup.py) ... done
  Created wheel for py2many: filename=py2many-0.4-py3-none-any.whl size=135227 sha256=fdee7d3e80a45ee303084aa6db3aa5a7568c1a18eb4e6f071b1fbd502ce751ec
  Stored in directory: /home/ptisnovs/.cache/pip/wheels/e0/90/16/93e6e6033164b1c0391430e30ce0ba0ef247c24d3a93c25d36
Successfully built py2many
Installing collected packages: toposort, py2many
Successfully installed py2many-0.4 toposort-1.10
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Podpůrné nástroje pro naformátování výsledných zdrojových kódů podle zvyklostí cílového programovacího jazyka</h2>

<p>Samotný transpřekladač <strong>py2many</strong> sice dokáže generovat
zdrojové kódy pro zvolený cílový jazyk, ovšem naformátování těchto kódů nemusí
odpovídat zvyklostem, které jsou v&nbsp;cílovém ekosystému dodržovány. Týká se
to především ekosystémů okolo programovacích jazyků Rust a Go, v&nbsp;nichž se
poměrně striktně dodržuje určitá <i>štábní kultura</i>. Aby výsledné zdrojové
kódy do těchto ekosystémů dobře zapadaly, pokouší se nástroj
<strong>py2many</strong> volat pomocné nástroje pro jejich výsledné
naformátování. Konkrétně se v&nbsp;případě jazyka Rust jedná o nástroj
<strong>rustfmt</strong> (lze nainstalovat samostatně) a v&nbsp;případě jazyka
Go pak o nástroj <strong>go fmt</strong> (ten je součástí instalace samotného
Go a není ho nutné instalovat samostatně).</p>

<p>Jen pro úplnost si ukažme instalaci nástroje <strong>rustfmt</strong> na
operačním systému s&nbsp;podporou balíčků RPM. Je to snadné:</p>

<pre>
$ <strong>sudo dnf install rustfmt</strong>
</pre>

<p>Průběh instalace:</p>

<pre>
Last metadata expiration check: 3:36:59 ago on Fri 14 Jun 2024 05:53:53 AM CEST.
Dependencies resolved.
===============================================================================================================================================================
 Package                             Architecture                       Version                                      Repository                           Size
===============================================================================================================================================================
Installing:
 rustfmt                             x86_64                             1.78.0-1.fc38                                updates                             1.9 M
Installing dependencies:
 cargo                               x86_64                             1.78.0-1.fc38                                updates                             6.5 M
&nbsp;
Transaction Summary
===============================================================================================================================================================
Install  2 Packages
&nbsp;
Total download size: 8.4 M
Installed size: 26 M
Is this ok [y/N]: y
Downloading Packages:
(1/2): rustfmt-1.78.0-1.fc38.x86_64.rpm                                                                                        1.1 MB/s | 1.9 MB     00:01
(2/2): cargo-1.78.0-1.fc38.x86_64.rpm                                                                                          3.7 MB/s | 6.5 MB     00:01
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Total                                                                                                                          3.8 MB/s | 8.4 MB     00:02
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                                                                                                       1/1
  Installing       : cargo-1.78.0-1.fc38.x86_64                                                                                                            1/2
  Installing       : rustfmt-1.78.0-1.fc38.x86_64                                                                                                          2/2
  Running scriptlet: rustfmt-1.78.0-1.fc38.x86_64                                                                                                          2/2
  Verifying        : cargo-1.78.0-1.fc38.x86_64                                                                                                            1/2
  Verifying        : rustfmt-1.78.0-1.fc38.x86_64                                                                                                          2/2
&nbsp;
Installed:
  cargo-1.78.0-1.fc38.x86_64                                                    rustfmt-1.78.0-1.fc38.x86_64
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Transpřeklad programu typu &bdquo;Hello, world!&ldquo;</h2>

<p>Začneme zdánlivě triviálním příkladem, a to konkrétně skriptem, který po
svém spuštění vypíše obligátní pozdravení celému světu. V&nbsp;Pythonu je
takový skript skutečně jednoduchý:</p>

<pre>
print("Hello, world!")
</pre>

<p>Už u takto jednoduchého programu však narazíme na to, že zdaleka ne všechny
programovací jazyky (zejména ne ty klasické kompilované) podporují jednotlivé
příkazy, které nejsou vloženy do funkce. Proto také výsledky transpřekladu
dopadnou nevalně, protože mnohé výsledné zdrojové kódy nebudou přeložitelné
nebo budou nespustitelné (s&nbsp;výjimkou skriptu transpřeloženého do jazyka
Julia):</p>

<h3>hello.cpp</h3>

<pre>
#include &lt;iostream&gt; // NOLINT(build/include_order)
std::cout &lt;&lt; std::string{"Hello, world!"};
std::cout &lt;&lt; std::endl;
</pre>

<p><div class="rs-tip-major">Poznámka: nekorektní program.</div></p>



<h3>hello.go</h3>

<pre>
package main
&nbsp;
import (
"fmt")
&nbsp;
&nbsp;
&nbsp;
fmt.Printf("%v\n","Hello, world!");
</pre>

<p><div class="rs-tip-major">Poznámka: nekorektní program.</div></p>


<h3>hello.jl</h3>

<pre>
println(join(["Hello, world!"], " "));
</pre>

<p><div class="rs-tip-major">Poznámka: korektní program, i když interně dosti zvláštně strukturovaný.</div></p>


<h3>hello.rs</h3>

<pre>
        //! ```cargo
        //! [package]
        //! edition = "2018"
        //! [dependencies]
        //!
        //! ```
&nbsp;
&nbsp;
#![allow(clippy::collapsible_else_if)]
#![allow(clippy::double_parens)]  // https://github.com/adsharma/py2many/issues/17
#![allow(clippy::map_identity)]
#![allow(clippy::needless_return)]
#![allow(clippy::print_literal)]
#![allow(clippy::ptr_arg)]
#![allow(clippy::redundant_static_lifetimes)]  // https://github.com/adsharma/py2many/issues/266
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::useless_vec)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_parens)]
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
println!("{}","Hello, world!");
</pre>

<p><div class="rs-tip-major">Poznámka: nekorektní program.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Program obsahující pouze definici jediné funkce</h2>

<p>Ve druhém demonstrační příkladu si otestujeme transpřeklad skriptu
s&nbsp;definicí funkce bez parametrů i bez návratových hodnot. Tato funkce bude
jen definována, ovšem nebude volána. Nejprve je vypsán původní zdrojový kód
v&nbsp;Pythonu a poté zdrojové kódy získané po transpilaci do dalších
programovacích jazyků:</p>

<h3>hello_func2.py</h3>

<pre>
def hello():
    print("Hello, world!")
</pre>


<h3>hello_func2.cpp</h3>

<pre>
#include &lt;iostream&gt; // NOLINT(build/include_order)
inline void hello() {
  std::cout &lt;&lt; std::string{"Hello, world!"};
  std::cout &lt;&lt; std::endl;
}
</pre>


<h3>hello_func2.go</h3>

<pre>
package main
&nbsp;
import (
        "fmt"
)
&nbsp;
func Hello() {
        fmt.Printf("%v\n", "Hello, world!")
}
</pre>

<p><div class="rs-tip-major">Poznámka: poněkud zbytečné použití formátovacího řetězce.</div></p>


<h3>hello_func2.jl</h3>

<pre>
function hello()
    println(join(["Hello, world!"], " "));
end
&nbsp;
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně lze zapsat jednodušším způsobem.</div></p>


<h3>hello_func2.rs</h3>

<pre>
//! ```cargo
//! [package]
//! edition = "2018"
//! [dependencies]
//!
//! ```
&nbsp;
#![allow(clippy::collapsible_else_if)]
#![allow(clippy::double_parens)] // https://github.com/adsharma/py2many/issues/17
#![allow(clippy::map_identity)]
#![allow(clippy::needless_return)]
#![allow(clippy::print_literal)]
#![allow(clippy::ptr_arg)]
#![allow(clippy::redundant_static_lifetimes)] // https://github.com/adsharma/py2many/issues/266
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::useless_vec)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_parens)]
&nbsp;
pub fn hello() {
    println!("{}", "Hello, world!");
}
</pre>

<p>Výsledky jsou v&nbsp;tomto případě korektní pro všechny jazyky, i když ne
vždy odpovídají tomu, co by napsal člověk.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Definice funkce s&nbsp;voláním této funkce</h2>

<p>Ve třetím demonstračním příkladu rozšíříme předchozí skript o přímé volání
právě definované funkce. Opět zde narazíme na problémy v&nbsp;těch
programovacích jazycích, v&nbsp;nichž není možné zapisovat příkazy mimo funkce
či metody, což se v&nbsp;tomto případě týká všech jazyků kromě originálního
Pythonu a Julie:</p>

<h3>hello_func.py</h3>

<pre>
def hello():
    print("Hello, world!")
&nbsp;
&nbsp;
hello()
</pre>


<h3>hello_func.cpp</h3>

<pre>
#include &lt;iostream&gt; // NOLINT(build/include_order)
inline void hello() {
  std::cout &lt;&lt; std::string{"Hello, world!"};
  std::cout &lt;&lt; std::endl;
}
&nbsp;
hello();
</pre>


<h3>hello_func.go</h3>

<pre>
package main
&nbsp;
import (
"fmt")
&nbsp;
&nbsp;
&nbsp;
func Hello() {
fmt.Printf("%v\n","Hello, world!");}
&nbsp;
&nbsp;
Hello();
</pre>


<h3>hello_func.jl</h3>

<pre>
function hello()
    println(join(["Hello, world!"], " "));
end
&nbsp;
hello();
</pre>


<h3>hello_func.rs</h3>

<pre>
        //! ```cargo
        //! [package]
        //! edition = "2018"
        //! [dependencies]
        //!
        //! ```
&nbsp;
&nbsp;
#![allow(clippy::collapsible_else_if)]
#![allow(clippy::double_parens)]  // https://github.com/adsharma/py2many/issues/17
#![allow(clippy::map_identity)]
#![allow(clippy::needless_return)]
#![allow(clippy::print_literal)]
#![allow(clippy::ptr_arg)]
#![allow(clippy::redundant_static_lifetimes)]  // https://github.com/adsharma/py2many/issues/266
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::useless_vec)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_parens)]
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
pub fn hello()  {
println!("{}","Hello, world!");
 }
&nbsp;
hello();
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výpočet faktoriálu realizovaný funkcí bez typových informací</h2>

<p>Následuje příklad se složitější funkcí, konkrétně s&nbsp;rekurzivním
výpočtem faktoriálu. Funkce je v&nbsp;programovacím jazyku Python zapsána bez
použití typových informací (<i>type hints</i>). Výsledky transpilace nejsou
zcela špatné (někdy je lze dokonce i přeložit a spustit :-), ovšem je
evidentní, že chybějící typové informace nástroj <strong>py2many</strong>
poměrně hodně zmátly:</p>

<h3>factorial.py</h3>

<pre>
def factorial(n):
    """Rekurzivní výpočet faktoriálu."""
    if n &lt; 0:
        return None
    if n == 0:
        return 1
    result = n * factorial(n - 1)
    return result
</pre>


<h3>factorial.cpp</h3>

<pre>
template &lt;typename T0&gt; int factorial(T0 n) {
  if (n &lt; 0) {
    return NULL;
  }
  if (n == 0) {
    return 1;
  }
  int result = n * (factorial(n - 1));
  return result;
}
</pre>

<p><div class="rs-tip-major">Poznámka: zde se používají &bdquo;divné&ldquo;
typy, program kvůli tomu není korektní.</div></p>


<h3>factorial.go</h3>

<pre>
package main
&nbsp;
&nbsp;
&nbsp;
&nbsp;
func Factorial[T0 any](n T0 any) int {
if(n &lt; 0) {
return nil
}
if(n == 0) {
return 1
}
var result int = (n*Factorial((n - 1)))
return result}
&nbsp;
&nbsp;
</pre>

<p><div class="rs-tip-major">Poznámka: zápis typu je nekorektní, a to jak
syntakticky, tak i sémanticky.</div></p>

<h3>factorial.jl</h3>

<pre>
function factorial{T0}(n::T0)::Int64
    if n &lt; 0
        return nothing
    end
    if n == 0
        return 1
    end
    result = n*factorial(convert(, n - 1))
    return result
end
</pre>


<h3>factorial.rs</h3>

<pre>
//! ```cargo
//! [package]
//! edition = "2018"
//! [dependencies]
//!
//! ```
&nbsp;
#![allow(clippy::collapsible_else_if)]
#![allow(clippy::double_parens)] // https://github.com/adsharma/py2many/issues/17
#![allow(clippy::map_identity)]
#![allow(clippy::needless_return)]
#![allow(clippy::print_literal)]
#![allow(clippy::ptr_arg)]
#![allow(clippy::redundant_static_lifetimes)] // https://github.com/adsharma/py2many/issues/266
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::useless_vec)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_parens)]
&nbsp;
pub fn factorial&lt;T0&gt;(n: T0) -&gt; i32 {
    if (n as i32) &lt; 0 {
        return None;
    }
    if (n as i32) == 0 {
        return 1;
    }
    let result: i32 = ((n as i32) * factorial(((n as i32) - 1)));
    return result;
}
</pre>

<p><div class="rs-tip-major">Poznámka: zde opět dochází k&nbsp;testu typu
předávané hodnoty, což není zcela ideální řešení.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Ackermannova funkce definovaná bez použití datových typů</h2>

<p>I další demonstrační příklad, který si v&nbsp;dnešním článku ukážeme,
obsahuje definice funkcí. Konkrétně se jedná o známou Ackermannovu funkci,
kterou v&nbsp;Pythonu pochopitelně můžeme definovat bez toho, abychom uvedli
typové informace o jejích parametrech i o návratové hodnotě. V&nbsp;navazující
kapitole si pak ukážeme tutéž funkci, ovšem s&nbsp;uvedením typových
informací.</p>

<h3>ackermann_untyped.py</h3>

<pre>
# Výpočet Ackermannovy funkce, založeno na konstrukci if
&nbsp;
def A(m, n):
    """Ackermannova funkce."""
    if m == 0:
        return n + 1
    if n == 0:
        return A(m - 1, 1)
    return A(m - 1, A(m, n - 1))
&nbsp;
&nbsp;
def check_a():
    """Korektnosti výpočtu Ackermannovy funkce."""
    for m in range(4):
        for n in range(5):
            print(m, n, A(m, n))
&nbsp;
</pre>


<h3>ackermann_untyped.cpp</h3>

<pre>
#include &lt;cppitertools/range.hpp&gt; // NOLINT(build/include_order)
#include &lt;iostream&gt;               // NOLINT(build/include_order)
template &lt;typename T0, typename T1&gt; int A(T0 m, T1 n) {
  if (m == 0) {
    return n + 1;
  }
  if (n == 0) {
    return A(m - 1, 1);
  }
  return A(m - 1, A(m, n - 1));
}
&nbsp;
inline void check_a() {
  for (auto m : iter::range(4)) {
    for (auto n : iter::range(5)) {
      std::cout &lt;&lt; m;
      std::cout &lt;&lt; " ";
      std::cout &lt;&lt; n;
      std::cout &lt;&lt; " ";
      std::cout &lt;&lt; A(m, n);
      std::cout &lt;&lt; std::endl;
    }
  }
}
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je tato varianta
prakticky stejně obecná jako varianta v&nbsp;Pythonu, tj.&nbsp;nejsme zde
omezeni pouze na datový typ <strong>int</strong>.</div></p>


<h3>ackermann_untyped.go</h3>

<pre>
package main
&nbsp;
import (
iter "github.com/hgfischer/go-iter"
"fmt")
&nbsp;
&nbsp;
&nbsp;
func A[T0 any, T1 any](m T0 any, n T1 any) int {
if(m == 0) {
return (n + 1)
}
if(n == 0) {
return A((m - 1), 1)
}
return A((m - 1), A(m, (n - 1)))}
&nbsp;
&nbsp;
func CheckA() {
for _, m := range iter.NewIntSeq(iter.Start(0), iter.Stop(4)).All() {
for _, n := range iter.NewIntSeq(iter.Start(0), iter.Stop(5)).All() {
fmt.Printf("%v %v %v\n",m, n, A(m, n));
}
}}
&nbsp;
&nbsp;
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o nekorektní variantu, a to jak
z&nbsp;hlediska syntaxe, tak i sémantiky. Ovšem zajímavě je řešena iterace přes
celočíselné hodnoty.</div></p>


<h3>ackermann_untyped.jl</h3>

<pre>
function A{T0, T1}(m::T0, n::T1)::Int64
    if m == 0
        return n + 1
    end
    if n == 0
        return A(convert(, m - 1), convert(, 1))
    end
    return A(convert(, m - 1), convert(, A(m, convert(, n - 1))))
end
&nbsp;
function check_a()
    for m in 0:4 - 1
        for n in 0:5 - 1
            println(join([m, n, A(m, n)], " "));
        end
    end
end
&nbsp;
</pre>

<p><div class="rs-tip-major">Poznámka: varianta naprogramovaná v&nbsp;jazyce
Julia opět vychází vlastně nejlépe.</div></p>


<h3>ackermann_untyped.rs</h3>

<pre>
//! ```cargo
//! [package]
//! edition = "2018"
//! [dependencies]
//!
//! ```
&nbsp;
#![allow(clippy::collapsible_else_if)]
#![allow(clippy::double_parens)] // https://github.com/adsharma/py2many/issues/17
#![allow(clippy::map_identity)]
#![allow(clippy::needless_return)]
#![allow(clippy::print_literal)]
#![allow(clippy::ptr_arg)]
#![allow(clippy::redundant_static_lifetimes)] // https://github.com/adsharma/py2many/issues/266
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::useless_vec)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_parens)]
&nbsp;
pub fn A&lt;T0, T1&gt;(m: T0, n: T1) -&gt; i32 {
    if (m as i32) == 0 {
        return ((n as i32) + 1);
    }
    if (n as i32) == 0 {
        return A(((m as i32) - 1), 1);
    }
    return A(((m as i32) - 1), A(m, ((n as i32) - 1)));
}
&nbsp;
pub fn check_a() {
    for m in (0..4) {
        for n in (0..5) {
            println!("{} {} {}", m, n, A(m, n));
        }
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: dobře se přeložila zejména konstrukce
<strong>for-range</strong>, hůře už (podle očekávání) volání funkce, u které
nejsou dopředu známé datové typy parametrů.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Ackermannova funkce definovaná s&nbsp;využitím typových informací</h2>

<p>Pokusme se tedy tranpřekladači pomoci a upravit Ackermannovu funkci takovým
způsobem, aby byly již v&nbsp;čase (trans)překladu známé jak typy parametrů
této funkce, tak i typ návratové hodnoty:</p>

<h3>ackermann_typed.py</h3>

<pre>
# Výpočet Ackermannovy funkce, založeno na konstrukci if
&nbsp;
def A(m: int, n: int) -&gt; int:
    """Ackermannova funkce."""
    if m == 0:
        return n + 1
    if n == 0:
        return A(m - 1, 1)
    return A(m - 1, A(m, n - 1))
&nbsp;
&nbsp;
def check_a() -&gt; None:
    """Korektnosti výpočtu Ackermannovy funkce."""
    for m in range(4):
        for n in range(5):
            print(m, n, A(m, n))
&nbsp;
</pre>


<h3>ackermann_typed.cpp</h3>

<pre>
#include &lt;cppitertools/range.hpp&gt; // NOLINT(build/include_order)
#include &lt;iostream&gt;               // NOLINT(build/include_order)
inline int A(int m, int n) {
  if (m == 0) {
    return n + 1;
  }
  if (n == 0) {
    return A(m - 1, 1);
  }
  return A(m - 1, A(m, n - 1));
}
&nbsp;
inline auto check_a() {
  for (auto m : iter::range(4)) {
    for (auto n : iter::range(5)) {
      std::cout &lt;&lt; m;
      std::cout &lt;&lt; " ";
      std::cout &lt;&lt; n;
      std::cout &lt;&lt; " ";
      std::cout &lt;&lt; A(m, n);
      std::cout &lt;&lt; std::endl;
    }
  }
}
</pre>

<p><div class="rs-tip-major">Poznámka: zde evidentně typové informace velmi pomohly.</div></p>


<h3>ackermann_typed.go</h3>

<pre>
package main
&nbsp;
import (
        "fmt"
        iter "github.com/hgfischer/go-iter"
)
&nbsp;
func A(m int, n int) int {
        if m == 0 {
                return (n + 1)
        }
        if n == 0 {
                return A((m - 1), 1)
        }
        return A((m - 1), A(m, (n-1)))
}
&nbsp;
func CheckA() {
        for _, m := range iter.NewIntSeq(iter.Start(0), iter.Stop(4)).All() {
                for _, n := range iter.NewIntSeq(iter.Start(0), iter.Stop(5)).All() {
                        fmt.Printf("%v %v %v\n", m, n, A(m, n))
                }
        }
}
</pre>

<p><div class="rs-tip-major">Poznámka: až na dosti prapodivnou realizaci
iterátorů se vlastně jedná o korektní přístup a samotná Ackermannova funkce je
v&nbsp;pořádku.</div></p>


<h3>ackermann_typed.jl</h3>

<pre>
function A(m::Int64, n::Int64)::Int64
    if m == 0
        return n + 1
    end
    if n == 0
        return A(m - 1, 1)
    end
    return A(m - 1, A(m, n - 1))
end
&nbsp;
function check_a()::
    for m in 0:4 - 1
        for n in 0:5 - 1
            println(join([m, n, A(m, n)], " "));
        end
    end
end
&nbsp;
</pre>

<p><div class="rs-tip-major">Poznámka: zde již do určité míry vidíme důvod,
proč se výsledná zpráva skládá pomocí <strong>join</strong> (i když se nejedná
o nejkrásnější řešení).</div></p>


<h3>ackermann_typed.rs</h3>

<pre>
//! ```cargo
//! [package]
//! edition = "2018"
//! [dependencies]
//!
//! ```
&nbsp;
#![allow(clippy::collapsible_else_if)]
#![allow(clippy::double_parens)] // https://github.com/adsharma/py2many/issues/17
#![allow(clippy::map_identity)]
#![allow(clippy::needless_return)]
#![allow(clippy::print_literal)]
#![allow(clippy::ptr_arg)]
#![allow(clippy::redundant_static_lifetimes)] // https://github.com/adsharma/py2many/issues/266
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::useless_vec)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_parens)]
&nbsp;
pub fn A(m: i32, n: i32) -&gt; i32 {
    if m == 0 {
        return (n + 1);
    }
    if n == 0 {
        return A((m - 1), 1);
    }
    return A((m - 1), A(m, (n - 1)));
}
&nbsp;
pub fn check_a() {
    for m in (0..4) {
        for n in (0..5) {
            println!("{} {} {}", m, n, A(m, n));
        }
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;pořádku :-)</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<table>
<tr><th>Program</th><th>Testuje se</th><th>C++</th><th>Go</th><th>Julia</th><th>Rust</th></tr>
<tr><td>hello.py</td><td>jednotlivý příkaz mimo funkci</td><td>&times;</td><td>&times;</td><td>&#x2713</td><td>&times;</td></tr>
<tr><td>hello_func_2.py</td><td>definice samostatné funkce</td><td>&#x2713</td><td>&#x2713</td><td>&#x2713</td><td>&#x2713</td></tr>
<tr><td>hello_func.py</td><td>definice funkce s&nbsp;jejím voláním</td><td>&times;</td><td>&times;</td><td>&#x2713</td><td>&times;</td></tr>
<tr><td>factorial.py</td><td>definice funkce bez typových informací</td><td>&times;</td><td>&times;</td><td>&times;</td><td>&times;</td></tr>
<tr><td>ackermann_untyped.py</td><td>Ackermannova funkce definovaná bez datových typů</td><td></td><td></td><td></td><td></td></tr>
<tr><td>ackermann_typed.py</td><td>Ackermannova funkce definovaná s&nbsp;datovými typy</td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python a pro nástroj <strong>py2many</strong> byly uloženy
do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.py</td><td>jednotlivý příkaz volaný mimo funkci nebo metodu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.py</a></td></tr>
<tr><td> 2</td><td>hello.cpp</td><td>výsledek transpřekladu do jazyka C++</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.cpp">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.cpp</a></td></tr>
<tr><td> 3</td><td>hello.go</td><td>výsledek transpřekladu do jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.go">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.go</a></td></tr>
<tr><td> 4</td><td>hello.jl</td><td>výsledek transpřekladu do jazyka Julia</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.jl">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.jl</a></td></tr>
<tr><td> 5</td><td>hello.rs</td><td>výsledek transpřekladu do jazyka Rust</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.rs">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>hello_func2.py</td><td>definice samostatné funkce bez jejího volání</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.py</a></td></tr>
<tr><td> 7</td><td>hello_func2.cpp</td><td>výsledek transpřekladu do jazyka C++</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.cpp">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.cpp</a></td></tr>
<tr><td> 8</td><td>hello_func2.go</td><td>výsledek transpřekladu do jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.go">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.go</a></td></tr>
<tr><td> 9</td><td>hello_func2.jl</td><td>výsledek transpřekladu do jazyka Julia</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.jl">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.jl</a></td></tr>
<tr><td>10</td><td>hello_func2.rs</td><td>výsledek transpřekladu do jazyka Rust</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.rs">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func2.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>hello_func.py</td><td>definice funkce s&nbsp;jejím voláním</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.py</a></td></tr>
<tr><td>12</td><td>hello_func.cpp</td><td>výsledek transpřekladu do jazyka C++</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.cpp">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.cpp</a></td></tr>
<tr><td>13</td><td>hello_func.go</td><td>výsledek transpřekladu do jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.go">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.go</a></td></tr>
<tr><td>14</td><td>hello_func.jl</td><td>výsledek transpřekladu do jazyka Julia</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.jl">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.jl</a></td></tr>
<tr><td>15</td><td>hello_func.rs</td><td>výsledek transpřekladu do jazyka Rust</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.rs">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/hello_func.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>factorial.py</td><td>definice složitější funkce bez typových informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.py</a></td></tr>
<tr><td>17</td><td>factorial.cpp</td><td>výsledek transpřekladu do jazyka C++</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.cpp">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.cpp</a></td></tr>
<tr><td>18</td><td>factorial.go</td><td>výsledek transpřekladu do jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.go">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.go</a></td></tr>
<tr><td>19</td><td>factorial.jl</td><td>výsledek transpřekladu do jazyka Julia</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.jl">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.jl</a></td></tr>
<tr><td>20</td><td>factorial.rs</td><td>výsledek transpřekladu do jazyka Rust</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.rs">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/factorial.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>ackermann_untyped.py</td><td>Ackermannova funkce definovaná bez datových typů (hintů)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.py</a></td></tr>
<tr><td>22</td><td>ackermann_untyped.cpp</td><td>výsledek transpřekladu do jazyka C++</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.cpp">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.cpp</a></td></tr>
<tr><td>23</td><td>ackermann_untyped.go</td><td>výsledek transpřekladu do jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.go">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.go</a></td></tr>
<tr><td>24</td><td>ackermann_untyped.jl</td><td>výsledek transpřekladu do jazyka Julia</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.jl">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.jl</a></td></tr>
<tr><td>25</td><td>ackermann_untyped.rs</td><td>výsledek transpřekladu do jazyka Rust</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.rs">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_untyped.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>ackermann_typed.py</td><td>Ackermannova funkce definovaná s&nbsp;datovými typy (hinty)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.py</a></td></tr>
<tr><td>27</td><td>ackermann_typed.cpp</td><td>výsledek transpřekladu do jazyka C++</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.cpp">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.cpp</a></td></tr>
<tr><td>28</td><td>ackermann_typed.go</td><td>výsledek transpřekladu do jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.go">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.go</a></td></tr>
<tr><td>29</td><td>ackermann_typed.jl</td><td>výsledek transpřekladu do jazyka Julia</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.jl">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.jl</a></td></tr>
<tr><td>30</td><td>ackermann_typed.rs</td><td>výsledek transpřekladu do jazyka Rust</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.rs">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/ackermann_typed.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>bubble.py</td><td>algoritmus bublinkového řazení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.py</a></td></tr>
<tr><td>32</td><td>bubble.cpp</td><td>výsledek transpřekladu do jazyka C++</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.cpp">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.cpp</a></td></tr>
<tr><td>33</td><td>bubble.go</td><td>výsledek transpřekladu do jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.go">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.go</a></td></tr>
<tr><td>34</td><td>bubble.jl</td><td>výsledek transpřekladu do jazyka Julia</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.jl">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.jl</a></td></tr>
<tr><td>35</td><td>bubble.rs</td><td>výsledek transpřekladu do jazyka Rust</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.rs">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/bubble.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>36</td><td>list_untyped.py</td><td>práce se seznamy, bez typových informací (hintů)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.py</a></td></tr>
<tr><td>37</td><td>list_untyped.cpp</td><td>výsledek transpřekladu do jazyka C++</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.cpp">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.cpp</a></td></tr>
<tr><td>38</td><td>list_untyped.go</td><td>výsledek transpřekladu do jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.go">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.go</a></td></tr>
<tr><td>39</td><td>list_untyped.jl</td><td>výsledek transpřekladu do jazyka Julia</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.jl">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.jl</a></td></tr>
<tr><td>40</td><td>list_untyped.rs</td><td>výsledek transpřekladu do jazyka Rust</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.rs">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_untyped.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>41</td><td>list_typed.py</td><td>práce se seznamy, s&nbsp;typovými informacemi (hinty)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.py">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.py</a></td></tr>
<tr><td>42</td><td>list_typed.cpp</td><td>výsledek transpřekladu do jazyka C++</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.cpp">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.cpp</a></td></tr>
<tr><td>43</td><td>list_typed.go</td><td>výsledek transpřekladu do jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.go">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.go</a></td></tr>
<tr><td>44</td><td>list_typed.jl</td><td>výsledek transpřekladu do jazyka Julia</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.jl">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.jl</a></td></tr>
<tr><td>45</td><td>list_typed.rs</td><td>výsledek transpřekladu do jazyka Rust</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.rs">https://github.com/tisnik/most-popular-python-libs/blob/master/py2many/list_typed.rs</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Pseudocode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Pseudocode">https://en.wikipedia.org/wiki/Pseudocode</a>
</li>

<li>Pseudokód (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Pseudok%C3%B3d">https://cs.wikipedia.org/wiki/Pseudok%C3%B3d</a>
</li>

<li>Cython (home page)<br />
<a href="http://cython.org/">http://cython.org/</a>
</li>

<li>Cython (wiki)<br />
<a href="https://github.com/cython/cython/wiki">https://github.com/cython/cython/wiki</a>
</li>

<li>Cython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cython">https://en.wikipedia.org/wiki/Cython</a>
</li>

<li>Cython (GitHub)<br />
<a href="https://github.com/cython/cython">https://github.com/cython/cython</a>
</li>

<li>Seriál Programovací jazyk Julia<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-julia/">https://www.root.cz/serialy/programovaci-jazyk-julia/</a>
</li>

<li>Seriál programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Ackermann function<br />
<a href="https://en.wikipedia.org/wiki/Ackermann_function">https://en.wikipedia.org/wiki/Ackermann_function</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

