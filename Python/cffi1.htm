<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Propojení Pythonu s nativními knihovnami s využitím balíčku cffi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Propojení Pythonu s nativními knihovnami s využitím balíčku cffi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Programovací jazyk Python je dnes pravděpodobně nejrozšířenější programovacím jazykem, k čemuž přispěl i fakt, že pro něj existuje obrovské množství balíčků řešících problémy z různých oborů. A mnoho těchto balíčků není ve skutečnosti nic jiného, než sofistikované lepidlo mezi Pythonem a nativními knihovnami.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Propojení Pythonu s&nbsp;nativními knihovnami s&nbsp;využitím balíčku <i>cffi</i></a></p>
<p><a href="#k02">2. Instalace knihovny <i>cffi</i></a></p>
<p><a href="#k03">3. Funkce psaná v&nbsp;C, která sečte své dva celočíselné parametry</a></p>
<p><a href="#k04">4. Překlad funkce a uložení výsledku překladu do dynamicky linkované knihovny</a></p>
<p><a href="#k05">5. Načtení dynamicky linkované knihovny v&nbsp;Pythonním skriptu a zavolání nativní funkce přes <i>ctypes</i></a></p>
<p><a href="#k06">6. Srážka staticky typovaného světa se světem typovaným dynamicky</a></p>
<p><a href="#k07">7. Načtení dynamicky linkované knihovny a zavolání funkce z&nbsp;této knihovny s&nbsp;využitím <i>cffi</i></a></p>
<p><a href="#k08">8. Kontrola datových typů předávaných hodnot knihovnou <i>cffi</i></a></p>
<p><a href="#k09">9. Funkce naprogramovaná v&nbsp;céčku, která vytiskne předaný řetězec</a></p>
<p><a href="#k10">10. Céčkovské řetězce jsou odlišné od Pythonovských řetězců!</a></p>
<p><a href="#k11">11. Předání řetězců do céčkovské funkce realizované přes <i>cffi</i></a></p>
<p><a href="#k12">*** 12. Programovací jazyk Python a céčkovské ukazatele</a></p>
<p><a href="#k13">13. Funkce psaná v&nbsp;C, která prohodí hodnoty parametrů předaných referencí</a></p>
<p><a href="#k14">*** 14. Inicializace ukazatelů na straně Pythonu, předání ukazatelů do volané céčkové funkce</a></p>
<p><a href="#k15">*** 15. Kontrola, zda se s&nbsp;ukazatelem nezachází jako s&nbsp;polem</a></p>
<p><a href="#k16">*** 16. Práce s&nbsp;poli, konverze mezi polem a datovými typy Pythonu</a></p>
<p><a href="#k17">*** 17. Funkce psaná v&nbsp;C, která vyplní pole zvolenou hodnotou</a></p>
<p><a href="#k18">*** 18. Volání funkce pro výplň pole z&nbsp;Pythonu, zobrazení výsledného pole</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Propojení Pythonu s&nbsp;nativními knihovnami s&nbsp;využitím balíčku <i>cffi</i></h2>

<p><a href="https://www.root.cz/n/python/">Programovací jazyk Python</a> je
dnes pravděpodobně nejrozšířenějším [<a
href="https://www.tiobe.com/tiobe-index/">1</a>][<a
href="https://pypl.github.io/PYPL.html">2</a>] programovacím jazykem,
k&nbsp;čemuž přispěl i fakt, že pro něj existuje obrovské množství balíčků
řešících problémy z&nbsp;různých oborů (od obecného zpracování dat přes tvorbu
webů a grafického uživatelského rozhraní až po ML a AI). A mnoho těchto balíčků
není ve skutečnosti nic jiného, než &bdquo;pouhé&ldquo; sofistikované lepidlo
mezi Pythonem a nativními (dynamicky linkovanými) knihovnami. Jak je však
kooperace mezi Pythonem na straně jedné a nativním kódem na straně druhé
realizována po technologické stránce?</p>

<p>Programový kód napsaný typicky v&nbsp;C, C++ (popř.&nbsp;v&nbsp;Rustu, Go či
Fortranu atd.) je nejprve přeložen do nativní dynamické knihovny (tedy
konkrétně do souboru s&nbsp;koncovkou &bdquo;.so&ldquo; na Linuxu a
&bdquo;.dll&ldquo; ve Windows). Aplikace psaná v&nbsp;Pythonu tuto dynamickou
knihovnu načte a přes balíček <i>ctypes</i> umožní volání funkcí
naprogramovaných v&nbsp;C/C++ atd. Zpočátku se může zdát, že se jedná o
bezproblémové řešení, ovšem na cestě k&nbsp;výslednému produktu je nutné zdolat
poměrně mnoho překážek. Některé jsou relativně snadné (například <i>ctypes</i>
lze nahradit za <i>cffi</i>, pokud to vývojáři více vyhovuje &ndash; což si
ukážeme dnes i příště), další již komplikovanější. Tyto problémy spočívají
v&nbsp;tom, že se střetávají dva rozdílné typové systémy. Navíc obě technologie
předpokládají, že jedna z&nbsp;komunikujících stran je psaná v&nbsp;céčku
&ndash; a to znamená, že se mezi dva programovací jazyky s&nbsp;automatickou
správnou paměti vložilo rozhraní předpokládající manuální správu paměti se
všemi z&nbsp;toho plynoucími důsledky (to je případ komunikace mezi Pythonem a
Go).</p>

<p>Dnes se zaměříme na balíček <i>cffi</i>, který v&nbsp;Pythonu umožňuje volat
nativní funkce a předávat jim &bdquo;nativní&ldquo; datové typy a datové
struktury. <i>cffi</i> není, na rozdíl od <i>ctypes</i>, součástí standardní
knihovny Pythonu, ovšem v&nbsp;několika ohledech se jedná o lepší řešení, které
dobře &bdquo;škáluje&ldquo; společně s&nbsp;rostoucím množstvím nativního kódu,
který je nutné z&nbsp;Pythonu volat.</p>

<p><div class="rs-tip-major">Poznámka: zatímco <i>cffi</i> je určeno pro
Python, existuje podobný balíček určený pro Common LISP. Ten se pro změnu
jmenuje <i>CFFI</i>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace knihovny <i>cffi</i></h2>

<p>Samotná instalace knihovny <i>cffi</i> je velmi snadná, protože poslední
stabilní verze této knihovny je dostupná na <a
href="https://pypi.org/">PyPI</a> a tato knihovna má jen jedinou závislosti
&ndash; knihovnu <a href="https://github.com/eliben/pycparser">pycparser</a>.
Instalaci pro aktuálně přihlášeného uživatele provedeme příkazem:</p>

<pre>
$ <strong>pip3 install --user cffi</strong>
&nbsp;
Collecting cffi
  Using cached cffi-1.15.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (442 kB)
Collecting pycparser
  Using cached pycparser-2.21-py2.py3-none-any.whl (118 kB)
Installing collected packages: pycparser, cffi
Successfully installed cffi-1.15.1 pycparser-2.21
</pre>

<p>Poněkud naivní kontrola instalace může vypadat následovně:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.8.10 (default, Mar 13 2023, 10:26:41) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; <strong>import cffi</strong>
&gt;&gt;&gt; <strong>help(cffi]</strong>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce psaná v&nbsp;C, která sečte své dva celočíselné parametry</h2>

<p>V&nbsp;úvodních kapitolách praktické části dnešního článku si ukážeme, jak
lze z&nbsp;Pythonu zavolat velmi jednoduchou funkci, která je naprogramována
v&nbsp;jazyku C. Tato funkce akceptuje dva parametry typu <strong>int</strong>,
sečte je a následně vrátí výsledek součtu. Deklarace takové funkce je skutečně
triviální:</p>

<pre>
extern int <strong>add</strong>(int x, int y)
{
    return x+y;
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad funkce a uložení výsledku překladu do dynamicky linkované knihovny</h2>

<p>Soubor <strong>adder.c</strong>, v&nbsp;němž je výše uvedená funkce uložena,
nyní přeložíme do objektového souboru, který bude pojmenován
<strong>adder.o</strong>. Povšimněte si použití volby <strong>PIC</strong>,
kterou se zapíná takzvaný <i>Position Independent Code</i> (tedy instrukcí
nepoužívajících absolutní skoky) a která se používá při vytváření sdílených
knihoven na některých architekturách (na x86_64 však v&nbsp;našem jednoduchém
příkladu dostaneme stejný výsledek i bez použití této volby):</p>

<pre>
$ <strong>gcc -Wall -ansi -c -fPIC adder.c -o adder.o</strong>
</pre>

<p>Následně z&nbsp;tohoto objektového souboru vytvoříme sdílenou knihovnu
(<i>shared library</i>) pojmenovanou <strong>libadder.so</strong> (přípona
<i>.so</i> značí &bdquo;shared object&ldquo;):</p>

<pre>
$ <strong>gcc -shared -Wl,-soname,libadder.so -o libadder.so adder.o</strong>
</pre>

<p>Přesvědčíme se, že soubor <strong>libadder.so</strong> skutečně vznikl:</p>

<pre>
$ <strong>file libadder.so </strong>
&nbsp;
libadder.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=ca87f6b0705f4ddd589de8cc00bd31cdb8c6b6d6, not stripped
</pre>

<p>Popř.&nbsp;se můžeme podívat i na symboly, které jsou v&nbsp;tomto souboru
definovány. Použijeme k&nbsp;tomu nástroj <strong>nm</strong>:</p>

<pre>
$ <strong>nm libadder.so </strong>
&nbsp;
00000000000010f9 T add
0000000000004020 b completed.8061
                 w __cxa_finalize
0000000000001040 t deregister_tm_clones
00000000000010b0 t __do_global_dtors_aux
0000000000003e78 d __do_global_dtors_aux_fini_array_entry
0000000000004018 d __dso_handle
0000000000003e80 d _DYNAMIC
0000000000001114 t _fini
00000000000010f0 t frame_dummy
0000000000003e70 d __frame_dummy_init_array_entry
00000000000020a0 r __FRAME_END__
0000000000004000 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
0000000000002000 r __GNU_EH_FRAME_HDR
0000000000001000 t _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
0000000000001070 t register_tm_clones
0000000000004020 d __TMC_END__
</pre>

<p>Můžeme se dokonce podívat, jakým způsobem se funkce <strong>add</strong>
přeložila do strojového kódu. K&nbsp;tomuto účelu použijeme nástroj
<strong>objdump</strong> a pro získání disassemblovaného textu zvolené funkce
použijeme trik s&nbsp;<strong>awk</strong>, který z&nbsp;výpisu
&bdquo;vykousne&ldquo; pouze požadovanou funkci:</p>

<pre>
$ <strong>objdump -d -M intel libadder.so | awk -F"\n" -v RS="\n\n" '$1 ~ /add/'</strong>
&nbsp;
00000000000010f9 <add>:
    10f9:       f3 0f 1e fa             endbr64 
    10fd:       55                      push   rbp
    10fe:       48 89 e5                mov    rbp,rsp
    1101:       89 7d fc                mov    DWORD PTR [rbp-0x4],edi
    1104:       89 75 f8                mov    DWORD PTR [rbp-0x8],esi
    1107:       8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
    110a:       8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
    110d:       01 d0                   add    eax,edx
    110f:       5d                      pop    rbp
    1110:       c3                      ret    
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Načtení dynamicky linkované knihovny v&nbsp;Pythonním skriptu a zavolání nativní funkce přes <i>ctypes</i></h2>

<p>Nejdříve si ukážeme, jak je možné dynamicky linkovanou knihovnu načíst do
Pythonu přes standardní knihovnu <i>ctypes</i>. Po načtení (které ovšem může
vyvolat výjimku) je možné pracovat s&nbsp;výsledkem jako s&nbsp;objektem, který
mj.&nbsp;obsahuje i metodu nazvanou <strong>add</strong>, kterou lze zavolat
jako běžnou Pythonovskou funkci:</p>

<pre>
import ctypes
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
adder = load_library("libadder.so")
print(adder.add(1,2))
</pre>

<p><div class="rs-tip-major">Poznámka: aby bylo možné sdílenou knihovnu nalézt,
je nutné nastavit proměnnou prostředí <strong>LD_LIBRARY_PATH</strong> (jinak
by se knihovna hledala v&nbsp;/usr/lib popř.&nbsp;/usr/lib64 atd. ale nikoli
v&nbsp;aktuálním adresáři.). V&nbsp;našem konkrétním případě to znamená, že se
interpret Pythonu zavolá následujícím způsobem:</div></p>

<pre>
$ <strong>export LD_LIBRARY_PATH=.</strong>
$ <strong>python3 call_via_ctypes.py</strong>
</pre>

<p>Nebo takto:</p>

<pre>
$ <strong>LD_LIBRARY_PATH=. python3 call_from_python.py</strong>
</pre>

<p>Výsledkem by v&nbsp;každém případě měla být hodnota &bdquo;3&ldquo; vypsaná
na terminál.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Srážka staticky typovaného světa se světem typovaným dynamicky</h2>

<p>Výše uvedená céčkovská funkce akceptuje pouze parametry typu
<strong>int</strong>, což je z&nbsp;pohledu céčka celočíselná hodnota se
znaménkem s&nbsp;&bdquo;vhodnou&ldquo; šířkou odvozenou mj.&nbsp;i od použité
architektury. Z&nbsp;pohledu Pythonu se ovšem chápání funkcí liší, protože
funkcím je možné v&nbsp;runtime předat parametry libovolného typu. Například se
můžeme pokusit o předání řetězce namísto druhého celočíselného parametru a
sledovat, jak se bude program chovat:</p>

<pre>
import ctypes
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
adder = load_library("libadder.so")
print(adder.add(1, "foo"))
</pre>

<p>Program po spuštění kupodivu nezhavaruje (<i>ctypes</i> se snaží o provedení
konverze), i když vypíše nesmyslné výsledky:</p>

<pre>
$ <strong>python3 call_via_ctypes2.py </strong>
&nbsp;
-1157149183
</pre>

<p>Naproti tomu snaha o předání celého čísla obsahujícího příliš velkou
hodnotu, která se nevejde do nativního typu <strong>int</strong>, již vede
k&nbsp;pádu aplikace:</p>

<pre>
import ctypes
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
adder = load_library("libadder.so")
print(adder.add(1, 2**100))
</pre>

<p>Pokus o spuštění:</p>

<pre>
$ <strong>python3 call_via_ctypes3.py </strong>
&nbsp;
Traceback (most recent call last):
  File "call_via_ctypes3.py", line 9, in <module>
    print(adder.add(1, 2**100))
ctypes.ArgumentError: argument 2: &lt;class 'OverflowError'&gt;: int too long to convert
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Načtení dynamicky linkované knihovny a zavolání funkce z&nbsp;této knihovny s&nbsp;využitím <i>cffi</i></h2>

<p>Nyní se skript načítající dynamicky linkovanou knihovnu a volající v&nbsp;ní
uloženou nativní funkci pokusme přepsat tak, aby využíval balíček <i>cffi</i> a
nikoli <i>ctypes</i>. Je to vlastně velmi jednoduché a přímočaré, ovšem
s&nbsp;jednou výjimkou &ndash; balíčku <i>cffi</i> musíme specifikovat i
hlavičku volané funkce (popř.&nbsp;definici použitých datových typů), a to
v&nbsp;původní céčkovské syntaxi. Díky tomu dodáme balíčku <i>cffi</i> i ty
informace, které nelze odvodit z&nbsp;obsahu dynamicky linkované knihovny:</p>

<pre>
from cffi import FFI
&nbsp;
ffi = FFI()
&nbsp;
ffi.cdef("""
    int add(int x, int y);
""")
&nbsp;
def <strong>load_library</strong>(library_name):
    return ffi.dlopen(library_name)
&nbsp;
&nbsp;
adder = load_library("libadder.so")
print(adder.add(1,2))
</pre>

<p>Při spuštění je opět nutné zajistit, aby načítaná dynamicky linkovaná
knihovna byla uložena v&nbsp;adresáři, na který ukazuje proměnná prostředí
<strong>LD_LIBRARY_PATH</strong>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Kontrola datových typů předávaných hodnot knihovnou <i>cffi</i></h2>

<p>Víme již, že knihovna <i>ctypes</i> nekontroluje, že například do funkce
akceptující celé číslo předáváme řetězec atd. Jak ale bude kontrola datových
typů předávaných hodnot vypadat, pokud použijeme knihovnu <i>cffi</i>?</p>

<pre>
from cffi import FFI
&nbsp;
ffi = FFI()
&nbsp;
ffi.cdef("""
    int add(int x, int y);
""")
&nbsp;
def <strong>load_library</strong>(library_name):
    return ffi.dlopen(library_name)
&nbsp;
&nbsp;
adder = load_library("libadder.so")
print(adder.add(1,"foo"))
</pre>

<p>Nyní bude chyba detekována a volání se nezdaří (což je jen dobře):</p>

<pre>
Traceback (most recent call last):
  File "call_via_cffi2.py", line 14, in &lt;module&gt;
    print(adder.add(1,"foo"))
TypeError: an integer is required
</pre>

<p>Podobně dojde k&nbsp;chybě ve chvíli, kdy se pokusíme předat příliš velkou
celočíselnou hodnotu:</p>

<pre>
from cffi import FFI
&nbsp;
ffi = FFI()
&nbsp;
ffi.cdef("""
    int add(int x, int y);
""")
&nbsp;
def <strong>load_library</strong>(library_name):
    return ffi.dlopen(library_name)
&nbsp;
&nbsp;
adder = load_library("libadder.so")
print(adder.add(1,2**100))
</pre>

<p>Detekce chyby v&nbsp;runtime:</p>

<pre>
Traceback (most recent call last):
  File "call_via_cffi3.py", line 14, in &lt;module&gt;
    print(adder.add(1,2**100))
OverflowError: int too big to convert
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;prvního uvedeného příkladu je
patrné, že <i>cffi</i> dokáže provádět kontroly předávaných datových typů lépe,
než knihovna <i>ctypes</i> (ostatně má mnohem více informací).</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Funkce naprogramovaná v&nbsp;céčku, která vytiskne předaný řetězec</h2>

<p>V&nbsp;další části dnešního článku si opět ukážeme způsob volání velmi
jednoduché céčkovské funkce. Tentokrát bude funkce akceptovat řetězec (což je
ovšem v&nbsp;pojetí céčka ukazatel na první znak řetězce), který následně
vytiskne:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
extern void greet(char *x) {
    printf("Hello %s!\n", x);
}
</pre>

<p>Z&nbsp;dalšího textu bude patrné, že nyní již nebude vše tak jednoduché,
jako doposud &ndash; a to kvůli zcela odlišnému chápání řetězců v&nbsp;céčku a
v&nbsp;Pythonu.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Céčkovské řetězce jsou odlišné od Pythonovských řetězců!</h2>

<p>Způsob předávání dalších číselných typů (kromě komplexních čísel) je stejně
jednoduchý (nebo problematický &ndash; záleží na úhlu pohledu), jako práce
s&nbsp;parametry a návratovými hodnotami typu <strong>int</strong>
resp.&nbsp;<strong>long</strong>. Pojďme si však ukázat, jak lze zajistit
komunikaci mezi funkcí napsanou v&nbsp;C a skriptem v&nbsp;Pythonu za situace,
kdy je nutné céčkovské funkci předat řetězec. Začneme funkcí popsanou <a
href="#k10">v&nbsp;předchozí kapitole</a>.</p>

<p>Nejprve nám již známým způsobem načteme a inicializujeme dynamicky
linkovanou knihovnu, získáme referenci na céčkovskou funkci a zavoláme tuto
funkci s&nbsp;předáním řetězce:</p>

<pre>
import ctypes
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
greeter = load_library("libgreeter.so")
greeter.greet("world")
</pre>

<p>Výsledkem bude:</p>

<pre>
Hello w!
</pre>

<p>Tento první pokus nebude v&nbsp;Pythonu 3 úspěšný, neboť se provádí převod
na <strong>wchar_t*</strong>, tedy předává se ukazatel na řetězec zkonvertovaný
na pole &bdquo;širokých&ldquo; znaků. Hned první široký znak, tedy
&bdquo;W&ldquo;, bude ve druhém bajtu obsahovat nulu, která (z&nbsp;pohledu
céčka) řetězec ukončí, takže se vypíše právě ono dvojité wé:</p>

<p>Zkusme tedy převod řetězce na typ <strong>bytes</strong>, který je taktéž
knihovnou <i>ctypes</i> podporován. Určíme, že se má řetězec přetransformovat
do kódování UTF-8, kde již bude nulový bajt skutečně umístěn pouze na konci
řetězce:</p>

<pre>
import ctypes
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
greeter = load_library("libgreeter.so")
greeter.greet(b"world")
</pre>

<p>Výsledek:</p>

<pre>
Hello world!
</pre>

<p>Alternativní způsob, který korektně převede Pythonovský řetězec do podoby
kompatibilní s&nbsp;většinou céčkovských funkcí:</p>

<pre>
import ctypes
&nbsp;
&nbsp;
def <strong>load_library</strong>(library_name):
    return ctypes.CDLL(library_name)
&nbsp;
&nbsp;
greeter = load_library("libgreeter.so")
greeter.greet("world".encode("utf-8"))
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Předání řetězců do céčkovské funkce realizované přes <i>cffi</i></h2>

<p>Nyní se pokusme stejnou chybu, tedy přímé předání Pythonovského řetězce do
céčkovské funkce, která akceptuje <strong>char *</strong>, udělat i při použití
knihovny <i>cffi</i>:</p>

<pre>
from cffi import FFI
&nbsp;
ffi = FFI()
&nbsp;
ffi.cdef("""
    void greet(char *x);
""")
&nbsp;
def <strong>load_library</strong>(library_name):
    return ffi.dlopen(library_name)
&nbsp;
&nbsp;
greeter = load_library("libgreeter.so")
greeter.greet("world")
</pre>

<p>Knihovna <i>cffi</i> je v&nbsp;tomto ohledu mnohem přísnější než
<i>ctypes</i> a chybu odhalí (což je jen dobře, protože tato chyba by jinak
mohla zůstat nepovšimnuta):</p>

<pre>
Traceback (most recent call last):
  File "call_via_cffi1.py", line 14, in <module>
    greeter.greet("world")
TypeError: initializer for ctype 'char *' must be a bytes or list or tuple, not str
</pre>

<p>Oba způsoby opravy jsou knihovnou <i>cffi</i> akceptovány:</p>

<pre>
from cffi import FFI
&nbsp;
ffi = FFI()
&nbsp;
ffi.cdef("""
    void greet(char *x);
""")
&nbsp;
def <strong>load_library</strong>(library_name):
    return ffi.dlopen(library_name)
&nbsp;
&nbsp;
greeter = load_library("libgreeter.so")
greeter.greet(b"world")
</pre>

<p>Výsledek:</p>

<pre>
Hello world!
</pre>

<p>I tento způsob je akceptován:</p>

<pre>
from cffi import FFI
&nbsp;
ffi = FFI()
&nbsp;
ffi.cdef("""
    void greet(char *x);
""")
&nbsp;
def <strong>load_library</strong>(library_name):
    return ffi.dlopen(library_name)
&nbsp;
&nbsp;
greeter = load_library("libgreeter.so")
greeter.greet("world".encode("utf-8"))
</pre>

<p>Výsledek:</p>

<pre>
Hello world!
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Programovací jazyk Python a céčkovské ukazatele</h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce psaná v&nbsp;C, která prohodí hodnoty parametrů předaných referencí</h2>

<p>Použití ukazatelů si prozatím ukážeme na další velmi jednoduché funkci
(v&nbsp;další části článku budou uvedeny složitější příklady). Jedná se o
funkci, které se předají odkazy na dvě celočíselné hodnoty. Funkce tyto hodnoty
prohodí a díky tomu, že parametry nejsou předávány hodnotou, ale již zmíněným
odkazem, bude tato modifikace viditelná i mimo funkci
<strong>swap</strong>:</p>

<pre>
extern void <strong>swap</strong>(int *x, int *y)
{
    *x = *x ^ *y;
    *y = *x ^ *y;
    *x = *x ^ *y;
}
</pre>




<p><a name="k14"></a></p>
<h2 id="k14">14. Inicializace ukazatelů na straně Pythonu, předání ukazatelů do volané céčkové funkce</h2>

<pre>
from cffi import FFI

ffi = FFI()

ffi.cdef("""
    void swap(int *x, int *y);
""")

def load_library(library_name):
    return ffi.dlopen(library_name)


swapper = load_library("libswapper.so")

x = ffi.new("int *", 10)
y = ffi.new("int *", 20)

swapper.swap(x, y)
print(x[0])
print(y[0])
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Kontrola, zda se s&nbsp;ukazatelem nezachází jako s&nbsp;polem</h2>

<pre>
from cffi import FFI

ffi = FFI()

ffi.cdef("""
    void swap(int *x, int *y);
""")

def <strong>load_library</strong>(library_name):
    return ffi.dlopen(library_name)


swapper = load_library("libswapper.so")

x = ffi.new("int *", 10)
y = ffi.new("int *", 20)

swapper.swap(x, y)
print(x[1])
print(y[1])
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Práce s&nbsp;poli, konverze mezi polem a datovými typy Pythonu</h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Funkce psaná v&nbsp;C, která vyplní pole zvolenou hodnotou</h2>

<p></p>

<pre>
extern void fill(int *array, int size, int value)
{
    int i;
    for (i=0; i&lt;size; i++) {
        array[i] = value;
    }
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Volání funkce pro výplň pole z&nbsp;Pythonu, zobrazení výsledného pole</h2>

<pre>
from cffi import FFI
&nbsp;
ffi = FFI()
&nbsp;
ffi.cdef("""
    void fill(int *x, int, int);
""")
&nbsp;
def <strong>load_library</strong>(library_name):
    return ffi.dlopen(library_name)
&nbsp;
&nbsp;
filler = load_library("libfiller.so")
&nbsp;
array = ffi.new("int[10]")
print(list(array))
&nbsp;
filler.fill(array, len(array)//2, 42)
print(list(array))
&nbsp;
filler.fill(array+5, len(array)//2, -1)
print(list(array))
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny Pythonovské skripty, které jsme si v&nbsp;dnešním článku ukázali,
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je nutné mít
nainstalovánu knihovnu <i>cffi</i>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>adder/adder.c</td><td>funkce psaná v&nbsp;C, která sečte své dva celočíselné parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/adder.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/adder.c</a></td></tr>
<tr><td> 2</td><td>adder/call_via_cffi1.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;korektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi1.py</a></td></tr>
<tr><td> 3</td><td>adder/call_via_cffi2.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi2.py</a></td></tr>
<tr><td> 4</td><td>adder/call_via_cffi3.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi3.py</a></td></tr>
<tr><td> 5</td><td>adder/call_via_cffi.sh</td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi.sh</a></td></tr>
<tr><td> 6</td><td>adder/call_via_ctypes1.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;korektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes1.py</a></td></tr>
<tr><td> 7</td><td>adder/call_via_ctypes2.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes2.py</a></td></tr>
<tr><td> 8</td><td>adder/call_via_ctypes3.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes3.py</a></td></tr>
<tr><td> 9</td><td>adder/call_via_ctypes.sh </td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes.sh</a></td></tr>
<tr><td>10</td><td>adder/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/make_library.sh</a></td></tr>
<tr><td>11</td><td>adder/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>greeter/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/greeter.c</a></td></tr>
<tr><td>13</td><td>greeter/call_via_cffi1.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;nekorektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi1.py</a></td></tr>
<tr><td>14</td><td>greeter/call_via_cffi2.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi2.py</a></td></tr>
<tr><td>15</td><td>greeter/call_via_cffi3.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi3.py</a></td></tr>
<tr><td>16</td><td>greeter/call_via_cffi.sh</td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi.sh</a></td></tr>
<tr><td>17</td><td>greeter/call_via_ctypes1.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;nekorektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes1.py</a></td></tr>
<tr><td>18</td><td>greeter/call_via_ctypes2.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes2.py</a></td></tr>
<tr><td>19</td><td>greeter/call_via_ctypes3.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes3.py</a></td></tr>
<tr><td>20</td><td>greeter/call_via_ctypes.sh</td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes.sh</a></td></tr>
<tr><td>21</td><td>greeter/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/make_library.sh</a></td></tr>
<tr><td>22</td><td>greeter/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>swapper/swapper.c</td><td>céčkovská funkce prohazující obsah svých dvou parametrů předávaných referencí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/swapper.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/swapper.c</a></td></tr>
<tr><td>24</td><td>swapper/call_via_cffi1.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python (korektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi1.py</a></td></tr>
<tr><td>25</td><td>swapper/call_via_cffi2.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python (nekorektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi2.py</a></td></tr>
<tr><td>26</td><td>swapper/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi.sh</a></td></tr>
<tr><td>27</td><td>swapper/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/make_library.sh</a></td></tr>
<tr><td>28</td><td>swapper/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>filler/filler.c</td><td>céčkovská funkce pro vyplnění části pole zadanou hodnotou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/filler.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/filler.c</a></td></tr>
<tr><td>30</td><td>filler/call_via_cffi.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.py</a></td></tr>
<tr><td>31</td><td>filler/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.sh</a></td></tr>
<tr><td>32</td><td>filler/make_library.sh </td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/make_library.sh</a></td></tr>
<tr><td>32</td><td>filler/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/clean.sh</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>TIOBE Index for May 2023<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>CFFI documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>cffi 1.15.1 na PyPi<br />
<a href="https://pypi.org/project/cffi/">https://pypi.org/project/cffi/</a>
</li>

<li>Python Bindings: Calling C or C++ From Python<br />
<a href="https://realpython.com/python-bindings-overview/">https://realpython.com/python-bindings-overview/</a>
</li>

<li>Interfacing with C/C++ Libraries<br />
<a href="https://docs.python-guide.org/scenarios/clibs/">https://docs.python-guide.org/scenarios/clibs/</a>
</li>

<li>Cython, pybind11, cffi – which tool should you choose?<br />
<a href="http://blog.behnel.de/posts/cython-pybind11-cffi-which-tool-to-choose.html">http://blog.behnel.de/posts/cython-pybind11-cffi-which-tool-to-choose.html</a>
</li>

<li>Python FFI with ctypes and cffi<br />
<a href="https://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi">https://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi</a>
</li>

<li>Propojení Go s&nbsp;Pythonem s&nbsp;využitím cgo a ctypes<br />
<a href="https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes/">https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes/</a>
</li>

<li>Propojení Go s&nbsp;Pythonem s&nbsp;využitím cgo a ctypes (2. část)<br />
<a href="https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes-2-cast/">https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes-2-cast/</a>
</li>

<li>Programovací jazyk Rust: použití FFI pro volání funkcí z&nbsp;nativních knihoven<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven/">https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven/</a>
</li>

<li>Programovací jazyk Rust: použití FFI při předávání struktur<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pri-predavani-struktur/">https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pri-predavani-struktur/</a>
</li>

<li>Programovací jazyk Rust: použití FFI pro volání funkcí z&nbsp;nativních knihoven (2. část)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven-2-cast/">https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven-2-cast/</a>
</li>

<li>Dynamic-link library<br />
<a href="https://en.wikipedia.org/wiki/Dynamic-link_library">https://en.wikipedia.org/wiki/Dynamic-link_library</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

