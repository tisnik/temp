<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Algebraické datové typy v Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Algebraické datové typy v Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se ve stručnosti seznámíme s (částečnou) podporou algebraických datových typů v jazyku Python. Algebraické datové typy původně byly doménou jazyků ML, CAML, OCaml a F#, ovšem postupně se rozšiřují i do mainstreamových programovacích jazyků.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Algebraické datové typy v&nbsp;Pythonu</a></p>
<p><a href="#k02">2. Datový typ záznam (<i>record</i>)</a></p>
<p><a href="#k03">3. Datový typ n-tice (<i>tuple</i>)</a></p>
<p><a href="#k04">4. Datový typ disjunktní sjednocení (<i>discriminated union</i>)</a></p>
<p><a href="#k05">5. Od jazyků z&nbsp;rodiny ML k&nbsp;Pythonu</a></p>
<p><a href="#k06">6. Statické typové kontroly</a></p>
<p><a href="#k07">7. Product types v&nbsp;Pythonu</a></p>
<p><a href="#k08">8. Sum types v&nbsp;Pythonu</a></p>
<p><a href="#k09">9. Výpočet plochy geometrických tvarů: základní varianta</a></p>
<p><a href="#k10">10. Detekce hodnoty nekorektního typu</a></p>
<p><a href="#k11">11. Využití strukturálního pattern matchingu</a></p>
<p><a href="#k12">12. Detekce hodnoty nekorektního typu v&nbsp;konstrukci se strukturálním pattern matchingem</a></p>
<p><a href="#k13">13. Zachycení atributů do proměnných se stejným názvem, jaký mají původní atributy</a></p>
<p><a href="#k14">14. Využití datových tříd</a></p>
<p><a href="#k15">15. Přidání typových anotací</a></p>
<p><a href="#k16">16. Chování při odstranění jedné větve z&nbsp;konstrukce <strong>match-case</strong></a></p>
<p><a href="#k17">17. Chování v&nbsp;případě, že je součtový datový typ neúplný</a></p>
<p><a href="#k18">18. Chování při použití zcela nepodporovaného typu při volání funkce <strong>area</strong>, využití <strong>assert_never</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Algebraické datové typy v&nbsp;Pythonu</h2>

<p><a href="https://www.root.cz/serialy/f-a-ocaml/">V&nbsp;seriálu o
programovacích jazycích ML, CAML, OCaml a F#</a>, který na Rootu vycházel
zhruba před dvěma roky, jsme zabývali mj.&nbsp;i jednou z&nbsp;nejlepších
technologií, kterou jsou tyto programovací jazyky vybaveny. Jedná se o podporu
takzvaného <i>algebraického typového systému</i> (<i>algebraic type
system</i>). Jedná se o označení takového typového systému, který umožňuje
z&nbsp;jednodušších datových typů skládat složitější (kompozitní) datové typy
s&nbsp;(velmi zjednodušeně řečeno) využitím operátorů <strong>and</strong> a
<strong>or</strong> &ndash; výsledný typ tedy buď obsahuje položky všech
uvedených typů nebo jednu z&nbsp;těchto položek. Výsledné datové typy se často
označují termíny <i>product types</i> a <i>sum types</i>, ovšem v&nbsp;praxi se
spíše setkáme s&nbsp;konkrétními realizacemi těchto typů: n-ticemi, záznamy a
disjunktním sjednocením.</p>

<p>Algebraické datové typy je možné do jisté míry využít i <a
href="https://www.root.cz/n/python/">v&nbsp;Pythonu</a>. Typicky se
v&nbsp;tomto případě používá řešení založené na typových informacích (<i>type
hints</i>), datových třídách (<i>data classes</i>) a strukturálním pattern
matchingu. Jak uvidíme v&nbsp;praktické části dnešního článku, nejedná se
vlastně ze syntaktického pohledu o žádné nové konstrukce, ovšem jejich
sémantický význam je poměrně velký a posouvá Python k&nbsp;jazykům
s&nbsp;vyspělým typovým systémem (zde skutečně urazil dlouhou cestu).</p>

<p><div class="rs-tip-major">Poznámka: samozřejmě se nevyhneme kontrole
datových typů. K&nbsp;tomuto účelu použijeme nástroj <strong>mypy</strong>, se
kterým jsme se již na <a
href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy"/>stránkách
Roota ve stručnosti seznámili</a>, a taktéž nástroj <strong>Pyright</strong>,
který se pro tyto účely hodí ještě víc.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Datový typ záznam (<i>record</i>))</h2>

<p>Nejdříve se zaměříme na datové typy, které jsou složeny z&nbsp;jiných
(jednodušších) datových typů takovým způsobem, že v&nbsp;novém typu musí být
obsaženy všechny specifikované složky. V&nbsp;angličtině se tyto typy označují
termínem <i>product type</i> a pravděpodobně nejznámějším takovým typem
v&nbsp;běžných programovacích jazycích jsou záznamy (<i>record</i>). Příkladem
je definice záznamu v&nbsp;jazyku F#:</p>

<pre>
type car = {
    Color: string;
    Model: string;
    Manufacturer: string;
    Year: int;
}
</pre>

<p>Následuje příklad definice záznamu v&nbsp;programovacím jazyku Go, který
záznamy taktéž přímo podporuje (nazývají se zde <strong>struct</strong>):</p>

<pre>
type <strong>Car</strong> struct {
    Color        string
    Model        string
    Manufacturer string
    Year         int
}
</pre>

<p>Povšimněte si, že se skutečně jedná o <i>product type</i>, tj.&nbsp;o datový
typ, jehož hodnoty mohou obsahovat všechny kombinace hodnot jeho složek. To je
v&nbsp;případě složek typu <strong>string</strong> a <strong>int</strong>
obrovské množství kombinací, proto si ukažme jednodušší strukturu/záznam:</p>

<pre>
type <strong>AccessRights</strong> struct {
    read    bool
    write   bool
    execute bool
}
</pre>

<p>Každá ze složek záznamu může obsahovat jednu z&nbsp;hodnot
<strong>true</strong> nebo <strong>false</strong>, což jsou dvě hodnoty. Celkem
tedy může nový typ <strong>AccessRights</strong> nabývat jedné
z&nbsp;2&times;2&times;2=8 hodnot (zde je již pravděpodobně patrné, proč se
používá termín <i>product type</i>).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Datový typ n-tice (<i>tuple</i>)</h2>

<p>Ve skutečnosti nejsou záznamy tím nejjednodušším součinovým datovým typem.
Poněkud jednodušší jsou n-tice, které jsou taktéž některými jazyky podporovány.
Příkladem bude opět programovací jazyk F#. V&nbsp;tomto jazyku mohou n-tice
obsahovat prvky libovolných typů. Typ n-tice jako celku je pak odvozen od typů
jednotlivých prvků. Speciálním případem je n-tice bez prvků, neboli datový typ
<strong>unit</strong>.</p>

<p>Ukažme si příklad použití n-tice se dvěma prvky typu <strong>int</strong>
v&nbsp;jazyku F#:</p>

<pre>
<strong>Printf.printf "%A" (1,2)</strong>
</pre>

<p>Typ této n-tice se zapisuje takto:</p>

<pre>
int * int = (1, 2)
</pre>

<p><div class="rs-tip-major">Poznámka: opět zde máme nápovědu &ndash; znak *
naznačuje, že se jedná o součinový typ.</div></p>

<p>Typ složitější n-tice, která obsahuje prvky různých typů:</p>

<pre>
<strong>(1, 1.5, "foo", (1,2)) ;;</strong>
&nbsp;
- : int * float * string * (int * int) = (1, 1.5, "foo", (1, 2))
</pre>

<p>N-tici je samozřejmě možné přiřadit do proměnné a poté si nechat vytisknout
její obsah:</p>

<pre>
<strong>let x = (1,2,3)</strong>
<strong>Printf.printf "%A" x</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: vzhledem k&nbsp;tomu, že n-tice
s&nbsp;jediným prvkem nemá praktický význam, není v&nbsp;jazyce F# podporována
(na rozdíl od Pythonu, kde se však jedná o syntakticky problematický rys
jazyka).</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Datový typ disjunktní sjednocení (<i>discriminated union</i>)</h2>

<p>Velmi důležitým datovým typem je v&nbsp;programovacím jazyku F# (ale nikoli
pouze zde) typ nazývaný disjunktní sjednocení neboli <i>discriminated
union</i>. V&nbsp;té nejjednodušší podobě může být tento typ definován pouhým
výčtem možností:</p>

<pre>
type <strong>Day</strong> = Po | Ut | St | Ct | Pa | So | Ne
&nbsp;
let x = St
&nbsp;
printf "%A\n" x
</pre>

<p>Alternativní způsob zápisu:</p>

<pre>
type <strong>Day</strong> =
     | Po
     | Ut
     | St
     | Ct
     | Pa
     | So
     | Ne
let x = St
printf "%A\n" x
</pre>

<p>Až doposud by se mohlo zdát, že se vlastně jedná o typ výčet, ovšem možnosti
disjunktního sjednocení jsou mnohem větší. Pro některé jazyky, mj.&nbsp;i pro
Rust, je typické a idiomatické použití typů <strong>Option</strong> a
<strong>Result</strong>:</p>

<pre>
type <strong>Option&lt;'a&gt;</strong> =
   | Some of 'a
   | None
</pre>

<p>a:</p>

<pre>
type <strong>Result&lt;'T,'TError&gt;</strong> =
    | Ok of ResultValue:'T
    | Error of ErrorValue:'TError
</pre>

<p>Nejedná se o nic jiného, než právě o disjunktní sjednocení.</p>

<p><div class="rs-tip-major">Poznámka: zatímco n-tice a záznamy jsou součinové
typy, je disjunktní zobrazení typem součtovým.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Od jazyků z&nbsp;rodiny ML k&nbsp;Pythonu</h2>

<p><i>&bdquo;Objects are an open universe, where clients can implement new
subclasses that were not known at definition time; ADTs are a closed universe,
where the definition of an ADT specifies precisely all the cases that are
possible.&ldquo;</i></p>

<p>Algebraické datové typy se používají v&nbsp;několika desítkách
programovacích jazyků, ovšem pravděpodobně nejznámější je jejich využití
v&nbsp;jazycích z&nbsp;rodiny ML. Do této skupiny spadají především jazyky ML,
Standard ML, CAML, OCaml a F# (možná by se do této skupiny mohl zařadit i jazyk
Elm). Nás ovšem bude primárně zajímat způsob využití algebraických datových
typů v&nbsp;Pythonu. A vzhledem k&nbsp;tomu, že interpret programovacího jazyka
Python neprovádí prakticky žádné statické typové kontroly, doplníme tento
nástroj o další dvojici užitečných nástrojů. Bude se jednat o nástroje Mypy a
Pyright. V&nbsp;následujících kapitolách se nejdříve ve stručnosti seznámíme
s&nbsp;problematikou statických typových kontrol, řekneme si, jak lze
v&nbsp;Pythonu implementovat součinové a součtové typy a nakonec si
v&nbsp;několika krocích ukážeme postupnou modifikaci příkladu, který je na
těchto dvou datových typech založen (i když to zpočátku nemusí být zřejmé).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Statické typové kontroly</h2>

<p>Python samotný již od verze 3.5 podporuje zápis takzvaných typových anotací
resp.&nbsp;nápověd (<i>type annotations</i>, <i>type hints</i>). Jedná se o
nepovinnou (zcela dobrovolnou) specifikaci typů parametrů funkcí a metod,
návratových hodnot funkcí a metod, typů proměnných atd. A právě zápis typových
anotací do značné míry umožňuje provedení statických typových kontrol.</p>

<p>Myšlenka, na níž stojí statická typová kontrola, je snadno pochopitelná,
protože se do značné míry podobá dalším analýzám kódu (které provádí překladač,
lintery atd.). Celá myšlenka je založena na tom, že u každé proměnné
deklarované v&nbsp;programu, u každého parametru funkce a taktéž u každého
návratového parametru funkce se přímo či nepřímo uvede datový typ (nepřímo
v&nbsp;případě, že jazyk umí typ odvodit z&nbsp;použité hodnoty &ndash; jedná
se o takzvanou <i>typovou inferenci</i>). Díky tomu, že je specifikace typu
proměnné/parametru/návratové hodnoty dostupná přímo ve formě zdrojového kódu,
může být typová kontrola skutečně statická &ndash; nevyžaduje tedy, aby se
program spustil. To má své nesporné výhody, protože takto specifikované
informace o typech dokáží zpracovat i moderní (a nejenom moderní) integrovaná
vývojová prostředí, která ji mohou použít v&nbsp;kontextové nápovědě atd.</p>

<p>Ovšem současně zde narážíme na značnou nevýhodu: je velmi složité vytvořit
snadno použitelný a současně i staticky typovaný programovací jazyk. A další
nevýhodou je, že zápis datových typů je vyžadován i v&nbsp;případě, že se tvoří
jednoduché skripty nebo prototypy. Proto není divu, že mnoho jazyků (a nutno
říci, že mnohdy velmi úspěšných jazyků) striktní zápis datových typů nevyžaduje
a tím pádem nebude (zcela) dostupná statická typová kontrola.</p>

<p><div class="rs-tip-major">Poznámka: u staticky typovaných programovacích
jazyků provádí základní typové kontroly už samotný překladač. Ovšem jak uvidíme
v&nbsp;dalším textu, v&nbsp;závislosti na použitém typovém systému (různé typy
variance atd.) se může stát, že některé typové kontroly musí být přesunuty
z&nbsp;času překladu (<i>compile time</i>) do času běhu aplikace
(<i>runtime</i>).</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Product types v&nbsp;Pythonu</h2>

<p>Součinové typy lze v&nbsp;Pythonu realizovat několika možnými způsoby.
Typicky se používají n-tice nebo datové třídy (<i>dataclass</i>).</p>

<p>Začneme n-ticemi. U nich je možné explicitně určit typ všech jejich prvků
nebo typ jednotlivých prvků (potom se vlastně jedná o zjednodušené záznamy).
Ostatně si to vyzkoušejme na několika příkladech.</p>

<pre>
from typing import Tuple
&nbsp;
p: Tuple[int] = (1, 2, 3)
</pre>

<p>Tento zápis není korektní, protože specifikuje, že n-tice může obsahovat
jediný prvek typu <strong>int</strong> a nikoli trojici prvků:</p>

<pre>
tuple_type1.py:3: error: Incompatible types in assignment (expression has type "Tuple[int, int, int]", variable has type "Tuple[int]")  [assignment]
Found 1 error in 1 file (checked 1 source file)
</pre>

<p>Pokud skutečně budeme chtít vytvořit n-tici se třemi prvky typu
<strong>int</strong> (například pro reprezentaci barvy atd.), můžeme použít
tento zápis:</p>

<pre>
from typing import Tuple
&nbsp;
p: Tuple[int, int, int] = (1, 2, 3)
</pre>

<p>Nic nám však nebrání v&nbsp;tom určit, že každý prvek n-tice má být
odlišného datového typu, což je ukázáno na dalším příkladu:</p>

<pre>
from typing import Tuple
&nbsp;
p: Tuple[int, float, bool, str] = (1, 3.14, True, "Hello")
</pre>

<p>Výsledek statické typové kontroly:</p>

<pre>
Success: no issues found in 1 source file
</pre>

<p>A naopak si můžeme ukázat, kdy statická typová kontrola nalezne
problematický kód:</p>

<pre>
from typing import Tuple
&nbsp;
p: Tuple[int, float, bool, str] = (2.0, 3.14, 1, "Hello")
</pre>

<pre>
main.py:3: error: Incompatible types in assignment (expression has type "Tuple[float, float, int, str]", variable has type "Tuple[int, float, bool, str]")  [assignment]
Found 1 error in 1 file (checked 1 source file)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že je přesně určeno,
v&nbsp;čem chyba spočívá.</div></p>

<p>Alternativně lze použít datové třídy, u nichž se aplikací dekorátoru
<strong>dataclass</strong> automaticky vygeneruje jak konstruktor, tak i metoda
<strong>__repr__</strong>. A i v&nbsp;tomto případě můžeme provádět statické
typové kontroly:</p>

<pre>
from dataclasses import dataclass
&nbsp;
&nbsp;
<u>@dataclass</u>
class <strong>Rectangle</strong>:
    width: float
    height: float
&nbsp;
&nbsp;
rectangle_shape = Rectangle(height=2, width=3)
</pre>

<p>Nekorektní volání konstruktoru s&nbsp;hodnotou špatného typu:</p>

<pre>
from dataclasses import dataclass
&nbsp;
&nbsp;
<u>@dataclass</u>
class <strong>Rectangle</strong>:
    width: float
    height: float
&nbsp;
&nbsp;
rectangle_shape = Rectangle(height="foo", width=3)
</pre>

<p>Výsledek statické typové kontroly:</p>

<pre>
/home/ptisnovs/src/most-popular-python-libs/algebraic_types/dataclass_2.py
  /home/ptisnovs/src/most-popular-python-libs/algebraic_types/dataclass_2.py:10:36 - error: Argument of type "Literal['foo']" cannot be assigned to parameter "height" of type "float" in function "__init__"
    "Literal['foo']" is not assignable to "float" (reportArgumentType)
1 error, 0 warnings, 0 informations 
</pre>

<p>Nekorektní volání konstruktoru s&nbsp;neuvedením hodnot atributů:</p>

<pre>
from dataclasses import dataclass
&nbsp;
&nbsp;
<u>@dataclass</u>
class <strong>Rectangle</strong>:
    width: float
    height: float
&nbsp;
&nbsp;
rectangle_shape = Rectangle()
</pre>

<p>Výsledek typové kontroly:</p>

<pre>
/home/ptisnovs/src/most-popular-python-libs/algebraic_types/dataclass_3.py
  /home/ptisnovs/src/most-popular-python-libs/algebraic_types/dataclass_3.py:10:19 - error: Arguments missing for parameters "width", "height" (reportCallIssue)
1 error, 0 warnings, 0 informations
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Sum types v&nbsp;Pythonu</h2>

<p>Deklarace součtového typu může být snadná. Předpokládejme, že máme
definovány tři typy nazvané <strong>Square</strong>, <strong>Rectangle</strong>
a <strong>Circle</strong> (typicky se bude jednat o datové třídy &ndash;
<i>dataclass</i>). Z&nbsp;nich můžeme odvodit nový součtový typ následujícím
způsobem:</p>

<pre>
Shape = Square | Rectangle | Circle
</pre>

<p>popř.&nbsp;ve starších verzích Pythonu:</p>

<pre>
from typing import Union
&nbsp;
Shape = Union[Square, Rectangle, Circle]
</pre>

<p>I proměnná <strong>Shape</strong> je určitého typu, který můžeme zapsat
explicitně:</p>

<pre>
from typing import TypeAlias
&nbsp;
Shape: TypeAlias = Square | Rectangle | Circle
</pre>

<p>Můžeme si taktéž nadeklarovat známý typ, <strong>Result</strong> založený na
typových proměnných TOK a TERR:</p>

<pre>
TOK = TypeVar("TOK")
TERR = TypeVar("TERR")
&nbsp;
Result = Ok[TOK] | Err[TERR]
</pre>

<p><div class="rs-tip-major">Poznámka: asi vás napadlo, že podobně lze
realizovat typ <strong>Option</strong>, ten již však v&nbsp;modulu
<strong>typing</strong> existuje.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výpočet plochy geometrických tvarů: základní varianta</h2>

<p>Ve druhé části dnešního článku si ukážeme postupnou transformaci zdrojového
kódu založeného na běžných třídách do podoby, v&nbsp;níž se využijí algebraické
datové typy.</p>

<p>V&nbsp;první verzi zdrojového kódu je realizována funkce nazvaná
<strong>area</strong>, která dokáže vypočítat plochu zadaného geometrického
tvaru. Podporovány jsou čtverce, obdélníky a kruhy, přičemž každý z&nbsp;těchto
tvarů je implementován formou běžné třídy (bez společného předka). Povšimněte
si, že se vlastně nejedná o klasické objektově orientované programování,
protože to by vyžadovalo, aby každá z&nbsp;těchto tříd implementovala metodu
<strong>area</strong> (ovšem dále uvidíme, proč problém realizujeme jiným
způsobem; v&nbsp;každém případě je však &bdquo;OOP-přístup&ldquo; stále legální
a někdy i opodstatněný):</p>

<pre>
from math import pi
&nbsp;
&nbsp;
class <strong>Square</strong>:
    def <strong>__init__</strong>(self, size):
        self.size = size
&nbsp;
&nbsp;
class <strong>Rectangle</strong>:
    def <strong>__init__</strong>(self, width, height):
        self.width = width
        self.height = height
&nbsp;
&nbsp;
class <strong>Circle</strong>:
    def <strong>__init__</strong>(self, radius):
        self.radius = radius
&nbsp;
&nbsp;
def <strong>area</strong>(shape):
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    if isinstance(shape, Square):
        return shape.size**2
    elif isinstance(shape, Rectangle):
        return shape.width * shape.height
    elif isinstance(shape, Circle):
        return pi * shape.radius**2
&nbsp;
&nbsp;
square_shape = Square(10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(2, 3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
&nbsp;
area("xyzzy")
</pre>

<p>V&nbsp;tomto zdrojovém kódu nalezneme minimálně tři problémy: neřeší se
problematika předání nepodporované hodnoty do funkce <strong>area</strong>,
zcela chybí typové anotace (<i>type hints</i>) a navíc je detekce typu předané
hodnoty vyloženě škaredá &ndash; takové &bdquo;špagety&ldquo; většinou značí
špatný návrh.</p>

<p>První problém otestujeme spuštěním skriptu:</p>

<pre>
Area of square: 100 units
Area of rectangle: 6 units
Area of circle: 314.1592653589793 units
*** zde chybí jakákoli zmínka o chybném předání řetězce "xyzzy" ***
</pre>

<p>Druhý problém odhalí nástroj Mypy:</p>

<pre>
$ <strong>mypy --strict iteration_01.py</strong>
</pre>

<p>Vypíše se informace o všech místech v&nbsp;kódu, ve kterých chybí typové
anotace, které by vylepšily kontrolu chyb:</p>

<pre>
iteration_01.py:5: error: Function is missing a type annotation  [no-untyped-def]
iteration_01.py:10: error: Function is missing a type annotation  [no-untyped-def]
iteration_01.py:16: error: Function is missing a type annotation  [no-untyped-def]
iteration_01.py:20: error: Function is missing a type annotation  [no-untyped-def]
iteration_01.py:30: error: Call to untyped function "Square" in typed context  [no-untyped-call]
iteration_01.py:31: error: Call to untyped function "area" in typed context  [no-untyped-call]
iteration_01.py:34: error: Call to untyped function "Rectangle" in typed context  [no-untyped-call]
iteration_01.py:35: error: Call to untyped function "area" in typed context  [no-untyped-call]
iteration_01.py:38: error: Call to untyped function "Circle" in typed context  [no-untyped-call]
iteration_01.py:39: error: Call to untyped function "area" in typed context  [no-untyped-call]
iteration_01.py:42: error: Call to untyped function "area" in typed context  [no-untyped-call]
Found 11 errors in 1 file (checked 1 source file)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Detekce hodnoty nekorektního typu</h2>

<p>Detekci předání hodnoty nekorektního typu do funkce <strong>area</strong>
pochopitelně můžeme do programového kódu snadno přidat, i když je nutné
upozornit na to, že je zdrojový kód stále špatně čitelný i špatně
rozšiřitelný:</p>

<pre>
from math import pi
&nbsp;
&nbsp;
class <strong>Square</strong>:
    def <strong>__init__</strong>(self, size):
        self.size = size
&nbsp;
&nbsp;
class <strong>Rectangle</strong>:
    def <strong>__init__</strong>(self, width, height):
        self.width = width
        self.height = height
&nbsp;
&nbsp;
class <strong>Circle</strong>:
    def <strong>__init__</strong>(self, radius):
        self.radius = radius
&nbsp;
&nbsp;
def <strong>area</strong>(shape):
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    if isinstance(shape, Square):
        return shape.size**2
    elif isinstance(shape, Rectangle):
        return shape.width * shape.height
    elif isinstance(shape, Circle):
        return pi * shape.radius**2
    <u>else:</u>
        <u>raise TypeError(f"Unknown type '{type(shape).__name__}'")</u>
&nbsp;
&nbsp;
square_shape = Square(10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(2, 3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
&nbsp;
area("xyzzy")
</pre>

<p>Nyní po spuštění takto upraveného příkladu dojde ke korektnímu rozpoznání,
že se funkci <strong>area</strong> snažíme předávat hodnotu typu, který není
podporován. Vypíše se přesná informace o nepodporovaném typu:</p>

<pre>
Area of square: 100 units
Area of rectangle: 6 units
Area of circle: 314.1592653589793 units
&nbsp;
Traceback (most recent call last):
  File "/home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_02.py", line 44, in &lt;module&gt;
    area("xyzzy")
  File "/home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_02.py", line 29, in area
    raise TypeError(f"Unknown type '{type(shape).__name__}'")
TypeError: Unknown type 'str'
</pre>

<p><div class="rs-tip-major">Poznámka: na okraj &ndash; v&nbsp;Pythonu nemusíme
řešit &bdquo;speciální případy&ldquo;, kdy se namísto nějaké hodnoty předá
<strong>None</strong>. V&nbsp;Pythonu je totiž i <strong>None</strong> běžnou
hodnotou, konkrétně hodnotou typu <strong>NoneType</strong>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Využití strukturálního pattern matchingu</h2>

<p>V&nbsp;relativně nedávno vydaném Pythonu verze 3.10 se objevila dlouho
očekávaná novinka &ndash; takzvaný <i>strukturální pattern matching</i>. Jedná
se o v&nbsp;jazyku Python zcela novou programovou konstrukci, která velmi
vzdáleně připomíná konstrukci <strong>switch-case</strong>
z&nbsp;programovacího jazyka C (odkud byla převzata do dalších programovacích
jazyků, včetně C++ či Javy). Ovšem strukturální pattern matching ve skutečnosti
programátorům nabízí mnohem více možností než původní značně primitivní
konstrukce <strong>switch-case</strong>. Některé z&nbsp;těchto možností si
ukážeme právě v&nbsp;našem demonstračním příkladu.</p>

<p>Možnosti této nové programové konstrukce zahrnují i možnost testu či testů,
zda je hodnotou nějaký objekt (tedy atribut určité třídy), popř.&nbsp;jaké jsou
hodnoty atributů tohoto objektu. A právě tyto vzorky použijeme v&nbsp;našem
příkladu:</p>

<pre>
match shape:
    case Square(size=s):
        return s**2
    case Rectangle(width=w, height=h):
        return w * h
    case Circle(radius=r):
        return pi * r**2
</pre>

<p>Povšimněte si, že <strong>s</strong>, <strong>w</strong>, <strong>h</strong>
a <strong>r</strong> jsou proměnné, do kterých je zachycena konkrétní hodnota
atributů <strong>size</strong>, <strong>width</strong>, <strong>height</strong>
či <strong>radius</strong>.</p>

<p>Úplný zdrojový kód takto upraveného příkladu vypadá následovně:</p>

<pre>
from math import pi
&nbsp;
&nbsp;
class <strong>Square</strong>:
    def <strong>__init__</strong>(self, size):
        self.size = size
&nbsp;
&nbsp;
class <strong>Rectangle</strong>:
    def <strong>__init__</strong>(self, width, height):
        self.width = width
        self.height = height
&nbsp;
&nbsp;
class <strong>Circle</strong>:
    def <strong>__init__</strong>(self, radius):
        self.radius = radius
&nbsp;
&nbsp;
def <strong>area</strong>(shape):
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size=s):
            return s**2
        case Rectangle(width=w, height=h):
            return w * h
        case Circle(radius=r):
            return pi * r**2
&nbsp;
&nbsp;
square_shape = Square(10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(2, 3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
&nbsp;
area("xyzzy")
</pre>

<p>Výsledky:</p>

<pre>
Area of square: 100 units
Area of rectangle: 6 units
Area of circle: 314.1592653589793 units
</pre>

<p><div class="rs-tip-major">Poznámka: opět zde tedy chybí informace o tom, že
jsme funkci <strong>area</strong> zavolali se špatnou hodnotou,
resp.&nbsp;přesněji řečeno s&nbsp;hodnotou nepodporovaného typu.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Detekce hodnoty nekorektního typu v&nbsp;konstrukci se strukturálním pattern matchingem</h2>

<p>Programová konstrukce <strong>match-case</strong> umožňuje zapsat
v&nbsp;jedné větvi (typicky ve větvi poslední) vzorek, který se zapisuje pouze
formou podtržítka. Tento vzorek odpovídá jakémukoli vstupu, což vlastně
znamená, že příslušná větev odpovídá (i když ne zcela přesně) větvi
<strong>default</strong> známé z&nbsp;céčkovských jazyků nebo z&nbsp;Javy. To
nám mj.&nbsp;umožňuje naprogramovat reakci na situaci, ve které se předává
hodnota nekorektního typu, tj.&nbsp;taková hodnota, která není zachycena
předchozími větvemi:</p>

<pre>
match shape:
    case Square(size=s):
        return s**2
    case Rectangle(width=w, height=h):
        return w * h
    case Circle(radius=r):
        return pi * r**2
    <u>case _</u>:
        <u>raise TypeError(f"Unknown type '{type(shape).__name__}'")</u>
</pre>

<p>Upravený zdrojový kód demonstračního příkladu nyní vypadá následovně:</p>

<pre>
from math import pi
&nbsp;
&nbsp;
class <strong>Square</strong>:
    def <strong>__init__</strong>(self, size):
        self.size = size
&nbsp;
&nbsp;
class <strong>Rectangle</strong>:
    def <strong>__init__</strong>(self, width, height):
        self.width = width
        self.height = height
&nbsp;
&nbsp;
class <strong>Circle</strong>:
    def <strong>__init__</strong>(self, radius):
        self.radius = radius
&nbsp;
&nbsp;
def <strong>area</strong>(shape):
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size=s):
            return s**2
        case Rectangle(width=w, height=h):
            return w * h
        case Circle(radius=r):
            return pi * r**2
        case _:
            raise TypeError(f"Unknown type '{type(shape).__name__}'")
&nbsp;
&nbsp;
square_shape = Square(10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(2, 3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
&nbsp;
area("xyzzy")
</pre>

<p>Po spuštění skriptu je patrné, že při předání řetězce dojde
k&nbsp;(očekávanému) vyhození výjimky:</p>

<pre>
Area of square: 100 units
Area of rectangle: 6 units
Area of circle: 314.1592653589793 units
&nbsp;
Traceback (most recent call last):
  File "/home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_04.py", line 45, in &lt;module&gt;
    area("xyzzy")
  File "/home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_04.py", line 30, in area
    raise TypeError(f"Unknown type '{type(shape).__name__}'")
TypeError: Unknown type 'str'
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zachycení atributů do proměnných se stejným názvem, jaký mají původní atributy</h2>

<p>V&nbsp;předchozí dvojici demonstračních příkladů jsme zachytávali atributy
objektů typu <strong>Square</strong>, <strong>Rectangle</strong> a
<strong>Circle</strong> do nových proměnných, které se jmenovaly odlišně, než
samotné atributy. Například atribut <strong>size</strong> objektu typu
<strong>Square</strong> byl zachycen do proměnné <strong>s</strong> atd.:</p>

<pre>
match shape:
    case Square(<u>size=s</u>):
        return s**2
    case Rectangle(<u>width=w</u>, <u>height=h</u>):
        return w * h
    case Circle(<u>radius=r</u>):
        return pi * r**2
    case _:
        raise TypeError(f"Unknown type '{type(shape).__name__}'")
</pre>

<p>To však ve skutečnosti není nutné, protože jména atributů leží
v&nbsp;odlišném jmenném prostoru, než jména proměnných, do kterých je
zachytávání prováděno. Tudíž nemusíme trávit čas vymýšlením nových jmen (což
nedává smysl &ndash; sémanticky stejná hodnota má mít stejné jméno) a můžeme
přímo psát:</p>

<pre>
match shape:
    case Square(<u>size=size</u>):
        return size**2
    case Rectangle(<u>width=width</u>, <u>height=height</u>):
        return width * height
    case Circle(<u>radius=radius</u>):
        return pi * radius**2
    case _:
        raise TypeError(f"Unknown type '{type(shape).__name__}'")
</pre>

<p>Upravený zdrojový kód skriptu bude vypadat následovně a bude se chovat
stejně, jako skript původní:</p>

<pre>
from math import pi
&nbsp;
&nbsp;
class <strong>Square</strong>:
    def <strong>__init__</strong>(self, size):
        self.size = size
&nbsp;
&nbsp;
class <strong>Rectangle</strong>:
    def <strong>__init__</strong>(self, width, height):
        self.width = width
        self.height = height
&nbsp;
&nbsp;
class <strong>Circle</strong>:
    def <strong>__init__</strong>(self, radius):
        self.radius = radius
&nbsp;
&nbsp;
def <strong>area</strong>(shape):
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size=size):
            return size**2
        case Rectangle(width=width, height=height):
            return width * height
        case Circle(radius=radius):
            return pi * radius**2
        case _:
            raise TypeError(f"Unknown type '{type(shape).__name__}'")
&nbsp;
&nbsp;
square_shape = Square(10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(2, 3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Využití datových tříd</h2>

<p>V&nbsp;dalším kroku využijeme velmi užitečnou vlastnost, která byla přidána
do Pythonu verze 3.7. Jedná se o dekorátor nazvaný <strong>dataclass</strong>,
který je aplikován na celou třídu. S&nbsp;využitím tohoto dekorátoru je možné
do třídy automaticky vložit konstruktor <strong>__init__</strong>, který
automaticky inicializuje všechny atributy na základě parametrů předaných
konstruktoru. Navíc je vytvořena i metoda <strong>__repr__</strong>, což
zjednodušuje tisk obsahu datových tříd.</p>

<p>Podívejme se na jednoduchou datovou třídu:</p>

<pre>
<i>@dataclass</i>
class <strong>Rectangle</strong>:
    width: float
    height: float
</pre>

<p>Instance této třídy se vytvoří snadno:</p>

<pre>
rectangle_shape = Rectangle(height=2, width=3)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak je deklarace datové
třídy jednoduchá a navíc i velmi přehledná.</div></p>

<p>Navíc se zpřehlední i samotný zápis pattern matchingu &ndash; není zapotřebí
explicitně specifikovat proměnné pro zachycení:</p>

<pre>
match shape:
    case Square(size):
        return size**2
    case Rectangle(width, height):
        return width * height
    case Circle(radius):
        return pi * radius**2
</pre>

<p>Nová podoba našeho skriptu bude vypadat následovně:</p>

<pre>
from math import pi
from dataclasses import dataclass
&nbsp;
&nbsp;
<u>@dataclass</u>
class <strong>Square</strong>:
    size: float
&nbsp;
&nbsp;
<u>@dataclass</u>
class <strong>Rectangle</strong>:
    width: float
    height: float
&nbsp;
&nbsp;
<u>@dataclass</u>
class <strong>Circle</strong>:
    radius: float
&nbsp;
&nbsp;
def <strong>area</strong>(shape):
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size):
            return size**2
        case Rectangle(width, height):
            return width * height
        case Circle(radius):
            return pi * radius**2
&nbsp;
&nbsp;
square_shape = Square(size=10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(height=2, width=3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(radius=10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Přidání typových anotací</h2>

<p>Pokusme se nyní ověřit, do jaké míry je skript <a
href="#k14">z&nbsp;předchozí kapitoly</a> korektní z&nbsp;hlediska statické
typové kontroly:</p>

<pre>
$ <strong>mypy --strict iteration_06.py</strong>
&nbsp;
iteration_06.py:21: error: Function is missing a type annotation  [no-untyped-def]
iteration_06.py:33: error: Call to untyped function "area" in typed context  [no-untyped-call]
iteration_06.py:37: error: Call to untyped function "area" in typed context  [no-untyped-call]
iteration_06.py:41: error: Call to untyped function "area" in typed context  [no-untyped-call]
Found 4 errors in 1 file (checked 1 source file)
</pre>

<p>Z&nbsp;výsledků je patrné, že je nutné doplnit typové anotace, zejména do
hlavičky funkce <strong>area</strong>. V&nbsp;prvním kroku je však nutné
definovat nový součtový datový typ reprezentující všechny podporované
geometrické tvary. Takový typ se definuje snadno:</p>

<pre>
Shape = Square | Rectangle | Circle
</pre>

<p>Následně již můžeme upravit hlavičku funkce <strong>area</strong> do této podoby:</p>

<pre>
def <strong>area</strong>(shape: <u>Shape</u>) <u>-&gt; float</u>:
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    ...
    ...
    ...
</pre>

<p>Takto vypadá skript po výše popsaných úpravách:</p>

<pre>
from math import pi
from dataclasses import dataclass
&nbsp;
&nbsp;
@dataclass
class <strong>Square</strong>:
    size: float
&nbsp;
&nbsp;
@dataclass
class <strong>Rectangle</strong>:
    width: float
    height: float
&nbsp;
&nbsp;
@dataclass
class <strong>Circle</strong>:
    radius: float
&nbsp;
&nbsp;
Shape = Square | Rectangle | Circle
&nbsp;
&nbsp;
def <strong>area</strong>(shape: Shape) -&gt; float:
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size):
            return size**2
        case Rectangle(width, height):
            return width * height
        case Circle(radius):
            return pi * radius**2
&nbsp;
&nbsp;
square_shape = Square(size=10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(height=2, width=3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(radius=10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
</pre>

<p>Nyní dopadne statická typová kontrola mnohem lépe:</p>

<pre>
$ <strong>mypy --strict iteration_07.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Chování při odstranění jedné větve z&nbsp;konstrukce <strong>match-case</strong></h2>

<p>Připomeňme si, že náš nový datový typ <strong>Shape</strong> reprezentuje
tři podporované geometrické tvary, tedy konkrétně čtverec, obdélník a kruh:</p>

<pre>
Shape = Square | Rectangle | Circle
</pre>

<p>Vyzkoušejme si, co se stane v&nbsp;případě, že v&nbsp;konstrukci
<strong>match-case</strong> &bdquo;zapomeneme&ldquo; na větev odpovídající typu
<strong>Circle</strong>:</p>

<pre>
def <strong>area</strong>(shape: Shape) -&gt; float:
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size):
            return size**2
        case Rectangle(width, height):
            return width * height
</pre>

<p>V&nbsp;jazycích typu Rust nebo OCaml bychom byli na tento problém ihned
upozorněni ještě před spuštěním, ovšem v&nbsp;Pythonu tomu tak není &ndash;
interpret bez problémů příklad spustí a vypíše namísto obsahu kruhu nekorektní
hodnotu:</p>

<pre>
Area of square: 100 units
Area of rectangle: 6 units
Area of circle: None units
</pre>

<p>Musíme tedy použít statickou typovou kontrolu. Nejprve s&nbsp;využitím
nástroje Mypy:</p>

<pre>
$ <strong>mypy --strict iteration_08.py</strong>
&nbsp;
iteration_08.py:24: error: Missing return statement  [return]
Found 1 error in 1 file (checked 1 source file)
</pre>

<p>V&nbsp;tomto případě je sice problém popsán, ale nevíme, co přesně je
špatně. Pokusme se tedy použít nástroj Pyright:</p>

<pre>
$ <strong>pyright iteration_08.py</strong>
&nbsp;
/home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_08.py
  /home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_08.py:24:27 - error: Function with declared return type "float" must return value on all code paths
    "None" is not assignable to "float" (reportReturnType)
1 error, 0 warnings, 0 informations 
</pre>

<p>Chybové hlášení je opět neúplné.</p>

<p>Pro úplnost si uveďme celý příklad se &bdquo;zapomenutou&ldquo; větví:</p>

<pre>
from math import pi
from dataclasses import dataclass
&nbsp;
&nbsp;
@dataclass
class <strong>Square</strong>:
    size: float
&nbsp;
&nbsp;
@dataclass
class <strong>Rectangle</strong>:
    width: float
    height: float
&nbsp;
&nbsp;
@dataclass
class <strong>Circle</strong>:
    radius: float
&nbsp;
&nbsp;
Shape = Square | Rectangle | Circle
&nbsp;
&nbsp;
def <strong>area</strong>(shape: Shape) -&gt; float:
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size):
            return size**2
        case Rectangle(width, height):
            return width * height
&nbsp;
&nbsp;
square_shape = Square(size=10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(height=2, width=3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(radius=10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Chování v&nbsp;případě, že je součtový datový typ neúplný</h2>

<p>Chyb ovšem můžeme udělat více. Například můžeme zapomenout na přidání nového
podporovaného geometrického tvaru do typu <strong>Shape</strong>. Příkladem je
následující deklarace, ve které chybí typ <strong>Circle</strong>:</p>

<pre>
Shape = Square | Rectangle
</pre>

<p>S&nbsp;tímto typem ovšem budeme počítat ve funkci <strong>area</strong>
(takže se jedná o opak předchozího příkladu):</p>

<pre>
def <strong>area</strong>(shape: Shape) -&gt; float:
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size):
            return size**2
        case Rectangle(width, height):
            return width * height
        case Circle(c):
            return c
</pre>

<p>Nástroj Pyright nás na tento problém upozorní a vypíše přesný druh problému,
což je dobře:</p>

<pre>
$ <strong>pyright iteration_09.py</strong>
&nbsp;
/home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_09.py
  /home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_09.py:44:20 - error: Argument of type "Circle" cannot be assigned to parameter "shape" of type "Shape" in function "area"
    Type "Circle" is not assignable to type "Shape"
      "Circle" is not assignable to "Square"
      "Circle" is not assignable to "Rectangle" (reportArgumentType)
1 error, 0 warnings, 0 informations 
</pre>

<p>Pro úplnost si opět uveďme celý zdrojový kód tohoto příkladu:</p>

<pre>
from math import pi
from dataclasses import dataclass
&nbsp;
&nbsp;
@dataclass
class <strong>Square</strong>:
    size: float
&nbsp;
&nbsp;
@dataclass
class <strong>Rectangle</strong>:
    width: float
    height: float
&nbsp;
&nbsp;
@dataclass
class <strong>Circle</strong>:
    radius: float
&nbsp;
&nbsp;
Shape = Square | Rectangle
&nbsp;
&nbsp;
def <strong>area</strong>(shape: Shape) -&gt; float:
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size):
            return size**2
        case Rectangle(width, height):
            return width * height
        case Circle(c):
            return c
&nbsp;
&nbsp;
square_shape = Square(size=10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(height=2, width=3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(radius=10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Chování při použití zcela nepodporovaného typu při volání funkce <strong>area</strong>, využití <strong>assert_never</strong></h2>

<p>Předchozí dvojici demonstračních příkladů můžeme zkombinovat. Jak
v&nbsp;definici typu <strong>Shape</strong>, tak i v&nbsp;konstrukci
<strong>match-case</strong> zcela vynecháme typ <strong>Circle</strong> &ndash;
program tedy bude připraven na výpočty plochy pro čtverce a obdélníky. Ovšem
funkci <strong>area</strong> posléze zavoláme i s&nbsp;hodnotou typu
<strong>Circle</strong>:</p>

<pre>
from dataclasses import dataclass
&nbsp;
&nbsp;
@dataclass
class <strong>Square</strong>:
    size: float
&nbsp;
&nbsp;
@dataclass
class <strong>Rectangle</strong>:
    width: float
    height: float
&nbsp;
&nbsp;
@dataclass
class <strong>Circle</strong>:
    radius: float
&nbsp;
&nbsp;
Shape = Square | Rectangle
&nbsp;
&nbsp;
def <strong>area</strong>(shape: Shape) -&gt; float:
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size):
            return size**2
        case Rectangle(width, height):
            return width * height
&nbsp;
&nbsp;
square_shape = Square(size=10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(height=2, width=3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(radius=10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
</pre>

<p>Zdrojový kód si necháme zkontrolovat nástrojem <strong>pyright</strong>,
který je v&nbsp;tomto ohledu velmi striktní a přesně vypíše problém, který
nastal:</p>

<pre>
$ <strong>pyright iteration_10.py</strong>
&nbsp;
/home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_10.py
  /home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_10.py:41:20 - error: Argument of type "Circle" cannot be assigned to parameter "shape" of type "Shape" in function "area"
    Type "Circle" is not assignable to type "Shape"
      "Circle" is not assignable to "Square"
      "Circle" is not assignable to "Rectangle" (reportArgumentType)
1 error, 0 warnings, 0 informations 
</pre>

<p>V&nbsp;praxi se taktéž někdy setkáme s&nbsp;využitím funkce
<strong>assert_never</strong> z&nbsp;balíčku <strong>typing</strong>:</p>

<pre>
assert_never(arg: Never, /) -&gt; Never
    Statically assert that a line of code is unreachable.
&nbsp;
    Example::
&nbsp;
        def int_or_str(arg: int | str) -&gt; None:
            match arg:
                case int():
                    print("It's an int")
                case str():
                    print("It's a str")
                case _:
                    assert_never(arg)
&nbsp;
    If a type checker finds that a call to assert_never() is
    reachable, it will emit an error.
&nbsp;
    At runtime, this throws an exception when called.
</pre>

<p>Explicitně tak do zdrojového kódu přidáme kontrolu pro nepodporovaný datový
typ. Zápis by mohl vypadat následovně:</p>

<pre>
match shape:
    case Square(size):
        return size**2
    case Rectangle(width, height):
        return width * height
    <u>case _ as unreachable:</u>
        <u>assert_never(unreachable)</u>
</pre>

<p>Výsledek statické typové kontroly se změní, ovšem stále je patrné, která
část kódu je zapsaná nekorektně:</p>

<pre>
$ <strong>pyright iteration_11.py</strong>
&nbsp;
/home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_11.py
  /home/ptisnovs/src/most-popular-python-libs/algebraic_types/iteration_11.py:32:26 - error: Argument of type "Circle" cannot be assigned to parameter "arg" of type "Never" in function "assert_never"
    Type "Circle" is not assignable to type "Never" (reportArgumentType)
1 error, 0 warnings, 0 informations 
</pre>

<p>Opět si ukážeme celý zdrojový kód finální verze demonstračního příkladu:</p>

<pre>
from dataclasses import dataclass
from typing import assert_never
&nbsp;
&nbsp;
@dataclass
class <strong>Square</strong>:
    size: float
&nbsp;
&nbsp;
@dataclass
class <strong>Rectangle</strong>:
    width: float
    height: float
&nbsp;
&nbsp;
@dataclass
class <strong>Circle</strong>:
    radius: float
&nbsp;
&nbsp;
Shape = Square | Rectangle | Circle
&nbsp;
&nbsp;
def <strong>area</strong>(shape: Shape) -&gt; float:
    <i>"""Výpočet plochy geometrického tvaru."""</i>
    match shape:
        case Square(size):
            return size**2
        case Rectangle(width, height):
            return width * height
        case _ as unreachable:
            assert_never(unreachable)
&nbsp;
&nbsp;
square_shape = Square(size=10)
square_area = area(square_shape)
print(f"Area of square: {square_area} units")
&nbsp;
rectangle_shape = Rectangle(height=2, width=3)
rectangle_area = area(rectangle_shape)
print(f"Area of rectangle: {rectangle_area} units")
&nbsp;
circle_shape = Circle(radius=10)
circle_area = area(circle_shape)
print(f"Area of circle: {circle_area} units")
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, které jsme si dnes ukázali, jsou uloženy
v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th> #<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td> 1</td><td>dataclass_1.py</td><td>korektní konstrukce datové třídy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/dataclass_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/dataclass_1.py</a></td></tr>
<tr><td> 2</td><td>dataclass_2.py</td><td>nekorektní volání konstruktoru datové třídy s&nbsp;hodnotou špatného typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/dataclass_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/dataclass_1.py</a></td></tr>
<tr><td> 3</td><td>dataclass_3.py</td><td>nekorektní volání konstruktoru datové třídy s&nbsp;neuvedením hodnot atributů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/dataclass_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/dataclass_1.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>iteration_01.py</td><td>výpočet plochy geometrických tvarů: základní varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_01.py</a></td></tr>
<tr><td> 5</td><td>iteration_02.py</td><td>detekce hodnoty nekorektního typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_02.py</a></td></tr>
<tr><td> 6</td><td>iteration_03.py</td><td>využití strukturálního pattern matchingu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_03.py</a></td></tr>
<tr><td> 7</td><td>iteration_04.py</td><td>detekce hodnoty nekorektního typu v&nbsp;konstrukci se strukturálním pattern matchingem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_04.py</a></td></tr>
<tr><td> 8</td><td>iteration_05.py</td><td>zachycení atributů do proměnných se stejným názvem, jaký mají původní atributy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_05.py</a></td></tr>
<tr><td> 9</td><td>iteration_06.py</td><td>využití datových tříd</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_06.py</a></td></tr>
<tr><td>10</td><td>iteration_07.py</td><td>přidání typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_07.py</a></td></tr>
<tr><td>11</td><td>iteration_08.py</td><td>test, jak je detekován neúplný pattern matching</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_08.py</a></td></tr>
<tr><td>12</td><td>iteration_09.py</td><td>test, jak je detekován neúplný datový typ <strong>Shape</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_09.py</a></td></tr>
<tr><td>13</td><td>iteration_10.py</td><td>test, jak je detekován neúplný datový typ <strong>Shape</strong> i neúplný pattern matching</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_10.py</a></td></tr>
<tr><td>14</td><td>iteration_11.py</td><td>využití <strong>assert_never</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/algebraic_types/iteration_11.py</a></td></tr>
<table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Build a Simple Result type in Python - and why you should use them<br />
<a href="https://hamy.xyz/blog/2024-06_python-result-type">https://hamy.xyz/blog/2024-06_python-result-type</a>
</li>

<li>Pyright<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>mypy<br />
<a href="https://www.mypy-lang.org/">https://www.mypy-lang.org/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/</a>
</li>

<li>Python's Path to Embracing Algebraic Data Types<br />
<a href="https://www.turingtaco.com/pythons-path-to-embracing-algebraic-data-types/">https://www.turingtaco.com/pythons-path-to-embracing-algebraic-data-types/</a>
</li>

<li>Algebraic Data Types in (typed) Python<br />
<a href="https://threeofwands.com/algebraic-data-types-in-python/">https://threeofwands.com/algebraic-data-types-in-python/</a>
</li>

<li>Idiomatic algebraic data types in Python with dataclasses and Union<br />
<a href="https://blog.ezyang.com/2020/10/idiomatic-algebraic-data-types-in-python-with-dataclasses-and-union/">https://blog.ezyang.com/2020/10/idiomatic-algebraic-data-types-in-python-with-dataclasses-and-union/</a>
</li>

<li>Exhaustiveness checking util<br />
<a href="https://github.com/python/typing/issues/735">https://github.com/python/typing/issues/735</a>
</li>

<li>OCaml playground<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>Online Ocaml Compiler IDE<br />
<a href="https://www.jdoodle.com/compile-ocaml-online/">https://www.jdoodle.com/compile-ocaml-online/</a>
</li>

<li>Get Started - OCaml<br />
<a href="https://www.ocaml.org/docs">https://www.ocaml.org/docs</a>
</li>

<li>Get Up and Running With OCaml<br />
<a href="https://www.ocaml.org/docs/up-and-running">https://www.ocaml.org/docs/up-and-running</a>
</li>

<li>Better OCaml (Online prostředí)<br />
<a href="https://betterocaml.ml/?version=4.14.0">https://betterocaml.ml/?version=4.14.0</a>
</li>

<li>OCaml file extensions<br />
<a href="https://blog.waleedkhan.name/ocaml-file-extensions/">https://blog.waleedkhan.name/ocaml-file-extensions/</a>
</li>

<li>First thoughts on Rust vs OCaml<br />
<a href="https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/">https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/</a>
</li>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

<li>F# - .NET Blog<br />
<a href="https://devblogs.microsoft.com/dotnet/category/fsharp/">https://devblogs.microsoft.com/dotnet/category/fsharp/</a>
</li>

<li>Playground: OCaml<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>The F# Survival Guide<br />
<a href="https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx">https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx</a>
</li>

<li>Python to OCaml: Retrospective<br />
<a href="http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/">http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/</a>
</li>

<li>Why Programmers Need Limits<br />
<a href="https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db">https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db</a>
</li>

<li>Signatures<br />
<a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/signature-files">https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/signature-files</a>
</li>

<li>F# for Linux People<br />
<a href="https://carpenoctem.dev/blog/fsharp-for-linux-people/">https://carpenoctem.dev/blog/fsharp-for-linux-people/</a>
</li>

<li>Infographic showing code complexity vs developer experience<br />
<a href="https://twitter.com/rossipedia/status/1580639227313676288">https://twitter.com/rossipedia/status/1580639227313676288</a>
</li>

<li>OCaml for the Masses: Why the next language you learn should be functional<br />
<a href="https://queue.acm.org/detail.cfm?id=2038036">https://queue.acm.org/detail.cfm?id=2038036</a>
</li>

<li>Try EIO<br />
<a href="https://patricoferris.github.io/try-eio/">https://patricoferris.github.io/try-eio/</a>
</li>

<li>Try OCaml<br />
<a href="https://try.ocaml.pro/">https://try.ocaml.pro/</a>
</li>

<li>ML &ndash; funkcionální jazyk s revolučním typovým systémem<br />
<a href="https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/">https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/</a>
</li>

<li>Funkce a typový systém programovacího jazyka ML<br />
<a href="https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/">https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/</a>
</li>

<li>Curryfikace (currying), výjimky a vlastní operátory v jazyku ML<br />
<a href="https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/">https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/</a>
</li>

<li>Operátor J (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/J_operator">https://en.wikipedia.org/wiki/J_operator</a>
</li>

<li>Standard ML (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Standard_ML">https://en.wikipedia.org/wiki/Standard_ML</a>
</li>

<li>Xavier Leroy<br />
<a href="https://en.wikipedia.org/wiki/Xavier_Leroy">https://en.wikipedia.org/wiki/Xavier_Leroy</a>
</li>

<li>Unit type<br />
<a href="https://en.wikipedia.org/wiki/Unit_type">https://en.wikipedia.org/wiki/Unit_type</a>
</li>

<li>The Option type<br />
<a href="https://fsharpforfunandprofit.com/posts/the-option-type/">https://fsharpforfunandprofit.com/posts/the-option-type/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

