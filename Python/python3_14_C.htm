<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Nové vlastnosti Pythonu 3.14 v praxi: komunikace mezi interpretry</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Nové vlastnosti Pythonu 3.14 v praxi: komunikace mezi interpretry</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: komunikace mezi interpretry</a></p>
<p><a href="#k02">2. Komunikace mezi interpretry s&nbsp;využitím fronty</a></p>
<p><a href="#k03">3. Demonstrační příklad: poslání zprávy mezi úlohami, které běží v&nbsp;různých interpretrech</a></p>
<p><a href="#k04">4. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k05">5. Realizace programu pro zpracování úloh v&nbsp;samostatně běžících interpretrech</a></p>
<p><a href="#k06">6. Ukázka chování programu s&nbsp;více úlohami po jeho spuštění</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">9. Porovnání realizace <i>workerů</i> založené na interpretrech s&nbsp;realizací založenou na multiprocesingu</a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: komunikace mezi interpretry</h2>

<p>Na úvodní dvojici článků o nových vlastnostech <a
href="https://test.python.org/downloads/release/python-3140/">Pythonu 3.14</a>
[<a
href="https://www.root.cz/clanky/python-3-14-t-retezce-barvicky-lepsi-napoveda-a-odchazejici-gil/">1</a>]
[<a
href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">2</a>]
dnes navážeme. Minule jsme si řekli, že v&nbsp;Pythonu 3.14 je možné programově
vytvořit větší množství interpretrů a spouštět v&nbsp;nich úlohy, které jsou do
značné míry izolovány od úloh, které jsou spouštěny v&nbsp;jiných interpretrech
(i když se tato technologie odlišuje od klasického multiprocesingu). A nejen to
&ndash; úlohy v&nbsp;interpretrech mohou běžet (a většinou i běží)
v&nbsp;samostatných vláknech, takže lze dosáhnout souběžného a mnohdy i
paralelního běhu výpočtů.</p>

<p>Ovšem současně je nutné nějakým způsobem zajistit komunikaci mezi úlohami,
které jsou od sebe tímto způsobem odizolovány. Dnes si ukážeme, jakým způsobem
se to provádí. Navíc použitou technologii porovnáme s&nbsp;realizací komunikace
mezi asynchronně spouštěnými úlohami, vlákny a procesy (což jsou taktéž
technologie zajišťující souběžné provádění úloh, ovšem na odlišných
úrovních).</p>

<p><div class="rs-tip-major">Poznámka: všechny dále ukázané demonstrační
příklady poběží na nejnovější verzi Pythonu 3.14, přičemž tato varianta může
mít zakázaný i povolený GIL (ve výpisu se hlásí varianta Pythonu bez
GILu):</div></p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.14.0 free-threading build (main, Oct 18 2025, 10:08:58) [GCC 14.2.1 20240912 (Red Hat 14.2.1-3)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Komunikace mezi interpretry s&nbsp;využitím fronty</h2>

<p><a
href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">V&nbsp;předchozím
článku</a> jsme si ověřili, že pokud je nějaká úloha (kód ve zdrojové podobě
nebo funkce) spuštěna v&nbsp;kontextu nového interpretru, nemá přístup
k&nbsp;proměnným ostatních interpretrů. To je pochopitelně korektní a očekávané
chování protože tato úloha má běžet izolovaně od ostatních úloh. Ovšem mnohdy
je nutné zajistit předávání dat mezi jednotlivými (od sebe izolovanými)
úlohami. Pro tento účel se používají fronty, což není v&nbsp;ekosystému jazyka
Python překvapující, protože pro stejné účely se fronty používají i
v&nbsp;kontextu asynchronních úloh, úloh běžících ve vláknech nebo i při
spuštění úloh v&nbsp;samostatných procesech.</p>

<p>Nyní tedy víme, že pro komunikaci mezi interpretry (resp.&nbsp;mezi úlohami,
které v&nbsp;nich běží) slouží fronty. Jak se taková fronta vytvoří?
K&nbsp;tomuto účelu slouží funkce nazvaná <strong>create_queue</strong>
z&nbsp;balíčku <strong>concurrent.interpreters</strong> (jinou formu fronty
nepoužívejte):</p>

<pre>
create(maxsize=0, *, unbounditems=concurrent.interpreters._queues.UNBOUND)
    Return a new cross-interpreter queue.
&nbsp;
    The queue may be used to pass data safely between interpreters.
&nbsp;
    "unbounditems" sets the default for Queue.put(); see that method for
    supported values.  The default value is UNBOUND, which replaces
    the unbound item.
</pre>

<p>Příklad vytvoření fronty:</p>

<pre>
from concurrent import interpreters
&nbsp;
q = interpreters.create_queue()
...
...
...
</pre>

<p>Vytvořená fronta programátorům nabízí několik metod, které postupně
použijeme v&nbsp;dalším textu:</p>

<table>
<tr><th>#</th><th>Metoda</th></tr>
<tr><td>1</td><td>empty</td></tr>
<tr><td>2</td><td>full</td></tr>
<tr><td>3</td><td>get</td></tr>
<tr><td>4</td><td>get_nowait</td></tr>
<tr><td>5</td><td>put</td></tr>
<tr><td>6</td><td>put_nowait</td></tr>
<tr><td>7</td><td>qsize</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: tímto způsobem vytvořenou frontu je
možné předat no funkce, která bude spuštěna v&nbsp;jiném interpretru. Příkladem
je zavolání funkce <strong>run</strong> v&nbsp;novém interpretru, přičemž
jediným předávaným parametrem bude právě objekt typu
<strong>concurrent.interpreters._queues.Queue</strong>:</div></p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
q = interpreters.create_queue()
&nbsp;
interp.call_in_thread(run, q)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstrační příklad: poslání zprávy mezi úlohami, které běží v&nbsp;různých interpretrech</h2>

<p>Podívejme se nyní na způsob praktické realizace posílání zpráv mezi dvěma
úlohami, z&nbsp;nichž každá běží ve vlastním interpretru (navíc v&nbsp;různých
vláknech). Nejdříve zkonstruujeme nový interpretr (ten zatím neběží) a následně
frontu použitou pro komunikaci mezi úlohami:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
q = interpreters.create_queue()
</pre>

<p>Dále nadefinujeme funkci, která bude později spuštěna v&nbsp;novém
interpretru. Povšimněte si, že této funkci bude předán parametr
<strong>q</strong>, který by měl být typu <strong>Queue</strong> (těchto typů
existuje v&nbsp;základní knihovně Pythonu několik, ovšem jejich základní
vlastnosti jsou shodné). Funkce bude čekat na zprávu, kterou někdo jiný (kód
běžící v&nbsp;odlišném vláknu) pošle do fronty. Jakmile takovou zprávu dostane,
vypíše její obsah a funkce se následně ukončí:</p>

<pre>
def <strong>run</strong>(q):
    print("Hello from new interpreter, waiting for message")
    message = q.get()
    print(f"Message received: '{message}'")
</pre>

<p>Nyní již postačuje spustit tuto funkci v&nbsp;novém interpretru (navíc
v&nbsp;novém vláknu) a předat jí referenci na frontu:</p>

<pre>
print("Executing run()")
t = interp.call_in_thread(run, q)
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>t</strong> je typu
<strong>threading.Thread</strong>.</div></p>

<p>Pošleme zprávu do fronty; převezme si ji úloha běžící v&nbsp;jiném
interpretru/vláknu:</p>

<pre>
print("Sending message into queue")
q.put("foo")
print("Message sent")
</pre>

<p>Nyní již pouze počkáme na dokončení úlohy:</p>

<pre>
print("Waiting for other interpreter to finish")
t.join()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód příkladu, který byl popsán <a
href="#k03">v&nbsp;předchozí kapitole</a>, vypadá následovně:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
&nbsp;
def <strong>run</strong>(q):
    print("Hello from new interpreter, waiting for message")
    message = q.get()
    print(f"Message received: '{message}'")
&nbsp;
&nbsp;
q = interpreters.create_queue()
&nbsp;
print("Executing run()")
t = interp.call_in_thread(run, q)
&nbsp;
print("Sending message into queue")
q.put("foo")
print("Message sent")
&nbsp;
print("Waiting for other interpreter to finish")
t.join()
&nbsp;
print("Done")
</pre>

<p>Příklad chování programu po spuštění:</p>

<pre>
Executing run()
Sending message into queue
Message sent
Waiting for other interpreter to finish
Hello from new interpreter, waiting for message
Message received: 'foo'
Done
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Realizace programu pro zpracování úloh v&nbsp;samostatně běžících interpretrech</h2>

<p>Původní program popsaný v&nbsp;předchozích dvou kapitolách nyní upravíme do
nepatrně složitější podoby. V&nbsp;první řadě budeme v&nbsp;programu definovat
funkci nazvanou <strong>worker</strong>. Ta poběží (klidně i několikrát)
v&nbsp;různých interpretrech/vláknech a bude přes frontu přijímat úlohy.
Vytiskne parametry úlohy a samotnou práci bude simulovat funkcí
<strong>time.sleep</strong> :-). Pokud ovšem bude úloha obsahovat text
<strong>quit</strong>, bude funkce <strong>worker</strong> ihned ukončena:</p>

<pre>
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných interpretrech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Process '{name}' is about to quit")
            return
        time.sleep(1)
</pre>

<p>Funkce <strong>worker</strong> bude spuštěna několikrát, abychom si ukázali
možnosti škálování úloh:</p>

<pre>
    q = interpreters.create_queue()
&nbsp;
    <i># vytvoření tří procesů</i>
    names = ("foo", "bar", "baz")
    ins = [interpreters.create().call_in_thread(worker, name, q) for name in names]
</pre>

<p>Povšimněte si, že všem třem workerům je předáno sice odlišné jméno, ale ve
druhém parametru získají referenci na instanci stejné fronty. To nám umožní
předávat wokerkům úlohy, o které se budou dělit (podle toho, který worker je
zrovna dostupný):</p>

<pre>
    print("Sending data to other interpreters")
&nbsp;
    <i># komunikace s interpretry přes frontu</i>
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
</pre>

<p>Na konci požádáme workery o jejich ukončení a počkáme, až všechna vlákna, ve
kterých běží interpretry, skutečně skončí:</p>

<pre>
    <i># příkaz pro ukončení procesů</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other interpreters")
&nbsp;
    <i># čekání na ukončení interpretrů</i>
    for i in ins:
        i.join()
&nbsp;
    print("All work done!")
</pre>

<p>Úplný zdrojový kód takto upraveného demonstračního příkladu vypadá
následovně:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových interpretrech</i>
<i># - komunikace mezi interpretry s využitím fronty</i>
&nbsp;
import time
from concurrent import interpreters
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných interpretrech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Process '{name}' is about to quit")
            return
        time.sleep(1)
&nbsp;
&nbsp;
if __name__ == "__main__":
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi interpretry</i>
    q = interpreters.create_queue()
&nbsp;
    <i># vytvoření tří procesů</i>
    names = ("foo", "bar", "baz")
    ins = [interpreters.create().call_in_thread(worker, name, q) for name in names]
&nbsp;
    print("Sending data to other interpreters")
&nbsp;
    <i># komunikace s interpretry přes frontu</i>
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    print("Asking other interpreters to finish")
&nbsp;
    <i># příkaz pro ukončení procesů</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other interpreters")
&nbsp;
    <i># čekání na ukončení interpretrů</i>
    for i in ins:
        i.join()
&nbsp;
    print("All work done!")
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ukázka chování programu s&nbsp;více úlohami po jeho spuštění</h2>

<p>Po spuštění programu můžeme snadno zjistit, že se workeři skutečně o předané
úlohy dělili:</p>

<pre>
Process 'foo' received command 'command 0'
Process 'foo' received command 'command 3'
Process 'foo' received command 'command 6'
Process 'foo' received command 'command 9'
Process 'foo' received command 'quit'
Process 'foo' is about to quit
Process 'baz' received command 'command 2'
Process 'baz' received command 'command 5'
Process 'baz' received command 'command 8'
Process 'baz' received command 'quit'
Process 'baz' is about to quit
Process 'bar' received command 'command 1'
Process 'bar' received command 'command 4'
Process 'bar' received command 'command 7'
Process 'bar' received command 'quit'
Process 'bar' is about to quit
Starting
Sending data to other interpreters
Sending 'command 0'
Sending 'command 1'
Sending 'command 2'
Sending 'command 3'
Sending 'command 4'
Sending 'command 5'
Sending 'command 6'
Sending 'command 7'
Sending 'command 8'
Sending 'command 9'
Asking other interpreters to finish
Waiting for other interpreters
All work done!
</pre>

<p>Doba běhu programu je menší než 10 sekund:</p>

<pre>
real    0m4.171s
user    0m0.199s
sys     0m0.040s
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Technologie realizace souběžně prováděných operací v&nbsp;Pythonu</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
# Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh v nových procesech
# - komunikace mezi procesy s využitím fronty


import time
from multiprocessing import Process, Queue, freeze_support


def worker(name, q):
    """Worker spuštěný několikrát v samostatných procesech."""
    while True:
        # čtení příkazů z fronty
        cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Process '{name}' is about to quit")
            return
        time.sleep(1)


if __name__ == "__main__":
    print("Starting")
    freeze_support()

    # vytvoření fronty pro komunikaci mezi procesy
    q = Queue()

    # vytvoření tří procesů
    names = ("foo", "bar", "baz")
    ps = [Process(target=worker, args=(name, q)) for name in names]

    # spuštění tří procesů
    for p in ps:
        p.start()

    print("Sending data to other processes")

    # komunikace s procesy přes frontu
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))

    print("Asking other processes to finish")

    # příkaz pro ukončení procesů
    for i in range(3):
        q.put("quit")

    print("Waiting for other processes")

    # čekání na ukončení procesů
    for p in ps:
        p.join()

    print("All work done!")
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Porovnání realizace <i>workerů</i> založené na interpretrech s&nbsp;realizací založenou na multiprocesingu</h2>

<p>I když je realizace workerů založená na interpretrech interně značně odlišná
od realizace založené na multiprocesingu, jsou zdrojové kódy obou realizací
velmi podobné. Ostatně postačuje se podívat na porovnání obou zdrojových kódů
řádek po řádku:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:                    # Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových interpretrech                   # - spuštění více úloh v nových procesech</i>
<i># - komunikace mezi interpretry s využitím fronty               # - komunikace mezi procesy s využitím fronty</i>
&nbsp;                                                          
import time                                                     import time
from concurrent import interpreters                             from multiprocessing import Process, Queue, freeze_support
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):                                            def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných interpretrech      """Worker spuštěný několikrát v samostatných procesech.""</i>
    while True:                                                     while True:
        <i># čtení příkazů z fronty                                        # čtení příkazů z fronty</i>
        cmd = q.get()                                                   cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")             print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":                                               if cmd == "quit":
            print(f"Process '{name}' is about to quit")                     print(f"Process '{name}' is about to quit")
            return                                                          return
        time.sleep(1)                                                   time.sleep(1)
&nbsp;
&nbsp;
if __name__ == "__main__":                                      if __name__ == "__main__":
    print("Starting")                                               print("Starting")
                                                                    freeze_support()
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi interpretry              # vytvoření fronty pro komunikaci mezi procesy</i>
    q = interpreters.create_queue()                                 q = Queue()
&nbsp;
    <i># vytvoření tří procesů                                        # vytvoření tří procesů</i>
    names = ("foo", "bar", "baz")                                   names = ("foo", "bar", "baz")
    ins = [interpreters.create().call_in_thread(worker, name,       ps = [Process(target=worker, args=(name, q)) for name in 
&nbsp;
                                                                    <i># spuštění tří procesů</i>
                                                                    for p in ps:
                                                                        p.start()
&nbsp;
    print("Sending data to other interpreters")                     print("Sending data to other processes")
&nbsp;
    <i># komunikace s interpretry přes frontu                          # komunikace s procesy přes frontu</i>
    for i in range(10):                                             for i in range(10):
        print(f"Sending 'command {i}'")                                 print(f"Sending 'command {i}'")
        q.put("command {}".format(i))                                   q.put("command {}".format(i))
&nbsp;
    print("Asking other interpreters to finish")                    print("Asking other processes to finish")
&nbsp;
    <i># příkaz pro ukončení procesů                                   # příkaz pro ukončení procesů</i>
    for i in range(3):                                              for i in range(3):
        q.put("quit")                                                   q.put("quit")
&nbsp;
    print("Waiting for other interpreters")                         print("Waiting for other processes")
&nbsp;
    <i># čekání na ukončení interpretrů                                # čekání na ukončení procesů</i>
    for i in ins:                                                   for p in ps:
        i.join()                                                        p.join()
&nbsp;
    print("All work done!")                                         print("All work done!")
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
# Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh v nových vláknech
# - komunikace mezi vlákny s využitím fronty


from queue import Queue
from threading import Thread
import time


def worker(name, q):
    """Worker spuštěný několikrát v samostatných vláknech."""
    while True:
        # čtení příkazů z fronty
        cmd = q.get()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            return
        time.sleep(1)


if __name__ == "__main__":
    print("Starting")

    # vytvoření fronty pro komunikaci mezi vlákny
    q = Queue()

    # spuštění tří vláken
    names = ("foo", "bar", "baz")
    ts = [Thread(target=worker, daemon=True, name=name, args=[name, q]) for name in names]

    # spuštění tří vláken
    for t in ts:
        t.start()

    print("Sending data to other threads")

    # komunikace s vlákny přes frontu
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))

    print("Asking other threads to finish")

    # příkaz pro ukončení vláken
    for i in range(3):
        q.put("quit")

    print("Waiting for other threads")

    # čekání na zpracování všech zpráv ve frontě
    for t in ts:
        t.join()

    print("All work done!")
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
# Multiprocesing a multithreading v Pythonu:                   # Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh v nových interpretrech                  # - spuštění více úloh v nových vláknech
# - komunikace mezi interpretry s využitím fronty              # - komunikace mezi vlákny s využitím fronty


                                                               from queue import Queue
                                                               from threading import Thread
import time                                                    import time
from concurrent import interpreters                           


def worker(name, q):                                           def worker(name, q):
    """Worker spuštěný několikrát v samostatných interpretrec      """Worker spuštěný několikrát v samostatných vláknech."""
    while True:                                                    while True:
        # čtení příkazů z fronty                                       # čtení příkazů z fronty
        cmd = q.get()                                                  cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")            print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":                                              if cmd == "quit":
            print(f"Process '{name}' is about to quit")                    print(f"Thread '{name}' is about to quit")
            return                                                         return
        time.sleep(1)                                                  time.sleep(1)


if __name__ == "__main__":                                     if __name__ == "__main__":
    print("Starting")                                              print("Starting")

    # vytvoření fronty pro komunikaci mezi interpretry             # vytvoření fronty pro komunikaci mezi vlákny
    q = interpreters.create_queue()                                q = Queue()

    # vytvoření tří procesů                                        # spuštění tří vláken
    names = ("foo", "bar", "baz")                                  names = ("foo", "bar", "baz")
    ins = [interpreters.create().call_in_thread(worker, name,      ts = [Thread(target=worker, daemon=True, name=name, args=

                                                                   # spuštění tří vláken
                                                                   for t in ts:
                                                                       t.start()

    print("Sending data to other interpreters")                    print("Sending data to other threads")

    # komunikace s interpretry přes frontu                         # komunikace s vlákny přes frontu
    for i in range(10):                                            for i in range(10):
        print(f"Sending 'command {i}'")                                print(f"Sending 'command {i}'")
        q.put("command {}".format(i))                                  q.put("command {}".format(i))

    print("Asking other interpreters to finish")                   print("Asking other threads to finish")

    # příkaz pro ukončení procesů                                  # příkaz pro ukončení vláken
    for i in range(3):                                             for i in range(3):
        q.put("quit")                                                  q.put("quit")

    print("Waiting for other interpreters")                        print("Waiting for other threads")

    # čekání na ukončení interpretrů                               # čekání na zpracování všech zpráv ve frontě
    for i in ins:                                                  for t in ts:
        i.join()                                                       t.join()

    print("All work done!")                                        print("All work done!")
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
# Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh v nových vláknech
# - komunikace mezi vlákny s využitím fronty


from queue import Queue
from threading import Thread
import time


def worker(name, q):
    """Worker spuštěný několikrát v samostatných vláknech."""
    while True:
        # čtení příkazů z fronty
        cmd = q.get()
        q.task_done()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            return
        time.sleep(1)


if __name__ == "__main__":
    print("Starting")

    # vytvoření fronty pro komunikaci mezi vlákny
    q = Queue()

    # spuštění tří vláken
    names = ("foo", "bar", "baz")
    ts = [Thread(target=worker, daemon=True, name=name, args=[name, q]) for name in names]

    # spuštění tří vláken
    for t in ts:
        t.start()

    print("Sending data to other threads")

    # komunikace s vlákny přes frontu
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))

    print("Asking other threads to finish")

    # příkaz pro ukončení vláken
    for i in range(3):
        q.put("quit")

    print("Waiting for other threads")

    # čekání na zpracování všech zpráv ve frontě
    q.join()

    print("All work done!")
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
# Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh v nových vláknech
# - komunikace mezi vlákny s využitím fronty


from queue import Queue
from threading import Thread
import time


def worker(name, q):
    """Worker spuštěný několikrát v samostatných vláknech."""
    while True:
        # čtení příkazů z fronty
        cmd = q.get()
        q.task_done()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            return
        time.sleep(1)


def producer(name, q):
    for job in range(10):
        print(f"{name} thread: Starting producing {job}")
        q.put(job)
        time.sleep(0.3)
        print(f"{name} thread: Produced {job}")


if __name__ == "__main__":
    print("Starting")

    # vytvoření fronty pro komunikaci mezi vlákny
    q = Queue()

    # spuštění čtyř producentů
    names = ("1st", "2nd", "3rd", "4th")
    ps = [Thread(target=producer, daemon=True, name=name, args=[name, q]) for name in names]

    # spuštění producentů
    for p in ps:
        p.start()

    # spuštění tří vláken
    names = ("foo", "bar", "baz")
    ts = [Thread(target=worker, daemon=True, name=name, args=[name, q]) for name in names]

    # spuštění tří vláken
    for t in ts:
        t.start()

    print("Asking other threads to finish")

    # čekání na dokončení producentů
    for p in ps:
        p.join()

    # příkaz pro ukončení vláken
    for i in range(3):
        q.put("quit")

    print("Waiting for other threads")

    # čekání na zpracování všech zpráv ve frontě
    q.join()

    print("All work done!")
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
# Multiprocesing a multithreading v Pythonu:
# - spuštění více úloh asynchronně
# - komunikace mezi procesy s využitím fronty

from asyncio import Queue, sleep, run, gather, create_task


async def worker(name, q):
    """Worker spuštěný několikrát asynchronně."""
    while not q.empty():
        # čtení příkazů z fronty
        cmd = await q.get()
        print(f"Task '{name}' received command '{cmd}'")
        await sleep(1)


async def main():
    print("Starting")

    # vytvoření fronty pro komunikaci mezi úlohami
    queue = Queue()

    print("Sending data to async tasks")

    # komunikace s úlohami přes frontu
    for i in range(10):
        print(f"Sending 'command {i}'")
        await queue.put("command {}".format(i))

    print("Waiting for all tasks")

    await gather(
        create_task(worker("foo", queue)),
        create_task(worker("bar", queue)),
        create_task(worker("baz", queue)),
    )

    print("All work done!")


run(main())
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</h2>

<p>Na stránkách <a href="https://www.root.cz">Roota</a> jsme se již několikrát setkali s&nbsp;problematikou souběžnosti, paralelnosti a asynchronního běhu v&nbsp;Pythonu. Různé varianty spouštění a řízení více vláken, procesů a asynchronních úloh naleznete v&nbsp;následujících článcích (všechny v&nbsp;článcích uvedené demonstrační příklady by měly být spustitelné i v&nbsp;interpretru Pythonu 3.14 bez GILu):</p>

<ol>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – Curio a Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – závěrečné zhodnocení<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/</a>
</li>

<li>Interpret Pythonu bez GILu: vyplatí se odstranění velkého zámku?<br />
<a href="https://www.root.cz/clanky/interpret-pythonu-bez-gilu-vyplati-se-odstraneni-velkeho-zamku/">https://www.root.cz/clanky/interpret-pythonu-bez-gilu-vyplati-se-odstraneni-velkeho-zamku/</a>
</li>

<li>Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: vliv odstranění GIL a využití více interpretrů<br />
<a href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, které byly popsány v&nbsp;dnešním článku,
naleznete na adresách:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td>1</td><td>interpreters/queue-interpreters-1.py</td><td>poslání zprávy mezi úlohami, které běží v&nbsp;různých interpretrech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-1.py</a></td></tr>
<tr><td>2</td><td>interpreters/queue-interpreters-2.py</td><td>realizace programu pro zpracování úloh v&nbsp;samostatně běžících interpretrech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-2.py</a></td></tr>
<tr><td>3</td><td>interpreters/queue-async.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-async.py</a></td></tr>
<tr><td>4</td><td>interpreters/queue-multiprocessing.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multiprocessing.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multiprocessing.py</a></td></tr>
<tr><td>5</td><td>interpreters/queue-multithreading-1.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-1.py</a></td></tr>
<tr><td>6</td><td>interpreters/queue-multithreading-2.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-2.py</a></td></tr>
<tr><td>7</td><td>interpreters/queue-multithreading-3.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-3.py</a></td></tr>
</table>

<p>Všechny <a
href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">minule</a>
popsané demonstrační příklady jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td> 1</td><td>bubble-sort/bubble_sort_seq.py</td><td>benchmark provádějící sekvenční volání algoritmu pro bublinkové řazení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_seq.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_seq.py</a></td></tr>
<tr><td> 2</td><td>bubble-sort/bubble_sort_parallel.py</td><td>benchmark provádějící souběžné volání algoritmu pro bublinkové řazení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_parallel.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_parallel.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>julia-renderer/julia_seq_anim.py</td><td>sekvenční výpočet animace Juliových množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_seq_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_seq_anim.py</a></td></tr>
<tr><td> 4</td><td>julia-renderer/julia_parallel_anim.py</td><td>souběžný popř.&nbsp;paralelní výpočet animace Juliových množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_parallel_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_parallel_anim.py</a></td></tr>
<tr><td> 5</td><td>julia-renderer/palette_mandmap.py</td><td>pomocný soubor s&nbsp;barvovou mapou použitý dvěma předchozími benchmarky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/palette_mandmap.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>interpreters/list-interpreters.py</td><td>výpis seznamu inicializovaných interpretrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/list-interpreters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/list-interpreters.py</a></td></tr>
<tr><td> 7</td><td>interpreters/new-interpreter.py</td><td>konstrukce nového interpretru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/new-interpreter.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/new-interpreter.py</a></td></tr>
<tr><td> 8</td><td>interpreters/exec.py</td><td>zavolání funkce ve zvoleném interpretru (ve stejném vlákně)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/exec.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/exec.py</a></td></tr>
<tr><td> 9</td><td>interpreters/call_in_thread.py</td><td>zavolání funkce ve zvoleném interpretru (v&nbsp;novém vlákně)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/call_in_thread.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/call_in_thread.py</a></td></tr>
<tr><td>10</td><td>interpreters/shared-variables.py</td><td>jsou proměnné sdíleny mezi interpretry?</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/shared-variables.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/shared-variables.py</a></td></tr>
<tr><td>11</td><td>interpreters/behaviour_exec.py</td><td>chování dvou interpretrů v&nbsp;čase běhu (metoda <strong>exec</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_exec.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_exec.py</a></td></tr>
<tr><td>12</td><td>interpreters/behaviour_call_in_thread.py</td><td>chování dvou interpretrů v&nbsp;čase běhu (metoda <strong>call_in_thread</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_call_in_thread.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_call_in_thread.py</a></td></tr>
<tr><td>13</td><td>interpreters/interpreter_exception_1.py </td><td>chování interpretrů při vyhození nezachycené výjimky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_1.py</a></td></tr>
<tr><td>14</td><td>interpreters/interpreter_exception_2.py </td><td>chování interpretrů při vyhození nezachycené výjimky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_2.py</a></td></tr>
</table>

<p>Demonstrační příklady vytvořené pro Python verze 3.14 a popsané
v&nbsp;prvním článku najdete v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs/">https://github.com/tisnik/most-popular-python-libs/</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>argparse_test.py</td><td>skript s&nbsp;definicí přepínačů použitelných na příkazovém řádku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/argparse_test.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/argparse_test.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>syntax_error_1.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_1.py</a></td></tr>
<tr><td> 2</td><td>syntax_error_2.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_2.py</a></td></tr>
<tr><td> 3</td><td>syntax_error_3.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_3.py</a></td></tr>
<tr><td> 4</td><td>syntax_error_4.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_4.py</a></td></tr>
<tr><td> 5</td><td>syntax_error_5.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>primes.py</td><td>realizace výpočtu prvočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/primes.py</a></td></tr>
<tr><td> 7</td><td>test_primes.py</td><td>jednotkové testy pro modul <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/test_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/test_primes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>pep-758-motivation-1.py</td><td>zachycení většího množství výjimek v&nbsp;bloku <strong>except</strong> &ndash; motivační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-1.py</a></td></tr>
<tr><td> 9</td><td>pep-758-motivation-2.py</td><td>zachycení většího množství výjimek v&nbsp;bloku <strong>except</strong> &ndash; motivační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-2.py</a></td></tr>
<tr><td>10</td><td>pep-758-usage.py</td><td>nový způsob zachycení výjimek definovaný v&nbsp;PEP-758</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage.py</a></td></tr>
<tr><td>11</td><td>pep-758-usage-as.py</td><td>klauzule <strong>as</strong> a nový způsob zachycení výjimek definovaný v&nbsp;PEP-758</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage-as.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage-as.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>pep-765-motivation-1.py</td><td>detekce opuštění bloku <strong>finally</strong>, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-1.py</a></td></tr>
<tr><td>13</td><td>pep-765-motivation-2.py</td><td>detekce opuštění bloku <strong>finally</strong>, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-2.py</a></td></tr>
<tr><td>14</td><td>pep-765-motivation-3.py</td><td>detekce opuštění bloku <strong>finally</strong>, třetí demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-3.py</a></td></tr>
<tr><td>15</td><td>pep-765-motivation-4.py</td><td>detekce opuštění bloku <strong>finally</strong>, čtvrtý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>f-string-1.py</td><td>rozdíl mezi f-řetězci a t-řetězci, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-1.py</a></td></tr>
<tr><td>17</td><td>t-string-1.py</td><td>rozdíl mezi f-řetězci a t-řetězci, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-1.py</a></td></tr>
<tr><td>18</td><td>f-string-2.py</td><td>rozdíl mezi f-řetězci a t-řetězci, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-2.py</a></td></tr>
<tr><td>19</td><td>t-string-2.py</td><td>rozdíl mezi f-řetězci a t-řetězci, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python 3.14.0<br />
<a href="https://test.python.org/downloads/release/python-3140/">https://test.python.org/downloads/release/python-3140/</a>
</li>

<li>PEP 765 – Disallow return/break/continue that exit a finally block<br />
<a href="https://peps.python.org/pep-0765/">https://peps.python.org/pep-0765/</a>
</li>

<li>PEP 758 – Allow except and except* expressions without parentheses<br />
<a href="https://peps.python.org/pep-0758/">https://peps.python.org/pep-0758/</a>
</li>

<li>What’s new in Python 3.14 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.14.html">https://docs.python.org/3/whatsnew/3.14.html</a>
</li>

<li>What’s New In Python 3.13 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.13.html">https://docs.python.org/3/whatsnew/3.13.html</a>
</li>

<li>What’s New In Python 3.12 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.12.html">https://docs.python.org/3/whatsnew/3.12.html</a>
</li>

<li>What’s New In Python 3.11 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.11.html">https://docs.python.org/3/whatsnew/3.11.html</a>
</li>

<li>What’s New In Python 3.12<br />
<a href="https://dev.to/mahiuddindev/python-312-4n43">https://dev.to/mahiuddindev/python-312-4n43</a></li>

<li>PEP 698 – Override Decorator for Static Typing<br />
<a href="https://peps.python.org/pep-0698/">https://peps.python.org/pep-0698/</a>
</li>

<li>PEP 484 -- Type Hints<br />
<a href="https://www.python.org/dev/peps/pep-0484/">https://www.python.org/dev/peps/pep-0484/</a>
</li>

<li>What’s New In Python 3.5<br />
<a href="https://docs.python.org/3.5/whatsnew/3.5.html">https://docs.python.org/3.5/whatsnew/3.5.html</a>
</li>

<li>26.1. typing — Support for type hints<br />
<a href="https://docs.python.org/3.5/library/typing.html#module-typing">https://docs.python.org/3.5/library/typing.html#module-typing</a>
</li>

<li>Type Hints - Guido van Rossum - PyCon 2015 (youtube)<br />
<a href="https://www.youtube.com/watch?v=2wDvzy6Hgxg">https://www.youtube.com/watch?v=2wDvzy6Hgxg</a>
</li>

<li>Python 3.5 is on its way<br />
<a href="https://lwn.net/Articles/650904/">https://lwn.net/Articles/650904/</a>
</li>

<li>Type hints<br />
<a href="https://lwn.net/Articles/640359/">https://lwn.net/Articles/640359/</a>
</li>

<li>Stránka projektu PDM<br />
<a href="https://pdm.fming.dev/latest/">https://pdm.fming.dev/latest/</a>
</li>

<li>PDF na GitHubu<br />
<a href="https://github.com/pdm-project/pdm">https://github.com/pdm-project/pdm</a>
</li>

<li>PEP 582 &ndash; Python local packages directory<br />
<a href="https://peps.python.org/pep-0582/">https://peps.python.org/pep-0582/</a>
</li>

<li>PDM na PyPi<br />
<a href="https://pypi.org/project/pdm/">https://pypi.org/project/pdm/</a>
</li>

<li>Which Python package manager should you use?<br />
<a href="https://towardsdatascience.com/which-python-package-manager-should-you-use-d0fd0789a250">https://towardsdatascience.com/which-python-package-manager-should-you-use-d0fd0789a250</a>
</li>

<li>How to Use PDM to Manage Python Dependencies without a Virtual Environment<br />
<a href="https://www.youtube.com/watch?v=qOIWNSTYfcc">https://www.youtube.com/watch?v=qOIWNSTYfcc</a>
</li>

<li>What are the best Python package managers?<br />
<a href="https://www.slant.co/topics/2666/~best-python-package-managers">https://www.slant.co/topics/2666/~best-python-package-managers</a>
</li>

<li>PEP 621 &ndash; Storing project metadata in pyproject.toml<br />
<a href="https://peps.python.org/pep-0621/">https://peps.python.org/pep-0621/</a>
</li>

<li>Pick a Python Lockfile and Improve Security<br />
<a href="https://blog.phylum.io/pick-a-python-lockfile-and-improve-security/">https://blog.phylum.io/pick-a-python-lockfile-and-improve-security/</a>
</li>

<li>PyPA specifications<br />
<a href="https://packaging.python.org/en/latest/specifications/">https://packaging.python.org/en/latest/specifications/</a>
</li>

<li>Creation of virtual environments<br />
<a href="https://docs.python.org/3/library/venv.html">https://docs.python.org/3/library/venv.html</a>
</a>

<li>How to Use virtualenv in Python<br />
<a href="https://learnpython.com/blog/how-to-use-virtualenv-python/">https://learnpython.com/blog/how-to-use-virtualenv-python/</a>
</a>

<li>Python Virtual Environments: A Primer<br />
<a href="https://realpython.com/python-virtual-environments-a-primer/">https://realpython.com/python-virtual-environments-a-primer/</a>
</a>

<li>virtualenv Cheatsheet<br />
<a href="https://aaronlelevier.github.io/virtualenv-cheatsheet/">https://aaronlelevier.github.io/virtualenv-cheatsheet/</a>
</a>

<li>Installing Python Modules<br />
<a href="https://docs.python.org/3/installing/index.html">https://docs.python.org/3/installing/index.html</a>
</a>

<li>Python: The Documentary | An origin story<br />
<a href="https://www.youtube.com/watch?v=GfH4QL4VqJ0">https://www.youtube.com/watch?v=GfH4QL4VqJ0</a>
</li>

<li>History of Python<br />
<a href="https://en.wikipedia.org/wiki/History_of_Python">https://en.wikipedia.org/wiki/History_of_Python</a>
</li>

<li>History of Python<br />
<a href="https://www.geeksforgeeks.org/python/history-of-python/">https://www.geeksforgeeks.org/python/history-of-python/</a>
</li>

<li>IPython: jedno z nejpropracovanějších interaktivních prostředí pro práci s&nbsp;Pythonem<br />
<a href="https://www.root.cz/clanky/ipython-jedno-z-nejpropracova-nejsich-interaktivnich-prostredi-pro-praci-s-pythonem/">https://www.root.cz/clanky/ipython-jedno-z-nejpropracova-nejsich-interaktivnich-prostredi-pro-praci-s-pythonem/</a>
</li>

<li>Další kulaté výročí v IT: dvacet let existence Pythonu 2<br />
<a href="https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/">https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/</a>
</li>

<li>PEP 684 – A Per-Interpreter GIL<br />
<a href="https://peps.python.org/pep-0684/">https://peps.python.org/pep-0684/</a>
</li>

<li>What Is the Python Global Interpreter Lock (GIL)?<br />
<a href="https://realpython.com/python-gil/">https://realpython.com/python-gil/</a>
</li>

<li>PEP 703 – Making the Global Interpreter Lock Optional in CPython<br />
<a href="https://peps.python.org/pep-0703/">https://peps.python.org/pep-0703/</a>
</li>

<li>GlobalInterpreterLock<br />
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>
</li>

<li>What is the Python Global Interpreter Lock (GIL)<br />
<a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/">https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/</a>
</li>

<li>Let's remove the Global Interpreter Lock<br />
<a href="https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html">https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html</a>
</li>

<li>Global interpreter lock<br />
<a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">https://en.wikipedia.org/wiki/Global_interpreter_lock</a>
</li>

<li>Rychlost CPythonu 3.11 a 3.12 v&nbsp;porovnání s JIT a AOT překladači<br />
<a href="https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/">https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/</a>
</li>

<li>Dokumentace Pythonu: balíček queue<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Dokumentace Pythonu: balíček threading<br />
<a href="https://docs.python.org/3/library/threading.html?">https://docs.python.org/3/library/threading.html?</a>
</li>

<li>Dokumentace Pythonu: balíček multiprocessing<br />
<a href="https://docs.python.org/3/library/multiprocessing.html">https://docs.python.org/3/library/multiprocessing.html</a>
</li>

<li>Dokumentace Pythonu: balíček asyncio<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Synchronization Primitives<br />
<a href="https://docs.python.org/3/library/asyncio-sync.html">https://docs.python.org/3/library/asyncio-sync.html</a>
</li>

<li>Coroutines<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Queues<br />
<a href="https://docs.python.org/3/library/asyncio-queue.html">https://docs.python.org/3/library/asyncio-queue.html</a>
</li>

<li>python-csp<br />
<a href="https://python-csp.readthedocs.io/en/latest/">https://python-csp.readthedocs.io/en/latest/</a>
</li>

<li>TrellisSTM<br />
<a href="http://peak.telecommunity.com/DevCenter/TrellisSTM">http://peak.telecommunity.com/DevCenter/TrellisSTM</a>
</li>

<li>Python Multithreading and Multiprocessing Tutorial<br />
<a href="https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python">https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

