<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Nové vlastnosti Pythonu 3.14 v praxi: komunikace mezi interpretry</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Nové vlastnosti Pythonu 3.14 v praxi: komunikace mezi interpretry</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní dvojici článků o nových vlastnostech Pythonu 3.14 dnes navážeme. Ukážeme si, jak lze realizovat komunikaci mezi úlohami, které jsou spuštěny v samostatných interpretrech. A porovnáme toto řešení s technologiemi, které již Python nabízí: multiprocesing, multithreading a asynchronní volání.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: komunikace mezi interpretry</a></p>
<p><a href="#k02">2. Komunikace mezi interpretry s&nbsp;využitím fronty</a></p>
<p><a href="#k03">3. Demonstrační příklad: poslání zprávy mezi úlohami, které běží v&nbsp;různých interpretrech</a></p>
<p><a href="#k04">4. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k05">5. Realizace programu pro zpracování úloh v&nbsp;samostatně běžících interpretrech</a></p>
<p><a href="#k06">6. Ukázka chování programu s&nbsp;více úlohami po jeho spuštění</a></p>
<p><a href="#k07">7. Jazyk Python a multiprocessing</a></p>
<p><a href="#k08">8. Spuštění většího množství procesů, čekání na dokončení těchto procesů</a></p>
<p><a href="#k09">9. Realizace programu pro zpracování úloh v&nbsp;samostatných procesech</a></p>
<p><a href="#k10">10. Porovnání realizace <i>workerů</i> založené na interpretrech s&nbsp;realizací založenou na multiprocesingu</a></p>
<p><a href="#k11">11. Přepis programu takovým způsobem, aby se úlohy spouštěly v&nbsp;samostatných vláknech</a></p>
<p><a href="#k12">12. Porovnání realizace <i>workerů</i> založené na interpretrech s&nbsp;realizací založenou na multithreadingu</a></p>
<p><a href="#k13">13. Čekání na ukončení všech úloh s&nbsp;využitím synchronizačních mechanismů fronty</a></p>
<p><a href="#k14">14. Realizace klasického vzoru vzor producent&ndash;konzument</a></p>
<p><a href="#k15">15. Souběžně běžící úlohy a konstrukce <strong>async</strong> a <strong>await</strong></a></p>
<p><a href="#k16">16. Přepis programu takovým způsobem, aby se používaly asynchronně běžící úlohy</a></p>
<p><a href="#k17">17. Shrnutí</a></p>
<p><a href="#k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: komunikace mezi interpretry</h2>

<p>Na úvodní dvojici článků o nových vlastnostech <a
href="https://test.python.org/downloads/release/python-3140/">Pythonu 3.14</a>
[<a
href="https://www.root.cz/clanky/python-3-14-t-retezce-barvicky-lepsi-napoveda-a-odchazejici-gil/">1</a>]
[<a
href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">2</a>]
dnes navážeme. Minule jsme si řekli, že v&nbsp;Pythonu 3.14 je možné programově
vytvořit větší množství interpretrů a spouštět v&nbsp;nich úlohy, které jsou do
značné míry izolovány od úloh, které jsou spouštěny v&nbsp;jiných interpretrech
(i když se tato technologie odlišuje od klasického multiprocesingu). A nejen to
&ndash; úlohy v&nbsp;interpretrech mohou běžet (a většinou i běží)
v&nbsp;samostatných vláknech, takže lze dosáhnout souběžného a mnohdy i
paralelního běhu výpočtů.</p>

<p>Ovšem současně je nutné nějakým způsobem zajistit komunikaci mezi úlohami,
které jsou od sebe tímto způsobem odizolovány. Dnes si ukážeme, jakým způsobem
se to provádí. Navíc použitou technologii porovnáme s&nbsp;realizací komunikace
mezi asynchronně spouštěnými úlohami, vlákny a procesy (což jsou taktéž
technologie zajišťující souběžné provádění úloh, ovšem na odlišných
úrovních).</p>

<p><div class="rs-tip-major">Poznámka: všechny dále ukázané demonstrační
příklady poběží na nejnovější verzi Pythonu 3.14, přičemž tato varianta může
mít zakázaný i povolený GIL (ve výpisu se hlásí varianta Pythonu bez
GILu):</div></p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.14.0 free-threading build (main, Oct 18 2025, 10:08:58) [GCC 14.2.1 20240912 (Red Hat 14.2.1-3)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Komunikace mezi interpretry s&nbsp;využitím fronty</h2>

<p><a
href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">V&nbsp;předchozím
článku</a> jsme si ověřili, že pokud je nějaká úloha (kód ve zdrojové podobě
nebo funkce) spuštěna v&nbsp;kontextu nového interpretru, nemá přístup
k&nbsp;proměnným ostatních interpretrů. To je pochopitelně korektní a očekávané
chování protože tato úloha má běžet izolovaně od ostatních úloh. Ovšem mnohdy
je nutné zajistit předávání dat mezi jednotlivými (od sebe izolovanými)
úlohami. Pro tento účel se používají fronty, což není v&nbsp;ekosystému jazyka
Python překvapující, protože pro stejné účely se fronty používají i
v&nbsp;kontextu asynchronních úloh, úloh běžících ve vláknech nebo i při
spuštění úloh v&nbsp;samostatných procesech.</p>

<p>Nyní tedy víme, že pro komunikaci mezi interpretry (resp.&nbsp;mezi úlohami,
které v&nbsp;nich běží) slouží fronty. Jak se taková fronta vytvoří?
K&nbsp;tomuto účelu slouží funkce nazvaná <strong>create_queue</strong>
z&nbsp;balíčku <strong>concurrent.interpreters</strong> (jinou formu fronty
nepoužívejte):</p>

<pre>
create(maxsize=0, *, unbounditems=concurrent.interpreters._queues.UNBOUND)
    Return a new cross-interpreter queue.
&nbsp;
    The queue may be used to pass data safely between interpreters.
&nbsp;
    "unbounditems" sets the default for Queue.put(); see that method for
    supported values.  The default value is UNBOUND, which replaces
    the unbound item.
</pre>

<p>Příklad vytvoření fronty:</p>

<pre>
from concurrent import interpreters
&nbsp;
q = interpreters.create_queue()
...
...
...
</pre>

<p>Vytvořená fronta programátorům nabízí několik metod, které postupně
použijeme v&nbsp;dalším textu:</p>

<table>
<tr><th>#</th><th>Metoda</th></tr>
<tr><td>1</td><td>empty</td></tr>
<tr><td>2</td><td>full</td></tr>
<tr><td>3</td><td>get</td></tr>
<tr><td>4</td><td>get_nowait</td></tr>
<tr><td>5</td><td>put</td></tr>
<tr><td>6</td><td>put_nowait</td></tr>
<tr><td>7</td><td>qsize</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: tímto způsobem vytvořenou frontu je
možné předat no funkce, která bude spuštěna v&nbsp;jiném interpretru. Příkladem
je zavolání funkce <strong>run</strong> v&nbsp;novém interpretru, přičemž
jediným předávaným parametrem bude právě objekt typu
<strong>concurrent.interpreters._queues.Queue</strong>:</div></p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
q = interpreters.create_queue()
&nbsp;
interp.call_in_thread(run, q)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstrační příklad: poslání zprávy mezi úlohami, které běží v&nbsp;různých interpretrech</h2>

<p>Podívejme se nyní na způsob praktické realizace posílání zpráv mezi dvěma
úlohami, z&nbsp;nichž každá běží ve vlastním interpretru (navíc v&nbsp;různých
vláknech). Nejdříve zkonstruujeme nový interpretr (ten zatím neběží) a následně
frontu použitou pro komunikaci mezi úlohami:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
q = interpreters.create_queue()
</pre>

<p>Dále nadefinujeme funkci, která bude později spuštěna v&nbsp;novém
interpretru. Povšimněte si, že této funkci bude předán parametr
<strong>q</strong>, který by měl být typu <strong>Queue</strong> (těchto typů
existuje v&nbsp;základní knihovně Pythonu několik, ovšem jejich základní
vlastnosti jsou shodné). Funkce bude čekat na zprávu, kterou někdo jiný (kód
běžící v&nbsp;odlišném vláknu) pošle do fronty. Jakmile takovou zprávu dostane,
vypíše její obsah a funkce se následně ukončí:</p>

<pre>
def <strong>run</strong>(q):
    print("Hello from new interpreter, waiting for message")
    message = q.get()
    print(f"Message received: '{message}'")
</pre>

<p>Nyní již postačuje spustit tuto funkci v&nbsp;novém interpretru (navíc
v&nbsp;novém vláknu) a předat jí referenci na frontu:</p>

<pre>
print("Executing run()")
t = interp.call_in_thread(run, q)
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>t</strong> je typu
<strong>threading.Thread</strong>.</div></p>

<p>Pošleme zprávu do fronty; převezme si ji úloha běžící v&nbsp;jiném
interpretru/vláknu:</p>

<pre>
print("Sending message into queue")
q.put("foo")
print("Message sent")
</pre>

<p>Nyní již pouze počkáme na dokončení úlohy:</p>

<pre>
print("Waiting for other interpreter to finish")
t.join()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód příkladu, který byl popsán <a
href="#k03">v&nbsp;předchozí kapitole</a>, vypadá následovně:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
&nbsp;
def <strong>run</strong>(q):
    print("Hello from new interpreter, waiting for message")
    message = q.get()
    print(f"Message received: '{message}'")
&nbsp;
&nbsp;
q = interpreters.create_queue()
&nbsp;
print("Executing run()")
t = interp.call_in_thread(run, q)
&nbsp;
print("Sending message into queue")
q.put("foo")
print("Message sent")
&nbsp;
print("Waiting for other interpreter to finish")
t.join()
&nbsp;
print("Done")
</pre>

<p>Příklad chování programu po spuštění:</p>

<pre>
Executing run()
Sending message into queue
Message sent
Waiting for other interpreter to finish
Hello from new interpreter, waiting for message
Message received: 'foo'
Done
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Realizace programu pro zpracování úloh v&nbsp;samostatně běžících interpretrech</h2>

<p>Původní program popsaný v&nbsp;předchozích dvou kapitolách nyní upravíme do
nepatrně složitější podoby. V&nbsp;první řadě budeme v&nbsp;programu definovat
funkci nazvanou <strong>worker</strong>. Ta poběží (klidně i několikrát)
v&nbsp;různých interpretrech/vláknech a bude přes frontu přijímat úlohy.
Vytiskne parametry úlohy a samotnou práci bude simulovat funkcí
<strong>time.sleep</strong> :-). Pokud ovšem bude úloha obsahovat text
<strong>quit</strong>, bude funkce <strong>worker</strong> ihned ukončena:</p>

<pre>
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných interpretrech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Process '{name}' is about to quit")
            return
        time.sleep(1)
</pre>

<p>Funkce <strong>worker</strong> bude spuštěna několikrát, abychom si ukázali
možnosti škálování úloh:</p>

<pre>
    q = interpreters.create_queue()
&nbsp;
    <i># vytvoření tří procesů</i>
    names = ("foo", "bar", "baz")
    ins = [interpreters.create().call_in_thread(worker, name, q) for name in names]
</pre>

<p>Povšimněte si, že všem třem workerům je předáno sice odlišné jméno, ale ve
druhém parametru získají referenci na instanci stejné fronty. To nám umožní
předávat wokerkům úlohy, o které se budou dělit (podle toho, který worker je
zrovna dostupný):</p>

<pre>
    print("Sending data to other interpreters")
&nbsp;
    <i># komunikace s interpretry přes frontu</i>
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
</pre>

<p>Na konci požádáme workery o jejich ukončení a počkáme, až všechna vlákna, ve
kterých běží interpretry, skutečně skončí:</p>

<pre>
    <i># příkaz pro ukončení procesů</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other interpreters")
&nbsp;
    <i># čekání na ukončení interpretrů</i>
    for i in ins:
        i.join()
&nbsp;
    print("All work done!")
</pre>

<p>Úplný zdrojový kód takto upraveného demonstračního příkladu vypadá
následovně:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových interpretrech</i>
<i># - komunikace mezi interpretry s využitím fronty</i>
&nbsp;
import time
from concurrent import interpreters
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných interpretrech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Process '{name}' is about to quit")
            return
        time.sleep(1)
&nbsp;
&nbsp;
if __name__ == "__main__":
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi interpretry</i>
    q = interpreters.create_queue()
&nbsp;
    <i># vytvoření tří procesů</i>
    names = ("foo", "bar", "baz")
    ins = [interpreters.create().call_in_thread(worker, name, q) for name in names]
&nbsp;
    print("Sending data to other interpreters")
&nbsp;
    <i># komunikace s interpretry přes frontu</i>
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    print("Asking other interpreters to finish")
&nbsp;
    <i># příkaz pro ukončení procesů</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other interpreters")
&nbsp;
    <i># čekání na ukončení interpretrů</i>
    for i in ins:
        i.join()
&nbsp;
    print("All work done!")
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ukázka chování programu s&nbsp;více úlohami po jeho spuštění</h2>

<p>Po spuštění programu můžeme snadno zjistit, že se workeři skutečně o předané
úlohy dělili:</p>

<pre>
Process 'foo' received command 'command 0'
Process 'foo' received command 'command 3'
Process 'foo' received command 'command 6'
Process 'foo' received command 'command 9'
Process 'foo' received command 'quit'
Process 'foo' is about to quit
Process 'baz' received command 'command 2'
Process 'baz' received command 'command 5'
Process 'baz' received command 'command 8'
Process 'baz' received command 'quit'
Process 'baz' is about to quit
Process 'bar' received command 'command 1'
Process 'bar' received command 'command 4'
Process 'bar' received command 'command 7'
Process 'bar' received command 'quit'
Process 'bar' is about to quit
Starting
Sending data to other interpreters
Sending 'command 0'
Sending 'command 1'
Sending 'command 2'
Sending 'command 3'
Sending 'command 4'
Sending 'command 5'
Sending 'command 6'
Sending 'command 7'
Sending 'command 8'
Sending 'command 9'
Asking other interpreters to finish
Waiting for other interpreters
All work done!
</pre>

<p>Doba běhu programu je menší než 10 sekund:</p>

<pre>
real    0m4.171s
user    0m0.199s
sys     0m0.040s
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Jazyk Python a multiprocessing</h2>

<p>V&nbsp;předchozích kapitolách jsme si popsali technologii spouštění výpočtů
v&nbsp;samostatných vláknech, ve kterých navíc běží izolované interpretry.
Ovšem existují i další možnosti tvorby aplikací, jejichž části mají běžet buď
&bdquo;pouze&ldquo; souběžně nebo které využijí plnou paralelnost nabízenou
moderními počítači. Vzhledem k&nbsp;(dnes již volitelné) existenci GILu ve
standardním CPythonu může být problematické zajistit paralelní běh v&nbsp;rámci
jednoho procesu (tedy vlastně jednoho virtuálního stroje Pythonu), proto je
dalším logickým krokem rozdělení (<i>fork</i>) tohoto procesu na větší množství
plnohodnotných systémových procesů.</p>

<p>Ty budou moci běžet nezávisle na sobě a navíc toto řešení programátora
donutí k&nbsp;tomu, aby explicitně zajistil korektní komunikaci mezi těmito
procesy &ndash; zde již nemůže dojít k&nbsp;chybám typu &bdquo;přístup do
objektu vlastněného jiným vláknem&ldquo; atd. Toto řešení přináší i některé
nevýhody &ndash; větší systémové nároky, pomalejší spouštění procesů
(v&nbsp;porovnání se spouštěním interpretrů) a v&nbsp;některých případech se
projeví i delší doba přepínání mezi procesy (ovšem to se podle mého názoru u
interpretovaného Pythonu ztratí) a někdy by se skutečně hodilo mít snadný
přístup ke sdíleným objektům.</p>

<p>V&nbsp;případě, že se rozhodnete si vyzkoušet spouštění jednotlivých částí
algoritmu v&nbsp;samostatných procesech, můžete využít další standardní modul
(balíček), který se jmenuje příznačně <strong>multiprocessing</strong>. Tento
modul vývojáře do značné míry odstiňuje od nízkoúrovňových operací, tedy od
samotného rozvětvení procesu (<i>fork</i>), spuštění nového interpretru a
specifikace, jaký kód má tento interpret použít. Z&nbsp;pohledu vývojáře je
totiž použití modulu <strong>multiprocessing</strong> velmi přímočaré &ndash;
pouze se zvolí, jaká funkce se má zavolat v&nbsp;novém procesu a jaké mají být
této funkci předány argumenty. Navíc modul <strong>multiprocessing</strong>
programátorům nabízí mechanismy umožňující komunikaci mezi procesy. Zejména se
jedná o frontu (<i>queue</i>) (ovšem jinou frontu, než jsme doposud používali,
i když její API je v&nbsp;některých ohledech prakticky totožné) a taktéž o
oboustrannou rouru (<i>pipe</i>).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spuštění většího množství procesů, čekání na dokončení těchto procesů</h2>

<p>Podívejme se nyní na velmi jednoduchý demonstrační příklad, na němž jsou
ukázány základní mechanismy nabízené standardním modulem
<strong>multiprocessing</strong>.  Ve skriptu je definována následující funkce,
která se má spustit v&nbsp;samostatném procesu:</p>

<pre>
def <strong>worker</strong>(name):
    print("hello", name)
</pre>

<p>Nový proces se spustí následovně:</p>

<pre>
p = Process(target=worker, args=("foo",))
p.start()
</pre>

<p>Implementovat je možné i čekání na dokončení tohoto procesu:</p>

<pre>
p.join()
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že není požadováno
čekání na dokončení procesu, lze jeho vytvoření a spuštění napsat na jediný
řádek:</div></p>

<pre>
p = Process(target=worker, args=("foo",)).start()
</pre>

<p>Úplný zdrojový kód takto vytvořeného příkladu vypadá následovně:</p>

<pre>
from multiprocessing import Process
&nbsp;
&nbsp;
def <strong>worker</strong>(name):
    print("hello", name)
&nbsp;
&nbsp;
def <strong>main</strong>():
    p = Process(target=worker, args=("foo",))
    p.start()
    p.join()
&nbsp;
&nbsp;
if __name__ == '__main__':
    print("Running main")
    main()
</pre>

<p>Samozřejmě můžeme spustit větší množství procesů a následně si (například
nástrojem <strong>top</strong> nebo <strong>htop</strong>) tyto procesy
zobrazit. Na dokončení procesů lze počkat metodou <strong>join</strong> &ndash;
jedná se tedy o prakticky stejný koncept, jaký jsme viděli při práci
s&nbsp;větším množstvím interpretrů (a ještě uvidíme při práci
s&nbsp;vlákny):</p>

<pre>
from multiprocessing import Process
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(name):
    print("hello", name)
    time.sleep(5)
    print("done", name)
&nbsp;
&nbsp;
def <strong>main</strong>():
    ps = []
&nbsp;
    for name in ("foo", "bar", "baz", "other"):
        p = Process(target=worker, args=(name,))
        p.start()
        ps.append(p)
&nbsp;
    for p in ps:
        p.join()
&nbsp;
&nbsp;
if __name__ == '__main__':
    print("Running main")
    main()
</pre>

<p>Výpis procesů (včetně dvou nerelevantních procesů):</p>

<pre>
$ <strong>ps ax |grep python</strong>
&nbsp;
  767 ?        Ssl    0:00 /usr/bin/python3 -Es /usr/sbin/firewalld --nofork --nopid
10864 pts/4    S+     0:00 python3 multiprocessing2.py
10865 pts/4    S+     0:00 python3 multiprocessing2.py
10866 pts/4    S+     0:00 python3 multiprocessing2.py
10867 pts/4    S+     0:00 python3 multiprocessing2.py
10868 pts/4    S+     0:00 python3 multiprocessing2.py
10947 pts/6    S+     0:00 grep --color=auto python
</pre>

<p>Zvýraznění rozvětvení (<i>forku</i>), které bylo provedeno:</p>

<pre>
$ <strong>pstree -c 10864</strong>
&nbsp;
python3─┬─python3
        ├─python3
        ├─python3
        └─python3
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Realizace programu pro zpracování úloh v&nbsp;samostatných procesech</h2>

<p>V&nbsp;této chvíli již známe všechny informace pro to, abychom program, ve
kterém se úlohy spouští v&nbsp;samostatných interpretrech, změnili tak, aby se
úlohy spouštěly v&nbsp;samostatných procesech. I když se jedná o dosti velkou
změnu technologie, budou změny (z&nbsp;pohledu zdrojového kódu) relativně
malé:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových procesech</i>
<i># - komunikace mezi procesy s využitím fronty</i>
&nbsp;
&nbsp;
import time
from multiprocessing import Process, Queue, freeze_support
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných procesech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Process '{name}' is about to quit")
            return
        time.sleep(1)
&nbsp;
&nbsp;
if __name__ == "__main__":
    print("Starting")
    freeze_support()
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi procesy</i>
    q = Queue()
&nbsp;
    <i># vytvoření tří procesů</i>
    names = ("foo", "bar", "baz")
    ps = [Process(target=worker, args=(name, q)) for name in names]
&nbsp;
    <i># spuštění tří procesů</i>
    for p in ps:
        p.start()
&nbsp;
    print("Sending data to other processes")
&nbsp;
    <i># komunikace s procesy přes frontu</i>
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    print("Asking other processes to finish")
&nbsp;
    <i># příkaz pro ukončení procesů</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other processes")
&nbsp;
    <i># čekání na ukončení procesů</i>
    for p in ps:
        p.join()
&nbsp;
    print("All work done!")
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Porovnání realizace <i>workerů</i> založené na interpretrech s&nbsp;realizací založenou na multiprocesingu</h2>

<p>I když je realizace workerů založená na interpretrech interně značně odlišná
od realizace založené na multiprocesingu, jsou zdrojové kódy obou realizací
skutečně velmi podobné. Ostatně postačuje se podívat na porovnání obou
zdrojových kódů řádek po řádku:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:                    # Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových interpretrech                   # - spuštění více úloh v nových procesech</i>
<i># - komunikace mezi interpretry s využitím fronty               # - komunikace mezi procesy s využitím fronty</i>
&nbsp;                                                          
import time                                                     import time
from concurrent import interpreters                             from multiprocessing import Process, Queue, freeze_support
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):                                            def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných interpretrech      """Worker spuštěný několikrát v samostatných procesech.""</i>
    while True:                                                     while True:
        <i># čtení příkazů z fronty                                        # čtení příkazů z fronty</i>
        cmd = q.get()                                                   cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")             print(f"Process '{name}' received command '{cmd}'")
        if cmd == "quit":                                               if cmd == "quit":
            print(f"Process '{name}' is about to quit")                     print(f"Process '{name}' is about to quit")
            return                                                          return
        time.sleep(1)                                                   time.sleep(1)
&nbsp;
&nbsp;
if __name__ == "__main__":                                      if __name__ == "__main__":
    print("Starting")                                               print("Starting")
                                                                    freeze_support()
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi interpretry              # vytvoření fronty pro komunikaci mezi procesy</i>
    q = interpreters.create_queue()                                 q = Queue()
&nbsp;
    <i># vytvoření tří procesů                                        # vytvoření tří procesů</i>
    names = ("foo", "bar", "baz")                                   names = ("foo", "bar", "baz")
    ins = [interpreters.create().call_in_thread(worker, name,       ps = [Process(target=worker, args=(name, q)) for name in 
&nbsp;
                                                                    <i># spuštění tří procesů</i>
                                                                    for p in ps:
                                                                        p.start()
&nbsp;
    print("Sending data to other interpreters")                     print("Sending data to other processes")
&nbsp;
    <i># komunikace s interpretry přes frontu                          # komunikace s procesy přes frontu</i>
    for i in range(10):                                             for i in range(10):
        print(f"Sending 'command {i}'")                                 print(f"Sending 'command {i}'")
        q.put("command {}".format(i))                                   q.put("command {}".format(i))
&nbsp;
    print("Asking other interpreters to finish")                    print("Asking other processes to finish")
&nbsp;
    <i># příkaz pro ukončení procesů                                   # příkaz pro ukončení procesů</i>
    for i in range(3):                                              for i in range(3):
        q.put("quit")                                                   q.put("quit")
&nbsp;
    print("Waiting for other interpreters")                         print("Waiting for other processes")
&nbsp;
    <i># čekání na ukončení interpretrů                                # čekání na ukončení procesů</i>
    for i in ins:                                                   for p in ps:
        i.join()                                                        p.join()
&nbsp;
    print("All work done!")                                         print("All work done!")
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Přepis programu takovým způsobem, aby se úlohy spouštěly v&nbsp;samostatných vláknech</h2>

<p>V&nbsp;Pythonu je možné jednotlivé úlohy spouštět v&nbsp;samostatných
vláknech, a to se všemi výhodami a nevýhodami, které tato technologie přináší.
Pro komunikaci mezi vlákny se opět (typicky) používají fronty. Navíc je ovšem
nutné funkci, která má být zavolána v&nbsp;nově spuštěném vláknu, předat nějaké
parametry; v&nbsp;našem konkrétním případě jméno úlohy a referenci na frontu.
To nelze provést přímo (funkci totiž nevolá přímo programátor, ale modul
<strong>threading</strong>), nicméně parametry do volané funkce je možné
specifikovat, i když nepřímým způsobem:</p>

<pre>
    <i># vytvoření fronty pro komunikaci mezi vlákny</i>
    q = Queue()
&nbsp;
    <i># spuštění tří vláken</i>
    names = ("foo", "bar", "baz")
    ts = [Thread(target=worker, daemon=True, name=name, args=[name, q]) for name in names]
</pre>

<p>Čekání na dokončení úloh lze zajistit více způsoby, například explicitním
čekáním na dokončení vláken:</p>

<pre>
    print("Asking other threads to finish")
&nbsp;
    <i># příkaz pro ukončení vláken</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other threads")
&nbsp;
    <i># čekání na zpracování všech zpráv ve frontě</i>
    for t in ts:
        t.join()
</pre>

<p>Program upravený do takové podoby, že používá multithreading a nikoli
multiprocesing (či více interpretrů) může vypadat následovně:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových vláknech</i>
<i># - komunikace mezi vlákny s využitím fronty</i>
&nbsp;
&nbsp;
from queue import Queue
from threading import Thread
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných vláknech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            return
        time.sleep(1)
&nbsp;
&nbsp;
if __name__ == "__main__":
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi vlákny</i>
    q = Queue()
&nbsp;
    <i># spuštění tří vláken</i>
    names = ("foo", "bar", "baz")
    ts = [Thread(target=worker, daemon=True, name=name, args=[name, q]) for name in names]
&nbsp;
    <i># spuštění tří vláken</i>
    for t in ts:
        t.start()
&nbsp;
    print("Sending data to other threads")
&nbsp;
    <i># komunikace s vlákny přes frontu</i>
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    print("Asking other threads to finish")
&nbsp;
    <i># příkaz pro ukončení vláken</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other threads")
&nbsp;
    <i># čekání na zpracování všech zpráv ve frontě</i>
    for t in ts:
        t.join()

    print("All work done!")
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Porovnání realizace <i>workerů</i> založené na interpretrech s&nbsp;realizací založenou na multithreadingu</h2>

<p>Opět si porovnejme realizaci programu, který spouští úlohy v&nbsp;různých
interpretrech a programu, který provádí tutéž činnost, ovšem s&nbsp;využitím
multithreadingu. Změny ve zdrojovém kódu budou relativně malé:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:                   # Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových interpretrech                  # - spuštění více úloh v nových vláknech</i>
<i># - komunikace mezi interpretry s využitím fronty              # - komunikace mezi vlákny s využitím fronty</i>
&nbsp;
&nbsp;
                                                               from queue import Queue
                                                               from threading import Thread
import time                                                    import time
from concurrent import interpreters                           
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):                                           def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných interpretrec      """Worker spuštěný několikrát v samostatných vláknech."""</i>
    while True:                                                    while True:
        <i># čtení příkazů z fronty                                       # čtení příkazů z fronty</i>
        cmd = q.get()                                                  cmd = q.get()
        print(f"Process '{name}' received command '{cmd}'")            print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":                                              if cmd == "quit":
            print(f"Process '{name}' is about to quit")                    print(f"Thread '{name}' is about to quit")
            return                                                         return
        time.sleep(1)                                                  time.sleep(1)
&nbsp;
&nbsp;
if __name__ == "__main__":                                     if __name__ == "__main__":
    print("Starting")                                              print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi interpretry             # vytvoření fronty pro komunikaci mezi vlákny</i>
    q = interpreters.create_queue()                                q = Queue()
&nbsp;
    <i># vytvoření tří procesů                                        # spuštění tří vláken</i>
    names = ("foo", "bar", "baz")                                  names = ("foo", "bar", "baz")
    ins = [interpreters.create().call_in_thread(worker, name,      ts = [Thread(target=worker, daemon=True, name=name, args=
&nbsp;
                                                                   <i># spuštění tří vláken</i>
                                                                   for t in ts:
                                                                       t.start()
&nbsp;
    print("Sending data to other interpreters")                    print("Sending data to other threads")
&nbsp;
    <i># komunikace s interpretry přes frontu                         # komunikace s vlákny přes frontu</i>
    for i in range(10):                                            for i in range(10):
        print(f"Sending 'command {i}'")                                print(f"Sending 'command {i}'")
        q.put("command {}".format(i))                                  q.put("command {}".format(i))
&nbsp;
    print("Asking other interpreters to finish")                   print("Asking other threads to finish")
&nbsp;
    <i># příkaz pro ukončení procesů                                  # příkaz pro ukončení vláken</i>
    for i in range(3):                                             for i in range(3):
        q.put("quit")                                                  q.put("quit")
&nbsp;
    print("Waiting for other interpreters")                        print("Waiting for other threads")
&nbsp;
    <i># čekání na ukončení interpretrů                               # čekání na zpracování všech zpráv ve frontě</i>
    for i in ins:                                                  for t in ts:
        i.join()                                                       t.join()
&nbsp;
    print("All work done!")                                        print("All work done!")
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Čekání na ukončení všech úloh s&nbsp;využitím synchronizačních mechanismů fronty</h2>

<p>Ve skutečnosti je možné pro čekání na dokončení všech úloh použít ještě
jeden synchronizační mechanismus, který je ze sémantického hlediska výhodnější.
Samotní workeři totiž mohou signalizovat dokončení úlohy zavoláním metody
<strong>Queue.task_done()</strong>. A vlákno, ve kterém se čeká na dokončení
činnosti workerů, může použít metodu <strong>Queue.join()</strong>.</p>

<p>Realizace workera se tedy může změnit následovně:</p>

<pre>
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných vláknech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            q.task_done()
            return
        time.sleep(1)
        q.task_done()
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že dokončení úlohy
potvrzujeme skutečně až po dokončení všech jejích kroků.</div></p>

<p>Samotné čekání na všechna tři vlákna bude vypadat takto:</p>

<pre>
    <i># příkaz pro ukončení vláken</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other threads")
&nbsp;
    <i># čekání na zpracování všech zpráv ve frontě</i>
    q.join()
</pre>

<p>Zdrojový kód demonstračního příkladu se změní do následující podoby:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových vláknech</i>
<i># - komunikace mezi vlákny s využitím fronty</i>
&nbsp;
&nbsp;
from queue import Queue
from threading import Thread
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných vláknech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        q.task_done()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            return
        time.sleep(1)
&nbsp;
&nbsp;
if __name__ == "__main__":
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi vlákny</i>
    q = Queue()
&nbsp;
    <i># spuštění tří vláken</i>
    names = ("foo", "bar", "baz")
    ts = [Thread(target=worker, daemon=True, name=name, args=[name, q]) for name in names]
&nbsp;
    <i># spuštění tří vláken</i>
    for t in ts:
        t.start()
&nbsp;
    print("Sending data to other threads")
&nbsp;
    <i># komunikace s vlákny přes frontu</i>
    for i in range(10):
        print(f"Sending 'command {i}'")
        q.put("command {}".format(i))
&nbsp;
    print("Asking other threads to finish")
&nbsp;
    <i># příkaz pro ukončení vláken</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other threads")
&nbsp;
    <i># čekání na zpracování všech zpráv ve frontě</i>
    q.join()
&nbsp;
    print("All work done!")
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Realizace klasického vzoru vzor producent&ndash;konzument</h2>

<p>V&nbsp;následujícím demonstračním příkladu je ukázán známý systém
<i>producer-consumer</i>, kde jak producenti, tak i konzumenti každý běží
v&nbsp;samostatném vláknu a komunikují spolu pouze přes sdílenou frontu
<strong>q</strong>. Producentů i konzumentů může být (prakticky) libovolné
množství a navíc je možné je přidávat nebo ubírat na základě požadavků
aplikace. V&nbsp;následujícím demonstračním příkladu spolu komunikují tři
producenti a čtyři konzumenti:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh v nových vláknech</i>
<i># - komunikace mezi vlákny s využitím fronty</i>
&nbsp;
&nbsp;
from queue import Queue
from threading import Thread
import time
&nbsp;
&nbsp;
def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát v samostatných vláknech."""</i>
    while True:
        <i># čtení příkazů z fronty</i>
        cmd = q.get()
        print(f"Thread '{name}' received command '{cmd}'")
        if cmd == "quit":
            print(f"Thread '{name}' is about to quit")
            q.task_done()
            return
        time.sleep(1)
        q.task_done()
&nbsp;
&nbsp;
def <strong>producer</strong>(name, q):
    for job in range(10):
        print(f"{name} thread: Starting producing {job}")
        q.put(job)
        time.sleep(0.3)
        print(f"{name} thread: Produced {job}")
&nbsp;
&nbsp;
if __name__ == "__main__":
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi vlákny</i>
    q = Queue()
&nbsp;
    <i># spuštění čtyř producentů</i>
    names = ("1st", "2nd", "3rd", "4th")
    ps = [Thread(target=producer, daemon=True, name=name, args=[name, q]) for name in names]
&nbsp;
    <i># spuštění producentů</i>
    for p in ps:
        p.start()
&nbsp;
    <i># vytvoření tří vláken</i>
    names = ("foo", "bar", "baz")
    ts = [Thread(target=worker, daemon=True, name=name, args=[name, q]) for name in names]
&nbsp;
    <i># spuštění tří vláken</i>
    for t in ts:
        t.start()
&nbsp;
    print("Asking other threads to finish")
&nbsp;
    <i># čekání na dokončení producentů</i>
    for p in ps:
        p.join()
&nbsp;
    <i># příkaz pro ukončení vláken</i>
    for i in range(3):
        q.put("quit")
&nbsp;
    print("Waiting for other threads")
&nbsp;
    <i># čekání na zpracování všech zpráv ve frontě</i>
    q.join()
&nbsp;
    print("All work done!")
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Souběžně běžící úlohy a konstrukce <strong>async</strong> a <strong>await</strong></h2>

<p>V&nbsp;některých situacích je možné dosáhnout zvýšení efektivity aplikace
(například zvýšit počet odpovědí, které může server vygenerovat za určitou
časovou jednotku) a přitom není možné či vhodné využívat přímočaré ale dosti
nízkoúrovňové řešení založené na použití většího množství vláken, procesů nebo
interpretrů spravovaných runtime systémem Pythonu. Naprosto typickým příkladem
jsou některé virtuální stroje JavaScriptu, které povětšinou umožňují běh
aplikace v&nbsp;jediném vláknu.</p>

<p>Pokud aplikace intenzivně používá I/O, tedy například přístup k&nbsp;datům
přes HTTP(s), volání DB operací atd., lze namísto více vláken využít
<i>korutiny</i>, což jsou funkce transformované takovým způsobem, že mohou
běžet <i>souběžně</i>, nikoli však nutně <i>paralelně</i>. Existuje mnoho
způsobů konstrukce a volání korutin. V&nbsp;Pythonu se (vedle zavedeného slova
<strong>yield</strong>) nově používají dvě slova <strong>async</strong> a
<strong>await</strong>, přičemž <strong>async</strong> je klíčové slovo
umožňující transformaci funkce do korutiny a <strong>await</strong> je klíčové
slovo pro čekání na dokončení korutiny se získáním její návratové hodnoty.</p>

<p>I pro předávání dat mezi korutinami lze využít frontu, v&nbsp;tomto případě
se ovšem jedná o instanci třídy <strong>asyncio.Queue</strong>. Všechny operace
s&nbsp;touto frontou (tedy zejména operace <strong>put</strong> a
<strong>get</strong>) se musí volat v&nbsp;konstrukci <strong>await</strong>,
což je ukázáno v&nbsp;dalším demonstračním příkladu.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Přepis programu takovým způsobem, aby se používaly asynchronně běžící úlohy</h2>

<p>Jak bude vypadat přepis našeho programu s&nbsp;několika workery tak, aby
byly jednotlivé úlohy prováděny asynchronně? Samotná implementace workerů
vyžaduje asynchronní kód (<strong>async def</strong>) a čtení z&nbsp;fronty
tudíž bude obsahovat synchronizaci (<strong>await</strong>. Implementace může
vypadat následovně:</p>

<pre>
async def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát asynchronně."""</i>
    while not q.empty():
        <i># čtení příkazů z fronty</i>
        cmd = await q.get()
        print(f"Task '{name}' received command '{cmd}'")
        await sleep(1)
</pre>

<p><div class="rs-tip-major">Poznámka: worker skončí ve chvíli, kdy bude fronta
prázdná, což není zcela přesná analogie k&nbsp;předchozím příkladům!</div></p>

<p>Volání workerů je prováděno asynchronně a z&nbsp;tohoto důvodu Python
vyžaduje, aby toto volání bylo prováděno z&nbsp;asynchronní funkce:</p>

<pre>
async def <strong>main</strong>():
    ...
    ...
    ...
</pre>

<p>Připravíme si jednotlivé úlohy a vložíme je do fronty:</p>

<pre>
    <i># komunikace s úlohami přes frontu</i>
    for i in range(10):
        print(f"Sending 'command {i}'")
        await queue.put("command {}".format(i))
</pre>

<p>Následně spustíme tři workery, pochopitelně formou asynchronního kódu:</p>

<pre>
    await gather(
        create_task(worker("foo", queue)),
        create_task(worker("bar", queue)),
        create_task(worker("baz", queue)),
    )
</pre>

<p>Úplný zdrojový kód takto upraveného programu bude vypadat následovně:</p>

<pre>
<i># Multiprocesing a multithreading v Pythonu:</i>
<i># - spuštění více úloh asynchronně</i>
<i># - komunikace mezi procesy s využitím fronty</i>
&nbsp;
from asyncio import Queue, sleep, run, gather, create_task
&nbsp;
&nbsp;
async def <strong>worker</strong>(name, q):
    <i>"""Worker spuštěný několikrát asynchronně."""</i>
    while not q.empty():
        <i># čtení příkazů z fronty</i>
        cmd = await q.get()
        print(f"Task '{name}' received command '{cmd}'")
        await sleep(1)
&nbsp;
&nbsp;
async def <strong>main</strong>():
    print("Starting")
&nbsp;
    <i># vytvoření fronty pro komunikaci mezi úlohami</i>
    queue = Queue()
&nbsp;
    print("Sending data to async tasks")
&nbsp;
    <i># komunikace s úlohami přes frontu</i>
    for i in range(10):
        print(f"Sending 'command {i}'")
        await queue.put("command {}".format(i))
&nbsp;
    print("Waiting for all tasks")
&nbsp;
    await gather(
        create_task(worker("foo", queue)),
        create_task(worker("bar", queue)),
        create_task(worker("baz", queue)),
    )
&nbsp;
    print("All work done!")
&nbsp;
&nbsp;
run(main())
</pre>

<p><div class="rs-tip-major">Poznámka: úprava pro zpracování speciálních úloh
typu <strong>quit</strong> je již snadná, ovšem vyžaduje úpravy jak na straně
workerů, tak i na straně kódu, který úlohy vytváří.</div></p>

<p>A takto může vypadat chování programu po jeho spuštění (používám Python bez
GILu, to však nemusí mít na pořadí spouštění příkazů žádný zvenku viditelný
vliv):</p>

<pre>
Starting
Sending data to async tasks
Sending 'command 0'
Sending 'command 1'
Sending 'command 2'
Sending 'command 3'
Sending 'command 4'
Sending 'command 5'
Sending 'command 6'
Sending 'command 7'
Sending 'command 8'
Sending 'command 9'
Waiting for all tasks
Task 'foo' received command 'command 0'
Task 'bar' received command 'command 1'
Task 'baz' received command 'command 2'
Task 'foo' received command 'command 3'
Task 'bar' received command 'command 4'
Task 'baz' received command 'command 5'
Task 'foo' received command 'command 6'
Task 'bar' received command 'command 7'
Task 'baz' received command 'command 8'
Task 'foo' received command 'command 9'
All work done!
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Shrnutí</h2>

<p>Možnost spouštění úloh v&nbsp;samostatných a do značné míry izolovaných
interpretrech může být velmi užitečná a současně se jedná o technologii, která
doplňuje existující sadu tří technologií určených pro souběžné provádění úloh:
asynchronní kód, multithreading a multiprocesing. Při použití interpretrů
dosáhneme větší izolace kódu, než tomu je u multithreadingu, ovšem nároky na
systémové zdroje budou obecně menší, než při multiprocesingu (to však musíme
dokázat měřením). Ovšem důležité je, že pokud je vyžadováno, aby mezi sebou
jednotlivé úlohy komunikovaly, použije se ve všech čtyřech řešeních podobná
technika &ndash; fronta se synchronizovanými (a obecně blokujícími) operacemi
<strong>put</strong> a <strong>get</strong>. Na demonstračních příkladech jsme
si navíc ukázali, že i zdrojové kódy budou do značné míry totožné (až na
asynchronní kód), takže přechod mezi různými stupni izolace a paralelnosti
nemusí být v&nbsp;praxi příliš komplikovaný (pokud ovšem dodržíme fakt, že
úlohy mezi sebou striktně komunikují jen s&nbsp;využitím front).</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</h2>

<p>Na stránkách <a href="https://www.root.cz">Roota</a> jsme se již několikrát
setkali s&nbsp;problematikou souběžnosti, paralelnosti a asynchronního běhu
v&nbsp;Pythonu. Různé varianty spouštění a řízení více vláken, procesů a
asynchronních úloh naleznete v&nbsp;následujících článcích (všechny
v&nbsp;článcích uvedené demonstrační příklady by měly být spustitelné i
v&nbsp;interpretru Pythonu 3.14 bez GILu):</p>

<ol>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – Curio a Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – závěrečné zhodnocení<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/</a>
</li>

<li>Interpret Pythonu bez GILu: vyplatí se odstranění velkého zámku?<br />
<a href="https://www.root.cz/clanky/interpret-pythonu-bez-gilu-vyplati-se-odstraneni-velkeho-zamku/">https://www.root.cz/clanky/interpret-pythonu-bez-gilu-vyplati-se-odstraneni-velkeho-zamku/</a>
</li>

<li>Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: vliv odstranění GIL a využití více interpretrů<br />
<a href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, které byly popsány v&nbsp;dnešním článku,
naleznete na adresách:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td>1</td><td>interpreters/queue-interpreters-1.py</td><td>poslání zprávy mezi úlohami, které běží v&nbsp;různých interpretrech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-1.py</a></td></tr>
<tr><td>2</td><td>interpreters/queue-interpreters-2.py</td><td>realizace programu pro zpracování úloh v&nbsp;samostatně běžících interpretrech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-interpreters-2.py</a></td></tr>
<tr><td>3</td><td>interpreters/queue-async.py</td><td>plně asynchronní volání úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-async.py</a></td></tr>
<tr><td>4</td><td>interpreters/queue-multiprocessing.py</td><td>poslání zprávy mezi úlohami, které běží v&nbsp;různých procesech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multiprocessing.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multiprocessing.py</a></td></tr>
<tr><td>5</td><td>interpreters/queue-multithreading-1.py</td><td>poslání zprávy mezi úlohami, které běží v&nbsp;různých vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-1.py</a></td></tr>
<tr><td>6</td><td>interpreters/queue-multithreading-2.py</td><td>poslání zprávy mezi úlohami, které běží v&nbsp;různých vláknech, odlišné čekání na dokončení úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-2.py</a></td></tr>
<tr><td>7</td><td>interpreters/queue-multithreading-3.py</td><td>varianta s&nbsp;několika producenty a několika konzumenty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/queue-multithreading-3.py</a></td></tr>
</table>

<p>Všechny <a
href="https://www.root.cz/clanky/nove-vlastnosti-pythonu-3-14-v-praxi-vliv-odstraneni-gil-a-vyuziti-vice-interpretru/">minule</a>
popsané demonstrační příklady jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td> 1</td><td>bubble-sort/bubble_sort_seq.py</td><td>benchmark provádějící sekvenční volání algoritmu pro bublinkové řazení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_seq.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_seq.py</a></td></tr>
<tr><td> 2</td><td>bubble-sort/bubble_sort_parallel.py</td><td>benchmark provádějící souběžné volání algoritmu pro bublinkové řazení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_parallel.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_parallel.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>julia-renderer/julia_seq_anim.py</td><td>sekvenční výpočet animace Juliových množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_seq_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_seq_anim.py</a></td></tr>
<tr><td> 4</td><td>julia-renderer/julia_parallel_anim.py</td><td>souběžný popř.&nbsp;paralelní výpočet animace Juliových množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_parallel_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_parallel_anim.py</a></td></tr>
<tr><td> 5</td><td>julia-renderer/palette_mandmap.py</td><td>pomocný soubor s&nbsp;barvovou mapou použitý dvěma předchozími benchmarky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/palette_mandmap.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>interpreters/list-interpreters.py</td><td>výpis seznamu inicializovaných interpretrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/list-interpreters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/list-interpreters.py</a></td></tr>
<tr><td> 7</td><td>interpreters/new-interpreter.py</td><td>konstrukce nového interpretru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/new-interpreter.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/new-interpreter.py</a></td></tr>
<tr><td> 8</td><td>interpreters/exec.py</td><td>zavolání funkce ve zvoleném interpretru (ve stejném vlákně)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/exec.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/exec.py</a></td></tr>
<tr><td> 9</td><td>interpreters/call_in_thread.py</td><td>zavolání funkce ve zvoleném interpretru (v&nbsp;novém vlákně)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/call_in_thread.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/call_in_thread.py</a></td></tr>
<tr><td>10</td><td>interpreters/shared-variables.py</td><td>jsou proměnné sdíleny mezi interpretry?</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/shared-variables.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/shared-variables.py</a></td></tr>
<tr><td>11</td><td>interpreters/behaviour_exec.py</td><td>chování dvou interpretrů v&nbsp;čase běhu (metoda <strong>exec</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_exec.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_exec.py</a></td></tr>
<tr><td>12</td><td>interpreters/behaviour_call_in_thread.py</td><td>chování dvou interpretrů v&nbsp;čase běhu (metoda <strong>call_in_thread</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_call_in_thread.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_call_in_thread.py</a></td></tr>
<tr><td>13</td><td>interpreters/interpreter_exception_1.py </td><td>chování interpretrů při vyhození nezachycené výjimky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_1.py</a></td></tr>
<tr><td>14</td><td>interpreters/interpreter_exception_2.py </td><td>chování interpretrů při vyhození nezachycené výjimky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_2.py</a></td></tr>
</table>

<p>Demonstrační příklady vytvořené pro Python verze 3.14 a popsané
v&nbsp;prvním článku najdete v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs/">https://github.com/tisnik/most-popular-python-libs/</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>argparse_test.py</td><td>skript s&nbsp;definicí přepínačů použitelných na příkazovém řádku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/argparse_test.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/argparse_test.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>syntax_error_1.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_1.py</a></td></tr>
<tr><td> 2</td><td>syntax_error_2.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_2.py</a></td></tr>
<tr><td> 3</td><td>syntax_error_3.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_3.py</a></td></tr>
<tr><td> 4</td><td>syntax_error_4.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_4.py</a></td></tr>
<tr><td> 5</td><td>syntax_error_5.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>primes.py</td><td>realizace výpočtu prvočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/primes.py</a></td></tr>
<tr><td> 7</td><td>test_primes.py</td><td>jednotkové testy pro modul <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/test_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/test_primes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>pep-758-motivation-1.py</td><td>zachycení většího množství výjimek v&nbsp;bloku <strong>except</strong> &ndash; motivační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-1.py</a></td></tr>
<tr><td> 9</td><td>pep-758-motivation-2.py</td><td>zachycení většího množství výjimek v&nbsp;bloku <strong>except</strong> &ndash; motivační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-2.py</a></td></tr>
<tr><td>10</td><td>pep-758-usage.py</td><td>nový způsob zachycení výjimek definovaný v&nbsp;PEP-758</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage.py</a></td></tr>
<tr><td>11</td><td>pep-758-usage-as.py</td><td>klauzule <strong>as</strong> a nový způsob zachycení výjimek definovaný v&nbsp;PEP-758</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage-as.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage-as.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>pep-765-motivation-1.py</td><td>detekce opuštění bloku <strong>finally</strong>, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-1.py</a></td></tr>
<tr><td>13</td><td>pep-765-motivation-2.py</td><td>detekce opuštění bloku <strong>finally</strong>, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-2.py</a></td></tr>
<tr><td>14</td><td>pep-765-motivation-3.py</td><td>detekce opuštění bloku <strong>finally</strong>, třetí demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-3.py</a></td></tr>
<tr><td>15</td><td>pep-765-motivation-4.py</td><td>detekce opuštění bloku <strong>finally</strong>, čtvrtý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>f-string-1.py</td><td>rozdíl mezi f-řetězci a t-řetězci, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-1.py</a></td></tr>
<tr><td>17</td><td>t-string-1.py</td><td>rozdíl mezi f-řetězci a t-řetězci, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-1.py</a></td></tr>
<tr><td>18</td><td>f-string-2.py</td><td>rozdíl mezi f-řetězci a t-řetězci, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-2.py</a></td></tr>
<tr><td>19</td><td>t-string-2.py</td><td>rozdíl mezi f-řetězci a t-řetězci, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python 3.14.0<br />
<a href="https://test.python.org/downloads/release/python-3140/">https://test.python.org/downloads/release/python-3140/</a>
</li>

<li>PEP 765 – Disallow return/break/continue that exit a finally block<br />
<a href="https://peps.python.org/pep-0765/">https://peps.python.org/pep-0765/</a>
</li>

<li>PEP 758 – Allow except and except* expressions without parentheses<br />
<a href="https://peps.python.org/pep-0758/">https://peps.python.org/pep-0758/</a>
</li>

<li>What’s new in Python 3.14 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.14.html">https://docs.python.org/3/whatsnew/3.14.html</a>
</li>

<li>What’s New In Python 3.13 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.13.html">https://docs.python.org/3/whatsnew/3.13.html</a>
</li>

<li>What’s New In Python 3.12 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.12.html">https://docs.python.org/3/whatsnew/3.12.html</a>
</li>

<li>What’s New In Python 3.11 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.11.html">https://docs.python.org/3/whatsnew/3.11.html</a>
</li>

<li>What’s New In Python 3.12<br />
<a href="https://dev.to/mahiuddindev/python-312-4n43">https://dev.to/mahiuddindev/python-312-4n43</a></li>

<li>PEP 698 – Override Decorator for Static Typing<br />
<a href="https://peps.python.org/pep-0698/">https://peps.python.org/pep-0698/</a>
</li>

<li>PEP 484 -- Type Hints<br />
<a href="https://www.python.org/dev/peps/pep-0484/">https://www.python.org/dev/peps/pep-0484/</a>
</li>

<li>What’s New In Python 3.5<br />
<a href="https://docs.python.org/3.5/whatsnew/3.5.html">https://docs.python.org/3.5/whatsnew/3.5.html</a>
</li>

<li>26.1. typing — Support for type hints<br />
<a href="https://docs.python.org/3.5/library/typing.html#module-typing">https://docs.python.org/3.5/library/typing.html#module-typing</a>
</li>

<li>Type Hints - Guido van Rossum - PyCon 2015 (youtube)<br />
<a href="https://www.youtube.com/watch?v=2wDvzy6Hgxg">https://www.youtube.com/watch?v=2wDvzy6Hgxg</a>
</li>

<li>Python 3.5 is on its way<br />
<a href="https://lwn.net/Articles/650904/">https://lwn.net/Articles/650904/</a>
</li>

<li>Type hints<br />
<a href="https://lwn.net/Articles/640359/">https://lwn.net/Articles/640359/</a>
</li>

<li>Stránka projektu PDM<br />
<a href="https://pdm.fming.dev/latest/">https://pdm.fming.dev/latest/</a>
</li>

<li>PDF na GitHubu<br />
<a href="https://github.com/pdm-project/pdm">https://github.com/pdm-project/pdm</a>
</li>

<li>PEP 582 &ndash; Python local packages directory<br />
<a href="https://peps.python.org/pep-0582/">https://peps.python.org/pep-0582/</a>
</li>

<li>PDM na PyPi<br />
<a href="https://pypi.org/project/pdm/">https://pypi.org/project/pdm/</a>
</li>

<li>Which Python package manager should you use?<br />
<a href="https://towardsdatascience.com/which-python-package-manager-should-you-use-d0fd0789a250">https://towardsdatascience.com/which-python-package-manager-should-you-use-d0fd0789a250</a>
</li>

<li>How to Use PDM to Manage Python Dependencies without a Virtual Environment<br />
<a href="https://www.youtube.com/watch?v=qOIWNSTYfcc">https://www.youtube.com/watch?v=qOIWNSTYfcc</a>
</li>

<li>What are the best Python package managers?<br />
<a href="https://www.slant.co/topics/2666/~best-python-package-managers">https://www.slant.co/topics/2666/~best-python-package-managers</a>
</li>

<li>PEP 621 &ndash; Storing project metadata in pyproject.toml<br />
<a href="https://peps.python.org/pep-0621/">https://peps.python.org/pep-0621/</a>
</li>

<li>Pick a Python Lockfile and Improve Security<br />
<a href="https://blog.phylum.io/pick-a-python-lockfile-and-improve-security/">https://blog.phylum.io/pick-a-python-lockfile-and-improve-security/</a>
</li>

<li>PyPA specifications<br />
<a href="https://packaging.python.org/en/latest/specifications/">https://packaging.python.org/en/latest/specifications/</a>
</li>

<li>Creation of virtual environments<br />
<a href="https://docs.python.org/3/library/venv.html">https://docs.python.org/3/library/venv.html</a>
</a>

<li>How to Use virtualenv in Python<br />
<a href="https://learnpython.com/blog/how-to-use-virtualenv-python/">https://learnpython.com/blog/how-to-use-virtualenv-python/</a>
</a>

<li>Python Virtual Environments: A Primer<br />
<a href="https://realpython.com/python-virtual-environments-a-primer/">https://realpython.com/python-virtual-environments-a-primer/</a>
</a>

<li>virtualenv Cheatsheet<br />
<a href="https://aaronlelevier.github.io/virtualenv-cheatsheet/">https://aaronlelevier.github.io/virtualenv-cheatsheet/</a>
</a>

<li>Installing Python Modules<br />
<a href="https://docs.python.org/3/installing/index.html">https://docs.python.org/3/installing/index.html</a>
</a>

<li>Python: The Documentary | An origin story<br />
<a href="https://www.youtube.com/watch?v=GfH4QL4VqJ0">https://www.youtube.com/watch?v=GfH4QL4VqJ0</a>
</li>

<li>History of Python<br />
<a href="https://en.wikipedia.org/wiki/History_of_Python">https://en.wikipedia.org/wiki/History_of_Python</a>
</li>

<li>History of Python<br />
<a href="https://www.geeksforgeeks.org/python/history-of-python/">https://www.geeksforgeeks.org/python/history-of-python/</a>
</li>

<li>IPython: jedno z nejpropracovanějších interaktivních prostředí pro práci s&nbsp;Pythonem<br />
<a href="https://www.root.cz/clanky/ipython-jedno-z-nejpropracova-nejsich-interaktivnich-prostredi-pro-praci-s-pythonem/">https://www.root.cz/clanky/ipython-jedno-z-nejpropracova-nejsich-interaktivnich-prostredi-pro-praci-s-pythonem/</a>
</li>

<li>Další kulaté výročí v IT: dvacet let existence Pythonu 2<br />
<a href="https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/">https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/</a>
</li>

<li>PEP 684 – A Per-Interpreter GIL<br />
<a href="https://peps.python.org/pep-0684/">https://peps.python.org/pep-0684/</a>
</li>

<li>What Is the Python Global Interpreter Lock (GIL)?<br />
<a href="https://realpython.com/python-gil/">https://realpython.com/python-gil/</a>
</li>

<li>PEP 703 – Making the Global Interpreter Lock Optional in CPython<br />
<a href="https://peps.python.org/pep-0703/">https://peps.python.org/pep-0703/</a>
</li>

<li>GlobalInterpreterLock<br />
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>
</li>

<li>What is the Python Global Interpreter Lock (GIL)<br />
<a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/">https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/</a>
</li>

<li>Let's remove the Global Interpreter Lock<br />
<a href="https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html">https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html</a>
</li>

<li>Global interpreter lock<br />
<a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">https://en.wikipedia.org/wiki/Global_interpreter_lock</a>
</li>

<li>Rychlost CPythonu 3.11 a 3.12 v&nbsp;porovnání s JIT a AOT překladači<br />
<a href="https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/">https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/</a>
</li>

<li>Dokumentace Pythonu: balíček queue<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Dokumentace Pythonu: balíček threading<br />
<a href="https://docs.python.org/3/library/threading.html?">https://docs.python.org/3/library/threading.html?</a>
</li>

<li>Dokumentace Pythonu: balíček multiprocessing<br />
<a href="https://docs.python.org/3/library/multiprocessing.html">https://docs.python.org/3/library/multiprocessing.html</a>
</li>

<li>Dokumentace Pythonu: balíček asyncio<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Synchronization Primitives<br />
<a href="https://docs.python.org/3/library/asyncio-sync.html">https://docs.python.org/3/library/asyncio-sync.html</a>
</li>

<li>Coroutines<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Queues<br />
<a href="https://docs.python.org/3/library/asyncio-queue.html">https://docs.python.org/3/library/asyncio-queue.html</a>
</li>

<li>python-csp<br />
<a href="https://python-csp.readthedocs.io/en/latest/">https://python-csp.readthedocs.io/en/latest/</a>
</li>

<li>TrellisSTM<br />
<a href="http://peak.telecommunity.com/DevCenter/TrellisSTM">http://peak.telecommunity.com/DevCenter/TrellisSTM</a>
</li>

<li>Python Multithreading and Multiprocessing Tutorial<br />
<a href="https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python">https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

