<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovatelné IO na mikrořadičích RP2040 - praktické použití</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovatelné IO na mikrořadičích RP2040 - praktické použití</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní článek o programování PIO na mikrořadičích Raspberry Pi Pico dnes navážeme. Pokusíme se propojit znalosti o PIO (interní architektura, způsob propojení s mikrořadičem i s GPIO, instrukční soubor) s vlastnostmi MicroPythonu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovatelné IO na mikrořadičích RP2040 &ndash; praktické použití</a></p>
<p><a href="#k02">2. Získání MicroPythonu pro konkrétní verzi Rapberry Pi Pica</a></p>
<p><a href="#k03">3. Instalace MicroPythonu</a></p>
<p><a href="#k04">4. Spuštění interaktivní smyčky s&nbsp;MicroPythonem na Raspberry Pi Pico</a></p>
<p><a href="#k05">5. Připojení k&nbsp;Raspberry Pi Pico bez administrátorských práv</a></p>
<p><a href="#k06">6. Zjištění základních vlastností Raspberry Pi Pico z&nbsp;MicroPythonu</a></p>
<p><a href="#k07">7. Třída používaná pro ovládání stavových strojů PIO</a></p>
<p><a href="#k08">8. Tvorba programu pro PIO (stavový stroj)</a></p>
<p><a href="#k09">9. Pseudofunkce Pythonu určené pro naprogramování stavového stroje</a></p>
<p><a href="#k10">10. Specifikace počtu zpožďovacích cyklů</a></p>
<p><a href="#k11">11. Realizace skoků v&nbsp;PIO</a></p>
<p><a href="#k12">12. Typický první ukázkový příklad při programování MCU: blikání LED</a></p>
<p><a href="#k13">13. Naprogramování a načasování PIO pro blikání LED</a></p>
<p><a href="#k14">14. Naprogramování funkce s&nbsp;ovládáním LED přes PIO</a></p>
<p><a href="#k15">15. Ověření délky trvání jedné iterace PIO programu</a></p>
<p><a href="#k16">16. Konstrukce a spuštění stavového stroje</a></p>
<p><a href="#k17">17. Shrnutí</a></p>
<p><a href="#k18">18. Příloha: dekorátory v&nbsp;jazyce Python</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovatelné IO na mikrořadičích RP2040 &ndash; praktické použití</h2>

<p>Na <a
href="https://www.root.cz/clanky/programovatelne-io-na-mikroradicich-rp2040-v-raspberry-pi-pico/">úvodní
článek o programování PIO</a> na mikrořadičích Raspberry Pi Pico dnes navážeme.
Pokusíme se propojit znalosti o PIO (interní architektura, propojení
s&nbsp;mikrořadičem i s&nbsp;GPIO, instrukční soubor) s&nbsp;vlastnostmi
MicroPythonu. Varianta interpretru MicroPythonu určená pro Raspberry Pi Pico
totiž podporuje naprogramování a přímé řízení subsystému PIO, a to bez nutnosti
používat další nástroje (PIO assembler atd.). To nám umožní zkombinovat
možnosti poskytované vysokoúrovňovým programovacím jazykem se subsystémem PIO,
což je vlastně subsystém bežící v&nbsp;reálném čase &ndash; instrukce můžeme
načasovat přesně na jednotlivé cykly (a to může být velmi výhodné &ndash;
nemusíme používat HW časovače ani čítače).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Získání MicroPythonu pro konkrétní verzi Rapberry Pi Pica</h2>

<p>Prvním krokem, který musíme udělat, je získání MicroPythonu určeného pro
konkrétní verzi Raspberry Pi Pico, kterou provozujete. Pokud tedy máte
k&nbsp;dispozici původní Raspberry Pi Pico (1) bez Wifi modulu, použije se
odlišný soubor, než u Raspberry Pi Pico W (s&nbsp;Wifi modulem) nebo u
Raspberry Pi Pico 2. MicroPython pro všechny čtyři dnes dostupné varianty RPi
Pico naleznete na stránce <a
href="https://www.raspberrypi.com/documentation/microcontrollers/micropython.html">https://www.raspberrypi.com/documentation/microcontrollers/micropython.html</a>,
odkud si je můžete stáhnout. Nebo je možné použít tyto přímé odkazy:</p>

<ul>
<li><a href="https://micropython.org/download/rp2-pico/rp2-pico-latest.uf2">https://micropython.org/download/rp2-pico/rp2-pico-latest.uf2</a></li>
<li><a href="https://micropython.org/download/rp2-pico-w/rp2-pico-w-latest.uf2">https://micropython.org/download/rp2-pico-w/rp2-pico-w-latest.uf2</a></li>
<li><a href="https://micropython.org/download/RPI_PICO2/RPI_PICO2-latest.uf2">https://micropython.org/download/RPI_PICO2/RPI_PICO2-latest.uf2</a></li>
<li><a href="https://downloads.raspberrypi.com/micropython/mp_firmware_unofficial_latest.uf2">https://downloads.raspberrypi.com/micropython/mp_firmware_unofficial_latest.uf2</a></li>
</ul>

<p><div class="rs-tip-major">Poznámka: proč se jednotlivé adresy od sebe tak
odlišují, je mi záhadou.</div></p>

<p>Ukažme si konkrétní příklad. Budu stahovat MicroPython přeložený pro
variantu Raspberry Pico W:</p>

<pre>
$ <strong>wget https://micropython.org/download/rp2-pico-w/rp2-pico-w-latest.uf2</strong>
&nbsp;
HTTP response 302  [https://micropython.org/download/rp2-pico-w/rp2-pico-w-latest.uf2]
Adding URL: https://micropython.org/download/RPI_PICO_W/RPI_PICO_W-latest.uf2
Saving 'rp2-pico-w-latest.uf2'
HTTP response 200  [https://micropython.org/download/RPI_PICO_W/RPI_PICO_W-latest.uf2]
rp2-pico-w-latest.uf 100% [=====================================================================================>]    1.64M    --.-KB/s
                          [Files: 1  Bytes: 1.64M [2.74MB/s] Redirects: 1  Todo: 0  Errors: 0                    ]
</pre>

<p>Tímto příkazem získáme soubor o velikosti přibližně 1,7 MB:</p>

<pre>
$ <strong>ls -l rp2-pico-w-latest.uf2 </strong>
&nbsp;
-rw-r--r--. 1 ptisnovs ptisnovs 1727488 Nov 29 17:45 rp2-pico-w-latest.uf2
</pre>

<p><div class="rs-tip-major">Poznámka: kapacita Flash paměti u první verze
Raspberry Pi Pica je 2MB, kterou tento soubor nepřesahuje.</div></p>

<p>Pro jistotu si nechte vypočítat otisk (hash) staženého souboru a
zkontrolujte ho vůči vytištěné hodnotě:</p>

<pre>
$ <strong>sha256sum rp2-pico-w-latest.uf2</strong>
&nbsp;
bf869821b59a13de3f7fa0c3cc1592f9af4bd41ce571d919c2577d47b6ce540e  rp2-pico-w-latest.uf2
</pre>

<p>V&nbsp;případě, že si MicroPython stáhnete z&nbsp;výše uvedené stránky <a
href="https://www.raspberrypi.com/documentation/microcontrollers/micropython.html">https://www.raspberrypi.com/documentation/microcontrollers/micropython.html</a>,
bude mít soubor odlišné jméno, ovšem naprosto stejný otisk (a pochopitelně i
shodnou velikost):</p>

<pre>
$ <strong>sha256sum RPI_PICO_W-20241129-v1.24.1.uf2</strong>
&nbsp;
bf869821b59a13de3f7fa0c3cc1592f9af4bd41ce571d919c2577d47b6ce540e  RPI_PICO_W-20241129-v1.24.1.uf2
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace MicroPythonu</h2>

<p>Vlastní instalace MicroPythonu na Raspberry Pi Pico je snadná. Tyto
mikropočítače totiž mohou být připojeny přes USB k&nbsp;počítači/notebooku,
přičemž USB může pracovat v&nbsp;několika režimech. Výchozí režim je založený
na protokolu USB mass storage. V&nbsp;tomto režimu, který se nazývá
<i>bootloader mode</i>, je možné do Raspeberry Pi Pico přesunovat soubory
naprosto stejným způsobem, jakoby se jednalo o běžné paměťové zařízení
připojené k&nbsp;USB (Flash disk, pevný disk, paměť fotoaparátu atd. atd.).
Ihned po přesunu souboru s&nbsp;koncovkou <strong>.uf2</strong> (a takovou
koncovku má i soubor s&nbsp;MicroPythonem) se Raspberry Pi Pico od počítače
odpojí a jeho USB se přepne do režimu emulujícího sériové rozhraní (to
použijeme v&nbsp;dalších kapitolách).</p>

<a href="https://www.root.cz/obrazek/1171821/"><img src="https://i.iinfo.cz/images/601/micropython-pio-1-prev.webp" class="image-1171821" width="287" height="270" data-prev-filename="https://i.iinfo.cz/images/601/micropython-pio-1-prev.webp" data-prev-width="287" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/601/micropython-pio-1-large.webp" data-large-width="559" data-large-height="525" alt="&#160;" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 1: Raspberry Pi Pico v&nbsp;režimu USB Mass Storage.</i></p>

<p><div class="rs-tip-major">Poznámka: režim <i>bootloader</i> si lze kdykoli
později &bdquo;vynutit&ldquo; stiskem tlačítka BOOTSEL (jedná se o jediné
tlačítko, které je na Picu nainstalováno) při připojení Raspberry Pi Pica
k&nbsp;počítači přes USB. Tímto způsobem je možné například nahrát novou verzi
MicroPythonu, vyzkoušet si CircuitPython, nahrát vlastní program přeložený
z&nbsp;céčka, Rustu atd.</div></p>

<a href="https://www.root.cz/obrazek/1171824/"><img src="https://i.iinfo.cz/images/601/micropython-pio-2-prev.webp" class="image-1171824" width="287" height="270" data-prev-filename="https://i.iinfo.cz/images/601/micropython-pio-2-prev.webp" data-prev-width="287" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/601/micropython-pio-2-large.webp" data-large-width="559" data-large-height="525" alt="&#160;" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 2: Raspberry Pi Pico po přenosu MicroPythonu a odpojení USB Mass
Storage.</i></p>

<p>Seznam USB zařízení si můžete kdykoli vypsat příkazem <strong>lsusb</strong>:</p>

<pre>
$ <strong>lsusb</strong>
&nbsp;
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 003 Device 002: ID 06cb:00f9 Synaptics, Inc. 
Bus 003 Device 003: ID 04f2:b74f Chicony Electronics Co., Ltd Integrated Camera
Bus 003 Device 004: ID 8087:0033 Intel Corp. AX211 Bluetooth
<u>Bus 003 Device 010: ID 2e8a:0005 MicroPython Board in FS mode</u>
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
</pre>

<p>Podrobnější informace by bylo možné v&nbsp;tomto konkrétním případě získat
příkazem:</p>

<pre>
$ <strong>lsusb -D /dev/bus/usb/003/010</strong>
</pre>

<p>kde 003 je číslo sběrnice a 010 číslo zařízení z&nbsp;předchozího
výpisu.</p>

<p>Výpis by měl začínat takto:</p>

<pre>
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass          239 Miscellaneous Device
  bDeviceSubClass         2 [unknown]
  bDeviceProtocol         1 Interface Association
  bMaxPacketSize0        64
  idVendor           0x2e8a MicroPython
  idProduct          0x0005 Board in FS mode
  bcdDevice            1.00
  iManufacturer           1 MicroPython
  iProduct                2 Board in FS mode
  iSerial                 3 e6616408434bbc2e
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Spuštění interaktivní smyčky s&nbsp;MicroPythonem na Raspberry Pi Pico</h2>

<p>MicroPython je, podobně jako klasický Python, vybaven interaktivní smyčkou
REPL, což znamená, že interpret Pythonu očekává příkazy, které se ihned
vykonají. Ovšem jak ovládat interpret, který běží na Raspberry Pi Pico? Budeme
se k&nbsp;němu muset připojit, a to konkrétně s&nbsp;využitím protokolu, který
se chová podobně jako vysokorychlostní sériová linka. Budeme tedy muset použít
libovolnou aplikaci umožňující připojení a komunikaci přes sériovou linku. Pro
jednoduchost použiji <strong>minicom</strong>, což je letitý, ale stále velmi
dobře použitelný program.</p>

<p><div class="rs-tip-major">Poznámka: jedná se o jedinou aplikaci, kterou
budeme muset nainstalovat. Pro programování Raspberry Pi Pica není (na straně
počítače) nutné nic dalšího &ndash; žádný assembler ani překladač, žádné
integrované vývojové prostředí a ani žádný debugger (pokud pochopitelně
nebudeme tvořit komplikovanější programy).</div></p>

<p>Před připojením Raspberry Pi Pico k&nbsp;počítači si nejprve spusťte nástroj
<strong>dmesg</strong> (bude vyžadovat práva administrátora). Po připojení
Raspberry Pi Pica by se měly vypsat přibližně následující zprávy, přičemž
důležitý je údaj z&nbsp;posledního řádku (zde je podtržený):</p>

<pre>
[1444104.506249] usb 3-7: new full-speed USB device number 63 using xhci_hcd
[1444104.633015] usb 3-7: New USB device found, idVendor=2e8a, idProduct=0005, bcdDevice= 1.00
[1444104.633032] usb 3-7: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[1444104.633038] usb 3-7: Product: Board in FS mode
[1444104.633042] usb 3-7: Manufacturer: MicroPython
[1444104.633045] usb 3-7: SerialNumber: e661640843610b2c
[1444104.638506] cdc_acm 3-7:1.0: <u>ttyACM0</u>: USB ACM device
</pre>

<p>Vidíme, že na tomto konkrétním počítači a systému je připojené Raspberry Pi
Pico dostupné (v&nbsp;režimu sériové linky) přes zařízení nazvané
<strong>ttyACM0</strong>. To se ovšem může na různých počítačích/systémech
lišit (a proto potřebujeme <strong>dmesg</strong>).</p>

<p>Připojení k&nbsp;MicroPythonu provedeme příkazem:</p>

<pre>
$ <strong>sudo minicom -D /dev/ttyACM0</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: pokud se ve vašem případě vytvořilo
odlišné zařízení, samozřejmě bude nutné použít jeho název. Cesta však bude
stejná, tj.&nbsp;<strong>/dev/název_tty_zařízení</strong> (<strong>tty</strong>
je odvozeno od slova <i>teletype</i> neboli dálnopis).</div></p>

<p>Spojení by mělo být navázáno a objevit by se měla obrazovka
s&nbsp;následujícími údaji:</p>

<pre>
Welcome to minicom 2.8
&nbsp;
OPTIONS: I18n 
Compiled on Jan 25 2024, 00:00:00.
Port /dev/ttyACM0, 11:48:15
&nbsp;
Press CTRL-A Z for help on special keys
&nbsp;
MicroPython v1.24.1 on 2024-11-29; Raspberry Pi Pico W with RP2040
Type "help()" for more information.
&gt;&gt;&gt;
</pre>

<p>Nyní již můžeme s&nbsp;MicroPythonem komunikovat, což si ihned
vyzkoušíme:</p>

<pre>
&gt;&gt;&gt; <strong>help()</strong>
</pre>

<p>Vypsat by se mělo:</p>

<pre>
Welcome to MicroPython!
&nbsp;
For online docs please visit http://docs.micropython.org/
&nbsp;
For access to the hardware use the 'machine' module.  RP2 specific commands
are in the 'rp2' module.
&nbsp;
Quick overview of some objects:
  machine.Pin(pin) -- get a pin, eg machine.Pin(0)
  machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p
    methods: init(..), value([v]), high(), low(), irq(handler)
  machine.ADC(pin) -- make an analog object from a pin
    methods: read_u16()
  machine.PWM(pin) -- make a PWM object from a pin
    methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d])
  machine.I2C(id) -- create an I2C object (id=0,1)
    methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True)
             readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg)
  machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1)
    methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf)
  machine.Timer(freq, callback) -- create a software timer object
    eg: machine.Timer(freq=1, callback=lambda t:print(t))
&nbsp;
Pins are numbered 0-29, and 26-29 have ADC capabilities
Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT
Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN
&nbsp;
Useful control commands:
  CTRL-C -- interrupt a running program
  CTRL-D -- on a blank line, do a soft reset of the board
  CTRL-E -- on a blank line, enter paste mode
&nbsp;
For further help on a specific object, type help(obj)
For a list of available modules, type help('modules')
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Připojení k&nbsp;Raspberry Pi Pico bez administrátorských práv</h2>

<p>Většinou je nutné se k&nbsp;Raspberry Pi Pico připojit aplikací
<strong>minicom</strong>, která má přiřazená administrátorská práva
(<strong>sudo minicom</strong>). To však není ideální řešení, takže se
podívejme, jak lze operační systém nastavit tak, aby tato práva nebyla
vyžadována. Nejprve si (při připojeném Pi Pico) necháme vypsat vlastníka a
skupinu zařízení, které realizuje sériovou linku mezi počítačem a Pi Pico.
V&nbsp;mém konkrétním případě (viz předchozí kapitoly) se jedná o zařízení
<strong>ttyACM0</strong>, takže si nechám vypsat vlastnosti tohoto souboru,
který toto zařízení reprezentuje v&nbsp;souborovém systému Linuxu:</p>

<pre>
$ <strong>ls -la /dev/ttyACM0</strong>
&nbsp;
crw-rw----. 1 root dialout 166, 0 Feb  7 12:00 /dev/ttyACM0
</pre>

<p>Jméno skupiny je <strong>dialout</strong>. Dále si příkazem
<strong>groups</strong> můžeme ověřit, do kterých skupin je přiřazen
uživatel:</p>

<pre>
$ <strong>groups</strong>
&nbsp;
kvm devel ptisnovs
</pre>

<p>Z&nbsp;výpisu je patrné, že tento uživatel není přiřazen do skupiny
<strong>dialout</strong>. Musíme tedy právě aktivního uživatele do této skupiny
přiřadit. To se provede následujícím způsobem (používáme proměnnou prostředí
<strong>USER</strong> obsahující login uživatele):</p>

<pre>
$ <strong>sudo usermod -a -G dialout $USER</strong>
</pre>

<p>Dále se to skupiny přihlásíme:</p>

<pre>
$ <strong>newgrp dialout</strong>
</pre>

<p>A ověříme si, že se nyní uživatel nachází i ve skupině
<strong>dialout</strong>:</p>

<pre>
$ <strong>groups</strong>
&nbsp;
dialout kvm devel ptisnovs
</pre>

<p>Nyní bude možné se k&nbsp;Raspberry Pi Pico připojit bez toho, abychom
aplikaci <strong>minicom</strong> dali práva uživatele:</p>

<pre>
$ <strong>minicom -D /dev/ttyACM0</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: při každém dalším připojení Raspberry Pi
Pico postačuje se přihlásit ke skupině <strong>newgrp dialout</strong> a
spustit <strong>minicom</strong> (je možná vhodné si oba příkazy vložit do
aliasu).</div></p>

<p>Totéž nastavení je možné provést například i pro skupinu studentů atd.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zjištění základních vlastností Raspberry Pi Pico z&nbsp;MicroPythonu</h2>

<p>Na Raspberry Pi Pico jsme v&nbsp;rámci předchozích kapitol nahráli
MicroPython, který je možné (a vlastně i nutné) používat namísto <i>shellu</i>
operačního systému. Přes MicroPython je možné zjistit poměrně velké množství
údajů jak o prostředí MicroPythonu, tak i o samotném Raspberry Pi. Některé
základní možnosti budou uvedeny v&nbsp;této kapitole.</p>

<p>Nejdříve zjistíme verzi a variantu MicroPythonu. To je velmi snadné:</p>

<pre>
&gt;&gt;&gt; <strong>import sys</strong>
&nbsp;
&gt;&gt;&gt; <strong>sys.version</strong>
'3.4.0; MicroPython v1.24.1 on 2024-11-29'
&nbsp;
&gt;&gt;&gt; <strong>sys.implementation</strong>
(name='micropython', version=(1, 24, 1, ''), _machine='Raspberry Pi Pico W with RP2040', _mpy=4870)
</pre>

<p>V&nbsp;dalších kapitolách budeme potřebovat znát hodinovou frekvenci. Tu
zjistíme následovně:</p>

<pre>
&gt;&gt;&gt; <strong>import machine</strong>
&nbsp;
&gt;&gt;&gt; <strong>machine.freq()</strong>
125000000
</pre>

<p>Základní informace o jednotlivých GPIO (toto je ale spíše poněkud špinavý trik):</p>

<pre>
&gt;&gt;&gt; <strong>for i in range(30):</strong>
...     <strong>print(machine.Pin(i))</strong>
...
</pre>

<p>Vypsat se může například:</p>

<pre>
Pin(GPIO0, mode=IN)
Pin(GPIO1, mode=IN)
Pin(GPIO2, mode=ALT, alt=PWM)
Pin(GPIO3, mode=IN)
Pin(GPIO4, mode=IN)
Pin(GPIO5, mode=OUT)
Pin(GPIO6, mode=OUT)
Pin(GPIO7, mode=OUT)
Pin(GPIO8, mode=OUT)
Pin(GPIO9, mode=OUT)
Pin(GPIO10, mode=OUT)
Pin(GPIO11, mode=OUT)
Pin(GPIO12, mode=OUT)
Pin(GPIO13, mode=OUT)
Pin(GPIO14, mode=OUT)
Pin(GPIO15, mode=OUT)
Pin(GPIO16, mode=OUT)
Pin(GPIO17, mode=OUT)
Pin(GPIO18, mode=OUT)
Pin(GPIO19, mode=OUT)
Pin(GPIO20, mode=OUT)
Pin(GPIO21, mode=OUT)
Pin(GPIO22, mode=OUT)
Pin(GPIO23, mode=ALT, alt=31)
Pin(GPIO24, mode=ALT, alt=31)
Pin(GPIO25, mode=ALT, pull=PULL_DOWN, alt=31)
Pin(GPIO26, mode=IN)
Pin(GPIO27, mode=IN)
Pin(GPIO28, mode=ALT, pull=PULL_DOWN, alt=31)
Pin(GPIO29, mode=ALT, pull=PULL_DOWN, alt=31)
</pre>

<p>Pro zajímavost se podívejme na nároky Pythonu na mikrořadiči RP2040 ihned po
bootu, spuštění interpretru a po připojení k&nbsp;interpretru přes emulovanou
sériovou linku:</p>

<pre>
&gt;&gt;&gt; <strong>import micropython</strong>
&gt;&gt;&gt; <strong>micropython.mem_info()</strong>
&nbsp;
stack: 556 out of 7936
GC: total: 189952, used: 15552, free: 174400
 No. of 1-blocks: 162, 2-blocks: 44, max blk sz: 116, max free sz: 9896
</pre>

<p>Podrobnější informace o jednotlivých blocích paměti (prozatím nebudeme
potřebovat, ale lze tak sledovat činnost správce paměti):</p>

<pre>
&gt;&gt;&gt; <strong>micropython.mem_info(True)</strong>
&nbsp;
stack: 564 out of 7936
GC: total: 189952, used: 15744, free: 174208
 No. of 1-blocks: 167, 2-blocks: 46, max blk sz: 116, max free sz: 9896
GC memory layout; from 20011a00:
00000000: h=MLhhhhBDhhBTTDBBBBBDhTh===BDBDh====B=BBBBBBTB=BTB=BBBTB=TBTB=B
00000400: h===TB=h===========B=Lh=hh===================h========h=========
00000800: ========h=======================================================
00000c00: ========h=======================================================
00001000: ========h=h=======h========h====================================
00001400: ===================================hBTDLhh===h=Lhh=hhhhBh=hhh=Lh
00001800: =Lh=Lh=Lh=Lh=Lh=DTTFFLh=hLhhhTTBBBBBBBBBh=======Lh=Lh=Lh=Lh=Lh=L
00001c00: h=LLFh=h=Lh=LLFh=h=Lh=Lh=Lh=Lh=Lh=======Lh=======Lh=======Lh====
00002000: ===Lh=======Lh=======Lh=======Lh=======Lh=h=hhhBDhhh=hhhhBhhhhhh
00002400: hh==Bhhhhh=hhBh=hhhhhhh==Bh=hhhh=hh=======h==Bh=hhhhB..hh....h==
00002800: .....h================h=============================h=h==.......
00002c00: ................................................................
00003000: ...........................h....................................
00003400: ................................................................
00003800: ........................................h=======................
00003c00: ................................h...............................
00004000: ...............................hh=.....................h.....h..
00004400: .....h...................h=======...............................
00004800: ............................................h===================
00004c00: ============....................................................
00005000: ................................................................
00005400: ...........................................................h====
00005800: ===.............................................................
       (4 lines all free)
00006c00: ..............h================================================h
00007000: ==h=============================================================
00007400: ======================================================h=========
00007800: =====h==h==h==h=====h=======h=========h==h==h===========........
       (154 lines all free)
0002e400: ................................
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Třída používaná pro ovládání stavových strojů PIO</h2>

<p><a
href="https://www.root.cz/clanky/programovatelne-io-na-mikroradicich-rp2040-v-raspberry-pi-pico/">V&nbsp;předchozím
článku</a> jsme si řekli základní informace o PIO i o stavových strojích
(&bdquo;koprocesorech&ldquo;), přes které je možné programově manipulovat se
vstupně-výstupními piny Raspberry Pi. Pro zjednodušení konfigurace a spouštění
stavových strojů z&nbsp;MicroPythonu slouží třída <strong>StateMachine</strong>
z&nbsp;balíčku <strong>rp2</strong>. Můžeme se tedy pokusit o zjištění
základních informací o této třídě:</p>

<pre>
&gt;&gt;&gt; <strong>import rp2</strong>
&nbsp;
&gt;&gt;&gt; <strong>help(rp2.StateMachine)</strong>
object &lt;class 'StateMachine'&gt; is of type type
  init -- &lt;function&gt;
  active -- &lt;function&gt;
  restart -- &lt;function&gt;
  exec -- &lt;function&gt;
  get -- &lt;function&gt;
  put -- &lt;function&gt;
  rx_fifo -- &lt;function&gt;
  tx_fifo -- &lt;function&gt;
  irq -- &lt;function&gt;
</pre>

<p>Povšimněte si sady metod (zde jsou označeny jako funkce) určených pro
inicializaci a spuštění stavových strojů a taktéž metod pro práci se vstupními
i výstupními frontami (RX FIFO a TX FIFO).</p>

<p>Před konfigurací některého stavového stroje je tedy nutné zkonstruovat
instanci třídy <strong>StateMachine</strong>. K&nbsp;tomu slouží konstruktor,
jehož hlavička je následující:</p>

<pre>
StateMachine.init(
    program,
    freq=-1,
    *,
    in_base=None,
    out_base=None,
    set_base=None,
    jmp_pin=None,
    sideset_base=None,
    in_shiftdir=None,
    out_shiftdir=None,
    push_thresh=None,
    pull_thresh=None)
</pre>

<p>Tento konstruktor vyžaduje jeden povinný parametr, kterým je funkce
představující PIO program. Další parametry jsou nepovinné, i když některé
z&nbsp;nich použijeme.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Tvorba programu pro PIO (stavový stroj)</h2>

<p>Podívejme se nyní, jakým způsobem se v&nbsp;MicroPythonu tvoří programy pro
jednotlivé stavové stroje. Jedná se o běžné pythonovské funkce, které ovšem
musí být obaleny dekorátorem <strong>rp2.asm_pio</strong> a obsahovat mohou
zápis instrukcí PIO (popsaných minule), jež ovšem ze syntaktického pohledu
vypadají jako volání běžných Pythonovských funkcí.</p>

<pre>
<u>@rp2.asm_pio()</u>
def <strong>my_first_pio_program</strong>():
    ...
    ...
    ...
</pre>

<p>Samotnému dekorátoru <strong>rp2.asm_pio</strong> je možné předat mnoho
nepovinných parametrů, které si popíšeme později:</p>

<pre>
rp2.asm_pio(
    *,
    out_init=None,
    set_init=None,
    sideset_init=None,
    side_pindir=False,
    in_shiftdir=PIO.SHIFT_LEFT,
    out_shiftdir=PIO.SHIFT_LEFT,
    autopush=False,
    autopull=False,
    push_thresh=32,
    pull_thresh=32,
    fifo_join=PIO.JOIN_NONE)
</pre>

<p>Například:</p>

<pre>
<u>@rp2.asm_pio(set_init=rp2.PIO.OUT_LOW)</u>
def <strong>my_first_pio_program</strong>():
    ...
    ...
    ...
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Pseudofunkce Pythonu určené pro naprogramování stavového stroje</h2>

<p>V&nbsp;těle funkcí, které jsou &bdquo;obaleny&ldquo; dekorátorem
<strong>rp2.asm_pio</strong>, se používají následující pseudofunkce Pythonu
(interně se totiž tyto funkce transformují do PIO funkcí popsaných minule):</p>

<table>
<tr><th>Pseudofunkce</th><th>Instrukce PIO</th><th>Stručný popis</th></tr>
<tr><td>wrap_target()</td><td>&times;</td><td>specifikace místa v&nbsp;programu, kde činnost začne po <strong>wrap</strong></td></tr>
<tr><td>wrap()</td><td>&times;</td><td>specifikace místa v&nbsp;programu, kde PIO skončí činnost a může začít vykonávat nový cyklus</td></tr>
<tr><td>label(návěští)</td><td>&times;</td><td>pojmenované či očíslované návěští (typicky cíl skoku)</td></tr>
<tr><td>word(instrukce, návěští)</td><td>&times;</td><td>vložení 16bitové konstanty představující instrukční slovo (nízkoúrovňové)</td></tr>
<tr><td>jmp(label)</td><td>JMP</td><td>nepodmíněný skok</td></tr>
<tr><td>jmp(cond, label)</td><td>JMP</td><td>podmíněný skok</td></tr>
<tr><td>wait(polarity, src, index)</td><td>WAIT</td><td>čekání na splnění podmínky (stav pinu, IRQ)</td></tr>
<tr><td>in_(src, bit_count)</td><td>IN</td><td>zápis bitů ze zdroje do posuvného registru ISR</td></tr>
<tr><td>out (dest, bit_count)</td><td>OUT</td><td>vysunutí bitů z&nbsp;posuvného registru OSR do cíle</td></tr>
<tr><td>push()</td><td>PUSH</td><td>uložení hodnoty z&nbsp;posuvného registru ISR do RX fronty (FIFO)</td></tr>
<tr><td>push(block)</td><td>PUSH</td><td>dtto, blokující varianta</td></tr>
<tr><td>push(noblock)</td><td>PUSH</td><td>dtto, neblokující varianta</td></tr>
<tr><td>push(iffull)</td><td>PUSH</td><td>dtto, varianta s&nbsp;nastaveným bitem IfF</td></tr>
<tr><td>push(iffull, block)</td><td>PUSH</td><td>kombinace předchozích možností</td></tr>
<tr><td>push(iffull, noblock)</td><td>PUSH</td><td>kombinace předchozích možností</td></tr>
<tr><td>pull()</td><td>PULL</td><td>přečtení hodnoty z&nbsp;TX fronty (FIFO) se zápisem do posuvného registru OSR</td></tr>
<tr><td>pull(block)</td><td>PULL</td><td>dtto, blokující varianta</td></tr>
<tr><td>pull(noblock)</td><td>PULL</td><td>dtto, neblokující varianta</td></tr>
<tr><td>pull(ifempty)</td><td>PULL</td><td>dtto, varianta s&nbsp;nastaveným bitem IfE</td></tr>
<tr><td>pull(ifempty, block)</td><td>PULL</td><td>kombinace předchozích možností</td></tr>
<tr><td>pull(ifempty, noblock)</td><td>PULL</td><td>kombinace předchozích možností</td></tr>
<tr><td>mov(dest, src)</td><td>MOV</td><td>přenos dat s&nbsp;provedením zvolené operace (negace či otočení bitů)</td></tr>
<tr><td>irq(index)</td><td>IRQ</td><td>vyvolání přerušení</td></tr>
<tr><td>irq(mode, index)</td><td>IRQ</td><td>vyvolání přerušení</td></tr>
<tr><td>set(dest, data)</td><td>SET</td><td>zápis dat do zvoleného cíle</td></tr>
<tr><td>nop()</td><td>&times;</td><td>překládá se do MOV Y, Y (jen čekání)</td></tr>
</table>

<p>U instrukce <strong>MOV</strong> jsme si řekli, že kromě prostého převodu
hodnot ze zdroje do cíle je možné přenášené 32bitové hodnoty modifikovat
&ndash; buď negovat všechny bity nebo všechny bity otočit. To lze při použití
pseudofunkce <strong>mov</strong> realizovat následujícím způsobem:</p>

<pre>
mov()             <i># prostý přenos dat</i>
mov().invert()    <i># přenos dat s&nbsp;inverzí všech bitů</i>
mov().reverse()   <i># přenos dat s&nbsp;otočením všech bitů</i>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Specifikace počtu zpožďovacích cyklů</h2>

<p>Připomeňme si, že u všech instrukcí PIO je možné v&nbsp;pěti bitech (jsou
součástí 16bitového instrukčního slova) specifikovat počet zpožďovacích cyklů.
Instrukce po svém provedení může čekat dalších 1-31 cyklů, čímž lze realizovat
přenos různými rychlostmi atd. Jak se však tato část instrukce naplní
pseudofunkcemi, s&nbsp;nimiž jsme se seznámili <a href="#k09">v&nbsp;předchozí
kapitole</a>? Jedno řešení spočívá v&nbsp;tom, že budeme výsledek pseudofunkce
považovat za objekt a zavoláme jeho metodu <strong>delay</strong> (což do
určité míry odpovídá volání <strong>invert()</strong> a
<strong>reverse()</strong>). Zápis tedy může vypadat takto:</p>

<pre>
push().delay(10)
jmp("cíl").delay(31)
jmp(x_dc, "cíl").delay(0)
</pre>

<p>V&nbsp;praxi se však setkáme s&nbsp;odlišným zápisem &ndash; počet čekacích
cyklů se zapíše do hranatých závorek:</p>

<pre>
push()            [10]
jmp("cíl")        [31]
jmp(x_dc, "cíl")  [0]
</pre>

<p><div class="rs-tip-major">Poznámka: to může vypadat poněkud zvláštně a mohlo
by se dokonce zdát, že se vlastně ani nejedná o platný Pythonovský zdrojový
kód. Ovšem pokud bude výsledkem volání pseudofunkcí objekt, v&nbsp;jehož třídě
je přetížen operátor indexování, bude vše z&nbsp;pohledu syntaxe Pythonu
korektní.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Realizace skoků v&nbsp;PIO</h2>

<p>Ještě si musíme vysvětlit jeden koncept &ndash; jak se realizují skoky
v&nbsp;PIO v&nbsp;případě, že celý zápis provádíme v&nbsp;Pythonu.
K&nbsp;tomuto účelu použijeme funkci <strong>label</strong>, která slouží
k&nbsp;definici <i>návěští</i>. A právě návěští může sloužit jako cíl skoku.
Podívejme se například, jak by mohla vypadat nekonečná smyčka:</p>

<pre>
@rp2.asm_pio()
def <strong>endless_loop</strong>():
    label("opak")
    nop()
    jmp("opak")
</pre>

<p>Pokud by měla smyčka trvat delší dobu, můžeme použít tento zápis:</p>

<pre>
@rp2.asm_pio()
def <strong>endless_loop</strong>():
    label("opak")
    nop()           [31]
    jmp("opak")
</pre>

<p>Popř.&nbsp;bude nutné pseudoinstrukci <strong>nop</strong> opakovat:</p>

<pre>
@rp2.asm_pio()
def <strong>endless_loop</strong>():
    label("opak")
    nop()           [31]
    nop()           [31]
    nop()           [31]
    jmp("opak")
</pre>

<p>Počítanou smyčku bychom mohli zapsat například takto:</p>

<pre>
@rp2.asm_pio()
def <strong>counted_loop</strong>():
    set(x, 20)
    label("opak")
    nop()           [31]
    nop()           [31]
    nop()           [31]
    jmp(x_dec, "opak")
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Typický první ukázkový příklad při programování MCU: blikání LED</h2>

<p>Většina prvních pokusů s&nbsp;mikrořadiči většinou rozbliká LED připojenou
k&nbsp;vybranému GPIO (vstupně-výstupnímu pinu). Tento projekt si na začátek
ukážeme také, ovšem blikat LED budeme přes PIO a to velmi přesně &ndash;
s&nbsp;teoretickou přesnosti na jednotlivé hodinové cykly (125 MHz).
V&nbsp;případě, že máte k&nbsp;dispozici původní Raspberry Pi Pico bez Wifi
modulu, je situace velmi jednoduchá, protože LED, která je nainstalována přímo
na Raspberry, je dostupná přes GPIO pin číslo 25. V&nbsp;tomto případě tedy
budeme ovládat tento pin. Pro Raspberry Pi Pico W (tedy s&nbsp;Wifi modulem) to
už tak jednoduché není, protože LED není přímo ovladatelná přes GPIO. Proto si
připojíme vlastní LED: mezi GPIO číslo 8 (náhodný výběr) a GND (zem) je
zapojena LED v&nbsp;sérii s&nbsp;rezistorem 330&Omega; (není nutné dodržet
přesně, LED bude svítit i při použití 470&Omega; z&nbsp;řady E3). Samozřejmě
můžete LED zapojit i na jiné GPIO, ale bude nutné upravit program.</p>

<p>Nejdříve si otestujeme, zda je LED správně zapojena (polarita atd.).
Rozblikáme ji bez přímého použití PIO. Pro standardní LED na původním Raspberry
Pi Pico (bez Wifi) lze použít tento prográmek:</p>

<pre>
from machine import Pin, Timer
&nbsp;
led = Pin(25, Pin.OUT)
timer = Timer()
&nbsp;
def <strong>blink</strong>(timer):
    led.toggle()
&nbsp;
timer.init(freq=2, mode=Timer.PERIODIC, callback=blink)
</pre>

<p>Pro LED zapojenou ke GPIO číslo 8 jen změníme číslo pinu:</p>

<pre>
from machine import Pin, Timer
&nbsp;
led = Pin(8, Pin.OUT)
timer = Timer()
&nbsp;
def <strong>blink</strong>(timer):
    led.toggle()
&nbsp;
timer.init(freq=2, mode=Timer.PERIODIC, callback=blink)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Naprogramování a načasování PIO pro blikání LED</h2>

<p>Nyní se pokusíme rozblikat LED přes programovatelné PIO. Ukážeme si příklad,
jehož originální verzi naleznete na adrese <a
href="https://docs.micropython.org/en/latest/rp2/quickref.html#programmable-io-pio"></a>.
Jak bude naprogramování blikání probíhat? Budeme předpokládat, že hodinová
frekvence vybraného stavového stroje bude nastavena přesně na 2kHz. Toho můžeme
dosáhnout nastavením děliče hodinového signálu, o němž jsme se zmínili <a
href="https://www.root.cz/clanky/programovatelne-io-na-mikroradicich-rp2040-v-raspberry-pi-pico/#k06">zde</a>.
Co to znamená? Každou sekundu proběhne 2000 cyklů stavového stroje. Budeme
chtít, aby prvních 1000 cyklů dioda svítila a dalších 1000 cyklů naopak
zhasla.</p>

<p>Rozsvícení LED následované vhodně nastavenou čekací smyčkou může vypadat
takto:</p>

<pre>
    set(pins, 1)
    set(x, konstanta)
    label("delay_high")
    nop()
    jmp(x_dec, "delay_high")
</pre>

<p>Vhodným doplněním konstanty a zpožďovacích cyklů lze dosáhnout přesného
načasování. Například takto:</p>

<pre>
    set(pins, 1)
    set(x, 31)                  [6]
    label("delay_high")
    nop()                       [29]
    jmp(x_dec, "delay_high")
</pre>

<p>První instrukce trvá jeden hodinový cyklus, druhá instrukce trvá 1+6=7
cyklů. <strong>label</strong> není instrukcí, takže ji nepočítáme. Ovšem
počítat naopak musíme smyčku, která proběhne 32&times;. A každý cyklus smyčky
trvá 29+1 cyklus (<strong>nop</strong>) + 1 cyklus (<strong>jmp</strong>),
celkem tedy 32&times;31=992 cyklů. Pokud připočteme úvodních osm cyklů, získáme
přesně 1000 cyklů.</p>

<p>Druhá část programu, tj.&nbsp;zhasnutí LED po dobu 1000 cyklů, je již snadné
&ndash; jen zapíšeme nulu na port, namísto 1:</p>

<pre>
    set(pins, 0)
    set(x, 31)                  [6]
    label("delay_low")
    nop()                       [29]
    jmp(x_dec, "delay_low")
</pre>

<p><div class="rs-tip-major">Poznámka: to, jaký pin či piny se budou měnit
instrukcí <strong>set</strong>, může být nakonfigurováno v&nbsp;jiné části
programu (definicí mapování GPIO).</div></p>

<p>Pokud se vám nechce již v&nbsp;prvním PIO programu používat počítané smyčky,
lze celé zpoždění realizovat sérií instrukcí <strong>nop()</strong>,
z&nbsp;nichž každá potrvá přesně 32 strojových cyklů:</p>

<pre>
    nop()          [31]
    nop()          [31]
    nop()          [31]
    nop()          [31]
    ...
    ...
    ...
</pre>

<p><div class="rs-tip-major">Poznámka: nyní si již můžete snadno spočítat,
kolik takových instrukcí bude zapotřebí a jaká bude délka zpoždění poslední
z&nbsp;nich: součet musí být roven hodnotě 999, protože jeden cyklus trvá
instrukce <strong>set</strong>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Naprogramování funkce s&nbsp;ovládáním LED přes PIO</h2>

<p>Nyní máme k&nbsp;dispozici prakticky všechny informace potřebné pro
naprogramování funkce v&nbsp;MicroPythonu, která bude ovládat LED
s&nbsp;využitím PIO. Víme již, že taková funkce musí být obalena dekorátorem
<strong>rp2.asm_pio</strong> a může ve svém těle obsahovat konstantní výrazy a
volání pseudofunkcí, které odpovídají instrukcím PIO. K&nbsp;těmto
pseudofunkcím ještě přidejme funkci pro nastavení návěští (<i>label</i>) a
funkce pro označení začátku a konce celého PIO programu (mohou se vkládat
automaticky). A navíc můžeme do dekorátoru přidat i původní stav pinu (GPIO),
který se ovládá:</p>

<pre>
@rp2.asm_pio(set_init=rp2.PIO.OUT_LOW)
def <strong>blink_1hz</strong>():
    set(pins, 1)
    set(x, 31)                  [6]
    label("delay_high")
    nop()                       [29]
    jmp(x_dec, "delay_high")
    set(pins, 0)
    set(x, 31)                  [6]
    label("delay_low")
    nop()                       [29]
    jmp(x_dec, "delay_low")
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Ověření délky trvání jedné iterace PIO programu</h2>

<p>Celkovou dobu trvání jedné iterace celého PIO programu <a
href="#k14">z&nbsp;předchozí kapitoly</a> lze snadno vypočítat:</p>

<table>
<tr><th>Instrukce</th><th>Délka trvání</th><th>Opakování</th><th>Celkem</th></tr>
<tr><td>set(pins, 1)                    </td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>set(x, 31)                  [6] </td><td>1+6</td><td>1</td><td>7</td></tr>
<tr><td>nop()                       [29]</td><td>1+29</td><td>32</td><td>960</td></tr>
<tr><td>jmp(x_dec, "delay_high")        </td><td>1</td><td>32</td><td>32</td></tr>
<tr><td>set(pins, 0)                    </td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>set(x, 31)                  [6] </td><td>1+6</td><td>1</td><td>7</td></tr>
<tr><td>nop()                       [29]</td><td>1+29</td><td>32</td><td>960</td></tr>
<tr><td>jmp(x_dec, "delay_low")         </td><td>1</td><td>32</td><td>32</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Součet</td><td>&nbsp;</td><td>&nbsp;</td><td>2000</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Konstrukce a spuštění stavového stroje</h2>

<p>V&nbsp;případě, že se vám podařilo <a href="#k14">výše uvedenou funkci</a>
interpretovat MicroPythonem (postačuje přenos do terminálu s&nbsp;běžícím
Minicomem), můžeme přistoupit k&nbsp;dalšímu kroku. Zkonstruujeme totiž objekt,
který bude interně představovat stavový stroj PIO. Je to poměrně snadné:
přesněji řečeno snadné ve chvíli, kdy již víme, jak PIO pracuje. Určíme, že se
bude jednat o první program (konstanta 0), jehož instrukce jsou získány
z&nbsp;naší funkce <strong>blink_1hz</strong> (přes dekorátor). Dále určíme
hodnotu pro dělič frekvence &ndash; budeme vyžadovat provedení 2000 instrukcí
za sekundu. A konečně posledním parametrem je specifikován první pin
nastavovaný instrukcí <strong>set</strong> (tedy vlastně mapování). Pro LED
připojenou na GPIO číslo 8 použijeme:</p>

<pre>
sm = rp2.StateMachine(0, blink_1hz, freq=2000, set_base=Pin(8))
</pre>

<p>Naopak pro LED připojenou na standardní pin číslo 25 použijeme:</p>

<pre>
sm = rp2.StateMachine(0, blink_1hz, freq=2000, set_base=Pin(25))
</pre>

<p>A konečně tímto příkazem celý stavový stroj spustíme:</p>

<pre>
sm.active(1)
</pre>

<p>Nyní by měla LED začít blikat. A co víc &ndash; nyní již poměrně do všech
podrobností víme, proč bliká a jak je to celé zařízeno.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Shrnutí</h2>

<p>V&nbsp;dnešním článku jsme si (prozatím) ukázali naprosté základy využití
subsystému programovatelných vstupně-výstupních pinů. Nyní již ovšem přesně
víme, jak se dá celé PIO naprogramovat v&nbsp;MicroPythonu, co znamenají
&bdquo;tajemné&ldquo; hodnoty zapsané v&nbsp;hranatých závorkách i to, jak se
inicializuje a následně spustí a popř.&nbsp;pozastaví stavový stroj. Mnoho
nízkoúrovňových operací za nás dokáže provést samotný MicroPython (nastavení
děliče frekvence a mapování GPIO), ovšem to hlavní &ndash; PIO programy &ndash;
ponechává plně na vývojářích. Jedná se tak o poměrně dobře vyvážený koncept
vysokoúrovňového jazyka s&nbsp;(de facto) assemblerem PIO.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: dekorátory v&nbsp;jazyce Python</h2>

<p>Přílože dnešního dnešního článku si ve stručnosti vysvětlíme činnost
takzvaných <i>dekorátorů</i>. Dekorátory jsme mohli vidět v&nbsp;hlavičce
funkcí s&nbsp;PIO kódem. Jedná se o funkcionální technologii, která nám
umožňuje snadno &bdquo;obalit&ldquo; volání nějaké funkce dalším kódem a vrátit
výsledek jako novou funkci s&nbsp;přidanými vlastnostmi (tedy v&nbsp;případě
PIO by se vlastně vrátila sekvence operačních kódů instrukcí). Může to vypadat
následovně:</p>

<pre>
def <strong>wrapper</strong>1(původní_funkce):
    def <strong>nová_funkce</strong>():
        <i># nějaký kód</i>
        původní_funkce()
        <i># nějaký kód</i>
&nbsp;
    return nová_funkce
</pre>

<p>Důležité je, že ono vlastní &bdquo;obalení&ldquo; původní funkce je
realizováno snadno zapamatovatelnou syntaxí &ndash; před definici funkce se na
samostatný řádek zapíše jméno dekorátoru a jeho případné parametry:</p>

<pre>
@wrapper
def <strong>hello</strong>():
    print("Hello!")
</pre>

<p>Musíme si ovšem uvědomit, že se ve skutečnosti jedná pouze o syntaktický
cukr a podobnou techniku lze použít i v&nbsp;případě, že by dekorátory
v&nbsp;Pythonu neexistovaly (ostatně i dekorátor <strong>rp2.asm_pio</strong>
lze zavolat jako běžnou funkci).</p>

<p><div class="rs-tip-major">Poznámka: na dekorátory narazíme v&nbsp;Pythonu
prakticky v&nbsp;jakémkoli oboru (třeba i u tvorby testů, REST API atd.). Vždy
je důležité si uvědomit, že se nejedná o žádnou magii, ale o jinak zapsané
volání funkce vyššího řádu.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
MicroPython běžící na čipech RP2040 s&nbsp;architekturou Cortex-M0 byly uloženy
do repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;tabulce zobrazené níže jsou odkazy na jednotlivé příklady:</p>

<table>
<tr><th>#</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>display_version.py</td><td>tisk verze MicroPythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_version.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_version.py</a></td></tr>
<tr><td>2</td><td>display_frequency.py </td><td>zjištění hodinové frekvence MCU</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_frequency.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_frequency.py</a></td></tr>
<tr><td>3</td><td>display_mem_info_1.py</td><td>zobrazení základních informací o paměti MicroPythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_mem_info_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_mem_info_1.py</a></td></tr>
<tr><td>4</td><td>display_mem_info_2.py</td><td>zobrazení podrobnějších informací o paměti MicroPythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_mem_info_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_mem_info_2.py</a></td></tr>
<tr><td>5</td><td>display_pins.py</td><td>zobrazení konfigurace GPIO pinů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_pins.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/display_pins.py</a></td></tr>
<tr><td>6</td><td>blink_gpio_25.py</td><td>blikání LED na GPIO #25 bez použití PIO</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/blink_gpio_25.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/blink_gpio_25.py</a></td></tr>
<tr><td>7</td><td>blink_gpio_8.py</td><td>blikání LED na GPIO #8 bez použití PIO</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/blink_gpio_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/blink_gpio_8.py</a></td></tr>
<tr><td>8</td><td>pio_blink_pin_25.py</td><td>blikání LED na GPIO #25 s&nbsp;použitím PIO</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/pio_blink_pin_25.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/pio_blink_pin_25.py</a></td></tr>
<tr><td>9</td><td>pio_blink_pin_8.py</td><td>blikání LED na GPIO #8 s&nbsp;použitím PIO</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/pio_blink_pin_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/pio_blink_pin_8.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu<br />
<a href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu/">https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu/</a>
</li>

<li>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu (2)<br />
<a href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-2/">https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-2/</a>
</li>

<li>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-dokonceni/">https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-dokonceni/</a>
</li>

<li>Překlad funkcí přímo do nativního kódu MicroPythonem<br />
<a href="https://www.root.cz/clanky/preklad-funkci-primo-do-nativniho-kodu-micropythonem/">https://www.root.cz/clanky/preklad-funkci-primo-do-nativniho-kodu-micropythonem/</a>
</li>

<li>MicroPython ve webovém prohlížeči: lehkotonážní varianta k Pyodide<br />
<a href="https://www.root.cz/clanky/micropython-ve-webovem-prohlizeci-lehkotonazni-varianta-k-pyodide/">https://www.root.cz/clanky/micropython-ve-webovem-prohlizeci-lehkotonazni-varianta-k-pyodide/</a>
</li>

<li>Programmable IO<br />
<a href="https://docs.micropython.org/en/latest/rp2/tutorial/pio.html">https://docs.micropython.org/en/latest/rp2/tutorial/pio.html</a>
</li>

<li>Introduction to the PIO (Programmable Input Output) of the RP2040<br />
<a href="https://tutoduino.fr/en/pio-rp2040-en/">https://tutoduino.fr/en/pio-rp2040-en/</a>
</li>

<li>MicroPython examples: PIO<br />
<a href="https://github.com/raspberrypi/pico-micropython-examples/tree/master/pio">https://github.com/raspberrypi/pico-micropython-examples/tree/master/pio</a>
</li>

<li>PIO: Wikipedia CZ (pozor: jedná se o něco jiného!)<br />
<a href="https://cs.wikipedia.org/wiki/PIO">https://cs.wikipedia.org/wiki/PIO</a>
</li>

<li>RP2040 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RP2040">https://en.wikipedia.org/wiki/RP2040</a>
</li>

<li>Maximising MicroPython speed<br />
<a href="https://docs.micropython.org/en/latest/reference/speed_python.html">https://docs.micropython.org/en/latest/reference/speed_python.html</a>
</li>

<li>Online ARM converter<br />
<a href="https://armconverter.com/?disasm">https://armconverter.com/?disasm</a>
</li>

<li>The 3 different code emitters<br />
<a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832">https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832</a>
</li>

<li>The 3 different code emitters, part 2<br />
<a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145">https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145</a>
</li>

<li>Fast Filters for the Pyboard<br />
<a href="https://github.com/peterhinch/micropython-filters">https://github.com/peterhinch/micropython-filters</a>
</li>

<li>How to load 32 bit constant from assembler with @micropython.asm_thumb<br />
<a href="https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a">https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a</a>
</li>

<li>Pi pico, micropython.asm_thumb: ADR Rd, &lt;label&gt; and LDR Rd, &lt;label&gt; not implemented?<br />
<a href="https://github.com/orgs/micropython/discussions/12257">https://github.com/orgs/micropython/discussions/12257</a>
</li>

<li>MicroPython documentation<br />
<a href="https://docs.micropython.org/en/latest/index.html">https://docs.micropython.org/en/latest/index.html</a>
</li>

<li>Inline assembler for Thumb2 architectures<br />
<a href="https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html">https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html</a>
</li>

<li>Inline assembler in MicroPython<br />
<a href="https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler">https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami (2)<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>Cortex-M0 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M0">https://en.wikipedia.org/wiki/ARM_Cortex-M0</a>
</li>

<li>Cortex-M0+ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B">https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>The Thumb instruction set<br />
<a href="http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf">http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Raspberry Pi Pico Variants &ndash; A Detailed Comparison<br />
<a href="https://circuitdigest.com/article/raspberry-pi-pico-variants-comparison">https://circuitdigest.com/article/raspberry-pi-pico-variants-comparison</a>
</li>

<li>Raspberry Pi Pico 2 vs Original Pico: What’s New?<br />
<a href="https://www.digikey.cz/en/maker/blogs/2024/raspberry-pi-pico-2-vs-original-pico-whats-new">https://www.digikey.cz/en/maker/blogs/2024/raspberry-pi-pico-2-vs-original-pico-whats-new</a>
</li>

<li>pio-uart<br />
<a href="https://github.com/Sympatron/pio-uart">https://github.com/Sympatron/pio-uart</a>
</li>

<li>Datasheet čipu RP2040<br />
<a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

