<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Validace dat v Pythonu s využitím knihovny Pydantic</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Validace dat v Pythonu s využitím knihovny Pydantic</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme se základními vlastnostmi knihovny Pydantic. Jedná se o knihovnu určenou pro jazyk Python, která umožňuje definici struktury dat, validaci vstupních dat (ověření zda odpovídají definici), jejich serializaci i deserializaci atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Validace dat v&nbsp;Pythonu s&nbsp;využitím knihovny Pydantic</a></p>
<p><a href="#k02">2. Příprava projektu pro vyzkoušení možností nabízených Pydanticem</a></p>
<p><a href="#k03">3. Základ všech modelů &ndash; třída <strong>BaseModel</strong></a></p>
<p><a href="#k04">4. Definice vlastního jednoduchého modelu</a></p>
<p><a href="#k05">5. Inicializace objektu s&nbsp;explicitním nastavením všech jeho atributů</a></p>
<p><a href="#k06">6. Typová kontrola atributů</a></p>
<p><a href="#k07">7. Jak se pracuje s&nbsp;nepovinnými atributy?</a></p>
<p><a href="#k08">8. Atributy s&nbsp;typem umožňující i reprezentaci neexistující hodnoty</a></p>
<p><a href="#k09">9. Specializované datové typy poskytované knihovnou Pydantic</a></p>
<p><a href="#k10">10. Explicitní kontrola zadané hodnoty atributu</a></p>
<p><a href="#k11">11. Omezení délky řetězců zapisovaných do atributů</a></p>
<p><a href="#k12">12. Přečtení a validace celé struktury z&nbsp;JSONu</a></p>
<p><a href="#k13">13. Serializace celé struktury do formátu JSON</a></p>
<p><a href="#k14">14. Komplikovanější datová struktura obsahující další struktury</a></p>
<p><a href="#k15">15. Kontrola všech povinných atributů</a></p>
<p><a href="#k16">16. Nepovinný atribut popsaný modelem</a></p>
<p><a href="#k17">17. Výchozí hodnota nepovinných atributů</a></p>
<p><a href="#k18">18. Obsah navazujícího článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Validace dat v&nbsp;Pythonu s&nbsp;využitím knihovny Pydantic</h2>

<p>Jednou z&nbsp;nejpopulárnějších a současně i velmi dobře navržených knihoven
pro ekosystém <a href="https://www.root.cz/n/python/">programovacího jazyka
Python</a> je knihovna nazvaná <a
href="https://docs.pydantic.dev/latest/">Pydantic</a>. Tato knihovna je určena
pro definici takzvaných <i>modelů</i>, které popisují strukturu dat (například
výsledků dotazů přes REST API atd.). Následně umožňuje validaci takových dat,
jejich serializaci, deserializaci atd. Pro definici modelů se využívá typový
systém programovacího jazyka Python, tj.&nbsp;nativní Pythonní <i>typové
informace</i> (<i>type hints</i>). To znamená, že programátoři mohou využít
svých znalostí (bez typových informací se v&nbsp;Pythonu jen těžko tvoří
rozsáhlejší aplikace) a nemusí se učit nový doménově specifický jazyk. Pydantic
je v&nbsp;současnosti velmi často využíván společně s&nbsp;knihovnou <a
href="https://fastapi.tiangolo.com/">FastAPI</a>; nově se taktéž začíná
využívat <a href="https://ai.pydantic.dev/">Pydantic AI</a>, což je velmi
zajímavý framework, který bude podrobněji popsán v&nbsp;samostatném článku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Příprava projektu pro vyzkoušení možností nabízených Pydanticem</h2>

<p>Tento článek je zaměřen na praktické ukázky použití knihovny
<i>Pydantic</i>. Musíme si tedy připravit projekt v&nbsp;Pythonu a následně do
něj knihovnu <i>Pydantic</i> přidat formou přímé závislosti
(<i>dependency</i>). Pro vytvoření projektu použijeme buď nástroj <i>PDM</i>
&ndash; viz též <a
href="https://www.root.cz/clanky/pdm-moderni-spravce-balicku-a-virtualnich-prostredi-pythonu/">PDM:
moderní správce balíčků a virtuálních prostředí Pythonu</a> nebo (což je
v&nbsp;současnosti výhodnější) nástroj <a
href="https://docs.astral.sh/uv/">uv</a>:</p>

<pre>
$ <strong>uv init pydantic-demo</strong>
&nbsp;
Initialized project `pydantic-demo` at `/tmp/ramdisk/yyy/pydantic-demo`
</pre>

<p>Projekt bude vytvořen v&nbsp;novém (původně prázdném) adresáři a jeho
projektový soubor <strong>pyproject.toml</strong> může vypadat následovně:</p>

<pre>
[project]
name = "pydantic-demo"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = "&gt;=3.12"
dependencies = []
</pre>

<p>Příkazem <strong>pdm add</strong> nebo <strong>uv add</strong> do projektu
přidáme knihovnu <i>pydantic</i>:</p>

<pre>
$ <strong>uv add pydantic</strong>
</pre>

<p>Ve skutečnosti se automaticky přidají i tranzitivní závislosti, ovšem ve
skutečnosti jich není mnoho:</p>

<pre>
Using CPython 3.12.10 interpreter at: /usr/bin/python3.12
Creating virtual environment at: .venv
Resolved 6 packages in 199ms
Installed 5 packages in 38ms
 + annotated-types==0.7.0
 + pydantic==2.11.7
 + pydantic-core==2.33.2
 + typing-extensions==4.14.1
 + typing-inspection==0.4.1
</pre>

<p>Výsledný projektový soubor by měl vypadat takto:</p>

<pre>
[project]
name = "pydantic-demo"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = "&gt;=3.12"
dependencies = [
    "pydantic&gt;=2.11.7",
]
</pre>

<p>Nyní si již můžeme otestovat, zda je knihovna <i>Pydantic</i> dostupná.
Spustíme interpret Pythonu, ovšem v&nbsp;rámci virtuálního prostředí
projektu:</p>

<pre>
$ <strong>uv run python</strong>
&nbsp;
Python 3.12.10 (main, Apr 22 2025, 00:00:00) [GCC 14.2.1 20240912 (Red Hat 14.2.1-3)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>

<p>Provedeme import knihovny <i>Pydantic</i> a necháme si zobrazit její
nápovědu:</p>

<pre>
&gt;&gt;&gt; <strong>import pydantic</strong>
&nbsp;
&gt;&gt;&gt; <strong>help(pydantic)</strong>
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
Help on package pydantic:
&nbsp;
NAME
    pydantic
&nbsp;
PACKAGE CONTENTS
    _internal (package)
    _migration
    alias_generators
    aliases
    annotated_handlers
    class_validators
    color
    config
    dataclasses
    datetime_parse
    decorator
    deprecated (package)
    env_settings
    error_wrappers
    errors
    experimental (package)
    fields
    functional_serializers
    ...
    ...
    ...
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základ všech modelů &ndash; třída <strong>BaseModel</strong></h2>

<p>Základem všech modelů, resp.&nbsp;přesněji řečeno všech vývojářem
vytvářených modelů, je třída nazvaná <strong>BaseModel</strong>. Od této třídy
jsou totiž modely odvozovány (je tedy z&nbsp;pohledu objektově orientovaného
programování jejich rodičovskou třídou). Třídu <strong>BaseModel</strong>
využijeme ve všech demonstračních příkladech a pochopitelně si pro ni můžeme
nechat zobrazit nápovědu:</p>

<pre>
Help on class BaseModel in module pydantic.main:
&nbsp;
class BaseModel(builtins.object)
 |  BaseModel(**data: 'Any') -&gt; 'None'
 |
 |  Usage docs: https://docs.pydantic.dev/2.10/concepts/models/
 |
 |  A base class for creating Pydantic models.
 |
 |  Attributes:
 |      __class_vars__: The names of the class variables defined on the model.
 |      __private_attributes__: Metadata about the private attributes of the model.
 |      __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.
 |
 |      __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
 |      __pydantic_core_schema__: The core schema of the model.
 |      __pydantic_custom_init__: Whether the model has a custom `__init__` function.
 |      __pydantic_decorators__: Metadata containing the decorators defined on the model.
 |          This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
 |      __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
 |          __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
 |      __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
 |      __pydantic_post_init__: The name of the post-init method for the model, if defined.
 |      __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
 |      __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
 |      __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.
 |
 |      __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
 |      __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.
 |
 |      __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
 |          is set to `'allow'`.
 |      __pydantic_fields_set__: The names of fields explicitly set during instantiation.
 |      __pydantic_private__: Values of private attributes set on the model instance.
 ...
 ...
 ...
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Definice vlastního jednoduchého modelu</h2>

<p>Vyzkoušejme si nyní, jakým způsobem se vlastně postupuje při definici
modelu. Je to vlastně velmi snadné &ndash; postačuje odvodit vlastní třídu od
třídy <strong>BaseModel</strong> a nadefinovat její atributy, u nichž je kromě
jejich jména uveden i jejich typ. Pokud bychom například chtěli nadefinovat
model reprezentující uživatele, přičemž atributy by bylo jméno, příjmení, věk a
příznak, že je uživatel zaregistrován, bude celý skript vypadat následovně:</p>

<pre>
from pydantic import BaseModel
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: int
    registered: bool
&nbsp;
&nbsp;
user1 = User()
print(user1)
</pre>

<p>Ve skutečnosti dojde při spuštění tohoto skriptu k&nbsp;běhové výjimce,
protože jsme při konstrukci instance třídy <strong>User</strong>
nespecifikovali hodnoty atributů a současně nebyly nastaveny jejich výchozí
hodnoty. Tyto kontroly plně provádí knihovna Pydantic:</p>

<pre>
Traceback (most recent call last):
  File "/tmp/ramdisk/pydantic/pydantic-demo/user_1.py", line 11, in &lt;module&gt;
    user1 = User()
            ^^^^^^
  File "/tmp/ramdisk/pydantic/pydantic-demo/.venv/lib64/python3.12/site-packages/pydantic/main.py", line 253, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pydantic_core._pydantic_core.ValidationError: 4 validation errors for User
<u>name</u>
  Field required [type=missing, input_value={}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.11/v/missing
<u>surname</u>
  Field required [type=missing, input_value={}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.11/v/missing
<u>age</u>
  Field required [type=missing, input_value={}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.11/v/missing
<u>registered</u>
  Field required [type=missing, input_value={}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.11/v/missing
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že z&nbsp;vypsaných
chybových hlášení lze poznat, k&nbsp;jaké chybě došlo. Jména atributů jsou ve
výpise podtrženy pro větší přehlednost.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Inicializace objektu s&nbsp;explicitním nastavením všech jeho atributů</h2>

<p>Náš první demonstrační příklad, jenž byl uvedený <a href="#k05">v&nbsp;páté
kapitole</a>, zhavaroval z&nbsp;toho důvodu, že knihovna Pydantic obecně
vyžaduje, aby byly všechny atributy objektu inicializovány už při jeho
konstrukci &ndash; jakmile objekt existuje, je zajištěno, že je plně validní a
inicializovaný.  V&nbsp;našem konkrétním modelu jsme uvedli, že jméno,
příjmení, věk i příznak o registraci jsou <i>povinné atributy</i> a současně
není uvedena jejich výchozí hodnota, takže je skutečně musíme explicitně
nastavit:</p>

<pre>
user1 = <u>User(name="John", surname="Doe", age=42, registered=False)</u>
</pre>

<p>Demonstrační příklad si tedy nepatrně upravíme do této podoby:</p>

<pre>
from pydantic import BaseModel
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: int
    registered: bool
&nbsp;
&nbsp;
user1 = <u>User(name="John", surname="Doe", age=42, registered=False)</u>
print(user1)
</pre>

<p>O tom, že je nyní objekt vytvořen korektně, se snadno přesvědčíme spuštěním
skriptu:</p>

<pre>
$ <strong>uv run user_2.py </strong>
&nbsp;
name='John' surname='Doe' age=42 registered=False
</pre>

<p>Mohlo by se zdát, že kvůli tomu, že se v&nbsp;modelu definují atributy třídy
(a nikoli objektu), přepíšou se tyto atributy při konstrukci dalšího objektu.
Ve skutečnosti tomu tak není, což si můžeme velmi snadno ověřit konstrukcí dvou
objektů představujících dva různé uživatele:</p>

<pre>
from pydantic import BaseModel
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: int
    registered: bool
&nbsp;
&nbsp;
user1 = User(name="John", surname="Doe", age=42, registered=False)
user2 = User(name="Adam", surname="Bernau", age=52, registered=True)
&nbsp;
print(user1)
print(user2)
</pre>

<p>Z&nbsp;výpisu, který získáme po spuštění takto upraveného skriptu, je
zřejmé, že jsme vytvořili dva objekty, které mají rozdílné atributy:</p>

<pre>
name='John' surname='Doe' age=42 registered=False
name='Adam' surname='Bernau' age=52 registered=True
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Typová kontrola atributů</h2>

<p>Díky tomu, že každý atribut má v&nbsp;modelu stanovený svůj datový typ,
dokáže knihovna Pydantic provádět striktní typovou kontrolu při každé
konstrukci objektu. Ukažme si to na jednoduchém příkladu, ve kterém se budeme
snažit nastavit atributy <strong>age</strong> a <strong>registered</strong> na
hodnoty nekorektních typů (řetězce namísto celého čísla resp.&nbsp;pravdivostní
hodnoty):</p>

<pre>
from pydantic import BaseModel
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: int
    registered: bool
&nbsp;
&nbsp;
user1 = User(name="John", surname="Doe", <u>age="unknown"</u>, <u>registered="yes"</u>)
print(user1)
</pre>

<p>Po spuštění tohoto příkladu se (korektně) vypíše první chyba, na kterou
knihovna Pydantic narazila. Konkrétně se jedná o hodnotu předávanou do atributu
<strong>age</strong>:</p>

<pre>
$ <strong>uv run user_3.py</strong>
&nbsp;
Traceback (most recent call last):
  File "/tmp/ramdisk/pydantic/pydantic-demo/user_3.py", line 11, in &lt;module&gt;
    user1 = User(name="John", surname="Doe", age="unknown", registered="yes")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/tmp/ramdisk/pydantic/pydantic-demo/.venv/lib64/python3.12/site-packages/pydantic/main.py", line 253, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pydantic_core._pydantic_core.ValidationError: 1 validation error for User
<u>age</u>
  Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='unknown', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/int_parsing
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;toho mj.&nbsp;plyne, že modely by
ideálně neměly obsahovat atributy typu <strong>Any</strong>. Tím se totiž
připravíte o jednu z&nbsp;dobrých (možná dokonce nejlepších) vlastností
knihovny Pydantic.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Jak se pracuje s&nbsp;nepovinnými atributy?</h2>

<p>U mnoha modelů je nutné nějakým způsobem pracovat s&nbsp;nepovinnými
resp.&nbsp;s&nbsp;neznámými nebo nevyčíslitelnými atributy. Tyto atributy se
typicky nastavují na hodnotu <strong>None</strong>. Ovšem musíme si dát pozor
na to, že v&nbsp;Pythonu (na rozdíl od některých jiných programovacích jazyků)
má hodnota <strong>None</strong> svůj vlastní typ nazvaný
<strong>NoneType</strong>, který obecně <i>není</i> kompatibilní s&nbsp;jinými
typy (což je ostatně jen dobře!).</p>

<p>V&nbsp;našem testovacím modelu máme u všech atributů nastaveny konkrétní
datové typy a současně u nich neuvádíme žádné výchozí hodnoty. To ovšem
v&nbsp;důsledku znamená, že všechny atributy je nutné explicitně nastavit na
nějakou hodnotu, jejíž typ musí atributu odpovídat. Neboli například do
atributu <strong>age</strong> <i>není možné</i> předat hodnotu
<strong>None</strong>, která je odlišného typu. Můžeme si to ukázat:</p>

<pre>
from pydantic import BaseModel
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: int
    registered: bool
&nbsp;
&nbsp;
user1 = User(name="John", surname="Doe", <u>age=None</u>, <u>registered=None</u>)
print(user1)
</pre>

<p>Skript se pokusíme spustit běžným způsobem:</p>

<pre>
$ <strong>uv run user_4.py</strong>
</pre>

<p>Knihovna Pydantic správně odhalí, že se pokoušíme do atributů
<strong>age</strong> a <strong>registered</strong> předávat hodnoty
<strong>None</strong> a přitom jsou vyžadovány hodnoty typu
<strong>int</strong> resp.&nbsp;<strong>bool</strong>:</p>

<pre>
Traceback (most recent call last):
  File "/tmp/ramdisk/pydantic/pydantic-demo/user_4.py", line 11, in <module>
    user1 = User(name="John", surname="Doe", age=None, registered=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/tmp/ramdisk/pydantic/pydantic-demo/.venv/lib64/python3.12/site-packages/pydantic/main.py", line 253, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pydantic_core._pydantic_core.ValidationError: 2 validation errors for User
<u>age</u>
  Input should be a valid integer [type=int_type, input_value=None, input_type=NoneType]
    For further information visit https://errors.pydantic.dev/2.11/v/int_type
<u>registered</u>
  Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
    For further information visit https://errors.pydantic.dev/2.11/v/bool_type
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Atributy s&nbsp;typem umožňující i reprezentaci neexistující hodnoty</h2>

<p>Ukažme si nyní trojici způsobů, kterými je možné specifikovat, že některé
atributy mohou reprezentovat i neexistující hodnoty (neboli
<strong>None</strong>). První z&nbsp;naznačených způsobů je nejlepší, ovšem
vyžaduje novější verzi jazyka Python:</p>

<pre>
from pydantic import BaseModel
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: <u>int | None</u>
    registered: bool = False
&nbsp;
&nbsp;
user1 = User(name="John", surname="Doe", age=None)
print(user1)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si ještě jedné změny &ndash;
atribut <strong>registered</strong> má definovanou výchozí hodnotu, takže ho
není nutné explicitně uvádět. Pokud není jeho hodnota uživatelem/programátorem
zadána, přiřadí se mu právě nastavená výchozí hodnota.</div></p>

<p>Druhý způsob využívá typ <strong>Union</strong>, tedy &bdquo;spojení&ldquo;
více datových typů. Specifikujeme, že atribut <strong>age</strong> může být
typu celé číslo nebo typu <strong>NoneType</strong>:</p>

<pre>
from typing import Union
&nbsp;
from pydantic import BaseModel
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: Union[int, None]
    registered: bool = False
&nbsp;
&nbsp;
user1 = User(name="John", surname="Doe", age=None)
print(user1)
</pre>

<p>Ovšem vzhledem k&nbsp;tomu, že se <strong>Union[typ, None]</strong> používá
velmi často, je k&nbsp;dispozici i typ <strong>Optional</strong>
s&nbsp;prakticky stejnou sémantikou:</p>

<pre>
from typing import Optional
&nbsp;
from pydantic import BaseModel
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: Optional[int]
    registered: bool = False
&nbsp;
&nbsp;
user1 = User(name="John", surname="Doe", age=None)
print(user1)
</pre>

<p>Ve všech třech případech se objekt inicializuje naprosto stejným
způsobem:</p>

<pre>
name='John' surname='Doe' age=None registered=False
</pre>

<p><div class="rs-tip-major">Poznámka: nejlepší je první způsob zápisu, takže
pokud nemusíte podporovat starší interpretry Pythonu, použijte právě
ten.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Specializované datové typy poskytované knihovnou Pydantic</h2>

<p>V&nbsp;knihovně Pydantic nalezneme i některé specializované datové typy,
tj.&nbsp;typy, které konkretizují vlastnosti nějakého více univerzálního
datového typu. Velmi dobrým příkladem je typ nazvaný
<strong>PositiveInt</strong>. Jedná se o zúžení původního typu
<strong>int</strong> (tedy množina všech celých čísel) na čísla kladná. A
příkladem atributu, který by měl mít kladnou hodnotu (nebo nemusí být vůbec
známý) je atribut <strong>age</strong>, jehož definici změníme do podoby:</p>

<pre>
from pydantic import BaseModel, PositiveInt
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: <u>PositiveInt | None</u>
    registered: bool = False
&nbsp;
&nbsp;
user1 = User(name="John", surname="Doe", age=-1)
print(user1)
</pre>

<p>Model <strong>User</strong> nyní automaticky kontroluje nejenom to, zda je
atribut <strong>age</strong> zadán, ale i fakt, že se musí striktně jednat o
kladná čísla:</p>

<pre>
$ <strong>uv run user_6.py</strong>
&nbsp;
Traceback (most recent call last):
  File "/tmp/ramdisk/pydantic/pydantic-demo/user_6.py", line 11, in <module>
    user1 = User(name="John", surname="Doe", age=-1)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/tmp/ramdisk/pydantic/pydantic-demo/.venv/lib64/python3.12/site-packages/pydantic/main.py", line 253, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pydantic_core._pydantic_core.ValidationError: 1 validation error for User
<u>age</u>
  Input should be greater than 0 [type=greater_than, input_value=-1, input_type=int]
    For further information visit https://errors.pydantic.dev/2.11/v/greater_than
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Explicitní kontrola zadané hodnoty atributu</h2>

<p>U mnoha modelů existují další konkrétnější požadavky na hodnoty atributů.
Pokud nejsou tyto požadavky popsány nějakým datovým typem nebo jeho
specializací (ještě si ukážeme další příklady), je možné požadavek,
resp.&nbsp;přesněji řečeno podmínku, která musí být splněna, zapsat programově.
Příkladem může být opět kontrola zadaného věku. Předpokládejme, že se do
systému mohou registrovat jen dospělé osoby, tj.&nbsp;jejich věk by měl
dosáhnout alespoň osmnácti let. Takovou podmínku můžeme zapsat formou funkce,
která buď vrací upravenou hodnotu atributu nebo vyhodí výjimku typu
<strong>ValueError</strong> popř.&nbsp;<strong>ValidationError</strong>. Tuto
funkci s&nbsp;podmínkou je nutné zapsat s&nbsp;dekorátorem
<strong>field_validator</strong> tak, jak je to ukázáno v&nbsp;následujícím
skriptu:</p>

<pre>
from pydantic import BaseModel, PositiveInt, field_validator
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str
    surname: str
    age: PositiveInt | None
    registered: bool = False
&nbsp;
    @field_validator("age")
    def <strong>check_age</strong>(cls, value):
        if value &lt; 18:
            raise ValueError("You are too young to register")
        return value
&nbsp;
&nbsp;
user1 = User(name="John", surname="Doe", age=17)
print(user1)
</pre>

<p>Následuje ukázka provedené kontroly:</p>

<pre>
$ <strong>uv run user_7.py</strong>
&nbsp;
Traceback (most recent call last):
  File "/tmp/ramdisk/pydantic/pydantic-demo/user_7.py", line 17, in <module>
    user1 = User(name="John", surname="Doe", age=17)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/tmp/ramdisk/pydantic/pydantic-demo/.venv/lib64/python3.12/site-packages/pydantic/main.py", line 253, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pydantic_core._pydantic_core.ValidationError: 1 validation error for User
<u>age</u>
  Value error, <u>You are too young to register</u> [type=value_error, input_value=17, input_type=int]
    For further information visit https://errors.pydantic.dev/2.11/v/value_error
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se opět zobrazí
všechny důležité informace jak o provedené kontrole, tak i o chybě která
nastala.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Omezení délky řetězců zapisovaných do atributů</h2>

<p>Ve skutečnosti není nutné (a většinou ani vhodné) kontrolovat hodnoty
atributů programovým kódem. Výhodnější je využít dalších možností poskytovaných
knihovnou Pydantic, která umožňuje různé kontroly (resp.&nbsp;požadavky) zapsat
deklarativním způsobem. Dobrým příkladem může být požadavek na omezení délky
jména a příjmení na (řekněme) maximálně deset znaků. Pochopitelně by bylo možné
zapsat příslušnou kontrolu funkcí označenou dekorátorem, ale existuje i
jednodušší způsob spočívající ve využití objektu typu
<strong>Field</strong>.</p>

<p>K&nbsp;popisu tohoto objektu se ještě později vrátíme; dnes nám ovšem bude
postačovat znát, že mj.&nbsp;je možné parametrem <strong>max_length</strong>
omezit délku řetězců. Taktéž si povšimněte tří teček na místě prvního
parametru. V&nbsp;dokumentaci se tato trojtečka nazývá <i>ellipsis</i> a
v&nbsp;kontextu, ve kterém ji používáme, značí výchozí hodnotu:</p>

<pre>
from pydantic import BaseModel, Field, PositiveInt, field_validator
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str = <u>Field(..., max_length=10)</u>
    surname: str = <u>Field(..., max_length=10)</u>
    age: PositiveInt | None
    registered: bool = False
&nbsp;
    @field_validator("age")
    def <strong>check_age</strong>(cls, value):
        if value &lt; 18:
            raise ValueError("You are too young to register")
        return value
&nbsp;
&nbsp;
user1 = User(name="Nabuchodonozor", surname="II", age=18)
print(user1)
</pre>

<p>Otestování chování takto zapsaného modelu:</p>

<pre>
$ <strong>uv run user_8.py</strong>
&nbsp;
Traceback (most recent call last):
  File "/tmp/ramdisk/pydantic/pydantic-demo/user_8.py", line 17, in <module>
    user1 = User(name="Nabuchodonozor", surname="II", age=18)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/tmp/ramdisk/pydantic/pydantic-demo/.venv/lib64/python3.12/site-packages/pydantic/main.py", line 253, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pydantic_core._pydantic_core.ValidationError: 1 validation error for User
<u>name</u>
  <u>String should have at most 10 characters</u> [type=string_too_long, input_value='Nabuchodonozor', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/string_too_long
</pre>

<p><div class="rs-tip-major">Poznámka: opět si povšimněte velmi přesné
informace o chybě.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Přečtení a validace celé struktury z&nbsp;JSONu</h2>

<p>Velmi často se v&nbsp;praxi setkáme s&nbsp;tím, že datová struktura, která
se má v&nbsp;Pythonu zpracovat, je předána ve formátu JSON. Příkladem mohou být
různé webové služby atd. Deserializace datové struktury z&nbsp;JSONu současně
s&nbsp;její validací je možné provést přímo knihovnou Pydantic, a to konkrétně
zavoláním třídní metody nazvané <strong>model_validate_json</strong> (tato
metoda je dostupná pro každý model).</p>

<p>Opět si ukážeme jednoduchý příklad z&nbsp;deserializací a validací struktury
<strong>User</strong>:</p>

<pre>
from pydantic import BaseModel, Field, PositiveInt, field_validator
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str = Field(..., max_length=10)
    surname: str = Field(..., max_length=10)
    age: PositiveInt | None
    registered: bool = False
&nbsp;
    @field_validator("age")
    def <strong>check_age</strong>(cls, value):
        if value &lt; 18:
            raise ValueError("You are too young to register")
        return value
&nbsp;
&nbsp;
data = """
    {"name": "John",
     "surname": "Doe",
     "age": 18
    }
"""
&nbsp;
user1 = User.model_validate_json(data)
print(user1)
</pre>

<p>Výsledkem činnosti tohoto skriptu bude načtená a korektně zvalidovaná
hodnota typu <strong>User</strong>:</p>

<pre>
$ <strong>uv run user_9.py </strong>
&nbsp;
name='John' surname='Doe' age=18 registered=False
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Serializace celé struktury do formátu JSON</h2>

<p>Opakem deserializace datové struktury z&nbsp;formátu JSON je naopak její
serializace. I ta je knihovnou Pydantic podporována. Je přitom možné si zvolit,
zda má být výsledkem nenaformátovaný JSON vhodný pro strojové zpracování, nebo
JSON naformátovaný, s&nbsp;vhodným odsazením atd., který je mnohem čitelnější.
Obě možnosti jsou ukázány v&nbsp;dalším demonstračním příkladu:</p>

<pre>
from pydantic import BaseModel, Field, PositiveInt, field_validator
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str = Field(..., max_length=10)
    surname: str = Field(..., max_length=10)
    age: PositiveInt | None
    registered: bool = False
&nbsp;
    @field_validator("age")
    def <strong>check_age</strong>(cls, value):
        if value &lt; 18:
            raise ValueError("You are too young to register")
        return value
&nbsp;
&nbsp;
user1 = User(name="John", surname="Doe", age=18)
&nbsp;
as_json = user1.model_dump_json()
print(as_json)
&nbsp;
print()
&nbsp;
as_json = user1.model_dump_json(indent=4)
print(as_json)
</pre>

<p>Po spuštění tohoto skriptu se zobrazí dva JSONy se stejnými daty. První
z&nbsp;nich není naformátovaný, druhý již naformátovaný je, přičemž odsazení
vnitřních podstruktur má šířku čtyř mezer:</p>

<pre>
{"name":"John","surname":"Doe","age":18,"registered":false}
&nbsp;
{
    "name": "John",
    "surname": "Doe",
    "age": 18,
    "registered": false
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Komplikovanější datová struktura obsahující další struktury</h2>

<p>Prozatím měla námi definovaná datová struktura <strong>User</strong>
atributy s&nbsp;jednoduchými (primitivními) typy (sem pro jednoduchost řadím i
řetězce). Ovšem v&nbsp;praxi je situace mnohdy odlišná a pochopitelně se
setkáme i s&nbsp;takovými strukturami, které jako své atributy obsahují další
podstruktury. I tuto variantu knihovna Pydantic pochopitelně podporuje.
Příkladem může být definice modelu nazvaného <strong>Character</strong> se
třemi atributy, přičemž jeden z&nbsp;atributů je typu <strong>Address</strong>
(taktéž model) a další typu <strong>User</strong> (opět model):</p>

<pre>
from pydantic import BaseModel, Field, PositiveInt, field_validator
&nbsp;
&nbsp;
class <strong>Address</strong>(BaseModel):
    street: str
    house_number: PositiveInt | str
    city: str
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str = Field(..., max_length=10)
    surname: str = Field(..., max_length=10)
    age: PositiveInt | None
    registered: bool = False
&nbsp;
    @field_validator("age")
    def <strong>check_age</strong>(cls, value):
        if value &lt; 18:
            raise ValueError("You are too young to register")
        return value
&nbsp;
&nbsp;
class <strong>Character</strong>(BaseModel):
    role: str
    user: User
    address: Address
&nbsp;
&nbsp;
character = Character(
    role="Detective",
    user=User(name="Sherlock", surname="Holmes", age=42),
    address=Address(street="Baker", house_number="221B", city="London"),
)
&nbsp;
as_json = character.model_dump_json(indent=4)
print(as_json)
</pre>

<p>Knihovna Pydantic pochopitelně provádí (rekurzivně) i kontrolu všech
atributů. V&nbsp;tomto příkladu bude vše v&nbsp;naprostém pořádku:</p>

<pre>
$ <strong>uv run character_1.py </strong>
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
{
    "role": "Detective",
    "user": {
        "name": "Sherlock",
        "surname": "Holmes",
        "age": 42,
        "registered": false
    },
    "address": {
        "street": "Baker",
        "house_number": "221B",
        "city": "London"
    }
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Kontrola všech povinných atributů</h2>

<p>Již v&nbsp;předchozích kapitolách jsme si řekli, že knihovna Pydantic
kontroluje, jestli jsou při konstrukci objektu zadány všechny povinné atributy.
To platí i pro atributy, které jsou samy o sobě definovány modelem. Vykoušejme
si tedy, co se stane ve chvíli, kdy využijeme tento model:</p>

<pre>
class <strong>Character</strong>(BaseModel):
    role: str
    user: User
    address: Address
</pre>

<p>pro konstrukci objektu, u něhož nejsou uvedeny všechny jeho povinné
atributy:</p>

<pre>
character = Character(
    role="Detective",
    user=User(name="Sherlock", surname="Holmes", age=42)
)
</pre>

<p>To pochopitelně není dovoleno, takže opět dojde k&nbsp;běhové chybě, protože
je vyžadováno zadání celé adresy, tj.&nbsp;atributu popsaného modelem:</p>

<pre>
$ <strong>uv run character_2.py </strong>
&nbsp;
Traceback (most recent call last):
  File "/tmp/ramdisk/pydantic/pydantic-demo/character_2.py", line 29, in <module>
    character = Character(
                ^^^^^^^^^^
  File "/tmp/ramdisk/pydantic/pydantic-demo/.venv/lib64/python3.12/site-packages/pydantic/main.py", line 253, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
pydantic_core._pydantic_core.ValidationError: 1 validation error for Character
<u>address</u>
  <strong>Field required</strong> [type=missing, input_value={'role': 'Detective', 'us...e=42, registered=False)}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.11/v/missing
</pre>

<p>Pro úplnost si uveďme celý zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
from pydantic import BaseModel, Field, PositiveInt, field_validator
&nbsp;
&nbsp;
class <strong>Address</strong>(BaseModel):
    street: str
    house_number: PositiveInt | str
    city: str
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str = Field(..., max_length=10)
    surname: str = Field(..., max_length=10)
    age: PositiveInt | None
    registered: bool = False
&nbsp;
    @field_validator("age")
    def <strong>check_age</strong>(cls, value):
        if value &lt; 18:
            raise ValueError("You are too young to register")
        return value
&nbsp;
&nbsp;
class <strong>Character</strong>(BaseModel):
    role: str
    user: User
    address: Address
&nbsp;
&nbsp;
character = Character(
    role="Detective",
    user=User(name="Sherlock", surname="Holmes", age=42)
)
&nbsp;
as_json = character.model_dump_json(indent=4)
print(as_json)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Nepovinný atribut popsaný modelem</h2>

<p>Některé atributy, a to včetně atributů popsaných jiným modelem, pochopitelně
mohou být nepovinné. Příkladem může být atribut <strong>address</strong>, jehož
hodnotou je buď instance modelu <strong>Address</strong> nebo hodnota
<strong>None</strong> (víme již, že tento požadavek lze deklarovat třemi
různými způsoby; další dva vyžadují typy <strong>Union</strong> nebo
<strong>Optional</strong>):</p>

<pre>
class <strong>Character</strong>(BaseModel):
    role: str
    user: User
    address: <u>Address | None</u>
</pre>

<p>V&nbsp;tomto případě můžeme adresu při konstrukci objektu typu
<strong>Character</strong> legálně vynechat:</p>

<pre>
character = Character(
    role="Detective",
    user=User(name="Sherlock", surname="Holmes", age=42),
    address=None
)
</pre>

<p>Výsledek bude vypadat následovně:</p>

<pre>
$ <strong>uv run character_3.py</strong>
&nbsp;
{
    "role": "Detective",
    "user": {
        "name": "Sherlock",
        "surname": "Holmes",
        "age": 42,
        "registered": false
    },
    "address": null
}
</pre>

<p>A opět si pro úplnost uvedeme celý zdrojový kód tohoto demonstračního
příkladu:</p>

<pre>
from pydantic import BaseModel, Field, PositiveInt, field_validator
&nbsp;
&nbsp;
class <strong>Address</strong>(BaseModel):
    street: str
    house_number: PositiveInt | str
    city: str
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str = Field(..., max_length=10)
    surname: str = Field(..., max_length=10)
    age: PositiveInt | None
    registered: bool = False
&nbsp;
    @field_validator("age")
    def <strong>check_age</strong>(cls, value):
        if value &lt; 18:
            raise ValueError("You are too young to register")
        return value
&nbsp;
&nbsp;
class <strong>Character</strong>(BaseModel):
    role: str
    user: User
    address: Address | None
&nbsp;
&nbsp;
character = Character(
    role="Detective",
    user=User(name="Sherlock", surname="Holmes", age=42),
    address=None
)
&nbsp;
as_json = character.model_dump_json(indent=4)
print(as_json)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výchozí hodnota nepovinných atributů</h2>

<p>Poslední úprava, kterou v&nbsp;rámci dnešního článku provedeme, spočívá
v&nbsp;explicitním nastavení výchozí hodnoty nepovinného atributu &ndash; viz
podtržená část upravené definice modelu:</p>

<pre>
class <strong>Character</strong>(BaseModel):
    role: str
    user: User
    address: <u>Address | None = None</u>
</pre>

<p>Výsledek bude naprosto stejný, jako tomu bylo v&nbsp;předchozím
příkladu:</p>

<pre>
$ <strong>uv run character_4.py</strong>
&nbsp;
{
    "role": "Detective",
    "user": {
        "name": "Sherlock",
        "surname": "Holmes",
        "age": 42,
        "registered": false
    },
    "address": null
}
</pre>

<p>A opět si, dnes již naposledy, uvedeme celý zdrojový kód upraveného
skriptu:</p>

<pre>
from pydantic import BaseModel, Field, PositiveInt, field_validator
&nbsp;
&nbsp;
class <strong>Address</strong>(BaseModel):
    street: str
    house_number: PositiveInt | str
    city: str
&nbsp;
&nbsp;
class <strong>User</strong>(BaseModel):
    name: str = Field(..., max_length=10)
    surname: str = Field(..., max_length=10)
    age: PositiveInt | None
    registered: bool = False
&nbsp;
    @field_validator("age")
    def <strong>check_age</strong>(cls, value):
        if value &lt; 18:
            raise ValueError("You are too young to register")
        return value
&nbsp;
&nbsp;
class <strong>Character</strong>(BaseModel):
    role: str
    user: User
    address: Address | None = None
&nbsp;
&nbsp;
character = Character(
    role="Detective",
    user=User(name="Sherlock", surname="Holmes", age=42)
)
&nbsp;
as_json = character.model_dump_json(indent=4)
print(as_json)
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujícího článku</h2>

<p>V&nbsp;dnešním článku jsme se seznámili pouze s&nbsp;naprostými základy
knihovny Pydantic. Jedná se o poměrně rozsáhlou knihovnu s&nbsp;mnoha dalšími
možnostmi. S&nbsp;některými z&nbsp;těchto pokročilejších vlastností se setkáme
v&nbsp;navazujícím článku, ve kterém si představíme reálné (nutno podotknout,
že poměrně rozsáhlé) modely, jejichž deklarace jsou popsány několika sty
programovými řádky, takže se skutečně nejedná pouze o jednoduché ukázkové
příklady. Taktéž si ukážeme, jakým způsobem je možné z&nbsp;deklarace modelů
vygenerovat dokumentaci, a to jak v&nbsp;textové, tak i v&nbsp;grafické
podobě.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady vytvořené v&nbsp;Pythonu a popsané v&nbsp;dnešním
článku najdete v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs/">https://github.com/tisnik/most-popular-python-libs/</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>user_01.py</td><td>definice vlastního jednoduchého modelu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_01.py</a></td></tr>
<tr><td> 2</td><td>user_02.py</td><td>inicializace objektu s&nbsp;explicitním nastavením všech jeho atributů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_02.py</a></td></tr>
<tr><td> 3</td><td>user_03.py</td><td>typová kontrola atributů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_03.py</a></td></tr>
<tr><td> 4</td><td>user_04.py</td><td>pokus o nastavení některých atributů na hodnotu <strong>None</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_04.py</a></td></tr>
<tr><td> 5</td><td>user_05.py</td><td>atributy s&nbsp;typem umožňující i reprezentaci neexistující hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_05.py</a></td></tr>
<tr><td> 6</td><td>user_06.py</td><td>ukázka použití specializovaného typu poskytovaného knihovnou <i>Pydantic</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_06.py</a></td></tr>
<tr><td> 7</td><td>user_07.py</td><td>explicitní kontrola zadané hodnoty atributu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_07.py</a></td></tr>
<tr><td> 8</td><td>user_08.py</td><td>omezení délky řetězců zapisovaných do atributů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_08.py</a></td></tr>
<tr><td> 9</td><td>user_09.py</td><td>přečtení celé datové struktury z&nbsp;JSONu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_09.py</a></td></tr>
<tr><td>10</td><td>user_10.py</td><td>zápis modelu do formátu JSON</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/user_10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>character_1.py</td><td>komplikovanější datová struktura obsahující další struktury</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/character_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/character_1.py</a></td></tr>
<tr><td>12</td><td>character_2.py</td><td>kontrola všech povinných atributů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/character_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/character_2.py</a></td></tr>
<tr><td>13</td><td>character_3.py</td><td>výchozí hodnota strukturovaných atributů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/character_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/character_3.py</a></td></tr>
<tr><td>14</td><td>character_4.py</td><td>nepovinné strukturované atributy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/character_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/character_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>pyproject.toml</td><td>soubor s&nbsp;definicí projektu i s&nbsp;jeho závislostmi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/pyproject.toml">https://github.com/tisnik/most-popular-python-libs/blob/master/pydantic/pyproject.toml</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Pydantic: domácí stránka<br />
<a href="https://docs.pydantic.dev/latest/">https://docs.pydantic.dev/latest/</a>
</li>

<li>Pydantic na GitHubu<br />
<a href="https://github.com/pydantic/pydantic">https://github.com/pydantic/pydantic</a>
</li>

<li>Pydantic na PyPi<br />
<a href="https://pypi.org/project/pydantic/">https://pypi.org/project/pydantic/</a>
</li>

<li>Introduction to Python Pydantic Library<br />
<a href="https://www.geeksforgeeks.org/python/introduction-to-python-pydantic-library/">https://www.geeksforgeeks.org/python/introduction-to-python-pydantic-library/</a>
</li>

<li>An introduction to Pydantic (with basic example)<br />
<a href="https://www.slingacademy.com/article/an-introduction-to-pydantic-with-basic-example/">https://www.slingacademy.com/article/an-introduction-to-pydantic-with-basic-example/</a>
</li>

<li>Pydantic: Simplifying Data Validation in Python<br />
<a href="https://realpython.com/python-pydantic/">https://realpython.com/python-pydantic/</a>
</li>

<li>Pydantic: A Guide With Practical Examples<br />
<a href="https://www.datacamp.com/tutorial/pydantic">https://www.datacamp.com/tutorial/pydantic</a>
</li>

<li>Pydantic validators<br />
<a href="https://docs.pydantic.dev/latest/concepts/validators/">https://docs.pydantic.dev/latest/concepts/validators/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (2.část)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/</a>
</li>

<li>Novinky v&nbsp;typovém systému přidané do Pythonu 3.12<br />
<a href="https://www.root.cz/clanky/novinky-v-typovem-systemu-pridane-do-pythonu-3-12/">https://www.root.cz/clanky/novinky-v-typovem-systemu-pridane-do-pythonu-3-12/</a>
</li>

<li>Mastering Pydantic - A Guide for Python Developers<br />
<a href="https://dev.to/devasservice/mastering-pydantic-a-guide-for-python-developers-3kan">https://dev.to/devasservice/mastering-pydantic-a-guide-for-python-developers-3kan</a>
</li>

<li>7 Best Python Libraries for Validating Data<br />
<a href="https://www.yeahhub.com/7-best-python-libraries-validating-data/">https://www.yeahhub.com/7-best-python-libraries-validating-data/</a>
</li>

<li>Universally unique identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">https://en.wikipedia.org/wiki/Universally_unique_identifier</a>
</li>

<li>UUID objects according to RFC 4122 (knihovna pro Python)<br />
<a href="https://docs.python.org/3.5/library/uuid.html#uuid.uuid4">https://docs.python.org/3.5/library/uuid.html#uuid.uuid4</a>
</li>

<li>Object identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Object_identifier">https://en.wikipedia.org/wiki/Object_identifier</a>
</li>

<li>Digital object identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Digital_object_identifier">https://en.wikipedia.org/wiki/Digital_object_identifier</a>
</li>

<li>voluptuous na (na PyPi)<br />
<a href="https://pypi.python.org/pypi/voluptuous">https://pypi.python.org/pypi/voluptuous</a>
</li>

<li>voluptuous (na GitHubu)<br />
<a href="https://github.com/alecthomas/voluptuous">https://github.com/alecthomas/voluptuous</a>
</li>

<li>pytest-voluptuous 1.0.2 (na PyPi)<br />
<a href="https://pypi.org/project/pytest-voluptuous/">https://pypi.org/project/pytest-voluptuous/</a>
</li>

<li>pytest-voluptuous (na GitHubu)<br />
<a href="https://github.com/F-Secure/pytest-voluptuous">https://github.com/F-Secure/pytest-voluptuous</a>
</li>

<li>schemagic 0.9.1 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schemagic/0.9.1">https://pypi.python.org/pypi/schemagic/0.9.1</a>
</li>

<li>Schemagic / Schemagic.web (na GitHubu)<br />
<a href="https://github.com/Mechrophile/schemagic">https://github.com/Mechrophile/schemagic</a>
</li>

<li>schema 0.6.7 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schema">https://pypi.python.org/pypi/schema</a>
</li>

<li>schema (na GitHubu)<br />
<a href="https://github.com/keleshev/schema">https://github.com/keleshev/schema</a>
</li>

<li>XML Schema validator and data conversion library for Python<br />
<a href="https://github.com/brunato/xmlschema">https://github.com/brunato/xmlschema</a>
</li>

<li>xmlschema 0.9.7<br />
<a href="https://pypi.python.org/pypi/xmlschema/0.9.7">https://pypi.python.org/pypi/xmlschema/0.9.7</a>
</li>

<li>jsonschema 2.6.0<br />
<a href="https://pypi.python.org/pypi/jsonschema">https://pypi.python.org/pypi/jsonschema</a>
</li>

<li>Tired of Pydantic? Try These 5 Game-Changing Python Libraries<br />
<a href="https://developer-service.blog/tired-of-pydantic-try-these-5-game-changing-python-libraries/">https://developer-service.blog/tired-of-pydantic-try-these-5-game-changing-python-libraries/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

