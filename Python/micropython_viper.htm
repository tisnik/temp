<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Překlad funkcí přímo do nativního kódu MicroPythonem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Překlad funkcí přímo do nativního kódu MicroPythonem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Překlad funkcí přímo do nativního kódu MicroPythonem</a></p>
<p><a href="#k02">2. Tři způsoby překladu funkcí v&nbsp;MicroPythonu</a></p>
<p><a href="#k03">3. Překlad funkcí do nativního kódu</a></p>
<p><a href="#k04">4. Použití překladače Viper</a></p>
<p><a href="#k05">5. 32bitová aritmetika pro co nejvyšší výpočetní výkon</a></p>
<p><a href="#k06">6. Rychlost výpočtů &ndash; programové smyčky</a></p>
<p><a href="#k07">7. Výsledky benchmarků</a></p>
<p><a href="#k08">8. Povinné přidání typových informací</a></p>
<p><a href="#k09">9. Rychlost výpočtů &ndash; volání funkce</a></p>
<p><a href="#k10">10. Realizace stejné funkce přímo s&nbsp;využitím strojových instrukcí</a></p>
<p><a href="#k11">*** 11. Výsledky benchmarků</a></p>
<p><a href="#k12">*** 12. Jak vlastně vypadají funkce přeložené do nativního kódu?</a></p>
<p><a href="#k13">*** 13. Strojový kód funkce <strong>add</strong></a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. Další optimalizace v&nbsp;MicroPythonu</a></p>
<p><a href="#k17">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Překlad funkcí přímo do nativního kódu MicroPythonem</h2>

<p>V&nbsp;předchozí trojici článků o projektu MicroPython [<a
href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu/">1</a>],
[<a
href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-2/">2</a>],
[<a
href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-dokonceni/">3</a>]
jsme se seznámili s&nbsp;tím, jakým způsobem je možné přímo v&nbsp;MicroPythonu
vytvářet funkce obsahující strojové instrukce patřící do instrukčních sad
<i>Thumb</i> a <i>Thumb-2</i>. Jedná se o (pochopitelně z&nbsp;mého pohledu)
velmi užitečnou techniku, která může programování na úrovni instrukcí přiblížit
i začátečníkům, protože nevyžaduje časové investice do zaučení práce
s&nbsp;assemblerem (včetně všech jeho zákeřností) a dalších nástrojů (nehledě
na to, že propojení nativního kódu s&nbsp;Pythonem není jednoduché a vyžaduje
další znalosti). Ovšem ani v&nbsp;případech, v&nbsp;nichž je zapotřebí urychlit
běh některých funkcí, není nutné přecházet přímo &bdquo;ke strojáku&ldquo;.
MicroPython totiž umožňuje překlad vybraných funkcí do nativního kódu a nikoli
do bajtkódu Pythonu. To je velmi užitečné především v&nbsp;oblasti mikrořadičů,
kde například reakce na různé události musí být co nejrychlejší atd.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Tři způsoby překladu funkcí v&nbsp;MicroPythonu</h2>

<p>Ve skutečnosti v&nbsp;současném MicroPythonu existují celkem tři různé
způsoby, jakými mohou být funkce přeloženy. K&nbsp;překladu dochází
v&nbsp;každém případě, liší se ovšem výsledek i vlastní způsob překladu.
V&nbsp;každém případě je zdrojový kód funkce nejprve načten, následně je
provedena lexikální analýza a dále je zparsován a transformován do abstraktního
syntaktického stromu (AST). Další krok je již volitelný a je možné si
vybrat:</p>

<ol>

<li>Funkce může být přeložena do bajtkódu Pythonu. Tento bajtkód je posléze
spuštěn ve virtuálním stroji Pythonu. Toto řešení se vlastně nijak neodlišuje
od standardního CPythonu. A pochopitelně se kvůli nutnosti interpretace
bajtkódu jedná o obecně nejpomalejší řešení.</li>

<li>Funkce ovšem může být přeložena i do nativního kódu dané platformy.
Výsledný nativní (strojový) kód sice zabere v&nbsp;operační paměti (či ve
Flash) více místa než bajtkód, ovšem výsledek bude rychlejší, jak ostatně
uvidíme na benchmarcích.</li>

<li>Překlad může být proveden i s&nbsp;využitím technologie nazvané
<i>Viper</i>, která kromě jiného dokáže pracovat s&nbsp;32bitovými
celočíselnými hodnotami namísto typu <i>long</i>. Výsledek by měl být
v&nbsp;tomto případě nejrychlejší (předpokládáme běh na 32bitových
mikrořadičích a mikroprocesorech), ovšem oproti bajtkódu se opět jedná o
paměťově náročnější variantu.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: někdy se výše uvedené nástroje nazývají
<i>code emmiter(s)</i>, protože se jedná pouze o jeden z&nbsp;kroků
překladu.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad funkcí do nativního kódu</h2>

<p>Ukažme si nejprve běžnou Pythonovskou funkci, která po svém zavolání získá
jeden číselný argument, sečte ho se sebou samým a vrátí výsledek tohoto součtu.
Do této funkce pro zajímavost předáme celočíselné hodnoty pohybující se okolo
2<sup>31</sup> (proč, to uvidíme dále):</p>

<pre>
def <strong>foo</strong>(x):
    return x+x
&nbsp;
&nbsp;
for i in range(0x7ffffffc, 0x80000008):
    print(hex(foo(i)))
</pre>

<p>Výsledkem budou tyto hodnoty, které plně odpovídají očekávání:</p>

<pre>
0xfffffff8
0xfffffffa
0xfffffffc
0xfffffffe
0x100000000
0x100000002
0x100000004
0x100000006
0x100000008
0x10000000a
0x10000000c
0x10000000e
</pre>

<p>Předchozí funkce byla po lexikální analýze a parsingu převedena do bajtkódu.
Stejnou funkci je ovšem možné přeložit do nativního kódu dané platformy.
Postačí před ní zapsat dekorátor <strong>@micropython.native</strong>:</p>

<pre>
<i>@micropython.native</i>
def <strong>foo</strong>(x):
    return x+x
&nbsp;
&nbsp;
for i in range(0x7ffffffc, 0x80000008):
    print(hex(foo(i)))
</pre>

<p>I tímto způsobem přeložená funkce bude stále vracet korektní výsledky:</p>

<pre>
0xfffffff8
0xfffffffa
0xfffffffc
0xfffffffe
0x100000000
0x100000002
0x100000004
0x100000006
0x100000008
0x10000000a
0x10000000c
0x10000000e
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je funkce
<strong>foo</strong> mnohem obecnější, protože kromě číselných hodnot akceptuje
i některé další hodnoty, pro které je definován operátor +. O tom se ostatně
můžeme velmi snadno přesvědčit:</div></p>

<pre>
&gt;&gt;&gt; <strong>foo("abc")</strong>
'abcabc'
&nbsp;
&gt;&gt;&gt; <strong>foo([1,2,3])</strong>
[1, 2, 3, 1, 2, 3]
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Použití překladače Viper</h2>

<p>Namísto výše uvedeného dekorátoru <strong>@micropython.native</strong> ovšem
můžeme zapsat i dekorátor <strong>@micropython.viper</strong>. Tento dekorátor
povoluje odlišný typ překladu do strojového kódu, v&nbsp;němž může docházet
k&nbsp;více optimalizacím, ovšem výsledné chování nemusí odpovídat klasickému
Pythonu:</p>

<pre>
<i>@micropython.viper</i>
def <strong>foo</strong>(x):
    return x+x
&nbsp;
&nbsp;
for i in range(0x7ffffffc, 0x80000008):
    print(hex(foo(i)))
</pre>

<p>Výsledky získané po zavolání této funkce budou stále korektní:</p>

<pre>
0xfffffff8
0xfffffffa
0xfffffffc
0xfffffffe
0x100000000
0x100000002
0x100000004
0x100000006
0x100000008
0x10000000a
0x10000000c
0x10000000e
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. 32bitová aritmetika pro co nejvyšší výpočetní výkon</h2>

<p>Překladači (či možná přesněji řečeno &bdquo;emitoru strojového kódu&ldquo;)
<i>Viper</i> můžeme předat i funkci s&nbsp;typovými informacemi (<i>type
hints</i>). Lze například specifikovat, že parametr funkce je typu
<strong>uint</strong> a i výsledkem funkce bude hodnota typu
<strong>uint</strong>. V&nbsp;kontextu Viperu znamená <strong>uint</strong>
32bitovou celočíselnou hodnotu bez znaménka:</p>

<pre>
<i>@micropython.viper</i>
def <strong>foo</strong>(x: uint) -&gt; uint:
    return x+x
&nbsp;
&nbsp;
for i in range(0x7ffffffc, 0x80000008):
    print(hex(foo(i)))
</pre>

<p>Nyní se bude funkce chovat odlišně &ndash; všechny výpočty budou skutečně
prováděny v&nbsp;32bitové aritmetice a bude tedy docházet
k&nbsp;přetečení:</p>

<pre>
0xfffffff8
0xfffffffa
0xfffffffc
0xfffffffe
0x0
0x2
0x4
0x6
0x8
0xa
0xc
0xe
</pre>

<p>Navíc již nebude takto specifikovaná funkce tak univerzální, jako funkce
předcházející, což si můžeme snadno ověřit:</p>

<pre>
&gt;&gt;&gt; <strong>foo("abc")</strong>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't convert str to int
&nbsp;
&gt;&gt;&gt; <strong>foo([1,2,3])</strong>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't convert list to int
</pre>

<p><div class="rs-tip-major">Poznámka: tato funkce bude po svém zavolání
provedena nejrychleji, ovšem je nutné mít na paměti, že její chování není
kompatibilní s&nbsp;CPythonem (což ale v&nbsp;těchto konkrétních případech
nemusí být na škodu).</div></p>

<p>Ve skutečnosti ovšem nejsme omezeni na beznaménkové typy:</p>

<pre>
<i>@micropython.viper</i>
def <strong>bar</strong>() -&gt; int:
    return int(0xffffffff)
&nbsp;
&nbsp;
print(bar())
</pre>

<p>Tento příklad po svém překladu a spuštění v&nbsp;MicroPythonu vypíše hodnotu
-1.</p>

<p>Naproti tomu:</p>

<pre>
<i>@micropython.viper</i>
def <strong>bar</strong>() -&gt; uint:
    return uint(0xffffffff)
&nbsp;
&nbsp;
print(bar())
</pre>

<p>vypíše hodnotu 4294967295.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rychlost výpočtů &ndash; programové smyčky</h2>

<p>Nyní již víme, jakým způsobem lze nějakou funkci přeložit do bajtkódu, do
nativního kódu a popř.&nbsp;do optimalizovaného nativního kódu. Zbývá zjistit,
zda se vůbec vyplatí překlad do nativního kódu. Pokusme se nejdříve o změření
doby trvání funkce se dvěma vnořenými smyčkami. Celkově se hodnota lokální
proměnné <strong>x</strong> zvýší milionkrát a posléze se vypíše:</p>

<pre>
def <strong>loop</strong>():
    x = 0
    for i in range(1000):
        for j in range(1000):
            x+=1
    print(x)
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
loop()
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>Zkusme nyní stejnou funkci přeložit do strojového kódu a posléze změřit dobu
jejího běhu:</p>

<pre>
<i>@micropython.native</i>
def <strong>loop</strong>():
    x = 0
    for i in range(1000):
        for j in range(1000):
            x+=1
    print(x)
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
loop()
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>A konečně přichází na řadu technologie Viper:</p>

<pre>
<i>@micropython.viper</i>
def <strong>loop</strong>():
    x = 0
    for i in range(1000):
        for j in range(1000):
            x+=1
    print(x)
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
loop()
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledky benchmarků</h2>

<p>Podívejme se nyní na dobu běhu všech tří variant funkcí:</p>

<table>
<tr><th>Varianta</th><th>Doba běhu</th></tr>
<tr><td>bajtkód</td><td>5348108</td></tr>
<tr><td>nativní kód</td><td>2398861</td></tr>
<tr><td>překlad Viperem</td><td>236460</td></tr>
</table>

<p>Přeložená funkce je tedy více než dvojnásobně rychlejší než varianta
přeložená do bajtkódu (a poté interpretovaná). Ovšem přesvědčivě vyhrála
technologie Viper, která je ještě desetkrát rychlejší, než funkce přeložená do
nativního kódu přes dekorátor @micropython.native a tedy více než dvacetkrát
rychlejší, než funkce interpretovaná.</p>

<p><div class="rs-tip-major">Poznámka: samozřejmě nás zajímají relativní poměry
mezi výsledky a nikoli absolutní hodnoty. Ty totiž závisí na rychlosti
použitého mikrořadiče.</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: jen na okraj &ndash;
výsledky benchmarků jsou velmi stabilní a při každém běhu dostaneme prakticky
stejné hodnoty. To je výhoda malých mikrořadičů bez plnohodnotného operačního
systému s&nbsp;multitaskingem a mnoha na pozadí běžícími úlohami. Navíc je
architektura mikrořadičů poměrně dobře predikovatelná, na rozdíl od
mikroprocesorů pro PC, které mohou úlohu předávat mezi výkonnými a
&bdquo;zelenými&ldquo; jádry, přiškrcovat frekvenci při zahřátí CPU a provádět
další operace, které výsledky benchmarků mohou zkreslit (někdy i dost
významně).</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Povinné přidání typových informací</h2>

<p>Pokusme se nyní funkci s&nbsp;dvojicí vnořených smyček upravit tak, aby
namísto tisku výsledku vrátila hodnotu naakumulovanou v&nbsp;proměnné
<strong>x</strong>:</p>

<pre>
<i>@micropython.viper</i>
def <strong>loop</strong>():
    x = 0
    for i in range(1000):
        for j in range(1000):
            x+=1
    return x
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
loop()
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>Tato funkce, pokud bude překládaná přes Viper, nebude akceptována:</p>

<pre>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 7, in loop
ViperTypeError: return expected 'object' but got 'int'
</pre>

<p>Proč tomu tak je? V&nbsp;Pythonu jsou všechny hodnoty považovány za objekty,
a přístup k&nbsp;nim je řešen přes reference. Ovšem Viper odvodil, že proměnná
<strong>x</strong> je typu <strong>int</strong> a nyní neví, jak tuto hodnotu
převést na objekt (předpokládá totiž, že funkce vrací objekt). Pomoc je
v&nbsp;tomto případě relativně snadná &ndash; opět použijeme typové
informace:</p>

<pre>
<i>@micropython.viper</i>
def <strong>loop</strong>() -&gt; int:
    x = 0
    for i in range(1000):
        for j in range(1000):
            x+=1
    return x
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
loop()
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p><div class="rs-tip-major">Poznámka: doba běhu této funkce se stále pohybuje
v&nbsp;hodnotách 236 milisekund na použitém mikrořadiči.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Rychlost výpočtů &ndash; volání funkce</h2>

<p>U funkcí, v&nbsp;nichž se požívají vnořené programové smyčky, spouští se
výpočty s&nbsp;32bitovými hodnotami atd., již máme alespoň rámcovou představu,
jakého urychlení lze jejich překladem do nativního kódu dosáhnout. Ovšem ještě
je nutné zjistit, jak je časově náročné <i>volání</i> funkcí, konkrétně funkcí
přeložených do bajtkódu, nativního kódu či nativního kódu emitovaného
Viperem.</p>

<p>Vyzkoušejme si například jednoduchý benchmark, v&nbsp;němž budeme opakovaně
volat funkci <strong>add</strong>. První varianta funkce je překládaná do
bajtkódu:</p>

<pre>
def <strong>add</strong>(x, y):
    return x+y
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
x = 0
for i in range(10000):
    x = add(x, 10)
&nbsp;
print(x)
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>Podobně budeme volat funkci přeloženou do nativního kódu:</p>

<pre>
<i>@micropython.native</i>
def <strong>add</strong>(x, y):
    return x+y
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
x = 0
for i in range(10000):
    x = add(x, 10)
&nbsp;
print(x)
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>Stejným způsobem si můžeme nechat funkci přeložit Viperem:</p>

<pre>
<i>@micropython.viper</i>
def <strong>add</strong>(x, y):
    return x+y
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
x = 0
for i in range(10000):
    x = add(x, 10)
&nbsp;
print(x)
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>

<p>Ve čtvrté variantě taktéž použijeme Viper, ovšem s&nbsp;plným uvedením
typových informací u parametrů i u návratové hodnoty:</p>

<pre>
<i>@micropython.viper</i>
def <strong>add</strong>(x: int, y: int) -&gt; int:
    return x+y
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
&nbsp;
x: int = 0
for i in range(10000):
    x = add(x, 10)
&nbsp;
print(x)
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Realizace stejné funkce přímo s&nbsp;využitím strojových instrukcí</h2>

<p>Pro zajímavost a porovnání si funkci přepišme z&nbsp;Pythonu do instrukcí
z&nbsp;instrukční sady Thumb. To pro nás není nic nového a postačuje vědět, že
první parametr funkce se předává v&nbsp;registru <strong>R0</strong> a druhý
parametr v&nbsp;registru <strong>R1</strong>. Výsledek funkce je očekáván
v&nbsp;registru <strong>R0</strong>, takže se nám vlastně celý problém
&bdquo;smrskne&ldquo; na jedinou strojovou instrukci <strong>add</strong>, ke
které je přidána dvojice instrukcí <strong>push</strong> a
<strong>pop</strong>:</p>

<pre>
<i>@micropython.asm_thumb</i>
def <strong>add</strong>(r0, r1):
    add(r0, r0, r1)
&nbsp;
&nbsp;
import utime
t1 = utime.ticks_us()
&nbsp;
x: int = 0
for i in range(10000):
    x = add(x, 10)
&nbsp;
print(x)
t2 = utime.ticks_us()
print(utime.ticks_diff(t2, t1))
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výsledky benchmarků</h2>

<p>Z&nbsp;výsledků benchmarků vyplývá, že nativní kód je opět rychlejší (což se
dalo očekávat), ovšem urychlení již není tak významné. To je vlastně i
pochopitelné, protože se hodně času stráví v&nbsp;kódu pro předávání parametrů
a v&nbsp;neoptimalizovaném Pythonovském kódu. Povšimněte si však, že přidání
typových informací do funkce překládané Viperem situaci paradoxně zhoršilo, i
když nepatrně. A realizace přímo ve strojovém kódu kupodivu není rychlejší, což
souvisí s&nbsp;transformacemi hodnot z&nbsp;Pythonních objektů do nativních
32bitových hodnot a zpět:</p>

<table>
<tr><th>Varianta</th><th>Doba běhu</th></tr>
<tr><td>bajtkód</td><td>208311</td></tr>
<tr><td>nativní kód</td><td>163235</td></tr>
<tr><td>překlad Viperem</td><td>136255</td></tr>
<tr><td>překlad Viperem + typové informace</td><td>145537</td></tr>
<tr><td>použití instrukcí Thumb</td><td>137725</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: u takto krátkých funkcí, u nichž se více
času stráví samotným voláním funkce a předáváním argumentů, se pravděpodobně
překlad do nativního kódu nemusí vyplácet.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Jak vlastně vypadají funkce přeložené do nativního kódu?</h2>

<pre>
import machine
import array
&nbsp;
&nbsp;
def <strong>inspect</strong>(f):
    baddr = bytes(array.array("O", [f]))
    addr = int.from_bytes(baddr, "little")
    print("function object at: 0x%08x" % addr)
    print("number of args:     %u" % machine.mem32[addr + 8])
    code_addr = machine.mem32[addr + 12]
    print("machine code at:    0x%08x" % code_addr)
    previous = -1
    size = 0
    while True:
        current = machine.mem8[code_addr + size]
        size += 1
        if current == 0xbd and previous == 0xfe:
            break
        previous = current
    print(f"machine code size:  {size} bytes")
    print("-- code --")
    for i in range(size):
        print(f"{machine.mem8[code_addr + i]:02x}", end=" ")
        if i % 16 == 15:
            print()
    print("\n----------")
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Strojový kód funkce <strong>add</strong></h2>

<pre>
<i>@micropython.viper</i>
def <strong>add</strong>(x, y):
    return x+y
&nbsp;
&nbsp;
&nbsp;
&gt;&gt;&gt; <strong>inspect(add)</strong>
&nbsp;
function object at: 0x2000e2b0
number of args:     0
machine code at:    0x2000e510
machine code size:  66 bytes
-- code --
fe b5 47 68 ff 68 3f 68 08 46 11 46 1e 46 00 29 
00 d0 03 e0 02 22 90 42 00 d1 07 e0 00 4a 01 e0 
04 00 04 00 3b 46 34 33 db 6f 98 47 30 68 04 46 
70 68 05 46 2a 46 21 46 1b 20 bb 6c 98 47 ff e7 
fe bd 
----------
</pre>

<pre>
<i>@micropython.viper</i>
def <strong>add</strong>(x: int, y: int) -&gt; int:
    return x+y
</pre>

<pre>
&gt;&gt;&gt; <strong>inspect(add)</strong>
function object at: 0x2000f340
number of args:     0
machine code at:    0x2000f5a0
machine code size:  80 bytes
-- code --
fe b5 47 68 ff 68 3f 68 08 46 11 46 1e 46 00 29 
00 d0 03 e0 02 22 90 42 00 d1 07 e0 00 4a 01 e0 
04 00 04 00 3b 46 34 33 db 6f 98 47 30 68 02 21 
fb 68 98 47 04 46 70 68 02 21 fb 68 98 47 05 46 
21 46 49 19 08 46 02 21 3b 69 98 47 ff e7 fe bd 
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
push {r1, r2, r3, r4, r5, r6, r7, lr}
ldr r7, [r0, #4]
ldr r7, [r7, #0xc]
ldr r7, [r7]
mov r0, r1
mov r1, r2
mov r6, r3
cmp r1, #0
beq #0x14
b #0x1c
movs r2, #2
cmp r0, r2
bne #0x1c
b #0x2c
ldr r2, [pc, #0]
b #0x24
movs r4, r0
movs r4, r0
mov r3, r7
adds r3, #0x34
ldr r3, [r3, #0x7c]
blx r3
ldr r0, [r6]
movs r1, #2
ldr r3, [r7, #0xc]
blx r3
mov r4, r0
ldr r0, [r6, #4]
movs r1, #2
ldr r3, [r7, #0xc]
blx r3
mov r5, r0
mov r1, r4
adds r1, r1, r5
mov r0, r1
movs r1, #2
ldr r3, [r7, #0x10]
blx r3
b #0x4e
pop {r1, r2, r3, r4, r5, r6, r7, pc}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
<i>@micropython.viper</i>
def <strong>loop</strong>() -&gt; int:
    x = 0
    for i in range(1000):
        for j in range(1000):
            x+=1
    return x
</pre>

<pre>
&gt;&gt;&gt; <strong>inspect(loop)</strong>
function object at: 0x200100e0
number of args:     0
machine code at:    0x20010500
machine code size:  152 bytes
-- code --
fe b5 82 b0 47 68 ff 68 3f 68 08 46 11 46 1e 46 
00 29 00 d0 03 e0 00 22 90 42 00 d1 04 e0 00 22 
3b 46 34 33 db 6f 98 47 00 24 00 21 00 91 20 e0 
00 98 05 46 00 90 00 21 01 91 0a e0 01 98 06 46 
01 22 21 46 89 18 0c 46 01 90 01 22 01 99 89 18 
01 91 01 98 7d 22 d2 00 01 46 01 90 91 42 01 db 
00 20 00 e0 01 20 00 28 e8 d1 01 22 00 99 89 18 
00 91 00 98 7d 22 d2 00 01 46 00 90 91 42 01 db 
00 20 00 e0 01 20 00 28 d2 d1 00 20 02 21 3b 69 
98 47 ff e7 02 b0 fe bd 
</pre>

<pre>
push {r1, r2, r3, r4, r5, r6, r7, lr}
sub sp, #8
ldr r7, [r0, #4]
ldr r7, [r7, #0xc]
ldr r7, [r7]
mov r0, r1
mov r1, r2
mov r6, r3
cmp r1, #0
beq #0x16
b #0x1e
movs r2, #0
cmp r0, r2
bne #0x1e
b #0x28
movs r2, #0
mov r3, r7
adds r3, #0x34
ldr r3, [r3, #0x7c]
blx r3
movs r4, #0
movs r1, #0
str r1, [sp]
b #0x72
ldr r0, [sp]
mov r5, r0
str r0, [sp]
movs r1, #0
str r1, [sp, #4]
b #0x52
ldr r0, [sp, #4]
mov r6, r0
movs r2, #1
mov r1, r4
adds r1, r1, r2
mov r4, r1
str r0, [sp, #4]
movs r2, #1
ldr r1, [sp, #4]
adds r1, r1, r2
str r1, [sp, #4]
ldr r0, [sp, #4]
movs r2, #0x7d
lsls r2, r2, #3
mov r1, r0
str r0, [sp, #4]
cmp r1, r2
blt #0x64
movs r0, #0
b #0x66
movs r0, #1
cmp r0, #0
bne #0x3c
movs r2, #1
ldr r1, [sp]
adds r1, r1, r2
str r1, [sp]
ldr r0, [sp]
movs r2, #0x7d
lsls r2, r2, #3
mov r1, r0
str r0, [sp]
cmp r1, r2
blt #0x84
movs r0, #0
b #0x86
movs r0, #1
cmp r0, #0
bne #0x30
movs r0, #0
movs r1, #2
ldr r3, [r7, #0x10]
blx r3
b #0x94
add sp, #8
pop {r1, r2, r3, r4, r5, r6, r7, pc}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Další optimalizace v&nbsp;MicroPythonu</h2>

<p>Překlad funkcí do nativního kódu je jen jednou z&nbsp;forem optimalizací, které je možné v&nbsp;MicroPythonu provádět. Tvůrci MicroPythonu do tohoto jazyka (či dialektu) totiž </p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
MicroPython (a otestovaných na RP2040) byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>loop1.py</td><td>vnořené programové smyčky, překládáno do bajtkódu Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop1.py</a></td></tr>
<tr><td> 2</td><td>loop2.py</td><td>vnořené programové smyčky, překládáno do nativního kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop2.py</a></td></tr>
<tr><td> 3</td><td>loop3.py</td><td>vnořené programové smyčky, překládáno do nativního kódu Viperem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop3.py</a></td></tr>
<tr><td> 4</td><td>loop4.py</td><td>problematika návratové hodnoty z&nbsp;funkce překládané Viperem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop4.py</a></td></tr>
<tr><td> 5</td><td>loop5.py</td><td>typové informace přidané do překládané funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/loop5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>add1.py</td><td>funkce překládaná do bajtkódu Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add1.py</a></td></tr>
<tr><td> 7</td><td>add2.py</td><td>funkce překládaná do nativního kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add2.py</a></td></tr>
<tr><td> 8</td><td>add3.py</td><td>funkce překládaná do nativního kódu Viperem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add3.py</a></td></tr>
<tr><td> 9</td><td>add4.py</td><td>přidání typových informací, překlad Viperem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add4.py</a></td></tr>
<tr><td>10</td><td>add5.py</td><td>varianta naprogramovaná přímo v&nbsp;instrukcích Thumb</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/add5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>foo1.py</td><td>součet dvou hodnot blízko 2<sup>31</sup>, Pythonní varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/foo1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/foo1.py</a></td></tr>
<tr><td>12</td><td>foo2.py</td><td>stejná funkce, ovšem přeložená do nativního kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/foo2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/foo2.py</a></td></tr>
<tr><td>13</td><td>foo3.py</td><td>stejná funkce, ovšem přeložená do nativního kódu Viperem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/foo3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/foo3.py</a></td></tr>
<tr><td>14</td><td>foo4.py</td><td>stejná funkce, ovšem přeložená do nativního kódu Viperem, přidání informací o datových typech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/foo4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/foo4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>type_int.py</td><td>explicitní použití datového typu <strong>int</strong> pro návratovou hodnotu funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/type_int.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/type_int.py</a></td></tr>
<tr><td>16</td><td>type_uint.py</td><td>explicitní použití datového typu <strong>uint</strong> pro návratovou hodnotu funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/type_uint.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/type_uint.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>inspect_function.py</td><td>získání strojového kódu funkce přeložené Viperem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/inspect_function.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-viper/inspect_function.py</a></td></tr>
</table>

<p>Pro úplnost ještě přidávám odkazy na demonstrační příklady, v&nbsp;nichž se
používají funkce se strojovými instrukcemi ze sady Thumb a Thumb-2. Ty jsme si
popsali v&nbsp;předchozí trojici článků:</p>

<table>
<tr><th>#</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>return_constant.py</td><td>návratová hodnota z&nbsp;funkce s&nbsp;Thumb instrukcemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_constant.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_constant.py</a></td></tr>
<tr><td>2</td><td>return_big_constant_1.py</td><td>pokus o vrácení příliš velké konstanty (nekorektní)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_1.py</a></td></tr>
<tr><td>3</td><td>return_big_constant_2.py</td><td>pokus o vrácení příliš velké konstanty (nekorektní na Cortex-M0+)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_2.py</a></td></tr>
<tr><td>4</td><td>return_big_constant_3.py</td><td>vrácení 32bitové konstanty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/return_big_constant_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>inc1.py</td><td>předání argumentu do funkce s&nbsp;Thumb instrukcemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc1.py</a></td></tr>
<tr><td>6</td><td>inc2.py</td><td>pokus o předání argumentu v&nbsp;parametru špatného jména</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inc2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>add.py</td><td>součet dvou předaných argumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add.py</a></td></tr>
<tr><td>8</td><td>add_four.py</td><td>součet čtyř předaných argumentů (nekorektní)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_four.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_four.py</a></td></tr>
<tr><td>9</td><td>add_five.py</td><td>součet pěti předaných argumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_five.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/add_five.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>inspect_function.py</td><td>získání strojového kódu přeložených funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function.py</a></td></tr>
<tr><td>11</td><td>no_op.py</td><td>funkce bez příkazů, která se má přeložit do strojového kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/no_op.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/no_op.py</a></td></tr>
<tr><td>12</td><td>branch1.py</td><td>využití instrukce nepodmíněného skoku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch1.py</a></td></tr>
<tr><td>13</td><td>branch2.py</td><td>skok dopředu o několik instrukcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch2.py</a></td></tr>
<tr><td>14</td><td>branch3.py</td><td>skok vzad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/branch3.py</a></td></tr>
<tr><td>15</td><td>loop1.py</td><td>programová smyčka s&nbsp;počitadlem a podmíněným skokem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop1.py</a></td></tr>
<tr><td>16</td><td>loop2.py</td><td>zjednodušená varianta programové smyčky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop2.py</a></td></tr>
<tr><td>17</td><td>loop3.py</td><td>vnořené programové smyčky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop3.py</a></td></tr>
<tr><td>18</td><td>loop4.py</td><td>benchmark: vnořené smyčky naprogramované v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop4.py</a></td></tr>
<tr><td>19</td><td>loop5.py</td><td>benchmark: vnořené smyčky naprogramované v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>inspect_function_2.py</td><td>získání strojového kódu přeložených funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/inspect_function_2.py</a></td></tr>
<tr><td>21</td><td>loop6.py</td><td>programová smyčka s&nbsp;testem na začátku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop6.py</a></td></tr>
<tr><td>22</td><td>loop7.py</td><td>programová smyčka s&nbsp;testem na začátku (další varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop7.py</a></td></tr>
<tr><td>23</td><td>mul.py</td><td>instrukce součinu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/mul.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/mul.py</a></td></tr>
<tr><td>24</td><td>loop_mul_1.py</td><td>benchmark: rychlost násobení (strojové instrukce)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop_mul_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop_mul_1.py</a></td></tr>
<tr><td>25</td><td>loop_mul_2.py</td><td>benchmark: rychlost násobení (Python)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop_mul_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/loop_mul_2.py</a></td></tr>
<tr><td>26</td><td>ldrb.py</td><td>načtení jediného bajtu s&nbsp;rozšířením hodnoty na 32 bitů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ldrb.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ldrb.py</a></td></tr>
<tr><td>27</td><td>ldrh.py</td><td>načtení jediného 16bitového slova s&nbsp;rozšířením hodnoty na 32 bitů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ldrh.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ldrh.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>and.py</td><td>ukázka použití strojové instrukce <strong>AND</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/and.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/and.py</a></td></tr>
<tr><td>29</td><td>or.py</td><td>ukázka použití strojové instrukce <strong>OR</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/or.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/or.py</a></td></tr>
<tr><td>30</td><td>bic.py</td><td>ukázka použití strojové instrukce <strong>BIC</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/bic.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/bic.py</a></td></tr>
<tr><td>31</td><td>mvn.py</td><td>ukázka použití strojové instrukce <strong>MVN</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/mvn.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/mvn.py</a></td></tr>
<tr><td>32</td><td>lsl.py</td><td>ukázka použití strojové instrukce <strong>LSL</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/lsl.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/lsl.py</a></td></tr>
<tr><td>33</td><td>lsr.py</td><td>ukázka použití strojové instrukce <strong>LSR</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/lsr.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/lsr.py</a></td></tr>
<tr><td>34</td><td>asr.py</td><td>ukázka použití strojové instrukce <strong>ASR</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/asr.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/asr.py</a></td></tr>
<tr><td>35</td><td>ror.py</td><td>ukázka použití strojové instrukce <strong>ROR</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ror.py">https://github.com/tisnik/most-popular-python-libs/blob/master/micropython-thumb/ror.py</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>Maximising MicroPython speed<br />
<a href="https://docs.micropython.org/en/latest/reference/speed_python.html">https://docs.micropython.org/en/latest/reference/speed_python.html</a>
</li>

<li>Online ARM converter<br />
<a href="https://armconverter.com/?disasm">https://armconverter.com/?disasm</a>
</li>

<li>The 3 different code emitters<br />
<a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832">https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832</a>
</li>

<li>The 3 different code emitters, part 2<br />
<a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145">https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145</a>
</li>

<li>Fast Filters for the Pyboard<br />
<a href="https://github.com/peterhinch/micropython-filters">https://github.com/peterhinch/micropython-filters</a>
</li>

<li>How to load 32 bit constant from assembler with @micropython.asm_thumb<br />
<a href="https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a">https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a</a>
</li>

<li>Pi pico, micropython.asm_thumb: ADR Rd, &lt;label&gt; and LDR Rd, &lt;label&gt; not implemented?<br />
<a href="https://github.com/orgs/micropython/discussions/12257">https://github.com/orgs/micropython/discussions/12257</a>
</li>

<li>MicroPython documentation<br />
<a href="https://docs.micropython.org/en/latest/index.html">https://docs.micropython.org/en/latest/index.html</a>
</li>

<li>Inline assembler for Thumb2 architectures<br />
<a href="https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html">https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html</a>
</li>

<li>Inline assembler in MicroPython<br />
<a href="https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler">https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami (2)<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>Cortex-M0 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M0">https://en.wikipedia.org/wiki/ARM_Cortex-M0</a>
</li>

<li>Cortex-M0+ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B">https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>The Thumb instruction set<br />
<a href="http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf">http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

