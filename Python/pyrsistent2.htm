<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pyrsistent: persistentní datové struktury v Pythonu (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pyrsistent: persistentní datové struktury v Pythonu (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o knihovně pyrsistent se zaměříme na popis zbývajících persistentních datových struktur, které tato knihovna vývojářům nabízí. Jedná se především o persistentní mapy a obousměrné fronty. V této knihovně nalezneme i persistentní objekty popř. takzvané záznamy i podporu pro kolekce s testem konzistence a typovosti.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pyrsistent: persistentní datové struktury v&nbsp;Pythonu (dokončení)</a></p>
<p><a href="#k02">2. Persistentní mapy</a></p>
<p><a href="#k03">3. Konstrukce mapy</a></p>
<p><a href="#k04">4. Klíče mapy s&nbsp;typem rozdílným od řetězce</a></p>
<p><a href="#k05">5. &bdquo;Modifikace&ldquo; mapy</a></p>
<p><a href="#k06">6. Operace spojení dvou či více map</a></p>
<p><a href="#k07">7. Konverze mezi mapami a dalšími typy kontejnerů</a></p>
<p><a href="#k08">8. Kontejner typu &bdquo;Bag&ldquo;</a></p>
<p><a href="#k09">9. Operace &bdquo;freeze&ldquo; pro konstrukci vektorů</a></p>
<p><a href="#k10">10. Operace &bdquo;freeze&ldquo; pro konstrukci množin a map</a></p>
<p><a href="#k11">11. Persistentní obousměrná fronta &ndash; deque</a></p>
<p><a href="#k12">12. Atributy <strong>left</strong> a <strong>right</strong></a></p>
<p><a href="#k13">13. Přidání prvku do fronty zleva či zprava</a></p>
<p><a href="#k14">14. Odstranění nejlevějšího či nejpravějšího prvku z&nbsp;fronty</a></p>
<p><a href="#k15">15. Metody <strong>reverse</strong> a <strong>rotate</strong></a></p>
<p><a href="#k16">16. Persistentní záznam &ndash; mapa s&nbsp;pevně zadanými klíči</a></p>
<p><a href="#k17">17. Kontrola typu a/nebo hodnoty prvků v&nbsp;persistentních datových strukturách</a></p>
<p><a href="#k18">18. Vektor s&nbsp;kontrolou typu a/nebo hodnoty ukládaných prvků</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pyrsistent: persistentní datové struktury v&nbsp;Pythonu (dokončení)</h2>

<p>Ve druhé části článku o knihovně <i>pyrsistent</i> se zaměříme na popis
zbývajících persistentních datových struktur, které tato knihovna vývojářům
nabízí. Jednat se bude zejména o <a href="#k02">persistentní mapy</a>
(<i>maps</i>), ale i o <a href="#k11">persistentní obousměrné fronty</a>
(<i>deque</i>) či o kontejner typu <a href="#k08">bag</a>. To však není ani
zdaleka vše, protože v&nbsp;knihovně <i>pyrsistent</i> nalezneme i podporu pro
persistentní objekty (což je v&nbsp;Pythonu poměrně nový koncept)
popř.&nbsp;pro takzvané záznamy (<i>records</i>). Nezapomeneme ani na podporu
pro kolekce, u nichž je testována jejich konzistence a dokonce i typů
popř.&nbsp;hodnot prvků, které jsou v&nbsp;takových kolekcích uloženy. A
popíšeme si i velmi užitečnou funkci <strong>freeze</strong>, která slouží pro
konverzi mezi nepersistentními kontejnery Pythonu (<a href="#09">vektory</a>,
<a href="#10">množiny</a> a <a href="#k10">mapy</a>) do persistentní podoby
(opačnou operaci provádí funkce nazvaná <strong>thaf</strong>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Persistentní mapy</h2>

<p><a
href="https://www.root.cz/clanky/pyrsistent-persistentni-datove-struktury-v-pythonu/">V&nbsp;úvodním
článku</a> o pythonovské knihovně <i>Pyrsistent</i> byly popsány dvě základní
persistentní datové struktury, které se nazývají <i>vektory</i> a
<i>množiny</i>. Na vektory i na množiny se můžeme dívat jako na pole
s&nbsp;neměnitelnou strukturou (prvky nelze přidávat ani odebírat &ndash; tyto
operace vedou k&nbsp;vytvoření nové struktury), ovšem zatímco u vektorů je
zaručeno pořadí prvků a možnost výběru prvků na základě jejich celočíselných
indexů, u množin se operace omezují na test existence prvku popř.&nbsp;na
přečtení hodnoty prvku. Ovšem s&nbsp;množinami jako celkem lze navíc provádět
standardní množinové operace &ndash; sjednocení, průnik, diferenci, symetrickou
diferenci a v&nbsp;neposlední řadě i test, jestli je nějaká množina podmnožinou
množiny jiné. Množiny jsou tedy v&nbsp;mnoha ohledech velmi užitečné datové
struktury, které jsou však mnohdy &ndash; poněkud neprávem &ndash; při vývoji
přehlíženy.</p>

<p>Nyní se však zaměřme na další velmi užitečnou datovou strukturu neboli
<i>kontejner</i>. Jedná se o <i>mapy</i> (<i>maps</i>), které jsou známé taktéž
pod jménem asociativní pole. Prvky uložené v&nbsp;mapě jsou přístupné přes
<i>klíč</i> a nikoli přes celočíselný <i>index</i>, což znamená, že se jedná o
univerzálnější a interně i komplikovanější datovou strukturu. A vzhledem
k&nbsp;tomu, že se v&nbsp;knihovně <i>Pyrsistent</i> pracuje
s&nbsp;persistentními datovými strukturami, jsou i mapy persistentní,
tj.&nbsp;do mapy není možné přidávat ani z&nbsp;nich odebírat prvky. Mapy po
své konstrukci sice zdánlivě nabízí možnost s&nbsp;prvky mapy tímto způsobem
manipulovat, ovšem každá manipulace vede k&nbsp;vytvoření (a vrácení) nové
mapy. Využívá se zde již minule zmíněné sdílení interní struktury
(<i>structural sharing</i>), což znamená, že nově vytvořená mapa ve skutečnosti
sdílí prakticky celou vnitřní strukturu s&nbsp;mapou původní (až na nově
vytvořené, smazané či modifikované prvky). Přístup k&nbsp;prvkům přes klíče je
velmi rychlý &ndash; časová složitost přístupu je rovna časové složitosti
přístupu u vektorů a množin, tedy <i>O(log<sub>32</sub>n)</i>, kde <i>n</i> je
počet prvků uložených v&nbsp;mapě.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Konstrukce mapy</h2>

<p>Pro konstrukci mapy se používá konstruktor nazvaný jednoduše
<strong>m</strong>, podobně jako pro vektor existuje konstruktor pojmenovaný
<strong>v</strong> a pro množiny konstruktor se jménem <strong>s</strong>.
Tomuto konstruktoru lze předat libovolné množství pojmenovaných parametrů,
přičemž jméno parametru bude klíčem prvku v&nbsp;nově vytvářené mapě a hodnota
parametru hodnotou prvku v&nbsp;mapě. Na mapy je navíc mj.&nbsp;možné aplikovat
standardní funkci <strong>len</strong> a samozřejmě i zjistit její typ další
standardní funkcí <strong>type</strong>:</p>

<pre>
from pyrsistent import m
&nbsp;
map1 = <strong>m(first=1, second=2, third=3)</strong>
&nbsp;
print(map1)
print(type(map1))
print(len(map1))
</pre>

<p>Výsledkem bude persistentní mapa obsahující tři prvky:</p>

<pre>
pmap({'first': 1, 'third': 3, 'second': 2})
&lt;class 'pyrsistent._pmap.PMap'&gt;
3
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Klíče mapy s&nbsp;typem rozdílným od řetězce</h2>

<p>V&nbsp;předchozím demonstračním příkladu jsme vlastně měli
&bdquo;štěstí&ldquo;, protože jsme potřebovali vytvořit mapu, jejíž prvky mají
klíče typu řetězec (<i>string</i>). Jak se však může mapa zkonstruovat ve
chvíli, kdy například potřebujeme namísto řetězců použít n-tice nebo například
celá čísla? Problém spočívá v&nbsp;tom, že jména parametrů musí být platnými
identifikátory Pythonu. Následující příklad tedy není zapsán korektně:</p>

<pre>
from pyrsistent import m
&nbsp;
map1 = <strong>m(1="first", 2="second", 3="third")</strong>
&nbsp;
print(map1)
print(type(map1))
print(len(map1))
</pre>

<p>Jedná se o syntaktickou chybu, na kterou nás upozorní interpret Pythonu:</p>

<pre>
  File "map02.py", line 3
    map1 = m(1="first", 2="second", 3="third")
&nbsp;             ^
SyntaxError: expression cannot contain assignment, perhaps you meant "=="?
</pre>

<p>Řešení spočívá v&nbsp;použití konstruktoru <strong>pmap</strong>, jenž
umožňuje vytvořit persistentní mapu z&nbsp;jiného typu kontejneru, typicky ze
slovníku (<i>dictionary</i>):</p>

<pre>
from pyrsistent import pmap
&nbsp;
map1 = <strong>pmap({1:"first", 2:"second", 3:"third"})</strong>
&nbsp;
print(map1)
print(type(map1))
print(len(map1))
</pre>

<p>Tento skript je již bez chyby spustitelný:</p>

<pre>
pmap({1: 'first', 2: 'second', 3: 'third'})
&lt;class 'pyrsistent._pmap.PMap'&gt;
3
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. &bdquo;Modifikace&ldquo; mapy</h2>

<p>Do persistentních map nelze (z&nbsp;prostého důvodu jejich persistence)
přidávat nové prvky ani z&nbsp;nich prvky odstraňovat. Přesto knihovna
<i>Pyrsistent</i> programátorům při manipulacích s&nbsp;mapami nabízí podobné
operace. Tyto operace však vrací novou mapu s&nbsp;přidaným/ubraným prvkem;
původní mapa zůstane nezměněna. Tyto nové mapy sdílejí interní strukturu
s&nbsp;původní mapou, takže i zdánlivě složité operace přidání/ubrání prvku
jsou z&nbsp;časového i paměťového hlediska poměrně efektivní.</p>

<p>Přidání nového prvku či změnu existujícího prvku zajišťuje operace
pojmenovaná <strong>set</strong>, odstranění prvku pak operace nazvaná
<strong>remove</strong>. Výsledkem je vždy nová mapa; původní mapa zůstane, jak
již víme, beze změn:</p>

<pre>
from pyrsistent import m
&nbsp;
map1 = <strong>m(first=1, second=2, third=3)</strong>
print("Original map")
print(map1)
&nbsp;
map2 = <strong>map1.set("fourth", 4)</strong>
print("\nAfter set")
print(map1)
print(map2)
&nbsp;
map3 = <strong>map1.remove("first")</strong>
print("\nAfter remove")
print(map1)
print(map2)
print(map3)
</pre>

<p>Výsledky ukazují, že se původní mapa skutečně nezmění:</p>

<pre>
Original map
pmap({'second': 2, 'third': 3, 'first': 1})
&nbsp;
After set
pmap({'second': 2, 'third': 3, 'first': 1})
pmap({'second': 2, 'fourth': 4, 'third': 3, 'first': 1})
&nbsp;
After remove
pmap({'second': 2, 'third': 3, 'first': 1})
pmap({'second': 2, 'fourth': 4, 'third': 3, 'first': 1})
pmap({'second': 2, 'third': 3})
</pre>

<p>Ve skutečnosti je odstranění prvku z&nbsp;persistentní mapy realizováno
dvěma operacemi nazvanými <strong>discard</strong> a <strong>remove</strong>.
Ty se od sebe odlišují svým chováním ve chvíli, kdy prvek s&nbsp;daným klíčem
neexistuje. Metoda <strong>discard</strong> v&nbsp;tomto případě vrátí původní
mapu zatímco metoda <strong>remove</strong> vyhodí výjimku typu
<strong>KeyError</strong>. Chování obou zmíněných operací si můžeme velmi
snadno ověřit následujícím skriptem:</p>

<pre>
from pyrsistent import m
&nbsp;
map1 = <strong>m(first=1, second=2, third=3)</strong>
print("Original map")
print(map1)
&nbsp;
map2 = <strong>map1.set("fourth", 4)</strong>
print("\nAfter set")
print(map1)
print(map2)
&nbsp;
map3 = <strong>map1.discard("first")</strong>
print("\nAfter remove")
print(map1)
print(map2)
print(map3)
&nbsp;
<strong>map1.discard("nonexistentA")</strong>
<strong>map1.remove("nonexistentB")</strong>
</pre>

<p>Zatímco metoda <strong>discard</strong> proběhne bez chyby, v&nbsp;případě
metody <strong>remove</strong> je vyhozena výjimka typu
<strong>KeyError</strong>:</p>

<pre>
Original map
pmap({'first': 1, 'second': 2, 'third': 3})
&nbsp;
After set
pmap({'first': 1, 'second': 2, 'third': 3})
pmap({'first': 1, 'second': 2, 'third': 3, 'fourth': 4})
&nbsp;
After remove
pmap({'first': 1, 'second': 2, 'third': 3})
pmap({'first': 1, 'second': 2, 'third': 3, 'fourth': 4})
pmap({'second': 2, 'third': 3})
Traceback (most recent call last):
  File "maps05.py", line 19, in &lt;module&gt;
    map1.remove("nonexistentB")
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/pyrsistent/_pmap.py", line 192, in remove
    return self.evolver().remove(key).persistent()
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/pyrsistent/_pmap.py", line 366, in remove
    raise KeyError('{0}'.format(key))
KeyError: 'nonexistentB'
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Operace spojení dvou či více map</h2>

<p>Pro spojení dvou či více map slouží přetížený operátor <strong>+</strong>.
Nejprve se podívejme na spojení dvou map v&nbsp;případě, že klíče prvků
v&nbsp;obou mapách jsou unikátní a nedochází tedy k&nbsp;žádnému
&bdquo;překryvu&ldquo;:</p>

<pre>
from pyrsistent import pmap
&nbsp;
map1 = <strong>pmap({1:"first", 2:"second"})</strong>
map2 = <strong>pmap({3:"third", 4:"fourth"})</strong>
&nbsp;
print(map1)
print(map2)
&nbsp;
map3 = <strong>map1 + map2</strong>
print(map3)
</pre>

<p>Výsledkem spojení je nová mapa; mapy původní zůstanou beze změny:</p>

<pre>
pmap({1: 'first', 2: 'second'})
pmap({4: 'fourth', 3: 'third'})
pmap({4: 'fourth', 1: 'first', 2: 'second', 3: 'third'})
</pre>

<p>Alternativně je možné namísto přetíženého operátoru <strong>+</strong>
použít metodu <strong>update</strong>. Tentokrát se však podívejme, co se stane
ve chvíli, kdy nějaký prvek v&nbsp;první mapě má stejný klíč, jako prvek
v&nbsp;mapě druhé:</p>

<pre>
from pyrsistent import pmap
&nbsp;
map1 = <strong>pmap({1:"first", 2:"second", 3:"third"})</strong>
map2 = <strong>pmap({3:"3rd", 4:"4th"})</strong>
&nbsp;
print(map1)
print(map2)
&nbsp;
map3 = <strong>map1.update(map2)</strong>
print(map3)
</pre>

<p>Z&nbsp;výsledku je patrné, že spojením &bdquo;vyhrál&ldquo; prvek
z&nbsp;druhé mapy:</p>

<pre>
pmap({1: 'first', 2: 'second', 3: 'third'})
pmap({4: '4th', 3: '3rd'})
pmap({1: 'first', 2: 'second', 3: '3rd', 4: '4th'})
</pre>

<p>Naprosto stejný výsledek získáme po spojení map operátorem
<strong>+</strong>:</p>

<pre>
from pyrsistent import pmap
&nbsp;
map1 = <strong>pmap({1:"first", 2:"second", 3:"third"})</strong>
map2 = <strong>pmap({3:"3rd", 4:"4th"})</strong>
&nbsp;
print(map1)
print(map2)
&nbsp;
map3 = <strong>map1 + map2</strong>
print(map3)
</pre>

<p>Výsledek:</p>

<pre>
pmap({1: 'first', 2: 'second', 3: 'third'})
pmap({4: '4th', 3: '3rd'})
pmap({1: 'first', 2: 'second', 3: '3rd', 4: '4th'})
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Konverze mezi mapami a dalšími typy kontejnerů</h2>

<p>Persistentní mapy programátorům nabízí metody <strong>items</strong> a
<strong>values</strong>. První z&nbsp;těchto metod vrací persistentní vektor
s&nbsp;klíči i hodnotami (což jsou dvojice), druhá metoda vrací taktéž
persistentní vektor, tentokrát však s&nbsp;hodnotami prvků:</p>

<pre>
from pyrsistent import pmap
&nbsp;
map1 = <strong>pmap({1:"first", 2:"second", 3:"third"})</strong>
&nbsp;
vector1 = <strong>map1.items()</strong>
&nbsp;
print("Items:")
print(vector1)
print(type(vector1))
&nbsp;
vector2 = <strong>map1.values()</strong>
&nbsp;
print("\nValues:")
print(vector2)
print(type(vector2))
</pre>

<p>Po spuštění tohoto příkladu je patrné, jak obě výše zmíněné metody
pracují:</p>

<pre>
Items:
pvector([(1, 'first'), (2, 'second'), (3, 'third')])
&lt;class 'pvectorc.PVector'&gt;
&nbsp;
Values:
pvector(['first', 'second', 'third'])
&lt;class 'pvectorc.PVector'&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: pokud by nám nezáleželo na pořadí prvků
v&nbsp;mapě, mohla by metoda <strong>items</strong> vracet množinu.</div></p>

<p>Ještě snadnější je převod všech hodnot na běžný nepersistentní seznam,
k&nbsp;čemuž slouží standardní funkce <strong>list</strong>:</p>

<pre>
from pyrsistent import pmap
&nbsp;
map1 = <strong>pmap({1:"first", 2:"second", 3:"third"})</strong>
&nbsp;
list1 = <strong>list(map1)</strong>
&nbsp;
print("As list:")
print(list1)
print(type(list1))
</pre>

<p>Výsledky:</p>

<pre>
As list:
[1, 2, 3]
&lt;class 'list'&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: jak metody <strong>items</strong> a
<strong>values</strong>, tak i standardní funkce <strong>list</strong> vrací
datovou strukturu, přes kterou lze snadno iterovat s&nbsp;využitím standardních
syntaktických prostředků Pythonu.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Kontejner typu &bdquo;Bag&ldquo;</h2>

<p>V&nbsp;knihovně <i>Pyrsistent</i> nalezneme i persistentní kontejner, který
je nazvaný <strong>Bag</strong> neboli <i>multimnožina</i> (<i>multiset</i>,
<i>mset</i>). Jedná se o mix mezi vektory a množinami &ndash; <i>bag</i> ukládá
prvky obecně bez zaručení pořadí (tedy stejně, jako je tomu u množin), ovšem
umožňuje uložení většího množství kopií prvků se stejnou hodnotou (stejně, jako
je tomu u vektorů). Pro konstrukci tohoto persistentního kontejneru slouží
funkce/konstruktor nazvaný <strong>pbag</strong>, kterému se předává jiný
kontejner (seznam, n-tice, persistentní vektor) s&nbsp;hodnotami prvků. Navíc
jsou podporovány i operace <strong>add</strong> a <strong>remove</strong>,
které vrací nový <i>bag</i> (tedy multimnožinu), jež podle očekávání sdílí
svoji interní strukturu s&nbsp;množinou původní:</p>

<pre>
from pyrsistent import pbag
&nbsp;
bag1 = <strong>pbag(["foo", "bar", "baz"])</strong>
&nbsp;
print(bag1)
print(type(bag1))
&nbsp;
bag2 = <strong>bag1.add("bar")</strong>
&nbsp;
print(bag2)
print(type(bag2))
&nbsp;
bag3 = <strong>bag2.remove("baz")</strong>
&nbsp;
print(bag3)
print(type(bag3))
</pre>

<p>Po spuštění tohoto skriptu se vypíše obsah i typ všech tří postupně
vytvořených multimnožin:</p>

<pre>
pbag(['baz', 'bar', 'foo'])
&lt;class 'pyrsistent._pbag.PBag'&gt;
pbag(['baz', 'bar', 'bar', 'foo'])
&lt;class 'pyrsistent._pbag.PBag'&gt;
pbag(['bar', 'bar', 'foo'])
&lt;class 'pyrsistent._pbag.PBag'&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že multimnožiny mohou
skutečně obsahovat vícenásobné kopie stejných prvků.</div></p>

<p>Multimnožiny je možné spojit i s&nbsp;využitím přetíženého operátoru
<strong>+</strong>, což je ukázáno v&nbsp;následujícím skriptu. Současně je zde
ukázána možnost převodu multimnožiny na běžný pythonovský seznam:</p>

<pre>
from pyrsistent import pbag
&nbsp;
bag1 = <strong>pbag(["foo", "bar", "baz"])</strong>
&nbsp;
print(bag1)
&nbsp;
l = <strong>list(bag1)</strong>
print(l)
&nbsp;
bag2 = <strong>bag1 + pbag(["baz", "alpha", "omega"])</strong>
&nbsp;
print(bag2)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
pbag(['bar', 'foo', 'baz'])
['bar', 'foo', 'baz']
pbag(['bar', 'alpha', 'foo', 'omega', 'baz', 'baz'])
</pre>

<p><div class="rs-tip-major">Poznámka: opět si povšimněte toho, že druhá
multimnožina obsahuje větší množství prvků se stejnou hodnotou.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Operace &bdquo;freeze&ldquo; pro konstrukci vektorů</h2>

<p>Užitečná je i operace <strong>freeze</strong> použitá při konstrukci
vektorů. V&nbsp;prvním příkladu vytvoříme persistentní vektor ze seznamu, jehož
prvky jsou různého typu:</p>

<pre>
from pyrsistent import freeze
&nbsp;
vector1 = <strong>freeze([1, "foo", (1, 2, 3), None])</strong>
print(vector1)
print(type(vector1))
&nbsp;
vector2 = vector1.append("Five!")
print(vector1)
print(type(vector1))
&nbsp;
print(vector2)
print(type(vector2))
</pre>

<p>Výsledky ukazují, že se nově vytvořený vektor skutečně chová jako
persistentní vektor:</p>

<pre>
pvector([1, 'foo', (1, 2, 3), None])
&lt;class 'pvectorc.PVector'&gt;
pvector([1, 'foo', (1, 2, 3), None])
&lt;class 'pvectorc.PVector'&gt;
pvector([1, 'foo', (1, 2, 3), None, 'Five!'])
&lt;class 'pvectorc.PVector'&gt;
</pre>

<p>Druhý příklad je odlišný, neboť ukazuje, že i seznam uvnitř seznamu
(zvýrazněná část kódu) se převede na persistentní vektor:</p>

<pre>
from pyrsistent import freeze
&nbsp;
vector1 = freeze([1, "foo", <strong>[1, 2, 3]</strong>, None])
print(vector1)
print(type(vector1))
&nbsp;
vector2 = vector1.append("Five!")
print(vector1)
print(type(vector1))
&nbsp;
print(vector2)
print(type(vector2))
</pre>

<p>Onen zmíněný vektor ve vektoru je ve výsledcích rovněž zvýrazněn:</p>

<pre>
pvector([1, 'foo', <strong>pvector([1, 2, 3])</strong>, None])
&lt;class 'pvectorc.PVector'&gt;
pvector([1, 'foo', <strong>pvector([1, 2, 3])</strong>, None])
&lt;class 'pvectorc.PVector'&gt;
pvector([1, 'foo', <strong>pvector([1, 2, 3])</strong>, None, 'Five!'])
&lt;class 'pvectorc.PVector'&gt;
</pre>

<p>Vektor jako prvek převáděného seznamu ovšem můžeme specifikovat i
explicitně:</p>

<pre>
from pyrsistent import freeze, v
&nbsp;
vector1 = freeze([1, "foo", <strong>v(1, [2, 3])</strong>, None])
print(vector1)
print(type(vector1))
&nbsp;
vector2 = vector1.append("Five!")
print(vector1)
print(type(vector1))
&nbsp;
print(vector2)
print(type(vector2))
</pre>

<p>S&nbsp;výsledkem &bdquo;vektor ve vektoru vektorů&ldquo;:</p>

<pre>
pvector([1, 'foo', pvector([1, pvector([2, 3])]), None])
&lt;class 'pvectorc.PVector'&gt;
pvector([1, 'foo', pvector([1, pvector([2, 3])]), None])
&lt;class 'pvectorc.PVector'&gt;
pvector([1, 'foo', pvector([1, pvector([2, 3])]), None, 'Five!'])
&lt;class 'pvectorc.PVector'&gt;
</pre>

<p>Tuto rekurzivní náhradu seznamů za persistentní vektory je možné
v&nbsp;případě potřeby zakázat tím, že se funkci <strong>freeze</strong> předá
nepovinný parametr se jménem <strong>strict</strong> a hodnotou
<strong>False</strong>:</p>

<pre>
from pyrsistent import freeze, v
&nbsp;
vector1 = freeze([1, "foo", v(1, [2, 3]), None], <strong>strict=False</strong>)
print(vector1)
print(type(vector1))
&nbsp;
vector2 = vector1.append("Five!")
print(vector1)
print(type(vector1))
&nbsp;
print(vector2)
print(type(vector2))
</pre>

<p>Výsledky nyní budou odlišné:</p>

<pre>
pvector([1, 'foo', pvector([1, [2, 3]]), None])
&lt;class 'pvectorc.PVector'&gt;
pvector([1, 'foo', pvector([1, [2, 3]]), None])
&lt;class 'pvectorc.PVector'&gt;
pvector([1, 'foo', pvector([1, [2, 3]]), None, 'Five!'])
&lt;class 'pvectorc.PVector'&gt;
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Operace &bdquo;freeze&ldquo; pro konstrukci množin a map</h2>

<p>Funkci <strong>freeze</strong>, kterou jsme si v&nbsp;souvislosti
s&nbsp;vektory popsali <a href="#k09">v&nbsp;předchozí kapitole</a>, lze použít
i pro další dva typy kontejnerů Pythonu &ndash; konkrétně pro množiny a
slovníky.</p>

<p>Nejprve se podívejme na konstrukci persistentní množiny z&nbsp;běžné
(nepersistentní) Pythonovské množiny:</p>

<pre>
from pyrsistent import freeze
&nbsp;
set1 = <strong>freeze({1,2,3})</strong>
&nbsp;
print(set1)
print(type(set1))
&nbsp;
print()
&nbsp;
for i in range(0, 5):
    print(i, i in set1)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
pset([1, 2, 3])
&lt;class 'pyrsistent._pset.PSet'&gt;
&nbsp;
0 False
1 True
2 True
3 True
4 False
</pre>

<p>Podobným způsobem můžeme sestrojit persistentní mapu z&nbsp;běžného
Pythonovského slovníku, a to následovně:</p>

<pre>
from pyrsistent import freeze
&nbsp;
map1 = <strong>freeze({1:"first", 2:"second", 3:"third"})</strong>
&nbsp;
print(map1)
print(type(map1))
</pre>

<p>Výsledek získaný po spuštění bude vypadat takto:</p>

<pre>
pmap({1: 'first', 2: 'second', 3: 'third'})
&lt;class 'pyrsistent._pmap.PMap'&gt;
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Persistentní obousměrná fronta &ndash; deque</h2>

<p>Posledním &bdquo;klasickým&ldquo; kontejnerem podporovaným v&nbsp;knihovně
<i>Pyrsistent</i>, o němž se v&nbsp;dnešním článku zmíníme, je kontejner
nazvaný <i>deque</i>, což je jedna z&nbsp;možných implementací obousměrné
fronty (<i>double ended queue</i>). Jedná se tedy o kontejner, který podporuje
operace připojení nového prvku k&nbsp;oběma koncům fronty popř.&nbsp;naopak
k&nbsp;získání (a odstranění) prvku z&nbsp;libovolného konce &ndash; jedná se
ovšem pochopitelně o operace zachovávající persistenci a tedy vracející novou
obousměrnou frontu s&nbsp;novým a/nebo odstraněným prvkem. Podporovány jsou
ovšem i další dvě operace, které typicky u implementací obousměrných front
nenajdeme. Jedná se o operaci určenou pro rotaci prvků uložených ve frontě a
taktéž o operaci, která vede k&nbsp;otočení fronty, tj.&nbsp;ke změně pořadí
všech prvků, které jsou ve frontě uloženy.</p>

<p><div class="rs-tip-major">Poznámka: obousměrnou frontu je možné pochopitelně
použít i ve funkci zásobníku (<i>stack</i>), zde konkrétně persistentního
zásobníku. Z&nbsp;tohoto důvodu v&nbsp;Pyrsistent nenalezneme přímo kontejner
<i>stack</i> resp.&nbsp;<i>pstack</i>.</div></p>

<p>Frontu je možné zkonstruovat funkcí-konstruktorem nazvaným
<strong>dq</strong>, kterému se předají všechny prvky, které se mají do
obousměrné fronty uložit (v&nbsp;zadaném pořadí):</p>

<pre>
from pyrsistent import dq
&nbsp;
deque = <strong>dq("foo", "bar", "baz")</strong>
&nbsp;
print(deque)
print(type(deque))
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
pdeque(['foo', 'bar', 'baz'])
&lt;class 'pyrsistent._pdeque.PDeque'&gt;
</pre>

<p>Alternativně je možné použít i konstruktor pojmenovaný
<strong>pdeque</strong>, kterému se prvky předají v&nbsp;jediném parametru
&ndash; kterým je typicky jiný kontejner, například klasický seznam:</p>

<pre>
from pyrsistent import pdeque
&nbsp;
deque = <strong>pdeque(["foo", "bar", "baz"])</strong>
&nbsp;
print(deque)
print(type(deque))
</pre>

<p>Výsledek je shodný s&nbsp;předchozím příkladem:</p>

<pre>
pdeque(['foo', 'bar', 'baz'])
&lt;class 'pyrsistent._pdeque.PDeque'&gt;
</pre>

<p>Dtto pro n-tice:</p>

<pre>
from pyrsistent import pdeque
&nbsp;
deque = <strong>pdeque(("foo", "bar", "baz"))</strong>
&nbsp;
print(deque)
print(type(deque))
</pre>

<p>Opět dostaneme shodný výsledek:</p>

<pre>
pdeque(['foo', 'bar', 'baz'])
&lt;class 'pyrsistent._pdeque.PDeque'&gt;
</pre>

<p>A persistentní frontu je možné zkonstruovat i z&nbsp;persistentního
vektoru:</p>

<pre>
from pyrsistent import pdeque, v
&nbsp;
vec = <strong>v("foo", "bar", "baz")</strong>
deque = <strong>pdeque(vec)</strong>
&nbsp;
print(vec)
print(type(vec))
&nbsp;
print()
&nbsp;
print(deque)
print(type(deque))
</pre>

<p>Tento demonstrační příklad nejdříve vypíše obsah a typ persistentního
vektoru a posléze i obsah a typ obousměrné fronty:</p>

<pre>
pvector(['foo', 'bar', 'baz'])
&lt;class 'pvectorc.PVector'&gt;
&nbsp;
pdeque(['foo', 'bar', 'baz'])
&lt;class 'pyrsistent._pdeque.PDeque'&gt;
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Atributy <strong>left</strong> a <strong>right</strong></h2>

<p>V&nbsp;souvislosti s&nbsp;obousměrnými frontami je nutné nějakým způsobem
označit resp.&nbsp;pojmenovat oba konce fronty. V&nbsp;některých dokumentech
nebo knihovnách se setkáme s&nbsp;označením &bdquo;first&ldquo; a
&bdquo;last&ldquo; popř.&nbsp;&bdquo;head&ldquo; a &bdquo;tail&ldquo;, což však
může být matoucí. Namísto toho se v&nbsp;knihovně <i>Pyrsistent</i> setkáme
s&nbsp;použitím slov &bdquo;left&ldquo; a &bdquo;right&ldquo;, tj.&nbsp;jeden
z&nbsp;konců fronty je &bdquo;levý&ldquo; a druhý &bdquo;pravý&ldquo;.</p>

<p>K&nbsp;dispozici jsou i atributy se jmény <strong>left</strong> a
<strong>right</strong>, které obsahují referencí na nejlevější nebo nejpravější
prvek ve frontě (za předpokladu, že fronta obsahuje alespoň jeden prvek):</p>

<pre>
from pyrsistent import dq
&nbsp;
deque = dq("foo", "bar", "baz")
&nbsp;
print(deque)
print(type(deque))
&nbsp;
print(<strong>deque.left</strong>)
print(<strong>deque.right</strong>)
</pre>

<p>Po spuštění tohoto skriptu se nejdříve vypíše celá fronta, následně její typ
(což již známe) a nakonec hodnota jejích prvků na obou koncích &ndash; levém i
pravém:</p>

<pre>
pdeque(['foo', 'bar', 'baz'])
&lt;class 'pyrsistent._pdeque.PDeque'&gt;
foo
baz
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přidání prvku do fronty zleva či zprava</h2>

<p>Pro přidání prvku do fronty zprava slouží metoda <strong>append</strong>
(protože v&nbsp;jiných strukturách <strong>append</strong> přidává prvky na
konec, tedy v&nbsp;naší kultuře doprava). Výsledkem je pochopitelně nová
fronta:</p>

<pre>
from pyrsistent import pdeque, v
&nbsp;
vec = v("foo")
deque1 = <strong>pdeque(vec)</strong>
&nbsp;
print(deque1)
&nbsp;
deque2 = <strong>deque1.append("bar")</strong>
print(deque2)
&nbsp;
deque3 = <strong>deque2.append("baz")</strong>
print(deque3)
</pre>

<p>Tento skript vypíše tři fronty, které interně částečně sdílí svoji
strukturu:</p>

<pre>
pdeque(['foo'])
pdeque(['foo', 'bar'])
pdeque(['foo', 'bar', 'baz'])
</pre>

<p>Pro přidání prvku na levý konec fronty je určena metoda pojmenovaná
<strong>appendleft</strong>:</p>

<pre>
from pyrsistent import pdeque, v
&nbsp;
vec = v("foo")
deque1 = <strong>pdeque(vec)</strong>
&nbsp;
print(deque1)
&nbsp;
deque2 = <strong>deque1.appendleft("bar")</strong>
print(deque2)
&nbsp;
deque3 = deque2.appendleft("baz")
print(deque3)
</pre>

<p>Tři fronty, které postupně vzniknou, jsou odlišné od předchozího
příkladu:</p>

<pre>
pdeque(['foo'])
pdeque(['bar', 'foo'])
pdeque(['baz', 'bar', 'foo'])
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odstranění nejlevějšího či nejpravějšího prvku z&nbsp;fronty</h2>

<p><a href="#k13">V&nbsp;předchozí kapitole</a> jsme si ukázali, jak lze
přidávat prvky do persistentní obousměrné fronty, tj.&nbsp;jak vznikne nová
fronta s&nbsp;prvkem připojeným na její levý nebo pravý konec. Opakem této
operace je odebrání prvku zleva nebo zprava. Tyto operace opět způsobí, že se
vytvoří nová fronta, jejíž prvek na levém nebo pravém konci bude odstraněn.
Neprovádí se však čtení hodnoty odstraňovaného prvku &ndash; k&nbsp;tomu slouží
již výše zmíněné atributy <strong>left</strong> a <strong>right</strong>.</p>

<pre>
from pyrsistent import pdeque, v
&nbsp;
vec = v("foo", "bar", "baz")
deque1 = <strong>pdeque(vec)</strong>
&nbsp;
print(deque1)
&nbsp;
deque2 = <strong>deque1.pop()</strong>
print(deque2)
&nbsp;
deque3 = <strong>deque2.pop()</strong>
print(deque3)
</pre>

<p>Výsledky ukazují, jak se prvky skutečně odstraňují zprava (v&nbsp;nových
frontách):</p>

<pre>
pdeque(['foo', 'bar', 'baz'])
pdeque(['foo', 'bar'])
pdeque(['foo'])
</pre>

<p>O odstranění prvků zleva se stará metoda pojmenovaná
<strong>popleft</strong>:</p>

<pre>
from pyrsistent import pdeque, v
&nbsp;
vec = v("foo", "bar", "baz")
deque1 = <strong>pdeque(vec)</strong>
&nbsp;
print(deque1)
&nbsp;
deque2 = <strong>deque1.popleft()</strong>
print(deque2)
&nbsp;
deque3 = <strong>deque2.popleft()</strong>
print(deque3)
</pre>

<p>Povšimněte si rozdílů ve výsledcích oproti předchozímu skriptu:</p>

<pre>
pdeque(['foo', 'bar', 'baz'])
pdeque(['bar', 'baz'])
pdeque(['baz'])
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Metody <strong>reverse</strong> a <strong>rotate</strong></h2>

<p>Poslední dvě metody, s&nbsp;nimiž se v&nbsp;souvislosti s&nbsp;persistentní
obousměrnou frontou seznámíme, jsou metody vracející otočenou frontu a taktéž
pro rotaci prvků ve frontě (jakoby se jednalo o kruhový buffer &ndash; <i>ring
buffer</i>). Obě zmíněné metody vrací novou persistentní frontu a metodě
<strong>rotate</strong> se navíc předává počet rotací prvků (ten může být i
záporný):</p>

<pre>
from pyrsistent import pdeque, v
&nbsp;
vec = v("foo", "bar", "baz")
deque1 = <strong>pdeque(vec)</strong>
&nbsp;
deque2 = <strong>deque1.reverse()</strong>
print(deque2)
&nbsp;
deque3 = <strong>deque1.rotate(1)</strong>
print(deque3)
</pre>

<p>Tento skript nejdříve vypíše obsah otočené fronty a následně obsah fronty,
jejíž prvky jsou orotovány doprava o jeden prvek:</p>

<pre>
pdeque(['baz', 'bar', 'foo'])
pdeque(['baz', 'foo', 'bar'])
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Persistentní záznam &ndash; mapa s&nbsp;pevně zadanými klíči</h2>

<p>Předposledním persistentním kontejnerem, s&nbsp;nímž se v&nbsp;dnešním
článku seznámíme, je <i>persistentní záznam</i>, což je kontejner, který si
můžeme představit jako persistentní mapu (se všemi metodami, které již známe),
jejíž množina klíčů je pevně zadaná již v&nbsp;deklaraci. V&nbsp;následujícím
demonstračním příkladu vytvoříme záznam, který může (ale nemusí!) obsahovat
prvky s&nbsp;klíči &bdquo;x&ldquo; a &bdquo;y&ldquo;, ovšem další klíče již
nejsou povoleny:</p>

<pre>
from pyrsistent import PRecord, field
&nbsp;
class <strong>XYRecord</strong>(PRecord):
    x = field()
    y = field()
&nbsp;
&nbsp;
record1 = <strong>XYRecord(x=1)</strong>
print(record1)
&nbsp;
record2 = <strong>record1.set("y", 42)</strong>
print(record2)
&nbsp;
record3 = <strong>record2.set("z", 0)</strong>
print(record3)
</pre>

<p>Při pokusu o použití klíče &bdquo;z&ldquo; dojde k&nbsp;chybě &ndash; takové
klíče nepodporujeme:</p>

<pre>
XYRecord(x=1)
XYRecord(y=42, x=1)
Traceback (most recent call last):
  File "precord.py", line 14, in &lt;module&gt;
    record3 = record2.set("z", 0)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/pyrsistent/_precord.py", line 65, in set
    return super(PRecord, self).set(args[0], args[1])
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/pyrsistent/_pmap.py", line 181, in set
    return self.evolver().set(key, val).persistent()
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/pyrsistent/_precord.py", line 146, in set
    raise AttributeError("'{0}' is not among the specified fields for {1}".format(key, self._destination_cls.__name__))
AttributeError: 'z' is not among the specified fields for XYRecord
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Kontrola typu a/nebo hodnoty prvků v&nbsp;persistentních datových strukturách</h2>

<p>Všechny typy persistentních kontejnerů, které jsme si až doposud popsali,
umožňovaly uložení prvků jakýchkoli typů a hodnot. Toto chování ostatně vychází
z&nbsp;filozofie Pythonu jakožto vysokoúrovňového dynamicky typovaného jazyka.
Ovšem v&nbsp;některých situacích může být vhodné omezit možnosti kontejnerů
&ndash; aby například umožňovaly uložení prvků určitého typu nebo dokonce
prvků, jejichž hodnota splňuje nějakou programátorem zadanou podmínku &ndash;
invariant. I tuto funkcionalitu knihovna <i>Pyrsistent</i> programátorům
nabízí, protože ke každému již popsanému kontejneru existuje i jeho
&bdquo;checked&ldquo; (tedy kontrolovaná) varianta. Při použití kontrolované
varianty kontejneru můžeme specifikovat jak povolené typy prvků, tak i (což je
zajímavější) nějaké další kontrolované podmínky, například to, že prvky musí
být kladné, musí se jednat o neprázdné řetězce, musí se jednat o datová razítka
s&nbsp;časem ukazujícím pouze do budoucnosti (nebo naopak jen na poslední
měsíc) atd.</p>

<p><div class="rs-tip-major">Poznámka: tyto kontroly jsou prováděny za běhu
(<i>runtime</i>), nikoli při analýze a překladu skriptů do bajtkódu.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Vektor s&nbsp;kontrolou typu a/nebo hodnoty ukládaných prvků</h2>

<p>V&nbsp;dnešním posledním demonstračním příkladu je ukázáno, jak lze použít
persistentní vektor, který může obsahovat hodnoty specifikovaného typu a
současně odpovídající zadané podmínce. V&nbsp;příkladu je deklarována třída
odpovídající persistentnímu vektoru pro celočíselné hodnoty, které současně
musí být dělitelné dvěma. Následně se pokusíme o vytvoření dvou vektorů &ndash;
prvního s&nbsp;prvky, které podmínku splňují a druhého, které podmínku naopak
nesplňují (dva prvky jsou lichými čísly):</p>

<pre>
from pyrsistent import CheckedPVector
&nbsp;
class Evens(CheckedPVector):
    <strong>__type__ = (int,)</strong>
    <strong>__invariant__ = lambda n: (n % 2 == 0, "Even")</strong>
&nbsp;
vector1 = Evens([2, 4, 6])
&nbsp;
print(vector1)
print(type(vector1))
&nbsp;
vector2 = Evens([1, 2, 3])
&nbsp;
print(vector2)
print(type(vector2))
</pre>

<p>Při spuštění skriptu bude první vektor bez problémů vytvořen zatímco při
pokusu o konstrukci druhého vektoru dojde k&nbsp;vyhození výjimky typu
<strong>InvariantException</strong>:</p>

<pre>
Evens([2, 4, 6])
&lt;Class '__main__.Evens'&gt;
Traceback (most recent call last):
  File "checked_vector.py", line 12, in &lt;module&gt;
    vector2 = Evens([1, 2, 3])
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/pyrsistent/_checked_types.py", line 292, in __new__
    return CheckedPVector.Evolver(cls, python_pvector()).extend(initial).persistent()
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/pyrsistent/_checked_types.py", line 341, in persistent
    raise InvariantException(error_codes=self._invariant_errors)
pyrsistent._checked_types.InvariantException: , invariant_errors=[Even, Even], missing_fields=[]
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 a knihovnu <i>pyrsistent</i> byly uloženy do Git
repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>list01.py</td><td>standardní datový typ seznam</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/list01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/list01.py</a></td></tr>
<tr><td> 2</td><td>list02.py</td><td>přidání prvků do seznamu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/list02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/list02.py</a></td></tr>
<tr><td> 3</td><td>list03.py</td><td>měnitelné prvky seznamu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/list03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/list03.py</a></td></tr>
<tr><td> 4</td><td>list04.py</td><td>rekurzivní seznam</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/list04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/list04.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>tuple01.py</td><td>standardní neměnný typ n-tice</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/tuple01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/tuple01.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>vectors01.py</td><td>konstrukce vektoru se třemi prvky stejného typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors01.py</a></td></tr>
<tr><td> 7</td><td>vectors02.py</td><td>konstrukce vektoru se čtyřmi prvky rozdílného typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors02.py</a></td></tr>
<tr><td> 8</td><td>vectors03.py</td><td>metoda <strong>append</strong> vytvářející nový vektor</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors03.py</a></td></tr>
<tr><td> 9</td><td>vectors04.py</td><td>neměnná hodnota &ndash; reference na seznam</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors04.py</a></td></tr>
<tr><td>10</td><td>vectors05.py</td><td>proměnná hodnota &ndash; vlastní obsah seznamu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors05.py</a></td></tr>
<tr><td>11</td><td>vectors06.py</td><td>proměnná hodnota &ndash; obsah mapy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors06.py</a></td></tr>
<tr><td>12</td><td>vectors07.py</td><td>přístup k&nbsp;prvkům vektoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors07.py</a></td></tr>
<tr><td>13</td><td>vectors08.py</td><td>slicing</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors08.py</a></td></tr>
<tr><td>14</td><td>vectors09.py</td><td>slicing se specifikací kroku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/vectors09.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>sets01.py</td><td>konstrukce persistentní množiny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets01.py</a></td></tr>
<tr><td>16</td><td>sets02.py</td><td>persistentní množina a operace <strong>add</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets02.py</a></td></tr>
<tr><td>17</td><td>sets03.py</td><td>persistentní množina a operace <strong>remove</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets03.py</a></td></tr>
<tr><td>18</td><td>sets04.py</td><td>množinové operace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets04.py</a></td></tr>
<tr><td>19</td><td>sets05.py</td><td>test na existenci prvku v&nbsp;množině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/sets05.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>maps01.py</td><td>konstrukce persistentní mapy konstruktorem <strong>m</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps01.py</a></td></tr>
<tr><td>21</td><td>maps02.py</td><td>pokus o konstrukci mapy, jejímiž klíči jsou celá čísla</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps02.py</a></td></tr>
<tr><td>22</td><td>maps03.py</td><td>konstrukce mapy konstruktorem <strong>pmap</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps03.py</a></td></tr>
<tr><td>23</td><td>maps04.py</td><td>persistentní mapy a operace <strong>set</strong> a <strong>remove</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps04.py</a></td></tr>
<tr><td>24</td><td>maps05.py</td><td>rozdíl mezi operacemi <strong>remove</strong> a <strong>discard</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps05.py</a></td></tr>
<tr><td>25</td><td>maps06.py</td><td>spojení dvou persistentních map operátorem <strong>+</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps06.py</a></td></tr>
<tr><td>26</td><td>maps07.py</td><td>spojení dvou persistentních map obsahujících prvky se stejnými klíči</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps07.py</a></td></tr>
<tr><td>27</td><td>maps08.py</td><td>spojení dvou persistentních map obsahujících prvky se stejnými klíči</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps08.py</a></td></tr>
<tr><td>28</td><td>maps09.py</td><td>získání prvků popř.&nbsp;jen jejich hodnot z&nbsp;množiny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps09.py</a></td></tr>
<tr><td>29</td><td>maps10.py</td><td>převod prvků na seznam</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/maps10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>bag01.py</td><td>multimnožina</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/bag01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/bag01.py</a></td></tr>
<tr><td>31</td><td>bag02.py</td><td>multimnožina</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/bag02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/bag02.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>freeze_maps.py</td><td>operace &bdquo;freeze&ldquo; provedená se slovníkem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_maps.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_maps.py</a></td></tr>
<tr><td>33</td><td>freeze_sets.py</td><td>operace &bdquo;freeze&ldquo; provedená s&nbsp;množinou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_sets.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_sets.py</a></td></tr>
<tr><td>34</td><td>freeze_vectors_01.py</td><td>operace &bdquo;freeze&ldquo; provedená se seznamem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_vectors_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_vectors_01.py</a></td></tr>
<tr><td>35</td><td>freeze_vectors_02.py</td><td>operace &bdquo;freeze&ldquo; provedená se seznamem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_vectors_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_vectors_02.py</a></td></tr>
<tr><td>36</td><td>freeze_vectors_03.py</td><td>operace &bdquo;freeze&ldquo; provedená se seznamem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_vectors_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_vectors_03.py</a></td></tr>
<tr><td>37</td><td>freeze_vectors_04.py</td><td>operace &bdquo;freeze&ldquo; provedená se seznamem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_vectors_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/freeze_vectors_04.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>38</td><td>deque01.py</td><td>konstrukce obousměrné fronty konstruktorem <strong>dq</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque01.py</a></td></tr>
<tr><td>39</td><td>deque02.py</td><td>konstrukce obousměrné fronty konstruktorem <strong>pdeque</strong> (seznam)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque02.py</a></td></tr>
<tr><td>40</td><td>deque03.py</td><td>konstrukce obousměrné fronty konstruktorem <strong>pdeque</strong> (n-tice)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque03.py</a></td></tr>
<tr><td>41</td><td>deque04.py</td><td>konstrukce obousměrné fronty konstruktorem <strong>pdeque</strong> (vektor)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque04.py</a></td></tr>
<tr><td>42</td><td>deque05.py</td><td>atributy <strong>left</strong> a <strong>right</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque05.py</a></td></tr>
<tr><td>43</td><td>deque06.py</td><td>přidání prvku do fronty metodou <strong>append</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque06.py</a></td></tr>
<tr><td>44</td><td>deque07.py</td><td>přidání prvku do fronty metodou <strong>appendleft</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque07.py</a></td></tr>
<tr><td>45</td><td>deque08.py</td><td>odstranění prvku z&nbsp;fronty metodou <strong>pop</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque08.py</a></td></tr>
<tr><td>46</td><td>deque09.py</td><td>odstranění prvku z&nbsp;fronty metodou <strong>popleft</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque09.py</a></td></tr>
<tr><td>47</td><td>deque10.py</td><td>metody <strong>reverse</strong> a <strong>rotate</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/deque10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>precord.py</td><td>persistentní záznam &ndash; mapa s&nbsp;pevně zadanými klíči</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/precord.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/precord.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>checked_vector.py</td><td>vektor s&nbsp;kontrolou typu a/nebo hodnoty ukládaných prvků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/checked_vector.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyrsistent/checked_vector.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Persistent data structure<br />
<a href="https://en.wikipedia.org/wiki/Persistent_data_structure">https://en.wikipedia.org/wiki/Persistent_data_structure</a>
</li>

<li>Collections (Python)<br />
<a href="https://docs.python.org/3/library/collections.abc.html">https://docs.python.org/3/library/collections.abc.html</a>
</li>

<li>Immutable object<br />
<a href="https://en.wikipedia.org/wiki/Immutable_object">https://en.wikipedia.org/wiki/Immutable_object</a>
</li>

<li>pyrsistent na PyPi<br />
<a href="https://pypi.org/project/pyrsistent/">https://pypi.org/project/pyrsistent/</a>
</li>

<li>pyrsistent na GitHubu<br />
<a href="https://github.com/tobgu/pyrsistent">https://github.com/tobgu/pyrsistent</a>
</li>

<li>Dokumentace knihovny pyrsistent<br />
<a href="https://pyrsistent.readthedocs.io/en/latest/index.html">https://pyrsistent.readthedocs.io/en/latest/index.html</a>
</li>

<li>pyrthon na GitHubu<br />
<a href="https://github.com/tobgu/pyrthon/">https://github.com/tobgu/pyrthon/</a>
</li>

<li>Mori na GitHubu<br />
<a href="https://github.com/swannodette/mori">https://github.com/swannodette/mori</a>
</li>

<li>Mori: popis API (dokumentace)<br />
<a href="http://swannodette.github.io/mori/">http://swannodette.github.io/mori/</a>
</li>

<li>Mori: Benchmarking<br />
<a href="https://github.com/swannodette/mori/wiki/Benchmarking">https://github.com/swannodette/mori/wiki/Benchmarking</a>
</li>

<li>Functional data structures in JavaScript with Mori<br />
<a href="http://sitr.us/2013/11/04/functional-data-structures.html">http://sitr.us/2013/11/04/functional-data-structures.html</a>
</li>

<li>Immutable.js<br />
<a href="https://facebook.github.io/immutable-js/">https://facebook.github.io/immutable-js/</a>
</li>

<li>Understanding Clojure's Persistent Vectors, pt. 1<br />
<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">http://hypirion.com/musings/understanding-persistent-vector-pt-1</a>
</li>

<li>Hash array mapped trie (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">https://en.wikipedia.org/wiki/Hash_array_mapped_trie</a>
</li>

<li>Java theory and practice: To mutate or not to mutate?<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html">http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html</a>
</li>

<li>Efficient persistent (immutable) data structures<br />
<a href="https://persistent.codeplex.com/">https://persistent.codeplex.com/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

