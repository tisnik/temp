<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Validace datových struktur v Pythonu (2. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Validace datových struktur v Pythonu (2. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku nejprve dokončíme popis knihovny Schema a následně se zmíníme o další knihovně určené pro validaci datových struktur. Tato knihovna se jmenuje Voluptuous a je založena na podobných principech, jako knihovny Schemagic a Schema.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Validace datových struktur v&nbsp;Pythonu (2. část)</a></p>
<p><a href="#k02">2. Dokončení popisu možností nabízených knihovnou <i>Schema</i></a></p>
<p><a href="#k03">3. Třetí demonstrační příklad &ndash; kontrola platu a pracovní pozice zaměstnanců</a></p>
<p><a href="#k04">4. Výsledky běhu třetího demonstračního příkladu</a></p>
<p><a href="#k05">5. Čtvrtý demonstrační příklad &ndash; použití klauzulí <strong>And</strong> a <strong>Or</strong></a></p>
<p><a href="#k06">6. Výsledky běhu čtvrtého demonstračního příkladu</a></p>
<p><a href="#k07">7. Použití klauzule <strong>Optional</strong></a></p>
<p><a href="#k08">8. Použití regulárních výrazů pro kontrolu dat ve slovnících</a></p>
<p><a href="#k09">9. Zdrojový kód pátého demonstračního příkladu a jeho výsledky</a></p>
<p><a href="#k10">10. Použití třídy pro kontrolu údajů o platu a o pracovní pozici</a></p>
<p><a href="#k11">11. Kontrola unikátnosti ID zaměstnance</a></p>
<p><a href="#k12">12. Zdrojový kód šestého demonstračního příkladu</a></p>
<p><a href="#k13">13. Výsledky běhu šestého demonstračního příkladu</a></p>
<p><a href="#k14">14. Knihovna <i>Voluptuous</i></a></p>
<p><a href="#k15">15. Ukázka základních možností knihovny <i>Voluptuous</i> v&nbsp;REPLu</a></p>
<p><a href="#k16">16. První příklad &ndash; validace obsahu seznamů knihovnou <i>Voluptuous</i></a></p>
<p><a href="#k17">17. Tři varianty validace celých kladných čísel implementované ve třech knihovnách</a></p>
<p><a href="#k18">18. Druhý příklad &ndash; validace obsahu slovníků</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Validace datových struktur v&nbsp;Pythonu (2. část)</h2>

<p><a
href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">V&nbsp;předchozím
článku</a> jsme se seznámili s&nbsp;dvojicí knihoven určených pro validaci
datových struktur v&nbsp;Pythonu. Připomeňme si, že se jedná o knihovny
pojmenované <i>Schemagic</i> a <i>Schema</i>. Obě tyto knihovny jsou založeny
na tom, že samotný popis validačních schémat je nadeklarován přímo
v&nbsp;Pythonu, takže se případní uživatelé těchto knihoven (což jsou většinou
programátoři) nemusí učit nový <i>DSL</i> (doménově specifický jazyk). Knihovna
<i>Schemagic</i> je zvláštní tím, že kromě vlastní validace provádí i konverzi
dat. Ve stručnosti je možné říci, že validační kritéria jsou představována
konverzními funkcemi, které buď konverzi provedou nebo vyhodí výjimku typu
<strong>ValueError</strong> nebo <strong>TypeError</strong>. Naproti tomu
knihovna <i>Schema</i> skutečně provádí pouze validaci datových struktur a
proto jsou jinak zapisována i validační kritéria &ndash; ta jsou tvořena
<i>predikáty</i>, tj.&nbsp;funkcemi vracejícími pravdivostní hodnotu
<strong>True</strong> či <strong>False</strong>.</p>

<p>Příklad (ten nejjednodušší možný) validace knihovnou <i>Schemagic</i>:</p>

<pre>
&gt;&gt;&gt; <strong>from schemagic import validate_against_schema</strong>
&gt;&gt;&gt; <strong>validate_against_schema(int, 42)</strong>
42
</pre>

<p>Příklad validace knihovnou <i>Schema</i>:</p>

<pre>
&gt;&gt;&gt; <strong>from schema import Schema</strong>
&gt;&gt;&gt; <strong>s1 = Schema({"name": str, "surname": str})</strong>
&nbsp;
&gt;&gt;&gt; <strong>s1.validate({"name": "Eda", "surname": "Wasserfall"})</strong>
{'name': 'Eda', 'surname': 'Wasserfall'}
&nbsp;
&gt;&gt;&gt; <strong>s1.validate({"name": "Eda"})</strong>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/tester/.local/lib/python3.4/site-packages/schema.py", line 290, in validate
    SchemaMissingKeyError('Missing keys: ' + s_missing_keys, e)
schema.SchemaMissingKeyError: Missing keys: 'surname'
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Dokončení popisu možností nabízených knihovnou <i>Schema</i></h2>

<p>V&nbsp;první polovině dnešního článku nejprve dokončíme popis knihovny
<i>Schema</i>. Pravděpodobně se jedná o nejčastěji používanou knihovnu tohoto
typu (alespoň v&nbsp;Pythonu), ovšem to může být způsobeno tím, že třetí
knihovna <i>Voluptuous</i> má těžko zapamatovatelné jméno, i když jsou některé
její vlastnosti lepší. U knihovny <i>Schema</i> si ukážeme použití klauzulí
<strong>And</strong>, <strong>Or</strong> a <strong>Optional</strong> i to,
jakým způsobem je možné validační schéma vylepšit (a současně zjednodušit)
s&nbsp;využitím vlastních tříd implementujících metodu
<strong>validate</strong>. Díky tomu, že se pro validaci používají třídy, je
totiž možné implementovat i poměrně sofistikované testy, například zjištění,
zda údaje ve všech slovnících mají unikátní ID popř.&nbsp;že je někde ID
zduplikováno (samozřejmě lze vymyslet i další testy, v&nbsp;nichž se využívají
kontextové informace uložené do objektů).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Třetí demonstrační příklad &ndash; kontrola platu a pracovní pozice zaměstnanců</h2>

<p>Již minule jsme si ukázali některé možnosti nabízené knihovnou
<i>Schema</i>. Víme již, jak pomocí predikátů kontrolovat například i hodnoty
uložené do slovníků atd. Nyní si tyto vlastnosti otestujeme na dalším příkladu,
v&nbsp;němž budeme validovat záznamy (slovníky) obsahující informace o
zaměstnancích. V&nbsp;těchto záznamech se budou vyskytovat údaje o platu a
taktéž pracovní pozici (ta bude později kontrolována oproti číselníku).
Základní validační schéma může vypadat takto:</p>

<pre>
employee = Schema({"name": str,
                   "surname": str,
                   "id": positive_integer,
                   "salary": salary,
                   "position": str})
</pre>

<p>Vidíme, že tři hodnoty musí být typu řetězec, ID zaměstnance bude celé
kladné číslo a jeho plat bude kontrolován predikátem <strong>salary</strong>.
Oba dva námi vytvořené predikáty jsou prozatím dosti jednoduché:</p>

<pre>
def <strong>positive_integer</strong>(value):
    return type(value) is int and value &gt; 0
&nbsp;
&nbsp;
def <strong>salary</strong>(value):
    return type(value) is float and value &gt; 10000.0 and value &lt; 99999.9
</pre>

<p>Ve druhém predikátu kontrolujeme jak datový typ, tak i to, zda hodnota leží
v&nbsp;určeném rozsahu.</p>

<p>Úplný zdrojový kód v&nbsp;pořadí <a
href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-3">třetího
příkladu</a>, v&nbsp;němž zkoušíme možnosti knihovny <i>Schema</i>, vypadá
následovně:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from sys import argv
from schema import Schema, SchemaError
&nbsp;
&nbsp;
def <strong>validate</strong>(schema, data, verbose_mode=False):
    try:
        print("\n\n")
        if verbose_mode:
            print(schema)
        print(data)
        schema.validate(data)
        print("pass")
    except SchemaError as e:
        print(e)
&nbsp;
&nbsp;
def <strong>positive_integer</strong>(value):
    return type(value) is int and value &gt; 0
&nbsp;
&nbsp;
def <strong>salary</strong>(value):
    return type(value) is float and value &gt; 10000.0 and value &lt; 99999.9
&nbsp;
&nbsp;
employee = Schema({"name": str,
                   "surname": str,
                   "id": positive_integer,
                   "salary": salary,
                   "position": str})
&nbsp;
&nbsp;
verbose_mode = "-v" in argv
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": -15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 1000000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "id": 1,
                    "salary": 100000000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 45000.0,
                    "position": ""},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 45000.0,
                    "position": "tovarnik"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "",
                    "surname": "",
                    "id": 1,
                    "salary": 25000.0,
                    "position": ""},
                    verbose_mode)
</pre>

<p><div class="rs-tip-major">Poznámka: příklad lze spustit s&nbsp;volbou
<strong>-v</strong> pro výpis podrobnějších informací o použitém
schématu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výsledky běhu třetího demonstračního příkladu</h2>

<p>Podívejme se nyní na výsledky běhu třetího demonstračního příkladu,
především na zprávy oznamující úspěšnou popř.&nbsp;neúspěšnou validaci:</p>

<pre>
{'salary': 15000.0, 'position': 'QA', 'name': 'Eda', 'id': 1, 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'salary': 15000, 'position': 'QA', 'name': 'Eda', 'id': 1, 'surname': 'Wasserfall'}
Key 'salary' error:
<strong>salary(15000) should evaluate to True</strong>
&nbsp;
&nbsp;
&nbsp;
{'salary': -15000.0, 'position': 'QA', 'name': 'Eda', 'id': 1, 'surname': 'Wasserfall'}
Key 'salary' error:
<strong>salary(-15000.0) should evaluate to True</strong>
&nbsp;
&nbsp;
&nbsp;
{'salary': 1000000.0, 'position': 'QA', 'name': 'Eda', 'id': 1, 'surname': 'Wasserfall'}
Key 'salary' error:
<strong>salary(1000000.0) should evaluate to True</strong>
&nbsp;
&nbsp;
&nbsp;
{'salary': 15000.0, 'position': 'QA', 'name': 'Eda', 'id': 1, 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'salary': 100000000.0, 'position': 'QA', 'name': 'Eda', 'id': 1}
Key 'salary' error:
<strong>salary(100000000.0) should evaluate to True</strong>
&nbsp;
&nbsp;
&nbsp;
{'salary': 45000.0, 'position': '', 'name': 'Eda', 'id': 1, 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'salary': 45000.0, 'position': 'tovarnik', 'name': 'Eda', 'id': 1, 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'salary': 25000.0, 'position': '', 'name': '', 'id': 1, 'surname': ''}
<strong>pass</strong>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Čtvrtý demonstrační příklad &ndash; použití klauzulí <strong>And</strong> a <strong>Or</strong></h2>

<p>Při pohledu na předchozí příklad je patrné, že validace ještě v&nbsp;žádném
případě není dokonalá. Především se může stát, že plat bude zapsán formou
celého čísla, vůbec nekontrolujeme, zda není jméno/příjmení prázdný řetězec a
dále není kontrolována ani pracovní pozice. Vylepšení bude provedeno
s&nbsp;pomocí klauzulí <strong>And</strong> a <strong>Or</strong>, které
dokážou spojit více predikátů logickou spojkou. Nejprve si však vytvoříme nové
predikáty, které použijeme (bez dalšího popisu &ndash; jsou prajednoduché):</p>

<pre>
def <strong>positive_integer</strong>(value):
    return type(value) is int and value &gt; 0
&nbsp;
&nbsp;
def <strong>positive_float</strong>(value):
    return type(value) is float and value &gt; 0
</pre>

<p>Dále si vytvoříme jednoduchý číselník se jmény pracovních pozic:</p>

<pre>
<strong>POSITIONS</strong> = ["QA", "DevOps", "Admin", "Docs", "HR"]
</pre>

<p>A konečně můžeme napsat nové validační schéma, tentokrát pomocí spojek
<strong>And</strong> a <strong>Or</strong>:</p>

<pre>
employee = Schema({"name": <strong>And</strong>(str, len),
                   "surname": <strong>And</strong>(str, len),
                   "id": positive_integer,
                   "salary": <strong>Or</strong>(positive_integer, positive_float, lambda x: x &gt; 10000.0 and x &lt; 99999.0),
                   "position": <strong>And</strong>(str, lambda s: s in POSITIONS)})
</pre>

<p><div class="rs-tip-major">Validační kritérium u &bdquo;salary&ldquo; není
napsáno správně &ndash; pokuste se ho opravit před přečtením dalších
kapitol.</div></p>

<p>Úplný zdrojový kód v&nbsp;pořadí již <a
href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-4">čtvrtého
příkladu</a>, v&nbsp;němž zkoušíme možnosti knihovny <i>Schema</i>, vypadá
následovně:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from sys import argv
from schema import Schema, SchemaError, And, Or
&nbsp;
&nbsp;
def <strong>validate</strong>(schema, data, verbose_mode=False):
    try:
        print("\n\n")
        if verbose_mode:
            print(schema)
        print(data)
        schema.validate(data)
        print("pass")
    except SchemaError as e:
        print(e)
&nbsp;
&nbsp;
def <strong>positive_integer</strong>(value):
    return type(value) is int and value &gt; 0
&nbsp;
&nbsp;
def <strong>positive_float</strong>(value):
    return type(value) is float and value &gt; 0
&nbsp;
&nbsp;
POSITIONS = ["QA", "DevOps", "Admin", "Docs", "HR"]
&nbsp;
employee = Schema({"name": And(str, len),
                   "surname": And(str, len),
                   "id": positive_integer,
                   "salary": Or(positive_integer, positive_float, lambda x: x &gt; 10000.0 and x &lt; 99999.0),
                   "position": And(str, lambda s: s in POSITIONS)})
&nbsp;
verbose_mode = "-v" in argv
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": -15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 1000000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "id": 1,
                    "salary": 100000000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 45000.0,
                    "position": ""},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 45000.0,
                    "position": "tovarnik"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "",
                    "surname": "",
                    "id": 1,
                    "salary": 25000.0,
                    "position": ""},
                    verbose_mode)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledky běhu čtvrtého demonstračního příkladu</h2>

<p>Pokud předchozí příklad spustíme, měly by se na standardní výstup vypsat
následující zprávy o úspěchu či neúspěchu validace jednotlivých informací o
zaměstnancích:</p>

<pre>
{'position': 'QA', 'id': 1, 'salary': 15000.0, 'name': 'Eda', 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'position': 'QA', 'id': 1, 'salary': 15000, 'name': 'Eda', 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'position': 'QA', 'id': 1, 'salary': -15000.0, 'name': 'Eda', 'surname': 'Wasserfall'}
<strong>Key 'salary' error:</strong>
Or(&lt;function positive_integer at 0x7fa41594fbf8&gt;, &lt;function positive_float at 0x7fa4158df730&gt;, &lt;function &lt;lambda&gt; at 0x7fa4158df7b8&gt;) did not validate -15000.0
&lt;lambda&gt;(-15000.0) should evaluate to True
&nbsp;
&nbsp;
&nbsp;
{'position': 'QA', 'id': 1, 'salary': 1000000.0, 'name': 'Eda', 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'position': 'QA', 'id': 1, 'salary': 15000.0, 'name': 'Eda', 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'id': 1, 'salary': 100000000.0, 'name': 'Eda', 'position': 'QA'}
<strong>Missing keys: 'surname'</strong>
&nbsp;
&nbsp;
&nbsp;
{'position': '', 'id': 1, 'salary': 45000.0, 'name': 'Eda', 'surname': 'Wasserfall'}
<strong>Key 'position' error:</strong>
&lt;lambda&gt;('') should evaluate to True
&nbsp;
&nbsp;
&nbsp;
{'position': 'tovarnik', 'id': 1, 'salary': 45000.0, 'name': 'Eda', 'surname': 'Wasserfall'}
<strong>Key 'position' error:</strong>
&lt;lambda&gt;('tovarnik') should evaluate to True
&nbsp;
&nbsp;
&nbsp;
{'position': '', 'id': 1, 'salary': 25000.0, 'name': '', 'surname': ''}
<strong>Key 'position' error:</strong>
&lt;lambda&gt;('') should evaluate to True
</pre>

<p>Povšimněte si, jak se projevilo nekorektně napsané validační kritérium pro
&bdquo;salary&ldquo;.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Použití klauzule <strong>Optional</strong></h2>

<p>Další velmi užitečnou klauzulí je klauzule <strong>Optional</strong>, která
se zapisuje u <i>klíčů</i>. Označujeme jí ty klíče, resp.&nbsp;ty dvojice
klíč+hodnota, které jsou nepovinné. Příklad použití pro dvě nepovinné položky
&bdquo;salary&ldquo; a &bdquo;position&ldquo; zapsané do validačního
kritéria:</p>

<pre>
employee = Schema({"name": <strong>And</strong>(str, len),
                   "surname": <strong>And</strong>(str, len),
                   "id": positive_integer,
                   <strong>Optional</strong>("salary"): <strong>And</strong>(<strong>Or</strong>(positive_integer, positive_float), lambda x: x &gt; 10000.0 and x &lt; 99999.0),
                   <strong>Optional</strong>("position"): <strong>And</strong>(str, lambda s: s in POSITIONS)})
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití regulárních výrazů pro kontrolu dat ve slovnících</h2>

<p>Ukažme si ještě jednoduchý predikát sloužící pro kontrolu, zda zadaná
hodnota odpovídá jménu či příjmení (používáme zde velmi jednoduchý regulární
výraz, ten ovšem nemusí být platný pro všechna příjmení):</p>

<pre>
def <strong>name_str</strong>(value):
    return re.fullmatch("[A-Z][a-z]+", value)
</pre>

<p>Způsob zakomponování tohoto predikátu do validačního schématu:</p>

<pre>
employee = Schema({"name": <strong>And</strong>(str, len, name_str),
                   "surname": <strong>And</strong>(str, len, name_str),
                   "id": positive_integer,
                   <strong>Optional</strong>("salary"): <strong>And</strong>(<strong>Or</strong>(positive_integer, positive_float), lambda x: x &gt; 10000.0 and x &lt; 99999.0),
                   <strong>Optional</strong>("position"): <strong>And</strong>(str, lambda s: s in POSITIONS)})
</pre>

<p>Je použita klauzule <strong>And</strong>, takže pro jméno a příjmení je
nutné, aby následující predikáty platily v&nbsp;uvedeném pořadí:</p>

<ul>
<li><strong>str</strong> &ndash; jedná se o řetězec</li>
<li><strong>len</strong> &ndash; řetězec není prázdný</li>
<li><strong>name_str</strong> &ndash; řetězec odpovídá regulárnímu výrazu <strong>"[A-Z][a-z]+"</strong></li>
</ul>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojový kód pátého demonstračního příkladu a jeho výsledky</h2>

<p>Úplný zdrojový kód <a
href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-5">pátého
příkladu</a> vypadá následovně:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import re
from sys import argv
from schema import Schema, SchemaError, And, Or, Optional
&nbsp;
&nbsp;
def <strong>validate</strong>(schema, data, verbose_mode=False):
    try:
        print("\n\n")
        if verbose_mode:
            print(schema)
        print(data)
        schema.validate(data)
        print("pass")
    except SchemaError as e:
        print(e)
&nbsp;
&nbsp;
def <strong>positive_integer</strong>(value):
    return type(value) is int and value &gt; 0
&nbsp;
&nbsp;
def <strong>positive_float</strong>(value):
    return type(value) is float and value &gt; 0
&nbsp;
&nbsp;
def <strong>name_str</strong>(value):
    return re.fullmatch("[A-Z][a-z]+", value)
&nbsp;
&nbsp;
<strong>POSITIONS</strong> = ["QA", "DevOps", "Admin", "Docs", "HR"]
&nbsp;
employee = Schema({"name": And(str, len, name_str),
                   "surname": And(str, len, name_str),
                   "id": positive_integer,
                   Optional("salary"): And(Or(positive_integer, positive_float), lambda x: x &gt; 10000.0 and x &lt; 99999.0),
                   Optional("position"): And(str, lambda s: s in POSITIONS)})
&nbsp;
verbose_mode = "-v" in argv
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": -15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 1000000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "id": 1,
                    "salary": 100000000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 45000.0,
                    "position": ""},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 45000.0,
                    "position": "tovarnik"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 25000.0,},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "position": "DevOps"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 45000.0,
                    "position": "HR"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "wasserfall",
                    "id": 1,
                    "salary": 45000.0,
                    "position": "HR"},
                    verbose_mode)
</pre>

<p>Následuje výpis výsledků validace:</p>

<pre>
{'position': 'QA', 'id': 1, 'name': 'Eda', 'surname': 'Wasserfall', 'salary': 15000.0}
pass
&nbsp;
&nbsp;
&nbsp;
{'position': 'QA', 'id': 1, 'name': 'Eda', 'surname': 'Wasserfall', 'salary': 15000}
pass
&nbsp;
&nbsp;
&nbsp;
{'position': 'QA', 'id': 1, 'name': 'Eda', 'surname': 'Wasserfall', 'salary': -15000.0}
Key 'salary' error:
Or(&lt;function positive_integer at 0x7f671c0779d8&gt;, &lt;function positive_float at 0x7f671c085730&gt;) did not validate -15000.0
positive_float(-15000.0) should evaluate to True
&nbsp;
&nbsp;
&nbsp;
{'position': 'QA', 'id': 1, 'name': 'Eda', 'surname': 'Wasserfall', 'salary': 1000000.0}
Key 'salary' error:
&lt;lambda&gt;(1000000.0) should evaluate to True
&nbsp;
&nbsp;
&nbsp;
{'position': 'QA', 'id': 1, 'name': 'Eda', 'surname': 'Wasserfall', 'salary': 15000.0}
pass
&nbsp;
&nbsp;
&nbsp;
{'position': 'QA', 'id': 1, 'name': 'Eda', 'salary': 100000000.0}
Key 'salary' error:
&lt;lambda&gt;(100000000.0) should evaluate to True
&nbsp;
&nbsp;
&nbsp;
{'position': '', 'id': 1, 'name': 'Eda', 'surname': 'Wasserfall', 'salary': 45000.0}
Key 'position' error:
&lt;lambda&gt;('') should evaluate to True
&nbsp;
&nbsp;
&nbsp;
{'position': 'tovarnik', 'id': 1, 'name': 'Eda', 'surname': 'Wasserfall', 'salary': 45000.0}
Key 'position' error:
&lt;lambda&gt;('tovarnik') should evaluate to True
&nbsp;
&nbsp;
&nbsp;
{'id': 1, 'name': 'Eda', 'surname': 'Wasserfall', 'salary': 25000.0}
pass
&nbsp;
&nbsp;
&nbsp;
{'position': 'DevOps', 'id': 1, 'name': 'Eda', 'surname': 'Wasserfall'}
pass
&nbsp;
&nbsp;
&nbsp;
{'id': 1, 'name': 'Eda', 'surname': 'Wasserfall'}
pass
&nbsp;
&nbsp;
&nbsp;
{'position': 'HR', 'id': 1, 'name': 'eda', 'surname': 'Wasserfall', 'salary': 45000.0}
Key 'name' error:
name_str('eda') should evaluate to True
&nbsp;
&nbsp;
&nbsp;
{'position': 'HR', 'id': 1, 'name': 'Eda', 'surname': 'wasserfall', 'salary': 45000.0}
Key 'surname' error:
name_str('wasserfall') should evaluate to True
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Použití třídy pro kontrolu údajů o platu a o pracovní pozici</h2>

<p>Knihovna <i>Schema</i> programátorům nabízí ještě jednu velmi zajímavou
možnost definice validačních kritérií. Kritérium totiž může být implementováno
třídou, u které se očekává existence metody <strong>validate</strong>, která
pro neúspěšnou validaci vyhazuje výjimku typu <strong>SchemaError</strong>.
Ukažme si to na tom nejjednodušším příkladu &ndash; kontrole platu:</p>

<pre>
class <strong>Salary</strong>:
    def <strong>validate</strong>(self, value):
        if not is_integer(value) and not is_float(value):
            raise SchemaError("Salary has unexpected type {t}".format(t=type(value)))
        elif value &lt;= 10000:
            raise SchemaError("Salary {s} is too low".format(s=value))
        elif value &gt;= 99999.9:
            raise SchemaError("Salary {s} is too high".format(s=value))
</pre>

<p>Zařazení do schématu se provede takto (vytvoří se instance třídy):</p>

<pre>
employee = Schema({"name": And(str, len, name_str)),
                   "surname": And(str, len, name_str)),
                   "id": ...,
                   Optional("salary"): <strong>Salary()</strong>,
                   Optional("position"): ...})
</pre>

<p>Podobná třída již v&nbsp;knihovně existuje &ndash; jedná se o třídu
<strong>Regex</strong>, kterou taktéž můžeme použít. Při vytváření objektů se
do konstruktoru přímo předá regulární výraz:</p>

<pre>
employee = Schema({"name": And(str, len, <strong>Regex("[A-Z][a-z]+")</strong>),
                   "surname": And(str, len, <strong>Regex("[A-Z][a-z]+")</strong>),
                   "id": ...,
                   Optional("salary"): <strong>Salary()</strong>,
                   Optional("position"): ...})
</pre>

<p>Podobně lze realizovat třídu pro kontrolu pracovní pozice:</p>

<pre>
class <strong>Position</strong>:
    POSITIONS = ["QA", "DevOps", "Admin", "Docs", "HR"]
&nbsp;
    def <strong>validate</strong>(self, value):
        if value not in Position.POSITIONS:
            raise SchemaError("Unknown position '{p}'".format(p=value))
</pre>

<p>Zařazení do schématu se provede takto (vytvoří se instance třídy):</p>

<pre>
employee = Schema({"name": And(str, len, <strong>Regex("[A-Z][a-z]+"</strong>)),
                   "surname": And(str, len, <strong>Regex("[A-Z][a-z]+"</strong>)),
                   "id": ...,
                   Optional("salary"): <strong>Salary()</strong>,
                   Optional("position"): And(str, <strong>Position()</strong>)})
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kontrola unikátnosti ID zaměstnance</h2>

<p>Vzhledem k&nbsp;tomu, že se do schématu předává instance třídy provádějící
validaci, můžeme naše validační schéma ještě více vylepšit. Můžeme totiž
provést kontrolu, zda je ID zaměstnance unikátní, tj.&nbsp;zda neexistují
nějaké duplicity. Provede se to jednoduše &ndash; do nové třídy pro kontrolu
unikátnosti ID přidáme atribut <strong>_ids</strong> obsahující množinu již
validovaných ID. Musí přitom platit podmínka, že ID právě kontrolovaného
záznamu se v&nbsp;této množině nesmí vyskytovat. Implementace je snadná:</p>

<pre>
class <strong>UniqueId</strong>:
&nbsp;
    def <strong>__init__</strong>(self):
        self._ids = set()
&nbsp;
    def <strong>validate</strong>(self, value):
        if value in self._ids:
            raise SchemaError("ID {id} is not unique".format(id=value))
        self._ids.add(value)
</pre>

<p>Zařazení do schématu se provede takto:</p>

<pre>
employee = Schema({"name": And(str, len, <strong>Regex("[A-Z][a-z]+"</strong>)),
                   "surname": And(str, len, <strong>Regex("[A-Z][a-z]+"</strong>)),
                   "id": <strong>UniqueId()</strong>,
                   Optional("salary"): <strong>Salary()</strong>,
                   Optional("position"): And(str, <strong>Position()</strong>)})
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zdrojový kód šestého demonstračního příkladu</h2>

<p>Následuje výpis úplného zdrojového kódu <a
href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-6">šestého
příkladu použití knihovny Schema</a>:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import re
from sys import argv
from schema import Schema, SchemaError, And, Or, Optional, Regex
&nbsp;
&nbsp;
def <strong>validate</strong>(schema, data, verbose_mode=False):
    try:
        print("\n\n")
        if verbose_mode:
            print(schema)
        print(data)
        schema.validate(data)
        print("pass")
    except SchemaError as e:
        print(e)
&nbsp;
&nbsp;
def <strong>is_integer</strong>(value):
    return type(value) is int
&nbsp;
&nbsp;
def <strong>is_float</strong>(value):
    return type(value) is float
&nbsp;
&nbsp;
class <strong>Salary</strong>:
    def <strong>validate</strong>(self, value):
        if not is_integer(value) and not is_float(value):
            raise SchemaError("Salary has unexpected type {t}".format(t=type(value)))
        elif value &lt;= 10000:
            raise SchemaError("Salary {s} is too low".format(s=value))
        elif value &gt;= 99999.9:
            raise SchemaError("Salary {s} is too high".format(s=value))
&nbsp;
&nbsp;
class <strong>Position</strong>:
    POSITIONS = ["QA", "DevOps", "Admin", "Docs", "HR"]
&nbsp;
    def <strong>validate</strong>(self, value):
        if value not in Position.POSITIONS:
            raise SchemaError("Unknown position '{p}'".format(p=value))
&nbsp;
&nbsp;
class <strong>UniqueId</strong>:
&nbsp;
    def <strong>__init__</strong>(self):
        self._ids = set()
&nbsp;
    def <strong>validate</strong>(self, value):
        if value in self._ids:
            raise SchemaError("ID {id} is not unique".format(id=value))
        self._ids.add(value)
&nbsp;
&nbsp;
employee = Schema({"name": And(str, len, Regex("[A-Z][a-z]+")),
                   "surname": And(str, len, Regex("[A-Z][a-z]+")),
                   "id": UniqueId(),
                   Optional("salary"): Salary(),
                   Optional("position"): And(str, Position())})
&nbsp;
verbose_mode = "-v" in argv
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 1,
                    "salary": 15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 2,
                    "salary": 15000,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 3,
                    "salary": -15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 4,
                    "salary": 1000000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 5,
                    "salary": 15000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "id": 6,
                    "salary": 100000000.0,
                    "position": "QA"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 7,
                    "salary": 45000.0,
                    "position": ""},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 8,
                    "salary": 45000.0,
                    "position": "tovarnik"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 9,
                    "salary": 25000.0},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 10,
                    "position": "DevOps"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Wasserfall",
                    "id": 11},
                    verbose_mode)
&nbsp;
validate(employee, {"id": 12},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "eda",
                    "surname": "Wasserfall",
                    "id": 13,
                    "salary": 45000.0,
                    "position": "HR"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "wasserfall",
                    "id": 14,
                    "salary": 45000.0,
                    "position": "HR"},
                    verbose_mode)
&nbsp;
validate(employee, {"name": "Eda",
                    "surname": "Unique",
                    "id": 1,
                    "salary": 45000.0,
                    "position": "HR"},
                    verbose_mode)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Výsledky běhu šestého demonstračního příkladu</h2>

<p>Po spuštění příkladu by se na standardní výstup měly vypsat tyto informace.
Povšimněte si, že nyní jsou chybové zprávy velmi dobře čitelné:</p>

<pre>
{'name': 'Eda', 'salary': 15000.0, 'id': 1, 'surname': 'Wasserfall', 'position': 'QA'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': 15000, 'id': 2, 'surname': 'Wasserfall', 'position': 'QA'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': -15000.0, 'id': 3, 'surname': 'Wasserfall', 'position': 'QA'}
<strong>Key 'salary' error:</strong>
<strong>Salary -15000.0 is too low</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': 1000000.0, 'id': 4, 'surname': 'Wasserfall', 'position': 'QA'}
<strong>Key 'salary' error:</strong>
<strong>Salary 1000000.0 is too high</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': 15000.0, 'id': 5, 'surname': 'Wasserfall', 'position': 'QA'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': 100000000.0, 'id': 6, 'position': 'QA'}
<strong>Key 'salary' error:</strong>
<strong>Salary 100000000.0 is too high</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': 45000.0, 'id': 7, 'surname': 'Wasserfall', 'position': ''}
<strong>Key 'position' error:</strong>
<strong>Unknown position ''</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': 45000.0, 'id': 8, 'surname': 'Wasserfall', 'position': 'tovarnik'}
<strong>Key 'position' error:</strong>
<strong>Unknown position 'tovarnik'</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': 25000.0, 'id': 9, 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'id': 10, 'surname': 'Wasserfall', 'position': 'DevOps'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'id': 11, 'surname': 'Wasserfall'}
<strong>pass</strong>
&nbsp;
&nbsp;
&nbsp;
{'id': 12}
<strong>Missing keys: 'name', 'surname'</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'eda', 'salary': 45000.0, 'id': 13, 'surname': 'Wasserfall', 'position': 'HR'}
<strong>Key 'name' error:</strong>
<strong>Regex('[A-Z][a-z]+') does not match 'eda'</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': 45000.0, 'id': 14, 'surname': 'wasserfall', 'position': 'HR'}
<strong>Key 'surname' error:</strong>
<strong>Regex('[A-Z][a-z]+') does not match 'wasserfall'</strong>
&nbsp;
&nbsp;
&nbsp;
{'name': 'Eda', 'salary': 45000.0, 'id': 1, 'surname': 'Unique', 'position': 'HR'}
<strong>Key 'id' error:</strong>
<strong>ID 1 is not unique</strong>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Knihovna <i>Voluptuous</i></h2>

<p>Poslední knihovnou určenou pro kontrolu struktury složitějších dat,
s&nbsp;níž se v&nbsp;dnešním článku alespoň ve stručnosti seznámíme, je
knihovna s&nbsp;dosti neobvyklým názvem <i>Voluptuous</i>, jejíž zdrojové kódy
nalezneme na adrese <a
href="https://github.com/alecthomas/voluptuous">https://github.com/alecthomas/voluptuous</a>.
Tato knihovna je postavena na podobných principech, s&nbsp;jakými jsme se již
dříve setkali u knihoven <i>Schemagic</i> i <i>Schema</i> &ndash; samotná
struktura dat je popsána přímo v&nbsp;Pythonu (jako klasická nativní
pythonovská datová struktura, většinou seznam či slovník) a není tedy zapotřebí
používat žádný doménově specifický jazyk (<i>DSL &ndash; Domain Specific
Language</i>). I z&nbsp;tohoto důvodu bude základní popis této knihovny
relativně stručný, protože si její vlastnosti a rozdíly ukážeme na několika
demonstračních příkladech, které budou v&nbsp;mnoha ohledech podobné již
popsaným příkladům.</p>

<p>Knihovnu <i>Voluptuous</i> (schválně, kdo dokáže to jméno opsat bez chyby?)
si nejdříve nainstalujeme, a to konkrétně s&nbsp;využitím nástroje
<strong>pip3</strong> (nebo <strong>pip</strong>), protože tato knihovna je <a
href="https://pypi.python.org/pypi/voluptuous">samozřejmě registrována</a> i na
<a href="https://pypi.python.org/pypi">PyPI (Python Package Index)</a>. Pro
jednoduchost provedeme instalaci jen pro právě aktivního uživatele:</p>

<pre>
$ <strong>pip3 install --user voluptuous</strong>
&nbsp;
Collecting voluptuous
  Downloading voluptuous-0.11.1-py2.py3-none-any.whl
Installing collected packages: voluptuous
Successfully installed voluptuous-0.11.1
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Ukázka základních možností knihovny <i>Voluptuous</i> v&nbsp;REPLu</h2>

<p>Nyní si můžeme základní vlastnosti této knihovny otestovat
v&nbsp;interaktivní smyčce REPL programovacího jazyka Python. REPL spustíme
klasicky:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.6.3 (default, Oct  9 2017, 12:11:29) 
[GCC 7.2.1 20170915 (Red Hat 7.2.1-2)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 
</pre>

<p>Naimportujeme objekt <strong>Schema</strong> z&nbsp;této knihovny:</p>

<pre>
&gt;&gt;&gt; <strong>from voluptuous import Schema</strong>
&gt;&gt;&gt; 
</pre>

<p>Nyní si již můžeme nadeklarovat jednoduché schéma:</p>

<pre>
<strong>user = Schema({"name": str,</strong>
               <strong>"surname": str,</strong>
               <strong>"id": int})</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že deklarace schématu je
v&nbsp;tomto jednoduchém příkladě totožná s&nbsp;deklarací, kterou jsme si
ukázali <a
href="https://github.com/tisnik/python-schema-checks/blob/master/schema-demo-2/schema-demo-2.py#L55">ve
druhém demonstračním příkladu používajícího knihovnu Schema</a>.</div></p>

<p>Předchozí volání konstruktoru vytvořilo objekt typu <strong>Schema</strong>,
o čemž se můžeme přesvědčit velmi snadno:</p>

<pre>
&gt;&gt;&gt; <strong>user</strong>
&lt;Schema({'name': &lt;class 'str'&gt;, 'surname': &lt;class 'str'&gt;, 'id': &lt;class 'int'&gt;}, extra=PREVENT_EXTRA, required=False) object at 0x7fa88cb93eb8&gt;
</pre>

<p>Následuje ukázka použití schématu pro validaci (korektních) dat:</p>

<pre>
<strong>user({"name": "Eda",</strong>
      <strong>"surname": "Wasserfall",</strong>
      <strong>"id": 1})</strong>
&nbsp;
{'name': 'Eda', 'surname': 'Wasserfall', 'id': 1}
</pre>

<p>Povšimněte si malé změny: zde se přímo volá <strong>user(data)</strong>
(jakoby <strong>user</strong> byla běžná funkce a ne objekt) a nikoli
<strong>user.validate(data)</strong>, což je konvence, se kterou jsme se
setkali v&nbsp;knihovně <i>Schema</i>. V&nbsp;knihovně <i>Voluptuous</i> je
zkrácené volání implementováno díky překrytí metody <strong>__call__</strong>
vlastní implementací.</p>

<p>Příklad chybového výstupu pro nekorektní data bude vypadat následovně:</p>

<pre>
<strong>user({"name": 42,</strong>
      <strong>"id": "X"})</strong>
&nbsp;
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
  File "/home/tester/.local/lib/python3.6/site-packages/voluptuous/schema_builder.py", line 267, in __call__
    return self._compiled([], data)
  File "/home/tester/.local/lib/python3.6/site-packages/voluptuous/schema_builder.py", line 587, in validate_dict
    return base_validate(path, iteritems(data), out)
  File "/home/tester/.local/lib/python3.6/site-packages/voluptuous/schema_builder.py", line 425, in validate_mapping
    raise er.MultipleInvalid(errors)
voluptuous.error.MultipleInvalid: expected str for dictionary value @ data['name']
&gt;&gt;&gt;
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. První příklad &ndash; validace obsahu seznamů knihovnou <i>Voluptuous</i></h2>

<p>Ukažme si nyní <a
href="https://github.com/tisnik/python-schema-checks/tree/master/voluptuous-demo-1">demonstrační
příklad</a> se základním použitím této knihovny. Příklad obsahuje jediný soubor
napsaný v&nbsp;Pythonu, podobně jako tomu bylo i ve všech předchozích
demonstračních příkladech. V&nbsp;příkladu používáme již nám známou
uživatelskou funkci <strong>validate</strong>:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from voluptuous import Schema
from voluptuous import Invalid
&nbsp;
&nbsp;
def <strong>validate</strong>(schema, data):
    try:
        print("\n\n")
        print(schema)
        print(data)
        schema(data)
        print("pass")
    except Exception as e:
        print(e)
&nbsp;
&nbsp;
def <strong>pos</strong>(value):
    if type(value) is not int or value &lt;= 0:
        raise Invalid("positive integer value expected, but got {v} instead".format(v=value))
&nbsp;
&nbsp;
number_list = Schema([int, float, complex])
&nbsp;
validate(number_list, [1, 2, 3])
validate(number_list, [1.1, 2.2, 3.3])
validate(number_list, [1+2j, 3+4j, 5j])
validate(number_list, ["1", "2", "3"])
&nbsp;
binary_numbers = Schema([0, 1])
validate(binary_numbers, [0, 0, 0])
validate(binary_numbers, [1, 1, 0])
validate(binary_numbers, [1, 2, 3])
&nbsp;
validate(Schema(pos), 42)
validate(Schema(pos), 0)
validate(Schema(pos), -1)
validate(Schema(pos), 1.5)
</pre>

<p>U seznamů deklarujeme, jaké vlastnosti jsou očekávány u všech prvků. Mezi
vlastnostmi se implicitně používá operace &bdquo;or&ldquo;:</p>

<pre>
<i># seznam čísel libovolného typu</i>
number_list = Schema([int, float, complex])
&nbsp;
<i># seznam binárních číslic</i>
binary_numbers = Schema([0, 1])
</pre>

<p>Podívejme se nyní na výsledky běhu tohoto demonstračního příkladu. První
část, tj.&nbsp;kontrola typů prvků seznamů dopadla následovně. Pouze poslední
seznam obsahující řetězce byl vyhodnocen jako nekorektní (podle očekávání):</p>

<pre>
[&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;]
[1, 2, 3]
pass
&nbsp;
&nbsp;
&nbsp;
[&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;]
[1.1, 2.2, 3.3]
pass
&nbsp;
&nbsp;
&nbsp;
[&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;]
[(1+2j), (3+4j), 5j]
pass
&nbsp;
&nbsp;
&nbsp;
[&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;]
['1', '2', '3']
expected complex @ data[0]
</pre>

<p>Dále testujeme, jestli prvky seznamu tvoří řetězec binárních číslic, opět
s&nbsp;očekávaným výsledkem:</p>

<pre>
[0, 1]
[0, 0, 0]
pass
&nbsp;
&nbsp;
&nbsp;
[0, 1]
[1, 1, 0]
pass
&nbsp;
&nbsp;
&nbsp;
[0, 1]
[1, 2, 3]
not a valid value @ data[1]
</pre>

<p>A nakonec test, zda jsou hodnoty celými kladnými čísly:</p>

<pre>
&lt;function pos at 0x7f421daff0d0&gt;
42
pass
&nbsp;
&nbsp;
&nbsp;
&lt;function pos at 0x7f421daff0d0&gt;
0
positive integer value expected, but got 0 instead
&nbsp;
&nbsp;
&nbsp;
&lt;function pos at 0x7f421daff0d0&gt;
-1
positive integer value expected, but got -1 instead
&nbsp;
&nbsp;
&nbsp;
&lt;function pos at 0x7f421daff0d0&gt;
1.5
positive integer value expected, but got 1.5 instead
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Tři varianty validace celých kladných čísel implementované ve třech knihovnách</h2>

<p>Zajímavá je především definice funkce <strong>pos</strong> kontrolující, zda
je jejím parametrem celé kladné číslo. Tato funkce musí v&nbsp;případě
nekorektní hodnoty vyhodit výjimku typu <strong>Invalid</strong> (třídu
s&nbsp;touto výjimkou jsme importovali na začátku). Je pro osvěžení si
porovnejme implementaci této funkce pro všechny tři popsané knihovny:</p>

<h3>Schemagic</h3>

<pre>
def <strong>positive_integer</strong>(value):
    if type(value) is not int or value &lt;= 0:
        raise TypeError("positive integer value expected, but got {v} instead".format(v=value))
</pre>

<p>V&nbsp;případě nevalidních dat se vyhazuje výjimka typu
<strong>TypeError</strong> nebo <strong>ValueError</strong>.</p>



<h3>Schema</h3>

<pre>
def <strong>positive_integer</strong>(value):
    return type(value) is int and value &gt; 0
</pre>

<p>Predikát, který u nevalidních dat vrací pravdivostní hodnotu
<strong>False</strong>.</p>



<h3>Voluptuous</h3>

<pre>
def <strong>positive_integer</strong>(value):
    if type(value) is not int or value &lt;= 0:
        raise Invalid("positive integer value expected, but got {v} instead".format(v=value))
</pre>

<p>V&nbsp;případě nevalidních dat se vyhazuje výjimka typu
<strong>Invalid</strong>.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Druhý příklad &ndash; validace obsahu seznamů</h2>

<p><a
href="https://github.com/tisnik/python-schema-checks/tree/master/voluptuous-demo-2">Ve
druhém příkladu</a> založeném na knihovně <i>Voluptuous</i> si ukážeme nám již
dobře známý problém &ndash; verifikaci, jestli předaný slovník obsahuje všechny
očekávané klíče a zda jsou hodnoty na tyto klíče navázané očekávaného typu.
Zápis validačních kritérií vypadá naprosto stejně, jako u předchozí popisované
knihovny <i>Schema</i>:</p>

<pre>
user = Schema({"name": str,
               "surname": str,
               "id": pos})
</pre>

<p>Následně toto schéma použijeme pro validaci slovníků s&nbsp;různým obsahem,
například:</p>

<pre>
validate(user, {"name": "Eda",
                "surname": "Wasserfall",
                "id": 1})
&nbsp;
validate(user, {"name": "Eda",
                "id": 1})
</pre>

<p>Úplný kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from voluptuous import Schema
from voluptuous import Invalid
&nbsp;
&nbsp;
def <strong>validate</strong>(schema, data):
    try:
        print("\n\n")
        print(schema)
        print(data)
        schema(data)
        print("pass")
    except Exception as e:
        print(e)
&nbsp;
&nbsp;
def <strong>pos</strong>(value):
    if type(value) is not int or value &lt;= 0:
        raise Invalid("positive integer value expected, but got {v} instead".format(v=value))
&nbsp;
&nbsp;
number_list = Schema([int, float, complex])
&nbsp;
validate(number_list, [1, 2, 3])
validate(number_list, [1.1, 2.2, 3.3])
validate(number_list, [1+2j, 3+4j, 5j])
validate(number_list, ["1", "2", "3"])
&nbsp;
binary_numbers = Schema([0, 1])
validate(binary_numbers, [0, 0, 0])
validate(binary_numbers, [1, 1, 0])
validate(binary_numbers, [1, 2, 3])
&nbsp;
validate(Schema(pos), 42)
validate(Schema(pos), 0)
validate(Schema(pos), -1)
validate(Schema(pos), 1.5)
&nbsp;
user = Schema({"name": str,
               "surname": str,
               "id": pos})
&nbsp;
validate(user, {"name": "Eda",
                "surname": "Wasserfall",
                "id": 1})
&nbsp;
validate(user, {"name": "Eda",
                "id": 1})
&nbsp;
validate(user, {"name": "Eda",
                "surname": "Wasserfall",
                "id": 0})
</pre>

<p>Opět se podívejme na výstup vyprodukovaný tímto příkladem:</p>

<pre>
[&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;]
[1, 2, 3]
pass
&nbsp;
&nbsp;
&nbsp;
[&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;]
[1.1, 2.2, 3.3]
pass
&nbsp;
&nbsp;
&nbsp;
[&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;]
[(1+2j), (3+4j), 5j]
pass
&nbsp;
&nbsp;
&nbsp;
[&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;]
['1', '2', '3']
expected complex @ data[0]
&nbsp;
&nbsp;
&nbsp;
[0, 1]
[0, 0, 0]
pass
&nbsp;
&nbsp;
&nbsp;
[0, 1]
[1, 1, 0]
pass
&nbsp;
&nbsp;
&nbsp;
[0, 1]
[1, 2, 3]
not a valid value @ data[1]
&nbsp;
&nbsp;
&nbsp;
&lt;function pos at 0x7f2fb79b50d0&gt;
42
pass
&nbsp;
&nbsp;
&nbsp;
&lt;function pos at 0x7f2fb79b50d0&gt;
0
positive integer value expected, but got 0 instead
&nbsp;
&nbsp;
&nbsp;
&lt;function pos at 0x7f2fb79b50d0&gt;
-1
positive integer value expected, but got -1 instead
&nbsp;
&nbsp;
&nbsp;
&lt;function pos at 0x7f2fb79b50d0&gt;
1.5
positive integer value expected, but got 1.5 instead
&nbsp;
&nbsp;
&nbsp;
{'name': &lt;class 'str'&gt;, 'surname': &lt;class 'str'&gt;, 'id': &lt;function pos at 0x7f2fb79b50d0&gt;}
{'name': 'Eda', 'surname': 'Wasserfall', 'id': 1}
pass
&nbsp;
&nbsp;
&nbsp;
{'name': &lt;class 'str'&gt;, 'surname': &lt;class 'str'&gt;, 'id': &lt;function pos at 0x7f2fb79b50d0&gt;}
{'name': 'Eda', 'id': 1}
pass
&nbsp;
&nbsp;
&nbsp;
{'name': &lt;class 'str'&gt;, 'surname': &lt;class 'str'&gt;, 'id': &lt;function pos at 0x7f2fb79b50d0&gt;}
{'name': 'Eda', 'surname': 'Wasserfall', 'id': 0}
positive integer value expected, but got 0 instead for dictionary value @ data['id']
</pre>

<p><div class="rs-tip-major">Poznámka: možnosti této knihovny jsou samozřejmě
mnohem větší, ovšem podrobnosti si ukážeme až ve třetí a současně i závěrečné
části tohoto miniseriálu.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační projekty, které jsme si v&nbsp;dnešním článku popsali,
byly uloženy do Git repositáře, který naleznete na adrese <a
href="https://github.com/tisnik/python-schema-checks">https://github.com/tisnik/python-schema-checks</a>.
V&nbsp;tabulce pod tímto odstavcem jsou vypsány odkazy na všechny projekty
rozdělené podle použité knihovny. Z&nbsp;tohoto důvodu zde naleznete i projekty
zmíněné <a
href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">minule</a>.</p>

<h3>Schemagic</h3>

<table>
<tr><th>Projekt</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>schemagic-demo-1</td><td>základní vlastnosti knihovny Schemagic</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-1">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-1</a></td></tr>
<tr><td>schemagic-demo-2</td><td>konverze prováděné při validaci</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-2">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-2</a></td></tr>
<tr><td>schemagic-demo-3</td><td>vlastní validační funkce</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-3">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-3</a></td></tr>
<tr><td>schemagic-demo-4</td><td>vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-4">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-4</a></td></tr>
<tr><td>schemagic-demo-5</td><td>validace slovníků</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-5">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-5</a></td></tr>
<tr><td>schemagic-demo-6</td><td>validace slovníků podruhé</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-6">https://github.com/tisnik/python-schema-checks/tree/master/schemagic-demo-6</a></td></tr>
</table>

<h3>Schema</h3>

<table>
<tr><th>Projekt</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>schema-demo-1</td><td>základní vlastnosti knihovny Schema</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-1">https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-1</a></td></tr>
<tr><td>schema-demo-2</td><td>validace slovníků a dalších typů</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-2">https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-2</a></td></tr>
<tr><td>schema-demo-3</td><td>validace slovníků a dalších typů</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-3">https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-3</a></td></tr>
<tr><td>schema-demo-4</td><td>validace slovníků a dalších typů</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-4">https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-4</a></td></tr>
<tr><td>schema-demo-5</td><td>validace slovníků a dalších typů</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-5">https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-5</a></td></tr>
<tr><td>schema-demo-6</td><td>validace slovníků a dalších typů</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-6">https://github.com/tisnik/python-schema-checks/tree/master/schema-demo-6</a></td></tr>
</table>

<h3>Voluptuous</h3>

<table>
<tr><th>Projekt</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>voluptuous-demo-1</td><td>základní vlastnosti knihovny Voluptuous</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/voluptuous-demo-1">https://github.com/tisnik/python-schema-checks/tree/master/voluptuous-demo-1</a></td></tr>
<tr><td>voluptuous-demo-2</td><td>validace obsahu slovníků</td><td><a href="https://github.com/tisnik/python-schema-checks/tree/master/voluptuous-demo-2">https://github.com/tisnik/python-schema-checks/tree/master/voluptuous-demo-2</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>7 Best Python Libraries for Validating Data<br />
<a href="https://www.yeahhub.com/7-best-python-libraries-validating-data/">https://www.yeahhub.com/7-best-python-libraries-validating-data/</a>
</li>

<li>voluptuous na (na PyPi)<br />
<a href="https://pypi.python.org/pypi/voluptuous">https://pypi.python.org/pypi/voluptuous</a>
</li>

<li>voluptuous (na GitHubu)<br />
<a href="https://github.com/alecthomas/voluptuous">https://github.com/alecthomas/voluptuous</a>
</li>

<li>schemagic 0.9.1 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schemagic/0.9.1">https://pypi.python.org/pypi/schemagic/0.9.1</a>
</li>

<li>Schemagic / Schemagic.web (na GitHubu)<br />
<a href="https://github.com/Mechrophile/schemagic">https://github.com/Mechrophile/schemagic</a>
</li>

<li>schema 0.6.7 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schema">https://pypi.python.org/pypi/schema</a>
</li>

<li>schema (na GitHubu)<br />
<a href="https://github.com/keleshev/schema">https://github.com/keleshev/schema</a>
</li>

<li>XML Schema validator and data conversion library for Python<br />
<a href="https://github.com/brunato/xmlschema">https://github.com/brunato/xmlschema</a>
</li>

<li>xmlschema 0.9.7<br />
<a href="https://pypi.python.org/pypi/xmlschema/0.9.7">https://pypi.python.org/pypi/xmlschema/0.9.7</a>
</li>

<li>jsonschema 2.6.0<br />
<a href="https://pypi.python.org/pypi/jsonschema">https://pypi.python.org/pypi/jsonschema</a>
</li>

<li>warlock 1.3.0<br />
<a href="https://pypi.python.org/pypi/warlock">https://pypi.python.org/pypi/warlock</a>
</li>

<li>Python Virtual Environments – A Primer<br />
<a href="https://realpython.com/python-virtual-environments-a-primer/">https://realpython.com/python-virtual-environments-a-primer/</a>
</li>

<li>pip 1.1 documentation: Requirements files<br />
<a href="https://pip.readthedocs.io/en/1.1/requirements.html">https://pip.readthedocs.io/en/1.1/requirements.html</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Unit testing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

