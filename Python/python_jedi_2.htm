<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovna Jedi: doplňování kódu a statická analýza kódu v Pythonu (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovna Jedi: doplňování kódu a statická analýza kódu v Pythonu (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o knihovně Jedi si ukážeme další funkce dostupné při statické analýze zdrojových kódů napsaných v Pythonu. Samozřejmě nezapomeneme na ukázku propojení knihovny Jedi s textovým editorem Atom a taktéž s modulem určeným pro slavný Emacs.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Knihovna Jedi: doplňování kódu a statická analýza kódu v Pythonu (dokončení)</a></p>
<p><a href="#k02">2. Proč dát přednost knihovně Jedi před konkurenčními projekty?</a></p>
<p><a href="#k03">3. Použití metody <strong>follow_definition()</strong> pro přečtení podrobnějších informací a navrhovaném identifikátoru</a></p>
<p><a href="#k04">4. Analýza volání funkce</a></p>
<p><a href="#k05">5. Složitější příklad pro analýzu volaných funkcí</a></p>
<p><a href="#k06">6. Volání metod namísto obyčejných funkcí</a></p>
<p><a href="#k07">7. Malé zopakování z&nbsp;minula &ndash; dynamické chování Pythonu a jeho vliv na funkci knihovny Jedi</a></p>
<p><a href="#k08">8. Podrobnější informace o jménech funkcí v&nbsp;případě, že kód nelze staticky jednoznačně analyzovat</a></p>
<p><a href="#k09">9. Doplnění jmen volaných metod</a></p>
<p><a href="#k10">10. Výpis všech metod objektu</a></p>
<p><a href="#k11">11. Výpis metod začínajících na uvedený prefix</a></p>
<p><a href="#k12">12. Některé chyby, které v&nbsp;knihovně Jedi existují</a></p>
<p><a href="#k13">13. Chování Jedi vs.&nbsp;chování interpretru Pythonu</a></p>
<p><a href="#k14">14. Další pluginy integrující knihovnu Jedi do programátorských textových editorů</a></p>
<p><a href="#k15">15. Použití knihovny Jedi v&nbsp;textovém editoru Atom</a></p>
<p><a href="#k16">16. Ukázky volání funkcí Jedi z&nbsp;Atomu při editaci zdrojových kódů napsaných v&nbsp;Pythonu</a></p>
<p><a href="#k17">17. Použití knihovny Jedi společně s&nbsp;Emacsem</a></p>
<p><a href="#k18">18. Ukázky volání funkcí Jedi z&nbsp;Emacsu při editaci zdrojových kódů napsaných v&nbsp;Pythonu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovna Jedi: doplňování kódu a statická analýza kódu v Pythonu (dokončení)</h2>

<p>V&nbsp;dnešním článku o knihovně <i>Jedi</i> navážeme na obě témata, kterým
jsme se věnovali <a
href="https://www.root.cz/clanky/knihovna-jedi-doplnovani-kodu-a-staticka-analyza-kodu-v-pythonu/">v&nbsp;úvodním
článku</a>. Nejprve se seznámíme s&nbsp;dalšími možnostmi, které tato knihovna
nabízí při analýze kódu. Bude se jednat například o <a href="#k04">zjištění
funkce</a>, jejíž parametry uživatel právě zapisuje, doplňování jmen metod,
nabídky všech metod platných v&nbsp;daném kontextu (v&nbsp;textových editorech
se tyto údaje typicky zobrazí po zápisu tečky, popř.&nbsp;tečky následované
prefixem jména metody) a taktéž si ukážeme příklad zdrojového kódu, který už
knihovna Jedi nedokáže korektně zpracovat. Ve druhé části dnešního článku si
ukážeme, jakým způsobem je tato knihovna propojena s&nbsp;programátorskými
textovými editory <a href="#k15">Atom</a> a taktéž <a href="#k17">Emacs</a>
přes vhodný plugin (zajímavé přitom je, že Jedi je využita hned v&nbsp;několika
pluginech určených pro Atom i Emacs).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Proč dát přednost knihovně Jedi před konkurenčními projekty?</h2>

<p><a
href="https://www.root.cz/clanky/knihovna-jedi-doplnovani-kodu-a-staticka-analyza-kodu-v-pythonu/">Minule</a>
jsme si ve druhé polovině článku <a
href="https://www.root.cz/clanky/knihovna-jedi-doplnovani-kodu-a-staticka-analyza-kodu-v-pythonu/#k15">popsali</a>
způsob použití knihovny <i>Jedi</i> společně s&nbsp;populárním textovým
editorem Vim. Dnes si kromě jiného řekneme, jakým způsobem je možné <i>Jedi</i>
<a href="#k15">integrovat do editoru Atom</a> a následně i způsob integrace se
<a href="#k17">slavným <del>operačním systémem</del> textovým editorem
Emacs</a>. Taktéž již víme, že existují i další rozhraní mezi knihovnou
<i>Jedi</i> a dalšími textovými editory či integrovanými vývojovými
prostředími. Například pro Visual Studio Code existuje Python Extension,
podobný plugin najdeme pro Eric IDE, Sublime text apod. Nesmíme zapomenout ani
na technologii <a
href="https://microsoft.github.io/language-server-protocol/">Language Server
Protocol</a>, která je v&nbsp;případě programovacího jazyka Python
implementována v&nbsp;projektu<a
href="https://github.com/palantir/python-language-server">Python Language
Server</a>.</p>

<p>Na tomto místě se čtenář může se zeptat, z&nbsp;jakého důvodu vlastně
vzniklo tolik rozhraní a projektů, které používají zrovna knihovnu Jedi a
nikoli jiný podobně koncipovaný nástroj. Existují dva hlavní důvody. První
z&nbsp;nich je ten, že knihovna Jedi dává při analýze zdrojových souborů
psaných v&nbsp;Pythonu poměrně dobré a přesné výsledky (i když ji můžeme
v&nbsp;některých případech zmást &ndash; viz jeden příklad uvedený níže). A
druhým důvodem je fakt, že se jedná o jednoduše nastavitelný a současně i
dostatečně &bdquo;lehkotonážní&ldquo; projekt, takže případná tvorba nového
pluginu pro nějaký textový editor je relativně jednoduchá (pokud můžu soukromě
a navíc trošku neférově porovnat, tak je to mnohem jednodušší, než například
provozovat Eclipse v&nbsp;režimu serveru).</p>

<p><div class="rs-tip-major">Poznámka: druhý důvod bude pravděpodobně stále
platit i ve chvíli, kdy se více rozšíří již zmíněný <i>LSP</i> (<i>Language
Server Protocol</i>), protože již dnes je knihovna Jedi součástí Python
Language Serveru, který LSP používá pro komunikaci s&nbsp;IDE a textovými
editory (popř.&nbsp;v&nbsp;případě potřeby i dalšími nástroji).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití metody <strong>follow_definition()</strong> pro přečtení podrobnějších informací a navrhovaném identifikátoru</h2>

<p>Dnešní první demonstrační příklad bude do určité míry shrnovat informace,
které jsme si řekli v&nbsp;úvodním článku. Budeme v&nbsp;něm analyzovat
následující (neúplný) skript, v&nbsp;němž je definována třída, funkce, lambda
funkce a dvě proměnné &ndash; všechny identifikátory přitom začínají na
&bdquo;an&ldquo;. Na posledním řádku testovacího skriptu je zapsán jen začátek
identifikátoru, taktéž &bdquo;an&ldquo;:</p>

<pre>
     1  
     2  class anumber:
     3      """Docstring for a class."""
     4      pass
     5  
     6  def anagrams(word):
     7      """Very primitive anagram generator."""
     8      if len(word) &lt; 2:
     9          return word
    10      else:
    11          tmp = []
    12          for i, letter in enumerate(word):
    13              for j in anagrams(word[:i]+word[i+1:]):
    14                  tmp.append(j+letter)
    15      return tmp
    16  
    17  ann = lambda x,y: x+y
    18  anybody=True
    19  answer="42"
    20  an
</pre>

<p>Při analýze skriptu umístíme pomyslný kurzor na řádek 20 a sloupec 2. To
zajistí následující kód:</p>

<pre>
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('an'), 'test.py')
</pre>

<p>Dále můžeme přes knihovnu Jedi zjistit všechny možné identifikátory, které
v&nbsp;kontextu řádku 20 začínají na &bdquo;an&ldquo;:</p>

<pre>
completions = script.completions()
</pre>

<p>Identifikátory, resp.&nbsp;přesněji řečeno jejich jména, si můžeme snadno
vypsat:</p>

<pre>
for completion in completions:
    print(completion.name)
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
anagrams
ann
answer
anumber
any
anybody
</pre>

<p>Kromě jmen identifikátorů můžeme také získat informace o jejich definici, a
to s&nbsp;využitím metody <strong>follow_definition()</strong> (tyto informace
ostatně uvidíme i v&nbsp;pluginem pro Atom a Emacs). Kód pro výpis se nám změní
následovně:</p>

<pre>
for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>

<p>Pomocná funkce <strong>print_definitions()</strong> vypíše typ objektu
(funkce, třída atd.), jeho plné jméno, jméno modulu, v&nbsp;němž je objekt
definovaný a konečně i řádek s&nbsp;definicí:</p>

<pre>
def print_definitions(definitions):
    if not definitions:
        print("not found")
        return
&nbsp;
    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
</pre>

<p>Po spuštění upraveného příkladu dostaneme následující výsledek. Povšimněte
si, že jméno modulu &bdquo;test.py&ldquo; odpovídá jménu předanému do
konstruktoru <strong>Script()</strong>; typicky toto jméno automaticky doplňuje
textový editor:</p>

<pre>
<strong>anagrams</strong>
----------------------------------------
function __main__.anagrams in test.py:6
anagrams(word)
&nbsp;
Very primitive anagram generator.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>ann</strong>
----------------------------------------
function __main__.&lt;lambda&gt; in test.py:17
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>answer</strong>
----------------------------------------
instance str in builtins.py:None
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>anumber</strong>
----------------------------------------
class __main__.anumber in test.py:2
Docstring for a class.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>any</strong>
----------------------------------------
function any in builtins.py:None
Return True if bool(x) is True for any x in the iterable.
&nbsp;
If the iterable is empty, return False.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>anybody</strong>
----------------------------------------
instance bool in builtins.py:None
</pre>

<p>Následuje výpis <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi11_follow_definitions.py">úplného
zdrojového kódu</a> dnešního prvního demonstračního příkladu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
class anumber:
    """Docstring for a class."""
    pass
&nbsp;
def anagrams(word):
    """Very primitive anagram generator."""
    if len(word) &lt; 2:
        return word
    else:
        tmp = []
        for i, letter in enumerate(word):
            for j in anagrams(word[:i]+word[i+1:]):
                tmp.append(j+letter)
    return tmp
&nbsp;
ann = lambda x,y: x+y
anybody=True
answer="42"
an'''
&nbsp;
&nbsp;
def print_definitions(definitions):
    if not definitions:
        print("not found")
        return
&nbsp;
    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('an'), 'test.py')
&nbsp;
completions = script.completions()
&nbsp;
for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Analýza volání funkce</h2>

<p>Knihovna Jedi obsahuje i další užitečnou vlastnost &ndash; ve chvíli, kdy se
kurzor nachází mezi kulatými závorkami za jménem volané funkce, dokáže zjistit
přesnější informace o této funkci; dokonce zjistí i pořadí právě zapisovaného
parametru. Totéž samozřejmě platí i pro volané metody. To například znamená, že
v&nbsp;případě tohoto kódu (kurzor je naznačen šipkou):</p>

<pre>
print(
      ^
</pre>

<p>by se vrátila informace o funkci <strong>print</strong>. Ukažme si tuto
užitečnou vlastnost na následujícím skriptu:</p>

<pre>
     1  
     2  def anagrams(word):
     3      """Very primitive anagram generator."""
     4      if len(word) &lt; 2:
     5          return word
     6      else:
     7          tmp = []
     8          for i, letter in enumerate(word):
     9              for j in anagrams(word[:i]+word[i+1:]):
    10                  tmp.append(j+letter)
    11      return tmp
    12  
    13  anagrams("pokus")
                  ^
</pre>

<p>Kurzor umístíme na místo šipky (řádek 13, sloupec 10):</p>

<pre>
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('anagrams('), 'test.py')
</pre>

<p>Po konstrukci objektu typu <strong>Script</strong> získáme seznam všech
funkcí, které v&nbsp;daném kontextu přichází do úvahy (vzhledem k&nbsp;dynamice
Pythonu nemusí být určení zcela jednoznačné). V&nbsp;našem případě se bude
jednat o jedinou funkci, ovšem v&nbsp;obecném případě se může jednat o více
záznamů:</p>

<pre>
call_signatures = script.call_signatures()
</pre>

<p>Získané signatury si následně v&nbsp;programové smyčce vypíšeme, konkrétně
především umístění otevírací závorky a index zadávaného parametru (to opět může
pomoci textovým editorům v&nbsp;orientaci ve zdrojovém kódu):</p>

<pre>
for call_signature in call_signatures:
    print(call_signatures.__str__(), call_signature.index, call_signature.bracket_start)
</pre>

<p>Výsledek vypsaný předchozí programovou smyčkou by měl vypadat
následovně:</p>

<pre>
[&lt;CallSignature: anagrams index 0&gt;] 0 (13, 8)
</pre>

<p>Tento výsledek je možné přečíst následovně: uživatel právě doplňuje
argumenty pro funkci <strong>anagrams</strong>, přičemž se jedná o první
argument (s&nbsp;indexem 0) a otevírací závorka byla nalezena na pozici [13,
8], tj.&nbsp;na třináctém řádku a sloupci 8.</p>

<p>Samozřejmě si opět ukážeme <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi12_call_signatures.py">celý
zdrojový kód tohoto příkladu</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def anagrams(word):
    """Very primitive anagram generator."""
    if len(word) &lt; 2:
        return word
    else:
        tmp = []
        for i, letter in enumerate(word):
            for j in anagrams(word[:i]+word[i+1:]):
                tmp.append(j+letter)
    return tmp
&nbsp;
anagrams("pokus")'''
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('anagrams('), 'test.py')
&nbsp;
call_signatures = script.call_signatures()
&nbsp;
for call_signature in call_signatures:
    print(call_signatures.__str__(), call_signature.index, call_signature.bracket_start)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Složitější příklad pro analýzu volaných funkcí</h2>

<p>Pro úplnost se podívejme na poněkud složitější příklad. Testovací skript od
řádku 11 obsahuje hned několik volaných funkcí, které mají různý počet
parametrů, otevírací levá kulatá závorka nemusí následovat hned na jménem
funkce a v&nbsp;posledním případu je dokonce otevírací závorka na zcela jiném
řádku, než první argument (i tento styl zápisu Python umožňuje, i když není
zcela přesně v&nbsp;souladu s&nbsp;PEP-8). Šipkami ^ jsou naznačena umístění
kurzoru, pro něž budeme žádat analýzu:</p>

<pre>
     1
     2  def foo():
     3      return 0
     4
     5  def bar(x):
     6      return 1
     7
     8  def baz(x,y):
     9      return 2
    10
    11  foo()
    12  bar(1)
    13  baz(1,2)
    14  baz(foo(), bar(1))
    15  print(10, 20, 30, 40, 50)
    16  print   (10, 20, 30, 40, 50)'''
</pre>

<p>Pro všech sedm umístění kurzoru by se měly vrátit následující údaje.
Povšimněte si, že místo zápisu levé otevírací závorky je vždy vypočteno
správně, a to i v&nbsp;poslední funkci (opět velká pomoc pro tvůrce pluginů) a
u funkce <strong>foo()</strong>, která nemá žádné parametry, se namísto indexu
zapisovaného argumentu objevila hodnota <strong>None</strong>:</p>

<pre>
[&lt;CallSignature: foo index None&gt;] None (11, 3)
&nbsp;
[&lt;CallSignature: bar index 0&gt;] 0 (12, 3)
&nbsp;
[&lt;CallSignature: baz index 1&gt;] 1 (13, 3)
&nbsp;
[&lt;CallSignature: bar index 0&gt;] 0 (14, 14)
&nbsp;
[&lt;CallSignature: print index 4&gt;] 4 (15, 5)
&nbsp;
[&lt;CallSignature: print index 4&gt;] 4 (16, 8)
</pre>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def foo():
    return 0
&nbsp;
def bar(x):
    return 1
&nbsp;
def baz(x,y):
    return 2
&nbsp;
foo()
bar(1)
baz(1,2)
baz(foo(), bar(1))
print(10, 20, 30, 40, 50)
print   (10, 20, 30, 40, 50)'''
&nbsp;
&nbsp;
def print_call_signatures(script):
    call_signatures = script.call_signatures()
&nbsp;
    for call_signature in call_signatures:
        print(call_signatures.__str__(), call_signature.index, call_signature.bracket_start)
&nbsp;
    print()
&nbsp;
&nbsp;
lines = src.count('\n')
&nbsp;
script = jedi.Script(src, lines-4, len('foo('), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, lines-3, len('bar(1'), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, lines-2, len('baz(1,2'), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, lines-1, len('baz(foo(), bar(1'), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, lines, len('print(10, 20, 30, 40, '), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, lines+1, len('print   (10, 20, 30, 40, '), 'test.py')
print_call_signatures(script)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Volání metod namísto obyčejných funkcí</h2>

<pre>
#!/usr/bin/env python3
# vim: set fileencoding=utf-8

import jedi

src = '''
class C1:
    def foo(self):
        return 0

    def bar(self, x):
        return 1

    def baz(self, x,y):
        return 2

obj = C1()
obj.foo()
obj.bar(1)
obj.baz(1,2)
obj.baz(obj.foo(), obj.bar(1))'''


def print_call_signatures(script):
    call_signatures = script.call_signatures()

    for call_signature in call_signatures:
        print(call_signatures.__str__(), call_signature.index, call_signature.bracket_start)

    print()


lines = src.count('\n')

script = jedi.Script(src, lines-2, len('obj.foo('), 'test.py')
print_call_signatures(script)

script = jedi.Script(src, lines-1, len('obj.bar(1'), 'test.py')
print_call_signatures(script)

script = jedi.Script(src, lines, len('obj.baz(1,2'), 'test.py')
print_call_signatures(script)

script = jedi.Script(src, lines+1, len('obj.baz(obj.foo(), obj.bar(1'), 'test.py')
print_call_signatures(script)
</pre>

<pre>
[<CallSignature: foo index None>] None (13, 7)

[<CallSignature: bar index 0>] 0 (14, 7)

[<CallSignature: baz index 1>] 1 (15, 7)

[<CallSignature: bar index 0>] 0 (16, 26)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Malé zopakování z&nbsp;minula &ndash; dynamické chování Pythonu a jeho vliv na funkci knihovny Jedi</h2>

<pre>
     1
     2  class anumber:
     3      """Docstring for a class."""
     4      pass
     5
     6
     7  if random.random() &lt; 0.5:
     8      def answer():
     9          """1st variant of answer function."""
    10          return "42"
    11  elif random.random() &lt; 0.5:
    12      def answer():
    13          """2nd variant of answer function."""
    14          return 42
    15  else:
    16      def answer():
    17          """3rd variant of answer function."""
    18          return [42]
    19
    20
    21  def anagrams(word):
    22      """Very primitive anagram generator."""
    23      if len(word) &lt; 2:
    24          return word
    25      else:
    26          tmp = []
    27          for i, letter in enumerate(word):
    28              for j in anagrams(word[:i]+word[i+1:]):
    29                  tmp.append(j+letter)
    30      return tmp
    31
    32  ann = lambda x,y: x+y
    33  anybody=True
    34  print(answer())
</pre>

<pre>
function __main__.answer in test.py:8
function __main__.answer in test.py:12
function __main__.answer in test.py:16
</pre>

<pre>
#!/usr/bin/env python3
# vim: set fileencoding=utf-8

import jedi

src = '''
class anumber:
    """Docstring for a class."""
    pass


if random.random() &lt; 0.5:
    def answer():
        """1st variant of answer function."""
        return "42"
elif random.random() &lt; 0.5:
    def answer():
        """2nd variant of answer function."""
        return 42
else:
    def answer():
        """3rd variant of answer function."""
        return [42]


def anagrams(word):
    """Very primitive anagram generator."""
    if len(word) &lt; 2:
        return word
    else:
        tmp = []
        for i, letter in enumerate(word):
            for j in anagrams(word[:i]+word[i+1:]):
                tmp.append(j+letter)
    return tmp

ann = lambda x,y: x+y
anybody=True
print(answer())'''


def print_definitions(definitions):
    if not definitions:
        print("not found")
        return

    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))


lines = src.count('\n')
script = jedi.Script(src, lines+1, len('print('), 'test.py')

definitions = script.goto_definitions()

print_definitions(definitions)
</pre>




<p><a name="k08"></a></p>
<h2 id="k08">8. Podrobnější informace o jménech funkcí v&nbsp;případě, že kód nelze staticky jednoznačně analyzovat</h2>

<pre>
     1
     2  class anumber:
     3      """Docstring for a class."""
     4      pass
     5
     6
     7  if random.random() &lt; 0.5:
     8      def answer():
     9          """1st variant of answer function."""
    10          return "42"
    11  elif random.random() &lt; 0.5:
    12      def answer():
    13          """2nd variant of answer function."""
    14          return 42
    15  else:
    16      def answer():
    17          """3rd variant of answer function."""
    18          return [42]
    19
    20
    21  def anagrams(word):
    22      """Very primitive anagram generator."""
    23      if len(word) &lt; 2:
    24          return word
    25      else:
    26          tmp = []
    27          for i, letter in enumerate(word):
    28              for j in anagrams(word[:i]+word[i+1:]):
    29                  tmp.append(j+letter)
    30      return tmp
    31
    32  ann = lambda x,y: x+y
    33  anybody=True
    34  an
</pre>

<pre>
anagrams
----------------------------------------
function __main__.anagrams in test.py:21
anagrams(word)

Very primitive anagram generator.




ann
----------------------------------------
function __main__.<lambda> in test.py:32





answer
----------------------------------------
function __main__.answer in test.py:16
answer()

3rd variant of answer function.




anumber
----------------------------------------
class __main__.anumber in test.py:2
Docstring for a class.




any
----------------------------------------
function any in builtins.py:None
Return True if bool(x) is True for any x in the iterable.

If the iterable is empty, return False.




anybody
----------------------------------------
instance bool in builtins.py:None





</pre>

<pre>
#!/usr/bin/env python3
# vim: set fileencoding=utf-8

import jedi

src = '''
class anumber:
    """Docstring for a class."""
    pass


if random.random() &lt; 0.5:
    def answer():
        """1st variant of answer function."""
        return "42"
elif random.random() &lt; 0.5:
    def answer():
        """2nd variant of answer function."""
        return 42
else:
    def answer():
        """3rd variant of answer function."""
        return [42]


def anagrams(word):
    """Very primitive anagram generator."""
    if len(word) &lt; 2:
        return word
    else:
        tmp = []
        for i, letter in enumerate(word):
            for j in anagrams(word[:i]+word[i+1:]):
                tmp.append(j+letter)
    return tmp

ann = lambda x,y: x+y
anybody=True
an'''


def print_definitions(definitions):
    if not definitions:
        print("not found")
        return

    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))


lines = src.count('\n')
script = jedi.Script(src, lines+1, len('an'), 'test.py')

completions = script.completions()

for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Doplnění jmen volaných metod</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výpis všech metod objektu</h2>

<pre>
Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.




__eq__
----------------------------------------
function object.__eq__ in builtins.py:None
Return self==value.




__format__
----------------------------------------
function object.__format__ in builtins.py:None
default object formatter




__ge__
----------------------------------------
function object.__ge__ in builtins.py:None
Return self>=value.




__getattribute__
----------------------------------------
function object.__getattribute__ in builtins.py:None
Return getattr(self, name).




__gt__
----------------------------------------
function object.__gt__ in builtins.py:None
Return self>value.




__hash__
----------------------------------------
function object.__hash__ in builtins.py:None
Return hash(self).




__init__
----------------------------------------
function object.__init__ in builtins.py:None
Initialize self.  See help(type(self)) for accurate signature.




__init_subclass__
----------------------------------------
function object.__init_subclass__ in builtins.py:None
This method is called when a class is subclassed.

The default implementation does nothing. It may be
overridden to extend subclasses.




__le__
----------------------------------------
function object.__le__ in builtins.py:None
Return self<=value.




__lt__
----------------------------------------
function object.__lt__ in builtins.py:None
Return self<value.




__ne__
----------------------------------------
function object.__ne__ in builtins.py:None
Return self!=value.




__new__
----------------------------------------
function object.__new__ in builtins.py:None
Create and return a new object.  See help(type) for accurate signature.




__reduce__
----------------------------------------
function object.__reduce__ in builtins.py:None
helper for pickle




__reduce_ex__
----------------------------------------
function object.__reduce_ex__ in builtins.py:None
helper for pickle




__repr__
----------------------------------------
function object.__repr__ in builtins.py:None
Return repr(self).




__setattr__
----------------------------------------
function object.__setattr__ in builtins.py:None
Implement setattr(self, name, value).




__sizeof__
----------------------------------------
function object.__sizeof__ in builtins.py:None
__sizeof__() -> int
size of object in memory, in bytes




__str__
----------------------------------------
function object.__str__ in builtins.py:None
Return str(self).




__subclasshook__
----------------------------------------
function object.__subclasshook__ in builtins.py:None
Abstract classes can override this to customize issubclass().

This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).




</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Výpis metod začínajících na uvedený prefix</h2>

<pre>
foo
----------------------------------------
function __main__.foo in test.py:8
foo(self)

Function foo defined in class C2.
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Některé chyby, které v&nbsp;Jedi existují</h2>

<pre>
     1
     2  class C1:
     3      def foo(self):
     4          """Function foo defined in class C1."""
     5          return 1
     6
     7  class C2:
     8      def foo(self):
     9          """Function foo defined in class C2."""
    10          return 2
    11
    12  class C3:
    13      def foo(self):
    14          """Function foo defined in class C3."""
    15          return 2
    16
    17  if True:
    18      obj = C1()
    19  elif True:
    20      obj = C2()
    21  else:
    22      obj = C3()
    23  obj.fo
</pre>

<pre>
foo
----------------------------------------
function __main__.foo in test.py:8
foo(self)

Function foo defined in class C2.
</pre>

<pre>
#!/usr/bin/env python3
# vim: set fileencoding=utf-8

import jedi

src = '''
class C1:
    def foo(self):
        """Function foo defined in class C1."""
        return 1

class C2:
    def foo(self):
        """Function foo defined in class C2."""
        return 2

class C3:
    def foo(self):
        """Function foo defined in class C3."""
        return 2

if True:
    obj = C1()
elif True:
    obj = C2()
else:
    obj = C3()
obj.fo'''


def print_definitions(definitions):
    if not definitions:
        print("not found")
        return

    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))


lines = src.count('\n')
script = jedi.Script(src, lines+1, len('obj.fo'), 'test.py')

completions = script.completions()

for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Použití knihovny Jedi v&nbsp;textovém editoru Atom</h2>

wget -o atom.rpm https://atom.io/download/rpm

[root@ibm-x3650m4-01-vm-09 ~]# dnf install atom.rpm
Last metadata expiration check: 1:09:13 ago on Tue 21 Aug 2018 10:00:34 AM EDT.
Dependencies resolved.
================================================================================
 Package          Arch      Version           Repository                   Size
================================================================================
Installing:
 atom             x86_64    1.29.0-0.1        @commandline                131 M
Installing dependencies:
 libXScrnSaver    x86_64    1.2.2-14.fc28     Fedora-Everything            29 k

Transaction Summary
================================================================================
Install  2 Packages

Total size: 131 M
Total download size: 29 k
Installed size: 523 M
Is this ok [y/N]:

Downloading Packages:
libXScrnSaver-1.2.2-14.fc28.x86_64.rpm          1.1 MB/s |  29 kB     00:00    
--------------------------------------------------------------------------------
Total                                           1.0 MB/s |  29 kB     00:00     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : libXScrnSaver-1.2.2-14.fc28.x86_64                     1/2 
  Running scriptlet: libXScrnSaver-1.2.2-14.fc28.x86_64                     1/2 
  Installing       : atom-1.29.0-0.1.x86_64                                 2/2 
  Running scriptlet: atom-1.29.0-0.1.x86_64                                 2/2 
  Verifying        : atom-1.29.0-0.1.x86_64                                 1/2 
  Verifying        : libXScrnSaver-1.2.2-14.fc28.x86_64                     2/2 

Installed:
  atom.x86_64 1.29.0-0.1           libXScrnSaver.x86_64 1.2.2-14.fc28          

Complete!


<p><a name="k16"></a></p>
<h2 id="k16">16. Ukázky volání funkcí Jedi z&nbsp;Atomu při editaci zdrojových kódů napsaných v&nbsp;Pythonu</h2>

<p>Po úspěšné instalaci pluginu &bdquo;autocomplete-python-jedi&ldquo; si
můžeme vyzkoušet, jaké nové funkce jsou v&nbsp;Atomu dostupné. Opět se
podívejme na screenshoty s&nbsp;krátkým popisem:</p>

<a href="https://www.root.cz/obrazek/337209/"><img src="https://i.iinfo.cz/images/420/jedi2-5-prev.png" class="image-337209" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 7: Nápověda (přesněji řečeno dokumentační řetězec) k&nbsp;právě
zadávané funkci nebo metodě se zobrazí automaticky (po nepatrné časové
prodlevě).</i></p>

<a href="https://www.root.cz/obrazek/337210/"><img src="https://i.iinfo.cz/images/420/jedi2-6-prev.png" class="image-337210" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 8: Zobrazení seznamu funkcí/metod/proměnných obsahujících buď
přímo zadaný prefix, nebo (což je potenciálně velmi užitečné) sekvenci zadaných
znaků kdekoli v&nbsp;názvu. Na prvním místě jsou samozřejmě zobrazeny ty
identifikátory, které začínají prefixem. Výchozí klávesová zkratka je
<strong>Ctrl+Space</strong>. Podobným způsobem se zobrazí metody objektu
apod.</i></p>

<a href="https://www.root.cz/obrazek/337211/"><img src="https://i.iinfo.cz/images/420/jedi2-7-prev.png" class="image-337211" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 9: Kurzor se nachází na volání funkce.</i></p>

<a href="https://www.root.cz/obrazek/337212/"><img src="https://i.iinfo.cz/images/420/jedi2-8-prev.png" class="image-337212" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 10: A po stisku poněkud kostrbaté klávesové zkratky
<strong>Ctrl+Alt+G</strong> se provedl skok na její definici.</i></p>

<a href="https://www.root.cz/obrazek/337213/"><img src="https://i.iinfo.cz/images/420/jedi2-9-prev.png" class="image-337213" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 11: Zobrazení všech výskytů nějaké objektu (funkce, metody,
proměnné).</i></p>

<a href="https://www.root.cz/obrazek/337214/"><img src="https://i.iinfo.cz/images/420/jedi2-10-prev.png" class="image-337214" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 12: Pokud si navíc nainstalujete plugin nazvaný
&bdquo;Hyperclick&ldquo;, bude možné namísto <strong>Ctrl+Alt+G</strong> použít
zkratku <strong>Ctrl+klik myší</strong> (což ovšem koliduje s&nbsp;přidáním
multikurzoru, takže se tato zkratka musela přesunout).</i></p>

<a href="https://www.root.cz/obrazek/337215/"><img src="https://i.iinfo.cz/images/420/jedi2-11-prev.png" class="image-337215" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 13: Použití kombinace pluginů &bdquo;Hyperclick&ldquo; a
&bdquo;autocomplete-python-jedi&ldquo;.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Použití knihovny Jedi společně s&nbsp;Emacsem</h2>

<p>V&nbsp;článcích, v&nbsp;nichž se zmiňujeme o programátorských textových
editorech, samozřejmě není možné nezmínit slavný Emacs, který za sebou má <a
href="https://www.root.cz/clanky/historie-vyvoje-textovych-editoru-eine-zwei-emacs/">dosti
dlouhou historii</a>, v&nbsp;jejímž průběhu vzniklo jeho několik forků. Pro
Emacs existuje hned několik pluginů volajících knihovnu <i>Jedi</i>; my si dnes
popíšeme plugin pojmenovaný jednoduše <strong>jedi</strong>. Existuje několik
způsobů instalace tohoto pluginu. Nejjednodušší je instalace ve chvíli, kdy
máte v&nbsp;Emacsu povolen repositář balíčků <a
href="https://melpa.org/">MELPA</a> (ten obsahuje přibližně 3900 balíčků!). Po
zadání příkazu:</p>

<pre>
Alt-X list-packages
</pre>

<p>je možné zjistit, jestli je MELPA povolena a zda je tedy balíček
<strong>jedi</strong> přímo k&nbsp;dispozici:</p>

<img src="https://i.iinfo.cz/images/420/jedi2-12.png" class="image-337216" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 14: V&nbsp;případě, že MELPA není povolena, budou dostupné jen
balíčky z&nbsp;repositáře ELPA (Emacs Lisp Package Archive).</i></p>

<p>Pokud tomu tak není, je nutné MELPu povolit, například těmito řádky
přidanými do souboru <strong>.emacs</strong>:</p>

<pre>
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

<img src="https://i.iinfo.cz/images/420/jedi2-13.png" class="image-337217" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 15: V&nbsp;případě, že MELPA je povolena, měl by se
v&nbsp;seznamu balíčků objevit i plugin <strong>jedi</strong>.</i></p>

<p>Plugin <strong>jedi</strong> nainstalujeme běžným způsobem:</p>

<img src="https://i.iinfo.cz/images/420/jedi2-14.png" class="image-337218" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 16: Instalace pluginu <strong>jedi</strong>.</i></p>

<p>Následně přidáme další dva řádky do souboru <strong>.emacs</strong>:</p>

<pre>
<strong>(add-hook 'python-mode-hook 'jedi:setup)</strong>
<strong>(setq jedi:complete-on-dot t)</strong>
</pre>

<p>Takže jeho výsledný obsah <i>může</i> vypadat přibližně takto:</p>

<pre>
<strong>(require 'package)</strong>
<strong>(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)</strong>
&nbsp;
;; Added by Package.el.  This must come before configurations of
;; installed packages.  Don't delete this line.  If you don't want it,
;; just comment it out by adding a semicolon to the start of the line.
;; You may delete these explanatory comments.
(package-initialize)

(add-hook 'python-mode-hook 'jedi:setup)
(setq jedi:complete-on-dot t)

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(inhibit-startup-screen t)
 '(package-selected-packages (quote (jedi diffview ##))))

(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Ukázky volání funkcí Jedi z&nbsp;Emacsu při editaci zdrojových kódů napsaných v&nbsp;Pythonu</h2>

<p>Po načtení souboru s&nbsp;koncovkou &bdquo;.py&ldquo; se Emacs přepne do
režimu Pythonu a současně by se na pozadí měla spustit knihovna Jedi ve
vlastním virtuálním prostředí (<i>virtualenv</i>). Ta umožní například
následující operace připomínající skutečné IDE:</p>

<img src="https://i.iinfo.cz/images/420/jedi2-15.png" class="image-337219" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 17: Zobrazení seznamu objektů (funkcí, metod atd.) začínajících
daným prefixem. U vybraného objektu se zobrazí jeho nápověda (dokumentační
řetězec).</i></p>

<img src="https://i.iinfo.cz/images/420/jedi2-16.png" class="image-337220" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 18: Zúžení výběru po zadání delšího prefixu.</i></p>

<img src="https://i.iinfo.cz/images/420/jedi2-17.png" class="image-337221" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 19: Zobrazení všech metod objektu.</i></p>

<img src="https://i.iinfo.cz/images/420/jedi2-18.png" class="image-337222" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 20: Zde si povšimněte, že se zobrazí námi zapsaný dokumentační
řetězec (Jedi má přístup k&nbsp;editovanému souboru).</i></p>

<img src="https://i.iinfo.cz/images/420/jedi2-19.png" class="image-337223" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 21: Zápis prefixu jména třídy, opět se zobrazením dokumentačního
řetězce.</i></p>

<p><div class="rs-tip-major">Poznámka: některé další možnosti kombinace Emacsu
a Jedi budou popsány v&nbsp;miniseriálu o Emacsu ve funkci IDE.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady ukazující některé možnosti
knihovny <i>Jedi</i> byly uloženy do Git repositáře, který je dostupný na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již poměrně rozsáhlý) repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>1</td><td>jedi11_follow_definitions.py</td><td>použití metody <strong>follow_definition()</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi11_follow_definitions.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi11_follow_definitions.py</a></td></tr>
<tr><td>2</td><td>jedi12_call_signatures.py</td><td>použití metody <strong>Script.call_signatures()</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi12_call_signatures.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi12_call_signatures.py</a></td></tr>
<tr><td>3</td><td>jedi13_more_difficult_call_signatures.py</td><td>použití metody <strong>Script.call_signatures()</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi13_more_difficult_call_signatures.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi13_more_difficult_call_signatures.py</a></td></tr>
<tr><td>4</td><td>jedi14_method_signatures.py</td><td>signatury volaných metod (ne funkcí)</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi14_method_signatures.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi14_method_signatures.py</a></td></tr>
<tr><td>5</td><td>jedi15_goto_definitions_random_function_declaration.py</td><td>dynamické chování Pythonu ovlivňující chování Jedi</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi15_goto_definitions_random_function_declaration.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi15_goto_definitions_random_function_declaration.py</a></td></tr>
<tr><td>6</td><td>jedi16_completion_follow_definition.py</td><td>dtto jako předchozí příklad, ovšem pro <strong>follow_definition()</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi16_completion_follow_definition.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi16_completion_follow_definition.py</a></td></tr>
<tr><td>7</td><td>jedi17_method_completion_and_definition.py</td><td>korektní doplnění jména metody</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi17_method_completion_and_definition.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi17_method_completion_and_definition.py</a></td></tr>
<tr><td>8</td><td>jedi18_all_methods_completion_and_definition.py</td><td>korektní doplnění jména metody</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi18_all_methods_completion_and_definition.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi18_all_methods_completion_and_definition.py</a></td></tr>
<tr><td>9</td><td>jedi19_howto_confuse_jedi.py</td><td>ukázka jednoduchého zmatení Jedi</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi18_howto_confuse_jedi.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi18_howto_confuse_jedi.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Jedi - an awesome autocompletion/static analysis library for Python<br />
<a href="https://jedi.readthedocs.io/en/latest/index.html">https://jedi.readthedocs.io/en/latest/index.html</a>
</li>

<li>Jedi API Overview<br />
<a href="https://jedi.readthedocs.io/en/latest/docs/api.html">https://jedi.readthedocs.io/en/latest/docs/api.html</a>
</li>

<li>jedi-vim<br />
<a href="https://github.com/davidhalter/jedi-vim">https://github.com/davidhalter/jedi-vim</a>
</li>

<li>YouCompleteMe: A code-completion engine for Vim<br />
<a href="https://valloric.github.io/YouCompleteMe/">https://valloric.github.io/YouCompleteMe/</a>
</li>

<li>Elpy: Emacs Python Development Environment<br />
<a href="https://github.com/jorgenschaefer/elpy">https://github.com/jorgenschaefer/elpy</a>
</li>

<li>Emacs-Jedi<br />
<a href="https://github.com/tkf/emacs-jedi">https://github.com/tkf/emacs-jedi</a>
</li>

<li>Python Autocomplete Jedi Package<br />
<a href="https://atom.io/packages/autocomplete-python-jedi">https://atom.io/packages/autocomplete-python-jedi</a>
</li>

<li>Autocomplete (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Autocomplete">https://en.wikipedia.org/wiki/Autocomplete</a>
</li>

<li>Seriál Textový editor Vim jako IDE (zde na Root.cz)<br />
<a href="https://www.root.cz/serialy/textovy-editor-vim-jako-ide/">https://www.root.cz/serialy/textovy-editor-vim-jako-ide/</a>
</li>

<li>Jedi: A completion library for Python<br />
<a href="https://www.masteringemacs.org/article/jedi-completion-library-python">https://www.masteringemacs.org/article/jedi-completion-library-python</a>
</li>

<li>Jedi.el - Python auto-completion for Emacs (GitHub)<br />
<a href="https://github.com/tkf/emacs-jedi">https://github.com/tkf/emacs-jedi</a>
</li>

<li>Jedi.el - Python auto-completion for Emacs (dokumentace, popis možností apod.)<br />
<a href="http://tkf.github.io/emacs-jedi/latest/">http://tkf.github.io/emacs-jedi/latest/</a>
</li>

<li>Vim - the ubiquitous text editor<br />
<a href="https://www.vim.org/">https://www.vim.org/</a>
</li>

<li>GNU Emacs<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>EmacsWiki<br />
<a href="https://www.emacswiki.org/emacs/EmacsWiki">https://www.emacswiki.org/emacs/EmacsWiki</a>
</li>

<li>Atom (stránka textového editoru)<br />
<a href="https://atom.io/">https://atom.io/</a>
</li>

<li>el-get (GitHub)<br />
<a href="https://github.com/dimitri/el-get">https://github.com/dimitri/el-get</a>
</li>

<li>MELPA<br />
<a href="https://www.emacswiki.org/emacs/MELPA">https://www.emacswiki.org/emacs/MELPA</a>
</li>

<li>Atom IDE<br />
<a href="https://ide.atom.io/">https://ide.atom.io/</a>
</li>

<li>Sublime Text as Python IDE - jedi<br />
<a href="https://screamingatmyscreen.com/2013/9/sublime-text-as-python-ide-jedi/">https://screamingatmyscreen.com/2013/9/sublime-text-as-python-ide-jedi/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

