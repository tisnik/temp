<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovna Jedi: doplňování kódu a statická analýza kódu v Pythonu (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovna Jedi: doplňování kódu a statická analýza kódu v Pythonu (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o knihovně Jedi si ukážeme další funkce dostupné při statické analýze zdrojových kódů napsaných v Pythonu. Samozřejmě nezapomeneme na ukázku propojení knihovny Jedi s textovým editorem Atom a taktéž s modulem určeným pro slavný Emacs.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Knihovna Jedi: doplňování kódu a statická analýza kódu v Pythonu (dokončení)</a></p>
<p><a href="#k02">2. Proč dát přednost knihovně Jedi před konkurenčními projekty?</a></p>
<p><a href="#k03">3. Použití metody <strong>follow_definition()</strong> pro přečtení podrobnějších informací a navrhovaném identifikátoru</a></p>
<p><a href="#k04">4. Analýza volání funkce</a></p>
<p><a href="#k05">5. Složitější příklad pro analýzu volaných funkcí</a></p>
<p><a href="#k06">6. Volání metod namísto obyčejných funkcí</a></p>
<p><a href="#k07">7. Malé zopakování z&nbsp;minula &ndash; dynamické chování Pythonu a jeho vliv na funkci knihovny Jedi</a></p>
<p><a href="#k08">8. Podrobnější informace o jménech funkcí v&nbsp;případě, že kód nelze staticky jednoznačně analyzovat</a></p>
<p><a href="#k09">9. Doplnění jmen volaných metod</a></p>
<p><a href="#k10">10. Výpis všech metod objektu</a></p>
<p><a href="#k11">11. Výpis metod začínajících na uvedený prefix</a></p>
<p><a href="#k12">12. Některé chyby, které v&nbsp;knihovně Jedi existují</a></p>
<p><a href="#k13">13. Chování Jedi vs.&nbsp;chování interpretru Pythonu</a></p>
<p><a href="#k14">14. Další pluginy integrující knihovnu Jedi do programátorských textových editorů</a></p>
<p><a href="#k15">15. Použití knihovny Jedi v&nbsp;textovém editoru Atom</a></p>
<p><a href="#k16">16. Ukázky volání funkcí Jedi z&nbsp;Atomu při editaci zdrojových kódů napsaných v&nbsp;Pythonu</a></p>
<p><a href="#k17">17. Použití knihovny Jedi společně s&nbsp;Emacsem</a></p>
<p><a href="#k18">18. Ukázky volání funkcí Jedi z&nbsp;Emacsu při editaci zdrojových kódů napsaných v&nbsp;Pythonu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovna Jedi: doplňování kódu a statická analýza kódu v Pythonu (dokončení)</h2>

<p>V&nbsp;dnešním článku o knihovně <i>Jedi</i> navážeme na obě témata, kterým
jsme se věnovali <a
href="https://www.root.cz/clanky/knihovna-jedi-doplnovani-kodu-a-staticka-analyza-kodu-v-pythonu/">v&nbsp;úvodním
článku</a>. Nejprve se seznámíme s&nbsp;dalšími možnostmi, které tato knihovna
nabízí při analýze kódu. Bude se jednat například o <a href="#k04">zjištění
funkce</a>, jejíž parametry uživatel právě zapisuje, doplňování jmen metod,
nabídky všech metod platných v&nbsp;daném kontextu (v&nbsp;textových editorech
se tyto údaje typicky zobrazí po zápisu tečky, popř.&nbsp;tečky následované
prefixem jména metody) a taktéž si ukážeme příklad zdrojového kódu, který už
knihovna Jedi nedokáže korektně zpracovat. Ve druhé části dnešního článku si
ukážeme, jakým způsobem je tato knihovna propojena s&nbsp;programátorskými
textovými editory <a href="#k15">Atom</a> a taktéž <a href="#k17">Emacs</a>
přes vhodný plugin (zajímavé přitom je, že Jedi je využita hned v&nbsp;několika
pluginech určených pro Atom i Emacs).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Proč dát přednost knihovně Jedi před konkurenčními projekty?</h2>

<p><a
href="https://www.root.cz/clanky/knihovna-jedi-doplnovani-kodu-a-staticka-analyza-kodu-v-pythonu/">Minule</a>
jsme si ve druhé polovině článku <a
href="https://www.root.cz/clanky/knihovna-jedi-doplnovani-kodu-a-staticka-analyza-kodu-v-pythonu/#k15">popsali</a>
způsob použití knihovny <i>Jedi</i> společně s&nbsp;populárním textovým
editorem Vim. Dnes si kromě jiného řekneme, jakým způsobem je možné <i>Jedi</i>
<a href="#k15">integrovat do editoru Atom</a> a následně i způsob integrace se
<a href="#k17">slavným <del>operačním systémem</del> textovým editorem
Emacs</a>. Taktéž již víme, že existují i další rozhraní mezi knihovnou
<i>Jedi</i> a dalšími textovými editory či integrovanými vývojovými
prostředími. Například pro Visual Studio Code existuje Python Extension,
podobný plugin najdeme pro Eric IDE, Sublime text apod. Nesmíme zapomenout ani
na technologii <a
href="https://microsoft.github.io/language-server-protocol/">Language Server
Protocol</a>, která je v&nbsp;případě programovacího jazyka Python
implementována v&nbsp;projektu<a
href="https://github.com/palantir/python-language-server">Python Language
Server</a>.</p>

<p>Na tomto místě se čtenář může se zeptat, z&nbsp;jakého důvodu vlastně
vzniklo tolik rozhraní a projektů, které používají zrovna knihovnu Jedi a
nikoli jiný podobně koncipovaný nástroj. Existují dva hlavní důvody. První
z&nbsp;nich je ten, že knihovna Jedi dává při analýze zdrojových souborů
psaných v&nbsp;Pythonu poměrně dobré a přesné výsledky (i když ji můžeme
v&nbsp;některých případech zmást &ndash; viz jeden příklad uvedený níže). A
druhým důvodem je fakt, že se jedná o jednoduše nastavitelný a současně i
dostatečně &bdquo;lehkotonážní&ldquo; projekt, takže případná tvorba nového
pluginu pro nějaký textový editor je relativně jednoduchá (pokud můžu soukromě
a navíc trošku neférově porovnat, tak je to mnohem jednodušší, než například
provozovat Eclipse v&nbsp;režimu serveru).</p>

<p><div class="rs-tip-major">Poznámka: druhý důvod bude pravděpodobně stále
platit i ve chvíli, kdy se více rozšíří již zmíněný <i>LSP</i> (<i>Language
Server Protocol</i>), protože již dnes je knihovna Jedi součástí Python
Language Serveru, který LSP používá pro komunikaci s&nbsp;IDE a textovými
editory (popř.&nbsp;v&nbsp;případě potřeby i dalšími nástroji).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití metody <strong>follow_definition()</strong> pro přečtení podrobnějších informací a navrhovaném identifikátoru</h2>

<p>Dnešní první demonstrační příklad bude do určité míry shrnovat informace,
které jsme si řekli v&nbsp;úvodním článku. Budeme v&nbsp;něm analyzovat
následující (neúplný) skript, v&nbsp;němž je definována třída, funkce, lambda
funkce a dvě proměnné &ndash; všechny identifikátory přitom začínají na
&bdquo;an&ldquo;. Na posledním řádku testovacího skriptu je zapsán jen začátek
identifikátoru, taktéž &bdquo;an&ldquo;:</p>

<pre>
     1  
     2  class anumber:
     3      """Docstring for a class."""
     4      pass
     5  
     6  def anagrams(word):
     7      """Very primitive anagram generator."""
     8      if len(word) &lt; 2:
     9          return word
    10      else:
    11          tmp = []
    12          for i, letter in enumerate(word):
    13              for j in anagrams(word[:i]+word[i+1:]):
    14                  tmp.append(j+letter)
    15      return tmp
    16  
    17  ann = lambda x,y: x+y
    18  anybody=True
    19  answer="42"
    20  an
</pre>

<p>Při analýze skriptu umístíme pomyslný kurzor na řádek 20 a sloupec 2. To
zajistí následující kód:</p>

<pre>
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('an'), 'test.py')
</pre>

<p>Dále můžeme přes knihovnu Jedi zjistit všechny možné identifikátory, které
v&nbsp;kontextu řádku 20 začínají na &bdquo;an&ldquo;:</p>

<pre>
completions = script.completions()
</pre>

<p>Identifikátory, resp.&nbsp;přesněji řečeno jejich jména, si můžeme snadno
vypsat:</p>

<pre>
for completion in completions:
    print(completion.name)
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
anagrams
ann
answer
anumber
any
anybody
</pre>

<p>Kromě jmen identifikátorů můžeme také získat informace o jejich definici, a
to s&nbsp;využitím metody <strong>follow_definition()</strong> (tyto informace
ostatně uvidíme i v&nbsp;pluginem pro Atom a Emacs). Kód pro výpis se nám změní
následovně:</p>

<pre>
for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>

<p>Pomocná funkce <strong>print_definitions()</strong> vypíše typ objektu
(funkce, třída atd.), jeho plné jméno, jméno modulu, v&nbsp;němž je objekt
definovaný a konečně i řádek s&nbsp;definicí:</p>

<pre>
def print_definitions(definitions):
    if not definitions:
        print("not found")
        return
&nbsp;
    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
</pre>

<p>Po spuštění upraveného příkladu dostaneme následující výsledek. Povšimněte
si, že jméno modulu &bdquo;test.py&ldquo; odpovídá jménu předanému do
konstruktoru <strong>Script()</strong>; typicky toto jméno automaticky doplňuje
textový editor:</p>

<pre>
<strong>anagrams</strong>
----------------------------------------
function __main__.anagrams in test.py:6
anagrams(word)
&nbsp;
Very primitive anagram generator.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>ann</strong>
----------------------------------------
function __main__.&lt;lambda&gt; in test.py:17
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>answer</strong>
----------------------------------------
instance str in builtins.py:None
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>anumber</strong>
----------------------------------------
class __main__.anumber in test.py:2
Docstring for a class.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>any</strong>
----------------------------------------
function any in builtins.py:None
Return True if bool(x) is True for any x in the iterable.
&nbsp;
If the iterable is empty, return False.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>anybody</strong>
----------------------------------------
instance bool in builtins.py:None
</pre>

<p>Následuje výpis <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi11_follow_definitions.py">úplného
zdrojového kódu</a> dnešního prvního demonstračního příkladu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
class anumber:
    """Docstring for a class."""
    pass
&nbsp;
def anagrams(word):
    """Very primitive anagram generator."""
    if len(word) &lt; 2:
        return word
    else:
        tmp = []
        for i, letter in enumerate(word):
            for j in anagrams(word[:i]+word[i+1:]):
                tmp.append(j+letter)
    return tmp
&nbsp;
ann = lambda x,y: x+y
anybody=True
answer="42"
an'''
&nbsp;
&nbsp;
def print_definitions(definitions):
    if not definitions:
        print("not found")
        return
&nbsp;
    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('an'), 'test.py')
&nbsp;
completions = script.completions()
&nbsp;
for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Analýza volání funkce</h2>

<p>Knihovna Jedi obsahuje i další užitečnou vlastnost &ndash; ve chvíli, kdy se
kurzor nachází mezi kulatými závorkami za jménem volané funkce, dokáže zjistit
přesnější informace o této funkci; dokonce zjistí i pořadí právě zapisovaného
parametru. Totéž samozřejmě platí i pro volané metody. To například znamená, že
v&nbsp;případě tohoto kódu (kurzor je naznačen šipkou):</p>

<pre>
print(
      ^
</pre>

<p>by se vrátila informace o funkci <strong>print</strong>. Ukažme si tuto
užitečnou vlastnost na následujícím skriptu:</p>

<pre>
     1  
     2  def anagrams(word):
     3      """Very primitive anagram generator."""
     4      if len(word) &lt; 2:
     5          return word
     6      else:
     7          tmp = []
     8          for i, letter in enumerate(word):
     9              for j in anagrams(word[:i]+word[i+1:]):
    10                  tmp.append(j+letter)
    11      return tmp
    12  
    13  anagrams("pokus")
                  ^
</pre>

<p>Kurzor umístíme na místo šipky (řádek 13, sloupec 10):</p>

<pre>
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('anagrams('), 'test.py')
</pre>

<p>Po konstrukci objektu typu <strong>Script</strong> získáme seznam všech
funkcí, které v&nbsp;daném kontextu přichází do úvahy (vzhledem k&nbsp;dynamice
Pythonu nemusí být určení zcela jednoznačné). V&nbsp;našem případě se bude
jednat o jedinou funkci, ovšem v&nbsp;obecném případě se může jednat o více
záznamů:</p>

<pre>
call_signatures = script.call_signatures()
</pre>

<p>Získané signatury si následně v&nbsp;programové smyčce vypíšeme, konkrétně
především umístění otevírací závorky a index zadávaného parametru (to opět může
pomoci textovým editorům v&nbsp;orientaci ve zdrojovém kódu):</p>

<pre>
for call_signature in call_signatures:
    print(call_signatures.__str__(), call_signature.index, call_signature.bracket_start)
</pre>

<p>Výsledek vypsaný předchozí programovou smyčkou by měl vypadat
následovně:</p>

<pre>
[&lt;CallSignature: anagrams index 0&gt;] 0 (13, 8)
</pre>

<p>Tento výsledek je možné přečíst následovně: uživatel právě doplňuje
argumenty pro funkci <strong>anagrams</strong>, přičemž se jedná o první
argument (s&nbsp;indexem 0) a otevírací závorka byla nalezena na pozici [13,
8], tj.&nbsp;na třináctém řádku a sloupci 8.</p>

<p>Samozřejmě si opět ukážeme <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi12_call_signatures.py">celý
zdrojový kód tohoto příkladu</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def anagrams(word):
    """Very primitive anagram generator."""
    if len(word) &lt; 2:
        return word
    else:
        tmp = []
        for i, letter in enumerate(word):
            for j in anagrams(word[:i]+word[i+1:]):
                tmp.append(j+letter)
    return tmp
&nbsp;
anagrams("pokus")'''
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('anagrams('), 'test.py')
&nbsp;
call_signatures = script.call_signatures()
&nbsp;
for call_signature in call_signatures:
    print(call_signatures.__str__(), call_signature.index, call_signature.bracket_start)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Složitější příklad pro analýzu volaných funkcí</h2>

<p>Pro úplnost se podívejme na poněkud složitější příklad. Testovací skript od
řádku 11 obsahuje hned několik volaných funkcí, které mají různý počet
parametrů, otevírací levá kulatá závorka nemusí následovat hned na jménem
funkce a v&nbsp;posledním případu je dokonce otevírací závorka na zcela jiném
řádku, než první argument (i tento styl zápisu Python umožňuje, i když není
zcela přesně v&nbsp;souladu s&nbsp;PEP-8). Šipkami ^ jsou naznačena umístění
kurzoru, pro něž budeme žádat analýzu:</p>

<pre>
     1
     2  def foo():
     3      return 0
     4
     5  def bar(x):
     6      return 1
     7
     8  def baz(x,y):
     9      return 2
    10
    11  foo()
           ^
    12  bar(1)
            ^
    13  baz(1,2)
              ^
    14  baz(foo(), bar(1))
                       ^
    15  print(10, 20, 30, 40, 50)
                             ^
    16  print   (10, 20, 30, 40, 50)
                                ^
    17  print(
    18
    19  42)
        ^
</pre>

<p>Pro všech sedm umístění kurzoru by se měly vrátit následující údaje.
Povšimněte si, že místo zápisu levé otevírací závorky je vždy vypočteno
správně, a to i v&nbsp;poslední funkci (opět velká pomoc pro tvůrce pluginů) a
u funkce <strong>foo()</strong>, která nemá žádné parametry, se namísto indexu
zapisovaného argumentu objevila hodnota <strong>None</strong>:</p>

<pre>
[&lt;CallSignature: foo index None&gt;] None (11, 3)
&nbsp;
[&lt;CallSignature: bar index 0&gt;] 0 (12, 3)
&nbsp;
[&lt;CallSignature: baz index 1&gt;] 1 (13, 3)
&nbsp;
[&lt;CallSignature: bar index 0&gt;] 0 (14, 14)
&nbsp;
[&lt;CallSignature: print index 4&gt;] 4 (15, 5)
&nbsp;
[&lt;CallSignature: print index 4&gt;] 4 (16, 8)
&nbsp;
[&lt;CallSignature: print index 0&gt;] 0 (17, 5)
</pre>

<p>Jak již zajisté, očekáváte, opět si ukážeme <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi13_more_difficult_call_signatures.py">celý
zdrojový kód tohoto příkladu</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
def foo():
    return 0
&nbsp;
def bar(x):
    return 1
&nbsp;
def baz(x,y):
    return 2
&nbsp;
foo()
bar(1)
baz(1,2)
baz(foo(), bar(1))
print(10, 20, 30, 40, 50)
print   (10, 20, 30, 40, 50)
print(
&nbsp;
42)
'''
&nbsp;
&nbsp;
def print_call_signatures(script):
    call_signatures = script.call_signatures()
&nbsp;
    for call_signature in call_signatures:
        print(call_signatures.__str__(), call_signature.index, call_signature.bracket_start)

    print()
&nbsp;
&nbsp;
lines = src.count('\n')
&nbsp;
script = jedi.Script(src, 11, len('foo('), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, 12, len('bar(1'), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, 13, len('baz(1,2'), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, 14, len('baz(foo(), bar(1'), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, 15, len('print(10, 20, 30, 40, '), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, 16, len('print   (10, 20, 30, 40, '), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, lines, 1, 'test.py')
print_call_signatures(script)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Volání metod namísto obyčejných funkcí</h2>

<p>V&nbsp;dalším demonstračním příkladu, jehož zdrojový kód naleznete na <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi14_method_signatures.py">této
adrese</a> je ukázáno, že metoda <strong>Script.call_signatures()</strong> je
použitelná nejenom pro zjištění dalších informací o volaných funkcích, ale i
v&nbsp;případě, že jsou volány metody. Skript, na němž je tento příklad
vyzkoušen, je velmi jednoduchý (ve skriptu jsou opět naznačeny pozice
kurzorů):</p>

<pre>
     1
     2  class C1:
     3      def foo(self):
     4          return 0
     5
     6      def bar(self, x):
     7          return 1
     8
     9      def baz(self, x,y):
    10          return 2
    11
    12  obj = C1()
    13  obj.foo()
               ^
    14  obj.bar(1)
                ^
    15  obj.baz(1,2)
                  ^
    16  obj.baz(obj.foo(), obj.bar(1))
                                   ^
</pre>

<p>Výsledek analýzy volaných metod vypadá takto (v&nbsp;tomto případě se nijak
zvlášť nerozlišuje mezi voláním funkce a voláním metody):</p>

<pre>
[&lt;CallSignature: foo index None&gt;] None (13, 7)
&nbsp;
[&lt;CallSignature: bar index 0&gt;] 0 (14, 7)
&nbsp;
[&lt;CallSignature: baz index 1&gt;] 1 (15, 7)
&nbsp;
[&lt;CallSignature: bar index 0&gt;] 0 (16, 26)
</pre>

<p>A nakonec si opět ukažme zdrojový kód celého příkladu, který volá funkce a
metody knihovny <i>Jedi</i>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
class C1:
    def foo(self):
        return 0
&nbsp;
    def bar(self, x):
        return 1
&nbsp;
    def baz(self, x,y):
        return 2
&nbsp;
obj = C1()
obj.foo()
obj.bar(1)
obj.baz(1,2)
obj.baz(obj.foo(), obj.bar(1))'''
&nbsp;
&nbsp;
def print_call_signatures(script):
    call_signatures = script.call_signatures()
&nbsp;
    for call_signature in call_signatures:
        print(call_signatures.__str__(), call_signature.index, call_signature.bracket_start)
&nbsp;
    print()
&nbsp;
&nbsp;
lines = src.count('\n')
&nbsp;
script = jedi.Script(src, lines-2, len('obj.foo('), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, lines-1, len('obj.bar(1'), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, lines, len('obj.baz(1,2'), 'test.py')
print_call_signatures(script)
&nbsp;
script = jedi.Script(src, lines+1, len('obj.baz(obj.foo(), obj.bar(1'), 'test.py')
print_call_signatures(script)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Malé zopakování z&nbsp;minula &ndash; dynamické chování Pythonu a jeho vliv na funkci knihovny Jedi</h2>

<p>V&nbsp;této kapitole si jen pro připomenutí ukážeme, jakým způsobem se
projeví dynamické chování interpretru Pythonu na analýze kódu. V&nbsp;dalším
skriptu máme (kromě dalších věcí) deklarovanou i funkci
<strong>answer()</strong>, ovšem v&nbsp;průběhu statické analýzy kódu není
možné zjistit, která ze tří možných deklarací bude skutečně použita. Jedná se
samozřejmě o poněkud umělý příklad, ale někdy se s&nbsp;podobně koncipovaným
kódem můžete setkat:</p>

<pre>
     1
     2  class anumber:
     3      """Docstring for a class."""
     4      pass
     5
     6
     7  if random.random() &lt; 0.5:
     8      def answer():
     9          """1st variant of answer function."""
    10          return "42"
    11  elif random.random() &lt; 0.5:
    12      def answer():
    13          """2nd variant of answer function."""
    14          return 42
    15  else:
    16      def answer():
    17          """3rd variant of answer function."""
    18          return [42]
    19
    20
    21  def anagrams(word):
    22      """Very primitive anagram generator."""
    23      if len(word) &lt; 2:
    24          return word
    25      else:
    26          tmp = []
    27          for i, letter in enumerate(word):
    28              for j in anagrams(word[:i]+word[i+1:]):
    29                  tmp.append(j+letter)
    30      return tmp
    31
    32  ann = lambda x,y: x+y
    33  anybody=True
    34  print(answer())
</pre>

<p>Při zavolání metody <strong>Script.goto_definitions()</strong> na posledním
(patnáctém) řádku nemůže knihovna <i>Jedi</i> rozhodnout, o kterou funkci se
jedná a z&nbsp;tohoto důvodu vrátí všechny tři možné varianty, což je
pravděpodobně v&nbsp;tomto případě nejkorektnější chování:</p>

<pre>
function __main__.answer in test.py:8
function __main__.answer in test.py:12
function __main__.answer in test.py:16
</pre>

<p>Celý příklad, který zjistí informaci o volané funkci
<strong>answer()</strong>, vypadá následovně:</p>

<pre>
#!/usr/bin/env python3
# vim: set fileencoding=utf-8
&nbsp;
import jedi
&nbsp;
src = '''
class anumber:
    """Docstring for a class."""
    pass
&nbsp;
&nbsp;
if random.random() &lt; 0.5:
    def answer():
        """1st variant of answer function."""
        return "42"
elif random.random() &lt; 0.5:
    def answer():
        """2nd variant of answer function."""
        return 42
else:
    def answer():
        """3rd variant of answer function."""
        return [42]
&nbsp;
&nbsp;
def anagrams(word):
    """Very primitive anagram generator."""
    if len(word) &lt; 2:
        return word
    else:
        tmp = []
        for i, letter in enumerate(word):
            for j in anagrams(word[:i]+word[i+1:]):
                tmp.append(j+letter)
    return tmp
&nbsp;
ann = lambda x,y: x+y
anybody=True
print(answer())'''
&nbsp;
&nbsp;
def print_definitions(definitions):
    if not definitions:
        print("not found")
        return
&nbsp;
    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('print('), 'test.py')
&nbsp;
definitions = script.goto_definitions()
&nbsp;
print_definitions(definitions)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podrobnější informace o jménech funkcí v&nbsp;případě, že kód nelze staticky jednoznačně analyzovat</h2>

<p>Zajímavé je, že při návrhu jména funkce/metody/proměnné, které se má na
nějakém místě doplnit, pracuje knihovna <i>Jedi</i> poněkud odlišně.
Následující testovací skript je prakticky kompletně zkopírován ze skriptu
předchozího, jen s&nbsp;tím rozdílem, že na řádku číslo 34 budeme chtít vypsat
všechny identifikátory, které se mohou na tomto místě doplnit:</p>

<pre>
     1
     2  class anumber:
     3      """Docstring for a class."""
     4      pass
     5
     6
     7  if random.random() &lt; 0.5:
     8      def answer():
     9          """1st variant of answer function."""
    10          return "42"
    11  elif random.random() &lt; 0.5:
    12      def answer():
    13          """2nd variant of answer function."""
    14          return 42
    15  else:
    16      def answer():
    17          """3rd variant of answer function."""
    18          return [42]
    19
    20
    21  def anagrams(word):
    22      """Very primitive anagram generator."""
    23      if len(word) &lt; 2:
    24          return word
    25      else:
    26          tmp = []
    27          for i, letter in enumerate(word):
    28              for j in anagrams(word[:i]+word[i+1:]):
    29                  tmp.append(j+letter)
    30      return tmp
    31
    32  ann = lambda x,y: x+y
    33  anybody=True
    34  an
          ^
</pre>

<p>Podívejme se, jaké možnosti získáme &ndash; nyní se funkce
<strong>answer</strong> nabízí pouze jedenkrát, a to ve své poslední (třetí)
variantě, což není příliš intuitivní:</p>

<pre>
<strong>anagrams</strong>
----------------------------------------
function __main__.anagrams in test.py:21
anagrams(word)
&nbsp;
Very primitive anagram generator.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>ann</strong>
----------------------------------------
function __main__.<lambda> in test.py:32
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>answer</strong>
----------------------------------------
function __main__.answer in test.py:16
answer()
&nbsp;
3rd variant of answer function.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>anumber</strong>
----------------------------------------
class __main__.anumber in test.py:2
Docstring for a class.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>any</strong>
----------------------------------------
function any in builtins.py:None
Return True if bool(x) is True for any x in the iterable.
&nbsp;
If the iterable is empty, return False.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>anybody</strong>
----------------------------------------
instance bool in builtins.py:None
</pre>

<p>Předchozí výstup byl vytvořen tímto příkladem, který nejprve získá informace
o všech možnostech pro doplnění symbolu a posléze zobrazí i definici
příslušného symbolu a jeho dokumentační řetězec:</p>

<pre>
completions = script.completions()
&nbsp;
for completion in completions:
    print(completion.name)
    definitions = completion.follow_definition()
    print(completion.docstring())
    print("\n"*3)
</pre>

<p>Úplný zdrojový kód příkladu vypadá takto:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
class anumber:
    """Docstring for a class."""
    pass
&nbsp;
&nbsp;
if random.random() &lt; 0.5:
    def answer():
        """1st variant of answer function."""
        return "42"
elif random.random() &lt; 0.5:
    def answer():
        """2nd variant of answer function."""
        return 42
else:
    def answer():
        """3rd variant of answer function."""
        return [42]
&nbsp;
&nbsp;
def anagrams(word):
    """Very primitive anagram generator."""
    if len(word) &lt; 2:
        return word
    else:
        tmp = []
        for i, letter in enumerate(word):
            for j in anagrams(word[:i]+word[i+1:]):
                tmp.append(j+letter)
    return tmp
&nbsp;
ann = lambda x,y: x+y
anybody=True
an'''
&nbsp;
&nbsp;
def print_definitions(definitions):
    if not definitions:
        print("not found")
        return
&nbsp;
    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('an'), 'test.py')
&nbsp;
completions = script.completions()
&nbsp;
for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Doplnění jmen volaných metod</h2>

<p>V&nbsp;prakticky všech vyspělejších integrovaných vývojových prostředích se
uživatel setká i s&nbsp;automatickým doplněním jména volané metody
popř.&nbsp;s&nbsp;nabídkou seznamu metod, které je možné v&nbsp;daném místě
kódu doplnit. Knihovna <i>Jedi</i> tuto funkci samozřejmě podporuje, takže si
v&nbsp;navazujících dvou kapitolách ukážeme způsob získání všech metod nějakého
objektu (typicky po zápisu tečky v&nbsp;programátorském editoru či v&nbsp;IDE)
a taktéž těch metod, jejichž jméno začíná na nějaký prefix. Obě funkce jsou
vlastně implementovány naprosto stejným kódem &ndash; jediným rozdílem je fakt,
že po tečce lze zapsat jakoukoli metodu, zatímco zapsáním prefixu se seznam
možných metod (které dávají v&nbsp;daném kontextu význam) zmenšuje.</p>

<a href="https://www.root.cz/obrazek/337205/"><img src="https://i.iinfo.cz/images/420/jedi2-1-prev.png" class="image-337205" alt="&#160;" width="337" height="270" /></a>
<p><i>Obrázek 1: Nabídka dostupných metod ve vývojovém prostředí Eclipse
(zdrojový kód je psán v&nbsp;Javě).</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výpis všech metod objektu</h2>

<p>Nejprve si ukažme způsob výpisu všech metod objektu. V&nbsp;následujícím
testovacím skriptu si povšimněte, že kurzor bude umístěn na tečku oddělující
jméno objektu od (nějaké) metody, takže na tomto místě je skutečně možné
zavolat libovolnou metodu pro daný objekt:</p>

<pre>
class <strong>C1</strong>:
    def <strong>foo</strong>(self):
        """Function foo defined in class C1."""
        return 1
&nbsp;
class <strong>C2</strong>:
    def <strong>foo</strong>(self):
        """Function foo defined in class C2."""
        return 2
&nbsp;
class <strong>C3</strong>:
    def <strong>foo</strong>(self):
        """Function foo defined in class C3."""
        return 2
&nbsp;
obj = C2()
obj.'''
   ^
</pre>

<p>Výsledkem bude sáhodlouhá zpráva o všech dostupných metodách. Pro větší
přehlednost jsou názvy metod zvýrazněny:</p>

<pre>
<strong>foo</strong>
----------------------------------------
function __main__.foo in test.py:8
foo(self)
&nbsp;
Function foo defined in class C2.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__class__</strong>
----------------------------------------
class object.type in builtins.py:None
type(object_or_name, bases, dict)
type(object) -&gt; the object's type
type(name, bases, dict) -&gt; a new type
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__delattr__</strong>
----------------------------------------
function object.__delattr__ in builtins.py:None
Implement delattr(self, name).
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__dir__</strong>
----------------------------------------
function object.__dir__ in builtins.py:None
__dir__() -&gt; list
default dir() implementation
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__doc__</strong>
----------------------------------------
instance object.str in builtins.py:None
str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str
&nbsp;
Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__eq__</strong>
----------------------------------------
function object.__eq__ in builtins.py:None
Return self==value.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__format__</strong>
----------------------------------------
function object.__format__ in builtins.py:None
default object formatter
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__ge__</strong>
----------------------------------------
function object.__ge__ in builtins.py:None
Return self&gt;=value.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__getattribute__</strong>
----------------------------------------
function object.__getattribute__ in builtins.py:None
Return getattr(self, name).
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__gt__</strong>
----------------------------------------
function object.__gt__ in builtins.py:None
Return self&gt;value.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__hash__</strong>
----------------------------------------
function object.__hash__ in builtins.py:None
Return hash(self).
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__init__</strong>
----------------------------------------
function object.__init__ in builtins.py:None
Initialize self.  See help(type(self)) for accurate signature.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__init_subclass__</strong>
----------------------------------------
function object.__init_subclass__ in builtins.py:None
This method is called when a class is subclassed.
&nbsp;
The default implementation does nothing. It may be
overridden to extend subclasses.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__le__</strong>
----------------------------------------
function object.__le__ in builtins.py:None
Return self&lt;=value.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__lt__</strong>
----------------------------------------
function object.__lt__ in builtins.py:None
Return self&lt;value.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__ne__</strong>
----------------------------------------
function object.__ne__ in builtins.py:None
Return self!=value.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__new__</strong>
----------------------------------------
function object.__new__ in builtins.py:None
Create and return a new object.  See help(type) for accurate signature.
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__reduce__</strong>
----------------------------------------
function object.__reduce__ in builtins.py:None
helper for pickle
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__reduce_ex__</strong>
----------------------------------------
function object.__reduce_ex__ in builtins.py:None
helper for pickle
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__repr__</strong>
----------------------------------------
function object.__repr__ in builtins.py:None
Return repr(self).
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__setattr__</strong>
----------------------------------------
function object.__setattr__ in builtins.py:None
Implement setattr(self, name, value).
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__sizeof__</strong>
----------------------------------------
function object.__sizeof__ in builtins.py:None
__sizeof__() -&gt; int
size of object in memory, in bytes
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__str__</strong>
----------------------------------------
function object.__str__ in builtins.py:None
Return str(self).
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<strong>__subclasshook__</strong>
----------------------------------------
function object.__subclasshook__ in builtins.py:None
Abstract classes can override this to customize issubclass().
&nbsp;
This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).
&nbsp;
&nbsp;
&nbsp;
&nbsp;
</pre>

<p>Tento výsledek lze snadno získat <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi18_all_methods_completion_and_definition.py">programem</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
class C1:
    def foo(self):
        """Function foo defined in class C1."""
        return 1
&nbsp;
class C2:
    def foo(self):
        """Function foo defined in class C2."""
        return 2
&nbsp;
class C3:
    def foo(self):
        """Function foo defined in class C3."""
        return 2
&nbsp;
obj = C2()
obj.'''
&nbsp;
&nbsp;
def print_definitions(definitions):
    if not definitions:
        print("not found")
        return
&nbsp;
    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('obj.'), 'test.py')
&nbsp;
completions = script.completions()
&nbsp;
for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výpis metod začínajících na uvedený prefix</h2>

<p>Jen nepatrnou úpravou předchozího programu získáme seznam všech metod, které
začínají na zadaný prefix. Změní se v&nbsp;podstatě jen dvě věci. Samotný
testovaný skript:</p>

<pre>
class <strong>C1</strong>:
    def <strong>foo</strong>(self):
        """Function foo defined in class C1."""
        return 1
&nbsp;
class <strong>C2</strong>:
    def <strong>foo</strong>(self):
        """Function foo defined in class C2."""
        return 2
&nbsp;
class <strong>C3</strong>:
    def <strong>foo</strong>(self):
        """Function foo defined in class C3."""
        return 2
&nbsp;
obj = C2()
obj.fo'''
    ^
</pre>

<p>A v&nbsp;následujícím řádku posuneme pomyslný kurzor o dva znaky
doprava:</p>

<pre>
script = jedi.Script(src, lines+1, len('obj.fo'), 'test.py')
</pre>

<p>Výsledkem bude seznam obsahující jen jedinou metodu, a to konkrétně naši
metodu <strong>C2.foo()</strong>:</p>

<pre>
<strong>foo</strong>
----------------------------------------
function __main__.foo in test.py:8
foo(self)
&nbsp;
Function foo defined in class C2.
</pre>

<p>Pro úplnost si <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi17_method_completion_and_definition.py">ukažme
celý příklad</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
class C1:
    def foo(self):
        """Function foo defined in class C1."""
        return 1
&nbsp;
class C2:
    def foo(self):
        """Function foo defined in class C2."""
        return 2
&nbsp;
class C3:
    def foo(self):
        """Function foo defined in class C3."""
        return 2
&nbsp;
obj = C2()
obj.fo'''
&nbsp;
&nbsp;
def print_definitions(definitions):
    if not definitions:
        print("not found")
        return
&nbsp;
    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('obj.fo'), 'test.py')
&nbsp;
completions = script.completions()
&nbsp;
for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Některé chyby, které v&nbsp;knihovně Jedi existují</h2>

<p>Knihovna <i>Jedi</i> pochopitelně není zcela bezchybná, takže se můžeme
&ndash; i když ne příliš často &ndash; setkat s&nbsp;nápovědou nebo analýzou
kódu, která nebude odpovídat běžnému chování interpretru Pythonu. Jedna
z&nbsp;těchto chyb je naznačena v&nbsp;dalším příkladu. Nejprve se podívejme na
testovací skript. Jsou v&nbsp;něm deklarovány tři třídy <strong>C1</strong>,
<strong>C2</strong> a <strong>C3</strong>, přičemž v&nbsp;každé z&nbsp;těchto
tříd je vytvořena metoda nazvaná <strong>foo()</strong>. Tuto část Jedi
samozřejmě bez problémů zpracuje. Ovšem ve druhé polovině skriptu máme
programovou konstrukci <strong>if-elseif-else</strong>, v&nbsp;níž se přiřazuje
hodnota k&nbsp;nově vytvářené proměnné <strong>obj</strong>. Na samotném konci
skriptu pak budeme chtít doplnit jméno metody a současně si i zobrazit to místo
v&nbsp;programovém kódu, v&nbsp;němž je metoda deklarována:</p>

<pre>
     1
     2  class C1:
     3      def foo(self):
     4          """Function foo defined in class C1."""
     5          return 1
     6
     7  class C2:
     8      def foo(self):
     9          """Function foo defined in class C2."""
    10          return 2
    11
    12  class C3:
    13      def foo(self):
    14          """Function foo defined in class C3."""
    15          return 2
    16
    17  if True:
    18      obj = C1()
    19  elif True:
    20      obj = C2()
    21  else:
    22      obj = C3()
    23  obj.fo
             ^
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Chování Jedi vs.&nbsp;chování interpretru Pythonu</h2>

<p>Pokud se skript ukázaný <a href="#k13">v&nbsp;předchozí kapitole</a>
pokusíme analyzovat knihovnou <i>Jedi</i>, dostaneme informaci o tom, že se na
řádku 23 má doplnit jméno metody <strong>foo</strong> (což je zcela správně),
ovšem následuje další informace o tom, že tato metoda je deklarována ve třídě
<strong>C2</strong>:</p>

<pre>
<strong>foo</strong>
----------------------------------------
function __main__.foo in <strong>test.py:8</strong>
foo(self)
&nbsp;
Function <strong>foo</strong> defined in class <strong>C2</strong>.
</pre>

<p>Můžeme si samozřejmě ukázat chování interpretru Pythonu, které plně odpovídá
očekávání &ndash; ve skutečnosti se do <strong>obj</strong> přiřadí instance
třídy <strong>C1</strong> a tudíž se o několik řádků níže zavolá metoda
<strong>C1.foo()</strong>:</p>

<pre>
class <strong>C1</strong>:
    def <strong>foo</strong>(self):
        """Function foo defined in class C1."""
        return 1
&nbsp;
class <strong>C2</strong>:
    def <strong>foo</strong>(self):
        """Function foo defined in class C2."""
        return 2
&nbsp;
class <strong>C3</strong>:
    def <strong>foo</strong>(self):
        """Function foo defined in class C3."""
        return 2
&nbsp;
if True:
    obj = C1()
elif True:
    obj = C2()
else:
    obj = C3()
&nbsp;
print(obj)
print(obj.foo())
</pre>

<p>Po spuštění dostaneme korektní informaci o třídě <strong>C1</strong> a její
metodě <strong>C1.foo()</strong>:</p>

<pre>
&lt;__main__.C1 object at 0x7fe665617278&gt;
1
</pre>

<p>Analýza ukázaná na začátku této kapitoly byla vytvořena programem <a
href="https://github.com/tisnik/presentations/blob/master/jedi/jedi18_howto_confuse_jedi.py">jedi18_howto_confuse_jedi.py</a>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import jedi
&nbsp;
src = '''
class C1:
    def foo(self):
        """Function foo defined in class C1."""
        return 1
&nbsp;
class C2:
    def foo(self):
        """Function foo defined in class C2."""
        return 2
&nbsp;
class C3:
    def foo(self):
        """Function foo defined in class C3."""
        return 2
&nbsp;
if True:
    obj = C1()
elif True:
    obj = C2()
else:
    obj = C3()
obj.fo'''
&nbsp;
&nbsp;
def print_definitions(definitions):
    if not definitions:
        print("not found")
        return
&nbsp;
    for definition in definitions:
        print("{type} {name} in {module}.py:{line}".format(type=definition.type,
                                                           name=definition.full_name,
                                                           module=definition.module_name,
                                                           line=definition.line))
&nbsp;
&nbsp;
lines = src.count('\n')
script = jedi.Script(src, lines+1, len('obj.fo'), 'test.py')
&nbsp;
completions = script.completions()
&nbsp;
for completion in completions:
    print(completion.name)
    print("-"*40)
    definitions = completion.follow_definition()
    print_definitions(definitions)
    print(completion.docstring())
    print("\n"*3)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Další pluginy integrující knihovnu Jedi do programátorských textových editorů</h2>

<p>Ve druhé části článku si ukážeme, jakým způsobem je vyřešena integrace
knihovny <i>Jedi</i> s&nbsp;dalšími programátorskými textovými editory. Minule
jsme si ukázali integraci s&nbsp;Vimem, a to konkrétně s&nbsp;využitím pluginu
nazvaného <strong>jedi-vim</strong>. Dnes se zaměříme na <a
href="https://www.root.cz/clanky/atom-moderni-textovy-editor/">textový editor
Atom</a> a samozřejmě také na <a
href="https://www.root.cz/serialy/emacs-pro-mirne-pokrocile/">Emacs</a>
(důvody, proč je Jedi použit v&nbsp;mnoha pluginech, byly napsány <a
href="#k02">ve druhé kapitole</a>).</p>

<a href="https://www.root.cz/obrazek/337025/"><img src="https://i.iinfo.cz/images/179/jedi1-4-prev.png" class="image-337025" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 2: Nápověda k&nbsp;minule popsanému pluginu
<strong>jedi-vim</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě Atomu se budeme zabývat
skutečně &bdquo;pouze&ldquo; samotným textovým editorem a jeho pluginy; nebude
se tedy jednat o popis <a href="https://ide.atom.io/">Atom IDE</a>, protože
popis možností Atom IDE by si vyžádal samostatný článek.</div></p>

<a href="https://www.root.cz/obrazek/337032/"><img src="https://i.iinfo.cz/images/179/jedi1-11-prev.png" class="image-337032" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 3: Zobrazení dokumentačního řetězce pro identifikátor, nad nímž
se nachází kurzor. Tato funkce je dostupná po stisku klávesové zkratky
<strong>K</strong>.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Použití knihovny Jedi v&nbsp;textovém editoru Atom</h2>

<p>Před popisem možností integrace knihovny Jedi s&nbsp;Atomem si pro úplnost
řekněme, jak se Atom nainstaluje. V&nbsp;případě, že balíčky s&nbsp;Atomem
nemáte přímo v&nbsp;repositáři vaší distribuce (popř.&nbsp;když tyto balíčky
zastaraly), můžete si přímo ze stránek <a
href="https://atom.io/">https://atom.io/</a> příslušný balíček stáhnout a
následně si ho i nainstalovat:</p>

<p>Stažení balíčku pro distribuce založené na RPM:</p>

<pre>
$ <strong>wget -o atom.rpm https://atom.io/download/rpm</strong>
</pre>

<p>Stažení balíčku pro distribuce založené na Debianních balíčcích:</p>

<pre>
$ <strong>wget -o atom.deb https://atom.io/download/deb</strong>
</pre>

<p>Ve chvíli, kdy máme stažený soubor <strong>atom.rpm</strong> (má velikost
přibližně 132 MB!), můžeme přistoupit k&nbsp;vlastní instalaci. Ta je pro
distribuce založené na RPM velmi jednoduchá:</p>

<pre>
# <strong>dnf install atom.rpm</strong>
&nbsp;
Last metadata expiration check: 1:09:13 ago on Tue 21 Aug 2018 10:00:34 AM EDT.
Dependencies resolved.
================================================================================
 Package          Arch      Version           Repository                   Size
================================================================================
Installing:
 atom             x86_64    1.29.0-0.1        @commandline                131 M
Installing dependencies:
 libXScrnSaver    x86_64    1.2.2-14.fc28     Fedora-Everything            29 k
&nbsp;
Transaction Summary
================================================================================
Install  2 Packages
&nbsp;
Total size: 131 M
Total download size: 29 k
Installed size: 523 M
Is this ok [y/N]:
</pre>

<p>Další průběh instalace:</p>

<pre>
Downloading Packages:
libXScrnSaver-1.2.2-14.fc28.x86_64.rpm          1.1 MB/s |  29 kB     00:00    
--------------------------------------------------------------------------------
Total                                           1.0 MB/s |  29 kB     00:00     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : libXScrnSaver-1.2.2-14.fc28.x86_64                     1/2 
  Running scriptlet: libXScrnSaver-1.2.2-14.fc28.x86_64                     1/2 
  Installing       : atom-1.29.0-0.1.x86_64                                 2/2 
  Running scriptlet: atom-1.29.0-0.1.x86_64                                 2/2 
  Verifying        : atom-1.29.0-0.1.x86_64                                 1/2 
  Verifying        : libXScrnSaver-1.2.2-14.fc28.x86_64                     2/2 
&nbsp;
Installed:
  atom.x86_64 1.29.0-0.1           libXScrnSaver.x86_64 1.2.2-14.fc28          
&nbsp;
Complete!
</pre>

<p>Po instalaci si již můžete (jako běžný uživatel, ne Root), textový editor
Atom spustit jednoduše:</p>

<pre>
$ <strong>atom</strong>
</pre>

<p>Dále je nutné nainstalovat plugin nazvaný
<strong>autocomplete-python-jedi</strong>:</p>

<a href="https://www.root.cz/obrazek/337206/"><img src="https://i.iinfo.cz/images/420/jedi2-2-prev.png" class="image-337206" alt="&#160;" width="370" height="266" /></a>
<p><i>Obrázek 4: V&nbsp;okně &bdquo;Install Packages&ldquo; vyhledáme všechny
(nové) pluginy, v&nbsp;jejichž jméně se nachází řetězec
&bdquo;Jedi&ldquo;.</i></p>

<a href="https://www.root.cz/obrazek/337207/"><img src="https://i.iinfo.cz/images/420/jedi2-3-prev.png" class="image-337207" alt="&#160;" width="370" height="266" /></a>
<p><i>Obrázek 5: Vybereme balíček pojmenovaný
&bdquo;autocomplete-python-jedi&ldquo;.</i></p>

<a href="https://www.root.cz/obrazek/337208/"><img src="https://i.iinfo.cz/images/420/jedi2-4-prev.png" class="image-337208" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 6: Po nainstalování se přesvědčíme, že balíček není zakázán
(disabled). Žádné možnosti nastavení vlastně ani nejsou
k&nbsp;dispozici.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Ukázky volání funkcí Jedi z&nbsp;Atomu při editaci zdrojových kódů napsaných v&nbsp;Pythonu</h2>

<p>Po úspěšné instalaci pluginu &bdquo;autocomplete-python-jedi&ldquo; si
můžeme vyzkoušet, jaké nové funkce jsou v&nbsp;Atomu dostupné. Opět se
podívejme na screenshoty s&nbsp;krátkým popisem:</p>

<a href="https://www.root.cz/obrazek/337209/"><img src="https://i.iinfo.cz/images/420/jedi2-5-prev.png" class="image-337209" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 7: Nápověda (přesněji řečeno dokumentační řetězec) k&nbsp;právě
zadávané funkci nebo metodě se zobrazí automaticky (po nepatrné časové
prodlevě).</i></p>

<a href="https://www.root.cz/obrazek/337210/"><img src="https://i.iinfo.cz/images/420/jedi2-6-prev.png" class="image-337210" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 8: Zobrazení seznamu funkcí/metod/proměnných obsahujících buď
přímo zadaný prefix, nebo (což je potenciálně velmi užitečné) sekvenci zadaných
znaků kdekoli v&nbsp;názvu. Na prvním místě jsou samozřejmě zobrazeny ty
identifikátory, které začínají prefixem. Výchozí klávesová zkratka je
<strong>Ctrl+Space</strong>. Podobným způsobem se zobrazí metody objektu
apod.</i></p>

<a href="https://www.root.cz/obrazek/337211/"><img src="https://i.iinfo.cz/images/420/jedi2-7-prev.png" class="image-337211" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 9: Kurzor se nachází na volání funkce.</i></p>

<a href="https://www.root.cz/obrazek/337212/"><img src="https://i.iinfo.cz/images/420/jedi2-8-prev.png" class="image-337212" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 10: A po stisku poněkud kostrbaté klávesové zkratky
<strong>Ctrl+Alt+G</strong> se provedl skok na její definici.</i></p>

<a href="https://www.root.cz/obrazek/337213/"><img src="https://i.iinfo.cz/images/420/jedi2-9-prev.png" class="image-337213" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 11: Zobrazení všech výskytů nějaké objektu (funkce, metody,
proměnné).</i></p>

<a href="https://www.root.cz/obrazek/337214/"><img src="https://i.iinfo.cz/images/420/jedi2-10-prev.png" class="image-337214" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 12: Pokud si navíc nainstalujete plugin nazvaný
&bdquo;Hyperclick&ldquo;, bude možné namísto <strong>Ctrl+Alt+G</strong> použít
zkratku <strong>Ctrl+klik myší</strong> (což ovšem koliduje s&nbsp;přidáním
multikurzoru, takže se tato zkratka musela přesunout).</i></p>

<a href="https://www.root.cz/obrazek/337215/"><img src="https://i.iinfo.cz/images/420/jedi2-11-prev.png" class="image-337215" alt="&#160;" width="370" height="258" /></a>
<p><i>Obrázek 13: Použití kombinace pluginů &bdquo;Hyperclick&ldquo; a
&bdquo;autocomplete-python-jedi&ldquo;.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Použití knihovny Jedi společně s&nbsp;Emacsem</h2>

<p>V&nbsp;článcích, v&nbsp;nichž se zmiňujeme o programátorských textových
editorech, samozřejmě není možné nezmínit slavný Emacs, který za sebou má <a
href="https://www.root.cz/clanky/historie-vyvoje-textovych-editoru-eine-zwei-emacs/">dosti
dlouhou historii</a>, v&nbsp;jejímž průběhu vzniklo jeho několik forků. Pro
Emacs existuje hned několik pluginů volajících knihovnu <i>Jedi</i>; my si dnes
popíšeme plugin pojmenovaný jednoduše <strong>jedi</strong>. Existuje několik
způsobů instalace tohoto pluginu. Nejjednodušší je instalace ve chvíli, kdy
máte v&nbsp;Emacsu povolen repositář balíčků <a
href="https://melpa.org/">MELPA</a> (ten obsahuje přibližně 3900 balíčků!). Po
zadání příkazu:</p>

<pre>
Alt-X list-packages
</pre>

<p>je možné zjistit, jestli je MELPA povolena a zda je tedy balíček
<strong>jedi</strong> přímo k&nbsp;dispozici:</p>

<img src="https://i.iinfo.cz/images/420/jedi2-12.png" class="image-337216" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 14: V&nbsp;případě, že MELPA není povolena, budou dostupné jen
balíčky z&nbsp;repositáře ELPA (Emacs Lisp Package Archive).</i></p>

<p>Pokud tomu tak není, je nutné MELPu povolit, například těmito řádky
přidanými do souboru <strong>.emacs</strong>:</p>

<pre>
<strong>(require 'package)</strong>
<strong>(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)</strong>
</pre>

<p>Po opětovném načtení editoru zkuste znovu zadat příkaz:</p>

<pre>
Alt-X list-packages
</pre>

<p>Tentokrát by se měl objevit mj.&nbsp;i balíček nazvaný <strong>jedi</strong>
(pozor na to, že prvotní načtení všech 3900 balíčků může chvíli trvat):</p>

<img src="https://i.iinfo.cz/images/420/jedi2-13.png" class="image-337217" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 15: V&nbsp;případě, že MELPA je povolena, měl by se
v&nbsp;seznamu balíčků objevit i plugin <strong>jedi</strong>.</i></p>

<p>Plugin <strong>jedi</strong> nainstalujeme běžným způsobem:</p>

<img src="https://i.iinfo.cz/images/420/jedi2-14.png" class="image-337218" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 16: Instalace pluginu <strong>jedi</strong>.</i></p>

<p>Následně přidáme další dva řádky do souboru <strong>.emacs</strong>:</p>

<pre>
<strong>(add-hook 'python-mode-hook 'jedi:setup)</strong>
<strong>(setq jedi:complete-on-dot t)</strong>
</pre>

<p>Takže jeho výsledný obsah <i>může</i> vypadat přibližně takto:</p>

<pre>
<strong>(require 'package)</strong>
<strong>(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)</strong>
&nbsp;
;; Added by Package.el.  This must come before configurations of
;; installed packages.  Don't delete this line.  If you don't want it,
;; just comment it out by adding a semicolon to the start of the line.
;; You may delete these explanatory comments.
(package-initialize)
&nbsp;
<strong>(add-hook 'python-mode-hook 'jedi:setup)</strong>
<strong>(setq jedi:complete-on-dot t)</strong>
&nbsp;
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(inhibit-startup-screen t)
 '(package-selected-packages (quote (jedi diffview ##))))
&nbsp;
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Ukázky volání funkcí Jedi z&nbsp;Emacsu při editaci zdrojových kódů napsaných v&nbsp;Pythonu</h2>

<p>Po načtení souboru s&nbsp;koncovkou &bdquo;.py&ldquo; se Emacs přepne do
režimu Pythonu a současně by se na pozadí měla spustit knihovna Jedi ve
vlastním virtuálním prostředí (<i>virtualenv</i>). Ta umožní například
následující operace připomínající skutečné IDE:</p>

<img src="https://i.iinfo.cz/images/420/jedi2-15.png" class="image-337219" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 17: Zobrazení seznamu objektů (funkcí, metod atd.) začínajících
daným prefixem. U vybraného objektu se zobrazí jeho nápověda (dokumentační
řetězec).</i></p>

<img src="https://i.iinfo.cz/images/420/jedi2-16.png" class="image-337220" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 18: Zúžení výběru po zadání delšího prefixu.</i></p>

<img src="https://i.iinfo.cz/images/420/jedi2-17.png" class="image-337221" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 19: Zobrazení všech metod objektu.</i></p>

<img src="https://i.iinfo.cz/images/420/jedi2-18.png" class="image-337222" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 20: Zde si povšimněte, že se zobrazí námi zapsaný dokumentační
řetězec (Jedi má přístup k&nbsp;editovanému souboru).</i></p>

<img src="https://i.iinfo.cz/images/420/jedi2-19.png" class="image-337223" alt="&#160;" width="754" height="741" />
<p><i>Obrázek 21: Zápis prefixu jména třídy, opět se zobrazením dokumentačního
řetězce.</i></p>

<p><div class="rs-tip-major">Poznámka: některé další možnosti kombinace Emacsu
a Jedi budou popsány v&nbsp;miniseriálu o Emacsu ve funkci IDE.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady ukazující některé možnosti
knihovny <i>Jedi</i> byly uloženy do Git repositáře, který je dostupný na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již poměrně rozsáhlý) repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>1</td><td>jedi11_follow_definitions.py</td><td>použití metody <strong>follow_definition()</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi11_follow_definitions.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi11_follow_definitions.py</a></td></tr>
<tr><td>2</td><td>jedi12_call_signatures.py</td><td>použití metody <strong>Script.call_signatures()</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi12_call_signatures.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi12_call_signatures.py</a></td></tr>
<tr><td>3</td><td>jedi13_more_difficult_call_signatures.py</td><td>použití metody <strong>Script.call_signatures()</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi13_more_difficult_call_signatures.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi13_more_difficult_call_signatures.py</a></td></tr>
<tr><td>4</td><td>jedi14_method_signatures.py</td><td>signatury volaných metod (ne funkcí)</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi14_method_signatures.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi14_method_signatures.py</a></td></tr>
<tr><td>5</td><td>jedi15_goto_definitions_random_function_declaration.py</td><td>dynamické chování Pythonu ovlivňující chování Jedi</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi15_goto_definitions_random_function_declaration.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi15_goto_definitions_random_function_declaration.py</a></td></tr>
<tr><td>6</td><td>jedi16_completion_follow_definition.py</td><td>dtto jako předchozí příklad, ovšem pro <strong>follow_definition()</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi16_completion_follow_definition.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi16_completion_follow_definition.py</a></td></tr>
<tr><td>7</td><td>jedi17_method_completion_and_definition.py</td><td>korektní doplnění jména metody</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi17_method_completion_and_definition.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi17_method_completion_and_definition.py</a></td></tr>
<tr><td>8</td><td>jedi18_all_methods_completion_and_definition.py</td><td>korektní doplnění jména metody</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi18_all_methods_completion_and_definition.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi18_all_methods_completion_and_definition.py</a></td></tr>
<tr><td>9</td><td>jedi19_howto_confuse_jedi.py</td><td>ukázka jednoduchého zmatení Jedi</td><td><a href="https://github.com/tisnik/presentations/blob/master/jedi/jedi18_howto_confuse_jedi.py">https://github.com/tisnik/presentations/blob/master/jedi/jedi18_howto_confuse_jedi.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Jedi - an awesome autocompletion/static analysis library for Python<br />
<a href="https://jedi.readthedocs.io/en/latest/index.html">https://jedi.readthedocs.io/en/latest/index.html</a>
</li>

<li>Jedi API Overview<br />
<a href="https://jedi.readthedocs.io/en/latest/docs/api.html">https://jedi.readthedocs.io/en/latest/docs/api.html</a>
</li>

<li>jedi-vim<br />
<a href="https://github.com/davidhalter/jedi-vim">https://github.com/davidhalter/jedi-vim</a>
</li>

<li>YouCompleteMe: A code-completion engine for Vim<br />
<a href="https://valloric.github.io/YouCompleteMe/">https://valloric.github.io/YouCompleteMe/</a>
</li>

<li>Elpy: Emacs Python Development Environment<br />
<a href="https://github.com/jorgenschaefer/elpy">https://github.com/jorgenschaefer/elpy</a>
</li>

<li>Emacs-Jedi<br />
<a href="https://github.com/tkf/emacs-jedi">https://github.com/tkf/emacs-jedi</a>
</li>

<li>Python Autocomplete Jedi Package<br />
<a href="https://atom.io/packages/autocomplete-python-jedi">https://atom.io/packages/autocomplete-python-jedi</a>
</li>

<li>Autocomplete (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Autocomplete">https://en.wikipedia.org/wiki/Autocomplete</a>
</li>

<li>Seriál Textový editor Vim jako IDE (zde na Root.cz)<br />
<a href="https://www.root.cz/serialy/textovy-editor-vim-jako-ide/">https://www.root.cz/serialy/textovy-editor-vim-jako-ide/</a>
</li>

<li>Jedi: A completion library for Python<br />
<a href="https://www.masteringemacs.org/article/jedi-completion-library-python">https://www.masteringemacs.org/article/jedi-completion-library-python</a>
</li>

<li>Jedi.el - Python auto-completion for Emacs (GitHub)<br />
<a href="https://github.com/tkf/emacs-jedi">https://github.com/tkf/emacs-jedi</a>
</li>

<li>Jedi.el - Python auto-completion for Emacs (dokumentace, popis možností apod.)<br />
<a href="http://tkf.github.io/emacs-jedi/latest/">http://tkf.github.io/emacs-jedi/latest/</a>
</li>

<li>Vim - the ubiquitous text editor<br />
<a href="https://www.vim.org/">https://www.vim.org/</a>
</li>

<li>GNU Emacs<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>EmacsWiki<br />
<a href="https://www.emacswiki.org/emacs/EmacsWiki">https://www.emacswiki.org/emacs/EmacsWiki</a>
</li>

<li>Atom (stránka textového editoru)<br />
<a href="https://atom.io/">https://atom.io/</a>
</li>

<li>el-get (GitHub)<br />
<a href="https://github.com/dimitri/el-get">https://github.com/dimitri/el-get</a>
</li>

<li>MELPA<br />
<a href="https://www.emacswiki.org/emacs/MELPA">https://www.emacswiki.org/emacs/MELPA</a>
</li>

<li>Atom IDE<br />
<a href="https://ide.atom.io/">https://ide.atom.io/</a>
</li>

<li>Sublime Text as Python IDE - jedi<br />
<a href="https://screamingatmyscreen.com/2013/9/sublime-text-as-python-ide-jedi/">https://screamingatmyscreen.com/2013/9/sublime-text-as-python-ide-jedi/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

