<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé a současně i předposlední části článku o knihovně Behave integrující jazyk Gherkin s Pythonem si popíšeme některé další možnosti, které Gherkin programátorům a testerům nabízí. Jedná se především o možnost deklarace dat s využitím tabulek.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Behavior-driven development v&nbsp;Pythonu s&nbsp;využitím knihovny Behave (druhá část)</a></p>
<p><a href="#k02">2. Využití dat zapsaných do tabulek</a></p>
<p><a href="#k03">3. Zápis dat ve formě tabulky do testovacího scénáře</a></p>
<p><a href="#k04">4. Načtení dat z&nbsp;tabulky</a></p>
<p><a href="#k05">5. Výsledek běhu prvního demonstračního příkladu</a></p>
<p><a href="#k06">6. Výsledek běhu příkladu ve chvíli, kdy je výpočet nekorektní</a></p>
<p><a href="#k07">7. Druhý demonstrační příklad &ndash; konverze měn (směnné kurzy)</a></p>
<p><a href="#k08">8. Implementace jednotlivých kroků testu</a></p>
<p><a href="#k09">9. Výsledek běhu druhého demonstračního příkladu</a></p>
<p><a href="#k10">10. Výsledek běhu příkladu ve chvíli, kdy je výpočet převodu měn nekorektní</a></p>
<p><a href="#k11">11. Kombinace předchozích příkladů &ndash; tabulky v&nbsp;<strong>Given</strong> i v&nbsp;osnově testů</a></p>
<p><a href="#k12">12. Implementace jednotlivých kroků testu</a></p>
<p><a href="#k13">13. Výsledek běhu pátého demonstračního příkladu</a></p>
<p><a href="#k14">14. Výsledky ve chvíli, kdy je výpočet převodu měn naprogramován nekorektně</a></p>
<p><a href="#k15">15. Testovací scénáře pro kontrolu funkčnosti REST API</a></p>
<p><a href="#k16">16. Soubory <strong>environment.py</strong> a <strong>common.py</strong></a></p>
<p><a href="#k17">17. Spuštění testu se zobrazením výsledků</a></p>
<p><a href="#k18">18. Výsledek testu ve chvíli, kdy je REST API nedostupné</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Behavior-driven development v&nbsp;Pythonu s&nbsp;využitím knihovny Behave (druhá část)</h2>

<p><a
href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">V&nbsp;prvním
článku</a> o knihovně Behave, jejímž úkolem je integrace doménově specifického
jazyka Gherkin do Pythonu, jsme si ukázali, jakým způsobem se zapisují
jednotlivé testovací scénáře a jak se jednotlivé kroky těchto scénářů mapují na
funkce definované přímo v&nbsp;Pythonu. Také jsme si řekli, jaký je význam
takzvaného testovacího <i>kontextu</i>, tj.&nbsp;objektu, který drží informace
o stavu testů. Tento objekt většinou potřebujeme z&nbsp;toho důvodu, že
testovací scénáře zapisované v&nbsp;jazyku Gherkin vlastně odpovídají konečnému
automatu. Dnes si ukážeme některé další možnosti tohoto jazyka. Pravděpodobně
nejužitečnější je podpora pro deklaraci dat s&nbsp;využitím tabulek, které se
velmi jednoduše zapisují do testovacích scénářů. S&nbsp;tabulkami jsme se již
setkali při popisu tzv.&nbsp;osnov (<i>scenario outline</i>), ovšem jejich
použití je poněkud širší, což uvidíme již v&nbsp;prvním demonstračním příkladu
popsaném v&nbsp;navazujících kapitolách.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Využití dat zapsaných do tabulek</h2>

<p>První demonstrační příklad bude velmi jednoduchý. Budeme se v&nbsp;něm
snažit otestovat funkci nazvanou <strong>sum</strong>, které se předá seznam
číselných hodnot (popř.&nbsp;celočíselných, hodnot s&nbsp;plovoucí řádovou
čárkou, komplexních čísel) a jejím výsledkem by měl být součet těchto hodnot.
Tuto funkci je samozřejmě možné napsat různými způsoby; pod tímto odstavcem je
zobrazena varianta funkce zapsaná funkcionálně (interně se postupně
zpracovávají jednotlivé prvky seznamu, aplikuje se na ně zvolená funkce a
výsledek se ukládá do akumulátoru):</p>

<pre>
from functools import reduce
&nbsp;
&nbsp;
def sum(numbers):
    return reduce(lambda x, y: x+y, numbers)
</pre>

<p><div class="rs-tip-major">Poznámka: schválně si zkuste manuálně vyzkoušet,
jak funkce reaguje na různé vstupy, například na prázdný seznam, seznam objektů
implementujících metodu <strong>__add__</strong> apod.</div></p>

<p>Nyní si vytvoříme <a
href="https://github.com/tisnik/python-behave-demos/tree/master/table_data">projekt</a>,
v&nbsp;němž bude umístěn jak modul s&nbsp;testovanou funkcí, tak i konfigurace
knihovny <strong>Behave</strong>, vlastní testovací scénář i modul
implementující jednotlivé kroky testů. Struktura celého projektu bude vypadat
následovně (to pro nás není nic nového, protože jsme projekty s&nbsp;podobnou
strukturou používali již v&nbsp;předchozím článku):</p>

<pre>
├── feature_list.txt
├── features
│   ├── steps
│   │   └── common.py
│   └── sum.feature
├── requirements.in
├── requirements.txt
├── run_tests.sh
└── src
    └── sum.py
</pre>

<p>Připravit je nutné soubor <strong>requirements.txt</strong> obsahující
seznam knihoven, na nichž náš projekt závisí:</p>

<pre>
behave
pytest
</pre>

<p>Dále si pro jistotu ukažme obsah skriptu, který slouží pro spuštění testů.
V&nbsp;tomto skriptu je možné řídit, zda se mají testy spustit ve virtuálním
prostředí Pythonu (tím pádem instalace proběhnou v&nbsp;rámci lokálního
adresáře), nebo zda se virtuální prostředí nemá použít (v&nbsp;tomto případě je
ovšem nutné, aby byly všechny potřebné knihovny již nainstalovány, ať již pro
celý systém přes <strong>pip3 install ...</strong> nebo pro aktivního uživatele
pomocí <strong>pip3 install --user ...</strong>):</p>

<pre>
#!/bin/bash -ex
&nbsp;
export NOVENV=1
&nbsp;
function prepare_venv() {
    virtualenv -p python3 venv &amp;&amp; source venv/bin/activate &amp;&amp; python3 `which pip3` install -r requirements.txt
}
&nbsp;
[ "$NOVENV" == "1" ] || prepare_venv || exit 1
&nbsp;
PYTHONDONTWRITEBYTECODE=1 python3 `which behave` --tags=-skip -D dump_errors=true @feature_list.txt $@
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zápis dat ve formě tabulky do testovacího scénáře</h2>

<p>Nejzajímavější bude způsob zápisu testovacího scénáře. Nyní totiž již nebude
praktické použít přístup známý z&nbsp;minula, kdy jsme testovali mnohem
jednodušší funkci <strong>add</strong> se dvěma vstupy. U funkce
<strong>sum</strong> akceptující obecně libovolně dlouhý seznam bude výhodnější
(= přehlednější, stručnější) použít pro deklaraci vstupních dat tabulku. Tu lze
umístit přímo do klauzule <strong>Given</strong>, kam se tato &bdquo;přípravná
fáze&ldquo; testů obvykle umisťuje. Tabulku zapíšeme jednoduše způsobem, který
připomíná zápis tabulek v&nbsp;AsciiDocu či podobném formátu:</p>

<pre>
<strong>Feature</strong>: Sum function test 1
&nbsp;
  <strong>Scenario</strong>: Check the function sum()
    <strong>Given</strong> a list of integers
      |value |
      | 1    |
      | 10   |
      | 100  |
      | 1000 |
</pre>

<p>Následně kroky testovacího scénáře již jsou snadno pochopitelné &ndash;
v&nbsp;klauzuli <strong>When</strong> je specifikováno volání testované funkce,
v&nbsp;klauzuli <strong>Then</strong> pak porovnání s&nbsp;očekávaným
výsledkem:</p>

<pre>
    <strong>When</strong> I summarize all those integers
    <strong>Then</strong> I should get 1111 as a result
</pre>

<p>Podobně můžeme zapsat i testy pro menší počet prvků v&nbsp;tabulce, aby bylo
možné otestovat chování testované funkce i v&nbsp;těchto nepatrně mezních
případech:</p>

<pre>
  <strong>Scenario</strong>: Check the function sum() for two inputs only
    <strong>Given</strong> a list of integers
      |value |
      | 1    |
      | 2    |
    <strong>When</strong> I summarize all those integers
    <strong>Then</strong> I should get 3 as a result
</pre>

<p>popř.:</p>

<pre>
  <strong>Scenario</strong>: Check the function sum() for one input only
    <strong>Given</strong> a list of integers
      |value |
      | 42   |
    <strong>When</strong> I summarize all those integers
    <strong>Then</strong> I should get 42 as a result
</pre>

<p>Všechny výše uvedené kroky jsou zapsány do souboru
<strong>sum.feature</strong>, který je do struktury projektu umístěn
následovně:</p>

<pre>
├── feature_list.txt
├── features
│   ├── steps
│   │   └── common.py
│   └── <strong>sum.feature</strong>
├── requirements.in
├── requirements.txt
├── run_tests.sh
└── src
    └── sum.py
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Načtení dat z&nbsp;tabulky</h2>

<p>Samotný testovací scénář již máme zapsaný, ovšem mnohem důležitější je jeho
integrace s&nbsp;implementací testovacích kroků. Nejsložitější pravděpodobně
bude zpracování tabulky uvedené v&nbsp;klauzuli <strong>Given</strong>.
Implementaci testovacích kroků zapíšeme do souboru <strong>common.py</strong>,
který je v&nbsp;projektu uložen takto:</p>

<pre>
├── feature_list.txt
├── features
│   ├── steps
│   │   └── <strong>common.py</strong>
│   └── sum.feature
├── requirements.in
├── requirements.txt
├── run_tests.sh
└── src
    └── sum.py
</pre>

<p>Nejprve si uveďme celý obsah souboru <strong>common.py</strong>, teprve poté
si popíšeme, jak vlastně funguje první funkce:</p>

<pre>
from behave import given, then, when
&nbsp;
<i># import testovane funkce</i>
from src.sum import sum
&nbsp;
&nbsp;
@<strong>given</strong>(u'a list of integers')
def list_of_integers(context):
    <i># seznam, do ktereho se ulozi hodnoty z tabulky</i>
    numbers = []
&nbsp;
    <i># iterace pres radky tabulky</i>
    for row in context.table:
        # ziskani hodnoty ze sloupce "value" a prevod na int
        numbers.append(int(row["value"]))
&nbsp;
    <i># zapamatovani hodnot</i>
    context.numbers = numbers
&nbsp;
&nbsp;
@<strong>when</strong>(u'I summarize all those integers')
def step_impl(context):
    <i>"""Zavolani testovane funkce."""</i>
    context.result = sum(context.numbers)
&nbsp;
&nbsp;
@<strong>then</strong>('I should get {expected:d} as a result')
def check_integer_result(context, expected):
    <i>"""Porovnani vypocteneho vysledku s vysledkem ocekavanym."""</i>
    assert context.result == expected, \
        "Wrong result: {r} != {e}".format(r=context.result, e=expected)
</pre>

<p>Nyní se dostáváme k&nbsp;nejzajímavější části &ndash; zpracování dat
z&nbsp;tabulky, která je zapsána v&nbsp;testovacím scénáři. Data zpracujeme
následovně:</p>

<ol>

<li>Získáme referenci na objekt představující tabulku s&nbsp;daným jménem
(tento objekt vytvoří knihovna Behave a pokud jde o jednu tabulku, nemusíme ani
jméno tabulky použít)</li>

<li>Postupně iterujeme přes všechny řádky tabulky</li>

<li>V&nbsp;každém kroku iterace přečteme prvek ze sloupce &bdquo;value&ldquo; a
jelikož se jedná o řetězec, provedeme převod na číselnou hodnotu</li>

<li>Konvertovaný prvek uložíme do seznamu</li>

<li>Samotný seznam se následně stane součástí testovacího <i>kontextu</i> (do
něj můžeme ukládat libovolná data)</li>

</ol>

<p>Celý postup je v&nbsp;Pythonu implementován následujícím způsobem. Zejména
je důležité pochopit způsob získání reference na tabulku a posléze přístup
k&nbsp;prvku v&nbsp;daném sloupci:</p>

<pre>
@<strong>given</strong>(u'a list of integers')
def list_of_integers(context):
    <i># seznam, do ktereho se ulozi hodnoty z tabulky</i>
    numbers = []
&nbsp;
    <i># iterace pres radky tabulky</i>
    for row in context.table:
        # ziskani hodnoty ze sloupce "value" a prevod na int
        numbers.append(int(row["value"]))
&nbsp;
    <i># zapamatovani hodnot</i>
    context.numbers = numbers
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výsledek běhu prvního demonstračního příkladu</h2>

<p>Všechny důležité části projektu jsme si již popsali, takže se nyní pojďme
podívat, jak dopadne výsledek testování. V&nbsp;případě, že pro spuštění testů
použijeme výše uvedený skript, měly by se na standardní výstup vypsat
následující zprávy s&nbsp;informacemi o tom, že se testování zdařilo:</p>

<pre>
Feature: Sum function test 1 # features/sum.feature:1
&nbsp;
  Scenario: Check the function sum()    # features/sum.feature:3
    Given a list of integers            # features/steps/common.py:5
      | value |
      | 1     |
      | 10    |
      | 100   |
      | 1000  |
    When I summarize all those integers # features/steps/common.py:13
    Then I should get 1111 as a result  # features/steps/common.py:18
&nbsp;
  Scenario: Check the function sum() for two inputs only  # features/sum.feature:14
    Given a list of integers                              # features/steps/common.py:5
      | value |
      | 1     |
      | 2     |
    When I summarize all those integers                   # features/steps/common.py:13
    Then I should get 3 as a result                       # features/steps/common.py:18
&nbsp;
  Scenario: Check the function sum() for one input only  # features/sum.feature:23
    Given a list of integers                             # features/steps/common.py:5
      | value |
      | 42    |
    When I summarize all those integers                  # features/steps/common.py:13
    Then I should get 42 as a result                     # features/steps/common.py:18
&nbsp;
1 feature passed, 0 failed, 0 skipped
3 scenarios passed, 0 failed, 0 skipped
9 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m0.001s
</pre>

<a href="https://www.root.cz/obrazek/325432/"><img src="https://i.iinfo.cz/images/357/behave2-1-prev.png" class="image-325432" alt="&#160;" height="270" width="325" /></a>
<p><i>Obrázek 1: Zprávy vypsané knihovnou Behave při spuštění prvního
příkladu.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledek běhu příkladu ve chvíli, kdy je výpočet nekorektní</h2>

<p>Pokud ovšem v&nbsp;testované funkci záměrně uděláme chybu...:</p>

<pre>
from functools import reduce
&nbsp;
&nbsp;
def sum(numbers):
    return reduce(lambda x, y: x+y*2, numbers)
</pre>

<p>...dopadnou testy zcela odlišně:</p>

<pre>
Feature: Sum function test 1 # features/sum.feature:1
&nbsp;
  Scenario: Check the function sum()    # features/sum.feature:3
    Given a list of integers            # features/steps/common.py:7 0.000s
      | value |
      | 1     |
      | 10    |
      | 100   |
      | 1000  |
    When I summarize all those integers # features/steps/common.py:21 0.000s
    Then I should get 1111 as a result  # features/steps/common.py:27 0.000s
      <strong>Assertion Failed: Wrong result: 2221 != 1111</strong>
&nbsp;
&nbsp;
  Scenario: Check the function sum() for two inputs only  # features/sum.feature:14
    Given a list of integers                              # features/steps/common.py:7 0.000s
      | value |
      | 1     |
      | 2     |
    When I summarize all those integers                   # features/steps/common.py:21 0.000s
    Then I should get 3 as a result                       # features/steps/common.py:27 0.000s
      <strong>Assertion Failed: Wrong result: 5 != 3</strong>
&nbsp;
&nbsp;
  Scenario: Check the function sum() for one input only  # features/sum.feature:23
    Given a list of integers                             # features/steps/common.py:7 0.000s
      | value |
      | 42    |
    When I summarize all those integers                  # features/steps/common.py:21 0.000s
    Then I should get 42 as a result                     # features/steps/common.py:27 0.000s
&nbsp;
&nbsp;
Failing scenarios:
  features/sum.feature:3  Check the function sum()
  features/sum.feature:14  Check the function sum() for two inputs only
&nbsp;
0 features passed, 1 failed, 0 skipped
1 scenario passed, 2 failed, 0 skipped
7 steps passed, 2 failed, 0 skipped, 0 undefined
Took 0m0.001s
</pre>

<p><div class="rs-tip-major">Poznámka: chybná implementace testované funkce je
součástí upraveného demonstračního příkladu, jehož zdrojové kódy naleznete <a
href="https://github.com/tisnik/python-behave-demos/tree/master/table_data_invalid_calc">na
této adrese</a>.</div></p>

<a href="https://www.root.cz/obrazek/325433/"><img src="https://i.iinfo.cz/images/357/behave2-2-prev.png" class="image-325433" alt="&#160;" height="270" width="304" /></a>
<p><i>Obrázek 2: Zprávy vypsané knihovnou Behave při spuštění příkladu, u něhož
je pokažený výpočet.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Druhý demonstrační příklad &ndash; konverze měn</h2>

<p>Tabulky s&nbsp;daty, které jsou typicky použité v&nbsp;klauzuli
<strong>Given</strong>, samozřejmě mohou obsahovat i složitější údaje.
V&nbsp;předchozím příkladu se celá tabulka sestávala z&nbsp;jediného sloupce
čísel, což je ta nejjednodušší možnost. Ukažme si tedy <a
href="https://github.com/tisnik/python-behave-demos/tree/master/exchange_rate1">složitější
příklad</a>. V&nbsp;něm budeme testovat převod měn, tj.&nbsp;kolik Kč zaplatíme
za stanovený počet jednotek jiné měny. Z&nbsp;tohoto důvodu bude přímo
v&nbsp;testovacím scénáři uvedena tabulka s&nbsp;kurzy měn, v&nbsp;testovacím
kroku pak budeme zjišťovat, kolik Kč zaplatíme, pokud nakoupíme X jednotek jiné
měny. Testovací scénář tedy může vypadat například následovně:</p>

<pre>
<strong>Feature</strong>: Exchange rate test
&nbsp;
  <strong>Scenario</strong>: Check the exchange rate calculation
    <strong>Given</strong> the following exchange rate table
      | currency |  rate  |
      | CZK      |  1.000 |
      | CAD      | 16.172 |
      | HRK      |  3.407 | 
      | USD      | 20.655 |
    <strong>When</strong> I sell 10 CAD
    <strong>Then</strong> I should receive 161.72 CZK
&nbsp;
  <strong>Scenario</strong>: Check the exchange rate calculation
    <strong>Given</strong> the following exchange rate table
      | currency |  rate  |
      | CZK      |  1.000 |
      | CAD      | 16.172 |
      | HRK      |  3.407 | 
      | USD      | 20.655 |
    <strong>When</strong> I sell 1 HRK
    <strong>Then</strong> I should receive 3.407 CZK
    <strong>When</strong> I sell 2 HRK
    <strong>Then</strong> I should receive 6.814 CZK
&nbsp;
  <strong>Scenario</strong>: Check the exchange rate calculation
    <strong>Given</strong> the following exchange rate table
      | currency |  rate  |
      | CZK      |  1.000 |
      | CAD      | 16.172 |
      | HRK      |  3.407 | 
      | USD      | 20.655 |
    <strong>When</strong> I sell 1000 CZK
    <strong>Then</strong> I should receive 1000 CZK
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Implementace jednotlivých kroků testu</h2>

<p>Při implementaci testovacích kroků již tedy musíme zpracovat tabulku se
dvěma sloupci, přičemž první sloupec obsahuje jednoznačné (unikátní) klíče a
druhý sloupec hodnoty typu <i>float</i>. Přirozenou datovou strukturou, kterou
v&nbsp;Pythonu použijeme, bude tedy slovník (mapa), přičemž klíče budou
představovány kódem měny (řetězce &bdquo;USD&ldquo;, &bdquo;HKR&ldquo;...) a
hodnotami budou příslušné převodní kurzy. Programová smyčka z&nbsp;předchozího
příkladu, v&nbsp;němž jsme naplňovali seznam, se tedy změní na smyčku, ve které
postupně naplňujeme slovník, který je následně přiřazen k&nbsp;testovacímu
<i>kontextu</i>:</p>

<pre>
@<strong>given</strong>(u'the following exchange rate table')
def exchange_rate_table_init(context):
    <i># slovnik do ktereho se ulozi smenne kurzy</i>
    tbl = {}
&nbsp;
    <i># iterace pres vsechny radky tabulky v kroku Given</i>
    for row in context.table:
        <i># nacist kod meny a aktualni kurz</i>
        currency = row["currency"]
        rate = float(row["rate"])
        <i># ulozit do slovniku</i>
        tbl[currency] = rate
&nbsp;
    <i># slovnik se stane soucasti testovaciho kontextu</i>
    context.exchange_rate_table = tbl
</pre>

<p>Další krok testu představovaný klauzulí <strong>When</strong> zjistí kód
měny z&nbsp;věty, která je zapsána v&nbsp;testovacím scénáři a taktéž, kolik
jednotek této měny potřebujeme zakoupit. Následně vypočte potřebný objem Kč
(povšimněte si, že vlastně vůbec nevoláme žádnou testovanou funkci, ale
přímočaře celý výpočet provedeme v&nbsp;implementaci kroku testu, což je
samozřejmě značné zjednodušení, které při reálném testování nenastane):</p>

<pre>
@<strong>when</strong>(u'I sell {sold} {currency}')
def step_impl(context, sold, currency):
    <i>"""Vypocet na zaklade smenneho kurzu."""</i>
    exchange_rate = context.exchange_rate_table[currency]
    context.result = exchange_rate * float(sold)
</pre>

<p>Poslední krok představovaný klauzulí <strong>Then</strong> již teoreticky
není nijak složitý, protože v&nbsp;něm jen budeme potřebovat zjistit, jestli
vypočtený objem Kč odpovídá očekávané hodnotě:</p>

<pre>
@<strong>then</strong>(u'I should receive {amount:g} CZK')
def step_impl(context, amount):
    <i>"""Porovnani vypocteneho vysledku s vysledkem ocekavanym."""</i>
    assert isclose(context.result, amount, rel_tol=1e-5), \
        "Wrong result: {r} != {a}".format(r=context.result, a=amount)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si zvláštnosti &ndash; obě
funkce jsou pojmenovány stejně, a to proto, že jsem kostru definice testovacích
kroků vytvořil na základě nápovědy zobrazené knihovnou Behave (viz úvodní část
tohoto článku). Vzhledem k&nbsp;tomu, že implementace každého kroku má odlišnou
anotaci, to nebude vadit.</div></p>

<p>Jak ovšem záhy zjistíte, není korektní přímo porovnávat dvě hodnoty typu
<i>float</i>, protože textová podoba čísel neodpovídá jejich vnitřní
reprezentaci (více viz články na toto téma [<a
href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/">1</a>]
a [<a
href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/">2</a>].
Z&nbsp;tohoto důvodu je ještě v&nbsp;testech definována pomocná funkce pro
zjištění, do jaké míry se od sebe dvě hodnoty typu <i>float</i> odlišují:</p>

<pre>
def <strong>isclose</strong>(a, b, rel_tol=1e-09, abs_tol=0.0):
    <i>"""Pomocna funkce pro porovnani dvou cisel s plovouci radovou carkou."""</i>
    return abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)
</pre>

<p><div class="rs-tip-major">Poznámka: tato funkce je <a
href="https://docs.python.org/3/library/math.html#math.isclose">součástí
knihoven novějších implementací Pythonu</a>, ale zde ji pro jistotu definuji
explicitně, protože ve starších (ještě pořád používaných verzích) ji
nenalezneme.</div></p>

<p>Nový projekt má prakticky shodnou strukturu s&nbsp;předchozím projektem,
pouze v&nbsp;něm chybí testovaný modul:</p>

<pre>
.
├── feature_list.txt
├── features
│   ├── exchange_rate.feature
│   └── steps
│       └── common.py
├── requirements.in
├── requirements.txt
└── run_tests.sh
&nbsp;
2 directories, 6 files
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výsledek běhu druhého demonstračního příkladu</h2>

<p>Pokud nyní testovací scénář spustíme, měly by se na standardní výstup vypsat
následující řádky:</p>

<pre>
Feature: Exchange rate test # features/exchange_rate.feature:1
&nbsp;
  Scenario: Check the exchange rate calculation  # features/exchange_rate.feature:3
    Given the following exchange rate table      # features/steps/common.py:12 0.000s
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 10 CAD                           # features/steps/common.py:22 0.000s
    Then I should receive 161.72 CZK             # features/steps/common.py:28 0.000s
&nbsp;
  Scenario: Check the exchange rate calculation  # features/exchange_rate.feature:13
    Given the following exchange rate table      # features/steps/common.py:12 0.000s
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 1 HRK                            # features/steps/common.py:22 0.000s
    Then I should receive 3.407 CZK              # features/steps/common.py:28 0.000s
    When I sell 2 HRK                            # features/steps/common.py:22 0.000s
    Then I should receive 6.814 CZK              # features/steps/common.py:28 0.000s
&nbsp;
  Scenario: Check the exchange rate calculation  # features/exchange_rate.feature:25
    Given the following exchange rate table      # features/steps/common.py:12 0.000s
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 1000 CZK                         # features/steps/common.py:22 0.000s
    Then I should receive 1000 CZK               # features/steps/common.py:28 0.000s
&nbsp;
1 feature passed, 0 failed, 0 skipped
3 scenarios passed, 0 failed, 0 skipped
11 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m0.002s
</pre>

<a href="https://www.root.cz/obrazek/325434/"><img src="https://i.iinfo.cz/images/357/behave2-3-prev.png" class="image-325434" alt="&#160;" height="270" width="292" /></a>
<p><i>Obrázek 3: Zprávy vypsané knihovnou Behave při spuštění třetího příkladu
s&nbsp;konverzí měn.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výsledek běhu příkladu ve chvíli, kdy je výpočet převodu měn nekorektní</h2>

<p>Pro zajímavost nyní schválně pokazíme tu část kódu, která počítá převod
měn:</p>

<pre>
</pre>

<p>Jestliže testovací scénář spustíme s&nbsp;pokaženým (resp.&nbsp;přesněji
řečeno s&nbsp;nekorektně pracujícím výpočtem), dostaneme podle očekávání
výsledky s&nbsp;množstvím chyb:</p>

<pre>
Feature: Exchange rate test # features/exchange_rate.feature:1
&nbsp;
  Scenario: Check the exchange rate calculation  # features/exchange_rate.feature:3
    Given the following exchange rate table      # features/steps/common.py:4 0.000s
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 10 CAD                           # features/steps/common.py:21 0.000s
    Then I should receive 161.72 CZK             # features/steps/common.py:28 0.000s
      <strong>Assertion Failed: Wrong result: 323.44 != 161.72</strong>
&nbsp;
&nbsp;
  Scenario: Check the exchange rate calculation  # features/exchange_rate.feature:13
    Given the following exchange rate table      # features/steps/common.py:4 0.000s
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 1 HRK                            # features/steps/common.py:21 0.000s
    Then I should receive 3.407 CZK              # features/steps/common.py:28 0.000s
      <strong>Assertion Failed: Wrong result: 6.814 != 3.407</strong>
&nbsp;
    When I sell 2 HRK                            # None
    Then I should receive 6.814 CZK              # None
&nbsp;
  Scenario: Check the exchange rate calculation  # features/exchange_rate.feature:25
    Given the following exchange rate table      # features/steps/common.py:4 0.000s
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 1000 CZK                         # features/steps/common.py:21 0.000s
    Then I should receive 1000 CZK               # features/steps/common.py:28 0.000s
      <strong>Assertion Failed: Wrong result: 2000.0 != 1000.0</strong>
</pre>

<p>Na obrázku níže jsou dobře vidět ty části testovacích scénářů, které se
vůbec nespustily. Je to vlastně logické, protože každý scénář testuje (či by
měl testovat) ucelenou část chování aplikace s&nbsp;na sebe navazujícími kroky,
takže když se první krok nepovede (start rakety), tak nemá smysl testovat, zda
jsme se dostali na oběžnou dráhu:</p>

<a href="https://www.root.cz/obrazek/325435/"><img src="https://i.iinfo.cz/images/357/behave2-4-prev.png" class="image-325435" alt="&#160;" height="270" width="302" /></a>
<p><i>Obrázek 4: Azurovou barvou jsou zvýrazněny ty kroky testovacího scénáře,
které se vůbec nespustily.</i></p>

<p>Poznámka: i &bdquo;pokažený&ldquo; test je součástí speciální verze
demonstračního příkladu, jehož úplný zdrojový kód naleznete <a
href="https://github.com/tisnik/python-behave-demos/tree/exchange_rate1_invalid_calc">na
této adrese</a>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kombinace předchozích příkladů &ndash; tabulky v&nbsp;<strong>Given</strong> i v&nbsp;osnově testů</h2>

<p>Další <a
href="https://github.com/tisnik/python-behave-demos/tree/master/exchange_rate2">demonstrační
příklad</a> (který se již přibližuje reálným způsobům použití knihovny Behave)
kombinuje možnosti tabulek popsaných minule a dnes. <a
href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">Minule</a>
jsme se totiž zabývali tím, jak popsat ty kroky testu, které se neustále
opakují, pouze se do nich dosazují jiné hodnoty a očekávají se jiné výsledky.
Dnes jsme se naproti tomu dozvěděli, jak je možné deklarovat tabulková data
přímo v&nbsp;testovacím scénáři. Tyto dvě technologie je samozřejmě možné velmi
jednoduše spojit dohromady. Ostatně se stačí podívat na nový testovací scénář,
který by již měl být pochopitelný. První část scénáře odpovídá předchozímu
příkladu. Jedná se jen o klauzuli <strong>Given</strong>, ovšem povšimněte si,
že namísto běžného scénáře používáme osnovu (<i>scenario outline</i>):</p>

<pre>
<strong>Feature</strong>: Exchange rate test
&nbsp;
  <strong>Scenario Outline</strong>: Check the exchange rate calculation
    <strong>Given</strong> the following exchange rate table
      | currency |  rate  |
      | CZK      |  1.000 |
      | CAD      | 16.172 |
      | HRK      |  3.407 | 
      | USD      | 20.655 |
</pre>

<p>Ovšem druhá část již testuje různé transakce (převody měn) a to právě
s&nbsp;využitím tabulek. Tabulka jednoduše obsahuje jednotlivé transakce,
tj.&nbsp;jakou měnu se chystáme koupit a v&nbsp;jakém objemu. Samozřejmě je
nutné uvést i očekávanou sumu, kterou bude nutné zaplatit v&nbsp;Kč:</p>

<pre>
    <strong>When</strong> I sell &lt;sold&gt; &lt;currency&gt;
    <strong>Then</strong> I should receive &lt;amount&gt; CZK
&nbsp;
    <strong>Examples</strong>: sold
        | sold | currency | amount |
        | 1    |   CZK    |    1.000 |
        | 10   |   CZK    |   10.000 |
        | 1    |   CAD    |   16.172 |
        | 100  |   CAD    | 1617.200 |
        | 2    |   HRK    |    6.814 |
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Implementace jednotlivých kroků testu</h2>

<p>Asi nebude větším překvapením zjištění, že existence druhé tabulky (té
v&nbsp;popisu osnovy) se vlastně nijak neodrazí na tom, jak budou muset být
zapsány implementace jednotlivých kroků testu. Je tomu tak z&nbsp;toho důvodu,
že (de facto) převod tabulky na smyčku je proveden intepretrem jazyka Gherkin
(tedy knihovnou Behave):</p>

<pre>
from behave import given, then, when
&nbsp;
&nbsp;
@<strong>given</strong>(u'the following exchange rate table')
def exchange_rate_table_init(context):
    <i># slovnik do ktereho se ulozi smenne kurzy</i>
    tbl = {}
&nbsp;
    <i># iterace pres vsechny radky tabulky v kroku Given</i>
    for row in context.table:
        <i># nacist kod meny a aktualni kurz</i>
        currency = row["currency"]
        rate = float(row["rate"])
        <i># ulozit do slovniku</i>
        tbl[currency] = rate
&nbsp;
    <i># slovnik se stane soucasti testovaciho kontextu</i>
    context.exchange_rate_table = tbl
&nbsp;
&nbsp;
@<strong>when</strong>(u'I sell {sold} {currency}')
def step_impl(context, sold, currency):
    <i>"""Vypocet na zaklade smenneho kurzu."""</i>
    exchange_rate = context.exchange_rate_table[currency]
    context.result = exchange_rate * float(sold)
&nbsp;
&nbsp;
@<strong>then</strong>(u'I should receive {amount:g} CZK')
def step_impl(context, amount):
    <i>"""Porovnani vypocteneho vysledku s vysledkem ocekavanym."""</i>
    assert isclose(context.result, amount, rel_tol=1e-5), \
        "Wrong result: {r} != {a}".format(r=context.result, a=amount)
&nbsp;
&nbsp;
def <strong>isclose</strong>(a, b, rel_tol=1e-09, abs_tol=0.0):
    <i>"""Pomocna funkce pro porovnani dvou cisel s plovouci radovou carkou."""</i>
    return abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Výsledek běhu třetího demonstračního příkladu</h2>

<p>Opět se podívejme, jak bude vypadat výsledek spuštění celého testovacího
scénáře. Povšimněte si, že skutečně došlo k&nbsp;&bdquo;rozbalení&ldquo;
testové osnovy do jednotlivých samostatně spouštěných scénářů:</p>

<pre>
Feature: Exchange rate test # features/exchange_rate.feature:1
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.1 sold  # features/exchange_rate.feature:15
    Given the following exchange rate table                           # features/steps/common.py:12
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 1 CZK                                                 # features/steps/common.py:22
    Then I should receive 1.000 CZK                                   # features/steps/common.py:28
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.2 sold  # features/exchange_rate.feature:16
    Given the following exchange rate table                           # features/steps/common.py:12
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 10 CZK                                                # features/steps/common.py:22
    Then I should receive 10.000 CZK                                  # features/steps/common.py:28
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.3 sold  # features/exchange_rate.feature:17
    Given the following exchange rate table                           # features/steps/common.py:12
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 1 CAD                                                 # features/steps/common.py:22
    Then I should receive 16.172 CZK                                  # features/steps/common.py:28
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.4 sold  # features/exchange_rate.feature:18
    Given the following exchange rate table                           # features/steps/common.py:12
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 100 CAD                                               # features/steps/common.py:22
    Then I should receive 1617.200 CZK                                # features/steps/common.py:28
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.4 sold  # features/exchange_rate.feature:18
    Given the following exchange rate table                           # features/steps/common.py:12
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 100 CAD                                               # features/steps/common.py:22
    Then I should receive 1617.200 CZK                                # features/steps/common.py:28
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.5 sold  # features/exchange_rate.feature:19
    Given the following exchange rate table                           # features/steps/common.py:12
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 2 HRK                                                 # features/steps/common.py:22
    Then I should receive 6.814 CZK                                   # features/steps/common.py:28
&nbsp;
1 feature passed, 0 failed, 0 skipped
5 scenarios passed, 0 failed, 0 skipped
15 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m0.002s
</pre>

<a href="https://www.root.cz/obrazek/325436/"><img src="https://i.iinfo.cz/images/357/behave2-5-prev.png" class="image-325436" alt="&#160;" height="270" width="343" /></a>
<p><i>Obrázek 5: Výsledek běhu pátého demonstračního příkladu tak, jak vypadá
na konzoli.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výsledky ve chvíli, kdy je výpočet převodu měn naprogramován nekorektně</h2>

<p>V&nbsp;případě, že naschvál provedeme výpočet převodu měn špatně, například
úpravou zvýrazněného výrazu:</p>

<pre>
@when(u'I sell {sold} {currency}')
def step_impl(context, sold, currency):
    <i>"""Vypocet na zaklade smenneho kurzu."""</i>
    exchange_rate = context.exchange_rate_table[currency]
    context.result = <strong>exchange_rate * float(sold) / 2</strong>
</pre>

<p>bude tento problém detekován v&nbsp;konstrukci <strong>assert</strong>,
resp.&nbsp;přesněji řečeno vyvolá <strong>assert</strong> výjimku, kterou
zpracuje knihovna Gherkin a do testů vypíše zprávu přiřazenou k&nbsp;výjimce
při její konstrukci (to je velmi důležité, protože výsledky testů by měly být
stejně čitelné, jako samotný zápis testovacího scénáře):</p>

<pre>
@then(u'I should receive {amount:g} CZK')
def step_impl(context, amount):
    <i>"""Porovnani vypocteneho vysledku s vysledkem ocekavanym."""</i>
    assert isclose(context.result, amount, rel_tol=1e-5), \
        "Wrong result: {r} != {a}".format(r=context.result, a=amount)
</pre>

<p>V&nbsp;následující sekvenci zpráv vypsaných knihovnou Behave jsou zvýrazněny
všechny pády (způsobené porovnáním v&nbsp;konstrukci
<strong>assert</strong>):</p>

<pre>
Feature: Exchange rate test # features/exchange_rate.feature:1
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.1 sold  # features/exchange_rate.feature:15
    Given the following exchange rate table                           # features/steps/common.py:4
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 1 CZK                                                 # features/steps/common.py:21
    Then I should receive 1.000 CZK                                   # features/steps/common.py:28
      <strong>Assertion Failed: Wrong result: 0.5 != 1.0</strong>
&nbsp;
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.2 sold  # features/exchange_rate.feature:16
    Given the following exchange rate table                           # features/steps/common.py:4
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 10 CZK                                                # features/steps/common.py:21
    Then I should receive 10.000 CZK                                  # features/steps/common.py:28
      <strong>Assertion Failed: Wrong result: 5.0 != 10.0</strong>
&nbsp;
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.3 sold  # features/exchange_rate.feature:17
    Given the following exchange rate table                           # features/steps/common.py:4
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 1 CAD                                                 # features/steps/common.py:21
    Then I should receive 16.172 CZK                                  # features/steps/common.py:28
      <strong>Assertion Failed: Wrong result: 8.086 != 16.172</strong>
&nbsp;
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.4 sold  # features/exchange_rate.feature:18
    Given the following exchange rate table                           # features/steps/common.py:4
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
    When I sell 1 CAD                                                 # features/steps/common.py:21
    Then I should receive 16.172 CZK                                  # features/steps/common.py:28
      <strong>Assertion Failed: Wrong result: 8.086 != 16.172</strong>
&nbsp;
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.4 sold  # features/exchange_rate.feature:18
    Given the following exchange rate table                           # features/steps/common.py:4
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 100 CAD                                               # features/steps/common.py:21
    Then I should receive 1617.200 CZK                                # features/steps/common.py:28
      <strong>Assertion Failed: Wrong result: 808.6 != 1617.2</strong>
&nbsp;
&nbsp;
  Scenario Outline: Check the exchange rate calculation -- @1.5 sold  # features/exchange_rate.feature:19
    Given the following exchange rate table                           # features/steps/common.py:4
      | currency | rate   |
      | CZK      | 1.000  |
      | CAD      | 16.172 |
      | HRK      | 3.407  |
      | USD      | 20.655 |
    When I sell 2 HRK                                                 # features/steps/common.py:21
    Then I should receive 6.814 CZK                                   # features/steps/common.py:28
      <strong>Assertion Failed: Wrong result: 3.407 != 6.814</strong>
&nbsp;
&nbsp;
&nbsp;
Failing scenarios:
  features/exchange_rate.feature:15  Check the exchange rate calculation -- @1.1 sold
  features/exchange_rate.feature:16  Check the exchange rate calculation -- @1.2 sold
  features/exchange_rate.feature:17  Check the exchange rate calculation -- @1.3 sold
  features/exchange_rate.feature:18  Check the exchange rate calculation -- @1.4 sold
  features/exchange_rate.feature:19  Check the exchange rate calculation -- @1.5 sold
&nbsp;
0 features passed, 1 failed, 0 skipped
0 scenarios passed, 5 failed, 0 skipped
10 steps passed, 5 failed, 0 skipped, 0 undefined
Took 0m0.002s
</pre>

<a href="https://www.root.cz/obrazek/325437/"><img src="https://i.iinfo.cz/images/357/behave2-6-prev.png" class="image-325437" alt="&#160;" height="270" width="352" /></a></p>
<p><i>Obrázek 6: Výsledek běhu ve chvíli, kdy je výpočet převodu měn naschvál
naprogramován nekorektně.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Testovací scénáře pro kontrolu funkčnosti REST API</h2>

<p>Další dva demonstrační příklady, s&nbsp;nimiž se dnes seznámíme, již budou
zaměřeny poněkud praktičtěji a budou vlastně do značné míry kopírovat příklady,
které jsme si již ukázali při popisu knihovny <i>Cucumber</i> určené pro
programovací jazyk Clojure [<a
href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">1</a>]
[<a
href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">2</a>].
V&nbsp;těchto příkladech budeme testovat REST API, konkrétně REST API nabízené
GitHubem (z&nbsp;toho důvodu, že toto API může použít kdokoli, ani se
v&nbsp;některých případech nemusí nijak autentizovat).</p>

<p><div class="rs-tip-major">Poznámka: můžete taktéž využít REST API dostupné
na adrese <a href="https://httpbin.org/">https://httpbin.org/</a>, které je
taktéž vhodné pro různé testy a kontroly.</div></p>

<p>První demonstrační příklad bude velmi jednoduchý, protože v&nbsp;něm pouze
zjistíme, zda je REST API dostupné a zda volané <i>endpointy</i> vrací správné
stavové kódy protokolu HTTP. Testovací scénář bude vypadat následovně:</p>

<pre>
<strong>Feature</strong>: Smoke test
&nbsp;
  <strong>Scenario</strong>: Check the GitHub API entry point
    <strong>Given</strong> GitHub is accessible
    <strong>When</strong> I access the API endpoint /
    <strong>Then</strong> I should receive 200 status code
</pre>

<p>Struktura <a
href="https://github.com/tisnik/python-behave-demos/tree/master/github_test_version1">tohoto
projektu</a> bude nepatrně složitější, než jsme byli zvyklí u předchozích
příkladů, a to z&nbsp;toho důvodu, že do projektu přidáme další důležitý soubor
nazvaný <strong>environment.py</strong>, který je uložen do adresáře
<strong>features</strong>, což naznačuje, že je nějak spojen s&nbsp;testovacími
scénáři:</p>

<pre>
.
├── feature_list.txt
├── features
│   ├── <strong>environment.py</strong>
│   ├── smoketest.feature
│   └── steps
│       └── common.py
├── requirements.in
├── requirements.txt
└── run_tests.sh
&nbsp;
2 directories, 7 files
</pre>

<p>Změní se také soubor <strong>requirements.txt</strong>, a to z&nbsp;toho
důvodu, že pro přístup k&nbsp;REST API GitHubu budeme používat knihovnu <a
href="http://docs.python-requests.org/en/master/">requests</a>:</p>

<pre>
behave
pytest
requests
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Soubory <strong>environment.py</strong> a <strong>common.py</strong></h2>

<p>Soubor <strong>environment.py</strong> uložený do adresáře
<strong>features</strong> se prozatím v&nbsp;demonstračních příkladech
neobjevoval, ale v&nbsp;praxi se s&nbsp;ním setkáme velmi často. Právě
v&nbsp;tomto modulu jsou totiž definovány například funkce spouštěné před všemi
testovacími scénáři či před jednotlivými kroky atd. Naše verze tohoto souboru
bude prozatím velmi jednoduchá, protože v&nbsp;ní budeme deklarovat funkci
nazvanou <strong>_is_accessible</strong>, jejíž reference bude uložena do
<i>kontextu</i>. Podobně do kontextu uložíme atribut nesoucí adresu REST API
GitHubu.</p>

<p>To vše se provede ve speciální funkci se jménem <strong>before_all</strong>,
protože tato funkce je vyhledána a spuštěna před spuštěním testovacího scénáře
(specialita této funkce spočívá v&nbsp;jejím jménu a způsobu jejího vyhledání
knihovnou Behave). Nastavení provedená v&nbsp;této funkci budou viditelná ve
všech testovacích scénářích (v&nbsp;jiných případech se totiž kontext mezi
scénáři znovu inicializuje). Za povšimnutí stojí i nastavení logování,
resp.&nbsp;přesněji řečeno zachytávání logovacích zpráv, aby se mohly
v&nbsp;případě problémů zobrazit ve výsledcích spuštěných testů (celá
problematika je však složitější a budeme se jí zabývat příště):</p>

<pre>
import json
import os.path
&nbsp;
from behave.log_capture import capture
import requests
&nbsp;
&nbsp;
def _is_accessible(context, accepted_codes=None):
    accepted_codes = accepted_codes or {200, 401}
    url = context.api_url
    try:
        res = requests.get(url)
        return res.status_code in accepted_codes
    except requests.exceptions.ConnectionError as e:
        print("Connection error: {e}".format(e=e))
    return False
&nbsp;
&nbsp;
def before_all(context):
    <i>"""Perform setup before the first event."""</i>
    context.is_accessible = _is_accessible
    context.api_url = "https://api.github.com"
</pre>

<p>Vidíme, že do <i>kontextu</i> skutečně byly přidány další dva atributy,
z&nbsp;nichž jeden obsahuje referenci na funkci a druhý adresu REST API
(abychom ji nemuseli složitě přidávat přímo do testů, ale mohli ji načíst
například z&nbsp;konfiguračního souboru).</p>

<p>Další soubor pojmenovaný <strong>common.py</strong> již obsahuje
implementace jednotlivých kroků testů. Povšimněte si, že v&nbsp;kroku
<strong>when</strong> pošleme dotaz na REST API a do <i>kontextu</i> uložíme
celou odpověď, včetně statusu a případného těla s&nbsp;daty. V&nbsp;kroku
<strong>then</strong> pak již jen zjišťujeme HTTP kód:</p>

<pre>
import json
&nbsp;
from behave import given, then, when
from urllib.parse import urljoin
import requests
&nbsp;
&nbsp;
@<strong>given</strong>('GitHub is accessible')
def initial_state(context):
    assert context.is_accessible(context)
&nbsp;
&nbsp;
@<strong>when</strong>('I access the API endpoint {url}')
def access_endpoint(context, url):
    context.response = requests.get(context.api_url + url)
&nbsp;
&nbsp;
@<strong>then</strong>('I should receive {status:d} status code')
def check_status_code(context, status):
    <i>"""Check the HTTP status code returned by the REST API."""</i>
    assert context.response.status_code == status
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Spuštění testu se zobrazením výsledků</h2>

<p>REST API GitHubu je většinou velmi dobře dostupné, takže by se po spuštění
testů (opět skriptem) měla na standardní výstup vypsat zpráva o úspěšném
přístupu &ndash; REST API endpoint na dotaz vrátí HTTP kód 200:</p>

<pre>
Feature: Smoke test # features/smoketest.feature:1
&nbsp;
  @smoketest
  Scenario: Check the GitHub API entry point  # features/smoketest.feature:4
    Given GitHub is accessible                # features/steps/common.py:8 0.647s
    When I access the API endpoint /          # features/steps/common.py:13 0.634s
    Then I should receive 200 status code     # features/steps/common.py:18 0.000s
&nbsp;
1 feature passed, 0 failed, 0 skipped
1 scenario passed, 0 failed, 0 skipped
3 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m1.281s
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Výsledek testu ve chvíli, kdy je REST API nedostupné</h2>

<p>Nepatrnou úpravou adresy REST API, která je uložena v&nbsp;souboru
<strong>environment.py</strong>:</p>

<pre>
def before_all(context):
    <i>"""Perform setup before the first event."""</i>
    context.is_accessible = _is_accessible
    context.api_url = <strong>"https://xyzzy.github.com"</strong>
</pre>

<p>samozřejmě podle očekávání dosáhneme toho, že testy skončí s&nbsp;chybou.
Tato chyba je pro nás o to zajímavější, že nastane již na začátku testovacího
scénáře, tj.&nbsp;v&nbsp;kroku <strong>Given</strong>. Vzhledem k&nbsp;tomu, že
chyba nebyla žádným způsobem zpracována, zobrazí se na výstupu testů celý stack
trace:</p>

<pre>
Feature: Smoke test # features/smoketest.feature:1
&nbsp;
  Scenario: Check the GitHub API entry point  # features/smoketest.feature:4
    Given GitHub is accessible                # features/steps/common.py:8 0.415s
      Traceback (most recent call last):
        File "/usr/local/lib/python3.4/dist-packages/behave/model.py", line 1456, in run
          match.run(runner.context)
        File "/usr/local/lib/python3.4/dist-packages/behave/model.py", line 1903, in run
          self.func(context, *args, **kwargs)
        File "features/steps/common.py", line 10, in initial_state
          assert context.is_accessible(context)
      <strong>AssertionError</strong>
&nbsp;
      Captured logging:
      INFO:urllib3.connectionpool:Starting new HTTPS connection (1): xyzzy.github.com
&nbsp;
    When I access the API endpoint /          # None
    Then I should receive 200 status code     # None
&nbsp;
&nbsp;
Failing scenarios:
  features/smoketest.feature:4  Check the GitHub API entry point
&nbsp;
0 features passed, 1 failed, 0 skipped
0 scenarios passed, 1 failed, 0 skipped
0 steps passed, 1 failed, 2 skipped, 0 undefined
Took 0m0.415s
</pre>

<p><div class="rs-tip-major">Poznámka: chybná implementace testované funkce je
součástí upraveného demonstračního příkladu, jehož zdrojové kódy naleznete <a
href="https://github.com/tisnik/python-behave-demos/tree/master/github_test_version1_wrong_url">na
této adrese</a>.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všech osm demonstračních projektů, které jsme si dnes popsali bylo uloženo
do repositáře, který naleznete na adrese <a
href="https://github.com/tisnik/python-behave-demos">https://github.com/tisnik/python-behave-demos</a>.
V&nbsp;tabulce jsou zobrazeny odkazy na tyto projekty:</p>

<table>
<tr><th>Projekt</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>table_data</td><td>deklarace dat v Given</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/table_data">https://github.com/tisnik/python-behave-demos/tree/table_data</a></td></tr>
<tr><td>table_data_invalid_calc</td><td>detekce nekorektního výpočtu</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/table_data_invalid_calc">https://github.com/tisnik/python-behave-demos/tree/table_data_invalid_calc</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>exchange_rate1</td><td>konverze měn</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/exchange_rate1">https://github.com/tisnik/python-behave-demos/tree/exchange_rate1</a></td></tr>
<tr><td>exchange_rate2</td><td>vylepšení testů tabulkou</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/exchange_rate2">https://github.com/tisnik/python-behave-demos/tree/exchange_rate2</a></td></tr>
<tr><td>exchange_rate1_invalid_calc</td><td>detekce nekorektního výpočtu</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/exchange_rate1_invalid_calc">https://github.com/tisnik/python-behave-demos/tree/exchange_rate1_invalid_calc</a></td></tr>
<tr><td>exchange_rate2_invalid_calc</td><td>detekce nekorektního výpočtu</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/exchange_rate2_invalid_calc">https://github.com/tisnik/python-behave-demos/tree/exchange_rate2_invalid_calc</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>github_test_version1</td><td>test dostupnosti REST API</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/github_test_version1">https://github.com/tisnik/python-behave-demos/tree/github_test_version1</a></td></tr>
<tr><td>github_test_version1_wrong_url</td><td>test NEdostupnosti REST API</td><td><a href="https://github.com/tisnik/python-behave-demos/tree/master/github_test_version1_wrong_url">https://github.com/tisnik/python-behave-demos/tree/github_test_version1_wrong_url</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Behave na GitHubu<br />
<a href="https://github.com/behave/behave">https://github.com/behave/behave</a>
</li>

<li>behave 1.2.6 (PyPi)<br />
<a href="https://pypi.python.org/pypi/behave">https://pypi.python.org/pypi/behave</a>
</li>

<li>Dokumentace k Behave<br />
<a href="http://behave.readthedocs.io/en/latest/">http://behave.readthedocs.io/en/latest/</a>
</li>

<li>Příklady použití Behave<br />
<a href="https://github.com/behave/behave.example">https://github.com/behave/behave.example</a>
</li>

<li>Příklady použití Behave použité v&nbsp;dnešním článku<br />
<a href="https://github.com/tisnik/python-behave-demos">https://github.com/tisnik/python-behave-demos</a>
</li>

<li>Cucumber data tables<br />
<a href="http://www.thinkcode.se/blog/2014/06/30/cucumber-data-tables">http://www.thinkcode.se/blog/2014/06/30/cucumber-data-tables</a>
</li>

<li>Tables (Gherkin)<br />
<a href="http://docs.behat.org/en/v2.5/guides/1.gherkin.html#tables">http://docs.behat.org/en/v2.5/guides/1.gherkin.html#tables</a>
</li>

<li>Predefined Data Types in parse<br />
<a href="https://jenisys.github.io/behave.example/datatype/builtin_types.html">https://jenisys.github.io/behave.example/datatype/builtin_types.html</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Behavior-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Behavior-driven_development">https://en.wikipedia.org/wiki/Behavior-driven_development</a>
</li>

<li>Cucumber<br />
<a href="https://cucumber.io/">https://cucumber.io/</a>
</li>

<li>Jasmine<br />
<a href="https://jasmine.github.io/">https://jasmine.github.io/</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>pdb — The Python Debugger<br />
<a href="https://docs.python.org/3.6/library/pdb.html">https://docs.python.org/3.6/library/pdb.html</a>
</li>

<li>pdb – Interactive Debugger<br />
<a href="https://pymotw.com/2/pdb/">https://pymotw.com/2/pdb/</a>
</li>

<li>functools.reduce<br />
<a href="https://docs.python.org/3.6/library/functools.html#functools.reduce">https://docs.python.org/3.6/library/functools.html#functools.reduce</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

