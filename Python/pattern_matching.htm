<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. SNOBOL &ndash; jazyk založený na práci se vzorky</a></p>
<p><a href="#k03">*** 3. Pattern matching v&nbsp;programovacím jazyku ML</a></p>
<p><a href="#k04">*** 4. Pattern matching v&nbsp;Rustu</a></p>
<p><a href="#k05">*** 5. Pattern jazyk v&nbsp;jazyku Coconut: první krok k&nbsp;Pythonu</a></p>
<p><a href="#k06">*** 6. Pattern matching v&nbsp;programovacím jazyku Python verze 3.10</a></p>
<p><a href="#k07">*** 7. Překlad a instalace Pythonu 3.10</a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. SNOBOL &ndash; jazyk založený na práci se vzorky</h2>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pattern matching v&nbsp;programovacím jazyku ML</h2>

<p>Koncept <i>pattern matchingu</i> by dále rozvinut v&nbsp;programovacím jazyku ML, odkud se dále rozšířil do dalších programovacích jazyků: na přímé linii do jazyka Caml a OCamp (a vlastně i F#) a na nepřímé linii do Rustu, Pythonu atd. Podívejme se nyní ve stručnosti na praktické použití této programovací techniky v&nbsp;ML.</p>

<p>Obecný zápis funkce s&nbsp;pattern matchingem vypadá následovně:</p>

<pre>
<strong>fun &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
</pre>

<p>Většinou se však používá větší množství vzorků, které jsou spojeny znakem
&bdquo;or&ldquo;. V&nbsp;takovém případě jsou vzorky postupně procházeny a
pokud budou vyhovovat předaným datům, bude příslušná větev funkce vykonána:</p>

<pre>
<strong>fun &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
 <strong>|  &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
 <strong>|  &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
 <strong>|  &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
</pre>

<p>O tom, jak vypadá zápis běžné funkce, jsme se dozvěděli <a href="#k13">ve
třinácté kapitole</a>. Příkladem je funkce <strong>length</strong>:</p>

<pre>
<strong>fun length(x) = if null(x) then 0</strong>
                <strong>else 1 + length(tl(x));</strong>
</pre>

<p>V&nbsp;této funkci se provede vždy jedna z&nbsp;větví na základě zapsané
podmínky (<i>case analysis</i>). Ovšem díky existenci pattern matchingu lze
stejnou funkci zapsat odlišně &ndash; a to vyjmenováním invariantů:</p>

<pre>
<strong>fun length([]) = 0</strong>
  <strong>| length(a::x) = 1 + length(x)</strong>
</pre>

<p>Tímto zápisem vlastně popisujeme, že pro prázdný seznam je délka rovna nule
a pro seznam skládající se z&nbsp;hlavy a těla je délka tohoto seznamu rovna
délce těla + 1.</p>

<p>Existují však i zajímavější vzorky. Například funkci <strong>car</strong>
vracející hlavu seznamu (první prvek) lze zapsat opět vyjmenováním
invarianty:</p>

<pre>
<strong>fun car(x::y) = x;</strong>
</pre>

<p>V&nbsp;tomto případě ML rozezná, že nejsou pokryty všechny možné
varianty:</p>

<pre>
&gt; val car = fn: ∀ 'a . 'a list → 'a;
&nbsp;
WARN: Pattern matching is not exhaustive.
</pre>

<p><div class="rs-tip-major">Poznámka: nejprve si povšimněte typu funkce
(generická funkce, ovšem hlídající správné typy) a taktéž varování, ke kterému
se hned dostaneme (a které není radno ignorovat).</div></p>

<p>To, zda tato funkce pracuje podle očekávání, si můžeme snadno ověřit:</p>

<pre>
<strong>car([1,2,3]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>car(["foo", "bar"]);</strong>
&gt; val it = "foo": string;
&nbsp;
<strong>car(["first"]);</strong>
&gt; val it = "first": string;
&nbsp;
<strong>car([]);</strong>
Uncaught SML exception: Match
</pre>

<a href="https://www.root.cz/obrazek/562541/"><img src="https://i.iinfo.cz/images/361/ml1-2-prev.png" class="image-562541" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" width="370" height="75" /></a>
<p><i>Obrázek 2: Otestování funkce ve webovém prostředí.</i></p>

<p>Na posledním příkladu je patrné, že ML měl pravdu &ndash; kód funkce
nepokrývá všechny okrajové podmínky. Náprava je snadná, protože stačí přidat
vzorek pro prázdný seznam na vstupu:</p>

<pre>
<strong>fun car([]) = 0</strong>
  <strong>| car(x::y) = x;</strong>
&gt; val car = fn: int list → int;
&nbsp;
<strong>car([1,2,3]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>car([]);</strong>
&gt; val it = 0: int;
</pre>

<p>Nebo ještě lépe &ndash; vyhodíme výjimku:</p>

<pre>
<strong>fun car nil = raise Empty</strong>
  <strong>| car(x::y) = x;</strong>
&gt; val car = fn: ∀ 'a . 'a list → 'a;
&nbsp;
<strong>car([1,2,3]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>car([]);</strong>
Uncaught SML exception: Empty
</pre>

<p><div class="rs-tip-major">Poznámka: na těchto jednoduchých příkladech to
sice není tak patrné, ale spojením pattern matchingu se silným typovým systémem
vzniká velmi bezpečný programovací jazyk, zejména pokud programátor skutečně
reaguje na všechna varování vypisovaná při analýze jeho zdrojového
kódu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pattern matching v&nbsp;Rustu</h2>

<p>Programovací jazyk Rust sice nepodporuje klasickou céčkovskou rozhodovací konstrukci typu <strong>switch-case</strong> (kterou převzala a jen mírně rozšířila Java atd.), což však ve skutečnosti není žádná škoda, protože namísto toho nabízí mnohem robustnější konstrukci <strong>match</strong>, kterou lze taktéž použít pro volbu některé větve kódu, jenž se má provést. Nejprve se bez dlouhých popisů podívejme na způsob zápisu této konstrukce v&nbsp;její nejjednodušší podobě, tedy při klasickém rozvětvení:</p>

<pre>
fn main() {
    let x:i32 = 1;
&nbsp;
    match x {
        0 =&gt; println!("zero"),
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("something else"),
    }
}
</pre>

<p>Vidíme, že v&nbsp;konstrukci <strong>match</strong> je několik větví, přičemž každá větev začíná porovnávanou hodnotou a výraz či příkaz je uveden za šipkou tvořenou znaky =&gt;. Poslední řádek obsahuje symbol _, který vlastně nahrazuje větev <strong>default</strong>. Ve skutečnosti je však sémantika tohoto symbolu poněkud odlišná, protože před šipkou =&gt; je uveden takzvaný vzorek (<i>pattern</i>) a nikoli pouhopouhá konstanta.</p>

<p>Ve skutečnosti překladač kontroluje, zda je _ použit, protože je vyžadováno, aby větve v&nbsp;konstrukci <strong>match</strong> pokryly všechny možné hodnoty testovaného výrazu (mám pocit, že současný překladač obsahuje chybu, protože pouze vyžaduje použití _ vždy, i když to s&nbsp;ohledem na předchozí větve není nutné). Zkusme přeložit následující příklad:</p>

<pre>
fn main() {
    let x:i32 = 1;

    match x {
        0 =&gt; println!("zero"),
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
    }
}
</pre>

<p>Podle očekávání skončí pokus o překlad tohoto zdrojového kódu s&nbsp;chybou:</p>

<pre>
   Compiling playground v0.0.1 (/playground)
error[E0004]: non-exhaustive patterns: `i32::MIN..=-1_i32` and `4_i32..=i32::MAX` not covered
 --&gt; src/main.rs:4:11
  |
4 |     match x {
  |           ^ patterns `i32::MIN..=-1_i32` and `4_i32..=i32::MAX` not covered
  |
  = note: the matched value is of type `i32`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms
  |
8 ~         3 =&gt; println!("three")
9 ~         i32::MIN..=-1_i32 | 4_i32..=i32::MAX =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `playground` due to previous error
</pre>

<p>Podobně jako tomu bylo o konstrukce <strong>if-else</strong> či u programového bloku <strong>{}</strong>, je i konstrukce <strong>match</strong> považována za <i>výraz</i>, nikoli za <i>příkaz</i>. To znamená, že <strong>match</strong> je možné použít v&nbsp;nějakém výpočtu, uvnitř jiného výrazu atd. V&nbsp;dalším příkladu je deklarována funkce nazvaná <strong>classify</strong>, které se předá celočíselná hodnota a funkce vrátí konstantní řetězec, který tuto hodnotu popisuje (podezřelému zápisu &amp;'static str prosím prozatím věřte, popíšeme si ho později, protože řetězce jsou poměrně komplikované téma). Tato funkce obsahuje ve svém bloku jediný výraz a tím je <strong>match</strong> (proto ostatně za složenou závorkou není středník):</p>

<pre>
fn classify(x:i32) -&gt; &amp;'static str {
    match x {
        0 =&gt; "zero",
        1 =&gt; "one",
        2 =&gt; "two",
        3 =&gt; "three",
        _ =&gt; "something else",
    }
}
&nbsp;
fn main() {
    for x in 0..10 {
        println!("{}:{}", x, classify(x))
    }
}
</pre>

<p>Po překladu a spuštění dostaneme na standardním výstupu tyto zprávy:</p>

<pre>
0:zero
1:one
2:two
3:three
4:something else
5:something else
6:something else
7:something else
8:something else
9:something else
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pattern jazyk v&nbsp;jazyku Coconut: první krok k&nbsp;Pythonu</h2>

<p>Funkcionální jazyk Coconut, s&nbsp;nímž jsme se seznámili v&nbsp;článcích [<a href="">1</a>] a [<a href="">2</a>] (a jenž je transpřekládán právě do Pythonu), taktéž podporuje <i>pattern matching</i>, jenž je ostatně poměrně běžný i v&nbsp;dalších funkcionálních jazycích. Pattern matching je v&nbsp;Coconutu realizován jazykovou konstrukcí používající nová klíčová slova <strong>case</strong> a <strong>match</strong>.  V&nbsp;nejjednodušším případě dokážeme pomocí těchto slov nahradit poměrně špatně čitelnou konstrukci <strong>if-elif-elif...-else</strong>:</p> 

<pre>
def factorial_variant_A(n):
    <strong>case</strong> n:
        <strong>match</strong> 0:
            return 1
        <strong>match</strong> 1:
            return 1
        <strong>match</strong> x:
            return x * factorial_variant_A(x-1)
    <strong>else</strong>:
        raise TypeError("expecting integer &gt;= 0")
</pre>

<p>V&nbsp;tomto případě se bude interpret (resp.&nbsp;přesněji řečeno transpřekladač) snažit najít ten vzor (pattern), který nejlépe a jednoznačně odpovídá vstupu, tj.&nbsp;hodnotě proměnné <strong>n</strong>. Postupně se testují vzorky 0, 1 a jakákoli jiná hodnota.</p>

<p>Povšimněte si toho, že se na třetím řádku <strong>match x</strong> objevuje
<strong>x</strong>, což je proměnná platná jen v&nbsp;rámci dané větve a to
(samozřejmě) pouze v&nbsp;tom případě, že se tato větev bude provádět.</p>

<p>Ve skutečnosti se však mohou v&nbsp;části <strong>match</strong> použít i
další klauzule, zejména klauzule s&nbsp;podmínkou. Předchozí příklad nepracuje
korektně pro záporná čísla, takže doplníme příslušnou podmínku:</p>

<pre>
def factorial_variant_B(n):
    case n:
        match 0:
            return 1
        match 1:
            return 1
        <strong>match x if x &gt; 1</strong>:
            return x * factorial_variant_B(x-1)
    else:
        raise TypeError("expecting integer &gt;= 0")
</pre>

<p>Zde klademe na třetí vzorek další podmínku, takže mu nebude odpovídat
jakákoli hodnota proměnné <strong>n</strong>, ale pouze hodnota větší než
1.</p>

<p>Ani tato úprava však nezajistí zcela korektní chování. Ostatně si sami
vyzkoušejte, co se stane při volání s&nbsp;hodnotou 1.5. Přidáme tedy další
klauzuli na kontrolu typu s&nbsp;využitím operátoru <strong>is</strong>:</p>

<pre>
def factorial_variant_C(n):
    case n:
        match 0:
            return 1
        match 1:
            return 1
        <strong>match x is int if x &gt; 1</strong>:
            return x * factorial_variant_C(x-1)
    else:
        raise TypeError("expecting integer &gt;= 0")
</pre>

<p>Ukažme si některé poněkud složitější příklady použití pattern matchingu.
Například funkci, která rozhodne o tom, jak velký seznam je jí předán:</p>

<pre>
def type(x):
    case x:
        match [a, b]:
            return "list, 2 items"
        match [a]:
            return "list, 1 item"
        match []:
            return "empty list"
</pre>

<p>Otestování vzájemného vztahu dvou hodnot ve dvojici (seznamu, n-tici):</p>

<pre>
def pair(p):
    case p:
        match [x,x]:
            return "same values!"
        match [x,y] if x&gt;y:
            return "1st value is greater"
        match [x,y]:
            return "2nd value is greater"
    else:
        return "other"
</pre>




<p><a name="k06"></a></p>
<h2 id="k06">6. Pattern matching v&nbsp;programovacím jazyku Python verze 3.10</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad a instalace Pythonu 3.10</h2>

<pre>
$ <strong>sudo dnf install wget yum-utils make gcc openssl-devel bzip2-devel libffi-devel zlib-devel</strong>
</pre>

<pre>
$ <strong>wget https://www.python.org/ftp/python/3.10.2/Python-3.10.2.tgz </strong>
</pre>

<pre>
$ <strong>tar xzf Python-3.10.2.tgz </strong>
</pre>

<pre>
$ <strong>cd Python-3.10.2 </strong>
$ <strong>sudo ./configure --with-system-ffi --with-computed-gotos --enable-loadable-sqlite-extensions</strong>
</pre>

<pre>
$ <strong>sudo make -j ${nproc}</strong>
$ <strong>sudo make altinstall</strong>
</pre>

<pre>
$ <strong>python3.10</strong>
&nbsp;
Python 3.10.2 (main, May 20 2022, 04:51:23) [GCC 11.3.1 20220421 (Red Hat 11.3.1-2)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Pattern matching (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Pattern_matching">https://en.wikipedia.org/wiki/Pattern_matching</a>
</li>

<li>Python 3.10.0<br />
<a href="https://www.python.org/downloads/release/python-3100/">https://www.python.org/downloads/release/python-3100/</a>
</li>

<li>PEP 634 – Structural Pattern Matching: Specification<br />
<a href="https://peps.python.org/pep-0634/">https://peps.python.org/pep-0634/</a>
</li>

<li>PEP 635 – Structural Pattern Matching: Motivation and Rationale<br />
<a href="https://peps.python.org/pep-0635/">https://peps.python.org/pep-0635/</a>
</li>

<li>PEP 636 – Structural Pattern Matching: Tutorial<br />
<a href="https://peps.python.org/pep-0636/">https://peps.python.org/pep-0636/</a>
</li>

<li>PEP 622 – Structural Pattern Matching<br />
<a href="https://peps.python.org/pep-0622/">https://peps.python.org/pep-0622/</a>
</li>

<li>Python 3.10 se strukturálním pattern matchingem<br />
<a href="https://www.root.cz/zpravicky/python-3-10-se-strukturalnim-pattern-matchingem/">https://www.root.cz/zpravicky/python-3-10-se-strukturalnim-pattern-matchingem/</a>
</li>

<li>Coconut: funkcionální jazyk s pattern matchingem kompatibilní s Pythonem<br />
<a href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/</a>
</li>

<li>How to Install Python 3.10 on CentOS/RHEL 8 &amp; Fedora 35/34<br />
<a href="https://tecadmin.net/how-to-install-python-3-10-on-centos-rhel-8-fedora/">https://tecadmin.net/how-to-install-python-3-10-on-centos-rhel-8-fedora/</a>
</li>

<li>Pattern matching functions in Clojure?<br />
<a href="https://stackoverflow.com/questions/8596980/pattern-matching-functions-in-clojure">https://stackoverflow.com/questions/8596980/pattern-matching-functions-in-clojure</a>
</li>

<li>Clojure core.match<br />
<a href="https://github.com/clojure/core.match">https://github.com/clojure/core.match</a>
</li>

<li>The Rust Programming Language: Patterns and Matching<br />
<a href="https://doc.rust-lang.org/book/ch18-00-patterns.html#patterns-and-matching">https://doc.rust-lang.org/book/ch18-00-patterns.html#patterns-and-matching</a>
</li>

<li>The Rust Programming Language: Pattern Syntax<br />
<a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html">https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html</a>
</li>

<li>Coconut: funkcionální jazyk s pattern matchingem kompatibilní s Pythonem<br />
<a href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/</a>
</li>

<li>Coconut aneb funkcionální nadstavba nad Pythonem (2.část)<br />
<a href="https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/">https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/</a>
</li>

<li>Programovací jazyky používané v SSSR (část 2 – SNOBOL)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-v-sssr-cast-2-ndash-snobol/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-v-sssr-cast-2-ndash-snobol/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

