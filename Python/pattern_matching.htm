<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Nejdůležitější novinka v Pythonu 3.10: strukturální pattern matching</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Nejdůležitější novinka v Pythonu 3.10: strukturální pattern matching</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Nejdůležitější novinka v&nbsp;Pythonu 3.10: strukturální pattern matching</a></p>
<p><a href="#k02">*** 2. SNOBOL &ndash; jazyk založený na práci se vzorky</a></p>
<p><a href="#k03">*** 3. Strukturální pattern matching v&nbsp;programovacím jazyku ML</a></p>
<p><a href="#k04">*** 4. Strukturální pattern matching v&nbsp;Rustu</a></p>
<p><a href="#k05">*** 5. Strukturální pattern jazyk v&nbsp;jazyku Coconut: první krok k&nbsp;Pythonu</a></p>
<p><a href="#k06">*** 6. Strukturální pattern matching v&nbsp;programovacím jazyku Python verze 3.10</a></p>
<p><a href="#k07">*** 7. Překlad a instalace Pythonu 3.10</a></p>
<p><a href="#k08">*** 8. Nejjednodušší příklad &ndash; rozeskok</a></p>
<p><a href="#k09">*** 9. Větší množství hodnot v&nbsp;každé větvi</a></p>
<p><a href="#k10">*** 10. Zachycení hodnoty proměnné v&nbsp;rozhodovací větvi</a></p>
<p><a href="#k11">*** 11. Podmínka v&nbsp;rozhodovací větvi, větev &bdquo;else&ldquo;</a></p>
<p><a href="#k12">*** 12. Test obsahu n-tic</a></p>
<p><a href="#k13">*** 13. n-tice a podmínky pro hodnoty prvků</a></p>
<p><a href="#k14">*** 14. Zpracování příkazů či strukturovaných textových souborů</a></p>
<p><a href="#k15">*** 15. Proměnné části víceslovních příkazů</a></p>
<p><a href="#k16">*** 16. Vnořené řídicí struktury <strong>match</strong></a></p>
<p><a href="#k17">*** 17. Strukturální pattern matching a objekty</a></p>
<p><a href="#k18">*** 18. Příloha: část gramatiky Pythonu s&nbsp;pattern matchingem</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nejdůležitější novinka v&nbsp;Pythonu 3.10: strukturální pattern matching</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. SNOBOL &ndash; jazyk založený na práci se vzorky</h2>

<p>Bellovy laboratoře jsou v&nbsp;oblasti elektroniky a samozřejmě taktéž informatiky velmi známou institucí. Právě v&nbsp;Bellových laboratořích byl zkonstruován první tranzistor (William Shockley, Gerald Pearson, John Bardeen, Walter Brattain), vytvořena první verze dodnes široce používaného programovacího jazyka <strong>C</strong> (Dennis Ritchie) a v&nbsp;neposlední řadě taktéž funkční prototyp operačního systému <i>UNIX</i> (Ken Thompson, Dennis Ritchie, Brian Kernighan, Douglas McIlroy, Joe Ossanna a další). Kromě těchto známých projektů, z&nbsp;nichž například vynález tranzistoru byl odměněn Nobelovou cenou, však v&nbsp;Bellových laboratořích vzniklo i poměrně velké množství dalších více či méně úspěšných projektů. Jedním z&nbsp;těchto poněkud méně známých projektů je i programovací jazyk <i>SNOBOL</i>, který byl v&nbsp;Bellových laboratořích vyvíjen v&nbsp;průběhu let 1962 až 1967. Jeho autory jsou David J. Farber, Ralph E. Griswold a Ivan P. Polonsky.</p>

<p>Syntaxe programovacího jazyka <i>SNOBOL</i> je velmi jednoduchá, protože tento jazyk ve své základní podobě neobsahuje žádné podmíněné příkazy, programové smyčky ani jiné jazykové konstrukce známé z&nbsp;jiných (strukturovaných) jazyků. Namísto toho se struktura programů nejvíce podobá zápisu stavů a přechodů konečného automatu, což je ostatně při zpracovávání řetězců (či jiných dat) jeden ze základních nástrojů prakticky každého programátora. Nejprve si popišme základní syntaxi programovacího jazyka <i>SNOBOL</i>. Na každém programovém řádku se může nacházet až pět bloků, z&nbsp;nichž žádný není povinný:</p>

<ol>
<li>náveští (<i>label</i>)</li>
<li>subjekt (<i>subject</i>)</li>
<li>vzor (<i>pattern</i>)</li>
<li>objekt (<i>object</i>)</li>
<li>odkaz(y) na jiné příkazy (<i>goto</i>)</li>
</ol>

<p>V&nbsp;případě, že se neprovádí vyhledávání řetězců podle zadaného vzoru, ani náhrada části řetězců za jiné řetězce, obsahuje programový řádek pouze trojici bloků:</p>

<ol>
<li>náveští (<i>label</i>)</li>
<li>příkaz (<i>ostatement</i>)</li>
<li>odkaz(y) na jiné příkazy (<i>goto</i>)</li>
</ol>

<p>Nepovinné návěští (cíl skoku) je od příkazu odděleno mezerou, podmíněné či nepodmíněné odkazy jsou od příkazu odděleny dvojtečkou. V&nbsp;programech je možné používat běžné aritmetické výrazy (jejich části se od sebe musí oddělovat mezerou), proměnné (s&nbsp;automatickými konverzemi mezi celočíselným typem, reálným číslem a řetězcem) i některé speciální proměnné, jejichž použití ve skutečnosti vede k&nbsp;zavolání nějaké funkce operačního systému. Mezi speciální proměnné patří <strong>OUTPUT</strong> (standardní výstup) a <strong>INPUT</strong> (standardní vstup). Přiřazení nějaké hodnoty do proměnné <strong>OUTPUT</strong> způsobí její tisk na standardní výstup, naopak čtení z&nbsp;proměnné <strong>INPUT</strong> odpovídá načtení řetězce ze standardního vstupu (pojmy &bdquo;standardní vstup&ldquo; a &bdquo;standardní výstup&ldquo; nemusí odpovídat tomu, co si pod těmito souslovími představujeme v&nbsp;Unixu, neboť <i>SNOBOL</i> se používá na velkém množství různých platforem, které mají vstupně/výstupní část řešenou odlišným způsobem).</p>

<p><div class="rs-tip-major">Poznámka: samotný SNOBOL byl sice používán, a to poměrně intenzivně, ovšem z&nbsp;dnešního pohledu je mnohem důležitější, že SNOBOL ovlivnil sémantiku dalšího programovacího jazyka. Jedná se o jazyk <i>AWK</i>, jenž je používán dodnes, typicky pro tvorbu pomocných skriptů pro zpracování či transformaci textových dat. Mnoho algoritmů lze s&nbsp;využitím <i>AWK</i> realizovat velmi efektivním způsobem, a to právě díky (prakticky implicitnímu) <i>pattern matchingu</i>.</div></p>

BEGIN LINE = INPUT
      &ANCHOR = 1
      NUM     = SPAN("0123456789")
      TERM    = ANY("XYZ")
      OP      = ANY("+-*/")
      EXPR    = TERM | *EXPR OP TERM
      LINE    EXPR "=" NUM            :S(END)
      OUTPUT = LINE                   :(BEGIN)
END


<p><a name="k03"></a></p>
<h2 id="k03">3. Strukturální pattern matching v&nbsp;programovacím jazyku ML</h2>

<p>Koncept <i>pattern matchingu</i> by dále rozvinut v&nbsp;programovacím jazyku ML, odkud se dále rozšířil do dalších programovacích jazyků: na přímé linii do jazyka Caml a OCamp (a vlastně i F#) a na nepřímé linii do Rustu, Pythonu atd. Podívejme se nyní ve stručnosti na praktické použití této programovací techniky v&nbsp;ML.</p>

<p>Obecný zápis funkce s&nbsp;pattern matchingem vypadá následovně:</p>

<pre>
<strong>fun &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
</pre>

<p>Většinou se však používá větší množství vzorků, které jsou spojeny znakem
&bdquo;or&ldquo;. V&nbsp;takovém případě jsou vzorky postupně procházeny a
pokud budou vyhovovat předaným datům, bude příslušná větev funkce vykonána:</p>

<pre>
<strong>fun &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
 <strong>|  &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
 <strong>|  &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
 <strong>|  &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
</pre>

<p>Naproti tomu příkladem běžné funkce bez pattern matchingu je funkce <strong>length</strong>:</p>

<pre>
<strong>fun length(x) = if null(x) then 0</strong>
                <strong>else 1 + length(tl(x));</strong>
</pre>

<p>V&nbsp;této funkci se provede vždy jedna z&nbsp;větví na základě zapsané
podmínky (<i>case analysis</i>). Ovšem díky existenci pattern matchingu lze
stejnou funkci zapsat odlišně &ndash; a to vyjmenováním invariantů:</p>

<pre>
<strong>fun length([]) = 0</strong>
  <strong>| length(a::x) = 1 + length(x)</strong>
</pre>

<p>Tímto zápisem vlastně popisujeme, že pro prázdný seznam je délka rovna nule
a pro seznam skládající se z&nbsp;hlavy a těla je délka tohoto seznamu rovna
délce těla + 1.</p>

<p>Existují však i zajímavější vzorky. Například funkci <strong>car</strong>
vracející hlavu seznamu (první prvek) lze zapsat opět vyjmenováním
invarianty:</p>

<pre>
<strong>fun car(x::y) = x;</strong>
</pre>

<p>V&nbsp;tomto případě ML rozezná, že nejsou pokryty všechny možné
varianty:</p>

<pre>
&gt; val car = fn: ∀ 'a . 'a list → 'a;
&nbsp;
WARN: Pattern matching is not exhaustive.
</pre>

<p><div class="rs-tip-major">Poznámka: nejprve si povšimněte typu funkce
(generická funkce, ovšem hlídající správné typy) a taktéž varování, ke kterému
se hned dostaneme (a které není radno ignorovat).</div></p>

<p>To, zda tato funkce pracuje podle očekávání, si můžeme snadno ověřit:</p>

<pre>
<strong>car([1,2,3]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>car(["foo", "bar"]);</strong>
&gt; val it = "foo": string;
&nbsp;
<strong>car(["first"]);</strong>
&gt; val it = "first": string;
&nbsp;
<strong>car([]);</strong>
Uncaught SML exception: Match
</pre>

<a href="https://www.root.cz/obrazek/562541/"><img src="https://i.iinfo.cz/images/361/ml1-2-prev.png" class="image-562541" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" width="370" height="75" /></a>
<p><i>Obrázek 2: Otestování funkce ve webovém prostředí.</i></p>

<p>Na posledním příkladu je patrné, že ML měl pravdu &ndash; kód funkce
nepokrývá všechny okrajové podmínky. Náprava je snadná, protože stačí přidat
vzorek pro prázdný seznam na vstupu:</p>

<pre>
<strong>fun car([]) = 0</strong>
  <strong>| car(x::y) = x;</strong>
&gt; val car = fn: int list → int;
&nbsp;
<strong>car([1,2,3]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>car([]);</strong>
&gt; val it = 0: int;
</pre>

<p>Nebo ještě lépe &ndash; vyhodíme výjimku:</p>

<pre>
<strong>fun car nil = raise Empty</strong>
  <strong>| car(x::y) = x;</strong>
&gt; val car = fn: ∀ 'a . 'a list → 'a;
&nbsp;
<strong>car([1,2,3]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>car([]);</strong>
Uncaught SML exception: Empty
</pre>

<p><div class="rs-tip-major">Poznámka: na těchto jednoduchých příkladech to
sice není tak patrné, ale spojením pattern matchingu se silným typovým systémem
vzniká velmi bezpečný programovací jazyk, zejména pokud programátor skutečně
reaguje na všechna varování vypisovaná při analýze jeho zdrojového
kódu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Strukturální pattern matching v&nbsp;Rustu</h2>

<p>Programovací jazyk Rust sice nepodporuje klasickou céčkovskou rozhodovací konstrukci typu <strong>switch-case</strong> (kterou převzala a jen mírně rozšířila Java atd.), což však ve skutečnosti není žádná škoda, protože namísto toho nabízí mnohem robustnější konstrukci <strong>match</strong>, kterou lze taktéž použít pro volbu některé větve kódu, jenž se má provést. Nejprve se bez dlouhých popisů podívejme na způsob zápisu této konstrukce v&nbsp;její nejjednodušší podobě, tedy při klasickém rozvětvení:</p>

<pre>
fn main() {
    let x:i32 = 1;
&nbsp;
    match x {
        0 =&gt; println!("zero"),
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("something else"),
    }
}
</pre>

<p>Vidíme, že v&nbsp;konstrukci <strong>match</strong> je několik větví, přičemž každá větev začíná porovnávanou hodnotou a výraz či příkaz je uveden za šipkou tvořenou znaky =&gt;. Poslední řádek obsahuje symbol _, který vlastně nahrazuje větev <strong>default</strong>. Ve skutečnosti je však sémantika tohoto symbolu poněkud odlišná, protože před šipkou =&gt; je uveden takzvaný vzorek (<i>pattern</i>) a nikoli pouhopouhá konstanta.</p>

<p>Ve skutečnosti překladač kontroluje, zda je _ použit, protože je vyžadováno, aby větve v&nbsp;konstrukci <strong>match</strong> pokryly všechny možné hodnoty testovaného výrazu (mám pocit, že současný překladač obsahuje chybu, protože pouze vyžaduje použití _ vždy, i když to s&nbsp;ohledem na předchozí větve není nutné). Zkusme přeložit následující příklad:</p>

<pre>
fn main() {
    let x:i32 = 1;

    match x {
        0 =&gt; println!("zero"),
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
    }
}
</pre>

<p>Podle očekávání skončí pokus o překlad tohoto zdrojového kódu s&nbsp;chybou:</p>

<pre>
   Compiling playground v0.0.1 (/playground)
error[E0004]: non-exhaustive patterns: `i32::MIN..=-1_i32` and `4_i32..=i32::MAX` not covered
 --&gt; src/main.rs:4:11
  |
4 |     match x {
  |           ^ patterns `i32::MIN..=-1_i32` and `4_i32..=i32::MAX` not covered
  |
  = note: the matched value is of type `i32`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms
  |
8 ~         3 =&gt; println!("three")
9 ~         i32::MIN..=-1_i32 | 4_i32..=i32::MAX =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `playground` due to previous error
</pre>

<p>Podobně jako tomu bylo o konstrukce <strong>if-else</strong> či u programového bloku <strong>{}</strong>, je i konstrukce <strong>match</strong> považována za <i>výraz</i>, nikoli za <i>příkaz</i>. To znamená, že <strong>match</strong> je možné použít v&nbsp;nějakém výpočtu, uvnitř jiného výrazu atd. V&nbsp;dalším příkladu je deklarována funkce nazvaná <strong>classify</strong>, které se předá celočíselná hodnota a funkce vrátí konstantní řetězec, který tuto hodnotu popisuje (podezřelému zápisu &amp;'static str prosím prozatím věřte, popíšeme si ho později, protože řetězce jsou poměrně komplikované téma). Tato funkce obsahuje ve svém bloku jediný výraz a tím je <strong>match</strong> (proto ostatně za složenou závorkou není středník):</p>

<pre>
fn classify(x:i32) -&gt; &amp;'static str {
    match x {
        0 =&gt; "zero",
        1 =&gt; "one",
        2 =&gt; "two",
        3 =&gt; "three",
        _ =&gt; "something else",
    }
}
&nbsp;
fn main() {
    for x in 0..10 {
        println!("{}:{}", x, classify(x))
    }
}
</pre>

<p>Po překladu a spuštění dostaneme na standardním výstupu tyto zprávy:</p>

<pre>
0:zero
1:one
2:two
3:three
4:something else
5:something else
6:something else
7:something else
8:something else
9:something else
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Strukturální pattern jazyk v&nbsp;jazyku Coconut: první krok k&nbsp;Pythonu</h2>

<p>Funkcionální jazyk Coconut, s&nbsp;nímž jsme se seznámili v&nbsp;článcích [<a href="">1</a>] a [<a href="">2</a>] (a jenž je transpřekládán právě do Pythonu), taktéž podporuje <i>pattern matching</i>, jenž je ostatně poměrně běžný i v&nbsp;dalších funkcionálních jazycích. Pattern matching je v&nbsp;Coconutu realizován jazykovou konstrukcí používající nová klíčová slova <strong>case</strong> a <strong>match</strong>.  V&nbsp;nejjednodušším případě dokážeme pomocí těchto slov nahradit poměrně špatně čitelnou konstrukci <strong>if-elif-elif...-else</strong>:</p> 

<pre>
def factorial_variant_A(n):
    <strong>case</strong> n:
        <strong>match</strong> 0:
            return 1
        <strong>match</strong> 1:
            return 1
        <strong>match</strong> x:
            return x * factorial_variant_A(x-1)
    <strong>else</strong>:
        raise TypeError("expecting integer &gt;= 0")
</pre>

<p>V&nbsp;tomto případě se bude interpret (resp.&nbsp;přesněji řečeno transpřekladač) snažit najít ten vzor (pattern), který nejlépe a jednoznačně odpovídá vstupu, tj.&nbsp;hodnotě proměnné <strong>n</strong>. Postupně se testují vzorky 0, 1 a jakákoli jiná hodnota.</p>

<p>Povšimněte si toho, že se na třetím řádku <strong>match x</strong> objevuje
<strong>x</strong>, což je proměnná platná jen v&nbsp;rámci dané větve a to
(samozřejmě) pouze v&nbsp;tom případě, že se tato větev bude provádět.</p>

<p>Ve skutečnosti se však mohou v&nbsp;části <strong>match</strong> použít i
další klauzule, zejména klauzule s&nbsp;podmínkou. Předchozí příklad nepracuje
korektně pro záporná čísla, takže doplníme příslušnou podmínku:</p>

<pre>
def factorial_variant_B(n):
    case n:
        match 0:
            return 1
        match 1:
            return 1
        <strong>match x if x &gt; 1</strong>:
            return x * factorial_variant_B(x-1)
    else:
        raise TypeError("expecting integer &gt;= 0")
</pre>

<p>Zde klademe na třetí vzorek další podmínku, takže mu nebude odpovídat
jakákoli hodnota proměnné <strong>n</strong>, ale pouze hodnota větší než
1.</p>

<p>Ani tato úprava však nezajistí zcela korektní chování. Ostatně si sami
vyzkoušejte, co se stane při volání s&nbsp;hodnotou 1.5. Přidáme tedy další
klauzuli na kontrolu typu s&nbsp;využitím operátoru <strong>is</strong>:</p>

<pre>
def factorial_variant_C(n):
    case n:
        match 0:
            return 1
        match 1:
            return 1
        <strong>match x is int if x &gt; 1</strong>:
            return x * factorial_variant_C(x-1)
    else:
        raise TypeError("expecting integer &gt;= 0")
</pre>

<p>Ukažme si některé poněkud složitější příklady použití pattern matchingu.
Například funkci, která rozhodne o tom, jak velký seznam je jí předán:</p>

<pre>
def type(x):
    case x:
        match [a, b]:
            return "list, 2 items"
        match [a]:
            return "list, 1 item"
        match []:
            return "empty list"
</pre>

<p>Otestování vzájemného vztahu dvou hodnot ve dvojici (seznamu, n-tici):</p>

<pre>
def pair(p):
    case p:
        match [x,x]:
            return "same values!"
        match [x,y] if x&gt;y:
            return "1st value is greater"
        match [x,y]:
            return "2nd value is greater"
    else:
        return "other"
</pre>

<p>V&nbsp;případě, že se další funkci předá řetězec začínající na &bdquo;My name is &ldquo;, vezme se z&nbsp;něj další text a přiřadí do proměnné <strong>name</strong>:</p>

<pre>
def say_hello(s):
    case s:
        match "My name is " + name:
            return "Hi " + name
</pre>

<p>Specifikovat je možné začátek i konec řetěze (ovšem ne regulárním výrazem):</p>

<pre>
def get_name(s):
    case s:
        match name + "@root.cz":
            return name
&nbsp;
def say_hello2(s):
    case s:
        match "My name is " + name + ".":
            return "Hi " + name
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Strukturální pattern matching v&nbsp;programovacím jazyku Python verze 3.10</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad a instalace Pythonu 3.10</h2>

<pre>
$ <strong>sudo dnf install wget yum-utils make gcc openssl-devel bzip2-devel libffi-devel zlib-devel</strong>
</pre>

<pre>
$ <strong>wget https://www.python.org/ftp/python/3.10.6/Python-3.10.6.tgz</strong>
</pre>

<pre>
$ <strong>tar xzf Python-3.10.6.tgz</strong>
</pre>

<pre>
$ <strong>cd Python-3.10.6</strong>
$ <strong>./configure --with-system-ffi --with-computed-gotos --enable-loadable-sqlite-extensions</strong>
</pre>

<pre>
</pre>

<pre>
$ <strong>make -j ${nproc}</strong>
</pre>

<pre>
Python-3.10.6$ <strong>ls -l -h python</strong>
-rwxrwxr-x 1 ptisnovs ptisnovs 24M Aug 25 12:55 python
</pre>

<pre>
Python-3.10.6$ <strong>strip python</strong>
Python-3.10.6$ <strong>ls -l -h python</strong>
</pre>

<pre>
Python-3.10.6$ <strong>./python </strong>
Python 3.10.6 (main, Aug 25 2022, 12:55:31) [GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>
<pre>
$ <strong>sudo make altinstall</strong>
</pre>

<pre>
$ <strong>python3.10</strong>
&nbsp;
Python 3.10.6 (main, May 20 2022, 04:51:23) [GCC 11.3.1 20220421 (Red Hat 11.3.1-2)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nejjednodušší příklad &ndash; rozeskok</h2>

<pre>
print("Not ready reading drive A")


def abort_retry_fail():
    response = input("Abort, Retry, Fail? ")

    <strong>if</strong> response == "a":
        return "Abort"
    <strong>elif</strong> response == "r":
        return "Retry"
    <strong>elif</strong> response == "f":
        return "Fail"
    <strong>else</strong>:
        return "Wrong response"


print(abort_retry_fail())
</pre>

<pre>
print("Not ready reading drive A")


def abort_retry_fail():
    response = input("Abort, Retry, Fail? ")

    commands = {
            "a": "Abort",
            "r": "Retry",
            "f": "Fail"
            }

    return <strong>commands.get(response, "Wrong response")</strong>


print(abort_retry_fail())
</pre>

<pre>
print("Not ready reading drive A")


def abort_retry_fail():
    response = input("Abort, Retry, Fail? ")

    <strong>match</strong> response:
        <strong>case</strong> "a":
            return "Abort"
        <strong>case</strong> "r":
            return "Retry"
        <strong>case</strong> "f":
            return "Fail"
        <strong>case</strong> _:
            return "Wrong response"


print(abort_retry_fail())
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Větší množství hodnot v&nbsp;každé větvi</h2>

<p></p>

<pre>
print("Not ready reading drive A")


def abort_retry_fail():
    response = input("Abort, Retry, Fail? ")

    <strong>if</strong> response in {"a", "A"}:
        return "Abort"
    <strong>elif</strong> response in {"r", "R"}:
        return "Retry"
    <strong>elif</strong> response in {"f", "F"}:
        return "Fail"
    <strong>else</strong>:
        return "Wrong response"


print(abort_retry_fail())
</pre>

<p></p>

<pre>
print("Not ready reading drive A")


def abort_retry_fail():
    response = input("Abort, Retry, Fail? ")

    <strong>match</strong> response:
        <strong>case</strong> "a" | "A":
            return "Abort"
        <strong>case</strong> "r" | "R":
            return "Retry"
        <strong>case</strong> "f" | "F":
            return "Fail"
        <strong>case</strong> _:
            return "Wrong response"


print(abort_retry_fail())
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zachycení hodnoty proměnné v&nbsp;rozhodovací větvi</h2>

<p></p>

<pre>
print("Not ready reading drive A")


def abort_retry_fail():
    response = input("Abort, Retry, Fail? ")

    <strong>match</strong> response:
        <strong>case</strong> "a" | "A":
            return "Abort"
        <strong>case</strong> "r" | "R":
            return "Retry"
        <strong>case</strong> "f" | "F":
            return "Fail"
        <strong>case</strong> _ as x:
            return f"Wrong response {x}"


print(abort_retry_fail())
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Podmínka v&nbsp;rozhodovací větvi, větev &bdquo;else&ldquo;</h2>

<p></p>

<pre>
def factorial(n):
    <strong>match</strong> n:
        <strong>case</strong> 0:
            return 1
        <strong>case</strong> 1:
            return 1
        <strong>case</strong> x:
            return x * factorial(x-1)


for i in range(0, 10):
    print(i, factorial(i))
</pre>

<p></p>

<pre>
def factorial(n):
    <strong>match</strong> n:
        <strong>case</strong> 0:
            return 1
        <strong>case</strong> 1:
            return 1
        <strong>case</strong> x if x&gt;1:
            return x * factorial(x-1)
        <strong>case</strong> _:
            raise TypeError("expecting integer &gt;= 0")


for i in range(-1, 10):
    try:
        print(i, factorial(i))
    except Exception as e:
        print(e)
</pre>

<pre>
def factorial(n):
    <strong>match</strong> n:
        <strong>case</strong> 0:
            return 1
        <strong>case</strong> 1:
            return 1
        <strong>case</strong> x if isinstance(x, int) and x&gt;1:
            return x * factorial(x-1)
        <strong>case</strong> _:
            raise TypeError("expecting integer &gt;= 0")


for i in range(-1, 10):
    try:
        print(i, factorial(i))
    except Exception as e:
        print(e)

try:
    print(factorial(3.14))
except Exception as e:
    print(e)

try:
    print(factorial("hello"))
except Exception as e:
    print(e)
</pre>

<pre>
def factorial(n):
    <strong>match</strong> n:
        <strong>case</strong> 0 | 1:
            return 1
        <strong>case</strong> x if isinstance(x, int) and x&gt;1:
            return x * factorial(x-1)
        <strong>case</strong> _:
            raise TypeError("expecting integer &gt;= 0")


for i in range(-1, 10):
    try:
        print(i, factorial(i))
    except Exception as e:
        print(e)

try:
    print(factorial(3.14))
except Exception as e:
    print(e)

try:
    print(factorial("hello"))
except Exception as e:
    print(e)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Test obsahu n-tic</h2>

<p></p>

<pre>
def test_number(value):
    <strong>match</strong> value:
        <strong>case</strong> (0, 0):
            print("Zero")
        <strong>case</strong> (real, 0):
            print(f"Real number {real}")
        <strong>case</strong> (0, imag):
            print(f"Imaginary number {imag}")
        <strong>case</strong> (real, imag):
            print(f"Complex number {real}+i{imag}")
        <strong>case</strong> _:
            raise ValueError("Not a complex numbe")


test_number((0,0))
test_number((1,0))
test_number((0,1))
test_number((1,1))
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. n-tice a podmínky pro hodnoty prvků</h2>

<p></p>

<pre>
def test_number(value):
    <strong>match</strong> value:
        <strong>case</strong> (0, 0):
            print("Zero")
        <strong>case</strong> (real, 0) if real&gt;0:
            print(f"Positive real number {real}")
        <strong>case</strong> (real, 0):
            print(f"Negative real number {real}")
        <strong>case</strong> (0, imag) if imag&lt;0:
            print(f"Negative imaginary number {imag}")
        <strong>case</strong> (0, imag):
            print(f"Negative imaginary number {imag}")
        <strong>case</strong> (real, imag):
            print(f"Complex number {real}+i{imag}")
        <strong>case</strong> _:
            raise ValueError("Not a complex numbe")


test_number((0,0))
test_number((1,0))
test_number((-1,0))
test_number((0,1))
test_number((0,-1))
test_number((1,1))
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zpracování příkazů či strukturovaných textových souborů</h2>

<pre>
def perform_command():
    response = input("&gt; ")

    match response:
        case "quit":
            return "Quit"
        case "list employees":
            return "List employees"
        case "list departments":
            return "List departments"
        case "list rooms":
            return "List rooms"
        case _:
            return "Wrong command"


print(perform_command())
</pre>

<pre>
def perform_command():
    response = input("&gt; ")

    match response.split():
        case ["quit"]:
            return "Quit"
        case ["list", "employees"]:
            return "List employees"
        case ["list", "departments"]:
            return "List departments"
        case ["list", "rooms"]:
            return "List rooms"
        case _:
            return "Wrong command"


print(perform_command())
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Proměnné části víceslovních příkazů</h2>

<pre>
def perform_command():
    response = input("&gt; ")

    match response.split():
        case ["quit"]:
            return "Quit"
        case ["list", "employees"]:
            return "List employees"
        case ["list", "departments"]:
            return "List departments"
        case ["list", "rooms"]:
            return "List rooms"
        case ["info", subject]:
            return f"Info about subject '{subject}'"
        case _:
            return "Wrong command"


print(perform_command())
</pre>

<pre>
def perform_command():
    response = input("&gt; ")

    match response.split():
        case ["quit"]:
            return "Quit"
        case ["list", obj]:
            match obj:
                case "employees":
                    return "List employees"
                case "departments":
                    return "List departments"
                case "rooms":
                    return "List rooms"
                case _:
                    return "Invalid object type: employees, departments, or rooms expected"
        case ["info", subject]:
            return f"Info about subject '{subject}'"
        case _:
            return "Wrong command"


print(perform_command())
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Vnořené řídicí struktury <strong>match</strong></h2>

<pre>
def perform_command():
    response = input("&gt; ")

    match response.split():
        case ["quit"]:
            return "Quit"
        case ["list", ("employees" | "departments" | "rooms") as obj]:
            match obj:
                case "employees":
                    return "List employees"
                case "departments":
                    return "List departments"
                case "rooms":
                    return "List rooms"
        case ["info", subject]:
            return f"Info about subject '{subject}'"
        case _:
            return "Wrong command"


print(perform_command())
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Strukturální pattern matching a objekty</h2>

<pre>
class Complex():

    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __str__(self):
        return f"Complex number {self.real}+i{self.imag} represented as object"


def test_number(value):
    match value:
        case (0, 0):
            print("Zero")
        case (real, 0) if real&gt;0:
            print(f"Positive real number {real}")
        case (real, 0):
            print(f"Negative real number {real}")
        case (0, imag) if imag&lt;0:
            print(f"Negative imaginary number {imag}")
        case (0, imag):
            print(f"Negative imaginary number {imag}")
        case (real, imag):
            print(f"Complex number {real}+i{imag}")
        case Complex():
            print(value)
        case _:
            raise ValueError("Not a complex number")


test_number((0,0))
test_number((1,0))
test_number((-1,0))
test_number((0,1))
test_number((0,-1))
test_number((1,1))

test_number(Complex(0,0))
test_number(Complex(1,0))
test_number(Complex(-1,0))
test_number(Complex(0,1))
test_number(Complex(0,-1))
test_number(Complex(1,1))
</pre>

<pre>
from fractions import Fraction


class Complex():

    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __str__(self):
        return f"Complex number {self.real}+i{self.imag} represented as object"


def test_number(value):
    match value:
        case (0, 0):
            print("Zero")
        case (real, 0) if real&gt;0:
            print(f"Positive real number {real}")
        case (real, 0):
            print(f"Negative real number {real}")
        case (0, imag) if imag&lt;0:
            print(f"Negative imaginary number {imag}")
        case (0, imag):
            print(f"Negative imaginary number {imag}")
        case (real, imag):
            print(f"Complex number {real}+i{imag}")
        case Complex(real=0, imag=0):
            print(f"Zero complex represented as object")
        case Complex():
            print(value)
        case Fraction():
            print(f"Fraction {value}")
        case _:
            raise ValueError("Not a complex number")


test_number((0,0))
test_number((1,0))
test_number((-1,0))
test_number((0,1))
test_number((0,-1))
test_number((1,1))

test_number(Complex(0,0))
test_number(Complex(1,0))
test_number(Complex(-1,0))
test_number(Complex(0,1))
test_number(Complex(0,-1))
test_number(Complex(1,1))

test_number(Fraction(0,1))
test_number(Fraction(1,1))
test_number(Fraction(1,2))
test_number(Fraction(1,3))
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: část gramatiky Pythonu s&nbsp;pattern matchingem</h2>

<pre>
compound_stmt[stmt_ty]:
    | &amp;('def' | '@' | ASYNC) function_def
    | &amp;'if' if_stmt
    | &amp;('class' | '@') class_def
    | &amp;('with' | ASYNC) with_stmt
    | &amp;('for' | ASYNC) for_stmt
    | &amp;'try' try_stmt
    | &amp;'while' while_stmt
    | match_stmt
</pre>

<pre>
match_stmt[stmt_ty]:
    | "match" subject=subject_expr ':' NEWLINE INDENT cases[asdl_match_case_seq*]=case_block+ DEDENT {
        CHECK_VERSION(stmt_ty, 10, "Pattern matching is", _PyAST_Match(subject, cases, EXTRA)) }
    | invalid_match_stmt
subject_expr[expr_ty]:
    | value=star_named_expression ',' values=star_named_expressions? {
        _PyAST_Tuple(CHECK(asdl_expr_seq*, _PyPegen_seq_insert_in_front(p, value, values)), Load, EXTRA) }
    | named_expression
case_block[match_case_ty]:
    | invalid_case_block
    | "case" pattern=patterns guard=guard? ':' body=block {
        _PyAST_match_case(pattern, guard, body, p-&gt;arena) }
guard[expr_ty]: 'if' guard=named_expression { guard }
</pre>

<pre>
patterns[pattern_ty]:
    | patterns[asdl_pattern_seq*]=open_sequence_pattern {
        _PyAST_MatchSequence(patterns, EXTRA) }
    | pattern
pattern[pattern_ty]:
    | as_pattern
    | or_pattern
as_pattern[pattern_ty]:
    | pattern=or_pattern 'as' target=pattern_capture_target {
        _PyAST_MatchAs(pattern, target-&gt;v.Name.id, EXTRA) }
    | invalid_as_pattern
or_pattern[pattern_ty]:
    | patterns[asdl_pattern_seq*]='|'.closed_pattern+ {
        asdl_seq_LEN(patterns) == 1 ? asdl_seq_GET(patterns, 0) : _PyAST_MatchOr(patterns, EXTRA) }

closed_pattern[pattern_ty] (memo):
    | literal_pattern
    | capture_pattern
    | wildcard_pattern
    | value_pattern
    | group_pattern
    | sequence_pattern
    | mapping_pattern
    | class_pattern

# Literal patterns are used for equality and identity constraints
literal_pattern[pattern_ty]:
    | value=signed_number !('+' | '-') { _PyAST_MatchValue(value, EXTRA) }
    | value=complex_number { _PyAST_MatchValue(value, EXTRA) }
    | value=strings { _PyAST_MatchValue(value, EXTRA) }
    | 'None' { _PyAST_MatchSingleton(Py_None, EXTRA) }
    | 'True' { _PyAST_MatchSingleton(Py_True, EXTRA) }
    | 'False' { _PyAST_MatchSingleton(Py_False, EXTRA) }

# Literal expressions are used to restrict permitted mapping pattern keys
literal_expr[expr_ty]:
    | signed_number !('+' | '-')
    | complex_number
    | strings
    | 'None' { _PyAST_Constant(Py_None, NULL, EXTRA) }
    | 'True' { _PyAST_Constant(Py_True, NULL, EXTRA) }
    | 'False' { _PyAST_Constant(Py_False, NULL, EXTRA) }
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3.10 (nikoli ovšem pro starší verze Pythonu 3!) byly
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>abort_retry_fail_1.py</td><td>rozvětvení realizované konstrukcí <strong>if-elif-else</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_1.py</a></td></tr>
<tr><td> 2</td><td>abort_retry_fail_2.py</td><td>náhrada rozvětvení za mapu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_2.py</a></td></tr>
<tr><td> 3</td><td>abort_retry_fail_3.py</td><td>rozvětvení realizované konstrukcí <strong>match-case</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_3.py</a></td></tr>
<tr><td> 4</td><td>abort_retry_fail_4.py</td><td>složitější podmínky v&nbsp;konstrukci <strong>if-elif-else</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_4.py</a></td></tr>
<tr><td> 5</td><td>abort_retry_fail_5.py</td><td>konstrukce <strong>match-case</strong> a operátor <strong>or</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_5.py</a></td></tr>
<tr><td> 6</td><td>abort_retry_fail_6.py</td><td>zachycení hodnoty v&nbsp;konstrukci <strong>match-case</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/abort_retry_fail_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>factorial1.py</td><td>rekurzivní výpočet faktoriálu založený na konstrukci <strong>match-case</strong></strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/factorial1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/factorial1.py</a></td></tr>
<tr><td> 8</td><td>factorial2.py</td><td>dodatečný test ve větvi <strong>case</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/factorial2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/factorial2.py</a></td></tr>
<tr><td> 9</td><td>factorial3.py</td><td>dodatečné testy ve větvi <strong>case</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/factorial3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/factorial3.py</a></td></tr>
<tr><td>10</td><td>factorial4.py</td><td>operátor <strong>or</strong> ve větvi <strong>case</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/factorial4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/factorial4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>complex1.py</td><td>test hodnot v&nbsp;n-ticích, zachytávání hodnot</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/complex1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/complex1.py</a></td></tr>
<tr><td>12</td><td>complex2.py</td><td>test hodnot v&nbsp;n-ticích, zachytávání hodnot</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/complex2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/complex2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>multiword_commands_1.py</td><td>zpracování víceslovních příkazů, základní varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_1.py</a></td></tr>
<tr><td>14</td><td>multiword_commands_2.py</td><td>zpracování víceslovních příkazů, zpracování rozděleného příkazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_2.py</a></td></tr>
<tr><td>15</td><td>multiword_commands_3.py</td><td>zpracování víceslovních příkazů, zachycení druhého slova</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_3.py</a></td></tr>
<tr><td>16</td><td>multiword_commands_4.py</td><td>zpracování víceslovních příkazů, vnořené struktury <strong>match-case</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_4.py</a></td></tr>
<tr><td>17</td><td>multiword_commands_5.py</td><td>zpracování víceslovních příkazů, vnořené struktury <strong>match-case</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/multiword_commands_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>object1.py</td><td>test na typ objektu v&nbsp;konstrukci <strong>match-case</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/object1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/object1.py</a></td></tr>
<tr><td>19</td><td>object2.py</td><td>test na typ a hodnotu objektu v&nbsp;konstrukci <strong>match-case</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/object2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pattern_matching/object2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Pattern matching (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Pattern_matching">https://en.wikipedia.org/wiki/Pattern_matching</a>
</li>

Python 3.10 and the Elegance of Pattern Matching
https://python.plainenglish.io/python-3-10-and-the-elegance-of-pattern-matching-2620a02b2379

<li>More Pattern Matching in Python 3.10<br />
<a href="https://towardsdatascience.com/more-advanced-pattern-matching-in-python-3-10-2dbd8598302a">https://towardsdatascience.com/more-advanced-pattern-matching-in-python-3-10-2dbd8598302a</a>
</li>

<li>Pattern Matching in Python 3.10<br />
<a href="https://towardsdatascience.com/pattern-matching-in-python-3-10-6124ff2079f0">https://towardsdatascience.com/pattern-matching-in-python-3-10-6124ff2079f0</a>
</li>

<li>Python 3.10.0<br />
<a href="https://www.python.org/downloads/release/python-3100/">https://www.python.org/downloads/release/python-3100/</a>
</li>

<li>PEP 634 – Structural Pattern Matching: Specification<br />
<a href="https://peps.python.org/pep-0634/">https://peps.python.org/pep-0634/</a>
</li>

<li>PEP 635 – Structural Pattern Matching: Motivation and Rationale<br />
<a href="https://peps.python.org/pep-0635/">https://peps.python.org/pep-0635/</a>
</li>

<li>PEP 636 – Structural Pattern Matching: Tutorial<br />
<a href="https://peps.python.org/pep-0636/">https://peps.python.org/pep-0636/</a>
</li>

<li>PEP 622 – Structural Pattern Matching<br />
<a href="https://peps.python.org/pep-0622/">https://peps.python.org/pep-0622/</a>
</li>

<li>Python 3.10 se strukturálním pattern matchingem<br />
<a href="https://www.root.cz/zpravicky/python-3-10-se-strukturalnim-pattern-matchingem/">https://www.root.cz/zpravicky/python-3-10-se-strukturalnim-pattern-matchingem/</a>
</li>

<li>Coconut: funkcionální jazyk s pattern matchingem kompatibilní s Pythonem<br />
<a href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/</a>
</li>

<li>How to Install Python 3.10 on CentOS/RHEL 8 &amp; Fedora 35/34<br />
<a href="https://tecadmin.net/how-to-install-python-3-10-on-centos-rhel-8-fedora/">https://tecadmin.net/how-to-install-python-3-10-on-centos-rhel-8-fedora/</a>
</li>

<li>Pattern matching functions in Clojure?<br />
<a href="https://stackoverflow.com/questions/8596980/pattern-matching-functions-in-clojure">https://stackoverflow.com/questions/8596980/pattern-matching-functions-in-clojure</a>
</li>

<li>Clojure core.match<br />
<a href="https://github.com/clojure/core.match">https://github.com/clojure/core.match</a>
</li>

<li>The Rust Programming Language: Patterns and Matching<br />
<a href="https://doc.rust-lang.org/book/ch18-00-patterns.html#patterns-and-matching">https://doc.rust-lang.org/book/ch18-00-patterns.html#patterns-and-matching</a>
</li>

<li>The Rust Programming Language: Pattern Syntax<br />
<a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html">https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html</a>
</li>

<li>Coconut: funkcionální jazyk s pattern matchingem kompatibilní s Pythonem<br />
<a href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/</a>
</li>

<li>Coconut aneb funkcionální nadstavba nad Pythonem (2.část)<br />
<a href="https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/">https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/</a>
</li>

<li>Programovací jazyky používané v SSSR (část 2 – SNOBOL)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-v-sssr-cast-2-ndash-snobol/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-v-sssr-cast-2-ndash-snobol/</a>
</li>

<li>Coconut: Simple, elegant, Pythonic functional programming<br />
<a href="http://coconut-lang.org/">http://coconut-lang.org/</a>
</li>

<li>Parsing expression grammar<br />
<a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">https://en.wikipedia.org/wiki/Parsing_expression_grammar</a>
</li>

<li>Abort, Retry, Fail?<br />
<a href="https://en.wikipedia.org/wiki/Abort,_Retry,_Fail%3F">https://en.wikipedia.org/wiki/Abort,_Retry,_Fail%3F</a>
</li>

<li>SNOBOL4 and SPITBOL Information<br />
<a href="http://www.snobol4.com/">http://www.snobol4.com/</a>
</li>

<li>Vanilla Snobol4 Reference Manual<br />
<a href="http://burks.bton.ac.uk/burks/language/snobol/catspaw/manual/contents.htm">http://burks.bton.ac.uk/burks/language/snobol/catspaw/manual/contents.htm</a>
</li>

<li>SNOBOL4.ORG &ndash; SNOBOL4 Resources<br />
<a href="http://www.snobol4.org/">http://www.snobol4.org/</a>
</li>

<li>Snobol3 &ndash; Snobol 3 Interpreter Implemented in Java<br />
<a href="http://serl.cs.colorado.edu/~dennis/software/s3.html">http://serl.cs.colorado.edu/~dennis/software/s3.html</a>
</li>

<li>Exploring Beautiful Languages &ndash; A guick look at SNOBOL<br />
<a href="http://langexplr.blogspot.com/2007/12/quick-look-at-snobol.html">http://langexplr.blogspot.com/2007/12/quick-look-at-snobol.html</a>
</li>

<li>Rosetta Code: Roman_numerals<br />
<a href="http://rosettacode.org/wiki/Roman_numerals">http://rosettacode.org/wiki/Roman_numerals</a>
</li>

<li>Category:SNOBOL4<br />
<a href="http://rosettacode.org/wiki/Category:SNOBOL4">http://rosettacode.org/wiki/Category:SNOBOL4</a>
</li>

<li>An introduction to SNOBOL by James Ford<br />
<a href="http://drofmij.awardspace.com/snobol/">http://drofmij.awardspace.com/snobol/</a>
</li>

<li>AWK<br />
<a href="https://en.wikipedia.org/wiki/AWK">https://en.wikipedia.org/wiki/AWK</a>
</li>

<li>Get started with GAWK: AWK language fundamentals<br />
<a href="https://web.archive.org/web/20150427143548/https://www6.software.ibm.com/developerworks/education/au-gawk/au-gawk-a4.pdf">https://web.archive.org/web/20150427143548/https://www6.software.ibm.com/developerworks/education/au-gawk/au-gawk-a4.pdf</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

