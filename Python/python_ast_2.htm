<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o lexikální a syntaktické analýze zdrojových kódů napsaných v Pythonu si nejdříve řekneme, jak jsou tokenizovány pythonovské bloky. Následně se budeme zabývat konstrukcí a zobrazením abstraktního syntaktického stromu (AST). Nakonec si ukážeme, jak lze AST přeložit a spustit.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Tokenizace bloků v&nbsp;Pythonu</a></p>
<p><a href="#k02">2. Ukázka použití tokenů <strong>INDENT</strong> a <strong>DEDENT</strong></a></p>
<p><a href="#k03">3. Tokenizace kódu s&nbsp;vnořenými úplnými konstrukcemi <strong>if-else</strong></a></p>
<p><a href="#k04">4. Realizace průchodu AST</a></p>
<p><a href="#k05">5. Rekurzivní průchod AST s&nbsp;pevně daným pořadím procházení uzly</a></p>
<p><a href="#k06">6. Rekurzivní průchod AST se zvýrazněním úrovně</a></p>
<p><a href="#k07">7. Grafická vizualizace AST</a></p>
<p><a href="#k08">8. Vizualizace AST jednoduchého výrazu</a></p>
<p><a href="#k09">9. Vizualizace AST programu pro výpočet prvočísel</a></p>
<p><a href="#k10">10. Vizualizace AST programu pro provádění asynchronních operací</a></p>
<p><a href="#k11">11. Rozpoznání uzlů tvořících algebraický výraz</a></p>
<p><a href="#k12">12. Algebraický výraz s&nbsp;proměnnými</a></p>
<p><a href="#k13">13. Překlad AST s&nbsp;jeho spuštěním</a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Tokenizace bloků v&nbsp;Pythonu</h2>

<p><a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/nazory/">V&nbsp;diskuzi</a>
pod <a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">úvodním
článkem</a> zazněl mj.&nbsp;i <a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/nazory/vlakno/1/">zajímavý
dotaz</a>, jak se v&nbsp;tokenizovaném kódu vlastně rozeznávají začátky a konce
bloků.  V&nbsp;&bdquo;klasických&ldquo; lexerech (tedy nástrojích provádějících
tokenizaci) určených například pro zpracování zdrojových kódu v&nbsp;jazyku C
či Pythonu, se běžně pracuje s&nbsp;tokeny reprezentujícími znaky
&bdquo;{&ldquo; a &bdquo;}&ldquo; popř.&nbsp;slova <strong>begin</strong> a
<strong>end</strong> &ndash; samotný lexer ovšem tyto tokeny dále nerozlišuje
(tj.&nbsp;například neví, zda znak &bdquo;{&ldquo; reprezentuje začátek
programového bloku nebo deklaraci struktury). Naproti tomu v&nbsp;lexeru
Pythonu je tomu poněkud jinak, protože bloky jsou značeny odsazením.
Z&nbsp;tohoto důvodu lexer (s&nbsp;využitím k&nbsp;tomu určené <a
href="https://github.com/python/cpython/blob/3.10/Lib/tokenize.py#L509">speciální
logiky</a>) rozlišuje tokeny <strong>INDENT</strong> a
<strong>DEDENT</strong>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Ukázka použití tokenů <strong>INDENT</strong> a <strong>DEDENT</strong></h2>

<p>Pro otestování, jakým způsobem se v&nbsp;tokenizovaném kódu rozeznávají
začátky a konce bloků s&nbsp;využitím tokenů <strong>INDENT</strong> a
<strong>DEDENT</strong>, se pokusíme o tokenizaci tohoto zdrojového kódu
s&nbsp;trojicí vnořených bloků <strong>if</strong> (to, jaká podmínka se
testuje, je v&nbsp;dané chvíli nepodstatné):</p>

<pre>
if True:
    if False:
        if False and True:
            print("impossible")
</pre>

<p>Tokenizaci provedeme tímto skriptem:</p>

<pre>
import tokenize
&nbsp;
with tokenize.open("ifs1.py") as fin:
    token_generator = tokenize.generate_tokens(fin.readline)
    for token in token_generator:
        print(token)
</pre>

<p>Výsledkem tokenizace s&nbsp;využitím výše uvedeného skriptu je sekvence
tokenů, v&nbsp;nichž jsou zvýrazněny právě tokeny <strong>INDENT</strong> a
<strong>DEDENT</strong>. Povšimněte si toho, že token <strong>INDENT</strong>
je vždy prvním tokenem na prvním odsazeném řádku bloku. Naproti tomu token
<strong>DEDENT</strong> je &bdquo;hlášen&ldquo; na prázdném řádku:</p>

<pre>
TokenInfo(type=1  (NAME),      string='if',           start=(1, 0),  end=(1, 2),  line='if True:\n')
TokenInfo(type=1  (NAME),      string='True',         start=(1, 3),  end=(1, 7),  line='if True:\n')
TokenInfo(type=54 (OP),        string=':',            start=(1, 7),  end=(1, 8),  line='if True:\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(1, 8),  end=(1, 9),  line='if True:\n')
<strong>TokenInfo(type=5  (INDENT),    string='    ',         start=(2, 0),  end=(2, 4),  line='    if False:\n')</strong>
TokenInfo(type=1  (NAME),      string='if',           start=(2, 4),  end=(2, 6),  line='    if False:\n')
TokenInfo(type=1  (NAME),      string='False',        start=(2, 7),  end=(2, 12), line='    if False:\n')
TokenInfo(type=54 (OP),        string=':',            start=(2, 12), end=(2, 13), line='    if False:\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(2, 13), end=(2, 14), line='    if False:\n')
<strong>TokenInfo(type=5  (INDENT),    string='        ',     start=(3, 0),  end=(3, 8),  line='        if False and True:\n')</strong>
TokenInfo(type=1  (NAME),      string='if',           start=(3, 8),  end=(3, 10), line='        if False and True:\n')
TokenInfo(type=1  (NAME),      string='False',        start=(3, 11), end=(3, 16), line='        if False and True:\n')
TokenInfo(type=1  (NAME),      string='and',          start=(3, 17), end=(3, 20), line='        if False and True:\n')
TokenInfo(type=1  (NAME),      string='True',         start=(3, 21), end=(3, 25), line='        if False and True:\n')
TokenInfo(type=54 (OP),        string=':',            start=(3, 25), end=(3, 26), line='        if False and True:\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(3, 26), end=(3, 27), line='        if False and True:\n')
<strong>TokenInfo(type=5  (INDENT),    string='            ', start=(4, 0),  end=(4, 12), line='            print("impossible")\n')</strong>
TokenInfo(type=1  (NAME),      string='print',        start=(4, 12), end=(4, 17), line='            print("impossible")\n')
TokenInfo(type=54 (OP),        string='(',            start=(4, 17), end=(4, 18), line='            print("impossible")\n')
TokenInfo(type=3  (STRING),    string='"impossible"', start=(4, 18), end=(4, 30), line='            print("impossible")\n')
TokenInfo(type=54 (OP),        string=')',            start=(4, 30), end=(4, 31), line='            print("impossible")\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(4, 31), end=(4, 32), line='            print("impossible")\n')
<strong>TokenInfo(type=6  (DEDENT),    string='',             start=(5, 0),  end=(5, 0),  line='')</strong>
<strong>TokenInfo(type=6  (DEDENT),    string='',             start=(5, 0),  end=(5, 0),  line='')</strong>
<strong>TokenInfo(type=6  (DEDENT),    string='',             start=(5, 0),  end=(5, 0),  line='')</strong>
TokenInfo(type=0  (ENDMARKER), string='',             start=(5, 0),  end=(5, 0),  line='')
</pre>                                                                            



<p><a name="k03"></a></p>
<h2 id="k03">3. Tokenizace kódu s&nbsp;vnořenými úplnými konstrukcemi <strong>if-else</strong></h2>

<p>Nyní si vyzkoušejme, jakým způsobem bude tokenizován následující programový
kód, který obsahuje trojici vnořených <i>úplných</i> programových smyček
<strong>if-else</strong>:</p>

<pre>
if True:
    if False:
        if False and True:
            print("impossible")
        else:
            print("possible")
    else:
        pass
else:
    pass
</pre>

<p>Pro tokenizaci výše uvedeného příkladu je použit tento jednoduchý
skript:</p>

<pre>
import tokenize
&nbsp;
with tokenize.open("ifs2.py") as fin:
    token_generator = tokenize.generate_tokens(fin.readline)
    for token in token_generator:
        print(token)
</pre>

<p>Výsledná sekvence tokenů vypadá následovně. Opět jsou zvýrazněny tokeny
<strong>INDENT</strong> a <strong>DEDENT</strong>:</p>

<pre>
TokenInfo(type=1  (NAME),      string='if',           start=(1, 0),  end=(1, 2),  line='if True:\n')
TokenInfo(type=1  (NAME),      string='True',         start=(1, 3),  end=(1, 7),  line='if True:\n')
TokenInfo(type=54 (OP),        string=':',            start=(1, 7),  end=(1, 8),  line='if True:\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(1, 8),  end=(1, 9),  line='if True:\n')
<strong>TokenInfo(type=5  (INDENT),    string='    ',         start=(2, 0),  end=(2, 4),  line='    if False:\n')</strong>
TokenInfo(type=1  (NAME),      string='if',           start=(2, 4),  end=(2, 6),  line='    if False:\n')
TokenInfo(type=1  (NAME),      string='False',        start=(2, 7),  end=(2, 12), line='    if False:\n')
TokenInfo(type=54 (OP),        string=':',            start=(2, 12), end=(2, 13), line='    if False:\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(2, 13), end=(2, 14), line='    if False:\n')
<strong>TokenInfo(type=5  (INDENT),    string='        ',     start=(3, 0),  end=(3, 8),  line='        if False and True:\n')</strong>
TokenInfo(type=1  (NAME),      string='if',           start=(3, 8),  end=(3, 10), line='        if False and True:\n')
TokenInfo(type=1  (NAME),      string='False',        start=(3, 11), end=(3, 16), line='        if False and True:\n')
TokenInfo(type=1  (NAME),      string='and',          start=(3, 17), end=(3, 20), line='        if False and True:\n')
TokenInfo(type=1  (NAME),      string='True',         start=(3, 21), end=(3, 25), line='        if False and True:\n')
TokenInfo(type=54 (OP),        string=':',            start=(3, 25), end=(3, 26), line='        if False and True:\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(3, 26), end=(3, 27), line='        if False and True:\n')
<strong>TokenInfo(type=5  (INDENT),    string='            ', start=(4, 0),  end=(4, 12), line='            print("impossible")\n')</strong>
TokenInfo(type=1  (NAME),      string='print',        start=(4, 12), end=(4, 17), line='            print("impossible")\n')
TokenInfo(type=54 (OP),        string='(',            start=(4, 17), end=(4, 18), line='            print("impossible")\n')
TokenInfo(type=3  (STRING),    string='"impossible"', start=(4, 18), end=(4, 30), line='            print("impossible")\n')
TokenInfo(type=54 (OP),        string=')',            start=(4, 30), end=(4, 31), line='            print("impossible")\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(4, 31), end=(4, 32), line='            print("impossible")\n')
<strong>TokenInfo(type=6  (DEDENT),    string='',             start=(5, 8),  end=(5, 8),  line='        else:\n')</strong>
TokenInfo(type=1  (NAME),      string='else',         start=(5, 8),  end=(5, 12), line='        else:\n')
TokenInfo(type=54 (OP),        string=':',            start=(5, 12), end=(5, 13), line='        else:\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(5, 13), end=(5, 14), line='        else:\n')
<strong>TokenInfo(type=5  (INDENT),    string='            ', start=(6, 0),  end=(6, 12), line='            print("possible")\n')</strong>
TokenInfo(type=1  (NAME),      string='print',        start=(6, 12), end=(6, 17), line='            print("possible")\n')
TokenInfo(type=54 (OP),        string='(',            start=(6, 17), end=(6, 18), line='            print("possible")\n')
TokenInfo(type=3  (STRING),    string='"possible"',   start=(6, 18), end=(6, 28), line='            print("possible")\n')
TokenInfo(type=54 (OP),        string=')',            start=(6, 28), end=(6, 29), line='            print("possible")\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(6, 29), end=(6, 30), line='            print("possible")\n')
<strong>TokenInfo(type=6  (DEDENT),    string='',             start=(7, 4),  end=(7, 4),  line='    else:\n')</strong>
<strong>TokenInfo(type=6  (DEDENT),    string='',             start=(7, 4),  end=(7, 4),  line='    else:\n')</strong>
TokenInfo(type=1  (NAME),      string='else',         start=(7, 4),  end=(7, 8),  line='    else:\n')
TokenInfo(type=54 (OP),        string=':',            start=(7, 8),  end=(7, 9),  line='    else:\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(7, 9),  end=(7, 10), line='    else:\n')
<strong>TokenInfo(type=5  (INDENT),    string='        ',     start=(8, 0),  end=(8, 8),  line='        pass\n')</strong>
TokenInfo(type=1  (NAME),      string='pass',         start=(8, 8),  end=(8, 12), line='        pass\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(8, 12), end=(8, 13), line='        pass\n')
<strong>TokenInfo(type=6  (DEDENT),    string='',             start=(9, 0),  end=(9, 0),  line='else:\n')</strong>
<strong>TokenInfo(type=6  (DEDENT),    string='',             start=(9, 0),  end=(9, 0),  line='else:\n')</strong>
TokenInfo(type=1  (NAME),      string='else',         start=(9, 0),  end=(9, 4),  line='else:\n')
TokenInfo(type=54 (OP),        string=':',            start=(9, 4),  end=(9, 5),  line='else:\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(9, 5),  end=(9, 6),  line='else:\n')
<strong>TokenInfo(type=5  (INDENT),    string='    ',         start=(10, 0), end=(10, 4), line='    pass\n')</strong>
TokenInfo(type=1  (NAME),      string='pass',         start=(10, 4), end=(10, 8), line='    pass\n')
TokenInfo(type=4  (NEWLINE),   string='\n',           start=(10, 8), end=(10, 9), line='    pass\n')
<strong>TokenInfo(type=6  (DEDENT),    string='',             start=(11, 0), end=(11, 0), line='')</strong>
TokenInfo(type=0  (ENDMARKER), string='',             start=(11, 0), end=(11, 0), line='')
</pre>                                               
                                                     


<p><a name="k04"></a></p>
<h2 id="k04">4. Realizace průchodu AST</h2>

<p>Podívejme se nyní na způsob realizace průchodu abstraktním datovým stromem.
Zcela nejjednodušší způsob spočívá v&nbsp;parsingu zdrojového kódu do AST
(pochopitelně přes lexer), čímž získáme objekt obsahující všechny uzly AST.
S&nbsp;využitím funkce <strong>walk</strong> lze projít všemi uzly tohoto
stromu, což lze v&nbsp;Pythonu realizovat jednoduše:</p>

<pre>
import ast
&nbsp;
tree = ast.parse("1+2*3")
&nbsp;
for node in ast.walk(tree):
    print(node)
</pre>

<p>Výsledkem bude výpis devíti uzlů AST, ovšem bez podrobnějších informací:</p>

<pre>
$ <strong>python3 traverse_expression_1.py </strong>
&nbsp;
&lt;_ast.Module object at 0x7fbbc9c230d0&gt;
&lt;_ast.Expr object at 0x7fbbc9c234f0&gt;
&lt;_ast.BinOp object at 0x7fbbc9c23250&gt;
&lt;_ast.Constant object at 0x7fbbc9b5f550&gt;
&lt;_ast.Add object at 0x7fbbc9b80dc0&gt;
&lt;_ast.BinOp object at 0x7fbbc9b5f6a0&gt;
&lt;_ast.Constant object at 0x7fbbc9b5f730&gt;
&lt;_ast.Mult object at 0x7fbbc9b80e80&gt;
&lt;_ast.Constant object at 0x7fbbc9b5f7f0&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: ze zobrazeného výsledku je patrné, že
jednotlivé typy uzlů jsou reprezentovány speciálními objekty. K&nbsp;jejich
významu se ještě vrátíme.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rekurzivní průchod AST s&nbsp;pevně daným pořadím procházení uzly</h2>

<p>Průchod uzly AST ukázaný <a href="#k05">v&nbsp;předchozí kapitole</a> není
příliš vhodný ve chvíli, kdy potřebujeme stromem procházet <a
href="https://towardsdatascience.com/4-types-of-tree-traversal-algorithms-d56328450846">v&nbsp;určitém
pořadí uzlů</a> &ndash; inorder, preorder či postorder, filtrovat nezajímavé
uzly, nebo dokonce když potřebujeme AST nějakým způsobem modifikovat.
V&nbsp;takových případech je vhodnější využít návrhového vzoru <i>Visitor</i>,
který je založen na volání callback metody <strong>visit</strong> pro každý
navštívený uzel. V&nbsp;případě, že tento uzel obsahuje poduzly, lze je
navštívit zavoláním metody <strong>generic_visit</strong> (tedy
rekurzivně):</p>

<p>Realizace algoritmu pro průchod AST je díky podpoře návrhového vzoru
<i>Visitor</i> triviální. Povšimněte si, jak rekurzivně voláme metodu
<strong>generic_visit</strong> při návštěvě uzlu:</p>

<pre>
import ast
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>visit</strong>(self, node):
        print(node)
        <strong>self.generic_visit(node)</strong>
&nbsp;
&nbsp;
tree = ast.parse("1+2*3")
&nbsp;
visitor = <strong>Visitor()</strong>
<strong>visitor.visit(tree)</strong>
</pre>

<p>Výsledkem bude opět devět uzlů:</p>

<pre>
$ <strong>python3 traverse_expression_2.py </strong>
&nbsp;
&lt;_ast.Module object at 0x7f59ac3320d0&gt;
&lt;_ast.Expr object at 0x7f59ac3324f0&gt;
&lt;_ast.BinOp object at 0x7f59ac26d610&gt;
&lt;_ast.Constant object at 0x7f59ac26d640&gt;
&lt;_ast.Add object at 0x7f59ac28fe50&gt;
&lt;_ast.BinOp object at 0x7f59ac26d820&gt;
&lt;_ast.Constant object at 0x7f59ac26d880&gt;
&lt;_ast.Mult object at 0x7f59ac28ff10&gt;
&lt;_ast.Constant object at 0x7f59ac26d8e0&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: sami si vyzkoušejte, co se stane ve
chvíli, kdy se prohodí volání funkce <strong>print</strong> a metody
<strong>generic_visit</strong>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rekurzivní průchod AST se zvýrazněním úrovně</h2>

<p>Vzhledem k&nbsp;tomu, že i pro jednoduchý výraz obsahuje AST uzly
v&nbsp;několika úrovních, bude vhodné si tyto úrovně nějakým způsobem
zvýraznit. Pomoci si můžeme malým trikem &ndash; zapamatováním úrovně, ve které
se při zpracování uzlů právě nacházíme. To je z&nbsp;implementačního pohledu
snadné; postačuje pouze do naší třídy <strong>Visitor</strong> přidat
(nestatický) atribut, do něhož bude uložena úroveň právě zpracovávaného uzlu.
Při průchodu podstromem se tato úroveň o jedničku zvýší, po dokončení průchodu
opět sníží. A číselnou hodnotu úrovně lze následně použít například pro
odsazení uzlů v&nbsp;podstromech. Upravený kód může vypadat následovně:</p>

<pre>
import ast
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 1
&nbsp;
    def <strong>visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        <strong>self.generic_visit(node)</strong>
        self.nest_level -= 1
&nbsp;
&nbsp;
tree = ast.parse("1+2*3+1")
&nbsp;
visitor = <strong>Visitor()</strong>
<strong>visitor.visit(tree)</strong>
</pre>

<p>Nyní bude již výsledek čitelnější (i když ne příliš):</p>

<pre>
$ <strong>python3 traverse_expression_3.py </strong>
&nbsp;
   &lt;_ast.Module object at 0x7f21f20fc0d0&gt;
     &lt;_ast.Expr object at 0x7f21f20fc4f0&gt;
       &lt;_ast.BinOp object at 0x7f21f20376d0&gt;
         &lt;_ast.BinOp object at 0x7f21f2037700&gt;
           &lt;_ast.Constant object at 0x7f21f20377f0&gt;
           &lt;_ast.Add object at 0x7f21f2059ee0&gt;
           &lt;_ast.BinOp object at 0x7f21f2037910&gt;
             &lt;_ast.Constant object at 0x7f21f2037940&gt;
             &lt;_ast.Mult object at 0x7f21f2059fa0&gt;
             &lt;_ast.Constant object at 0x7f21f2037a00&gt;
         &lt;_ast.Add object at 0x7f21f2059ee0&gt;
         &lt;_ast.Constant object at 0x7f21f2037880&gt;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Grafická vizualizace AST</h2>

<p>AST je formou stromové datové struktury, která se na klasickém terminálu
zobrazuje poměrně špatně &ndash; informace totiž na ploše terminálu obsazují
hodně místa a přesto nejsou patrné vazby mezi jednotlivými uzly stromu.
Z&nbsp;tohoto důvodu je vhodnější si AST zobrazit graficky. V&nbsp;konkrétním
případě programovacího jazyka Python a jeho standardního balíčku
<strong>ast</strong> slouží pro vizualizaci AST nástroj nazvaný přímočaře
<strong>python-ast-visualizer</strong>. Ten transformuje AST do podoby
kompatibilní s&nbsp;nástrojem <i>Graphviz</i> (viz též <a
href="https://www.root.cz/clanky/tvorba-grafu-a-diagramu-s-vyuzitim-domenove-specifickeho-jazyka-nastroje-graphviz/">tento
článek</a>). Následně je zavolán <i>Graphviz</i>, který AST vykreslí do
vektorového obrázku uloženého do formátu PDF.</p>

<p>Nástroj <strong>python-ast-visualizer</strong> lze nainstalovat přes PyPi
nebo přímo naklonováním repositáře s&nbsp;jeho zdrojovými kódy:</p>

<pre>
$ <strong>git clone git@github.com:pombredanne/python-ast-visualizer.git</strong>
&nbsp;
Cloning into 'python-ast-visualizer'...
remote: Enumerating objects: 14, done.
remote: Counting objects: 100% (6/6), done.
remote: Compressing objects: 100% (2/2), done.
Receiving objects: 100% (14/14), done.
Resolving deltas: 100% (5/5), done.
remote: Total 14 (delta 4), reused 4 (delta 4), pack-reused 8
</pre>

<p>Tento nástroj je realizován skriptem a lze ho spustit následovně:</p>

<pre>
$ <strong>python3 astvisualizer.py --help</strong>
&nbsp;
Usage: astvisualizer.py [options] [string]
&nbsp;
Options:
  -h, --help            show this help message and exit
  -f FILE, --file=FILE  Read a code snippet from the specified file
  -l LABEL, --label=LABEL
                        The label for the visualization
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vizualizace AST jednoduchého výrazu</h2>

<p>Vyzkoušejme si nyní, jak vlastně bude vypadat vizualizace AST pro velmi
jednoduchý výraz, konkrétně pro tento výraz:</p>

<pre>
1+2*3
</pre>

<p>Vizualizace se provede příkazem:</p>

<pre>
$ <strong>python3 astvisualizer.py -f expression2.py</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<img src="https://i.iinfo.cz/images/181/python-ast-02-1.png" class="image-579221" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="436" height="754" />
<p><i>Obrázek 1: AST s&nbsp;vizualizací výrazu 1+2*3.</i></p>

<p><div class="rs-tip-major">Poznámka: z&nbsp;AST je patrné, že podvýraz 2*3
bude vyhodnocen dříve, protože se jedná o binární operaci s&nbsp;vyšší
prioritou. Tudíž je celý tento podvýraz reprezentován podstromem (zvýrazněno po
konstrukci AST v&nbsp;grafickém editoru).</div></p>

<p>Nyní výraz pozměníme přidáním závorek, které změní prioritu operací:</p>

<pre>
(1+2)*3
</pre>

<p>Výsledek bude v&nbsp;tomto případě vypadat následovně:</p>

<img src="https://i.iinfo.cz/images/181/python-ast-02-2.png" class="image-579222" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="426" height="755" />
<p><i>Obrázek 2: AST s&nbsp;vizualizací výrazu (1+2)*3.</i></p>

<p><div class="rs-tip-major">Poznámka: nyní bude naopak nejdříve vyhodnocen
podvýraz 1+2 (zvýrazněno). Povšimněte si, že v&nbsp;AST již není informace o
závorkách.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vizualizace AST programu pro výpočet prvočísel</h2>

<p>AST jednoduchého výrazu obsahuje malé množství uzlů, takže je možné obraz
celého AST jednoduše vložit i do dnešního článku, což jsme ostatně mohli vidět
i <a href="#k08">v&nbsp;předchozí kapitole</a>. Jak však bude vypadat AST
složitějšího kódu, například funkce pro výpočet prvočísel, s&nbsp;níž jsme se
již seznámili <a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">minule</a>?</p>

<pre>
<i># originální kód lze nalézt na adrese:</i>
<i># http://www.rosettacode.org/wiki/Sieve_of_Eratosthenes#Using_array_lookup</i>
def <strong>primes2</strong>(limit):
    <i>"""Výpočet seznamu prvočísel až do zadaného limitu."""</i>
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)):  # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False
    return [i for i, prime in enumerate(is_prime) if prime]
&nbsp;
&nbsp;
print(primes2(100))
</pre>

<p>Celý AST již v&nbsp;takovém případě obsahuje desítky až nižší stovky
uzlů:</p>

<a href="https://www.root.cz/obrazek/579223/"><img src="https://i.iinfo.cz/images/181/python-ast-02-3-prev.png" class="image-579223" data-prev-filename="https://i.iinfo.cz/images/181/python-ast-02-3-prev.png" data-prev-width="370" data-prev-height="169" data-large-filename="https://i.iinfo.cz/images/181/python-ast-02-3-large.png" data-large-width="720" data-large-height="330" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="370" height="169" /></a>
<p><i>Obrázek 3: AST popisující algoritmus pro výpočet prvočísel.</i></p>

<p>Bližší pohled na AST odhaluje, s&nbsp;jakými typy uzlů se zde můžeme
setkat:</p>

<a href="https://www.root.cz/obrazek/579224/"><img src="https://i.iinfo.cz/images/181/python-ast-02-4-prev.png" class="image-579224" data-prev-filename="https://i.iinfo.cz/images/181/python-ast-02-4-prev.png" data-prev-width="370" data-prev-height="214" data-large-filename="https://i.iinfo.cz/images/181/python-ast-02-4-large.png" data-large-width="720" data-large-height="417" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="370" height="214" /></a>
<p><i>Obrázek 4: Podrobnější pohled na AST popisující algoritmus pro výpočet
prvočísel.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vizualizace AST programu pro provádění asynchronních operací</h2>

<p>Do Pythonu 3.5 byla přidána nová klíčová slova <strong>async</strong> a
<strong>await</strong> určená pro tvorbu a koordinaci souběžně běžících úloh,
což je téma, s&nbsp;nímž jsme se na Rootu seznámili v&nbsp;následujících
článcích:</p>

<ol>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – Curio a Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – závěrečné zhodnocení<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/</a>
</li>

</ol>

<p>Víme již, že při tokenizaci se tato <a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/#k09">klíčová
slova nerozeznávají</a>, ovšem ve výsledném AST již budou mít speciální uzly.
Ostatně můžeme se o tom přesvědčit velmi snadno, a to převodem následujícího
kódu do AST:</p>

<pre>
import trio
&nbsp;
&nbsp;
<strong>async def</strong> producer(send_channel):
    for i in range(1, 10):
        message = f"message {i}"
        print(f"Producer: {message}")
        <strong>await</strong> send_channel.send(message)
&nbsp;
&nbsp;
<strong>async def</strong> consumer(receive_channel):
    <strong>async for</strong> value in receive_channel:
        print(f"Consumer: received{value!r}")
        <strong>await</strong> trio.sleep(1)
&nbsp;
&nbsp;
<strong>async def</strong> main():
    <strong>async with</strong> trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        nursery.start_soon(producer, send_channel)
        nursery.start_soon(consumer, receive_channel)
&nbsp;
&nbsp;
trio.run(main)
</pre>

<p>AST zkonstruovaný z&nbsp;tohoto zdrojového kódu vypadá následovně (opět se
jedná o desítky až menší stovky uzlů):</p>

<a href="https://www.root.cz/obrazek/579225/"><img src="https://i.iinfo.cz/images/181/python-ast-02-5-prev.png" class="image-579225" data-prev-filename="https://i.iinfo.cz/images/181/python-ast-02-5-prev.png" data-prev-width="370" data-prev-height="103" data-large-filename="https://i.iinfo.cz/images/181/python-ast-02-5-large.png" data-large-width="720" data-large-height="201" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="370" height="103" /></a>
<p><i>Obrázek 5: Celý AST s&nbsp;funkcemi používajícími klíčová slova
<strong>async</strong> a <strong>await</strong>.</i></p>

<p>Zajímavější bude se podívat na konkrétní uzly, které souvisí s&nbsp;klíčovým
slovem <strong>async</strong>. Konkrétně se jedná o uzly s&nbsp;definicí
asynchronní funkce, asynchronní smyčky <i>for</i> a asynchronní smyčky
<i>with</i> (tedy se třemi uzly různého typu):</p>

<a href="https://www.root.cz/obrazek/579226/"><img src="https://i.iinfo.cz/images/181/python-ast-02-6-prev.png" class="image-579226" data-prev-filename="https://i.iinfo.cz/images/181/python-ast-02-6-prev.png" data-prev-width="370" data-prev-height="214" data-large-filename="https://i.iinfo.cz/images/181/python-ast-02-6-large.png" data-large-width="720" data-large-height="417" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="370" height="214" /></a>
<p><i>Obrázek 6: Podrobnější pohled na AST s&nbsp;funkcemi používajícími
klíčová slova <strong>async</strong> a <strong>await</strong> se zvýrazněním
příslušných uzlů.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rozpoznání uzlů tvořících algebraický výraz</h2>

<p>Jednotlivé uzly AST jsou tvořeny instancemi tříd z&nbsp;balíčku AST. Tyto
instance lze rozlišit podle jejich typu a tím pádem můžeme v&nbsp;AST nalézt a
vlastně i zpětně zrekonstruovat algebraické výrazy. Tento postup je naznačen
v&nbsp;dalším demonstračním příkladu, který z&nbsp;důvodu větší čitelnosti
rozpoznává jen základní typy uzlů &ndash; binární operátory a číselné konstanty
(pouze u typu uzlu &bdquo;konstanta&ldquo; vypisujeme i hodnotu této
konstanty):</p>

<pre>
import ast
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1
&nbsp;
    def <strong>visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node2string(node))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
&nbsp;
def <strong>node2string</strong>(node):
    t = type(node)
    if t == ast.Constant:
        return "Constant: {}".format(node.value)
    elif t == ast.Expr:
        return "Expression:"
    elif t == ast.BinOp:
        return "Binary operation"
    elif t == ast.Add:
        return "Operator: +"
    elif t == ast.Sub:
        return "Operator: -"
    elif t == ast.Mult:
        return "Operator: *"
    elif t == ast.Div:
        return "Operator: /"
    return ""
&nbsp;
&nbsp;
tree = <strong>ast.parse("1+2*(1-3/4)+5")</strong>
&nbsp;
visitor = <strong>Visitor()</strong>
<strong>visitor.visit(tree)</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;novějším Pythonu bude lepší
použít <i>pattern matching</i>, což je ovšem téma na samostatný
článek.</div></p>

<p>Zrekonstruovaný výraz se zobrazí tímto způsobem:</p>

<pre>
     Expression:
       Binary operation
         Binary operation
           Constant: 1
           Operator: +
           Binary operation
             Constant: 2
             Operator: *
             Binary operation
               Constant: 1
               Operator: -
               Binary operation
                 Constant: 3
                 Operator: /
                 Constant: 4
         Operator: +
         Constant: 5
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Algebraický výraz s&nbsp;proměnnými</h2>

<p>Algebraické výrazy mohou pochopitelně obsahovat i proměnné (nebo symbolické
konstanty). Proměnnou v&nbsp;AST poznáme tak, že se jedná o uzel
<strong>ast.Name</strong> následovaný poduzly <strong>ast.Id</strong> a
<strong>ast.Load</strong>, což znamená načtení hodnoty proměnné:</p>

<img src="https://i.iinfo.cz/images/529/python-ast-02.png" class="image-579228" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" width="527" height="870" />
<p><i>Obrázek 7: Výraz s&nbsp;proměnnou: 1+2*3+x.</i></p>

<p>Při analýze AST a pro zobrazení výrazu na terminálu nám postačuje zpracovat
pouze uzel <strong>ast.Name</strong> a jeho poduzel <strong>ast.Id</strong>,
takže skript <a href="#k11">z&nbsp;předchozí kapitoly</a> je možné nepatrně
rozšířit takto:</p>

<p>Opět se podívejme na upravený kód skriptu:</p>

<pre>
import ast
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 1
&nbsp;
    def <strong>visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node2string(node))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
&nbsp;
def <strong>node2string</strong>(node):
    t = type(node)
    if t == ast.Constant:
        return "Constant: {}".format(node.value)
    elif t == ast.Name:
        return "Variable: {}".format(node.id)
    elif t == ast.Expr:
        return "Expression:"
    elif t == ast.BinOp:
        return "Binary operation"
    elif t == ast.Add:
        return "Operator: +"
    elif t == ast.Sub:
        return "Operator: -"
    elif t == ast.Mult:
        return "Operator: *"
    elif t == ast.Div:
        return "Operator: /"
    return ""
&nbsp;
&nbsp;
tree = <strong>ast.parse("a+2*(1-b/4)+c")</strong>
&nbsp;
visitor = <strong>Visitor()</strong>
<strong>visitor.visit(tree)</strong>
</pre>

<p>Nyní skript dokáže zobrazit i názvy proměnných použitých ve výrazu:</p>

<pre>
     Expression:
       Binary operation
         Binary operation
           Variable: a
&nbsp;
           Operator: +
           Binary operation
             Constant: 2
             Operator: *
             Binary operation
               Constant: 1
               Operator: -
               Binary operation
                 Variable: b
&nbsp;
                 Operator: /
                 Constant: 4
         Operator: +
         Variable: c
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Překlad AST s&nbsp;jeho spuštěním</h2>

<p>S&nbsp;AST je pochopitelně možné manipulovat a tím například provádět různé
optimalizace. Ovšem současně je AST ústředním prvkem pythonovského
překladače:</p>

<pre>
zdrojový kód &rarr; parse tree &rarr; AST &rarr; CFG &rarr; bajtkód
</pre>

<p>Co to v&nbsp;praxi znamená? Pokud již máme vytvořený AST (ať již vznikl
jakýmkoli způsobem), můžeme ho přeložit do bajtkódu a následně tento bajtkód
spustit. K&nbsp;tomu slouží základní (<i>built-in</i>) funkce nazvané
<strong>compile</strong> a <strong>exec</strong>. Tyto funkce pochopitelně není
nutné importovat, takže pro překlad a spuštění AST můžeme psát:</p>

<pre>
import ast
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 1
&nbsp;
    def <strong>visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
&nbsp;
tree = <strong>ast.parse("print(1+2*(1-3/4)+5)", mode="exec")</strong>
&nbsp;
visitor = <strong>Visitor()</strong>
<strong>visitor.visit(tree)</strong>
&nbsp;
print("Executing")
&nbsp;
<strong>exec(compile(tree, filename="&lt;ast&gt;", mode="exec"))</strong>
&nbsp;
print("Done")
</pre>

<p>Po spuštění tohoto skriptu se nejdříve zobrazí všechny uzly AST:</p>

<pre>
   &lt;_ast.Module object at 0x7f4db2abf430&gt;
     &lt;_ast.Expr object at 0x7f4db2a02670&gt;
       &lt;_ast.Call object at 0x7f4db2a026a0&gt;
         &lt;_ast.Name object at 0x7f4db2a027c0&gt;
           &lt;_ast.Load object at 0x7f4db2a1ca00&gt;
         &lt;_ast.BinOp object at 0x7f4db2a028b0&gt;
           &lt;_ast.BinOp object at 0x7f4db2a028e0&gt;
             &lt;_ast.Constant object at 0x7f4db2a02910&gt;
             &lt;_ast.Add object at 0x7f4db2a1ce80&gt;
             &lt;_ast.BinOp object at 0x7f4db2a2ad00&gt;
               &lt;_ast.Constant object at 0x7f4db2a2ad30&gt;
               &lt;_ast.Mult object at 0x7f4db2a1cf40&gt;
               &lt;_ast.BinOp object at 0x7f4db2a2ad90&gt;
                 &lt;_ast.Constant object at 0x7f4db2a2adc0&gt;
                 &lt;_ast.Sub object at 0x7f4db2a1cee0&gt;
                 &lt;_ast.BinOp object at 0x7f4db2a2ae20&gt;
                   &lt;_ast.Constant object at 0x7f4db2a2ae80&gt;
                   &lt;_ast.Div object at 0x7f4db2a2a040&gt;
                   &lt;_ast.Constant object at 0x7f4db2a2aeb0&gt;
           &lt;_ast.Add object at 0x7f4db2a1ce80&gt;
           &lt;_ast.Constant object at 0x7f4db2a029a0&gt;
</pre>

<p>Následně je AST přeložen do bajtkódu a tento bajtkód je spuštěn. Výsledkem
je řetězec 6.5:</p>

<pre>
Executing
<strong>6.5</strong>
Done
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 (některé přímo pro Python 3.10) byly uloženy do Git
repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující jednoduchý výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py</a></td></tr>
<tr><td> 2</td><td>err_expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující chybný výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py</a></td></tr>
<tr><td> 3</td><td>async.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující async a await</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py</a></td></tr>
<tr><td> 4</td><td>primes.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující výpočet celočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>print_tokens.py</td><td>výpis všech typů a hodnot tokenů pro aktuální verzi Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py</a></td></tr>
<tr><td> 6</td><td>tokenize_expression_1.py</td><td>tokenizace výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py</a></td></tr>
<tr><td> 7</td><td>tokenize_expression_2.py</td><td>tokenizace výrazu, alternativní způsob otevření zdrojového souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py</a></td></tr>
<tr><td> 8</td><td>tokenize_expression_3.py</td><td>tokenizace výrazu s&nbsp;více operátory</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py</a></td></tr>
<tr><td> 9</td><td>tokenize_expression_4.py</td><td>tokenizace výrazu s&nbsp;více operátory, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py</a></td></tr>
<tr><td>10</td><td>tokenize_async.py</td><td>tokenizace zdrojového kódu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py</a></td></tr>
<tr><td>11</td><td>tokenize_primes.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py</a></td></tr>
<tr><td>12</td><td>tokenize_primes_2.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong>, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>parse_expression.py</td><td>parsing zdrojového kódu s&nbsp;výrazem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py</a></td></tr>
<tr><td>14</td><td>parse_expression_3_10.py</td><td>parsing zdrojového kódu s&nbsp;výrazem, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py</a></td></tr>
<tr><td>15</td><td>parse_async.py</td><td>parsing zdrojového kodu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py</a></td></tr>
<tr><td>16</td><td>parse_async_3_10.py</td><td>parsing zdrojového kodu <strong>async.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py</a></td></tr>
<tr><td>17</td><td>parse_primes.py</td><td>parsing zdrojového kodu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py</a></td></tr>
<tr><td>18</td><td>parse_primes_3_10.py</td><td>parsing zdrojového kodu <strong>primes.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>traverse_expression_1.py</td><td>průchod AST, nejjednodušší varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py</a></td></tr>
<tr><td>20</td><td>traverse_expression_2.py</td><td>průchod AST, vzor <i>Visitor</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py</a></td></tr>
<tr><td>21</td><td>traverse_expression_3.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py</a></td></tr>
<tr><td>22</td><td>traverse_expression_4.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py</a></td></tr>
<tr><td>23</td><td>traverse_expression_5.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>ifs1.py</td><td>zdrojový kód s&nbsp;několika zanořenými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py</a></td></tr>
<tr><td>25</td><td>ifs2.py</td><td>zdrojový kód s&nbsp;několika zanořenými úplnými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py</a></td></tr>
<tr><td>26</td><td>tokenize_ifs1.py</td><td>tokenizace zdrojového kódu &bdquo;ifs1.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py</a></td></tr>
<tr><td>27</td><td>tokenize_ifs2.py</td><td>tokenizace zdrojového kódu &bdquo;ifs2.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>compile_tree.py</td><td>překlad a spuštění AST</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Pygments - Python syntax highlighter<br />
<a href="http://pygments.org/">http://pygments.org/</a>
</li>

<li>Pygments (dokumentace)<br />
<a href="http://pygments.org/docs/">http://pygments.org/docs/</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Jazyky podporované knihovnou Pygments<br />
<a href="http://pygments.org/languages/">http://pygments.org/languages/</a>
</li>

<li>Pygments FAQ<br />
<a href="http://pygments.org/faq/">http://pygments.org/faq/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

