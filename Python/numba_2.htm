<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">2. Instalace nástroje Numba</a></p>
<p><a href="#k03">*** 3. Získání systémových informací i aktuální konfigurace Numby</a></p>
<p><a href="#k04">4. Anotace skriptů zpracovávaných nástrojem Numba</a></p>
<p><a href="#k05">5. Ukázka anotace jednoduché funkce sčítající dvě celočíselné hodnoty</a></p>
<p><a href="#k06">6. Co z&nbsp;anotovaného kódu vyčteme?</a></p>
<p><a href="#k07">7. Anotace stejné funkce, ovšem zavolané s&nbsp;jinými typy argumentů</a></p>
<p><a href="#k08">8. Funkce, která je postupně volána s&nbsp;různými typy argumentů</a></p>
<p><a href="#k09">9. Just in time překlad volaných funkcí do mezikódu LLVM</a></p>
<p><a href="#k10">10. Rozdíly mezi funkcí volanou s&nbsp;celočíselnými parametry a s&nbsp;parametry typu <strong>double</strong></a></p>
<p><a href="#k11">11. Zobrazení optimalizovaného mezikódu</a></p>
<p><a href="#k12">12. Překlad do assembleru cílové architektury</a></p>
<p><a href="#k13">*** 13. Využití SIMD instrukcí systémem Numba</a></p>
<p><a href="#k14">*** 14. Anotovaný zdrojový kód a optimalizovaný mezikód</a></p>
<p><a href="#k15">*** 15. Vygenerovaný kód v&nbsp;assembleru využívající SIMD instrukce</a></p>
<p><a href="#k16">*** 16. Režim <i>fast math</i></a></p>
<p><a href="#k17">*** 17. Paralelizace výsledného kódu</a></p>
<p><a href="#k18">*** 18. Kdy se paralelizace vyplatí a kdy nikoli?</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>Nástroj Numba podporuje překlad vybraných částí kódu aplikace psané
v&nbsp;Pythonu do nativního kódu cílové platformy (x86-64 apod.), přičemž
cílovou platformou může být i GPU (přes CUDA). Jedná se tedy o takzvaný <a
href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT</a> neboli o
<i>just-in-time</i> překladač, který má tu výhodu, že dokáže odvodit datové
typy proměnných a argumentů funkcí na základě skutečného chování aplikace, tedy
na základě typů předávaných parametrů a kontextu. To samozřejmě neznamená, že
by JIT již při prvním volání funkce přesně věděl, jak má funkci přeložit. Ve
skutečnosti se dozví pouze informace o jediné konkrétní větvi, kterou může
přeložit. V&nbsp;případě, že bude ta samá funkce později volána
s&nbsp;odlišnými typy parametrů, popř.&nbsp;se její chování změní jiným
způsobem (Python je velmi dynamický jazyk), provede se just-in-time překlad
znovu, takže zde zaplatíme za vyšší výpočetní výkon poněkud většími paměťovými
nároky a pomalejším během prvních volání funkce. Na druhou stranu mnoho
náročných výpočtů používá Numpy a Numba s&nbsp;Numpy dokáže spolupracovat velmi
dobře.</p>

<p>Z&nbsp;pohledu běžného vývojáře je největší předností tohoto způsobu
překladu fakt, že není zapotřebí samotný zdrojový kód měnit (až na uvedení
anotace před funkci). Nepříjemný je přesun času překladu do runtime, což sice
nevadí u aplikací, které běží delší dobu, ovšem u jednorázových skriptů může
být použití JITu spíše kontraproduktivní.</p>

<p>Samotný překlad je prováděn na několika úrovních, přičemž Numba na nižších
úrovních využívá možností nabízených LLVM. Jedná se o relativně složitou
problematiku, které se budeme věnovat v&nbsp;samostatném článku.</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;JITy jsme se již na stránkách
Roota setkali, především v&nbsp;souvislosti <a
href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">s&nbsp;LuaJITem</a>
a <a
href="https://www.root.cz/clanky/pohled-pod-kapotu-jvm-zaklady-optimalizace-aplikaci-naprogramovanych-v-jave/">JVM</a>.
Další odkazy naleznete na konci článku.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace nástroje Numba</h2>

<p>V&nbsp;současnosti existuje hned několik možností, jak projekt Numba
nainstalovat. Pravděpodobně nejjednodušší možnost představuje použití nástroje
<i>conda</i> (viz též <a
href="https://www.anaconda.com/what-is-anaconda/">platformu Anaconda</a>.
Instalace bude v&nbsp;tomto případě probíhat takto:</p>

<pre>
$ <strong>conda install numba</strong>
</pre>

<p>popř.&nbsp;pro přechod na vyšší verzi:</p>

<pre>
$ <strong>conda update numba</strong>
</pre>

<p>Pokud namísto nástroje <i>conda</i> použijete nástroj <i>pip</i> (jenž je
taktéž podporován), je nejprve vhodné provést upgrade <i>pip</i>u na novější
verzi, protože instalace <i>Numby</i> se starým <i>pip</i>em není
podporována:</p>

<pre>
$ <strong>sudo python3 -m pip install --upgrade pip</strong>
&nbsp;
Collecting pip
  Downloading https://files.pythonhosted.org/packages/a4/6d/6463d49a933f547439d6b5b98b46af8742cc03ae83543e4d7688c2420f8b/pip-21.3.1-py3-none-any.whl (1.7MB)
    100% |████████████████████████████████| 1.7MB 764kB/s 
Installing collected packages: pip
  Found existing installation: pip 9.0.3
    Uninstalling pip-9.0.3:
      Successfully uninstalled pip-9.0.3
Successfully installed pip-21.3.1
</pre>

<p>Pro jistotu zkontrolujeme, zda se používá skutečně poslední nainstalovaná
verze nástroje <i>pip</i>:</p>

<pre>
$ <strong>pip3 --version</strong>
&nbsp;
pip 21.3.1 from /usr/local/lib/python3.8/site-packages/pip
</pre>

<p>Nyní provedeme instalaci balíčku <strong>llvmlite</strong>, který obsahuje
část projektu LLVM, který je nástrojem Numba interně používán:</p>

<pre>
$ <strong>pip3 install --user llvmlite</strong>
&nbsp;
Collecting llvmlite
  Downloading llvmlite-0.36.0-cp36-cp36m-manylinux2010_x86_64.whl (25.3 MB)
     |████████████████████████████████| 25.3 MB 3.2 MB/s            
Installing collected packages: llvmlite
Successfully installed llvmlite-0.36.0
</pre>

<p>A následně již můžeme nainstalovat samotnou Numbu:</p>

<pre>
$ <strong>pip3 install --user numba</strong>
&nbsp;
Collecting numba
  Downloading numba-0.53.1-cp36-cp36m-manylinux2014_x86_64.whl (3.4 MB)
     |████████████████████████████████| 3.4 MB 1.4 MB/s            
Requirement already satisfied: setuptools in /usr/lib/python3.8/site-packages (from numba) (37.0.0)
Requirement already satisfied: numpy&gt;=1.15 in ./.local/lib/python3.8/site-packages (from numba) (1.19.4)
Requirement already satisfied: llvmlite&lt;0.37,&gt;=0.36.0rc1 in ./.local/lib/python3.8/site-packages (from numba) (0.36.0)
Installing collected packages: numba
Successfully installed numba-0.53.1
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně je možné předchozí dva
kroky spojit, ovšem pro řešení problémů s&nbsp;instalací je asi vhodnější
provádět celou instalaci krok po kroku.</div></p>

<p>Dalším krokem ihned po instalaci bude zjištění, zda se Numba nainstalovala
korektně. Prvním pokusem bude pokus o spuštění příkazu <strong>numba</strong>,
tj.&nbsp;především test, jestli tento příkaz leží na <strong>PATH</strong>:</p>

<pre>
$ <strong>numba</strong>
&nbsp;
numba: error: the following arguments are required: filename
</pre>

<p>V&nbsp;případě, že se tento příkaz nepodaří spustit, většinou to znamená, že
do <strong>PATH</strong> není zahrnuta cesta <strong>~/.local/bin</strong>, což
lze snadno napravit (.bashrc atd.).</p>

<p>Zobrazení nápovědy:</p>

<pre>
$ <strong>numba --help</strong>
&nbsp;
usage: numba [-h] [--annotate] [--dump-llvm] [--dump-optimized]
             [--dump-assembly] [--dump-cfg] [--dump-ast]
             [--annotate-html ANNOTATE_HTML] [-s] [--sys-json SYS_JSON]
             [filename]
&nbsp;
positional arguments:
  filename              Python source filename
&nbsp;
optional arguments:
  -h, --help            show this help message and exit
  --annotate            Annotate source
  --dump-llvm           Print generated llvm assembly
  --dump-optimized      Dump the optimized llvm assembly
  --dump-assembly       Dump the LLVM generated assembly
  --dump-cfg            [Deprecated] Dump the control flow graph
  --dump-ast            [Deprecated] Dump the AST
  --annotate-html ANNOTATE_HTML
                        Output source annotation as html
  -s, --sysinfo         Output system information for bug reporting
  --sys-json SYS_JSON   Saves the system info dict as a json file
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Získání systémových informací i aktuální konfigurace Numby</h2>

<p></p>

<pre>
$ <strong>numba -s</strong>
</pre>

<p></p>

<pre>
System info:
--------------------------------------------------------------------------------
__Time Stamp__
Report started (local time)                   : 2023-05-20 12:01:57.835226
UTC start time                                : 2023-05-20 10:01:57.835229
Running time (s)                              : 0.829354

__Hardware Information__
Machine                                       : x86_64
CPU Name                                      : skylake
CPU Count                                     : 8
Number of accessible CPUs                     : 8
List of accessible CPUs cores                 : 0 1 2 3 4 5 6 7
CFS Restrictions (CPUs worth of runtime)      : None

CPU Features                                  : 64bit adx aes avx avx2 bmi bmi2
                                                clflushopt cmov cx16 cx8 f16c fma
                                                fsgsbase fxsr invpcid lzcnt mmx
                                                movbe pclmul popcnt prfchw rdrnd
                                                rdseed rtm sahf sgx sse sse2 sse3
                                                sse4.1 sse4.2 ssse3 xsave xsavec
                                                xsaveopt xsaves

Memory Total (MB)                             : 15466
Memory Available (MB)                         : 13824

__OS Information__
Platform Name                                 : Linux-4.18.19-100.fc27.x86_64-x86_64-with-fedora-27-Twenty_Seven
Platform Release                              : 4.18.19-100.fc27.x86_64
OS Name                                       : Linux
OS Version                                    : #1 SMP Wed Nov 14 22:04:34 UTC 2018
OS Specific Version                           : ?
Libc Version                                  : glibc 2.3.4

__Python Information__
Python Compiler                               : GCC 7.3.1 20180303 (Red Hat 7.3.1-5)
Python Implementation                         : CPython
Python Version                                : 3.8.6
Python Locale                                 : en_US.UTF-8

__LLVM Information__
LLVM Version                                  : 10.0.1

__CUDA Information__
CUDA Device Initialized                       : False
CUDA Driver Version                           : ?
CUDA Detect Output:
None
CUDA Libraries Test Output:
None

__ROC information__
ROC Available                                 : False
ROC Toolchains                                : None
HSA Agents Count                              : 0
HSA Agents:
None
HSA Discrete GPUs Count                       : 0
HSA Discrete GPUs                             : None

__SVML Information__
SVML State, config.USING_SVML                 : False
SVML Library Loaded                           : False
llvmlite Using SVML Patched LLVM              : True
SVML Operational                              : False

__Threading Layer Information__
TBB Threading Layer Available                 : False
+--> Disabled due to Unknown import problem.
OpenMP Threading Layer Available              : True
+-->Vendor: GNU
Workqueue Threading Layer Available           : True
+-->Workqueue imported successfully.

__Numba Environment Variable Information__
None found.

__Conda Information__
Conda not available.
</pre>

<pre>
__Installed Packages__
Package                  Version
------------------------ -----------------
absl-py                  0.11.0
alabaster                0.7.9
aniso8601                3.0.0
...
...
...
xmltodict                0.11.0
zc.thread                1.0.0
zipp                     3.1.0
</pre>

<p></p>

<pre>
__Warning log__
Warning (cuda): CUDA driver library cannot be found or no CUDA enabled devices are present.
Exception class: <class 'numba.cuda.cudadrv.error.CudaSupportError'>
Warning (roc): Error initialising ROC: No ROC toolchains found.
Warning (roc): No HSA Agents found, encountered exception when searching: Error at driver init: 
NUMBA_HSA_DRIVER /opt/rocm/lib/libhsa-runtime64.so is not a valid file path.  Note it must be a filepath of the .so/.dll/.dylib or the driver:
Warning: Conda not available.
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Anotace skriptů zpracovávaných nástrojem Numba</h2>

<p>Nástroj Numba dokáže skripty naprogramované v&nbsp;Pythonu překládat do
strojového (tedy nativního) kódu cílové platformy. Ovšem nejedná se (a
v&nbsp;případě Pythonu se ani nemůže jednat) o operaci provedenou
v&nbsp;jediném kroku. Celý překlad je totiž rozdělen na mnoho fází. První
operací, kterou Numba provádí, je analýza AST (abstraktního syntaktického
stromu) se snahou o &bdquo;porozumění&ldquo; kódu zapsaného vývojářem. Druhou
operací je odvození datových typů argumentů zpracovávaných funkcí a tím pádem i
typů lokálních proměnných těchto funkcí. Numba navíc dokáže původní zdrojový
kód doplnit o komentáře, které naznačí, jak vstupnímu zdrojovému kódu
&bdquo;rozumí&ldquo; po tomto kroku (tedy analýze) a jaké další informace
(typy, živost proměnných) byly z&nbsp;kódu odvozeny. Do původního zdrojového
kódu jsou formou poznámek doplněny další informace, jak ostatně uvidíme
dále.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Ukázka anotace jednoduché funkce sčítající dvě celočíselné hodnoty</h2>

<p>Vyzkoušejme si nyní, jak vlastně bude vypadat <a
href="#k04">v&nbsp;předchozí kapitole</a> zmíněná anotace zdrojového kódu
zpracovávaného nástrojem Numba, na následujícím jednoduchém demonstračním
příkladu, který obsahuje jednu funkci s&nbsp;dekorátorem <strong>@jit</strong>
&ndash; tím Numbě naznačujeme, že chceme JITovat právě tuto funkci (význam
parametrů dekorátoru si vysvětlíme dále, na anotaci však nemají vliv). Funkce
je volána s&nbsp;parametry typu <strong>int</strong>:</p>

<pre>
from numba import jit
&nbsp;
&nbsp;
<u>@jit(nopython=True,nogil=True)</u>
def <strong>sum</strong>(a, b):
     return a+b
&nbsp;
&nbsp;
x = sum(1, 2)
print(x)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum1.py</a>.</div></p>

<p>Vytvoření anotovaného kódu s&nbsp;jeho následujícím výpisem zajišťuje tento
příkaz:</p>

<pre>
$ <strong>numba --annotate sum1.py</strong>
</pre>

<p>Podívejme se nyní na výsledek vypsaný nástrojem Numba:</p>

<pre>
-----------------------------------ANNOTATION-----------------------------------
# File: sum1.py
# --- LINE 4 --- 
&nbsp;
@jit(nopython=True,nogil=True)
&nbsp;
# --- LINE 5 --- 
&nbsp;
def sum(a, b):
&nbsp;
     # --- LINE 6 --- 
     # label 0
     #   a = arg(0, name=a)  :: int64
     #   b = arg(1, name=b)  :: int64
     #   $0.3 = a + b  :: int64
     #   del b
     #   del a
     #   $0.4 = cast(value=$0.3)  :: int64
     #   del $0.3
     #   return $0.4
&nbsp;
     return a+b
&nbsp;
&nbsp;
================================================================================
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Co z&nbsp;anotovaného kódu vyčteme?</h2>

<p>Výsledek uvedený <a href="#k04">v&nbsp;páté kapitole</a> ukazuje, jaké
užitečné informace nástroj Numba v&nbsp;rámci prvních dvou kroků JIT překladu
získal:</p>

<ul>

<li>Typy argumentů předávaných do funkce <strong>sum</strong> &ndash; oba
argumenty jsou v&nbsp;našem konkrétním případě typu <strong>int64</strong> (což
ovšem znamená <i>zúžení</i> původního typu, protože Pythonovská celá čísla mají
neomezený rozsah!)</li>

<li>Typ výsledku operace (operací) prováděných ve funkci. Konkrétně je typ
hodnoty získané operací a+b taktéž roven <strong>int64</strong> (mezivýsledek
je představován pseudoproměnnou <strong>$0.3</strong>).</li>

<li>Původní argumenty mohou být po provedení operace součtu z&nbsp;paměti
odstraněny, což Numba korektně detekuje a naznačí příkazem
<strong>del</strong>.</li>

<li>Poté je zapsáno explicitní přetypování, které bude později při
optimalizacích opět odstraněno.</li>

<li>I mezivýsledek může být z&nbsp;paměti odstraněn, což naznačuje poslední
příkaz <strong>del</strong>.</li>

</ul>

<p><div class="rs-tip-major">Poznámka: jedná se tedy o překvapivě velké
množství informací, které se nástroji Numba budou zcela jistě hodit
v&nbsp;navazujících krocích JIT překladu. Navíc Numba, možná poněkud přímočaře,
předpokládá, že se celočíselné hodnoty vejdou do rozsahu datového typu
<strong>int64</strong>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Anotace stejné funkce, ovšem zavolané s&nbsp;jinými typy argumentů</h2>

<p>Funkci <strong>sum</strong> uvedenou <a href="#k05">v&nbsp;páté kapitole</a>
je pochopitelně možné v&nbsp;Pythonu volat s&nbsp;prakticky jakýmikoli typy
parametrů, protože operace + je definována například pro pravdivostní hodnoty
(i když výsledek může někoho překvapit), pro celočíselné hodnoty, hodnoty
s&nbsp;plovoucí řádovou čárkou, řetězce, n-tice, seznamy, množiny atd. Co se
tedy stane v&nbsp;případě, kdy stejnou funkci nyní zavoláme s&nbsp;parametry
typu <strong>float</strong>? Můžeme si to velmi snadno ověřit:</p>

<pre>
from numba import jit
&nbsp;
&nbsp;
<u>@jit(nopython=True,nogil=True)</u>
def <strong>sum</strong>(a, b):
     return a+b
&nbsp;
&nbsp;
x = sum(1.1, 2.2)
print(x)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum2.py</a>.</div></p>

<p>Nyní bude výsledek analýzy AST, odvození typů a živosti proměnných vypadat
poněkud odlišně:</p>

<pre>
$ <strong>numba --annotate sum2.py</strong>
&nbsp;
-----------------------------------ANNOTATION-----------------------------------
# File: sum2.py
# --- LINE 4 --- 
&nbsp;
@jit(nopython=True,nogil=True)
&nbsp;
# --- LINE 5 --- 
&nbsp;
def sum(a, b):
&nbsp;
     # --- LINE 6 --- 
     # label 0
     #   a = arg(0, name=a)  :: float64
     #   b = arg(1, name=b)  :: float64
     #   $0.3 = a + b  :: float64
     #   del b
     #   del a
     #   $0.4 = cast(value=$0.3)  :: float64
     #   del $0.3
     #   return $0.4
&nbsp;
     return a+b
&nbsp;
&nbsp;
================================================================================
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že v&nbsp;místech, kde
byl původně zapsán typ <strong>int64</strong> se nyní nachází jméno typu
<strong>float64</strong>, což odpovídá typu <i>double</i> z&nbsp;jazyka
C:</div></p>

<pre>
$ <strong>numba --annotate sum1.py &gt; sum1_annotated</strong>
&nbsp;
$ <strong>numba --annotate sum2.py &gt; sum2_annotated</strong>
&nbsp;
$ <strong>diff -y sum1_annotated sum2_annotated </strong>
-----------------------------------ANNOTATION----------------   -----------------------------------ANNOTATION----------------
# File: sum1.py                                               | # File: sum2.py
# --- LINE 4 ---                                                # --- LINE 4 --- 
&nbsp;
@jit(nopython=True,nogil=True)                                  @jit(nopython=True,nogil=True)
&nbsp;
# --- LINE 5 ---                                                # --- LINE 5 --- 
&nbsp;
def sum(a, b):                                                  def sum(a, b):
&nbsp;
     # --- LINE 6 ---                                                # --- LINE 6 --- 
     # label 0                                                       # label 0
     #   a = arg(0, name=a)  :: int64                         |      #   a = arg(0, name=a)  :: float64
     #   b = arg(1, name=b)  :: int64                         |      #   b = arg(1, name=b)  :: float64
     #   $0.3 = a + b  :: int64                               |      #   $0.3 = a + b  :: float64
     #   del b                                                       #   del b
     #   del a                                                       #   del a
     #   $0.4 = cast(value=$0.3)  :: int64                    |      #   $0.4 = cast(value=$0.3)  :: float64
     #   del $0.3                                                    #   del $0.3
     #   return $0.4                                                 #   return $0.4
&nbsp;
     return a+b                                                      return a+b
&nbsp;
&nbsp;
=============================================================   =============================================================
3                                                             | 3.3000000000000003
</pre>

<p><div class="rs-tip-major">Poznámka: poslední řádek obsahuje vypočtené
hodnoty.</div></p>

<p>Pro zajímavost si ještě v&nbsp;rychlosti ukažme stejnou funkci, ovšem nyní
spojující dvě n-tice:</p>

<pre>
from numba import jit
&nbsp;
&nbsp;
<u>@jit(nopython=True,nogil=True)</u>
def <strong>sum</strong>(a, b):
     return a+b
&nbsp;
&nbsp;
x = sum((1, 2), (3, 4))
&nbsp;
print(x)
</pre>

<p>Anotovaný zdrojový kód:</p>

<pre>
$ <strong>numba --annotate sum3.py</strong>
&nbsp;
-----------------------------------ANNOTATION-----------------------------------
# File: sum3.py
# --- LINE 4 --- 
&nbsp;
@jit(nopython=True,nogil=True)
&nbsp;
# --- LINE 5 --- 
&nbsp;
def sum(a, b):
&nbsp;
     # --- LINE 6 --- 
     # label 0
     #   a = arg(0, name=a)  :: UniTuple(int64 x 2)
     #   b = arg(1, name=b)  :: UniTuple(int64 x 2)
     #   $0.3 = a + b  :: UniTuple(int64 x 4)
     #   del b
     #   del a
     #   $0.4 = cast(value=$0.3)  :: UniTuple(int64 x 4)
     #   del $0.3
     #   return $0.4
&nbsp;
     return a+b
&nbsp;
&nbsp;
================================================================================
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Funkce, která je postupně volána s&nbsp;různými typy argumentů</h2>

<p>Viděli jsme, že Numpy dokáže správně detekovat a odvodit parametry volané
funkce v&nbsp;případě, že je daná funkce v&nbsp;programovém kódu volána pouze
jedenkrát. Ovšem v&nbsp;praxi nás Python nijak neomezuje v&nbsp;tom, jak a
kolikrát bude nějaká funkce volána, což znamená, že stejná funkce může být
volána vícekrát, pokaždé s&nbsp;různými typy (a někdy i počtem) parametrů. To
pro Numbu ve skutečnosti znamená jen nepatrný problém &ndash; danou funkci bude
muset přeložit vícekrát, pokaždé pro jiné typy parametrů (a tím pádem i typy
lokálních proměnných atd.). A řešení tohoto problému by se mělo projevit i na
anotaci, takže si tuto domněnku otestujme na tomto příkladu:</p>

<pre>
from numba import jit
&nbsp;
&nbsp;
<u>@jit(nopython=True,nogil=True)</u>
def <strong>sum</strong>(a, b):
     return a+b
&nbsp;
&nbsp;
x = sum(1, 2)
y = sum(1.1, 2.2)
z = sum((1, 2), (3, 4))
&nbsp;
print(x)
print(y)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum3.py</a>.</div></p>

<p>Skript spustíme a přitom si necháme vypsat anotace JITovaných funkcí:</p>

<pre>
$ <strong>numba --annotate sum3.py</strong>
</pre>

<p>Z&nbsp;vypsaných výsledků je patrné, že se tatáž funkce skutečně ve výpisu
objeví ve třech různých variantách:</p>

<pre>
-----------------------------------ANNOTATION-----------------------------------
# File: sum3.py
# --- LINE 4 --- 
&nbsp;
@jit(nopython=True,nogil=True)
&nbsp;
# --- LINE 5 --- 
&nbsp;
def sum(a, b):
&nbsp;
     # --- LINE 6 --- 
     # label 0
     #   a = arg(0, name=a)  :: int64
     #   b = arg(1, name=b)  :: int64
     #   $0.3 = a + b  :: int64
     #   del b
     #   del a
     #   $0.4 = cast(value=$0.3)  :: int64
     #   del $0.3
     #   return $0.4
&nbsp;
     return a+b
&nbsp;
&nbsp;
================================================================================
-----------------------------------ANNOTATION-----------------------------------
# File: sum3.py
# --- LINE 4 --- 
&nbsp;
@jit(nopython=True,nogil=True)
&nbsp;
# --- LINE 5 --- 
&nbsp;
def sum(a, b):
&nbsp;
     # --- LINE 6 --- 
     # label 0
     #   a = arg(0, name=a)  :: float64
     #   b = arg(1, name=b)  :: float64
     #   $0.3 = a + b  :: float64
     #   del b
     #   del a
     #   $0.4 = cast(value=$0.3)  :: float64
     #   del $0.3
     #   return $0.4
&nbsp;
     return a+b
&nbsp;
&nbsp;
================================================================================
-----------------------------------ANNOTATION-----------------------------------
# File: sum3.py
# --- LINE 4 --- 
&nbsp;
@jit(nopython=True,nogil=True)
&nbsp;
# --- LINE 5 --- 
&nbsp;
def sum(a, b):
&nbsp;
     # --- LINE 6 --- 
     # label 0
     #   a = arg(0, name=a)  :: UniTuple(int64 x 2)
     #   b = arg(1, name=b)  :: UniTuple(int64 x 2)
     #   $0.3 = a + b  :: UniTuple(int64 x 4)
     #   del b
     #   del a
     #   $0.4 = cast(value=$0.3)  :: UniTuple(int64 x 4)
     #   del $0.3
     #   return $0.4
&nbsp;
     return a+b
&nbsp;
&nbsp;
================================================================================
</pre>

<p><div class="rs-tip-major">Poznámka: asi je možné předpokládat, že poslední
varianta nebude přeložena do krátkého strojového kódu, kdežto první dvě
varianty ano.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Just in time překlad volaných funkcí do mezikódu LLVM</h2>

<p>V&nbsp;okamžiku, kdy má nástroj Numba k&nbsp;dispozici podrobné informace o
typech parametrů funkcí a odvodí jak typy, tak i živost lokálních proměnných,
může dojít k&nbsp;další fázi překladu &ndash; k&nbsp;vygenerování <a
href="https://llvm.org/docs/LangRef.html">mezikódu pro LLVM</a>. Tento mezikód
si můžeme nechat snadno zobrazit příkazem:</p>

<pre>
$ <strong>numba --dump-llvm sum1.py</strong>
</pre>

<p>Vygenerovaný mezikód obsahuje mnoho pseudoinstrukcí. V&nbsp;následujícím
výpisu se setkáme zejména s&nbsp;pseudoinstrukcemi <a
href="https://llvm.org/docs/LangRef.html#store-instruction">store</a>, <a
href="https://llvm.org/docs/LangRef.html#alloca-instruction">alloca</a>, <a
href="https://llvm.org/docs/LangRef.html#ret-instruction">ret</a>, <a
href="https://llvm.org/docs/LangRef.html#br-instruction">br</a>, <a
href="https://llvm.org/docs/LangRef.html#load-instruction">load</a> a <a
href="https://llvm.org/docs/LangRef.html#add-instruction">add</a>:</p>

<pre>
--------------------LLVM DUMP &lt;function descriptor 'sum$1'&gt;---------------------
; ModuleID = "sum$1"
target triple = "x86_64-unknown-linux-gnu"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
&nbsp;
@"_ZN08NumbaEnv8__main__7sum$241Exx" = common global i8* null
define i32 @"_ZN8__main__7sum$241Exx"(i64* noalias nocapture %"retptr", {i8*, i32, i8*}** noalias nocapture %"excinfo", i64 %"arg.a", i64 %"arg.b") 
{
entry:
  %"a" = alloca i64
  store i64 0, i64* %"a"
  %"b" = alloca i64
  store i64 0, i64* %"b"
  %"$0.3" = alloca i64
  store i64 0, i64* %"$0.3"
  %"$0.4" = alloca i64
  store i64 0, i64* %"$0.4"
  br label %"B0"
B0:
  %".7" = load i64, i64* %"a"
  store i64 %"arg.a", i64* %"a"
  %".10" = load i64, i64* %"b"
  store i64 %"arg.b", i64* %"b"
  %".12" = load i64, i64* %"a"
  %".13" = load i64, i64* %"b"
  %".14" = add nsw i64 %".12", %".13"
  %".16" = load i64, i64* %"$0.3"
  store i64 %".14", i64* %"$0.3"
  %".18" = load i64, i64* %"b"
  store i64 0, i64* %"b"
  %".20" = load i64, i64* %"a"
  store i64 0, i64* %"a"
  %".22" = load i64, i64* %"$0.3"
  %".24" = load i64, i64* %"$0.4"
  store i64 %".22", i64* %"$0.4"
  %".26" = load i64, i64* %"$0.3"
  store i64 0, i64* %"$0.3"
  %".28" = load i64, i64* %"$0.4"
  store i64 %".28", i64* %"retptr"
  ret i32 0
}
&nbsp;
================================================================================
3
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se tedy o formu assembleru, ovšem
určeného pro virtuální stroj a nikoli pro nějakou konkrétní cílovou
platformu.</div></p>

<p>Pro zajímavost se můžeme podívat, jak se do mezikódu LLVM přeloží druhá
funkce, kterou voláme s&nbsp;parametry typu <strong>double</strong>:</p>

<pre>
$ <strong>numba --dump-llvm sum2.py</strong>
</pre>

<p>Výsledek:</p>

<pre>
--------------------LLVM DUMP &lt;function descriptor 'sum$1'&gt;---------------------
; ModuleID = "sum$1"
target triple = "x86_64-unknown-linux-gnu"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
&nbsp;
@"_ZN08NumbaEnv8__main__7sum$241Edd" = common global i8* null
define i32 @"_ZN8__main__7sum$241Edd"(double* noalias nocapture %"retptr", {i8*, i32, i8*}** noalias nocapture %"excinfo", double %"arg.a", double %"arg.b") 
{
entry:
  %"a" = alloca double
  store double 0.0, double* %"a"
  %"b" = alloca double
  store double 0.0, double* %"b"
  %"$0.3" = alloca double
  store double 0.0, double* %"$0.3"
  %"$0.4" = alloca double
  store double 0.0, double* %"$0.4"
  br label %"B0"
B0:
  %".7" = load double, double* %"a"
  store double %"arg.a", double* %"a"
  %".10" = load double, double* %"b"
  store double %"arg.b", double* %"b"
  %".12" = load double, double* %"a"
  %".13" = load double, double* %"b"
  %".14" = fadd double %".12", %".13"
  %".16" = load double, double* %"$0.3"
  store double %".14", double* %"$0.3"
  %".18" = load double, double* %"b"
  store double 0.0, double* %"b"
  %".20" = load double, double* %"a"
  store double 0.0, double* %"a"
  %".22" = load double, double* %"$0.3"
  %".24" = load double, double* %"$0.4"
  store double %".22", double* %"$0.4"
  %".26" = load double, double* %"$0.3"
  store double 0.0, double* %"$0.3"
  %".28" = load double, double* %"$0.4"
  store double %".28", double* %"retptr"
  ret i32 0
}
&nbsp;
================================================================================
3.3000000000000003
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Rozdíly mezi funkcí volanou s&nbsp;celočíselnými parametry a s&nbsp;parametry typu <strong>double</strong></h2>

<p>Opět se podívejme na rozdíly mezi oběma výsledky. V&nbsp;této fázi by neměly
být velké, protože se liší &bdquo;jen&ldquo; datové typy, s&nbsp;nimiž se
pracuje:</p>

<pre>
$ <strong>numba --dump-llvm sum1.py &gt; sum1_llvm</strong>
&nbsp;
$ <strong>numba --dump-llvm sum2.py &gt; sum2_llvm</strong>
</pre>

<p>Rozdíly spočívají v&nbsp;náhradě <strong>i64</strong> na
<strong>double</strong>:</p>

<pre>
$ <strong>diff -y sum1_llvm sum2_llvm </strong>
&nbsp;
--------------------LLVM DUMP &lt;function descriptor 'sum$1'&gt;--   --------------------LLVM DUMP &lt;function descriptor 'sum$1'&gt;--
; ModuleID = "sum$1"                                            ; ModuleID = "sum$1"
target triple = "x86_64-unknown-linux-gnu"                      target triple = "x86_64-unknown-linux-gnu"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i   target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i
&nbsp;
@"_ZN08NumbaEnv8__main__7sum$241Exx" = common global i8* null | @"_ZN08NumbaEnv8__main__7sum$241Edd" = common global i8* null
define i32 @"_ZN8__main__7sum$241Exx"(i64* noalias nocapture  | define i32 @"_ZN8__main__7sum$241Edd"(double* noalias nocaptu
{                                                               {
entry:                                                          entry:
  %"a" = alloca i64                                           |   %"a" = alloca double
  store i64 0, i64* %"a"                                      |   store double 0.0, double* %"a"
  %"b" = alloca i64                                           |   %"b" = alloca double
  store i64 0, i64* %"b"                                      |   store double 0.0, double* %"b"
  %"$0.3" = alloca i64                                        |   %"$0.3" = alloca double
  store i64 0, i64* %"$0.3"                                   |   store double 0.0, double* %"$0.3"
  %"$0.4" = alloca i64                                        |   %"$0.4" = alloca double
  store i64 0, i64* %"$0.4"                                   |   store double 0.0, double* %"$0.4"
  br label %"B0"                                                  br label %"B0"
B0:                                                             B0:
  %".7" = load i64, i64* %"a"                                 |   %".7" = load double, double* %"a"
  store i64 %"arg.a", i64* %"a"                               |   store double %"arg.a", double* %"a"
  %".10" = load i64, i64* %"b"                                |   %".10" = load double, double* %"b"
  store i64 %"arg.b", i64* %"b"                               |   store double %"arg.b", double* %"b"
  %".12" = load i64, i64* %"a"                                |   %".12" = load double, double* %"a"
  %".13" = load i64, i64* %"b"                                |   %".13" = load double, double* %"b"
  %".14" = add nsw i64 %".12", %".13"                         |   %".14" = fadd double %".12", %".13"
  %".16" = load i64, i64* %"$0.3"                             |   %".16" = load double, double* %"$0.3"
  store i64 %".14", i64* %"$0.3"                              |   store double %".14", double* %"$0.3"
  %".18" = load i64, i64* %"b"                                |   %".18" = load double, double* %"b"
  store i64 0, i64* %"b"                                      |   store double 0.0, double* %"b"
  %".20" = load i64, i64* %"a"                                |   %".20" = load double, double* %"a"
  store i64 0, i64* %"a"                                      |   store double 0.0, double* %"a"
  %".22" = load i64, i64* %"$0.3"                             |   %".22" = load double, double* %"$0.3"
  %".24" = load i64, i64* %"$0.4"                             |   %".24" = load double, double* %"$0.4"
  store i64 %".22", i64* %"$0.4"                              |   store double %".22", double* %"$0.4"
  %".26" = load i64, i64* %"$0.3"                             |   %".26" = load double, double* %"$0.3"
  store i64 0, i64* %"$0.3"                                   |   store double 0.0, double* %"$0.3"
  %".28" = load i64, i64* %"$0.4"                             |   %".28" = load double, double* %"$0.4"
  store i64 %".28", i64* %"retptr"                            |   store double %".28", double* %"retptr"
  ret i32 0                                                       ret i32 0
}                                                               }
&nbsp;
=============================================================   =============================================================
3                                                             | 3.3000000000000003
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zobrazení optimalizovaného mezikódu</h2>

<p>Dalším krokem, který nástroj Numba (nyní již nepřímo) zajišťuje, je
optimalizace mezikódu LLVM. I optimalizovaný mezikód si pochopitelně můžeme
nechat zobrazit, a to s&nbsp;využitím přepínače
<strong>--dump-optimized</strong>:</p>

<pre>
$ <strong>numbra --show-optimized sum1.py</strong>
</pre>

<p>Výsledek je poněkud dlouhý, protože obsahuje i realizaci různých mezních
stavů, ovšem pro nás je nejpodstatnější následující část, která opravdu
obsahuje velmi optimalizovaný kód:</p>

<pre>
<i>; Function Attrs: nofree norecurse nounwind writeonly</i>
define i32 @"_ZN8__main__7sum$241Exx"(i64* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture readnone %excinfo, i64 %arg.a, i64 %arg.b) local_unnamed_addr #0 {
entry:
  %.14 = add nsw i64 %arg.b, %arg.a
  store i64 %.14, i64* %retptr, align 8
  ret i32 0
}
</pre>

<p><div class="rs-tip-major">Poznámka: zde je patrné, že návratový kód funkce
ve skutečnosti neobsahuje výslednou hodnotu.</div></p>

<p>Podobně si můžeme nechat zobrazit optimalizovaný mezikód i pro druhou
variantu funkce <strong>sum</strong>:</p>

<pre>
$ <strong>numbra --show-optimized sum2.py</strong>
</pre>

<pre>
<i>; Function Attrs: nofree norecurse nounwind writeonly</i>
define i32 @"_ZN8__main__7sum$241Edd"(double* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture readnone %excinfo, double %arg.a, double %arg.b) local_unnamed_addr #0 {
entry:
  %.14 = fadd double %arg.a, %arg.b
  store double %.14, double* %retptr, align 8
  ret i32 0
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Překlad do assembleru cílové architektury</h2>

<p>LLVM v&nbsp;navazujícím kroku provádí překlad z&nbsp;optimalizovaného
mezikódu do strojového kódu cílové architektury, což dnes bude pro jednoduchost
prozatím x86-64, ovšem v&nbsp;dalším článku si ukážeme i další nabízené
možnosti. A i způsob provedení tohoto kroku můžeme velmi snadno zkontrolovat,
protože nástroj Numba nabízí přepínač <strong>--dump-assembly</strong>, jenž
vypíše sekvenci instrukcí v&nbsp;assembleru, které odpovídají výslednému
strojovému kódu.</p>

<p>Vyzkoušíme si to nejprve na funkci <strong>sum</strong> ve variantě, kdy je
volána s&nbsp;dvojicí celých čísel:</p>

<pre>
$ <strong>numba --dump-assembly sum1.py</strong>
</pre>

<p>Překlad do assembleru cílové architektury bude vypadat následovně:</p>

<pre>
_ZN8__main__7sum$241Exx:
        addq    %rcx, %rdx
        movq    %rdx, (%rdi)
        xorl    %eax, %eax
        retq
</pre>

<p><div class="rs-tip-major">Poznámka: opět si povšimněte, že návratový kód
neobsahuje výsledek volané funkce.</div></p>

<p>A jak bude vypadat způsob překladu stejné funkce, ovšem volané
s&nbsp;parametry typu <strong>double</strong>?</p>

<pre>
$ <strong>numba --dump-assembly sum2.py</strong>
</pre>

<p>Nyní vidíme využití registrů přidaných v&nbsp;rámci z&nbsp;rozšíření
instrukční sady <i>SSE</i> popř.&nbsp;<i>SSE2</i> a instrukce
<strong>vaddsd</strong> a <strong>vmovsd</strong> jsou definovány
v&nbsp;<i>AVX</i>:</p>

<pre>
_ZN8__main__7sum$241Edd:
        vaddsd  %xmm1, %xmm0, %xmm0
        vmovsd  %xmm0, (%rdi)
        xorl    %eax, %eax
        retq
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Využití SIMD instrukcí systémem Numba</h2>

<p></p>

<pre>
from numba import jit
&nbsp;
import numpy as np
&nbsp;
&nbsp;
<u>@jit(nopython=True)</u>
def <strong>sum_array</strong>(array):
    result = 0
    for i in range(array.shape[0]):
        result += array[i]
    return result
&nbsp;
&nbsp;
array = np.arange(1, 1001)
print(sum_array(array))
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_array.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_array.py</a>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Anotovaný zdrojový kód a optimalizovaný mezikód</h2>

<p></p>

<pre>
-----------------------------------ANNOTATION-----------------------------------
# File: sum_array.py
# --- LINE 6 --- 

@jit(nopython=True)

# --- LINE 7 --- 

def sum_array(array):

    # --- LINE 8 --- 
    # label 0
    #   array = arg(0, name=array)  :: array(int64, 1d, C)
    #   result = const(int, 0)  :: Literal[int](0)

    result = 0

    # --- LINE 9 --- 
    #   jump 6
    # label 6
    #   jump 8
    # label 8
    #   $8.1 = global(range: <class 'range'>)  :: Function(<class 'range'>)
    #   $8.3 = getattr(value=array, attr=shape)  :: UniTuple(int64 x 1)
    #   $const8.4 = const(int, 0)  :: Literal[int](0)
    #   $8.5 = static_getitem(value=$8.3, index=0, index_var=$const8.4, fn=<built-in function getitem>)  :: int64
    #   del $const8.4
    #   del $8.3
    #   $8.6 = call $8.1($8.5, func=$8.1, args=[Var($8.5, sum_array.py:9)], kws=(), vararg=None)  :: (int64,) -> range_state_int64
    #   del $8.5
    #   del $8.1
    #   $8.7 = getiter(value=$8.6)  :: range_iter_int64
    #   del $8.6
    #   $phi22.1 = $8.7  :: range_iter_int64
    #   del $8.7
    #   jump 22
    # label 22
    #   result.2 = phi(incoming_values=[Var(result, sum_array.py:8), Var(result.1, sum_array.py:10)], incoming_blocks=[8, 24])  :: int64
    #   del result.1
    #   $22.2 = iternext(value=$phi22.1)  :: pair<int64, bool>
    #   $22.3 = pair_first(value=$22.2)  :: int64
    #   $22.4 = pair_second(value=$22.2)  :: bool
    #   del $22.2
    #   $phi24.1 = $22.3  :: int64
    #   $phi40.1 = $22.3  :: int64
    #   del $phi40.1
    #   del $22.3
    #   $phi40.2 = $phi22.1  :: range_iter_int64
    #   del $phi40.2
    #   branch $22.4, 24, 40
    # label 24
    #   del $22.4
    #   i = $phi24.1  :: int64
    #   del $phi24.1

    for i in range(array.shape[0]):

        # --- LINE 10 --- 
        #   $24.5 = getitem(value=array, index=i, fn=<built-in function getitem>)  :: int64
        #   del i
        #   $24.6 = inplace_binop(fn=<built-in function iadd>, immutable_fn=<built-in function add>, lhs=result.2, rhs=$24.5, static_lhs=Undefined, static_rhs=Undefined)  :: int64
        #   del result.2
        #   del $24.5
        #   result.1 = $24.6  :: int64
        #   del $24.6
        #   jump 22
        # label 40

        result += array[i]

    # --- LINE 11 --- 
    #   del result
    #   del array
    #   del $phi24.1
    #   del $phi22.1
    #   del $22.4
    #   jump 42
    # label 42
    #   $42.2 = cast(value=result.2)  :: int64
    #   del result.2
    #   return $42.2

    return result


================================================================================
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vygenerovaný kód v&nbsp;assembleru využívající SIMD instrukce</h2>

<pre>
_ZN8__main__13sum_array$241E5ArrayIxLi1E1C7mutable7alignedE:
        movq    16(%rsp), %rax
        testq   %rax, %rax
        jle     .LBB0_1
        movq    8(%rsp), %r9
        cmpq    $16, %rax
        jae     .LBB0_4
        xorl    %r8d, %r8d
        xorl    %ecx, %ecx
        jmp     .LBB0_13
.LBB0_1:
        xorl    %ecx, %ecx
        jmp     .LBB0_15
.LBB0_4:
        movq    %rax, %r8
        andq    $-16, %r8
        leaq    -16(%r8), %rdx
        movq    %rdx, %rsi
        shrq    $4, %rsi
        incq    %rsi
        movl    %esi, %ecx
        andl    $3, %ecx
        cmpq    $48, %rdx
        jae     .LBB0_6
        vpxor   %xmm0, %xmm0, %xmm0
        xorl    %edx, %edx
        vpxor   %xmm1, %xmm1, %xmm1
        vpxor   %xmm2, %xmm2, %xmm2
        vpxor   %xmm3, %xmm3, %xmm3
        jmp     .LBB0_8
.LBB0_6:
        subq    %rcx, %rsi
        vpxor   %xmm0, %xmm0, %xmm0
        xorl    %edx, %edx
        vpxor   %xmm1, %xmm1, %xmm1
        vpxor   %xmm2, %xmm2, %xmm2
        vpxor   %xmm3, %xmm3, %xmm3
        .p2align        4, 0x90
.LBB0_7:
        vpaddq  (%r9,%rdx,8), %ymm0, %ymm0
        vpaddq  32(%r9,%rdx,8), %ymm1, %ymm1
        vpaddq  64(%r9,%rdx,8), %ymm2, %ymm2
        vpaddq  96(%r9,%rdx,8), %ymm3, %ymm3
        vpaddq  128(%r9,%rdx,8), %ymm0, %ymm0
        vpaddq  160(%r9,%rdx,8), %ymm1, %ymm1
        vpaddq  192(%r9,%rdx,8), %ymm2, %ymm2
        vpaddq  224(%r9,%rdx,8), %ymm3, %ymm3
        vpaddq  256(%r9,%rdx,8), %ymm0, %ymm0
        vpaddq  288(%r9,%rdx,8), %ymm1, %ymm1
        vpaddq  320(%r9,%rdx,8), %ymm2, %ymm2
        vpaddq  352(%r9,%rdx,8), %ymm3, %ymm3
        vpaddq  384(%r9,%rdx,8), %ymm0, %ymm0
        vpaddq  416(%r9,%rdx,8), %ymm1, %ymm1
        vpaddq  448(%r9,%rdx,8), %ymm2, %ymm2
        vpaddq  480(%r9,%rdx,8), %ymm3, %ymm3
        addq    $64, %rdx
        addq    $-4, %rsi
        jne     .LBB0_7
.LBB0_8:
        testq   %rcx, %rcx
        je      .LBB0_11
        leaq    (%r9,%rdx,8), %rdx
        addq    $96, %rdx
        negq    %rcx
        .p2align        4, 0x90
.LBB0_10:
        vpaddq  -96(%rdx), %ymm0, %ymm0
        vpaddq  -64(%rdx), %ymm1, %ymm1
        vpaddq  -32(%rdx), %ymm2, %ymm2
        vpaddq  (%rdx), %ymm3, %ymm3
        subq    $-128, %rdx
        incq    %rcx
        jne     .LBB0_10
.LBB0_11:
        vpaddq  %ymm3, %ymm1, %ymm1
        vpaddq  %ymm2, %ymm0, %ymm0
        vpaddq  %ymm1, %ymm0, %ymm0
        vextracti128    $1, %ymm0, %xmm1
        vpaddq  %xmm1, %xmm0, %xmm0
        vpshufd $78, %xmm0, %xmm1
        vpaddq  %xmm1, %xmm0, %xmm0
        vmovq   %xmm0, %rcx
        cmpq    %rax, %r8
        je      .LBB0_15
        andl    $15, %eax
.LBB0_13:
        leaq    (%r9,%r8,8), %rdx
        incq    %rax
        .p2align        4, 0x90
.LBB0_14:
        addq    (%rdx), %rcx
        addq    $8, %rdx
        decq    %rax
        cmpq    $1, %rax
        jg      .LBB0_14
.LBB0_15:
        movq    %rcx, (%rdi)
        xorl    %eax, %eax
        vzeroupper
        retq
.Lfunc_end0:
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Režim <i>fast math</i></h2>

<pre>
from numba import jit

import numpy as np


@jit
def sum_array(array):
    result = 0.
    for x in array:
        result += np.sqrt(x)
    return result


array = np.arange(1, 100000001)
x = 0

for _ in range(100):
    x += sum_array(array)

print(sum_array(array))
</pre>

<pre>
from numba import jit

import numpy as np


@jit(nopython=True)
def sum_array(array):
    result = 0.
    for x in array:
        result += np.sqrt(x)
    return result


array = np.arange(1, 100000001)
x = 0

for _ in range(100):
    x += sum_array(array)

print(sum_array(array))
</pre>

<pre>
from numba import jit

import numpy as np


@jit(nopython=True, fastmath=True)
def sum_array(array):
    result = 0.
    for x in array:
        result += np.sqrt(x)
    return result


array = np.arange(1, 100000001)
x = 0

for _ in range(100):
    x += sum_array(array)

print(sum_array(array))
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Paralelizace výsledného kódu</h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Kdy se paralelizace vyplatí a kdy nikoli?</h2>

<pre>
import time

from numba import jit
import numpy as np


def regular_sum(a, b):
     return a+b


@jit(nopython=True)
def sequential_sum(a, b):
     return a+b


@jit(nopython=True,nogil=True,parallel=True)
def parallel_sum(a, b):
     return a+b


N = 1000

x = np.arange(0, N)
y = np.zeros(N)

print("Let's start")

z = regular_sum(x, y)
z = sequential_sum(x, y)
z = nogil_sum(x, y)
z = parallel_sum(x, y)

MAX = 100000

print("Compiled")

t1 = time.time()
for _ in range(MAX):
    z = regular_sum(x, y)
t2 = time.time()
print(t2-t1)

t1 = time.time()
for _ in range(MAX):
    z = sequential_sum(x, y)
t2 = time.time()
print(t2-t1)

t1 = time.time()
for _ in range(MAX):
    z = parallel_sum(x, y)
t2 = time.time()
print(t2-t1)
</pre>

<pre>
import time

from numba import jit
import numpy as np


def regular_sum(a, b):
     return a+b


@jit(nopython=True)
def sequential_sum(a, b):
     return a+b


@jit(nopython=True,nogil=True,parallel=True)
def parallel_sum(a, b):
     return a+b


N = 100000

x = np.arange(0, N)
y = np.zeros(N)

print("Let's start")

z = regular_sum(x, y)
z = sequential_sum(x, y)
z = nogil_sum(x, y)
z = parallel_sum(x, y)

MAX = 100000

print("Compiled")

t1 = time.time()
for _ in range(MAX):
    z = regular_sum(x, y)
t2 = time.time()
print(t2-t1)

t1 = time.time()
for _ in range(MAX):
    z = sequential_sum(x, y)
t2 = time.time()
print(t2-t1)

t1 = time.time()
for _ in range(MAX):
    z = parallel_sum(x, y)
t2 = time.time()
print(t2-t1)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Paralelní varianta programové smyčky <strong>for-range</strong></h2>

<pre>
from numba import jit
import numpy as np

@jit(nopython=True)
def range_sum(A):
    sum = 0
    for i in range(A.shape[0]):
        sum += A[i]
    return sum


a = range_sum(np.arange(10000))
print(a)
</pre>

<pre>
from numba import jit, prange
import numpy as np


@jit(nopython=True, parallel=True)
def prange_sum(A):
    sum = 0
    for i in prange(A.shape[0]):
        sum += A[i]
    return sum


a = prange_sum(np.arange(10000))
print(a)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

prange_loop.py
range_loop.py
sum4.py
sum5.py
sum6.py
sum_array.py
sum_sqrts1.py
sum_sqrts2.py
sum_sqrts3.py



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny skripty, které jsme si v&nbsp;dnešním i <a
href="https://www.root.cz/clanky/projekt-numba-aneb-dalsi-pristup-k-prekladu-pythonu-do-nativniho-kodu/">minulém</a>
článku ukázali, naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je nutné mít
nainstalovánu knihovnu Numba a její závislosti):</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>mandelbrot-v1</td><td>benchmark, v&nbsp;němž se nepoužívají anotace projektu Numba</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/"></a></td></tr>
<tr><td> 2</td><td>mandelbrot-v2</td><td>použití anotace <strong>@jit</strong> ve funkci, v&nbsp;níž se provádí mnoho výpočtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/"></a></td></tr>
<tr><td> 3</td><td>mandelbrot-v3</td><td>volání zjednodušených variant funkce <strong>print</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/"></a></td></tr>
<tr><td> 4</td><td>mandelbrot-v4</td><td>použití anotace <strong>@jit</strong> s&nbsp;parametrem <strong>nopython</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/"></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>sum1.py</td><td>funkce pro výpočet součtu dvou prvků, které je volána s&nbsp;argumenty typu <strong>int64</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum1.py</a></td></tr>
<tr><td> 6</td><td>sum2.py</td><td>funkce pro výpočet součtu dvou prvků, které je volána s&nbsp;argumenty typu <strong>double/float64</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum2.py</a></td></tr>
<tr><td> 7</td><td>sum3.py</td><td>funkce pro výpočet součtu dvou prvků volaná s&nbsp;argumenty různých typů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum3.py</a></td></tr>
<tr><td> 8</td><td>sum4.py</td><td>součet dvou polí z&nbsp;balíčku <i>Numpy</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum4.py</a></td></tr>
<tr><td> 9</td><td>sum5.py</td><td>porovnání různých variant součtu dvou polí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum5.py</a></td></tr>
<tr><td>10</td><td>sum6.py</td><td>dtto, ale pro větší počet volání funkce pro provedení součtu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>sum_array.py</td><td>explicitní zápis součtu všech prvků pole</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_array.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_array.py</a></td></tr>
<tr><td>12</td><td>range_loop.py</td><td>využití funkce <strong>range</strong> ve smyčce <strong>for</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/range_loop.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/range_loop.py</a></td></tr>
<tr><td>13</td><td>prange_loop.py</td><td>paralelní varianta funkce <strong>range</strong> ve smyčce <strong>for</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/prange_loop.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/prange_loop.py</a></td></tr>
<tr><td>14</td><td>sum_sqrts1.py</td><td>výpočet prováděný ve smyčce s&nbsp;akumulací výsledku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts1.py</a></td></tr>
<tr><td>15</td><td>sum_sqrts2.py</td><td>dtto, ovšem provedení v&nbsp;režimu <strong>nopython</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts2.py</a></td></tr>
<tr><td>16</td><td>sum_sqrts3.py</td><td>zapnutí režimu <i>fast array</i> při výpočtech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts3.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Numba<br />
<a href="http://numba.pydata.org/">http://numba.pydata.org/</a>
</li>

<li>numba 0.57.0<br />
<a href="https://pypi.org/project/numba/">https://pypi.org/project/numba/</a>
</li>

<li>Pushing Python toward C speeds with SIMD <br />
<a href="https://laurenar.net/posts/python-simd/">https://laurenar.net/posts/python-simd/</a>
</li>

<li>Retrieve generated LLVM from Numba<br />
<a href="https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba">https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba</a>
</li>

<li>Numba documentation<br />
<a href="http://numba.pydata.org/numba-doc/latest/index.html">http://numba.pydata.org/numba-doc/latest/index.html</a>
</li>

<li>Numba na GitHubu<br />
<a href="https://github.com/numba/numba">https://github.com/numba/numba</a>
</li>

<li>First Steps with numba<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html</a>
</li>

<li>Numba and types<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html</a>
</li>

<li>Just-in-time compilation<br />
<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">https://en.wikipedia.org/wiki/Just-in-time_compilation</a>
</li>

<li>Cython (home page)<br />
<a href="http://cython.org/">http://cython.org/</a>
</li>

<li>Cython (wiki)<br />
<a href="https://github.com/cython/cython/wiki">https://github.com/cython/cython/wiki</a>
</li>

<li>Cython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cython">https://en.wikipedia.org/wiki/Cython</a>
</li>

<li>Cython (GitHub)<br />
<a href="https://github.com/cython/cython">https://github.com/cython/cython</a>
</li>

<li>Python Implementations: Compilers<br />
<a href="https://wiki.python.org/moin/PythonImplementations#Compilers">https://wiki.python.org/moin/PythonImplementations#Compilers</a>
</li>

<li>EmbeddingCython<br />
<a href="https://github.com/cython/cython/wiki/EmbeddingCython">https://github.com/cython/cython/wiki/EmbeddingCython</a>
</li>

<li>The Basics of Cython<br />
<a href="http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html">http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html</a>
</li>

<li>Overcoming Python's GIL with Cython<br />
<a href="https://lbolla.info/python-threads-cython-gil">https://lbolla.info/python-threads-cython-gil</a>
</li>

<li>GlobalInterpreterLock<br />
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>
</li>

<li>The Magic of RPython<br />
<a href="https://refi64.com/posts/the-magic-of-rpython.html">https://refi64.com/posts/the-magic-of-rpython.html</a>
</li>

<li>RPython: Frequently Asked Questions<br />
<a href="http://rpython.readthedocs.io/en/latest/faq.html">http://rpython.readthedocs.io/en/latest/faq.html</a>
</li>

<li>RPython’s documentation<br />
<a href="http://rpython.readthedocs.io/en/latest/index.html">http://rpython.readthedocs.io/en/latest/index.html</a>
</li>

<li>RPython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/PyPy#RPython">https://en.wikipedia.org/wiki/PyPy#RPython</a>
</li>

<li>Getting Started with RPython<br />
<a href="http://rpython.readthedocs.io/en/latest/getting-started.html">http://rpython.readthedocs.io/en/latest/getting-started.html</a>
</li>

<li>PyPy (home page)<br />
<a href="https://pypy.org/">https://pypy.org/</a>
</li>

<li>PyPy (dokumentace)<br />
<a href="http://doc.pypy.org/en/latest/">http://doc.pypy.org/en/latest/</a>
</li>

<li>Localized Type Inference of Atomic Types in Python (2005)<br />
<a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231</a>
</li>

<li>Tutorial: Writing an Interpreter with PyPy, Part 1<br />
<a href="https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html">https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html</a>
</li>

<li>List of numerical analysis software<br />
<a href="https://en.wikipedia.org/wiki/List_of_numerical_analysis_software">https://en.wikipedia.org/wiki/List_of_numerical_analysis_software</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>The future can be written in RPython now (článek z&nbsp;roku 2010)<br />
<a href="http://blog.christianperone.com/2010/05/the-future-can-be-written-in-rpython-now/">http://blog.christianperone.com/2010/05/the-future-can-be-written-in-rpython-now/</a>
</li>

<li>PyPy is the Future of Python (článek z&nbsp;roku 2010)<br />
<a href="https://alexgaynor.net/2010/may/15/pypy-future-python/">https://alexgaynor.net/2010/may/15/pypy-future-python/</a>
</li>

<li>Portal:Python programming<br />
<a href="https://en.wikipedia.org/wiki/Portal:Python_programming">https://en.wikipedia.org/wiki/Portal:Python_programming</a>
</li>

<li>RPython Frontend and C Wrapper Generator<br />
<a href="http://www.codeforge.com/article/383293">http://www.codeforge.com/article/383293</a>
</li>

<li>PyPy’s Approach to Virtual Machine Construction<br />
<a href="https://bitbucket.org/pypy/extradoc/raw/tip/talk/dls2006/pypy-vm-construction.pdf">https://bitbucket.org/pypy/extradoc/raw/tip/talk/dls2006/pypy-vm-construction.pdf</a>
</li>

<li>Tutorial: Writing an Interpreter with PyPy, Part 1<br />
<a href="https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html">https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html</a>
</li>

<li>A simple interpreter from scratch in Python (part 1)<br />
<a href="http://www.jayconrod.com/posts/37/a-simple-interpreter-from-scratch-in-python-part-1">http://www.jayconrod.com/posts/37/a-simple-interpreter-from-scratch-in-python-part-1</a>
</li>

<li>Brainfuck Interpreter in Python<br />
<a href="https://helloacm.com/brainfuck-interpreter-in-python/">https://helloacm.com/brainfuck-interpreter-in-python/</a>
</li>

<li>Interpretry, překladače, JIT překladače a transpřekladače programovacího jazyka Lua<br />
<a href="https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/">https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (5 – tabulky a pole)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (6 – překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (7 – dokončení popisu mezijazyka LuaJITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (8 – základní vlastnosti trasovacího JITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (9 – další vlastnosti trasovacího JITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (10 – JIT překlad do nativního kódu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (11 – JIT překlad do nativního kódu procesorů s architekturami x86 a ARM)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (12 – překlad operací s reálnými čísly)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

<li>Podpora SIMD (vektorových) instrukcí na RISCových procesorech<br />
<a href="https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/">https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/</a>
</li>

<li>Užitečné rozšíření GCC – podpora SIMD (vektorových) instrukcí: nedostatky technologie<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic pro nízkoúrovňové optimalizace<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic: technologie SSE<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/</a>
</li>

<li>Rozšíření instrukční sady „Advanced Vector Extensions“ na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady F16C, FMA a AVX-512 na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/</a>
</li>

<li>Použití instrukcí SSE a AVX pro zrychlení bitových operací<br />
<a href="https://www.root.cz/clanky/pouziti-instrukci-sse-a-avx-pro-zrychleni-bitovych-operaci/">https://www.root.cz/clanky/pouziti-instrukci-sse-a-avx-pro-zrychleni-bitovych-operaci/</a>
</li>

<li>Rozšíření instrukční sady AVX-512 na platformě x86–64 (dokončení)<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/</a>
</li>

<li>Nuitka<br />
<a href="https://github.com/Nuitka/Nuitka">https://github.com/Nuitka/Nuitka</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

