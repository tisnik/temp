<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes se seznámíme se základními vlastnostmi knihovny LibCST. Tato knihovna umožňuje snadnou modifikaci zdrojových kódů Pythonu. Tato modifikace ovšem pochopitelně neprobíhá přímo na úrovni zdrojového kódu, sekvence tokenů ani nad AST, ale nad CST (Concrete Syntax Tree).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu</a></p>
<p><a href="#k02">2. AST vs CST</a></p>
<p><a href="#k03">3. Parsing jednoduchého výrazu s&nbsp;konstrukcí CST</a></p>
<p><a href="#k04">4. Zobrazení struktury výsledného CST</a></p>
<p><a href="#k05">5. Zachování formátu výrazu i konstant ve výrazu</a></p>
<p><a href="#k06">6. Rozdíl mezi identifikátorem a řetězcem</a></p>
<p><a href="#k07">7. Strom s&nbsp;reprezentací složitějších výrazů</a></p>
<p><a href="#k08">8. Strom, který reprezentuje výraz &bdquo;6*7&ldquo;</a></p>
<p><a href="#k09">9. Bílé znaky zapsané ve výrazu</a></p>
<p><a href="#k10">10. Výraz obalený závorkami</a></p>
<p><a href="#k11">11. Strom pro složitější výraz s&nbsp;několika operátory</a></p>
<p><a href="#k12">12. Parsing celého modulu</a></p>
<p><a href="#k13">13. Ukázky parsingu dalších jednoduchých modulů</a></p>
<p><a href="#k14">14. Modul s&nbsp;definicí funkce</a></p>
<p><a href="#k15">15. Realizace průchodu CST</a></p>
<p><a href="#k16">16. Výpis uzlů stromu tak, aby byla viditelná jeho struktura</a></p>
<p><a href="#k17">17. Získání dalších informací o uzlech známých typů</a></p>
<p><a href="#k18">18. Různé zpracování uzlů podle jejich typů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu</h2>

<p>Na čtveřici článků, v&nbsp;nichž jsme se zabývali problematikou lexikální a
syntaktické analýzy zdrojových kódů programovacího jazyka Python [<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">1</a>]
[<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">2</a>]
[<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">3</a>]
[<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">4</a>]
dnes do jisté míry navážeme. Víme již, jak je možné s&nbsp;využitím
standardních modulů <strong>tokenize</strong> a <strong>ast</strong> provést
takzvanou <i>tokenizaci</i> a následně <i>parsing</i> zdrojových kódů, jehož
výsledkem je <i>AST</i> neboli abstraktní syntaktický strom (<i>Abstract Syntax
Tree</i>). Tyto techniky nám umožní manipulovat s&nbsp;programovým kódem na
vhodné úrovni abstrakce, protože abstraktní syntaktický strom je pro tyto účely
mnohem vhodnější, než přímo zdrojový kód či pouhá sekvence tokenů.
Z&nbsp;tohoto důvodu je tokenizace a parsing součástí většiny linterů i dalších
analyzátorů programových kódů.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. AST vs CST</h2>

<p>Standardní abstraktní syntaktický strom má ovšem jednu poměrně zásadní
nevýhodu &ndash; v&nbsp;případě, že <i>AST</i> upravíme a necháme si
z&nbsp;něho zpětně vygenerovat zdrojový kód, ztratíme veškeré původní
formátování, tedy například mezery zapsané ve výrazech, přesné umístění
komentářů atd. Z&nbsp;tohoto důvodu se pro ty nástroje, které musí modifikovat
zdrojový kód (nepřímo &ndash; přes strom) používají nepatrně odlišné typy
stromů, které se nazývají <i>Concrete Syntax Tree</i> neboli zkráceně
<i>CST</i> (popř.&nbsp;<i>derivační stromy</i> nebo <i>parse tree</i>). Tyto
stromové datové struktury, jak již ostatně jejich název napovídá, reprezentují
syntaktickou strukturu daného bloku programového kódu (což může být konstanta,
výraz, příkaz, složený blok, funkce, třída, či celý modul). Díky tomu, že si
<i>CST</i> pamatuje původní zápis syntaktických prvků, je umožněna relativně
snadná tvorba nástrojů pro refaktoring kódu. Pro manipulaci s&nbsp;<i>CST</i>
slouží v&nbsp;Pythonu knihovna <i>LibCST</i>, s&nbsp;jejímiž základními
vlastnostmi se seznámíme v&nbsp;dnešním článku.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Parsing jednoduchého výrazu s&nbsp;konstrukcí CST</h2>

<p>Možnosti knihovny <i>LibCST</i> si otestujeme na množství demonstračních
příkladů. První příklady budou velmi jednoduché, protože budeme zpracovávat
zdrojový kód obsahující pouze jedinou konstantu. Může se jednat například o
konstantu představující celé číslo (což je v&nbsp;Pythonu zcela korektní
zdrojový kód):</p>

<pre>
42
</pre>

<p>Tato konstanta (tedy její zdrojový kód) se zpracuje tokenizérem a parserem
takto:</p>

<pre>
from libcst import parse_expression
&nbsp;
constant = "42"
&nbsp;
parsed = parse_expression(constant)
</pre>

<p>Výsledek, tedy obsah proměnné <strong>parsed</strong>, je datová struktura
přesně popisující výraz s&nbsp;konstantou. Tuto datovou strukturu si můžeme
přímo zobrazit:</p>

<pre>
print(parsed)
</pre>

<p>Ovšem užitečnější bývá použití pomocné funkce <strong>dump</strong>, která
vytiskne CST v&nbsp;čitelnější podobě:</p>

<pre>
from libcst.tool import dump
&nbsp;
dumped = dump(parsed)
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalších příkladech budeme
používat oba způsoby výstupu, takže se sami budete moci přesvědčit, která
vizualizace CST (a onen textový výstup ničím jiným, než vizualizací není) je
výhodnější.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zobrazení struktury výsledného CST</h2>

<p>Celý skript, který provede parsing výrazu do CST a následně zobrazí
strukturu CST, vypadá následovně:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
constant = "42"
&nbsp;
parsed = parse_expression(constant)
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py</a>.</div></p>

<p>Po spuštění tohoto skriptu se nejdříve zobrazí CST se všemi podrobnostmi a
posléze &bdquo;pouze&ldquo; výsledek operace <strong>dump</strong>, který je
stručnější a v&nbsp;tomto případě i čitelnější:</p>

<pre>
Parsed:
Integer(
    value='42',
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
Integer(
  value='42',
)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zachování formátu výrazu i konstant ve výrazu</h2>

<p>Knihovna <i>LibCST</i> se nesnaží o &bdquo;normalizaci&ldquo; výrazů ani
hodnot, které jsou ve výrazu specifikovány. To je nutné, aby bylo možné
zrekonstruovat původní výraz přesně v&nbsp;takové podobě, v&nbsp;jaké byl
původně zapsán (samozřejmě za předpokladu, že nedojde k&nbsp;modifikaci
stromu).</p>

<p>Vyzkoušejme si, jak bude zparsován výraz s&nbsp;konstantou 1_000, což je
běžná celočíselná konstanta 1000, do které byl přidán nepovinný oddělovač
řádu:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
constant = "1_000"
&nbsp;
parsed = parse_expression(constant)
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py</a>.</div></p>

<p>V&nbsp;CST stromu nalezneme původní zápis konstanty, což nám (jak již víme)
umožní rekonstrukci originální podoby výrazu:</p>

<pre>
Parsed:
Integer(
    value='1_000',
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
Integer(
  value='1_000',
)
</pre>

<p>Nakonec si ještě pro úplnost ukažme výsledek parsingu komplexního čísla:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
<strong>constant = "1+2j"</strong>
&nbsp;
parsed = <strong>parse_expression(constant)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p>Zkonstruovaný strom vypadá takto:</p>

<pre>
Parsed:
BinaryOperation(
    left=Integer(
        value='1',
        lpar=[],
        rpar=[],
    ),
    operator=Add(
        whitespace_before=SimpleWhitespace(
            value='',
        ),
        whitespace_after=SimpleWhitespace(
            value='',
        ),
    ),
    right=Imaginary(
        value='2j',
        lpar=[],
        rpar=[],
    ),
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
BinaryOperation(
  left=Integer(
    value='1',
  ),
  operator=Add(),
  right=Imaginary(
    value='2j',
  ),
)
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;pohledu CST se tedy nejedná o
konstantu, ale o složitější výraz. K&nbsp;nim se vrátíme v&nbsp;sedmé
kapitole.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozdíl mezi identifikátorem a řetězcem</h2>

<p>Zkusme si nyní nechat převést na CST výraz obsahující jedinou konstantu
<strong>True</strong>. Samotný výraz, který má být zparsován, je uložen
v&nbsp;řetězci, což může být v&nbsp;tomto případě poněkud matoucí, ovšem
knihovna LibCST parsuje zdrojový kód uložený v&nbsp;řetězci, takže zápis
&bdquo;True&ldquo; skutečně znamená logickou konstantu
<strong>True</strong>:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
<strong>constant = "True"</strong>
&nbsp;
parsed = <strong>parse_expression(constant)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_3.py</a>.</div></p>

<p>Povšimněte si, že se ve výsledném CST stromu objevil uzel typu
<strong>Name</strong>. LibCST tedy nerozlišuje mezi běžným pojmenovaným
identifikátorem a &bdquo;speciálními&ldquo; identifikátory typu
<strong>True</strong>, <strong>False</strong> či <strong>None</strong> (což
může později způsobovat nepatrné problémy při analýze programu):</p>

<pre>
Parsed:
Name(
    value='True',
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
Name(
  value='True',
)
</pre>

<p>Naproti tomu zápis <strong>"'True'"</strong> (dvojice uvozovek) značí
řetězcový literál, který jen náhodou obsahuje známé slovo:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
<strong>constant = "'True'"</strong>
&nbsp;
parsed = <strong>parse_expression(constant)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_4.py</a>.</div></p>

<p>Rozdíl je ihned patrný při pohledu na typ uzlu stromu &ndash; nyní se jedná
o uzel <strong>SimpleString</strong> a nikoli o uzel <strong>Name</strong>:</p>

<pre>
Parsed:
SimpleString(
    value="'True'",
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
SimpleString(
  value="'True'",
)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Strom s&nbsp;reprezentací složitějších výrazů</h2>

<p>Prozatím jsme si ukázali parsing těch nejjednodušších možných výrazů, které
obsahovaly jen jedinou hodnotu &ndash; buď konstantu (celočíselnou, řetězec
atd.) nebo jméno identifikátoru. Speciálním případem bylo komplexní číslo,
které je vlastně výrazem s&nbsp;reálnou a imaginární složkou. Ovšem
v&nbsp;praxi se pochopitelně setkáme s&nbsp;mnohem složitějšími výrazy.
V&nbsp;rámci navazujících kapitol si ukážeme, jak knihovna <i>LibCST</i> ze
složitějších výrazů tvoří strom. A odtud je již jen malý krok k&nbsp;parsingu
programových bloků, funkcí, či celých modulů.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Strom, který reprezentuje výraz &bdquo;6*7&ldquo;</h2>

<p>Podívejme se na způsob parsingu výrazu 6*7, tedy výrazu obsahujícího
aritmetickou operaci součinu. Samotný skript zůstane zachován, pouze se změní
výraz, se kterým se bude pracovat:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
<strong>expression = "6*7"</strong>
&nbsp;
parsed = <strong>parse_expression(expression)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_1.py</a>.</div></p>

<p>Výsledkem nyní bude strom obsahující kořenový uzel typu
<strong>BinaryOperation</strong>. Tento uzel obsahuje trojici poduzlů
reprezentujících postupně celé číslo, operátor součinu a další celé číslo. To
znamená, že samotný uzel <strong>BinaryOperation</strong> nenese informaci o
prováděné operaci; je nutné se podívat do poduzlů. Taktéž si povšimněte
atributů <strong>lpar</strong> a <strong>rpar</strong>, v&nbsp;nichž mohou být
uloženy informace o závorkách (zde žádné závorky nepoužíváme) a atributů
<strong>whitespace_before</strong> a <strong>whitespace_after</strong>,
k&nbsp;nimž se ještě vrátíme:</p>

<pre>
BinaryOperation(
    left=Integer(
        value='6',
        lpar=[],
        rpar=[],
    ),
    operator=Multiply(
        whitespace_before=SimpleWhitespace(
            value='',
        ),
        whitespace_after=SimpleWhitespace(
            value='',
        ),
    ),
    right=Integer(
        value='7',
        lpar=[],
        rpar=[],
    ),
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
BinaryOperation(
  left=Integer(
    value='6',
  ),
  operator=Multiply(),
  right=Integer(
    value='7',
  ),
)
</pre>

<p><div class="rs-tip-major">Poznámka: druhý výstup (dumped) je opět
čitelnější, neboť neobsahuje prázdné atributy.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Bílé znaky zapsané ve výrazu</h2>

<p>V&nbsp;samotném výrazu povoluje programovací jazyk Python používat bílé
znaky, ostatně podobně jako mnohé další programovací jazyky. Ovšem tyto bílé
znaky musí být v&nbsp;CST zachovány, aby bylo možné zrekonstruovat původní
zdrojový kód. Podívejme se tedy na výsledek parsingu výrazu 6 * 7 (tedy
s&nbsp;mezerami mezi celočíselnými konstantami a operátorem):</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
<strong>expression = "6 * 7"</strong>
&nbsp;
parsed = <strong>parse_expression(expression)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_2.py</a>.</div></p>

<p>Bílé znaky jsou v&nbsp;CST uloženy v&nbsp;atributech
<strong>whitespace_before</strong> a <strong>whitespace_after</strong>
v&nbsp;uzlu typu <strong>Multiply</strong>, což sice může vypadat zvláštně,
ovšem umožní snadnou rekonstrukci zdrojového kódu:</p>

<pre>
BinaryOperation(
    left=Integer(
        value='6',
        lpar=[],
        rpar=[],
    ),
    operator=Multiply(
        whitespace_before=SimpleWhitespace(
            value=' ',
        ),
        whitespace_after=SimpleWhitespace(
            value=' ',
        ),
    ),
    right=Integer(
        value='7',
        lpar=[],
        rpar=[],
    ),
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
BinaryOperation(
  left=Integer(
    value='6',
  ),
  operator=Multiply(),
  right=Integer(
    value='7',
  ),
)
</pre>

<p>Co se ovšem stane ve chvíli, kdy mezeru umístíme před první celočíselnou
konstantu? Otestujme si i tento případ:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
<strong>expression = " 6 * 7 "</strong>
&nbsp;
parsed = <strong>parse_expression(expression)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_3.py</a>.</div></p>

<p>Nyní dojde při pokusu o konstrukci CST k&nbsp;výjimce, jak je to ostatně
patrné i z&nbsp;následujícího opisu obsahu terminálu:</p>

<pre>
Traceback (most recent call last):
  File "parse_expression_3.py", line 10, in &lt;module&gt;
    parsed = parse_expression(expression)
  File "/home/ptisnovs/.local/lib/python3.12/site-packages/libcst/_parser/entrypoints.py", line 160, in parse_expression
    result = _parse(
  File "/home/ptisnovs/.local/lib/python3.12/site-packages/libcst/_parser/entrypoints.py", line 55, in _parse
    return parse(source_str)
libcst._exceptions.ParserSyntaxError: Syntax Error @ 1:1.
parser error: error at 1:1: expected one of *, +, -, ..., AWAIT, False, NAME, NUMBER, None, True, lambda, not, ~
&nbsp;
 6 * 7 
^
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výraz obalený závorkami</h2>

<p>Celý výraz může být v&nbsp;Pythonu obalený závorkami. V&nbsp;takovém případě
závorky nemají syntaktický význam, ovšem opět platí, že musí být zachovány, aby
bylo možné provést rekonstrukci původního zdrojového kódu. Vyzkoušejme si tedy,
jakým způsobem jsou tyto závorky reprezentovány v&nbsp;CST:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
<strong>expression = "(6*7)"</strong>
&nbsp;
parsed = <strong>parse_expression(expression)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_5.py</a>.</div></p>

<p>Z&nbsp;výpisu stromu je patrné, že informace o závorkách jsou uloženy
v&nbsp;atributech nazvaných <strong>lpar</strong> a <strong>rpar</strong>. Tyto
atributy v&nbsp;našem případě obsahují informace o typu závorek a případně i
informace o mezerách mezi závorkami a výrazem (zde již jsou mezery
povoleny):</p>

<pre>
Parsed:
BinaryOperation(
    left=Integer(
        value='6',
        lpar=[],
        rpar=[],
    ),
    operator=Multiply(
        whitespace_before=SimpleWhitespace(
            value='',
        ),
        whitespace_after=SimpleWhitespace(
            value='',
        ),
    ),
    right=Integer(
        value='7',
        lpar=[],
        rpar=[],
    ),
    lpar=[
        LeftParen(
            whitespace_after=SimpleWhitespace(
                value='',
            ),
        ),
    ],
    rpar=[
        RightParen(
            whitespace_before=SimpleWhitespace(
                value='',
            ),
        ),
    ],
)
&nbsp;
Dumped:
BinaryOperation(
  left=Integer(
    value='6',
  ),
  operator=Multiply(),
  right=Integer(
    value='7',
  ),
  lpar=[
    LeftParen(),
  ],
  rpar=[
    RightParen(),
  ],
)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Strom pro složitější výraz s&nbsp;několika operátory</h2>

<p>Knihovna LibCST pochopitelně dokáže zparsovat prakticky libovolně složitý
výraz a vytvořit z&nbsp;něj strom, který původní výraz plnohodnotně
reprezentuje. Ukažme si to na příkladu výrazu <strong>(1+2)*3/2**4</strong>,
v&nbsp;němž jsou použity operátory s&nbsp;různou prioritou i asociativitou a
navíc i kulaté závorky, které mění prioritu operací:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
expression = <strong>"(1+2)*3/2**4"</strong>
&nbsp;
parsed = <strong>parse_expression(expression)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_4.py</a>.</div></p>

<p>Výsledný strom již obsahuje větší množství poduzlů, což je ostatně jen pochopitelné:</p>

<pre>
Parsed:
BinaryOperation(
    left=BinaryOperation(
        left=BinaryOperation(
            left=Integer(
                value='1',
                lpar=[],
                rpar=[],
            ),
            operator=Add(
                whitespace_before=SimpleWhitespace(
                    value='',
                ),
                whitespace_after=SimpleWhitespace(
                    value='',
                ),
            ),
            right=Integer(
                value='2',
                lpar=[],
                rpar=[],
            ),
            lpar=[
                LeftParen(
                    whitespace_after=SimpleWhitespace(
                        value='',
                    ),
                ),
            ],
            rpar=[
                RightParen(
                    whitespace_before=SimpleWhitespace(
                        value='',
                    ),
                ),
            ],
        ),
        operator=Multiply(
            whitespace_before=SimpleWhitespace(
                value='',
            ),
            whitespace_after=SimpleWhitespace(
                value='',
            ),
        ),
        right=Integer(
            value='3',
            lpar=[],
            rpar=[],
        ),
        lpar=[],
        rpar=[],
    ),
    operator=Divide(
        whitespace_before=SimpleWhitespace(
            value='',
        ),
        whitespace_after=SimpleWhitespace(
            value='',
        ),
    ),
    right=BinaryOperation(
        left=Integer(
            value='2',
            lpar=[],
            rpar=[],
        ),
        operator=Power(
            whitespace_before=SimpleWhitespace(
                value='',
            ),
            whitespace_after=SimpleWhitespace(
                value='',
            ),
        ),
        right=Integer(
            value='4',
            lpar=[],
            rpar=[],
        ),
        lpar=[],
        rpar=[],
    ),
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
BinaryOperation(
  left=BinaryOperation(
    left=BinaryOperation(
      left=Integer(
        value='1',
      ),
      operator=Add(),
      right=Integer(
        value='2',
      ),
      lpar=[
        LeftParen(),
      ],
      rpar=[
        RightParen(),
      ],
    ),
    operator=Multiply(),
    right=Integer(
      value='3',
    ),
  ),
  operator=Divide(),
  right=BinaryOperation(
    left=Integer(
      value='2',
    ),
    operator=Power(),
    right=Integer(
      value='4',
    ),
  ),
)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Parsing celého modulu</h2>

<p>Prozatím jsme pro parsing konstant a výrazů používali funkci
<strong>libcst.parse_expression</strong>. Ovšem v&nbsp;případě, že se parsují
větší celky kódu, které mohou obsahovat další metainformace atd., se namísto
této funkce může použít funkce nazvaná <strong>libcst.parse_module</strong>.
Výsledný strom přitom bude odlišný, i když se bude ve skutečnosti parsovat
naprosto stejný výraz. Ostatně si to můžeme velmi snadno ověřit:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module
from libcst.tool import dump
&nbsp;
&nbsp;
expression = <strong>"1 + 2"</strong>
&nbsp;
parsed = <strong>parse_module(expression)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
&nbsp;
print()
</pre>

<p>Výsledkem bude strom reprezentující celý modul, tedy jeho tělo, které
obsahuje řádky kódu atd. Podívejme se na výsledek, z&nbsp;něhož je patrné, že
je celý modul reprezentován uzlem typu <strong>Module</strong>. Navíc jsou
formou atributů přidány metainformace o modulu:</p>

<pre>
Parsed:
Module(
    body=[
        SimpleStatementLine(
            body=[
                Expr(
                    value=BinaryOperation(
                        left=Integer(
                            value='1',
                            lpar=[],
                            rpar=[],
                        ),
                        operator=Add(
                            whitespace_before=SimpleWhitespace(
                                value=' ',
                            ),
                            whitespace_after=SimpleWhitespace(
                                value=' ',
                            ),
                        ),
                        right=Integer(
                            value='2',
                            lpar=[],
                            rpar=[],
                        ),
                        lpar=[],
                        rpar=[],
                    ),
                    semicolon=MaybeSentinel.DEFAULT,
                ),
            ],
            leading_lines=[],
            trailing_whitespace=TrailingWhitespace(
                whitespace=SimpleWhitespace(
                    value='',
                ),
                comment=None,
                newline=Newline(
                    value=None,
                ),
            ),
        ),
    ],
    header=[],
    footer=[],
    encoding='utf-8',
    default_indent='    ',
    default_newline='\n',
    has_trailing_newline=False,
)
&nbsp;
Dumped:
Module(
  body=[
    SimpleStatementLine(
      body=[
        Expr(
          value=BinaryOperation(
            left=Integer(
              value='1',
            ),
            operator=Add(),
            right=Integer(
              value='2',
            ),
          ),
        ),
      ],
    ),
  ],
)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Ukázky parsingu dalších jednoduchých modulů</h2>

<p>Podívejme se na příklad parsingu dalších jednoduchých modulů. Začneme
modulem, který obsahuje pouze výraz, ovšem s&nbsp;různým počtem mezer mezi
operandem a operátorem. I tyto mezery pochopitelně musí zůstat zachovány
v&nbsp;CST, aby se z&nbsp;něho dal zpětně vytvořit původní zdrojový kód:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module
from libcst.tool import dump
&nbsp;
&nbsp;
expression = <strong>"1  + 2"</strong>
&nbsp;
parsed = parse_module(expression)
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
&nbsp;
print()
&nbsp;
code = parsed.code
print("Code:")
print(code)
</pre>

<p>Ve výsledném CST se zaměřte především na atributy
<strong>whitespace_before</strong> a <strong>whitespace_after</strong>
v&nbsp;uzlu typu <strong>Add</strong>. A opět si povšimněte, že se na konci
vypsal i původní zdrojový kód (včetně všech mezer atd.):</p>

<pre>
Parsed:
Module(
    body=[
        SimpleStatementLine(
            body=[
                Expr(
                    value=BinaryOperation(
                        left=Integer(
                            value='1',
                            lpar=[],
                            rpar=[],
                        ),
                        operator=Add(
                            whitespace_before=SimpleWhitespace(
                                value='  ',
                            ),
                            whitespace_after=SimpleWhitespace(
                                value=' ',
                            ),
                        ),
                        right=Integer(
                            value='2',
                            lpar=[],
                            rpar=[],
                        ),
                        lpar=[],
                        rpar=[],
                    ),
                    semicolon=MaybeSentinel.DEFAULT,
                ),
            ],
            leading_lines=[],
            trailing_whitespace=TrailingWhitespace(
                whitespace=SimpleWhitespace(
                    value='',
                ),
                comment=None,
                newline=Newline(
                    value=None,
                ),
            ),
        ),
    ],
    header=[],
    footer=[],
    encoding='utf-8',
    default_indent='    ',
    default_newline='\n',
    has_trailing_newline=False,
)
&nbsp;
Dumped:
Module(
  body=[
    SimpleStatementLine(
      body=[
        Expr(
          value=BinaryOperation(
            left=Integer(
              value='1',
            ),
            operator=Add(),
            right=Integer(
              value='2',
            ),
          ),
        ),
      ],
    ),
  ],
)
&nbsp;
Code:
1  + 2
</pre>

<p>Dále se podívejme na modul s&nbsp;logickým výrazem:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module
from libcst.tool import dump
&nbsp;
&nbsp;
expression = <strong>"True or False"</strong>
&nbsp;
parsed = parse_module(expression)
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
&nbsp;
print()
&nbsp;
code = parsed.code
print("Code:")
print(code)
</pre>

<p>Ve výsledném stromu nalezneme uzel typu <strong>BooleanOperation</strong>
s&nbsp;poduzlem <strong>Or</strong> a pochopitelně i poduzly obsahujícími oba
operandy:</p>

<pre>
Parsed:
Module(
    body=[
        SimpleStatementLine(
            body=[
                Expr(
                    value=BooleanOperation(
                        left=Name(
                            value='True',
                            lpar=[],
                            rpar=[],
                        ),
                        operator=Or(
                            whitespace_before=SimpleWhitespace(
                                value=' ',
                            ),
                            whitespace_after=SimpleWhitespace(
                                value=' ',
                            ),
                        ),
                        right=Name(
                            value='False',
                            lpar=[],
                            rpar=[],
                        ),
                        lpar=[],
                        rpar=[],
                    ),
                    semicolon=MaybeSentinel.DEFAULT,
                ),
            ],
            leading_lines=[],
            trailing_whitespace=TrailingWhitespace(
                whitespace=SimpleWhitespace(
                    value='',
                ),
                comment=None,
                newline=Newline(
                    value=None,
                ),
            ),
        ),
    ],
    header=[],
    footer=[],
    encoding='utf-8',
    default_indent='    ',
    default_newline='\n',
    has_trailing_newline=False,
)
&nbsp;
Dumped:
Module(
  body=[
    SimpleStatementLine(
      body=[
        Expr(
          value=BooleanOperation(
            left=Name(
              value='True',
            ),
            operator=Or(),
            right=Name(
              value='False',
            ),
          ),
        ),
      ],
    ),
  ],
)
&nbsp;
Code:
True or False
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Modul s&nbsp;definicí funkce</h2>

<p>Pouze pro úplnost (k&nbsp;tomuto tématu se totiž ještě vrátíme) si ukažme,
jakým způsobem lze naparsovat modul obsahující definici jedné funkce
(s&nbsp;dvojicí parametrů). Pro jednoduchost tato funkce neobsahuje typové
informace, protože i ty se pochopitelně v&nbsp;CST musí zachovat:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module
from libcst.tool import dump
&nbsp;
&nbsp;
module = """
<strong>def add(x, y):</strong>
<strong>    return x + y</strong>
"""
&nbsp;
parsed = parse_module(module)
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
&nbsp;
print()
&nbsp;
code = parsed.code
print("Code:")
print(code)
</pre>

<p>Výsledkem je již poměrně rozsáhlý strom, jehož stručná verze je však stále
dobře čitelná. Povšimněte si toho, že u funkce je uloženo jak její tělo, tak i
podrobné informace o parametrech atd. A až do zdrojového kódu přidáme typové
informace, nalezneme v&nbsp;CST stromu i tyto atributy:</p>

<pre>
Parsed:
Module(
    body=[
        FunctionDef(
            name=Name(
                value='add',
                lpar=[],
                rpar=[],
            ),
            params=Parameters(
                params=[
                    Param(
                        name=Name(
                            value='x',
                            lpar=[],
                            rpar=[],
                        ),
                        annotation=None,
                        equal=MaybeSentinel.DEFAULT,
                        default=None,
                        comma=Comma(
                            whitespace_before=SimpleWhitespace(
                                value='',
                            ),
                            whitespace_after=SimpleWhitespace(
                                value=' ',
                            ),
                        ),
                        star='',
                        whitespace_after_star=SimpleWhitespace(
                            value='',
                        ),
                        whitespace_after_param=SimpleWhitespace(
                            value='',
                        ),
                    ),
                    Param(
                        name=Name(
                            value='y',
                            lpar=[],
                            rpar=[],
                        ),
                        annotation=None,
                        equal=MaybeSentinel.DEFAULT,
                        default=None,
                        comma=MaybeSentinel.DEFAULT,
                        star='',
                        whitespace_after_star=SimpleWhitespace(
                            value='',
                        ),
                        whitespace_after_param=SimpleWhitespace(
                            value='',
                        ),
                    ),
                ],
                star_arg=MaybeSentinel.DEFAULT,
                kwonly_params=[],
                star_kwarg=None,
                posonly_params=[],
                posonly_ind=MaybeSentinel.DEFAULT,
            ),
            body=IndentedBlock(
                body=[
                    SimpleStatementLine(
                        body=[
                            Return(
                                value=BinaryOperation(
                                    left=Name(
                                        value='x',
                                        lpar=[],
                                        rpar=[],
                                    ),
                                    operator=Add(
                                        whitespace_before=SimpleWhitespace(
                                            value=' ',
                                        ),
                                        whitespace_after=SimpleWhitespace(
                                            value=' ',
                                        ),
                                    ),
                                    right=Name(
                                        value='y',
                                        lpar=[],
                                        rpar=[],
                                    ),
                                    lpar=[],
                                    rpar=[],
                                ),
                                whitespace_after_return=SimpleWhitespace(
                                    value=' ',
                                ),
                                semicolon=MaybeSentinel.DEFAULT,
                            ),
                        ],
                        leading_lines=[],
                        trailing_whitespace=TrailingWhitespace(
                            whitespace=SimpleWhitespace(
                                value='',
                            ),
                            comment=None,
                            newline=Newline(
                                value=None,
                            ),
                        ),
                    ),
                ],
                header=TrailingWhitespace(
                    whitespace=SimpleWhitespace(
                        value='',
                    ),
                    comment=None,
                    newline=Newline(
                        value=None,
                    ),
                ),
                indent=None,
                footer=[],
            ),
            decorators=[],
            returns=None,
            asynchronous=None,
            leading_lines=[],
            lines_after_decorators=[],
            whitespace_after_def=SimpleWhitespace(
                value=' ',
            ),
            whitespace_after_name=SimpleWhitespace(
                value='',
            ),
            whitespace_before_params=SimpleWhitespace(
                value='',
            ),
            whitespace_before_colon=SimpleWhitespace(
                value='',
            ),
            type_parameters=None,
            whitespace_after_type_parameters=SimpleWhitespace(
                value='',
            ),
        ),
    ],
    header=[
        EmptyLine(
            indent=True,
            whitespace=SimpleWhitespace(
                value='',
            ),
            comment=None,
            newline=Newline(
                value=None,
            ),
        ),
    ],
    footer=[],
    encoding='utf-8',
    default_indent='    ',
    default_newline='\n',
    has_trailing_newline=True,
)
&nbsp;
Dumped:
Module(
  body=[
    FunctionDef(
      name=Name(
        value='add',
      ),
      params=Parameters(
        params=[
          Param(
            name=Name(
              value='x',
            ),
            star='',
          ),
          Param(
            name=Name(
              value='y',
            ),
            star='',
          ),
        ],
      ),
      body=IndentedBlock(
        body=[
          SimpleStatementLine(
            body=[
              Return(
                value=BinaryOperation(
                  left=Name(
                    value='x',
                  ),
                  operator=Add(),
                  right=Name(
                    value='y',
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    ),
  ],
)
&nbsp;
Code:
&nbsp;
def add(x, y):
    return x + y
</pre>

<p><div class="rs-tip-major">Poznámka: ve výpisu je uveden i původní zdrojový
kód funkce.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Realizace průchodu CST</h2>

<p>Podívejme se nyní na způsob realizace průchodu CST. Pro tento účel je nutné
vytvořit třídu odvozenou od třídy <strong>CSTVisitor</strong>. Při průchodu CST
se budou volat metody nazvané <strong>on_visit</strong> a
<strong>on_leave</strong>; první metoda při vstupu do uzlu, druhá naopak při
jeho opouštění. Důležité přitom je, že metoda <strong>on_visit</strong> vrací
pravdivostní hodnotu, která určuje, zda se má vstoupit do poduzlů daného uzlu
či nikoli. V&nbsp;našem velmi jednoduchém příkladu vstup do poduzlů vždy
povolíme a tím umožníme průchod celým stromem, až do listů stromu (naproti tomu
metoda <strong>on_leave</strong> nic nevrací):</p>

<pre>
class <strong>Visitor</strong>(CSTVisitor):
    def <strong>__init__</strong>(self):
        ...
        ...
        ...
&nbsp;
    def <strong>on_visit</strong>(self, node):
        ...
        ...
        ...
        return True
&nbsp;
    def on_leave(self, node):
        ...
        ...
        ...
</pre>

<p>Nejprve zahájíme parsing, a to vždy celého modulu (nestačí parsing
výrazu):</p>

<pre>
constant = "1 + 2 * 3"
&nbsp;
parsed = parse_module(constant)
</pre>

<p>Dále zkonstruujeme instanci třídy <strong>Visitor</strong> a předáme ji do
metody <strong>parsed.visit</strong>. Tím se zahájí průchod jednotlivými uzly
CST:</p>

<pre>
visitor = Visitor()
parsed.visit(visitor)
</pre>

<p>Výsledek (tedy jednotlivé navštívené uzly) bude vypadat takto:</p>

<pre>
Visitor init
Visited node:  Module
Visited node:  SimpleStatementLine
Visited node:  Expr
Visited node:  BinaryOperation
Visited node:  Integer
Visited node:  Add
Visited node:  SimpleWhitespace
Visited node:  SimpleWhitespace
Visited node:  BinaryOperation
Visited node:  Integer
Visited node:  Multiply
Visited node:  SimpleWhitespace
Visited node:  SimpleWhitespace
Visited node:  Integer
Visited node:  TrailingWhitespace
Visited node:  SimpleWhitespace
Visited node:  Newline
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTVisitor
from libcst.tool import dump
&nbsp;
&nbsp;
class <strong>Visitor</strong>(CSTVisitor):
    def <strong>__init__</strong>(self):
        print("Visitor init")
&nbsp;
    def <strong>on_visit</strong>(self, node):
        print("Visited node: ", node.__class__.__name__)
        return True
&nbsp;
    def <strong>on_leave</strong>(self, node):
        pass
&nbsp;
&nbsp;
constant = "1 + 2 * 3"
&nbsp;
parsed = parse_module(constant)
visitor = Visitor()
parsed.visit(visitor)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_1.py</a>.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Výpis uzlů stromu tak, aby byla viditelná jeho struktura</h2>

<p>V&nbsp;demonstračním příkladu popsaném <a href="#k15">v&nbsp;předchozí
kapitole</a> byly jednotlivé uzly navštívené při průchodu stromem vypsány pod
sebou bez vizuálního zvýraznění struktury stromu (tedy na jaké úrovni stromu se
uzel nachází). Ovšem poměrně snadno si můžeme výpis upravit tak, aby se
zvýraznila struktura stromu. Postačuje si pamatovat aktuální úroveň (začínáme
v&nbsp;kořenu, tedy na nulté úrovni) a při každém volání metody
<strong>on_visit</strong> se úroveň zvýší a naopak při volání metody
<strong>on_leave</strong> se úroveň sníží. Před jméno každého uzlu potom
vložíme tolik mezer, aby to odpovídalo úrovni uložení uzlu ve stromu:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTVisitor
from libcst.tool import dump
&nbsp;
&nbsp;
class <strong>Visitor</strong>(CSTVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 0
&nbsp;
    def <strong>on_visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node.__class__.__name__)
        self.nest_level += 1
        return True
&nbsp;
    def <strong>on_leave</strong>(self, node):
        self.nest_level -= 1
&nbsp;
&nbsp;
constant = "1 + 2 * 3"
&nbsp;
parsed = parse_module(constant)
visitor = Visitor()
parsed.visit(visitor)
</pre>

<p>Výsledek, který se vypíše na terminál, již vypadá poměrně čitelně:</p>

<pre>
 Module
   SimpleStatementLine
     Expr
       BinaryOperation
         Integer
         Add
           SimpleWhitespace
           SimpleWhitespace
         BinaryOperation
           Integer
           Multiply
             SimpleWhitespace
             SimpleWhitespace
           Integer
     TrailingWhitespace
       SimpleWhitespace
       Newline
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Získání dalších informací o uzlech známých typů</h2>

<p>Každý uzel, kterým třída typu <strong>Visitor</strong> prochází, je
reprezentován objektem nějakého typu (tedy například operátor je reprezentován
jiným typem než řetězec apod.). A tento objekt většinou &ndash; podle typu uzlu
&ndash; obsahuje i další atributy, s&nbsp;nimiž je možné dále pracovat a
získávat tak například podrobnější informace o tom, jakou část programového
kódu tento uzel reprezentuje.</p>

<p>V&nbsp;dalším demonstračním příkladu je ukázáno zpracování uzlů typu
<strong>BinaryOperation</strong> (libovolný binární operátor, resp.&nbsp;výraz
s&nbsp;tímto operátorem), <strong>Integer</strong> (celočíselná konstanta),
<strong>Add</strong> (operace součtu) a <strong>Multiply</strong> (operace
součinu). U binárního operátoru je ukázáno zjištění konkrétní třídy (klasický
Pythonní přístup), u celočíselné konstanty je přečtena a vypsána hodnota této
konstanty a u součtu a součinu se vypíšou pouze znaky &bdquo;+&ldquo;
resp.&nbsp; &bdquo;*&ldquo;:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTVisitor
from libcst import BinaryOperation, Integer, Add, Multiply
from libcst.tool import dump
&nbsp;
&nbsp;
class <strong>Visitor</strong>(CSTVisitor):
    def __init__(self):
        self.nest_level = 0
&nbsp;
    def <strong>on_visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        info = node.__class__.__name__
&nbsp;
        if isinstance(node, BinaryOperation):
            info = "Binary operation: " + node.operator.__class__.__name__
&nbsp;
        if isinstance(node, Integer):
            info = node.value
&nbsp;
        if isinstance(node, Add):
            info = "+"
&nbsp;
        if isinstance(node, Multiply):
            info = "*"
&nbsp;
        print(indent, info)
&nbsp;
        self.nest_level += 1
        return True
&nbsp;
    def <strong>on_leave</strong>(self, node):
        self.nest_level -= 1
&nbsp;
&nbsp;
constant = "1 + 2 * 3"
&nbsp;
parsed = parse_module(constant)
visitor = Visitor()
parsed.visit(visitor)
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě by bylo vhodnější
namísto sekvence podmínek <strong>if</strong> použít novou programovou
konstrukci <strong>match</strong> s&nbsp;větvemi
<strong>case</strong>.</div></p>

<p>Výsledkem je již poměrně čitelná reprezentace kódu s&nbsp;využitím stromové
struktury:</p>

<pre>
 Module
   SimpleStatementLine
     Expr
       Binary operation: Add
         1
         +
           SimpleWhitespace
           SimpleWhitespace
         Binary operation: Multiply
           2
           *
             SimpleWhitespace
             SimpleWhitespace
           3
     TrailingWhitespace
       SimpleWhitespace
       Newline
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Různé zpracování uzlů podle jejich typů</h2>

<p>Samozřejmě nám ovšem nic nebrání v&nbsp;tom, abychom nějaké uzly sice při
průchodu stromem zpracovali, ale vůbec je nevypsali. Příkladem může být
&bdquo;ignorování&ldquo; uzlů typu <strong>SimpleWhitespace</strong>. Informace
o těchto uzlech se ve výsledku neobjeví, protože pokud na tento uzel narazíme,
je metoda <strong>on_visit</strong> ihned ukončena:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTVisitor
from libcst import BinaryOperation, Integer, Add, Multiply
from libcst import SimpleWhitespace
from libcst.tool import dump
&nbsp;
&nbsp;
class <strong>Visitor</strong>(CSTVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 0
&nbsp;
    def <strong>on_visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        info = node.__class__.__name__
        self.nest_level += 1
&nbsp;
        if isinstance(node, SimpleWhitespace):
            return True
&nbsp;
        if isinstance(node, BinaryOperation):
            info = "Binary operation: " + node.operator.__class__.__name__
&nbsp;
        if isinstance(node, Integer):
            info = node.value
&nbsp;
        if isinstance(node, Add):
            info = "+"
&nbsp;
        if isinstance(node, Multiply):
            info = "*"
&nbsp;
        print(indent, info)
&nbsp;
        return True
&nbsp;
    def <strong>on_leave</strong>(self, node):
        self.nest_level -= 1
&nbsp;
&nbsp;
constant = "1 + 2 * 3"
&nbsp;
parsed = parse_module(constant)
visitor = Visitor()
parsed.visit(visitor)
</pre>

<p>Výsledek bude vypadat takto:</p>

<pre>
 Module
   SimpleStatementLine
     Expr
       Binary operation: Add
         1
         +
         Binary operation: Multiply
           2
           *
           3
     TrailingWhitespace
       Newline
</pre>

<p>Popř.&nbsp;můžeme zcela odstranit všechny uzly, které se týkají nových řádků
či mezer v&nbsp;programovém kódu:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTVisitor
from libcst import BinaryOperation, Integer, Add, Multiply
from libcst import SimpleWhitespace, TrailingWhitespace, SimpleStatementLine, Newline
from libcst.tool import dump
&nbsp;
&nbsp;
class <strong>Visitor</strong>(CSTVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 0
&nbsp;
    def <strong>on_visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        info = node.__class__.__name__
        self.nest_level += 1
&nbsp;
        if isinstance(node, SimpleWhitespace) or \
           isinstance(node, TrailingWhitespace) or \
           isinstance(node, SimpleStatementLine) or \
           isinstance(node, Newline):
            return True
&nbsp;
        if isinstance(node, BinaryOperation):
            info = "Binary operation: " + node.operator.__class__.__name__
&nbsp;
        if isinstance(node, Integer):
            info = node.value
&nbsp;
        if isinstance(node, Add):
            info = "+"
&nbsp;
        if isinstance(node, Multiply):
            info = "*"
&nbsp;
        print(indent, info)
&nbsp;
        return True
&nbsp;
    def <strong>on_leave</strong>(self, node):
        self.nest_level -= 1
&nbsp;
&nbsp;
constant = "1 + 2 * 3 + 4 * 5"
&nbsp;
parsed = parse_module(constant)
visitor = Visitor()
parsed.visit(visitor)
</pre>

<p>Čitelný výsledek:</p>

<pre>
 Module
     Expr
       Binary operation: Add
         Binary operation: Add
           1
           +
           Binary operation: Multiply
             2
             *
             3
         +
         Binary operation: Multiply
           4
           *
           5
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů
určených pro programovací jazyk Python 3 a knihovnu <i>libcst</i> byly
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>parse_constant_1.py</td><td>parsing kódu obsahujícího celočíselnou konstantu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py</a></td></tr>
<tr><td> 2</td><td>parse_constant_2.py</td><td>parsing kódu obsahujícího celočíselnou konstantu s&nbsp;podtržítkem ve funkci oddělovače řádů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py</a></td></tr>
<tr><td> 3</td><td>parse_constant_3.py</td><td>parsing kódu obsahujícího logickou konstantu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_3.py</a></td></tr>
<tr><td> 4</td><td>parse_constant_4.py</td><td>parsing kódu obsahujícího řetězcový literál</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_4.py</a></td></tr>
<tr><td> 5</td><td>parse_constant_5.py</td><td>parsing kódu obsahujícího komplexní číslo</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>parse_expression_1.py</td><td>parsing jednoduchého aritmetického výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_1.py</a></td></tr>
<tr><td> 7</td><td>parse_expression_2.py</td><td>parsing jednoduchého aritmetického výrazu s&nbsp;mezerami mezi operandy a operátorem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_2.py</a></td></tr>
<tr><td> 8</td><td>parse_expression_3.py</td><td>parsing výrazu, před nímž je zapsána mezera</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_3.py</a></td></tr>
<tr><td> 9</td><td>parse_expression_4.py</td><td>parsing složitějšího aritmetického výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_4.py</a></td></tr>
<tr><td>10</td><td>parse_expression_5.py</td><td>výraz obalený závorkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>parse_module_1.py</td><td>parsing celého modulu, který obsahuje jediný výraz, první příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_1.py</a></td></tr>
<tr><td>12</td><td>parse_module_2.py</td><td>parsing celého modulu, který obsahuje jediný výraz, druhý příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_2.py</a></td></tr>
<tr><td>13</td><td>parse_module_3.py</td><td>parsing celého modulu, který obsahuje jediný výraz, třetí příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_3.py</a></td></tr>
<tr><td>14</td><td>parse_module_4.py</td><td>parsing celého modulu s&nbsp;definicí funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>traverse_code_1.py</td><td>průchod CST stromem, nejjednodušší řešení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_1.py</a></td></tr>
<tr><td>16</td><td>traverse_code_2.py</td><td>průchod CST stromem, vizualizace zanoření uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_2.py</a></td></tr>
<tr><td>17</td><td>traverse_code_3.py</td><td>průchod CST stromem, test na typ uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_3.py</a></td></tr>
<tr><td>18</td><td>traverse_code_4.py</td><td>průchod CST stromem, filtrace uzlů podle jejich typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_4.py</a></td></tr>
<tr><td>19</td><td>traverse_code_5.py</td><td>průchod CST stromem, ještě výraznější filtrace uzlů podle jejich typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_5.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů jazyka Python (4.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/</a>
</li>

<li>LibCST &ndash; dokumentace<br />
<a href="https://libcst.readthedocs.io/en/latest/index.html">https://libcst.readthedocs.io/en/latest/index.html</a>
</li>

<li>libCST na PyPi<br />
<a href="https://pypi.org/project/libcst/">https://pypi.org/project/libcst/</a>
</li>

<li>libCST na GitHubu<br />
<a href="https://github.com/Instagram/LibCST">https://github.com/Instagram/LibCST</a>
</li>

<li>Inside The Python Virtual Machine<br />
<a href="https://leanpub.com/insidethepythonvirtualmachine">https://leanpub.com/insidethepythonvirtualmachine</a>
</li>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>SymbolTable<br />
<a href="https://docs.python.org/3.8/library/symtable.html">https://docs.python.org/3.8/library/symtable.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Pygments - Python syntax highlighter<br />
<a href="http://pygments.org/">http://pygments.org/</a>
</li>

<li>Pygments (dokumentace)<br />
<a href="http://pygments.org/docs/">http://pygments.org/docs/</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Jazyky podporované knihovnou Pygments<br />
<a href="http://pygments.org/languages/">http://pygments.org/languages/</a>
</li>

<li>Pygments FAQ<br />
<a href="http://pygments.org/faq/">http://pygments.org/faq/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>
