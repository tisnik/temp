<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu</a></p>
<p><a href="#k02">2. AST vs CST</a></p>
<p><a href="#k03">3. Parsing jednoduchého výrazu s&nbsp;konstrukcí CST</a></p>
<p><a href="#k04">4. Zobrazení struktury výsledného CST</a></p>
<p><a href="#k05">5. Zachování formátu výrazu i konstant ve výrazu</a></p>
<p><a href="#k06">6. Rozdíl mezi identifikátorem a řetězcem</a></p>
<p><a href="#k07">7. Strom s&nbsp;reprezentací složitějších výrazů</a></p>
<p><a href="#k08">8. Strom, který reprezentuje výraz &bdquo;6*7&ldquo;</a></p>
<p><a href="#k09">9. Bílé znaky zapsané ve výrazu</a></p>
<p><a href="#k10">*** 10. Výraz obalený závorkami</a></p>
<p><a href="#k11">*** 11. Strom pro složitější výraz s&nbsp;několika operátory</a></p>
<p><a href="#k12">*** 12. Parsing celého modulu</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. Realizace průchodu CST</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu</h2>

<p>Na čtveřici článků, v&nbsp;nichž jsme se zabývali problematikou lexikální a
syntaktické analýzy zdrojových kódů programovacího jazyka Python [<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">1</a>]
[<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">2</a>]
[<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">3</a>]
[<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">4</a>]
dnes do jisté míry navážeme. Víme již, jak je možné s&nbsp;využitím
standardních modulů <strong>tokenize</strong> a <strong>ast</strong> provést
takzvanou <i>tokenizaci</i> a následně <i>parsing</i> zdrojových kódů, jehož
výsledkem je <i>AST</i> neboli abstraktní syntaktický strom (<i>Abstract Syntax
Tree</i>). Tyto techniky nám umožní manipulovat s&nbsp;programovým kódem na
vhodné úrovni abstrakce, protože abstraktní syntaktický strom je pro tyto účely
mnohem vhodnější, než přímo zdrojový kód či pouhá sekvence tokenů.
Z&nbsp;tohoto důvodu je tokenizace a parsing součástí většiny linterů i dalších
analyzátorů programových kódů.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. AST vs CST</h2>

<p>Standardní abstraktní syntaktický strom má ovšem jednu poměrně zásadní
nevýhodu &ndash; v&nbsp;případě, že <i>AST</i> upravíme a necháme si
z&nbsp;něho zpětně vygenerovat zdrojový kód, ztratíme veškeré původní
formátování, tedy například mezery zapsané ve výrazech, přesné umístění
komentářů atd. Z&nbsp;tohoto důvodu se pro ty nástroje, které musí modifikovat
zdrojový kód (nepřímo &ndash; přes strom) používají nepatrně odlišné typy
stromů, které se nazývají <i>Concrete Syntax Tree</i> neboli zkráceně
<i>CST</i> (popř.&nbsp;<i>derivační stromy</i> nebo <i>parse tree</i>). Tyto
stromové datové struktury, jak již ostatně jejich název napovídá, reprezentují
syntaktickou strukturu daného bloku programového kódu (což může být konstanta,
výraz, příkaz, složený blok, funkce, třída, či celý modul). Díky tomu, že si
<i>CST</i> pamatuje původní zápis syntaktických prvků, je umožněna relativně
snadná tvorba nástrojů pro refaktoring kódu. Pro manipulaci s&nbsp;<i>CST</i>
slouží v&nbsp;Pythonu knihovna <i>LibCST</i>, s&nbsp;jejímiž základními
vlastnostmi se seznámíme v&nbsp;dnešním článku.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Parsing jednoduchého výrazu s&nbsp;konstrukcí CST</h2>

<p>Možnosti knihovny <i>LibCST</i> si otestujeme na množství demonstračních
příkladů. První příklady budou velmi jednoduché, protože budeme zpracovávat
zdrojový kód obsahující pouze jedinou konstantu. Může se jednat například o
konstantu představující celé číslo (což je v&nbsp;Pythonu zcela korektní
zdrojový kód):</p>

<pre>
42
</pre>

<p>Tato konstanta (tedy její zdrojový kód) se zpracuje tokenizérem a parserem
takto:</p>

<pre>
from libcst import parse_expression
&nbsp;
constant = "42"
&nbsp;
parsed = parse_expression(constant)
</pre>

<p>Výsledek, tedy obsah proměnné <strong>parsed</strong>, je datová struktura
přesně popisující výraz s&nbsp;konstantou. Tuto datovou strukturu si můžeme
přímo zobrazit:</p>

<pre>
print(parsed)
</pre>

<p>Ovšem užitečnější bývá použití pomocné funkce <strong>dump</strong>, která
vytiskne CST v&nbsp;čitelnější podobě:</p>

<pre>
from libcst.tool import dump
&nbsp;
dumped = dump(parsed)
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalších příkladech budeme
používat oba způsoby výstupu, takže se sami budete moci přesvědčit, která
vizualizace CST (a onen textový výstup ničím jiným, než vizualizací není) je
výhodnější.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zobrazení struktury výsledného CST</h2>

<p>Celý skript, který provede parsing výrazu do CST a následně zobrazí
strukturu CST, vypadá následovně:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
constant = "42"
&nbsp;
parsed = parse_expression(constant)
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py</a>.</div></p>

<p>Po spuštění tohoto skriptu se nejdříve zobrazí CST se všemi podrobnostmi a
posléze &bdquo;pouze&ldquo; výsledek operace <strong>dump</strong>, který je
stručnější a v&nbsp;tomto případě i čitelnější:</p>

<pre>
Parsed:
Integer(
    value='42',
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
Integer(
  value='42',
)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zachování formátu výrazu i konstant ve výrazu</h2>

<p>Knihovna <i>LibCST</i> se nesnaží o &bdquo;normalizaci&ldquo; výrazů ani
hodnot, které jsou ve výrazu specifikovány. To je nutné, aby bylo možné
zrekonstruovat původní výraz přesně v&nbsp;takové podobě, v&nbsp;jaké byl
původně zapsán (samozřejmě za předpokladu, že nedojde k&nbsp;modifikaci
stromu).</p>

<p>Vyzkoušejme si, jak bude zparsován výraz s&nbsp;konstantou 1_000, což je
běžná celočíselná konstanta 1000, do které byl přidán nepovinný oddělovač
řádu:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
constant = "1_000"
&nbsp;
parsed = parse_expression(constant)
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto příkladu naleznete
na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py</a>.</div></p>

<p>V&nbsp;CST stromu nalezneme původní zápis konstanty, což nám (jak již víme)
umožní rekonstrukci originální podoby výrazu:</p>

<pre>
Parsed:
Integer(
    value='1_000',
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
Integer(
  value='1_000',
)
</pre>

<p>Nakonec si ještě pro úplnost ukažme výsledek parsingu komplexního čísla:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_expression
from libcst.tool import dump
&nbsp;
&nbsp;
<strong>constant = "1+2j"</strong>
&nbsp;
parsed = <strong>parse_expression(constant)</strong>
print("Parsed:")
print(parsed)
&nbsp;
print()
&nbsp;
dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<p>Zkonstruovaný strom vypadá takto:</p>

<pre>
Parsed:
BinaryOperation(
    left=Integer(
        value='1',
        lpar=[],
        rpar=[],
    ),
    operator=Add(
        whitespace_before=SimpleWhitespace(
            value='',
        ),
        whitespace_after=SimpleWhitespace(
            value='',
        ),
    ),
    right=Imaginary(
        value='2j',
        lpar=[],
        rpar=[],
    ),
    lpar=[],
    rpar=[],
)
&nbsp;
Dumped:
BinaryOperation(
  left=Integer(
    value='1',
  ),
  operator=Add(),
  right=Imaginary(
    value='2j',
  ),
)
</pre>

dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<pre>
Parsed:
Name(
    value='True',
    lpar=[],
    rpar=[],
)

Dumped:
Name(
  value='True',
)
</pre>

<pre>
#!/usr/bin/python
# vim: set fileencoding=utf-8

from libcst import parse_expression
from libcst.tool import dump


constant = "'True'"

parsed = parse_expression(constant)
print("Parsed:")
print(parsed)

print()

dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<pre>
Parsed:
SimpleString(
    value="'True'",
    lpar=[],
    rpar=[],
)

Dumped:
SimpleString(
  value="'True'",
)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<pre>
#!/usr/bin/python
# vim: set fileencoding=utf-8

from libcst import parse_expression
from libcst.tool import dump


expression = "6*7"

parsed = parse_expression(expression)
print("Parsed:")
print(parsed)

print()

dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<pre>
BinaryOperation(
    left=Integer(
        value='6',
        lpar=[],
        rpar=[],
    ),
    operator=Multiply(
        whitespace_before=SimpleWhitespace(
            value='',
        ),
        whitespace_after=SimpleWhitespace(
            value='',
        ),
    ),
    right=Integer(
        value='7',
        lpar=[],
        rpar=[],
    ),
    lpar=[],
    rpar=[],
)

Dumped:
BinaryOperation(
  left=Integer(
    value='6',
  ),
  operator=Multiply(),
  right=Integer(
    value='7',
  ),
)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<pre>
#!/usr/bin/python
# vim: set fileencoding=utf-8

from libcst import parse_expression
from libcst.tool import dump


expression = "6 * 7"

parsed = parse_expression(expression)
print("Parsed:")
print(parsed)

print()

dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<pre>
BinaryOperation(
    left=Integer(
        value='6',
        lpar=[],
        rpar=[],
    ),
    operator=Multiply(
        whitespace_before=SimpleWhitespace(
            value=' ',
        ),
        whitespace_after=SimpleWhitespace(
            value=' ',
        ),
    ),
    right=Integer(
        value='7',
        lpar=[],
        rpar=[],
    ),
    lpar=[],
    rpar=[],
)

Dumped:
BinaryOperation(
  left=Integer(
    value='6',
  ),
  operator=Multiply(),
  right=Integer(
    value='7',
  ),
)
</pre>

<pre>
#!/usr/bin/python
# vim: set fileencoding=utf-8

from libcst import parse_expression
from libcst.tool import dump


expression = " 6 * 7 "

parsed = parse_expression(expression)
print("Parsed:")
print(parsed)

print()

dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>

<pre>
Traceback (most recent call last):
  File "parse_expression_3.py", line 10, in <module>
    parsed = parse_expression(expression)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/libcst/_parser/entrypoints.py", line 160, in parse_expression
    result = _parse(
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/libcst/_parser/entrypoints.py", line 55, in _parse
    return parse(source_str)
libcst._exceptions.ParserSyntaxError: Syntax Error @ 1:1.
parser error: error at 1:1: expected one of *, +, -, ..., AWAIT, False, NAME, NUMBER, None, True, lambda, not, ~

 6 * 7 
^
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
#!/usr/bin/python
# vim: set fileencoding=utf-8

from libcst import parse_expression
from libcst.tool import dump


expression = "(1+2)*3/2**4"

parsed = parse_expression(expression)
print("Parsed:")
print(parsed)

print()

dumped = dump(parsed)
print("Dumped:")
print(dumped)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů
určených pro programovací jazyk Python 3 a knihovnu <i>libcst</i> byly
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>parse_constant_1.py</td><td>parsing kódu obsahujícího celočíselnou konstantu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py</a></td></tr>
<tr><td> 2</td><td>parse_constant_2.py</td><td>parsing kódu obsahujícího celočíselnou konstantu s&nbsp;podtržítkem ve funkci oddělovače řádů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py</a></td></tr>
<tr><td> 3</td><td>parse_constant_3.py</td><td>parsing kódu obsahujícího logickou konstantu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_3.py</a></td></tr>
<tr><td> 4</td><td>parse_constant_4.py</td><td>parsing kódu obsahujícího řetězcový literál</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_4.py</a></td></tr>
<tr><td> 5</td><td>parse_constant_5.py</td><td>parsing kódu obsahujícího komplexní číslo</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>parse_expression_1.py</td><td>parsing jednoduchého aritmetického výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_1.py</a></td></tr>
<tr><td> 7</td><td>parse_expression_2.py</td><td>parsing jednoduchého aritmetického výrazu s&nbsp;mezerami mezi operandy a operátorem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_2.py</a></td></tr>
<tr><td> 8</td><td>parse_expression_3.py</td><td>parsing výrazu, před nímž je zapsána mezera</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_3.py</a></td></tr>
<tr><td> 9</td><td>parse_expression_4.py</td><td>parsing složitějšího aritmetického výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_4.py</a></td></tr>
<tr><td>10</td><td>parse_expression_5.py</td><td>výraz obalený závorkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>parse_module_1.py</td><td>parsing celého modulu, který obsahuje jediný výraz, první příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_1.py</a></td></tr>
<tr><td>12</td><td>parse_module_2.py</td><td>parsing celého modulu, který obsahuje jediný výraz, druhý příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_2.py</a></td></tr>
<tr><td>13</td><td>parse_module_3.py</td><td>parsing celého modulu, který obsahuje jediný výraz, třetí příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>traverse_code_1.py</td><td>průchod CST stromem, nejjednodušší řešení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_1.py</a></td></tr>
<tr><td>15</td><td>traverse_code_2.py</td><td>průchod CST stromem, vizualizace zanoření uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_2.py</a></td></tr>
<tr><td>16</td><td>traverse_code_3.py</td><td>průchod CST stromem, test na typ uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_3.py</a></td></tr>
<tr><td>17</td><td>traverse_code_4.py</td><td>průchod CST stromem, filtrace uzlů podle jejich typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_4.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů jazyka Python (4.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/</a>
</li>

<li>LibCST &ndash; dokumentace<br />
<a href="https://libcst.readthedocs.io/en/latest/index.html">https://libcst.readthedocs.io/en/latest/index.html</a>
</li>

libCST na PyPi
https://pypi.org/project/libcst/

libCST na GitHubu
https://github.com/Instagram/LibCST

<li>Inside The Python Virtual Machine<br />
<a href="https://leanpub.com/insidethepythonvirtualmachine">https://leanpub.com/insidethepythonvirtualmachine</a>
</li>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>SymbolTable<br />
<a href="https://docs.python.org/3.8/library/symtable.html">https://docs.python.org/3.8/library/symtable.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Pygments - Python syntax highlighter<br />
<a href="http://pygments.org/">http://pygments.org/</a>
</li>

<li>Pygments (dokumentace)<br />
<a href="http://pygments.org/docs/">http://pygments.org/docs/</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Jazyky podporované knihovnou Pygments<br />
<a href="http://pygments.org/languages/">http://pygments.org/languages/</a>
</li>

<li>Pygments FAQ<br />
<a href="http://pygments.org/faq/">http://pygments.org/faq/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>
