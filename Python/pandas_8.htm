<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Operace s daty uloženými v binárních souborech v knihovnách NumPy a Pandas</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Operace s daty uloženými v binárních souborech v knihovnách NumPy a Pandas</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Poměrně často se můžeme setkat s požadavkem analýzy dat uložených v binárních souborech. S těmito soubory dokáže do určité míry pracovat jak knihovna NumPy, tak i knihovna Pandas. Dnes si představíme základní metody ukládání i načítání binárních dat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Operace s&nbsp;daty uloženými v&nbsp;binárních souborech v&nbsp;knihovnách NumPy a Pandas</a></p>
<p><a href="#k02">2. Uložení obsahu vektoru do textového souboru se specifikací oddělovače</a></p>
<p><a href="#k03">3. Uložení obsahu vektoru do binárního souboru</a></p>
<p><a href="#k04">4. Načtení obsahu vektoru z&nbsp;textového popř.&nbsp;binárního souboru</a></p>
<p><a href="#k05">5. Uložení obsahu matice do textového souboru se specifikací oddělovače i do souboru binárního</a></p>
<p><a href="#k06">6. Standardní binární soubor knihovny NumPy</a></p>
<p><a href="#k07">7. Standardní binární soubor pro vektory</a></p>
<p><a href="#k08">8. Uložení a načtení matice do/ze standardního binárního souboru</a></p>
<p><a href="#k09">9. Binární soubory a knihovna Pandas</a></p>
<p><a href="#k10">10. Načtení obsahu datové řady z&nbsp;binárního souboru s&nbsp;konverzí</a></p>
<p><a href="#k11">11. Načtení obsahu datového rámce z&nbsp;binárního souboru se specifikací formátu</a></p>
<p><a href="#k12">12. Vygenerování binárního souboru se dvěma sloupci čísel s&nbsp;různou reprezentací</a></p>
<p><a href="#k13">13. Načtení binárního souboru s&nbsp;různými typy sloupců do datového rámce</a></p>
<p><a href="#k14">14. Specifikace endianity dat</a></p>
<p><a href="#k15">15. Vygenerování binárního souboru se dvěma sloupci čísel s&nbsp;různou reprezentací a se sloupcem s&nbsp;řetězci</a></p>
<p><a href="#k16">16. Načtení obsahu datového rámce z&nbsp;binárního souboru obsahujícího řetězce pevné délky</a></p>
<p><a href="#k17">17. Převod sekvence bajtů na řetězec</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu o knihovně Pandas</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Operace s&nbsp;daty uloženými v&nbsp;binárních souborech v&nbsp;knihovnách NumPy a Pandas</h2>

<p>Poměrně často se v&nbsp;praxi můžeme setkat s&nbsp;požadavkem analýzy dat
uložených v&nbsp;binárních souborech. S&nbsp;těmito soubory dokáže do určité
míry pracovat jak knihovna <i>NumPy</i>, tak i knihovna <i>Pandas</i>. Dnes si
představíme základní metody ukládání i načítání binárních dat;
v&nbsp;navazujícím článku si pak ukážeme některé pokročilé (resp.&nbsp;spíše
pouze pokročilejší) metody, například přeskakování bloků v&nbsp;binárních
souborech, využití <strong>mmap</strong> u obrovských souborů, které se celé
nevejdou do operační paměti atd.</p>

<p>Pro prohlížení obsahu binárních souborů lze použít například nějakou formu
<i>hexadecimálního prohlížeče</i>. Co si však pod pojmenováním
&bdquo;hexadecimální prohlížeč&ldquo; nebo &bdquo;hexadecimální editor&ldquo;
máme představit? Jedná se o aplikace, které vstupní binární soubor
(tj.&nbsp;soubor, který může mít libovolný obsah, jenž není nijak
interpretován) zobrazí typickým způsobem ve formě hexadecimálních hodnot
(tj.&nbsp;číselných hodnot využívajících při zobrazení šestnáctkovou soustavu)
umístěných do sloupců (viz též první obrázek). Ve skutečnosti je však možné
mnoho těchto prohlížečů a editorů nakonfigurovat takovým způsobem, že se
namísto hexadeciálních hodnot používají hodnoty reprezentované v&nbsp;osmičkové
soustavě, v&nbsp;soustavě dvojkové či dokonce v&nbsp;desítkové soustavě (což
ovšem v&nbsp;naprosté většině případů není moc praktické).</p>

<img src="https://i.iinfo.cz/images/166/hexa1-1.png" class="image-311432" alt="&#160;" width="804" height="504" />
<p><i>Obrázek 1: Pohled na typický hexadecimální editor spuštěný na terminálu
s&nbsp;osmdesáti sloupci a dvaceti pěti textovými řádky. Plocha terminálu je
rozdělena do čtyř oblastí &ndash; sloupec adres, sloupec s&nbsp;hexadecimálními
hodnotami, sloupec s&nbsp;textovou reprezentací bajtů a konečně na stavový a
příkazový řádek (v&nbsp;některých případech obsahují hexadecimální editory i
řádek s&nbsp;menu).</i></p>

<p>Hexadecimálních prohlížečů a editorů existuje (pro Linux) relativně velké
množství. První dva nástroje nazvané <strong>od</strong> a
<strong>hexdump</strong> (zkráceně <strong>hd</strong>) pracují jako relativně
jednoduché jednosměrné filtry (navíc bývají nainstalovány společně se základním
sadou nástrojů), ovšem další nástroj pojmenovaný <strong>xxd</strong> již může
být použit pro obousměrný převod (filtraci), tj.&nbsp;jak pro transformaci
původního binárního souboru do čitelného tvaru (většinou s&nbsp;využitím
šestnáctkové soustavy), tak i pro zpětný převod. Díky tomu je možné
<strong>xxd</strong> použít například ve funkci pluginu do běžných textových
editorů. Další nástroj pojmenovaný <strong>hexdiff</strong> dokáže porovnat
obsah dvou binárních souborů a poslední zmíněný nástroj <strong>mcview</strong>
je, na rozdíl od předchozí čtveřice, aplikací s&nbsp;interaktivním ovládáním a
plnohodnotným textovým uživatelským prostředím.</p>

<p><div class="rs-tip-major">Poznámka: dnes si vystačíme s&nbsp;možnostmi
nabízenými nástrojem <strong>od</strong> neboli <i>octal dump</i>. Jméno tohoto
nástroje je ve skutečnosti zavádějící, protože dokáže zobrazit obsah binárního
soubory mnoha různými způsoby. Již fakt, že jméno této utility má pouhá dvě
písmena, napovídá, že se jedná o nástroj pocházející již z&nbsp;prvních verzí
Unixu. Původní varianty utility <strong>od</strong> vypisovaly obsah zvoleného
souboru (alternativně standardního vstupu či zvoleného zařízení)
s&nbsp;využitím osmičkové soustavy, ovšem GNU verze <strong>od</strong> nabízí
uživatelům mnohem víc možností, a to včetně včetně použití hexadecimální
soustavy (ostatně i proto o této utilitě dnes píšeme), zformátování sousedních
čtyř bajtů do čísla typu <i>single/float</i>, dtto pro osm bajtů a čísla typu
<i>double</i> apod.</div></p>

<p>Ukažme si nyní některé možnosti nabízené nástrojem <strong>od</strong>
(ovšem bez problémů lze <a href="#k02">přeskočit na další kapitolu</a>
s&nbsp;popisem možností knihoven NumPy a posléze i Pandas, ostatně právě
v&nbsp;dalších kapitolách využijeme i další formáty podporované tímto
nástrojem).</p>

<p>Výpis obsahu binárního souboru v&nbsp;osmičkové soustavě s&nbsp;použitím
výchozího nastavení (povšimněte si oddělení hvězdičkou po 256 bajtech, což je
historicky daná hodnota odpovídající jedné stránce paměti a/nebo jednomu
sektoru):</p>

<pre>
<strong>od a.out</strong>
&nbsp;
0000000 042577 043114 000401 000001 000000 000000 000000 000000
0000020 000002 000050 000001 000000 100124 000000 000064 000000
0000040 000230 000000 001000 002400 000064 000040 000001 000050
0000060 000004 000003 000001 000000 000000 000000 100000 000000
0000100 100000 000000 000140 000000 000140 000000 000005 000000
0000120 100000 000000 070001 161640 000000 161640 000000 167400
0000140 011501 000000 060400 060545 064542 000400 000011 000000
0000160 000406 000410 027000 064163 072163 072162 061141 027000
0000200 062564 072170 027000 051101 027115 072141 071164 061151
0000220 072165 071545 000000 000000 000000 000000 000000 000000
0000240 000000 000000 000000 000000 000000 000000 000000 000000
*
0000300 000013 000000 000001 000000 000006 000000 100124 000000
0000320 000124 000000 000014 000000 000000 000000 000000 000000
0000340 000004 000000 000000 000000 000021 000000 000003 070000
0000360 000000 000000 000000 000000 000140 000000 000024 000000
0000400 000000 000000 000000 000000 000001 000000 000000 000000
0000420 000001 000000 000003 000000 000000 000000 000000 000000
0000440 000164 000000 000041 000000 000000 000000 000000 000000
0000460 000001 000000 000000 000000
0000470
</pre>

<p>Přepnutí do šestnáctkové soustavy, ovšem se sdružením bajtů do 16bitových
slov:</p>

<pre>
<strong>od -h a.out</strong>
&nbsp;
0000000 457f 464c 0101 0001 0000 0000 0000 0000
0000020 0002 0028 0001 0000 8054 0000 0034 0000
0000040 0098 0000 0200 0500 0034 0020 0001 0028
0000060 0004 0003 0001 0000 0000 0000 8000 0000
0000100 8000 0000 0060 0000 0060 0000 0005 0000
0000120 8000 0000 7001 e3a0 0000 e3a0 0000 ef00
0000140 1341 0000 6100 6165 6962 0100 0009 0000
0000160 0106 0108 2e00 6873 7473 7472 6261 2e00
0000200 6574 7478 2e00 5241 2e4d 7461 7274 6269
0000220 7475 7365 0000 0000 0000 0000 0000 0000
0000240 0000 0000 0000 0000 0000 0000 0000 0000
*
0000300 000b 0000 0001 0000 0006 0000 8054 0000
0000320 0054 0000 000c 0000 0000 0000 0000 0000
0000340 0004 0000 0000 0000 0011 0000 0003 7000
0000360 0000 0000 0000 0000 0060 0000 0014 0000
0000400 0000 0000 0000 0000 0001 0000 0000 0000
0000420 0001 0000 0003 0000 0000 0000 0000 0000
0000440 0074 0000 0021 0000 0000 0000 0000 0000
0000460 0001 0000 0000 0000
0000470
</pre>

<p>Explicitní žádost, aby hodnoty bajtů nebyly spojovány do větších slov:</p>

<pre>
<strong>od -t x1 a.out</strong>
&nbsp;
0000000 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
0000020 02 00 28 00 01 00 00 00 54 80 00 00 34 00 00 00
0000040 98 00 00 00 00 02 00 05 34 00 20 00 01 00 28 00
0000060 04 00 03 00 01 00 00 00 00 00 00 00 00 80 00 00
0000100 00 80 00 00 60 00 00 00 60 00 00 00 05 00 00 00
0000120 00 80 00 00 01 70 a0 e3 00 00 a0 e3 00 00 00 ef
0000140 41 13 00 00 00 61 65 61 62 69 00 01 09 00 00 00
0000160 06 01 08 01 00 2e 73 68 73 74 72 74 61 62 00 2e
0000200 74 65 78 74 00 2e 41 52 4d 2e 61 74 74 72 69 62
0000220 75 74 65 73 00 00 00 00 00 00 00 00 00 00 00 00
0000240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0000300 0b 00 00 00 01 00 00 00 06 00 00 00 54 80 00 00
0000320 54 00 00 00 0c 00 00 00 00 00 00 00 00 00 00 00
0000340 04 00 00 00 00 00 00 00 11 00 00 00 03 00 00 70
0000360 00 00 00 00 00 00 00 00 60 00 00 00 14 00 00 00
0000400 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00
0000420 01 00 00 00 03 00 00 00 00 00 00 00 00 00 00 00
0000440 74 00 00 00 21 00 00 00 00 00 00 00 00 00 00 00
0000460 01 00 00 00 00 00 00 00
0000470
</pre>

<p>Zákaz výpisu oddělovací hvězdičky:</p>

<pre>
<strong>od -v -t x1 a.out</strong>
&nbsp;
0000000 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
0000020 02 00 28 00 01 00 00 00 54 80 00 00 34 00 00 00
0000040 98 00 00 00 00 02 00 05 34 00 20 00 01 00 28 00
0000060 04 00 03 00 01 00 00 00 00 00 00 00 00 80 00 00
0000100 00 80 00 00 60 00 00 00 60 00 00 00 05 00 00 00
0000120 00 80 00 00 01 70 a0 e3 00 00 a0 e3 00 00 00 ef
0000140 41 13 00 00 00 61 65 61 62 69 00 01 09 00 00 00
0000160 06 01 08 01 00 2e 73 68 73 74 72 74 61 62 00 2e
0000200 74 65 78 74 00 2e 41 52 4d 2e 61 74 74 72 69 62
0000220 75 74 65 73 00 00 00 00 00 00 00 00 00 00 00 00
0000240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000300 0b 00 00 00 01 00 00 00 06 00 00 00 54 80 00 00
0000320 54 00 00 00 0c 00 00 00 00 00 00 00 00 00 00 00
0000340 04 00 00 00 00 00 00 00 11 00 00 00 03 00 00 70
0000360 00 00 00 00 00 00 00 00 60 00 00 00 14 00 00 00
0000400 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00
0000420 01 00 00 00 03 00 00 00 00 00 00 00 00 00 00 00
0000440 74 00 00 00 21 00 00 00 00 00 00 00 00 00 00 00
0000460 01 00 00 00 00 00 00 00
0000470
</pre>

<p>Výpis 128 bajtů od offsetu 64 (počet bajtů i offset se zadává
desítkově):</p>

<pre>
<strong>od -j 64 -N 128 -v -t x1 a.out</strong>
&nbsp;
0000100 00 80 00 00 60 00 00 00 60 00 00 00 05 00 00 00
0000120 00 80 00 00 01 70 a0 e3 00 00 a0 e3 00 00 00 ef
0000140 41 13 00 00 00 61 65 61 62 69 00 01 09 00 00 00
0000160 06 01 08 01 00 2e 73 68 73 74 72 74 61 62 00 2e
0000200 74 65 78 74 00 2e 41 52 4d 2e 61 74 74 72 69 62
0000220 75 74 65 73 00 00 00 00 00 00 00 00 00 00 00 00
0000240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000300
</pre>

<p>Výpis 128 bajtů od offsetu 64 (počet bajtů i offset se zadává
v&nbsp;šestnáctkové soustavě):</p>

<pre>
<strong>od -j 0x40 -N 0x80 -v -t x1 a.out</strong>
&nbsp;
0000100 00 80 00 00 60 00 00 00 60 00 00 00 05 00 00 00
0000120 00 80 00 00 01 70 a0 e3 00 00 a0 e3 00 00 00 ef
0000140 41 13 00 00 00 61 65 61 62 69 00 01 09 00 00 00
0000160 06 01 08 01 00 2e 73 68 73 74 72 74 61 62 00 2e
0000200 74 65 78 74 00 2e 41 52 4d 2e 61 74 74 72 69 62
0000220 75 74 65 73 00 00 00 00 00 00 00 00 00 00 00 00
0000240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000300
</pre>

<p>Každé čtyři bajty jsou považovány za číslo ve formátu <i>single/float</i>
podle IEEE 754. Zde se sice jedná o zcela nesmyslný výstup, ovšem při načítán
binárních souborů s&nbsp;poli se může hodit:</p>

<pre>
<strong>od -t f4 a.out</strong>
&nbsp;
0000000       13073.374      9.2196e-41               0               0
0000020    3.673423e-39           1e-45      4.6035e-41         7.3e-44
0000040        2.13e-43   6.0188984e-36    2.938809e-39    3.673421e-39
0000060     2.75512e-40           1e-45               0      4.5918e-41
0000100      4.5918e-41        1.35e-43        1.35e-43           7e-45
0000120      4.5918e-41  -5.9190996e+21   -5.902958e+21  -3.9614081e+28
0000140       6.907e-42   2.6445587e+20   2.3585495e-38         1.3e-44
0000160    2.497999e-38   4.5935344e+24    7.683702e+31    2.919121e-11
0000200    7.871993e+31   2.0742511e+11   7.1362664e+31  1.07658465e+21
0000220   1.8179291e+31               0               0               0
0000240               0               0               0               0
*
0000300         1.5e-44           1e-45           8e-45      4.6035e-41
0000320        1.18e-43         1.7e-44               0               0
0000340           6e-45               0         2.4e-44   1.5845638e+29
0000360               0               0        1.35e-43         2.8e-44
0000400               0               0           1e-45               0
0000420           1e-45           4e-45               0               0
0000440        1.63e-43         4.6e-44               0               0
0000460           1e-45               0
0000470
</pre>

<p>Následující příklad vypíše část sektoru ze zvoleného blokového zařízení,
dejte si ovšem pozor, že <strong>od</strong> bude poctivě
&bdquo;seekovat&ldquo; na zadaný offset:</p>

<pre>
<strong>sudo od -j 100000000 -N 256 -v -t x1 /dev/sda1</strong>
&nbsp;
...
...
...
</pre>

<img src="https://i.iinfo.cz/images/2/hexa2-4.png" class="image-311442" alt="&#160;" width="804" height="504" />
<p><i>Obrázek 2: Alternativní způsob, kdy se kromě kódů znaků zobrazí i jejich
jméno v&nbsp;ASCII.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Uložení obsahu vektoru do textového souboru se specifikací oddělovače</h2>

<p>Začneme tím nejjednodušším možným případem; konkrétně se bude jednat o
uložení obsahu desetiprvkového vektoru do textového souboru, a to navíc se
specifikací oddělovače jednotlivých prvků. Jako oddělovat zvolíme čárku:</p>

<pre>
<i>"""Uložení obsahu vektoru do textového souboru se specifikací oddělovače."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 8bitové hodnoty (byte)</i>
v = np.linspace(1, 10, 10, dtype="b")
print(v)
&nbsp;
<strong>v.tofile("vector1.txt", sep=",")</strong>
</pre>

<p>Obsah vygenerovaného souboru by měl vypadat následovně &ndash; jedná se o
jediný řádek se všemi hodnotami:</p>

<pre>
1,2,3,4,5,6,7,8,9,10
</pre>

<p>Alternativně je možné si zvolit formát jednotlivých prvků. Ve výchozím
nastavení odpovídá formát &bdquo;nejčitelnější&ldquo; variantě, ovšem snadno
můžeme například zajistit, aby se hodnoty prvků umístily do uvozovek, apostrofů
atd. atd.:</p>

<pre>
<i>"""Uložení obsahu vektoru do textového souboru se specifikací oddělovače a</i>
<i>formátu jednotlivých prvků."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 8bitové hodnoty (byte)</i>
v = np.linspace(1, 10, 10, dtype="b")
print(v)
&nbsp;
<strong>v.tofile("vector2.txt", sep=",", format='"%s"')</strong>
</pre>

<p>Výsledek:</p>

<pre>
"1","2","3","4","5","6","7","8","9","10"
</pre>

<p><div class="rs-tip-major">Poznámka: pokud jako oddělovač zapíšete znak
&bdquo;\n&ldquo;, bude každý prvek vektoru umístěn na samostatné
řádce.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Uložení obsahu vektoru do binárního souboru</h2>

<p>V&nbsp;případě, že se oddělovač neuvede, bude vektor uložen do binárního
souboru. V&nbsp;takovém případě záleží konkrétní způsob uložení na tom, jakého
typu jsou prvky vektoru. Abychom si vše ilustrovali, budeme do binárního
souboru ukládat vektory s&nbsp;prvky různých typů a následně se podíváme na
délku i obsah výsledného souboru.</p>

<p><div class="rs-tip-major">Poznámka: důležité upozornění &ndash; pro všechny
typy větší než bajt se mohou výsledné soubory lišit podle architektury
procesoru, konkrétně podle jeho <i>endianity</i>, tedy podle toho, jak jsou
bajty ve vícebajtovém slově uspořádány (zda od nejvyššího bajtu
k&nbsp;nejnižšímu, naopak, či zda se bude jednat o nějaký mix obou
přístupů).</div></p>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 8bitové hodnoty (byte)</i>
v = np.linspace(1, 10, 10, dtype="b")
print(v)
&nbsp;
v.tofile("vector3.bin")
</pre>

<p>Soubor s&nbsp;délkou deseti bajtů:</p>

<pre>
$ <strong>od -t x1 vector3.bin</strong>
&nbsp;
0000000 01 02 03 04 05 06 07 08 09 0a
0000012
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 16bitové hodnoty (half integer)</i>
v = np.linspace(1, 10, 10, dtype="h")
print(v)
&nbsp;
v.tofile("vector4.bin")
</pre>

<p>Vytvoří se soubor s&nbsp;délkou dvaceti bajtů, který si prohlédneme odlišným
způsobem &ndash; dekadicky:</p>

<pre>
$ <strong>od -t d2 vector4.bin</strong>
&nbsp;
0000000      1      2      3      4      5      6      7      8
0000020      9     10
0000024
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 32bitové hodnoty (integer)</i>
v = np.linspace(1, 10, 10, dtype="i")
print(v)
&nbsp;
v.tofile("vector5.bin")
</pre>

<p>V&nbsp;tomto případě si soubor prohlédneme jak &bdquo;dekadicky&ldquo;, tak
i s&nbsp;hexadecimálním výstupem:</p>

<pre>
$ <strong>od -t d4 vector5.bin</strong>
&nbsp;
0000000           1           2           3           4
0000020           5           6           7           8
0000040           9          10
0000050
&nbsp;
$ <strong>od -t x1 vector5.bin</strong>
&nbsp;
0000000 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00
0000020 05 00 00 00 06 00 00 00 07 00 00 00 08 00 00 00
0000040 09 00 00 00 0a 00 00 00
0000050
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 64bitové hodnoty (long integer)</i>
v = np.linspace(1, 10, 10, dtype="l")
print(v)
&nbsp;
v.tofile("vector6.bin")
</pre>

<p>Výsledky:</p>

<pre>
$ <strong>od -t d8 vector6.bin</strong>
&nbsp;
0000000                    1                    2
0000020                    3                    4
0000040                    5                    6
0000060                    7                    8
0000100                    9                   10
0000120
&nbsp;
$ <strong>od -t x1 vector6.bin</strong>
&nbsp;
0000000 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00
0000020 03 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00
0000040 05 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00
0000060 07 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00
0000100 09 00 00 00 00 00 00 00 0a 00 00 00 00 00 00 00
0000120
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující hodnoty s plovoucí řádovou čárkou</i>
<i># s jednoduchou přesností (float, single)</i>
v = np.linspace(1, 10, 10, dtype="f")
print(v)
&nbsp;
v.tofile("vector7.bin")
</pre>

<p>V&nbsp;tomto případě je nejvýhodnější formát <strong>f4</strong>:</p>

<pre>
$ <strong>od -t f4 vector7.bin </strong>
&nbsp;
0000000               1               2               3               4
0000020               5               6               7               8
0000040               9              10
0000050
&nbsp;
$ <strong>od -t x1 vector7.bin </strong>
&nbsp;
0000000 00 00 80 3f 00 00 00 40 00 00 40 40 00 00 80 40
0000020 00 00 a0 40 00 00 c0 40 00 00 e0 40 00 00 00 41
0000040 00 00 10 41 00 00 20 41
0000050
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující hodnoty s plovoucí řádovou čárkou</i>
<i># s dvojitou přesností (double)</i>
v = np.linspace(1, 10, 10, dtype="d")
print(v)
&nbsp;
v.tofile("vector8.bin")
</pre>

<p>Výsledky:</p>

<pre>
$ <strong>od -t f8 vector8.bin </strong>
&nbsp;
0000000                        1                        2
0000020                        3                        4
0000040                        5                        6
0000060                        7                        8
0000100                        9                       10
0000120
&nbsp;
$ <strong>od -t x1 vector8.bin </strong>
&nbsp;
0000000 00 00 00 00 00 00 f0 3f 00 00 00 00 00 00 00 40
0000020 00 00 00 00 00 00 08 40 00 00 00 00 00 00 10 40
0000040 00 00 00 00 00 00 14 40 00 00 00 00 00 00 18 40
0000060 00 00 00 00 00 00 1c 40 00 00 00 00 00 00 20 40
0000100 00 00 00 00 00 00 22 40 00 00 00 00 00 00 24 40
0000120
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující hodnoty s plovoucí řádovou čárkou</i>
<i># s poloviční přesností (half)</i>
v = np.linspace(1, 10, 10, dtype="e")
print(v)
&nbsp;
v.tofile("vector9.bin")
</pre>

<p>Tento formát není nástrojem <strong>od</strong> podporován, takže si budeme
muset vystačit s&nbsp;převodem na hexadecimální hodnoty:</p>

<pre>
$ <strong>od -t x1 vector9.bin </strong>
&nbsp;
0000000 00 3c 00 40 00 42 00 44 00 45 00 46 00 47 00 48
0000020 80 48 00 49
0000024
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Načtení obsahu vektoru z&nbsp;textového popř.&nbsp;binárního souboru</h2>

<p>Opakem uložení vektoru je jeho načtení ze souboru. To je většinou triviální,
což si ostatně ukážeme na několika příkladech. Nejdříve načtení obsahu vektoru
z&nbsp;textového souboru se specifikací oddělovače:</p>

<pre>
<i>"""Načtení obsahu vektoru z textového souboru se specifikací oddělovače."""</i>
&nbsp;
import numpy as np
&nbsp;
v = <strong>np.fromfile("vector1.txt", sep=",")</strong>
print(v)
</pre>

<p>Specifikovat můžeme i konverzi na kýžený datový typ:</p>

<pre>
<i>"""Načtení obsahu vektoru z textového souboru se specifikací oddělovače a s konverzí."""</i>
&nbsp;
import numpy as np
&nbsp;
v = <strong>np.fromfile("vector1.txt", sep=",").astype("i")</strong>
print(v)
</pre>

<p>Pokus o načtení vektoru z&nbsp;binárního souboru bez uvedení datového typu
většinou povede k&nbsp;chybě:</p>

<pre>
<i>"""Načtení obsahu vektoru z binárního souboru (nekorektní použití)."""</i>
&nbsp;
import numpy as np
&nbsp;
v = <strong>np.fromfile("vector4.bin")</strong>
print(v)
</pre>

<p>V&nbsp;naprosté většině případů je nutné specifikovat, jakého typu jsou
prvky vektoru v&nbsp;době, kdy došlo k&nbsp;jeho uložení do binárního
souboru:</p>

<pre>
<i>"""Načtení obsahu vektoru z binárního souboru s konverzí."""</i>
&nbsp;
import numpy as np
&nbsp;
v = <strong>np.fromfile("vector4.bin", dtype="h")</strong>
print(v)
</pre>

<p><div class="rs-tip-major">Poznámka: &bdquo;h&ldquo; znamená 16bitovou
hodnotu s&nbsp;plovoucí řádovou čárkou.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Uložení obsahu matice do textového souboru se specifikací oddělovače i do souboru binárního</h2>

<p>Naprosto stejným způsobem jako s&nbsp;vektory se pracuje s&nbsp;maticemi,
protože pro metodu <strong>tofile</strong> se stále jedná o pouhou sekvenci
prvků (ztrácí se tedy informace o tvaru &ndash; &bdquo;shape&ldquo;
matice!):</p>

<pre>
<i>"""Uložení obsahu matice do textového souboru se specifikací oddělovače."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># matice obsahující celočíselné 8bitové hodnoty (byte)</i>
m = np.linspace(1, 12, 12, dtype="b").reshape(3, 4)
print(m)
&nbsp;
<strong>m.tofile("matrix1.txt", sep=",")</strong>
</pre>

<p>Uložení matice do binárního souboru je opět snadné:</p>

<pre>
<i>"""Uložení obsahu matice do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># matice obsahující celočíselné 8bitové hodnoty (byte)</i>
m = np.linspace(1, 12, 12, dtype="b").reshape(3, 4)
print(m)
&nbsp;
<strong>m.tofile("matrix2.bin")</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě vznikne soubor o
velikosti 12 bajtů &ndash; uloží se tedy pouze prvky matice, nikoli informace o
jejím tvaru!</div></p>

<p>Při načítání matice ve skutečnosti získáme pouhý jednorozměrný vektor, který
je nutné na matici převést metodou <strong>reshape</strong>:</p>

<pre>
<i>"""Načtení obsahu matice z textového souboru se specifikací oddělovače."""</i>
&nbsp;
import numpy as np
&nbsp;
m = <strong>np.fromfile("matrix1.txt", sep=",").reshape(3, 4)</strong>
print(m)
</pre>

<p>Provést můžeme i přetypování prvků po jejich načtení:</p>

<pre>
<i>"""Načtení obsahu matice z textového souboru se specifikací oddělovače."""</i>
&nbsp;
import numpy as np
&nbsp;
m = <strong>np.fromfile("matrix1.txt", sep=",").reshape(3, 4).astype("b")</strong>
print(m)
</pre>

<p>Následující příklad bude funkční pouze za předpokladu, že prvky matice měly
formát <strong>int64</strong>. Obecně je vhodné při každém načítání binárních
souborů použít explicitní specifikaci typu prvků:</p>

<pre>
<i>"""Načtení obsahu matice z binárního souboru bez specifikace formátu."""</i>
&nbsp;
import numpy as np
&nbsp;
m = <strong>np.fromfile("matrix2.bin").reshape(3, 4)</strong>
print(m)
</pre>

<p>Takto je to správně &ndash; explicitně uvádíme jak typ prvků, tak i
požadovaný výsledný tvar matice:</p>

<pre>
<i>"""Načtení obsahu matice z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
&nbsp;
m = <strong>np.fromfile("matrix2.bin", dtype="b").reshape(3, 4)</strong>
print(m)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Standardní binární soubor knihovny NumPy</h2>

<p>Z&nbsp;předchozích kapitol je patrné, že je sice možné n-rozměrná pole
ukládat do binárních souborů, ale bude se jednat skutečně pouze o čisté hodnoty
prvků. Žádné další informace se neuloží &ndash; tedy ani typ prvků ani tvar
pole. To není ani zdaleka ideální situace a proto byl vyvinut dnes již
standardní binární formát určený pro ukládání n-rozměrných polí. Tento formát
se nazývá NPY a jeho popis lze nalézt na stránce <a
href="https://numpy.org/devdocs/reference/generated/numpy.lib.format.html">https://numpy.org/devdocs/reference/generated/numpy.lib.format.html</a>.
Jedná se o přímou serializaci pole do souboru, ovšem před vlastní hodnoty prvků
je uložena jednoduchá hlavička se všemi důležitými informacemi &ndash; včetně
endianity, kterou jsme prozatím vůbec neřešili.</p>

<p><div class="rs-tip-major">Poznámka: pokud se má uložit větší množství polí,
lze soubory NPY zabalit do ZIP archivu a použít koncovku NPZ. Podrobnosti si
ukážeme příště.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Standardní binární soubor pro vektory</h2>

<p>Vektor s&nbsp;prvky libovolného typu se uloží do standardního binárního
formátu funkcí <strong>save</strong>. Té je možné (a vhodné) předat parametr
<strong>allow_pickle=False</strong> aby se zabránilo případné serializaci
objektů:</p>

<pre>
<i>"""Uložení obsahu vektoru do standardního binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující hodnoty s plovoucí řádovou čárkou</i>
<i># s poloviční přesností (half)</i>
v = np.linspace(1, 10, 10, dtype="e")
print(v)
&nbsp;
<strong>np.save("vector.npy", v, allow_pickle=False)</strong>
</pre>

<p>Výsledný soubor si vypíšeme jak v&nbsp;hexadecimálním tvaru, tak i jako
sekvenci znaků:</p>

<pre>
$ <strong>od -t x1z -v vector.npy</strong>
&nbsp;
0000000 93 4e 55 4d 50 59 01 00 76 00 7b 27 64 65 73 63  &gt;.NUMPY..v.{'desc&lt;
0000020 72 27 3a 20 27 3c 66 32 27 2c 20 27 66 6f 72 74  &gt;r': '&lt;f2', 'fort&lt;
0000040 72 61 6e 5f 6f 72 64 65 72 27 3a 20 46 61 6c 73  &gt;ran_order': Fals&lt;
0000060 65 2c 20 27 73 68 61 70 65 27 3a 20 28 31 30 2c  &gt;e, 'shape': (10,&lt;
0000100 29 2c 20 7d 20 20 20 20 20 20 20 20 20 20 20 20  &gt;), }            &lt;
0000120 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20  &gt;                &lt;
0000140 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20  &gt;                &lt;
0000160 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 0a  &gt;               .&lt;
0000200 00 3c 00 40 00 42 00 44 00 45 00 46 00 47 00 48  &gt;.&lt;.@.B.D.E.F.G.H&lt;
0000220 80 48 00 49                                      &gt;.H.I&lt;
0000224
</pre>

<p>Hlavička v&nbsp;tomto případě obsahuje mj.&nbsp;i informace o typu prvků
&bdquo;f2&ldquo; i o tvaru pole (v&nbsp;čitelném tvaru). Samotná data začínají
na offsetu 128 (tedy 200 oktalově).</p>

<p>Tento binární soubor s&nbsp;obsahem vektoru lze načíst velmi snadno, a to
konkrétně funkcí <strong>numpy.load()</strong>:</p>

<pre>
<i>"""Přečtení obsahu vektoru ze standardního binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
v = <strong>np.load("vector.npy")</strong>
print(v)
print(v.dtype)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Uložení a načtení matice do/ze standardního binárního souboru</h2>

<p>Naprosto stejným způsobem jako s&nbsp;vektory se v&nbsp;případě standardního
binárního souboru NPY pracuje s&nbsp;maticemi. Uložení matice:</p>

<pre>
<i>"""Uložení obsahu matice do standardního binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># matice obsahující celočíselné 8bitové hodnoty (byte)</i>
m = np.linspace(1, 12, 12, dtype="b").reshape(3, 4)
print(m)
&nbsp;
<strong>np.save("matrix1.npy", m, allow_pickle=False)</strong>
</pre>

<p>Zpětné načtení matice:</p>

<pre>
<i>"""Přečtení obsahu matice ze standardního binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
m = <strong>np.load("matrix1.npy")</strong>
print(m)
print(m.dtype)
</pre>

<p>Přitom je vytvořen tento soubor:</p>

<pre>
$ <strong>od -Ax -t x1z -v matrix1.npy</strong>
&nbsp;
000000 93 4e 55 4d 50 59 01 00 76 00 7b 27 64 65 73 63  &gt;.NUMPY..v.{'desc&lt;
000010 72 27 3a 20 27 7c 69 31 27 2c 20 27 66 6f 72 74  &gt;r': '|i1', 'fort&lt;
000020 72 61 6e 5f 6f 72 64 65 72 27 3a 20 46 61 6c 73  &gt;ran_order': Fals&lt;
000030 65 2c 20 27 73 68 61 70 65 27 3a 20 28 33 2c 20  &gt;e, 'shape': (3, &lt;
000040 34 29 2c 20 7d 20 20 20 20 20 20 20 20 20 20 20  &gt;4), }           &lt;
000050 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20  &gt;                &lt;
000060 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20  &gt;                &lt;
000070 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 0a  &gt;               .&lt;
000080 01 02 03 04 05 06 07 08 09 0a 0b 0c              &gt;............&lt;
00008c
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že tvar je popsán
řetězcem <strong>(3, 4</strong>).</div></p>

<p>Stejný příklad, ovšem s&nbsp;maticí obsahující prvky typu
&bdquo;float&ldquo;:</p>

<pre>
<i>"""Uložení obsahu matice do standardního binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
m = np.linspace(1, 12, 12, dtype="f").reshape(3, 4)
print(m)
&nbsp;
<strong>np.save("matrix2.npy", m, allow_pickle=False)</strong>
</pre>

<p>Zpětné načtení matice:</p>

<pre>
<i>"""Přečtení obsahu matice ze standardního binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
m = <strong>np.load("matrix2.npy")</strong>
print(m)
print(m.dtype)
</pre>

<p>Druhý binární soubor má obsah:</p>

<pre>
$ <strong>od -Ax -t x1z -v matrix2.npy</strong>
&nbsp;
000000 93 4e 55 4d 50 59 01 00 76 00 7b 27 64 65 73 63  &gt;.NUMPY..v.{'desc&lt;
000010 72 27 3a 20 27 3c 66 34 27 2c 20 27 66 6f 72 74  &gt;r': '&lt;f4', 'fort&lt;
000020 72 61 6e 5f 6f 72 64 65 72 27 3a 20 46 61 6c 73  &gt;ran_order': Fals&lt;
000030 65 2c 20 27 73 68 61 70 65 27 3a 20 28 33 2c 20  &gt;e, 'shape': (3, &lt;
000040 34 29 2c 20 7d 20 20 20 20 20 20 20 20 20 20 20  &gt;4), }           &lt;
000050 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20  &gt;                &lt;
000060 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20  &gt;                &lt;
000070 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 0a  &gt;               .&lt;
000080 00 00 80 3f 00 00 00 40 00 00 40 40 00 00 80 40  &gt;...?...@..@@...@&lt;
000090 00 00 a0 40 00 00 c0 40 00 00 e0 40 00 00 00 41  &gt;...@...@...@...A&lt;
0000a0 00 00 10 41 00 00 20 41 00 00 30 41 00 00 40 41  &gt;...A.. A..0A..@A&lt;
0000b0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Binární soubory a knihovna Pandas</h2>

<p>Práce s&nbsp;n-dimenzionálními poli uloženými do binárních souborů je
přímočará, protože všechny prvky vektorů, matic i vícedimenzionálních polí musí
být stejného typu. To znamená, že binární soubory obsahují prvky uložené
v&nbsp;jediném formátu. Ovšem v&nbsp;případě knihovny <i>Pandas</i> je situace
odlišná, neboť datové rámce (<i>data frame</i>) obecně mohou mít každý sloupec
jiného typu. Tato skutečnost se odráží i v&nbsp;tom, že do knihovny Pandas lze
načítat datové soubory s&nbsp;poměrně flexibilní binární strukturou. Dnes si
ukážeme základní práci s&nbsp;binárními soubory, u nichž je nutné dodržet pouze
jedinou podmínku &ndash; všechny řádky musí mít shodnou délku (počítanou
v&nbsp;bajtech) a i všechny prvky musí být stejně široké. V&nbsp;praxi to tedy
znamená především to, že jsme omezeni na řetězce pevné délky (což je ovšem
v&nbsp;binárních souborech velmi časté a mnohdy i užitečné &ndash; zejména při
nutnosti častých <i>seeků</i> na n-tý záznam.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Načtení obsahu datové řady z&nbsp;binárního souboru s&nbsp;konverzí</h2>

<p>Začneme nejdříve tím nejjednodušším možným případem, konkrétně
s&nbsp;načtením datové řady (<i>Series</i>). Nejprve do binárního souboru
uložíme běžný vektor, konkrétně desetiprvkový vektor s&nbsp;16bitovými celými
čísly:</p>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 16bitové hodnoty (half integer)</i>
v = np.linspace(1, 10, 10, dtype="h")
print(v)
&nbsp;
v.tofile("vector4.bin")
</pre>

<p>Tento vektor můžeme zpětně načíst (což již velmi dobře známe
z&nbsp;předchozích kapitol). A následně tento vektor převedeme na datovou řadu
konstruktorem <strong>pandas.Series</strong>:</p>

<pre>
<i>"""Načtení obsahu datové řady z binárního souboru s konverzí."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
v = <strong>np.fromfile("vector4.bin", dtype="h")</strong>
s = <strong>pd.Series(v)</strong>
&nbsp;
print(s)
print()
print(s.describe())
</pre>

<p>Výsledkem je podle očekávání datová řada s&nbsp;deseti prvky a automaticky
vytvořenými indexy:</p>

<pre>
0     1
1     2
2     3
3     4
4     5
5     6
6     7
7     8
8     9
9    10
&nbsp;
dtype: int16
&nbsp;
count    10.00000
mean      5.50000
std       3.02765
min       1.00000
25%       3.25000
50%       5.50000
75%       7.75000
max      10.00000
dtype: float64
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Načtení obsahu datového rámce z&nbsp;binárního souboru se specifikací formátu</h2>

<p>Podobně přímočaré je načtení datového rámce v&nbsp;případě, že všechny
sloupce datového rámce mají shodný formát. V&nbsp;tomto případě načteme běžnou
matici a tu na datový rámec převedeme:</p>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
m = <strong>np.fromfile("matrix2.bin", dtype="b").reshape(3, 4)</strong>
&nbsp;
df = <strong>pd.DataFrame(m)</strong>
&nbsp;
print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<p>Tento skript po svém spuštění nejdříve vypíše obsah matice a poté i
informace o zkonstruovaném datovém rámci:</p>

<pre>
   0   1   2   3
0  1   2   3   4
1  5   6   7   8
2  9  10  11  12
&nbsp;
&lt;class 'pandas.core.frame.DataFrame'&gt;
&nbsp;
RangeIndex: 3 entries, 0 to 2
Data columns (total 4 columns):
 #   Column  Non-Null Count  Dtype
---  ------  --------------  -----
 0   0       3 non-null      int8 
 1   1       3 non-null      int8 
 2   2       3 non-null      int8 
 3   3       3 non-null      int8 
dtypes: int8(4)
memory usage: 140.0 bytes
&nbsp;
None
&nbsp;
         0     1     2     3
count  3.0   3.0   3.0   3.0
mean   5.0   6.0   7.0   8.0
std    4.0   4.0   4.0   4.0
min    1.0   2.0   3.0   4.0
25%    3.0   4.0   5.0   6.0
50%    5.0   6.0   7.0   8.0
75%    7.0   8.0   9.0  10.0
max    9.0  10.0  11.0  12.0
</pre>

<p><div class="rs-tip-major">Poznámka: skutečně se jedná o dvojici těch
nejjednodušších případů (navíc dosti teoretických). V&nbsp;praxi je situace
většinou mnohem složitější, neboť datové rámce mohou obsahovat sloupce
s&nbsp;různými typy dat. Práce s&nbsp;binárními soubory, které mohou tato data
obsahovat, je ukázána v&nbsp;navazujících kapitolách.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vygenerování binárního souboru se dvěma sloupci čísel s&nbsp;různou reprezentací</h2>

<p>Pro vytvoření binárního souboru, který obsahuje dva sloupce numerických
hodnot (každý ovšem s&nbsp;odlišnou reprezentací) poslouží následující zdrojový
kód napsaný v&nbsp;ANSI C. Každý pomyslný řádek obsahuje celočíselnou hodnotu
typu <strong>int</strong> a taktéž hodnotu reprezentovanou v&nbsp;systému
plovoucí řádové čárky (<strong>float</strong>). Povšimněte si, že tento program
může vygenerovat soubory různé délky (podle šířky typu <strong>int</strong>) a
navíc nikde nespecifikujeme endianitu hodnot. Výsledek tedy nebude přenositelný
na různé architektury:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int <strong>main</strong>(void) {
    FILE *fout;
    int i;
&nbsp;
    fout = fopen("binary_df_1.bin", "w");
    if (!fout) {
        return 1;
    }
    for (i=1; i&lt;11; i++) {
        float x = 1.0/i;
        fwrite(&amp;i, sizeof(int), 1, fout);
        fwrite(&amp;x, sizeof(float), 1, fout);
    }
    fclose(fout);
    return 0;
}
</pre>

<p>Na platformě x86-64 by měl vzniknout soubor o délce přesně osmdesáti bajtů,
protože jak typ <strong>int</strong>, tak i <strong>float</strong> jsou uloženy
ve čtyřech bajtech:</p>

<pre>
$ <strong>od -t x1 binary_df_1.bin</strong>
&nbsp;
0000000 01 00 00 00 00 00 80 3f 02 00 00 00 00 00 00 3f
0000020 03 00 00 00 ab aa aa 3e 04 00 00 00 00 00 80 3e
0000040 05 00 00 00 cd cc 4c 3e 06 00 00 00 ab aa 2a 3e
0000060 07 00 00 00 25 49 12 3e 08 00 00 00 00 00 00 3e
0000100 09 00 00 00 39 8e e3 3d 0a 00 00 00 cd cc cc 3d
0000120
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si endianity, kterou snadno
zjistíme již z&nbsp;první celočíselné hodnoty 1 (neboli 0x00000001):</div></p>

<pre>
01 00 00 00
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Načtení binárního souboru s&nbsp;různými typy sloupců do datového rámce</h2>

<p>Binární soubor vytvořený programem uvedeným <a href="#k12">v&nbsp;předchozí
kapitole</a> lze relativně snadno načíst do datového rámce. Celý postup se
přitom skládá z&nbsp;několika kroků:</p>

<ol>
<li>Specifikace typů dat pro jednotlivé sloupce</li>
<li>Načtení binárního souboru do specifického n-dimenzionálního pole (s&nbsp;n-ticemi)</li>
<li>Konverze tohoto pole na běžný datový rámec</li>
</ol>

<p><div class="rs-tip-major">Poznámka: druhý krok může vypadat zvláštně,
protože v&nbsp;knihovně NumPy jsou všechna pole <i>homogenní</i>,
tj.&nbsp;vlastně nemohou obsahovat sloupce různých typů. To je sice pravda,
ovšem prvkem pole může být například i n-tice nebo objekt &ndash; potom se
stále bude jednat o homogenní pole, ovšem nikoli s&nbsp;prvky primitivních
datových typů. A právě tento trik je použit v&nbsp;dále ukázaném demonstračním
příkladu.</div></p>

<p>Povšimněte si, jakým způsobem jsou definovány typy sloupců &ndash; uvedeme
mapování mezi názvem sloupce a kódem jeho datového typu, kde například
&bdquo;u4&ldquo; znamená celočíselnou hodnotu bez znaménka uloženou ve čtyřech
bajtech, &bdquo;f4&ldquo; hodnotu typu <i>float</i> uloženou ve čtyřech bajtech
atd.:</p>

<pre>
<i># specifikace typů dat jednotlivých sloupců</i>
<strong>dt = np.dtype([</strong>
    <strong>("i", "u4"),</strong>
    <strong>("x", "f4")</strong>
    <strong>])</strong>
</pre>

<p>Úplný skript vypadá následovně:</p>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
<i># specifikace typů dat jednotlivých sloupců</i>
<strong>dt = np.dtype([</strong>
    <strong>("i", "u4"),</strong>
    <strong>("x", "f4")</strong>
    <strong>])</strong>
&nbsp;
<strong>np_data = np.fromfile("binary_df_1.bin", dtype=dt)</strong>
print(np_data)
print(np_data.ndim)
print(np_data.dtype)
&nbsp;
<strong>df = pd.DataFrame(np_data)</strong>
&nbsp;
print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<p>Skript po svém spuštění nejdříve vypíše obsah načteného pole. Z&nbsp;tohoto
výpisu je patrné, že se jedná o n-tice:</p>

<pre>
[( 1, 1.        ) ( 2, 0.5       ) ( 3, 0.33333334) ( 4, 0.25      )
 ( 5, 0.2       ) ( 6, 0.16666667) ( 7, 0.14285715) ( 8, 0.125     )
 ( 9, 0.11111111) (10, 0.1       )]
</pre>

<p>Dále se vypíše počet dimenzí tohoto pole (což je v&nbsp;tomto případě
konkrétně jednodimenzionální vektor) a datový typ prvků:</p>

<pre>
1
[('i', '&lt;u4'), ('x', '&lt;f4')]
</pre>

<p>A nakonec se vypíše vytvořený datový rámec a další informace o tomto
rámci:</p>

<pre>
    i         x
0   1  1.000000
1   2  0.500000
2   3  0.333333
3   4  0.250000
4   5  0.200000
5   6  0.166667
6   7  0.142857
7   8  0.125000
8   9  0.111111
9  10  0.100000
&nbsp;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 10 entries, 0 to 9
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   i       10 non-null     uint32 
 1   x       10 non-null     float32
dtypes: float32(1), uint32(1)
memory usage: 208.0 bytes
None
&nbsp;
              i          x
count  10.00000  10.000000
mean    5.50000   0.292897
std     3.02765   0.277265
min     1.00000   0.100000
25%     3.25000   0.129464
50%     5.50000   0.183333
75%     7.75000   0.312500
max    10.00000   1.000000
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Specifikace endianity dat</h2>

<p>Při specifikaci typů prvků uložených v&nbsp;jednotlivých sloupcích lze
specifikovat i jejich endianitu. Provádí se to pomocí znaků &lt; a &gt;.
Například na architektuře x86-64 se očekává little endian a tedy:</p>

<pre>
dt = np.dtype([
    ("i", "&lt;u4"),
    ("x", "&lt;f4")
    ])
</pre>

<p>Schválně se ale podívejme na to, co se stane, pokud při načítání binárního
souboru s&nbsp;little endian budeme u celočíselných prvků definovat opačnou
endianitu, tedy big endian (viz zvýrazněný programový řádek):</p>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
dt = np.dtype([
    <strong>("i", "&gt;u4")</strong>,
    ("x", "&lt;f4")
    ])
&nbsp;
np_data = np.fromfile("binary_df_1.bin", dtype=dt)
print(np_data)
print(np_data.ndim)
print(np_data.dtype)
&nbsp;
df = pd.DataFrame(np_data)
&nbsp;
print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<p>Z&nbsp;vypsaných výsledků je patrné, že se data sice načetla, ale například
místo hodnoty 1 dostaneme hodnotu 16777216 atd. Je tak tomu z&nbsp;toho důvodu,
že jedničku lze reprezentovat jako sekvenci bajtů 00 00 00 01, ovšem my jsme
namísto toho načetli 01 00 00 00, což se na celé číslo převede formou
1&times;2<sup>24</sup>:</p>

<pre>
[( 16777216, 1.        ) ( 33554432, 0.5       ) ( 50331648, 0.33333334)
 ( 67108864, 0.25      ) ( 83886080, 0.2       ) (100663296, 0.16666667)
 (117440512, 0.14285715) (134217728, 0.125     ) (150994944, 0.11111111)
 (167772160, 0.1       )]
&nbsp;
1
&nbsp;
[('i', '&gt;u4'), ('x', '&lt;f4')]
&nbsp;
           i         x
0   16777216  1.000000
1   33554432  0.500000
2   50331648  0.333333
3   67108864  0.250000
4   83886080  0.200000
5  100663296  0.166667
6  117440512  0.142857
7  134217728  0.125000
8  150994944  0.111111
9  167772160  0.100000
&nbsp;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 10 entries, 0 to 9
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   i       10 non-null     &gt;u4    
 1   x       10 non-null     float32
dtypes: float32(1), uint32(1)
memory usage: 208.0 bytes
None
&nbsp;
                  i          x
count  1.000000e+01  10.000000
mean   9.227469e+07   0.292897
std    5.079554e+07   0.277265
min    1.677722e+07   0.100000
25%    5.452595e+07   0.129464
50%    9.227469e+07   0.183333
75%    1.300234e+08   0.312500
max    1.677722e+08   1.000000
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vygenerování binárního souboru se dvěma sloupci čísel s&nbsp;různou reprezentací a se sloupcem s&nbsp;řetězci</h2>

<p><a href="#k12">Ve dvanácté kapitole</a> jsme si ukázali program napsaný
v&nbsp;ANSI C, který po svém spuštění vytvořil binární soubor obsahující dva
sloupce číselných hodnot. Tento program nyní nepatrně upravíme takovým
způsobem, aby se ukládal ještě jeden sloupec hodnot &ndash; tentokrát ovšem
řetězců. Pro jednoduchost prozatím budeme generovat řetězce pevné délky (a
dokonce se ani nebude jednat o klasické céčkovské řetězce, protože nebude
ukládána koncová nula). Ostatně s&nbsp;řetězci pevné délky se v&nbsp;binárních
souborech můžeme setkat relativně často:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
char* names[] = {
    "odd ",
    "even"
};
&nbsp;
int <strong>main</strong>(void) {
    FILE *fout;
    int i;
&nbsp;
    fout = fopen("binary_df_2.bin", "w");
    if (!fout) {
        return 1;
    }
    for (i=1; i&lt;11; i++) {
        float x = 1.0/i;
        fwrite(&amp;i, sizeof(int), 1, fout);
        fwrite(&amp;x, sizeof(float), 1, fout);
        fwrite(names[i%2], 4, 1, fout);
    }
    fclose(fout);
    return 0;
}
</pre>

<p>Výsledkem by měl být na platformě x86-64 binární soubor o délce 120 bajtů
&ndash; to konkrétně znamená, že každý řádek obsahuje přesně dvanáct bajtů
(čtyři pro celočíselnou hodnotu, další čtyři pro hodnotu s&nbsp;plovoucí
řádovou čárkou a poslední čtyři bajty pro uložení čtyřech znaků řetězce):</p>

<pre>
$ <strong>od -t x1 binary_df_2.bin</strong>
&nbsp;
0000000 01 00 00 00 00 00 80 3f 65 76 65 6e 02 00 00 00
0000020 00 00 00 3f 6f 64 64 20 03 00 00 00 ab aa aa 3e
0000040 65 76 65 6e 04 00 00 00 00 00 80 3e 6f 64 64 20
0000060 05 00 00 00 cd cc 4c 3e 65 76 65 6e 06 00 00 00
0000100 ab aa 2a 3e 6f 64 64 20 07 00 00 00 25 49 12 3e
0000120 65 76 65 6e 08 00 00 00 00 00 00 3e 6f 64 64 20
0000140 09 00 00 00 39 8e e3 3d 65 76 65 6e 0a 00 00 00
0000160 cd cc cc 3d 6f 64 64 20
0000170
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Načtení obsahu datového rámce z&nbsp;binárního souboru obsahujícího řetězce pevné délky</h2>

<p>Binární soubor vytvořený v&nbsp;rámci <a href="#k15">předchozí kapitoly</a>
je možné načíst do datového rámce knihovny Pandas. Musíme ovšem opět explicitně
specifikovat datové typy jednotlivých sloupců. První dva typy (pro celá čísla i
typ <i>float</i>) již známe, takže nám zbývá určit, že další čtyři bajty
obsahují znaky (tedy dohromady řetězec). Použijeme kód &bdquo;S4&ldquo;:</p>

<pre>
dt = np.dtype([
    ("i", "&lt;u4"),
    ("x", "&lt;f4"),
    ("type", "S4"),
    ])
</pre>

<p>Celý skript, který binární soubor načte a vytvoří z&nbsp;něho datový rámec,
bude vypadat takto:</p>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
dt = np.dtype([
    ("i", "&lt;u4"),
    ("x", "&lt;f4"),
    ("type", "S4"),
    ])
&nbsp;
np_data = np.fromfile("binary_df_2.bin", dtype=dt)
print(np_data)
print(np_data.ndim)
print(np_data.dtype)
&nbsp;
df = pd.DataFrame(np_data)
&nbsp;
print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<p>Po spuštění tohoto skriptu se nejprve vypíše informace o surových načtených
datech:</p>

<pre>
[( 1, 1.        , b'even') ( 2, 0.5       , b'odd ')
 ( 3, 0.33333334, b'even') ( 4, 0.25      , b'odd ')
 ( 5, 0.2       , b'even') ( 6, 0.16666667, b'odd ')
 ( 7, 0.14285715, b'even') ( 8, 0.125     , b'odd ')
 ( 9, 0.11111111, b'even') (10, 0.1       , b'odd ')]
&nbsp;
1
&nbsp;
[('i', '&lt;u4'), ('x', '&lt;f4'), ('type', 'S4')]
</pre>

<p>Dále se již vypíše obsah samotného datového rámce, metainformace o tomto
rámci a statistika:</p>

<pre>
    i         x     type
0   1  1.000000  b'even'
1   2  0.500000  b'odd '
2   3  0.333333  b'even'
3   4  0.250000  b'odd '
4   5  0.200000  b'even'
5   6  0.166667  b'odd '
6   7  0.142857  b'even'
7   8  0.125000  b'odd '
8   9  0.111111  b'even'
9  10  0.100000  b'odd '
&nbsp;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 10 entries, 0 to 9
Data columns (total 3 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   i       10 non-null     uint32 
 1   x       10 non-null     float32
 2   type    10 non-null     object 
dtypes: float32(1), object(1), uint32(1)
memory usage: 288.0+ bytes
None
&nbsp;
              i          x
count  10.00000  10.000000
mean    5.50000   0.292897
std     3.02765   0.277265
min     1.00000   0.100000
25%     3.25000   0.129464
50%     5.50000   0.183333
75%     7.75000   0.312500
max    10.00000   1.000000
</pre>

<p><div class="rs-tip-major">Poznámka: ještě je nutné provést konverzi hodnot
posledního sloupce &bdquo;type&ldquo;, což je jednoduchá operace, kterou si
popíšeme <a href="#k17">v&nbsp;navazující kapitole</a>.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Převod sekvence bajtů na řetězec</h2>

<p>Demonstrační příklad <a href="#k16">z&nbsp;předchozí kapitoly</a> ve
skutečnosti nevytvořil sloupec &bdquo;type&ldquo; obsahující řetězce, protože
se jednalo o sekvenci bajtů, která se v&nbsp;Pythonu liší od skutečných
řetězců, v&nbsp;nichž se mohou vyskytovat všechny znaky Unicode. Pro převod
sekvence bajtů na řetězec pochopitelně musíme znát způsob kódování. Můžeme
předpokládat například dnes pravděpodobně nejpoužívanější kódování UTF-8. Potom
bude konverze obsahu sloupce &bdquo;type&ldquo; vypadat následovně:</p>

<pre>
df["type"] = df["type"].str.decode("utf-8")
</pre>

<p><div class="rs-tip-major">Poznámka: může být ale použito i jiné kódování
v&nbsp;závislosti na tom, jak binární soubor vznikl.</div></p>

<p>Předchozí demonstrační příklad můžeme snadno přepsat do podoby, která
vytvoří datový rámec, v&nbsp;jehož sloupci &bdquo;type&ldquo; již bude uložený
skutečný řetězec:</p>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
dt = np.dtype([
    ("i", "&lt;u4"),
    ("x", "&lt;f4"),
    ("type", "S4"),
    ])
&nbsp;
np_data = np.fromfile("binary_df_2.bin", dtype=dt)
print(np_data)
print(np_data.ndim)
print(np_data.dtype)
&nbsp;
df = pd.DataFrame(np_data)
<strong>df["type"] = df["type"].str.decode("utf-8")</strong>
&nbsp;
print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<p>Po spuštění se nejprve vypíše informace o surových načtených datech:</p>

<pre>
[( 1, 1.        , b'even') ( 2, 0.5       , b'odd ')
 ( 3, 0.33333334, b'even') ( 4, 0.25      , b'odd ')
 ( 5, 0.2       , b'even') ( 6, 0.16666667, b'odd ')
 ( 7, 0.14285715, b'even') ( 8, 0.125     , b'odd ')
 ( 9, 0.11111111, b'even') (10, 0.1       , b'odd ')]
&nbsp;
1
&nbsp;
[('i', '&lt;u4'), ('x', '&lt;f4'), ('type', 'S4')]
</pre>

<p>A posléze se vypíše i datový rámec vytvořený konverzí i základní
metainformace a statistické informace o tomto rámci:</p>

<pre>
    i         x  type
0   1  1.000000  even
1   2  0.500000  odd 
2   3  0.333333  even
3   4  0.250000  odd 
4   5  0.200000  even
5   6  0.166667  odd 
6   7  0.142857  even
7   8  0.125000  odd 
8   9  0.111111  even
9  10  0.100000  odd 
&nbsp;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 10 entries, 0 to 9
Data columns (total 3 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   i       10 non-null     uint32 
 1   x       10 non-null     float32
 2   type    10 non-null     object 
dtypes: float32(1), object(1), uint32(1)
memory usage: 288.0+ bytes
None
&nbsp;
              i          x
count  10.00000  10.000000
mean    5.50000   0.292897
std     3.02765   0.277265
min     1.00000   0.100000
25%     3.25000   0.129464
50%     5.50000   0.183333
75%     7.75000   0.312500
max    10.00000   1.000000
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů určených pro
Python 3 a nejnovější stabilní verzi knihoven Numpy a Pandas byly uloženy do
Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následujících
tabulkách.</p>

<p>Příklady určené pouze pro knihovnu Numpy:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>vector_to_file_1.py</td><td>uložení obsahu vektoru do textového souboru se specifikací oddělovače</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_1.py</a></td></tr>
<tr><td> 2</td><td>vector_to_file_2.py</td><td>uložení obsahu vektoru do textového souboru se specifikací oddělovače a formátu jednotlivých prvků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_2.py</a></td></tr>
<tr><td> 3</td><td>vector_to_file_3.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;byte&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_3.py</a></td></tr>
<tr><td> 4</td><td>vector_to_file_4.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;half integer&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_4.py</a></td></tr>
<tr><td> 5</td><td>vector_to_file_5.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;integer&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_5.py</a></td></tr>
<tr><td> 6</td><td>vector_to_file_6.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;long integer&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_6.py</a></td></tr>
<tr><td> 7</td><td>vector_to_file_7.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;single&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_7.py</a></td></tr>
<tr><td> 8</td><td>vector_to_file_8.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;double&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_8.py</a></td></tr>
<tr><td> 9</td><td>vector_to_file_9.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;half&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_9.py</a></td></tr>
<tr><td>10</td><td>vector_from_file_1.py</td><td>načtení obsahu vektoru z textového souboru se specifikací oddělovače</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_1.py</a></td></tr>
<tr><td>11</td><td>vector_from_file_2.py</td><td>načtení obsahu vektoru z textového souboru se specifikací oddělovače a s konverzí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_2.py</a></td></tr>
<tr><td>12</td><td>vector_from_file_3.py</td><td>načtení obsahu vektoru z binárního souboru (nekorektní použití)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_3.py</a></td></tr>
<tr><td>13</td><td>vector_from_file_4.py</td><td>načtení obsahu vektoru z binárního souboru s konverzí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_4.py</a></td></tr>
<tr><td>14</td><td>vector_save.py</td><td>uložení obsahu vektoru do standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_save.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_save.py</a></td></tr>
<tr><td>15</td><td>vector_load.py</td><td>načtení obsahu vektoru ze standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_load.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_load.py</a></td></tr>
<tr><td>16</td><td>matrix_save_1.py</td><td>uložení matice s&nbsp;prvky typu &bdquo;byte&ldquo; do standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_save_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_save_1.py</a></td></tr>
<tr><td>17</td><td>matrix_save_2.py</td><td>uložení matice s&nbsp;prvky typu &bdquo;float&ldquo; do standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_save_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_save_2.py</a></td></tr>
<tr><td>18</td><td>matrix_load_1.py</td><td>načtení matice s&nbsp;prvky typu &bdquo;byte&ldquo; ze standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_load_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_load_1.py</a></td></tr>
<tr><td>19</td><td>matrix_load_2.py</td><td>načtení matice s&nbsp;prvky typu &bdquo;float&ldquo; ze standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_load_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_load_2.py</a></td></tr>
<tr><td>20</td><td>matrix_to_file_1.py</td><td>export obsahu matice do textového souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_to_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_to_file_1.py</a></td></tr>
<tr><td>21</td><td>matrix_to_file_2.py</td><td>export obsahu matice do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_to_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_to_file_2.py</a></td></tr>
<tr><td>22</td><td>matrix_from_file_1.py</td><td>načtení matice z&nbsp;textového souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_1.py</a></td></tr>
<tr><td>23</td><td>matrix_from_file_2.py</td><td>načtení matice z&nbsp;textového souboru s&nbsp;konverzí na jiný typ</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_2.py</a></td></tr>
<tr><td>24</td><td>matrix_from_file_3.py</td><td>načtení matice z&nbsp;binárního souboru bez specifikace formátu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_3.py</a></td></tr>
<tr><td>25</td><td>matrix_from_file_4.py</td><td>načtení matice z&nbsp;binárního souboru se specifikací formátu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_4.py</a></td></tr>
</table>

<p>Příklady určené pro knihovnu Pandas:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>vector_to_file_4.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;half integer&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/vector_to_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/vector_to_file_4.py</a></td></tr>
<tr><td> 2</td><td>matrix_to_file_2.py</td><td>export obsahu matice do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/matrix_to_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/matrix_to_file_2.py</a></td></tr>
<tr><td> 3</td><td>binary_df_1.c</td><td>vygenerování binárního souboru s&nbsp;prvky různých typů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/binary_df_1.c">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/binary_df_1.c</a></td></tr>
<tr><td> 4</td><td>binary_df_2.c</td><td>vygenerování binárního souboru s&nbsp;prvky různých typů, včetně řetězců</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/binary_df_2.c">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/binary_df_2.c</a></td></tr>
<tr><td> 5</td><td>serie_from_file.py</td><td>načtení obsahu datové řady z&nbsp;binárního souboru s&nbsp;konverzí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/serie_from_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/serie_from_file.py</a></td></tr>
<tr><td> 6</td><td>dataframe_from_file_1.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu společného pro všechny sloupce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_1.py</a></td></tr>
<tr><td> 7</td><td>dataframe_from_file_2.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_2.py</a></td></tr>
<tr><td> 8</td><td>dataframe_from_file_3.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu i endianity</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_3.py</a></td></tr>
<tr><td> 9</td><td>dataframe_from_file_4.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu i endianity, bytové pole</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_4.py</a></td></tr>
<tr><td>10</td><td>dataframe_from_file_5.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu i endianity, řetězce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_5.py</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o knihovně Pandas</h2>

<p>Popisem knihovny Pandas (a do jisté míry i Numpy) jsme se již na stránkách
Roota zabývali. Pod tímto odstavcem naleznete odkazy na jednotlivé články,
které již o knihovně Pandas vyšly:</p>

<ol>

<li>Knihovna Pandas: základy práce s datovými rámci<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-zaklady-prace-s-datovymi-ramci/">https://www.root.cz/clanky/knihovna-pandas-zaklady-prace-s-datovymi-ramci/</a>
</li>

<li>Knihovna Pandas: zobrazení obsahu datových rámců, vykreslení grafů a validace dat<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-zobrazeni-obsahu-datovych-ramcu-vykresleni-grafu-a-validace-dat/">https://www.root.cz/clanky/knihovna-pandas-zobrazeni-obsahu-datovych-ramcu-vykresleni-grafu-a-validace-dat/</a>
</li>

<li>Knihovna Pandas: práce s&nbsp;datovými řadami (series)<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-prace-s-datovymi-radami-series/">https://www.root.cz/clanky/knihovna-pandas-prace-s-datovymi-radami-series/</a>
</li>

<li>Knihovna Pandas: pokročilejší práce s&nbsp;datovými řadami (series)<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-pokrocilejsi-prace-s-datovymi-radami-series/">https://www.root.cz/clanky/knihovna-pandas-pokrocilejsi-prace-s-datovymi-radami-series/</a>
</li>

<li>Knihovna Pandas: spojování datových rámců s&nbsp;využitím append, concat, merge a join<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-spojovani-datovych-ramcu-s-vyuzitim-append-concat-merge-a-join/">https://www.root.cz/clanky/knihovna-pandas-spojovani-datovych-ramcu-s-vyuzitim-append-concat-merge-a-join/</a>
</li>

<li>Knihovna Pandas: použití metody groupby, naformátování a export tabulek pro tisk<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-pouziti-metody-groupby-naformatovani-a-export-tabulek-pro-tisk/">https://www.root.cz/clanky/knihovna-pandas-pouziti-metody-groupby-naformatovani-a-export-tabulek-pro-tisk/</a>
</li>

<li>Knihovna Pandas: práce se seskupenými záznamy, vytvoření multiindexů<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-prace-se-seskupenymi-zaznamy-vytvoreni-multiindexu/">https://www.root.cz/clanky/knihovna-pandas-prace-se-seskupenymi-zaznamy-vytvoreni-multiindexu/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>A Simple File Format for NumPy Arrays<br />
<a href="https://docs.scipy.org/doc/numpy-1.14.2/neps/npy-format.html">https://docs.scipy.org/doc/numpy-1.14.2/neps/npy-format.html</a>
</li>

<li>numpy.lib.format<br />
<a href="https://numpy.org/devdocs/reference/generated/numpy.lib.format.html">https://numpy.org/devdocs/reference/generated/numpy.lib.format.html</a>
</li>

<li>The NumPy array: a structure for efficient numerical computation<br />
<a href="https://arxiv.org/pdf/1102.1523.pdf">https://arxiv.org/pdf/1102.1523.pdf</a>
</li>

<li>numpy.ndarray.tofile<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.tofile.html#numpy.ndarray.tofile">https://numpy.org/doc/stable/reference/generated/numpy.ndarray.tofile.html#numpy.ndarray.tofile</a>
</li>

<li>numpy.fromfile<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html">https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html</a>
</li>

<li>How to read part of binary file with numpy?<br />
<a href="https://stackoverflow.com/questions/14245094/how-to-read-part-of-binary-file-with-numpy">https://stackoverflow.com/questions/14245094/how-to-read-part-of-binary-file-with-numpy</a>
</li>

<li>How to read binary files in Python using NumPy?<br />
<a href="https://stackoverflow.com/questions/39762019/how-to-read-binary-files-in-python-using-numpy">https://stackoverflow.com/questions/39762019/how-to-read-binary-files-in-python-using-numpy</a>
</li>

<li>numpy.save<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.save.html#numpy.save">https://numpy.org/doc/stable/reference/generated/numpy.save.html#numpy.save</a>
</li>

<li>numpy.load<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.load.html#numpy.load">https://numpy.org/doc/stable/reference/generated/numpy.load.html#numpy.load</a>
</li>

<li>Loading binary data to NumPy/Pandas<br />
<a href="https://towardsdatascience.com/loading-binary-data-to-numpy-pandas-9caa03eb0672">https://towardsdatascience.com/loading-binary-data-to-numpy-pandas-9caa03eb0672</a>
</li>

<li>Combining Data in Pandas With merge(), .join(), and concat()<br />
<a href="https://realpython.com/pandas-merge-join-and-concat/">https://realpython.com/pandas-merge-join-and-concat/</a>
</li>

<li>Repositář python-tabulate na GitHubu<br />
<a href="https://github.com/astanin/python-tabulate">https://github.com/astanin/python-tabulate</a>
</li>

<li>python-tabulate na PyPi<br />
<a href="https://pypi.org/project/tabulate/">https://pypi.org/project/tabulate/</a>
</li>

<li>Understanding Pandas groupby() function<br />
<a href="https://www.askpython.com/python-modules/pandas/pandas-groupby-function">https://www.askpython.com/python-modules/pandas/pandas-groupby-function</a>
</li>

<li>Python Pandas - GroupBy<br />
<a href="https://www.tutorialspoint.com/python_pandas/python_pandas_groupby.htm">https://www.tutorialspoint.com/python_pandas/python_pandas_groupby.htm</a>
</li>

<li>Pandas GroupBy: Group Data in Python<br />
<a href="https://pythonspot.com/pandas-groupby/">https://pythonspot.com/pandas-groupby/</a>
</li>

<li>JOIN<br />
<a href="https://cs.wikipedia.org/wiki/JOIN">https://cs.wikipedia.org/wiki/JOIN</a>
</li>

<li>Plotting with matplotlib<br />
<a href="https://pandas.pydata.org/pandas-docs/version/0.13/visualization.html">https://pandas.pydata.org/pandas-docs/version/0.13/visualization.html</a>
</li>

<li>Plot With Pandas: Python Data Visualization for Beginners<br />
<a href="https://realpython.com/pandas-plot-python/">https://realpython.com/pandas-plot-python/</a>
</li>

<li>Pandas Dataframe: Plot Examples with Matplotlib and Pyplot<br />
<a href="https://queirozf.com/entries/pandas-dataframe-plot-examples-with-matplotlib-pyplot">https://queirozf.com/entries/pandas-dataframe-plot-examples-with-matplotlib-pyplot</a>
</li>

<li>Opulent-Pandas na PyPi<br />
<a href="https://pypi.org/project/opulent-pandas/">https://pypi.org/project/opulent-pandas/</a>
</li>

<li>pandas_validator na PyPi<br />
<a href="https://pypi.org/project/pandas_validator/">https://pypi.org/project/pandas_validator/</a>
</li>

<li>pandas-validator (dokumentace)<br />
<a href="https://pandas-validator.readthedocs.io/en/latest/">https://pandas-validator.readthedocs.io/en/latest/</a>
</li>

<li>7 Best Python Libraries for Validating Data<br />
<a href="https://www.yeahhub.com/7-best-python-libraries-validating-data/">https://www.yeahhub.com/7-best-python-libraries-validating-data/</a>
</li>

<li>Universally unique identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">https://en.wikipedia.org/wiki/Universally_unique_identifier</a>
</li>

<li>Nullable integer data type<br />
<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html</a>
</li>

<li>pandas.read_csv<br />
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html</a>
</li>

<li>How to define format when using pandas to_datetime?<br />
<a href="https://stackoverflow.com/questions/36848514/how-to-define-format-when-using-pandas-to-datetime">https://stackoverflow.com/questions/36848514/how-to-define-format-when-using-pandas-to-datetime</a>
</li>

<li>Pandas : skip rows while reading csv file to a Dataframe using read_csv() in Python<br />
<a href="https://thispointer.com/pandas-skip-rows-while-reading-csv-file-to-a-dataframe-using-read_csv-in-python/">https://thispointer.com/pandas-skip-rows-while-reading-csv-file-to-a-dataframe-using-read_csv-in-python/</a>
</li>

<li>Skip rows during csv import pandas<br />
<a href="https://stackoverflow.com/questions/20637439/skip-rows-during-csv-import-pandas">https://stackoverflow.com/questions/20637439/skip-rows-during-csv-import-pandas</a>
</li>

<li>Denni kurz<br />
<a href="https://www.cnb.cz/cs/financni_trhy/devizovy_trh/kurzy_devizoveho_trhu/denni_kurz.txt">https://www.cnb.cz/cs/financni_trhy/devizovy_trh/kurzy_devizoveho_trhu/denni_kurz.txt</a>
</li>

<li>UUID objects according to RFC 4122 (knihovna pro Python)<br />
<a href="https://docs.python.org/3.5/library/uuid.html#uuid.uuid4">https://docs.python.org/3.5/library/uuid.html#uuid.uuid4</a>
</li>

<li>Object identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Object_identifier">https://en.wikipedia.org/wiki/Object_identifier</a>
</li>

<li>Digital object identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Digital_object_identifier">https://en.wikipedia.org/wiki/Digital_object_identifier</a>
</li>

<li>voluptuous na (na PyPi)<br />
<a href="https://pypi.python.org/pypi/voluptuous">https://pypi.python.org/pypi/voluptuous</a>
</li>

<li>Repositář knihovny voluptuous na GitHubu<br />
<a href="https://github.com/alecthomas/voluptuous">https://github.com/alecthomas/voluptuous</a>
</li>

<li>pytest-voluptuous 1.0.2 (na PyPi)<br />
<a href="https://pypi.org/project/pytest-voluptuous/">https://pypi.org/project/pytest-voluptuous/</a>
</li>

<li>pytest-voluptuous (na GitHubu)<br />
<a href="https://github.com/F-Secure/pytest-voluptuous">https://github.com/F-Secure/pytest-voluptuous</a>
</li>

<li>schemagic 0.9.1 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schemagic/0.9.1">https://pypi.python.org/pypi/schemagic/0.9.1</a>
</li>

<li>Schemagic / Schemagic.web (na GitHubu)<br />
<a href="https://github.com/Mechrophile/schemagic">https://github.com/Mechrophile/schemagic</a>
</li>

<li>schema 0.6.7 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schema">https://pypi.python.org/pypi/schema</a>
</li>

<li>schema (na GitHubu)<br />
<a href="https://github.com/keleshev/schema">https://github.com/keleshev/schema</a>
</li>

<li>XML Schema validator and data conversion library for Python<br />
<a href="https://github.com/brunato/xmlschema">https://github.com/brunato/xmlschema</a>
</li>

<li>xmlschema 0.9.7<br />
<a href="https://pypi.python.org/pypi/xmlschema/0.9.7">https://pypi.python.org/pypi/xmlschema/0.9.7</a>
</li>

<li>jsonschema 2.6.0<br />
<a href="https://pypi.python.org/pypi/jsonschema">https://pypi.python.org/pypi/jsonschema</a>
</li>

<li>warlock 1.3.0<br />
<a href="https://pypi.python.org/pypi/warlock">https://pypi.python.org/pypi/warlock</a>
</li>

<li>Python Virtual Environments – A Primer<br />
<a href="https://realpython.com/python-virtual-environments-a-primer/">https://realpython.com/python-virtual-environments-a-primer/</a>
</li>

<li>pip 1.1 documentation: Requirements files<br />
<a href="https://pip.readthedocs.io/en/1.1/requirements.html">https://pip.readthedocs.io/en/1.1/requirements.html</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Unit testing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

