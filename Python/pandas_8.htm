<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Operace s daty uloženými v binárních souborech v knihovnách NumPy a Pandas</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Operace s daty uloženými v binárních souborech v knihovnách NumPy a Pandas</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Poměrně často se můžeme setkat s požadavkem analýzy dat uložených v binárních souborech. S těmito soubory dokáže do určité míry pracovat jak knihovna NumPy, tak i knihovna Pandas. Dnes si představíme základní metody ukládání i načítání binárních dat.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Operace s&nbsp;daty uloženými v&nbsp;binárních souborech v&nbsp;knihovnách NumPy a Pandas</a></p>
<p><a href="#k02">2. Uložení obsahu vektoru do textového souboru se specifikací oddělovače</a></p>
<p><a href="#k03">*** 3. Uložení obsahu vektoru do binárního souboru</a></p>
<p><a href="#k04">*** 4. Načtení obsahu vektoru z&nbsp;textového popř.&nbsp;binárního souboru</a></p>
<p><a href="#k05">*** 5. Uložení obsahu matice do textového souboru se specifikací oddělovače i do souboru binárního</a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">12. Vygenerování binárního souboru se dvěma sloupci čísel s&nbsp;různou reprezentací</a></p>
<p><a href="#k13">13. Načtení binárního souboru s&nbsp;různými typy sloupců do datového rámce</a></p>
<p><a href="#k14">14. Specifikace endianity dat</a></p>
<p><a href="#k15">15. Vygenerování binárního souboru se dvěma sloupci čísel s&nbsp;různou reprezentací a se sloupcem s&nbsp;řetězci</a></p>
<p><a href="#k16">16. Načtení obsahu datového rámce z&nbsp;binárního souboru obsahujícího řetězce pevné délky</a></p>
<p><a href="#k17">17. Převod sekvence bajtů na řetězec</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu o knihovně Pandas</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Operace s&nbsp;daty uloženými v&nbsp;binárních souborech v&nbsp;knihovnách NumPy a Pandas</h2>

<p>Poměrně často se můžeme setkat s požadavkem analýzy dat uložených v binárních souborech. S těmito soubory dokáže do určité míry pracovat jak knihovna NumPy, tak i knihovna Pandas. Dnes si představíme základní metody ukládání i načítání binárních dat.</p>

<p>Pro prohlížení obsahu binárních souborů lze použít například nějakou formu
<i>hexadecimálního prohlížeče</i>. Co si však pod pojmenováním
&bdquo;hexadecimální prohlížeč&ldquo; nebo &bdquo;hexadecimální editor&ldquo;
máme představit? Jedná se o aplikace, které vstupní binární soubor
(tj.&nbsp;soubor, který může mít libovolný obsah, jenž není nijak
interpretován) zobrazí typickým způsobem ve formě hexadecimálních hodnot
(tj.&nbsp;číselných hodnot využívajících při zobrazení šestnáctkovou soustavu)
umístěných do sloupců (viz též první obrázek). Ve skutečnosti je však možné
mnoho těchto prohlížečů a editorů nakonfigurovat takovým způsobem, že se
namísto hexadeciálních hodnot používají hodnoty reprezentované v&nbsp;osmičkové
soustavě, v&nbsp;soustavě dvojkové či dokonce v&nbsp;desítkové soustavě (což
ovšem v&nbsp;naprosté většině případů není moc praktické).</p>

<img src="https://i.iinfo.cz/images/166/hexa1-1.png" class="image-311432" alt="&#160;" width="804" height="504" />
<p><i>Obrázek 1: Pohled na typický hexadecimální editor spuštěný na terminálu
s&nbsp;osmdesáti sloupci a dvaceti pěti textovými řádky. Plocha terminálu je
rozdělena do čtyř oblastí &ndash; sloupec adres, sloupec s&nbsp;hexadecimálními
hodnotami, sloupec s&nbsp;textovou reprezentací bajtů a konečně na stavový a
příkazový řádek (v&nbsp;některých případech obsahují hexadecimální editory i
řádek s&nbsp;menu).</i></p>

<p>Hexadecimálních prohlížečů a editorů existuje (pro Linux) relativně velké
množství. První dva nástroje nazvané <strong>od</strong> a
<strong>hexdump</strong> (zkráceně <strong>hd</strong>) pracují jako relativně
jednoduché jednosměrné filtry (navíc bývají nainstalovány společně se základním
sadou nástrojů), ovšem další nástroj pojmenovaný <strong>xxd</strong> již může
být použit pro obousměrný převod (filtraci), tj.&nbsp;jak pro transformaci
původního binárního souboru do čitelného tvaru (většinou s&nbsp;využitím
šestnáctkové soustavy), tak i pro zpětný převod. Díky tomu je možné
<strong>xxd</strong> použít například ve funkci pluginu do běžných textových
editorů. Další nástroj pojmenovaný <strong>hexdiff</strong> dokáže porovnat
obsah dvou binárních souborů a poslední zmíněný nástroj <strong>mcview</strong>
je, na rozdíl od předchozí čtveřice, aplikací s&nbsp;interaktivním ovládáním a
plnohodnotným textovým uživatelským prostředím.</p>

<p><div class="rs-tip-major">Poznámka: dnes si vystačíme s&nbsp;možnostmi
nabízenými nástrojem <strong>od</strong> neboli <i>octal dump</i>. Jméno tohoto
nástroje je ve skutečnosti zavádějící, protože dokáže zobrazit obsah binárního
soubory mnoha různými způsoby. Již fakt, že jméno této utility má pouhá dvě
písmena, napovídá, že se jedná o nástroj pocházející již z&nbsp;prvních verzí
Unixu. Původní varianty utility <strong>od</strong> vypisovaly obsah zvoleného
souboru (alternativně standardního vstupu či zvoleného zařízení)
s&nbsp;využitím osmičkové soustavy, ovšem GNU verze <strong>od</strong> nabízí
uživatelům mnohem víc možností, a to včetně včetně použití hexadecimální
soustavy (ostatně i proto o této utilitě dnes píšeme), zformátování sousedních
čtyř bajtů do čísla typu <i>single/float</i>, dtto pro osm bajtů a čísla typu
<i>double</i> apod.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Uložení obsahu vektoru do textového souboru se specifikací oddělovače</h2>

<p>Začneme tím nejjednodušším možným případem; konkrétně se bude jednat o
uložení obsahu desetiprvkového vektoru do textového souboru, a to navíc se
specifikací oddělovače jednotlivých prvků. Jako oddělovat zvolíme čárku:</p>

<pre>
<i>"""Uložení obsahu vektoru do textového souboru se specifikací oddělovače."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 8bitové hodnoty (byte)</i>
v = np.linspace(1, 10, 10, dtype="b")
print(v)
&nbsp;
<strong>v.tofile("vector1.txt", sep=",")</strong>
</pre>

<p>Obsah vygenerovaného souboru by měl vypadat následovně &ndash; jedná se o
jediný řádek se všemi hodnotami:</p>

<pre>
1,2,3,4,5,6,7,8,9,10
</pre>

<p>Alternativně je možné si zvolit formát jednotlivých prvků. Ve výchozím
nastavení odpovídá formát &bdquo;nejčitelnější&ldquo; variantě, ovšem snadno
můžeme například zajistit, aby se hodnoty prvků umístily do uvozovek, apostrofů
atd. atd.:</p>

<pre>
<i>"""Uložení obsahu vektoru do textového souboru se specifikací oddělovače a</i>
<i>formátu jednotlivých prvků."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 8bitové hodnoty (byte)</i>
v = np.linspace(1, 10, 10, dtype="b")
print(v)
&nbsp;
<strong>v.tofile("vector2.txt", sep=",", format='"%s"')</strong>
</pre>

<p>Výsledek:</p>

<pre>
"1","2","3","4","5","6","7","8","9","10"
</pre>

<p><div class="rs-tip-major">Poznámka: pokud jako oddělovač zapíšete znak
&bdquo;\n&ldquo;, bude každý prvek vektoru umístěn na samostatné
řádce.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Uložení obsahu vektoru do binárního souboru</h2>

<p>V&nbsp;případě, že se oddělovač neuvede, bude vektor uložen do binárního
souboru. V&nbsp;takovém případě záleží konkrétní způsob uložení na tom, jakého
typu jsou prvky vektoru. Abychom si vše ilustrovali, budeme do binárního
souboru ukládat vektory s&nbsp;prvky různých typů a následně se podíváme na
délku i obsah výsledného souboru.</p>

<p><div class="rs-tip-major">Poznámka: důležité upozornění &ndash; pro všechny
typy větší než bajt se mohou výsledné soubory lišit podle architektury
procesoru, konkrétně podle jeho <i>endianity</i>, tedy podle toho, jak jsou
bajty ve vícebajtovém slově uspořádány (zda od nejvyššího bajtu
k&nbsp;nejnižšímu, naopak, či zda se bude jednat o nějaký mix obou
přístupů).</div></p>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 8bitové hodnoty (byte)</i>
v = np.linspace(1, 10, 10, dtype="b")
print(v)
&nbsp;
v.tofile("vector3.bin")
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 16bitové hodnoty (half integer)</i>
v = np.linspace(1, 10, 10, dtype="h")
print(v)
&nbsp;
v.tofile("vector4.bin")
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 32bitové hodnoty (integer)</i>
v = np.linspace(1, 10, 10, dtype="i")
print(v)
&nbsp;
v.tofile("vector5.bin")
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující celočíselné 64bitové hodnoty (long integer)</i>
v = np.linspace(1, 10, 10, dtype="l")
print(v)
&nbsp;
v.tofile("vector6.bin")
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující hodnoty s plovoucí řádovou čárkou</i>
<i># s jednoduchou přesností (float, single)</i>
v = np.linspace(1, 10, 10, dtype="f")
print(v)
&nbsp;
v.tofile("vector7.bin")
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující hodnoty s plovoucí řádovou čárkou</i>
<i># s dvojitou přesností (double)</i>
v = np.linspace(1, 10, 10, dtype="d")
print(v)
&nbsp;
v.tofile("vector8.bin")
</pre>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>
&nbsp;
import numpy as np
&nbsp;
<i># vektor obsahující hodnoty s plovoucí řádovou čárkou</i>
<i># s poloviční přesností (half)</i>
v = np.linspace(1, 10, 10, dtype="e")
print(v)
&nbsp;
v.tofile("vector9.bin")
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Načtení obsahu vektoru z&nbsp;textového popř.&nbsp;binárního souboru</h2>

<pre>
<i>"""Načtení obsahu vektoru z textového souboru se specifikací oddělovače."""</i>

import numpy as np

v = np.fromfile("vector1.txt", sep=",")
print(v)
</pre>

<pre>
<i>"""Načtení obsahu vektoru z textového souboru se specifikací oddělovače a s konverzí."""</i>

import numpy as np

v = np.fromfile("vector1.txt", sep=",").astype("i")
print(v)
</pre>

<pre>
<i>"""Načtení obsahu vektoru z binárního souboru (nekorektní použití)."""</i>

import numpy as np

v = np.fromfile("vector4.bin")
print(v)
</pre>

<pre>
<i>"""Načtení obsahu vektoru z binárního souboru s konverzí."""</i>

import numpy as np

v = np.fromfile("vector4.bin", dtype="h")
print(v)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Uložení obsahu matice do textového souboru se specifikací oddělovače i do souboru binárního</h2>

<pre>
<i>"""Uložení obsahu matice do textového souboru se specifikací oddělovače."""</i>

import numpy as np

# matice obsahující celočíselné 8bitové hodnoty (byte)
m = np.linspace(1, 12, 12, dtype="b").reshape(3, 4)
print(m)

m.tofile("matrix1.txt", sep=",")
</pre>

<pre>
<i>"""Uložení obsahu matice do binárního souboru."""</i>

import numpy as np

# matice obsahující celočíselné 8bitové hodnoty (byte)
m = np.linspace(1, 12, 12, dtype="b").reshape(3, 4)
print(m)

m.tofile("matrix2.bin")
</pre>

<pre>
<i>"""Načtení obsahu matice z textového souboru se specifikací oddělovače."""</i>

import numpy as np

m = np.fromfile("matrix1.txt", sep=",").reshape(3, 4)
print(m)
</pre>

<pre>
<i>"""Načtení obsahu matice z textového souboru se specifikací oddělovače."""</i>

import numpy as np

m = np.fromfile("matrix1.txt", sep=",").reshape(3, 4).astype("b")
print(m)
</pre>

<pre>
<i>"""Načtení obsahu matice z binárního souboru bez specifikace formátu."""</i>

import numpy as np

m = np.fromfile("matrix2.bin").reshape(3, 4)
print(m)
</pre>

<pre>
<i>"""Načtení obsahu matice z binárního souboru se specifikací formátu."""</i>

import numpy as np

m = np.fromfile("matrix2.bin", dtype="b").reshape(3, 4)
print(m)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
<i>"""Uložení obsahu vektoru do standardního binárního souboru."""</i>

import numpy as np

# vektor obsahující hodnoty s plovoucí řádovou čárkou
# s poloviční přesností (half)
v = np.linspace(1, 10, 10, dtype="e")
print(v)

np.save("vector.npy", v, allow_pickle=False)
</pre>

<pre>
<i>"""Přečtení obsahu vektoru ze standardního binárního souboru."""</i>

import numpy as np

v = np.load("vector.npy")
print(v)
print(v.dtype)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
<i>"""Uložení obsahu matice do standardního binárního souboru."""</i>

import numpy as np

# matice obsahující celočíselné 8bitové hodnoty (byte)
m = np.linspace(1, 12, 12, dtype="b").reshape(3, 4)
print(m)

np.save("matrix1.npy", m, allow_pickle=False)
</pre>

<pre>
<i>"""Přečtení obsahu matice ze standardního binárního souboru."""</i>

import numpy as np

m = np.load("matrix1.npy")
print(m)
print(m.dtype)
</pre>

<pre>
<i>"""Uložení obsahu matice do standardního binárního souboru."""</i>

import numpy as np

m = np.linspace(1, 12, 12, dtype="f").reshape(3, 4)
print(m)

np.save("matrix2.npy", m, allow_pickle=False)
</pre>

<pre>
<i>"""Přečtení obsahu matice ze standardního binárního souboru."""</i>

import numpy as np

m = np.load("matrix2.npy")
print(m)
print(m.dtype)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
<i>"""Uložení obsahu vektoru do binárního souboru."""</i>

import numpy as np

# vektor obsahující celočíselné 16bitové hodnoty (half integer)
v = np.linspace(1, 10, 10, dtype="h")
print(v)

v.tofile("vector4.bin")
</pre>

<pre>
<i>"""Načtení obsahu datové řady z binárního souboru s konverzí."""</i>

import numpy as np
import pandas as pd

v = np.fromfile("vector4.bin", dtype="h")
s = pd.Series(v)

print(s)
print()
print(s.describe())
</pre>

<pre>
0     1
1     2
2     3
3     4
4     5
5     6
6     7
7     8
8     9
9    10
dtype: int16

count    10.00000
mean      5.50000
std       3.02765
min       1.00000
25%       3.25000
50%       5.50000
75%       7.75000
max      10.00000
dtype: float64
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
<i>"""Uložení obsahu matice do binárního souboru."""</i>

import numpy as np

# matice obsahující celočíselné 8bitové hodnoty (byte)
m = np.linspace(1, 12, 12, dtype="b").reshape(3, 4)
print(m)

m.tofile("matrix2.bin")
</pre>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>

import numpy as np
import pandas as pd

m = np.fromfile("matrix2.bin", dtype="b").reshape(3, 4)

df = pd.DataFrame(m)

print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<pre>
   0   1   2   3
0  1   2   3   4
1  5   6   7   8
2  9  10  11  12

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 3 entries, 0 to 2
Data columns (total 4 columns):
 #   Column  Non-Null Count  Dtype
---  ------  --------------  -----
 0   0       3 non-null      int8 
 1   1       3 non-null      int8 
 2   2       3 non-null      int8 
 3   3       3 non-null      int8 
dtypes: int8(4)
memory usage: 140.0 bytes
None

         0     1     2     3
count  3.0   3.0   3.0   3.0
mean   5.0   6.0   7.0   8.0
std    4.0   4.0   4.0   4.0
min    1.0   2.0   3.0   4.0
25%    3.0   4.0   5.0   6.0
50%    5.0   6.0   7.0   8.0
75%    7.0   8.0   9.0  10.0
max    9.0  10.0  11.0  12.0
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vygenerování binárního souboru se dvěma sloupci čísel s&nbsp;různou reprezentací</h2>

<p>Pro vytvoření binárního souboru, který obsahuje dva sloupce numerických
hodnot (každý ovšem s&nbsp;odlišnou reprezentací) poslouží následující zdrojový
kód napsaný v&nbsp;ANSI C. Každý pomyslný řádek obsahuje celočíselnou hodnotu
typu <strong>int</strong> a taktéž hodnotu reprezentovanou v&nbsp;systému
plovoucí řádové čárky (<strong>float</strong>). Povšimněte si, že tento program
může vygenerovat soubory různé délky (podle šířky typu <strong>int</strong>) a
navíc nikde nespecifikujeme endianitu hodnot. Výsledek tedy nebude přenositelný
na různé architektury:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int <strong>main</strong>(void) {
    FILE *fout;
    int i;
&nbsp;
    fout = fopen("binary_df_1.bin", "w");
    if (!fout) {
        return 1;
    }
    for (i=1; i&lt;11; i++) {
        float x = 1.0/i;
        fwrite(&amp;i, sizeof(int), 1, fout);
        fwrite(&amp;x, sizeof(float), 1, fout);
    }
    fclose(fout);
    return 0;
}
</pre>

<p>Na platformě x86-64 by měl vzniknout soubor o délce přesně osmdesáti bajtů,
protože jak typ <strong>int</strong>, tak i <strong>float</strong> jsou uloženy
ve čtyřech bajtech:</p>

<pre>
$ <strong>od -t x1 binary_df_1.bin</strong>
&nbsp;
0000000 01 00 00 00 00 00 80 3f 02 00 00 00 00 00 00 3f
0000020 03 00 00 00 ab aa aa 3e 04 00 00 00 00 00 80 3e
0000040 05 00 00 00 cd cc 4c 3e 06 00 00 00 ab aa 2a 3e
0000060 07 00 00 00 25 49 12 3e 08 00 00 00 00 00 00 3e
0000100 09 00 00 00 39 8e e3 3d 0a 00 00 00 cd cc cc 3d
0000120
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si endianity, kterou snadno
zjistíme již z&nbsp;první celočíselné hodnoty 1 (neboli 0x00000001):</div></p>

<pre>
01 00 00 00
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Načtení binárního souboru s&nbsp;různými typy sloupců do datového rámce</h2>

<p>Binární soubor vytvořený programem uvedeným <a href="#k12">v&nbsp;předchozí
kapitole</a> lze relativně snadno načíst do datového rámce. Celý postup se
přitom skládá z&nbsp;několika kroků:</p>

<ol>
<li>Specifikace typů dat pro jednotlivé sloupce</li>
<li>Načtení binárního souboru do specifického n-dimenzionálního pole (s&nbsp;n-ticemi)</li>
<li>Konverze tohoto pole na běžný datový rámec</li>
</ol>

<p><div class="rs-tip-major">Poznámka: druhý krok může vypadat zvláštně,
protože v&nbsp;knihovně NumPy jsou všechna pole <i>homogenní</i>,
tj.&nbsp;vlastně nemohou obsahovat sloupce různých typů. To je sice pravda,
ovšem prvkem pole může být například i n-tice nebo objekt &ndash; potom se
stále bude jednat o homogenní pole, ovšem nikoli s&nbsp;prvky primitivních
datových typů. A právě tento trik je použit v&nbsp;dále ukázaném demonstračním
příkladu.</div></p>

<p>Povšimněte si, jakým způsobem jsou definovány typy sloupců &ndash; uvedeme
mapování mezi názvem sloupce a kódem jeho datového typu, kde například
&bdquo;u4&ldquo; znamená celočíselnou hodnotu bez znaménka uloženou ve čtyřech
bajtech, &bdquo;f4&ldquo; hodnotu typu <i>float</i> uloženou ve čtyřech bajtech
atd.:</p>

<pre>
<i># specifikace typů dat jednotlivých sloupců</i>
<strong>dt = np.dtype([</strong>
    <strong>("i", "u4"),</strong>
    <strong>("x", "f4")</strong>
    <strong>])</strong>
</pre>

<p>Úplný skript vypadá následovně:</p>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
<i># specifikace typů dat jednotlivých sloupců</i>
<strong>dt = np.dtype([</strong>
    <strong>("i", "u4"),</strong>
    <strong>("x", "f4")</strong>
    <strong>])</strong>
&nbsp;
<strong>np_data = np.fromfile("binary_df_1.bin", dtype=dt)</strong>
print(np_data)
print(np_data.ndim)
print(np_data.dtype)
&nbsp;
<strong>df = pd.DataFrame(np_data)</strong>
&nbsp;
print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<p>Skript po svém spuštění nejdříve vypíše obsah načteného pole. Z&nbsp;tohoto
výpisu je patrné, že se jedná o n-tice:</p>

<pre>
[( 1, 1.        ) ( 2, 0.5       ) ( 3, 0.33333334) ( 4, 0.25      )
 ( 5, 0.2       ) ( 6, 0.16666667) ( 7, 0.14285715) ( 8, 0.125     )
 ( 9, 0.11111111) (10, 0.1       )]
</pre>

<p>Dále se vypíše počet dimenzí tohoto pole (což je v&nbsp;tomto případě
konkrétně jednodimenzionální vektor) a datový typ prvků:</p>

<pre>
1
[('i', '&lt;u4'), ('x', '&lt;f4')]
</pre>

<p>A nakonec se vypíše vytvořený datový rámec a další informace o tomto
rámci:</p>

<pre>
    i         x
0   1  1.000000
1   2  0.500000
2   3  0.333333
3   4  0.250000
4   5  0.200000
5   6  0.166667
6   7  0.142857
7   8  0.125000
8   9  0.111111
9  10  0.100000
&nbsp;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 10 entries, 0 to 9
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   i       10 non-null     uint32 
 1   x       10 non-null     float32
dtypes: float32(1), uint32(1)
memory usage: 208.0 bytes
None
&nbsp;
              i          x
count  10.00000  10.000000
mean    5.50000   0.292897
std     3.02765   0.277265
min     1.00000   0.100000
25%     3.25000   0.129464
50%     5.50000   0.183333
75%     7.75000   0.312500
max    10.00000   1.000000
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Specifikace endianity dat</h2>

<p>Při specifikaci typů prvků uložených v&nbsp;jednotlivých sloupcích lze
specifikovat i jejich endianitu. Provádí se to pomocí znaků &lt; a &gt;.
Například na architektuře x86-64 se očekává little endian a tedy:</p>

<pre>
dt = np.dtype([
    ("i", "&lt;u4"),
    ("x", "&lt;f4")
    ])
</pre>

<p>Schválně se ale podívejme na to, co se stane, pokud při načítání binárního
souboru s&nbsp;little endian budeme u celočíselných prvků definovat opačnou
endianitu, tedy big endian (viz zvýrazněný programový řádek):</p>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
dt = np.dtype([
    <strong>("i", "&gt;u4")</strong>,
    ("x", "&lt;f4")
    ])
&nbsp;
np_data = np.fromfile("binary_df_1.bin", dtype=dt)
print(np_data)
print(np_data.ndim)
print(np_data.dtype)
&nbsp;
df = pd.DataFrame(np_data)
&nbsp;
print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<p>Z&nbsp;vypsaných výsledků je patrné, že se data sice načetla, ale například
místo hodnoty 1 dostaneme hodnotu 16777216 atd. Je tak tomu z&nbsp;toho důvodu,
že jedničku lze reprezentovat jako sekvenci bajtů 00 00 00 01, ovšem my jsme
namísto toho načetli 01 00 00 00, což se na celé číslo převede formou
1&times;2<sup>24</sup>:</p>

<pre>
[( 16777216, 1.        ) ( 33554432, 0.5       ) ( 50331648, 0.33333334)
 ( 67108864, 0.25      ) ( 83886080, 0.2       ) (100663296, 0.16666667)
 (117440512, 0.14285715) (134217728, 0.125     ) (150994944, 0.11111111)
 (167772160, 0.1       )]
&nbsp;
1
&nbsp;
[('i', '&gt;u4'), ('x', '&lt;f4')]
&nbsp;
           i         x
0   16777216  1.000000
1   33554432  0.500000
2   50331648  0.333333
3   67108864  0.250000
4   83886080  0.200000
5  100663296  0.166667
6  117440512  0.142857
7  134217728  0.125000
8  150994944  0.111111
9  167772160  0.100000
&nbsp;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 10 entries, 0 to 9
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   i       10 non-null     &gt;u4    
 1   x       10 non-null     float32
dtypes: float32(1), uint32(1)
memory usage: 208.0 bytes
None
&nbsp;
                  i          x
count  1.000000e+01  10.000000
mean   9.227469e+07   0.292897
std    5.079554e+07   0.277265
min    1.677722e+07   0.100000
25%    5.452595e+07   0.129464
50%    9.227469e+07   0.183333
75%    1.300234e+08   0.312500
max    1.677722e+08   1.000000
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vygenerování binárního souboru se dvěma sloupci čísel s&nbsp;různou reprezentací a se sloupcem s&nbsp;řetězci</h2>

<p><a href="#k12">Ve dvanácté kapitole</a> jsme si ukázali program napsaný
v&nbsp;ANSI C, který po svém spuštění vytvořil binární soubor obsahující dva
sloupce číselných hodnot. Tento program nyní nepatrně upravíme takovým
způsobem, aby se ukládal ještě jeden sloupec hodnot &ndash; tentokrát ovšem
řetězců. Pro jednoduchost prozatím budeme generovat řetězce pevné délky (a
dokonce se ani nebude jednat o klasické céčkovské řetězce, protože nebude
ukládána koncová nula). Ostatně s&nbsp;řetězci pevné délky se v&nbsp;binárních
souborech můžeme setkat relativně často:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
char* names[] = {
    "odd ",
    "even"
};
&nbsp;
int <strong>main</strong>(void) {
    FILE *fout;
    int i;
&nbsp;
    fout = fopen("binary_df_2.bin", "w");
    if (!fout) {
        return 1;
    }
    for (i=1; i&lt;11; i++) {
        float x = 1.0/i;
        fwrite(&amp;i, sizeof(int), 1, fout);
        fwrite(&amp;x, sizeof(float), 1, fout);
        fwrite(names[i%2], 4, 1, fout);
    }
    fclose(fout);
    return 0;
}
</pre>

<p>Výsledkem by měl být na platformě x86-64 binární soubor o délce 120 bajtů
&ndash; to konkrétně znamená, že každý řádek obsahuje přesně dvanáct bajtů
(čtyři pro celočíselnou hodnotu, další čtyři pro hodnotu s&nbsp;plovoucí
řádovou čárkou a poslední čtyři bajty pro uložení čtyřech znaků řetězce):</p>

<pre>
$ <strong>od -t x1 binary_df_2.bin</strong>
&nbsp;
0000000 01 00 00 00 00 00 80 3f 65 76 65 6e 02 00 00 00
0000020 00 00 00 3f 6f 64 64 20 03 00 00 00 ab aa aa 3e
0000040 65 76 65 6e 04 00 00 00 00 00 80 3e 6f 64 64 20
0000060 05 00 00 00 cd cc 4c 3e 65 76 65 6e 06 00 00 00
0000100 ab aa 2a 3e 6f 64 64 20 07 00 00 00 25 49 12 3e
0000120 65 76 65 6e 08 00 00 00 00 00 00 3e 6f 64 64 20
0000140 09 00 00 00 39 8e e3 3d 65 76 65 6e 0a 00 00 00
0000160 cd cc cc 3d 6f 64 64 20
0000170
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Načtení obsahu datového rámce z&nbsp;binárního souboru obsahujícího řetězce pevné délky</h2>

<p>Binární soubor vytvořený v&nbsp;rámci <a href="#k15">předchozí kapitoly</a>
je možné načíst do datového rámce knihovny Pandas. Musíme ovšem opět explicitně
specifikovat datové typy jednotlivých sloupců. První dva typy (pro celá čísla i
typ <i>float</i>) již známe, takže nám zbývá určit, že další čtyři bajty
obsahují znaky (tedy dohromady řetězec). Použijeme kód &bdquo;S4&ldquo;:</p>

<pre>
dt = np.dtype([
    ("i", "&lt;u4"),
    ("x", "&lt;f4"),
    ("type", "S4"),
    ])
</pre>

<p>Celý skript, který binární soubor načte a vytvoří z&nbsp;něho datový rámec,
bude vypadat takto:</p>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
dt = np.dtype([
    ("i", "&lt;u4"),
    ("x", "&lt;f4"),
    ("type", "S4"),
    ])
&nbsp;
np_data = np.fromfile("binary_df_2.bin", dtype=dt)
print(np_data)
print(np_data.ndim)
print(np_data.dtype)
&nbsp;
df = pd.DataFrame(np_data)
&nbsp;
print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<p>Po spuštění tohoto skriptu se nejprve vypíše informace o surových načtených
datech:</p>

<pre>
[( 1, 1.        , b'even') ( 2, 0.5       , b'odd ')
 ( 3, 0.33333334, b'even') ( 4, 0.25      , b'odd ')
 ( 5, 0.2       , b'even') ( 6, 0.16666667, b'odd ')
 ( 7, 0.14285715, b'even') ( 8, 0.125     , b'odd ')
 ( 9, 0.11111111, b'even') (10, 0.1       , b'odd ')]
&nbsp;
1
&nbsp;
[('i', '&lt;u4'), ('x', '&lt;f4'), ('type', 'S4')]
</pre>

<p>Dále se již vypíše obsah samotného datového rámce, metainformace o tomto
rámci a statistika:</p>

<pre>
    i         x     type
0   1  1.000000  b'even'
1   2  0.500000  b'odd '
2   3  0.333333  b'even'
3   4  0.250000  b'odd '
4   5  0.200000  b'even'
5   6  0.166667  b'odd '
6   7  0.142857  b'even'
7   8  0.125000  b'odd '
8   9  0.111111  b'even'
9  10  0.100000  b'odd '
&nbsp;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 10 entries, 0 to 9
Data columns (total 3 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   i       10 non-null     uint32 
 1   x       10 non-null     float32
 2   type    10 non-null     object 
dtypes: float32(1), object(1), uint32(1)
memory usage: 288.0+ bytes
None
&nbsp;
              i          x
count  10.00000  10.000000
mean    5.50000   0.292897
std     3.02765   0.277265
min     1.00000   0.100000
25%     3.25000   0.129464
50%     5.50000   0.183333
75%     7.75000   0.312500
max    10.00000   1.000000
</pre>

<p><div class="rs-tip-major">Poznámka: ještě je nutné provést konverzi hodnot
posledního sloupce &bdquo;type&ldquo;, což je jednoduchá operace, kterou si
popíšeme <a href="#k17">v&nbsp;navazující kapitole</a>.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Převod sekvence bajtů na řetězec</h2>

<p>Demonstrační příklad <a href="#k16">z&nbsp;předchozí kapitoly</a> ve
skutečnosti nevytvořil sloupec &bdquo;type&ldquo; obsahující řetězce, protože
se jednalo o sekvenci bajtů, která se v&nbsp;Pythonu liší od skutečných
řetězců, v&nbsp;nichž se mohou vyskytovat všechny znaky Unicode. Pro převod
sekvence bajtů na řetězec pochopitelně musíme znát způsob kódování. Můžeme
předpokládat například dnes pravděpodobně nejpoužívanější kódování UTF-8. Potom
bude konverze obsahu sloupce &bdquo;type&ldquo; vypadat následovně:</p>

<pre>
df["type"] = df["type"].str.decode("utf-8")
</pre>

<p><div class="rs-tip-major">Poznámka: může být ale použito i jiné kódování
v&nbsp;závislosti na tom, jak binární soubor vznikl.</div></p>

<p>Předchozí demonstrační příklad můžeme snadno přepsat do podoby, která
vytvoří datový rámec, v&nbsp;jehož sloupci &bdquo;type&ldquo; již bude uložený
skutečný řetězec:</p>

<pre>
<i>"""Načtení obsahu datového rámce z binárního souboru se specifikací formátu."""</i>
&nbsp;
import numpy as np
import pandas as pd
&nbsp;
dt = np.dtype([
    ("i", "&lt;u4"),
    ("x", "&lt;f4"),
    ("type", "S4"),
    ])
&nbsp;
np_data = np.fromfile("binary_df_2.bin", dtype=dt)
print(np_data)
print(np_data.ndim)
print(np_data.dtype)
&nbsp;
df = pd.DataFrame(np_data)
<strong>df["type"] = df["type"].str.decode("utf-8")</strong>
&nbsp;
print(df)
print()
print(df.info())
print()
print(df.describe())
</pre>

<p>Po spuštění se nejprve vypíše informace o surových načtených datech:</p>

<pre>
[( 1, 1.        , b'even') ( 2, 0.5       , b'odd ')
 ( 3, 0.33333334, b'even') ( 4, 0.25      , b'odd ')
 ( 5, 0.2       , b'even') ( 6, 0.16666667, b'odd ')
 ( 7, 0.14285715, b'even') ( 8, 0.125     , b'odd ')
 ( 9, 0.11111111, b'even') (10, 0.1       , b'odd ')]
&nbsp;
1
&nbsp;
[('i', '&lt;u4'), ('x', '&lt;f4'), ('type', 'S4')]
</pre>

<p>A posléze se vypíše i datový rámec vytvořený konverzí i základní
metainformace a statistické informace o tomto rámci:</p>

<pre>
    i         x  type
0   1  1.000000  even
1   2  0.500000  odd 
2   3  0.333333  even
3   4  0.250000  odd 
4   5  0.200000  even
5   6  0.166667  odd 
6   7  0.142857  even
7   8  0.125000  odd 
8   9  0.111111  even
9  10  0.100000  odd 
&nbsp;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 10 entries, 0 to 9
Data columns (total 3 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   i       10 non-null     uint32 
 1   x       10 non-null     float32
 2   type    10 non-null     object 
dtypes: float32(1), object(1), uint32(1)
memory usage: 288.0+ bytes
None
&nbsp;
              i          x
count  10.00000  10.000000
mean    5.50000   0.292897
std     3.02765   0.277265
min     1.00000   0.100000
25%     3.25000   0.129464
50%     5.50000   0.183333
75%     7.75000   0.312500
max    10.00000   1.000000
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů určených pro
Python 3 a nejnovější stabilní verzi knihoven Numpy a Pandas byly uloženy do
Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následujících
tabulkách.</p>

<p>Příklady určené pouze pro knihovnu Numpy:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>vector_to_file_1.py</td><td>uložení obsahu vektoru do textového souboru se specifikací oddělovače</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_1.py</a></td></tr>
<tr><td> 2</td><td>vector_to_file_2.py</td><td>uložení obsahu vektoru do textového souboru se specifikací oddělovače a formátu jednotlivých prvků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_2.py</a></td></tr>
<tr><td> 3</td><td>vector_to_file_3.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;byte&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_3.py</a></td></tr>
<tr><td> 4</td><td>vector_to_file_4.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;half integer&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_4.py</a></td></tr>
<tr><td> 5</td><td>vector_to_file_5.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;integer&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_5.py</a></td></tr>
<tr><td> 6</td><td>vector_to_file_6.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;long integer&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_6.py</a></td></tr>
<tr><td> 7</td><td>vector_to_file_7.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;single&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_7.py</a></td></tr>
<tr><td> 8</td><td>vector_to_file_8.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;double&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_8.py</a></td></tr>
<tr><td> 9</td><td>vector_to_file_9.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;half&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_to_file_9.py</a></td></tr>
<tr><td>10</td><td>vector_from_file_1.py</td><td>načtení obsahu vektoru z textového souboru se specifikací oddělovače</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_1.py</a></td></tr>
<tr><td>11</td><td>vector_from_file_2.py</td><td>načtení obsahu vektoru z textového souboru se specifikací oddělovače a s konverzí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_2.py</a></td></tr>
<tr><td>12</td><td>vector_from_file_3.py</td><td>načtení obsahu vektoru z binárního souboru (nekorektní použití)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_3.py</a></td></tr>
<tr><td>13</td><td>vector_from_file_4.py</td><td>načtení obsahu vektoru z binárního souboru s konverzí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_from_file_4.py</a></td></tr>
<tr><td>14</td><td>vector_save.py</td><td>uložení obsahu vektoru do standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_save.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_save.py</a></td></tr>
<tr><td>15</td><td>vector_load.py</td><td>načtení obsahu vektoru ze standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_load.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/vector_load.py</a></td></tr>
<tr><td>16</td><td>matrix_save_1.py</td><td>uložení matice s&nbsp;prvky typu &bdquo;byte&ldquo; do standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_save_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_save_1.py</a></td></tr>
<tr><td>17</td><td>matrix_save_2.py</td><td>uložení matice s&nbsp;prvky typu &bdquo;float&ldquo; do standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_save_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_save_2.py</a></td></tr>
<tr><td>18</td><td>matrix_load_1.py</td><td>načtení matice s&nbsp;prvky typu &bdquo;byte&ldquo; ze standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_load_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_load_1.py</a></td></tr>
<tr><td>19</td><td>matrix_load_2.py</td><td>načtení matice s&nbsp;prvky typu &bdquo;float&ldquo; ze standardního binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_load_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_load_2.py</a></td></tr>
<tr><td>20</td><td>matrix_to_file_1.py</td><td>export obsahu matice do textového souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_to_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_to_file_1.py</a></td></tr>
<tr><td>21</td><td>matrix_to_file_2.py</td><td>export obsahu matice do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_to_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_to_file_2.py</a></td></tr>
<tr><td>22</td><td>matrix_from_file_1.py</td><td>načtení matice z&nbsp;textového souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_1.py</a></td></tr>
<tr><td>23</td><td>matrix_from_file_2.py</td><td>načtení matice z&nbsp;textového souboru s&nbsp;konverzí na jiný typ</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_2.py</a></td></tr>
<tr><td>24</td><td>matrix_from_file_3.py</td><td>načtení matice z&nbsp;binárního souboru bez specifikace formátu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_3.py</a></td></tr>
<tr><td>25</td><td>matrix_from_file_4.py</td><td>načtení matice z&nbsp;binárního souboru se specifikací formátu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numpy/matrix_from_file_4.py</a></td></tr>
</table>

<p>Příklady určené pro knihovnu Pandas:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>vector_to_file_4.py</td><td>uložení obsahu vektoru s&nbsp;prvky typu &bdquo;half integer&ldquo; do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/vector_to_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/vector_to_file_4.py</a></td></tr>
<tr><td> 2</td><td>matrix_to_file_2.py</td><td>export obsahu matice do binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/matrix_to_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/matrix_to_file_2.py</a></td></tr>
<tr><td> 3</td><td>binary_df_1.c</td><td>vygenerování binárního souboru s&nbsp;prvky různých typů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/binary_df_1.c">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/binary_df_1.c</a></td></tr>
<tr><td> 4</td><td>binary_df_2.c</td><td>vygenerování binárního souboru s&nbsp;prvky různých typů, včetně řetězců</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/binary_df_2.c">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/binary_df_2.c</a></td></tr>
<tr><td> 5</td><td>serie_from_file.py</td><td>načtení obsahu datové řady z&nbsp;binárního souboru s&nbsp;konverzí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/serie_from_file.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/serie_from_file.py</a></td></tr>
<tr><td> 6</td><td>dataframe_from_file_1.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu společného pro všechny sloupce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_1.py</a></td></tr>
<tr><td> 7</td><td>dataframe_from_file_2.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_2.py</a></td></tr>
<tr><td> 8</td><td>dataframe_from_file_3.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu i endianity</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_3.py</a></td></tr>
<tr><td> 9</td><td>dataframe_from_file_4.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu i endianity, bytové pole</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_4.py</a></td></tr>
<tr><td>10</td><td>dataframe_from_file_5.py</td><td>načtení obsahu datového rámce z binárního souboru se specifikací formátu i endianity, řetězce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pandas/dataframe_from_file_5.py</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o knihovně Pandas</h2>

<p>Popisem knihovny Pandas (a do jisté míry i Numpy) jsme se již na stránkách
Roota zabývali. Pod tímto odstavcem naleznete odkazy na jednotlivé články,
které již o knihovně Pandas vyšly:</p>

<ol>

<li>Knihovna Pandas: základy práce s datovými rámci<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-zaklady-prace-s-datovymi-ramci/">https://www.root.cz/clanky/knihovna-pandas-zaklady-prace-s-datovymi-ramci/</a>
</li>

<li>Knihovna Pandas: zobrazení obsahu datových rámců, vykreslení grafů a validace dat<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-zobrazeni-obsahu-datovych-ramcu-vykresleni-grafu-a-validace-dat/">https://www.root.cz/clanky/knihovna-pandas-zobrazeni-obsahu-datovych-ramcu-vykresleni-grafu-a-validace-dat/</a>
</li>

<li>Knihovna Pandas: práce s&nbsp;datovými řadami (series)<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-prace-s-datovymi-radami-series/">https://www.root.cz/clanky/knihovna-pandas-prace-s-datovymi-radami-series/</a>
</li>

<li>Knihovna Pandas: pokročilejší práce s&nbsp;datovými řadami (series)<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-pokrocilejsi-prace-s-datovymi-radami-series/">https://www.root.cz/clanky/knihovna-pandas-pokrocilejsi-prace-s-datovymi-radami-series/</a>
</li>

<li>Knihovna Pandas: spojování datových rámců s&nbsp;využitím append, concat, merge a join<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-spojovani-datovych-ramcu-s-vyuzitim-append-concat-merge-a-join/">https://www.root.cz/clanky/knihovna-pandas-spojovani-datovych-ramcu-s-vyuzitim-append-concat-merge-a-join/</a>
</li>

<li>Knihovna Pandas: použití metody groupby, naformátování a export tabulek pro tisk<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-pouziti-metody-groupby-naformatovani-a-export-tabulek-pro-tisk/">https://www.root.cz/clanky/knihovna-pandas-pouziti-metody-groupby-naformatovani-a-export-tabulek-pro-tisk/</a>
</li>

<li>Knihovna Pandas: práce se seskupenými záznamy, vytvoření multiindexů<br />
<a href="https://www.root.cz/clanky/knihovna-pandas-prace-se-seskupenymi-zaznamy-vytvoreni-multiindexu/">https://www.root.cz/clanky/knihovna-pandas-prace-se-seskupenymi-zaznamy-vytvoreni-multiindexu/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>A Simple File Format for NumPy Arrays<br />
<a href="https://docs.scipy.org/doc/numpy-1.14.2/neps/npy-format.html">https://docs.scipy.org/doc/numpy-1.14.2/neps/npy-format.html</a>
</li>

<li>numpy.lib.format<br />
<a href="https://numpy.org/devdocs/reference/generated/numpy.lib.format.html">https://numpy.org/devdocs/reference/generated/numpy.lib.format.html</a>
</li>

<li>The NumPy array: a structure for efficient numerical computation<br />
<a href="https://arxiv.org/pdf/1102.1523.pdf">https://arxiv.org/pdf/1102.1523.pdf</a>
</li>

<li>numpy.ndarray.tofile<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.tofile.html#numpy.ndarray.tofile">https://numpy.org/doc/stable/reference/generated/numpy.ndarray.tofile.html#numpy.ndarray.tofile</a>
</li>

<li>numpy.fromfile<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html">https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html</a>
</li>

<li>How to read part of binary file with numpy?<br />
<a href="https://stackoverflow.com/questions/14245094/how-to-read-part-of-binary-file-with-numpy">https://stackoverflow.com/questions/14245094/how-to-read-part-of-binary-file-with-numpy</a>
</li>

<li>How to read binary files in Python using NumPy?<br />
<a href="https://stackoverflow.com/questions/39762019/how-to-read-binary-files-in-python-using-numpy">https://stackoverflow.com/questions/39762019/how-to-read-binary-files-in-python-using-numpy</a>
</li>

<li>numpy.save<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.save.html#numpy.save">https://numpy.org/doc/stable/reference/generated/numpy.save.html#numpy.save</a>
</li>

<li>numpy.load<br />
<a href="https://numpy.org/doc/stable/reference/generated/numpy.load.html#numpy.load">https://numpy.org/doc/stable/reference/generated/numpy.load.html#numpy.load</a>
</li>

<li>Loading binary data to NumPy/Pandas<br />
<a href="https://towardsdatascience.com/loading-binary-data-to-numpy-pandas-9caa03eb0672">https://towardsdatascience.com/loading-binary-data-to-numpy-pandas-9caa03eb0672</a>
</li>

<li>Combining Data in Pandas With merge(), .join(), and concat()<br />
<a href="https://realpython.com/pandas-merge-join-and-concat/">https://realpython.com/pandas-merge-join-and-concat/</a>
</li>

<li>Repositář python-tabulate na GitHubu<br />
<a href="https://github.com/astanin/python-tabulate">https://github.com/astanin/python-tabulate</a>
</li>

<li>python-tabulate na PyPi<br />
<a href="https://pypi.org/project/tabulate/">https://pypi.org/project/tabulate/</a>
</li>

<li>Understanding Pandas groupby() function<br />
<a href="https://www.askpython.com/python-modules/pandas/pandas-groupby-function">https://www.askpython.com/python-modules/pandas/pandas-groupby-function</a>
</li>

<li>Python Pandas - GroupBy<br />
<a href="https://www.tutorialspoint.com/python_pandas/python_pandas_groupby.htm">https://www.tutorialspoint.com/python_pandas/python_pandas_groupby.htm</a>
</li>

<li>Pandas GroupBy: Group Data in Python<br />
<a href="https://pythonspot.com/pandas-groupby/">https://pythonspot.com/pandas-groupby/</a>
</li>

<li>JOIN<br />
<a href="https://cs.wikipedia.org/wiki/JOIN">https://cs.wikipedia.org/wiki/JOIN</a>
</li>

<li>Plotting with matplotlib<br />
<a href="https://pandas.pydata.org/pandas-docs/version/0.13/visualization.html">https://pandas.pydata.org/pandas-docs/version/0.13/visualization.html</a>
</li>

<li>Plot With Pandas: Python Data Visualization for Beginners<br />
<a href="https://realpython.com/pandas-plot-python/">https://realpython.com/pandas-plot-python/</a>
</li>

<li>Pandas Dataframe: Plot Examples with Matplotlib and Pyplot<br />
<a href="https://queirozf.com/entries/pandas-dataframe-plot-examples-with-matplotlib-pyplot">https://queirozf.com/entries/pandas-dataframe-plot-examples-with-matplotlib-pyplot</a>
</li>

<li>Opulent-Pandas na PyPi<br />
<a href="https://pypi.org/project/opulent-pandas/">https://pypi.org/project/opulent-pandas/</a>
</li>

<li>pandas_validator na PyPi<br />
<a href="https://pypi.org/project/pandas_validator/">https://pypi.org/project/pandas_validator/</a>
</li>

<li>pandas-validator (dokumentace)<br />
<a href="https://pandas-validator.readthedocs.io/en/latest/">https://pandas-validator.readthedocs.io/en/latest/</a>
</li>

<li>7 Best Python Libraries for Validating Data<br />
<a href="https://www.yeahhub.com/7-best-python-libraries-validating-data/">https://www.yeahhub.com/7-best-python-libraries-validating-data/</a>
</li>

<li>Universally unique identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">https://en.wikipedia.org/wiki/Universally_unique_identifier</a>
</li>

<li>Nullable integer data type<br />
<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html</a>
</li>

<li>pandas.read_csv<br />
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html</a>
</li>

<li>How to define format when using pandas to_datetime?<br />
<a href="https://stackoverflow.com/questions/36848514/how-to-define-format-when-using-pandas-to-datetime">https://stackoverflow.com/questions/36848514/how-to-define-format-when-using-pandas-to-datetime</a>
</li>

<li>Pandas : skip rows while reading csv file to a Dataframe using read_csv() in Python<br />
<a href="https://thispointer.com/pandas-skip-rows-while-reading-csv-file-to-a-dataframe-using-read_csv-in-python/">https://thispointer.com/pandas-skip-rows-while-reading-csv-file-to-a-dataframe-using-read_csv-in-python/</a>
</li>

<li>Skip rows during csv import pandas<br />
<a href="https://stackoverflow.com/questions/20637439/skip-rows-during-csv-import-pandas">https://stackoverflow.com/questions/20637439/skip-rows-during-csv-import-pandas</a>
</li>

<li>Denni kurz<br />
<a href="https://www.cnb.cz/cs/financni_trhy/devizovy_trh/kurzy_devizoveho_trhu/denni_kurz.txt">https://www.cnb.cz/cs/financni_trhy/devizovy_trh/kurzy_devizoveho_trhu/denni_kurz.txt</a>
</li>

<li>UUID objects according to RFC 4122 (knihovna pro Python)<br />
<a href="https://docs.python.org/3.5/library/uuid.html#uuid.uuid4">https://docs.python.org/3.5/library/uuid.html#uuid.uuid4</a>
</li>

<li>Object identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Object_identifier">https://en.wikipedia.org/wiki/Object_identifier</a>
</li>

<li>Digital object identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Digital_object_identifier">https://en.wikipedia.org/wiki/Digital_object_identifier</a>
</li>

<li>voluptuous na (na PyPi)<br />
<a href="https://pypi.python.org/pypi/voluptuous">https://pypi.python.org/pypi/voluptuous</a>
</li>

<li>Repositář knihovny voluptuous na GitHubu<br />
<a href="https://github.com/alecthomas/voluptuous">https://github.com/alecthomas/voluptuous</a>
</li>

<li>pytest-voluptuous 1.0.2 (na PyPi)<br />
<a href="https://pypi.org/project/pytest-voluptuous/">https://pypi.org/project/pytest-voluptuous/</a>
</li>

<li>pytest-voluptuous (na GitHubu)<br />
<a href="https://github.com/F-Secure/pytest-voluptuous">https://github.com/F-Secure/pytest-voluptuous</a>
</li>

<li>schemagic 0.9.1 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schemagic/0.9.1">https://pypi.python.org/pypi/schemagic/0.9.1</a>
</li>

<li>Schemagic / Schemagic.web (na GitHubu)<br />
<a href="https://github.com/Mechrophile/schemagic">https://github.com/Mechrophile/schemagic</a>
</li>

<li>schema 0.6.7 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schema">https://pypi.python.org/pypi/schema</a>
</li>

<li>schema (na GitHubu)<br />
<a href="https://github.com/keleshev/schema">https://github.com/keleshev/schema</a>
</li>

<li>XML Schema validator and data conversion library for Python<br />
<a href="https://github.com/brunato/xmlschema">https://github.com/brunato/xmlschema</a>
</li>

<li>xmlschema 0.9.7<br />
<a href="https://pypi.python.org/pypi/xmlschema/0.9.7">https://pypi.python.org/pypi/xmlschema/0.9.7</a>
</li>

<li>jsonschema 2.6.0<br />
<a href="https://pypi.python.org/pypi/jsonschema">https://pypi.python.org/pypi/jsonschema</a>
</li>

<li>warlock 1.3.0<br />
<a href="https://pypi.python.org/pypi/warlock">https://pypi.python.org/pypi/warlock</a>
</li>

<li>Python Virtual Environments – A Primer<br />
<a href="https://realpython.com/python-virtual-environments-a-primer/">https://realpython.com/python-virtual-environments-a-primer/</a>
</li>

<li>pip 1.1 documentation: Requirements files<br />
<a href="https://pip.readthedocs.io/en/1.1/requirements.html">https://pip.readthedocs.io/en/1.1/requirements.html</a>
</li>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Unit testing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

