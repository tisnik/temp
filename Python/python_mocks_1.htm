<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Při testování aplikací, zejména při psaní jednotkových testů, se poměrně často dostaneme do situace, kdy potřebujeme nahradit nějakou funkci či metodu používanou v&nbsp;reálné aplikaci za &bdquo;falešnou&ldquo; funkci resp.&nbsp;metodu vytvořenou pouze pro účely testů. V&nbsp;programovacím jazyku Python je možné pro tvorbu a použití takových &bdquo;falešných&ldquo; funkcí použít hned několik různých knihoven, které se od sebe odlišují jak svými možnostmi, tak i způsobem zápisu či deklarace očekávaného chování testované aplikace. Standardem v&nbsp;této oblasti je v&nbsp;současnosti knihovna <i>unittest.mock</i>. Dnes si ukážeme některé základní techniky, které nám tato knihovna poskytuje.</p><!--more-->



<h2>Obsah</h2>

<p><a href="#k01">1. Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování</a></p>
<p><a href="#k02">2. Zdrojový soubor s&nbsp;funkcí, kterou budeme mockovat</a></p>
<p><a href="#k03">3. Test s&nbsp;volanou i mockovanou funkcí</a></p>
<p><a href="#k04">4. Vytvoření handleru, který se zavolá namísto originální funkce</a></p>
<p><a href="#k05">5. Kombinace handleru s&nbsp;předkonfigurovanou návratovou hodnotou?</a></p>
<p><a href="#k06">6. Úplný zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k07">7. Otestování, zda byla mockovaná funkce zavolána</a></p>
<p><a href="#k08">8. Úplný zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k09">9. Problematika mockování funkce, která je volaná nepřímo</a></p>
<p><a href="#k10">10. Mockování funkce volané nepřímo</a></p>
<p><a href="#k11">11. Úplný zdrojový kód čtvrtého demonstračního příkladu</a></p>
<p><a href="#k12">12. Pátý příklad &ndash; změna kódu v&nbsp;případě, že použijeme <strong>import</strong> a nikoli <strong>from X import</strong></a></p>
<p><a href="#k13">13. Mockování metod</a></p>
<p><a href="#k14">14. Testovaná třída</a></p>
<p><a href="#k15">15. Nepřímé volání metody, kterou budeme mockovat</a></p>
<p><a href="#k16">16. Mockování nepřímo volané metody</a></p>
<p><a href="#k17">17. Úplný zdrojový kód šestého demonstračního příkladu</a></p>
<p><a href="#k18">18. Obsah druhé části článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování</h2>

<p>S&nbsp;následující situací se již setkal pravděpodobně každý vývojář &ndash; je nutné otestovat funkcionalitu části aplikace, v&nbsp;této části se však volá nějaká funkce nebo metoda provádějící potenciálně destruktivní činnost (změna filesystému, vzdálené volání procedur, programování zařízení připojeného přes USB atd.). Popř.&nbsp;se volá funkce/metoda, která v&nbsp;závislosti na různých okolnostech vrací (minimálně z&nbsp;pohledu testů) pseudonáhodná data. Takovou funkci/metodu by bylo vhodné pro účely testování nahradit jednodušším kódem, jenž bude provádět předem známou činnost, například bude za každých okolností pouze vracet určitou hodnotu. Taková náhrada skutečných funkcí či metod za funkce/metody &bdquo;falešné&ldquo; se (poněkud nepřesně) nazývá mockování, a příslušný náhradní kód pak <i>test double</i>. V&nbsp;dnešním článku si ukážeme, jakým způsobem se může tato technika použít v&nbsp;Pythonu, konkrétně v&nbsp;Pythonu řady 3.x, který se ve Fedoře stal již před poměrně dlouhou dobou standardem.</p>

<p>V&nbsp;současnosti existuje relativně velké množství různých knihoven, které mockování v&nbsp;Pythonu umožňují. Z&nbsp;nich jmenujme například velmi zajímavý projekt <i>Flexmock</i>, který naleznete na adrese <a href="https://pypi.python.org/pypi/flexmock">https://pypi.python.org/pypi/flexmock</a>. Ovšem v&nbsp;Pythonu 3.x se standardem v&nbsp;této oblasti stala knihovna nazvaná <a href="https://docs.python.org/dev/library/unittest.mock.html">unittest.mock</a>. V&nbsp;případě, že ještě z&nbsp;nějakého důvodu musíte používat Python 2.x, použijte namísto knihovny <i>unittest.mock</i> knihovnu nazvanou jednoduše <a href="https://pypi.python.org/pypi/mock">mock</a>. Tato knihovna nabízí prakticky stejné možnosti jako <i>unittest.mock</i> (je ostatně založena na stejném kódu, který pouze byl pro potřeby Pythonu 2.x upraven), ovšem lze ji použít jak v&nbsp;Pythonu 2.x, tak i v&nbsp;Pythonu 3.x, a to bez toho, abyste museli upravovat zdrojové kódy vašich testů (samozřejmě za předpokladu, že se v&nbsp;nich nevyskytují konstrukce, které nejsou v&nbsp;Pythonu 2.x podporovány).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zdrojový soubor s&nbsp;funkcí, kterou budeme mockovat</h2>

<p>Popis možností knihovny <strong>unittest.mock</strong> začneme na tom nejjednodušším možném příkladu. Bude se jednat o aplikaci (či spíše minimalistickou &bdquo;aplikaci&ldquo;) tvořenou jediným souborem se zdrojovým kódem <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test1/application.py">application.py</a>. Tento soubor obsahuje jedinou funkci nazvanou <strong>function1</strong>, která po svém zavolání nejprve vypíše na standardní výstup text &bdquo;function1 called&ldquo; a následně vrátí do volajícího kódu řetězec s&nbsp;obsahem &bdquo;tested function&ldquo;, jenž může být v&nbsp;případě potřeby dále zpracován. Celý soubor se zdrojovým kódem má pouhé tři řádky:</p>

<pre>
def function1():
    print("function1 called")
    return "tested function"
</pre>

<p>Spuštění je snadné:</p>

<pre>
python3 application.py
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Test s&nbsp;volanou i mockovanou funkcí</h2>

<p>Nyní se podívejme na to, jakým způsobem se může funkce <strong>function1</strong> volat v&nbsp;testech. Pro jednoduchost prozatím nepoužijeme žádný framework určený pro psaní jednotkových testů (to bude téma pro samostatný článek), ale vytvoříme si jednoduchý pomocný soubor nazvaný <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test1/test.py">test.py</a>, v&nbsp;němž se pokusíme zavolat jak původní funkci, tak i její tzv.&nbsp;<i>mock</i> (&bdquo;falešnou&ldquo; variantu původní funkce). Na začátku je nutné provést import modulu <strong>unittest.mock</strong> a samozřejmě taktéž import testovaného modulu <strong>application</strong>:</p>

<pre>
from unittest.mock import *

import application
</pre>

<p>První pseudotest bude jednoduchý &ndash; pouze v&nbsp;něm zavoláme původní funkci a vypíšeme hodnotu, kterou tato funkce vrátí volajícímu kódu (zde se žádné mockování neprování):</p>

<pre>
def test1():
    print(application.function1())
</pre>

<p>Druhý pseudotest je již mnohem zajímavější, protože v&nbsp;něm namísto původní funkce <strong>function1</strong> z&nbsp;modulu <strong>application</strong> použijeme mock. Deklarace testovací funkce je doplněna o anotaci <strong>@patch</strong>, v&nbsp;níž specifikujeme jméno mockované funkce (ve formě řetězce, jehož obsah je kontrolován) a současně i návratovou hodnotu. To je nutné, protože se původní funkce ve skutečnosti vůbec nezavolá, ale návratovou hodnotu použijeme ve funkci <strong>print</strong>:</p>

<pre>
@patch('application.function1', return_value=42)
def test2(mocked_function_object):
    print(application.function1())
</pre>

<p>Povšimněte si, že jméno mockované funkce je zapsáno i s&nbsp;uvedením jmenného prostoru (&bdquo;application.function1&ldquo;), který ovšem musí odpovídat kontextu, v&nbsp;němž se funkce volá! Právě uvedení správného kontextu je pravděpodobně nejdůležitější část, kterou je nutné při mockování pochopit (více viz navazující kapitoly). Navíc stojí za povšimnutí, že se testovací funkci <strong>test2</strong> předává parametr <strong>mocked_function_object</strong>, který představuje objekt udržující informace o mocku. Tento objekt využijeme v&nbsp;dalších demonstračních příkladech, nyní je však nutné si uvědomit, že se tento parametr plní automaticky (při volání <strong>test2</strong> ho explicitně nebudeme uvádět).</p>

<p>Nyní již můžeme skript doplnit o kód, který všechny testy spustí. Povšimněte si, že první test naschvál spouštíme dvakrát (na začátku a na konci), aby bylo patrné, že mockovaná funkce se volá pouze v&nbsp;testu <strong>test2</strong> (mockování je v&nbsp;tomto případě přísně lokální):</p>

<pre>
if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test1()
    print()
</pre>

<p>Výsledek vypsaný po provedení skriptu potvrzuje, že při každém spuštění testu <strong>test1</strong> se zavolá původní funkce, kdežto při spuštění testu <strong>test2</strong> funkce mockovaná:</p>

<pre>
$ <strong>python3 test.py</strong>
&nbsp;
function1 called
tested function
&nbsp;
42
&nbsp;
function1 called
tested function
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření handleru, který se zavolá namísto originální funkce</h2>

<p>Prozatím jsme se dozvěděli, jakým způsobem je možné nahradit volání skutečné funkce vrácením nějaké předem nastavené hodnoty. Tato hodnota sice může být prakticky jakákoli (číslo, pravdivostní hodnota, řetězec, pole, n-tice, slovník, objekt, klidně i <strong>None</strong>), ovšem někdy si s&nbsp;tímto chováním nevystačíme a budeme potřebovat, aby se namísto původní funkce zavolala funkce odlišná; typicky mnohem jednodušší, s&nbsp;předvídatelnějšími výsledky atd. Příkladem může být &bdquo;falešná&ldquo; funkce nahrazující čtení záznamů z&nbsp;databáze za výběr hodnoty z&nbsp;předem známé datové struktury. S&nbsp;využitím knihovny <strong>unittest.mock</strong> je nahrazení původní funkce za její (ne)plnohodnotný mock snadné. Nejprve tuto funkci deklarujeme (měla by akceptovat stejné parametry, jako funkce původní) a následně použijeme v&nbsp;anotaci <strong>@patch</strong> nepovinný parametr <strong>side_effect</strong>, kterému předáme referenci na mock:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print(application.function1())
</pre>

<p>Pokud spustíme třetí test představovaný výše vypsanou funkcí <strong>test3</strong> (a to opět BEZ parametrů):</p>

<pre>
test3()
</pre>

<p>zavolá se z&nbsp;něj ve skutečnosti funkce <strong>side_effect_handler</strong> a nikoli <strong>application.function1</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p>Poznámka: takto vytvořený mock je opět použit jen lokálně v&nbsp;rámci testu představovaného funkcí <strong>test3</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Kombinace handleru s&nbsp;předkonfigurovanou návratovou hodnotou?</h2>

<p>Podívejme se ještě, co se stane ve chvíli, kdy v&nbsp;anotaci <strong>@patch</strong> současně použijeme parametr <strong>return_value</strong> i <strong>side_effect</strong>. Zápis bude vypadat následovně:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1

@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def test4(mocked_function_object):
    print(application.function1())
</pre>

<p>Pokud zavoláme výše vypsanou testovací funkci <strong>test4</strong>, vypíšou se na standardní výstup následující dva řádky, z&nbsp;nichž je patrné, že se hodnota specifikovaná parametrem <strong>return_value</strong> ignorovala a namísto ní se použila návratová hodnota &bdquo;falešné&ldquo; funkce <strong>side_effect_handler</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p>Toto chování se ale změní ve chvíli, kdy mock vrátí speciální hodnotu <strong>unittest.mock.DEFAULT</strong> (přesněji řečeno <strong>sentinel.DEFAULT</strong>). V&nbsp;takovém případě se skutečně využije hodnota zapsaná v&nbsp;parametru <strong>return_value</strong> v&nbsp;anotaci <strong>@patch</strong>, o čemž se lze velmi snadno přesvědčit:</p>

<pre>
def side_effect_handler_2():
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function_object):
    print(application.function1())
</pre>

<p>Výsledek zavolání výše vypsané testovací funkce <strong>test5</strong>:</p>

<pre>
side_effect function called
42
</pre>

<p>Díky tomuto chování je možné použít &bdquo;falešnou&ldquo; funkci ve větším množství testů, což je téma, kterým se budeme podrobněji zabývat příště.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Úplný zdrojový kód druhého demonstračního příkladu</h2>

<p>Pro přehlednost je v&nbsp;této kapitole vypsán úplný zdrojový kód dnešního <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test2/">druhého demonstračního příkladu</a> rozděleného do dvou modulů.</p>



<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou funkcí</h3>

<pre>
def function1():
    print("function1 called")
    return "tested function"
</pre>



<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
from unittest.mock import *

import application


def test1():
    print(application.function1())


@patch('application.function1', return_value=42)
def test2(mocked_function_object):
    print(application.function1())


def side_effect_handler():
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print(application.function1())


@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def test4(mocked_function_object):
    print(application.function1())


def side_effect_handler_2():
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function_object):
    print(application.function1())


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()

    test5()
    print()
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Otestování, zda byla mockovaná funkce zavolána</h2>

<p>Mnohdy, zejména při testování složitěji strukturovaného programového kódu s&nbsp;mnoha podmínkami, je důležité zjistit, zda se vůbec mockovaná funkce zavolala. A právě v&nbsp;těchto případech nám přijde vhod objekt, který je do testovací funkce automaticky předáván, v&nbsp;našem případě v&nbsp;prvním parametru (jméno tohoto parametru si můžeme vybrat sami, důležité je pouze znát jeho pořadí/index):</p>

<pre>
@patch('application.function1', side_effect=side_effect_handler)
def test3(<strong>mocked_function_object</strong>):
</pre>

<p>Tento objekt obsahuje mj.&nbsp;i vlastnost (<i>property</i>) pojmenovanou jednoduše <strong>called</strong>. Ve výchozím stavu je tato vlastnost nastavena na hodnotu <strong>False</strong>, ale po prvním zavolání mockované funkce se vlastnost nastaví na hodnotu <strong>True</strong>. Ostatně se o tomto chování můžeme přesvědčit, a to velmi snadno &ndash; vypíšeme hodnotu vlastnosti <strong>called</strong> před vlastním voláním mockované funkce a taktéž ihned po tomto volání. Upravený test bude vypadat následovně:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print(application.function1())
    print("mocked function called: {c}".format(c=mocked_function_object.called))
</pre>

<p>Po zavolání testovací funkce <strong>test3</strong> by se na standardní výstup měla vypsat následující sekvence zpráv:</p>

<pre>
mocked function called: <strong>False</strong>
side_effect function called
-1
mocked function called: <strong>True</strong>
</pre>

<p>Podobně tomu bude v&nbsp;případě, že kombinujeme vlastní handler se specifikací návratové hodnoty (handler je tedy zavolán, jeho volání je korektně zaregistrováno, ovšem nakonec se použije programátorem specifikovaná návratová hodnota):</p>

<pre>
def side_effect_handler_2():
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function):
    print("mocked function called: {c}".format(c=mocked_function.called))
    print(application.function1())
    print("mocked function called: {c}".format(c=mocked_function.called))
</pre>

<p>Výsledky:</p>

<pre>
mocked function called: <strong>False</strong>
side_effect function called
42
mocked function called: <strong>True</strong>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Úplný zdrojový kód třetího demonstračního příkladu</h2>

<p>Pro přehlednost si v&nbsp;této kapitole opět ukážeme úplný zdrojový kód dnešního <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test3/">třetího demonstračního příkladu</a> rozděleného do dvou modulů. Funkce tohoto příkladu byla popsána v&nbsp;předchozí kapitole.</p>



<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou funkcí</h3>

<pre>
def function1():
    print("function1 called")
    return "tested function"
</pre>



<h3>Soubor <strong>test.py</strong></h3>

<pre>
from unittest.mock import *

import application


def test1():
    print(application.function1())


@patch('application.function1', return_value=42)
def test2(mocked_function_object):
    print(application.function1())


def side_effect_handler():
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print(application.function1())
    print("mocked function called: {c}".format(c=mocked_function_object.called))


@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def test4(mocked_function_object):
    print(application.function1())


def side_effect_handler_2():
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print(application.function1())
    print("mocked function called: {c}".format(c=mocked_function_object.called))


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()

    test5()
    print()
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Problematika mockování funkce, která je volaná nepřímo</h2>

<p>Nyní se dostáváme k&nbsp;velmi důležité vlastnosti knihovny <i>unittest.mock</i>, kterou je užitečné správně pochopit (už jen z&nbsp;toho důvodu, že dokumentace tuto vlastnost podle mého názoru nepopisuje do všech podrobností, o čemž svědčí časté dotazy na fórech). Týká se to způsobu určení plného jména funkce, která má být nahrazena svojí &bdquo;falešnou&ldquo; variantou. Nejdříve si naschvál zkomplikujeme kód aplikace, kterou budeme testovat. Nyní budou aplikaci tvořit dvě funkce nazvané <strong>function1</strong> a <strong>function2</strong>, přičemž si povšimněte, že se z&nbsp;funkce <strong>function1</strong> volá funkce <strong>function2</strong> (konkrétně v&nbsp;rámci příkazu <i>return</i>, ale to v&nbsp;tomto případě není tak důležité):</p>

<pre>
def function1():
    print("function1 called")
    return function2()

def function2():
    print("function2 called")
    return "function 2"
</pre>




<p><a name="k10"></a></p>
<h2 id="k10">10. Mockování funkce volané nepřímo</h2>

<p>Komplikace nastanou ve chvíli, kdy budeme potřebovat nahradit funkci <strong>function2</strong> za její falešnou variantu. Tuto funkci totiž nebudeme volat přímo z&nbsp;testu, ale pouze nepřímo &ndash; přes vlastní kód aplikace. A právě v&nbsp;tomto okamžiku se projevuje již zmíněná vlastnost &ndash; do anotace <strong>@patch</strong> je nutné uvést <i>jméno funkce tak, jak ji vidí volající kód</i>. Co to pro nás znamená? Funkce <strong>function2</strong> je volána z&nbsp;funkce pojmenované <strong>function1</strong> a přitom k&nbsp;tomuto volání dochází v&nbsp;modulu <strong>application</strong>. Plné jméno mockované funkce tedy bude znít <strong>application.function2</strong>, což jen náhodou odpovídá stejnému jménu, jakoby se funkce volala přímo z&nbsp;testů. Podívejme se na příklady testů.</p>

<p>Nejprve změníme import testovaného modulu takovým způsobem, aby nebylo nutné při volání funkcí z&nbsp;modulu <strong>application</strong> používat celé jméno tohoto modulu s&nbsp;tečkou:</p>

<pre>
from unittest.mock import *

from application import *
</pre>

<p>Můžeme si otestovat, že se funkce z&nbsp;modulu <strong>application</strong> mohou volat přímo (jsou totiž naimportovány do aktuálního jmenného prostoru):</p>

<pre>
def test1():
    print("function1 returns: {v}".format(v=function1()))
</pre>

<p>Výsledek:</p>

<pre>
function1 called
function2 called
function1 returns: function 2
</pre>

<p>Správné určení funkce, která se má mockovat, bude vypadat následovně &ndash; funkce je totiž volána nepřímo v&nbsp;modulu <strong>application</strong> a nikoli v&nbsp;modulu <strong>test</strong> (který je aktuálně nastaven):</p>

<pre>
@patch('application.function2', return_value=42)
def test2(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print("function1 returns: {v}".format(v=function1()))
    print("mocked function called: {c}".format(c=mocked_function_object.called))
</pre>

<p>Výsledek:</p>

<pre>
mocked function called: False
function1 called
function1 returns: 42  &lt; zde se volá mock namísto "pravé" funkce function2
mocked function called: True
</pre>

<p>Jakmile známe správné jméno funkce, můžeme samozřejmě použít i její falešnou verzi, například následovně:</p>

<pre>
def side_effect_handler():
    print("side_effect_handler function called")
    return -1


@patch('application.function2', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print(function1())
    print("mocked function called: {c}".format(c=mocked_function_object.called))
</pre>

<p>Výsledek:</p>

<pre>
mocked function called: False
function1 called
side_effect_handler function called
-1
mocked function called: True
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Úplný zdrojový kód čtvrtého demonstračního příkladu</h2>

<p>Podobně, jako tomu bylo v&nbsp;předchozích kapitolách, si uvedeme úplný zdrojový kód dnešního čtvrtého demonstračního příkladu, jenž je opět složen ze dvou souborů &ndash; <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test4/application.py">application.py</a> a <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test4/test.py">test.py</a>.</p>



<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou funkcí</h3>

<pre>
def function1():
    print("function1 called")
    return function2()

def function2():
    print("function2 called")
    return "function 2"
</pre>



<h3>Soubor <strong>test.py</strong></h3>

<pre>
from unittest.mock import *

from application import *


def test1():
    print("function1 returns: {v}".format(v=function1()))


@patch('application.function2', return_value=42)
def test2(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print("function1 returns: {v}".format(v=function1()))
    print("mocked function called: {c}".format(c=mocked_function_object.called))


def side_effect_handler():
    print("side_effect_handler function called")
    return -1


@patch('application.function2', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print(function1())
    print("mocked function called: {c}".format(c=mocked_function_object.called))


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<p><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test5/">Pátý příklad</a> je založen na stejném kódu jako <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test4/">příklad čtvrtý</a>, ovšem s&nbsp;tím podstatným rozdílem, že se modul <strong>application</strong> importuje do testů nikoli příkazem:</p>

<pre>
from application import *
</pre>

<p>ale:</p>

<pre>
import application
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Mockování metod</h2>

<p>Prakticky stejným způsobem, jakým jsme vytvářeli &bdquo;falešné&ldquo; varianty běžných funkcí, je možné nahrazovat metody vybraných tříd. Ostatně v&nbsp;Pythonu není mezi funkcemi a metodami tak velký rozdíl, jako v&nbsp;některých jiných programovacích jazycích, které před programátory skrývají implicitní parametr <strong>self</strong> či <strong>this</strong>. V&nbsp;následujících čtyřech kapitolách si ukážeme vytvoření jednoduchého mocku nepřímo volané (nestatické) metody.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Testovaná třída</h2>

<p>Třída, kterou budeme testovat, je opět velmi jednoduchá. Kromě konstruktoru obsahuje i dvě metody nazvané <strong>method1</strong> a <strong>method2</strong>, přičemž druhá metoda je automaticky volána z&nbsp;metody první (opět v&nbsp;příkazu return, což ovšem není podstatné):</p>

<pre>
class Application:

    def __init__(self):
        pass

    def method1(self):
        print("method1 called")
        return self.method2()

    def method2(self):
        print("method2 called")
        return "method 2"
</pre>

<p>Poznámka: ve skutečnosti obě metody nepřistupují k&nbsp;žádnému atributu objektu, takže by se z&nbsp;nich mohly stát statické metody pomocí anotace <strong>@staticmethod</strong>; alternativně i třídní metody. Nicméně pro jednoduchost zatím uvažujme o nestatických metodách, kterým se při jejich volání předává i parametr <strong>self</strong>.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Nepřímé volání metody, kterou budeme mockovat</h2>

<p>Samotný modul s&nbsp;testem bude začínat přesně tak, jak jsme zvyklí, tj.&nbsp;importem třídy <strong>unittest.mock</strong> i třídy <strong>Application</strong> uložené v&nbsp;modulu <strong>application</strong>:</p>

<pre>
from unittest.mock import *

from application import Application
</pre>

<p>První test prozatím žádnou mockovanou funkci nepoužívá, pouze je v&nbsp;něm ukázán způsob volání metody <strong>method1</strong> společně s&nbsp;výpisem návratové hodnoty této metody:</p>

<pre>
def test1():
    app = Application()
    print("method1 returns: {v}".format(v=app.method1()))
</pre>

<p>Po spuštění tohoto testu by se na standardní výstup měly vypsat následující řádky oznamující, že se z&nbsp;první metody volá metoda druhá:</p>

<pre>
method1 called
method2 called
method1 returns: method 2
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Mockování nepřímo volané metody</h2>

<p>Nyní se již dostáváme k&nbsp;popisu mockování metod. Opět si musíme uvědomit, že je zapotřebí zadat plné jméno metody, a to podle toho, v&nbsp;jakém kontextu bude metoda volána. Vzhledem k&nbsp;tomu, že mockujeme metodu se jménem <strong>Application.method2</strong>, která bude volána nepřímo (nikoli z&nbsp;testu, ale z&nbsp;první metody <strong>method1</strong>), bude plné jméno mockované metody znít &bdquo;application.Application.method2&ldquo;.</p>

<p>Zkusme si tento test napsat:</p>

<pre>
@patch('application.Application.method2', return_value=42)
def test2(mocked_method):
    app = Application()
    print("mocked method called: {c}".format(c=mocked_method.called))
    print("method1 returns: {v}".format(v=app.method1()))
    print("mocked method called: {c}".format(c=mocked_method.called))
</pre>

<p>Výsledek po spuštění testu:</p>

<pre>
mocked method called: False
method1 called
method1 returns: 42
mocked method called: True
</pre>

<p>Vzhledem k&nbsp;tomu, že vlastnosti mockovaných funkcí a metod jsou prakticky stejné, můžeme metodu nahradit jiným handlerem atd. atd.:</p>

<pre>
def side_effect_handler():
    print("side_effect_handler method called")
    return -1


@patch('application.Application.method2', side_effect=side_effect_handler)
def test3(mocked_method):
    app = Application()
    print("mocked method called: {c}".format(c=mocked_method.called))
    print("method1 returns: {v}".format(v=app.method1()))
    print("mocked method called: {c}".format(c=mocked_method.called))
</pre>

<p>Výsledek po spuštění testu:</p>

<pre>
mocked method called: False
method1 called
side_effect_handler method called
method1 returns: -1
mocked method called: True
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úplný zdrojový kód šestého demonstračního příkladu</h2>

<p>Na závěr si ukažme úplný zdrojový kód dnešního <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test6/">šestého demonstračního příkladu</a>.</p>



<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou třídou <strong>Application</strong></h3>

<pre>
class Application:

    def __init__(self):
        pass

    def method1(self):
        print("method1 called")
        return self.method2()

    def method2(self):
        print("method2 called")
        return "method 2"
</pre>



<h3>Soubor <strong>test.py</strong> s&nbsp;testy třídy <strong>Application</strong></h3>

<pre>
from unittest.mock import *

from application import Application


def test1():
    app = Application()
    print("method1 returns: {v}".format(v=app.method1()))


@patch('application.Application.method2', return_value=42)
def test2(mocked_method):
    app = Application()
    print("mocked method called: {c}".format(c=mocked_method.called))
    print("method1 returns: {v}".format(v=app.method1()))
    print("mocked method called: {c}".format(c=mocked_method.called))


def side_effect_handler():
    print("side_effect_handler method called")
    return -1


@patch('application.Application.method2', side_effect=side_effect_handler)
def test3(mocked_method):
    app = Application()
    print("mocked method called: {c}".format(c=mocked_method.called))
    print("method1 returns: {v}".format(v=app.method1()))
    print("mocked method called: {c}".format(c=mocked_method.called))


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah druhé části článku</h2>

<p>Ve druhé části tohoto článku si popíšeme další možnosti nabízené knihovnou <i>unittest.mock</i>. Zejména si ukážeme použití tříd nazvaných <strong>Mock</strong> a <strong>MagicMock</strong>, seznámíme se s&nbsp;možnostmi zjištění, zda jsou mockované funkce volány s&nbsp;očekávanými parametry a samozřejmě nezapomeneme ani na velmi důležitou &bdquo;maličkost&ldquo; &ndash; jakým způsobem se mockování použije společně s&nbsp;frameworkem <a href="https://docs.pytest.org/en/latest/">pytest</a> (protože právě při skutečném testování se mockování funkcí a metod provádí nejčastěji).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech šesti dnes popsaných demonstračních příkladů (každý společně s&nbsp;pomocným skriptem určeným pro spuštění testů) byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/mocking-in-python">https://github.com/tisnik/mocking-in-python</a>. V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem prozatím velmi malý, doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>Projekt</th><th>Cesta</th></tr>
<tr><td>mock-test1</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test1/">https://github.com/tisnik/mocking-in-python/blob/master/mock-test1/</a></td></tr>
<tr><td>mock-test2</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test2/">https://github.com/tisnik/mocking-in-python/blob/master/mock-test2/</a></td></tr>
<tr><td>mock-test3</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test3/">https://github.com/tisnik/mocking-in-python/blob/master/mock-test3/</a></td></tr>
<tr><td>mock-test4</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test4/">https://github.com/tisnik/mocking-in-python/blob/master/mock-test4/</a></td></tr>
<tr><td>mock-test5</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test5/">https://github.com/tisnik/mocking-in-python/blob/master/mock-test5/</a></td></tr>
<tr><td>mock-test6</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test6/">https://github.com/tisnik/mocking-in-python/blob/master/mock-test6/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Unit testing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>IPython Qt Console aneb vylepšený pseudoterminál<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-ipython-a-ipython-notebook/#k06">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-ipython-a-ipython-notebook/#k06</a>
</li>

<li>Vývojová prostředí ve Fedoře (4. díl)<br />
<a href="https://mojefedora.cz/vyvojova-prostredi-ve-fedore-4-dil/">https://mojefedora.cz/vyvojova-prostredi-ve-fedore-4-dil/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

