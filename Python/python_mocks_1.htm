<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Při testování aplikací, zejména při psaní jednotkových testů, se poměrně často dostaneme do situace, kdy potřebujeme nahradit nějakou funkci či metodu používanou v&nbsp;reálné aplikaci za &bdquo;falešnou&ldquo; funkci resp.&nbsp;metodu vytvořenou pouze pro účely testů. V&nbsp;programovacím jazyku Python je možné pro tvorbu a použití takových &bdquo;falešných&ldquo; funkcí použít hned několik různých knihoven, které se od sebe odlišují jak svými možnostmi, tak i způsobem zápisu či deklarace očekávaného chování testované aplikace. Standardem v&nbsp;této oblasti je v&nbsp;současnosti knihovna <i>unittest.mock</i>. Dnes si ukážeme některé základní techniky, které nám tato knihovna poskytuje.</p><!--more-->



<h2>Obsah</h2>

<p><a href="#k01">1. Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování</a></p>
<p><a href="#k02">2. Zdrojový soubor s&nbsp;funkcí, kterou budeme mockovat</a></p>
<p><a href="#k03">3. Test s&nbsp;volanou i mockovanou funkcí</a></p>
<p><a href="#k04">4. Vytvoření handleru, který se zavolá namísto originální funkce</a></p>
<p><a href="#k05">5. Kombinace handleru s&nbsp;předkonfigurovanou návratovou hodnotou?</a></p>
<p><a href="#k06">6. Úplný zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k07">7. Otestování, zda byla mockovaná funkce zavolána</a></p>
<p><a href="#k08">8. Úplný zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k09">9. Problematika mockování funkce, která je volaná nepřímo</a></p>
<p><a href="#k10">10. Mockování funkce volané nepřímo</a></p>
<p><a href="#k11">11. Úplný zdrojový kód čtvrtého demonstračního příkladu</a></p>
<p><a href="#k12">12. Pátý příklad &ndash; změna kódu v&nbsp;případě, že použijeme <strong>import</strong> a nikoli <strong>from X import</strong></a></p>
<p><a href="#k13">13. Mockování metod</a></p>
<p><a href="#k14">14. Testovaná třída</a></p>
<p><a href="#k15">15. Nepřímé volání metody, kterou budeme mockovat</a></p>
<p><a href="#k16">16. Mockování nepřímo volané metody</a></p>
<p><a href="#k17">17. Úplný zdrojový kód šestého demonstračního příkladu</a></p>
<p><a href="#k18">18. Obsah druhé části článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování</h2>

<p>S&nbsp;následující situací se již setkal pravděpodobně každý vývojář &ndash; je nutné otestovat funkcionalitu části aplikace, v&nbsp;této části se však volá nějaká funkce nebo metoda provádějící potenciálně destruktivní činnost (změna filesystému, vzdálené volání procedur, programování zařízení připojeného přes USB atd.). Popř.&nbsp;se volá funkce/metoda, která v&nbsp;závislosti na různých okolnostech vrací (minimálně z&nbsp;pohledu testů) pseudonáhodná data. Takovou funkci/metodu by bylo vhodné pro účely testování nahradit jednodušším kódem, jenž bude provádět předem známou činnost, například bude za každých okolností pouze vracet určitou hodnotu. Taková náhrada skutečných funkcí či metod za funkce/metody &bdquo;falešné&ldquo; se (poněkud nepřesně) nazývá mockování, a příslušný náhradní kód pak <i>test double</i>. V&nbsp;dnešním článku si ukážeme, jakým způsobem se může tato technika použít v&nbsp;Pythonu, konkrétně v&nbsp;Pythonu řady 3.x, který se ve Fedoře stal již před poměrně dlouhou dobou standardem.</p>

<p>V&nbsp;současnosti existuje relativně velké množství různých knihoven, které mockování v&nbsp;Pythonu umožňují. Z&nbsp;nich jmenujme například velmi zajímavý projekt <i>Flexmock</i>, který naleznete na adrese <a href="https://pypi.python.org/pypi/flexmock">https://pypi.python.org/pypi/flexmock</a>. Ovšem v&nbsp;Pythonu 3.x se standardem v&nbsp;této oblasti stala knihovna nazvaná <a href="https://docs.python.org/dev/library/unittest.mock.html">unittest.mock</a>. V&nbsp;případě, že ještě z&nbsp;nějakého důvodu musíte používat Python 2.x, použijte namísto knihovny <i>unittest.mock</i> knihovnu nazvanou jednoduše <a href="https://pypi.python.org/pypi/mock">mock</a>. Tato knihovna nabízí prakticky stejné možnosti jako <i>unittest.mock</i> (je ostatně založena na stejném kódu, který pouze byl pro potřeby Pythonu 2.x upraven), ovšem lze ji použít jak v&nbsp;Pythonu 2.x, tak i v&nbsp;Pythonu 3.x, a to bez toho, abyste museli upravovat zdrojové kódy vašich testů (samozřejmě za předpokladu, že se v&nbsp;nich nevyskytují konstrukce, které nejsou v&nbsp;Pythonu 2.x podporovány).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zdrojový soubor s&nbsp;funkcí, kterou budeme mockovat</h2>

<p>Popis možností knihovny <strong>unittest.mock</strong> začneme na tom nejjednodušším možném příkladu. Bude se jednat o aplikaci (či spíše minimalistickou &bdquo;aplikaci&ldquo;) tvořenou jediným souborem se zdrojovým kódem <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test1/application.py">application.py</a>. Tento soubor obsahuje jedinou funkci nazvanou <strong>function1</strong>, která po svém zavolání nejprve vypíše na standardní výstup text &bdquo;function1 called&ldquo; a následně vrátí do volajícího kódu řetězec s&nbsp;obsahem &bdquo;tested function&ldquo;, jenž může být v&nbsp;případě potřeby dále zpracován. Celý soubor se zdrojovým kódem má pouhé tři řádky:</p>

<pre>
def function1():
    print("function1 called")
    return "tested function"
</pre>

<p>Spuštění je snadné:</p>

<pre>
python3 application.py
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Test s&nbsp;volanou i mockovanou funkcí</h2>

<p>Nyní se podívejme na to, jakým způsobem se může funkce <strong>function1</strong> volat v&nbsp;testech. Pro jednoduchost prozatím nepoužijeme žádný framework určený pro psaní jednotkových testů (to bude téma pro samostatný článek), ale vytvoříme si jednoduchý pomocný soubor nazvaný <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test1/test.py">test.py</a>, v&nbsp;němž se pokusíme zavolat jak původní funkci, tak i její tzv.&nbsp;<i>mock</i> (&bdquo;falešnou&ldquo; variantu původní funkce). Na začátku je nutné provést import modulu <strong>unittest.mock</strong> a samozřejmě taktéž import testovaného modulu <strong>application</strong>:</p>

<pre>
from unittest.mock import *

import application
</pre>

<p>První pseudotest bude jednoduchý &ndash; pouze v&nbsp;něm zavoláme původní funkci a vypíšeme hodnotu, kterou tato funkce vrátí volajícímu kódu (zde se žádné mockování neprování):</p>

<pre>
def test1():
    print(application.function1())
</pre>

<p>Druhý pseudotest je již mnohem zajímavější, protože v&nbsp;něm namísto původní funkce <strong>function1</strong> z&nbsp;modulu <strong>application</strong> použijeme mock. Deklarace testovací funkce je doplněna o anotaci <strong>@patch</strong>, v&nbsp;níž specifikujeme jméno mockované funkce (ve formě řetězce, jehož obsah je kontrolován) a současně i návratovou hodnotu. To je nutné, protože se původní funkce ve skutečnosti vůbec nezavolá, ale návratovou hodnotu použijeme ve funkci <strong>print</strong>:</p>

<pre>
@patch('application.function1', return_value=42)
def test2(mocked_function_object):
    print(application.function1())
</pre>

<p>Povšimněte si, že jméno mockované funkce je zapsáno i s&nbsp;uvedením jmenného prostoru (&bdquo;application.function1&ldquo;), který ovšem musí odpovídat kontextu, v&nbsp;němž se funkce volá! Právě uvedení správného kontextu je pravděpodobně nejdůležitější část, kterou je nutné při mockování pochopit (více viz navazující kapitoly). Navíc stojí za povšimnutí, že se testovací funkci <strong>test2</strong> předává parametr <strong>mocked_function_object</strong>, který představuje objekt udržující informace o mocku. Tento objekt využijeme v&nbsp;dalších demonstračních příkladech, nyní je však nutné si uvědomit, že se tento parametr plní automaticky (při volání <strong>test2</strong> ho explicitně nebudeme uvádět).</p>

<p>Nyní již můžeme skript doplnit o kód, který všechny testy spustí. Povšimněte si, že první test naschvál spouštíme dvakrát (na začátku a na konci), aby bylo patrné, že mockovaná funkce se volá pouze v&nbsp;testu <strong>test2</strong> (mockování je v&nbsp;tomto případě přísně lokální):</p>

<pre>
if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test1()
    print()
</pre>

<p>Výsledek vypsaný po provedení skriptu potvrzuje, že při každém spuštění testu <strong>test1</strong> se zavolá původní funkce, kdežto při spuštění testu <strong>test2</strong> funkce mockovaná:</p>

<pre>
$ <strong>python3 test.py</strong>
&nbsp;
function1 called
tested function
&nbsp;
42
&nbsp;
function1 called
tested function
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření handleru, který se zavolá namísto originální funkce</h2>

<p>Prozatím jsme se dozvěděli, jakým způsobem je možné nahradit volání skutečné funkce vrácením nějaké předem nastavené hodnoty. Tato hodnota sice může být prakticky jakákoli (číslo, pravdivostní hodnota, řetězec, pole, n-tice, slovník, objekt, klidně i <strong>None</strong>), ovšem někdy si s&nbsp;tímto chováním nevystačíme a budeme potřebovat, aby se namísto původní funkce zavolala funkce odlišná; typicky mnohem jednodušší, s&nbsp;předvídatelnějšími výsledky atd. Příkladem může být &bdquo;falešná&ldquo; funkce nahrazující čtení záznamů z&nbsp;databáze za výběr hodnoty z&nbsp;předem známé datové struktury. S&nbsp;využitím knihovny <strong>unittest.mock</strong> je nahrazení původní funkce za její (ne)plnohodnotný mock snadné. Nejprve tuto funkci deklarujeme (měla by akceptovat stejné parametry, jako funkce původní) a následně použijeme v&nbsp;anotaci <strong>@patch</strong> nepovinný parametr <strong>side_effect</strong>, kterému předáme referenci na mock:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print(application.function1())
</pre>

<p>Pokud spustíme třetí test představovaný výše vypsanou funkcí <strong>test3</strong> (a to opět BEZ parametrů):</p>

<pre>
test3()
</pre>

<p>zavolá se z&nbsp;něj ve skutečnosti funkce <strong>side_effect_handler</strong> a nikoli <strong>application.function1</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p>Poznámka: takto vytvořený mock je opět použit jen lokálně v&nbsp;rámci testu představovaného funkcí <strong>test3</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Kombinace handleru s&nbsp;předkonfigurovanou návratovou hodnotou?</h2>

<p>Podívejme se ještě, co se stane ve chvíli, kdy v&nbsp;anotaci <strong>@patch</strong> současně použijeme parametr <strong>return_value</strong> i <strong>side_effect</strong>. Zápis bude vypadat následovně:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1

@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def test4(mocked_function_object):
    print(application.function1())
</pre>

<p>Pokud zavoláme výše vypsanou testovací funkci <strong>test4</strong>, vypíšou se na standardní výstup následující dva řádky, z&nbsp;nichž je patrné, že se hodnota specifikovaná parametrem <strong>return_value</strong> ignorovala a namísto ní se použila návratová hodnota &bdquo;falešné&ldquo; funkce <strong>side_effect_handler</strong>:</p>

<pre>
side_effect function called
-1
</pre>

<p>Toto chování se ale změní ve chvíli, kdy mock vrátí speciální hodnotu <strong>unittest.mock.DEFAULT</strong> (přesněji řečeno <strong>sentinel.DEFAULT</strong>). V&nbsp;takovém případě se skutečně využije hodnota zapsaná v&nbsp;parametru <strong>return_value</strong> v&nbsp;anotaci <strong>@patch</strong>, o čemž se lze velmi snadno přesvědčit:</p>

<pre>
def side_effect_handler_2():
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function_object):
    print(application.function1())
</pre>

<p>Výsledek zavolání výše vypsané testovací funkce <strong>test5</strong>:</p>

<pre>
side_effect function called
42
</pre>

<p>Díky tomuto chování je možné použít &bdquo;falešnou&ldquo; funkci ve větším množství testů, což je téma, kterým se budeme podrobněji zabývat příště.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Úplný zdrojový kód druhého demonstračního příkladu</h2>

<p>Pro přehlednost je v&nbsp;této kapitole vypsán úplný zdrojový kód dnešního <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test2/">druhého demonstračního příkladu</a> rozděleného do dvou modulů.</p>



<h3>Soubor <strong>application.py</strong> s&nbsp;testovanou funkcí</h3>

<pre>
def function1():
    print("function1 called")
    return "tested function"
</pre>



<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
from unittest.mock import *

import application


def test1():
    print(application.function1())


@patch('application.function1', return_value=42)
def test2(mocked_function_object):
    print(application.function1())


def side_effect_handler():
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print(application.function1())


@patch('application.function1', return_value=42, side_effect=side_effect_handler)
def test4(mocked_function_object):
    print(application.function1())


def side_effect_handler_2():
    print("side_effect function called")
    return DEFAULT


@patch('application.function1', return_value=42, side_effect=side_effect_handler_2)
def test5(mocked_function_object):
    print(application.function1())


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()

    test5()
    print()
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Otestování, zda byla mockovaná funkce zavolána</h2>

<p>Mnohdy, zejména při testování složitěji strukturovaného programového kódu s&nbsp;mnoha podmínkami, je důležité zjistit, zda se vůbec mockovaná funkce zavolala. A právě v&nbsp;těchto případech nám přijde vhod objekt, který je do testovací funkce automaticky předáván, v&nbsp;našem případě v&nbsp;prvním parametru (jméno tohoto parametru si můžeme vybrat sami, důležité je pouze znát jeho pořadí/index):</p>

<pre>
@patch('application.function1', side_effect=side_effect_handler)
def test3(<strong>mocked_function_object</strong>):
</pre>

<p>Tento objekt obsahuje mj.&nbsp;i vlastnost (<i>property</i>) pojmenovanou jednoduše <strong>called</strong>. Ve výchozím stavu je tato vlastnost nastavena na hodnotu <strong>False</strong>, ale po prvním zavolání mockované funkce se vlastnost nastaví na hodnotu <strong>True</strong>. Ostatně se o tomto chování můžeme přesvědčit, a to velmi snadno &ndash; vypíšeme hodnotu vlastnosti <strong>called</strong> před vlastním voláním mockované funkce a taktéž ihned po tomto volání. Upravený test bude vypadat následovně:</p>

<pre>
def side_effect_handler():
    print("side_effect function called")
    return -1


@patch('application.function1', side_effect=side_effect_handler)
def test3(mocked_function_object):
    print("mocked function called: {c}".format(c=mocked_function_object.called))
    print(application.function1())
    print("mocked function called: {c}".format(c=mocked_function_object.called))
</pre>

<p>Po zavolání testovací funkce <strong>test3</strong> by se na standardní výstup měla vypsat následující sekvence zpráv:</p>

<pre>
mocked function called: <strong>False</strong>
side_effect function called
-1
mocked function called: <strong>True</strong>
</pre>




<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<table>
<tr><th>Projekt</th><th>Cesta</th></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Unit testing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

