<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – závěrečné zhodnocení</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – závěrečné zhodnocení</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V šestém článku o vytváření, spouštění a řízení souběžných popř. paralelně běžících úloh v Pythonu nejdříve dokončíme popis knihovny Trio a posléze provedeme zhodnocení jednotlivých technologií &ndash; jak multiprocesingu a multithreadingu, tak i řešení založeného na korutinách.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Základní řešení problému typu producent-konzument v&nbsp;knihovně Trio</a></p>
<p><a href="#k02">2. Specifikace maximální doby čekání na zprávu popř.&nbsp;pro poslání zprávy do blokovaného kanálu</a></p>
<p><a href="#k03">3. Přeskočení blokující operace namísto vyhození výjimky</a></p>
<p><a href="#k04">4. Explicitní uzavření kanálu v&nbsp;korutině, reakce na uzavření kanálu dalšími korutinami</a></p>
<p><a href="#k05">5. Problematika uzavření kanálu používaného větším množstvím korutin</a></p>
<p><a href="#k06">6. Vyřešení předchozího problému &ndash; &bdquo;naklonování&ldquo; kanálu</a></p>
<p><a href="#k07">7. Využití kontextových informací</a></p>
<p><a href="#k08">8. Zámky</a></p>
<p><a href="#k09">9. Příklad použití zámku</a></p>
<p><a href="#k10">10. Férové získávání zámků</a></p>
<p><a href="#k11">11. Shrnutí &ndash; technologie pro souběžné a paralelní úlohy v&nbsp;Pythonu</a></p>
<p><a href="#k12">12. Tři nejčastěji používané strategie</a></p>
<p><a href="#k13">13. Jaké řešení je tedy nejvhodnější?</a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Předchozí články z&nbsp;miniseriálu o souběžných úlohách v&nbsp;Pythonu</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Základní řešení problému typu producent-konzument v&nbsp;knihovně Trio</h2>

<p>V&nbsp;první polovině dnešního článku dokončíme popis problematiky, které
jsme se věnovali <a
href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/">již
minule</a>. Připomeňme si, že jsme se zabývali způsobem komunikace mezi
korutinami spravovanými knihovnou <i>Trio</i> s&nbsp;využitím jednosměrných
komunikačních kanálů (<i>channel</i>), které mohou být použity buď jako
jednoduché <i>mailboxy</i>, nebo mohou mít přiřazen buffer s&nbsp;určitou
kapacitou (potom se do jisté míry chovají jako fronty &ndash;
<i>queue</i>).</p>

<p>Mnoho reálných úloh je obdobou problematiky producent-konzument, což je
architektura, v&nbsp;níž jsou od sebe odděleny zdroje dat (nebo úloh) a cíle
dat (vykonavatelé úloh). Jak producenti, tak i konzumenti mohou být realizovány
s&nbsp;využitím korutin, což je zvláště užitečné ve chvíli, kdy vykonávají
mnoho I/O operací. V&nbsp;případě použití knihovny Trio může komunikace
probíhat s&nbsp;využitím kanálů resp.&nbsp;v&nbsp;tom nejjednodušším případě
s&nbsp;využitím jediného kanálu:</p>

<pre>
import <strong>trio</strong>
&nbsp;
&nbsp;
num_producers = 5
num_consumers = 20
&nbsp;
&nbsp;
<u>async def</u> <strong>producer</strong>(id, send_channel):
    for i in range(1, 10):
        message = f"message {i}"
        print(f"Producer #{id}: {message}")
        <u>await</u> send_channel.send(message)
&nbsp;
&nbsp;
<u>async def</u> <strong>consumer</strong>(id, receive_channel):
    async for value in receive_channel:
        print(f"Consumer #{id}: received{value!r}")
        <u>await</u> trio.sleep(1)
&nbsp;
&nbsp;
<u>async def</u> <strong>main</strong>():
    async with trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        for id in range(num_producers):
            nursery.start_soon(producer, id, send_channel)
        for id in range(num_consumers):
            nursery.start_soon(consumer, id, receive_channel)
&nbsp;
&nbsp;
trio.run(main)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_25_multiple_prod_cons.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_25_multiple_prod_cons.py</a>.</div></p>

<p>Obecně platí, že se producenti budou o zaslané úlohy dělit:</p>

<pre>
Producer #4: message 1
Producer #3: message 1
Producer #2: message 1
Producer #1: message 1
Producer #0: message 1
Producer #0: message 2
Consumer #15: received'message 1'
Producer #1: message 2
Consumer #16: received'message 1'
Producer #2: message 2
Consumer #17: received'message 1'
Producer #3: message 2
Consumer #18: received'message 1'
Producer #4: message 2
Consumer #19: received'message 1'
...
...
...
Consumer #16: received'message 8'
Producer #2: message 9
Consumer #17: received'message 8'
Producer #3: message 9
Consumer #18: received'message 8'
Producer #4: message 9
Consumer #19: received'message 8'
Consumer #6: received'message 9'
Consumer #5: received'message 9'
Consumer #0: received'message 9'
Consumer #1: received'message 9'
Consumer #2: received'message 9'
</pre>

<p>V&nbsp;dalších kapitolách si popíšeme některé problémy, které mohou nastat i
způsoby jejich řešení.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Specifikace maximální doby čekání na zprávu popř.&nbsp;pro poslání zprávy do blokovaného kanálu</h2>

<p>Poslání zprávy do kanálu či naopak přečtení zprávy z&nbsp;kanálu je obecně
blokující operace, která ve výchozím nastavení bude čekat potenciálně
nekonečnou dobu na to, až bude kanál uvolněn pro poslání zprávy či naopak až se
v&nbsp;něm objeví zpráva, na kterou čeká konzument. Ovšem, jak jsme si již
řekli minule, je možné specifikovat maximální dobu čekání na dokončení nějaké
operace či operací. V&nbsp;našem konkrétním případě to znamená, že se bude
jednat o operaci poslání zprávy:</p>

<pre>
with trio.fail_after(producer_timeout):
    <u>await</u> send_channel.send(message)
</pre>

<p>Nebo naopak o operaci příjmu zprávy:</p>

<pre>
with trio.fail_after(consumer_timeout):
    value = <u>await</u> receive_channel.receive()
    print(f"Consumer #{id}: received{value!r}")
    <u>await</u> trio.sleep(1)
</pre>

<p>V&nbsp;obou uvedených případech platí, že pokud nedojde k&nbsp;dokončení
operace v&nbsp;nastaveném čase je vyhozena výjimka, na kterou lze v&nbsp;dalším
kódu adekvátně reagovat.</p>

<p>Podívejme se nyní na demonstrační příklad, kde je tento koncept použit:</p>

<pre>
import <strong>trio</strong>
&nbsp;
&nbsp;
num_producers = 5
num_consumers = 20
consumer_timeout = 2
producer_timeout = 2
&nbsp;
&nbsp;
<u>async def</u> <strong>producer</strong>(id, send_channel):
    for i in range(1, 10):
        message = f"message {i}"
        print(f"Producer #{id}: {message}")
        with trio.fail_after(producer_timeout):
            <u>await</u> send_channel.send(message)
&nbsp;
&nbsp;
<u>async def</u> <strong>consumer</strong>(id, receive_channel):
    while True:
        with trio.fail_after(consumer_timeout):
            value = <u>await</u> receive_channel.receive()
            print(f"Consumer #{id}: received{value!r}")
            <u>await</u> trio.sleep(1)
&nbsp;
&nbsp;
<u>async def</u> <strong>main</strong>():
    <u>async with</u> trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        for id in range(num_producers):
            nursery.start_soon(producer, id, send_channel)
        for id in range(num_consumers):
            nursery.start_soon(consumer, id, receive_channel)
&nbsp;
&nbsp;
trio.run(main)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_26_timeouts.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_26_timeouts.py</a>.</div></p>

<p>Po spuštění skriptu začnou pracovat jak producenti, tak i konzumenti:</p>

<pre>
Producer #4: message 1
Producer #3: message 1
Producer #2: message 1
Producer #1: message 1
Producer #0: message 1
Consumer #19: received'message 1'
Producer #4: message 2
Consumer #18: received'message 1'
Producer #3: message 2
Consumer #17: received'message 1'
Producer #2: message 2
Consumer #16: received'message 1'

Producer #4: message 1
Producer #3: message 1
Producer #2: message 1
Producer #1: message 1
Producer #0: message 1
Consumer #19: received'message 1'
Producer #4: message 2
Consumer #18: received'message 1'
Producer #3: message 2
Consumer #17: received'message 1'
Producer #2: message 2
Consumer #16: received'message 1'
...
...
...
</pre>

<p>Ovšem každý producent vytvoří pouze určitý počet zpráv a potom je ukončen.
Následně je vyhozena výjimka typu <strong>TooSlowError</strong> následovaná
ukončením všech operací:</p>

<pre>
Producer #3: message 5
Consumer #0: received'message 4'
Producer #4: message 5
Traceback (most recent call last):
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_timeouts.py", line 106, in fail_at
    yield scope
  File "trio_26_timeouts.py", line 23, in consumer
    <u>await</u> trio.sleep(1)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_timeouts.py", line 76, in sleep
    <u>await</u> sleep_until(trio.current_time() + seconds)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_timeouts.py", line 57, in sleep_until
    <u>await</u> sleep_forever()
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_timeouts.py", line 40, in sleep_forever
    <u>await</u> trio.lowlevel.wait_task_rescheduled(lambda _: trio.lowlevel.Abort.SUCCEEDED)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_core/_traps.py", line 166, in wait_task_rescheduled
    return (await _async_yield(WaitTaskRescheduled(abort_func))).unwrap()
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/outcome/_impl.py", line 138, in unwrap
    raise captured_error
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_core/_run.py", line 1173, in raise_cancel
    raise Cancelled._create()
trio.Cancelled: Cancelled
&nbsp;
During handling of the above exception, another exception occurred:
&nbsp;
Traceback (most recent call last):
  File "trio_26_timeouts.py", line 35, in &lt;module&gt;
    trio.run(main)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_core/_run.py", line 1946, in run
    raise runner.main_task_outcome.error
  File "trio_26_timeouts.py", line 32, in main
    nursery.start_soon(consumer, id, receive_channel)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_core/_run.py", line 813, in __aexit__
    raise combined_error_from_nursery
  File "trio_26_timeouts.py", line 23, in consumer
    <u>await</u> trio.sleep(1)
  File "/usr/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_timeouts.py", line 108, in fail_at
    raise TooSlowError
trio.TooSlowError
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Přeskočení blokující operace namísto vyhození výjimky</h2>

<p>V&nbsp;případě <i>timeoutu</i> se obecně očekávají dvě reakce &ndash; buď
dojde k&nbsp;vyhození výjimky, nebo se bude operace posílání/příjmu do kanálu
ignorovat. Prozatím umíme vyhodit výjimku, pokud je kanál blokovaný po delší
dobu, než je doba specifikovaná ve funkci <strong>fail_after</strong>.
Alternativou může být pouhé přeskočení dané operace (tedy &bdquo;pokus se deset
sekund čekat na zprávu a potom pokračuj dále, pokud není zpráva
přijata&ldquo;).  Tento alternativní přístup je možné realizovat
s&nbsp;využitím funkce <strong>move_on_after</strong>. Podívejme se tedy na
způsob úpravy předchozího demonstračního příkladu tak, aby byl použit tento
alternativní přístup:</p>

<pre>
import <strong>trio</strong>
&nbsp;
&nbsp;
num_producers = 5
num_consumers = 20
consumer_timeout = 2
producer_timeout = 2
&nbsp;
&nbsp;
<u>async def</u> <strong>producer</strong>(id, send_channel):
    for i in range(1, 10):
        message = f"message {i}"
        print(f"Producer #{id}: {message}")
        with trio.move_on_after(producer_timeout):
            <u>await</u> send_channel.send(message)
&nbsp;
&nbsp;
<u>async def</u> <strong>consumer</strong>(id, receive_channel):
    while True:
        print(f"Consumer #{id}: trying to receive message")
        with trio.move_on_after(consumer_timeout):
            value = <u>await</u> receive_channel.receive()
            print(f"Consumer #{id}: received{value!r}")
            <u>await</u> trio.sleep(1)
&nbsp;
&nbsp;
<u>async def</u> <strong>main</strong>():
    async with trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        for id in range(num_producers):
            nursery.start_soon(producer, id, send_channel)
        for id in range(num_consumers):
            nursery.start_soon(consumer, id, receive_channel)
&nbsp;
&nbsp;
trio.run(main)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_26B_move_after.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_26B_move_after.py</a>.</div></p>

<p>Chování po spuštění:</p>

<pre>
Consumer #19: trying to receive message
Consumer #18: trying to receive message
Consumer #17: trying to receive message
Consumer #16: trying to receive message
Consumer #15: trying to receive message
...
...
...
</pre>

<p>Začátek práce producentů:</p>

<pre>
...
...
...
Producer #4: message 1
Producer #3: message 1
Producer #2: message 1
Producer #1: message 1
Producer #0: message 1
Consumer #19: received'message 1'
Producer #4: message 2
Consumer #18: received'message 1'
Producer #3: message 2
Consumer #17: received'message 1'
Producer #2: message 2
Consumer #16: received'message 1'
...
...
...
</pre>

<p>Po poslání všech zpráv:</p>

<pre>
...
...
...
Consumer #14: received'message 9'
Consumer #5: received'message 9'
Consumer #6: received'message 9'
Consumer #7: received'message 9'
Consumer #13: trying to receive message
Consumer #14: trying to receive message
Consumer #5: trying to receive message
Consumer #6: trying to receive message
Consumer #7: trying to receive message
Consumer #12: trying to receive message
Consumer #11: trying to receive message
Consumer #10: trying to receive message
Consumer #15: trying to receive message
Consumer #16: trying to receive message
Consumer #17: trying to receive message
Consumer #18: trying to receive message
Consumer #19: trying to receive message
...
...
...
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Explicitní uzavření kanálu v&nbsp;korutině, reakce na uzavření kanálu dalšími korutinami</h2>

<p>Prozatím jsme na straně producenta používali přibližně tento programový kód
(někdy doplněný o řešení timeoutů):</p>

<pre>
<u>async def</u> <strong>producer</strong>(id, send_channel):
    for i in range(1, 10):
        message = f"message {i}"
        print(f"Producer #{id}: {message}")
        <u>await</u> send_channel.send(message)
</pre>

<p>V&nbsp;takových případech producent pouze ukončil posílání zpráv, ovšem
nijak neinformoval další korutiny, že již další zprávy nebude posílat.
Samozřejmě by bylo možné navrhnout si nějaký komunikační protokol, ovšem
existuje i jednodušší řešení &ndash; prostě komunikační kanál uzavřít. Stav
kanálu (uzavřen/otevřen) je další informací, kterou mezi sebou korutiny mohou
komunikovat, protože stav kanálu lze snadno zjistit. Automatické uzavření
kanálu lze realizovat takto:</p>

<pre>
<u>async with</u> send_channel:
    ...
    ...
    ...
<i># po opuštění bloku with je kanál uzavřen</i>
</pre>

<p>Na což může reagovat konzument ukončením smyčky <strong>async
for</strong>:</p>

<pre>
async for value in receive_channel:
    ...
    ...
    ...
<i># pokud se dostaneme sem, byl kanál uzavřen</i>
</pre>

<p>Podívejme se nyní na ucelený demonstrační příklad používající tento
potenciálně velmi užitečný koncept:</p>

<pre>
import <strong>trio</strong>
&nbsp;
&nbsp;
<u>async def</u> <strong>producer</strong>(send_channel):
    <u>async with</u> send_channel:
        for i in range(1, 10):
            message = f"message {i}"
            print(f"Producer: {message}")
            <u>await</u> send_channel.send(message)
&nbsp;
&nbsp;
<u>async def</u> <strong>consumer</strong>(receive_channel):
    async for value in receive_channel:
        print(f"Consumer: received{value!r}")
        <u>await</u> trio.sleep(1)
    print("No more messages can be received!")
&nbsp;
&nbsp;
<u>async def</u> <strong>main</strong>():
    <u>async with</u> trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        nursery.start_soon(producer, send_channel)
        nursery.start_soon(consumer, receive_channel)
&nbsp;
&nbsp;
trio.run(main)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_27_channel_close.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_27_channel_close.py</a>.</div></p>

<p>Nyní se chování příkladu poměrně zásadním způsobem změní, protože konzument
dokáže správně zareagovat na situaci, kdy je kanál uzavřen &ndash; namísto
čekání na další zprávu je přijímací programová smyčka jednoduše a bez dalšího
čekání ukončena:</p>

<pre>
Producer: message 1
Producer: message 2
Consumer: received'message 1'
Consumer: received'message 2'
Producer: message 3
Producer: message 4
Consumer: received'message 3'
Consumer: received'message 4'
Producer: message 5
Consumer: received'message 5'
Producer: message 6
Producer: message 7
Consumer: received'message 6'
Consumer: received'message 7'
Producer: message 8
Producer: message 9
Consumer: received'message 8'
Consumer: received'message 9'
No more messages can be received!
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Problematika uzavření kanálu používaného větším množstvím korutin</h2>

<p>Předchozí příklad sice pracoval zcela korektně, ale bylo tomu pouze
z&nbsp;toho důvodu, že byl použit pouze jediný producent zpráv. To vlastně
znamená, že kanál byl uzavřen pouze jedenkrát. Ovšem ve chvíli, kdy by bylo
použito větší množství producentů sdílejících stejný kanál, povede prakticky
totožný programový kód k&nbsp;tomu, že se jednotliví producenti budou snažit
kanál uzavřít popř.&nbsp;k&nbsp;tomu, že nějaký producent zapíše zprávu do již
uzavřeného kanálu. Ostatně můžeme si to sami otestovat spuštěním následujícího
skriptu:</p>

<pre>
import <strong>trio</strong>
&nbsp;
&nbsp;
num_producers = 5
num_consumers = 20
&nbsp;
&nbsp;
<u>async def</u> <strong>producer</strong>(id, send_channel):
    <u>async with</u> send_channel:
        for i in range(1, 10):
            message = f"message {i}"
            print(f"Producer #{id}: {message}")
            <u>await</u> send_channel.send(message)
&nbsp;
&nbsp;
<u>async def</u> <strong>consumer</strong>(id, receive_channel):
    async for value in receive_channel:
        print(f"Consumer #{id}: received{value!r}")
        <u>await</u> trio.sleep(id)
    print("No more messages can be received!")
&nbsp;
&nbsp;
<u>async def</u> <strong>main</strong>():
    <u>async with</u> trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        for id in range(num_producers):
            nursery.start_soon(producer, id, send_channel)
        for id in range(num_consumers):
            nursery.start_soon(consumer, id, receive_channel)
&nbsp;
&nbsp;
trio.run(main)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_28_multiple_channel_close.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_28_multiple_channel_close.py</a>.</div></p>

<p>Skript (zcela podle očekávání) zpočátku pracuje korektně, ovšem ihned poté,
co první (libovolný) producent kanál uzavře, dojde k&nbsp;vyhození výjimky při
přístupu k&nbsp;již uzavřenému kanálu:</p>

<pre>
Producer #0: message 1
Producer #1: message 1
Producer #2: message 1
Producer #3: message 1
Producer #4: message 1
Consumer #4: received'message 1'
Producer #4: message 2
Consumer #3: received'message 1'
Producer #3: message 2
Consumer #2: received'message 1'
Producer #2: message 2
Consumer #1: received'message 1'
Producer #1: message 2
Consumer #0: received'message 1'
Producer #0: message 2
Consumer #5: received'message 2'
Producer #4: message 3
Consumer #6: received'message 2'
Producer #3: message 3
Consumer #7: received'message 2'
Producer #2: message 3
Consumer #8: received'message 2'
Producer #1: message 3
Consumer #9: received'message 2'
Producer #0: message 3
Consumer #10: received'message 3'
Producer #4: message 4
Consumer #11: received'message 3'
Producer #3: message 4
Consumer #12: received'message 3'
Producer #2: message 4
Consumer #13: received'message 3'
Producer #1: message 4
Consumer #14: received'message 3'
Producer #0: message 4
Consumer #15: received'message 4'
Consumer #0: received'message 8'
Producer #0: message 9
Consumer #0: received'message 9'
&nbsp;
No more messages can be received!
Traceback (most recent call last):
  File "trio_28_multiple_channel_close.py", line 32, in &lt;module&gt;
    trio.run(main)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_core/_run.py", line 1946, in run
    raise runner.main_task_outcome.error
  File "trio_28_multiple_channel_close.py", line 29, in main
    nursery.start_soon(consumer, id, receive_channel)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_core/_run.py", line 813, in __aexit__
    raise combined_error_from_nursery
  File "trio_28_multiple_channel_close.py", line 13, in producer
    <u>await</u> send_channel.send(message)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_channel.py", line 178, in send
    <u>await</u> trio.lowlevel.wait_task_rescheduled(abort_fn)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/trio/_core/_traps.py", line 166, in wait_task_rescheduled
    return (await _async_yield(WaitTaskRescheduled(abort_func))).unwrap()
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/outcome/_impl.py", line 138, in unwrap
    raise captured_error
trio.ClosedResourceError
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vyřešení předchozího problému &ndash; &bdquo;naklonování&ldquo; kanálu</h2>

<p>Uzavírání kanálů producentem či konzumentem, aby se touto operací oznámilo
ostatním komunikujícím stranám, že daná korutina už nebude posílat či přijímat
zprávy, je poměrně elegantní a navíc i idiomatické řešení celého problému.
Ovšem na druhou stranu pracuje korektně jen ve chvíli, kdy kanál uzavírá jediný
producent či konzument, což by mohlo vést ke zbytečné komplikaci kódu (logika
pro určení, kdo může a kdo již ne kanál zavřít). Knihovna Trio však
programátorům nabízí řešení tohoto problému, a to &bdquo;naklonováním&ldquo;
kanálu. Z&nbsp;jednoho kanálu tak lze vytvořit klony, které ovšem sdílí data a
ve chvíli, kdy je uzavřen poslední naklonovaný kanál, se uzavře i skutečný
kanál. Toto řešení tedy přenáší celý problém na stranu Tria a bude vypadat
následovně:</p>

<pre>
<u>async with</u> send_channel, receive_channel:
    for id in range(num_producers):
        nursery.start_soon(producer, id, <strong>send_channel.clone()</strong>)
    for id in range(num_consumers):
        nursery.start_soon(consumer, id, <strong>receive_channel.clone()</strong>)
</pre>

<p>Žádné další úpravy není zapotřebí provádět:</p>

<pre>
import <strong>trio</strong>
&nbsp;
&nbsp;
num_producers = 5
num_consumers = 20
&nbsp;
&nbsp;
<u>async def</u> <strong>producer</strong>(id, send_channel):
    <u>async with</u> send_channel:
        for i in range(1, 10):
            message = f"message {i}"
            print(f"Producer #{id}: {message}")
            <u>await</u> send_channel.send(message)
&nbsp;
&nbsp;
<u>async def</u> <strong>consumer</strong>(id, receive_channel):
    async for value in receive_channel:
        print(f"Consumer #{id}: received{value!r}")
        <u>await</u> trio.sleep(id)
    print("No more messages can be received!")
&nbsp;
&nbsp;
<u>async def</u> <strong>main</strong>():
    <u>async with</u> trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        <u>async with</u> send_channel, receive_channel:
            for id in range(num_producers):
                nursery.start_soon(producer, id, send_channel.clone())
            for id in range(num_consumers):
                nursery.start_soon(consumer, id, receive_channel.clone())
&nbsp;
&nbsp;
trio.run(main)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_29_multiple_channel_close.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_29_multiple_channel_close.py</a>.</div></p>

<p>Podívejme se na chování kódu po jeho spuštění. Začátek práce korutin:</p>

<pre>
Producer #4: message 1
Producer #3: message 1
Producer #2: message 1
Producer #1: message 1
Producer #0: message 1
Consumer #19: received'message 1'
Producer #4: message 2
Consumer #18: received'message 1'
Producer #3: message 2
Consumer #17: received'message 1'
Producer #2: message 2
Consumer #16: received'message 1'
Producer #1: message 2
Consumer #15: received'message 1'
</pre>

<p>Ukončení práce producentů zpráv:</p>

<pre>
Producer #4: message 9
Consumer #0: received'message 8'
Consumer #0: received'message 9'
Consumer #0: received'message 9'
Consumer #0: received'message 9'
Consumer #0: received'message 9'
Consumer #0: received'message 9'
No more messages can be received!
No more messages can be received!
No more messages can be received!
No more messages can be received!
No more messages can be received!
No more messages can be received!
</pre>

<p>Nyní začínají konzumenti hlásit, že nedostanou další data a sami sebe
korektně ukončí:</p>

<pre>
No more messages can be received!
No more messages can be received!
No more messages can be received!
No more messages can be received!
No more messages can be received!
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Využití kontextových informací</h2>

<p>V&nbsp;Pythonu nalezneme knihovnu nazvanou <strong>contextvars</strong>.
Tato knihovna slouží pro vytváření a přístup ke kontextovým proměnným (či
informacím), a to z&nbsp;mnoha míst kódu. Jedná se o vylepšenou alternativu ke
globálním proměnným, s&nbsp;nimiž se v&nbsp;programech s&nbsp;větším množstvím
korutin pracuje dost nešikovně (a obecně se jedná spíše o problematickou
vlastnost jazyka). Naproti tomu je mnohdy užitečné mít možnost sdílet informace
mezi korutinami bez toho, aby se do všech funkcí předávaly ty stejné parametry
(například informace pro logování atd.).  A právě v&nbsp;těchto případech je
možné použít kontextové proměnné.</p>

<p>Balíček s&nbsp;podporou kontextových proměnných se importuje takto:</p>

<pre>
import contextvars
</pre>

<p>Kontextovou proměnnou lze kdykoli vytvořit zápisem:</p>

<pre>
additional_info = contextvars.ContextVar("additional_info")
</pre>

<p>Tato proměnná podporuje metody <strong>.get</strong> a
<strong>.set</strong>, které lze volat z&nbsp;libovolné korutiny, bez nutnosti
další synchronizace.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zámky</h2>

<p>V&nbsp;knihovně <i>Trio</i> nalezneme i realizaci klasických zámků
(<i>lock</i>) neboli <i>mutexů</i>. Zámkem je v&nbsp;kontextu souběžných úloh
myšleno synchronizační primitivum, které (pochopitelně při správném použití)
zajišťuje výhradní přístup k&nbsp;nějakým sdíleným prostředkům, například
k&nbsp;bloku paměti (sdílená proměnná či objekt), otevřenému socketu atd. Zámky
obecně podporují dvě operace &ndash; <strong>acquire</strong> pro získání zámku
a <strong>release</strong> pro jeho uvolnění. Přitom platí, že zámek může
vlastnit pouze jediná korutina. V&nbsp;případě, že se dvě či více korutin
pokusí o získání zámku, &bdquo;vyhraje&ldquo; jedna z&nbsp;těchto korutin a
další korutiny čekají na jeho uvolnění. Díky použití zámků lze tedy
&bdquo;serializovat&ldquo; přístup k&nbsp;nějakému prostředku. Hrozí však
nebezpečí, že pokud budou korutiny pracovat s&nbsp;větším množstvím zámků,
dojde k&nbsp;<i>deadlocku</i>.</p>

<p>Dostupné metody třídy <strong>trio.Lock</strong>:</p>

<ol>
<li>acquire</li>
<li>acquire_nowait</li>
<li>locked</li>
<li>release</li>
<li>statistics</li>
</ol>

<p><div class="rs-tip-major">Poznámka: používají se zejména již obě výše
zmíněné operace <strong>acquire</strong> a <strong>release</strong>, a to
nepřímo:</div></p>

<pre>
async with objekt_typu_zámek:
    ...
    ...
    ...
</pre>

<p>Do tohoto bloku se vstoupí jen ve chvíli, kdy korutina získá zámek. A po
opuštění bloku dojde automaticky k&nbsp;uvolnění zámku, a to i v&nbsp;případě
vyhození výjimky atd.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Příklad použití zámku</h2>

<p>Podívejme se nyní na to, jakým způsobem lze se zámky pracovat
v&nbsp;případě, že je vytvořeno několik korutin spouštějících totožný
programový kód. Povšimněte si, že zámek je získán a současně i posléze uvolněn
v&nbsp;bloku <strong>async with</strong>. To mj.&nbsp;znamená, že se na
uvolnění zámku nezapomene. Navíc se jedná o idiomatický přístup, který známe i
z&nbsp;dalších oblastí Tria:</p>

<pre>
import trio
&nbsp;
&nbsp;
num_workers = 10
&nbsp;
&nbsp;
<u>async def</u> <strong>worker</strong>(id, lock):
    while True:
        <i># pokus o ziskani zamku s jeho naslednym automatickym uvolnenim</i>
        async with lock:
            print(f"Worker #{id}: acquires lock")
            <u>await</u> trio.sleep(1)
        <i># zde je jiz zamek uvolnen</i>
&nbsp;
&nbsp;
<u>async def</u> <strong>main</strong>():
    <u>async with</u> trio.open_nursery() as nursery:
        <i># konstrukce zamku</i>
        lock = trio.Lock()
        for id in range(num_workers):
            nursery.start_soon(worker, id, lock)
&nbsp;
&nbsp;
trio.run(main)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Férové získávání zámků</h2>

<p>Zajímavé bude vysledovat, jakým způsobem je zámek po uvolnění předáván další
korutině. Obecně totiž není specifikováno, které korutině bude zámek předán (a
v&nbsp;mnoha programovacích jazycích resp.&nbsp;knihovnách tak může zámek stále
získávat stále ta samá korutina a stále se bude jednat o korektní chování),
ovšem v&nbsp;knihovně <i>Trio</i> (minimálně v&nbsp;současné verzi) je
realizován algoritmus zajišťující určitou míru férovosti &ndash; viz též <a
href="https://github.com/python-trio/trio/issues/54">Should our locks (and
semaphores, queues, etc.) be fair?</a>. Ostatně spuštěním výše uvedeného
demonstračního příkladu se můžeme sami přesvědčit, do jaké míry je předávání
zámku férové či nikoli:</p>

<pre>
Worker #0: acquires lock
Worker #1: acquires lock
Worker #2: acquires lock
Worker #3: acquires lock
Worker #4: acquires lock
Worker #5: acquires lock
Worker #6: acquires lock
Worker #7: acquires lock
Worker #8: acquires lock
Worker #9: acquires lock
Worker #0: acquires lock
Worker #1: acquires lock
Worker #2: acquires lock
Worker #3: acquires lock
Worker #4: acquires lock
Worker #5: acquires lock
...
...
...
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;předchozího úryvku výsledků je
patrné, že se skutečně jedná o férový algoritmus typu
<i>round-robin</i>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Shrnutí &ndash; technologie pro souběžné a paralelní úlohy v&nbsp;Pythonu</h2>

<p>V&nbsp;dnes končícím miniseriálu o souběžných, popř.&nbsp;v&nbsp;některých
případech i paralelních úlohách realizovaných v&nbsp;programovacím jazyku <a
href="https://www.root.cz/n/python/">Python</a> jsme se seznámili
s&nbsp;několika zajímavými a taktéž užitečnými technologiemi. Připomeňme si, že
se jednalo jak o balíčky (knihovny) určené pro jazyk Python, tak i o rozšíření
samotného Pythonu o nové konstrukce realizované klíčovými slovy
<strong>async</strong> a <strong>await</strong>, které jsou typicky
zkombinovány s&nbsp;již existujícími klíčovými slovy <strong>def</strong>,
<strong>with</strong> a <strong>for</strong>.</p>

<p><div class="rs-tip-major">Poznámka: konstrukce <strong>async</strong> a
<strong>await</strong> se (tedy v&nbsp;případě, že se zaměříme na ty známější
jazyky) nejprve objevily v&nbsp;jazyku F# a posléze se rozšířily do C#,
JavaScriptu, TypeScriptu, Pythonu atd. I když se sémantika mnohdy poněkud
odlišuje, stále se jedná v&nbsp;oblasti souběžných úloh o dnes již de facto
standardní konstrukce, což je ostatně jen dobře (již tak roztříštěný svět IT
není zapotřebí zbytečně dále fragmentovat vymýšlením unikátně pojmenovaných
konstrukcí).</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Tři nejčastěji používané strategie</h2>

<p>Všechna již popsaná technologická řešení můžeme zobecnit a následně rozdělit
do tří kategorií podle toho, jak jsou vlastně souběžné a popř.&nbsp;i plně
paralelně běžící úlohy realizovány:</p>

<ol>

<li>První způsob spočívá v&nbsp;tvorbě a spouštění souběžných a současně i
potenciálně paralelně běžících úloh, přičemž každá úloha je realizována
samostatným procesem (<i>process</i>) viditelným a řízeným přímo operačním
systémem. Jednotlivé úlohy jsou sice vzájemně izolovány, ovšem mohou spolu
komunikovat s&nbsp;využitím objektu typu <strong>Pipe</strong>. Konkrétně je
tento problém řešen standardními knihovnami nazvanými
<strong>multiprocessing</strong> a <strong>ProcessPoolExecutor</strong> (lze
používat odděleně). Oddělení (<i>isolation</i>) je v&nbsp;porovnání
s&nbsp;ostatními dvěma technologiemi nejlepší, ovšem nevýhodou jsou obecně
větší nároky na systémové prostředky (několik běžících virtuálních strojů
Pythonu).</li>

<li>Druhý způsob není založen na samostatně běžících procesech, ale na vláknech
(<i>thread</i>), které jsou vytvářeny a spouštěny v&nbsp;rámci jediného procesu
(virtuálního stroje Pythonu). Vzájemná izolace jednotlivých úloh je
v&nbsp;tomto případě menší a záleží vlastně jen na vývojáři, zda a jak zajistí
přístup většího množství vláken do sdílených proměnných. Standardně se pro
komunikaci mezi vlákny používají různé realizace front popř.&nbsp;zásobníků
(<strong>Queue</strong>, <strong>LifoQueue</strong>,
<strong>PriorityQueue</strong> a <strong>SimpleQueue</strong>). Práce
s&nbsp;větším množstvím vláken je nabízena ve standardních knihovnách
<strong>threading</strong> a taktéž <strong>ThreadPoolExecutor</strong> (opět
lze používat odděleně).</li>

<li>Třetí způsob nepoužívá ani samostatně běžící procesy ani (již méně
samostatná) vlákna, ale vystačí si s&nbsp;využitím korutin (<i>koroutines</i>),
přičemž v&nbsp;daný okamžik může souběžně běžet větší množství korutin, přičemž
jedna korutina je aktivní. Operace s&nbsp;korutinami jsou realizovány přes již
zmíněná klíčová slova <strong>async</strong> a <strong>await</strong> využívaná
například standardní knihovnou <strong>asyncio</strong> s&nbsp;vlastní
realizací asynchronní fronty a podporované dalšími knihovnami typu
<strong>aiohttp</strong>. Kromě toho je práce s&nbsp;korutinami podporována i
dalšími knihovnami, z&nbsp;nichž za zmínku stojí především knihovna
<strong>Curio</strong> či ještě lépe navržená knihovna <strong>Trio</strong>,
která z&nbsp;Curia částečně vychází.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: <strong>Pipe</strong> zajišťuje
obousměrnou komunikaci, <strong>Queue</strong> typicky komunikaci jednosměrnou
(ovšem nijak ji negarantuje) a <strong>channel</strong> striktně jednosměrnou
komunikaci.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Jaké řešení je tedy nejvhodnější?</h2>

<p>Pravděpodobně není možné bez podrobnějších znalostí řešeného problému říci,
která z&nbsp;výše zmíněných technologií je obecně nejlepší. Do značné míry
totiž záleží na konkrétních požadavcích, které má vytvářená aplikace či služba
splňovat. Pokud je například nutné řešit především mnoho souběžných I/O operací
typu přístup k&nbsp;souborům, databázím, proudům (<i>streams</i>), komunikace
přes HTTP atd. (což patří mezi typické úlohy programované v&nbsp;Pythonu), může
být výhodné použít korutiny a například knihovnu <strong>Trio</strong> nebo
dnes přece jen více standardní dvojici knihoven
<strong>asyncio+aiohttp</strong>. Předností tohoto řešení je fakt, že
v&nbsp;případě využití Tria má programátor široké možnosti řízení korutin,
dokáže korektně reagovat na případné výjimky, které mohou v&nbsp;korutinách
vzniknout atd. Na druhé straně toto řešení nezaručuje skutečně paralelní běh
výpočtů atd.</p>

<p>Pokud je na druhou stranu nutné realizovat spíše výpočetně náročné úlohy
(které lze do jisté míry paralelizovat), může se pro tento účel více hodit
multiprocesing a (v&nbsp;menší míře) multithreading, který je ovšem
v&nbsp;CPythonu (dnes asi nejpoužívanější implementace Pythonu) omezen kvůli
existenci <a href="https://realpython.com/python-gil/">GILu</a> (a aby nedošlo
k&nbsp;mýlce &ndash; GIL v&nbsp;žádném případě neřeší korektní přístup ke
sdíleným proměnným). Zcela subjektivně bych řekl, že multithreading je ze všech
tří nabízených řešení pravděpodobně nejhůře reálně použitelnou a v&nbsp;mnoha
ohledech i nebezpečnou technologií (vlákna nejsou na jedné straně oddělena, na
straně druhé se špatně řídí a kontroluje jejich stav).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>multithreading1.py</td><td>spuštění tří vláken vykonávajících déletrvající činnost</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading1.py</a></td></tr>
<tr><td> 2</td><td>multithreading2.py</td><td>spuštění tří vláken, předání parametrů volaným funkcím</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading2.py</a></td></tr>
<tr><td> 3</td><td>multithreading3.py</td><td>explicitní čekání na dokončení běhu vláken metodou <strong>join</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading3.py</a></td></tr>
<tr><td> 4</td><td>multithreading4.py</td><td>sdílený objekt</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading4.py</a></td></tr>
<tr><td> 5</td><td>multithreading_join_deamon.py</td><td>čekání na dokončení vláken s&nbsp;příznakem &bdquo;daemon&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_join_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_join_deamon.py</a></td></tr>
<tr><td> 6</td><td>multithreading_no_join_deamon.py</td><td>vlákna s&nbsp;příznakem &bdquo;daemon&ldquo;, na jejichž ukončení se nečeká</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_deamon.py</a></td></tr>
<tr><td> 7</td><td>multithreading_no_join_no_deamon.py</td><td>běžná vlákna bez příznaku &bdquo;daemon&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_no_deamon.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_no_join_no_deamon.py</a></td></tr>
<tr><td> 8</td><td>multithreading_timeout.py</td><td>specifikace maximální doby čekání na ukončení vlákna</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_timeout.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multithreading_timeout.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>multiprocessing1.py</td><td>zavolání funkce spuštěné v&nbsp;rámci dalšího procesu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing1.py</a></td></tr>
<tr><td>10</td><td>multiprocessing2.py</td><td>spuštění většího množství procesů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing2.py</a></td></tr>
<tr><td>11</td><td>multiprocessing3.py</td><td>nepatrná úprava předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing3.py</a></td></tr>
<tr><td>12</td><td>multiprocessing4.py</td><td>řízení workerů posílanými příkazy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing4.py</a></td></tr>
<tr><td>13</td><td>multiprocessing5.py</td><td>řízení workerů posílanými příkazy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing5.py</a></td></tr>
<tr><td>14</td><td>multiprocessing6.py</td><td>jeden proces a sdílená globální hodnota</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing6.py</a></td></tr>
<tr><td>15</td><td>multiprocessing7.py</td><td>více procesů, které nesdílí hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/multiprocessing7.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>queue_example.py</td><td>základní vlastnosti sdílené datové struktury <strong>Queue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queue_example.py</a></td></tr>
<tr><td>17</td><td>simple_queue_example.py</td><td>základní vlastnosti sdílené datové struktury <strong>SimpleQueue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/simple_queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/simple_queue_example.py</a></td></tr>
<tr><td>18</td><td>priority_queue_example.py</td><td>základní vlastnosti sdílené datové struktury <strong>PriorityQueue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/priority_queue_example.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/priority_queue_example.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>queues1.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: základní forma</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues1.py</a></td></tr>
<tr><td>20</td><td>queues2.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: více konzumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues2.py</a></td></tr>
<tr><td>21</td><td>queues3.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: více producentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues3.py</a></td></tr>
<tr><td>22</td><td>queues4.py</td><td>komunikace mezi vlákny s&nbsp;využitím front: více producentů i konzumentů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/queues4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>thread_pool_1.py</td><td>spuštění tří úloh ve třech vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_1.py</a></td></tr>
<tr><td>24</td><td>thread_pool_2.py</td><td>spuštění deseti úloh v&nbsp;deseti vláknech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_2.py</a></td></tr>
<tr><td>25</td><td>thread_pool_3.py</td><td>omezení počtu vláken na 3 pro celkem deset úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_3.py</a></td></tr>
<tr><td>26</td><td>thread_pool_4.py</td><td>návratová hodnota získaná po spuštění úlohy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_4.py</a></td></tr>
<tr><td>27</td><td>thread_pool_5.py</td><td>získání vypočtených hodnot</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_5.py</a></td></tr>
<tr><td>28</td><td>thread_pool_6.py</td><td>alternativní způsob zápisu předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/thread_pool_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>process_pool_1.py</td><td>spuštění tří úloh ve vlastních procesech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_1.py</a></td></tr>
<tr><td>30</td><td>process_pool_2.py</td><td>návratové hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_2.py</a></td></tr>
<tr><td>31</td><td>process_pool_3.py</td><td>čekání na dokončení úloh + získání návratových hodnot</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/process_pool_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>async_await_1.py</td><td>základní způsob použití <strong>async</strong> a <strong>await</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_1.py</a></td></tr>
<tr><td>33</td><td>async_await_2.py</td><td>funkce <strong>main</strong> volaná asynchronně</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_2.py</a></td></tr>
<tr><td>34</td><td>async_await_3.py</td><td>dvě asynchronně běžící úlohy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_3.py</a></td></tr>
<tr><td>35</td><td>async_await_4.py</td><td>získání výsledků z&nbsp;asynchronně běžících úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_await_4.py</a></td></tr>
<tr><td>36</td><td>async_queue_1.py</td><td>fronty pro kooperace mezi korutinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_1.py</a></td></tr>
<tr><td>37</td><td>async_queue_2.py</td><td>korektní spuštění většího množství korutin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_2.py</a></td></tr>
<tr><td>38</td><td>async_queue_3.py</td><td>využití <strong>asyncio.gather</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_queue_3.py</a></td></tr>
<tr><td>39</td><td>async_aiohttp_1.py</td><td>použití knihovny <strong>aiohttp</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_1.py</a></td></tr>
<tr><td>40</td><td>async_aiohttp_2.py</td><td>záznam časů trvání jednotlivých operací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_2.py</a></td></tr>
<tr><td>41</td><td>async_aiohttp_3.py</td><td>vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_3.py</a></td></tr>
<tr><td>42</td><td>async_aiohttp_4.py</td><td>využití deseti korutin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_aiohttp_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>curio_01.py</td><td>základní konstrukce nabízené knihovnou <strong>curio</strong> (<strong>curio.run</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_01.py</a></td></tr>
<tr><td>44</td><td>curio_02.py</td><td>předání parametrů asynchronně volané korutině při volání <strong>curio.run</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_02.py</a></td></tr>
<tr><td>45</td><td>curio_03.py</td><td>chování programu při spuštění několika korutin funkcí <strong>curio.run</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_03.py</a></td></tr>
<tr><td>46</td><td>curio_04.py</td><td>asynchronní spuštění korutin pomocí <strong>curio.spawn</strong> (nekorektní příklad)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_04.py</a></td></tr>
<tr><td>47</td><td>curio_05.py</td><td>asynchronní spuštění korutin pomocí <strong>curio.spawn</strong> (korektní příklad)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_05.py</a></td></tr>
<tr><td>48</td><td>curio_06.py</td><td>čekání na dokončení korutin s&nbsp;využitím metody <strong>task.join</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_06.py</a></td></tr>
<tr><td>49</td><td>curio_07.py</td><td>spuštění monitoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_07.py</a></td></tr>
<tr><td>50</td><td>curio_08.py</td><td>využití fronty pro předávání parametrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_08.py</a></td></tr>
<tr><td>51</td><td>curio_09.py</td><td>datová struktura <strong>curio.UniversalQueue</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_09.py</a></td></tr>
<tr><td>52</td><td>curio_10.py</td><td>klasický program typu producent-konzument</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_10.py</a></td></tr>
<tr><td>53</td><td>curio_11.py</td><td>výsledky vrácené korutinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_11.py</a></td></tr>
<tr><td>54</td><td>curio_12.py</td><td>výsledky vrácené dlouho běžícími korutinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_12.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_12.py</a></td></tr>
<tr><td>55</td><td>curio_13.py</td><td>čekání na výsledky po stanovený mezní časový interval</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_13.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_13.py</a></td></tr>
<tr><td>56</td><td>curio_14.py</td><td>reakce na vypršení mezního časového intervalu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_14.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_14.py</a></td></tr>
<tr><td>57</td><td>curio_15.py</td><td>výjimka vzniklá v&nbsp;korutině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_15.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_14.py</a></td></tr>
<tr><td>58</td><td>curio_16.py</td><td>reakce na výjimku vyhozenou v&nbsp;korutině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_16.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/curio_16.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>59</td><td>with_block.py</td><td>blok <strong>with</strong> a <i>context manager</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/with_block.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/with_block.py</a></td></tr>
<tr><td>60</td><td>async_with_block.py</td><td>blok <strong>async with</strong> a asynchronní <i>context manager</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_with_block.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/async_with_block.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>trio_01.py</td><td>spuštění korutiny knihovnou <strong>Trio</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_01.py</a></td></tr>
<tr><td>62</td><td>trio_01_error.py</td><td>chybné vynechání slova <strong>awai</strong> při volání jiné korutiny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_01_error.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_01_error.py</a></td></tr>
<tr><td>63</td><td>trio_02.py</td><td>déletrvající souběžně běžící úloha</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_02.py</a></td></tr>
<tr><td>64</td><td>trio_03.py</td><td>tři souběžně běžící úlohy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_03.py</a></td></tr>
<tr><td>65</td><td>trio_04.py</td><td>základní způsob použití objektu <strong>nursery</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_04.py</a></td></tr>
<tr><td>66</td><td>trio_05.py</td><td>hodnota získaná po spuštění korutiny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_05.py</a></td></tr>
<tr><td>67</td><td>trio_06.py</td><td>trojice postupně spuštěných korutin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_06.py</a></td></tr>
<tr><td>68</td><td>trio_07.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_07.py</a></td></tr>
<tr><td>69</td><td>trio_08.py</td><td>vyhození výjimky v&nbsp;korutině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_08.py</a></td></tr>
<tr><td>70</td><td>trio_09.py</td><td>pokus o zachycení výjimky v&nbsp;korutině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_09.py</a></td></tr>
<tr><td>71</td><td>trio_10.py</td><td>vznik výjimek v&nbsp;několika korutinách</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_10.py</a></td></tr>
<tr><td>72</td><td>trio_11.py</td><td>paměťové nároky programu se 100 korutinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_11.py</a></td></tr>
<tr><td>73</td><td>trio_12.py</td><td>paměťové nároky programu s&nbsp;10000 korutinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_12.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_12.py</a></td></tr>
<tr><td>74</td><td>trio_13.py</td><td>spuštění 10000 souběžných úloh</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_13.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_13.py</a></td></tr>
<tr><td>75</td><td>trio_14.py</td><td>ukázka klasické úlohy typu producent-konzument</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_14.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_14.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>76</td><td>trio_15.py</td><td>programátorem vyvolané výjimky v&nbsp;korutině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_15.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_15.py</a></td></tr>
<tr><td>77</td><td>trio_16.py</td><td>zachycení výjimky typu <strong>TaskError</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_16.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_16.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>78</td><td>trio_17_no_consumer.py</td><td>chování Tria v&nbsp;případě, že existuje jen producent zpráv u kanálu s&nbsp;nulovou kapacitou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_17_no_consumer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_17_no_consumer.py</a></td></tr>
<tr><td>79</td><td>trio_18_no_consumer_capacity.py</td><td>chybějící konzument, použití komunikačního kanálu s&nbsp;nenulovou kapacitou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_18_no_consumer_capacity.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_18_no_consumer_capacity.py</a></td></tr>
<tr><td>80</td><td>trio_19_no_consumer_no_wait.py</td><td>zápis zprávy do kanálu synchronní operací <strong>send_nowait</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_19_no_consumer_no_wait.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_19_no_consumer_no_wait.py</a></td></tr>
<tr><td>81</td><td>trio_20_no_consumer_fail_after.py</td><td>pokus o zápis do kanálu se specifikovanou maximální dobou čekání</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_20_no_consumer_fail_after.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_20_no_consumer_fail_after.py</a></td></tr>
<tr><td>82</td><td>trio_21_no_producer.py</td><td>chování Tria v&nbsp;případě, že existuje jen konzument zpráv u kanálu s&nbsp;nulovou kapacitou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_21_no_producer.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_21_no_producer.py</a></td></tr>
<tr><td>83</td><td>trio_22_no_producer_B.py</td><td>úprava předchozího příkladu &ndash; náhrada smyčky <strong>async for</strong> za <strong>while</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_22_no_producer_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_22_no_producer_B.py</a></td></tr>
<tr><td>84</td><td>trio_23_no_producer_no_wait.py</td><td>synchronní příjem zpráv z&nbsp;kanálu (bez čekání)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_23_no_producer_no_wait.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_23_no_producer_no_wait.py</a></td></tr>
<tr><td>85</td><td>trio_24_no_producer_fail_after.py</td><td>pokus o příjem zprávy z&nbsp;kanálu se specifikovanou maximální dobou čekání</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_24_no_producer_fail_after.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_24_no_producer_fail_after.py</a></td></tr>
<tr><td>86</td><td>trio_25_multiple_prod_cons.py</td><td>větší množství producentů a konzumentů zpráv</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_25_multiple_prod_cons.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_25_multiple_prod_cons.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>87</td><td>producer_consumer.go</td><td>klasická úloha typu producent-konzument naprogramovaná v&nbsp;jazyku Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/producer_consumer.go">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/producer_consumer.go</a></td></tr>
<tr><td>88</td><td>producer_consumer_2.go</td><td>vylepšená klasická úloha typu producent-konzument naprogramovaná v&nbsp;jazyku Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/producer_consumer_2.go">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/producer_consumer_2.go</a></td></tr>
<tr><td>89</td><td>producer_only.go</td><td>producent, zprávy nejsou nikým konzumovány</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/producer_only.go">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/producer_only.go</a></td></tr>
<tr><td>90</td><td>consumer_only.go</td><td>konzument, zprávy nejsou nikým produkovány</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/consumer_only.go">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/consumer_only.go</a></td></tr>
<tr><td>91</td><td>producers_consumers.go</td><td>větší množství producentů a konzumentů zpráv</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/producers_consumers.go">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/producers_consumers.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>92</td><td>trio_26_timeouts.py</td><td>specifikace maximální doby čekání na zprávu popř.&nbsp;pro poslání zprávy do blokovaného kanálu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_26_timeouts.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_26_timeouts.py</a></td></tr>
<tr><td>93</td><td>trio_26B_move_after.py</td><td>specifikace maximální doby čekání na zprávu popř.&nbsp;pro poslání zprávy do blokovaného kanálu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_26B_move_after.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_26B_move_after.py</a></td></tr>
<tr><td>94</td><td>trio_27_channel_close.py</td><td>explicitní uzavření kanálu v&nbsp;korutině, reakce na uzavření kanálu dalšími korutinami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_27_channel_close.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_27_channel_close.py</a></td></tr>
<tr><td>95</td><td>trio_28_multiple_channel_close.py</td><td>problematika uzavření kanálu používaného větším množstvím korutin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_28_multiple_channel_close.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_28_multiple_channel_close.py</a></td></tr>
<tr><td>96</td><td>trio_29_multiple_channel_close.py</td><td>vyřešení předchozího problému &ndash; &bdquo;naklonování&ldquo; kanálu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_29_multiple_channel_close.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_29_multiple_channel_close.py</a></td></tr>
<tr><td>97</td><td>trio_31_locks.py</td><td>využití zámků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_31_locks.py">https://github.com/tisnik/most-popular-python-libs/blob/master/concurrent/trio_31_locks.py</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Předchozí články z&nbsp;miniseriálu o souběžných úlohách v&nbsp;Pythonu</h2>

<ol>

<li>Souběžné a paralelně běžící úlohy naprogramované v&nbsp;Pythonu<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v&nbsp;Pythonu (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v&nbsp;Pythonu &ndash; Curio a Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v&nbsp;Pythonu &ndash; knihovna Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v&nbsp;Pythonu &ndash; knihovna Trio (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/</a>
</li>

</ol>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace Pythonu: balíček queue<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Dokumentace Pythonu: balíček threading<br />
<a href="https://docs.python.org/3/library/threading.html?">https://docs.python.org/3/library/threading.html?</a>
</li>

<li>Dokumentace Pythonu: balíček multiprocessing<br />
<a href="https://docs.python.org/3/library/multiprocessing.html">https://docs.python.org/3/library/multiprocessing.html</a>
</li>

<li>Dokumentace Pythonu: balíček asyncio<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Synchronization Primitives<br />
<a href="https://docs.python.org/3/library/asyncio-sync.html">https://docs.python.org/3/library/asyncio-sync.html</a>
</li>

<li>Coroutines<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Queues<br />
<a href="https://docs.python.org/3/library/asyncio-queue.html">https://docs.python.org/3/library/asyncio-queue.html</a>
</li>

<li>python-csp<br />
<a href="https://python-csp.readthedocs.io/en/latest/">https://python-csp.readthedocs.io/en/latest/</a>
</li>

<li>TrellisSTM<br />
<a href="http://peak.telecommunity.com/DevCenter/TrellisSTM">http://peak.telecommunity.com/DevCenter/TrellisSTM</a>
</li>

<li>Python Multithreading and Multiprocessing Tutorial<br />
<a href="https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python">https://www.toptal.com/python/beginners-guide-to-concurrency-and-parallelism-in-python</a>
</li>

<li>ThreadPoolExecutor<br />
<a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor">https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor</a>
</li>

<li>ProcessPoolExecutor<br />
<a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor">https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor</a>
</li>

<li>asyncio — Asynchronous I/O<br />
<a href="https://docs.python.org/3/library/asyncio.html">https://docs.python.org/3/library/asyncio.html</a>
</li>

<li>Threads vs Async: Has Asyncio Solved Concurrency?<br />
<a href="https://www.youtube.com/watch?v=NZq31Sg8R9E">https://www.youtube.com/watch?v=NZq31Sg8R9E</a>
</li>

<li>Python Asynchronous Programming &ndash; AsyncIO &amp; Async/Await<br />
<a href="https://www.youtube.com/watch?v=t5Bo1Je9EmE">https://www.youtube.com/watch?v=t5Bo1Je9EmE</a>
</li>

<li>AsyncIO &amp; Asynchronous Programming in Python<br />
<a href="https://www.youtube.com/watch?v=6RbJYN7SoRs">https://www.youtube.com/watch?v=6RbJYN7SoRs</a>
</li>

<li>Coroutines and Tasks<br />
<a href="https://docs.python.org/3/library/asyncio-task.html">https://docs.python.org/3/library/asyncio-task.html</a>
</li>

<li>Python async/await Tutorial<br />
<a href="https://stackabuse.com/python-async-await-tutorial/">https://stackabuse.com/python-async-await-tutorial/</a>
</li>

<li>Demystifying Python's Async and <u>await</u> Keywords<br />
<a href="https://www.youtube.com/watch?v=F19R_M4Nay4">https://www.youtube.com/watch?v=F19R_M4Nay4</a>
</li>

<li>Curio<br />
<a href="https://curio.readthedocs.io/en/latest/">https://curio.readthedocs.io/en/latest/</a>
</li>

<li>Trio: a friendly Python library for async concurrency and I/O<br />
<a href="https://trio.readthedocs.io/en/stable/">https://trio.readthedocs.io/en/stable/</a>
</li>

<li>Curio &ndash; A Tutorial Introduction<br />
<a href="https://curio.readthedocs.io/en/latest/tutorial.html">https://curio.readthedocs.io/en/latest/tutorial.html</a>
</li>

<li>unsync<br />
<a href="https://github.com/alex-sherman/unsync">https://github.com/alex-sherman/unsync</a>
</li>

<li>David Beazley - Die Threads<br />
<a href="https://www.youtube.com/watch?v=xOyJiN3yGfU">https://www.youtube.com/watch?v=xOyJiN3yGfU</a>
</li>

<li>Miguel Grinberg Asynchronous Python for the Complete Beginner PyCon 2017<br />
<a href="https://www.youtube.com/watch?v=iG6fr81xHKA">https://www.youtube.com/watch?v=iG6fr81xHKA</a>
</li>

<li>Build Your Own Async<br />
<a href="https://www.youtube.com/watch?v=Y4Gt3Xjd7G8">https://www.youtube.com/watch?v=Y4Gt3Xjd7G8</a>
</li>

<li>The Other Async (Threads + Async = ❤️)<br />
<a href="https://www.youtube.com/watch?v=x1ndXuw7S0s">https://www.youtube.com/watch?v=x1ndXuw7S0s</a>
</li>

<li>Fear and <u>await</u>ing in Async: A Savage Journey to the Heart of the Coroutine Dream<br />
<a href="https://www.youtube.com/watch?v=E-1Y4kSsAFc">https://www.youtube.com/watch?v=E-1Y4kSsAFc</a>
</li>

<li>Keynote David Beazley - Topics of Interest (Python Asyncio)<br />
<a href="https://www.youtube.com/watch?v=ZzfHjytDceU">https://www.youtube.com/watch?v=ZzfHjytDceU</a>
</li>

<li>David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015<br />
<a href="https://www.youtube.com/watch?v=MCs5OvhV9S4">https://www.youtube.com/watch?v=MCs5OvhV9S4</a>
</li>

<li>Python Async basics video (100 million HTTP requests)<br />
<a href="https://www.youtube.com/watch?v=Mj-Pyg4gsPs">https://www.youtube.com/watch?v=Mj-Pyg4gsPs</a>
</li>

<li>Nathaniel J. Smith - Trio: Async concurrency for mere mortals &ndash; PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=oLkfnc_UMcE">https://www.youtube.com/watch?v=oLkfnc_UMcE</a>
</li>

<li>Timeouts and cancellation for humans<br />
<a href="https://vorpus.org/blog/timeouts-and-cancellation-for-humans/">https://vorpus.org/blog/timeouts-and-cancellation-for-humans/</a>
</li>

<li>What is the core difference between asyncio and trio?<br />
<a href="https://stackoverflow.com/questions/49482969/what-is-the-core-difference-between-asyncio-and-trio">https://stackoverflow.com/questions/49482969/what-is-the-core-difference-between-asyncio-and-trio</a>
</li>

<li>Some thoughts on asynchronous API design in a post-async/await world<br />
<a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/#the-curious-effectiveness-of-curio">https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/#the-curious-effectiveness-of-curio</a>
</li>

<li>Companion post for my PyCon 2018 talk on async concurrency using Trio<br />
<a href="https://vorpus.org/blog/companion-post-for-my-pycon-2018-talk-on-async-concurrency-using-trio/">https://vorpus.org/blog/companion-post-for-my-pycon-2018-talk-on-async-concurrency-using-trio/</a>
</li>

<li>Control-C handling in Python and Trio<br />
<a href="https://vorpus.org/blog/control-c-handling-in-python-and-trio/">https://vorpus.org/blog/control-c-handling-in-python-and-trio/</a>
</li>

<li>Context Managers and Python's with Statement<br />
<a href="https://realpython.com/python-with-statement/">https://realpython.com/python-with-statement/</a>
</li>

<li>Notes on structured concurrency, or: Go statement considered harmful<br />
<a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/</a>
</li>

<li>Structured concurrency explained - Part 1: Introduction<br />
<a href="https://www.thedevtavern.com/blog/posts/structured-concurrency-explained/">https://www.thedevtavern.com/blog/posts/structured-concurrency-explained/</a>
</li>

<li>Structured concurrency<br />
<a href="https://en.wikipedia.org/wiki/Structured_concurrency">https://en.wikipedia.org/wiki/Structured_concurrency</a>
</li>

<li>Structured Concurrency<br />
<a href="https://250bpm.com/blog:71/">https://250bpm.com/blog:71/</a>
</li>

<li>Python and Trio, where producers are consumers, how to exit gracefully when the job is done?<br />
<a href="https://stackoverflow.com/questions/65304775/python-and-trio-where-producers-are-consumers-how-to-exit-gracefully-when-the">https://stackoverflow.com/questions/65304775/python-and-trio-where-producers-are-consumers-how-to-exit-gracefully-when-the</a>
</li>

<li>Lock (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">https://en.wikipedia.org/wiki/Lock_(computer_science)</a>
</li>

<li>Zámek (informatika)<br />
<a href="https://cs.wikipedia.org/wiki/Z%C3%A1mek_(informatika)">https://cs.wikipedia.org/wiki/Z%C3%A1mek_(informatika)</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

