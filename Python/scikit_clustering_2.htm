<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Shluková analýza (clustering) a knihovna Scikit-learn (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Shluková analýza (clustering) a knihovna Scikit-learn (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Shluková analýza (clustering) a knihovna Scikit-learn (2)</a></p>
<p><a href="#k02">2. Meze algoritmu K-means</a></p>
<p><a href="#k03">3. Pomocná funkce pro vygenerování bodů rozmístěných v&nbsp;soustředných kružnicích</a></p>
<p><a href="#k04">4. Pomocná funkce pro vygenerování bodů rozmístěných do dvou půlměsíců</a></p>
<p><a href="#k05">5. Shluková analýza algoritmem K-means pro body rozmístěné do soustředných kružnic</a></p>
<p><a href="#k06">6. Shluková analýza algoritmem k-means pro body rozmístěné do dvou půlměsíců</a></p>
<p><a href="#k07">7. Shluková analýza realizovaná algoritmem <i>spectral clustering</i></a></p>
<p><a href="#k08">8. Výsledek shlukové analýzy provedené algoritmem <i>spectral clustering</i></a></p>
<p><a href="#k09">9. Shluková analýza algoritmem <i>spectral clustering</i> pro body rozmístěné do soustředných kružnic</a></p>
<p><a href="#k10">10. Shluková analýza algoritmem <i>spectral clustering</i> pro body rozmístěné do dvou půlměsíců</a></p>
<p><a href="#k11">11. Meze algoritmu <i>spectral clustering</i></a></p>
<p><a href="#k12">12. Další algoritmy shlukové analýzy nabízené knihovnou Scikit-Learn</a></p>
<p><a href="#k13">13. Emergence: struktury vzniklé ze zdánlivého chaosu</a></p>
<p><a href="#k14">*** 14. Příklad vzniku emergentní struktury</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Shluková analýza (clustering) a knihovna Scikit-learn (2)</h2>

<p>V&nbsp;dnešním článku si nejprve naznačíme některé meze algoritmu
<i>K-means</i>, kterým jsme se zabývali <a
href="https://www.root.cz/clanky/shlukova-analyza-clustering-a-knihovna-scikit-learn/">v&nbsp;předchozím
článku</a> a které omezují použití tohoto algoritmu pouze na některé problémy
řešené shlukovou analýzou. Posléze se budeme zabývat dalšími vybranými
algoritmy, které dokážou provádět shlukové analýzy a které jsou podporovány
knihovnou Scikit-learn. Pro otestování chování těchto algoritmů použijeme další
pomocné funkce určené pro vygenerování bodů v&nbsp;pseudonáhodných pozicích,
tedy funkce obdobné minule využité funkci <strong>make_blobs</strong>.
V&nbsp;praxi se navíc poměrně často setkáme s&nbsp;požadavkem na nalezení
hierarchie shluků (<i>clusterů</i>), což je problém řešitelný algoritmy
specializovanými na hierarchickou shlukovou analýzu (ty však mají mnohdy
relativně velkou výpočetní složitost).</p>

<img src="https://i.iinfo.cz/images/375/scikit-learn-clustering-1.webp" class="image-1111745" width="720" height="820" alt="&#160;" title="Autor: adam, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 3: Shlukovou analýzu H&ndash;R diagramu lze provádět mnohými
algoritmy, ovšem algoritmus K-means je pro tyto účely zcela nevhodný.<br />
Autor obrázku: Adam na projektu Wikipedie v jazyce čeština – Na Commons přeneseno z
cs.wikipedia., Volné dílo,
https://commons.wikimedia.org/w/index.php?curid=2157609</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Meze algoritmu K-means</h2>

<p>Algoritmus K-means je sice v&nbsp;oblasti shlukové analýzy velmi často
využíván, ovšem stále je nutné mít na paměti, že jeho základní vlastnosti do
určité míry omezují jeho použití. V&nbsp;případě, že skutečně potřebujeme
nalézt skupiny bodů, které se shlukují okolo jednoho bodu (<i>centroidu</i>),
lze tento algoritmus použít. Předností bude rychlý výpočet, zejména
v&nbsp;porovnání se sofistikovanějšími shlukovými algoritmy. Relativně dobře
bude tento algoritmus fungovat i ve chvíli, kdy se oblasti shluků budou
překrývat &ndash; v&nbsp;takových případech budou hranice mezi shluky
připomínat Voronoiův diagram:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-7.webp" class="image-1111752" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 1: Výsledek clusteringu pro překrývající se oblasti centroidů.</i></p>

<p>V&nbsp;náhodných datech ovšem algoritmus žádnou strukturu nenalezne (což
bylo ovšem možné očekávat). Nicméně některé algoritmy tuto situaci dokážou
detekovat a vložit všechny body do jediného clusteru:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-8.webp" class="image-1111753" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 2: Výsledek shlukové analýzy náhodných dat.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pomocná funkce pro vygenerování bodů rozmístěných v&nbsp;soustředných kružnicích</h2>

<p>Abychom si mohli ještě lépe ilustrovat principiální omezení algoritmu
K-means, vyzkoušíme si použití odlišných metod generování vstupních bodů
v&nbsp;ploše. Namísto nám již velmi dobře známé funkce
<strong>make_blobs</strong> se pokusíme využít funkci nazvanou
<strong>make_circles</strong>. Jedná se o příhodný název, protože výsledek
skutečně připomíná soustředné kružnice. Tuto funkci lze zavolat následovně:</p>

<pre>
samples, labels = <strong>make_circles</strong>(
    n_samples=n_samples, factor=0.5, noise=0.05
)
</pre>

<p>kde parametr <strong>factor</strong> určuje rozdíl velikostí vnější a
vnitřní kružnice a parametrem <strong>noise</strong> se nastavuje směrodatná
odchylka při výpočtu pozice bodů.</p>

<p>Takto vypadá skript, který vygeneruje a následně zobrazí sadu bodů
v&nbsp;rovině:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.datasets import make_circles
&nbsp;
<i># testovací data</i>
n_samples = 2000
&nbsp;
samples, labels = <strong>make_circles</strong>(
    n_samples=n_samples, factor=0.5, noise=0.05
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># vykreslení bodů v rovině</i>
plt.scatter(samples[:, 0], samples[:, 1], s=1.0)
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("circles1.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Z&nbsp;výsledků je patrné, že shluková analýza založená na centroidech
nemůže vypočítat ucházející výsledek:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-1.webp" class="image-1111837" wiath="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 3: Body rozmístěné po ploše funkcí <strong>make_circles</strong> s&nbsp;použitím malé míry náhodnosti.</i></p>

<p>Pokusme se nyní zvýšit směrodatnou odchylku a zjistit, jak se tato změna
projeví ve výsledném obrazci složeném z&nbsp;bodů:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.datasets import make_circles
&nbsp;
<i># testovací data</i>
n_samples = 2000
&nbsp;
samples, labels = <strong>make_circles</strong>(
    n_samples=n_samples, factor=0.5, <u>noise=0.10</u>
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># vykreslení bodů v rovině</i>
plt.scatter(samples[:, 0], samples[:, 1], s=1.0)
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("circles2.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Obě kružnice již nebudou tak výrazné, takže je možné předpokládat, že i
algoritmy pro shlukovou analýzu začnou mít s&nbsp;podobnými obrázky
problémy:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-2.webp" class="image-1111838" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 4: Body rozmístěné po ploše funkcí <strong>make_circles</strong> s&nbsp;použitím velké míry náhodnosti.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pomocná funkce pro vygenerování bodů rozmístěných do dvou půlměsíců</h2>

<p>Podobným způsobem si lze nechat vygenerovat sadu bodů, které po svém
zobrazení v&nbsp;rovině vytvoří dvojici půlměsíců. Pro tento účel se používá
funkce nazvaná <strong>make_moons</strong>:</p>

<pre>
samples, labels = <strong>make_moons</strong>(
    n_samples=n_samples, noise=0.05
)
</pre>

<p>Příklad použití této funkce:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.datasets import make_moons
&nbsp;
<i># testovací data</i>
n_samples = 2000
&nbsp;
samples, labels = <strong>make_moons</strong>(
    n_samples=n_samples, noise=0.05
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># vykreslení bodů v rovině</i>
plt.scatter(samples[:, 0], samples[:, 1], s=1.0)
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("moons1.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Z&nbsp;výsledků je opět zřejmé, že klasický algoritmus pro clustering na
základě nalezených centroidů zde nebude ideálním prostředkem pro shlukovou
analýzu:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-3.webp" class="image-1111839" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 5: Body rozmístěné po ploše funkcí <strong>make_moons</strong> s&nbsp;použitím malé míry náhodnosti.</i></p>

<p>A pro úplnost ještě zvýšíme hodnotu směrodatné odchylky, což celý výsledný
obrazec složený z&nbsp;bodů učiní ještě více náhodným:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.datasets import make_moons
&nbsp;
<i># testovací data</i>
n_samples = 2000
&nbsp;
samples, labels = <strong>make_moons</strong>(
    n_samples=n_samples, <u>noise=0.15</u>
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># vykreslení bodů v rovině</i>
plt.scatter(samples[:, 0], samples[:, 1], s=1.0)
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("moons2.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Výsledný korelační diagram bude v&nbsp;tomto případě vypadat následovně:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-4.webp" class="image-1111840" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 6: Body rozmístěné po ploše funkcí <strong>make_moons</strong> s&nbsp;použitím velké míry náhodnosti.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Shluková analýza algoritmem K-means pro body rozmístěné do soustředných kružnic</h2>

<p>Vyzkoušejme si nyní, jak bude vypadat výsledek shlukové analýzy
v&nbsp;případě, že na body vygenerované pomocnou funkcí
<strong>make_circles</strong> (tedy na dvojici soustředných kružnic) použijeme
algoritmus K-means, s&nbsp;nímž jsme se setkali v&nbsp;předchozím článku.
Vygenerujeme celkem 2000 bodů a pousíme se najít 6 clusterů (i když počet
nebude hrát velkou roli):</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.cluster import KMeans
from sklearn.datasets import make_circles
&nbsp;
<i># testovací data</i>
n_samples = 2000
&nbsp;
samples, labels = <strong>make_circles</strong>(
    n_samples=n_samples, factor=0.5, noise=0.05
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
<i># clustering</i>
kmeans = KMeans(n_clusters=6, random_state=0, n_init="auto").fit(samples)
&nbsp;
<i># vykreslení bodů s jejich přiřazením ke clusteru</i>
for i, color in enumerate(colors):
    selector = kmeans.labels_ == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=1)
&nbsp;
plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], c="red", s=50)
plt.title("K-Means++")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("circles_kmeans.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Z&nbsp;výsledků je patrné to, co jsme pravděpodobně již tušili &ndash;
algoritmus, který se snaží nalézt centroidy, bude prakticky nepoužitelný na
body seskupené do dvojice soustředných kružnic, neboť takový tvar nelze tímto
algoritmem rozumně rozdělit:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-5.webp" class="image-1111841" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 7: Výsledek shlukové analýzy provedené algoritmem K-means.</i></p>

<img src="https://i.iinfo.cz/images/424/scikit-learn-2b-1.webp" class="image-1111867" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 8: Výsledek pro 5000 vstupních bodů a dva výsledné clustery.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Shluková analýza algoritmem k-means pro body rozmístěné do dvou půlměsíců</h2>

<p>Podobně ovšem platí, že algoritmus K-means nebude použitelný ani
v&nbsp;případě, že mu předložíme body uspořádané do dvou půlměsíců, které navíc
(alespoň částečně) do sebe zapadají. Opět si to ukažme na příkladu, v&nbsp;němž
funkci <strong>make_circles</strong> nahradíme za funkci
<strong>make_moons</strong>.  Ve skriptu je specifikováno, že se body mají
rozdělit do šesti clusterů, ovšem sami si můžete otestovat, že výsledky nebudou
lepší ani při specifikaci dvou clusterů (což opět plyne z&nbsp;vlastností
algoritmu K-means):</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.cluster import KMeans
from sklearn.datasets import make_moons
&nbsp;
<i># testovací data</i>
n_samples = 2000
&nbsp;
samples, labels = <strong>make_moons</strong>(
    n_samples=n_samples, noise=0.05
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
<i># clustering</i>
kmeans = KMeans(n_clusters=6, random_state=0, n_init="auto").fit(samples)
&nbsp;
<i># vykreslení bodů s jejich přiřazením ke clusteru</i>
for i, color in enumerate(colors):
    selector = kmeans.labels_ == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=1)
&nbsp;
plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], c="red", s=50)
plt.title("K-Means++")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("moons_kmeans.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Výsledky:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-6.webp" class="image-1111842" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 9: Výsledek shlukové analýzy provedené algoritmem K-means.</i></p>

<img src="https://i.iinfo.cz/images/424/scikit-learn-2b-2.webp" class="image-1111868" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 10: Výsledek pro 5000 vstupních bodů a dva clustery.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Shluková analýza realizovaná algoritmem <i>spectral clustering</i></h2>

<p>Z&nbsp;předchozích kapitol je patrné, že algoritmus K-means nedokáže provést
korektní shlukovou analýzu ani pro body uspořádané do soustředných kružnic ani
pro body uspořádané do dvou půlměsíců. Je to očekávatelné chování &ndash;
ostatně ony dva tvary byly schválně zvoleny tak, aby nebyly algoritmem K-means
řešitelné. Ovšem co použít namísto tohoto algoritmu? Knihovna Scikit-learn nám
nabízí hned několik alternativních algoritmů, které se od sebe odlišují jak
svými základními vlastnostmi (jaké tvary clusterů dokážou detekovat a zda
dokáží pracovat s&nbsp;hierarchickými clustery), tak i časovou a prostorovou
složitostí (tedy tím, kolik času procesoru popř.&nbsp;jakou kapacitu operační
paměti vyžadují).</p>

<p>Jedním z&nbsp;vhodných algoritmů je algoritmus nazvaný <i>spectral
clustering</i>, jehož popis nalezneme například <a
href="https://en.wikipedia.org/wiki/Spectral_clustering">na této stránce</a>.
Shlukovou analýzu s&nbsp;využitím tohoto algoritmu provedeme příkazem:</p>

<pre>
spectral = <strong>SpectralClustering(n_clusters=n_components, eigen_solver="arpack", affinity="nearest_neighbors", random_state=0).fit(samples)</strong>
</pre>

<p>Vstupními parametry je především očekávaný počet clusterů (zde použijeme
hodnotu 2) a parametr určující, jak bude zkonstruována matice příbuzných bodů.
Navíc je možné pro velký počet bodů změnit způsob výpočtu vlastních čísel
(<i>eigenvalues</i>) a použít tak sice rychlejší, ale v&nbsp;některých
případech méně stabilní postup (oba dva poslední parametry si ještě otestujeme
později).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výsledek shlukové analýzy provedené algoritmem <i>spectral clustering</i></h2>

<p>Nyní nastává okamžik otestování základních vlastností algoritmu <i>spectral
clustering</i>. Nejprve tento algoritmus vyzkoušíme nad body získanými pomocnou
funkcí <strong>make_blobs</strong>. Mimochodem &ndash; povšimněte si, že
analyzujeme množinu 10000 bodů, což se již (společně s&nbsp;požadovaným počtem
nalezených clusterů) projeví na delší době běhu skriptu. Velká část výpočtů
bude navíc provedena v&nbsp;jediném vláknu, což je problematika, ke které se
ještě vrátíme:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.cluster import SpectralClustering
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 10000
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
samples, labels = <strong>make_blobs</strong>(
    n_samples=n_samples, centers=n_components, cluster_std=1.50, random_state=0
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
<i># clustering</i>
spectral = <strong>SpectralClustering(n_clusters=n_components, eigen_solver="arpack", affinity="nearest_neighbors", random_state=0).fit(samples)</strong>
&nbsp;
<i># vykreslení bodů s jejich přiřazením ke clusteru</i>
for i, color in enumerate(colors):
    selector = spectral.labels_ == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=1)
&nbsp;
plt.title("Spectral clustering")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("blobs_spectral.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>A takto bude vypadat rozdělení bodů do clusterů:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-7.webp" class="image-1111843" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 11: Výsledek shlukové analýzy provedené algoritmem Spectral clustering.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Shluková analýza algoritmem <i>spectral clustering</i> pro body rozmístěné do soustředných kružnic</h2>

<p>Stejný algoritmus nyní použijeme pro shlukovou analýzu bodů rozmístěných
(resp.&nbsp;vygenerovaných) pomocnou funkcí <strong>make_circles</strong>.
Upravíme tedy celý skript následujícím způsobem (budeme pochopitelně vyžadovat
nalezení dvou clusterů a nikoli šesti clusterů, jako tomu bylo v&nbsp;předchozí
kapitole):</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.cluster import SpectralClustering
from sklearn.datasets import make_circles
&nbsp;
<i># testovací data</i>
n_samples = 2000
&nbsp;
samples, labels = <strong>make_circles</strong>(
    n_samples=n_samples, factor=0.5, noise=0.05
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
<i># clustering</i>
spectral = <strong>SpectralClustering(n_clusters=2, eigen_solver="arpack", affinity="nearest_neighbors", random_state=0).fit(samples)</strong>
&nbsp;
<i># vykreslení bodů s jejich přiřazením ke clusteru</i>
for i, color in enumerate(colors):
    selector = spectral.labels_ == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=1)
&nbsp;
plt.title("Spectral clustering")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("circles_spectral.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Nyní je zřejmé, že algoritmus správně rozpoznal a rozdělil body do dvou
skupin. Na rozdíl od algoritmu K-means jsme tedy v&nbsp;tomto konkrétním
případě získali použitelný výsledek:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-8.webp" class="image-1111844" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 12: Výsledek shlukové analýzy provedené algoritmem Spectral clustering.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Shluková analýza algoritmem <i>spectral clustering</i> pro body rozmístěné do dvou půlměsíců</h2>

<p>A konečně si otestujme, jak dobře (či naopak špatně) dokáže algoritmus
<i>spectral clustering</i> rozdělit body, které jsou rozmístěné do oblastí
připomínajících dva půlměsíce. Prozatím při vytváření vstupních bodů ponecháme
hodnotu <strong>noise</strong> na relativně nízké hodnotě 0,05; později si
vyzkoušíme tuto hodnotu postupně zvyšovat. A samozřejmě budeme vyžadovat
rozdělení bodů do dvou clusterů:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.cluster import SpectralClustering
from sklearn.datasets import make_moons
&nbsp;
<i># testovací data</i>
n_samples = 2000
&nbsp;
samples, labels = <strong>make_moons</strong>(
    n_samples=n_samples, noise=0.05
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
<i># clustering</i>
spectral = <strong>SpectralClustering(n_clusters=2, eigen_solver="arpack", affinity="nearest_neighbors", random_state=0).fit(samples)</strong>
&nbsp;
<i># vykreslení bodů s jejich přiřazením ke clusteru</i>
for i, color in enumerate(colors):
    selector = spectral.labels_ == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=1)
&nbsp;
plt.title("Spectral clustering")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("moons_spectral.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Výsledek zobrazený na následujícím obrázku opět naznačuje, že byl algoritmus
pro danou vstupní množinu bodů velmi úspěšný:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-9.webp" class="image-1111845" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 13: Výsledek shlukové analýzy provedené algoritmem Spectral clustering.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Meze algoritmu <i>spectral clustering</i></h2>

<p>Podobně jako v&nbsp;případě již minule popsaného algoritmu K-means má i
algoritmus <i>spectral clustering</i> určité meze, které znamenají, že ho není
možné použít ve všech případech (resp.&nbsp;přesněji řečeno můžeme získat
shluky, které nebudou vyhovující). Zkusme jednu takovou mez objevit. Skript <a
href="#k10">z&nbsp;předchozí kapitoly</a> nepatrně upravíme tak, aby byly body
tvořící vstupní data rozmístěny po větší ploše. To se provede snadno &ndash;
zvýšením parametru <strong>noise</strong> z&nbsp;hodnoty 0.05 na hodnotu
0.15:</p>

<pre>
<i># testovací data</i>
n_samples = 3000
&nbsp;
samples, labels = <strong>make_moons</strong>(
    n_samples=n_samples, noise=0.15
)
</pre>

<p>Po této zdánlivě nepatrné úpravě již nebudou shluky (clustery) nalezené
algoritmem spectral clustering ideální, což je ostatně velmi dobře patrné při
pohledu na vizualizovaný výsledek. Algoritmus totiž za těchto podmínek již
nedokázal správně rozpoznat oba více či méně izolované půlměsíce:</p>

<img src="https://i.iinfo.cz/images/581/scikit-learn-clustering-2a-10.webp" class="image-1111846" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 14: Výsledek shlukové analýzy provedené algoritmem Spectral clustering pro náhodněji rozmístěné body.</i></p>

<p>Výše zobrazený obrázek s&nbsp;vizualizací clusterů byl získán tímto
skriptem:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.cluster import SpectralClustering
from sklearn.datasets import make_moons
&nbsp;
<i># testovací data</i>
n_samples = 3000
&nbsp;
samples, labels = make_moons(
    n_samples=n_samples, noise=0.15
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
<i># clustering</i>
spectral = SpectralClustering(n_clusters=2, eigen_solver="arpack", affinity="nearest_neighbors", random_state=0).fit(samples)
&nbsp;
<i># vykreslení bodů s jejich přiřazením ke clusteru</i>
for i, color in enumerate(colors):
    selector = spectral.labels_ == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=1)
&nbsp;
plt.title("Spectral clustering")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("moons_spectral.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<img src="https://i.iinfo.cz/images/424/scikit-learn-2b-3.webp" class="image-1111869" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 15: Pro 5000 bodů leží mez použitelnosti algoritmu na hodnotě
noise přibližně 0,8 či 0,9. Zde již můžeme vidět špatné rozdělení bodů do
clusterů.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Další algoritmy shlukové analýzy nabízené knihovnou Scikit-Learn</h2>

<p>Pro oba zmíněné &bdquo;problematické&ldquo; tvary (resp.&nbsp;přesněji
řečeno oblasti, v&nbsp;níž jsou vstupní body generovány) lze s&nbsp;úspěchem
použít tyto algoritmy:</p>

<ul>
<li>spectral clustering (již jsme si vyzkoušeli)</li>
<li>DBSCAN</li>
<li>HDBSCAN</li>
<li>OPTICS</li>
</ul>

<p>K&nbsp;základním vlastnostem tří zbylých algoritmů se ještě vrátíme, protože
v&nbsp;praxi je důležité pro každý problém vybrat ten správný algoritmus a
navíc i korektně nastavit jeho parametry (což se mnohdy musí provádět
iterativním způsobem).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Emergence: struktury vzniklé ze zdánlivého chaosu</h2>

<p>V&nbsp;některých dynamických systémech mohou i na základě mnohdy velmi
jednoduchých pravidel vznikat složitější <i>emergentní</i> struktury. Tato
vlastnost se týká mnoha typů <i>komplexních systémů</i>, ovšem nás budou
v&nbsp;dnešním (i v&nbsp;navazujícím) článku zajímat především takové komplexní
systémy, v&nbsp;nichž je možné vlastnosti jejich jednotlivých elementů
reprezentovat jako body v&nbsp;ploše či v&nbsp;prostoru.</p>

<p>Poměrně známým příkladem mohou být různé systémy částic (<i>particle
systems</i>), v&nbsp;nichž lze při vhodné definici pravidel chování
jednotlivých částic taktéž nalézt emergentní struktury. Toto téma je sice velmi
rozsáhlé a vyžádá si nejméně jeden samostatný článek, ovšem již dnes si můžeme
jeden takový částicový systém ukázat. A vzhledem k&nbsp;tomu, že dále zmíněný
částicový systém vede ke vzniku emergentní struktury (a nikoli pouze náhodného
&bdquo;oblaku&ldquo; bodů), budeme ho moci analyzovat právě s&nbsp;využitím
shlukové analýzy.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Příklad vzniku emergentní struktury</h2>

<p>Vlastní částicový systém, který budeme modelovat, je vlastně poměrně
jednoduchý. Nachází se v&nbsp;něm čtyři typy částic, které se při vykreslování
liší svou barvou. Částice se pohybují v&nbsp;rovině a působí na ně jak
setrvačnost, tak i vzájemná přitažlivost. Ovšem nejzajímavější je, že
přitažlivost mezi různými kombinacemi částic může být taktéž rozdílná &ndash;
tedy například dvě červené částice se budou přitahovat jinou silou, než dvě
stejně vzdálené částice s&nbsp;červenou a žlutou barvou atd. A právě modifikací
počtu částic různé barvy a obsahu matice s&nbsp;koeficienty přitažlivosti (což
jsou vlastně gravitační konstanty) částic různých barev lze dosáhnout mnohdy i
velmi komplexního chování celého systému &ndash; budou se tvořit organické
tvary, vzniknou &bdquo;predátoři&ldquo; z&nbsp;několika částic stejné barvy,
vznikne stabilní mřížce podobná struktura atd.</p>

<p>Realizace takového systému v&nbsp;Pythonu je sice z&nbsp;pohledu
programátora snadná, ovšem samotná simulace bude velmi pomalá (zejména
v&nbsp;porovnání s&nbsp;céčkovou variantou, kterou mám taktéž
k&nbsp;dispozici). Důležité však je, že klávesou <strong>w</strong> lze
v&nbsp;libovolném okamžiku simulace uložit pozice všech částic do souboru ve
formátu CSV:</p>

<pre>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import sys
from enum import Enum
from random import random
from math import sqrt
&nbsp;
import pygame
import pygame.locals
&nbsp;
WINDOW_WIDTH = 800
WINDOW_HEIGHT = 600
WINDOW_TITLE = "Particle life simulator"
&nbsp;
<i># Constants used by model</i>
RED_GROUP = 0
GREEN_GROUP = 1
YELLOW_GROUP = 2
BLUE_GROUP = 3
&nbsp;
<i># Model options</i>
BORDER = 50
&nbsp;
<i># Number of particles of different colors/attributes</i>
MAX_RED = 1000
MAX_GREEN = 200
MAX_BLUE = 50
MAX_YELLOW = 10
&nbsp;
<i># Total number of particles in the whole system</i>
MAX_PARTICLES = MAX_RED+MAX_GREEN+MAX_BLUE+MAX_YELLOW
&nbsp;
<i># Other model options</i>
MAX_DISTANCE = 2000
DAMPING_FACTOR = 0.5
SLOW_DOWN_FACTOR = 0.1
SCALE_FACTOR = 1
&nbsp;
&nbsp;
class <strong>Colors</strong>(Enum):
    <i>"""Named colors used everywhere on demo screens."""</i>
&nbsp;
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    CYAN = (0, 255, 255)
    GREEN = (0, 255, 0)
    YELLOW = (255, 255, 0)
    RED = (255, 0, 0)
    MAGENTA = (255, 0, 255)
    WHITE = (255, 255, 255)
&nbsp;
&nbsp;
class <strong>Particle</strong>:
    def <strong>__init__</strong>(self, x : float, y : float, vx : float, vy : float, type : int):
        self.x = x
        self.y = y
        self.vx = vx
        self.vy = vy
        self.type = type
&nbsp;
&nbsp;
class <strong>Atoms</strong>:
    def <strong>__init__</strong>(self, max_particles : int):
        self.colors = (0xffff0000, 0xff00ff00, 0xff2020ff, 0xffffff00)
        self.particles = []
        self.particles += (create_particles(MAX_RED, RED_GROUP))
        self.particles += (create_particles(MAX_GREEN, GREEN_GROUP))
        self.particles += (create_particles(MAX_BLUE, BLUE_GROUP))
        self.particles += (create_particles(MAX_YELLOW, YELLOW_GROUP))
        print("Particles in atoms:", len(self.particles))
&nbsp;
&nbsp;
class <strong>Model</strong>:
    def <strong>__init__</strong>(self, max_particles : int):
        self.rules = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]
        self.init_rules()
        self.atoms = Atoms(max_particles)
&nbsp;
    def <strong>init_rules</strong>(self):
        for j in range(4):
            for i in range(4):
                self.rules[i][j] = 2.0*random() - 1.0
&nbsp;
&nbsp;
def <strong>random_x</strong>() -&gt; float:
    return (WINDOW_WIDTH - BORDER*2) * random() + BORDER
&nbsp;
&nbsp;
def <strong>random_y</strong>() -&gt; float:
    return (WINDOW_HEIGHT - BORDER*2) * random() + BORDER
&nbsp;
&nbsp;
def create_particles(max : int, type : int):
    return [Particle(random_x(), random_y(), 0.0, 0.0, type) for i in range(max)]
&nbsp;
&nbsp;
def <strong>redraw</strong>(surface, model):
    surface.fill(Colors.BLACK.value)
    atoms = model.atoms
    for particle in atoms.particles:
        color = atoms.colors[particle.type]
        surface.set_at((int(particle.x),int(particle.y)), color)
        surface.set_at((int(particle.x-1),int(particle.y)), color)
        surface.set_at((int(particle.x+1),int(particle.y)), color)
        surface.set_at((int(particle.x),int(particle.y-1)), color)
        surface.set_at((int(particle.x),int(particle.y+1)), color)
&nbsp;
&nbsp;
def <strong>apply_rules</strong>(model : Model):
    for i in range(len(model.atoms.particles)):
        fx : float = 0.0
        fy : float = 0.0
&nbsp;
        a = model.atoms.particles[i]
&nbsp;
        <i># compute force for selected particle</i>
        for j in range(len(model.atoms.particles)):
            if i != j:
                b = model.atoms.particles[j]
                g = model.rules[a.type][b.type] * SCALE_FACTOR
                dx = a.x - b.x
                dy = a.y - b.y
                if dx != 0.0 or dy != 0.0:
                    d = dx*dx + dy*dy
                    if d &lt; MAX_DISTANCE:
                        f = g / sqrt(d)
                        fx += f * dx
                        fy += f * dy
&nbsp;
        <i># apply force to selected particle</i>
        a.vx = (a.vx + fx) * DAMPING_FACTOR
        a.vy = (a.vy + fy) * DAMPING_FACTOR
&nbsp;
        <i># move particle</i>
        a.x += a.vx
        a.y += a.vy
&nbsp;
        <i># check if particle touches scene boundary</i>
        if a.x &lt;= 0:
            a.vx = -a.vx
            a.x = 0
&nbsp;
        if a.x &gt;= WINDOW_WIDTH:
            a.vx = -a.vx
            a.x = WINDOW_WIDTH - 1
&nbsp;
        if a.y &lt;= 0:
            a.vy = -a.vy
            a.y = 0
&nbsp;
        if a.y &gt;= WINDOW_HEIGHT:
            a.vy = -a.vy
            a.y = WINDOW_HEIGHT - 1
&nbsp;
&nbsp;
def <strong>write_particles</strong>(model, filename):
    atoms = model.atoms
    with open(filename, "w") as fout:
        fout.write('"x","y"\n')
        for particle in atoms.particles:
            fout.write(f"{particle.x},{particle.y}\n")
&nbsp;
&nbsp;
<i># set window title</i>
pygame.display.set_caption(WINDOW_TITLE)
&nbsp;
display = pygame.display.set_mode([WINDOW_WIDTH, WINDOW_HEIGHT])
display.fill(Colors.BLACK.value)
&nbsp;
surface = pygame.Surface([WINDOW_WIDTH, WINDOW_HEIGHT])
surface.set_at((101,100), 0xffff0000)
surface.set_at((100,101), 0xffff0000)
surface.set_at((101,101), 0xffff0000)
&nbsp;
clock = pygame.time.Clock()
model = Model(MAX_PARTICLES)
&nbsp;
while True:
    for event in pygame.event.get():
        if event.type == pygame.locals.QUIT:
            pygame.quit()
            sys.exit()
        if event.type == pygame.locals.KEYDOWN:
            if event.key == pygame.locals.K_ESCAPE:
                pygame.quit()
                sys.exit()
            if event.key == pygame.locals.K_RETURN:
                pygame.quit()
                sys.exit()
            if event.key == pygame.locals.K_w:
                write_particles(model, "particles.csv")
&nbsp;
    <i># all events has been processed - update scene and redraw the screen</i>
    apply_rules(model)
    redraw(surface, model)
    display.blit(surface, (0, 0))
    pygame.display.update()
    <i># clock.tick(25)</i>
</pre>

<p></p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
<i># knihovnu Pandas využijeme pro načtení datového rámce</i>
import pandas as pd
&nbsp;
df = pd.read_csv("particles.csv")
&nbsp;
<i># vykreslení bodů v rovině</i>
plt.scatter(df["x"], df["y"], s=1)
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("particles.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<img src="https://i.iinfo.cz/images/424/scikit-learn-2b-4.webp" class="image-1111870" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 16: </i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady využívající knihovnu Scikit-learn lze nalézt
v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady i na (Jupyter) diáře s&nbsp;postupem
výpočtů a analýz:</p>

<table>
<tr><th>#<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td> 1</td><td>01_show_matrix.py</td><td>kooperace mezi knihovnami Matplotlib a NumPy: vizualizace obsahu 2D matice</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/01_show_matrix.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/01_show_matrix.py</a></td></tr>
<tr><td> 2</td><td>02_get_digits.py</td><td>datová množina obsahující naskenované ručně napsané číslice</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/02_get_digits.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/02_get_digits.py</a></td></tr>
<tr><td> 3</td><td>03_get_features.py</td><td>další atributy datové množiny, které použijeme při trénování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/03_get_features.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/03_get_features.py</a></td></tr>
<tr><td> 4</td><td>04_get_images.py</td><td>přečtení a následné vykreslení jednotlivých ručně nakreslených číslic</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/04_get_images.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/04_get_images.py</a></td></tr>
<tr><td> 5</td><td>05_show_grayscale_matrix.py</td><td>odstranění umělé aplikované barvové palety (obrázky ve stupních šedi)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/05_show_grayscale_matrix.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/05_show_grayscale_matrix.py</a></td></tr>
<tr><td> 6</td><td>06_grayscale_images.py</td><td>vykreslení ručně nakreslených číslic ve formě obrázků ve stupních šedi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/06_grayscale_images.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/06_grayscale_images.py</a></td></tr>
<tr><td> 7</td><td>07_multiplot.py</td><td>rozdělení plochy grafu do oblastí; vykreslení více obrázků do jediného grafu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/07_multiplot.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/07_multiplot.py</a></td></tr>
<tr><td> 8</td><td>08_model_preperation_1.py</td><td>obrázky s&nbsp;jejich ohodnocením</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/08_model_preperation_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/08_model_preperation_1.py</a></td></tr>
<tr><td> 9</td><td>09_training_set.py</td><td>příprava dat pro trénink</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/09_training_set.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/09_training_set.py</a></td></tr>
<tr><td>10</td><td>10_classification.py</td><td>klasifikace obrázků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/10_classification.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/10_classification.py</a></td></tr>
<tr><td>11</td><td>11_results.py</td><td>vykreslení obrázků společně s&nbsp;jejich klasifikací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/11_results.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/11_results.py</a></td></tr>
<tr><td>12</td><td>12_change_training_set.py</td><td>změna poměru rozdělení dat na tréninkovou a testovací množinu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/12_change_training_set.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/12_change_training_set.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>13_blobs.py</td><td>použití funkce <strong>make_blobs</strong> pro vygenerování sady bodů v&nbsp;rovině sdružených do oblastí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/13_blobs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/13_blobs.py</a></td></tr>
<tr><td>14</td><td>14_swap_coords.py</td><td>úprava předchozího příkladu: prohození souřadnic na osách</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/14_swap_coords.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/14_swap_coords.py</a></td></tr>
<tr><td>15</td><td>15_blobs_scatter_plot.py</td><td>základní podoba bodového diagramu (<i>scatter plot</i>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/15_blobs_scatter_plot.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/15_blobs_scatter_plot.py</a></td></tr>
<tr><td>16</td><td>16_blobs_scatter_plot.py</td><td>úprava bodového diagramu při zobrazení většího množství bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/16_blobs_scatter_plot.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/16_blobs_scatter_plot.py</a></td></tr>
<tr><td>17</td><td>17_colorized_blobs.py</td><td>obarvení bodů podle oblastí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/17_colorized_blobs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/17_colorized_blobs.py</a></td></tr>
<tr><td>18</td><td>18_k-means.py</td><td>základní použití algoritmu K-means pro clustering</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/18_k-means.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/18_k-means.py</a></td></tr>
<tr><td>19</td><td>19_combination.py</td><td>zobrazení centroidů společně s&nbsp;původními body</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/19_combination.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/19_combination.py</a></td></tr>
<tr><td>20</td><td>20_combinations.py</td><td>vizualizace clusteringu původní množiny bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/20_combinations.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/20_combinations.py</a></td></tr>
<tr><td>21</td><td>21_other_settings.py</td><td>vizualizace clusteringu původní množiny bodů pro odlišnou množinu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/21_other_settings.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/21_other_settings.py</a></td></tr>
<tr><td>22</td><td>22_random_points.py</td><td>clustering pro náhodná data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/22_random_points.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/22_random_points.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>23_circles.py</td><td>pseudonáhodné rozmístění bodů do kružnic, menší náhodnost výsledku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/23_circles.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/23_circles.py</a></td></tr>
<tr><td>24</td><td>24_more_noise_circles.py</td><td>pseudonáhodné rozmístění bodů do kružnic, větší náhodnost výsledku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/24_more_noise_circles.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/24_more_noise_circles.py</a></td></tr>
<tr><td>25</td><td>25_moons.py</td><td>pseudonáhodné rozmístění bodů do tvaru dvou půlměsíců, menší náhodnost</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/25_moons.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/25_moons.py</a></td></tr>
<tr><td>26</td><td>26_more_noisy_moons.py</td><td>pseudonáhodné rozmístění bodů do tvaru dvou půlměsíců, větší náhodnost</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/26_more_noisy_moons.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/26_more_noisy_moons.py</a></td></tr>
<tr><td>27</td><td>27_circles_kmeans.py</td><td>výsledek clusteringu provedeného algoritmem K-means na &bdquo;kružnice&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/27_circles_kmeans.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/27_circles_kmeans.py</a></td></tr>
<tr><td>28</td><td>28_moons_kmeans.py</td><td>výsledek clusteringu provedeného algoritmem K-means na &bdquo;půlměsíce&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/28_moons_kmeans.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/28_moons_kmeans.py</a></td></tr>
<tr><td>29</td><td>29_blobs_spectral_clustering.py</td><td>spectral clustering pro body rozmístěné pomocí <strong>make_blobs</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/29_blobs_spectral_clustering.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/29_blobs_spectral_clustering.py</a></td></tr>
<tr><td>30</td><td>30_circles_spectral_clustering.py</td><td>spectral clustering pro body rozmístěné do kružnic</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/30_circles_spectral_clustering.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/30_circles_spectral_clustering.py</a></td></tr>
<tr><td>31</td><td>31_moons_spectral_clustering.py</td><td>spectral clustering pro body rozmístěné do půlměsíců </td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/31_moons_spectral_clustering.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/31_moons_spectral_clustering.py</a></td></tr>
<tr><td>32</td><td>32_moons_spectral_clustering_limits.py</td><td>vyhledání limitů algoritmu spectral clustering</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/32_moons_spectral_clustering_limits.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/32_moons_spectral_clustering_limits.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>pyproject.toml</td><td>projektový soubor (pro PDM) se všemi závislostmi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/pyproject.toml">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/pyproject.toml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>34</td><td>pdm.lock</td><td>lock soubor s&nbsp;konkrétními verzemi všech přímých i tranzitivních závislostí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/pdm.lock">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/pdm.lock</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>35</td><td>Rozpoznání_obrazu_scikit-learn.ipynb</td><td>Jupyter notebook s&nbsp;celým postupem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/Rozpoznání_obrazu_scikit-learn.ipynb">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/Rozpoznání_obrazu_scikit-learn.ipynb</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>36</td><td>particle_life.py</td><td>emergence: příklad vzniku struktury</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/particles/particle_life.py">https://github.com/tisnik/most-popular-python-libs/blob/master/particles/particle_life.py</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>scikit-learn: Machine Learning in Python<br />
<a href="https://scikit-learn.org/stable/index.html">https://scikit-learn.org/stable/index.html</a>
</li>

<li>Sklearn-pandas<br />
<a href="https://github.com/scikit-learn-contrib/sklearn-pandas">https://github.com/scikit-learn-contrib/sklearn-pandas</a>
</li>

<li>sklearn-xarray<br />
<a href="https://github.com/phausamann/sklearn-xarray/">https://github.com/phausamann/sklearn-xarray/</a>
</li>

<li>Clustering<br />
<a href="https://scikit-learn.org/stable/modules/clustering.html">https://scikit-learn.org/stable/modules/clustering.html</a>
</li>

<li>Cluster analysis (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cluster_analysis">https://en.wikipedia.org/wiki/Cluster_analysis</a>
</li>

<li>Shluková analýza (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Shlukov%C3%A1_anal%C3%BDza">https://cs.wikipedia.org/wiki/Shlukov%C3%A1_anal%C3%BDza</a>
</li>

<li>K-means<br />
<a href="https://cs.wikipedia.org/wiki/K-means">https://cs.wikipedia.org/wiki/K-means</a>
</li>

<li>k-means clustering<br />
<a href="https://en.wikipedia.org/wiki/K-means_clustering">https://en.wikipedia.org/wiki/K-means_clustering</a>
</li>

<li>Spectral clustering<br />
<a href="https://en.wikipedia.org/wiki/Spectral_clustering">https://en.wikipedia.org/wiki/Spectral_clustering</a>
</li>

<li>Emergence<br />
<a href="https://cs.wikipedia.org/wiki/Emergence">https://cs.wikipedia.org/wiki/Emergence</a>
</li>

<li>Particle Life: Vivid structures from rudimentary rules<br />
<a href="https://particle-life.com/">https://particle-life.com/</a>
</li>

<li>Hertzsprungův–Russellův diagram<br />
<a href="https://cs.wikipedia.org/wiki/Hertzsprung%C5%AFv%E2%80%93Russell%C5%AFv_diagram">https://cs.wikipedia.org/wiki/Hertzsprung%C5%AFv%E2%80%93Russell%C5%AFv_diagram</a>
</li>

<li>Using Machine Learning in an HR Diagram<br />
<a href="https://cocalc.com/share/public_paths/08b6e03583cbdef3cdb9813a54ec68ff773c747f">https://cocalc.com/share/public_paths/08b6e03583cbdef3cdb9813a54ec68ff773c747f</a>
</li>

<li>Gaia H-R diagrams: Querying Gaia data for one million nearby stars<br />
<a href="https://vlas.dev/post/gaia-dr2-hrd/">https://vlas.dev/post/gaia-dr2-hrd/</a>
</li>

<li>The Hertzsprung–Russell diagram<br />
<a href="https://scipython.com/book2/chapter-9-data-analysis-with-pandas/problems/p92/the-hertzsprung-russell-diagram/">https://scipython.com/book2/chapter-9-data-analysis-with-pandas/problems/p92/the-hertzsprung-russell-diagram/</a>
</li>

<li>Animated Hertzsprung-Russell Diagram with 119,614 datapoints<br />
<a href="https://github.com/zonination/h-r-diagram">https://github.com/zonination/h-r-diagram</a>
</li>

<li>Neuraxle Pipelines<br />
<a href="https://github.com/Neuraxio/Neuraxle">https://github.com/Neuraxio/Neuraxle</a>
</li>

<li>scikit-learn: Getting Started<br />
<a href="https://scikit-learn.org/stable/getting_started.html">https://scikit-learn.org/stable/getting_started.html</a>
</li>

<li>Support Vector Machines<br />
<a href="https://scikit-learn.org/stable/modules/svm.html">https://scikit-learn.org/stable/modules/svm.html</a>
</li>

<li>Use Deep Learning to Detect Programming Languages<br />
<a href="http://searene.me/2017/11/26/use-neural-networks-to-detect-programming-languages/">http://searene.me/2017/11/26/use-neural-networks-to-detect-programming-languages/</a>
</li>

<li>Natural-language processing<br />
<a href="https://en.wikipedia.org/wiki/Natural-language_processing">https://en.wikipedia.org/wiki/Natural-language_processing</a>
</li>

<li>THE MNIST DATABASE of handwritten digits<br />
<a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a>
</li>

<li>MNIST database (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MNIST_database">https://en.wikipedia.org/wiki/MNIST_database</a>
</li>

<li>MNIST For ML Beginners<br />
<a href="https://www.tensorflow.org/get_started/mnist/beginners">https://www.tensorflow.org/get_started/mnist/beginners</a>
</li>

<li>Stránka projektu Torch<br />
<a href="http://torch.ch/">http://torch.ch/</a>
</li>

<li>Torch: Serialization<br />
<a href="https://github.com/torch/torch7/blob/master/doc/serialization.md">https://github.com/torch/torch7/blob/master/doc/serialization.md</a>
</li>

<li>Torch: modul image<br />
<a href="https://github.com/torch/image/blob/master/README.md">https://github.com/torch/image/blob/master/README.md</a>
</li>

<li>Data pro neuronové sítě<br />
<a href="http://archive.ics.uci.edu/ml/index.php">http://archive.ics.uci.edu/ml/index.php</a>
</li>

<li>Torch na GitHubu (několik repositářů)<br />
<a href="https://github.com/torch">https://github.com/torch</a>
</li>

<li>Torch (machine learning), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Torch_%28machine_learning%29">https://en.wikipedia.org/wiki/Torch_%28machine_learning%29</a>
</li>

<li>Torch Package Reference Manual<br />
<a href="https://github.com/torch/torch7/blob/master/README.md">https://github.com/torch/torch7/blob/master/README.md</a>
</li>

<li>Torch Cheatsheet<br />
<a href="https://github.com/torch/torch7/wiki/Cheatsheet">https://github.com/torch/torch7/wiki/Cheatsheet</a>
</li>

<li>Neural network containres (Torch)<br />
<a href="https://github.com/torch/nn/blob/master/doc/containers.md">https://github.com/torch/nn/blob/master/doc/containers.md</a>
</li>

<li>Simple layers<br />
<a href="https://github.com/torch/nn/blob/master/doc/simple.md#nn.Linear">https://github.com/torch/nn/blob/master/doc/simple.md#nn.Linear</a>
</li>

<li>Transfer Function Layers<br />
<a href="https://github.com/torch/nn/blob/master/doc/transfer.md#nn.transfer.dok">https://github.com/torch/nn/blob/master/doc/transfer.md#nn.transfer.dok</a>
</li>

<li>Feedforward neural network<br />
<a href="https://en.wikipedia.org/wiki/Feedforward_neural_network">https://en.wikipedia.org/wiki/Feedforward_neural_network</a>
</li>

<li>Biologické algoritmy (4) - Neuronové sítě<br />
<a href="https://www.root.cz/clanky/biologicke-algoritmy-4-neuronove-site/">https://www.root.cz/clanky/biologicke-algoritmy-4-neuronove-site/</a>
</li>

<li>Biologické algoritmy (5) - Neuronové sítě<br />
<a href="https://www.root.cz/clanky/biologicke-algoritmy-5-neuronove-site/">https://www.root.cz/clanky/biologicke-algoritmy-5-neuronove-site/</a>
</li>

<li>Umělá neuronová síť (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Um%C4%9Bl%C3%A1_neuronov%C3%A1_s%C3%AD%C5%A5">https://cs.wikipedia.org/wiki/Um%C4%9Bl%C3%A1_neuronov%C3%A1_s%C3%AD%C5%A5</a>
</li>

<li>PyTorch<br />
<a href="http://pytorch.org/">http://pytorch.org/</a>
</li>

<li>JupyterLite na PyPi<br />
<a href="https://pypi.org/project/jupyterlite/">https://pypi.org/project/jupyterlite/</a>
</li>

<li>JupyterLite na GitHubu<br />
<a href="https://github.com/jupyterlite/jupyterlite">https://github.com/jupyterlite/jupyterlite</a>
</li>

<li>Dokumentace k&nbsp;projektu JupyterLite<br />
<a href="https://github.com/jupyterlite/jupyterlite">https://github.com/jupyterlite/jupyterlite</a>
</li>

<li>Matplotlib Home Page<br />
<a href="http://matplotlib.org/">http://matplotlib.org/</a>
</li>

<li>Matplotlib (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Matplotlib">https://en.wikipedia.org/wiki/Matplotlib</a>
</li>

<li>Popis barvových map modulu matplotlib.cm<br />
<a href="https://gist.github.com/endolith/2719900#id7">https://gist.github.com/endolith/2719900#id7</a>
</li>

<li>Ukázky (palety) barvových map modulu matplotlib.cm<br />
<a href="http://matplotlib.org/examples/color/colormaps_reference.html">http://matplotlib.org/examples/color/colormaps_reference.html</a>
</li>

<li>Galerie grafů vytvořených v&nbsp;Matplotlibu<br />
<a href="https://matplotlib.org/3.2.1/gallery/">https://matplotlib.org/3.2.1/gallery/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

