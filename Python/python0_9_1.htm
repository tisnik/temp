<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Malé ohlédnutí za historií Pythonu: Python 0.9.1 na moderním hardware</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Malé ohlédnutí za historií Pythonu: Python 0.9.1 na moderním hardware</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V souvislosti s články o nejnovější verzi Pythonu 3.14 se na chvíli ohlédněme do prehistorie tohoto programovacího jazyka. Python verze 0.9.1 byl vydán již v roce 1991 (tedy v době DOSu a Windows 3.0), ovšem lze ho přeložit a použít i na moderním 64bitovém operačním systému.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Malé ohlédnutí za historií Pythonu: Python 0.9.1 na moderním hardware</a></p>
<p><a href="#k02">2. Předchůdce Pythonu &ndash; neúspěšný jazyk ABC</a></p>
<p><a href="#k03">3. Od programovacího jazyka ABC k&nbsp;Pythonu</a></p>
<p><a href="#k04">4. Odsazování v&nbsp;ABC a Pythonu</a></p>
<p><a href="#k05">5. Otestování možností Pythonu 0.9.1</a></p>
<p><a href="#k06">6. Příprava na překlad Pythonu 0.9.1</a></p>
<p><a href="#k07">7. Úprava souboru <strong>Makefile</strong></a></p>
<p><a href="#k08">8. Překlad interpretru Pythonu 0.9.1</a></p>
<p><a href="#k09">9. Plnohodnotný interpret Pythonu menší než 200kB?</a></p>
<p><a href="#k10">10. Oprava chyby v&nbsp;implementaci operátoru pro součin dvou hodnot</a></p>
<p><a href="#k11">11. Realizace algoritmu bublinkového řazení pro moderní Python</a></p>
<p><a href="#k12">12. Přepis algoritmu pro Python 0.9.1</a></p>
<p><a href="#k13">13. Vizuální porovnání obou variant: verze pro moderní Python vs. verze pro 34 let starý překladač</a></p>
<p><a href="#k14">14. Porovnání rychlosti moderního interpretru s&nbsp;jeho 34 let starou variantou</a></p>
<p><a href="#k15">15. Základní vlastnosti Pythonu 0.9.1</a></p>
<p><a href="#k16">16. Numerické konstanty</a></p>
<p><a href="#k17">17. Definice třídy</a></p>
<p><a href="#k18">18. Definice funkcí a základní programové konstrukce</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Malé ohlédnutí za historií Pythonu: Python 0.9.1 na moderním hardware</h2>

<p>Před několika týdny byla oficiálně vydána nejnovější verze interpretru
Pythonu, která nese číslo 3.14. Samotný Python ovšem není v&nbsp;oblasti
programovacích jazyků žádným nováčkem, protože jeho první varianty vyšly již na
začátku roku 1991, tedy před více než 34 lety! V&nbsp;tomto článku si
vyzkoušíme přeložit interpret Pythonu 0.9.1, což je prakticky nejstarší
dostupná verze Pythonu vůbec (první verze s&nbsp;číslem 0.9.0 se možná již
z&nbsp;internetů ztratila). Zajímavé je, že Python 0.9.1 je stále (i když
s&nbsp;malými změnami) přeložitelný a bude pracovat i na moderních 64bitových
operačních systémech (což je vzhledem k&nbsp;posunu architektur CPU od
16bitových k&nbsp;64bitovým registrům atd.&nbsp;poměrně unikátní).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Předchůdce Pythonu &ndash; neúspěšný jazyk ABC</h2>

<p><i>&bdquo;I remembered all my experience and some of my frustration with
ABC. I decided to try to design a simple scripting language that possessed some
of ABC's better properties, but without its problems. So I started typing. I
created a simple virtual machine, a simple parser, and a simple runtime. I made
my own version of the various ABC parts that I liked. I created a basic syntax,
used indentation for statement grouping instead of curly braces or begin-end
blocks, and developed a small number of powerful data types: a hash table (or
dictionary, as we call it), a list, strings, and numbers.&ldquo;</i></p>

<p>Pro většinu čtenářů tohoto článku nebude s&nbsp;velkou pravděpodobností
příliš velkým překvapením konstatování, že autorem programovacího jazyka Python
je <a href="https://gvanrossum.github.io/">Guido van Rossum</a>. Před popisem
vývoje samotného Pythonu se však musíme nejprve zmínit o jeho ideovém
předchůdci, jimž je <a
href="https://homepages.cwi.nl/~steven/abc/">programovací jazyke ABC</a>. Vývoj
jazyka ABC začal již v&nbsp;polovině osmdesátých let minulého století
v&nbsp;CWI. Pravě na vývoji tohoto jazyka pracoval mj.&nbsp;i Guido; tehdy na
juniorské pozici a ve vývojovém týmu společně s&nbsp;Lambertem Meertensem, Leo
Geurtsem a Stevenem Pembertonem. Cílem tohoto týmu bylo vytvořit programovací
jazyk dobře použitelný i lidmi, kteří sice nejsou profesionálními programátory,
ale aplikace potřebují vytvářet a nějakým způsobem udržovat. Jednou
z&nbsp;cílových skupin byli pochopitelně vědci (a právě zaměřením mj.&nbsp;i na
neprofesionály je známý moderní Python).</p>

<p>Jen pro připomenutí dobových reálií &ndash; v&nbsp;polovině osmdesátých let
minulého století došlo k&nbsp;obrovskému rozvoji v&nbsp;oblasti osmibitových
domácích mikropočítačů i šestnáctibitových osobních mikropočítačů. A především
domácím mikropočítačům kraloval jiný programovací jazyk určený pro širokou
veřejnost a nikoli pro profesionály &ndash; <a
href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">BASIC</a>.</p>

<img src="http://i.iinfo.cz/images/403/pc115-9.png" width="336" height="240" alt=" " />
<p><i>Obrázek 1: Práce s&nbsp;numerickými proměnnými a poli v&nbsp;BASICU.
Povšimněte si, že na řádku 50 se do proměnné A vloží hodnota 0 a současně se
vytvoří numerické proměnné B a C inicializované na nulu. Dále se na řádku 70
vytvoří desetiprvkové pole, na řádku 80 se nastaví hodnota prvního prvku tohoto
pole na 42 a na řádku 100 se vypíše hodnota zdánlivě neinicializovaného prvku
číslo 2 (který je ve skutečnosti automaticky nastaven na nulu).</i></p>

<p>Jenže na rozdíl od (většinou) nestrukturovaného BASICu, který navíc nabízel
pouze základní datové typy (typicky pouze čísla, řetězce, jednorozměrná pole,
matice) byl programovací jazyk ABC navržen odlišným, dnes bychom řekli, že
mnohem modernějším způsobem (zdá se, že Meertens dokonce BASIC přímo nesnášel,
jeho motto bylo &bdquo;Stamp out Basic!&ldquo;). Ostatně podívejme se na
jednoduchý příklad programu zapsaného v&nbsp;syntaxi jazyka ABC, který získá
všechna slova ze vstupního dokumentu. Můžeme zde vidět velkou podobnost
s&nbsp;pozdějším Pythonem &ndash; odsazování je součástí syntaxe, používání
dvojteček, programová smyčka typu for-each, použití operátoru not.in atd:</p>

<pre>
HOW TO RETURN words document:
   PUT {} IN collection
   FOR line IN document:
      FOR word IN split line:
         IF word not.in collection:
            INSERT word IN collection
   RETURN collection
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>HOW TO RETURN</strong> definuje
novou funkci, tj.&nbsp;jedná se o obdobu dnešního <strong>def</strong>.
Referenční příručka celého jazyka ABC je dostupná na stránce <a
href="https://homepages.cwi.nl/~steven/abc/qr.html">https://homepages.cwi.nl/~steven/abc/qr.html</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Od programovacího jazyka ABC k&nbsp;Pythonu</h2>

<p>Ovšem už při vývoji jazyka ABC se ukázalo, že svět informatiky nebyl na
tento programovací jazyk připraven (někdo by řekl, že se jednalo o špatné
načasování vstupu na trh). Na mikropočítačích s&nbsp;relativně malými
systémovými zdroji nebylo možné potenciálu ABC využít (navíc mu konkuroval
BASIC, o kterém vycházely desítky, možná i stovky knížek a který byl díky
uložení v&nbsp;ROM logicky prvním jazykem většiny začátečníků &ndash; včetně
autora tohoto článku) a na druhé straně výkonnostního spektra, tedy na
počítačích s&nbsp;UNIXem, se již používaly odlišné skriptovací jazyky,
například Tcl (1988) a Perl (1987); na strojích IBM se naproti tomu používal <a
href="https://www.root.cz/clanky/historie-vyvoje-textovych-editoru-xedit-a-programovaci-jazyk-rexx/#k06">jazyk
Rexx</a> (1979), ze kterého se na Amize vyvinul <a
href="https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-51-cast-dalsi-vyvojove-nastroje-dostupne-pro-mikropocitace-amiga/#k04">jazyk
ARexx</a>.</p>

<p>Nicméně i přes relativní neúspěch jazyka ABC nebyly základní myšlenky
ztraceny, protože je později Guido van Rossum použil právě při implementaci
první verze Pythonu, který z&nbsp;jazyka ABC v&nbsp;mnoha ohledech
vycházel.</p>

<p>Prvotní verze Pythonu (před oficiální verzí 1.0) jsou vypsány
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Verze</th><th>Datum vydání</th></tr>
<tr><td>0.9.0</td><td>20. února 1991</td></tr>
<tr><td>0.9.1</td><td>konec února 1991</td></tr>
<tr><td>0.9.2</td><td>podzim 1991</td></tr>
<tr><td>0.9.4</td><td>24. prosince 1991</td></tr>
<tr><td>0.9.5</td><td>2. ledna 1992</td></tr>
<tr><td>0.9.6</td><td>6. dubna 1992</td></tr>
<tr><td>0.9.8</td><td>9. ledna 1993</td></tr>
<tr><td>0.9.9</td><td>29. července 1993</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Odsazování v&nbsp;ABC a Pythonu</h2>

<p>Zkušenější programátoři, kteří se seznamují s&nbsp;programovacím jazykem
Python, bývají poměrně často překvapeni tím, že součástí syntaxe tohoto jazyka
je i odsazení; navíc se na začátku bloků používá dvojtečka (naopak začátečníci,
kteří jiný jazyk neznají, tento fakt většinou zcela přirozeně přijmou, což mám
několikrát ověřeno v&nbsp;praxi). Kde se vlastně tento neobvyklý zápis programů
objevil? Ještě před samotným jazykem ABC bylo vytvořeno několik jeho předchůdců
označovaných písmenem B a číslovkou (B0, B1, ...). A již v&nbsp;B0 se objevilo
<i>povinné</i> odsazování, které zde mělo význam sdružení operací do bloků.
Ovšem samotné bloky tehdy byly uvozeny klíčovými slovy <strong>BEGIN</strong> a
<strong>END</strong>. Plánovalo se, že díky použití klíčových slov bude
odsazování prováděno automaticky ve specializovaném programátorském textovém
editoru (a to se stále pohybujeme na začátku devadesátých let minulého
století).</p>

<p><div class="rs-tip-major">Poznámka: tato klíčová slova známe i
z&nbsp;Pascalu nebo programovacího jazyka Lua. Ovšem v&nbsp;těchto jazycích
není odsazování striktně vyžadováno, na rozdíl od jazyka B.</div></p>

<a href="https://www.root.cz/obrazek/368436/"><img src="https://i.iinfo.cz/images/238/tp03-6-prev.png" class="image-368436" alt="&#160;" width="370" height="219" /></a>
<p><i>Obrázek 2: Nepovinné, ovšem pochopitelně doporučené odsazování
v&nbsp;Pascalu, resp.&nbsp;zde konkrétně ve slavném Turbo Pascalu.</i></p>

<p>Ovšem poté si tvůrci jazyka B0 uvědomili, že vyžadovat odsazení a současně
navíc i použití klíčových slov <strong>BEGIN</strong> a <strong>END</strong> je
vlastně nadbytečné a proto v&nbsp;jazyce B1 (tedy ve druhé generaci jazyka B)
již chybělo klíčové slovo <strong>BEGIN</strong>. Namísto <strong>END</strong>
se používalo spojení <strong>END IF</strong>, <strong>END FOR</strong> atd. (to
tedy znamená, že podmínky a smyčky automaticky vytvářely bloky, což je podle
mého skromného názoru poměrně dobrý způsob strukturování programů). A nakonec
se v&nbsp;jazyce B2 programátoři &bdquo;museli&ldquo; zcela obejít bez zápisu
začátků a konců bloků pomocí klíčových slov &ndash; vše bylo vyřešeno pouhým
odsazením.</p>

<p><div class="rs-tip-major">Poznámka: odsazení pro specifikaci bloků se
používalo i v&nbsp;jiných jazycích (Miranda atd.), ovšem jazyk B byl
pravděpodobně prvním jazykem, kde k&nbsp;této implementaci došlo.</div></p>

<p>Dalším typickým prvkem programovacího jazyka B (a posléze ABC a Pythonu) je
dvojtečka zapisovaná před začátkem bloku. Myšlenka použít dvojtečku vznikla
v&nbsp;roce 1978, kdy Robert Dewar, Peter King, Jack Schwartz a náš starý známý
Lambert Meertens navrhovali syntaxi jazyka B a porovnávali různě zápisy bubble
sortu. Nakonec zavolali manželku Roberta Dewara a zeptali se jí, zda se jí
navržená varianta líbí. Ta odpověděla, že má pocit, že se zápis &bdquo;FOR i
...&ldquo; vztahuje pouze k&nbsp;jednomu řádku a nikoli k&nbsp;celému bloku pod
tímto řádkem. A právě na základě tohoto alfa testingu návrhu jazyka bylo
rozhodnuto před začátkem bloku používat dvojtečku, což Pythonu vydrželo až do
dneška.</p>

<p><div class="rs-tip-major">Poznámka: to vlastně znamená, že dvojtečka před
začátkem bloku (namísto závorek či klíčových slov) není v&nbsp;žádném případě
novým a neobvyklým vynálezem; je s&nbsp;námi v&nbsp;IT již plných 47
let.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Otestování možností Pythonu 0.9.1</h2>

<p>Tento článek není zaměřen pouze na popis historie vývoje programovacího
jazyka Python. Ukážeme si i použití dnes již značně historického interpretru
Python 0.9.1 na moderním hardware. Zajímavé je, že i tak starý zdrojový kód (má
již 34 let), který byl určen pro šestnáctibitové a 32bitové systémy a překládán
byl relativně jednoduchými překladači jazyka C, je možné přeložit moderním
překladačem céčka pro 64bitový operační systém &ndash; a výsledek bude stále
funkční a dokonce do značné míry kompatibilní s&nbsp;moderními variantami
programovacího jazyka Python.</p>

<p>V&nbsp;rámci dalších kapitol si popíšeme způsob překladu Pythonu 0.9.1 a
opravu jedné chyby v&nbsp;interpretru. Dále si ukážeme jednoduchý benchmark,
kterým porovnáme rychlost interpretace kódu v&nbsp;Pythonu 0.9.1
v&nbsp;porovnání s&nbsp;moderním Pythonem 3.13 (resp.&nbsp;dnes vlastně 3.14).
A nakonec si ukážeme některé rozdíly v&nbsp;syntaxi Pythonu.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Příprava na překlad Pythonu 0.9.1</h2>

<p>Nejprve je nutné získat zdrojové kódy Pythonu 0.9.1, které se pokusíme
přeložit moderním překladačem jazyka C. Tyto zdrojové kódy lze nalézt na adrese
<a
href="https://www.python.org/ftp/python/src/Python-0.9.1.tar.gz">https://www.python.org/ftp/python/src/Python-0.9.1.tar.gz</a>,
i když existuje i několik repositářů, které je ve více či méně původní podobě
obsahují taktéž.</p>

<p>Nejprve stáhneme tarball se zdrojovými kódy:</p>

<pre>
$ <strong>wget https://www.python.org/ftp/python/src/Python-0.9.1.tar.gz</strong>

Saving 'Python-0.9.1.tar.gz'
HTTP response 200  [https://www.python.org/ftp/python/src/Python-0.9.1.tar.gz]
Python-0.9.1.tar.gz  100% [=====================================================================================&gt;]  378.07K    --.-KB/s
                      [Files: 1  Bytes: 378.07K [665.62KB/s] Redirects: 0  Todo: 0  Errors: 0                ]
</pre>

<p>Tarball běžným způsobem rozbalíme:</p>

<pre>
$ <strong>tar xvfz Python-0.9.1.tar.gz </strong>
&nbsp;
python-0.9.1/
python-0.9.1/demo/
python-0.9.1/demo/README
python-0.9.1/demo/scripts/
python-0.9.1/demo/scripts/findlinksto.py
python-0.9.1/demo/scripts/mkreal.py
...
...
...
python-0.9.1/src/To.do
python-0.9.1/src/token.h
python-0.9.1/src/tokenizer.c
python-0.9.1/src/tokenizer.h
python-0.9.1/src/traceback.c
python-0.9.1/src/traceback.h
python-0.9.1/src/tupleobject.c
python-0.9.1/src/tupleobject.h
python-0.9.1/src/typeobject.c
python-0.9.1/src/xxobject.c
</pre>

<p>Po rozbalení tarballu by měl vzniknout adresář <strong>python-0.9.1</strong>
s&nbsp;následující strukturou podadresářů:</p>

<pre>
├── demo
│   ├── scripts
│   ├── sgi
│   │   ├── audio
│   │   ├── audio_stdwin
│   │   ├── gl
│   │   └── gl_panel
│   │       ├── apanel
│   │       ├── flying
│   │       ├── nurbs
│   │       └── twoview
│   └── stdwin
├── doc
├── lib
└── src
</pre>

<p>Samotné zdrojové kódy interpretru Pythonu jsou, společně s&nbsp;pomocnými
soubory, uloženy do podadresáře <strong>src</strong>, do kterého se
přepneme:</p>

<pre>
$ cd python-0.9.1/src
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úprava souboru <strong>Makefile</strong></h2>

<p>Aby bylo možné interpret Pythonu 0.9.1 přeložit i moderním překladačem C,
který se v&nbsp;mnoha ohledech liší od dobového &bdquo;céčka&ldquo;, musíme do
souboru <strong>Makefile</strong> přidat definici několika přepínačů céčka,
které umožní překlad kódu s&nbsp;implicitně definovanými funkcemi
(tj.&nbsp;funkcemi bez předběžné definice), umožní pracovat s&nbsp;navzájem
nekompatibilními ukazateli atd.:</p>

<pre>
CFLAGS=-Wno-implicit-function-declaration -Wno-incompatible-pointer-types -Wno-implicit-int
</pre>

<p>Dále je nutné upravit příkaz použitý pro cíl <strong>python</strong>
(odstraní se zavináč atd.):</p>

<pre>
python:                libpython.a $(OBJECTS) $(LIBDEPS) Makefile
    $(CC) $(CFLAGS) $(OBJECTS) $(LIBS) -o python
</pre>

<p>Patch, který je možné aplikovat na původní Makefile (tedy na soubor získaný
z&nbsp;tarballu), vypadá následovně:</p>

<pre>
--- Makefile    2009-03-27 01:23:41.000000000 +0100
+++ /tmp/ramdisk/python-0.9.1-/src/Makefile     2025-10-18 17:33:35.054267113 +0200
@@ -56,6 +56,8 @@
#RANLIB =      true    # For System V
RANLIB =       ranlib  # For BSD
&nbsp; 
+CFLAGS=-Wno-implicit-function-declaration -Wno-incompatible-pointer-types -Wno-implicit-int
+
# If your system doesn't have symbolic links, uncomment the following
# line.
&nbsp;
@@ -380,8 +382,7 @@
# ============
&nbsp;
python:                libpython.a $(OBJECTS) $(LIBDEPS) Makefile
-       $(CC) $(CFLAGS) $(OBJECTS) $(LIBS) -o @python
-       mv @python python
+       $(CC) $(CFLAGS) $(OBJECTS) $(LIBS) -o python
&nbsp; 
libpython.a:   $(LIBOBJECTS)
    -rm -f @lib
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Překlad interpretru Pythonu 0.9.1</h2>

<p>Nyní se již můžeme pokusit o překlad interpretru Pythonu 0.9.1. Postačuje
zadat příkaz <strong>make</strong> (nepoužívá se <strong>./configure</strong>;
život vývojáře býval jednodušší a dobrodružnější):</p>

<pre>
$ <strong>make</strong>
</pre>

<p>Moderní překladač céčka si sice bude na mnoha místech stěžovat, že se volají
funkce bez předběžné definice, používají se nesprávné datové typy při volání
funkcí atd., ovšem překlad by se měl nakonec dokončit bez chyby:</p>

<pre>
cc -Wno-implicit-function-declaration -Wno-incompatible-pointer-types -Wno-implicit-int   -c -o acceler.o acceler.c
In file included from pgenheaders.h:48,
             from acceler.c:36:
malloc.h:59:13: warning: conflicting types for built-in function ‘malloc’; expected ‘void *(long unsigned int)’ [-Wbuiltin-declaration-mismatch]
59 | extern ANY *malloc PROTO((unsigned int));
  |             ^~~~~~
malloc.h:1:1: note: ‘malloc’ is declared in header ‘&lt;stdlib.h&gt;’
+++ |+#include &lt;stdlib.h&gt;
1 | /***********************************************************
malloc.h:60:13: warning: conflicting types for built-in function ‘calloc’; expected ‘void *(long unsigned int,  long unsigned int)’ [-Wbuiltin-declaration-mismatch]
...
...
...
pythonmain.c: In function ‘fatal’:
pythonmain.c:349:8: warning: incompatible implicit declaration of built-in function ‘abort’ [-Wbuiltin-declaration-mismatch]
349 |        abort();
  |        ^~~~~
pythonmain.c:349:8: note: include ‘&lt;stdlib.h&gt;’ or provide a declaration of ‘abort’
pythonmain.c: In function ‘goaway’:
pythonmain.c:385:8: warning: incompatible implicit declaration of built-in function ‘exit’ [-Wbuiltin-declaration-mismatch]
385 |        exit(sts);
  |        ^~~~
pythonmain.c:385:8: note: include ‘&lt;stdlib.h&gt;’ or provide a declaration of ‘exit’
cc -c -Wno-implicit-function-declaration -Wno-incompatible-pointer-types -Wno-implicit-int      '-DPYTHONPATH=".:/usr/local/lib/python:/ufs/guido/lib/python:../lib"'  config.c
cc -Wno-implicit-function-declaration -Wno-incompatible-pointer-types -Wno-implicit-int pythonmain.o config.o libpython.a      -lm -o python
</pre>

<p><div class="rs-tip-major">Poznámka: dnes bychom se na projekt, který při
překladu vypisuje tolik varování, asi dívali hodně nedůvěřivě. Ovšem dobové
překladače céčka byly tolerantní a prováděly přesně to, co bylo zapsáno (a
někdy i to, co skutečně vývojář chtěl implementovat).</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Plnohodnotný interpret Pythonu menší než 200kB?</h2>

<p>Výsledkem překladu, který mimochodem na moderním HW trvá jen několik sekund,
je spustitelný soubor <strong>python</strong>; v&nbsp;mém konkrétním případě
soubor pro 64bitovou (!) platformu x86-64:</p>

<pre>
$ <strong>file python</strong>
&nbsp;
python: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=494acb46ee8b972e65311ff0b8aa63e519422456, for GNU/Linux 3.2.0, not stripped
</pre>

<p>Tento soubor má velikost necelých 200kB, což je v&nbsp;ostrém kontrastu
s&nbsp;moderními interpretry Pythonu, v&nbsp;nichž velikost interpretru
dosahuje 39MB, což je více než 200&times; více:</p>

<pre>
-rwxr-xr-x. 1 ptisnovs ptisnovs 185504 Oct 21 18:15 python
</pre>

<p>Interpret Pythonu, který jsme získali, je pojat velmi minimalisticky a
například neakceptuje prakticky žádné přepínače (jen -s a -display) a
pochopitelně neobsahuje ani nápovědu:</p>

<pre>
$ <strong>./python --help</strong>
python: can't open file '--help'
</pre>

<p>Otestujeme, zda interpret skutečně pracuje:</p>

<pre>
$ <strong>./python</strong>
&gt;&gt;&gt; 
</pre>

<p>Výrazy se ihned interaktivně vyhodnocují, naprosto stejně, jako je tomu i
dnes:</p>

<pre>
&gt;&gt;&gt; <strong>1+2</strong>
3
&gt;&gt;&gt; 
</pre>

<p><div class="rs-tip-major">Poznámka: interpret se ukončuje klávesovou
zkratkou <strong>Ctrl+D</strong>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Oprava chyby v&nbsp;implementaci operátoru pro součin dvou hodnot</h2>

<p>Pokusme se v&nbsp;interpretru Pythonu 0.9.1 vypočítat součin 6&times;7:</p>

<pre>
$ <strong>./python</strong>
&gt;&gt;&gt; <strong>6*7</strong>
&nbsp;
Unhandled exception: run-time error: integer overflow
Stack backtrace (innermost last):
File "&lt;stdin&gt;", line 1
&gt;&gt;&gt;
</pre>

<p>Zajímavé je, že tento jednoduchý výpočet nebyl dokončen, protože skončil
běhovou chybou. Je tomu tak z&nbsp;toho důvodu, že se ve zdrojovém kódu
interpretru špatně detekuje přetečení výsledku operace součinu. Používá se zde
přetypování vypočtené hodnoty na <strong>long</strong>, ovšem tento typ nemá
přesně definovánu bitovou šířku a tudíž se zde projevuje vliv moderních
překladačů jazyka C. Oprava je snadná &ndash; v&nbsp;souboru
<strong>intobject.c</strong> je nutné namísto <strong>long</strong> použít
například přenositelný <strong>int32_t</strong>:</p>

<pre>
static object *
int_mul(v, w)
   intobject *v;
   register object *w;
{
   register long a, b;
   double x;
   if (!is_intobject(w)) {
           err_badarg();
           return NULL;
   }
   a = v-&gt;ob_ival;
   b = ((intobject *)w) -&gt; ob_ival;
   x = (double)a * (double)b;
   if (x &gt; 0x7fffffff || x &lt; (double) (<strong>int32_t</strong>) 0x80000000)
           return err_ovf();
   return newintobject(a * b);
}
</pre>

<p>Příslušný patch vypadá následovně:</p>

<pre>
--- intobject.c 2009-03-27 00:59:41.000000000 +0100
+++ /tmp/ramdisk/python-0.9.1/src/intobject.c   2025-10-21 18:22:17.740699911 +0200
@@ -22,6 +22,8 @@
&nbsp;
******************************************************************/
&nbsp;
+#include &lt;stdint.h&gt;
+
/* Integer object implementation */
&nbsp;
#include "allobjects.h"
@@ -197,7 +199,7 @@
    a = v-&gt;ob_ival;
    b = ((intobject *)w) -&gt; ob_ival;
    x = (double)a * (double)b;
-       if (x &gt; 0x7fffffff || x &lt; (double) (long) 0x80000000)
+       if (x &gt; 0x7fffffff || x &lt; (double) (int32_t) 0x80000000)
            return err_ovf();
    return newintobject(a * b);
}
</pre>

<p>Po aplikaci patche je nutné interpret znovu přeložit. Nyní již bude vše plně
funkční:</p>

<pre>
$ <strong>./python</strong>
&gt;&gt;&gt; <strong>6*7</strong>
42
&gt;&gt;&gt;
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Realizace algoritmu bublinkového řazení pro moderní Python</h2>

<p>V&nbsp;další části článku se pokusíme o zjištění, jak rychlé jsou moderní
interpretry Pythonu oproti jeho nejstarší dostupné verzi, tj.&nbsp;0.9.1.
Připravíme si jednoduchý benchmark, ve kterém je realizován algoritmus
bublinkového řazení. Tento algoritmus (a vlastně i celý program) jsem schválně
napsal takovým způsobem, aby byl snadno transformovatelný do podoby
kompatibilní s&nbsp;Pythonem 0.9.1:</p>

<pre>
import random
import time
&nbsp;
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = []
    for i in range(size):
        a.append(random.randint(0, 2**15))
    for i in range(size - 1, 0, -1):
        for j in range(i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
    for i in range(size-1):
        if a[i] &gt; a[i+1]:
            print("FAIL")
&nbsp;
t1 = time.time()
&nbsp;
bubble_sort(30000)
&nbsp;
t2 = time.time()
&nbsp;
print("Total time:", t2-t1)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Přepis algoritmu pro Python 0.9.1</h2>

<p>Pokusme se tento benchmark přepsat do podoby kompatibilní s&nbsp;Pythonem
0.9.1. Je nutné provést několik změn:</p>

<ol>

<li>namísto modulu <strong>random</strong> se použije modul nazvaný
<strong>rand</strong> (náhodná čísla schválně generujeme v&nbsp;rozsahu
0..32767), abychom dostali stejný rozsah hodnot.</li>

<li><strong>print</strong> se zapisuje jako příkaz, nikoli jako volání
funkce.</li>

<li>řetězce musí být uzavřeny do apostrofů, nikoli do uvozovek.</li>

</ol>

<p>Výsledný program bude vypadat následovně:</p>

<pre>
import rand
import time
&nbsp;
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = []
    for i in range(size):
        a.append(rand.rand())
    for i in range(size - 1, 0, -1):
        for j in range(i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
    for i in range(size-1):
        if a[i] &gt; a[i+1]:
            print 'FAIL'
&nbsp;
t1 = time.time()
&nbsp;
bubble_sort(30000)
&nbsp;
t2 = time.time()
&nbsp;
print 'Total time:', t2-t1
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Vizuální porovnání obou variant: verze pro moderní Python vs. verze pro 34 let starý překladač</h2>

<p>Pro zajímavost se podívejme, jak málo změn je vlastně nutné provést ve
výpočtu tak, aby byl zdrojový kód kompatibilní s&nbsp;více než 34 let starým
interpretrem. Liší se způsob výpočtu pseudonáhodných čísel,
<strong>print</strong> byl původně příkazem a nikoli funkcí, řetězce musí být
zapisovány do apostrofů &ndash; a to je vlastně vše:</p>

<pre>
import random                                      import rand
import time                                        import time
&nbsp;
&nbsp;
def bubble_sort(size):                             def bubble_sort(size):
    a = []                                             a = []
    for i in range(size):                              for i in range(size):
        a.append(random.randint(0, 2**15))                 a.append(rand.rand())
    for i in range(size - 1, 0, -1):                   for i in range(size - 1, 0, -1):
        for j in range(i):                                 for j in range(i):
            if a[j] &gt; a[j + 1]:                                if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]                    a[j], a[j + 1] = a[j + 1], a[j]
    for i in range(size-1):                            for i in range(size-1):
        if a[i] &gt; a[i+1]:                                  if a[i] &gt; a[i+1]:
            print("FAIL")                                      print 'FAIL'
&nbsp;
t1 = time.time()                                   t1 = time.time()
&nbsp;
bubble_sort(30000)                                 bubble_sort(30000)
&nbsp;
t2 = time.time()                                   t2 = time.time()
&nbsp;
print("Total time:", t2-t1)                        print 'Total time:', t2-t1
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Porovnání rychlosti moderního interpretru s&nbsp;jeho 34 let starou variantou</h2>

<p>V&nbsp;deváté kapitole jsme si řekli, že interpret Pythonu 0.9.1 je cca
200&times; menší, než interpret moderního Pythonu (což ovšem ani zdaleka není
férové srovnání). Ovšem zajímavé bude porovnat i rychlosti obou variant
interpretrů. Použijeme benchmarky s&nbsp;realizací algoritmu bublinkového
řazení s&nbsp;těmito výsledky:</p>

<table>
<tr><th>Python 0.9.1</th><th>Python 3.13</th><th>Zrychlení</th></tr>
<tr><td>189</td><td>54</td><td>3,5&times;</td></tr>
<tr><td>188</td><td>53</td><td>3,5&times;</td></tr>
<tr><td>189</td><td>54</td><td>3,5&times;</td></tr>
<tr><td>189</td><td>55</td><td>3,4&times;</td></tr>
<tr><td>188</td><td>54</td><td>3,4&times;</td></tr>
<tr><td>187</td><td>53</td><td>3,5&times;</td></tr>
<tr><td>187</td><td>56</td><td>3,3&times;</td></tr>
<tr><td>193</td><td>58</td><td>3,3&times;</td></tr>
<tr><td>187</td><td>57</td><td>3,2&times;</td></tr>
</table>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 720px"><a href="https://www.root.cz/obrazek/1235694/"><img src="https://i.iinfo.cz/images/530/old-python-speed-large.png" class="image-1235694" width="720" height="446" data-prev-filename="https://i.iinfo.cz/images/530/old-python-speed-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/530/old-python-speed-prev.webp" data-prev-width="370" data-prev-height="229" data-large-filename="https://i.iinfo.cz/images/530/old-python-speed-large.png" data-large-filename-webp="https://i.iinfo.cz/images/530/old-python-speed-large.webp" data-large-width="720" data-large-height="446" alt="Porovnání rychlosti Pythonu 0.9.1 s Pythonem 3.13" data-description="Porovnání rychlosti Pythonu 0.9.1 s Pythonem 3.13" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 720px" /></a><p>Obrázek 3: Porovnání rychlosti Pythonu 0.9.1 s Pythonem 3.13<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>Z&nbsp;naměřených výsledků je patrné, že došlo k&nbsp;přibližně 3,5
násobnému zrychlení (popravdě bych očekával ještě větší zrychlení,
resp.&nbsp;přesněji řečeno konkurenční technologie, například JVM, se zrychlily
mnohem více).</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Základní vlastnosti Pythonu 0.9.1</h2>

<p>Pro čtenáře tohoto článku pravděpodobně nebude velkým překvapením, když
napíšeme, že se programovací jazyk Python postupně vyvíjí a že některé jeho
verze mezi sebou nejsou (resp.&nbsp;nemusí být) plně kompatibilní. Mohlo by se
tedy zdát, že Python 0.9.1 bude v&nbsp;porovnání s&nbsp;moderními Pythony již
na první pohled zcela odlišný programovací jazyk. Samozřejmě k&nbsp;několika
změnám v&nbsp;syntaxi a sémantice došlo, ale kupodivu jich není příliš mnoho,
což si ostatně ukážeme v&nbsp;několika demonstračních příkladech popsaných
v&nbsp;navazujících třech kapitolách.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Numerické konstanty</h2>

<p>V&nbsp;moderním Pythonu lze používat celočíselné hodnoty s&nbsp;neomezeným
rozsahem, hodnoty s&nbsp;plovoucí řádovou čárkou i komplexní čísla:</p>

<pre>
<i># int/long</i>
print(42)
print(100000000000000000000000000000000000000000000000000000)
&nbsp;
<i># float</i>
print(3.1415)
print(1.2e10)
print(3e-3)
print(-3e-3)
&nbsp;
<i># complex</i>
print(2 + 3j)
print(1.5 + 2.8j)
print(1e10 + 3e-5j)
</pre>

<p>Python 0.9.1 podporuje jen celočíselné typy s&nbsp;omezeným rozsahem a typ
s&nbsp;plovoucí řádovou čárkou:</p>

<pre>
<i># int/long</i>
print(42)
print(100000000000000000000000000000000000000000000000000000)
&nbsp;
<i># float</i>
print(3.1415)
print(1.2e10)
print(3e-3)
print(-3e-3)
</pre>

<p>Povšimněte si, že je sice možné načíst &bdquo;neomezené&ldquo; celé číslo,
ale interně dojde k&nbsp;jeho omezení na <strong>long</strong> (což vlastně
máme štěstí &ndash; původně se totiž jednalo jen o 32bitový rozsah):</p>

<pre>
42
9223372036854775807
3.1415
12000000000.0
0.003
-0.003
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Definice třídy</h2>

<p>Definice třídy v&nbsp;moderním Pythonu vypadá následovně:</p>

<pre>
class <strong>Employee</strong>:
&nbsp;
    def <strong>__init__</strong>(self, first_name, surname, salary):
        self._first_name = first_name
        self._surname = surname
        self._salary = salary
&nbsp;
e = Employee()
</pre>

<p>V&nbsp;Pythonu 0.9.1 se musí explicitně zapisovat předek
<strong>Object</strong> a taktéž se v&nbsp;definici třídy nesmí objevit prázdné
řádky (to ovšem ani v&nbsp;definici funkce):</p>

<pre>
class <strong>Employee</strong>(Object):
    def <strong>__init__</strong>(self, first_name, surname, salary):
        self._first_name = first_name
        self._surname = surname
        self._salary = salary

e = Employee()
</pre>

<p><div class="rs-tip-major">Poznámka: žádné další změny nejsou v&nbsp;tomto
případě zapotřebí!</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Definice funkcí a základní programové konstrukce</h2>

<p>Nepatrně složitější program slouží k&nbsp;výpočtu BMI na základě
interaktivně zadaných vstupů. Verze pro moderní verze Pythonu může vypadat
následovně:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># encoding=utf-8</i>
&nbsp;
<i>"""Body Mass Index calculator."""</i>
&nbsp;
import sys
&nbsp;
&nbsp;
def <strong>compute_bmi</strong>(mass, height):
    <i>"""Vlastní výpočet BMI za základě hmotnosti a výšky."""</i>
    height = height / 100.0
    bmi = mass / (height * height)
    return bmi
&nbsp;
&nbsp;
print("Mass (kg): ")
mass = int(input())
&nbsp;
<i># kontrola na špatný vstup</i>
if mass &lt; 0:
    print("Invalid input")
    sys.exit(1)
&nbsp;
print("Height (cm): ")
height = int(input())
&nbsp;
<i># kontrola na špatný vstup</i>
if height &lt; 0:
    print("Invalid input")
    sys.exit(1)
&nbsp;
<i># výpočet výsledku a výpis na obrazovku</i>
print("BMI = ", compute_bmi(mass, height))
</pre>

<p>Verze stejného programu, nyní ovšem pro Python 0.9.1 se v&nbsp;několika
ohledech liší. Nepoužíváme dokumentační řetězce, ostatní řetězce jsou
zapisovány do apostrofů, namísto funkce <strong>print</strong> se používá
příkaz <strong>print</strong> a navíc není povoleno v&nbsp;jednom výrazu použít
celočíselnou proměnnou a hodnotou či proměnnou typu <i>double</i>, takže je
konverze provedena explicitně přímo ve zdrojovém kódu. A opět &ndash; žádné
další změny nejsou nutné!:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># encoding=utf-8</i>
&nbsp;
import sys
&nbsp;
&nbsp;
def <strong>compute_bmi</strong>(mass, height):
    height = float(height)
    height = height / 100.0
    bmi = float(mass) / (height * height)
    return bmi
&nbsp;
&nbsp;
print 'Mass (kg): '
mass = int(input())
&nbsp;
<i># kontrola na špatný vstup</i>
if mass &lt; 0:
    print 'Invalid input'
    sys.exit(1)
&nbsp;
print 'Height (cm): '
height = int(input())
&nbsp;
<i># kontrola na špatný vstup</i>
if height &lt; 0:
    print 'Invalid input'
    sys.exit(1)
&nbsp;
<i># výpočet výsledku a výpis na obrazovku</i>
print 'BMI = ', compute_bmi(mass, height)
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady jsou vypsány v&nbsp;následující
tabulce:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td>1</td><td>numbers_modern.py</td><td>číselné konstanty: varianta pro moderní Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/numbers_modern.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/numbers_modern.py</a></td></tr>
<tr><td>2</td><td>numbers_old.py</td><td>číselné konstanty: varianta pro Python 0.9.1</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/numbers_old.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/numbers_old.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>class_modern.py</td><td>definice třídy: varianta pro moderní Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/class_modern.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/class_modern.py</a></td></tr>
<tr><td>4</td><td>class_old.py</td><td>definice třídy: varianta pro Python 0.9.1</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/class_old.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/class_old.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>bmi_modern.py</td><td>práce s&nbsp;hodnotami a definice funkcí: varianta pro moderní Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/bmi_modern.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/bmi_modern.py</a></td></tr>
<tr><td>6</td><td>bmi_old.py</td><td>práce s&nbsp;hodnotami a definice funkcí: varianta pro Python 0.9.1</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/bmi_old.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/bmi_old.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>bubble_sort_modern.py</td><td>algoritmus bublinkového řazení: varianta pro moderní Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/bubble_sort_modern.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/bubble_sort_modern.py</a></td></tr>
<tr><td>8</td><td>bubble_sort_old.py</td><td>algoritmus bublinkového řazení: varianta pro Python 0.9.1</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/bubble_sort_old.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python0.9.1/bubble_sort_old.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python history: from None to AI<br />
<a href="https://python3.info/about/history.html">https://python3.info/about/history.html</a>
</li>

<li>The History of the Python Language: A Journey Through Time<br />
<a href="https://coderivers.org/blog/history-of-python-language/">https://coderivers.org/blog/history-of-python-language/</a>
</li>

<li>Python - History and Versions<br />
<a href="https://www.tutorialspoint.com/python/python_history.htm">https://www.tutorialspoint.com/python/python_history.htm</a>
</li>

<li>The Evolution of Python: A Detailed History and Major Achievements<br />
<a href="https://www.backendmesh.com/the-evolution-of-python/">https://www.backendmesh.com/the-evolution-of-python/</a>
</li>

<li>History of Python<br />
<a href="https://en.wikipedia.org/wiki/History_of_Python">https://en.wikipedia.org/wiki/History_of_Python</a>
</li>

<li>History of Python<br />
<a href="https://www.geeksforgeeks.org/python/history-of-python/">https://www.geeksforgeeks.org/python/history-of-python/</a>
</li>

<li>Old Python releases<br />
<a href="https://www.python.org/download/releases/">https://www.python.org/download/releases/</a>
</li>

<li>Interactive: The Top Programming Languages 2016 (starší data, pěkný způsob filtrace atd.)<br />
<a href="https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2016">https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2016</a>
</li>

<li>Generational list of programming languages<br />
<a href="https://en.wikipedia.org/wiki/Generational_list_of_programming_languages">https://en.wikipedia.org/wiki/Generational_list_of_programming_languages</a>
</li>

<li>Most Popular Programming Languages on Stack Overflow Bar Chart Race<br />
<a href="https://www.youtube.com/watch?v=cKzP61Gjf00">https://www.youtube.com/watch?v=cKzP61Gjf00</a>
</li>

<li>Další kulaté výročí v IT: dvacet let existence Pythonu 2<br />
<a href="https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/">https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/</a>
</li>

<li>Zdrojové kódy starých verzí Pythonu<br />
<a href="https://legacy.python.org/download/releases/src/">https://legacy.python.org/download/releases/src/</a>
</li>

<li>Python 1.5.2<br />
<a href="https://www.python.org/download/releases/1.5/">https://www.python.org/download/releases/1.5/</a>
</li>

<li>Python 1.6.1<br />
<a href="https://www.python.org/download/releases/1.6.1/">https://www.python.org/download/releases/1.6.1/</a>
</li>

<li>Python 3.14.0<br />
<a href="https://test.python.org/downloads/release/python-3140/">https://test.python.org/downloads/release/python-3140/</a>
</li>

<li>What’s new in Python 3.14 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.14.html">https://docs.python.org/3/whatsnew/3.14.html</a>
</li>

<li>What’s New In Python 3.13 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.13.html">https://docs.python.org/3/whatsnew/3.13.html</a>
</li>

<li>What’s New In Python 3.12 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.12.html">https://docs.python.org/3/whatsnew/3.12.html</a>
</li>

<li>What’s New In Python 3.11 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.11.html">https://docs.python.org/3/whatsnew/3.11.html</a>
</li>

<li>What’s New In Python 3.12<br />
<a href="https://dev.to/mahiuddindev/python-312-4n43">https://dev.to/mahiuddindev/python-312-4n43</a></li>

<li>Python: The Documentary | An origin story<br />
<a href="https://www.youtube.com/watch?v=GfH4QL4VqJ0">https://www.youtube.com/watch?v=GfH4QL4VqJ0</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

