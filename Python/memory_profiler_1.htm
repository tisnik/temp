<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Detekce velikosti hodnot uložených v&nbsp;operační paměti a spravovaných interpretrem Pythonu</a></p>
<p><a href="#k02">2. Standardní funkce <strong>getsizeof</strong> z&nbsp;balíčku <strong>sys</strong></a></p>
<p><a href="#k03">3. Zjištění velikosti hodnot standardních skalárních datových typů Pythonu</a></p>
<p><a href="#k04">4. Velikosti objektů představujících řetězce</a></p>
<p><a href="#k05">5. Zjištění velikosti hodnot uložených do standardních kolekcí Pythonu</a></p>
<p><a href="#k06">6. Velikosti skalárních hodnot i kolekcí</a></p>
<p><a href="#k07">7. Velikosti funkcí v&nbsp;operační paměti zjišťované pomocí <strong>getsizeof</strong></a></p>
<p><a href="#k08">8. Velikosti tříd a objektů zjišťované pomocí <strong>getsizeof</strong></a></p>
<p><a href="#k09">9. Balíček <i>Pympler</i></a></p>
<p><a href="#k10">10. Funkce poskytované balíčkem <strong>pympler.asizeof</strong></a></p>
<p><a href="#k11">11. Funkce <strong>asizeof.asizeof</strong> pro zjištění velikosti hodnot v&nbsp;operační paměti</p>
<p><a href="#k12">12. Zjištění a výpis velikosti skalárních hodnot i kolekcí</a></p>
<p><a href="#k13">*** 13. Zobrazení podrobnější statistiky o velikostech hodnot</a></p>
<p><a href="#k14">*** 14. Získání skutečné velikosti tříd a objektů uložených v&nbsp;operační paměti</a></p>
<p><a href="#k15">*** 15. Balíček <i>memory_profiler</i></a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">17. Proč se tedy liší velikosti hodnot <strong>True</strong> a <strong>False</strong>?</a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Detekce velikosti hodnot uložených v&nbsp;operační paměti a spravovaných interpretrem Pythonu</h2>

<p>Programovací jazyk <a href="https://www.root.cz/n/python/">Python</a> se
v&nbsp;prvních letech své existence používal především pro tvorbu pomocných
systémových a jiných skriptů; jednalo se tedy o (čitelnější) náhradu za Perl,
BASH (či jiný v&nbsp;té době existující shell) a AWK. Ovšem v&nbsp;současnosti
se Python používá i v&nbsp;mnoha dalších oblastech informatiky, mnohdy i pro
tvorbu rozsáhlých aplikací a služeb. A právě ve chvíli, kdy se Python nasazuje
i ve velkých aplikacích popř.&nbsp;pokud se používá pro zpracování dat
s&nbsp;velkým objemem, se často objevují požadavky na snížení paměťové
náročnosti těchto systémů.</p>

<p>Z&nbsp;tohoto důvodu je vhodné alespoň zhruba vědět, jak velké oblasti
paměti jsou obsazeny jednotlivými hodnotami, které se v&nbsp;aplikacích psaných
v&nbsp;Pythonu používají. Jak však zjistit velikost objektů (resp.&nbsp;obecně
řečeno velikost hodnot) uložených v&nbsp;RAM?  K&nbsp;tomuto účelu slouží jedna
funkce ze standardní knihovny a taktéž pomocné balíčky, s&nbsp;nimiž se
postupně seznámíme.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Standardní funkce <strong>getsizeof</strong> z&nbsp;balíčku <strong>sys</strong></h2>

<p>V&nbsp;případě, že postačuje zjistit pouze přibližné nároky jednotlivých
objektů (resp.&nbsp;přesněji řečeno jejich hodnot) na dostupnou kapacitu
operační paměti, není nutné instalovat žádné dodatečné balíčky, protože
podobnou funkci nabízí i funkce <a
href="https://docs.python.org/3/library/sys.html#sys.getsizeof">getsizeof</a>
ze standardního balíčku <a
href="https://docs.python.org/3/library/sys.html">sys</a>:</p>

<pre>
from <strong>sys</strong> import <strong>getsizeof</strong>
&nbsp;
help(<strong>getsizeof</strong>)
</pre>

<p>Nápověda k&nbsp;této funkci je velmi stručná a neobsahuje například
informaci, zda vrácená velikost (v&nbsp;bajtech) je skutečnou velikostí objektu
nebo se vrací velikost bloku paměti alokované pro zkoumaný objekt. To totiž
není totéž &ndash; už jen kvůli zarovnání paměťových bloků:</p>

<pre>
Help on built-in function getsizeof in module sys:
&nbsp;
getsizeof(...)
    getsizeof(object [, default]) -&gt; int
&nbsp;
    Return the size of object in bytes.
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zjištění velikosti hodnot standardních skalárních datových typů Pythonu</h2>

<p>Způsob použití <a href="#k02">výše zmíněné funkce <strong>sys</strong></a>
si můžeme otestovat na skriptu, v&nbsp;němž prozkoumáme velikost hodnot
základních skalárních datových typů programovacího jazyka Python. Bude se
konkrétně jednat o celá čísla (tedy <strong>long</strong> v&nbsp;Pythonu 3),
numerické hodnoty s&nbsp;plovoucí řádovou čárkou, pravdivostní hodnoty, hodnotu
<strong>None</strong> a o řetězce (které jsou kupodivu taktéž považovány za
skalární hodnoty). Pro zajímavost jsme do skriptu přidali ještě hodnoty
posledního skalárního typu &ndash; komplexních čísel:</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(0)
print_sizeof(1)
print_sizeof(42)
print_sizeof(2&lt;&lt;30)
print_sizeof(2&lt;&lt;60)
print()
&nbsp;
print_sizeof(1.0)
print_sizeof(3.1415)
print()
&nbsp;
print_sizeof(1+2j)
print_sizeof(1.2+3.4j)
print()
&nbsp;
print_sizeof(True)
print_sizeof(False)
print_sizeof(None)
print()
&nbsp;
print_sizeof("")
print_sizeof("f")
print_sizeof("fo")
print_sizeof("foo")
print_sizeof("foo bar")
print_sizeof("foo bar baz")
print_sizeof("foo bar baz xyz")
print_sizeof("foo bar baz xyzzy")
</pre>

<p>Zajímavé bude zjistit, jaké velikosti se vlastně vrací (viz první
sloupec):</p>

<pre>
24       int             0
28       int             1
28       int             42
32       int             2147483648
36       int             2305843009213693952
&nbsp;
24       float           1.0
24       float           3.1415
&nbsp;
32       complex         (1+2j)
32       complex         (1.2+3.4j)
&nbsp;
28       bool            True
24       bool            False
16       NoneType        None
&nbsp;
49       str             
50       str             f
51       str             fo
52       str             foo
56       str             foo bar
60       str             foo bar baz
64       str             foo bar baz xyz
66       str             foo bar baz xyzzy
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si například rozdílu mezi
<strong>True</strong> a <strong>False</strong>. Proč se vrací odlišné hodnoty
bude vysvětleno <a href="#k17">v&nbsp;sedmnácté</a> a <a href="#k18">osmnácté
kapitole</a>. Taktéž je zajímavé, že celočíselné hodnoty mají (obecně)
rozdílnou velikost, což si opět vysvětlíme v&nbsp;navazujícím textu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Velikosti objektů představujících řetězce</h2>

<p>Nejjednodušší je situace u řetězců, protože základní velikost objektu typu
řetězec (přesněji prázdný řetězec) je 49 bajtů a každý další přidaný znak
znamená, že se velikost objektu zvýší o jeden až čtyři bajty, v&nbsp;závislosti
na konkrétních znacích uložených v&nbsp;řetězci.</p>

<p>V&nbsp;programovacím jazyku Python verze totiž 3.3 došlo k&nbsp;poměrně
významné změně, která se týká způsobu interního uložení řetězců. Autoři Pythonu
si totiž uvědomili, že na jednu stranu je sice důležité a velmi žádoucí
podporovat Unicode (a to celé Unicode, tedy žádný subset typu <a
href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">BMP</a>,
vzhledem k&nbsp;normě <a href="https://en.wikipedia.org/wiki/GB_18030">GB
18030</a>) ovšem v&nbsp;mnoha případech to vede k&nbsp;tomu, že se do operační
paměti ukládá až čtyřikrát větší množství dat, než je skutečně nutné, protože
mnoho řetězců používaných v&nbsp;každodenní praxi obsahuje pouze ASCII znaky
(příkladem mohou být URL). Navíc větší množství dat uložených v&nbsp;paměti
znamená, že se při manipulaci s&nbsp;nimi bude hůře využívat procesorová cache.
Proto došlo v&nbsp;rámci <a
href="https://www.python.org/dev/peps/pep-0393/">PEP 393</a> k&nbsp;takové
úpravě, která zajistí možnost uložení řetězců ve třech formátech, což je
naznačeno v&nbsp;tabulce:</p>

<table>
<tr><th>Šířka znaku</th><th>Kódování</th><th>Prefix při zápisu kódu</th></tr>
<tr><td>1 bajt</td><td>Latin-1</td><td>\x</td></tr>
<tr><td>2 bajty</td><td>UCS-2</td><td>\u</td></tr>
<tr><td>4 bajty</td><td>UCS-4</td><td>\U</td></tr>
</table>

<p>Tyto změny by měly být pro programátory i uživatele zcela transparentní,
takže by se nemělo stát, že by například do řetězce původně uloženého
s&nbsp;kódováním Latin-1 (nadmnožina ASCII) nešel uložit například znak
v&nbsp;azbuce &ndash; ostatně řetězce jsou v&nbsp;Pythonu neměnitelné, takže se
konverze provede v&nbsp;rámci prováděné operace automaticky.</p>

<p>Podívejme se nyní, jak je výběr formátu pro uložení řetězce prováděn při
interpretaci řetězcového literálu. Nejprve importujeme modul
<strong>sys</strong>, který nabízí funkci <strong>getsizeof()</strong>:</p

<pre>
&gt;&gt;&gt; import sys
</pre>

<p>Zjistíme velikost objektu reprezentujícího prázdný řetězec. Tato velikost se
může lišit podle verze Pythonu a použité architektury, nás však budou zajímat
rozdíly oproti této hodnotě:</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("")
49
</pre>

<p>Zjistíme velikost objektu řetězce s&nbsp;jedním ASCII znakem (měla by být o
jedničku vyšší, než hodnota předchozí) a taktéž velikost objektu řetězce
s&nbsp;jedenácti znaky (bude se lišit o deset bajtů oproti hodnotě předchozí).
Výsledek je zřejmý &ndash; každý znak je v&nbsp;tomto případě reprezentován
jediným bajtem:</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("e")
50
&gt;&gt;&gt; sys.getsizeof("e 123456789")
60
</pre>

<p>Nyní vytvoříme řetězec s&nbsp;ne-ASCII znakem. Velikost příslušného objektu
se zvětší (opět nás však bude zajímat rozdíl oproti této velikosti, ne její
absolutní hodnota):</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("ě")
76
</pre>

<p>Dále vypočteme velikost řetězce s&nbsp;ne-ASCII znakem, po němž následuje
deset ASCII znaků. Vidíme, že každý znak je uložen ve dvou bajtech &ndash;
prvním znakem byl určen interní formát řetězce:</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("ě 123456789")
96
</pre>

<p>Zkusme si nyní vytvořit řetězec s&nbsp;jediným znakem, který nepatří do BPM,
tedy ho nelze reprezentovat v&nbsp;UCS-2. Posléze k&nbsp;tomuto znaku přidáme
dalších deset znaků a snadno zjistíme, že v&nbsp;tomto případě je každý znak
reprezentován čtyřmi bajty ((120-80)/10):</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("\U0001ffff")
80
&gt;&gt;&gt; sys.getsizeof("\U0001ffff 123456789")
120
</pre>

<p>Jen pro zajímavost se můžeme podívat, jak celý objekt s&nbsp;řetězcem
vypadá. U ASCII řetězců:</p>

<pre>
&gt;&gt;&gt; bytearray((ctypes.c_byte*sys.getsizeof("Hello world!")).from_address(id("Hello world!")))
bytearray(b'\x02\x00\x00\x00\x00\x00\x00\x00\x00\x89\x96\x00
\x00\x00\x00\x00\x0c\x00\x00\x00\x00\x00\x00\x00\x17L\xc6c\x01
\xc0\x08a\xe4\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00Hello world!\x00')
</pre>

<p>U řetězců reprezentovaných v&nbsp;UCS-2:</p>

<pre>
&gt;&gt;&gt; bytearray((ctypes.c_byte*sys.getsizeof("ěščřžýáíéúů")).from_address(id("ěščřžýáíéúů")))
bytearray(b'\x02\x00\x00\x00\x00\x00\x00\x00\x00\x89\x96\x00
\x00\x00\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x98\xd8J\xd9
\xd5\xb7\xd0\x9d\xa8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1b
\x01a\x01\r\x01Y\x01~\x01\xfd\x00\xe1\x00\xed\x00\xe9\x00\xfa
\x00o\x01\x00\x00')
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zjištění velikosti hodnot uložených do standardních kolekcí Pythonu</h2>

<p>V&nbsp;dalším kroku použijeme funkci <strong>getsizeof</strong> pro zjištění
velikosti kolekcí, tedy n-tic, seznamů a asociativních polí (můžet si do
příkladu přidat i množiny):</p>

<pre>
from sys import <strong>getsizeof</strong>
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(())
print_sizeof((1,))
print_sizeof((1, 2))
print_sizeof((1, 2, 3))
print_sizeof((1, 2, 3, 4))
print_sizeof((1, 2, 3, 4, 5))
print_sizeof((1, 2, 3, 4, 5, 6))
print()
&nbsp;
print_sizeof([])
print_sizeof([1])
print_sizeof([1, 2])
print_sizeof([1, 2, 3])
print_sizeof([1, 2, 3, 4])
print_sizeof([1, 2, 3, 4, 5])
print_sizeof([1, 2, 3, 4, 5, 6])
print()
&nbsp;
print_sizeof({})
print_sizeof({1:1})
print_sizeof({1:1, 2:2})
print_sizeof({1:1, 2:2, 3:3})
print_sizeof({1:1, 2:2, 3:3, 4:4})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5, 6:6})
</pre>

<p>Výsledky ukazují, jak se velikosti kolekcí postupně zvětšují společně se
zvyšujícím se počtem prvků:</p>

<pre>
40       tuple           ()
48       tuple           (1,)
56       tuple           (1, 2)
64       tuple           (1, 2, 3)
72       tuple           (1, 2, 3, 4)
80       tuple           (1, 2, 3, 4, 5)
88       tuple           (1, 2, 3, 4, 5, 6)
&nbsp;
56       list            []
64       list            [1]
72       list            [1, 2]
80       list            [1, 2, 3]
88       list            [1, 2, 3, 4]
96       list            [1, 2, 3, 4, 5]
104      list            [1, 2, 3, 4, 5, 7]
&nbsp;
64       dict            {}
232      dict            {1: 1}
232      dict            {1: 1, 2: 2}
232      dict            {1: 1, 2: 2, 3: 3}
232      dict            {1: 1, 2: 2, 3: 3, 4: 4}
232      dict            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}
360      dict            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6}
</pre>

<p>Ukazují se však skutečně velikosti všech hodnot, nebo pouze velikosti
referencí uložených v&nbsp;kolekcích (v&nbsp;Pythonu je vše reference)? To
zjistíme snadno &ndash; zkusíme do kolekce uložit řetězce s&nbsp;milionem
znaků:</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename)
&nbsp;
&nbsp;
print_sizeof((1, 2))
print_sizeof((1, <strong>"?" * 1000000</strong>))
print()
&nbsp;
print_sizeof([1, 2])
print_sizeof([1, <strong>"?" * 1000000</strong>])
print()
&nbsp;
print_sizeof({1:1, 2:2})
print_sizeof({1:1, <strong>2:"?" * 1000000</strong>})
</pre>

<p>Z&nbsp;výsledků je jasně patrné, že se velikosti samotných hodnot do
výsledku nezapočítávají:</p>

<pre>
56       tuple   
56       tuple   
&nbsp;
72       list    
72       list    
&nbsp;
232      dict    
232      dict    
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Velikosti skalárních hodnot i kolekcí</h2>

<p>Hodnoty získané výše uvedenými skripty nám pomohly získat alespoň základní
představu o tom, jaký objem RAM je potřeba pro uložení skalárních hodnot i
prvků do základních kolekcí. Shrnutí platné pro současné verze Pythonu 3
(budoucí verze Pythonu mohou mít odlišné požadavky) je uvedeno
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Datový typ</th><th>Význam</th><th>Minimální velikost</th><th>Další růst</th></tr>
<tr><td>long</td><td>celé číslo</td><td>28</td><td>+4 bajty pro každou mocninu 2<sup>30</sup></td></tr>
<tr><td>float</td><td>číslo s&nbsp;plovoucí řádovou čárkou</td><td>24</td><td>&times;</td></tr>
<tr><td>complex</td><td>komplexní číslo s&nbsp;plovoucí řádovou čárkou</td><td>32</td><td>&times;</td></tr>
<tr><td>bool</td><td>True nebo False</td><td>24/28</td><td>&times;</td></tr>
<tr><td>NoneType</td><td>hodnota <strong>none</strong></td><td>16</td><td>&times;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<td><td>string</td><td>řetězec</td><td>49</td><td>+1 až 4 bajty pro každý další znak (již známe)</td></td>
<td><td>tuple</td><td>n-tice</td><td>40</td><td>+8 bajtů pro každý další prvek n-tice</td></td>
<td><td>list</td><td>seznam</td><td>56</td><td>+8 bajtů pro každý další prvek seznamu</td></td>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<td><td>set</td><td>množina</td><td>216</td><td>5 prvků: 728, 19 prvků: 2264, ..., 77 prvků: 8408, ...</td></td>
<td><td>dict</td><td>slovník</td><td>64</td><td>1 prvek 232, 6 prvků: 360; 22 prvků: 1184; ...</td></td>
</table>

<p><div class="rs-tip-major">Poznámka: z&nbsp;výše uvedené tabulky je patrné,
že hodnoty můžeme zhruba rozdělit do tří skupin. V&nbsp;první skupině jsou
skalární hodnoty s&nbsp;buď pevnou velikostí, nebo velikostí, která roste pro
vyšší hodnoty (celá čísla). Ve druhé skupině nalezneme &bdquo;lineární&ldquo;
datové typy, jejichž velikosti rostou lineárně s&nbsp;počtem uložených prvků
(nebo s&nbsp;počtem znaků pro řetězce). A konečně ve třetí skupině jsou množiny
a slovníky, které pochopitelně musí taktéž růst s&nbsp;rostoucím počtem
uložených prvků, ale růst není striktně lineární &ndash; paměť se totiž alokuje
po větších blocích, což je v&nbsp;IT velmi častá forma optimalizace.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Velikosti funkcí v&nbsp;operační paměti zjišťované pomocí <strong>getsizeof</strong></h2>

<p>Velmi důležitým datovým typem je v&nbsp;programovacím jazyku Python funkce.
Podobně jako v&nbsp;případě hodnot dalších typů může být v&nbsp;operační paměti
uloženo (obecně) libovolné množství hodnot typu funkce. Vyzkoušejme si tedy,
jakou velikost (chápáno jaké množství bajtů) funkce vrací standardní volání
<strong>sys.getsizeof</strong>, a to pro různě definované funkce:</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
def <strong>foo</strong>():
    pass
&nbsp;
&nbsp;
def <strong>bar</strong>(x, y):
    return x+y
&nbsp;
&nbsp;
def <strong>baz</strong>(x=0, y=1):
    print(x)
    print(y)
    return x+y
&nbsp;
&nbsp;
print_sizeof(print)
print_sizeof(foo)
print_sizeof(bar)
print_sizeof(baz)
</pre>

<p>Získané výsledky vypadají následovně:</p>

<pre>
72       builtin_function_or_method      &lt;built-in function print&gt;
136      function        &lt;function foo at 0x7fcea02f8160&gt;
136      function        &lt;function bar at 0x7fcea02f81f0&gt;
136      function        &lt;function baz at 0x7fcea02f8280&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: později uvidíme, že tyto velikosti
nejsou vypočteny přesně, protože se vrací pouze velikost &bdquo;slotu&ldquo;
pro funkci.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Velikosti tříd a objektů zjišťované pomocí <strong>getsizeof</strong></h2>

<p>Standardní funkce <strong>sys.getsizeof</strong> může být použita i pro
zjištění velikosti tříd (což jsou taktéž hodnoty) a instancí tříd neboli
objektů. Opět se podívejme na jednoduchý příklad, v&nbsp;němž tyto hodnoty
zjišťujeme:</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
class <strong>C1</strong>:
    pass
&nbsp;
&nbsp;
class <strong>C2</strong>:
    def <strong>__init__</strong>(self):
        pass
&nbsp;
class <strong>C3</strong>:
    def __init__(self):
        pass
&nbsp;
    def <strong>foo</strong>(self, x):
        self.x=x
&nbsp;
    def <strong>bar</strong>(self, y):
        self.y=y
&nbsp;
&nbsp;
o1 = C1()
o2 = C2()
o3 = C3()
&nbsp;
print_sizeof(C1)
print_sizeof(o1)
&nbsp;
print_sizeof(C2)
print_sizeof(o2)
&nbsp;
print_sizeof(C3)
print_sizeof(o3)
&nbsp;
o3.foo(42)
&nbsp;
print_sizeof(C3)
print_sizeof(o3)
&nbsp;
o3.bar(0)
&nbsp;
print_sizeof(C3)
print_sizeof(o3)
</pre>

<p>Podívejme se na zjištěné a zobrazené velikosti objektů i tříd:</p>

<pre>
1064     type            &lt;class '__main__.C1'&gt;
48       C1              &lt;__main__.C1 object at 0x7ff7f2e20430&gt;
1064     type            &lt;class '__main__.C2'&gt;
48       C2              &lt;__main__.C2 object at 0x7ff7f2e20040&gt;
1064     type            &lt;class '__main__.C3'&gt;
48       C3              &lt;__main__.C3 object at 0x7ff7f2e20190&gt;
1064     type            &lt;class '__main__.C3'&gt;
48       C3              &lt;__main__.C3 object at 0x7ff7f2e20190&gt;
1064     type            &lt;class '__main__.C3'&gt;
48       C3              &lt;__main__.C3 object at 0x7ff7f2e20190&gt;
</pre>

<p>Popř.&nbsp;lze příklad nepatrně upravit tak, že naplníme atribut objektu tím
samým objektem (resp.&nbsp;referencí na ten samý objekt):</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
class <strong>C4</strong>:
    def <strong>__init__</strong>(self):
        pass
&nbsp;
    def <strong>foo</strong>(self, x):
        self.x=x
&nbsp;
&nbsp;
o4 = C4()
&nbsp;
print_sizeof(C4)
print_sizeof(o4)
&nbsp;
o4.foo(o4)
&nbsp;
print_sizeof(C4)
print_sizeof(o4)
</pre>

<p>Výsledky nyní budou vypadat následovně:</p>

<pre>
1064     type            &lt;class '__main__.C4'&gt;
48       C4              &lt;__main__.C4 object at 0x7f7f2f0d6430&gt;
1064     type            &lt;class '__main__.C4'&gt;
48       C4              &lt;__main__.C4 object at 0x7f7f2f0d6430&gt;
</pre>

<p>Naše znalosti o velikosti hodnot tedy můžeme doplnit takto:</p>

<table>
<tr><th>Datový typ</th><th>Význam</th><th>Minimální velikost</th><th>Další růst</th></tr>
<tr><td>func</td><td>funkce</td><td>136</td><td>&nbsp;</td></tr>
<tr><td>class</td><td>definice třídy</td><td>1064</td><td>&nbsp;</td></tr>
<tr><td>inst</td><td>instance třídy</td><td>48</td><td>jako u slovníků pro každý další atribut</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: dále opět uvidíme, jak je možné zjistit
velikost těchto hodnot přesnějším způsobem &ndash; výsledky získané přes
<strong>sys.getsizeof</strong> totiž v&nbsp;tomto případě v&nbsp;žádném případě
nejsou přesné.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Balíček <i>Pympler</i></h2>

<p>Největší předností výše popsané funkce <strong>sys.getsizeof</strong> je
fakt, že se jedná o funkci ze standardní knihovny <strong>sys</strong>. To
mj.&nbsp;znamená, že tuto funkci je možné zavolat prakticky kdykoli a kdekoli,
a to bez nutnosti instalace nějakých dalších balíčků. Ovšem tato funkce není
příliš dokonalá, protože například neumožňuje zjistit velikost hodnot
v&nbsp;operační paměti po zarovnání, protože alokátor paměti alokuje nové bloky
vždy na adresách dělitelných nějakou konstantou 4, 8 či 16 (podle systému a
architektury) a tudíž vlastně nebudou využity bajty umístěné těsně za koncem
bloku v&nbsp;případě, že velikost bloku není dělitelná výše uvedenou
konstantou. A navíc má tato standardní funkce problémy se zjištěním velikosti
tříd a objektů, protože automaticky nezapočítává velikosti jednotlivých
atributů atd.</p>

<p>Existují však i další (ovšem nutno dodat, že již nestandardní) balíčky,
které &bdquo;opravují&ldquo; chování funkce <strong>sys.getsizeof</strong> a
navíc nabízí uživatelům i další zajímavou a potenciálně užitečnou
funkcionalitu. Tyto balíčky je však pochopitelně nutné nejdříve nainstalovat.
Prvním z&nbsp;balíčků, o nichž se dnes alespoň ve stručnosti zmíníme, je
balíček nazvaný <strong>Pympler</strong>. Vzhledem k&nbsp;tomu, že je
zaregistrovaný na <i>PyPi</i>, je instalace tohoto balíčku triviální a můžeme
ji provést (pro právě přihlášeného uživatele) tímto příkazem:</p>

<pre>
$ <strong>pip3 install --user pympler</strong>
</pre>

<p>Samotná instalace proběhne prakticky okamžitě:</p>

<pre>
Collecting pympler
  Downloading Pympler-1.0.1-py3-none-any.whl (164 kB)
     |████████████████████████████████| 164 kB 1.5 MB/s 
Installing collected packages: pympler
Successfully installed pympler-1.0.1
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě můžete provést instalaci i
tohoto balíčku v&nbsp;rámci virtuálního prostředí Pythonu atd.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce poskytované balíčkem <strong>pympler.asizeof</strong></h2>

<p>Samotný Pympler obsahuje několik podbalíčků, z&nbsp;nichž nás v&nbsp;dnešním
článku bude zajímat především podbalíček nazvaný
<strong>pympler.asizeof</strong>:</p>

<pre>
&gt;&gt;&gt; <strong>from pympler import asizeof</strong>
</pre>

<p>Podbalíček <strong>pympler.asizeof</strong> v&nbsp;současné verzi obsahuje
devět užitečných funkcí:</p>

<pre>
&gt;&gt;&gt; <strong>help(asizeof)</strong>
</pre>

<pre>
Help on module pympler.asizeof in pympler:
&nbsp;
NAME
    pympler.asizeof
&nbsp;
DESCRIPTION
    This module exposes 9 functions and 2 classes to obtain lengths and
    sizes of Python objects (for Python 3.5 or later).
&nbsp;
    Earlier versions of this module supported Python versions down to
    Python 2.2.  If you are using Python 3.5 or older, please consider
    downgrading Pympler.
&nbsp;
    **Public Functions** [#unsafe]_
&nbsp;
       Function **asizeof** calculates the combined (approximate) size
       in bytes of one or several Python objects.
&nbsp;
       Function **asizesof** returns a tuple containing the (approximate)
       size in bytes for each given Python object separately.
&nbsp;
       Function **asized** returns for each object an instance of class
       **Asized** containing all the size information of the object and
       a tuple with the referents [#refs]_.
&nbsp;
       Functions **basicsize** and **itemsize** return the *basic-*
       respectively *itemsize* of the given object, both in bytes.  For
       objects as ``array.array``, ``numpy.array``, ``numpy.matrix``,
       etc. where the item size varies depending on the instance-specific
       data type, function **itemsize** returns that item size.
&nbsp;
       Function **flatsize** returns the *flat size* of a Python object
       in bytes defined as the *basic size* plus the *item size* times
       the *length* of the given object.
&nbsp;
       Function **leng** returns the *length* of an object, like standard
       function ``len`` but extended for several types.  E.g. the **leng**
       of a multi-precision int (or long) is the number of ``digits``
       [#digit]_.  The length of most *mutable* sequence objects includes
       an estimate of the over-allocation and therefore, the **leng** value
       may differ from the standard ``len`` result.  For objects like
</pre>

<p>V&nbsp;podbalíčku však nalezneme i další více či méně zajímavé hodnoty,
které lze vypsat například takto:</p>

<pre>
from pympler import asizeof
&nbsp;
for item in dir(asizeof):
    if item[0] != "_":
        print(item)
</pre>

<p>Výsledek:</p>

<pre>
ABCMeta
Asized
Asizer
Callable
Dict
List
Optional
Struct
Tuple
Types
Union
Weakref
adict
array
asized
asizeof
asizesof
basicsize
calcsize
curdir
finditer
flatsize
isbuiltin
isclass
iscode
isframe
isfunction
ismethod
ismodule
itemsize
leng
linesep
log
named_refs
numpy
refs
stack
stat
statvfs
sys
warnings
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Funkce <strong>asizeof.asizeof</strong> pro zjištění velikosti hodnot v&nbsp;operační paměti</h2>

<p>Nejužitečnější funkce z&nbsp;podbalíčku <strong>pympler.asizeof</strong> se
jmenuje taktéž <strong>asizeof</strong>. Jedná se o v&nbsp;mnoha ohledech
vylepšenou standardní funkci <strong>sys.getsizeof</strong>, která umožňuje
vypočítat skutečné velikosti objektů uložených v&nbsp;operační paměti:</p>

<pre>
from pympler import asizeof
&nbsp;
help(asizeof.asizeof)
</pre>

<p>Tato funkce má několik zajímavých přepínačů, z&nbsp;nichž některé si
popíšeme v&nbsp;dalším textu:</p>

<pre>
Help on function asizeof in module pympler.asizeof:
&nbsp;
asizeof(*objs, **opts)
    Return the combined size (in bytes) of all objects passed
    as positional arguments.
&nbsp;
    The available options and defaults are:
&nbsp;
         *above=0*      -- threshold for largest objects stats
&nbsp;
         *align=8*      -- size alignment
&nbsp;
         *clip=80*      -- clip ``repr()`` strings
&nbsp;
         *code=False*   -- incl. (byte)code size
&nbsp;
         *cutoff=10*    -- limit large objects or profiles stats
&nbsp;
         *derive=False* -- derive from super type
&nbsp;
         *frames=False* -- ignore stack frame objects
&nbsp;
         *ignored=True* -- ignore certain types
&nbsp;
         *infer=False*  -- try to infer types
&nbsp;
         *limit=100*    -- recursion limit
&nbsp;
         *stats=0*      -- print statistics
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zjištění a výpis velikosti skalárních hodnot i kolekcí</h2>

<p>Nyní se pokusme upravit skripty pro zjišťování velikostí různých hodnot
uložených v&nbsp;operační paměti takovým způsobem, aby se namísto standardní
funkce <strong>sys-getsizeof</strong> volala funkce <strong>asizeof</strong>
z&nbsp;podbalíčku <strong>pympler.asizeof</strong>. Úprava skriptu je ve
skutečnosti minimální, ovšem umožní nám další úpravy (a taktéž výsledky se
mohou lišit).</p>

<p>Začneme skriptem, v&nbsp;němž se zjišťují velikosti skalárních hodnot, a to
včetně řetězců. Upravená varianta tohoto skriptu bude vypadat následovně:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(0)
print_sizeof(1)
print_sizeof(42)
print_sizeof(2&lt;&lt;30)
print_sizeof(2&lt;&lt;60)
print()
&nbsp;
print_sizeof(1.0)
print_sizeof(3.1415)
print()
&nbsp;
print_sizeof(1+2j)
print_sizeof(1.2+3.4j)
print()
&nbsp;
print_sizeof(True)
print_sizeof(False)
print_sizeof(None)
print()
&nbsp;
print_sizeof("")
print_sizeof("f")
print_sizeof("fo")
print_sizeof("foo")
print_sizeof("foo bar")
print_sizeof("foo bar baz")
print_sizeof("foo bar baz xyz")
print_sizeof("foo bar baz xyzzy")
</pre>

<p>Podívejme se nyní na zjištěné a vypsané výsledky:</p>

<pre>
24       int             0
32       int             1
32       int             42
32       int             2147483648
40       int             2305843009213693952
&nbsp;
24       float           1.0
24       float           3.1415
&nbsp;
32       complex         (1+2j)
32       complex         (1.2+3.4j)
&nbsp;
32       bool            True
24       bool            False
16       NoneType        None
&nbsp;
56       str             
56       str             f
56       str             fo
56       str             foo
56       str             foo bar
64       str             foo bar baz
64       str             foo bar baz xyz
72       str             foo bar baz xyzzy
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že velikosti jsou vždy
dělitelné osmi, protože <strong>asizeof</strong> počítá se zarovnáním
paměťových bloků.</div></p>

<p>V&nbsp;dalším kroku provedeme úpravu skriptu pro zjištění velikosti
kolekcí:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(())
print_sizeof((1,))
print_sizeof((1, 2))
print_sizeof((1, 2, 3))
print_sizeof((1, 2, 3, 4))
print_sizeof((1, 2, 3, 4, 5))
print_sizeof((1, 2, 3, 4, 5, 6))
print()
&nbsp;
print_sizeof([])
print_sizeof([1])
print_sizeof([1, 2])
print_sizeof([1, 2, 3])
print_sizeof([1, 2, 3, 4])
print_sizeof([1, 2, 3, 4, 5])
print_sizeof([1, 2, 3, 4, 5, 6])
print()
&nbsp;
print_sizeof({})
print_sizeof({1:1})
print_sizeof({1:1, 2:2})
print_sizeof({1:1, 2:2, 3:3})
print_sizeof({1:1, 2:2, 3:3, 4:4})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5, 6:6})
</pre>

<p>Opět je zajímavé se podívat na výsledky, které tento skript vypočítal a
zobrazil:</p>

<pre>
40       tuple           ()
80       tuple           (1,)
120      tuple           (1, 2)
160      tuple           (1, 2, 3)
200      tuple           (1, 2, 3, 4)
240      tuple           (1, 2, 3, 4, 5)
280      tuple           (1, 2, 3, 4, 5, 6)
&nbsp;
56       list            []
96       list            [1]
136      list            [1, 2]
176      list            [1, 2, 3]
216      list            [1, 2, 3, 4]
256      list            [1, 2, 3, 4, 5]
296      list            [1, 2, 3, 4, 5, 6]
&nbsp;
64       dict            {}
264      dict            {1: 1}
296      dict            {1: 1, 2: 2}
328      dict            {1: 1, 2: 2, 3: 3}
360      dict            {1: 1, 2: 2, 3: 3, 4: 4}
392      dict            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}
552      dict            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6}
</pre>

<p>Opět se podívejme na příklad s&nbsp;kolekcemi, které obsahují řetězce o délce milionu znaků (a v&nbsp;tomto případě i bajtů):</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, code=True), "\t", typename)
&nbsp;
&nbsp;
print_sizeof((1, 2))
print_sizeof((1, <strong>"?" * 1000000)</strong>)
print()
&nbsp;
print_sizeof([1, 2])
print_sizeof([1, <strong>"?" * 1000000]</strong>)
print()
&nbsp;
print_sizeof({1:1, 2:2})
print_sizeof({1:1, <strong>2:"?" * 1000000}</strong>)
</pre>

<p>Nyní již výsledky, na rozdíl od použití <strong>sys.getsizeof</strong>, mají
praktický význam:</p>

<pre>
120       tuple   
1000144   tuple   
&nbsp;
136       list    
1000160   list    
&nbsp;
296       dict    
1000352   dict    
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zobrazení podrobnější statistiky o velikostech hodnot</h2>

<p></p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, <u>stats=1</u>), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(0)
print_sizeof(1)
print_sizeof(42)
print_sizeof(2&lt;&lt;30)
print_sizeof(2&lt;&lt;60)
print()
&nbsp;
print_sizeof(1.0)
print_sizeof(3.1415)
print()
&nbsp;
print_sizeof(1+2j)
print_sizeof(1.2+3.4j)
print()
&nbsp;
print_sizeof(True)
print_sizeof(False)
print_sizeof(None)
print()
&nbsp;
print_sizeof("")
print_sizeof("f")
print_sizeof("fo")
print_sizeof("foo")
print_sizeof("foo bar")
print_sizeof("foo bar baz")
print_sizeof("foo bar baz xyz")
print_sizeof("foo bar baz xyzzy")
</pre>

<pre>
from pympler import asizeof


def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, <u>stats=1</u>), "\t", typename, "\t", value)


print_sizeof(())
print_sizeof((1,))
print_sizeof((1, 2))
print_sizeof((1, 2, 3))
print_sizeof((1, 2, 3, 4))
print_sizeof((1, 2, 3, 4, 5))
print_sizeof((1, 2, 3, 4, 5, 6))
print()

print_sizeof([])
print_sizeof([1])
print_sizeof([1, 2])
print_sizeof([1, 2, 3])
print_sizeof([1, 2, 3, 4])
print_sizeof([1, 2, 3, 4, 5])
print_sizeof([1, 2, 3, 4, 5, 6])
print()

print_sizeof({})
print_sizeof({1:1})
print_sizeof({1:1, 2:2})
print_sizeof({1:1, 2:2, 3:3})
print_sizeof({1:1, 2:2, 3:3, 4:4})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5, 6:6})
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Získání skutečné velikosti tříd a objektů uložených v&nbsp;operační paměti</h2>

<p>Jak jsme si již řekli v&nbsp;úvodní části tohoto článku, vrací standardní funkce <strong>sys.getsizeof</strong> pro všechny třídy stejnou velikost a totéž do jisté míry platí i pro všechny objekty (tam ovšem již záleží na počtu atributů). Bude tedy zajímavé zjistit, jaké hodnoty vypíše funkce <strong>asizeof</strong>, která je interně mnohem komplikovanější, než <strong>sys.getsizeof</strong>:</p>

<pre>
from pympler import asizeof


def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value), "\t", typename, "\t", value)


def foo():
    pass


def bar(x, y):
    return x+y


def baz(x=0, y=1):
    print(x)
    print(y)
    return x+y


print_sizeof(print)
print_sizeof(foo)
print_sizeof(bar)
print_sizeof(baz)
</pre>

<pre>
from pympler import asizeof


def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, code=True), "\t", typename, "\t", value)


def foo():
    pass


def bar(x, y):
    return x+y


def baz(x=0, y=1):
    print(x)
    print(y)
    return x+y


print_sizeof(print)
print_sizeof(foo)
print_sizeof(bar)
print_sizeof(baz)
</pre>

<pre>
from pympler import asizeof


def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, code=True), "\t", typename, "\t", value)


class C1:
    pass


class C2:
    def __init__(self):
        pass

class C3:
    def __init__(self):
        pass

    def foo(self, x):
        self.x=x

    def bar(self, y):
        self.y=y


o1 = C1()
o2 = C2()
o3 = C3()

print_sizeof(C1)
print_sizeof(o1)

print_sizeof(C2)
print_sizeof(o2)

print_sizeof(C3)
print_sizeof(o3)

o3.foo(42)

print_sizeof(C3)
print_sizeof(o3)

o3.bar(0)

print_sizeof(C3)
print_sizeof(o3)
</pre>

<pre>
from pympler import asizeof


def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, code=True), "\t", typename, "\t", value)


class C4:
    def __init__(self):
        pass

    def foo(self, x):
        self.x=x


o4 = C4()

print_sizeof(C4)
print_sizeof(o4)

o4.foo(o4)

print_sizeof(C4)
print_sizeof(o4)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Balíček <i>memory_profiler</i></h2>

<p>Kromě balíčku <strong></strong>, jehož (prozatím velmi malou část) jsme si dnes popsali, ovšem existují i další balíčky, které se používají ve chvílích, kdy je nutné zjistit chování aplikace z&nbsp;hlediska spotřeby operační paměti. Mezi velmi užitečný balíček z&nbsp;této oblasti patří balíček nazvaný <strong></strong>, který je již možné využít pro analýzu chování celé aplikace, tedy nejenom pro zjištění velikosti jednotlivých hodnot (navíc typicky nemá programátor přehled o všech hodnotách, které jsou v&nbsp;paměti uloženy, protože některé z&nbsp;těchto hodnot využívá samotný interpret atd.). I tento balíček je dostupný na <i>PyPi</i>, takže je jeho instalace triviální:</p>

<pre>
$ <strong>pip3 install --user guppy3</strong>
</pre>

<pre>
Collecting guppy3
  Downloading guppy3-3.1.2-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (649 kB)
     |████████████████████████████████| 649 kB 1.6 MB/s 
Installing collected packages: guppy3
Successfully installed guppy3-3.1.2
</pre>

<pre>
$ <strong>pip3 install --user memory_profiler</strong>
</pre>

<pre>
Collecting memory_profiler
  Downloading memory_profiler-0.61.0-py3-none-any.whl (31 kB)
Requirement already satisfied: psutil in /usr/lib/python3/dist-packages (from memory_profiler) (5.5.1)
Installing collected packages: memory-profiler
Successfully installed memory-profiler-0.61.0
</pre>

<p>Po instalaci si otestujeme, zda je nově nainstalovaný balíček skutečně dostupný i z&nbsp;interpretru Pythonu:</p>



>>> h.doc
Top level interface to Heapy. Available attributes:
Anything            Prod                Via                 iso
Clodo               Rcs                 doc                 load
Id                  Root                findex              monitor
Idset               Size                heap                pb
Module              Type                heapu               setref
Nothing             Unity               idset               test
Use eg: h.doc.<attribute> for info on <attribute>.


Help on function hpy in module guppy:

hpy(ht=None)
    Main entry point to the Heapy system.
    Returns an object that provides a session context and will import
    required modules on demand. Some commononly used methods are:

    .heap()                 get a view of the current reachable heap
    .iso(obj..)     get information about specific objects

    The optional argument, useful for debugging heapy itself, is:

        ht     an alternative hiding tag

Help on method heap in module guppy.heapy.Use:

heap() method of guppy.heapy.Use._GLUECLAMP_ instance
    heap() -> IdentitySet[1]

    Traverse the heap from a root to find all reachable and visible
    objects. The objects that belong to a heapy instance are normally not
    included. Return an IdentitySet with the objects found, which is
    presented as a table partitioned according to a default equivalence
    relation (Clodo [3]).

    See also: setref[2]

    References
        [0] heapy_Use.html#heapykinds.Use.heap
        [1] heapy_UniSet.html#heapykinds.IdentitySet
        [2] heapy_Use.html#heapykinds.Use.setref
        [3] heapy_Use.html#heapykinds.Use.Clodo


heapu(rma=1, abs=0, stat=1) method of guppy.heapy.Use._GLUECLAMP_ instance
    heapu() -> Stat

    Finds the objects in the heap that remain after garbage collection but
    are _not_ reachable from the root.  This can be used to find objects
    in extension modules that remain in memory even though they are
    gc-collectable and not reachable.

    Returns an object containing a statistical summary of the objects
    found - not the objects themselves. This is to avoid making the
    objects reachable.

    See also: setref[1]

    References
        [0] heapy_Use.html#heapykinds.Use.heapu
        [1] heapy_Use.html#heapykinds.Use.setref


<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

>>> h.heap()[0]
Partition of a set of 34181 objects. Total size = 3177461 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0  34181 100  3177461 100   3177461 100 str


>>> h.heap()[0].byid
Set of 34202 <str> objects. Total size = 3179683 bytes.
 Index     Size   %   Cumulative  %   Representation (limited)
     0     7423   0.2      7423   0.2 'The class Bi... copy of S.\n'
     1     6512   0.2     13935   0.4 '\nThe ``code...hentication``'
     2     6327   0.2     20262   0.6 'Configuratio... by spaces.\n'
     3     6150   0.2     26412   0.8 "Support for ... 'error'.\n\n"
     4     5573   0.2     31985   1.0 'Controls for...ger`.\n\n    '
     5     4791   0.2     36776   1.2 'Heap queues\...at Art! :-)\n'
     6     4791   0.2     41567   1.3 'Heap queues\...at Art! :-)\n'
     7     4708   0.1     46275   1.5 ' Retry confi...equest.\n    '
     8     4252   0.1     50527   1.6 'Serialize ``...ible.\n\n    '
     9     4114   0.1     54641   1.7 '\n        Ge...ib`\n        '

>>> x="*"*10000
>>> h.heap()[0].byid
Set of 34204 <str> objects. Total size = 3189794 bytes.
 Index     Size   %   Cumulative  %   Representation (limited)
     0    10049   0.3     10049   0.3 '************...*************'
     1     7423   0.2     17472   0.5 'The class Bi... copy of S.\n'
     2     6512   0.2     23984   0.8 '\nThe ``code...hentication``'
     3     6327   0.2     30311   1.0 'Configuratio... by spaces.\n'
     4     6150   0.2     36461   1.1 "Support for ... 'error'.\n\n"
     5     5573   0.2     42034   1.3 'Controls for...ger`.\n\n    '
     6     4791   0.2     46825   1.5 'Heap queues\...at Art! :-)\n'
     7     4791   0.2     51616   1.6 'Heap queues\...at Art! :-)\n'
     8     4708   0.1     56324   1.8 ' Retry confi...equest.\n    '
     9     4252   0.1     60576   1.9 'Serialize ``...ible.\n\n    '
<34194 more rows. Type e.g. '_.more' to view.>

>>> x=None
>>> h.heap()[0].byid
Set of 34203 <str> objects. Total size = 3179745 bytes.
 Index     Size   %   Cumulative  %   Representation (limited)
     0     7423   0.2      7423   0.2 'The class Bi... copy of S.\n'
     1     6512   0.2     13935   0.4 '\nThe ``code...hentication``'
     2     6327   0.2     20262   0.6 'Configuratio... by spaces.\n'
     3     6150   0.2     26412   0.8 "Support for ... 'error'.\n\n"
     4     5573   0.2     31985   1.0 'Controls for...ger`.\n\n    '
     5     4791   0.2     36776   1.2 'Heap queues\...at Art! :-)\n'
     6     4791   0.2     41567   1.3 'Heap queues\...at Art! :-)\n'
     7     4708   0.1     46275   1.5 ' Retry confi...equest.\n    '
     8     4252   0.1     50527   1.6 'Serialize ``...ible.\n\n    '
     9     4114   0.1     54641   1.7 '\n        Ge...ib`\n        '
<34193 more rows. Type e.g. '_.more' to view.>


<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Proč se tedy liší velikosti hodnot <strong>True</strong> a <strong>False</strong>?</h2>

<p>Zbývá nám ještě odpovědět na otázku z&nbsp;titulku tohoto článku, tedy proč
se velikosti hodnot <strong>True</strong> a <strong>False</strong> odlišují.
Nejprve si musíme uvědomit, o jakých hodnotách se vlastně bavíme.
Z&nbsp;historických důvodů totiž programovací jazyk Python reprezentuje hodnotu
<strong>False</strong> jako nulu a hodnotu <strong>True</strong> jako jedničku.
Nejedná se však o pouhou (řekněme) pseudoekvivalenci získanou na základě
nějakých konverzních pravidel, ale o (pro naprostou většinu operací) skutečnou
ekvivalenci:</p>

<pre>
&gt;&gt;&gt; <strong>0 == False</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>1 == True</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>2 == True</strong>
False
</pre>

<p>Z&nbsp;tohoto pohledu jsou tedy hodnoty <strong>True</strong> a
<strong>False</strong> instancemi třídy <strong>Number</strong>! Vyzkoušejme si
to:</p>

<pre>
&gt;&gt;&gt; <strong>import numbers</strong>
&nbsp;
&gt;&gt;&gt; <strong>isinstance(0, numbers.Number)</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>isinstance(1, numbers.Number)</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>isinstance(True, numbers.Number)</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>isinstance(False, numbers.Number)</strong>
True
</pre>

<p>Nyní tedy víme, že nám bude postačovat zjistit, z&nbsp;jakého důvodu je
celočíselná hodnota <strong>0</strong> uložena v&nbsp;operační paměti
s&nbsp;jinou velikostí než celočíselná hodnota <strong>1</strong>, protože
naprosto stejná pravidla budou platit pro hodnotu <strong>False</strong> a
hodnotu <strong>True</strong>.</p>

<p><div class="rs-tip-major">Poznámka: o obou pravdivostních hodnotách můžeme
mluvit v&nbsp;singuláru, protože typicky mohou existovat v&nbsp;rámci celého
procesu jen v&nbsp;jediné instanci, na níž se odkazují jednotlivé proměnné,
atributy nebo parametry funkcí/metod.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p>V&nbsp;Pythonu 3 jsou celočíselné hodnoty reprezentovány datovým typem nazvaným <i>long</i>. Ovšem nejedná se o stejný <i>long</i>, jaký známe například z&nbsp;C, C++ či Javy, protože typ <i>long</i> v&nbsp;podání Pythonu znamená, že uložená celočíselná hodnota může mít prakticky jakýkoli rozsah. To mj.&nbsp;znamená, že nejsme omezeni pouze například na &bdquo;klasický&ldquo; 32bitový či 64bitový rozsah, tedy na hodnoty -2<sup>31</sup>..2<sup>31</sup>-1 či -2<sup>63</sup>..2<sup>63</sup>-1 (popř.&nbsp;na rozsah 64bitový).</p>

<p>Způsob uložení hodnot typu <i>long</i> tedy musí být adaptivní, což znamená, že malé hodnoty budou uloženy v&nbsp;kratším paměťovém bloku, než hodnoty větší. To pochopitelně komplikuje a prodlužuje všechny výpočty, takže obecně platí, že v&nbsp;této oblasti bude Python vždy pomalejší, než nativní kód popř.&nbsp;než skripty napsané v&nbsp;interpretovaných jazycích, které podporují standardní formát celočíselných hodnot.</p>

<p>Konkrétně vypadá paměťová struktura s&nbsp;celými čísly typu <i>long</i> následovně:</p>

<p></p>
<pre>
/* Long integer representation.
   The absolute value of a number is equal to
        SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
   Negative numbers are represented with ob_size &lt; 0;
   zero is represented by ob_size == 0.
   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant
   digit) is never zero.  Also, in all cases, for all valid i,
        0 &lt;= ob_digit[i] &lt;= MASK.
   The allocation function takes care of allocating extra memory
   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.
   We always allocate memory for at least one digit, so accessing ob_digit[0]
   is always safe. However, in the case ob_size == 0, the contents of
   ob_digit[0] may be undefined.
   CAUTION:  Generic code manipulating subtypes of PyVarObject has to
   aware that ints abuse  ob_size's sign bit.
*/
</pre>

typedef struct _PyLongValue {
    uintptr_t lv_tag; /* Number of digits, sign and flags */
    digit ob_digit[1];
} _PyLongValue;

struct _longobject {
    PyObject_HEAD
    _PyLongValue long_value;
};



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>getsizeof1.py</td><td>získání nápovědy k&nbsp;funkci <strong>getsizeof</strong> z&nbsp;balíčku <strong>sys</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof1.py</a></td></tr>
<tr><td> 2</td><td>getsizeof2.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof2.py</a></td></tr>
<tr><td> 3</td><td>getsizeof3.py</td><td>získání a tisk velikosti kontejnerů Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof3.py</a></td></tr>
<tr><td> 4</td><td>getsizeof4.py</td><td>získání a tisk velikosti funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof4.py</a></td></tr>
<tr><td> 5</td><td>getsizeof5.py</td><td>získání a tisk velikosti tříd a objektů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof5.py</a></td></tr>
<tr><td> 6</td><td>getsizeof6.py</td><td>získání a tisk velikosti tříd a objektů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>asizeof01.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof01.py</a></td></tr>
<tr><td> 8</td><td>asizeof02.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof02.py</a></td></tr>
<tr><td> 9</td><td>asizeof03.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof03.py</a></td></tr>
<tr><td>10</td><td>asizeof04.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof04.py</a></td></tr>
<tr><td>11</td><td>asizeof05.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof05.py</a></td></tr>
<tr><td>12</td><td>asizeof06.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof06.py</a></td></tr>
<tr><td>13</td><td>asizeof07.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof07.py</a></td></tr>
<tr><td>14</td><td>asizeof08.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof08.py</a></td></tr>
<tr><td>15</td><td>asizeof09.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof09.py</a></td></tr>
<tr><td>16</td><td>asizeof10.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof10.py</a></td></tr>
<tr><td>17</td><td>asizeof11.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/">https://github.com/tisnik/most-popular-python-libs/blob/master/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Top 5 Python Memory Profilers<br />
<a href="https://stackify.com/top-5-python-memory-profilers/">https://stackify.com/top-5-python-memory-profilers/</a>
</li>

<li>Pympler na GitHubu<br />
<a href="https://github.com/pympler/pympler">https://github.com/pympler/pympler</a>
</li>

<li>Pympler na PyPI<br />
<a href="https://pypi.org/project/Pympler/">https://pypi.org/project/Pympler/</a>
</li>

<li>Dokumentace k&nbsp;balíčku Pympler<br />
<a href="https://pympler.readthedocs.io/en/latest/">https://pympler.readthedocs.io/en/latest/</a>
</li>

<li>Guppy 3 na GitHubu<br />
<a href="https://github.com/zhuyifei1999/guppy3/">https://github.com/zhuyifei1999/guppy3/</a>
</li>

<li>Guppy 3 na PyPI<br />
<a href="https://pypi.org/project/guppy3/">https://pypi.org/project/guppy3/</a>
</li>

<li>Memory Profiler na GitHubu<br />
<a href="https://github.com/pythonprofilers/memory_profiler">https://github.com/pythonprofilers/memory_profiler</a>
</li>

<li>Memory Profiler na PyPI<br />
<a href="https://pypi.org/project/memory-profiler/">https://pypi.org/project/memory-profiler/</a>
</li>

<li>How to use guppy/heapy for tracking down memory usage<br />
<a href="https://smira.ru/wp-content/uploads/2011/08/heapy.html">https://smira.ru/wp-content/uploads/2011/08/heapy.html</a>
</li>

<li>Identifying memory leaks<br />
<a href="https://pympler.readthedocs.io/en/latest/muppy.html#muppy">https://pympler.readthedocs.io/en/latest/muppy.html#muppy</a>
</li>

<li>How do I determine the size of an object in Python?<br />
<a href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python</a>
</li>

<li>Why is bool a subclass of int?<br />
<a href="https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int">https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int</a>
</li>

<li>Memory Management in Python<br />
<a href="https://realpython.com/python-memory-management/">https://realpython.com/python-memory-management/</a>
</li>

<li>Why do ints require three times as much memory in Python?<br />
<a href="https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python">https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python</a>
</li>

<li>cpython/Include/cpython/longintrepr.h<br />
<a href="https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64">https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64</a>
</li>

<li>sys — System-specific parameters and functions<br />
<a href="https://docs.python.org/3/library/sys.html">https://docs.python.org/3/library/sys.html</a>
</li>

<li>Python 3.3 s&nbsp;flexibilní reprezentací řetězců<br />
<a href="https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/#k17">https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/#k17</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

