<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Detekce velikosti hodnot uložených v operační paměti a spravovaných interpretrem Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Detekce velikosti hodnot uložených v operační paměti a spravovaných interpretrem Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V ekosystému programovacího jazyka Python je mnohdy užitečné zjistit, jaký objem operační paměti zabírají hodnoty (objekty), s nimiž se v aplikacích psaných v Pythonu pracuje. Kupodivu se nejedná o zcela triviální úlohu, protože tak dynamický jazyk, jakým Python je, neposkytuje programátorům obdobu konstrukce sizeof. Namísto toho je mnohdy nutné využít nestandardní balíčky.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Detekce velikosti hodnot uložených v&nbsp;operační paměti a spravovaných interpretrem Pythonu</a></p>
<p><a href="#k02">2. Standardní funkce <strong>getsizeof</strong> z&nbsp;balíčku <strong>sys</strong></a></p>
<p><a href="#k03">3. Zjištění velikosti hodnot standardních skalárních datových typů Pythonu</a></p>
<p><a href="#k04">4. Velikosti objektů představujících řetězce</a></p>
<p><a href="#k05">5. Zjištění velikosti hodnot uložených do standardních kolekcí Pythonu</a></p>
<p><a href="#k06">6. Velikosti skalárních hodnot i kolekcí</a></p>
<p><a href="#k07">7. Velikosti funkcí v&nbsp;operační paměti zjišťované pomocí <strong>getsizeof</strong></a></p>
<p><a href="#k08">8. Velikosti tříd a objektů zjišťované pomocí <strong>getsizeof</strong></a></p>
<p><a href="#k09">9. Balíček <i>Pympler</i></a></p>
<p><a href="#k10">10. Funkce poskytované balíčkem <strong>pympler.asizeof</strong></a></p>
<p><a href="#k11">11. Funkce <strong>asizeof.asizeof</strong> pro zjištění velikosti hodnot v&nbsp;operační paměti</p>
<p><a href="#k12">12. Zjištění a výpis velikosti skalárních hodnot i kolekcí</a></p>
<p><a href="#k13">13. Zobrazení podrobnější statistiky o velikostech hodnot</a></p>
<p><a href="#k14">14. Získání skutečné velikosti funkcí, tříd a objektů uložených v&nbsp;operační paměti</a></p>
<p><a href="#k15">15. Balíček <i>guppy3</i></a></p>
<p><a href="#k16">16. Přístup k&nbsp;informacím o objektech uložených na haldě (<i>heap</i>)</a></p>
<p><a href="#k17">17. Proč se tedy liší velikosti hodnot <strong>True</strong> a <strong>False</strong>?</a></p>
<p><a href="#k18">18. Způsob uložení celočíselných hodnot Pythonu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Detekce velikosti hodnot uložených v&nbsp;operační paměti a spravovaných interpretrem Pythonu</h2>

<p>Programovací jazyk <a href="https://www.root.cz/n/python/">Python</a> se
v&nbsp;prvních letech své existence používal především pro tvorbu pomocných
systémových a jiných skriptů; jednalo se tedy o (čitelnější) náhradu za Perl,
BASH (či jiný v&nbsp;té době existující shell) a AWK. Ovšem v&nbsp;současnosti
se Python používá i v&nbsp;mnoha dalších oblastech informatiky, mnohdy i pro
tvorbu rozsáhlých aplikací a služeb. A právě ve chvíli, kdy se Python nasazuje
i ve velkých aplikacích popř.&nbsp;pokud se používá pro zpracování dat
s&nbsp;velkým objemem, se často objevují požadavky na snížení paměťové
náročnosti těchto systémů.</p>

<p>Z&nbsp;tohoto důvodu je vhodné alespoň zhruba vědět, jak velké oblasti
paměti jsou obsazeny jednotlivými hodnotami, které se v&nbsp;aplikacích psaných
v&nbsp;Pythonu používají. Jak však zjistit velikost objektů (resp.&nbsp;obecně
řečeno velikost hodnot) uložených v&nbsp;RAM?  K&nbsp;tomuto účelu slouží jedna
funkce ze standardní knihovny a taktéž další pomocné balíčky, s&nbsp;nimiž se
postupně seznámíme.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Standardní funkce <strong>getsizeof</strong> z&nbsp;balíčku <strong>sys</strong></h2>

<p>V&nbsp;případě, že postačuje zjistit pouze přibližné nároky jednotlivých
objektů (resp.&nbsp;přesněji řečeno jejich hodnot) na dostupnou kapacitu
operační paměti, není nutné instalovat žádné dodatečné balíčky, protože
podobnou funkci nabízí i funkce <a
href="https://docs.python.org/3/library/sys.html#sys.getsizeof">getsizeof</a>
ze standardního balíčku <a
href="https://docs.python.org/3/library/sys.html">sys</a>:</p>

<pre>
from <strong>sys</strong> import <strong>getsizeof</strong>
&nbsp;
help(<strong>getsizeof</strong>)
</pre>

<p>Nápověda k&nbsp;této funkci je velmi stručná a neobsahuje například
informaci, zda vrácená velikost (v&nbsp;bajtech) je skutečnou velikostí objektu
nebo se vrací velikost bloku paměti alokované pro zkoumaný objekt. To totiž
není totéž &ndash; už jen kvůli zarovnání paměťových bloků:</p>

<pre>
Help on built-in function getsizeof in module sys:
&nbsp;
getsizeof(...)
    getsizeof(object [, default]) -&gt; int
&nbsp;
    Return the size of object in bytes.
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zjištění velikosti hodnot standardních skalárních datových typů Pythonu</h2>

<p>Způsob použití <a href="#k02">výše zmíněné funkce <strong>sys</strong></a>
si můžeme otestovat na skriptu, v&nbsp;němž prozkoumáme velikost hodnot
základních skalárních datových typů programovacího jazyka Python. Bude se
konkrétně jednat o celá čísla (tedy <strong>long</strong> v&nbsp;Pythonu 3),
numerické hodnoty s&nbsp;plovoucí řádovou čárkou, pravdivostní hodnoty, hodnotu
<strong>None</strong> a o řetězce (které jsou kupodivu taktéž považovány za
skalární hodnoty). Pro zajímavost jsme do skriptu přidali ještě hodnoty
posledního skalárního typu &ndash; komplexních čísel:</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(0)
print_sizeof(1)
print_sizeof(42)
print_sizeof(2&lt;&lt;30)
print_sizeof(2&lt;&lt;60)
print()
&nbsp;
print_sizeof(1.0)
print_sizeof(3.1415)
print()
&nbsp;
print_sizeof(1+2j)
print_sizeof(1.2+3.4j)
print()
&nbsp;
print_sizeof(True)
print_sizeof(False)
print_sizeof(None)
print()
&nbsp;
print_sizeof("")
print_sizeof("f")
print_sizeof("fo")
print_sizeof("foo")
print_sizeof("foo bar")
print_sizeof("foo bar baz")
print_sizeof("foo bar baz xyz")
print_sizeof("foo bar baz xyzzy")
</pre>

<p>Zajímavé bude zjistit, jaké velikosti se vlastně vrací (viz první
sloupec):</p>

<pre>
24       int             0
28       int             1
28       int             42
32       int             2147483648
36       int             2305843009213693952
&nbsp;
24       float           1.0
24       float           3.1415
&nbsp;
32       complex         (1+2j)
32       complex         (1.2+3.4j)
&nbsp;
28       bool            True
24       bool            False
16       NoneType        None
&nbsp;
49       str             
50       str             f
51       str             fo
52       str             foo
56       str             foo bar
60       str             foo bar baz
64       str             foo bar baz xyz
66       str             foo bar baz xyzzy
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si například rozdílu mezi
<strong>True</strong> a <strong>False</strong>. Proč se vrací odlišné hodnoty
bude vysvětleno <a href="#k17">v&nbsp;sedmnácté</a> a <a href="#k18">osmnácté
kapitole</a>. Taktéž je zajímavé, že celočíselné hodnoty mají (obecně)
rozdílnou velikost, což si opět vysvětlíme v&nbsp;navazujícím textu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Velikosti objektů představujících řetězce</h2>

<p>Nejjednodušší je situace u řetězců, protože základní velikost objektu typu
řetězec (přesněji prázdný řetězec) je 49 bajtů a každý další přidaný znak
znamená, že se velikost objektu zvýší o jeden až čtyři bajty, v&nbsp;závislosti
na konkrétních znacích uložených v&nbsp;řetězci.</p>

<p>V&nbsp;programovacím jazyku Python verze totiž 3.3 došlo k&nbsp;poměrně
významné změně, která se týká způsobu interního uložení řetězců. Autoři Pythonu
si totiž uvědomili, že na jednu stranu je sice důležité a velmi žádoucí
podporovat Unicode (a to celé Unicode, tedy žádný subset typu <a
href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">BMP</a>,
vzhledem k&nbsp;normě <a href="https://en.wikipedia.org/wiki/GB_18030">GB
18030</a>) ovšem v&nbsp;mnoha případech to vede k&nbsp;tomu, že se do operační
paměti ukládá až čtyřikrát větší množství dat, než je skutečně nutné, protože
mnoho řetězců používaných v&nbsp;každodenní praxi obsahuje pouze ASCII znaky
(příkladem mohou být URL). Navíc větší množství dat uložených v&nbsp;paměti
znamená, že se při manipulaci s&nbsp;nimi bude hůře využívat procesorová cache.
Proto došlo v&nbsp;rámci <a
href="https://www.python.org/dev/peps/pep-0393/">PEP 393</a> k&nbsp;takové
úpravě, která zajistí možnost uložení řetězců ve třech formátech, což je
naznačeno v&nbsp;tabulce:</p>

<table>
<tr><th>Šířka znaku</th><th>Kódování</th><th>Prefix při zápisu kódu</th></tr>
<tr><td>1 bajt</td><td>Latin-1</td><td>\x</td></tr>
<tr><td>2 bajty</td><td>UCS-2</td><td>\u</td></tr>
<tr><td>4 bajty</td><td>UCS-4</td><td>\U</td></tr>
</table>

<p>Tyto změny by měly být pro programátory i uživatele zcela transparentní,
takže by se nemělo stát, že by například do řetězce původně uloženého
s&nbsp;kódováním Latin-1 (nadmnožina ASCII) nešel uložit například znak
v&nbsp;azbuce &ndash; ostatně řetězce jsou v&nbsp;Pythonu neměnitelné, takže se
konverze provede v&nbsp;rámci prováděné operace automaticky.</p>

<p>Podívejme se nyní, jak je výběr formátu pro uložení řetězce prováděn při
interpretaci řetězcového literálu. Nejprve importujeme modul
<strong>sys</strong>, který nabízí funkci <strong>getsizeof()</strong>:</p>

<pre>
&gt;&gt;&gt; import sys
</pre>

<p>Zjistíme velikost objektu reprezentujícího prázdný řetězec. Tato velikost se
může lišit podle verze Pythonu a použité architektury, nás však budou zajímat
rozdíly oproti této hodnotě:</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("")
49
</pre>

<p>Zjistíme velikost objektu řetězce s&nbsp;jedním ASCII znakem (měla by být o
jedničku vyšší, než hodnota předchozí) a taktéž velikost objektu řetězce
s&nbsp;jedenácti znaky (bude se lišit o deset bajtů oproti hodnotě předchozí).
Výsledek je zřejmý &ndash; každý znak je v&nbsp;tomto případě reprezentován
jediným bajtem:</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("e")
50
&gt;&gt;&gt; sys.getsizeof("e 123456789")
60
</pre>

<p>Nyní vytvoříme řetězec s&nbsp;ne-ASCII znakem. Velikost příslušného objektu
se zvětší (opět nás však bude zajímat rozdíl oproti této velikosti, ne její
absolutní hodnota):</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("ě")
76
</pre>

<p>Dále vypočteme velikost řetězce s&nbsp;ne-ASCII znakem, po němž následuje
deset ASCII znaků. Vidíme, že každý znak je uložen ve dvou bajtech &ndash;
prvním znakem byl určen interní formát řetězce:</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("ě 123456789")
96
</pre>

<p>Zkusme si nyní vytvořit řetězec s&nbsp;jediným znakem, který nepatří do BPM,
tedy ho nelze reprezentovat v&nbsp;UCS-2. Posléze k&nbsp;tomuto znaku přidáme
dalších deset znaků a snadno zjistíme, že v&nbsp;tomto případě je každý znak
reprezentován čtyřmi bajty ((120-80)/10):</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("\U0001ffff")
80
&gt;&gt;&gt; sys.getsizeof("\U0001ffff 123456789")
120
</pre>

<p>Jen pro zajímavost se můžeme podívat, jak celý objekt s&nbsp;řetězcem
vypadá. U ASCII řetězců:</p>

<pre>
&gt;&gt;&gt; bytearray((ctypes.c_byte*sys.getsizeof("Hello world!")).from_address(id("Hello world!")))
bytearray(b'\x02\x00\x00\x00\x00\x00\x00\x00\x00\x89\x96\x00
\x00\x00\x00\x00\x0c\x00\x00\x00\x00\x00\x00\x00\x17L\xc6c\x01
\xc0\x08a\xe4\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00Hello world!\x00')
</pre>

<p>U řetězců reprezentovaných v&nbsp;UCS-2:</p>

<pre>
&gt;&gt;&gt; bytearray((ctypes.c_byte*sys.getsizeof("ěščřžýáíéúů")).from_address(id("ěščřžýáíéúů")))
bytearray(b'\x02\x00\x00\x00\x00\x00\x00\x00\x00\x89\x96\x00
\x00\x00\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x98\xd8J\xd9
\xd5\xb7\xd0\x9d\xa8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1b
\x01a\x01\r\x01Y\x01~\x01\xfd\x00\xe1\x00\xed\x00\xe9\x00\xfa
\x00o\x01\x00\x00')
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zjištění velikosti hodnot uložených do standardních kolekcí Pythonu</h2>

<p>V&nbsp;dalším kroku použijeme funkci <strong>getsizeof</strong> pro zjištění
velikosti kolekcí, tedy n-tic, seznamů a asociativních polí (můžet si do
příkladu přidat i množiny):</p>

<pre>
from sys import <strong>getsizeof</strong>
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(())
print_sizeof((1,))
print_sizeof((1, 2))
print_sizeof((1, 2, 3))
print_sizeof((1, 2, 3, 4))
print_sizeof((1, 2, 3, 4, 5))
print_sizeof((1, 2, 3, 4, 5, 6))
print()
&nbsp;
print_sizeof([])
print_sizeof([1])
print_sizeof([1, 2])
print_sizeof([1, 2, 3])
print_sizeof([1, 2, 3, 4])
print_sizeof([1, 2, 3, 4, 5])
print_sizeof([1, 2, 3, 4, 5, 6])
print()
&nbsp;
print_sizeof({})
print_sizeof({1:1})
print_sizeof({1:1, 2:2})
print_sizeof({1:1, 2:2, 3:3})
print_sizeof({1:1, 2:2, 3:3, 4:4})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5, 6:6})
</pre>

<p>Výsledky ukazují, jak se velikosti kolekcí postupně zvětšují společně se
zvyšujícím se počtem prvků:</p>

<pre>
40       tuple           ()
48       tuple           (1,)
56       tuple           (1, 2)
64       tuple           (1, 2, 3)
72       tuple           (1, 2, 3, 4)
80       tuple           (1, 2, 3, 4, 5)
88       tuple           (1, 2, 3, 4, 5, 6)
&nbsp;
56       list            []
64       list            [1]
72       list            [1, 2]
80       list            [1, 2, 3]
88       list            [1, 2, 3, 4]
96       list            [1, 2, 3, 4, 5]
104      list            [1, 2, 3, 4, 5, 7]
&nbsp;
64       dict            {}
232      dict            {1: 1}
232      dict            {1: 1, 2: 2}
232      dict            {1: 1, 2: 2, 3: 3}
232      dict            {1: 1, 2: 2, 3: 3, 4: 4}
232      dict            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}
360      dict            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6}
</pre>

<p>Ukazují se však skutečně velikosti všech hodnot, nebo pouze velikosti
referencí uložených v&nbsp;kolekcích (v&nbsp;Pythonu je vše reference)? To
zjistíme snadno &ndash; zkusíme do kolekce uložit řetězce s&nbsp;milionem
znaků:</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename)
&nbsp;
&nbsp;
print_sizeof((1, 2))
print_sizeof((1, <strong>"?" * 1000000</strong>))
print()
&nbsp;
print_sizeof([1, 2])
print_sizeof([1, <strong>"?" * 1000000</strong>])
print()
&nbsp;
print_sizeof({1:1, 2:2})
print_sizeof({1:1, <strong>2:"?" * 1000000</strong>})
</pre>

<p>Z&nbsp;výsledků je jasně patrné, že se velikosti samotných hodnot do
výsledku nezapočítávají:</p>

<pre>
56       tuple   
56       tuple   
&nbsp;
72       list    
72       list    
&nbsp;
232      dict    
232      dict    
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Velikosti skalárních hodnot i kolekcí</h2>

<p>Hodnoty získané výše uvedenými skripty nám pomohly získat alespoň základní
představu o tom, jaký objem RAM je potřeba pro uložení skalárních hodnot i
prvků do základních kolekcí. Shrnutí platné pro současné verze Pythonu 3
(budoucí verze Pythonu mohou mít odlišné požadavky) je uvedeno
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Datový typ</th><th>Význam</th><th>Minimální velikost</th><th>Další růst</th></tr>
<tr><td>long</td><td>celé číslo</td><td>28</td><td>+4 bajty pro každou mocninu 2<sup>30</sup></td></tr>
<tr><td>float</td><td>číslo s&nbsp;plovoucí řádovou čárkou</td><td>24</td><td>&times;</td></tr>
<tr><td>complex</td><td>komplexní číslo s&nbsp;plovoucí řádovou čárkou</td><td>32</td><td>&times;</td></tr>
<tr><td>bool</td><td>True nebo False</td><td>24/28</td><td>&times;</td></tr>
<tr><td>NoneType</td><td>hodnota <strong>none</strong></td><td>16</td><td>&times;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>string</td><td>řetězec</td><td>49</td><td>+1 až 4 bajty pro každý další znak (již známe)</td></tr>
<tr><td>tuple</td><td>n-tice</td><td>40</td><td>+8 bajtů pro každý další prvek n-tice</td></tr>
<tr><td>list</td><td>seznam</td><td>56</td><td>+8 bajtů pro každý další prvek seznamu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>set</td><td>množina</td><td>216</td><td>5 prvků: 728, 19 prvků: 2264, ..., 77 prvků: 8408, ...</td></tr>
<tr><td>dict</td><td>slovník</td><td>64</td><td>1 prvek 232, 6 prvků: 360; 22 prvků: 1184; ...</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: z&nbsp;výše uvedené tabulky je patrné,
že hodnoty můžeme zhruba rozdělit do tří skupin. V&nbsp;první skupině jsou
skalární hodnoty s&nbsp;buď pevnou velikostí, nebo velikostí, která roste pro
vyšší hodnoty (celá čísla). Ve druhé skupině nalezneme &bdquo;lineární&ldquo;
datové typy, jejichž velikosti rostou lineárně s&nbsp;počtem uložených prvků
(nebo s&nbsp;počtem znaků pro řetězce). A konečně ve třetí skupině jsou množiny
a slovníky, které pochopitelně musí taktéž růst s&nbsp;rostoucím počtem
uložených prvků, ale růst není striktně lineární &ndash; paměť se totiž alokuje
po větších blocích, což je v&nbsp;IT velmi častá forma optimalizace.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Velikosti funkcí v&nbsp;operační paměti zjišťované pomocí <strong>getsizeof</strong></h2>

<p>Velmi důležitým datovým typem je v&nbsp;programovacím jazyku Python funkce.
Podobně jako v&nbsp;případě hodnot dalších typů může být v&nbsp;operační paměti
uloženo (obecně) libovolné množství hodnot typu funkce. Vyzkoušejme si tedy,
jakou velikost (chápáno jaké množství bajtů) funkce vrací standardní volání
<strong>sys.getsizeof</strong>, a to pro různě definované funkce:</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
def <strong>foo</strong>():
    pass
&nbsp;
&nbsp;
def <strong>bar</strong>(x, y):
    return x+y
&nbsp;
&nbsp;
def <strong>baz</strong>(x=0, y=1):
    print(x)
    print(y)
    return x+y
&nbsp;
&nbsp;
print_sizeof(print)
print_sizeof(foo)
print_sizeof(bar)
print_sizeof(baz)
</pre>

<p>Získané výsledky vypadají následovně:</p>

<pre>
72       builtin_function_or_method      &lt;built-in function print&gt;
136      function        &lt;function foo at 0x7fcea02f8160&gt;
136      function        &lt;function bar at 0x7fcea02f81f0&gt;
136      function        &lt;function baz at 0x7fcea02f8280&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: později uvidíme, že tyto velikosti
nejsou vypočteny přesně, protože se vrací pouze velikost &bdquo;slotu&ldquo;
pro funkci.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Velikosti tříd a objektů zjišťované pomocí <strong>getsizeof</strong></h2>

<p>Standardní funkce <strong>sys.getsizeof</strong> může být použita i pro
zjištění velikosti tříd (což jsou taktéž hodnoty) a instancí tříd neboli
objektů. Opět se podívejme na jednoduchý příklad, v&nbsp;němž tyto hodnoty
zjišťujeme:</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
class <strong>C1</strong>:
    pass
&nbsp;
&nbsp;
class <strong>C2</strong>:
    def <strong>__init__</strong>(self):
        pass
&nbsp;
class <strong>C3</strong>:
    def __init__(self):
        pass
&nbsp;
    def <strong>foo</strong>(self, x):
        self.x=x
&nbsp;
    def <strong>bar</strong>(self, y):
        self.y=y
&nbsp;
&nbsp;
o1 = C1()
o2 = C2()
o3 = C3()
&nbsp;
print_sizeof(C1)
print_sizeof(o1)
&nbsp;
print_sizeof(C2)
print_sizeof(o2)
&nbsp;
print_sizeof(C3)
print_sizeof(o3)
&nbsp;
o3.foo(42)
&nbsp;
print_sizeof(C3)
print_sizeof(o3)
&nbsp;
o3.bar(0)
&nbsp;
print_sizeof(C3)
print_sizeof(o3)
</pre>

<p>Podívejme se na zjištěné a zobrazené velikosti objektů i tříd:</p>

<pre>
1064     type            &lt;class '__main__.C1'&gt;
48       C1              &lt;__main__.C1 object at 0x7ff7f2e20430&gt;
1064     type            &lt;class '__main__.C2'&gt;
48       C2              &lt;__main__.C2 object at 0x7ff7f2e20040&gt;
1064     type            &lt;class '__main__.C3'&gt;
48       C3              &lt;__main__.C3 object at 0x7ff7f2e20190&gt;
1064     type            &lt;class '__main__.C3'&gt;
48       C3              &lt;__main__.C3 object at 0x7ff7f2e20190&gt;
1064     type            &lt;class '__main__.C3'&gt;
48       C3              &lt;__main__.C3 object at 0x7ff7f2e20190&gt;
</pre>

<p>Popř.&nbsp;lze příklad nepatrně upravit tak, že naplníme atribut objektu tím
samým objektem (resp.&nbsp;referencí na ten samý objekt):</p>

<pre>
from sys import getsizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(getsizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
class <strong>C4</strong>:
    def <strong>__init__</strong>(self):
        pass
&nbsp;
    def <strong>foo</strong>(self, x):
        self.x=x
&nbsp;
&nbsp;
o4 = C4()
&nbsp;
print_sizeof(C4)
print_sizeof(o4)
&nbsp;
o4.foo(o4)
&nbsp;
print_sizeof(C4)
print_sizeof(o4)
</pre>

<p>Výsledky nyní budou vypadat následovně:</p>

<pre>
1064     type            &lt;class '__main__.C4'&gt;
48       C4              &lt;__main__.C4 object at 0x7f7f2f0d6430&gt;
1064     type            &lt;class '__main__.C4'&gt;
48       C4              &lt;__main__.C4 object at 0x7f7f2f0d6430&gt;
</pre>

<p>Naše znalosti o velikosti hodnot tedy můžeme doplnit takto:</p>

<table>
<tr><th>Datový typ</th><th>Význam</th><th>Minimální velikost</th><th>Další růst</th></tr>
<tr><td>func</td><td>funkce</td><td>136</td><td>&nbsp;</td></tr>
<tr><td>class</td><td>definice třídy</td><td>1064</td><td>&nbsp;</td></tr>
<tr><td>inst</td><td>instance třídy</td><td>48</td><td>jako u slovníků pro každý další atribut</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: dále opět uvidíme, jak je možné zjistit
velikost těchto hodnot přesnějším způsobem &ndash; výsledky získané přes
<strong>sys.getsizeof</strong> totiž v&nbsp;tomto případě v&nbsp;žádném případě
nejsou přesné.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Balíček <i>Pympler</i></h2>

<p>Největší předností výše popsané funkce <strong>sys.getsizeof</strong> je
fakt, že se jedná o funkci ze standardní knihovny <strong>sys</strong>. To
mj.&nbsp;znamená, že tuto funkci je možné zavolat prakticky kdykoli a kdekoli,
a to bez nutnosti instalace nějakých dalších balíčků. Ovšem tato funkce není
příliš dokonalá, protože například neumožňuje zjistit velikost hodnot
v&nbsp;operační paměti po zarovnání, protože alokátor paměti alokuje nové bloky
vždy na adresách dělitelných nějakou konstantou 4, 8 či 16 (podle systému a
architektury) a tudíž vlastně nebudou využity bajty umístěné těsně za koncem
bloku v&nbsp;případě, že velikost bloku není dělitelná výše uvedenou
konstantou. A navíc má tato standardní funkce problémy se zjištěním velikosti
tříd a objektů, protože automaticky nezapočítává velikosti jednotlivých
atributů atd.</p>

<p>Existují však i další (ovšem nutno dodat, že již nestandardní) balíčky,
které &bdquo;opravují&ldquo; chování funkce <strong>sys.getsizeof</strong> a
navíc nabízí uživatelům i další zajímavou a potenciálně užitečnou
funkcionalitu. Tyto balíčky je však pochopitelně nutné nejdříve nainstalovat.
Prvním z&nbsp;balíčků, o nichž se dnes alespoň ve stručnosti zmíníme, je
balíček nazvaný <strong>Pympler</strong>. Vzhledem k&nbsp;tomu, že je
zaregistrovaný na <i>PyPi</i>, je instalace tohoto balíčku triviální a můžeme
ji provést (pro právě přihlášeného uživatele) tímto příkazem:</p>

<pre>
$ <strong>pip3 install --user pympler</strong>
</pre>

<p>Samotná instalace proběhne prakticky okamžitě:</p>

<pre>
Collecting pympler
  Downloading Pympler-1.0.1-py3-none-any.whl (164 kB)
     |████████████████████████████████| 164 kB 1.5 MB/s 
Installing collected packages: pympler
Successfully installed pympler-1.0.1
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě můžete provést instalaci i
tohoto balíčku v&nbsp;rámci virtuálního prostředí Pythonu atd.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce poskytované balíčkem <strong>pympler.asizeof</strong></h2>

<p>Samotný Pympler obsahuje několik podbalíčků, z&nbsp;nichž nás v&nbsp;dnešním
článku bude zajímat především podbalíček nazvaný
<strong>pympler.asizeof</strong>:</p>

<pre>
&gt;&gt;&gt; <strong>from pympler import asizeof</strong>
</pre>

<p>Podbalíček <strong>pympler.asizeof</strong> v&nbsp;současné verzi obsahuje
devět užitečných funkcí:</p>

<pre>
&gt;&gt;&gt; <strong>help(asizeof)</strong>
</pre>

<pre>
Help on module pympler.asizeof in pympler:
&nbsp;
NAME
    pympler.asizeof
&nbsp;
DESCRIPTION
    This module exposes 9 functions and 2 classes to obtain lengths and
    sizes of Python objects (for Python 3.5 or later).
&nbsp;
    Earlier versions of this module supported Python versions down to
    Python 2.2.  If you are using Python 3.5 or older, please consider
    downgrading Pympler.
&nbsp;
    **Public Functions** [#unsafe]_
&nbsp;
       Function **asizeof** calculates the combined (approximate) size
       in bytes of one or several Python objects.
&nbsp;
       Function **asizesof** returns a tuple containing the (approximate)
       size in bytes for each given Python object separately.
&nbsp;
       Function **asized** returns for each object an instance of class
       **Asized** containing all the size information of the object and
       a tuple with the referents [#refs]_.
&nbsp;
       Functions **basicsize** and **itemsize** return the *basic-*
       respectively *itemsize* of the given object, both in bytes.  For
       objects as ``array.array``, ``numpy.array``, ``numpy.matrix``,
       etc. where the item size varies depending on the instance-specific
       data type, function **itemsize** returns that item size.
&nbsp;
       Function **flatsize** returns the *flat size* of a Python object
       in bytes defined as the *basic size* plus the *item size* times
       the *length* of the given object.
&nbsp;
       Function **leng** returns the *length* of an object, like standard
       function ``len`` but extended for several types.  E.g. the **leng**
       of a multi-precision int (or long) is the number of ``digits``
       [#digit]_.  The length of most *mutable* sequence objects includes
       an estimate of the over-allocation and therefore, the **leng** value
       may differ from the standard ``len`` result.  For objects like
</pre>

<p>V&nbsp;podbalíčku však nalezneme i další více či méně zajímavé hodnoty,
které lze vypsat například takto:</p>

<pre>
from pympler import asizeof
&nbsp;
for item in dir(asizeof):
    if item[0] != "_":
        print(item)
</pre>

<p>Výsledek:</p>

<pre>
ABCMeta
Asized
Asizer
Callable
Dict
List
Optional
Struct
Tuple
Types
Union
Weakref
adict
array
asized
asizeof
asizesof
basicsize
calcsize
curdir
finditer
flatsize
isbuiltin
isclass
iscode
isframe
isfunction
ismethod
ismodule
itemsize
leng
linesep
log
named_refs
numpy
refs
stack
stat
statvfs
sys
warnings
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Funkce <strong>asizeof.asizeof</strong> pro zjištění velikosti hodnot v&nbsp;operační paměti</h2>

<p>Nejužitečnější funkce z&nbsp;podbalíčku <strong>pympler.asizeof</strong> se
jmenuje taktéž <strong>asizeof</strong>. Jedná se o v&nbsp;mnoha ohledech
vylepšenou standardní funkci <strong>sys.getsizeof</strong>, která umožňuje
vypočítat skutečné velikosti objektů uložených v&nbsp;operační paměti:</p>

<pre>
from pympler import asizeof
&nbsp;
help(asizeof.asizeof)
</pre>

<p>Tato funkce má několik zajímavých přepínačů, z&nbsp;nichž některé si
popíšeme v&nbsp;dalším textu:</p>

<pre>
Help on function asizeof in module pympler.asizeof:
&nbsp;
asizeof(*objs, **opts)
    Return the combined size (in bytes) of all objects passed
    as positional arguments.
&nbsp;
    The available options and defaults are:
&nbsp;
         *above=0*      -- threshold for largest objects stats
&nbsp;
         *align=8*      -- size alignment
&nbsp;
         *clip=80*      -- clip ``repr()`` strings
&nbsp;
         *code=False*   -- incl. (byte)code size
&nbsp;
         *cutoff=10*    -- limit large objects or profiles stats
&nbsp;
         *derive=False* -- derive from super type
&nbsp;
         *frames=False* -- ignore stack frame objects
&nbsp;
         *ignored=True* -- ignore certain types
&nbsp;
         *infer=False*  -- try to infer types
&nbsp;
         *limit=100*    -- recursion limit
&nbsp;
         *stats=0*      -- print statistics
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zjištění a výpis velikosti skalárních hodnot i kolekcí</h2>

<p>Nyní se pokusme upravit skripty pro zjišťování velikostí různých hodnot
uložených v&nbsp;operační paměti takovým způsobem, aby se namísto standardní
funkce <strong>sys-getsizeof</strong> volala funkce <strong>asizeof</strong>
z&nbsp;podbalíčku <strong>pympler.asizeof</strong>. Úprava skriptu je ve
skutečnosti minimální, ovšem umožní nám další úpravy (a taktéž výsledky se
mohou lišit).</p>

<p>Začneme skriptem, v&nbsp;němž se zjišťují velikosti skalárních hodnot, a to
včetně řetězců. Upravená varianta tohoto skriptu bude vypadat následovně:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(0)
print_sizeof(1)
print_sizeof(42)
print_sizeof(2&lt;&lt;30)
print_sizeof(2&lt;&lt;60)
print()
&nbsp;
print_sizeof(1.0)
print_sizeof(3.1415)
print()
&nbsp;
print_sizeof(1+2j)
print_sizeof(1.2+3.4j)
print()
&nbsp;
print_sizeof(True)
print_sizeof(False)
print_sizeof(None)
print()
&nbsp;
print_sizeof("")
print_sizeof("f")
print_sizeof("fo")
print_sizeof("foo")
print_sizeof("foo bar")
print_sizeof("foo bar baz")
print_sizeof("foo bar baz xyz")
print_sizeof("foo bar baz xyzzy")
</pre>

<p>Podívejme se nyní na zjištěné a vypsané výsledky:</p>

<pre>
24       int             0
32       int             1
32       int             42
32       int             2147483648
40       int             2305843009213693952
&nbsp;
24       float           1.0
24       float           3.1415
&nbsp;
32       complex         (1+2j)
32       complex         (1.2+3.4j)
&nbsp;
32       bool            True
24       bool            False
16       NoneType        None
&nbsp;
56       str             
56       str             f
56       str             fo
56       str             foo
56       str             foo bar
64       str             foo bar baz
64       str             foo bar baz xyz
72       str             foo bar baz xyzzy
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že velikosti jsou vždy
dělitelné osmi, protože <strong>asizeof</strong> počítá se zarovnáním
paměťových bloků.</div></p>

<p>V&nbsp;dalším kroku provedeme úpravu skriptu pro zjištění velikosti
kolekcí:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(())
print_sizeof((1,))
print_sizeof((1, 2))
print_sizeof((1, 2, 3))
print_sizeof((1, 2, 3, 4))
print_sizeof((1, 2, 3, 4, 5))
print_sizeof((1, 2, 3, 4, 5, 6))
print()
&nbsp;
print_sizeof([])
print_sizeof([1])
print_sizeof([1, 2])
print_sizeof([1, 2, 3])
print_sizeof([1, 2, 3, 4])
print_sizeof([1, 2, 3, 4, 5])
print_sizeof([1, 2, 3, 4, 5, 6])
print()
&nbsp;
print_sizeof({})
print_sizeof({1:1})
print_sizeof({1:1, 2:2})
print_sizeof({1:1, 2:2, 3:3})
print_sizeof({1:1, 2:2, 3:3, 4:4})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5, 6:6})
</pre>

<p>Opět je zajímavé se podívat na výsledky, které tento skript vypočítal a
zobrazil:</p>

<pre>
40       tuple           ()
80       tuple           (1,)
120      tuple           (1, 2)
160      tuple           (1, 2, 3)
200      tuple           (1, 2, 3, 4)
240      tuple           (1, 2, 3, 4, 5)
280      tuple           (1, 2, 3, 4, 5, 6)
&nbsp;
56       list            []
96       list            [1]
136      list            [1, 2]
176      list            [1, 2, 3]
216      list            [1, 2, 3, 4]
256      list            [1, 2, 3, 4, 5]
296      list            [1, 2, 3, 4, 5, 6]
&nbsp;
64       dict            {}
264      dict            {1: 1}
296      dict            {1: 1, 2: 2}
328      dict            {1: 1, 2: 2, 3: 3}
360      dict            {1: 1, 2: 2, 3: 3, 4: 4}
392      dict            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}
552      dict            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6}
</pre>

<p>Opět se podívejme na příklad s&nbsp;kolekcemi, které obsahují řetězce o délce milionu znaků (a v&nbsp;tomto případě i bajtů):</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def print_sizeof(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, code=True), "\t", typename)
&nbsp;
&nbsp;
print_sizeof((1, 2))
print_sizeof((1, <strong>"?" * 1000000)</strong>)
print()
&nbsp;
print_sizeof([1, 2])
print_sizeof([1, <strong>"?" * 1000000]</strong>)
print()
&nbsp;
print_sizeof({1:1, 2:2})
print_sizeof({1:1, <strong>2:"?" * 1000000}</strong>)
</pre>

<p>Nyní již výsledky, na rozdíl od použití <strong>sys.getsizeof</strong>, mají
praktický význam:</p>

<pre>
120       tuple   
1000144   tuple   
&nbsp;
136       list    
1000160   list    
&nbsp;
296       dict    
1000352   dict    
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zobrazení podrobnější statistiky o velikostech hodnot</h2>

<p>O hodnotách uložených v&nbsp;operační paměti lze získat i další podrobnější
informace. To provedeme takovým způsobem, že při volání funkce
<strong>asizeof</strong> kromě reference na hodnotu (objekt) použijeme i
pojmenovaný parametr <strong>stats</strong> nastavený na hodnotu odlišnou od
<strong>False</strong>. Vyzkoušejme si to nejprve pro skalární hodnoty:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, <u>stats=1</u>), "\n", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(0)
print_sizeof(1)
print_sizeof(42)
print_sizeof(2&lt;&lt;30)
print_sizeof(2&lt;&lt;60)
print()
&nbsp;
print_sizeof(1.0)
print_sizeof(3.1415)
print()
&nbsp;
print_sizeof(1+2j)
print_sizeof(1.2+3.4j)
print()
&nbsp;
print_sizeof(True)
print_sizeof(False)
print_sizeof(None)
print()
&nbsp;
print_sizeof("")
print_sizeof("f")
print_sizeof("fo")
print_sizeof("foo")
print_sizeof("foo bar")
print_sizeof("foo bar baz")
print_sizeof("foo bar baz xyz")
print_sizeof("foo bar baz xyzzy")
</pre>

<p>Z&nbsp;výsledků je patrné, že se skutečně zobrazí mnoho doplňujících
informací o každé hodnotě, a to včetně informace o zarovnání atd.:</p>

<pre>
asizeof((0,), stats=1) ...
 24 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
24 
 int             0
&nbsp;
asizeof((1,), stats=1) ...
 32 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
32 
 int             1
&nbsp;
asizeof((42,), stats=1) ...
 32 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
32 
 int             42
&nbsp;
asizeof((2147483648,), stats=1) ...
 32 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
32 
 int             2147483648
&nbsp;
asizeof((2305843009213693952,), stats=1) ...
 40 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
40 
 int             2305843009213693952
&nbsp;
&nbsp;
asizeof((1.0,), stats=1) ...
 24 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
24 
 float           1.0
&nbsp;
asizeof((3.1415,), stats=1) ...
 24 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
24 
 float           3.1415
&nbsp;
&nbsp;
asizeof(((1+2j),), stats=1) ...
 32 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
32 
 complex         (1+2j)
&nbsp;
asizeof(((1.2+3.4j),), stats=1) ...
 32 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
32 
 complex         (1.2+3.4j)
&nbsp;
&nbsp;
asizeof((True,), stats=1) ...
 32 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
32 
 bool            True
&nbsp;
asizeof((False,), stats=1) ...
 24 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
24 
 bool            False
&nbsp;
asizeof((None,), stats=1) ...
 16 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
16 
 NoneType        None
&nbsp;
&nbsp;
asizeof(('',), stats=1) ...
 56 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
56 
 str             
&nbsp;
asizeof(('f',), stats=1) ...
 56 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
56 
 str             f
&nbsp;
asizeof(('fo',), stats=1) ...
 56 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
56 
 str             fo
...
...
...
asizeof(('foo bar baz xyzzy',), stats=1) ...
 72 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
72 
 str             foo bar baz xyzzy
</pre>

<p>Podobně můžeme získat informace o kolekcích:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, <u>stats=1</u>), "\t", typename, "\t", value)
&nbsp;
&nbsp;
print_sizeof(())
print_sizeof((1,))
print_sizeof((1, 2))
print_sizeof((1, 2, 3))
print_sizeof((1, 2, 3, 4))
print_sizeof((1, 2, 3, 4, 5))
print_sizeof((1, 2, 3, 4, 5, 6))
print()
&nbsp;
print_sizeof([])
print_sizeof([1])
print_sizeof([1, 2])
print_sizeof([1, 2, 3])
print_sizeof([1, 2, 3, 4])
print_sizeof([1, 2, 3, 4, 5])
print_sizeof([1, 2, 3, 4, 5, 6])
print()
&nbsp;
print_sizeof({})
print_sizeof({1:1})
print_sizeof({1:1, 2:2})
print_sizeof({1:1, 2:2, 3:3})
print_sizeof({1:1, 2:2, 3:3, 4:4})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5})
print_sizeof({1:1, 2:2, 3:3, 4:4, 5:5, 6:6})
</pre>

<p>Výsledky (zkráceno, ovšem povšimněte si, že se detekují prvky uložené
v&nbsp;kolekcích):</p>

<pre>
asizeof(((),), stats=1) ...
 40 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
  1 deepest recursion
40       tuple           ()
...
...
...
asizeof(((1, 2, 3, 4, 5, 6),), stats=1) ...
 280 bytes
   8 byte aligned
   8 byte sizeof(void*)
   1 object given
   7 objects sized
   7 objects seen
   0 objects missed
   0 duplicates
   1 deepest recursion
280      tuple           (1, 2, 3, 4, 5, 6)
&nbsp;
&nbsp;
asizeof(([],), stats=1) ...
 56 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
  1 deepest recursion
56       list            []
...
...
...
asizeof(([1, 2, 3, 4, 5, 6],), stats=1) ...
 296 bytes
   8 byte aligned
   8 byte sizeof(void*)
   1 object given
   7 objects sized
   7 objects seen
   0 objects missed
   0 duplicates
   1 deepest recursion
296      list            [1, 2, 3, 4, 5, 6]
&nbsp;
&nbsp;
asizeof(({},), stats=1) ...
 64 bytes
  8 byte aligned
  8 byte sizeof(void*)
  1 object given
  1 object sized
  1 object seen
  0 objects missed
  0 duplicates
  1 deepest recursion
64       dict            {}
...
...
...
asizeof(({1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6},), stats=1) ...
 552 bytes
   8 byte aligned
   8 byte sizeof(void*)
   1 object given
   7 objects sized
  13 objects seen
   0 objects missed
   6 duplicates
   1 deepest recursion
552      dict            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Získání skutečné velikosti funkcí, tříd a objektů uložených v&nbsp;operační paměti</h2>

<p>Jak jsme si již řekli v&nbsp;úvodní části tohoto článku, vrací standardní
funkce <strong>sys.getsizeof</strong> pro všechny třídy stejnou velikost a
totéž do jisté míry platí i pro všechny objekty (tam ovšem již záleží na počtu
atributů). Bude tedy zajímavé zjistit, jaké hodnoty vypíše funkce
<strong>asizeof</strong>, která je interně mnohem komplikovanější, než
<strong>sys.getsizeof</strong>.</p>

<p>Začneme výpisem velikosti funkcí:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value), "\t", typename, "\t", value)
&nbsp;
&nbsp;
def <strong>foo</strong>():
    pass
&nbsp;
&nbsp;
def <strong>bar</strong>(x, y):
    return x+y
&nbsp;
&nbsp;
def <strong>baz</strong>(x=0, y=1):
    print(x)
    print(y)
    return x+y
&nbsp;
&nbsp;
print_sizeof(print)
print_sizeof(foo)
print_sizeof(bar)
print_sizeof(baz)
</pre>

<p>Výsledky jsou poněkud překvapivé:</p>

<pre>
0        builtin_function_or_method      &lt;built-in function print&gt;
0        function        &lt;function foo at 0x7f3828c4d790&gt;
0        function        &lt;function bar at 0x7f3828c4d820&gt;
0        function        &lt;function baz at 0x7f3828c4d8b0&gt;
</pre>

<p>Pro získání skutečné velikosti funkcí je nutné funkci
<strong>asizeof</strong> předat pojmenovaný parametr <strong>code</strong>
nastavený na hodnotu odlišnou od <strong>False</strong>. Příklad tedy upravíme
do následující podoby:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, <u>code=True</u>), "\t", typename, "\t", value)
&nbsp;
&nbsp;
def <strong>foo</strong>():
    pass
&nbsp;
&nbsp;
def <strong>bar</strong>(x, y):
    return x+y
&nbsp;
&nbsp;
def <strong>baz</strong>(x=0, y=1):
    print(x)
    print(y)
    return x+y
&nbsp;
&nbsp;
print_sizeof(print)
print_sizeof(foo)
print_sizeof(bar)
print_sizeof(baz)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
0        builtin_function_or_method      &lt;built-in function print&gt;
736      function        &lt;function foo at 0x7f3ced833790&gt;
912      function        &lt;function bar at 0x7f3ced833820&gt;
1032     function        &lt;function baz at 0x7f3ced8338b0&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že pro interní funkce
interpretru se nevrací korektní hodnota.</div></p>

<p>Podobně můžeme postupovat i při získávání velikostí tříd a objektů &ndash;
opět je více než vhodné použít parametr <strong>code</strong> v&nbsp;případě,
že nás zajímá skutečná velikost objektu jak s&nbsp;kódem, tak i
s&nbsp;atributy:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, code=True), "\t", typename, "\t", value)
&nbsp;
&nbsp;
class <strong>C1</strong>:
    pass
&nbsp;
&nbsp;
class <strong>C2</strong>:
    def <strong>__init__</strong>(self):
        pass
&nbsp;
class <strong>C3</strong>:
    def <strong>__init__</strong>(self):
        pass
&nbsp;
    def <strong>foo</strong>(self, x):
        self.x=x
&nbsp;
    def <strong>bar</strong>(self, y):
        self.y=y
&nbsp;
&nbsp;
o1 = C1()
o2 = C2()
o3 = C3()
&nbsp;
print_sizeof(C1)
print_sizeof(o1)
&nbsp;
print_sizeof(C2)
print_sizeof(o2)
&nbsp;
print_sizeof(C3)
print_sizeof(o3)
&nbsp;
o3.foo(42)
&nbsp;
print_sizeof(C3)
print_sizeof(o3)
&nbsp;
o3.bar(0)
&nbsp;
print_sizeof(C3)
print_sizeof(o3)
</pre>

<p>Výsledky:</p>

<pre>
1672     type            &lt;class '__main__.C1'&gt;
1824     C1              &lt;__main__.C1 object at 0x7fb416e05430&gt;
2504     type            &lt;class '__main__.C2'&gt;
2656     C2              &lt;__main__.C2 object at 0x7fb416e05040&gt;
3832     type            &lt;class '__main__.C3'&gt;
3984     C3              &lt;__main__.C3 object at 0x7fb416e05190&gt;
3832     type            &lt;class '__main__.C3'&gt;
4016     C3              &lt;__main__.C3 object at 0x7fb416e05190&gt;
3832     type            &lt;class '__main__.C3'&gt;
4016     C3              &lt;__main__.C3 object at 0x7fb416e05190&gt;
</pre>

<p>A konečně si ukažme, se není velkým problémem ani situace, kdy objekt
obsahuje referenci na sebe sama:</p>

<pre>
from pympler import asizeof
&nbsp;
&nbsp;
def <strong>print_sizeof</strong>(value):
    typename = "{:8}".format(type(value).__name__)
    print(asizeof.asizeof(value, code=True), "\t", typename, "\t", value)
&nbsp;
&nbsp;
class <strong>C4</strong>:
    def <strong>__init__</strong>(self):
        pass
&nbsp;
    def <strong>foo</strong>(self, x):
        self.x=x
&nbsp;
&nbsp;
o4 = C4()
&nbsp;
print_sizeof(C4)
print_sizeof(o4)
&nbsp;
o4.foo(o4)
&nbsp;
print_sizeof(C4)
print_sizeof(o4)
</pre>

<p>Výsledek:</p>

<pre>
3184     type            &lt;class '__main__.C4'&gt;
3336     C4              &lt;__main__.C4 object at 0x7fc7f42b9430&gt;
3184     type            &lt;class '__main__.C4'&gt;
3336     C4              &lt;__main__.C4 object at 0x7fc7f42b9430&gt;
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Balíček <i>guppy3</i></h2>

<p>Kromě balíčku <strong>Pympler</strong>, jehož (prozatím velmi malou část)
jsme si dnes popsali, ovšem existují i další balíčky, které se používají ve
chvílích, kdy je nutné zjistit chování aplikace z&nbsp;hlediska spotřeby
operační paměti. Mezi velmi užitečný balíček z&nbsp;této oblasti patří balíček
nazvaný <strong>guppy</strong>, který je již možné využít pro analýzu chování
celé aplikace, tedy nejenom pro zjištění velikosti jednotlivých hodnot (navíc
typicky nemá programátor přehled o všech hodnotách, které jsou v&nbsp;paměti
uloženy, protože některé z&nbsp;těchto hodnot využívá samotný interpret atd.).
I tento balíček je dostupný na <i>PyPi</i>, takže je jeho instalace
triviální:</p>

<pre>
$ <strong>pip3 install --user guppy3</strong>
</pre>

<pre>
Collecting guppy3
  Downloading guppy3-3.1.2-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (649 kB)
     |████████████████████████████████| 649 kB 1.6 MB/s 
Installing collected packages: guppy3
Successfully installed guppy3-3.1.2
</pre>

<p><div class="rs-tip-major">Poznámka: trojka v&nbsp;názvu tohoto balíčku
značí, že se jedná o port původního balíčku určeného pro Python 2 do Pythonu
3.</div></p>

<p>Po instalaci si otestujeme, zda je nově nainstalovaný balíček skutečně
dostupný i z&nbsp;interpretru Pythonu (konkrétně se zaměříme na balíček
<strong>hpy</strong> s&nbsp;informacemi o objektech uložených na haldě):</p>

<pre>
&gt;&gt;&gt; <strong>from guppy import hpy</strong>
&nbsp;
&gt;&gt;&gt; <strong>h=hpy()</strong>
&nbsp;
&gt;&gt;&gt; <strong>h.doc</strong>
&nbsp;
Top level interface to Heapy. Available attributes:
Anything            Prod                Via                 iso
Clodo               Rcs                 doc                 load
Id                  Root                findex              monitor
Idset               Size                heap                pb
Module              Type                heapu               setref
Nothing             Unity               idset               test
</pre>

<p>a:</p>

<pre>
&gt;&gt;&gt; <strong>help(hpy)</strong>
&nbsp;
&nbsp;
Help on function hpy in module guppy:
&nbsp;
hpy(ht=None)
    Main entry point to the Heapy system.
    Returns an object that provides a session context and will import
    required modules on demand. Some commononly used methods are:
&nbsp;
    .heap()                 get a view of the current reachable heap
    .iso(obj..)     get information about specific objects
&nbsp;
    The optional argument, useful for debugging heapy itself, is:
&nbsp;
        ht     an alternative hiding tag
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Přístup k&nbsp;informacím o objektech uložených na haldě (<i>heap</i>)</h2>

<p>Pravděpodobně zcela nejužitečnější funkcí nabízenou celým balíčkem
<strong>guppy3</strong> je metoda <strong>heap</strong> dostupná přes třídy
z&nbsp;podbalíčku <strong>heapy</strong> (hpy). Tato metoda umožňuje získat
informace o hodnotách (objektech) uložených na haldě a vracet tyto informace
v&nbsp;podobě, která je snadno programově zpracovatelná. Nalezneme zde i různé
další varianty této metody, například <strong>heapu</strong> atd.:</p>

<pre>
Help on method heap in module guppy.heapy.Use:
&nbsp;
heap() method of guppy.heapy.Use._GLUECLAMP_ instance
    heap() -&gt; IdentitySet[1]
&nbsp;
    Traverse the heap from a root to find all reachable and visible
    objects. The objects that belong to a heapy instance are normally not
    included. Return an IdentitySet with the objects found, which is
    presented as a table partitioned according to a default equivalence
    relation (Clodo [3]).
&nbsp;
    See also: setref[2]
&nbsp;
    References
        [0] heapy_Use.html#heapykinds.Use.heap
        [1] heapy_UniSet.html#heapykinds.IdentitySet
        [2] heapy_Use.html#heapykinds.Use.setref
        [3] heapy_Use.html#heapykinds.Use.Clodo
&nbsp;
&nbsp;
heapu(rma=1, abs=0, stat=1) method of guppy.heapy.Use._GLUECLAMP_ instance
    heapu() -&gt; Stat
&nbsp;
    Finds the objects in the heap that remain after garbage collection but
    are _not_ reachable from the root.  This can be used to find objects
    in extension modules that remain in memory even though they are
    gc-collectable and not reachable.
&nbsp;
    Returns an object containing a statistical summary of the objects
    found - not the objects themselves. This is to avoid making the
    objects reachable.
&nbsp;
    See also: setref[1]
&nbsp;
    References
        [0] heapy_Use.html#heapykinds.Use.heapu
        [1] heapy_Use.html#heapykinds.Use.setref
</pre>

<p>Podívejme se nyní na některé způsoby použití metody <strong>heap</strong>.
Získáme souhrnné informace o všech objektech na haldě a necháme si zobrazit
jejich statistiku. K&nbsp;tomu nám postačují pouhé tři řádky kódu:</p>

<pre>
from guppy import hpy
&nbsp;
h=<strong>hpy()</strong>
print(<strong>h.heap()</strong>)
</pre>

<p>Výsledkem bude tabulka, která obsahuje jak informace o celkovém počtu
objektů (120000 objektů pro interpretaci programu se třemi řádky!!!), tak i
celkové obsazení haldy. To však není vše, protože objekty jsou rozděleny do
skupin podle jejich typu (<strong>str</strong>, <strong>tuple</strong> atd.) a
tabulka obsahuje jak celkový počet objektů daného typu, tak i obsazení
paměti:</p>

<pre>
Partition of a set of 121759 objects. Total size = 12892713 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0  31829  26  2973098  23   2973098  23 str
     1  21959  18  2072008  16   5045106  39 tuple
     2   6716   6  1186311   9   6231417  48 types.CodeType
     3   1158   1  1052208   8   7283625  56 type
     4  13621  11  1047842   8   8331467  65 bytes
     5   6319   5   859384   7   9190851  71 function
     6  25507  21   719732   6   9910583  77 int
     7   1158   1   568640   4  10479223  81 dict of type
     8    327   0   508584   4  10987807  85 dict of module
     9    760   1   481272   4  11469079  89 dict (no owner)
&lt;270 more rows. Type e.g. '_.more' to view.&gt;
</pre>

<p>Mimochodem: na starší verzi Pythonu (3.6.6) dostaneme zcela odlišné hodnoty
(i proto si ji pro jeden projekt udržuji :-):</p>

<pre>
Partition of a set of 41461 objects. Total size = 4814075 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0  11614  28  1041238  22   1041238  22 str
     1  10110  24   733424  15   1774662  37 tuple
     2    563   1   462216  10   2236878  46 type
     3   2525   6   365032   8   2601910  54 types.CodeType
     4   5024  12   346353   7   2948263  61 bytes
     5   2455   6   333880   7   3282143  68 function
     6    563   1   271736   6   3553879  74 dict of type
     7    106   0   187896   4   3741775  78 dict of module
     8    261   1   183416   4   3925191  82 dict (no owner)
     9    402   1   148928   3   4074119  85 set
&lt;118 more rows. Type e.g. '_.more' to view.&gt;
</pre>

<p>Pokusme se skript upravit tak, že v&nbsp;něm vytvoříme velký řetězec a poté
opět zavoláme metodu <strong>heap</strong>:</p>

<pre>
from guppy import hpy
&nbsp;
x="?"*100000000
&nbsp;
h=hpy()
print(h.heap())
</pre>

<p>Nyní bude výsledek vypadat odlišně, přesně podle očekávání (viz první řádek
tabulky s&nbsp;hodnotami typu <strong>str</strong>):</p>

<pre>
Partition of a set of 41464 objects. Total size = 104814244 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     <strong>0  11616  28 101041345  96 101041345  96 str</strong>
     1  10110  24   733448   1 101774793  97 tuple
     2    563   1   462216   0 102237009  98 type
     3   2525   6   365032   0 102602041  98 types.CodeType
     4   5024  12   346363   0 102948404  98 bytes
     5   2455   6   333880   0 103282284  99 function
     6    563   1   271736   0 103554020  99 dict of type
     7    106   0   187896   0 103741916  99 dict of module
     8    261   1   183416   0 103925332  99 dict (no owner)
     9    402   1   148928   0 104074260  99 set
&lt;118 more rows. Type e.g. '_.more' to view.&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: počet objektů i celková obsazenost haldy
se může lišit v&nbsp;případě, že skript spustíme několikrát. Vše záleží na
(asynchronním) běhu automatického správce paměti.</div></p>

<p>Ovšem metoda <strong>heap</strong> nezobrazí pouze tabulku, ale umožňuje nám
(například interaktivně nebo i programově) objekty procházet a zkoumat je.
Například si můžeme nechat vypsat statistiku o první řádku tabulky, tedy o
všech objektem typu <strong>str</strong> (všechny další příklady jsou prováděny
z&nbsp;REPLu Pythonu):</p>

<pre>
&gt;&gt;&gt; <strong>h.heap()[0]</strong>
Partition of a set of 34181 objects. Total size = 3177461 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0  34181 100  3177461 100   3177461 100 str
</pre>

<p>Necháme si vypsat nejdelší řetězce (resp.&nbsp;jejich prvních několik
znaků):</p>

<pre>
&gt;&gt;&gt; <strong>h.heap()[0].byid</strong>
Set of 34202 <str> objects. Total size = 3179683 bytes.
 Index     Size   %   Cumulative  %   Representation (limited)
     0     7423   0.2      7423   0.2 'The class Bi... copy of S.\n'
     1     6512   0.2     13935   0.4 '\nThe ``code...hentication``'
     2     6327   0.2     20262   0.6 'Configuratio... by spaces.\n'
     3     6150   0.2     26412   0.8 "Support for ... 'error'.\n\n"
     4     5573   0.2     31985   1.0 'Controls for...ger`.\n\n    '
     5     4791   0.2     36776   1.2 'Heap queues\...at Art! :-)\n'
     6     4791   0.2     41567   1.3 'Heap queues\...at Art! :-)\n'
     7     4708   0.1     46275   1.5 ' Retry confi...equest.\n    '
     8     4252   0.1     50527   1.6 'Serialize ``...ible.\n\n    '
     9     4114   0.1     54641   1.7 '\n        Ge...ib`\n        '
</pre>

<p>Nyní naalokujeme delší řetězec (10000 znaků) a zopakujeme předchozí operaci.
Nový řetězec se dostane na samotný vrchol tabulky (a jeho velikost přesně
odpovídá popisu, který jsme si uvedli v&nbsp;předchozích kapitolách &ndash; 49
bajtů + počet znaků pro ASCII řetězce):</p>

<pre>
&gt;&gt;&gt; <strong>x="*"*10000</strong>
&nbsp;
&gt;&gt;&gt; <strong>h.heap()[0].byid</strong>
Set of 34204 <str> objects. Total size = 3189794 bytes.
 Index     Size   %   Cumulative  %   Representation (limited)
     0    10049   0.3     10049   0.3 '************...*************'
     1     7423   0.2     17472   0.5 'The class Bi... copy of S.\n'
     2     6512   0.2     23984   0.8 '\nThe ``code...hentication``'
     3     6327   0.2     30311   1.0 'Configuratio... by spaces.\n'
     4     6150   0.2     36461   1.1 "Support for ... 'error'.\n\n"
     5     5573   0.2     42034   1.3 'Controls for...ger`.\n\n    '
     6     4791   0.2     46825   1.5 'Heap queues\...at Art! :-)\n'
     7     4791   0.2     51616   1.6 'Heap queues\...at Art! :-)\n'
     8     4708   0.1     56324   1.8 ' Retry confi...equest.\n    '
     9     4252   0.1     60576   1.9 'Serialize ``...ible.\n\n    '
&lt;34194 more rows. Type e.g. '_.more' to view.&gt;
</pre>

<p>Řetězec necháme odstranit správcem paměti a opět se podíváme na
výsledky:</p>

<pre>
&gt;&gt;&gt; <strong>x=None</strong>
&nbsp;
&gt;&gt;&gt; <strong>h.heap()[0].byid</strong>
Set of 34203 <str> objects. Total size = 3179745 bytes.
 Index     Size   %   Cumulative  %   Representation (limited)
     0     7423   0.2      7423   0.2 'The class Bi... copy of S.\n'
     1     6512   0.2     13935   0.4 '\nThe ``code...hentication``'
     2     6327   0.2     20262   0.6 'Configuratio... by spaces.\n'
     3     6150   0.2     26412   0.8 "Support for ... 'error'.\n\n"
     4     5573   0.2     31985   1.0 'Controls for...ger`.\n\n    '
     5     4791   0.2     36776   1.2 'Heap queues\...at Art! :-)\n'
     6     4791   0.2     41567   1.3 'Heap queues\...at Art! :-)\n'
     7     4708   0.1     46275   1.5 ' Retry confi...equest.\n    '
     8     4252   0.1     50527   1.6 'Serialize ``...ible.\n\n    '
     9     4114   0.1     54641   1.7 '\n        Ge...ib`\n        '
&lt;34193 more rows. Type e.g. '_.more' to view.&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: projekt Guppy3 nabízí i mnohé další
zajímavé a potenciálně užitečné vlastnosti, o nichž se podrobněji zmíníme
příště.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Proč se tedy liší velikosti hodnot <strong>True</strong> a <strong>False</strong>?</h2>

<p>Zbývá nám ještě odpovědět na otázku z&nbsp;titulku tohoto článku, tedy proč
se velikosti hodnot <strong>True</strong> a <strong>False</strong> odlišují.
Nejprve si musíme uvědomit, o jakých hodnotách se vlastně bavíme.
Z&nbsp;historických důvodů totiž programovací jazyk Python reprezentuje hodnotu
<strong>False</strong> jako nulu a hodnotu <strong>True</strong> jako jedničku.
Nejedná se však o pouhou (řekněme) pseudoekvivalenci získanou na základě
nějakých konverzních pravidel, ale o (pro naprostou většinu operací) skutečnou
ekvivalenci:</p>

<pre>
&gt;&gt;&gt; <strong>0 == False</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>1 == True</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>2 == True</strong>
False
</pre>

<p>Z&nbsp;tohoto pohledu jsou tedy hodnoty <strong>True</strong> a
<strong>False</strong> instancemi třídy <strong>Number</strong>! Vyzkoušejme si
to:</p>

<pre>
&gt;&gt;&gt; <strong>import numbers</strong>
&nbsp;
&gt;&gt;&gt; <strong>isinstance(0, numbers.Number)</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>isinstance(1, numbers.Number)</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>isinstance(True, numbers.Number)</strong>
True
&nbsp;
&gt;&gt;&gt; <strong>isinstance(False, numbers.Number)</strong>
True
</pre>

<p>Nyní tedy víme, že nám bude postačovat zjistit, z&nbsp;jakého důvodu je
celočíselná hodnota <strong>0</strong> uložena v&nbsp;operační paměti
s&nbsp;jinou velikostí než celočíselná hodnota <strong>1</strong>, protože
naprosto stejná pravidla budou platit pro hodnotu <strong>False</strong> a
hodnotu <strong>True</strong>.</p>

<p><div class="rs-tip-major">Poznámka: o obou pravdivostních hodnotách můžeme
mluvit v&nbsp;singuláru, protože typicky mohou existovat v&nbsp;rámci celého
procesu jen v&nbsp;jediné instanci, na níž se odkazují jednotlivé proměnné,
atributy nebo parametry funkcí/metod.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Způsob uložení celočíselných hodnot Pythonu</h2>

<p>V&nbsp;Pythonu 3 jsou celočíselné hodnoty reprezentovány datovým typem
interně nazvaným <i>long</i> (a externě se jedná o objekty typu
<strong>int</strong>). Ovšem nejedná se o stejný <i>long</i>, jaký známe
například z&nbsp;programovacích jazyků C, C++ či Javy, protože typ <i>long</i>
v&nbsp;podání Pythonu znamená, že uložená celočíselná hodnota může mít
prakticky jakýkoli rozsah (teoreticky jsme omezeni jen kapacitou operační
paměti). To mj.&nbsp;znamená, že nejsme omezeni pouze například na
&bdquo;klasický&ldquo; 32bitový či 64bitový rozsah, tedy na hodnoty
-2<sup>31</sup>..2<sup>31</sup>-1 či -2<sup>63</sup>..2<sup>63</sup>-1
(popř.&nbsp;na rozsah 64bitový).</p>

<p>Způsob uložení hodnot typu <i>long</i> tedy musí být do značné míry
adaptivní, což znamená, že malé hodnoty budou uloženy v&nbsp;kratším paměťovém
bloku, než hodnoty větší (resp.&nbsp;přesněji řečeno hodnoty více vzdálené od
nuly). To pochopitelně komplikuje a prodlužuje všechny výpočty, takže obecně
platí, že v&nbsp;této oblasti bude Python vždy pomalejší, než nativní kód
popř.&nbsp;než skripty napsané v&nbsp;interpretovaných jazycích, které
podporují standardní formát celočíselných hodnot implementovaný přímo na
mikroprocesoru.</p>

<p>Konkrétně vypadá paměťová struktura s&nbsp;celými čísly typu <i>long</i> následovně:</p>

<pre>
struct <strong>_longobject</strong> {
    <strong>PyObject_HEAD</strong>
    <strong>_PyLongValue</strong> long_value;
};
</pre>

<p>Samotná hlavička objektu není nyní příliš zajímavá (bylo by to téma na
samostatný článek), takže se podívejme na druhý prvek celé struktury, což je
opět datová struktura:</p>

<pre>
typedef struct <strong>_PyLongValue</strong> {
    <strong>uintptr_t</strong> lv_tag; <strong>/* Number of digits, sign and flags */</strong>
    <strong>digit</strong> ob_digit[1];
} _PyLongValue;
</pre>

<p>Tady se skrývají zajímavější informace. V&nbsp;prvním prvku struktury jsou
uloženy informace o počtu cifer, znaménko a další příznaky. A druhý prvek je
polem, do něhož jsou uloženy bajty, z&nbsp;nichž se celočíselná hodnota skládá.
Výpočet uložené hodnoty lze zapsat takto:</p>

<pre>
value = SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
</pre>

<p>kde <strong>ob_size</strong> je jeden z&nbsp;atributů každé hodnoty a
<strong>SHIFT</strong> může být buď 15 nebo 30. V&nbsp;prvním případě, kdy je
<strong>SHIFT==15</strong>, se pracuje se 16bitovými hodnotami, ve druhém
případě s&nbsp;hodnotami 32bitovými (tato volba je provedena při překladu
interpretru Pythonu; poté ji již není možné měnit).</p>

<p>Speciálním případem je nula, která má <strong>ob_size</strong> nulový a tedy
se nealokuje žádné pole <strong>ob_digit</strong>. Ale již pro jedničku je
nutné pole alokovat, i když pochopitelně jen s&nbsp;jedním prvkem. A právě zde
je tedy odpověď na původní otázku, proč je velikost <strong>False</strong>
menší než velikost <strong>True</strong>. <strong>False</strong> je hodnota
odpovídající celočíselné nule a tudíž ji lze v&nbsp;paměti uložit bez pole
<strong>ob_digits</strong>. Naproti tomu <strong>True</strong> je již
plnohodnotný celočíselný objekt, jehož velikost je stejná, jako velikost
objektů/hodnot 1 až 2<sup>30</sup> (na současných platformách).</p>

<p><div class="rs-tip-major">Poznámka: pro jistotu dodejme, že zatímco typ
<strong>long</strong> (z&nbsp;pohledu Pythonistů <strong>int</strong>)
zajišťuje uložení hodnot s&nbsp;prakticky neomezeným rozsahem, typ
<strong>float</strong> již tuto vlastnost nemá, protože jde o typ definovaný
v&nbsp;normě IEEE 754, kterou jsme se již na stránkách Roota zabývali
několikrát (a proto budou výpočtu s&nbsp;floaty v&nbsp;Pythonu poněkud
paradoxně rychlejší, než celočíselné výpočty).</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>getsizeof1.py</td><td>získání nápovědy k&nbsp;funkci <strong>getsizeof</strong> z&nbsp;balíčku <strong>sys</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof1.py</a></td></tr>
<tr><td> 2</td><td>getsizeof2.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof2.py</a></td></tr>
<tr><td> 3</td><td>getsizeof3.py</td><td>získání a tisk velikosti kontejnerů Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof3.py</a></td></tr>
<tr><td> 4</td><td>getsizeof4.py</td><td>získání a tisk velikosti funkcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof4.py</a></td></tr>
<tr><td> 5</td><td>getsizeof5.py</td><td>získání a tisk velikosti tříd a objektů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof5.py</a></td></tr>
<tr><td> 6</td><td>getsizeof6.py</td><td>získání a tisk velikosti tříd a objektů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof6.py</a></td></tr>
<tr><td> 7</td><td>getsizeof7.py</td><td>velikost kolekcí obsahujících velké prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sys/getsizeof7.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>asizeof01.py</td><td>získání nápovědy k&nbsp;balíčku <strong>pympler.asizeof</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof01.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof01.py</a></td></tr>
<tr><td> 9</td><td>asizeof02.py</td><td>všechny veřejné atributy balíčku <strong>pympler.asizeof</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof02.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof02.py</a></td></tr>
<tr><td>10</td><td>asizeof03.py</td><td>získání nápovědy k&nbsp;funkci <strong>asizeof</strong> z&nbsp;balíčku <strong>pympler.asizeof</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof03.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof03.py</a></td></tr>
<tr><td>11</td><td>asizeof04.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof04.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof04.py</a></td></tr>
<tr><td>12</td><td>asizeof05.py</td><td>získání a tisk velikosti kontejnerů Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof05.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof05.py</a></td></tr>
<tr><td>13</td><td>asizeof06.py</td><td>získání a tisk velikostí vybraných skalárních hodnot Pythonu se statistikou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof06.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof06.py</a></td></tr>
<tr><td>14</td><td>asizeof07.py</td><td>získání a tisk velikosti kontejnerů Pythonu se statistikou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof07.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof07.py</a></td></tr>
<tr><td>15</td><td>asizeof08.py</td><td>získání a tisk velikosti funkcí bez parametru <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof08.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof08.py</a></td></tr>
<tr><td>16</td><td>asizeof09.py</td><td>získání a tisk velikosti funkcí s&nbsp;parametrem <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof09.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof09.py</a></td></tr>
<tr><td>17</td><td>asizeof10.py</td><td>získání a tisk velikosti tříd a objektů bez parametru <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof10.py</a></td></tr>
<tr><td>18</td><td>asizeof11.py</td><td>získání a tisk velikosti tříd a objektů s&nbsp;parametrem <strong>code</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py</a></td></tr>
<tr><td>19</td><td>asizeof12.py</td><td>velikost kolekcí obsahujících velké prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py">https://github.com/tisnik/most-popular-python-libs/blob/master/asizeof/asizeof11.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Top 5 Python Memory Profilers<br />
<a href="https://stackify.com/top-5-python-memory-profilers/">https://stackify.com/top-5-python-memory-profilers/</a>
</li>

<li>Pympler na GitHubu<br />
<a href="https://github.com/pympler/pympler">https://github.com/pympler/pympler</a>
</li>

<li>Pympler na PyPI<br />
<a href="https://pypi.org/project/Pympler/">https://pypi.org/project/Pympler/</a>
</li>

<li>Dokumentace k&nbsp;balíčku Pympler<br />
<a href="https://pympler.readthedocs.io/en/latest/">https://pympler.readthedocs.io/en/latest/</a>
</li>

<li>Guppy 3 na GitHubu<br />
<a href="https://github.com/zhuyifei1999/guppy3/">https://github.com/zhuyifei1999/guppy3/</a>
</li>

<li>Guppy 3 na PyPI<br />
<a href="https://pypi.org/project/guppy3/">https://pypi.org/project/guppy3/</a>
</li>

<li>Memory Profiler na GitHubu<br />
<a href="https://github.com/pythonprofilers/memory_profiler">https://github.com/pythonprofilers/memory_profiler</a>
</li>

<li>Memory Profiler na PyPI<br />
<a href="https://pypi.org/project/memory-profiler/">https://pypi.org/project/memory-profiler/</a>
</li>

<li>How to use guppy/heapy for tracking down memory usage<br />
<a href="https://smira.ru/wp-content/uploads/2011/08/heapy.html">https://smira.ru/wp-content/uploads/2011/08/heapy.html</a>
</li>

<li>Identifying memory leaks<br />
<a href="https://pympler.readthedocs.io/en/latest/muppy.html#muppy">https://pympler.readthedocs.io/en/latest/muppy.html#muppy</a>
</li>

<li>How do I determine the size of an object in Python?<br />
<a href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python</a>
</li>

<li>Why is bool a subclass of int?<br />
<a href="https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int">https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int</a>
</li>

<li>Memory Management in Python<br />
<a href="https://realpython.com/python-memory-management/">https://realpython.com/python-memory-management/</a>
</li>

<li>Why do ints require three times as much memory in Python?<br />
<a href="https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python">https://stackoverflow.com/questions/23016610/why-do-ints-require-three-times-as-much-memory-in-python</a>
</li>

<li>cpython/Include/cpython/longintrepr.h<br />
<a href="https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64">https://github.com/python/cpython/blob/main/Include/cpython/longintrepr.h#L64</a>
</li>

<li>sys — System-specific parameters and functions<br />
<a href="https://docs.python.org/3/library/sys.html">https://docs.python.org/3/library/sys.html</a>
</li>

<li>Python 3.3 s&nbsp;flexibilní reprezentací řetězců<br />
<a href="https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/#k17">https://www.root.cz/clanky/interni-reprezentace-retezcu-v-ruznych-jazycich-od-pocitacoveho-praveku-po-soucasnost/#k17</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

