<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Podpora funkcionálního programování v&nbsp;Pythonu &ndash; knihovna <strong>functools</strong></a></p>
<p><a href="#k02">2. Čistě funkcionální jazyky vs.&nbsp;hybridní jazyky</a></p>
<p><a href="#k03">3. Funkcionální vlastnosti programovacího jazyka Python</a></p>
<p><a href="#k04">4. Funkce vyššího řádu akceptující jinou funkci jako parametr</a></p>
<p><a href="#k05">5. Funkce vyššího řádu vracející jinou funkci</a></p>
<p><a href="#k06">6. Malá odbočka &ndash; implementace všech operátorů Pythonu formou funkcí</a></p>
<p><a href="#k07">7. Typ &bdquo;funkce&ldquo; z&nbsp;pohledu typového systému Pythonu</a></p>
<p><a href="#k08">8. Typy funkcí vyšších řádů z&nbsp;předchozích demonstračních příkladů</a></p>
<p><a href="#k09">*** 9. Klasické funkce vyššího řádu: <strong>map</strong>, <strong>filter</strong> a <strong>reduce/fold</strong></a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podpora funkcionálního programování v&nbsp;Pythonu &ndash; knihovna <strong>functools</strong></h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Čistě funkcionální jazyky vs.&nbsp;hybridní jazyky</h2>

<p>Termín <i>funkcionální programování</i> resp.&nbsp;ještě více
<i>funkcionální programovací jazyk</i> je dnes do určité míry zneužíván a
používán v&nbsp;nesprávném kontextu (ovšem mnohem hůře je na tom termín
<i>objektově orientované programování</i>, na jehož významu se prakticky nikdo
nedokáže shodnout :). Vraťme se však k&nbsp;funkcionálním programovacím
jazykům. Tyto jazyky je vhodné rozdělit do dvou kategorií &ndash; čistě
funkcionální jazyky a hybridní jazyky. Mezi čistě funkcionální jazyky patří
především Haskell, ale také Hope nebo Miranda. A do skupiny hybridních jazyků
patří spíše praktičtěji orientované jazyky typu <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">LISP</a>
(ten skutečně není čistě funkcionální), <a
href="https://www.root.cz/n/clojure/">Clojure</a> (to má k&nbsp;čistě
funkcionálním jazykům blíže), Scheme, <a
href="https://www.root.cz/serialy/funkcionalni-programovaci-jazyk-ml/">Standard
ML</a> a (podle mého názoru) velmi povedený jazyk F#, k&nbsp;němuž se ještě na
Rootu několikrát vrátíme.</p>

<p>Čistě funkcionální jazyky obecně nedovolují modifikace datových struktur,
což vede k&nbsp;tomu, že se v&nbsp;nich nepoužívají proměnné (ve standardním
smyslu tohoto slova), ale hodnoty, které jsou z&nbsp;pohledu programátora
konstantní. Naproti tomu u jazyků hybridních existuje možnost použití
modifikovatelných proměnných; většinou jsou ovšem možnosti modifikace poměrně
striktně hlídány a řízeny (příkladem může být opět Clojure nebo na druhé straně
F#). Ovšem obě skupiny jazyků mají minimálně jednu vlastnost společnou &ndash;
funkce jsou v&nbsp;nich plnohodnotným typem a všude tam, kde lze zadat nějakou
hodnotu (parametr jiné funkce, člen ve výrazu, návratová hodnota funkce atd.)
je možné zadat i funkci. Navíc se s&nbsp;funkcemi dají typicky provádět i další
operace, než jejich pouhá definice a volání. Například je umožněn
&bdquo;currying funkcí&ldquo;, k&nbsp;čemuž se dnes ještě vrátíme.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkcionální vlastnosti programovacího jazyka Python</h2>

<p>V&nbsp;dnešním článku se budeme primárně zabývat programovacím jazykem
Python, který ovšem není řazen do skupiny funkcionálních programovacích jazyků,
protože mu chybí některé důležité vlastnosti (resp.&nbsp;přesněji řečeno mu
naopak některé vlastnosti &bdquo;přebývají&ldquo;, například možnost modifikace
datových struktur). Nicméně i přesto v&nbsp;Pythonu některé důležité
funkcionální prvky nalezneme. Především se v&nbsp;Pythonu s&nbsp;funkcemi
pracuje jako s&nbsp;plnohodnotnými datovými typy, i když zde poněkud uměle
existují rozdíly mezi plnohodnotnými pojmenovanými funkcemi na straně jedné a
omezenými lambda výrazy na straně druhé (to ovšem znamená, že funkce mohou být
vytvořeny a použity i lokálně, v&nbsp;uzávěru atd!). Z&nbsp;toho, že jsou
funkce plnohodnotnými typy, plyne i fakt, že jsou podporovány funkce vyššího
řádu, tj.&nbsp;funkce, které jako své parametry akceptují jiné funkce či jiné
funkce vrací. A ještě jeden z&nbsp;této vlastnosti plynoucí fakt &ndash; jsou
podporovány uzávěry (<i>closure</i>), k&nbsp;nimiž se ještě vrátíme.</p>

<p>Některé funkce vyššího řádu, například <strong>map</strong> a
<strong>filter</strong>, nalezneme přímo v&nbsp;základní knihovně Pythonu.
Python navíc umožňuje manipulaci s&nbsp;funkcemi s&nbsp;využitím
<i>dekorátorů</i>. Zbývají nám další dvě důležité vlastnosti, které lze ve
funkcionálních jazycích nalézt &ndash; podporu pro kompozici funkcí a podporu
pro currying. Jak se tyto dvě vlastnosti v&nbsp;Pythonu využívají, si ukážeme
v&nbsp;navazujícím textu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce vyššího řádu akceptující jinou funkci jako parametr</h2>

<p>Termínem <i>funkce vyššího řádu</i> se označují ty funkce (ať již definované
v&nbsp;knihovně nebo uživatelem), které jako své parametry akceptují jiné
funkce či naopak vrací funkci jako svoji návratovou hodnotu. Nejprve si ukažme
první variantu funkcí vyššího řádu, tedy funkci, která akceptuje jinou funkci
jako svůj parametr. Tuto funkci, která v&nbsp;našem konkrétním případě
akceptuje implementaci libovolného binárního &bdquo;operátoru&ldquo; zapsaného
formou funkce a navíc ještě akceptuje dva číselné parametry, nazveme
<strong>calc</strong>, protože provede vyhodnocení operátoru s&nbsp;dosazením
obou předaných parametrů:</p>

<pre>
def <strong>calc</strong>(operator, x, y):
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x, y):
    return x &lt; y
&nbsp;
&nbsp;
z = calc(add, 10, 20)
print(z)
&nbsp;
z = calc(mul, 10, 20)
print(z)
&nbsp;
z = calc(less_than, 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py</a>.</div></p>

<p>Výsledky získané po spuštění tohoto skriptu nejsou příliš překvapivé:</p>

<pre>
30
200
True
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Funkce vyššího řádu vracející jinou funkci</h2>

<p>Druhá varianta funkce vyššího řádu naopak funkci vrací jako svoji návratovou
hodnotu. Pokud zůstaneme u našich příkladů s&nbsp;operátory, může se jednat o
funkci <strong>get_operator</strong>, která vrací funkci popř.&nbsp;hodnotu
<strong>None</strong>:</p>

<pre>
def <strong>get_operator</strong>(symbol):
    if symbol == "+":
        return add
    elif symbol == "*":
        return mul
    else:
        return None
&nbsp;
&nbsp;
def <strong>calc</strong>(operator, x, y):
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x, y):
    return x &lt; y
&nbsp;
&nbsp;
z = calc(get_operator("+"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("*"), 10, 20)
print(z)
&nbsp;
z = calc(less_than, 10, 20)
print(z)
</pre>

<p>Výsledky:</p>

<pre>
30
200
True
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py</a>.</div></p>

<p>Aby byl fakt, že funkce jsou plnohodnotnými hodnotami ještě více zdůrazněn,
můžeme předchozí demonstrační příklad přepsat do podoby založené na použití
slovníků (<i>dictionary</i>), v&nbsp;němž jsou funkce hodnotami:</p>

<pre>
def <strong>get_operator</strong>(symbol):
    operators = {
            "+": add,
            "*": mul,
            "&lt;": less_than,
    }
    return operators[symbol]
&nbsp;
&nbsp;
def <strong>calc</strong>(operator, x, y):
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x, y):
    return x &lt; y
&nbsp;
&nbsp;
z = calc(get_operator("+"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("*"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("&lt;"), 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py</a>.</div></p>

<p><div class="rs-tip-major">Poznámka: výsledky budou v&nbsp;obou případech
totožné.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Malá odbočka &ndash; implementace všech operátorů Pythonu formou funkcí</h2>

<p>Právě v&nbsp;případě, kdy využíváme funkcionální vlastnosti programovacího
jazyka Python, se ukazují poměrně zásadní rozdíly mezi klasickými funkcemi
(popř.&nbsp;lambda výrazy) a operátory. Z&nbsp;tohoto důvodu nalezneme ve
standardní knihovně Pythonu i balíček nazvaný <a
href="https://docs.python.org/3/library/operator.html">operator</a>,
v&nbsp;němž jsou všechny operátory přepsány do formy funkcí. Použití tohoto
balíčku v&nbsp;našem (upraveném) demonstračním příkladu je triviální:</p>

<pre>
from operator import *
&nbsp;
&nbsp;
def <strong>get_operator</strong>(symbol):
    operators = {
            "+": add,
            "*": mul,
            "^": pow,
            "&lt;": lt,
            "&gt;": gt,
    }
    return operators[symbol]
&nbsp;
&nbsp;
def <strong>calc</strong>(operator, x, y):
    return operator(x, y)
&nbsp;
&nbsp;
z = calc(get_operator("+"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("*"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("^"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("&lt;"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("&gt;"), 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Typ &bdquo;funkce&ldquo; z&nbsp;pohledu typového systému Pythonu</h2>

<p>Jak jsme si již několikrát řekli v&nbsp;předchozích odstavcích, jsou funkce
plnohodnotnými hodnotami, s&nbsp;nimiž se v&nbsp;Pythonu může pracovat naprosto
stejným způsobem, jako s&nbsp;jakýmikoli jinými hodnotami. To ovšem znamená, že
tyto hodnoty musí být nějakého typu. Typ funkce je &ndash; nezávisle na jejím
těle &ndash; odvozen pouze z&nbsp;typů parametrů a z&nbsp;typu návratové
hodnoty, přičemž výchozím typem je v&nbsp;obou případech <strong>Any</strong>.
Plné typové určení funkce se zapisuje následujícím způsobem:</p>

<pre>
Callable[[typ_parametru1, typ_parametru_2, ...] typ_návratové_hodnoty]
</pre>

<p><div class="rs-tip-major">Poznámka: Python sice syntakticky umožňuje, aby
funkce vracela více hodnot, sémanticky se však jedná o n-tici a tedy o jedinou
hodnotu.</div></p>

<p>S&nbsp;typovými anotacemi funkcí (i dalších hodnot) pracuje například
nástroj Mypy, s&nbsp;nímž jsme se již setkali v&nbsp;následujících
článcích:</p>

<ol>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (2.část)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/</a>
</li>

</ol>



<p><a name="k08"></a></p>
<h2 id="k08">8. Typy funkcí vyšších řádů z&nbsp;předchozích demonstračních příkladů</h2>

<p>Nyní již víme, jakým způsobem je možné zapsat typ nějaké funkce na základě
typu jejich parametrů i typu návratové hodnoty. Podívejme se tedy na způsob
úpravy příkladů z&nbsp;předchozích kapitol tak, aby obsahovaly přesné a úplné
typové informace. Začneme příkladem s&nbsp;funkcí vyššího řádu
<strong>calc</strong>, která <i>akceptuje</i> jinou funkci jako svůj
parametr:</p>

<pre>
from typing import Callable
&nbsp;
&nbsp;
def <strong>calc</strong>(operator: <u>Callable[[int, int], int]</u>, x: int, y: int) -&gt; int:
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x: int, y: int) -&gt; int:
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x: int, y: int) -&gt; int:
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x: int, y: int) -&gt; bool:
    return x &lt; y
&nbsp;
&nbsp;
z = calc(add, 10, 20)
print(z)
&nbsp;
z = calc(mul, 10, 20)
print(z)
&nbsp;
z = calc(less_than, 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py</a>.</div></p>

<p>Druhý příklad obsahuje funkci vyššího řádu <strong>get_operator</strong>,
která naopak vrací jinou funkci jako svoji návratovou hodnotu. Plná typová
deklarace této funkce vyššího řádu může vypadat takto:</p>

<pre>
from typing import Callable
&nbsp;
&nbsp;
def <strong>get_operator</strong>(symbol: str) -&gt; <u>Callable[[int, int], int]</u>:
    operators = {
            "+": add,
            "*": mul,
    }
    return operators[symbol]
&nbsp;
&nbsp;
def <strong>calc</strong>(operator: Callable[[int, int], int], x: int, y: int) -&gt; int:
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x: int, y: int) -&gt; int:
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x: int, y: int) -&gt; int:
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x: int, y: int) -&gt; bool:
    return x &lt; y
&nbsp;
&nbsp;
z = calc(get_operator("+"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("*"), 10, 20)
print(z)
&nbsp;
z = calc(less_than, 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py</a>.</div></p>

<p>Oba výše uvedené příklady obsahují všechny nutné typové informace, o čemž se
můžeme velmi snadno přesvědčit:</p>

<pre>
$ <strong>mypy --strict binary_operator_types.py get_operator_types.py </strong>
&nbsp;
Success: no issues found in 2 source files
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Klasické funkce vyššího řádu: <strong>map</strong>, <strong>filter</strong> a <strong>reduce/fold</strong></h2>

<p>Zatímco v&nbsp;běžných imperativních programovacích jazycích se seznamy
popř.&nbsp;n-tice či obecné sekvence zpracovávají prvek po prvku
s&nbsp;využitím nějaké formy programové smyčky popř.&nbsp;smyčky
&bdquo;skryté&ldquo; například v&nbsp;generátorové notaci seznamu, ve
funkcionálních programovacích jazycích se setkáme spíše s&nbsp;aplikací
několika funkcí vyššího řádu, které jako svůj vstup akceptují
seznam/n-tici/sekvenci a nějakou funkci, která je postupně aplikována buď na
prvky sekvence, nebo na prvek sekvence a takzvaný <i>akumulátor</i>, jehož
hodnota se postupně při zpracovávání jednotlivých prvků sekvence mění.
Výsledkem bývá buď nová sekvence, nebo výsledná hodnota akumulátoru. Tyto
funkce se většinou nazývají <strong>map</strong>, <strong>filter</strong> a
<strong>reduce</strong> či <strong>foldl</strong>. Tyto funkce vyššího řádu
nalezneme i v&nbsp;Pythonu, přičemž dvě z&nbsp;nich jsou umístěny ve výchozím
jmenném prostoru (a nemusí se tedy importovat), zatímco funkci
<strong>reduce</strong> najdeme v&nbsp;již zmíněném balíčku <a
href="https://docs.python.org/3/library/functools.html">functools</a>.</p>

<p><div class="rs-tip-major">Poznámka: funkce <strong>filter</strong> je
v&nbsp;některých jazycích a knihovnách nazvána <strong>remove-if</strong> a má
tedy otočený (resp.&nbsp;přesněji řečeno spíše negovaný) význam podmínky, jak
ostatně uvidíme dále.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce vyššího řádu <strong>map</strong></h2>

<p>Podívejme se nyní na funkci <strong>map</strong>. Tato funkce prochází prvky
sekvence a aplikuje na ně nějakou další uživatelem zvolenou funkci, podobně
jako ve smyčce <strong>for-each</strong> nebo spíše v&nbsp;generátorové notaci
seznamu či n-tice, ovšem namísto využití vedlejšího efektu se na základě
návratových hodnot funkce <strong>map</strong> vytváří nová sekvence prvků.</p>

<p><div class="rs-tip-major">Poznámka: interně se tedy musí celý algoritmus
realizovat přes programovou smyčku, rekurzi či koncovou rekurzi, to nás ovšem
jako uživatele funkce <strong>map</strong> nemusí trápit.</div></p>

<p>Příkladem použití funkce <strong>map</strong> může být výpočet délky všech
slov ve vstupním textu. Ten lze realizovat snadno &ndash; namapováním
standardní funkce <strong>len</strong> na jednotlivá slova získaná rozdělením
řetězce metodou <strong>split</strong>:</p>

<pre>
message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua"
words = message.split()
&nbsp;
lengths = <strong>map(len, words)</strong>
print(list(lengths))
</pre>

<p>Výsledek:</p>

<pre>
[5, 5, 5, 3, 5, 11, 10, 5, 3, 2, 7, 6, 10, 2, 6, 2, 6, 5, 6]
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py</a>.</div></p>

<p>Vstupem do funkce <strong>map</strong> ovšem nemusí být pouze seznam, ale
například i objekt typu <strong>range</strong>:</p>

<pre>
values = range(-10, 11)
&nbsp;
converted = <strong>map(abs, values)</strong>
print(list(converted))
</pre>

<p>Výsledek:</p>

<pre>
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny Pythonovské skripty, které jsme si v&nbsp;dnešním článku ukázali,
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je nutné mít
nainstalovánu některou z&nbsp;podporovaných verzí Pythonu 3, žádné další
balíčky nejsou zapotřebí):</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>binary_operator.py</td><td>ukázka funkce vyššího řádu, která jako parametr akceptuje jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py</a></td></tr>
<tr><td> 2</td><td>get_operator_1.py</td><td>ukázka funkce vyššího řádu, která vrací jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py</a></td></tr>
<tr><td> 3</td><td>get_operator_2.py</td><td>ukázka funkce vyššího řádu, která vrací jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py</a></td></tr>
<tr><td> 4</td><td>standard_operators.py</td><td>použití standardních operátorů přepsaných do formy funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>binary_operator_types.py</td><td>varianta příkladu <strong>binary_operator.py</strong> s&nbsp;plnými typovými deklaracemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py</a></td></tr>
<tr><td> 6</td><td>get_operator_types.py</td><td>varianta příkladu <strong>get_operator_2.py</strong> s&nbsp;plnými typovými deklaracemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/</a></td></tr>
<tr><td> 8</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/</a></td></tr>
<tr><td> 9</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/</a></td></tr>
<tr><td>10</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/</a></td></tr>
<tr><td>11</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/</a></td></tr>
<tr><td>12</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/</a></td></tr>
<tr><td>13</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/</a></td></tr>
<tr><td>14</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>functools — Higher-order functions and operations on callable objects<br />
<a href="https://docs.python.org/3/library/functools.html">https://docs.python.org/3/library/functools.html</a>
</li>

<li>Functional Programming HOWTO<br />
<a href="https://docs.python.org/3/howto/functional.html">https://docs.python.org/3/howto/functional.html</a>
</li>

<li>Functional Programming in Python: When and How to Use It<br />
<a href="https://realpython.com/python-functional-programming/">https://realpython.com/python-functional-programming/</a>
</li>

<li>Functional Programming With Python<br />
<a href="https://realpython.com/learning-paths/functional-programming/">https://realpython.com/learning-paths/functional-programming/</a>
</li>

<li>Awesome Functional Python<br />
<a href="https://github.com/sfermigier/awesome-functional-python">https://github.com/sfermigier/awesome-functional-python</a>
</li>

<li>Coconut: funkcionální jazyk s pattern matchingem kompatibilní s&nbsp;Pythonem<br />
<a href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/</a>
</li>

<li>A HITCHHIKER'S GUIDE TO functools<br />
<a href="https://ep2021.europython.eu/media/conference/slides/a-hitchhikers-guide-to-functools.pdf">https://ep2021.europython.eu/media/conference/slides/a-hitchhikers-guide-to-functools.pdf</a>
</li>

<li>Coconut aneb funkcionální nadstavba nad Pythonem (2.část)<br />
<a href="https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/">https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/</a>
</li>

<li>Knihovny pro zpracování posloupností (sekvencí) v&nbsp;Pythonu<br />
<a href="https://www.root.cz/clanky/knihovny-pro-zpracovani-posloupnosti-sekvenci-v-pythonu/">https://www.root.cz/clanky/knihovny-pro-zpracovani-posloupnosti-sekvenci-v-pythonu/</a>
</li>

<li>clj - repositář s knihovnou<br />
<a href="https://github.com/bfontaine/clj">https://github.com/bfontaine/clj</a>
</li>

<li>clj 0.1.0 &ndash; stránka na PyPi<br />
<a href="https://pypi.python.org/pypi/clj/0.1.0">https://pypi.python.org/pypi/clj/0.1.0</a>
</li>

<li>Coconut: Simple, elegant, Pythonic functional programming<br />
<a href="http://coconut-lang.org/">http://coconut-lang.org/</a>
</li>

<li>coconut (Python package index)<br />
<a href="https://pypi.python.org/pypi/coconut/">https://pypi.python.org/pypi/coconut/</a>
</li>

<li>Coconut Tutorial<br />
<a href="http://coconut.readthedocs.io/en/master/HELP.html">http://coconut.readthedocs.io/en/master/HELP.html</a>
</li>

<li>Coconut FAQ<br />
<a href="http://coconut.readthedocs.io/en/master/FAQ.html">http://coconut.readthedocs.io/en/master/FAQ.html</a>
</li>

<li>Coconut Documentation<br />
<a href="http://coconut.readthedocs.io/en/master/DOCS.html">http://coconut.readthedocs.io/en/master/DOCS.html</a>
</li>

<li>Coconut na Redditu<br />
<a href="https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/">https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/</a>
</li>

<li>Repositář na GitHubu<br />
<a href="https://github.com/evhub/coconut">https://github.com/evhub/coconut</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

