<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Podpora funkcionálního programování v Pythonu a knihovna functools</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Podpora funkcionálního programování v Pythonu a knihovna functools</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Python je multiparadigmatickým jazykem, což znamená, že menší skripty a nástroje lze psát prakticky čistě imperativně a pro rozsáhlejší aplikace podporuje objektově orientované programování. Navíc i v Pythonu nalezneme poměrně velké množství vlastností převzatých z funkcionálních jazyků.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Podpora funkcionálního programování v&nbsp;Pythonu a knihovna <strong>functools</strong></a></p>
<p><a href="#k02">2. Čistě funkcionální jazyky vs.&nbsp;hybridní jazyky</a></p>
<p><a href="#k03">3. Funkcionální vlastnosti programovacího jazyka Python</a></p>
<p><a href="#k04">4. Funkce vyššího řádu akceptující jinou funkci jako parametr</a></p>
<p><a href="#k05">5. Funkce vyššího řádu vracející jinou funkci</a></p>
<p><a href="#k06">6. Malá odbočka &ndash; implementace všech operátorů Pythonu formou funkcí</a></p>
<p><a href="#k07">7. Typ &bdquo;funkce&ldquo; z&nbsp;pohledu typového systému Pythonu</a></p>
<p><a href="#k08">8. Typy funkcí vyšších řádů z&nbsp;předchozích demonstračních příkladů</a></p>
<p><a href="#k09">9. Klasické funkce vyššího řádu: <strong>map</strong>, <strong>filter</strong> a <strong>reduce/fold</strong></a></p>
<p><a href="#k10">10. Funkce vyššího řádu <strong>map</strong></a></p>
<p><a href="#k11">11. Předání vlastní pojmenované či anonymní funkce do funkce vyššího řádu <strong>map</strong></a></p>
<p><a href="#k12">12. Funkce vyššího řádu <strong>filter</strong></a></p>
<p><a href="#k13">13. Ukázky použití funkce <strong>filter</strong></a></p>
<p><a href="#k14">14. Generátorové notace vs.&nbsp;funkce vyššího řádu <strong>map</strong> a <strong>filter</strong></a></p>
<p><a href="#k15">15. Náhrada funkce <strong>map</strong> za generátorovou notaci</a></p>
<p><a href="#k16">16. Náhrada funkce <strong>filter</strong> za generátorovou notaci</a></p>
<p><a href="#k17">17. Funkce vyššího řádu <strong>reduce</strong></a></p>
<p><a href="#k18">18. Obsah navazujícího článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podpora funkcionálního programování v&nbsp;Pythonu a knihovna <strong>functools</strong></h2>

<p><a href="https://www.root.cz/n/python/">Programovací jazyk Python</a> je
multiparadigmatickým programovacím jazykem, což v&nbsp;praxi znamená, že menší
skripty a nástroje lze psát prakticky čistě imperativně (ovšem strukturovaně) a
pro rozsáhlejší aplikace Python podporuje objektově orientované programování.
To ovšem není vše, protože i v&nbsp;Pythonu nalezneme poměrně velké množství
vlastností převzatých z&nbsp;funkcionálních jazyků (asi nejviditelnější
vlastnost: funkce jsou plnohodnotnými typy a tím pádem jsou v&nbsp;Pythonu
podporovány funkce vyššího řádu, lokální funkce atd. atd.) a dokonce pro něho
vznikly knihovny určené pro podporu funkcionálního přístupu.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je vhodné poznamenat, že
<a href="https://gvanrossum.github.io/">původní autor Pythonu</a>
(v&nbsp;současnosti na dlouhé dovolené :-) se k&nbsp;funkcionálním prvkům
přidaným do Pythonu stavěl poněkud rezervovaně, o čemž se ostatně zmíníme
dále.</div></p>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;některými základními koncepty
funkcionálního programování; zaměříme se ovšem na ty koncepty, které lze najít
v&nbsp;Pythonu (proto je nutné &ndash; alespoň prozatím &ndash; vynechat
podporu pro neměnitelné hodnoty). Kvůli tomu, že některé důležité funkcionální
prvky jsou přesunuty do standardních balíčků, seznámíme se dnes, i když
prozatím pouze ve stručnosti, i se standardním balíčkem nazvaným velmi
příhodně: <a
href="https://docs.python.org/3/library/functools.html">functools</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Čistě funkcionální jazyky vs.&nbsp;hybridní jazyky</h2>

<p>Termín <i>funkcionální programování</i> resp.&nbsp;ještě více
<i>funkcionální programovací jazyk</i> je dnes do určité míry zneužíván a
používán v&nbsp;nesprávném kontextu (ovšem mnohem hůře je na tom termín
<i>objektově orientované programování</i>, na jehož významu se prakticky nikdo
nedokáže shodnout :). Vraťme se však k&nbsp;funkcionálním programovacím
jazykům. Tyto jazyky je vhodné rozdělit do dvou kategorií &ndash; čistě
funkcionální jazyky a hybridní jazyky. Mezi čistě funkcionální jazyky patří
především Haskell, ale také Hope nebo Miranda. A do skupiny hybridních jazyků
patří spíše praktičtěji orientované jazyky typu <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">LISP</a>
(ten skutečně není čistě funkcionální), <a
href="https://www.root.cz/n/clojure/">Clojure</a> (to má k&nbsp;čistě
funkcionálním jazykům blíže), Scheme, <a
href="https://www.root.cz/serialy/funkcionalni-programovaci-jazyk-ml/">Standard
ML</a> a (podle mého názoru) velmi povedený jazyk F#, k&nbsp;němuž se ještě na
Rootu několikrát vrátíme.</p>

<p>Čistě funkcionální jazyky obecně nedovolují modifikace datových struktur,
což vede k&nbsp;tomu, že se v&nbsp;nich nepoužívají proměnné (ve standardním
smyslu tohoto slova), ale hodnoty, které jsou z&nbsp;pohledu programátora
konstantní. Naproti tomu u jazyků hybridních existuje možnost použití
modifikovatelných proměnných; většinou jsou ovšem možnosti modifikace poměrně
striktně hlídány a řízeny (příkladem může být opět Clojure nebo na druhé straně
F#). Ovšem obě skupiny jazyků mají minimálně jednu vlastnost společnou &ndash;
funkce jsou v&nbsp;nich plnohodnotným typem a všude tam, kde lze zadat nějakou
hodnotu (parametr jiné funkce, člen ve výrazu, návratová hodnota funkce atd.)
je možné zadat i funkci. Navíc se s&nbsp;funkcemi dají typicky provádět i další
operace, než jejich pouhá definice a volání. Například je umožněn
&bdquo;currying funkcí&ldquo;, k&nbsp;čemuž se dnes ještě vrátíme.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkcionální vlastnosti programovacího jazyka Python</h2>

<p>V&nbsp;dnešním článku se budeme primárně zabývat programovacím jazykem
Python, který ovšem není řazen do skupiny funkcionálních programovacích jazyků,
protože mu chybí některé důležité vlastnosti (resp.&nbsp;přesněji řečeno mu
naopak některé vlastnosti &bdquo;přebývají&ldquo;, například možnost modifikace
datových struktur). Nicméně i přesto v&nbsp;Pythonu některé důležité
funkcionální prvky nalezneme. Především se v&nbsp;Pythonu s&nbsp;funkcemi
pracuje jako s&nbsp;plnohodnotnými datovými typy, i když zde poněkud uměle
existují rozdíly mezi plnohodnotnými pojmenovanými funkcemi na straně jedné a
omezenými lambda výrazy na straně druhé (to ovšem znamená, že funkce mohou být
vytvořeny a použity i lokálně, v&nbsp;uzávěru atd!). Z&nbsp;toho, že jsou
funkce plnohodnotnými typy, plyne i fakt, že jsou podporovány funkce vyššího
řádu, tj.&nbsp;funkce, které jako své parametry akceptují jiné funkce či jiné
funkce vrací. A ještě jeden z&nbsp;této vlastnosti plynoucí fakt &ndash; jsou
podporovány uzávěry (<i>closure</i>), k&nbsp;nimiž se ještě vrátíme.</p>

<p>Některé funkce vyššího řádu, například <strong>map</strong> a
<strong>filter</strong>, nalezneme přímo v&nbsp;základní knihovně Pythonu.
Python navíc umožňuje manipulaci s&nbsp;funkcemi s&nbsp;využitím
<i>dekorátorů</i>. Zbývají nám další dvě důležité vlastnosti, které lze ve
funkcionálních jazycích nalézt &ndash; podporu pro kompozici funkcí a podporu
pro currying. Jak se tyto dvě vlastnosti v&nbsp;Pythonu využívají, si ukážeme
v&nbsp;navazujícím textu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce vyššího řádu akceptující jinou funkci jako parametr</h2>

<p>Termínem <i>funkce vyššího řádu</i> se označují ty funkce (ať již definované
v&nbsp;knihovně nebo uživatelem), které jako své parametry akceptují jiné
funkce či naopak vrací funkci jako svoji návratovou hodnotu. Nejprve si ukažme
první variantu funkcí vyššího řádu, tedy funkci, která akceptuje jinou funkci
jako svůj parametr. Tuto funkci, která v&nbsp;našem konkrétním případě
akceptuje implementaci libovolného binárního &bdquo;operátoru&ldquo; zapsaného
formou funkce a navíc ještě akceptuje dva číselné parametry, nazveme
<strong>calc</strong>, protože provede vyhodnocení operátoru s&nbsp;dosazením
obou předaných parametrů:</p>

<pre>
def <strong>calc</strong>(operator, x, y):
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x, y):
    return x &lt; y
&nbsp;
&nbsp;
z = calc(add, 10, 20)
print(z)
&nbsp;
z = calc(mul, 10, 20)
print(z)
&nbsp;
z = calc(less_than, 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py</a>.</div></p>

<p>Výsledky získané po spuštění tohoto skriptu nejsou příliš překvapivé:</p>

<pre>
30
200
True
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Funkce vyššího řádu vracející jinou funkci</h2>

<p>Druhá varianta funkce vyššího řádu naopak funkci vrací jako svoji návratovou
hodnotu. Pokud zůstaneme u našich příkladů s&nbsp;operátory, může se jednat o
funkci <strong>get_operator</strong>, která vrací funkci popř.&nbsp;hodnotu
<strong>None</strong>:</p>

<pre>
def <strong>get_operator</strong>(symbol):
    if symbol == "+":
        return add
    elif symbol == "*":
        return mul
    else:
        return None
&nbsp;
&nbsp;
def <strong>calc</strong>(operator, x, y):
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x, y):
    return x &lt; y
&nbsp;
&nbsp;
z = calc(get_operator("+"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("*"), 10, 20)
print(z)
&nbsp;
z = calc(less_than, 10, 20)
print(z)
</pre>

<p>Výsledky:</p>

<pre>
30
200
True
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py</a>.</div></p>

<p>Aby byl fakt, že funkce jsou plnohodnotnými hodnotami ještě více zdůrazněn,
můžeme předchozí demonstrační příklad přepsat do podoby založené na použití
slovníků (<i>dictionary</i>), v&nbsp;němž jsou funkce hodnotami:</p>

<pre>
def <strong>get_operator</strong>(symbol):
    operators = {
            "+": add,
            "*": mul,
            "&lt;": less_than,
    }
    return operators[symbol]
&nbsp;
&nbsp;
def <strong>calc</strong>(operator, x, y):
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x, y):
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x, y):
    return x &lt; y
&nbsp;
&nbsp;
z = calc(get_operator("+"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("*"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("&lt;"), 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py</a>.</div></p>

<p><div class="rs-tip-major">Poznámka: výsledky budou v&nbsp;obou případech
totožné.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Malá odbočka &ndash; implementace všech operátorů Pythonu formou funkcí</h2>

<p>Právě v&nbsp;případě, kdy využíváme funkcionální vlastnosti programovacího
jazyka Python, se ukazují poměrně zásadní rozdíly mezi klasickými funkcemi
(popř.&nbsp;lambda výrazy) a operátory. Z&nbsp;tohoto důvodu nalezneme ve
standardní knihovně Pythonu i balíček nazvaný <a
href="https://docs.python.org/3/library/operator.html">operator</a>,
v&nbsp;němž jsou všechny operátory přepsány do formy funkcí. Použití tohoto
balíčku v&nbsp;našem (upraveném) demonstračním příkladu je triviální:</p>

<pre>
from operator import *
&nbsp;
&nbsp;
def <strong>get_operator</strong>(symbol):
    operators = {
            "+": add,
            "*": mul,
            "^": pow,
            "&lt;": lt,
            "&gt;": gt,
    }
    return operators[symbol]
&nbsp;
&nbsp;
def <strong>calc</strong>(operator, x, y):
    return operator(x, y)
&nbsp;
&nbsp;
z = calc(get_operator("+"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("*"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("^"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("&lt;"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("&gt;"), 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Typ &bdquo;funkce&ldquo; z&nbsp;pohledu typového systému Pythonu</h2>

<p>Jak jsme si již několikrát řekli v&nbsp;předchozích odstavcích, jsou funkce
plnohodnotnými hodnotami, s&nbsp;nimiž se v&nbsp;Pythonu může pracovat naprosto
stejným způsobem, jako s&nbsp;jakýmikoli jinými hodnotami. To ovšem znamená, že
tyto hodnoty musí být nějakého typu. Typ funkce je &ndash; nezávisle na jejím
těle &ndash; odvozen pouze z&nbsp;typů parametrů a z&nbsp;typu návratové
hodnoty, přičemž výchozím typem je v&nbsp;obou případech <strong>Any</strong>.
Plné typové určení funkce se zapisuje následujícím způsobem:</p>

<pre>
Callable[[typ_parametru1, typ_parametru_2, ...] typ_návratové_hodnoty]
</pre>

<p><div class="rs-tip-major">Poznámka: Python sice syntakticky umožňuje, aby
funkce vracela více hodnot, sémanticky se však jedná o n-tici a tedy o jedinou
hodnotu.</div></p>

<p>S&nbsp;typovými anotacemi funkcí (i dalších hodnot) pracuje například
nástroj Mypy, s&nbsp;nímž jsme se již setkali v&nbsp;následujících
článcích:</p>

<ol>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (2.část)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/</a>
</li>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/</a>
</li>

</ol>



<p><a name="k08"></a></p>
<h2 id="k08">8. Typy funkcí vyšších řádů z&nbsp;předchozích demonstračních příkladů</h2>

<p>Nyní již víme, jakým způsobem je možné zapsat typ nějaké funkce na základě
typu jejich parametrů i typu návratové hodnoty. Podívejme se tedy na způsob
úpravy příkladů z&nbsp;předchozích kapitol tak, aby obsahovaly přesné a úplné
typové informace. Začneme příkladem s&nbsp;funkcí vyššího řádu
<strong>calc</strong>, která <i>akceptuje</i> jinou funkci jako svůj
parametr:</p>

<pre>
from typing import Callable
&nbsp;
&nbsp;
def <strong>calc</strong>(operator: <u>Callable[[int, int], int]</u>, x: int, y: int) -&gt; int:
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x: int, y: int) -&gt; int:
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x: int, y: int) -&gt; int:
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x: int, y: int) -&gt; bool:
    return x &lt; y
&nbsp;
&nbsp;
z = calc(add, 10, 20)
print(z)
&nbsp;
z = calc(mul, 10, 20)
print(z)
&nbsp;
z = calc(less_than, 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py</a>.</div></p>

<p>Druhý příklad obsahuje funkci vyššího řádu <strong>get_operator</strong>,
která naopak vrací jinou funkci jako svoji návratovou hodnotu. Plná typová
deklarace této funkce vyššího řádu může vypadat takto:</p>

<pre>
from typing import Callable
&nbsp;
&nbsp;
def <strong>get_operator</strong>(symbol: str) -&gt; <u>Callable[[int, int], int]</u>:
    operators = {
            "+": add,
            "*": mul,
    }
    return operators[symbol]
&nbsp;
&nbsp;
def <strong>calc</strong>(operator: Callable[[int, int], int], x: int, y: int) -&gt; int:
    return operator(x, y)
&nbsp;
&nbsp;
def <strong>add</strong>(x: int, y: int) -&gt; int:
    return x + y
&nbsp;
&nbsp;
def <strong>mul</strong>(x: int, y: int) -&gt; int:
    return x * y
&nbsp;
&nbsp;
def <strong>less_than</strong>(x: int, y: int) -&gt; bool:
    return x &lt; y
&nbsp;
&nbsp;
z = calc(get_operator("+"), 10, 20)
print(z)
&nbsp;
z = calc(get_operator("*"), 10, 20)
print(z)
&nbsp;
z = calc(less_than, 10, 20)
print(z)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py</a>.</div></p>

<p>Oba výše uvedené příklady obsahují všechny nutné typové informace, o čemž se
můžeme velmi snadno přesvědčit:</p>

<pre>
$ <strong>mypy --strict binary_operator_types.py get_operator_types.py </strong>
&nbsp;
Success: no issues found in 2 source files
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Klasické funkce vyššího řádu: <strong>map</strong>, <strong>filter</strong> a <strong>reduce/fold</strong></h2>

<p>Zatímco v&nbsp;běžných imperativních programovacích jazycích se seznamy
popř.&nbsp;n-tice či obecné sekvence zpracovávají prvek po prvku
s&nbsp;využitím nějaké formy programové smyčky popř.&nbsp;smyčky
&bdquo;skryté&ldquo; například v&nbsp;generátorové notaci seznamu, ve
funkcionálních programovacích jazycích se setkáme spíše s&nbsp;aplikací
několika funkcí vyššího řádu, které jako svůj vstup akceptují
seznam/n-tici/sekvenci a nějakou funkci, která je postupně aplikována buď na
prvky sekvence, nebo na prvek sekvence a takzvaný <i>akumulátor</i>, jehož
hodnota se postupně při zpracovávání jednotlivých prvků sekvence mění.
Výsledkem bývá buď nová sekvence, nebo výsledná hodnota akumulátoru. Tyto
funkce se většinou nazývají <strong>map</strong>, <strong>filter</strong> a
<strong>reduce</strong> či <strong>foldl</strong>. Tyto funkce vyššího řádu
nalezneme i v&nbsp;Pythonu, přičemž dvě z&nbsp;nich jsou umístěny ve výchozím
jmenném prostoru (a nemusí se tedy importovat), zatímco funkci
<strong>reduce</strong> najdeme v&nbsp;již zmíněném balíčku <a
href="https://docs.python.org/3/library/functools.html">functools</a>.</p>

<p><div class="rs-tip-major">Poznámka: funkce <strong>filter</strong> je
v&nbsp;některých jazycích a knihovnách nazvána <strong>remove-if</strong> a má
tedy otočený (resp.&nbsp;přesněji řečeno spíše negovaný) význam podmínky, jak
ostatně uvidíme dále.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce vyššího řádu <strong>map</strong></h2>

<p>Podívejme se nyní na funkci <strong>map</strong>. Tato funkce prochází prvky
sekvence a aplikuje na ně nějakou další uživatelem zvolenou funkci, podobně
jako ve smyčce <strong>for-each</strong> nebo spíše v&nbsp;generátorové notaci
seznamu či n-tice, ovšem namísto využití vedlejšího efektu se na základě
návratových hodnot funkce <strong>map</strong> vytváří nová sekvence prvků.</p>

<p><div class="rs-tip-major">Poznámka: interně se tedy musí celý algoritmus
realizovat přes programovou smyčku, rekurzi či koncovou rekurzi, to nás ovšem
jako uživatele funkce <strong>map</strong> nemusí trápit.</div></p>

<p>Příkladem použití funkce <strong>map</strong> může být výpočet délky všech
slov ve vstupním textu. Ten lze realizovat snadno &ndash; namapováním
standardní funkce <strong>len</strong> na jednotlivá slova získaná rozdělením
řetězce metodou <strong>split</strong>:</p>

<pre>
message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua"
words = message.split()
&nbsp;
lengths = <strong>map(len, words)</strong>
print(list(lengths))
</pre>

<p>Výsledek:</p>

<pre>
[5, 5, 5, 3, 5, 11, 10, 5, 3, 2, 7, 6, 10, 2, 6, 2, 6, 5, 6]
</pre>

<p>Povšimněte si, že výslednou sekvenci převádíme zpět na seznam pomocí
konstruktoru <strong>list</strong>.</p>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py</a>.</div></p>

<p>Vstupem do funkce <strong>map</strong> ovšem nemusí být pouze seznam, ale
například i objekt typu <strong>range</strong>:</p>

<pre>
values = range(-10, 11)
&nbsp;
converted = <strong>map(abs, values)</strong>
print(list(converted))
</pre>

<p>Výsledek:</p>

<pre>
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Předání vlastní pojmenované či anonymní funkce do funkce vyššího řádu <strong>map</strong></h2>

<p>Samozřejmě nám nic nebrání v&nbsp;tom, aby &bdquo;transformační&ldquo;
funkce předávaná do funkce vyššího řádu <strong>map</strong> byla získána ze
standardní knihovny. Můžeme použít i uživatelskou funkci s&nbsp;jedním
parametrem (a jednou výstupní hodnotou &ndash; ovšem lze využít i implicitní
hodnotu <strong>None</strong>). Například můžeme získat informace o tom, jaké
celočíselné hodnoty jsou &bdquo;uloženy&ldquo; v&nbsp;sekvenci představované
objektem typu <strong>range</strong>:</p>

<pre>
def <strong>sign</strong>(value):
    if value &lt; 0:
        return "negative"
    elif value &gt; 0:
        return "positive"
    else:
        return "zero"
&nbsp;
&nbsp;
values = range(-10, 11)
&nbsp;
converted = <strong>map(sign, values)</strong>
&nbsp;
for c in converted:
    print(c)
</pre>

<p>Výsledek získaný po spuštění tohoto skriptu by měl vypadat následovně:</p>

<pre>
negative
negative
negative
negative
negative
negative
negative
negative
negative
negative
zero
positive
positive
positive
positive
positive
positive
positive
positive
positive
positive
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_3.py</a>.</div></p>

<p>Velmi často se do funkcí vyššího řádu <strong>map</strong>,
<strong>filter</strong> a <strong>reduce</strong> předávají různé jednoduché a
ad-hoc vytvářené krátké funkce. V&nbsp;mnoha případech nemusíme takové funkce
definovat blokem <strong>def</strong> (a rozšiřovat tak počet identifikátorů ve
jmenném prostoru), ale můžeme využít možnost předání <i>lambda výrazu</i> (což
v&nbsp;Pythonu ovšem není plnohodnotná anonymní funkce). Předchozí skript lze
s&nbsp;využitím konstrukce <strong>lambda</strong> přepsat do následujícího
tvaru:</p>

<pre>
values = range(-10, 11)
&nbsp;
converted = <strong>map(lambda x: "negative" if x &lt; 0 else "positive" if x &gt; 0 else "zero", values)</strong>
&nbsp;
for c in converted:
    print(c)
</pre>

<p>Opět se podívejme na výsledek získaný po spuštění tohoto skriptu:</p>

<pre>
negative
negative
negative
negative
negative
negative
negative
negative
negative
negative
zero
positive
positive
positive
positive
positive
positive
positive
positive
positive
positive
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_4.py</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Funkce vyššího řádu <strong>filter</strong></h2>

<p>Kromě funkce vyššího řádu <strong>map</strong>, s&nbsp;níž jsme se seznámili
v&nbsp;předchozím textu, mají vývojáři k&nbsp;dispozici i další poměrně
užitečnou funkci, která se příhodně jmenuje <strong>filter</strong>. I
<strong>filter</strong> je funkcí vyššího řádu, kde funkce předaná uživatelem
(ať už pojmenovaná či anonymní) určuje svojí návratovou hodnotou, zda daný
prvek z&nbsp;původního seznamu (n-tice, sekvence atd.) má být přenesen do
seznamu vytvářeného. Jedná se tedy o obdobu klauzule <strong>WHERE</strong>
v&nbsp;programovacím jazyce SQL. Mimochodem &ndash; funkce předávaná do
<strong>filter</strong> se nazývá <i>predikát</i>, protože rozhodnutí, zda se
prvek ze vstupu má použít i na výstupu, se provádí na základě pravdivostní
hodnoty vrácené predikátem. A konkrétně v&nbsp;Pythonu se zde aplikují všechna
pravidla o tom, jaké hodnoty jsou považovány za <i>pravdu</i> a jaké za
<i>nepravdu</i>. Všechny hodnoty kromě hodnot zmíněných níže jsou považovány za
pravdu:</p>

<ul>
<li><strong>False</strong></li>
<li><strong>None</strong></li>
<li><strong>0</strong> (<i>long</i>)</li>
<li><strong>0.0</strong> (<i>double</i>)</li>
<li><strong>0j</strong> (<i>complex</i></li>
<li><strong>[]</strong> (prázdný seznam)</li>
<li><strong>()</strong> (prázdná n-tice)</li>
<li><strong>{}</strong> (prázdný slovník)</li>
<li><strong>set()</strong> (prázdná množina)</li>
<li><strong>""</strong> (prázdný řetězec)</li>
<li><strong>range(0)</strong> (prázdná sekvence)</li>
</ul>



<p><a name="k13"></a></p>
<h2 id="k13">13. Ukázky použití funkce <strong>filter</strong></h2>

<p>V&nbsp;prvním demonstračním příkladu založeném na funkci vyššího řádu
<strong>filter</strong> získáme ze seznamu slov ta slova, jejichž délka je
menší než čtyři znaky. A navíc provedeme ještě jednu filtraci, tentokrát naopak
pro slova s&nbsp;délkou větší nebo rovnou čtyřem. Výsledkem filtrace je opět
(podobně jako u funkce <strong>map</strong>) sekvence, kterou můžeme pro účely
tisku převést na seznam:</p>

<pre>
message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua"
words = message.split()
&nbsp;
filtered = <strong>filter(lambda word: len(word) &gt; 4, words)</strong>
print(list(filtered))
&nbsp;
filtered = <strong>filter(lambda word: len(word) &lt;= 4, words)</strong>
print(list(filtered))
</pre>

<p>Výsledkem činnosti tohoto skriptu jsou dva seznamy &ndash; první
s&nbsp;dlouhými slovy, druhý se slovy krátkými (povšimněte si problému
s&nbsp;počítáním čárky do délky slova):</p>

<pre>
['Lorem', 'ipsum', 'dolor', 'amet,', 'consectetur', 'adipiscing', 'elit,', 'eiusmod', 'tempor', 'incididunt', 'labore', 'dolore', 'magna', 'aliqua']
['sit', 'sed', 'do', 'ut', 'et']
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_1.py</a>.</div></p>

<p>Ve druhém demonstračním příkladu rozdělíme sekvenci numerických hodnot 0 až
10 (včetně) do sekvence obsahující lichá čísla a do sekvence obsahující naopak
čísla sudá. Predikátem budou v&nbsp;tomto případě uživatelsky definované
funkce:</p>

<pre>
def <strong>odd</strong>(value):
    return value % 2 == 1
&nbsp;
&nbsp;
def <strong>even</strong>(value):
    return not odd(value)
&nbsp;
&nbsp;
data = range(0, 11)
&nbsp;
filtered = <strong>filter(odd, data)</strong>
print(list(filtered))
&nbsp;
filtered = <strong>filter(even, data)</strong>
print(list(filtered))
</pre>

<p>Výsledek zobrazený po spuštění tohoto skriptu by měl vypadat takto:</p>

<pre>
[1, 3, 5, 7, 9]
[0, 2, 4, 6, 8, 10]
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_2.py</a>.</div></p>

<p>A konečně &ndash; předchozí skript můžeme v&nbsp;případě potřeby přepsat
takovým způsobem, aby se namísto uživatelských pojmenovaných funkcí
s&nbsp;jediným příkazem ve svém těle použily lambda výrazy:</p>

<pre>
data = range(0, 11)
&nbsp;
filtered = <strong>filter(lambda value : value %2 == 1, data)</strong>
print(list(filtered))
&nbsp;
filtered = <strong>filter(lambda value : value %2 == 0, data)</strong>
print(list(filtered))
</pre>

<p>Výsledek by měl být stejný, jako tomu je u předchozího příkladu:</p>

<pre>
[1, 3, 5, 7, 9]
[0, 2, 4, 6, 8, 10]
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_3.py</a>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Generátorové notace vs.&nbsp;funkce vyššího řádu <strong>map</strong> a <strong>filter</strong></h2>

<p>Funkce <strong>map</strong> a <strong>filter</strong>, které jsme si popsali
v&nbsp;předchozích kapitolách, pochází z&nbsp;klasických funkcionálních jazyků
a mají pochopitelně i své využití v&nbsp;Pythonu. Ovšem Python programátorům
nabízí i alternativní způsob zápisu algoritmů založených na <i>operacích</i>
<strong>map</strong> a <strong>filter</strong>, tedy na aplikaci nějaké
transformace na všechny prvky sekvence popř.&nbsp;na výběr prvků ze sekvence na
základě nějakého predikátu. Tento alternativní způsob zápisu je pokládán za
více <i>idiomatický</i> a nazývá se <i>generátorová notace</i>, což je poněkud
nepřesně přeložený anglický termín <i>(list/tuple) comprehension</i>.</p>

<p>Základní způsob zápisu generátorové notace seznamu vypadá takto:</p>

<pre>
<strong>[item * 2 for item in range(10)]</strong>
&nbsp;
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
</pre>

<p>Navíc můžeme přidat i podmínku a tím pádem realizovat <strong>filter</strong>:</p>

<pre>
<strong>[item * 2 for item in range(10) if item % 3 == 0]</strong>
&nbsp;
[0, 6, 12, 18]
</pre>

<p><div class="rs-tip-major">Poznámka: podmínka se vztahuje nikoli
k&nbsp;vypočteným výsledkům, ale ke &bdquo;vstupnímu&ldquo; prvku
<strong>item</strong>.</div></p>

<p>Jak uvidíme příště, je tento způsob zápisu sice možná na první způsob
elegantní, ale má poněkud omezené vyjadřovací schopnosti.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Náhrada funkce <strong>map</strong> za generátorovou notaci</h2>

<p>Pro zajímavost se nyní podívejme na způsob přepisu demonstračních příkladů
<a href="#k10">z&nbsp;desáté</a> a <a href="#k11">jedenácté</a> kapitoly tak,
aby se namísto funkce vyššího řádu <strong>map</strong> použila generátorová
notace (seznamu). Výsledkem budou v&nbsp;tomto případě nikoli sekvence, ale
přímo seznamy, které lze tisknout:</p>

<pre>
message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua"
words = message.split()
&nbsp;
lengths = [len(word) for word in words]
print(lengths)
</pre>

<pre>
values = range(-10, 11)
&nbsp;
converted = [abs(value) for value in values]
print(converted)
</pre>

<pre>
def <strong>sign</strong>(value):
    if value &lt; 0:
        return "negative"
    elif value &gt; 0:
        return "positive"
    else:
        return "zero"
&nbsp;
&nbsp;
values = range(-10, 11)
&nbsp;
converted = [sign(value) for value in values]
&nbsp;
for c in converted:
    print(c)
</pre>

<pre>
values = range(-10, 11)
&nbsp;
converted = ["negative" if x &lt; 0 else "positive" if x &gt; 0 else "zero" for x in values]
&nbsp;
for c in converted:
    print(c)
</pre>

<p><div class="rs-tip-major">Poznámka: zápis je sice (alespoň oficiálně) více
idiomatický, ovšem vyžaduje určitý trénink pro rozpoznání použitého vzoru,
zatímco zápisem <strong>map</strong> se daný algoritmus přímo
pojmenuje.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Náhrada funkce <strong>filter</strong> za generátorovou notaci</h2>

<p><a href="#k13">Ve třinácté kapitole</a> jsme si ukázali několik
demonstračních příkladů, v&nbsp;nichž se používala funkce vyššího řádu
<strong>filter</strong>. I tuto funkci můžeme nahradit za zápis založený na
generátorové notaci. Pokusme se tedy přepsat všechny tři příklady ze třinácté
kapitoly do idiomatického Pythonního kódu:</p>

<pre>
message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua"
words = message.split()
&nbsp;
filtered = [word for word in words if len(word) &gt; 4]
print(list(filtered))
&nbsp;
filtered = [word for word in words if len(word) &lt;= 4]
print(list(filtered))
</pre>

<pre>
def <strong>odd</strong>(value):
    return value % 2 == 1
&nbsp;
&nbsp;
def <strong>even</strong>(value):
    return not odd(value)
&nbsp;
&nbsp;
data = range(0, 11)
&nbsp;
filtered = [value for value in data if odd(value)]
print(filtered)
&nbsp;
filtered = [value for value in data if even(value)]
print(filtered)
</pre>

<pre>
data = range(0, 11)
&nbsp;
filtered = [value for value in data if value %2 == 1]
print(filtered)
&nbsp;
filtered = [value for value in data if value %2 == 0]
print(filtered)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Funkce vyššího řádu <strong>reduce</strong></h2>

<p>Ve většině programovacích jazyků inspirovaných funkcionálním programováním
se velmi často setkáme i s&nbsp;funkcí nazvanou <strong>reduce</strong> nebo
<strong>fold</strong>, popř.&nbsp;s&nbsp;různými alternativami s&nbsp;podobnými
operacemi. Základní operací tohoto typu je funkce vyššího řádu nazvaná
<strong>reduce</strong>, která postupně zpracovává všechny prvky seznamu,
n-tice, sekvence nebo slovníku <i>zleva doprava</i> a aplikuje na každý prvek a
akumulovanou hodnotu nějakou funkci (a právě to tedy mj.&nbsp;znamená, že
<strong>reduce</strong> je funkcí vyššího řádu). Výsledkem je v&nbsp;každé
iteraci nová hodnota akumulátoru a po projití celé vstupní sekvence je výsledná
hodnota uložená v&nbsp;akumulátoru současně i návratovou hodnotou funkce
<strong>reduce</strong>. Alternativně je možné specifikovat počáteční hodnotu
akumulátoru (ne ve všech implementacích, ovšem Pythonní implementace
<strong>reduce</strong> do této skupiny patří. Tuto funkci můžeme využít
například při výpočtu faktoriálu, protože při výpočtu faktoriálu nějakého
<i>n</i> postačuje pomocí <strong>range</strong> vytvořit pole o <i>n</i>
prvcích a posléze jeho prvky postupně pronásobit.</p>

<p><div class="rs-tip-major">Poznámka: na rozdíl od výše zmíněných funkcí
<strong>map</strong> a <strong>filter</strong> není funkce
<strong>reduce</strong> umístěna ve výchozím jmenném prostoru. Nalezneme ji ve
standardním balíčku <strong>functools</strong>. Důvody jsou zmíněny například
<a href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196">zde</a>
(osobně ovšem těm důvodům moc nerozumím, ale to je osobní názor založený na
odlišném chápání role <i>jmen</i> a <i>vzorů</i> či <i>idiomů</i>
v&nbsp;programovacích jazycích).</div></p>

<p>Podívejme se nyní na způsob použití funkce vyššího řádu
<strong>reduce</strong>. Následující skript po svém spuštění provede tento
výpočet:</p>

<pre>
(((((((((1*2)*3)*4)*5)*6)*7)*8)*9)*10)
</pre>

<p>To znamená, že se provede výpočet faktoriálu pro n=10:</p>

<pre>
from functools import reduce
&nbsp;
&nbsp;
def <strong>multiply</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
x = range(1, 11)
print(x)
&nbsp;
y = reduce(multiply, x)
print(y)
</pre>

<p>Výsledek získaný po spuštění:</p>

<pre>
range(1, 11)
3628800
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_1.py</a>.</div></p>

<p>Samozřejmě je možné celý výpočet přepsat takovým způsobem, aby se namísto
pojmenované funkce <strong>multiply</strong> použil kratší lambda výraz:</p>

<pre>
from functools import reduce
&nbsp;
&nbsp;
x = range(1, 11)
print(x)
&nbsp;
y = reduce(lambda a, b: a*b, x)
print(y)
</pre>

<p>Výsledek bude shodný:</p>

<pre>
range(1, 11)
3628800
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_2.py</a>.</div></p>

<p>Relativně snadno lze předchozí skript upravit do takové podoby, aby se
vypočetla tabulka faktoriálů pro n=0 až n=10. Třetím nepovinným parametrem
funkce <strong>reduce</strong> je počáteční hodnota akumulátoru. Výsledná
podoba skriptu bude vypadat následovně:</p>

<pre>
from functools import reduce
&nbsp;
&nbsp;
def <strong>factorial</strong>(n):
    return reduce(lambda a, b: a*b, range(1, n+1), 1)
&nbsp;
&nbsp;
for n in range(0, 11):
    print(n, factorial(n))
</pre>

<p>Výsledky:</p>

<pre>
0 1
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3628800
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_3.py</a>.</div></p>

<p>Ovšem i samotnou funkci <strong>factorial</strong> lze zapsal lambda výrazem
(což již ovšem nemusí být příliš čitelné a ani to není v&nbsp;Pythonu
idiomatické):</p>

<pre>
from functools import reduce
&nbsp;
&nbsp;
<strong>factorial</strong> = lambda n: reduce(lambda a, b: a*b, range(1, n+1), 1)
&nbsp;
for n in range(0, 11):
    print(n, factorial(n))
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_4.py</a>.</div></p>

<p>A konečně si ukažme &bdquo;funkcionální&ldquo; variantu předchozího skriptu,
v&nbsp;níž se nevyskytují programové smyčky a v&nbsp;níž se výsledek uloží do
sekvence (ovšem tento zápis nemusí být zcela čitelný)</p>

<pre>
from functools import reduce
&nbsp;
&nbsp;
n = range(0, 11)
&nbsp;
<strong>factorials</strong> = map(lambda n: reduce(lambda a, b: a*b, range(1, n+1), 1), n)
&nbsp;
print(list(factorials))
</pre>

<p>Výsledkem je sekvence převedená na seznam:</p>

<pre>
[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_5.py</a>.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujícího článku</h2>

<p>V&nbsp;navazujícím článku se zaměříme na ty nástroje dostupné ve standardním
balíčku <strong>functools</strong>, které jsou určeny pro pokročilejší
manipulace s&nbsp;funkcemi. Bude se jednat zejména o takzvaný <i>currying</i> a
taktéž o možnost zapamatování návratových hodnot funkcí v&nbsp;cache (což je
pro čisté funkce samozřejmě možné). Zmíníme se i o takzvaném <i>point-free</i>
programování, jímž jsme se obecně zabývali v&nbsp;článku <a
href="https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/">Programovací
technika nazvaná tacit programming</a>.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny Pythonovské skripty, které jsme si v&nbsp;dnešním článku ukázali,
naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je nutné mít
nainstalovánu některou z&nbsp;podporovaných verzí Pythonu 3, žádné další
balíčky nejsou zapotřebí):</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>binary_operator.py</td><td>ukázka funkce vyššího řádu, která jako parametr akceptuje jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator.py</a></td></tr>
<tr><td> 2</td><td>get_operator_1.py</td><td>ukázka funkce vyššího řádu, která vrací jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_1.py</a></td></tr>
<tr><td> 3</td><td>get_operator_2.py</td><td>ukázka funkce vyššího řádu, která vrací jinou funkci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_2.py</a></td></tr>
<tr><td> 4</td><td>standard_operators.py</td><td>použití standardních operátorů přepsaných do formy funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/standard_operators.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>binary_operator_types.py</td><td>varianta příkladu <strong>binary_operator.py</strong> s&nbsp;plnými typovými deklaracemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/binary_operator_types.py</a></td></tr>
<tr><td> 6</td><td>get_operator_types.py</td><td>varianta příkladu <strong>get_operator_2.py</strong> s&nbsp;plnými typovými deklaracemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/get_operator_types.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>map_1.py</td><td>příklad použití funkce <strong>map</strong>: výpočet délky všech slov v&nbsp;textu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_1.py</a></td></tr>
<tr><td> 8</td><td>map_2.py</td><td>příklad použití funkce <strong>map</strong>: výpočet absolutní hodnoty všech členů posloupnosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_2.py</a></td></tr>
<tr><td> 9</td><td>map_3.py</td><td>příklad použití funkce <strong>map</strong>: aplikace vlastní pojmenované funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_3.py</a></td></tr>
<tr><td>10</td><td>map_4.py</td><td>příklad použití funkce <strong>map</strong>: aplikace vlastního lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>map_list_comprehension_1.py</td><td>přepis skriptu <strong>map_1.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_1.py</a></td></tr>
<tr><td>12</td><td>map_list_comprehension_2.py</td><td>přepis skriptu <strong>map_2.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_2.py</a></td></tr>
<tr><td>13</td><td>map_list_comprehension_3.py</td><td>přepis skriptu <strong>map_3.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_3.py</a></td></tr>
<tr><td>14</td><td>map_list_comprehension_4.py</td><td>přepis skriptu <strong>map_4.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/map_list_comprehension_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>filter_1.py</td><td>filtrace dat na základě délky řetězce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_1.py</a></td></tr>
<tr><td>16</td><td>filter_2.py</td><td>filtrace numerických dat podle toho, zda se jedná o sudá či lichá čísla</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_2.py</a></td></tr>
<tr><td>17</td><td>filter_3.py</td><td>přepis předchozího příkladu s&nbsp;využitím lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>filter_list_comprehension_1.py</td><td>přepis skriptu <strong>filter_list_comprehension_1.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_1.py</a></td></tr>
<tr><td>19</td><td>filter_list_comprehension_2.py</td><td>přepis skriptu <strong>filter_list_comprehension_2.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_2.py</a></td></tr>
<tr><td>20</td><td>filter_list_comprehension_3.py</td><td>přepis skriptu <strong>filter_list_comprehension_3.py</strong> tak, aby se použila generátorová notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/filter_list_comprehension_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>reduce_1.py</td><td>výpočet faktoriálu s&nbsp;využitím funkce vyššího řádu <strong>reduce</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_1.py</a></td></tr>
<tr><td>22</td><td>reduce_2.py</td><td>přepis předchozího příkladu s&nbsp;využitím lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_2.py</a></td></tr>
<tr><td>23</td><td>reduce_3.py</td><td>tisk tabulky faktoriálů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_3.py</a></td></tr>
<tr><td>24</td><td>reduce_4.py</td><td>přepis předchozího příkladu s&nbsp;využitím lambda výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_4.py</a></td></tr>
<tr><td>25</td><td>reduce_5.py</td><td>přepis předchozího příkladu s&nbsp;využitím generátorové notace</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/functools/reduce_5.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>functools — Higher-order functions and operations on callable objects<br />
<a href="https://docs.python.org/3/library/functools.html">https://docs.python.org/3/library/functools.html</a>
</li>

<li>Functional Programming HOWTO<br />
<a href="https://docs.python.org/3/howto/functional.html">https://docs.python.org/3/howto/functional.html</a>
</li>

<li>Functional Programming in Python: When and How to Use It<br />
<a href="https://realpython.com/python-functional-programming/">https://realpython.com/python-functional-programming/</a>
</li>

<li>Functional Programming With Python<br />
<a href="https://realpython.com/learning-paths/functional-programming/">https://realpython.com/learning-paths/functional-programming/</a>
</li>

<li>Awesome Functional Python<br />
<a href="https://github.com/sfermigier/awesome-functional-python">https://github.com/sfermigier/awesome-functional-python</a>
</li>

<li>Coconut: funkcionální jazyk s pattern matchingem kompatibilní s&nbsp;Pythonem<br />
<a href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/</a>
</li>

<li>A HITCHHIKER'S GUIDE TO functools<br />
<a href="https://ep2021.europython.eu/media/conference/slides/a-hitchhikers-guide-to-functools.pdf">https://ep2021.europython.eu/media/conference/slides/a-hitchhikers-guide-to-functools.pdf</a>
</li>

<li>Coconut aneb funkcionální nadstavba nad Pythonem (2.část)<br />
<a href="https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/">https://www.root.cz/clanky/coconut-aneb-funkcionalni-nadstavba-nad-pythonem-2-cast/</a>
</li>

<li>Knihovny pro zpracování posloupností (sekvencí) v&nbsp;Pythonu<br />
<a href="https://www.root.cz/clanky/knihovny-pro-zpracovani-posloupnosti-sekvenci-v-pythonu/">https://www.root.cz/clanky/knihovny-pro-zpracovani-posloupnosti-sekvenci-v-pythonu/</a>
</li>

<li>clj - repositář s knihovnou<br />
<a href="https://github.com/bfontaine/clj">https://github.com/bfontaine/clj</a>
</li>

<li>clj 0.1.0 &ndash; stránka na PyPi<br />
<a href="https://pypi.python.org/pypi/clj/0.1.0">https://pypi.python.org/pypi/clj/0.1.0</a>
</li>

<li>Coconut: Simple, elegant, Pythonic functional programming<br />
<a href="http://coconut-lang.org/">http://coconut-lang.org/</a>
</li>

<li>coconut (Python package index)<br />
<a href="https://pypi.python.org/pypi/coconut/">https://pypi.python.org/pypi/coconut/</a>
</li>

<li>Coconut Tutorial<br />
<a href="http://coconut.readthedocs.io/en/master/HELP.html">http://coconut.readthedocs.io/en/master/HELP.html</a>
</li>

<li>Coconut FAQ<br />
<a href="http://coconut.readthedocs.io/en/master/FAQ.html">http://coconut.readthedocs.io/en/master/FAQ.html</a>
</li>

<li>Coconut Documentation<br />
<a href="http://coconut.readthedocs.io/en/master/DOCS.html">http://coconut.readthedocs.io/en/master/DOCS.html</a>
</li>

<li>Coconut na Redditu<br />
<a href="https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/">https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/</a>
</li>

<li>Repositář na GitHubu<br />
<a href="https://github.com/evhub/coconut">https://github.com/evhub/coconut</a>
</li>

<li>Object-Oriented Programming — The Trillion Dollar Disaster<br />
<a href="https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7</a>
</li>

<li>Goodbye, Object Oriented Programming<br />
<a href="https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53">https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53</a>
</li>

<li>So You Want to be a Functional Programmer (Part 1)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536</a>
</li>

<li>So You Want to be a Functional Programmer (Part 2)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 3)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7</a>
</li>

<li>So You Want to be a Functional Programmer (Part 4)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49</a>
</li>

<li>So You Want to be a Functional Programmer (Part 5)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 6)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403</a>
</li>

<li>Why Programmers Need Limits<br />
<a href="https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db">https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db</a>
</li>

<li>Infographic showing code complexity vs developer experience<br />
<a href="https://twitter.com/rossipedia/status/1580639227313676288">https://twitter.com/rossipedia/status/1580639227313676288</a>
</li>

<li>Python's reduce(): From Functional to Pythonic Style<br />
<a href="https://realpython.com/python-reduce-function/">https://realpython.com/python-reduce-function/</a>
</li>

<li>What is the problem with reduce()?<br />
<a href="https://stackoverflow.com/questions/181543/what-is-the-problem-with-reduce">https://stackoverflow.com/questions/181543/what-is-the-problem-with-reduce</a>
</li>

<li>The fate of reduce() in Python 3000<br />
<a href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196">https://www.artima.com/weblogs/viewpost.jsp?thread=98196</a>
</li>

<li>Reading 16: Map, Filter, Reduce<br />
<a href="http://web.mit.edu/6.031/www/sp22/classes/16-map-filter-reduce/">http://web.mit.edu/6.031/www/sp22/classes/16-map-filter-reduce/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

