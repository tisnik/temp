<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Rozhraní mezi nástrojem jq a programovacím jazykem Python</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Rozhraní mezi nástrojem jq a programovacím jazykem Python</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Minulý týden jsme se na stránkách Roota seznámili s nástrojem jq, který slouží pro zpracování dat uložených ve formátu JSON z příkazové řádky. Tento nástroj, resp. jeho DSL lze ovšem použít i ve skriptech psaných v Pythonu, a to díky balíčkům jq.py a pyjq, kterými se budeme zabývat dnes.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Rozhraní mezi nástrojem <strong>jq</strong> a programovacím jazykem Python</a></p>
<p><a href="#k02">2. Balíček <strong>jq.py</strong> s&nbsp;implementací rozhraní mezi Pythonem a nástrojem <strong>jq</strong></a></p>
<p><a href="#k03">3. Rozhraní mezi Pythonem a nástrojem <strong>jq</strong> z&nbsp;pohledu programátora</a></p>
<p><a href="#k04">4. Chování v&nbsp;případě chybného vstupu, obsluha výjimek</a></p>
<p><a href="#k05">5. Metoda <strong>first</strong></a></p>
<p><a href="#k06">6. Použití uvozovek v&nbsp;dotazovacím jazyku nástroje <strong>jq</strong></a></p>
<p><a href="#k07">7. Ukázky nepatrně složitějších dotazů</a></p>
<p><a href="#k08">8. Získání složitější datové struktury &ndash; slovníku nebo seznamu</a></p>
<p><a href="#k09">9. Dotaz vracející seznam obsahující slovníky</a></p>
<p><a href="#k10">10. Alternativní přístup k&nbsp;nástroji <strong>jq</strong></a></p>
<p><a href="#k11">11. Instalace balíčku <strong>pyjq</strong> a otestování, zda je ho možné naimportovat</a></p>
<p><a href="#k12">12. Struktura volání <strong>jq</strong> přes rozhraní reprezentované balíčkem <strong>pyjq</strong></a></p>
<p><a href="#k13">13. Chování balíčku <strong>pyjq</strong> ve chvíli, kdy požadovaný prvek neexistuje</a></p>
<p><a href="#k14">14. Použití uvozovek v&nbsp;dotazovacím jazyku</a></p>
<p><a href="#k15">15. Ukázky nepatrně složitějších dotazů</a></p>
<p><a href="#k16">16. Zřetězení dotazů s&nbsp;využitím znaku &bdquo;|&ldquo;</a></p>
<p><a href="#k17">17. Přečtení složitější datové struktury &ndash; slovníku nebo seznamu</a></p>
<p><a href="#k18">18. Ekvivalenty příkladů z&nbsp;první poloviny článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Rozhraní mezi nástrojem <strong>jq</strong> a programovacím jazykem Python</h2>

<p><a
href="https://www.root.cz/clanky/zpracovani-dat-reprezentovanych-ve-formatu-json-nastrojem-jq/">V&nbsp;článku
o užitečném nástroji <strong>jq</strong></a> jsme si řekli, že nástroj
<strong>jq</strong>, který je používám pro zpracování dat uložených ve formátu
JSON, je určen primárně pro spouštění z&nbsp;příkazové řádky popř.&nbsp;ze
shell skriptů. Ovšem kvůli velké popularitě tohoto nástroje (ostatně viz
například <a href="https://github.com/stedolan/jq">počet hvězdiček</a>
přidělených jeho repositáři) vzniklo i rozhraní mezi <strong>jq</strong> a <a
href="https://www.root.cz/n/python/">programovacím jazykem Python</a>. Ve
skutečnosti, abychom byli více přesní, vznikla dokonce dvě rozhraní
reprezentovaná různě pojmenovanými balíčky. První balíček se jmenuje
<strong>jq</strong>, ovšem kvůli rozlišení oproti původnímu nástroji
<strong>jq</strong> se většinou používá jméno <strong>jq.py</strong>. A druhý
podobně koncipovaný balíček, ovšem s&nbsp;odlišným API, se pro změnu jmenuje
<strong>pyjq</strong> (nyní pochopitelně bez tečky).</p>

<p>Před použitím pythoních balíčků <strong>jq.py</strong> nebo
<strong>pyjq</strong> je vhodné si nainstalovat binární balíček
<strong>jq</strong> se stejně pojmenovaným nástrojem <strong>jq</strong>
spustitelným z&nbsp;příkazové řádky. Podrobnostem jsme se věnovali <a
href="https://www.root.cz/clanky/zpracovani-dat-reprezentovanych-ve-formatu-json-nastrojem-jq/#k02">minule</a>,
takže jen krátce &ndash; nejrychlejší bývá použití správce balíčků vaší
distribuce Linuxu. V&nbsp;případě dnes již dosti muzeální Fedory 27 proběhne
instalace následovně:</p>

<pre>
$ <strong>sudo dnf install jq</strong>
&nbsp;
Last metadata expiration check: 1:36:21 ago on Tue 04 Aug 2020 05:00:30 PM CEST.
Dependencies resolved.
================================================================================
 Package            Arch            Version               Repository       Size
================================================================================
Installing:
 jq                 x86_64          1.5-8.fc27            fedora          158 k
Installing dependencies:
 oniguruma          x86_64          6.6.1-1.fc27          fedora          178 k
&nbsp;
Transaction Summary
================================================================================
Install  2 Packages
&nbsp;
Total download size: 337 k
Installed size: 1.1 M
Is this ok [y/N]: y
</pre>

<p><div class="rs-tip-major">Poznámka: podobně snadno instalace proběhne i na
distribucích založených na <strong>APT</strong> apod.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Balíček <strong>jq.py</strong> s&nbsp;implementací rozhraní mezi Pythonem a nástrojem <strong>jq</strong></h2>

<p>Nejdříve se budeme věnovat balíčku pojmenovaném <strong>jq.py</strong>, jenž
zpřístupňuje nástroj <strong>jq</strong> přímo programátorům používajícím
Python. Tento balíček lze nainstalovat snadno, typicky nástrojem
<strong>pip</strong> nebo <strong>pip3</strong>, popř.&nbsp;lze pochopitelně
využít virtuální prostředí Pythonu:</p>

<pre>
$ <strong>pip3 install --user jq</strong>
&nbsp;
Collecting jq
  Downloading https://files.pythonhosted.org/packages/37/83/e1f7162986c228cc33768b9c53c1167cafe222f8d81f1325a27cfff42f47/jq-1.0.2-cp36-cp36m-manylinux1_x86_64.whl (502kB)
    100% |████████████████████████████████| 512kB 1.5MB/s 
Installing collected packages: jq
Successfully installed jq-1.0.2
</pre>

<p><div class="rs-tip-major">Poznámka: instalace proběhne takto rychle pouze
v&nbsp;tom případě, že již máte nainstalován i binární balíček
<strong>jq</strong>. Pokud tomu tak není, pokusí se <strong>pip</strong> nebo
<strong>pip3</strong> nejdříve získat zdrojové kódy <strong>jq</strong> a
přeložit je. K&nbsp;tomu bude potřebovat základní sadu vývojářských nástrojů
gcc, zejména překladač céčka, linker a nástroj <strong>make</strong>.
V&nbsp;případě, že je binární verze <strong>jq</strong> na systému již
nainstalována (<a href="#k01">viz úvodní kapitolu</a>), jsou tyto kroky
přeskočeny.</div></p>

<p>Následně se můžeme přesvědčit, že je balíček <strong>jq.py</strong> skutečně
dostupný pro vývojáře používající programovací jazyk Python. Následující skript
by měl být spustitelný a měl by zobrazit nápovědu k&nbsp;balíčku
<strong>jq.py</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
&nbsp;
help(jq)
</pre>

<p>S&nbsp;přibližným výstupem:</p>

<pre>
Help on module jq:
&nbsp;
NAME
    jq
&nbsp;
FUNCTIONS
    all(...)
&nbsp;
    compile(...)
&nbsp;
    first(...)
&nbsp;
    iter(...)
&nbsp;
    jq(...)
&nbsp;
    text(...)
&nbsp;
DATA
    __test__ = {}
&nbsp;
FILE
</pre>

<p>Pokud dojde k&nbsp;chybě při importu, zkontrolujte si, zda je
<strong>jq.py</strong> nainstalován v&nbsp;adresáři, který je součástí seznamu
cest, na kterých interpret Pythonu hledá balíčky:</p>

<pre>
<strong>import</strong> sys
print(sys.path)
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti jsme prozatím otestovali
pouze to, že lze naimportovat balíček <strong>jq.py</strong> do interpretru
Pythonu, nikoli samotné rozhraní k&nbsp;binárnímu nástroji
<strong>jq</strong>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozhraní mezi Pythonem a nástrojem <strong>jq</strong> z&nbsp;pohledu programátora</h2>

<p>V&nbsp;balíčku <strong>jq.py</strong> je k&nbsp;dispozici pouze několik
funkcí a metod, které zprostředkovávají rozhraní mezi nástrojem
<strong>jq</strong> a skriptem psaným v&nbsp;Pythonu. Jedná se o následující
funkce a metody:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>compile()</td><td>(funkce) program psaný v&nbsp;DSL nástroje <strong>jq</strong> je přeložen a vrácen ve formě objektu</td></tr>
<tr><td>2</td><td>input()</td><td>metoda, které se předají vstupní data buď ve formě textu nebo JSON objektu</td></tr>
<tr><td>3</td><td>first()</td><td>získání prvního výsledku aplikace dotazu na JSON data</td></tr>
<tr><td>4</td><td>all()</td><td>získání všech výsledků aplikace dotazu na JSON data</td></tr>
<tr><td>5</td><td>text()</td><td>získání výsledků ve formě textu (a nikoli slovníku nebo seznamu)</td></tr>
<tr><td>6</td><td>iter()</td><td>(funkce) získání iterátoru pro procházení jednotlivými prvky výsledku</td></tr>
</table>

<p>Podívejme se nyní na několik základních příkladů použití balíčku
<strong>jq.py</strong>.</p>

<p>Přečtení vstupního souboru do řetězce (tedy do čistého textu), aplikace
dotazu na text a získání výsledku ve formě seznamu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = fin.read()
    print(jq.compile(".openapi").input(text=content).all())
</pre>

<p>Výsledek:</p>

<pre>
['3.0.0']
</pre>

<p>Přečtení vstupního souboru do objektu JSON, aplikace dotazu na JSON a
získání výsledku ve formě seznamu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>

<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(jq.compile(".openapi").input(content).all())
</pre>

<p>Výsledek:</p>

<pre>
['3.0.0']
</pre>

<p>Dtto, ale tentokrát získáme výsledek ve formě čistého textu a nikoli
seznamu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = fin.read()
    print(jq.compile(".openapi").input(text=content).text())
</pre>

<p>Výsledek:</p>

<pre>
"3.0.0"
</pre>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(jq.compile(".openapi").input(content).text())
</pre>

<p>Výsledek:</p>

<pre>
"3.0.0"
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že součástí výsledku
(tedy řetězce) jsou i uvozovky, které je možné v&nbsp;případě potřeby odstranit
prostředky samotného Pythonu. Podobně se vrátí řetězec (i když to tak nemusí na
první pohled vypadat) ve chvíli, kdy například přečteme pole a necháme si ho
vrátit ve formě textu:</div></p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    value = jq.compile(".security").input(content).text()
    print(value)
    print(type(value))
</pre>

<p>Výsledek:</p>

<pre>
[]
&lt;class 'str'&gt;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Chování v&nbsp;případě chybného vstupu, obsluha výjimek</h2>

<p>Nyní se pokusme zpracovat chybný soubor nazvaný &bdquo;broken.json&ldquo;,
který neobsahuje korektní obsah v&nbsp;JSONu. Obsah tohoto souboru nelze
přečíst prostředky poskytovanými standardním balíčkem <strong>json</strong>,
takže vyzkoušíme, co se stane při přečtení obsahu souboru do řetězce
s&nbsp;předáním tohoto řetězce zkompilovanému dotazu balíčku
<strong>jq.py</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
&nbsp;
<strong>with</strong> open("broken.json") <strong>as</strong> fin:
    content = fin.read()
    print(jq.compile(".openapi").input(text=content).all())
</pre>

<p>Při pokusu o spuštění výše uvedeného skriptu dojde k&nbsp;výjimce, která
naznačuje, že se vzniklá chyba v&nbsp;binárním balíčku <strong>jq</strong>
pouze převede na výjimku a předá se volajícímu kódu:</p>

<pre>
$ <strong>./04_no_error_handling.py</strong>
&nbsp;
Traceback (most recent call last):
  File "./04_no_error_handling.py", line 11, in &lt;module&gt;
    print(jq.compile(".openapi").input(text=content).all())
  File "jq.pyx", line 211, in jq._ProgramwithInput.all
  File "jq.pyx", line 242, in jq._ResultIterator.__next__
  File "jq.pyx", line 248, in jq._ResultIterator._next_string
  File "jq.pyx", line 275, in jq._ResultIterator._ready_next_input
ValueError: parse error: Expected separator between values at line 11, column 15
</pre>

<p>Takovou výjimku pochopitelně můžeme velmi snadno odchytit a nějakým způsobem
na ni zareagovat (minimálně vypsat informace do logu, když už nic jiného):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
&nbsp;
<strong>with</strong> open("broken.json") <strong>as</strong> fin:
    content = fin.read()
    <strong>try</strong>:
        print(jq.compile(".openapi").input(text=content).all())
    <strong>except</strong> Exception <strong>as</strong> e:
        print(e)
</pre>

<p>Chování takto upraveného skriptu po jeho spuštění již bude dosti
odlišné:</p>

<pre>
$ <strong>./05_error_handling.py</strong>
&nbsp;
parse error: Expected separator between values at line 11, column 15
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Metoda <strong>first</strong></h2>

<p>Víme již, že pokud je vstup do <strong>jq</strong> zpracován korektně,
můžeme výstup získat buď ve formě seznamu (metoda <strong>all</strong>) nebo
textu (metoda <strong>text</strong>). Mnohdy je ovšem výsledkem dotazu jediná
hodnota (prvek z&nbsp;původního JSONu popř.&nbsp;nějakým způsobem
transformovaný prvek). A hodnotu tohoto jediného prvku získáme metodou
<strong>first</strong>, což je ukázáno na dalším demonstračním příkladu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(jq.compile(".openapi").input(content).first())
    print(jq.compile(".info.description").input(content).first())
    print(jq.compile(".tags").input(content).first())
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
3.0.0
A very simple REST API service
[]
</pre>

<p>O tom, že se skutečně jedná o prvky se správným typem (v&nbsp;Pythonu) se
opět můžeme přesvědčit po úpravě skriptu:</p>

<pre>
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(type(jq.compile(".openapi").input(content).first()))
    print(type(jq.compile(".info.description").input(content).first()))
    print(type(jq.compile(".tags").input(content).first()))
</pre>

<p>Nyní se namísto hodnot získaných prvků vypíšou jejich typy:</p>

<pre>
&lt;class 'str'&gt;
&lt;class 'str'&gt;
&lt;class 'list'&gt;
</pre>

<p>V&nbsp;případě, že prvek není nalezen (je zadána špatná cesta
resp.&nbsp;cesta neodpovídající obsahu JSONu), vrátí se hodnota
<strong>None</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(jq.compile(".non_existing_key").input(content).first())
</pre>

<p>Vytiskne se:</p>

<pre>
None
</pre>

<p>Který je skutečně správného typu:</p>

<pre>
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(type(jq.compile(".non_existing_key").input(content).first()))
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
&lt;class 'NoneType'&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití uvozovek v&nbsp;dotazovacím jazyku nástroje <strong>jq</strong></h2>

<p>Balíček <strong>jq.py</strong> ve skutečnosti tvoří pouze velmi úzkou vrstvu
mezi Pythonem a nástrojem <strong>jq</strong>. Například se vlastně žádným
způsobem nemodifikuje dotaz (<i>query</i>) zapisovaný v&nbsp;doménově
specifickém jazyku (DSL) nástroje <strong>jq</strong>. Musíme si dát pozor
především na správné použití uvozovek ve chvíli, kdy se přistupuje ke klíči,
který například obsahuje lomítko či jiný specifický znak (JSON je sice
pojmenován podle JavaScriptu, ovšem jeho syntaxe je v&nbsp;tomto ohledu
volnější). Podívejme se nyní na demonstrační příklad, ve kterém se přistupuje
ke zvýrazněné části JSONu:</p>

<pre>
{
    ...
    ...
    ...
    "paths": {
        <strong>"/"</strong>: {
            "get": {
                ...
                ...
                ...
            }
        }
    }
}
</pre>

<p>V&nbsp;dotazu se tedy musí vyskytovat <strong>.paths./</strong>, což ovšem
není korektní zápis. Ve skutečnosti musíme lomítko (poslední část dotazu)
zapsat do uvozovek. Pokud do uvozovek vložíme celý dotaz, vrátí se samotný
dotaz jako výsledek (řetězec); pokud uvozovky neuvedeme vůbec, dojde
k&nbsp;chybě při pokusu o spuštění skriptu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print("-----------------------------")
    print(jq.compile('.paths."/"').input(content).first())
    print("-----------------------------")
    print(jq.compile('".paths./"').input(content).first())
    print("-----------------------------")
    print(jq.compile('.paths./').input(content).first())
</pre>

<p>Po spuštění tohoto demonstračního příkladu je jasně patrné, jakým způsobem
jsou výsledné dotazy zpracovány resp.&nbsp;v&nbsp;posledním případě
nezpracovány:</p>

<pre>
-----------------------------
{'get': {'summary': 'Returns valid HTTP 200 ok status when the service is ready', 'description': '', 'parameters': [], 'operationId': 'main', 'responses': {'default': {'description': 'Default response'}}}}
-----------------------------
.paths./
-----------------------------
Traceback (most recent call last):
  File "./08_escape_characters.py", line 17, in <module>
    print(jq.compile('.paths./').input(content).first())
  File "jq.pyx", line 56, in jq.compile
  File "jq.pyx", line 160, in jq._Program.__cinit__
  File "jq.pyx", line 131, in jq._JqStatePool.__cinit__
  File "jq.pyx", line 84, in jq._compile
  File "jq.pyx", line 72, in jq._compile
  File "jq.pyx", line 78, in jq._compile
ValueError: jq: error: syntax error, unexpected '/', expecting FORMAT or QQSTRING_START (Unix shell quoting issues?) at <top-level>, line 1:
.paths./       
jq: 1 compile error
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Ukázky nepatrně složitějších dotazů</h2>

<p>Získání informace o licenci, pod kterou je soubor vydán:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(jq.compile(".info.license.name").input(content).first())
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
Apache 2.0
</pre>

<p><div class="rs-tip-major">Poznámka: typ výsledku je v&nbsp;tomto případě
pochopitelně řetězec.</div></p>

<p>Získání souhrnných popisů všech endpointů s&nbsp;HTTP požadavkem typu
GET:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    summaries = jq.compile(".paths[] | .get.summary").input(content).all()
    for summary in summaries:
        print(summary)
</pre>

<p>Nyní se vypíše:</p>

<pre>
Returns valid HTTP 200 ok status when the service is ready
Read list of all clusters from database and return it to a client
Read cluster specified by its ID and return it to a client
Search for a cluster specified by its ID or name
</pre>

<p>Dtto, ovšem pro HTTP požadavky typu DELETE (ten existuje pouze pro jediný
koncový bod):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    summaries = jq.compile(".paths[] | .delete.summary").input(content).all()
    for summary in summaries:
        print(summary)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
None
None
Delete a cluster specified by its ID
None
</pre>

<p><div class="rs-tip-major">Poznámka: zde je zapotřebí si dát pozor na to, že
u některých endpointů získáme řetězce a u jiných hodnotu
<strong>None</strong>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Získání složitější datové struktury &ndash; slovníku nebo seznamu</h2>

<p>V&nbsp;případě, že je výsledkem dotazu obsah uzlu s&nbsp;dalšími poduzly
nebo polem, vrátí se tento obsah ve formě příslušné datové struktury Pythonu,
což si ostatně ukážeme na dalším příkladu, který obsahuje tentýž dotaz, jednou
ovšem zapsaný v&nbsp;dvojitých uvozovkách (interně vyžaduje
&bdquo;quotování&ldquo; vnitřních uvozovek) a podruhé zapsaný s&nbsp;uvozovkami
jednoduchými:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
from pprint <strong>import</strong> pprint
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    search = jq.compile(".paths.\"/client/cluster/search\"").input(content).first()
    pprint(search)
&nbsp;
    print("----------------------------------------------------------------------------")
&nbsp;
    search = jq.compile('.paths."/client/cluster/search"').input(content).first()
    pprint(search)
</pre>

<p>Výsledek je v&nbsp;obou případech vždy stejný:</p>

<pre>
{'get': {'description': '',
         'operationId': 'searchCluster',
         'parameters': [{'allowEmptyValue': True,
                         'description': 'Cluster ID',
                         'in': 'query',
                         'name': 'id',
                         'required': False,
                         'schema': {'type': 'string'}},
                        {'allowEmptyValue': True,
                         'description': 'Cluster name',
                         'in': 'query',
                         'name': 'name',
                         'required': False,
                         'schema': {'type': 'string'}}],
         'responses': {'default': {'description': 'Default response'}},
         'summary': 'Search for a cluster specified by its ID or name'}}
----------------------------------------------------------------------------
{'get': {'description': '',
         'operationId': 'searchCluster',
         'parameters': [{'allowEmptyValue': True,
                         'description': 'Cluster ID',
                         'in': 'query',
                         'name': 'id',
                         'required': False,
                         'schema': {'type': 'string'}},
                        {'allowEmptyValue': True,
                         'description': 'Cluster name',
                         'in': 'query',
                         'name': 'name',
                         'required': False,
                         'schema': {'type': 'string'}}],
         'responses': {'default': {'description': 'Default response'}},
         'summary': 'Search for a cluster specified by its ID or name'}}
</pre>

<p>V&nbsp;dalším příkladu je výsledkem dotazu seznam seznamů a ve druhé části
seznam pravdivostních hodnot <strong>True</strong> nebo <strong>False</strong>.
Seznam obsahuje pro každý koncový bod další seznam s&nbsp;podporovanými
metodami, který následně spojíme do řetězce tak, aby byly názvy jednotlivých
metod odděleny čárkami:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
&nbsp;
    for endpoint in jq.compile('.paths[]').input(content).all():
        print(",".join(endpoint.keys()))
&nbsp;
    print("-------------------------")
&nbsp;
    for has_get in jq.compile('.paths[] | has("get")').input(content).all():
        print(has_get)
</pre>

<p>Výsledek zobrazený po spuštění tohoto demonstračního příkladu:</p>

<pre>
get
x-temp,get
get,post,delete
get
-------------------------
True
True
True
True
</pre>

<p>Dtto, ovšem ve druhém dotazu a na něj navázané programové smyčce zobrazíme
informaci, zda daný koncový bod podporuje HTTP metodu DELETE:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
&nbsp;
    for endpoint in jq.compile('.paths[]').input(content).all():
        print(",".join(endpoint.keys()))
&nbsp;
    print("-------------------------")
&nbsp;
    for has_delete in jq.compile('.paths[] | has("delete")').input(content).all():
        print(has_delete)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
get
x-temp,get
get,post,delete
get
-------------------------
False
False
True
False
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Dotaz vracející seznam obsahující slovníky</h2>

<p>V&nbsp;posledním demonstračním příkladu, který je založen na balíčku
<strong>jq.py</strong> použijeme dotaz vracející seznam, jehož prvky jsou
slovníky. Dotaz totiž získá všechny parametry koncového bodu
&bdquo;/client/cluster/search&ldquo; pro HTTP metodu GET:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou jq.py</i>
&nbsp;
<strong>import</strong> jq
<strong>import</strong> json
from pprint <strong>import</strong> pprint
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
&nbsp;
    for parameters in jq.compile('.paths."/client/cluster/search".get.parameters').input(content).all():
        pprint(parameters)
</pre>

<p>Po spuštění tohoto skriptu by se měl zobrazit seznam s&nbsp;dvojicí prvků,
přičemž každý prvek je slovníkem. Povšimněte si, že pravdivostní hodnoty jsou
z&nbsp;JSONu převedeny na skutečné pravdivostní hodnoty jazyka Python:</p>

<pre>
[{'allowEmptyValue': True,
  'description': 'Cluster ID',
  'in': 'query',
  'name': 'id',
  'required': False,
  'schema': {'type': 'string'}},
 {'allowEmptyValue': True,
  'description': 'Cluster name',
  'in': 'query',
  'name': 'name',
  'required': False,
  'schema': {'type': 'string'}}]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Alternativní přístup k&nbsp;nástroji <strong>jq</strong></h2>

<p>V&nbsp;první polovině článku jsme se primárně zabývali balíčkem
<strong>jq.py</strong>, který poskytuje vývojářům pracujícím
v&nbsp;programovacím jazyku Python rozhraní pro nástroj <strong>jq</strong>.
Víme již, že kromě balíčku <strong>jq.py</strong> existuje i alternativní
balíček nazvaný pro změnu <strong>pyjq</strong>. Ve druhé části dnešního článku
si tedy ukážeme základní způsob použití tohoto balíčku, který se ovládá
nepatrně odlišným způsobem. Ovšem základní princip zůstává stejný &ndash;
získat ze vstupního JSONu datovou strukturu nebo seznam struktur a tu dále
nějakým způsobem dále zpracovat.</p>

<p><div class="rs-tip-major">Poznámka: většina příkladů je zvolena takovým
způsobem, aby se podobaly příkladům z&nbsp;první poloviny článku.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Instalace balíčku <strong>pyjq</strong> a otestování, zda je ho možné naimportovat</h2>

<p>Instalaci balíčku <strong>pyjq</strong> opět provedeme pomocí nástroje
<strong>pip</strong> popř.&nbsp;<strong>pip3</strong>. Instalace bude nepatrně
delší, protože se bude překládat i nativní část balíčku (počítejte s&nbsp;cca
dvaceti sekundami):</p>

<pre>
$ <strong>pip3 install --user pyjq</strong>
&nbsp;
Collecting pyjq
  Downloading https://files.pythonhosted.org/packages/a5/7c/b7fdc7b9653d5f05552cb08b6e9883db13db21ca0c8b0cd100e5a5ed3a35/pyjq-2.4.0.tar.gz (2.0MB)
    100% |████████████████████████████████| 2.0MB 723kB/s 
Installing collected packages: pyjq
  Running setup.py install for pyjq ... done
Successfully installed pyjq-2.4.0
</pre>

<p>A opět si můžeme otestovat, zda je možné naimportovat balíček
<strong>pyjq</strong> do Pythonovského skriptu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
&nbsp;
help(pyjq)
</pre>

<p>Tento skript by měl po svém spuštění vypsat (dosti stručnou) nápovědu:</p>

<pre>
Help on module pyjq:
&nbsp;
NAME
    pyjq
&nbsp;
DATA
    __all__ = []
&nbsp;
FILE
    /home/ptisnovs/.local/lib/python3.6/site-packages/pyjq.py
&nbsp;
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Struktura volání <strong>jq</strong> přes rozhraní reprezentované balíčkem <strong>pyjq</strong></h2>

<p>Ze zdrojových kódů následujících dvou skriptů je patrné, že se struktura
volání mezi balíčky <strong>jq.py</strong> a <strong>pyjq</strong> odlišuje.
Při použití balíčku <strong>pyjq</strong> je nejdříve nutné přeložit dotaz
(naprosto stejně pojmenovanou funkcí &ndash; konstruktorem), ovšem následně se
již přímo volá metoda <strong>all</strong> nebo <strong>first</strong>, které
se předá již načtený obsah JSON souboru. Povšimněte si, že není podporováno
přímé zpracování dat z&nbsp;textového souboru (resp.&nbsp;z&nbsp;řetězce)
&ndash; vždy se použije standardní balíček <strong>json</strong>.</p>

<p>Volání ve chvíli, kdy vyžadujeme získání většího množství hodnot:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(pyjq.compile(".openapi").all(content))
</pre>

<p>V&nbsp;tomto konkrétním případě se vrátí seznam s&nbsp;jedinou hodnotou,
ovšem stále se bude jednat o seznam:</p>

<pre>
['3.0.0']
</pre>

<p>Volání ve chvíli, kdy vyžadujeme přečtení jediné hodnoty, tj.&nbsp;buď
prvního prvku nebo jediného prvku odpovídajícího dotazu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(pyjq.compile(".openapi").first(content))
</pre>

<p>Výsledek je tvořen řetězcem:</p>

<pre>
3.0.0
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že řetězec nyní
neobsahuje uvozovky, na rozdíl od podobné konstrukce použité v&nbsp;balíčku
<strong>jq.py</strong>.</div></p>

<p>Pozor ovšem na to, že čistě textový vstup nelze zpracovat:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = fin.read()
    print(pyjq.compile(".openapi").all(content))
</pre>

<p>Při pokusu o zpracování dojde k&nbsp;chybě:</p>

<pre>
Traceback (most recent call last):
  File "./14_no_text_processing.py", line 11, in &lt;module&gt;
    print(pyjq.compile(".openapi").all(content))
  File "_pyjq.pyx", line 213, in _pyjq.Script.all
_pyjq.ScriptRuntimeError: Cannot index string with string "openapi"
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Chování balíčku <strong>pyjq</strong> ve chvíli, kdy požadovaný prvek neexistuje</h2>

<p>V&nbsp;případě, že požadovaný prvek neexistuje (tedy většinou tehdy, kdy
není nalezen příslušný klíč), vrací balíček <strong>pyjq</strong> buď hodnotu
<strong>None</strong> nebo seznam s&nbsp;jediným prvkem <strong>None</strong>.
Otestujme si nejprve první případ, tj.&nbsp;pokus o přečtení jediného prvku,
který ovšem v&nbsp;JSON souboru neexistuje:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(pyjq.compile(".foobar").first(content))
</pre>

<p>Prvek s&nbsp;klíčem <strong>foobar</strong> v&nbsp;JSON souboru nelze
nalézt, proto se vrátí hodnota:</p>

<pre>
None
</pre>

<p>Ve druhém případě budeme chtít získat více prvků, nikoli prvek jediný, takže
se použije metoda <strong>all</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(pyjq.compile(".foobar").all(content))
</pre>

<p>Výsledkem je v&nbsp;tomto případě seznam s&nbsp;jediným prvkem obsahujícím
hodnotu <strong>None</strong>:</p>

<pre>
[None]
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Použití uvozovek v&nbsp;dotazovacím jazyku</h2>

<p><a href="#k06">V&nbsp;šesté kapitole</a> jsme si řekli, že pokud klíče
obsahují některé speciální znaky, zejména lomítka, je nutné tyto názvy klíčů
(ovšem nikoli celý dotaz!) umístit do uvozovek. Pokud to neuděláme, dojde
k&nbsp;chybě. Obě možnosti ilustruje následující demonstrační příklad, který
vznikl přímým přepisem příkladu ze šesté kapitoly:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print("-----------------------------")
    print(pyjq.compile('.paths."/"').first(content))
    print("-----------------------------")
    print(pyjq.compile('".paths./"').first(content))
    print("-----------------------------")
    print(pyjq.compile('.paths./').first(content))
</pre>

<p>První výsledek je korektní, ve druhém případě je dotaz chápán jako
konstantní řetězec a v&nbsp;případě třetím (zcela chybějící uvozovky) dojde
k&nbsp;chybě při běhu:</p>

<pre>
-----------------------------
{'get': {'summary': 'Returns valid HTTP 200 ok status when the service is ready', 'description': '', 'parameters': [], 'operationId': 'main', 'responses': {'default': {'description': 'Default response'}}}}
-----------------------------
.paths./
-----------------------------
Traceback (most recent call last):
  File "./06_escape_characters.py", line 17, in &lt;module&gt;
    print(pyjq.compile('.paths./').first(content))
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/pyjq.py", line 19, in compile
    library_paths=library_paths)
  File "_pyjq.pyx", line 190, in _pyjq.Script.__init__
ValueError: jq: error: syntax error, unexpected '/', expecting FORMAT or QQSTRING_START (Unix shell quoting issues?) at <top-level>, line 1:
.paths./       
jq: 1 compile error
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Ukázky nepatrně složitějších dotazů</h2>

<p>Získání informace o licenci, pod kterou je soubor vydán (viz též sedmou
kapitolu):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    print(pyjq.compile(".info.license.name").first(content))
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
Apache 2.0
</pre>

<p><div class="rs-tip-major">Poznámka: typ výsledku je v&nbsp;tomto případě
pochopitelně řetězec.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Zřetězení dotazů s&nbsp;využitím znaku &bdquo;|&ldquo;</h2>

<p>Získání souhrnných popisů všech endpointů s&nbsp;HTTP požadavkem typu
GET:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    summaries = pyjq.compile(".paths[] | .get.summary").all(content)
    for summary in summaries:
        print(summary)
</pre>

<p>Po spuštění tohoto demonstračního příkladu se vypíše:</p>

<pre>
Returns valid HTTP 200 ok status when the service is ready
Read list of all clusters from database and return it to a client
Read cluster specified by its ID and return it to a client
Search for a cluster specified by its ID or name
</pre>

<p>Dtto, ovšem pro HTTP požadavky typu DELETE (ten existuje pouze pro jediný
koncový bod):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    summaries = pyjq.compile(".paths[] | .delete.summary").all(content)
    for summary in summaries:
        print(summary)
</pre>

<p>Výsledky:</p>

<pre>
None
None
Delete a cluster specified by its ID
None
</pre>

<p>Pro jistotu se podíváme i na typy vrácených hodnot:</p>

<pre>
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    summaries = pyjq.compile(".paths[] | .delete.summary").all(content)
    for summary in summaries:
        print(summary, type(summary))
</pre>

<p>Výsledky:</p>

<pre>
None &lt;class 'NoneType'&gt;
None &lt;class 'NoneType'&gt;
Delete a cluster specified by its ID &lt;class 'str'&gt;
None &lt;class 'NoneType'&gt;
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Přečtení složitější datové struktury &ndash; slovníku nebo seznamu</h2>

<p>Opět si ukažme, jak je možné získat složitější datovou strukturu z&nbsp;JSON
souboru. Většinou se bude jednat o slovník nebo seznam, v&nbsp;našem případě
slovník:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
from pprint <strong>import</strong> pprint
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
    search = pyjq.compile(".paths.\"/client/cluster/search\"").first(content)
    pprint(search)
&nbsp;
    print("----------------------------------------------------------------------------")
&nbsp;
    search = pyjq.compile('.paths."/client/cluster/search"').first(content)
    pprint(search)
</pre>

<p>Oba dotazy jsou totožné, ovšem druhý dotaz je díky použití jednoduchých i
dvojitých uvozovek mnohem čitelnější:</p>

<pre>
{'get': {'description': '',
         'operationId': 'searchCluster',
         'parameters': [{'allowEmptyValue': True,
                         'description': 'Cluster ID',
                         'in': 'query',
                         'name': 'id',
                         'required': False,
                         'schema': {'type': 'string'}},
                        {'allowEmptyValue': True,
                         'description': 'Cluster name',
                         'in': 'query',
                         'name': 'name',
                         'required': False,
                         'schema': {'type': 'string'}}],
         'responses': {'default': {'description': 'Default response'}},
         'summary': 'Search for a cluster specified by its ID or name'}}
----------------------------------------------------------------------------
{'get': {'description': '',
         'operationId': 'searchCluster',
         'parameters': [{'allowEmptyValue': True,
                         'description': 'Cluster ID',
                         'in': 'query',
                         'name': 'id',
                         'required': False,
                         'schema': {'type': 'string'}},
                        {'allowEmptyValue': True,
                         'description': 'Cluster name',
                         'in': 'query',
                         'name': 'name',
                         'required': False,
                         'schema': {'type': 'string'}}],
         'responses': {'default': {'description': 'Default response'}},
         'summary': 'Search for a cluster specified by its ID or name'}}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Ekvivalenty příkladů z&nbsp;první poloviny článku</h2>

<p>Demonstrační příklady, na nichž jsme si ukázali některé možnosti balíčku
<strong>jq.py</strong>, lze pochopitelně velmi snadno přepsat tak, aby
používaly alternativní balíček <strong>pyjq</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
&nbsp;
    <strong>for</strong> endpoint <strong>in</strong> pyjq.compile('.paths[]').all(content):
        print(",".join(endpoint.keys()))
&nbsp;
    print("-------------------------")
&nbsp;
    <strong>for</strong> has_get <strong>in</strong> pyjq.compile('.paths[] | has("get")').all(content):
        print(has_get)
</pre>

<p>Výsledek:</p>

<pre>
get
x-temp,get
get,post,delete
get
-------------------------
True
True
True
True
</pre>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
&nbsp;
    <strong>for</strong> endpoint <strong>in</strong> pyjq.compile('.paths[]').all(content):
        print(",".join(endpoint.keys()))
&nbsp;
    print("-------------------------")
&nbsp;
    <strong>for</strong> has_delete <strong>in</strong> pyjq.compile('.paths[] | has("delete")').all(content):
        print(has_delete)
</pre>

<p>Výsledek:</p>

<pre>
get
x-temp,get
get,post,delete
get
-------------------------
False
False
True
False
</pre>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i>#  Demonstrační příklad k článku:</i>
<i>#      Zpracování dat uložených ve formátu JSON knihovnou pyjq</i>
&nbsp;
<strong>import</strong> pyjq
<strong>import</strong> json
from pprint <strong>import</strong> pprint
&nbsp;
<strong>with</strong> open("openapi.json") <strong>as</strong> fin:
    content = json.load(fin)
&nbsp;
    <strong>for</strong> parameters <strong>in</strong> pyjq.compile('.paths."/client/cluster/search".get.parameters').all(content):
        pprint(parameters)
</pre>

<p>Výsledek:</p>

<pre>
[{'allowEmptyValue': True,
  'description': 'Cluster ID',
  'in': 'query',
  'name': 'id',
  'required': False,
  'schema': {'type': 'string'}},
 {'allowEmptyValue': True,
  'description': 'Cluster name',
  'in': 'query',
  'name': 'name',
  'required': False,
  'schema': {'type': 'string'}}]
</pre>

<p><div class="rs-tip-major">Poznámka: JSON není jediným vhodným formátem pro
přenosy strukturovaných dat. V&nbsp;některých ohledech je výhodnější použití
formátu EDN pocházejícího ze světa programovacího jazyka Clojure. S&nbsp;tímto
formátem se seznámíme příště.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně několik jednotek
kilobajtů), můžete namísto toho použít odkazy na jednotlivé demonstrační
příklady a jejich části, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_basic_installation_check.py</td><td>základní test, zda byl balíček <strong>jq.py</strong> nainstalován</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/01_basic_installation_check.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/01_basic_installation_check.py</a></td></tr>
<tr><td> 2</td><td>02_process_as_text.py</td><td>zpracování vstupních dat reprezentovaných řetězcem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/02_process_as_text.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/02_process_as_text.py</a></td></tr>
<tr><td> 3</td><td>02_process_as_text_to_text.py</td><td>zpracování vstupních dat reprezentovaných řetězcem, výsledkem je text</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/02_process_as_text_to_text.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/02_process_as_text_to_text.py</a></td></tr>
<tr><td> 4</td><td>03_process_as_json.py</td><td>zpracování již deserializovaných vstupních dat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/03_process_as_json.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/03_process_as_json.py</a></td></tr>
<tr><td> 5</td><td>03_process_as_json_to_text.py</td><td>zpracování již deserializovaných vstupních dat, zpracovává se řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/03_process_as_json_to_text.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/03_process_as_json_to_text.py</a></td></tr>
<tr><td> 6</td><td>03_process_as_json_to_text_B.py</td><td>zpracování již deserializovaných vstupních dat, zpracovává se seznam</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/03_process_as_json_to_text_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/03_process_as_json_to_text_B.py</a></td></tr>
<tr><td> 7</td><td>04_no_error_handling.py</td><td>chování při výskytu chyby ve vstupních datech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/04_no_error_handling.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/04_no_error_handling.py</a></td></tr>
<tr><td> 8</td><td>05_error_handling.py</td><td>reakce na chyby</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/05_error_handling.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/05_error_handling.py</a></td></tr>
<tr><td> 9</td><td>06_first_value.py</td><td>získání pouze prvního výsledku dotazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/06_first_value.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/06_first_value.py</a></td></tr>
<tr><td>10</td><td>06_first_value_type.py</td><td>získání typu prvního výsledku dotazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/06_first_value_type.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/06_first_value_type.py</a></td></tr>
<tr><td>11</td><td>07_non_existing_key.py</td><td>chování v&nbsp;případě, že dotaz nenalezl žádnou hodnotu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/07_non_existing_key.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/07_non_existing_key.py</a></td></tr>
<tr><td>12</td><td>07_non_existing_key_type.py</td><td>chování v&nbsp;případě, že dotaz nenalezl žádnou hodnotu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/07_non_existing_key_type.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/07_non_existing_key_type.py</a></td></tr>
<tr><td>13</td><td>08_escape_characters.py</td><td>problematika speciálních znaků v&nbsp;DSL nástroje <strong>jq</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/08_escape_characters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/08_escape_characters.py</a></td></tr>
<tr><td>14</td><td>09_get_license.py</td><td>přečtení licence uložené v&nbsp;JSONu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/09_get_license.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/09_get_license.py</a></td></tr>
<tr><td>15</td><td>10_summary_for_all_endpoints_get.py</td><td>složitější dotaz na všechny metody podporované endpointy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/10_summary_for_all_endpoints_get.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/10_summary_for_all_endpoints_get.py</a></td></tr>
<tr><td>16</td><td>11_summary_for_all_endpoints_delete.py</td><td>složitější dotaz na všechny metody podporované endpointy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/11_summary_for_all_endpoints_delete.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/11_summary_for_all_endpoints_delete.py</a></td></tr>
<tr><td>17</td><td>12_search_endpoint.py</td><td>získání složitější datové struktury &ndash; slovníku nebo seznamu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/12_search_endpoint.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/12_search_endpoint.py</a></td></tr>
<tr><td>18</td><td>13_has_get_method.py</td><td>získání seznamu obsahujícího další seznamy jako své prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/13_has_get_method.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/13_has_get_method.py</a></td></tr>
<tr><td>19</td><td>14_has_delete_method.py</td><td>získání seznamu obsahujícího další seznamy jako své prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/14_has_delete_method.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/14_has_delete_method.py</a></td></tr>
<tr><td>20</td><td>15_get_parameters.py</td><td>dotaz vracející seznam obsahující slovníky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/15_get_parameters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/jq.py/15_get_parameters.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>01_basic_installation_check.py</td><td>základní test, zda byl balíček <strong>pyjq</strong> nainstalován</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/01_basic_installation_check.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/01_basic_installation_check.py</a></td></tr>
<tr><td>19</td><td>02_process_as_json.py</td><td>zpracování již deserializovaných vstupních dat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/02_process_as_json.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/02_process_as_json.py</a></td></tr>
<tr><td>20</td><td>03_first_value.py</td><td>získání pouze prvního výsledku dotazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/03_first_value.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/03_first_value.py</a></td></tr>
<tr><td>21</td><td>04_non_existing_key.py</td><td>chování v&nbsp;případě, že dotaz nenalezl žádnou hodnotu (čtení jediného prvku)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/04_non_existing_key.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/04_non_existing_key.py</a></td></tr>
<tr><td>22</td><td>05_non_existing_key.py</td><td>chování v&nbsp;případě, že dotaz nenalezl žádnou hodnotu (čtení seznamu)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/05_non_existing_key.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/05_non_existing_key.py</a></td></tr>
<tr><td>23</td><td>06_escape_characters.py</td><td>problematika speciálních znaků v&nbsp;DSL nástroje <strong>jq</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/06_escape_characters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/06_escape_characters.py</a></td></tr>
<tr><td>24</td><td>07_get_license.py</td><td>přečtení licence uložené v&nbsp;JSONu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/07_get_license.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/07_get_license.py</a></td></tr>
<tr><td>25</td><td>08_summary_for_all_endpoints_get.py</td><td>zřetězení dotazů s&nbsp;využitím znaku &bdquo;|&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/08_summary_for_all_endpoints_get.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/08_summary_for_all_endpoints_get.py</a></td></tr>
<tr><td>26</td><td>09_summary_for_all_endpoints_delete.py</td><td>zřetězení dotazů s&nbsp;využitím znaku &bdquo;|&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/09_summary_for_all_endpoints_delete.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/09_summary_for_all_endpoints_delete.py</a></td></tr>
<tr><td>27</td><td>10_search_endpoint.py</td><td>získání složitější datové struktury &ndash; slovníku nebo seznamu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/10_search_endpoint.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/10_search_endpoint.py</a></td></tr>
<tr><td>28</td><td>11_has_get_method.py</td><td>získání seznamu obsahujícího další seznamy jako své prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/11_has_get_method.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/11_has_get_method.py</a></td></tr>
<tr><td>29</td><td>12_has_delete_method.py</td><td>získání seznamu obsahujícího další seznamy jako své prvky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/12_has_delete_method.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/12_has_delete_method.py</a></td></tr>
<tr><td>30</td><td>13_get_parameters.py</td><td>dotaz vracející seznam obsahující slovníky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/13_get_parameters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/13_get_parameters.py</a></td></tr>
<tr><td>31</td><td>14_no_text_processing.py</td><td>nelze zpracovávat čistě textový vstup</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/14_no_text_processing.py">https://github.com/tisnik/most-popular-python-libs/blob/master/pyjq/14_no_text_processing.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Zpracování dat reprezentovaných ve formátu JSON nástrojem jq<br />
<a href="https://www.root.cz/clanky/zpracovani-dat-reprezentovanych-ve-formatu-json-nastrojem-jq/">https://www.root.cz/clanky/zpracovani-dat-reprezentovanych-ve-formatu-json-nastrojem-jq/</a>
</li>

<li>Balíček jq.py na PyPi<br />
<a href="https://pypi.org/project/jq/">https://pypi.org/project/jq/</a>
</li>

<li>Balíček pyjq na PyPi<br />
<a href="https://pypi.org/project/pyjq/">https://pypi.org/project/pyjq/</a>
</li>

<li>Repositář projektu jq (GitHub)<br />
<a href="https://github.com/stedolan/jq">https://github.com/stedolan/jq</a>
</li>

<li>GitHub stránky projektu jq<br />
<a href="https://stedolan.github.io/jq/">https://stedolan.github.io/jq/</a>
</li>

<li>5 modern alternatives to essential Linux command-line tools<br />
<a href="https://opensource.com/article/20/6/modern-linux-command-line-tools">https://opensource.com/article/20/6/modern-linux-command-line-tools</a>
</li>

<li>Návod k&nbsp;nástroji jq<br />
<a href="https://stedolan.github.io/jq/tutorial/">https://stedolan.github.io/jq/tutorial/</a>
</li>

<li>jq Manual (development version)<br />
<a href="https://stedolan.github.io/jq/manual/">https://stedolan.github.io/jq/manual/</a>
</li>

<li>Introducing JSON<br />
<a href="https://www.json.org/json-en.html">https://www.json.org/json-en.html</a>
</li>

<li>jq.py: a lightweight and flexible JSON processor<br />
<a href="https://github.com/mwilliamson/jq.py">https://github.com/mwilliamson/jq.py</a>
</li>

<li>Discover how to use jq, a JSON manipulation command line, with GeoJSON<br />
<a href="https://webgeodatavore.com/jq-json-manipulation-command-line-with-geojson.html">https://webgeodatavore.com/jq-json-manipulation-command-line-with-geojson.html</a>
</li>

<li>Reshaping JSON with jq<br />
<a href="https://programminghistorian.org/en/lessons/json-and-jq">https://programminghistorian.org/en/lessons/json-and-jq</a>
</li>

<li>Python bindings for jq<br />
<a href="https://pypi.org/project/jq/">https://pypi.org/project/jq/</a>
</li>

<li>edn<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Why use JSON over XML?<br />
<a href="https://www.sitepoint.com/json-vs-xml/">https://www.sitepoint.com/json-vs-xml/</a>
</li>

<li>XML and XPath<br />
<a href="https://www.w3schools.com/XML/xml_xpath.asp">https://www.w3schools.com/XML/xml_xpath.asp</a>
</li>

<li>XPath (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/XPath">https://en.wikipedia.org/wiki/XPath</a>
</li>

<li>RFC7159<br />
<a href="https://www.ietf.org/rfc/rfc7159.txt">https://www.ietf.org/rfc/rfc7159.txt</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

