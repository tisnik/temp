<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Tvorba aplikací s textovým uživatelským rozhraním založeným na knihovně prompt_toolkit</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Tvorba aplikací s textovým uživatelským rozhraním založeným na knihovně prompt_toolkit</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhém článku o knihovně prompt_toolkit se budeme zabývat pokročilejšími nastaveními příkazové řádky. Ukážeme si zápis víceřádkového textu, použití externího editoru, validaci dat při jejich zadávání, nástrojové pruhy (TUI), styly prvků TUI i zvýrazněním syntaxe vstupních dat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Tvorba aplikací s&nbsp;textovým uživatelským rozhraním založeným na knihovně prompt_toolkit</a></p>
<p><a href="#k02">2. Základní funkcionalita pro interaktivní aplikace &ndash; vstupní (textový) řádek</a></p>
<p><a href="#k03">3. Podpora pro zápis víceřádkového textu</a></p>
<p><a href="#k04">4. Zpracování stisku Ctrl+C a Ctrl+D</a></p>
<p><a href="#k05">5. Validace textu zapisovaného uživatelem po stisku klávesy Enter</a></p>
<p><a href="#k06">6. Validace již v&nbsp;průběhu zadávání vstupních údajů</a></p>
<p><a href="#k07">7. Povolení použití externího textového editoru po použití zkratky Ctrl+X Ctrl+E nebo v</a></p>
<p><a href="#k08">*** 8. Spodní nástrojový pruh a zpráva zapsaná na pravém okraji výzvy</a></p>
<p><a href="#k09">9. Přístup k&nbsp;editovanému textu (objekty Buffer a Document)</a></p>
<p><a href="#k10">*** 10. Callback funkce volané během editace</a></p>
<p><a href="#k11">*** 11. Demonstrační příklad: spodní nástrojový pruh a zpráva na pravém okraji výzvy reagující na uživatelský vstup</a></p>
<p><a href="#k12">*** 12. Změna stylu zobrazení všech relevantních prvků TUI</a></p>
<p><a href="#k13">*** 13. Zvýraznění syntaxe textu zapisovaného uživatelem na vstup</a></p>
<p><a href="#k14">*** 14. Vytvoření vlastního lexeru s&nbsp;klíčovými slovy</a></p>
<p><a href="#k15">15. Demonstrační příklad používající programátorem definovaný lexer</a></p>
<p><a href="#k16">16. Použití myši na vstupním textovém řádku</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Tvorba aplikací s&nbsp;textovým uživatelským rozhraním založeným na knihovně prompt_toolkit</h2>

<p>Na <a
href="https://www.root.cz/clanky/tvorba-aplikaci-s-prikazovym-radkem-v-pythonu-s-vyuzitim-knihoven-gnu-readline-a-prompt-toolkit/">předchozí článek s&nbsp;úvodními informacemi o knihovnách GNU Readline a
prompt_toolkit</a> dnes navážeme. Popíšeme si totiž další možnosti, které
programátorům (a vlastně také uživatelům) knihovna
<strong>prompt_toolkit</strong> nabízí při zdánlivě primitivní operaci &ndash;
zápisu textových dat přes terminál (konzoli). Ve skutečnosti se u mnoha
aplikací jedná o nejdůležitější prvek jejich uživatelského rozhraní, takže se
programátoři snaží své aplikace vylepšovat a zadávání dat co nejvíce
zjednodušit a vylepšit. A právě v&nbsp;tomto ohledu nabízí knihovna
<strong>prompt_toolkit</strong> poměrně velké množství funkcí, které jsou navíc
jednoduše použitelné (obdobnou funkcionalitu je mnohdy v&nbsp;plnohodnotných
GUI knihovnách dosti těžké dosáhnout).</p>

<p>Všechny dále popsané příklady jsou založeny na <a
href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt/prompt4_PromptSession.py">skriptu</a>
využívajícího objekt typu <strong>PromptSession</strong>. který jsme si již <a
href="https://www.root.cz/clanky/tvorba-aplikaci-s-prikazovym-radkem-v-pythonu-s-vyuzitim-knihoven-gnu-readline-a-prompt-toolkit/#k12">popsali minule</a>:</p>

<pre>
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
<strong>s = PromptSession()</strong>
&nbsp;
while True:
    cmd = <strong>s.prompt("Command: ")</strong>
    if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní funkcionalita pro interaktivní aplikace &ndash; vstupní (textový) řádek</h2>

<p>Mezi funkce, které je možné díky existenci knihovny
<strong>prompt_toolkit</strong> využít při programování vstupního řádku, patří
zejména:</p>

<ul>
<li><a href="https://www.root.cz/clanky/tvorba-aplikaci-s-prikazovym-radkem-v-pythonu-s-vyuzitim-knihoven-gnu-readline-a-prompt-toolkit/#k12">Záznam historie zadaných příkazů s&nbsp;možností jejich vyhledávání v&nbsp;historii</a></li>
<li><a href="https://www.root.cz/clanky/tvorba-aplikaci-s-prikazovym-radkem-v-pythonu-s-vyuzitim-knihoven-gnu-readline-a-prompt-toolkit/#k12">Automatické doplňování příkazů (založené například na klíčových slovech)</a></li>
<li><a href="https://www.root.cz/clanky/tvorba-aplikaci-s-prikazovym-radkem-v-pythonu-s-vyuzitim-knihoven-gnu-readline-a-prompt-toolkit/#k12">Zobrazení menu s&nbsp;nabídkou příkazů, které je možné doplnit</a></li>
<li><a href="https://www.root.cz/clanky/tvorba-aplikaci-s-prikazovym-radkem-v-pythonu-s-vyuzitim-knihoven-gnu-readline-a-prompt-toolkit/#k11">Vstup hesla nebo jiných tajných údajů, které se nemají opisovat na terminál</a></li>
<li><a href="https://www.root.cz/clanky/tvorba-aplikaci-s-prikazovym-radkem-v-pythonu-s-vyuzitim-knihoven-gnu-readline-a-prompt-toolkit/#k14">Režim emulující textový editor Vi/Vim</a></li>
<li><a href="https://www.root.cz/clanky/tvorba-aplikaci-s-prikazovym-radkem-v-pythonu-s-vyuzitim-knihoven-gnu-readline-a-prompt-toolkit/#k15">Režim emulující textový editor Emacs</a></li>
<li>Podpora pro programovatelné klávesové zkratky</li>
<li><a href="#k03">Možnost zápisu víceřádkového textu</a></li>
<li><a href="#k07">Vyvolání externího textového editoru vybraného uživatelem</a></li>
<li><a href="#k06">Validace textu již při jeho zápisu nebo při stisku Enter</a></li>
<li><a href="#k08">Programovatelný nástrojový pruh a popř.&nbsp;zpráva zobrazená na pravém okraji vstupního řádku</a></li>
<li><a href="#k12">Konfigurovatelný styl všech prvků TUI (výzva, zapisovaný text, zpráva napravo, nástrojový pruh)</a></li>
<li><a href="#k13">Zvýraznění syntaxe zapisovaného textu</a></li>
<li><a href="#k16">Podpora pro použití myši ve vstupním řádku</a></li>
</ul>



<p><a name="k03"></a></p>
<h2 id="k03">3. Podpora pro zápis víceřádkového textu</h2>

<p>V&nbsp;některých aplikacích se setkáme s&nbsp;nutností vstupu víceřádkového
textu (představme si například textový editor, který je součástí mailového
klienta typu <i>Mutt</i>). Tento režim je knihovnou
<strong>prompt_toolkit</strong> samozřejmě taktéž podporován a pro jeho použití
postačuje do metody <strong>PromptSession.prompt()</strong> předat nepovinný
parametr <strong>multiline</strong>:</p>

<pre>
s = PromptSession()
&nbsp;
user_input = <strong>s.prompt("Command: ", multiline=True)</strong>
</pre>

<p>Na následujících screenshotech je ukázáno chování takto nakonfigurovaného
příkazového řádku:</p>

*** image ***
<p><i>Obrázek 1: Po stisku klávesy <strong>Enter</strong> nedojde
k&nbsp;ukončení vstupu, ale &bdquo;pouze&ldquo; k&nbsp;přechodu na další řádek.
Mezi řádky se můžete přesouvat kurzorovými šipkami, řádky lze spojovat
apod.</i></p>

*** image ***
<p><i>Obrázek 2: Vstup je ukončen stiskem kombinace <strong>Esc,
Enter</strong>. Metoda <strong>prompt()</strong> vrátí jediný řetězec,
v&nbsp;němž jsou řádky odděleny znaky \n.</i></p>

*** image ***
<p><i>Obrázek 3: Pozor na to, že znak pro nový řádek (\n) je součástí vráceného
řetězce.</i></p>

*** image ***
<p><i>Obrázek 4: Příkaz &bdquo;quit&ldquo; je nutné zapsat posloupností kláves
<strong>q</strong>, <strong>u</strong>, <strong>i</strong>, <strong>t</strong>,
<strong>Esc</strong>, <strong>Enter</strong>.</i></p>

<p>Výše popsané chování je naprogramováno v&nbsp;dnešním <a
href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt10_multiline_edit.py">prvním
demonstračním příkladu</a>:</p>

<pre>
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
<strong>s = PromptSession()</strong>
&nbsp;
while True:
    cmd = <strong>s.prompt("Command: ", multiline=True)</strong>
    print("Entered text: {}".format(cmd))
    if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
        break
    elif cmd in {"help", "Help", "?"}:
        show_help()
    elif cmd == "eval":
        print("42")
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zpracování stisku Ctrl+C a Ctrl+D</h2>

<p>Při čekání na zápis textu uživatelem do příkazového řádku je nutné myslet na
speciální význam kláves <strong>Ctrl+C</strong> a <strong>Ctrl+D</strong>.
Stisk <strong>Ctrl+C</strong> totiž ve výchozím nastavení vede k&nbsp;vyvolání
výjimky typu <strong>KeyboardInterrupt</strong> a stisk klávesy
<strong>Ctrl+D</strong> <i>na prázdném řádku</i> ke vzniku výjimky typu
<strong>EOFError</strong> (pokud řádek prázdný není, slouží tato klávesa jako
alternativa za <strong>Delete</strong>).</p>

<p>Ukončení aplikace pro stisku <strong>Ctrl+D</strong>:</p>

<pre>
Traceback (most recent call last):
  File "prompt10_multiline_edit.py", line 16, in &lt;module&gt;
    cmd = s.prompt("Command: ", multiline=True)
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/shortcuts/prompt.py", line 722, in prompt
    return run_sync()
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/shortcuts/prompt.py", line 706, in run_sync
    return self.app.run(inputhook=self.inputhook)
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/application/application.py", line 682, in run
    return run()
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/application/application.py", line 656, in run
    return f.result()
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/eventloop/future.py", line 149, in result
    raise self._exception
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/eventloop/coroutine.py", line 90, in step_next
    new_f = coroutine.throw(exc)
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/application/application.py", line 635, in _run_async2
    result = yield f
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/eventloop/coroutine.py", line 92, in step_next
    new_f = coroutine.send(f.result())
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/application/application.py", line 596, in _run_async
    result = yield From(f)
<strong>EOFError</strong>
</pre>

<p>Ukončení aplikace pro stisku <strong>Ctrl+C</strong>:</p>

<pre>
Traceback (most recent call last):
  File "prompt10_multiline_edit.py", line 16, in <module>
    cmd = s.prompt("Command: ", multiline=True)
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/shortcuts/prompt.py", line 722, in prompt
    return run_sync()
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/shortcuts/prompt.py", line 706, in run_sync
    return self.app.run(inputhook=self.inputhook)
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/application/application.py", line 682, in run
    return run()
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/application/application.py", line 656, in run
    return f.result()
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/eventloop/future.py", line 149, in result
    raise self._exception
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/eventloop/coroutine.py", line 90, in step_next
    new_f = coroutine.throw(exc)
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/application/application.py", line 635, in _run_async2
    result = yield f
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/eventloop/coroutine.py", line 92, in step_next
    new_f = coroutine.send(f.result())
  File "/home/tester/.local/lib/python3.4/site-packages/prompt_toolkit/application/application.py", line 596, in _run_async
    result = yield From(f)
<strong>KeyboardInterrupt</strong>
</pre>

<p>V&nbsp;případě, že tyto výjimky nejsou odchyceny, bude aplikace ihned
ukončena, což nemusí být vždy žádoucí (opět si představme například násilně
ukončenou aplikaci typu GNU Octave s&nbsp;rozpracovaným projektem). Obě výjimky
lze samozřejmě snadno zachytit, což je ukázáno v&nbsp;dalším příkladu i
s&nbsp;typickými reakcemi &ndash; <strong>Ctrl+C</strong> násilně ukončí
stávající příkaz (a očekává příkaz nový), <strong>Ctrl+D</strong> ukončí celou
smyčku příkazů a pokračuje v&nbsp;další činnosti aplikace):</p>

<pre>
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
<strong>s = PromptSession()</strong>
&nbsp;
while True:
    try:
        cmd = <strong>s.prompt("Command: ")</strong>
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except <strong>KeyboardInterrupt</strong>:
        continue
    except <strong>EOFError</strong>:
        break
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Validace textu zapisovaného uživatelem po stisku klávesy Enter</h2>

<p>Prakticky ve všech aplikacích je nutné text zapsaný uživatelem nějakým
způsobem zvalidovat a popř.&nbsp;nahlásit chybu. I tuto funkcionality je možné
naprogramovat a to dokonce dvěma způsoby, které se od sebe odlišují
uživatelskou přívětivostí a nároky na výpočetní výkon. První způsob spočívá
v&nbsp;tom, že se validace provede až po odeslání textu klávesou Enter. Samotná
validace je implementována objektem typu <strong>Validator</strong>, který
obsahuje metodu <strong>validate</strong>. Tato metoda je zavolána automaticky
a pokud nevyhodí výjimku <strong>ValidationError</strong>, je vstup zpracován
běžným způsobem. V&nbsp;opačném případě se vypíše chybová zpráva a kurzor je
umístěn na místo chyby &ndash; oba tyto údaje se předávají právě ve výjimce
<strong>ValidationError</strong>:</p>

*** image ***
<p><i>Obrázek 5: Způsob zobrazení chybové zprávy a přesun kurzoru na místo
s&nbsp;chybným znakem. Při vzniku chyby se příkaz neodešle, pouze se čeká na
jeho opravu.</i></p>

*** image ***
<p><i>Obrázek 6: Až po zápisu korektního příkazu je provedeno jeho
zpracování.</i></p>

<p>Ukažme si jednoduchý validátor, který testuje, jestli uživatel zapsal příkaz
složený z&nbsp;písmen abecedy. Ve výjimce je předána jak chybová zpráva, tak i
index prvního špatného znaku:</p>

<pre>
class <strong>CommandValidator</strong>(Validator):
&nbsp;
    def <strong>validate</strong>(self, document):
        user_input = document.text
&nbsp;
        if user_input and not user_input.isalpha():
            index = 0
&nbsp;
            for index, char in enumerate(user_input):
                if not char.isalpha():
                    break
&nbsp;
            msg = "Wrong character '{c}' on index {i}".format(c=char, i=index)
            raise ValidationError(message=msg, cursor_position=index)
</pre>

<p>Validátor se povolí následovně:</p>

<pre>
s = PromptSession()
&nbsp;
cmd = <strong>s.prompt("Command: ", validator=CommandValidator(), validate_while_typing=False)</strong>
</pre>

<p>Následuje výpis <a
href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt12_validator_on_enter.py">úplného
zdrojového kódu</a> tohoto příkladu:</p>

<pre>
from prompt_toolkit.validation import Validator, ValidationError
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
class <strong>CommandValidator</strong>(Validator):
&nbsp;
    def <strong>validate</strong>(self, document):
        user_input = document.text
&nbsp;
        if user_input and not user_input.isalpha():
            index = 0
&nbsp;
            for index, char in enumerate(user_input):
                if not char.isalpha():
                    break
&nbsp;
            msg = "Wrong character '{c}' on index {i}".format(c=char, i=index)
            raise ValidationError(message=msg, cursor_position=index)
&nbsp;
&nbsp;
<strong>s = PromptSession()</strong>
&nbsp;
while True:
    try:
        cmd = <strong>s.prompt("Command: ", validator=CommandValidator(), validate_while_typing=False)</strong>
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Validace již v&nbsp;průběhu zadávání vstupních údajů</h2>

<p>Druhá metoda validace spočívá v&nbsp;tom, že se text zadávaný uživatelem
kontroluje průběžně, tj.&nbsp;po jakékoli editační operaci, která do textu
přidá znaky, smaže znaky nebo je prohodí (<strong>Ctrl+T</strong>) se zavolá
validátor. Průběžná kontrola může být uživatelsky přívětivější (aplikace je
plně kooperativní), ovšem pokud je validátor implementován komplikovanějším
algoritmem, je náročnější na zdroje (čas CPU):</p>

<pre>
s = PromptSession()
&nbsp;
cmd = <strong>s.prompt("Command: ", validator=CommandValidator(), validate_while_typing=True)</strong>
</pre>

<p>Při &bdquo;realtime&ldquo; validaci se zobrazuje chybové hlášení, ovšem
neprovádí se posun kurzoru:</p>

*** image ***
<p><i>Obrázek 7: &bdquo;Realtime&ldquo; validace textu zapisovaného
uživatelem.</i></p>

<p>Opět se podívejme na úplný <a
href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt13_validator_while_typing.py">zdrojový
kód</a> tohoto příkladu:</p>

<pre>
from prompt_toolkit.validation import Validator, ValidationError
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
class <strong>CommandValidator</strong>(Validator):
&nbsp;
    def <strong>validate</strong>(self, document):
        user_input = document.text
&nbsp;
        if user_input and not user_input.isalpha():
            index = 0
&nbsp;
            for index, char in enumerate(user_input):
                if not char.isalpha():
                    break
&nbsp;
            msg = "Wrong character '{c}' on index {i}".format(c=char, i=index)
            raise ValidationError(message=msg, cursor_position=index)
&nbsp;
&nbsp;
<strong>s = PromptSession()</strong>
&nbsp;
while True:
    try:
        cmd = <strong>s.prompt("Command: ", validator=CommandValidator(), validate_while_typing=True)</strong>
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Povolení použití externího textového editoru po použití zkratky Ctrl+X Ctrl+E nebo v</h2>

<p>I přesto, že <strong>prompt_toolkit</strong> dokáže poměrně uspokojivě
emulovat chování textových editorů Vi/Vim či Emacs, nejedná se o plnohodnotnou
náhradu těchto aplikací (zvláště ve chvíli, kdy má uživatel svůj textový editor
nastavený podle vlastních požadavků). Navíc někteří uživatelé mohou preferovat
jiný textový editor, ať již běžící v&nbsp;terminálu či s&nbsp;plnohodnotným
GUI. Podobně, jako je tomu na příkazové řádce, lze i při použití knihovny
<strong>prompt_toolkit</strong> použít klávesovou zkratku <strong>Ctrl+X
Ctrl+E</strong> (režim Emacs) nebo <strong>v</strong> (režim Vi) pro spuštění
externího textového editoru, kterému se předá dočasný soubor obsahující text
již zadaný na příkazové řádce. Po ukončení editoru je text předán na příkazovou
řádku, jakoby ho tam uživatel přímo zapsal. Pro docílení této funkcionality je
pouze nutné použít nepovinný parametr
<strong>enable_open_in_editor</strong>:</p>

<pre>
s = PromptSession()
&nbsp;
cmd = <strong>s.prompt("Command: ", enable_open_in_editor=True)</strong>
</pre>

<p>Chování aplikace bude vypadat následovně:</p>

*** image ***
<p><i>Obrázek 8: Editace textu přímo v&nbsp;aplikaci.</i></p>

*** image ***
<p><i>Obrázek 9: Vyvolání externího editoru, v&nbsp;němž se automaticky zobrazí
již dříve zapsaný text. Dočasný soubor s&nbsp;textem se po ukončení textového
editoru automaticky smaže.</i></p>

<p>Editor, který se má spustit, se specifikuje v&nbsp;proměnné prostředí
<strong>EDITOR</strong>, například:</p>

<pre>
export EDITOR=vim
</pre>

<p><div class="rs-tip-major">Poznámka: pokud nastavíte editor s&nbsp;GUI, je
nutné ověřit, že vše bude funkční, tj.&nbsp;zda aplikace pozná, kdy se editor
ukončil. Například pro Gvim (Vim s&nbsp;GUI) je nutné použít EDITOR="gvim -f"
(spuštění na popředí).</div></p>

<p>Opět se podívejme, jak vypadá úplná implementace celého skriptu. Od
předchozích příkladů se bude odlišovat pouze v&nbsp;povolení použití externího
textového editoru:</p>

<pre>
from prompt_toolkit.validation import Validator, ValidationError
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
class <strong>CommandValidator</strong>(Validator):
&nbsp;
    def <strong>validate</strong>(self, document):
        user_input = document.text
&nbsp;
        if user_input and not user_input.isalpha():
            index = 0
&nbsp;
            for index, char in enumerate(user_input):
                if not char.isalpha():
                    break
&nbsp;
            msg = "Wrong character '{c}' on index {i}".format(c=char, i=index)
            raise ValidationError(message=msg, cursor_position=index)
&nbsp;
&nbsp;
<strong>s = PromptSession()</strong>
&nbsp;
while True:
    try:
        cmd = <strong>s.prompt("Command: ", validator=CommandValidator(),</strong>
                       <strong>validate_while_typing=True,</strong>
                       <strong>enable_open_in_editor=True)</strong>
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spodní nástrojový pruh a zpráva zapsaná na pravém okraji výzvy</h2>

<p></p>

<pre>
s = PromptSession()
&nbsp;
cmd = s.prompt("Command: ", validator=CommandValidator(),
               validate_while_typing=True,
               enable_open_in_editor=True,
               bottom_toolbar="Available commands: quit, exit, help, eval",
               rprompt="Don't panic!")
</pre>

<p>Podívejme se nyní na to, jak se vlastně oba dva nové prvky TUI zobrazí:</p>

*** image ***
<p><i>Obrázek 10: Nástrojový pruh v&nbsp;dolní části terminálu a zpráva vypsaná
na pravém okraji výzvy (vstupního řádku).</i></p>

*** image ***
<p><i>Obrázek 11: Současné zobrazení výzvy, editovaného textu, nástrojového
pruhu, zprávy na pravém okraji výzvy a chybového hlášení při zápisu
nekorektního znaku.</i></p>

<p>Úplný kód skriptu, v&nbsp;němž jsou použity oba dva nové prvky textového
uživatelského rozhraní, vypadá následovně:</p>

<pre>
from prompt_toolkit.validation import Validator, ValidationError
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
class <strong>CommandValidator</strong>(Validator):
&nbsp;
    def <strong>validate</strong>(self, document):
        user_input = document.text
&nbsp;
        if user_input and not user_input.isalpha():
            index = 0
&nbsp;
            for index, char in enumerate(user_input):
                if not char.isalpha():
                    break
&nbsp;
            msg = "Wrong character '{c}' on index {i}".format(c=char, i=index)
            raise ValidationError(message=msg, cursor_position=index)
&nbsp;
&nbsp;
<strong>s = PromptSession()</strong>
&nbsp;
while True:
    try:
        cmd = <strong>s.prompt("Command: ", validator=CommandValidator(),</strong>
                       <strong>validate_while_typing=True,</strong>
                       <strong>enable_open_in_editor=True,</strong>
                       <strong>bottom_toolbar="Available commands: quit, exit, help, eval",</strong>
                       <strong>rprompt="Don't panic!")</strong>
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přístup k&nbsp;editovanému textu (objekty Buffer a Document)</h2>

<p>V&nbsp;některých situacích, například při implementaci dále popsaných
callback funkcí volaných během editace příkazového řádku, je nutné získat text,
který již byl uživatelem zapsán. Předpokládejme, že máme k&nbsp;dispozici
instanci třídy <strong>PromptSession</strong> a nacházíme se v&nbsp;režimu
editace:</p>

<pre>
s = PromptSession()
cmd = s.prompt("Command: ")
</pre>

<p>V&nbsp;jakékoli callback funkci máme přístup ke globální proměnné
<strong>s</strong> a můžeme využít dále popsanou uživatelskou funkci
<strong>get_user_input</strong> pro získání již zapsaného textu. Tato funkce
pracuje následovně: nejdříve z&nbsp;instance třídy
<strong>PromptSession</strong> získá výchozí buffer (to je instance třídy
<strong>Buffer</strong>) a z&nbsp;tohoto objektu pak přečte atribut
<strong>document</strong>, což je pro změnu instance třídy
<strong>Document</strong>. Instance této třídy obsahují atribut
<strong>text</strong>, což je kýžený řetězec (měl by vždy existovat, i když
může obsahovat prázdný řetězec):</p>

<pre>
def <strong>get_user_input</strong>(prompt_session):
    <i># nejprve ziskame objekt typu Buffer</i>
    buffer = prompt_session.default_buffer
&nbsp;
    <i># z bufferu ziskame objekt typu Document</i>
    document = buffer.document
&nbsp;
    <i># ktery obsahuje atribut 'text'</i>
    return document.text
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Callback funkce volané během editace</h2>

<pre>
def <strong>right_prompt_callback</strong>():
    user_input = get_user_input(s)
    return "Typed {c} characters".format(c=len(user_input))
</pre>

<pre>
def <strong>bottom_toolbar_callback</strong>():
    user_input = get_user_input(s)
    if user_input in {"quit", "exit", "eval", "help"}:
        return "Valid command, press Enter"
    else:
        return "???"
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Demonstrační příklad: spodní nástrojový pruh a zpráva na pravém okraji výzvy reagující na uživatelský vstup</h2>

*** image ***
<p><i>Obrázek 12: </i></p>

*** image ***
<p><i>Obrázek 13: </i></p>

*** image ***
<p><i>Obrázek 14: </i></p>

<pre>
from prompt_toolkit.validation import Validator, ValidationError
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
class <strong>CommandValidator</strong>(Validator):
&nbsp;
    def <strong>validate</strong>(self, document):
        user_input = document.text
&nbsp;
        if user_input and not user_input.isalpha():
            index = 0
&nbsp;
            for index, char in enumerate(user_input):
                if not char.isalpha():
                    break
&nbsp;
            msg = "Wrong character '{c}' on index {i}".format(c=char, i=index)
            raise ValidationError(message=msg, cursor_position=index)
&nbsp;
&nbsp;
def <strong>get_user_input</strong>(prompt_session):
    # nejprve ziskame objekt typu Buffer
    buffer = prompt_session.default_buffer
    # z bufferu ziskame objekt typu Document
    document = buffer.document
    # ktery obsahuje atribut 'text'
    return document.text
&nbsp;
&nbsp;
def <strong>right_prompt_callback</strong>():
    user_input = get_user_input(s)
    return "Typed {c} characters".format(c=len(user_input))
&nbsp;
&nbsp;
def <strong>bottom_toolbar_callback</strong>():
    user_input = get_user_input(s)
    if user_input in {"quit", "exit", "eval", "help"}:
        return "Valid command, press Enter"
    else:
        return "???"
&nbsp;
&nbsp;
s = PromptSession()
&nbsp;
while True:
    try:
        cmd = s.prompt("Command: ", validator=CommandValidator(),
                       validate_while_typing=True,
                       enable_open_in_editor=True,
                       bottom_toolbar=bottom_toolbar_callback,
                       rprompt=right_prompt_callback)
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Změna stylu zobrazení všech relevantních prvků TUI</h2>

<pre>
from prompt_toolkit.validation import Validator, ValidationError
from prompt_toolkit.styles import Style
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
class <strong>CommandValidator</strong>(Validator):
&nbsp;
    def <strong>validate</strong>(self, document):
        user_input = document.text
&nbsp;
        if user_input and not user_input.isalpha():
            index = 0
&nbsp;
            for index, char in enumerate(user_input):
                if not char.isalpha():
                    break
&nbsp;
            msg = "Wrong character '{c}' on index {i}".format(c=char, i=index)
            raise ValidationError(message=msg, cursor_position=index)
&nbsp;
&nbsp;
def <strong>get_user_input</strong>(prompt_session):
    # nejprve ziskame objekt typu Buffer
    buffer = prompt_session.default_buffer
    # z bufferu ziskame objekt typu Document
    document = buffer.document
    # ktery obsahuje atribut 'text'
    return document.text
&nbsp;
&nbsp;
def <strong>right_prompt_callback</strong>():
    user_input = get_user_input(s)
    return "Typed {c} characters".format(c=len(user_input))
&nbsp;
&nbsp;
def <strong>bottom_toolbar_callback</strong>():
    user_input = get_user_input(s)
    if user_input in {"quit", "exit", "eval", "help"}:
        return "Valid command, press Enter"
    else:
        return "???"
&nbsp;
&nbsp;
new_tui_style = Style.from_dict({
    'rprompt': 'bg:#ff0066 #ffffff',
    'bottom-toolbar': 'bg:#ffffff #333333 reverse',
    'prompt': 'bg:#ansiyellow #000000',
    })
&nbsp;
&nbsp;
s = PromptSession()
&nbsp;
while True:
    try:
        cmd = s.prompt("Command: ", validator=CommandValidator(),
                       validate_while_typing=True,
                       enable_open_in_editor=True,
                       bottom_toolbar=bottom_toolbar_callback,
                       rprompt=right_prompt_callback,
                       style=new_tui_style)
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zvýraznění syntaxe textu zapisovaného uživatelem na vstup</h2>

<pre>
from pygments.lexers import PythonLexer
&nbsp;
from prompt_toolkit.styles import Style
from prompt_toolkit.lexers import PygmentsLexer
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
new_tui_style = Style.from_dict({
    'rprompt': 'bg:#ff0066 #ffffff',
    'bottom-toolbar': 'bg:#ffffff #333333 reverse',
    'prompt': 'bg:#ansiyellow #000000',
    })
&nbsp;
&nbsp;
s = PromptSession()
&nbsp;
while True:
    try:
        cmd = s.prompt("Command: ",
                       validate_while_typing=True,
                       enable_open_in_editor=True,
                       bottom_toolbar="Available commands: quit, exit, help, eval",
                       rprompt="Don't panic!",
                       style=new_tui_style,
                       lexer=PygmentsLexer(PythonLexer))
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>

<pre>
from pygments.lexers.jvm import ClojureLexer
&nbsp;
from prompt_toolkit.styles import Style
from prompt_toolkit.lexers import PygmentsLexer
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
new_tui_style = Style.from_dict({
    'rprompt': 'bg:#ff0066 #ffffff',
    'bottom-toolbar': 'bg:#ffffff #333333 reverse',
    'prompt': 'bg:#ansiyellow #000000',
    })
&nbsp;
&nbsp;
s = PromptSession()
&nbsp;
while True:
    try:
        cmd = s.prompt("Command: ",
                       validate_while_typing=True,
                       enable_open_in_editor=True,
                       bottom_toolbar="Available commands: quit, exit, help, eval",
                       rprompt="Don't panic!",
                       style=new_tui_style,
                       lexer=PygmentsLexer(ClojureLexer))
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vytvoření vlastního lexeru s&nbsp;klíčovými slovy</h2>

<pre>
class <strong>CommandLexer</strong>(RegexLexer):
    name = 'command'
    aliases = ['command']
    filenames = ['*.command']
&nbsp;
    tokens = {
        'root': [
            (r'quit', Keyword),
            (r'exit', Keyword),
            (r'help', Keyword),
            (r'eval', Keyword),
            (r'.+', Generic.Error),
        ]
    }
</pre>

*** image ***
<p><i>Obrázek </i></p>

*** image ***
<p><i>Obrázek </i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Demonstrační příklad používající programátorem definovaný lexer</h2>

<p>Celá implementace příkladu s&nbsp;vlastním (značně primitivním) lexerem může
vypadat následovně:</p>

<pre>
from pygments.lexer import RegexLexer
from pygments.token import *
&nbsp;
from prompt_toolkit.styles import Style
from prompt_toolkit.lexers import PygmentsLexer
from prompt_toolkit import PromptSession
&nbsp;
&nbsp;
class <strong>CommandLexer</strong>(RegexLexer):
    name = 'command'
    aliases = ['command']
    filenames = ['*.command']
&nbsp;
    tokens = {
        'root': [
            (r'quit', Keyword),
            (r'exit', Keyword),
            (r'help', Keyword),
            (r'eval', Keyword),
            (r'.+', Generic.Error),
        ]
    }
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
new_tui_style = Style.from_dict({
    'rprompt': 'bg:#ff0066 #ffffff',
    'bottom-toolbar': 'bg:#ffffff #333333 reverse',
    'prompt': 'bg:#ansiyellow #000000',
    })
&nbsp;
&nbsp;
<strong>s = PromptSession()</strong>
&nbsp;
while True:
    try:
        cmd = <strong>s.prompt("Command: ",</strong>
                       <strong>validate_while_typing=True,</strong>
                       <strong>enable_open_in_editor=True,</strong>
                       <strong>bottom_toolbar="Available commands: quit, exit, help, eval",</strong>
                       <strong>rprompt="Don't panic!",</strong>
                       <strong>style=new_tui_style,</strong>
                       <strong>lexer=PygmentsLexer(CommandLexer))</strong>
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Použití myši na vstupním textovém řádku</h2>

<p>Knihovna <strong>prompt_toolkit</strong> do jisté míry podporuje i použití
myši, která nemusí sloužit pouze k&nbsp;operacím typu <i>select</i> a
<i>paste</i>, ale lze ji využít i pro další operace, například:</p>

<ul>
<li>Posun textového kurzoru na vybrané místo v&nbsp;rámci příkazového řádku</li>
<li>Skrolování v&nbsp;dlouhém řádku</li>
<li>Výběr položek z&nbsp;menu obsahujícím nabídku příkazů (po stisku Tab)</li>
</ul>

<p>Použití myši v&nbsp;aplikaci je nutné povolit nepovinným parametrem
<strong>mouse_support</strong>:</p>

<pre>
<strong>s = PromptSession(completer=c)</strong>
cmd = <strong>s.prompt("Command: ", mouse_support=True)</strong>
</pre>

<p>Naposledy se dnes podívejme na demonstrační příklad, v&nbsp;němž je myš
povolena. Pokud na příkazový řádek zadáte například pouze znak &bdquo;e&ldquo;,
bude možné ze zobrazené nabídky vybrat příkaz &bdquo;eval&ldquo; nebo
&bdquo;exit&ldquo;. Dále bude možné měnit pozici textového kurzoru myší
atd.:</p>

<pre>
from prompt_toolkit import PromptSession
from prompt_toolkit.completion import WordCompleter
&nbsp;
&nbsp;
def <strong>show_help</strong>():
    print("""Help
--------
quit - quit this application
exit - exit from this application
eval - evaluate
""")
&nbsp;
&nbsp;
c = WordCompleter(["quit", "exit", "help", "eval"], ignore_case=True)
<strong>s = PromptSession(completer=c)</strong>
&nbsp;
while True:
    try:
        cmd = <strong>s.prompt("Command: ", mouse_support=True,</strong>
                       <strong>enable_open_in_editor=True,</strong>
                       <strong>bottom_toolbar="Available commands: quit, exit, help, eval",</strong>
                       <strong>rprompt="Don't panic!")</strong>
        if cmd in {"q", "quit", "Quit", "exit", "Exit"}:
            break
        elif cmd in {"help", "Help", "?"}:
            show_help()
        elif cmd == "eval":
            print("42")
    except KeyboardInterrupt:
        continue
    except EOFError:
        break
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">16. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly uloženy do Git repositáře
dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již poměrně rozsáhlý) repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>1</td><td>prompt10_multiline_edit.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt10_multiline_edit.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt10_multiline_edit.py</a></td></tr>
<tr><td>2</td><td>prompt11_ctrl_c_ctrl_d.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt11_ctrl_c_ctrl_d.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt11_ctrl_c_ctrl_d.py</a></td></tr>
<tr><td>3</td><td>prompt12_validator_on_enter.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt12_validator_on_enter.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt12_validator_on_enter.py</a></td></tr>
<tr><td>4</td><td>prompt13_validator_while_typing.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt13_validator_while_typing.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt13_validator_while_typing.py</a></td></tr>
<tr><td>5</td><td>prompt14_external_editor.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt14_external_editor.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt14_external_editor.py</a></td></tr>
<tr><td>6</td><td>prompt15_bottom_toolbar.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt15_bottom_toolbar.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt15_bottom_toolbar.py</a></td></tr>
<tr><td>7</td><td>prompt16_callback_functions.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt16_callback_functions.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt16_callback_functions.py</a></td></tr>
<tr><td>8</td><td>prompt17_tui_style.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt17_tui_style.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt17_tui_style.py</a></td></tr>
<tr><td>9</td><td>prompt18_input_syntax_highlight.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt18_input_syntax_highlight.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt18_input_syntax_highlight.py</a></td></tr>
<tr><td>10</td><td>prompt19_input_syntax_highlight_B.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt19_input_syntax_highlight_B.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt19_input_syntax_highlight_B.py</a></td></tr>
<tr><td>11</td><td>prompt20_custom_lexer.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt20_custom_lexer.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt20_custom_lexer.py</a></td></tr>
<tr><td>12</td><td>prompt21_mouse_support.py</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt21_mouse_support.py">https://github.com/tisnik/presentations/blob/master/prompt_toolkit/prompt21_mouse_support.py</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>4 Python libraries for building great command-line user interfaces<br />
<a href="https://opensource.com/article/17/5/4-practical-python-libraries">https://opensource.com/article/17/5/4-practical-python-libraries</a>
</li>

<li>prompt_toolkit 2.0.3 na PyPi<br />
<a href="https://pypi.org/project/prompt_toolkit/">https://pypi.org/project/prompt_toolkit/</a>
</li>

<li>python-prompt-toolkit na GitHubu<br />
<a href="https://github.com/jonathanslenders/python-prompt-toolkit">https://github.com/jonathanslenders/python-prompt-toolkit</a>
</li>

<li>The GNU Readline Library<br />
<a href="https://tiswww.case.edu/php/chet/readline/rltop.html">https://tiswww.case.edu/php/chet/readline/rltop.html</a>
</li>

<li>GNU Readline (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Readline">https://en.wikipedia.org/wiki/GNU_Readline</a>
</li>

<li>readline — GNU readline interface (Python 3.x)<br />
<a href="https://docs.python.org/3/library/readline.html">https://docs.python.org/3/library/readline.html</a>
</li>

<li>readline — GNU readline interface (Python 2.x)<br />
<a href="https://docs.python.org/2/library/readline.html">https://docs.python.org/2/library/readline.html</a>
</li>

<li>GNU Readline Library - command line editing<br />
<a href="https://tiswww.cwru.edu/php/chet/readline/readline.html">https://tiswww.cwru.edu/php/chet/readline/readline.html</a>
</li>

<li>gnureadline 6.3.8 na PyPi<br />
<a href="https://pypi.org/project/gnureadline/">https://pypi.org/project/gnureadline/</a>
</li>

<li>Editline Library (libedit)<br />
<a href="http://thrysoee.dk/editline/">http://thrysoee.dk/editline/</a>
</li>

<li>Comparing Python Command-Line Parsing Libraries – Argparse, Docopt, and Click<br />
<a href="https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/">https://realpython.com/comparing-python-command-line-parsing-libraries-argparse-docopt-click/</a>
</li>

<li>libedit or editline<br />
<a href="http://www.cs.utah.edu/~bigler/code/libedit.html">http://www.cs.utah.edu/~bigler/code/libedit.html</a>
</li>

<li>WinEditLine<br />
<a href="http://mingweditline.sourceforge.net/">http://mingweditline.sourceforge.net/</a>
</li>

<li>rlcompleter — Completion function for GNU readline<br />
<a href="https://docs.python.org/3/library/rlcompleter.html">https://docs.python.org/3/library/rlcompleter.html</a>
</li>

<li>rlwrap na GitHubu<br />
<a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a>
</li>

<li>rlwrap(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/rlwrap">https://linux.die.net/man/1/rlwrap</a>
</li>

<li>readline(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/readline">https://linux.die.net/man/3/readline</a>
</li>

<li>history(3) - Linux man page<br />
<a href="https://linux.die.net/man/3/history">https://linux.die.net/man/3/history</a>
</li>

<li>vi(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/vi">https://linux.die.net/man/1/vi</a>
</li>

<li>emacs(1) - Linux man page<br />
<a href="https://linux.die.net/man/1/emacs">https://linux.die.net/man/1/emacs</a>
</li>

<li>Pygments - Python syntax highlighter<br />
<a href="http://pygments.org/">http://pygments.org/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>TUI &ndash; Text User Interface<br />
<a href="https://en.wikipedia.org/wiki/Text-based_user_interface">https://en.wikipedia.org/wiki/Text-based_user_interface</a>
</li>

<li>PuDB: výkonný debugger pro Python s retro uživatelským rozhraním (nástroj s&nbsp;plnohodnotným TUI)<br />
<a href="https://www.root.cz/clanky/pudb-vykonny-debugger-pro-python-s-retro-uzivatelskym-rozhranim/">https://www.root.cz/clanky/pudb-vykonny-debugger-pro-python-s-retro-uzivatelskym-rozhranim/</a>
</li>

<li>Historie vývoje textových editorů: krkolomná cesta k moderním textovým procesorům<br />
<a href="https://www.root.cz/clanky/historie-vyvoje-textovych-editoru-krkolomna-cesta-k-modernim-textovym-procesorum/">https://www.root.cz/clanky/historie-vyvoje-textovych-editoru-krkolomna-cesta-k-modernim-textovym-procesorum/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

