<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování (2.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování (2.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku věnovaném testování zdrojového kódu aplikací naprogramovaných v&nbsp;Pythonu si popíšeme další možnosti nabízené knihovnou <i>unittest.mock</i>. Zejména si ukážeme použití tříd nazvaných <strong>Mock</strong> a <strong>MagicMock</strong>, seznámíme se s&nbsp;možnostmi zjištění, zda jsou mockované funkce volány s&nbsp;očekávanými parametry a samozřejmě nezapomeneme ani na velmi důležitou &bdquo;maličkost&ldquo; &ndash; jakým způsobem je vlastně možné v&nbsp;jedné testovací funkci použít větší množství funkcí či metod mockovaných.</p><!--more-->



<h2>Obsah</h2>

<p><a href="#k01">1. Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování (2.část)</a></p>
<p><a href="#k02">2. Složitější aplikace implementovaná ve větším množství modulů</a></p>
<p><a href="#k03">3. Mockování funkcí volaných nepřímo z&nbsp;jiných modulů</a></p>
<p><a href="#k04">4. Výsledek spuštění testů definovaných v&nbsp;prvním příkladu</a></p>
<p><a href="#k05">5. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k06">6. Mockování funkce přímo volané z&nbsp;testů</a></p>
<p><a href="#k07">7. Výsledek spuštění testů definovaných ve druhém příkladu</a></p>
<p><a href="#k08">8. Úplný zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k09">9. Přímé použití konstruktoru <strong>patch()</strong> v&nbsp;těle testů</a></p>
<p><a href="#k10">10. Úplný zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k11">11. Další možnosti nabízené objekty <strong>Mock</strong> a <strong>MagicMock</strong></a></p>
<p><a href="#k12">12. Úplný zdrojový kód čtvrtého demonstračního příkladu</a></p>
<p><a href="#k13">13. Zjištění kolikrát a s&nbsp;jakými parametry byla mockovaná funkce zavolána</a></p>
<p><a href="#k14">14. Výsledek spuštění testů definovaných v&nbsp;pátém příkladu</a></p>
<p><a href="#k15">15. Úplný zdrojový kód pátého demonstračního příkladu</a></p>
<p><a href="#k16">16. Pořadí předávání mock objektů do funkce s&nbsp;anotací <strong>@patch</strong></a></p>
<p><a href="#k17">17. Úplný zdrojový kód šestého demonstračního příkladu</a></p>
<p><a href="#k18">18. Výsledek spuštění testů definovaných v&nbsp;šestém příkladu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Python pro vývojáře: použití knihovny unittest.mock (nejenom) při testování (2.část)</h2>

<p>Ve druhé části dvoudílného [<a href="https://mojefedora.cz/python-pro-vyvojare-pouziti-knihovny-unittest-mock-nejenom-pri-testovani/">1</a>] článku si popíšeme další možnosti, které jsou nabízené knihovnou <i>unittest.mock</i>. Zejména si ukážeme použití tříd nazvaných <strong>Mock</strong> a <strong>MagicMock</strong>, seznámíme se s&nbsp;možnostmi zjištění (otestování), zda jsou mockované funkce volány s&nbsp;očekávanými parametry a samozřejmě nezapomeneme ani na velmi důležitou &bdquo;maličkost&ldquo; &ndash; jakým způsobem se mockování použije společně s&nbsp;frameworkem <a href="https://docs.pytest.org/en/latest/">pytest</a> (protože právě při skutečném testování se mockování funkcí a metod provádí nejčastěji).</p>

<p>Připomeňme si, že v&nbsp;současnosti existuje relativně velké množství různých knihoven, které mockování v&nbsp;Pythonu umožňují. Z&nbsp;nich jsme si již minule jmenovali projekt <i>Flexmock</i>, který naleznete na adrese <a href="https://pypi.python.org/pypi/flexmock">https://pypi.python.org/pypi/flexmock</a>. V&nbsp;Pythonu 3.x se standardem v&nbsp;této oblasti stala knihovna nazvaná <a href="https://docs.python.org/dev/library/unittest.mock.html">unittest.mock</a>. V&nbsp;případě, že ještě z&nbsp;nějakého důvodu musíte používat Python 2.x, použijte namísto knihovny <i>unittest.mock</i> knihovnu nazvanou jednoduše <a href="https://pypi.python.org/pypi/mock">mock</a>. Tato knihovna nabízí prakticky stejné možnosti jako <i>unittest.mock</i> (je ostatně založena na stejném kódu, který pouze byl pro potřeby Pythonu 2.x upraven), ovšem lze ji použít jak v&nbsp;Pythonu 2.x, tak i v&nbsp;Pythonu 3.x, a to bez toho, abyste museli upravovat zdrojové kódy vašich testů (samozřejmě za předpokladu, že se v&nbsp;nich nevyskytují konstrukce, které nejsou v&nbsp;Pythonu 2.x podporovány).</p>

<p>Poznámka: všechny dále popsané demonstrační příklady byly odzkoušeny společně s&nbsp;Pythonem 3.x (od verze 3.4 včetně), neboť tento interpret je v&nbsp;současných verzích Fedory výchozí. Úprava příkladů pro Python 2.x by však měla být velmi snadná.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Složitější aplikace implementovaná ve větším množství modulů</h2>

<p>Nejdříve navážeme na <a href="https://mojefedora.cz/python-pro-vyvojare-pouziti-knihovny-unittest-mock-nejenom-pri-testovani/">předchozí článek</a> a ukážeme si způsob mockování funkcí u složitěji strukturované aplikace, v&nbsp;níž se nachází celkem tři moduly pojmenované jednoduše <strong>module1.py</strong>, <strong>module2.py</strong> a <strong>module3.py</strong>:</p>

<pre>
module1.py
module2.py
module3.py
</pre>

<p>V&nbsp;prvním modulu <strong>module1</strong> nalezneme funkci nazvanou <strong>function1</strong>, která pouze na standardní výstup vypíše své jméno a zavolá funkci <strong>function2</strong> z&nbsp;modulu <strong>module2</strong>. Tento modul samozřejmě musíme importovat:</p>

<pre>
from module2 import *


def function1():
    print("function1")
    return "function1 " + function2()
</pre>

<p>Druhý modul pojmenovaný <strong>module2</strong> vypadá podobně jako modul první, ovšem nachází se v&nbsp;něm funkce <strong>function2</strong> volající funkci <strong>function3</strong> ze třetího modulu:</p>

<pre>
from module3 import *


def function2():
    print("function2")
    return "function2 " + function3()
</pre>

<p>Konečně se dostáváme ke třetímu modulu, který je nejjednodušší, protože neobsahuje žádný import, ale pouze implementaci funkce nazvané <strong>function3</strong>:</p>

<pre>
def function3():
    print("function3")
    return "function3"
</pre>

<p>Celá aplikace se spouští z&nbsp;modulu <strong>main.py</strong>:</p>

<pre>
from module1 import *


if __name__ == '__main__':
    print(function1())
</pre>

<p>Aplikaci si můžeme vyzkoušet například v&nbsp;debuggeru, a to poměrně jednoduše. Nejprve debugger spustíme:</p>

<pre>
$ <strong>python3 -m pdb main.py </strong>
</pre>

<p>Průběh spuštění a inicializace:</p>

<pre>
&gt; /home/tester/temp/python/mocking-in-python/mock-test7/main.py(1)&lt;module&gt;()
-&gt; from module1 import *
</pre>

<p>Dále nastavíme tzv.&nbsp;<i>breakpoint</i> (bod zastavení), a to na poslední volané funkci <strong>function3</strong>. Tato funkce není v&nbsp;modulu <strong>main.py</strong> a tudíž ji musíme klasifikovat celým jménem:</p>

<pre>
(Pdb) <strong>break module3.function3</strong>
&nbsp;
Breakpoint 1 at /home/tester/temp/python/mocking-in-python/mock-test7/module3.py:1
</pre>

<p>Program v&nbsp;debuggeru spustíme:</p>

<pre>
(Pdb) <strong>continue</strong>
function1
function2
&gt; /home/tester/temp/python/mocking-in-python/mock-test7/module3.py(2)function3()
-&gt; print("function3")
</pre>

<p>A po jeho zastavení se podíváme, jak vypadají zásobníkové rámce:</p>

<pre>
(Pdb) <strong>where</strong>
  /usr/lib/python3.4/bdb.py(431)run()
-&gt; exec(cmd, globals, locals)
  &lt;string&gt;(1)&lt;module&gt;()
  /home/tester/temp/python/mocking-in-python/mock-test7/main.py(5)&lt;module&gt;()
-&gt; print(function1())
  /home/tester/temp/python/mocking-in-python/mock-test7/module1.py(6)function1()
-&gt; return "function1 " + function2()
  /home/tester/temp/python/mocking-in-python/mock-test7/module2.py(6)function2()
-&gt; return "function2 " + function3()
&gt; /home/tester/temp/python/mocking-in-python/mock-test7/module3.py(2)function3()
-&gt; print("function3")
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Mockování funkcí volaných nepřímo z&nbsp;jiných modulů</h2>

<p>Nyní si již můžeme ukázat, jakým způsobem lze mockovat funkce volané z&nbsp;jiných modulů. V&nbsp;našem případě by se jednalo o tato volání:</p>

<table>
<tr><th>Voláno z</th><th>Volaná funkce</th><th>Modul v němž je funkce definována</th></tr>
<tr><td>(testy).py</td><td>function1</td><td>module1.py</td></tr>
<tr><td>module1.py</td><td>function2</td><td>module2.py</td></tr>
<tr><td>module2.py</td><td>function3</td><td>module3.py</td></tr>
</table>

<p>Připomeňme si základní pravidlo &ndash; při deklaraci mocku musíme uvést plné jméno funkce <i>v&nbsp;kontextu jejího volání</i>, tj.&nbsp;z&nbsp;jakého modulu je funkce <i>volána</i> a nikoli v&nbsp;jakém modulu je <i>definována</i>.</p>

<p>Zkusme si tedy napsat testovací skript <strong>test.py</strong>. Jeho začátek je &bdquo;klasický&ldquo;:</p>

<pre>
from unittest.mock import *

from module1 import *
</pre>

<p>První test <strong>test1</strong> bude jednoduše volat funkci <strong>function1</strong> z&nbsp;modulu <strong>module1</strong>:</p>

<pre>
def test1():
    print("*** test1 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Ve druhém testu voláme stejnou funkci, ale současně se pokusíme mockovat funkci <strong>function2</strong> volanou z&nbsp;modulu <strong>module2</strong> (což ale nebude mít žádný efekt):</p>

<pre>
@patch('module2.function2', return_value="*mocked*")
def test2(mocked_function):
    print("*** test2 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Třetí test již provede mockování skutečně volané funkce. Stále se jedná o funkci <strong>function2</strong>, ovšem volanou z&nbsp;modulu <strong>module1</strong>, což je i případ naší &bdquo;reálné&ldquo; aplikace:</p>

<pre>
@patch('module1.function2', return_value="*mocked*")
def test3(mocked_function):
    print("*** test3 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Čtvrtý test posunuje mock o jednu úroveň dále, konkrétně na funkci <strong>function3</strong> volanou z&nbsp;modulu <strong>module2</strong>:</p>

<pre>
@patch('module2.function3', return_value="*mocked*")
def test4(mocked_function):
    print("*** test4 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>A konečně se pokusíme taktéž mockovat funkci <strong>function3</strong>, ovšem tentokrát volanou z&nbsp;modulu <strong>module3</strong>, což ve skutečnosti nikdy nenastane:</p>

<pre>
@patch('module3.function3', return_value="*mocked*")
def test5(mocked_function):
    print("*** test5 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Poslední část skriptu pouze testy spustí bez dalších triků:</p>

<pre>
if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()

    test5()
    print()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výsledek spuštění testů definovaných v&nbsp;prvním příkladu</h2>

<p>Podívejme se nyní na výsledky, které získáme po spuštění testů definovaných v&nbsp;prvním demonstračním příkladu. Vlastní spuštění je jednoduché, protože postačuje spustit skript nazvaný <strong>test</strong> (ten spustí interpret Pythonu a předá mu skript <strong>test.py</strong>):</p>

<pre>
$ <strong>./test</strong>
</pre>

<p>První test <strong>test1</strong> ve skutečnosti žádné mockování nepoužívá, takže se funkce spustí v&nbsp;pořadí <strong>module1.function1</strong> &rarr; <strong>module2.function2</strong> &rarr; <strong>module3.function3</strong>:</p>

<pre>
*** test1 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>

<p>Ve druhém testu jsme se snažili mockovat funkci <strong>module2.function2</strong>, ovšem ve skutečnosti se tímto způsobem žádná funkce nevolá (voláme sice <strong>function2</strong>, ovšem v&nbsp;kontextu prvního modulu), takže výsledek bude stejný, jako v&nbsp;příkladu předchozím:</p>

<pre>
*** test2 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>

<p>Teprve ve třetím testu, v&nbsp;němž byl mock nastaven na &bdquo;module1.function2&ldquo; se namísto funkce <strong>module2.function2</strong> použila nastavená návratová hodnota &bdquo;*mocked*&ldquo;. Třetí funkce se pochopitelně vůbec nezavolá:</p>

<pre>
*** test3 ***
function1
function1 returns: function1 *mocked*
</pre>

<p>Čtvrtý příklad je obdobný, ovšem s&nbsp;tím rozdílem, že se mock použil namísto funkce <strong>module3.function3</strong>, ovšem &ndash; to je důležité &ndash; v&nbsp;kontextu druhého modulu, nikoli modulu třetího:</p>

<pre>
*** test4 ***
function1
function2
function1 returns: function1 function2 *mocked*
</pre>

<p>A konečně v&nbsp;posledním testu byla mockována funkce <strong>function3</strong> v&nbsp;kontextu modulu <strong>module3</strong>, což je sice korektní, ovšem v&nbsp;tomto kontextu žádná funkce zavolána není, takže výsledek je následující:</p>

<pre>
*** test5 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>Pro větší přehlednost je v&nbsp;této kapitole vypsán úplný zdrojový kód dnešního <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test7/">prvního demonstračního příkladu</a> rozděleného do třech modulů tvořících velmi jednoduchou aplikaci a jednoho modulu s&nbsp;testy.</p>



<h3>Soubor <strong>module1.py</strong></h3>

<pre>
from module2 import *


def function1():
    print("function1")
    return "function1 " + function2()
</pre>



<h3>Soubor <strong>module2.py</strong></h3>

<pre>
from module3 import *


def function2():
    print("function2")
    return "function2 " + function3()
</pre>



<h3>Soubor <strong>module3.py</strong></h3>

<pre>
def function3():
    print("function3")
    return "function3"
</pre>



<h3>Soubor <strong>main.py</strong> určený pro spuštění aplikace</h3>

<pre>
from module1 import *


if __name__ == '__main__':
    print(function1())
</pre>



<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
from unittest.mock import *

from module1 import *


def test1():
    print("*** test1 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))


@patch('module2.function2', return_value="*mocked*")
def test2(mocked_function):
    print("*** test2 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))


@patch('module1.function2', return_value="*mocked*")
def test3(mocked_function):
    print("*** test3 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))


@patch('module2.function3', return_value="*mocked*")
def test4(mocked_function):
    print("*** test4 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))


@patch('module3.function3', return_value="*mocked*")
def test5(mocked_function):
    print("*** test5 ***")
    value = function1()
    print("function1 returns: {v}".format(v=value))


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()

    test5()
    print()
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Mockování funkce přímo volané z&nbsp;testů</h2>

<p>V&nbsp;prvním demonstračním příkladu, s&nbsp;nímž jsme se seznámili v&nbsp;předchozích kapitolách, se modul nazvaný <strong>module1</strong> do testovacího modulu importoval tímto způsobem:</p>

<pre>
from module1 import *
</pre>

<p>To je samozřejmě zcela legální způsob, ovšem má jednu nevýhodu &ndash; všechny funkce a třídy z&nbsp;modulu <strong>module1</strong> se stanou součástí jmenného prostoru testů, takže se při tvorbě mocků těchto funkcí/tříd dostaneme do zbytečných problémů. Praktičtější bude import nepatrně změnit a použít následující řádek:</p>

<pre>
import module1
</pre>

<p>Nyní je již možné velmi jednoduše mockovat funkci <strong>function1</strong> volanou v&nbsp;kontextu modulu <strong>module1</strong>, protože přesně takto k&nbsp;této funkci budeme muset přistupovat:</p>

<pre>
@patch('module1.function1', return_value="*mocked*")
def test1(mocked_function):
    print("*** test1 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Podobným způsobem je možné zabezpečit mockování dalších funkcí, tentokrát již volaných nepřímo. Povšimněte si, že všechny další anotace <strong>@patch</strong> jsou shodné s&nbsp;prvním demonstračním příkladem:</p>

<pre>
@patch('module2.function2', return_value="*mocked*")
def test2(mocked_function):
    print("*** test2 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))


@patch('module1.function2', return_value="*mocked*")
def test3(mocked_function):
    print("*** test3 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))


@patch('module2.function3', return_value="*mocked*")
def test4(mocked_function):
    print("*** test4 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))


@patch('module3.function3', return_value="*mocked*")
def test5(mocked_function):
    print("*** test5 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>I spuštění testů je pochopitelně stejné (zde se nic nezměnilo):</p>

<pre>
if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()

    test5()
    print()
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledek spuštění testů definovaných ve druhém příkladu</h2>

<p>Pokud druhý demonstrační příklad spustíme, zjistíme snadno, že je skutečně možné mockovat i funkci pojmenovanou <strong>function1</strong> z&nbsp;modulu <strong>module1</strong> (viz první dva řádky výpisu):</p>

<pre>
*** test1 ***
function1 returns: *mocked*
</pre>

<p>Další zprávy vypisované v&nbsp;testech jsou již shodné s&nbsp;prvním příkladem:</p>

<pre>
*** test2 ***
function1
function2
function3
function1 returns: function1 function2 function3

*** test3 ***
function1
function1 returns: function1 *mocked*

*** test4 ***
function1
function2
function1 returns: function1 function2 *mocked*

*** test5 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Úplný zdrojový kód druhého demonstračního příkladu</h2>

<p>V&nbsp;této kapitole si opět pro přehlednost ukažme výpis zdrojových kódů všech modulů <a href="https://github.com/tisnik/mocking-in-python/tree/master/mock-test8">dnešního druhého demonstračního příkladu</a>.</p>



<h3>Soubor <strong>module1.py</strong></h3>

<pre>
from module2 import *


def function1():
    print("function1")
    return "function1 " + function2()
</pre>



<h3>Soubor <strong>module2.py</strong></h3>

<pre>
from module3 import *


def function2():
    print("function2")
    return "function2 " + function3()
</pre>



<h3>Soubor <strong>module3.py</strong></h3>

<pre>
def function3():
    print("function3")
    return "function3"
</pre>



<h3>Soubor <strong>main.py</strong> určený pro spuštění aplikace</h3>

<pre>
from module1 import *


if __name__ == '__main__':
    print(function1())
</pre>



<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
from unittest.mock import *

import module1


@patch('module1.function1', return_value="*mocked*")
def test1(mocked_function):
    print("*** test1 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))


@patch('module2.function2', return_value="*mocked*")
def test2(mocked_function):
    print("*** test2 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))


@patch('module1.function2', return_value="*mocked*")
def test3(mocked_function):
    print("*** test3 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))


@patch('module2.function3', return_value="*mocked*")
def test4(mocked_function):
    print("*** test4 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))


@patch('module3.function3', return_value="*mocked*")
def test5(mocked_function):
    print("*** test5 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()

    test5()
    print()
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přímé použití konstruktoru <strong>patch()</strong> v&nbsp;těle testů</h2>

<p>V&nbsp;některých případech není možné vystačit s&nbsp;tím, že se před testovací funkci napíše anotace <strong>@patch</strong>. Můžeme se totiž dostat do situace, kdy budeme jednou potřebovat zavolat funkci původní a jindy (v&nbsp;tom samém testu) mock této funkce. I toto chování je samozřejmě podporováno, protože namísto nám již známého zápisu:</p>

<pre>
@patch('module1.function1', return_value="*mocked*")
def test1(mocked_function):
    print("*** test1 ***")
    value = module1.function1()
    print("function1 returns: {v}".format(v=value))
</pre>

<p>Je možné použít přímé volání funkce <strong>patch</strong> importované z&nbsp;modulu <strong>unittest</strong>. Typicky se volání funkce <strong>patch</strong> používá společně s&nbsp;řídicí konstrukcí <strong>with</strong>, která omezuje kontext, v&nbsp;němž je mock platný. Podívejme se na příklad:</p>

<pre>
def test1():
    with patch("module1.function1", return_value="*mocked"):
        print("*** test1 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))
</pre>

<p>Podobným způsobem lze zapsat i další testovací funkce &ndash; viz výpis zdrojového kódu příkladu, který je uveden <a href="#k10">v&nbsp;navazující kapitole</a>. Výsledky testů budou shodné s&nbsp;výsledky předchozího příkladu:</p>

<pre>
*** test1 ***
function1 returns: *mocked

*** test2 ***
function1
function2
function3
function1 returns: function1 function2 function3

*** test3 ***
function1
function1 returns: function1 *mocked

*** test4 ***
function1
function2
function1 returns: function1 function2 *mocked

*** test5 ***
function1
function2
function3
function1 returns: function1 function2 function3
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úplný zdrojový kód třetího demonstračního příkladu</h2>

<p>Opět si pro přehlednost ukažme zdrojové kódy všech modulů <a href="https://github.com/tisnik/mocking-in-python/tree/master/mock-test9">třetího demonstračního příkladu</a>.</p>



<h3>Soubor <strong>module1.py</strong></h3>

<pre>
from module2 import *


def function1():
    print("function1")
    return "function1 " + function2()
</pre>



<h3>Soubor <strong>module2.py</strong></h3>

<pre>
from module3 import *


def function2():
    print("function2")
    return "function2 " + function3()
</pre>



<h3>Soubor <strong>module3.py</strong></h3>

<pre>
def function3():
    print("function3")
    return "function3"
</pre>



<h3>Soubor <strong>main.py</strong> určený pro spuštění aplikace</h3>

<pre>
from module1 import *


if __name__ == '__main__':
    print(function1())
</pre>



<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
from unittest.mock import *

import module1


def test1():
    with patch("module1.function1", return_value="*mocked"):
        print("*** test1 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))


def test2():
    with patch("module2.function2", return_value="*mocked"):
        print("*** test2 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))


def test3():
    with patch("module1.function2", return_value="*mocked"):
        print("*** test3 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))


def test4():
    with patch("module2.function3", return_value="*mocked"):
        print("*** test4 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))


def test5():
    with patch("module3.function3", return_value="*mocked"):
        print("*** test5 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()

    test5()
    print()
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Další možnosti nabízené objekty <strong>Mock</strong> a <strong>MagicMock</strong></h2>

<p>Již z&nbsp;předchozího článku víme, že je velmi snadné zjistit, jestli je mockovaná funkce volána či nikoli. To lze samozřejmě provést i ve chvíli, kdy nepoužijeme anotaci <strong>@patch</strong>, ale namísto toho přímo zavoláme funkci <strong>patch</strong> v&nbsp;bloku <strong>with</strong>. Co ovšem musíme doplnit je jméno proměnné obsahující referenci na mock. Tato reference je vrácena funkcí <strong>patch</strong>, ovšem kvůli jejímu volání v&nbsp;bloku <strong>with</strong> je syntaxe zápisu nepatrně odlišná:</p>

<pre>
with patch("jméno_modulu.jméno_funkce") as jméno_proměnné_s_referencí_na mock:
    ...
    ...
    ...
</pre>

<p>Ve chvíli, kdy máme referenci na mock, můžeme zjistit, zda byl volán přečtením vlastnosti <strong>called</strong>. Příklad použití pro první test:</p>

<pre>
def test1():
    with patch("module1.function1") as mocked_function:
        mocked_function.return_value = "*mocked*"

        print("*** test1 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
</pre>

<p>I zbylé testy budou vypadat podobně &ndash; viz úplný zdrojový kód příkladu vypsaný <a href="#k12">v&nbsp;navazující kapitole</a>. Podívejme se ještě na výsledky těchto testů.</p>

<pre>
*** test1 ***
function1 returns: *mocked*
mocked function called: True
</pre>

<p>U druhého testu k&nbsp;volání mocku nedošlo (což již nepřímo víme z&nbsp;výsledné hodnoty vrácené funkcí <strong>function1</strong>):</p>

<pre>
*** test2 ***
function1
function2
function3
function1 returns: function1 function2 function3
mocked function called: False
</pre>

<p>V&nbsp;dalších dvou testech se mockovaná funkce volala:</p>

<pre>
*** test3 ***
function1
function1 returns: function1 *mocked*
mocked function called: True

*** test4 ***
function1
function2
function1 returns: function1 function2 *mocked*
mocked function called: True
</pre>

<p>V&nbsp;posledním testu však již opět ne:</p>

<pre>
*** test5 ***
function1
function2
function3
function1 returns: function1 function2 function3
mocked function called: False
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úplný zdrojový kód čtvrtého demonstračního příkladu</h2>

<p>Opět si pro přehlednost ukažme zdrojové kódy všech modulů tvořících <a href="https://github.com/tisnik/mocking-in-python/tree/master/mock-testA">čtvrtý demonstrační příklad</a>.</p>



<h3>Soubor <strong>module1.py</strong></h3>

<pre>
from module2 import *


def function1():
    print("function1")
    return "function1 " + function2()
</pre>



<h3>Soubor <strong>module2.py</strong></h3>

<pre>
from module3 import *


def function2():
    print("function2")
    return "function2 " + function3()
</pre>



<h3>Soubor <strong>module3.py</strong></h3>

<pre>
def function3():
    print("function3")
    return "function3"
</pre>



<h3>Soubor <strong>main.py</strong> určený pro spuštění aplikace</h3>

<pre>
from module1 import *


if __name__ == '__main__':
    print(function1())
</pre>



<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
from unittest.mock import *

import module1


def test1():
    with patch("module1.function1") as mocked_function:
        mocked_function.return_value = "*mocked*"

        print("*** test1 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))


def test2():
    with patch("module2.function2") as mocked_function:
        mocked_function.return_value = "*mocked*"

        print("*** test2 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))


def test3():
    with patch("module1.function2") as mocked_function:
        mocked_function.return_value = "*mocked*"

        print("*** test3 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))


def test4():
    with patch("module2.function3") as mocked_function:
        mocked_function.return_value = "*mocked*"

        print("*** test4 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))


def test5():
    with patch("module3.function3") as mocked_function:
        mocked_function.return_value = "*mocked*"

        print("*** test5 ***")
        value = module1.function1()
        print("function1 returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()

    test5()
    print()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zjištění kolikrát a s&nbsp;jakými parametry byla mockovaná funkce zavolána</h2>

<p>Další vlastnost je při testování taktéž nemálo užitečná. Zavoláním <strong>mock.assert_called_with(hodnota1, hodnota2, ...)</strong> je totiž možné zjistit, zda vůbec a s&nbsp;jakými parametry je mock zavolán. To však není zdaleka vše, protože ve vlastnosti <strong>mock_calls</strong> je uložena sekvence všech volání. Z&nbsp;této sekvence zjistíme jak pořadí volání mocku, tak i hodnoty parametrů, které byly při volání použity. V&nbsp;dalším testu budeme mockovat tuto funkci:</p>

<pre>
def add(x, y):
    return add_implementation(x, y)
</pre>

<p>První test může vypadat následovně &ndash; nejdříve mock zavoláme, následně vypíšeme informaci o tom, zda byl skutečně zavolán, posléze otestujeme, jestli se použili parametry 1 a 2 (popř.&nbsp;při druhém volání 100 a 100) a konečně si necháme vypsat seznam všech volání dané funkce:</p>

<pre>
def test1():
    print("*** test1 ***")

    with patch("module1.add_implementation") as mocked_function:
        mocked_function.return_value = 42

        value = module1.add(1, 2)
        print("add returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
        mocked_function.assert_called_with(1, 2)

        value = module1.add(100, 100)
        print("add returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
        mocked_function.assert_called_with(100, 100)

        print("calls: ", mocked_function.mock_calls)
</pre>

<p>Naproti tomu druhý test je schválně napsán takovým způsobem, aby se při kontrole zjistilo, že mock byl sice volán, ale s&nbsp;neočekávanými parametry. Ve skutečnosti totiž voláme funkci s&nbsp;parametry 1 a 2, ale očekáváme volání s&nbsp;parametry 1 a 1:</p>

<pre>
def test2():
    print("*** test2 ***")

    with patch("module1.add_implementation") as mocked_function:
        mocked_function.return_value = 42

        value = module1.add(1, 2)
        print("add returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
        mocked_function.assert_called_with(1, 1)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výsledek spuštění testů definovaných v&nbsp;pátém příkladu</h2>

<p>Nejzajímavější je samozřejmě výsledek spuštění testů. V&nbsp;prvním testu se skutečně mockovaná funkce volala, a to dokonce dvakrát &ndash; poprvé s&nbsp;parametry 1, 2, podruhé s&nbsp;parametry 100, 100:</p>

<pre>
*** test1 ***
add returns: 42
mocked function called: True
add returns: 42
mocked function called: True
calls:  [call(1, 2), call(100, 100)]
</pre>

<p>U druhého testu však dojde k&nbsp;pádu, protože se mock nezavolal ani jednou, což kontrola velmi rychle odhalí:</p>

<pre>
*** test2 ***
add returns: 42
mocked function called: True
Traceback (most recent call last):
  File "test.py", line 41, in <module>
    test2()
  File "test.py", line 34, in test2
    mocked_function.assert_called_with(1, 1)
  File "/usr/lib/python3.4/unittest/mock.py", line 771, in assert_called_with
    raise AssertionError(_error_message()) from cause
AssertionError: Expected call: add_implementation(1, 1)
Actual call: add_implementation(1, 2)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Úplný zdrojový kód pátého demonstračního příkladu</h2>

<p>Opět si pro přehlednost ukažme zdrojové kódy všech modulů tvořících <a href="https://github.com/tisnik/mocking-in-python/tree/master/mock-testB">dnešní předposlední demonstrační příklad</a>.</p>



<h3>Soubor <strong>module1.py</strong></h3>

<pre>
from module2 import *


def add(x, y):
    return add_implementation(x, y)
</pre>



<h3>Soubor <strong>module2.py</strong></h3>

<pre>
def add_implementation(x, y):
    return x + y
</pre>



<h3>Soubor <strong>main.py</strong> určený pro spuštění aplikace</h3>

<pre>
from module1 import *


if __name__ == '__main__':
    print(add(1,0))
    print(add(1,1))
    print(add(1,2))
</pre>



<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
from unittest.mock import *

import module1


def test1():
    print("*** test1 ***")

    with patch("module1.add_implementation") as mocked_function:
        mocked_function.return_value = 42

        value = module1.add(1, 2)
        print("add returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
        mocked_function.assert_called_with(1, 2)

        value = module1.add(100, 100)
        print("add returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
        mocked_function.assert_called_with(100, 100)

        print("calls: ", mocked_function.mock_calls)


def test2():
    print("*** test2 ***")

    with patch("module1.add_implementation") as mocked_function:
        mocked_function.return_value = 42

        value = module1.add(1, 2)
        print("add returns: {v}".format(v=value))
        print("mocked function called: {c}".format(c=mocked_function.called))
        mocked_function.assert_called_with(1, 1)


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Pořadí předávání mock objektů do funkce s&nbsp;anotací <strong>@patch</strong></h2>

<p>Na závěr se ještě musíme zmínit o další vlastnosti anotace <strong>@patch</strong>. Pořadí předání reference na mockované funkce je totiž přesně opačné, než je pořadí zápisu anotací! Jinými slovy &ndash; anotace zapsaná nejblíže definici funkce odpovídá prvnímu parametru, anotace o řádek výše parametru druhému atd.</p>

<p>Test s&nbsp;dvěma mocky tedy bude začínat následovně:</p>

<pre>
@patch("module1.f1", name="f1", return_value=1)
@patch("module1.f2", name="f2", return_value=2)
def test3(mocked_f2, mocked_f1):
    ...
    ...
    ...
</pre>

<p>Test se třemi mocky bude vypadat takto:</p>

<pre>
@patch("module1.f1", name="f1", return_value=1)
@patch("module1.f2", name="f2", return_value=2)
@patch("module1.f3", name="f3", return_value=3)
def test4(mocked_f3, mocked_f2, mocked_f1):
    ...
    ...
    ...
</pre>

<p>Takto deklarované mocky jsou součástí šestého a současně i dnešního posledního demonstračního příkladu, jehož kód je uveden níže.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úplný zdrojový kód šestého demonstračního příkladu</h2>

<p>Před závěrem celého článku si ještě ukažme úplný zdrojový kód dnešního <a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-testC/">šestého a současně i posledního demonstračního příkladu</a>.</p>



<h3>Soubor <strong>module1.py</strong></h3>

<pre>
from module2 import *


def compute(x, y, z):
    return f1(x) + f2(y) + f3(z)
</pre>



<h3>Soubor <strong>module2.py</strong></h3>

<pre>
def f1(x):
    return x

def f2(x):
    return 2 * x

def f3(x):
    return 3 * x
</pre>



<h3>Soubor <strong>main.py</strong> určený pro spuštění aplikace</h3>

<pre>
from module1 import *


if __name__ == '__main__':
    print(compute(1, 2, 3))
</pre>



<h3>Soubor <strong>test.py</strong> s&nbsp;testy</h3>

<pre>
from unittest.mock import *

from module1 import *


def test1():
    print("*** test1 ***")

    value = compute(1, 2, 3)
    print("compute returns: {v}".format(v=value))


def mock_call_info(mocked_function):
    print("mocked function '{n}' called: {c}".format(n=mocked_function._mock_name,
                                                     c=mocked_function.called))
    print("calls: ", mocked_function.mock_calls)
    print()


@patch("module1.f1", name="f1", return_value=0)
def test2(mocked_f1):
    print("*** test1 ***")

    value = compute(10, 20, 30)
    print("compute returns: {v}".format(v=value))

    mock_call_info(mocked_f1)


@patch("module1.f1", name="f1", return_value=0)
@patch("module1.f2", name="f2", return_value=0)
def test3(mocked_f2, mocked_f1):
    print("*** test3 ***")

    value = compute(1, 2, 3)
    print("compute returns: {v}".format(v=value))

    mock_call_info(mocked_f1)
    mock_call_info(mocked_f2)


@patch("module1.f1", name="f1", return_value=0)
@patch("module1.f2", name="f2", return_value=0)
@patch("module1.f3", name="f3", return_value=0)
def test4(mocked_f3, mocked_f2, mocked_f1):
    print("*** test4 ***")

    value = compute(100, 200, 300)
    print("compute returns: {v}".format(v=value))

    mock_call_info(mocked_f1)
    mock_call_info(mocked_f2)
    mock_call_info(mocked_f3)


if __name__ == '__main__':
    test1()
    print()

    test2()
    print()

    test3()
    print()

    test4()
    print()
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Výsledek spuštění testů definovaných v&nbsp;šestém příkladu</h2>

<p>Pokud poslední příklad spustíte příkazem <strong>./test</strong>, měly by se na standardní výstup vypsat následující řádky:</p>

<pre>
*** test1 ***
compute returns: 14

*** test2 ***
compute returns: 130
mocked function 'f1' called: True
calls:  [call(10)]


*** test3 ***
compute returns: 9
mocked function 'f1' called: True
calls:  [call(1)]

mocked function 'f2' called: True
calls:  [call(2)]


*** test4 ***
compute returns: 0
mocked function 'f1' called: True
calls:  [call(100)]

mocked function 'f2' called: True
calls:  [call(200)]

mocked function 'f3' called: True
calls:  [call(300)]
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech šesti dnes popsaných demonstračních příkladů (každý společně s&nbsp;pomocným skriptem určeným pro spuštění testů) byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/mocking-in-python">https://github.com/tisnik/mocking-in-python</a>. V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem prozatím velmi malý, doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>Projekt</th><th>Cesta</th></tr>
<tr><td>mock-test7</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test7">https://github.com/tisnik/mocking-in-python/blob/master/mock-test7</a></td></tr>
<tr><td>mock-test8</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test8">https://github.com/tisnik/mocking-in-python/blob/master/mock-test8</a></td></tr>
<tr><td>mock-test9</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-test9">https://github.com/tisnik/mocking-in-python/blob/master/mock-test9</a></td></tr>
<tr><td>mock-testA</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-testA">https://github.com/tisnik/mocking-in-python/blob/master/mock-testA</a></td></tr>
<tr><td>mock-testB</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-testB">https://github.com/tisnik/mocking-in-python/blob/master/mock-testB</a></td></tr>
<tr><td>mock-testC</td><td><a href="https://github.com/tisnik/mocking-in-python/blob/master/mock-testC">https://github.com/tisnik/mocking-in-python/blob/master/mock-testC</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>unittest.mock — mock object library<br />
<a href="https://docs.python.org/3.5/library/unittest.mock.html">https://docs.python.org/3.5/library/unittest.mock.html</a>
</li>

<li>mock 2.0.0<br />
<a href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a>
</li>

<li>An Introduction to Mocking in Python<br />
<a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a>
</li>

<li>Mock - Mocking and Testing Library<br />
<a href="http://mock.readthedocs.io/en/stable/">http://mock.readthedocs.io/en/stable/</a>
</li>

<li>Python Mocking 101: Fake It Before You Make It<br />
<a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html">https://blog.fugue.co/2016-02-11-python-mocking-101.html</a>
</li>

<li>Nauč se Python! - Testování<br />
<a href="http://naucse.python.cz/lessons/intro/testing/">http://naucse.python.cz/lessons/intro/testing/</a>
</li>

<li>Flexmock (dokumentace)<br />
<a href="https://flexmock.readthedocs.io/en/latest/">https://flexmock.readthedocs.io/en/latest/</a>
</li>

<li>Test Fixture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test_fixture">https://en.wikipedia.org/wiki/Test_fixture</a>
</li>

<li>Behavior-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Behavior-driven_development">https://en.wikipedia.org/wiki/Behavior-driven_development</a>
</li>

<li>Mock object (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Mock_object">https://en.wikipedia.org/wiki/Mock_object</a>
</li>

<li>Unit testing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Unit testing<br />
<a href="https://cs.wikipedia.org/wiki/Unit_testing">https://cs.wikipedia.org/wiki/Unit_testing</a>
</li>

<li>Extrémní programování<br />
<a href="https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD">https://cs.wikipedia.org/wiki/Extr%C3%A9mn%C3%AD_programov%C3%A1n%C3%AD</a>
</li>

<li>Programování řízené testy<br />
<a href="https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy">https://cs.wikipedia.org/wiki/Programov%C3%A1n%C3%AD_%C5%99%C3%ADzen%C3%A9_testy</a>
</li>

<li>Test-driven development (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a>
</li>

<li>Pip (dokumentace)<br />
<a href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable/</a>
</li>

<li>Tox<br />
<a href="https://tox.readthedocs.io/en/latest/">https://tox.readthedocs.io/en/latest/</a>
</li>

<li>Cucumber<br />
<a href="https://cucumber.io/">https://cucumber.io/</a>
</li>

<li>Jasmine<br />
<a href="https://jasmine.github.io/">https://jasmine.github.io/</a>
</li>

<li>IPython Qt Console aneb vylepšený pseudoterminál<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-ipython-a-ipython-notebook/#k06">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-ipython-a-ipython-notebook/#k06</a>
</li>

<li>Vývojová prostředí ve Fedoře (4. díl)<br />
<a href="https://mojefedora.cz/vyvojova-prostredi-ve-fedore-4-dil/">https://mojefedora.cz/vyvojova-prostredi-ve-fedore-4-dil/</a>
</li>

<li>pytest: helps you write better programs<br />
<a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>
</li>

<li>doctest — Test interactive Python examples<br />
<a href="https://docs.python.org/dev/library/doctest.html#module-doctest">https://docs.python.org/dev/library/doctest.html#module-doctest</a>
</li>

<li>Python mock by example
<a href="http://www.alexandrejoseph.com/blog/2015-08-21-python-mock-example.html">http://www.alexandrejoseph.com/blog/2015-08-21-python-mock-example.html</a>
</li>

<li>unittest — Unit testing framework<br />
<a href="https://docs.python.org/dev/library/unittest.html">https://docs.python.org/dev/library/unittest.html</a>
</li>

<li>Python namespaces<br />
<a href="https://bytebaker.com/2008/07/30/python-namespaces/">https://bytebaker.com/2008/07/30/python-namespaces/</a>
</li>

<li>Namespaces and Scopes<br />
<a href="https://www.python-course.eu/namespaces.php">https://www.python-course.eu/namespaces.php</a>
</li>

<li>pdb — The Python Debugger<br />
<a href="https://docs.python.org/3.6/library/pdb.html">https://docs.python.org/3.6/library/pdb.html</a>
</li>

<li>pdb – Interactive Debugger<br />
<a href="https://pymotw.com/2/pdb/">https://pymotw.com/2/pdb/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

