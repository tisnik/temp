<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Krátké zopakování &ndash; průchod uzly CST stromu</a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">5. Speciální metody volané při vstupu či opuštění uzlů určitých typů</a></p>
<p><a href="#k06">6. Záměna jména zvolené proměnné za jiné jméno</a></p>
<p><a href="#k07">7. Průběh transformace, zobrazení výsledného výrazu po transformaci</a></p>
<p><a href="#k08">8. Zobrazení rozdílů mezi původní a transformovaným kódem s&nbsp;využitím knihovny <strong>difflib</strong></a></p>
<p><a href="#k09">9. Vylepšení třídy pro přejmenování symbolů</a></p>
<p><a href="#k10">10. Otestování funkcionality</a></p>
<p><a href="#k11">11. Komplikovanější transformace</a></p>
<p><a href="#k12">12. Záměna zvolených binárních aritmetických operátorů</a></p>
<p><a href="#k13">*** 13. Průběh transformace a tvar výsledného zdrojového kódu</a></p>
<p><a href="#k14">*** 14. Přejmenování jména volané funkce</a></p>
<p><a href="#k15">15. Průběh transformace a tvar výsledného zdrojového kódu</a></p>
<p><a href="#k16">16. Přejmenování jména funkce v&nbsp;její definici</a></p>
<p><a href="#k17">17. Spuštění příkladu a ukázka modifikovaného zdrojového kódu</a></p>
<p><a href="#k18">18. Obsah poslední části článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Krátké zopakování &ndash; průchod uzly CST stromu</h2>

<p>Připomeňme si nejdříve, jakým způsobem se prochází CST stromem
s&nbsp;využitím třídy odvozené od třídy <strong>CSTVisitor</strong>. Tímto
tématem jsme se podrobněji zabývali <a
href="https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/">v&nbsp;úvodním
článku o knihovně LibCST</a>. Ze třídy <strong>CSTVisitor</strong> si odvodíme
vlastní třídu nazvanou například <strong>Visitor</strong>. Tato třída bude
(samozřejmě kromě konstruktoru <strong>__init__</strong>) obsahovat metody
nazvané <strong>on_visit</strong> a <strong>on_leave</strong>. První
z&nbsp;těchto metod je volána při návštěvě uzlu při průchodu CST, druhá metoda
je volána naopak při opuštění tohoto uzlu, tedy ve chvíli, kdy již došlo
k&nbsp;průchodu všemi uzlu podstromu daného uzlu (pochopitelně za předpokladu,
že takový podstrom existuje):</p>

<pre>
class <strong>Visitor</strong>(CSTVisitor):
    def <strong>__init__</strong>(self):
        ...
        ...
        ...
&nbsp;
    def <strong>on_visit</strong>(self, node):
        ...
        ...
        ...
        return True nebo False
&nbsp;
    def <strong>on_leave</strong>(self, node):
        self.nest_level -= 1
</pre>

<p>Význam první metody <strong>on_visit</strong> spočívá v&nbsp;tom, že její
návratovou (pravdivostní) hodnotou lze řídit, zda se má projít i všemi poduzly
či nikoli (někdy nás totiž například nezajímá průchod všemi prvky výrazu či
těla funkce). Metoda <strong>on_leave</strong> zde zdánlivě postrádá smysl, ale
uvidíme, že pokud nahradíme <strong>CSTVisitor</strong> za
<strong>CSTTransformer</strong>, umožní nám modifikaci uzlu, jeho náhradu či
v&nbsp;některých případech dokonce jeho odstranění ze stromu (nahradí se za
<i>sentinel</i>).</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTVisitor
&nbsp;
&nbsp;
class <strong>Visitor</strong>(CSTVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 0
&nbsp;
    def <strong>on_visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node.__class__.__name__)
        self.nest_level += 1
        return True
&nbsp;
    def <strong>on_leave</strong>(self, node):
        self.nest_level -= 1
&nbsp;
&nbsp;
    expression = "1 + 2 * 3 - 4 / 5"
&nbsp;
parsed = parse_module(expression)
visitor = Visitor()
parsed.visit(visitor)
</pre>

<pre>
 Module
   SimpleStatementLine
     Expr
       BinaryOperation
         BinaryOperation
           Integer
           Add
             SimpleWhitespace
             SimpleWhitespace
           BinaryOperation
             Integer
             Multiply
               SimpleWhitespace
               SimpleWhitespace
             Integer
         Subtract
           SimpleWhitespace
           SimpleWhitespace
         BinaryOperation
           Integer
           Divide
             SimpleWhitespace
             SimpleWhitespace
           Integer
     TrailingWhitespace
       SimpleWhitespace
       Newline
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTVisitor
&nbsp;
&nbsp;
class <strong>Visitor</strong>(CSTVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 0
&nbsp;
    def <strong>on_visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node.__class__.__name__)
        self.nest_level += 1
        return True
&nbsp;
    def <strong>on_leave</strong>(self, node):
        self.nest_level -= 1
&nbsp;
    def <strong>on_visit_attribute</strong>(self, node, attribute):
        indent = " " * (self.nest_level + 1) * 2
        print(indent, "-&gt; attribute", attribute)
&nbsp;
    def <strong>on_leave_attribute</strong>(self, node, attribute):
        pass
&nbsp;
&nbsp;
expression = "1 + 2 * 3 - 4 / 5"
&nbsp;
parsed = parse_module(expression)
visitor = Visitor()
parsed.visit(visitor)
</pre>

<pre>
 Module
     -&gt; attribute header
     -&gt; attribute body
   SimpleStatementLine
       -&gt; attribute leading_lines
       -&gt; attribute body
     Expr
         -&gt; attribute value
       BinaryOperation
           -&gt; attribute lpar
           -&gt; attribute left
         BinaryOperation
             -&gt; attribute lpar
             -&gt; attribute left
           Integer
               -&gt; attribute lpar
               -&gt; attribute rpar
             -&gt; attribute operator
           Add
               -&gt; attribute whitespace_before
             SimpleWhitespace
               -&gt; attribute whitespace_after
             SimpleWhitespace
             -&gt; attribute right
           BinaryOperation
               -&gt; attribute lpar
               -&gt; attribute left
             Integer
                 -&gt; attribute lpar
                 -&gt; attribute rpar
               -&gt; attribute operator
             Multiply
                 -&gt; attribute whitespace_before
               SimpleWhitespace
                 -&gt; attribute whitespace_after
               SimpleWhitespace
               -&gt; attribute right
             Integer
                 -&gt; attribute lpar
                 -&gt; attribute rpar
               -&gt; attribute rpar
             -&gt; attribute rpar
           -&gt; attribute operator
         Subtract
             -&gt; attribute whitespace_before
           SimpleWhitespace
             -&gt; attribute whitespace_after
           SimpleWhitespace
           -&gt; attribute right
         BinaryOperation
             -&gt; attribute lpar
             -&gt; attribute left
           Integer
               -&gt; attribute lpar
               -&gt; attribute rpar
             -&gt; attribute operator
           Divide
               -&gt; attribute whitespace_before
             SimpleWhitespace
               -&gt; attribute whitespace_after
             SimpleWhitespace
             -&gt; attribute right
           Integer
               -&gt; attribute lpar
               -&gt; attribute rpar
             -&gt; attribute rpar
           -&gt; attribute rpar
         -&gt; attribute semicolon
       -&gt; attribute trailing_whitespace
     TrailingWhitespace
         -&gt; attribute whitespace
       SimpleWhitespace
         -&gt; attribute comment
         -&gt; attribute newline
       Newline
     -&gt; attribute footer
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. </h2>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTVisitor
&nbsp;
&nbsp;
class <strong>Visitor</strong>(CSTVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 0
&nbsp;
    def <strong>on_visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node.__class__.__name__)
        self.nest_level += 1
        return True
&nbsp;
    def <strong>on_leave</strong>(self, node):
        self.nest_level -= 1
&nbsp;
    def <strong>on_visit_attribute</strong>(self, node, attribute):
        indent = " " * (self.nest_level + 1) * 2
        print(indent, "-&gt; attribute", attribute)
&nbsp;
    def <strong>on_leave_attribute</strong>(self, node, attribute):
        pass
&nbsp;
&nbsp;
expression = "1 + 2 * 3 - 4 / 5"
&nbsp;
parsed = parse_module(expression)
visitor = Visitor()
parsed.visit(visitor)
&nbsp;
print()
print("-" * 60)
print(parsed.code)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_1.py</a>.</div></p>

<pre>
 Module
     -&gt; attribute header
     -&gt; attribute body
   SimpleStatementLine
       -&gt; attribute leading_lines
       -&gt; attribute body
     Expr
         -&gt; attribute value
       BinaryOperation
           -&gt; attribute lpar
           -&gt; attribute left
         BinaryOperation
             -&gt; attribute lpar
             -&gt; attribute left
           Integer
               -&gt; attribute lpar
               -&gt; attribute rpar
             -&gt; attribute operator
           Add
               -&gt; attribute whitespace_before
             SimpleWhitespace
               -&gt; attribute whitespace_after
             SimpleWhitespace
             -&gt; attribute right
           BinaryOperation
               -&gt; attribute lpar
               -&gt; attribute left
             Integer
                 -&gt; attribute lpar
                 -&gt; attribute rpar
               -&gt; attribute operator
             Multiply
                 -&gt; attribute whitespace_before
               SimpleWhitespace
                 -&gt; attribute whitespace_after
               SimpleWhitespace
               -&gt; attribute right
             Integer
                 -&gt; attribute lpar
                 -&gt; attribute rpar
               -&gt; attribute rpar
             -&gt; attribute rpar
           -&gt; attribute operator
         Subtract
             -&gt; attribute whitespace_before
           SimpleWhitespace
             -&gt; attribute whitespace_after
           SimpleWhitespace
           -&gt; attribute right
         BinaryOperation
             -&gt; attribute lpar
             -&gt; attribute left
           Integer
               -&gt; attribute lpar
               -&gt; attribute rpar
             -&gt; attribute operator
           Divide
               -&gt; attribute whitespace_before
             SimpleWhitespace
               -&gt; attribute whitespace_after
             SimpleWhitespace
             -&gt; attribute right
           Integer
               -&gt; attribute lpar
               -&gt; attribute rpar
             -&gt; attribute rpar
           -&gt; attribute rpar
         -&gt; attribute semicolon
       -&gt; attribute trailing_whitespace
     TrailingWhitespace
         -&gt; attribute whitespace
       SimpleWhitespace
         -&gt; attribute comment
         -&gt; attribute newline
       Newline
     -&gt; attribute footer
</pre>

<p></p>

<pre>
1 + 2 * 3 - 4 / 5
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTTransformer
&nbsp;
&nbsp;
class <strong>Transformer</strong>(CSTTransformer):
    def <strong>__init__</strong>(self):
        self.nest_level = 0
&nbsp;
    def <strong>on_visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node.__class__.__name__)
        self.nest_level += 1
        return True
&nbsp;
    def <strong>on_leave</strong>(self, original_node, updated_node):
        self.nest_level -= 1
        return original_node
&nbsp;
    def <strong>on_visit_attribute</strong>(self, node, attribute):
        indent = " " * (self.nest_level + 1) * 2
        print(indent, "-&gt; attribute", attribute)
&nbsp;
    def <strong>on_leave_attribute</strong>(self, node, attribute):
        pass
&nbsp;
&nbsp;
expression = "1 + 2 * 3 - 4 / 5"
&nbsp;
parsed = parse_module(expression)
transformer = Transformer()
transformed = parsed.visit(transformer)
&nbsp;
print()
print("-" * 60)
print(transformed.code)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_2.py</a>.</div></p>

<pre>
 Module
     -&gt; attribute header
     -&gt; attribute body
   SimpleStatementLine
       -&gt; attribute leading_lines
       -&gt; attribute body
     Expr
         -&gt; attribute value
       BinaryOperation
           -&gt; attribute lpar
           -&gt; attribute left
         BinaryOperation
             -&gt; attribute lpar
             -&gt; attribute left
           Integer
               -&gt; attribute lpar
               -&gt; attribute rpar
             -&gt; attribute operator
           Add
               -&gt; attribute whitespace_before
             SimpleWhitespace
               -&gt; attribute whitespace_after
             SimpleWhitespace
             -&gt; attribute right
           BinaryOperation
               -&gt; attribute lpar
               -&gt; attribute left
             Integer
                 -&gt; attribute lpar
                 -&gt; attribute rpar
               -&gt; attribute operator
             Multiply
                 -&gt; attribute whitespace_before
               SimpleWhitespace
                 -&gt; attribute whitespace_after
               SimpleWhitespace
               -&gt; attribute right
             Integer
                 -&gt; attribute lpar
                 -&gt; attribute rpar
               -&gt; attribute rpar
             -&gt; attribute rpar
           -&gt; attribute operator
         Subtract
             -&gt; attribute whitespace_before
           SimpleWhitespace
             -&gt; attribute whitespace_after
           SimpleWhitespace
           -&gt; attribute right
         BinaryOperation
             -&gt; attribute lpar
             -&gt; attribute left
           Integer
               -&gt; attribute lpar
               -&gt; attribute rpar
             -&gt; attribute operator
           Divide
               -&gt; attribute whitespace_before
             SimpleWhitespace
               -&gt; attribute whitespace_after
             SimpleWhitespace
             -&gt; attribute right
           Integer
               -&gt; attribute lpar
               -&gt; attribute rpar
             -&gt; attribute rpar
           -&gt; attribute rpar
         -&gt; attribute semicolon
       -&gt; attribute trailing_whitespace
     TrailingWhitespace
         -&gt; attribute whitespace
       SimpleWhitespace
         -&gt; attribute comment
         -&gt; attribute newline
       Newline
     -&gt; attribute footer

------------------------------------------------------------
1 + 2 * 3 - 4 / 5
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Speciální metody volané při vstupu či opuštění uzlů určitých typů</h2>

<p>V&nbsp;předchozích demonstračních příkladech jsme využívali obecné metody
nazvané <strong>on_visit</strong> a <strong>on_leave</strong>. Tyto metody byly
volány při návštěvě každého uzlu při traverzaci CST popř.&nbsp;naopak při
opouštění uzlu s&nbsp;tím, že právě při opouštění uzlu bylo možné provést jeho
záměnu či modifikaci. Ovšem v&nbsp;těchto metodách bylo (většinou) nutné
zjišťovat typ uzlu, tj.&nbsp;například to, zda se jedná o uzel reprezentující
řetězec, jméno proměnné, jméno volané funkce, typ operátoru atd. A to vede ke
zbytečně dlouhému a repetitivnímu kódu. Z&nbsp;tohoto důvodu nalezneme
v&nbsp;knihovně <i>LibCST</i> ještě jednu možnost &ndash; pro každý typ uzlu
jsou totiž definovány specializované metody volané pouze při vstupu či naopak
výstupu z&nbsp;konkrétního typu uzlu.</p>

<p>Příkladem může být uzel typu <strong>Multiply</strong>, tedy uzel
reprezentující operaci násobení. Při vstupu do tohoto uzlu se volá metoda
<strong>visit_Multiply</strong> (pokud existuje) a při výstupu metoda
<strong>leave_Multiply</strong>:</p>

<pre>
def <strong>visit_Multiply</strong>(self, original_node):
    print("multiply node visit")
    return True
&nbsp;
def <strong>leave_Divide</strong>(self, original_node, updated_node):
    print("multiply node leave")
    return original_node
</pre>

<p>Jména všech metod volaných při vstupu do uzlu jsem extrahoval <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/on_visit_node.py">do
tohoto souboru</a>. A jména všech metod volaných naopak při opouštění uzlu
daného typu <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/on_leave_node.py">naleznete
zde</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Záměna jména zvolené proměnné za jiné jméno</h2>

<p>Nyní již máme k&nbsp;dispozici všechny informace proto, abychom realizovali
průchod uzly CST s&nbsp;tím, že pokud budeme opouštět uzel typu
<strong>Name</strong> a hodnota jména bude nastavena na &bdquo;foo&ldquo;,
nahradíme tento uzel uzlem, v&nbsp;němž bude hodnota jména nastavená na
&bdquo;bar&ldquo;. Jinými slovy provedeme takovou transformaci zdrojového kódu,
při níž dojde k&nbsp;náhradě všech identifikátorů <strong>foo</strong> na
<strong>bar</strong>. Tato záměna se však nebude týkat ani řetězců, ani
komentářů. Samotná realizace popsané transformace vypadá takto:</p>

<pre>
    def <strong>leave_Name</strong>(self, original_node, updated_node):
        if original_node.value == "foo":
            print("Renaming 'foo' to 'bar'")
            return updated_node.with_changes(value="bar")
        return original_node
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak se modifikuje pouze
jeden (nebo více) vybraných atributů uzlu s&nbsp;využitím metody
<strong>with_changes</strong>. Nemusíme tedy pracně kopírovat jednotlivé
atributy atd.</div></p>

<p>Transformovat přitom budeme tento výraz:</p>

<pre>
expression = "1 + foo * 3 - 4 / foo"
</pre>

<p>Celý skript, který tuto transformaci provádí, bude vypadat následovně:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTTransformer
from libcst import SimpleWhitespace, Name
&nbsp;
&nbsp;
class <strong>Transformer</strong>(CSTTransformer):
    def <strong>__init__</strong>(self):
        pass
&nbsp;
    def <strong>on_visit</strong>(self, node):
        print(node.__class__.__name__)
        return True
&nbsp;
    def <strong>leave_Name</strong>(self, original_node, updated_node):
        if original_node.value == "foo":
            print("Renaming 'foo' to 'bar'")
            return updated_node.with_changes(value="bar")
        return original_node
&nbsp;
    def <strong>on_visit_attribute</strong>(self, node, attribute):
        print("-&gt; attribute", attribute)
&nbsp;
    def <strong>on_leave_attribute</strong>(self, node, attribute):
        pass
&nbsp;
&nbsp;
expression = "1 + foo * 3 - 4 / foo"
&nbsp;
parsed = parse_module(expression)
transformer = Transformer()
transformed = parsed.visit(transformer)
&nbsp;
print()
print("-" * 60)
print(parsed.code)
print(transformed.code)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_3.py</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Průběh transformace, zobrazení výsledného výrazu po transformaci</h2>

<p>V&nbsp;případě, že <a href="#k06">výše uvedený</a> skript spustíme, vypíšou
se postupně informace o tom, že se prochází jednotlivými uzly i jejich
atributy:</p>

<pre>
Module
-&gt; attribute header
-&gt; attribute body
SimpleStatementLine
-&gt; attribute leading_lines
-&gt; attribute body
Expr
-&gt; attribute value
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute operator
Add
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
Name
-&gt; attribute lpar
-&gt; attribute rpar
</pre>

<p>Jakmile se opustí uzel typu <strong>Name</strong> s&nbsp;hodnotou jména
&bdquo;foo&ldquo;, provede se záměna tohoto uzlu, o čemž jsme taktéž
informováni:</p>

<pre>
Renaming 'foo' to 'bar'
</pre>

<p>Pokračování v&nbsp;průchodu CST:</p>

<pre>
-&gt; attribute operator
Multiply
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute operator
Subtract
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute operator
Divide
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
Name
-&gt; attribute lpar
-&gt; attribute rpar
</pre>

<p>Další přejmenování:</p>

<pre>
Renaming 'foo' to 'bar'
</pre>

<p>Skript posléze dokončí průchod CST:</p>

<pre>
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute semicolon
-&gt; attribute trailing_whitespace
TrailingWhitespace
-&gt; attribute whitespace
SimpleWhitespace
-&gt; attribute comment
-&gt; attribute newline
Newline
-&gt; attribute footer
</pre>

<p>V&nbsp;samotném závěru se vypíše původní tvar zdrojového kódu a následně
tvar upravený (tedy s&nbsp;přejmenovanými identifikátory):</p>

<pre>
------------------------------------------------------------
1 + foo * 3 - 4 / foo
1 + bar * 3 - 4 / bar
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zobrazení rozdílů mezi původní a transformovaným kódem s&nbsp;využitím knihovny <strong>difflib</strong></h2>

<p>V&nbsp;případě, že se přes CST provádí složitější transformace kódu, nebude
dostačující pouze zobrazit původní kód a pod ním kód modifikovaný. Výhodnější
je v&nbsp;takovém případě použít zobrazení formou <i>diffu</i>
resp.&nbsp;přesněji <i>unifikovaného diffu</i> (viz též <a
href="https://www.root.cz/clanky/nastroje-pro-porovnani-obsahu-dvou-textovych-souboru/">tento
článek o nástroji Diff</a>. V&nbsp;programovacím jazyku Python můžeme pro tento
účel použít standardní knihovnu <a
href="https://docs.python.org/3/library/difflib.html">difflib</a> tak, jak je
to ukázáno v&nbsp;dalším demonstračním příkladu. Ten se od příkladu předchozího
odlišuje pouze posledními příkazy, v&nbsp;nichž zobrazíme původní kód, pod ním
modifikovaný kód a na konci rozdíly mezi oběma kódy formou unifikovaného
diffu:</p>

<pre>
print(parsed.code)
print(transformed.code)
&nbsp;
diff = "".join(unified_diff(parsed.code.splitlines(1), transformed.code.splitlines(1)))
print(diff)
</pre>

<p>Úplný zdrojový kód takto upraveného demonstračního příkladu vypadá
následovně:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTTransformer
from libcst import SimpleWhitespace, Name
from difflib import unified_diff
&nbsp;
&nbsp;
class <strong>Transformer</strong>(CSTTransformer):
    def <strong>__init__</strong>(self):
        pass
&nbsp;
    def <strong>on_visit</strong>(self, node):
        print(node.__class__.__name__)
        return True
&nbsp;
    def <strong>leave_Name</strong>(self, original_node, updated_node):
        if original_node.value == "foo":
            print("Renaming 'foo' to 'bar'")
            return updated_node.with_changes(value="bar")
        return original_node
&nbsp;
    def <strong>on_visit_attribute</strong>(self, node, attribute):
        print("-&gt; attribute", attribute)
&nbsp;
    def <strong>on_leave_attribute</strong>(self, node, attribute):
        pass
&nbsp;
&nbsp;
expression = "1 + foo * 3 - 4 / foo\n"
&nbsp;
parsed = parse_module(expression)
transformer = Transformer()
transformed = parsed.visit(transformer)
&nbsp;
print()
print("-" * 60)
print(parsed.code)
print(transformed.code)
&nbsp;
diff = "".join(unified_diff(parsed.code.splitlines(1), transformed.code.splitlines(1)))
print(diff)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_4.py</a>.</div></p>

<p>Výsledky získané po spuštění skriptu (pro stručnost vypustím zprávy o
návštěvách jednotlivých uzlů):</p>

<pre>
------------------------------------------------------------
1 + foo * 3 - 4 / foo
&nbsp;
1 + bar * 3 - 4 / bar
&nbsp;
--- 
+++ 
@@ -1 +1 @@
-1 + foo * 3 - 4 / foo
+1 + bar * 3 - 4 / bar
</pre>

<p>Řádky &bdquo;---&ldquo; a &bdquo;+++&ldquo; začíná porovnání souborů ve
formě unifikovaného diffu (což je pro jednořádkový &bdquo;program&ldquo; sice
poněkud zbytečné, ale v&nbsp;dalších kapitolách již budeme modifikovat delší
zdrojové kódy).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vylepšení třídy pro přejmenování symbolů</h2>

<p>První varianta třídy určené pro přejmenování symbolů obsahovala jak původní
jméno symbolu, tak i nové jméno symbolu přímo ve svém programovém kódu, což
není příliš obecné:</p>

<pre>
class <strong>SymbolRenamer</strong>(CSTTransformer):
    ...
    ...
    ...
    def <strong>leave_Name</strong>(self, original_node, updated_node):
        if original_node.value == <u>"foo"</u>:
            print("Renaming '<u>foo</u>' to '<u>bar</u>'")
            return updated_node.with_changes(value=<u>"bar"</u>)
        return original_node
    ...
    ...
    ...
</pre>

<p>Výhodnější a obecnější bude, aby bylo nahrazované jméno i jeho náhrada
uloženy v&nbsp;atributech objektu:</p>

<pre>
class <strong>SymbolRenamer</strong>(CSTTransformer):
    ...
    ...
    ...
    def <strong>leave_Name</strong>(self, original_node, updated_node):
        if original_node.value == <u>self.orig_name</u>:
            print(f"Renaming '{<u>self.orig_name</u>}' to '{<u>self.new_name</u>}'")
            return updated_node.with_changes(value=<u>self.new_name</u>)
        return original_node
    ...
    ...
    ...
</pre>

<p>Příslušné atributy se nastaví v&nbsp;konstruktoru:</p>

<pre>
    def <strong>__init__</strong>(self, orig_name, new_name):
        self.orig_name = orig_name
        self.new_name = new_name
</pre>

<p>A samotná transformace (což je vlastně jednoduchý refaktoring) bude vyvolána
takto:</p>

<pre>
transformer = SymbolRenamer("foo", "baz")
transformed = parsed.visit(transformer)
</pre>

<p>Pro úplnost si ukažme, jak bude vypadat zdrojový kód takto upraveného
skriptu:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTTransformer
from libcst import SimpleWhitespace, Name
from difflib import unified_diff
&nbsp;
&nbsp;
class <strong>SymbolRenamer</strong>(CSTTransformer):
    def <strong>__init__</strong>(self, orig_name, new_name):
        self.orig_name = orig_name
        self.new_name = new_name
&nbsp;
    def <strong>on_visit</strong>(self, node):
        print(node.__class__.__name__)
        return True
&nbsp;
    def <strong>leave_Name</strong>(self, original_node, updated_node):
        if original_node.value == self.orig_name:
            print(f"Renaming '{self.orig_name}' to '{self.new_name}'")
            return updated_node.with_changes(value=self.new_name)
        return original_node
&nbsp;
    def <strong>on_visit_attribute</strong>(self, node, attribute):
        print("-&gt; attribute", attribute)
&nbsp;
    def <strong>on_leave_attribute</strong>(self, node, attribute):
        pass
&nbsp;
&nbsp;
expression = "1 + foo * 3 - 4 / bar\n"
&nbsp;
parsed = parse_module(expression)
transformer = SymbolRenamer("foo", "baz")
transformed = parsed.visit(transformer)
&nbsp;
print()
print("-" * 60)
print(parsed.code)
print(transformed.code)
&nbsp;
diff = "".join(unified_diff(parsed.code.splitlines(1), transformed.code.splitlines(1)))
print(diff)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_5.py</a>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Otestování funkcionality</h2>

<p>Demonstrační příklad <a href="#k09">z&nbsp;předchozí kapitoly</a> by se měl
po svém spuštění chovat naprosto stejným způsobem jako původní třída
<strong>SymbolRenamer</strong>. Opět si to můžeme velmi snadno ověřit spuštěním
příslušného skriptu:</p>

<pre>
Module
-&gt; attribute header
-&gt; attribute body
SimpleStatementLine
-&gt; attribute leading_lines
-&gt; attribute body
Expr
-&gt; attribute value
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute operator
Add
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
Name
-&gt; attribute lpar
-&gt; attribute rpar
Renaming 'foo' to 'baz'
-&gt; attribute operator
Multiply
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute operator
Subtract
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute operator
Divide
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
Name
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute semicolon
-&gt; attribute trailing_whitespace
TrailingWhitespace
-&gt; attribute whitespace
SimpleWhitespace
-&gt; attribute comment
-&gt; attribute newline
Newline
-&gt; attribute footer
&nbsp;
------------------------------------------------------------
1 + foo * 3 - 4 / bar
&nbsp;
1 + baz * 3 - 4 / bar
&nbsp;
--- 
+++ 
@@ -1 +1 @@
-1 + foo * 3 - 4 / bar
+1 + baz * 3 - 4 / bar
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Komplikovanější transformace</h2>

<p>Prozatím jsme si ukázali pouze ten nejtriviálnější způsob transformace
programového kódu na úrovni CST. Tato transformace spočívala v&nbsp;modifikaci
nějakého atributu nalezeného uzlu. Ovšem v&nbsp;praxi lze provádět i složitější
transformace, zejména pak:</p>

<ol>

<li>Náhradu jednoho typu uzlu za uzel odlišného typu. Tato operace ovšem ne
vždy dává smysl, ovšem i takové příklady lze najít.</li>

<li>Odstranění uzlu ze stromu (CST), což se provádí náhradou původního uzlu za
takzvaný <i>sentinel</i>. Opět platí, že tato náhrada není vždy možná; záleží
na konkrétním typu uzlu a na jeho umístění v&nbsp;CST.</li>

<li>Namísto uzlu se do CST vloží celý podstrom, což odpovídá složitějšímu
refaktoringu.</li>

</ol>

<p>Dnes si ukážeme ještě způsob náhrady uzlu jednoho typu za uzel odlišného
typu. Složitějšími transformacemi se budeme podrobněji zabývat
v&nbsp;závěrečném článku této série.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Záměna zvolených binárních aritmetických operátorů</h2>

<p>Vyzkoušejme si nyní poněkud umělý příklad. Budeme v&nbsp;něm provádět záměnu
dvou zvolených binárních aritmetických operátorů, konkrétně operátoru součinu a
operátoru podílu. To tedy znamená, že každý součin bude nahrazen za podíl a
naopak každý podíl bude nahrazen součinem. Realizace takové náhrady bude
v&nbsp;tomto případě jednoduchá, protože namísto původního uzlu vrátíme uzel
odlišný (typu <strong>Multiply</strong> či <strong>Divide</strong>):</p>

<pre>
def <strong>leave_Multiply</strong>(self, original_node, updated_node):
    print("Replacing multiply by divide")
    return Divide()
&nbsp;
def <strong>leave_Divide</strong>(self, original_node, updated_node):
    print("Replacing divide by multiply")
    return Multiply()
</pre>

<p><div class="rs-tip-major">Poznámka: mohlo by se zdát, že ihned po náhradě
součinu za podíl se nahradí tento podíl zpět za součin. Ovšem ve skutečnosti
tomu tak není, protože náhradu uzlu provádíme ve chvíli, kdy se tento uzel již
opouští a již se na toto místo CST (v&nbsp;daném běhu transformace)
nevrátíme.</div></p>

<p>Transformaci si otestujeme na výrazu, v&nbsp;němž je použita jak operace
součinu, tak i operace podílu:</p>

<pre>
1 + 2 * 3 - 4 / 5
</pre>

<p>Podívejme se nyní na úplný zdrojový kód skriptu, který tuto transformaci
provádí:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTTransformer
from libcst import SimpleWhitespace, Name
from libcst import Multiply, Divide
from difflib import unified_diff
&nbsp;
&nbsp;
class <strong>BinaryOpReplacer</strong>(CSTTransformer):
    def <strong>__init__</strong>(self):
        pass
&nbsp;
    def <strong>on_visit</strong>(self, node):
        print(node.__class__.__name__)
        return True
&nbsp;
    def <strong>leave_Multiply</strong>(self, original_node, updated_node):
        print("Replacing multiply by divide")
        return Divide()
&nbsp;
    def <strong>leave_Divide</strong>(self, original_node, updated_node):
        print("Replacing divide by multiply")
        return Multiply()
&nbsp;
    def <strong>on_visit_attribute</strong>(self, node, attribute):
        print("-&gt; attribute", attribute)
&nbsp;
    def <strong>on_leave_attribute</strong>(self, node, attribute):
        pass
&nbsp;
&nbsp;
expression = "1 + 2 * 3 - 4 / 5\n"
&nbsp;
parsed = parse_module(expression)
transformer = BinaryOpReplacer()
transformed = parsed.visit(transformer)
&nbsp;
print()
print("-" * 60)
print(parsed.code)
print(transformed.code)
&nbsp;
diff = "".join(unified_diff(parsed.code.splitlines(1), transformed.code.splitlines(1)))
print(diff)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_6.py</a>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Průběh transformace a tvar výsledného zdrojového kódu</h2>

<p></p>

<pre>
Module
-&gt; attribute header
-&gt; attribute body
SimpleStatementLine
-&gt; attribute leading_lines
-&gt; attribute body
Expr
-&gt; attribute value
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute operator
Add
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute operator
Multiply
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
</pre>

<pre>
Replacing multiply by divide
</pre>

<pre>
-&gt; attribute right
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute operator
Subtract
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
-&gt; attribute right
BinaryOperation
-&gt; attribute lpar
-&gt; attribute left
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute operator
Divide
-&gt; attribute whitespace_before
SimpleWhitespace
-&gt; attribute whitespace_after
SimpleWhitespace
</pre>

<pre>
Replacing divide by multiply
</pre>

<pre>
-&gt; attribute right
Integer
-&gt; attribute lpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute rpar
-&gt; attribute semicolon
-&gt; attribute trailing_whitespace
TrailingWhitespace
-&gt; attribute whitespace
SimpleWhitespace
-&gt; attribute comment
-&gt; attribute newline
Newline
-&gt; attribute footer
</pre>

<p></p>

<pre>
1 + 2 * 3 - 4 / 5
&nbsp;
1 + 2 / 3 - 4 * 5
</pre>

<p></p>

<pre>
--- 
+++ 
@@ -1 +1 @@
-1 + 2 * 3 - 4 / 5
+1 + 2 / 3 - 4 * 5
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přejmenování jména volané funkce</h2>

<p></p>

<pre>
class <strong>FunctionRenamer</strong>(CSTTransformer):
    ...
    ...
    ...
    def <strong>leave_Call</strong>(self, original_node, updated_node):
        print("Function call: ", original_node.func.value)
        if original_node.func.value == self.orig_name:
            print(f"Renaming '{self.orig_name}' to '{self.new_name}'")
            return updated_node.with_changes(
                    func=Name(self.new_name))
        return original_node
</pre>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>

from libcst import parse_module, CSTTransformer
from libcst import SimpleWhitespace, Name
from difflib import unified_diff


class <strong>FunctionRenamer</strong>(CSTTransformer):
    def <strong>__init__</strong>(self, orig_name, new_name):
        self.orig_name = orig_name
        self.new_name = new_name

    def <strong>on_visit</strong>(self, node):
        return True

    def <strong>leave_Call</strong>(self, original_node, updated_node):
        print("Function call: ", original_node.func.value)
        if original_node.func.value == self.orig_name:
            print(f"Renaming '{self.orig_name}' to '{self.new_name}'")
            return updated_node.with_changes(
                    func=Name(self.new_name))
        return original_node


code = '''
def <strong>A</strong>(m: int, n: int) -&gt; int:
    """Ackermannova funkce."""
    if m == 0:
        return n + 1
    if n == 0:
        return A(m - 1, 1)
    return A(m - 1, A(m, n - 1))
'''

parsed = parse_module(code)
transformer = FunctionRenamer("A", "ackermann")
transformed = parsed.visit(transformer)

print()
print("-" * 60)
print(parsed.code)
print(transformed.code)

diff = "".join(unified_diff(parsed.code.splitlines(1), transformed.code.splitlines(1)))
print(diff)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_7.py</a>.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Průběh transformace a tvar výsledného zdrojového kódu</h2>

<p>Nyní se podívejme na průběh transformace zdrojového kódu ve chvíli, kdy
spustíme skript <a href="#k14">z&nbsp;předchozí kapitoly</a>. Nejdříve se
vypíšou tři zprávy o tom, že bylo nalezeno volání funkce <strong>A</strong> a
toto volání bylo nahrazeno za volání funkce <strong>ackermann</strong>:</p>

<pre>
Function call:  A
Renaming 'A' to 'ackermann'
Function call:  A
Renaming 'A' to 'ackermann'
Function call:  A
Renaming 'A' to 'ackermann'
</pre>

<p>Po těchto třech modifikacích CST se vypíše původní zdrojový kód (získaný
vygenerováním z&nbsp;původního CST) i modifikovaný zdrojový kód (získaný
vygenerováním z&nbsp;nového CST):</p>

<pre>
def <strong>A</strong>(m: int, n: int) -&gt; int:
    <i>"""Ackermannova funkce."""</i>
    if m == 0:
        return n + 1
    if n == 0:
        return <strong>A</strong>(m - 1, 1)
    return <strong>A</strong>(m - 1, <strong>A</strong>(m, n - 1))
&nbsp;
&nbsp;
def <strong>A</strong>(m: int, n: int) -&gt; int:
    <i>"""Ackermannova funkce."""</i>
    if m == 0:
        return n + 1
    if n == 0:
        return <strong>ackermann</strong>(m - 1, 1)
    return <strong>ackermann</strong>(m - 1, <strong>ackermann</strong>(m, n - 1))
</pre>

<p>Následně se zobrazí rozdíly mezi oběma kódy ve formě unifikovaného diffu.
Tyto rozdíly vypadají takto:</p>

<pre>
--- 
+++ 
@@ -4,5 +4,5 @@
     if m == 0:
         return n + 1
     if n == 0:
-        return A(m - 1, 1)
-    return A(m - 1, A(m, n - 1))
+        return ackermann(m - 1, 1)
+    return ackermann(m - 1, ackermann(m, n - 1))
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Přejmenování jména funkce v&nbsp;její definici</h2>

<p>Předchozí demonstrační příklad transformoval zdrojový kód takovým způsobem,
že nahradil všechny výskyty <i>volání</i> funkce <strong>A</strong> za volání
funkce <strong>ackermann</strong>. Jenže musíme ještě nahradit i jméno této
funkce přímo v&nbsp;její definici. K&nbsp;tomu můžeme využít modifikaci uzlu
typu <strong>FunctionDef</strong>, a to při opouštění tohoto uzlu při
traverzaci stromem. Vytvoříme si tedy metodu nazvanou
<strong>leave_FunctionDef</strong>, která slouží přesně k&nbsp;tomuto účelu.
V&nbsp;této metodě posléze otestujeme, zda atribut <strong>name</strong>
obsahuje jméno <strong>A</strong> a pokud tomu tak je, nahradíme toto jméno za
<strong>ackermann</strong> a vrátíme takto upravený uzel:</p>

<pre>
class <strong>FunctionRenamer</strong>(CSTTransformer):
    ...
    ...
    ...
&nbsp;
    def <strong>leave_FunctionDef</strong>(self, original_node, updated_node):
        print("Function definition: ", original_node.name.value)
        if original_node.name.value == self.orig_name:
            print(f"Renaming '{self.orig_name}' to '{self.new_name}'")
            return updated_node.with_changes(
                    name=Name(self.new_name))
        return original_node
&nbsp;
    ...
    ...
    ...
</pre>

<p>Úplný zdrojový kód takto upraveného příkladu vypadá následovně:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
from libcst import parse_module, CSTTransformer
from libcst import SimpleWhitespace, Name
from difflib import unified_diff
&nbsp;
&nbsp;
class <strong>FunctionRenamer</strong>(CSTTransformer):
    def <strong>__init__</strong>(self, orig_name, new_name):
        self.orig_name = orig_name
        self.new_name = new_name
&nbsp;
    def <strong>on_visit</strong>(self, node):
        return True
&nbsp;
    def <strong>leave_FunctionDef</strong>(self, original_node, updated_node):
        print("Function definition: ", original_node.name.value)
        if original_node.name.value == self.orig_name:
            print(f"Renaming '{self.orig_name}' to '{self.new_name}'")
            return updated_node.with_changes(
                    name=Name(self.new_name))
        return original_node
&nbsp;
    def <strong>leave_Call</strong>(self, original_node, updated_node):
        print("Function call: ", original_node.func.value)
        if original_node.func.value == self.orig_name:
            print(f"Renaming '{self.orig_name}' to '{self.new_name}'")
            return updated_node.with_changes(
                    func=Name(self.new_name))
        return original_node
&nbsp;
&nbsp;
code = '''
def A(m: int, n: int) -&gt; int:
    """Ackermannova funkce."""
    if m == 0:
        return n + 1
    if n == 0:
        return A(m - 1, 1)
    return A(m - 1, A(m, n - 1))
'''
&nbsp;
parsed = parse_module(code)
transformer = FunctionRenamer("A", "ackermann")
transformed = parsed.visit(transformer)
&nbsp;
print()
print("-" * 60)
print(parsed.code)
print(transformed.code)
&nbsp;
diff = "".join(unified_diff(parsed.code.splitlines(1), transformed.code.splitlines(1)))
print(diff)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_8.py</a>.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Spuštění příkladu a ukázka modifikovaného zdrojového kódu</h2>

<p>Pokud transformaci kódu popsanou <a href="#k16">v&nbsp;předchozí
kapitole</a> spustíme, vypíšou se nejdříve zprávy o tom, že se našly a
modifikovaly tři volání funkce <strong>A</strong> a že se tato volání nahradila
za funkci <strong>ackermann</strong>. Dále, na posledním místě, je zobrazena
zpráva o nalezení definice funkce <strong>A</strong> s&nbsp;tím, že i toto
jméno bylo nahrazeno. Proč se ovšem tato zpráva vypíše jako poslední?
V&nbsp;kódu totiž reagujeme na operaci opuštění uzlu, nikoli vstupu do uzlu (a
nejdříve se opustí všechny poduzly a až poté nadřazený uzel):</p>

<pre>
Function call:  A
Renaming 'A' to 'ackermann'
Function call:  A
Renaming 'A' to 'ackermann'
Function call:  A
Renaming 'A' to 'ackermann'
Function definition:  A
Renaming 'A' to 'ackermann'
</pre>

<p>Poté se vypíše originální zdrojový kód získaný zpětnou transformací
původního CST:</p>

<pre>
def <strong>A</strong>(m: int, n: int) -&gt; int:
    <i>"""Ackermannova funkce."""</i>
    if m == 0:
        return n + 1
    if n == 0:
        return <strong>A</strong>(m - 1, 1)
    return <strong>A</strong>(m - 1, <strong>A</strong>(m, n - 1))
</pre>

<p>A následně se vypíše kód získaný zpětnou transformací nového CST. Povšimněte
si, že došlo k&nbsp;náhradě jména funkce ve všech částech programu:</p>

<pre>
def <strong>ackermann</strong>(m: int, n: int) -&gt; int:
    <i>"""Ackermannova funkce."""</i>
    if m == 0:
        return n + 1
    if n == 0:
        return <strong>ackermann</strong>(m - 1, 1)
    return <strong>ackermann</strong>(m - 1, <strong>ackermann</strong>(m, n - 1))
</pre>

<p>A v&nbsp;posledním kroku se zobrazí rozdíly mezi původním kódem a kódem
novým; používá se zde unifikovaný diff:</p>

<pre>
--- 
+++ 
@@ -1,8 +1,8 @@
&nbsp;
-def A(m: int, n: int) -&gt; int:
+def ackermann(m: int, n: int) -&gt; int:
     """Ackermannova funkce."""
     if m == 0:
         return n + 1
     if n == 0:
-        return A(m - 1, 1)
-    return A(m - 1, A(m, n - 1))
+        return ackermann(m - 1, 1)
+    return ackermann(m - 1, ackermann(m, n - 1))
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah poslední části článku</h2>

<p>Ve třetí a současně i závěrečné části článku o knihovně <i>LibCST</i> se
seznámíme s&nbsp;některými složitějšími transformacemi kódu. Transformace,
které jsme prováděli až doposud, totiž nepotřebovaly znát <i>kontext</i>
(náhrady se prováděly pro celý zdrojový kód bez ohledu na předchozí
transformace atd.). Ovšem v&nbsp;praxi si s&nbsp;těmito typy transformací
nevystačíme, takže se příště podíváme na sice složitější, ale o to užitečnější
realizaci sofistikovanějšího refaktoringu.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů
určených pro programovací jazyk Python 3 a knihovnu <i>libcst</i> byly
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>parse_constant_1.py</td><td>parsing kódu obsahujícího celočíselnou konstantu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_1.py</a></td></tr>
<tr><td> 2</td><td>parse_constant_2.py</td><td>parsing kódu obsahujícího celočíselnou konstantu s&nbsp;podtržítkem ve funkci oddělovače řádů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_2.py</a></td></tr>
<tr><td> 3</td><td>parse_constant_3.py</td><td>parsing kódu obsahujícího logickou konstantu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_3.py</a></td></tr>
<tr><td> 4</td><td>parse_constant_4.py</td><td>parsing kódu obsahujícího řetězcový literál</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_4.py</a></td></tr>
<tr><td> 5</td><td>parse_constant_5.py</td><td>parsing kódu obsahujícího komplexní číslo</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_constant_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>parse_expression_1.py</td><td>parsing jednoduchého aritmetického výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_1.py</a></td></tr>
<tr><td> 7</td><td>parse_expression_2.py</td><td>parsing jednoduchého aritmetického výrazu s&nbsp;mezerami mezi operandy a operátorem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_2.py</a></td></tr>
<tr><td> 8</td><td>parse_expression_3.py</td><td>parsing výrazu, před nímž je zapsána mezera</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_3.py</a></td></tr>
<tr><td> 9</td><td>parse_expression_4.py</td><td>parsing složitějšího aritmetického výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_4.py</a></td></tr>
<tr><td>10</td><td>parse_expression_5.py</td><td>výraz obalený závorkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_expression_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>parse_module_1.py</td><td>parsing celého modulu, který obsahuje jediný výraz, první příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_1.py</a></td></tr>
<tr><td>12</td><td>parse_module_2.py</td><td>parsing celého modulu, který obsahuje jediný výraz, druhý příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_2.py</a></td></tr>
<tr><td>13</td><td>parse_module_3.py</td><td>parsing celého modulu, který obsahuje jediný výraz, třetí příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_3.py</a></td></tr>
<tr><td>14</td><td>parse_module_4.py</td><td>parsing celého modulu s&nbsp;definicí funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/parse_module_4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>traverse_code_1.py</td><td>průchod CST stromem, nejjednodušší řešení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_1.py</a></td></tr>
<tr><td>16</td><td>traverse_code_2.py</td><td>průchod CST stromem, vizualizace zanoření uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_2.py</a></td></tr>
<tr><td>17</td><td>traverse_code_3.py</td><td>průchod CST stromem, test na typ uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_3.py</a></td></tr>
<tr><td>18</td><td>traverse_code_4.py</td><td>průchod CST stromem, filtrace uzlů podle jejich typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_4.py</a></td></tr>
<tr><td>19</td><td>traverse_code_5.py</td><td>průchod CST stromem, ještě výraznější filtrace uzlů podle jejich typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_5.py</a></td></tr>
<tr><td>20</td><td>traverse_code_6.py</td><td>průchod CST stromem, výpis atributů jednotlivých uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/traverse_code_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>generate_code_1.py</td><td>použití třídy odvozené od <strong>CSTVisitor</strong> pro průchod stromem, výpis zpětně vygenerovaného zdrojového kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_1.py</a></td></tr>
<tr><td>22</td><td>generate_code_2.py</td><td>použití třídy odvozené od <strong>CSTTransformer</strong> pro průchod stromem a konstrukcí stromu nového</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_2.py</a></td></tr>
<tr><td>23</td><td>generate_code_3.py</td><td>transformace kódu &ndash; modifikace zvoleného jména na jméno odlišné</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_3.py</a></td></tr>
<tr><td>24</td><td>generate_code_4.py</td><td>vylepšený výpis rozdílů mezi původním a novým zdrojovým kódem (<strong>unified_diff</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_4.py</a></td></tr>
<tr><td>25</td><td>generate_code_5.py</td><td>vylepšený zápis transformace stromu se změnou jména symbolu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_5.py</a></td></tr>
<tr><td>26</td><td>generate_code_6.py</td><td>transformace stromu: záměna binárních operátorů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_6.py</a></td></tr>
<tr><td>27</td><td>generate_code_7.py</td><td>transformace stromu: změna jména vybrané volané funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_7.py</a></td></tr>
<tr><td>28</td><td>generate_code_8.py</td><td>transformace stromu: změna jména definované funkce i volané funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cst/generate_code_8.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů jazyka Python (4.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/</a>
</li>

<li>Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu<br />
<a href="https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/">https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/</a>
</li>

<li>LibCST &ndash; dokumentace<br />
<a href="https://libcst.readthedocs.io/en/latest/index.html">https://libcst.readthedocs.io/en/latest/index.html</a>
</li>

<li>libCST na PyPi<br />
<a href="https://pypi.org/project/libcst/">https://pypi.org/project/libcst/</a>
</li>

<li>libCST na GitHubu<br />
<a href="https://github.com/Instagram/LibCST">https://github.com/Instagram/LibCST</a>
</li>

<li>Inside The Python Virtual Machine<br />
<a href="https://leanpub.com/insidethepythonvirtualmachine">https://leanpub.com/insidethepythonvirtualmachine</a>
</li>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>SymbolTable<br />
<a href="https://docs.python.org/3.8/library/symtable.html">https://docs.python.org/3.8/library/symtable.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Pygments - Python syntax highlighter<br />
<a href="http://pygments.org/">http://pygments.org/</a>
</li>

<li>Pygments (dokumentace)<br />
<a href="http://pygments.org/docs/">http://pygments.org/docs/</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Jazyky podporované knihovnou Pygments<br />
<a href="http://pygments.org/languages/">http://pygments.org/languages/</a>
</li>

<li>Pygments FAQ<br />
<a href="http://pygments.org/faq/">http://pygments.org/faq/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>
