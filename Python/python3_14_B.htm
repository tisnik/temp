<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Nové vlastnosti Pythonu 3.14 v praxi: vliv odstranění GILu a využití více interpretrů</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Nové vlastnosti Pythonu 3.14 v praxi: vliv odstranění GILu a využití více interpretrů</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní článek o novinkách představených v Pythonu 3.14 dnes navážeme. Zaměříme se na dvě technologie, které Python 3.14 nabízí: podporu pro interpret bez GILu a knihovnu s API, které umožňuje využít větší množství interpretrů spouštěných v rámci jednoho procesu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: vliv odstranění GILu a využití více interpretrů</a></p>
<p><a href="#k02">2. Překlad Pythonu 3.14 s&nbsp;vypnutým GILem</a></p>
<p><a href="#k03">3. První benchmark: klasický neefektivní algoritmus bublinkového řazení</a></p>
<p><a href="#k04">4. Porovnání rychlosti sekvenční varianty benchmarku pro různé verze Pythonu</a></p>
<p><a href="#k05">5. Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;GILem i bez GILu</a></p>
<p><a href="#k06">6. Složitější výpočty s&nbsp;velkým množstvím numerických operací</a></p>
<p><a href="#k07">7. Výsledky benchmarku pro různé verze Pythonu</a></p>
<p><a href="#k08">8. Paralelní varianta výpočtu: využití proměnného počtu vláken</a></p>
<p><a href="#k09">9. Výsledky benchmarku pro různé verze Pythonu</a></p>
<p><a href="#k10">10. Rozdíly celkové doby výpočtů v&nbsp;Pythonu 3.14: GIL vs noGIL</a></p>
<p><a href="#k11">11. Podpora pro větší množství interpretrů v&nbsp;běžícím procesu</a></p>
<p><a href="#k12">12. Výpis interpretrů, konstrukce nového interpretru</a></p>
<p><a href="#k13">13. Spuštění kódu v&nbsp;novém interpretru</a></p>
<p><a href="#k14">14. Spuštění kódu v&nbsp;novém vláknu</a></p>
<p><a href="#k15">15. Sdílí interpretry svůj stav?</a></p>
<p><a href="#k16">16. Chování programu při spuštění dvou souběžných úloh v&nbsp;různých interpretrech</a></p>
<p><a href="#k17">17. Chování programu v&nbsp;případě, že je v&nbsp;interpretru vyhozena nezachycená výjimka</a></p>
<p><a href="#k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nové vlastnosti Pythonu 3.14 v&nbsp;praxi: vliv odstranění GILu a využití více interpretrů</h2>

<p>Na článek <a
href="https://www.root.cz/clanky/python-3-14-t-retezce-barvicky-lepsi-napoveda-a-odchazejici-gil/">Python
3.14: t-řetězce, barvičky, lepší nápověda a odcházející GIL</a>, který byl
vydán minulý týden, dnes navážeme. Zaměříme se na dvě technologie, které Python
3.14 nabízí. V&nbsp;první řadě se jedná o volitelné odstranění GILu (což sice
není úplně žhavá novinka, ale v&nbsp;rámci Pythonu 3.14 došlo v&nbsp;této
oblasti k&nbsp;různým vylepšením). Ve druhé části článku si popíšeme API, které
umožňuje využít větší množství interpretrů spouštěných v&nbsp;rámci jednoho
procesu. Tyto interpretry jsou od sebe do značné míry izolovány, ale
v&nbsp;případě potřeby mezi sebou mohou v&nbsp;nich spuštěné programy
komunikovat přes fronty zpráv (<i>message queue</i>), což je metoda, která je
v&nbsp;ekosystému jazyka Python používaná i v&nbsp;případě běžného
multithreadingu a multiprocessingu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Překlad Pythonu 3.14 s&nbsp;vypnutým GILem</h2>

<p>Ještě před tím, než si vyzkoušíme benchmarky popsané v&nbsp;rámci dalších
kapitol, je nutné si přeložit Python 3.14 ve verzi s&nbsp;GILem (běžná
instalace) i taktéž bez GILu (budeme tedy mít dva samostatné interpretry).
Průběh překladu 3.14 byl již popsán minule, takže jen velmi krátce:</p>

<p>Ze stránek <a
href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>
stáhnout archiv (zkomprimovaný tarball), ten rozbalit a použít klasickou
kombinaci příkazů (je nutné mít nainstalován překladač céčka, včetně jeho sady
nástrojů, a navíc i nástroj <strong>make</strong>):</p>

<pre>
$ <strong>cd Python-3.14.0</strong>
$ <strong>./configure</strong>
$ <strong>make</strong>
</pre>

<p>Výsledkem bude spustitelný interpret jazyka Python 3.14 s&nbsp;povoleným
GILem.</p>

<p>Pro překlad varianty interpretru se zakázaným GILem je nutné příkaz
<strong>configure</strong> volat s&nbsp;tímto parametrem:</p>

<pre>
$ <strong>./configure --disable-gil</strong>
</pre>

<p>Tento příkaz vygeneruje novou variantu souboru
<strong>Makefile</strong>:</p>

<pre>
...
...
...
configure: creating ./config.status
config.status: creating Makefile.pre
config.status: creating Misc/python.pc
config.status: creating Misc/python-embed.pc
config.status: creating Misc/python-config.sh
config.status: creating Modules/Setup.bootstrap
config.status: creating Modules/Setup.stdlib
config.status: creating Modules/ld_so_aix
config.status: creating pyconfig.h
config.status: pyconfig.h is unchanged
configure: creating Modules/Setup.local
configure: creating Makefile
configure:
</pre>

<p>V&nbsp;nové variantě <strong>Makefile</strong> by se měly nově objevit tyto
dva řádky:</p>

<pre>
# configure script arguments
CONFIG_ARGS=     '--disable-gil'
</pre>

<p>Další překlad již proběhne naprosto standardním způsobem:</p>

<pre>
$ <strong>make</strong>
</pre>

<p>Následováno příkazem:</p>

<pre>
$ <strong>sudo make install</strong>
</pre>

<p>Ověřme si, jakou variantu interpretru jsme vlastně přeložili a
nainstalovali:</p>

<pre>
$ <strong>python3.14</strong>
</pre>

<p>Ve vypsané hlavičce by se měl objevit i nápis <strong>free-threading
build</strong>, který u &bdquo;běžného&ldquo; interpretru chybí:</p>

<pre>
Python 3.14.0 <strong>free-threading build</strong> (main, Oct 18 2025, 10:08:58) [GCC 14.2.1 20240912 (Red Hat 14.2.1-3)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. První benchmark: klasický neefektivní algoritmus bublinkového řazení</h2>

<p>Jako první benchmark pro zjištění výkonnosti interpretru Pythonu 3.14 byl
zvolen algoritmus bublinkového řazení, který intenzivně pracuje s&nbsp;operační
pamětí a v&nbsp;uvedené implementaci operuje s&nbsp;prvky seznamů. Samozřejmě
se jedná o velmi neefektivní algoritmus (což vlastně benchmarky mají být :-).
Čistě sekvenční varianta tohoto benchmarku, která žádným způsobem nevyužívá
více threadů, vypadá následovně:</p>

<pre>
from time import perf_counter
import random
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    t1 = perf_counter()
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(0, i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
    t2 = perf_counter()
&nbsp;
    print(f"Sorted in {t2-t1} seconds:")
&nbsp;
&nbsp;
t1 = perf_counter()
&nbsp;
for i in range(100):
    bubble_sort(5000)
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Total time: {t2-t1} seconds:")
</pre>

<p>Jak je z&nbsp;tohoto zdrojového kódu patrné, voláme v&nbsp;tomto benchmarku
stokrát funkci, která vytvoří pole (realizované seznamem) se <i>size</i> prvky
s&nbsp;náhodnou hodnotou (zde pro jednoduchost náhodné číslo v&nbsp;rozsahu
0..10000). Toto pole je následně seřazeno. Pro úplnost se ještě měří čas
seřazení pole (provedeno stokrát pro různá pole) a taktéž celkový čas všech
výpočtů.</p>

<p>Paralelní či možná lépe řečeno pseudoparalelní varianta benchmarku je
prakticky stejná, ovšem oněch sto volání funkce <strong>bubble_sort</strong>
není provedeno sekvenčně, ale využívá se namísto toho standardní třída nazvaná
<strong>ThreadPoolExecutor</strong>. Hodnotou <strong>max_workers</strong>
můžeme omezit počet úloh spouštěných současně:</p>

<pre>
from concurrent.futures.thread import ThreadPoolExecutor
from time import perf_counter
import random
&nbsp;
&nbsp;
def <strong>bubble_sort</strong>(size):
    a = [random.randrange(0, 10000) for i in range(size)]
&nbsp;
    t1 = perf_counter()
&nbsp;
    for i in range(size - 1, 0, -1):
        for j in range(0, i):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&nbsp;
    t2 = perf_counter()
&nbsp;
    print(f"Sorted in {t2-t1} seconds:")
&nbsp;
&nbsp;
t1 = perf_counter()
&nbsp;
with ThreadPoolExecutor(max_workers=8) as executor:
    for i in range(100):
        executor.submit(bubble_sort, 5000)
&nbsp;
t2 = perf_counter()
&nbsp;
print(f"Total time: {t2-t1} seconds:")
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Porovnání rychlosti sekvenční varianty benchmarku pro různé verze Pythonu</h2>

<p>V&nbsp;následující tabulce jsou zobrazeny výsledky získané pro
&bdquo;sekvenční&ldquo; variantu benchmarku, tedy pro tu variantu, která
nevyužívá spuštění výpočtů ve více vláknech. Benchmarky byly pochopitelně
spuštěny na stejném počítači se stejně nastaveným režimem práce CPU
(performance mode &ndash; to proto, že aby se CPU nezpomaloval, pokud se
zahřeje):</p>

<table>
<tr><th>Verze Pythonu</th><th>Varianta</th><th>Celkový čas</th></tr>
<tr><td>3.12</td><td>GIL</td><td>73s</td></tr>
<tr><td>3.13</td><td>GIL</td><td>74s</td></tr>
<tr><td>3.14</td><td>GIL</td><td>54s</td></tr>
<tr><td>3.15</td><td>noGIL</td><td>66s</td></tr>
</table>

<p>Povšimněte si, že Python 3.14 je skutečně podstatně rychlejší, než předchozí
dvě verze Pythonu (připomeňme, že výchozí konfigurace Pythonu 3.14 stále
používá GIL). noGIL varianta Pythonu 3.14 je sice stále rychlejší, než
předchozí verze Pythonu (s&nbsp;GILem), ovšem pomalejší, než Python 3.14
s&nbsp;GILem. Z&nbsp;pohledu tohoto benchmarku &ndash; sekvenční výpočty
&ndash; se tedy noGIL verze nevyplatí.</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 708px"><a href="https://www.root.cz/obrazek/1234551/"><img src="https://i.iinfo.cz/images/117/python-3-14-b-1-large.png" class="image-1234551" width="708" height="525" data-prev-filename="https://i.iinfo.cz/images/117/python-3-14-b-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-1-prev.webp" data-prev-width="364" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/117/python-3-14-b-1-large.png" data-large-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-1-large.webp" data-large-width="708" data-large-height="525" alt="Obrázek 1: Porovnání rychlosti sekvenční varianty benchmarku v&nbsp;grafické podobě." data-description="Obrázek 1: Porovnání rychlosti sekvenční varianty benchmarku v&nbsp;grafické podobě." title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 708px" /></a><p>Obrázek 1: Porovnání rychlosti sekvenční varianty benchmarku v&nbsp;grafické podobě. Zde jasně vyhrává Python 3.14 s&nbsp;GILem.</p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k05"></a></p>
<h2 id="k05">5. Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;GILem i bez GILu</h2>

<p>Zajímavější bude porovnání paralelní varianty benchmarku, protože zde by se
měla projevit existence resp.&nbsp;naopak neexistence GILu. Nejprve porovnáme
interpretry verze 3.12, 3.13 i 3.14, všechny s&nbsp;GILem:</p>

<table>
<tr><th>Verze Pythonu</th><th>Varianta</th><th>Celkový čas</th></tr>
<tr><td>3.12</td><td>GIL</td><td>73s</td></tr>
<tr><td>3.13</td><td>GIL</td><td>73s</td></tr>
<tr><td>3.14</td><td>GIL</td><td>54s</td></tr>
</table>

<p>Zajímavé je, že časy dokončení benchmarku jsou prakticky stejné jako
v&nbsp;případě jeho sekvenční varianty. Jinými slovy nám složitější zápis
algoritmu nijak nepomohl, ovšem dobré je, že ani nijak neuškodil.</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 708px"><a href="https://www.root.cz/obrazek/1234554/"><img src="https://i.iinfo.cz/images/117/python-3-14-b-2-large.png" class="image-1234554" width="708" height="525" data-prev-filename="https://i.iinfo.cz/images/117/python-3-14-b-2-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-2-prev.webp" data-prev-width="364" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/117/python-3-14-b-2-large.png" data-large-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-2-large.webp" data-large-width="708" data-large-height="525" alt="Obrázek 2: Porovnání rychlosti paralelní varianty benchmarku (interpretry s&nbsp;GIL) v&nbsp;grafické podobě." data-description="Obrázek 2: Porovnání rychlosti paralelní varianty benchmarku (interpretry s&nbsp;GIL) v&nbsp;grafické podobě." title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 708px" /></a><p>Obrázek 2: Porovnání rychlosti paralelní varianty benchmarku (interpretry s&nbsp;GIL) v&nbsp;grafické podobě. Opět vyhrává Python 3.14 s&nbsp;GILem.<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>Přejděme nyní na Python 3.14 bez GILu. Benchmark budeme spouštět pro různý
počet workerů a tím pádem i pro různý počet vláken, které budou moci být
provedeny souběžně:</p>

<table>
<tr><th>Počet vláken</th><th>Varianta</th><th>Celkový čas</th></tr>
<tr><td>4</td><td>noGIL</td><td>18s</td></tr>
<tr><td>8</td><td>noGIL</td><td>11s</td></tr>
<tr><td>16</td><td>noGIL</td><td>9s</td></tr>
</table>

<p>Podle očekávání se čas běhu benchmarku postupně snižuje, což je ještě lépe
patrné při pohledu na graf (pokud první hodnotu vynásobíme počtem vláken,
dostaneme přibližně rychlost pro sekvenční variantu benchmarku):</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 708px"><a href="https://www.root.cz/obrazek/1234557/"><img src="https://i.iinfo.cz/images/117/python-3-14-b-3-large.png" class="image-1234557" width="708" height="525" data-prev-filename="https://i.iinfo.cz/images/117/python-3-14-b-3-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-3-prev.webp" data-prev-width="364" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/117/python-3-14-b-3-large.png" data-large-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-3-large.webp" data-large-width="708" data-large-height="525" alt="Obrázek 3: Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;vypnutým GILem." data-description="Obrázek 3: Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;vypnutým GILem." title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 708px" /></a><p>Obrázek 3: Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;vypnutým GILem.<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>Pro úplnost se podívejme na celkové časy běhu paralelní verze benchmarku pro
počet vláken od 1 do 20:</p>

<pre>
Workers: 1  total time: 62.31223807000788 seconds
Workers: 2  total time: 33.75166744997841 seconds
Workers: 3  total time: 23.33235937001882 seconds
Workers: 4  total time: 17.860626637993846 seconds
Workers: 5  total time: 15.856282107997686 seconds
Workers: 6  total time: 13.856884196982719 seconds
Workers: 7  total time: 12.629000126005849 seconds
Workers: 8  total time: 11.608698377996916 seconds
Workers: 9  total time: 11.077733537007589 seconds
Workers: 10  total time: 10.40789418600616 seconds
Workers: 11  total time: 10.052095271006692 seconds
Workers: 12  total time: 9.38940597101464 seconds
Workers: 13  total time: 9.442261223011883 seconds
Workers: 14  total time: 9.424980993004283 seconds
Workers: 15  total time: 9.394032383017475 seconds
Workers: 16  total time: 9.34619775399915 seconds
Workers: 17  total time: 9.31484580898541 seconds
Workers: 18  total time: 9.448251099995105 seconds
Workers: 19  total time: 9.392468684003688 seconds
</pre>

<p>Na mém CPU by teoretické zrychlení mělo dosahovat osminásobku (CPU má osm
skutečných jader, které se tváří jako šestnáct jader virtuálních), ovšem
v&nbsp;praxi se v&nbsp;tomto případě nedosáhlo ani sedminásobku (i tak ovšem
nejsou výsledky úplně špatné):</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 719px"><a href="https://www.root.cz/obrazek/1234560/"><img src="https://i.iinfo.cz/images/117/python-3-14-b-4-large.png" class="image-1234560" width="719" height="525" data-prev-filename="https://i.iinfo.cz/images/117/python-3-14-b-4-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-4-prev.webp" data-prev-width="370" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/117/python-3-14-b-4-large.png" data-large-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-4-large.webp" data-large-width="719" data-large-height="525" alt="Obrázek 4: Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;vypnutým GILem." data-description="Obrázek 4: Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;vypnutým GILem." title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 719px" /></a><p>Obrázek 4: Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;vypnutým GILem.<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k06"></a></p>
<h2 id="k06">6. Složitější výpočty s&nbsp;velkým množstvím numerických operací</h2>

<p>Větší počet jader mikroprocesoru, které mohou v&nbsp;ideálním případě
pracovat paralelně, oceníme především ve chvíli, kdy je nutné vykonat nějaké
složitější výpočty, neboť takové úlohy typicky nejsou omezeny rychlostí
vstupně-výstupních operací a mnohdy ani neprovádějí velké množství čtení a
zápisů do operační paměti. Jednou typicky výpočetně náročnou úlohou (kterou
jsme v&nbsp;nepatrně pozměněné podobě již použili při testování nástroje
<i>Numba</i> a <i>mypyc</i>), je výpočet nějakého fraktálu v&nbsp;komplexní
rovině.</p>

<a href="https://www.root.cz/obrazek/1113721/"><img src="https://i.iinfo.cz/images/463/python-nogil-6-prev.webp" class="image-1113721" width="270" height="270" data-prev-filename="https://i.iinfo.cz/images/463/python-nogil-6-prev.webp" data-prev-width="270" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/463/python-nogil-4.webp" data-large-width="512" data-large-height="512" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 5: Jedna varianta fraktálu vykreslená benchmarkem.</i></p>

<p>Zkusme si tedy nechat vykreslit několik Juliových množin v&nbsp;nastaveném
rozlišení (zde je konkrétně použito 256&times;256 pixelů) a s&nbsp;využitím
většího maximálního počtu iterací (1000). Následující benchmark
<i>sekvenčně</i> vypočítá několik desítek obrázků Juliových množin a uloží je
na disk:</p>

<pre>
<i>#!/usr/bin/env python</i>
&nbsp;
<i>"""Renderer of the classic Julia fractal."""</i>
&nbsp;
import math
from time import perf_counter
&nbsp;
from PIL import Image
&nbsp;
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
&nbsp;
def <strong>julia</strong>(cx, cy, zx, zy, maxiter):
    c = complex(cx, cy)
    z = complex(zx, zy)
    for i in range(maxiter):
        if abs(z) &gt; 2:
            return i
        z = z * z + c
    return 0
&nbsp;
&nbsp;
def <strong>recalc_fractal</strong>(filename, palette, xmin, ymin, xmax, ymax, cx, cy, maxiter=1000):
    <i>"""Recalculate the whole fractal and render the set into given image."""</i>
    t1 = perf_counter()
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))
&nbsp;
    width, height = image.size
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height
&nbsp;
    y1 = ymin
    for y in range(height):
        x1 = xmin
        for x in range(width):
            i = julia(cx, cy, x1, y1, maxiter)
            i = 3 * i % 256
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
            x1 += stepx
        y1 += stepy
&nbsp;
    image.save(filename)
    t2 = perf_counter()
    <i># print("Done", filename, t2-t1)</i>
&nbsp;
&nbsp;
def <strong>main</strong>():
    import palette_mandmap
&nbsp;
    for angle in range(0, 360, 5):
        rad = math.radians(angle)
        cx = 1.0 * math.cos(rad)
        cy = 1.0 * math.sin(rad)
        filename = f"anim_{angle:03d}.png"
        <i># print(filename)</i>
&nbsp;
        recalc_fractal(filename, palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, cx, cy, 1000)
&nbsp;
&nbsp;
if __name__ == "__main__":
    t1 = perf_counter()
    main()
    t2 = perf_counter()
    print(f"Threads: no   Rendering time: {t2-t1} seconds")
</pre>

<a href="https://www.root.cz/obrazek/1113722/"><img src="https://i.iinfo.cz/images/463/python-nogil-7-prev.webp" class="image-1113722" width="270" height="270" data-prev-filename="https://i.iinfo.cz/images/463/python-nogil-7-prev.webp" data-prev-width="270" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/463/python-nogil-4.webp" data-large-width="512" data-large-height="512" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 6: Další varianta fraktálu vykreslená benchmarkem.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledky benchmarku pro různé verze Pythonu</h2>

<p>V&nbsp;případě, že benchmark, jehož zdrojový kód byl uvedený <a
href="#k06">v&nbsp;šesté kapitole</a>, spustíme v&nbsp;různých verzích
interpretru jazyka Python, zjistíme, že časy výpočtu jsou prakticky totožné.
Python 3.14 je sice nepatrně rychlejší, než 3.12 nebo 3.13, ale rozdíly nejsou
tak markantní, jako tomu bylo v&nbsp;případě benchmarku s&nbsp;bublinkovým
řazením. To znamená, že počítaná smyčka a výpočty s&nbsp;komplexními čísly (tam
benchmark stráví nejvíce času) se prakticky nijak neurychlily:</p>

<table>
<tr><th>Verze Pythonu</th><th>Varianta</th><th>Celkový čas</th></tr>
<tr><td>3.12</td><td>GIL</td><td>8,7s</td></tr>
<tr><td>3.13</td><td>GIL</td><td>8,5s</td></tr>
<tr><td>3.14</td><td>GIL</td><td>8,4s</td></tr>
</table>

<p>Prakticky totožné časy výpočtu jsou dobře patrné i z&nbsp;grafické podoby
výsledků:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 719px"><a href="https://www.root.cz/obrazek/1234563/"><img src="https://i.iinfo.cz/images/117/python-3-14-b-5-large.png" class="image-1234563" width="719" height="525" data-prev-filename="https://i.iinfo.cz/images/117/python-3-14-b-5-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-5-prev.webp" data-prev-width="370" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/117/python-3-14-b-5-large.png" data-large-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-5-large.webp" data-large-width="719" data-large-height="525" alt="Obrázek 7: Porovnání rychlosti sekvenční varianty benchmarku v&nbsp;grafické podobě." data-description="Obrázek 7: Porovnání rychlosti sekvenční varianty benchmarku v&nbsp;grafické podobě." title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 719px" /></a><p>Obrázek 7: Porovnání rychlosti sekvenční varianty benchmarku v&nbsp;grafické podobě.<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k08"></a></p>
<h2 id="k08">8. Paralelní varianta výpočtu: využití proměnného počtu vláken</h2>

<p>Výpočet z&nbsp;předchozích dvou kapitol je možné snadno převést do varianty,
ve které se výpočet každého rastrového obrázku s&nbsp;Juliovou množinou
odehraje v&nbsp;samostatném vláknu. V&nbsp;závislosti na konkrétní variantě
interpretru Pythonu (s&nbsp;GILem či bez GILu) potom tato vlákna běží buď
souběžně (<i>concurrent</i>) nebo paralelně (<i>parallel</i>). Počet
vytvořených vláken lze specifikovat parametrem předávaným do konstruktoru
<strong>ThreadPoolExecutor</strong> podobně, jako tomu bylo u benchmarku pro
bublinkové řazení:</p>

<pre>
<i>#!/usr/bin/env python</i>
&nbsp;
<i>"""Renderer of the classic Julia fractal."""</i>
&nbsp;
import math
import sys
from concurrent.futures.thread import ThreadPoolExecutor
from time import perf_counter
&nbsp;
from PIL import Image
&nbsp;
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
&nbsp;
def <strong>julia</strong>(cx, cy, zx, zy, maxiter):
    c = complex(cx, cy)
    z = complex(zx, zy)
    for i in range(maxiter):
        if abs(z) &gt; 2:
            return i
        z = z * z + c
    return 0
&nbsp;
&nbsp;
def <strong>recalc_fractal</strong>(filename, palette, xmin, ymin, xmax, ymax, cx, cy, maxiter=1000):
    <i>"""Recalculate the whole fractal and render the set into given image."""</i>
    t1 = perf_counter()
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))
&nbsp;
    width, height = image.size
    stepx = (xmax - xmin) / width
    stepy = (ymax - ymin) / height
&nbsp;
    y1 = ymin
    for y in range(height):
        x1 = xmin
        for x in range(width):
            i = julia(cx, cy, x1, y1, maxiter)
            i = 3 * i % 256
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
            x1 += stepx
        y1 += stepy
&nbsp;
    image.save(filename)
    t2 = perf_counter()
    <i># print("Done", filename, t2-t1)</i>
&nbsp;
&nbsp;
def <strong>main</strong>(threads):
    import palette_mandmap
&nbsp;
    with ThreadPoolExecutor(max_workers=threads) as executor:
        for angle in range(0, 360, 5):
            rad = math.radians(angle)
            cx = 1.0 * math.cos(rad)
            cy = 1.0 * math.sin(rad)
            filename = f"anim_{angle:03d}.png"
            <i># print(filename)</i>
&nbsp;
            executor.submit(recalc_fractal, filename, palette_mandmap.palette, -1.5, -1.5, 1.5, 1.5, cx, cy, 1000)
&nbsp;
&nbsp;
if __name__ == "__main__":
    threads = 8
    if len(sys.argv) &gt; 1:
        threads = int(sys.argv[1])
&nbsp;
    t1 = perf_counter()
    main(threads)
    t2 = perf_counter()
    print(f"Threads: {threads}   Rendering time: {t2-t1} seconds")
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že počet vláken lze
nastavit z&nbsp;příkazového řádku.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výsledky benchmarku pro různé verze Pythonu</h2>

<p>Opět si ukažme výsledky pro různé verze interpretru programovacího jazyka
Python. Použity byly interpretry s&nbsp;GILem (ostatně starší varianty Pythonu
běh bez GILu neměly implementován):</p>

<table>
<tr><th>Verze Pythonu</th><th>Varianta</th><th>Celkový čas</th></tr>
<tr><td>3.12</td><td>GIL</td><td>7,9s</td></tr>
<tr><td>3.13</td><td>GIL</td><td>8,3s</td></tr>
<tr><td>3.14</td><td>GIL</td><td>8,5s</td></tr>
</table>

<p>Zajímavé je, že v&nbsp;tomto případě vychází Python 3.14 vlastně
nejhůře.</p>

<p><div class="rs-tip-major">Poznámka: jedná se o průměrné časy získané
z&nbsp;několika spuštění benchmarků, protože jsem se snažil v&nbsp;co největší
míře eliminovat vliv přepínání mezi P a E jádry.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Rozdíly celkové doby výpočtů v&nbsp;Pythonu 3.14: GIL vs noGIL</h2>

<p>Nyní se zaměřme pouze na interpret Pythonu 3.14, který &ndash; jak již víme
&ndash; může být přeložen takovým způsobem, že nebude používat GIL. Benchmark
spustíme ve verzi s&nbsp;GILem pro počet vláken, který se postupně mění od 1 do
16 (pro úplnost jsou na začátku vypsány i časy &bdquo;sekvenční&ldquo; varianty
benchmarku):</p>

<pre>
Threads: no   Rendering time: 8.26075068900002 seconds
Threads: 1   Rendering time: 8.611623036995297 seconds
Threads: 2   Rendering time: 8.259407158999238 seconds
Threads: 3   Rendering time: 8.441360425989842 seconds
Threads: 4   Rendering time: 8.47209037898574 seconds
Threads: 5   Rendering time: 8.53605182300089 seconds
Threads: 6   Rendering time: 8.031249245000026 seconds
Threads: 7   Rendering time: 8.194169141999964 seconds
Threads: 8   Rendering time: 8.253845249000051 seconds
Threads: 9   Rendering time: 8.439028205 seconds
Threads: 10   Rendering time: 8.730016430999967 seconds
Threads: 11   Rendering time: 8.830254810999918 seconds
Threads: 12   Rendering time: 8.628374089999966 seconds
Threads: 13   Rendering time: 8.723840595999945 seconds
Threads: 14   Rendering time: 8.796107125000049 seconds
Threads: 15   Rendering time: 8.895810613000094 seconds
Threads: 16   Rendering time: 8.817675302999987 seconds
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;těchto výsledků je patrné, že
počet vláken, do kterých se práce rozdělí, nemá vliv na celkový čas výpočtů,
protože prakticky všechna případná urychlení vlivem paralelního kódu
&bdquo;zarazí&ldquo; GIL, který vykonávání příkazů serializuje.</div></p>

<p>Naprosto odlišná však bude situace ve chvíli, kdy použijeme Python 3.14 se
zakázaným GILem. Opět si ukažme výsledky pro benchmark rozdělený do jednoho až
šestnácti vláken:</p>

<pre>
Threads: 1   Rendering time: 9.435709450015565 seconds
Threads: 2   Rendering time: 5.053133198001888 seconds
Threads: 3   Rendering time: 3.562595502997283 seconds
Threads: 4   Rendering time: 2.833458012988558 seconds
Threads: 5   Rendering time: 2.4556286619917955 seconds
Threads: 6   Rendering time: 2.1379492330015637 seconds
Threads: 7   Rendering time: 1.9770731370081194 seconds
Threads: 8   Rendering time: 1.872884926997358 seconds
Threads: 9   Rendering time: 1.864864025003044 seconds
Threads: 10   Rendering time: 1.7349536379915662 seconds
Threads: 11   Rendering time: 1.734476473997347 seconds
Threads: 12   Rendering time: 1.9110816899919882 seconds
Threads: 13   Rendering time: 1.775416452990612 seconds
Threads: 14   Rendering time: 1.7973549320013262 seconds
Threads: 15   Rendering time: 1.8662592969776597 seconds
Threads: 16   Rendering time: 1.843843137001386 seconds
</pre>

<p>Teoreticky by se mělo pro počet vláken přesahujících hodnotu 8 dosáhnout
osminásobného urychlení (což je počet reálných jader), ve skutečnosti však
urychlení dosáhne jen 5,5 násobku původního výpočtu. To nejsou zcela špatné
výsledky, ovšem na druhou stranu by mohly být i lepší a naznačuje to existenci
zámků buď přímo v&nbsp;interpretru nebo v&nbsp;použité knihovně:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 720px"><a href="https://www.root.cz/obrazek/1234566/"><img src="https://i.iinfo.cz/images/117/python-3-14-b-6-large.png" class="image-1234566" width="720" height="434" data-prev-filename="https://i.iinfo.cz/images/117/python-3-14-b-6-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-6-prev.webp" data-prev-width="370" data-prev-height="223" data-large-filename="https://i.iinfo.cz/images/117/python-3-14-b-6-large.png" data-large-filename-webp="https://i.iinfo.cz/images/117/python-3-14-b-6-large.webp" data-large-width="720" data-large-height="434" alt="Obrázek 8: Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;vypnutým GILem." data-description="Obrázek 8: Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;vypnutým GILem." title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 720px" /></a><p>Obrázek 8: Porovnání rychlosti paralelní varianty benchmarku pro Python 3.14 s&nbsp;vypnutým GILem.<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k11"></a></p>
<h2 id="k11">11. Podpora pro větší množství interpretrů v&nbsp;běžícím procesu</h2>

<p>V&nbsp;Pythonu 3.14 je k&nbsp;dispozici nová standardní knihovna <a
href="https://docs.python.org/3.14/library/concurrent.interpreters.html#module-concurrent.interpreters">concurrent.interpreters</a>.
Jak již název této knihovny naznačuje, poskytuje možnost konstrukce nových
instancí interpretru Pythonu, spuštění kódu v&nbsp;těchto interpretrech a
taktéž komunikaci mezi programy, které běží v&nbsp;jednotlivých interpretrech a
jsou od sebe izolovány (což znamená, že obecně nesdílí svoji paměť).
V&nbsp;názvu této knihovny je i slovo <strong>concurrent</strong>, protože
jednotlivé interpretry běží souběžně (a v&nbsp;některých případech i paralelně,
což je silnější podmínka, než souběžnost).</p>

<p><div class="rs-tip-major">Poznámka: jak uvidíme dále, je knihovna plně
funkční, ovšem sami její autoři přiznávají, že celý koncept mnoha běžících
interpretrů není po technické stránce dokonalý. Příkladem jsou poměrně velké
požadavky na paměť. To se však bude v&nbsp;dalších verzích Pythonu zlepšovat
&ndash; ostatně tvůrci Pythonu dokázali, že se skutečně ve své práci vyznají a
Python se postupně zrychluje.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výpis interpretrů, konstrukce nového interpretru</h2>

<p>Práce s&nbsp;interpretry na úrovni zdrojového kódu je relativně snadná a
přímočará. Nejprve se podívejme na to, jakým způsobem se vlastně získá seznam
všech dostupných interpretrů (ty mohou, ale také nemusí běžet, jsou však již
zkonstruovány):</p>

<pre>
from concurrent import interpreters
&nbsp;
for interpreter in <strong>interpreters.list_all()</strong>:
    print(interpreter)
</pre>

<p>Při inicializaci Pythonu 3.14 je zkonstruován jen jediný interpret. Ten je
tímto skriptem vypsán (resp.&nbsp;je vypsáno jméno objektu reprezentujícího
rozhraní k&nbsp;interpretru):</p>

<pre>
Interpreter(0)
</pre>

<p>Nový interpret se zkonstruuje funkcí <strong>interpreters.create</strong>. I
když není v&nbsp;tomto interpretru spuštěn žádný kód, bude i tento interpretr
vypsán:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = <strong>interpreters.create()</strong>
&nbsp;
for interpreter in interpreters.list_all():
    print(interpreter)
</pre>

<p>Výsledky:</p>

<pre>
Interpreter(0)
Interpreter(1)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Spuštění kódu v&nbsp;novém interpretru</h2>

<p>V&nbsp;nově vytvořeném interpretru je pochopitelně možné spustit nějaký kód.
Pro tento účel slouží metody <strong>call</strong> a <strong>exec</strong>.
Ukažme si použití metody <strong>call</strong>, která akceptuje identifikátor
funkce a její případné parametry. Funkce je spuštěna &bdquo;izolovaně&ldquo;
v&nbsp;novém interpretru:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
def <strong>run</strong>():
    print("Hello from new interpreter")
&nbsp;
print("Executing run()")
interp.call(run)
&nbsp;
print("Hello from the original interpreter")
</pre>

<p>Výsledky:</p>

<pre>
Executing run()
Hello from new interpreter
Hello from the original interpreter
</pre>

<p>Přičemž prostřední zpráva je vypsána kódem funkce <strong>run</strong>
běžící v&nbsp;novém interpretru.</p>

<p>Podobně lze použít i <strong>exec</strong>:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
def <strong>run</strong>():
    print("Hello from new interpreter")
&nbsp;
print("Executing run()")
interp.exec(run)
&nbsp;
print("Hello from the original interpreter")
</pre>

<p>Metodou <strong>exec</strong> je možné spustit i externí skript, kdežto
metoda <strong>call</strong> je omezena na zavolání funkcí:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
print("Executing run()")
interp.exec(open("hello.py").read())
&nbsp;
print("Hello from the original interpreter")
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Spuštění kódu v&nbsp;novém vláknu</h2>

<p>Ve světě mikroprocesorů s&nbsp;velkým množstvím procesorových jader je velmi
užitečné, že interpret může spustit zadanou funkci v&nbsp;novém vláknu. To je
ukázáno na dalším demonstračním příkladu, v&nbsp;němž funkci
<strong>run</strong> spustíme nejenom v&nbsp;novém interpretru, ale navíc i
v&nbsp;novém vláknu, které může běžet souběžně s&nbsp;původním vláknem:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
def <strong>run</strong>():
    print("Hello from new interpreter")
&nbsp;
print("Executing run()")
t = <strong>interp.call_in_thread(run)</strong>
&nbsp;
print("Hello from original interpreter")
&nbsp;
t.join()
</pre>

<p>V&nbsp;tomto demonstračním příkladu navíc explicitně čekáme na dokončení
vlákna, ve kterém byla funkce <strong>run</strong> spuštěna:</p>

<pre>
Executing run()
Hello from original interpreter
Hello from new interpreter
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Sdílí interpretry svůj stav?</h2>

<p>V&nbsp;předchozích odstavcích bylo napsáno, že funkce (či jiný kód) běžící
v&nbsp;jednotlivých interpretrech je odizolován od kódu z&nbsp;jiných
interpretrů. Zda tomu tak je se můžeme pokusit zjistit různými způsoby. Ukažme
si ten nejjednodušší z&nbsp;nich. Ve funkci <strong>run</strong> se pokusíme o
modifikaci obsahu globální proměnné:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
x = []
&nbsp;
def <strong>run</strong>():
    x.append("*")
&nbsp;
print("x=", x)
&nbsp;
run()
print("x=", x)
&nbsp;
t = interp.call_in_thread(run)
t.join()
&nbsp;
print("x=", x)
</pre>

<p>Spuštění tohoto skriptu povede k&nbsp;běhové chybě:</p>

<pre>
x= []
x= ['*']
x= []
x= ['*']
Exception in thread Thread-1 (_call):
Exception: ModuleNotFoundError: No module named '&lt;fake __main__&gt;'
&nbsp;
The above exception was the direct cause of the following exception:
&nbsp;
concurrent.interpreters.NotShareableError: object could not be unpickled
&nbsp;
The above exception was the direct cause of the following exception:
&nbsp;
Traceback (most recent call last):
  File "/usr/local/lib/python3.14t/threading.py", line 1081, in _bootstrap_inner
    self._context.run(self.run)
    ~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/usr/local/lib/python3.14t/threading.py", line 1023, in run
    self._target(*self._args, **self._kwargs)
    ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.14t/concurrent/interpreters/__init__.py", line 215, in _call
    res, excinfo = _interpreters.call(self._id, callable, args, kwargs, restrict=True)
                   ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
concurrent.interpreters.NotShareableError: func not shareable
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;vypsaných zpráv je patrné, že
interně je situace poněkud komplikovanější. Podrobnosti si řekneme příště při
popisu způsobu komunikace mezi interpretry &ndash; i to je totiž
možné.</div></p>

<p>To ovšem neznamená, že kód v&nbsp;různých interpretrech nedokáže komunikovat
s&nbsp;jiným kódem. Komunikace možná je, ovšem přes fronty, což si taktéž
příště ukážeme.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Chování programu při spuštění dvou souběžných úloh v&nbsp;různých interpretrech</h2>

<p>Ještě jednou se vraťme k&nbsp;problematice spuštění kódu jak
v&nbsp;samostatném interpretru, tak i v&nbsp;samostatném vláknu. Budeme
zkoumat, jak se takový program bude chovat v&nbsp;čase běhu, tedy
v&nbsp;<i>runtime</i>. Nejprve nepatrně upravíme skript, v&nbsp;němž se funkce
<strong>run</strong> spouští &bdquo;jen&ldquo; v&nbsp;novém interpretru, ale
pořád ve stejném vlákně. Přidáme volání funkce <strong>sleep</strong>:</p>

<pre>
from time import sleep
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
def <strong>run</strong>():
    from time import sleep
    sleep(5)
    print("Hello from new interpreter")
&nbsp;
print("Executing run()")
interp.exec(run)
&nbsp;
sleep(5)
print("Hello from the original interpreter")
</pre>

<p>Podle očekávání se zprávy zobrazí s&nbsp;přibližně pětisekundovými
prodlevami:</p>

<pre>
Executing run()
&lt;5 sekund&gt;
Hello from new interpreter
&lt;5 sekund&gt;
Hello from the original interpreter
</pre>

<p>Jak se ovšem chování změní tehdy, pokud bude <strong>run</strong> spuštěna
v&nbsp;novém vláknu?</p>

<pre>
from time import sleep
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
def <strong>run</strong>():
    from time import sleep
    sleep(5)
    print("Hello from new interpreter")
&nbsp;
print("Executing run()")
t = interp.call_in_thread(run)
&nbsp;
sleep(5)
print("Hello from original interpreter")
&nbsp;
t.join()
</pre>

<p>Druhé dvě zprávy se zobrazí v&nbsp;přibližně stejný okamžik, protože je sice
před nimi pětisekundová prodleva, ta však byla vykonána souběžně jak
v&nbsp;původním vláknu, tak i ve vláknu novém:</p>

<pre>
Executing run()
&lt;5 sekund&gt;
Hello from original interpreter
Hello from new interpreter
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Chování programu v&nbsp;případě, že je v&nbsp;interpretru vyhozena nezachycená výjimka</h2>

<p>Zajímavé bude zjistit, jak se bude celý program chovat ve chvíli, kdy je
z&nbsp;funkce spuštěné v&nbsp;novém (samostatném) interpretru vyhozena výjimka,
která není odchycena. Může se jednat například o chybu při dělení atd.,
tj.&nbsp;o takový typ výjimky, který se (většinou) přímo neošetřuje. Nejprve
spustíme kód v&nbsp;novém interpretru s&nbsp;využitím metody
<strong>exec</strong>, tj.&nbsp;vše poběží v&nbsp;jediném vláknu:</p>

<pre>
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
def <strong>run</strong>():
    print("Hello from new interpreter")
    0/0
&nbsp;
print("Executing run()")
interp.exec(run)
&nbsp;
print("Hello from the original interpreter")
</pre>

<p>Pokusme se tento skript spustit a sledovat, jaké operace se vykonají:</p>

<pre>
$ <strong>python3.14 interpreter_exception_1.py</strong>
&nbsp;
Executing run()
Hello from new interpreter
Traceback (most recent call last):
  File "/home/ptisnovs/src/most-popular-python-libs/python3.14/interpreters/interpreter_exception_1.py", line 10, in <module>
    interp.exec(run)
    ~~~~~~~~~~~^^^^^
  File "/usr/local/lib/python3.14/concurrent/interpreters/__init__.py", line 212, in exec
    raise ExecutionFailed(excinfo)
concurrent.interpreters.ExecutionFailed: ZeroDivisionError: division by zero
&nbsp;
Uncaught in the interpreter:
&nbsp;
Traceback (most recent call last):
  File "/home/ptisnovs/src/most-popular-python-libs/python3.14/interpreters/interpreter_exception_1.py", line 7, in run
    0/0
    ~^~
ZeroDivisionError: division by zero
</pre>

<p>V&nbsp;tomto případě došlo k&nbsp;&bdquo;běžnému&ldquo; pádu celé aplikace,
což znamená, že interpretry jsou sice od sebe izolovány, ale vlastní volání
funkce v&nbsp;interpretru může zhavarovat pokud dojde k&nbsp;vyhození
výjimky.</p>

<p>Spuštění kódu v&nbsp;novém vláknu (a v&nbsp;novém interpretru) se bude
chovat odlišně, i když dojde k&nbsp;vyhození stejné výjimky:</p>

<pre>
from time import sleep
from concurrent import interpreters
&nbsp;
interp = interpreters.create()
&nbsp;
def <strong>run</strong>():
    print("Hello from new interpreter")
    0/0
&nbsp;
print("Executing run()")
t = interp.call_in_thread(run)
&nbsp;
print("Hello from the original interpreter")
&nbsp;
sleep(5)
&nbsp;
print("Original interpreter is still alive")
&nbsp;
t.join()
</pre>

<p>Nyní je výjimkou ukončen běh kódu v&nbsp;jiném vláknu, ovšem původní
interpret stále poběží, což je patrné z&nbsp;hlášení, která jsou zobrazena:</p>

<pre>
$ <strong>python3.14 interpreter_exception_2.py</strong>
&nbsp;
Executing run()
Hello from the original interpreter
Hello from new interpreter
Exception in thread Thread-1 (_call):
Traceback (most recent call last):
  File "/usr/local/lib/python3.14/threading.py", line 1081, in _bootstrap_inner
    self._context.run(self.run)
    ~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/usr/local/lib/python3.14/threading.py", line 1023, in run
    self._target(*self._args, **self._kwargs)
    ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.14/concurrent/interpreters/__init__.py", line 217, in _call
    raise ExecutionFailed(excinfo)
concurrent.interpreters.ExecutionFailed: ZeroDivisionError: division by zero

Uncaught in the interpreter:

Traceback (most recent call last):
  File "/home/ptisnovs/src/most-popular-python-libs/python3.14/interpreters/interpreter_exception_2.py", line 8, in run
    0/0
    ~^~
ZeroDivisionError: division by zero
Original interpreter is still alive
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na články s&nbsp;problematikou souběžnosti a paralelnosti v&nbsp;Pythonu</h2>

<p>Na stránkách <a href="https://www.root.cz">Roota</a> jsme se již několikrát setkali s&nbsp;problematikou souběžnosti, paralelnosti a asynchronního běhu v&nbsp;Pythonu. Různé varianty spouštění a řízení více vláken, procesů a asynchronních úloh naleznete v&nbsp;následujících článcích (všechny v&nbsp;článcích uvedené demonstrační příklady by měly být spustitelné i v&nbsp;interpretru Pythonu 3.14 bez GILu):</p>

<ol>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – Curio a Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-curio-a-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – knihovna Trio (2)<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-knihovna-trio-2/</a>
</li>

<li>Souběžné a paralelně běžící úlohy naprogramované v Pythonu – závěrečné zhodnocení<br />
<a href="https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/">https://www.root.cz/clanky/soubezne-a-paralelne-bezici-ulohy-naprogramovane-v-pythonu-zaverecne-zhodnoceni/</a>
</li>

<li>Interpret Pythonu bez GILu: vyplatí se odstranění velkého zámku?<br />
<a href="https://www.root.cz/clanky/interpret-pythonu-bez-gilu-vyplati-se-odstraneni-velkeho-zamku/">https://www.root.cz/clanky/interpret-pythonu-bez-gilu-vyplati-se-odstraneni-velkeho-zamku/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady jsou vypsány v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td> 1</td><td>bubble-sort/bubble_sort_seq.py</td><td>benchmark provádějící sekvenční volání algoritmu pro bublinkové řazení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_seq.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_seq.py</a></td></tr>
<tr><td> 2</td><td>bubble-sort/bubble_sort_parallel.py</td><td>benchmark provádějící souběžné volání algoritmu pro bublinkové řazení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_parallel.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/bubble-sort/bubble_sort_parallel.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>julia-renderer/julia_seq_anim.py</td><td>sekvenční výpočet animace Juliových množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_seq_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_seq_anim.py</a></td></tr>
<tr><td> 4</td><td>julia-renderer/julia_parallel_anim.py</td><td>souběžný popř.&nbsp;paralelní výpočet animace Juliových množin</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_parallel_anim.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/julia_parallel_anim.py</a></td></tr>
<tr><td> 5</td><td>julia-renderer/palette_mandmap.py</td><td>pomocný soubor s&nbsp;barvovou mapou použitý dvěma předchozími benchmarky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/julia-renderer/palette_mandmap.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>interpreters/list-interpreters.py</td><td>výpis seznamu inicializovaných interpretrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/list-interpreters.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/list-interpreters.py</a></td></tr>
<tr><td> 7</td><td>interpreters/new-interpreter.py</td><td>konstrukce nového interpretru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/new-interpreter.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/new-interpreter.py</a></td></tr>
<tr><td> 8</td><td>interpreters/exec.py</td><td>zavolání funkce ve zvoleném interpretru (ve stejném vlákně)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/exec.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/exec.py</a></td></tr>
<tr><td> 9</td><td>interpreters/call_in_thread.py</td><td>zavolání funkce ve zvoleném interpretru (v&nbsp;novém vlákně)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/call_in_thread.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/call_in_thread.py</a></td></tr>
<tr><td>10</td><td>interpreters/shared-variables.py</td><td>jsou proměnné sdíleny mezi interpretry?</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/shared-variables.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/shared-variables.py</a></td></tr>
<tr><td>11</td><td>interpreters/behaviour_exec.py</td><td>chování dvou interpretrů v&nbsp;čase běhu (metoda <strong>exec</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_exec.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_exec.py</a></td></tr>
<tr><td>12</td><td>interpreters/behaviour_call_in_thread.py</td><td>chování dvou interpretrů v&nbsp;čase běhu (metoda <strong>call_in_thread</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_call_in_thread.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/behaviour_call_in_thread.py</a></td></tr>
<tr><td>13</td><td>interpreters/interpreter_exception_1.py </td><td>chování interpretrů při vyhození nezachycené výjimky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_1.py</a></td></tr>
<tr><td>14</td><td>interpreters/interpreter_exception_2.py </td><td>chování interpretrů při vyhození nezachycené výjimky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/interpreters/interpreter_exception_2.py</a></td></tr>
</table>

<p>Demonstrační příklady vytvořené pro Python verze 3.14 a popsané
v&nbsp;minulém článku najdete v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs/">https://github.com/tisnik/most-popular-python-libs/</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>argparse_test.py</td><td>skript s&nbsp;definicí přepínačů použitelných na příkazovém řádku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/argparse_test.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/argparse_test.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>syntax_error_1.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_1.py</a></td></tr>
<tr><td> 2</td><td>syntax_error_2.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_2.py</a></td></tr>
<tr><td> 3</td><td>syntax_error_3.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_3.py</a></td></tr>
<tr><td> 4</td><td>syntax_error_4.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_4.py</a></td></tr>
<tr><td> 5</td><td>syntax_error_5.py</td><td>skript obsahující syntaktické chyby: chybějící či naopak přebývající písmeno v&nbsp;klíčovém slovu nebo identifikátoru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/syntax_error_5.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>primes.py</td><td>realizace výpočtu prvočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/primes.py</a></td></tr>
<tr><td> 7</td><td>test_primes.py</td><td>jednotkové testy pro modul <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/test_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/test_primes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>pep-758-motivation-1.py</td><td>zachycení většího množství výjimek v&nbsp;bloku <strong>except</strong> &ndash; motivační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-1.py</a></td></tr>
<tr><td> 9</td><td>pep-758-motivation-2.py</td><td>zachycení většího množství výjimek v&nbsp;bloku <strong>except</strong> &ndash; motivační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-motivation-2.py</a></td></tr>
<tr><td>10</td><td>pep-758-usage.py</td><td>nový způsob zachycení výjimek definovaný v&nbsp;PEP-758</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage.py</a></td></tr>
<tr><td>11</td><td>pep-758-usage-as.py</td><td>klauzule <strong>as</strong> a nový způsob zachycení výjimek definovaný v&nbsp;PEP-758</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage-as.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-758-usage-as.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>pep-765-motivation-1.py</td><td>detekce opuštění bloku <strong>finally</strong>, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-1.py</a></td></tr>
<tr><td>13</td><td>pep-765-motivation-2.py</td><td>detekce opuštění bloku <strong>finally</strong>, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-2.py</a></td></tr>
<tr><td>14</td><td>pep-765-motivation-3.py</td><td>detekce opuštění bloku <strong>finally</strong>, třetí demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-3.py</a></td></tr>
<tr><td>15</td><td>pep-765-motivation-4.py</td><td>detekce opuštění bloku <strong>finally</strong>, čtvrtý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/pep-765-motivation-4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>f-string-1.py</td><td>rozdíl mezi f-řetězci a t-řetězci, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-1.py</a></td></tr>
<tr><td>17</td><td>t-string-1.py</td><td>rozdíl mezi f-řetězci a t-řetězci, první demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-1.py</a></td></tr>
<tr><td>18</td><td>f-string-2.py</td><td>rozdíl mezi f-řetězci a t-řetězci, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/f-string-2.py</a></td></tr>
<tr><td>19</td><td>t-string-2.py</td><td>rozdíl mezi f-řetězci a t-řetězci, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/python3.14/t-string-2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python 3.14.0<br />
<a href="https://test.python.org/downloads/release/python-3140/">https://test.python.org/downloads/release/python-3140/</a>
</li>

<li>PEP 765 – Disallow return/break/continue that exit a finally block<br />
<a href="https://peps.python.org/pep-0765/">https://peps.python.org/pep-0765/</a>
</li>

<li>PEP 758 – Allow except and except* expressions without parentheses<br />
<a href="https://peps.python.org/pep-0758/">https://peps.python.org/pep-0758/</a>
</li>

<li>What’s new in Python 3.14 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.14.html">https://docs.python.org/3/whatsnew/3.14.html</a>
</li>

<li>What’s New In Python 3.13 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.13.html">https://docs.python.org/3/whatsnew/3.13.html</a>
</li>

<li>What’s New In Python 3.12 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.12.html">https://docs.python.org/3/whatsnew/3.12.html</a>
</li>

<li>What’s New In Python 3.11 (official)<br />
<a href="https://docs.python.org/3/whatsnew/3.11.html">https://docs.python.org/3/whatsnew/3.11.html</a>
</li>

<li>What’s New In Python 3.12<br />
<a href="https://dev.to/mahiuddindev/python-312-4n43">https://dev.to/mahiuddindev/python-312-4n43</a></li>

<li>PEP 698 – Override Decorator for Static Typing<br />
<a href="https://peps.python.org/pep-0698/">https://peps.python.org/pep-0698/</a>
</li>

<li>PEP 484 -- Type Hints<br />
<a href="https://www.python.org/dev/peps/pep-0484/">https://www.python.org/dev/peps/pep-0484/</a>
</li>

<li>What’s New In Python 3.5<br />
<a href="https://docs.python.org/3.5/whatsnew/3.5.html">https://docs.python.org/3.5/whatsnew/3.5.html</a>
</li>

<li>26.1. typing — Support for type hints<br />
<a href="https://docs.python.org/3.5/library/typing.html#module-typing">https://docs.python.org/3.5/library/typing.html#module-typing</a>
</li>

<li>Type Hints - Guido van Rossum - PyCon 2015 (youtube)<br />
<a href="https://www.youtube.com/watch?v=2wDvzy6Hgxg">https://www.youtube.com/watch?v=2wDvzy6Hgxg</a>
</li>

<li>Python 3.5 is on its way<br />
<a href="https://lwn.net/Articles/650904/">https://lwn.net/Articles/650904/</a>
</li>

<li>Type hints<br />
<a href="https://lwn.net/Articles/640359/">https://lwn.net/Articles/640359/</a>
</li>

<li>Stránka projektu PDM<br />
<a href="https://pdm.fming.dev/latest/">https://pdm.fming.dev/latest/</a>
</li>

<li>PDF na GitHubu<br />
<a href="https://github.com/pdm-project/pdm">https://github.com/pdm-project/pdm</a>
</li>

<li>PEP 582 &ndash; Python local packages directory<br />
<a href="https://peps.python.org/pep-0582/">https://peps.python.org/pep-0582/</a>
</li>

<li>PDM na PyPi<br />
<a href="https://pypi.org/project/pdm/">https://pypi.org/project/pdm/</a>
</li>

<li>Which Python package manager should you use?<br />
<a href="https://towardsdatascience.com/which-python-package-manager-should-you-use-d0fd0789a250">https://towardsdatascience.com/which-python-package-manager-should-you-use-d0fd0789a250</a>
</li>

<li>How to Use PDM to Manage Python Dependencies without a Virtual Environment<br />
<a href="https://www.youtube.com/watch?v=qOIWNSTYfcc">https://www.youtube.com/watch?v=qOIWNSTYfcc</a>
</li>

<li>What are the best Python package managers?<br />
<a href="https://www.slant.co/topics/2666/~best-python-package-managers">https://www.slant.co/topics/2666/~best-python-package-managers</a>
</li>

<li>PEP 621 &ndash; Storing project metadata in pyproject.toml<br />
<a href="https://peps.python.org/pep-0621/">https://peps.python.org/pep-0621/</a>
</li>

<li>Pick a Python Lockfile and Improve Security<br />
<a href="https://blog.phylum.io/pick-a-python-lockfile-and-improve-security/">https://blog.phylum.io/pick-a-python-lockfile-and-improve-security/</a>
</li>

<li>PyPA specifications<br />
<a href="https://packaging.python.org/en/latest/specifications/">https://packaging.python.org/en/latest/specifications/</a>
</li>

<li>Creation of virtual environments<br />
<a href="https://docs.python.org/3/library/venv.html">https://docs.python.org/3/library/venv.html</a>
</a>

<li>How to Use virtualenv in Python<br />
<a href="https://learnpython.com/blog/how-to-use-virtualenv-python/">https://learnpython.com/blog/how-to-use-virtualenv-python/</a>
</a>

<li>Python Virtual Environments: A Primer<br />
<a href="https://realpython.com/python-virtual-environments-a-primer/">https://realpython.com/python-virtual-environments-a-primer/</a>
</a>

<li>virtualenv Cheatsheet<br />
<a href="https://aaronlelevier.github.io/virtualenv-cheatsheet/">https://aaronlelevier.github.io/virtualenv-cheatsheet/</a>
</a>

<li>Installing Python Modules<br />
<a href="https://docs.python.org/3/installing/index.html">https://docs.python.org/3/installing/index.html</a>
</a>

<li>Python: The Documentary | An origin story<br />
<a href="https://www.youtube.com/watch?v=GfH4QL4VqJ0">https://www.youtube.com/watch?v=GfH4QL4VqJ0</a>
</li>

<li>History of Python<br />
<a href="https://en.wikipedia.org/wiki/History_of_Python">https://en.wikipedia.org/wiki/History_of_Python</a>
</li>

<li>History of Python<br />
<a href="https://www.geeksforgeeks.org/python/history-of-python/">https://www.geeksforgeeks.org/python/history-of-python/</a>
</li>

<li>IPython: jedno z nejpropracovanějších interaktivních prostředí pro práci s&nbsp;Pythonem<br />
<a href="https://www.root.cz/clanky/ipython-jedno-z-nejpropracova-nejsich-interaktivnich-prostredi-pro-praci-s-pythonem/">https://www.root.cz/clanky/ipython-jedno-z-nejpropracova-nejsich-interaktivnich-prostredi-pro-praci-s-pythonem/</a>
</li>

<li>Další kulaté výročí v IT: dvacet let existence Pythonu 2<br />
<a href="https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/">https://www.root.cz/clanky/dalsi-kulate-vyroci-v-it-dvacet-let-existence-pythonu-2/</a>
</li>

<li>PEP 684 – A Per-Interpreter GIL<br />
<a href="https://peps.python.org/pep-0684/">https://peps.python.org/pep-0684/</a>
</li>

<li>What Is the Python Global Interpreter Lock (GIL)?<br />
<a href="https://realpython.com/python-gil/">https://realpython.com/python-gil/</a>
</li>

<li>PEP 703 – Making the Global Interpreter Lock Optional in CPython<br />
<a href="https://peps.python.org/pep-0703/">https://peps.python.org/pep-0703/</a>
</li>

<li>GlobalInterpreterLock<br />
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>
</li>

<li>What is the Python Global Interpreter Lock (GIL)<br />
<a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/">https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/</a>
</li>

<li>Let's remove the Global Interpreter Lock<br />
<a href="https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html">https://www.pypy.org/posts/2017/08/lets-remove-global-interpreter-lock-748023554216649595.html</a>
</li>

<li>Global interpreter lock<br />
<a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">https://en.wikipedia.org/wiki/Global_interpreter_lock</a>
</li>

<li>Rychlost CPythonu 3.11 a 3.12 v&nbsp;porovnání s JIT a AOT překladači<br />
<a href="https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/">https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

