<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovna Polars: výkonnější alternativa ke knihovně Pandas (líné vyhodnocování operací)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovna Polars: výkonnější alternativa ke knihovně Pandas (líné vyhodnocování operací)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Mezi zajímavé vlastnosti knihovny Polars patří schopnost pracovat s daty, jejichž objem je větší než volná kapacita operační paměti. Protože se jedná o velmi důležitou vlastnost (a mnohdy o jediný důvod, proč vlastně uvažovat o přechodu od Pandas k Polars), budeme se touto technikou zabývat dnes.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Knihovna Polars: výkonnější alternativa ke knihovně Pandas (líné vyhodnocování operací)</a></p>
<p><a href="#k02">2. Líné operace a líné vyhodnocování v&nbsp;IT</a></p>
<p><a href="#k03">3. Koncept líných datových rámců</a></p>
<p><a href="#k04">4. Líné načtení dat do datového rámce ze souboru ve formátu CSV</a></p>
<p><a href="#k05">5. Převod běžného datového rámce na líný datový rámec</a></p>
<p><a href="#k06">6. Převod líného datového rámce na běžný datový rámec</a></p>
<p><a href="#k07">7. Ukázka podpory líných operací v&nbsp;knihovně Polars</a></p>
<p><a href="#k08">8. Konstrukce plánu s&nbsp;větším množstvím operací; realizace plánu</a></p>
<p><a href="#k09">9. Větší množství naplánovaných operací</a></p>
<p><a href="#k10">10. Ladění naplánovaných operací s&nbsp;využitím omezeného objemu dat</a></p>
<p><a href="#k11">11. Limity operace <strong>fetch</strong> při agregaci dat</a></p>
<p><a href="#k12">12. Další snížení počtu řádků vracených operací <strong>fetch</strong>: zvýraznění nekorektních výsledků</a></p>
<p><a href="#k13">13. Operace <strong>head</strong> aplikovaná na líný rámec</a></p>
<p><a href="#k14">14. Rozvětvení a opětovné spojení plánů</a></p>
<p><a href="#k15">15. Vizualizace plánu</a></p>
<p><a href="#k16">16. Vizualizace plánu s&nbsp;operacemi <strong>SLICE</strong></a></p>
<p><a href="#k17">17. Obsah závěrečné části seriálu o knihovně Polars</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovna Polars: výkonnější alternativa ke knihovně Pandas (líné vyhodnocování operací)</h2>

<p>Jak jsme si již několikrát připomenuli v&nbsp;předchozí dvojici článků [<a
href="https://www.root.cz/clanky/knihovna-polars-vykonnejsi-alternativa-ke-knihovne-pandas/">1</a>]
[<a
href="https://www.root.cz/clanky/knihovna-polars-vykonnejsi-alternativa-ke-knihovne-pandas-datove-ramce/">2</a>],
je knihovna <i>Polars</i> navržena takovým způsobem, aby byly operace
s&nbsp;daty uloženými v&nbsp;datových řadách nebo v&nbsp;datových rámcích
realizovány co nejrychleji, ideálně s&nbsp;využitím souběžně běžících úloh, ale
i s&nbsp;využitím moderních SIMD operací. Mnohem užitečnější je však další
vlastnost této knihovny &ndash; schopnost pracovat s&nbsp;daty, jejichž objem
je větší než volná kapacita operační paměti. Vzhledem k&nbsp;tomu, že se jedná
o velmi důležitou vlastnost (a v&nbsp;mnoha případech vlastně o jediný důvod,
proč vlastně uvažovat o přechodu od <i>Pandas</i> k&nbsp;<i>Polars</i>), budeme
se touto velmi zajímavou problematikou zabývat v&nbsp;dnešním článku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Líné operace a líné vyhodnocování v&nbsp;IT</h2>

<p>V&nbsp;informatice se na mnoha místech setkáme s&nbsp;využitím takzvaných
&bdquo;líných&ldquo; operací popř.&nbsp;&bdquo;líných datových struktur&ldquo;
resp.&nbsp;&bdquo;<a
href="https://en.wikipedia.org/wiki/Lazy_evaluation">líného
vyhodnocování</a>&ldquo;. Jedná se o koncept, který je založen na tom, že se
nějaký výpočet či operace neprovede ihned ve chvíli, kdy je v&nbsp;programu
zapsána, ale obecně se její vykonání přesune do budoucnosti s&nbsp;tím
předpokladem, že mnohdy vlastně není nutné operaci provádět vůbec nebo ne
v&nbsp;plném rozsahu. Připomeňme si například, jak jsou realizovány &bdquo;líné
sekvence&ldquo; v&nbsp;programovacím jazyku Clojure. Obecně platí, že se prvky
v&nbsp;líných sekvencích vyhodnocují až tehdy, kdy je to nezbytně nutné a
předpokládá se, že k&nbsp;vyhodnocení nemusí dojít vůbec.</p>

<p>Příkladem může být líná sekvence, která vznikne aplikací funkcí
<strong>range</strong> + <strong>filter</strong> + <strong>map</strong> +
<strong>take</strong>. V&nbsp;Clojure můžeme pro větší čitelnost použít
<i>threading makro</i>, takže výsledný zápis připomíná klasickou pipelinu:</p>

<pre>
(-&gt;&gt; (range)
     (map #(* % 3))
     (filter #(even %))
     (take 10))
</pre>

<p>Funkce <strong>range</strong> obecně (pokud se jí nezadají další parametry)
generuje nekonečnou sekvenci, ovšem díky pozdějšímu použití
<strong>take</strong> se z&nbsp;této nekonečné sekvence získá jen prvních
<i>n</i> prvků &ndash; a až za podmínky, kdy se musí pracovat s&nbsp;hodnotou
prvku (například když se má výsledek vytisknout). Aplikace funkcí
<strong>range</strong>, <strong>filter</strong> a <strong>map</strong> jsou
tedy provedeny později či vůbec ne. V&nbsp;našem konkrétním případě bude
výsledkem tato konečná a <i>realizovaná</i> sekvence:</p>

<pre>
(0 6 12 18 24 30 36 42 48 54)
</pre>

<p><div class="rs-tip-major">Poznámka: koncept líného vyhodnocování operací
není použit pouze v&nbsp;jazyku Clojure, ale najdeme ho (pochopitelně
v&nbsp;poněkud odlišné podobě) například v&nbsp;OCamlu, Scheme, Haskellu,
Mirandě, ale &ndash; i když jen v&nbsp;omezené míře &ndash; například i
v&nbsp;Pythonu (generátory, které mohou vytvářet nekonečné sekvence).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Koncept líných datových rámců</h2>

<p>V&nbsp;tomto seriálu jsme se již několikrát zmínili o funkci nazvané
<strong>read_csv</strong>. Připomeňme si, že tato funkce slouží pro načtení dat
uložených ve formátu CSV (<i>comma separated values</i>), TSV (<i>tab separated
values</i>) popř.&nbsp;z&nbsp;textového souboru s&nbsp;pevně zadanou
strukturou. Výsledkem je plnohodnotný datový rámec, jenž je uložený
v&nbsp;operační paměti a na který je možné aplikovat všechny předminule i
minule popsané operace, včetně seskupení dat s&nbsp;jejich následnou agregací.
Například:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># přečtení zdrojových dat</i>
df = polars.read_csv("hall_of_fame.csv")
&nbsp;
<i># maximální počet zobrazených řádků</i>
polars.Config.set_tbl_rows(100)
&nbsp;
<i># seskupení podle názvu jazyka</i>
df = df.groupby("Winner", maintain_order=True).agg([polars.col("Year").len()<strong>.alias("Zvítězil")</strong>]). \
        sort("Zvítězil"). \
        reverse(). \
        <strong>head(5)</strong>
&nbsp;
<i># zobrazíme datový rámec</i>
print(df)
</pre>

<p>Jakým způsobem je ale vůbec možné pracovat s&nbsp;daty, která mají větší
objem, než je volná kapacita operační paměti? Řešením jsou takzvané <i>líné
datové rámce</i>. V&nbsp;případě použití líných rámců se operace vyžadované
uživatelem neprovádí hned, ale až ve chvíli, kdy jsou výsledky skutečně
zapotřebí &ndash; vyžadované operace jsou tedy zapamatovány ve formě
<i>plánu</i>. A navíc je vykonávání operací řešeno formou
&bdquo;streamu&ldquo;, tj.&nbsp;v&nbsp;naprosté většině případů se nevyžaduje,
aby byl celý datový rámec uložen v&nbsp;operační paměti. Práci s&nbsp;línými
datovými rámci si ostatně ukážeme v&nbsp;navazujících kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Líné načtení dat do datového rámce ze souboru ve formátu CSV</h2>

<p>Podívejme se nyní na způsob &bdquo;líného&ldquo; načtení datového rámce ze
souboru, v&nbsp;němž jsou data uložena ve formátu CSV. Namísto funkce
<strong>read_csv</strong> použijeme funkci nazvanou <strong>scan_csv</strong>,
která má stejné povinné i nepovinné parametry, jako již zmíněná funkce
<strong>read_csv</strong>, takže záměna v&nbsp;existujících skriptech je možná
a hlavně snadná:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = <strong>polars.scan_csv("hall_of_fame.csv")</strong>
&nbsp;
<i># zobrazíme líně načtený datový rámec</i>
print(df)
print()
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_01_scan_csv.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_01_scan_csv.py</a>.</div></p>

<p>Výsledek, který získáme po spuštění tohoto skriptu, je zcela odlišný od
výsledku operace <strong>read_csv</strong>. Funkce <strong>scan_csv</strong>
totiž pouze zaznamená, jaká operace se má provést a uloží tento záznam do
<i>plánu</i>. A tento plán je skriptem zobrazen:</p>

<pre>
naive plan: (run LazyFrame.describe_optimized_plan() to see the optimized plan)
&nbsp;
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
</pre>

<p>Výsledkem je tedy <i>líný datový rámec</i>. Naproti tomu použití funkce
<strong>read_csv</strong> vede k&nbsp;okamžitému načtení dat a výsledkem bude
běžný datový rámec:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># okamžité přečtení zdrojových dat</i>
df = <strong>polars.read_csv("hall_of_fame.csv")</strong>
&nbsp;
<i># zobrazíme načtený datový rámec</i>
print(df)
print()
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
shape: (20, 2)
┌──────┬────────┐
│ Year ┆ Winner │
│ ---  ┆ ---    │
│ i64  ┆ str    │
╞══════╪════════╡
│ 2022 ┆ C++    │
│ 2021 ┆ Python │
│ 2020 ┆ Python │
│ 2019 ┆ C      │
│ ...  ┆ ...    │
│ 2006 ┆ Ruby   │
│ 2005 ┆ Java   │
│ 2004 ┆ PHP    │
│ 2003 ┆ C++    │
└──────┴────────┘
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Převod běžného datového rámce na líný datový rámec</h2>

<p>Knihovna <i>Polars</i> umožňuje provést převod běžného datového rámce
(tj.&nbsp;rámce s&nbsp;vyhodnocenými daty) na líný datový rámec. Pro tento účel
se používá metoda nazvaná příznačně <strong>lazy</strong>. Podívejme se nyní na
to, jak tento převod může proběhnout v&nbsp;praxi. V&nbsp;dalším demonstračním
příkladu nejdříve načteme obsah souboru ve formátu CSV do běžného datového
rámce, jehož obsah je následně zobrazen na terminálu. Posléze z&nbsp;tohoto
rámce vytvoříme líný datový rámec s&nbsp;využitím již zmíněné metody
<strong>lazy</strong> a následně tento líný datový rámec zobrazíme:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># přečtení zdrojových dat</i>
df = <strong>polars.read_csv("hall_of_fame.csv")</strong>
&nbsp;
<i># převod na líný datový rámec</i>
df2 = <strong>df.lazy()</strong>
&nbsp;
<i># zobrazíme načtený datový rámec</i>
print(df)
print()
&nbsp;
<i># následně zobrazíme líný datový rámec</i>
print(df2)
print()
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_02_read_csv_and_convert.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_02_read_csv_and_convert.py</a>.</div></p>

<p>Ze zobrazených výsledků je patrné, že se nejdříve skutečně zobrazí obsah
běžného datového rámce:</p>

<pre>
shape: (20, 2)
┌──────┬────────┐
│ Year ┆ Winner │
│ ---  ┆ ---    │
│ i64  ┆ str    │
╞══════╪════════╡
│ 2022 ┆ C++    │
│ 2021 ┆ Python │
│ 2020 ┆ Python │
│ 2019 ┆ C      │
│ ...  ┆ ...    │
│ 2006 ┆ Ruby   │
│ 2005 ┆ Java   │
│ 2004 ┆ PHP    │
│ 2003 ┆ C++    │
└──────┴────────┘
</pre>

<p>Následně se namísto obsahu líného datového rámce vzniklého konverzí zobrazí
&ndash; přesně podle očekávání &ndash; pouze <i>plán</i>, tj.&nbsp;seznam
operací, které se mají provést v&nbsp;budoucnosti:</p>

<pre>
naive plan: (run LazyFrame.describe_optimized_plan() to see the optimized plan)
&nbsp;
  DF ["Year", "Winner"]; PROJECT */2 COLUMNS; SELECTION: "None"
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Převod líného datového rámce na běžný datový rámec</h2>

<p>Způsob převodu běžného datového rámce na líný datový rámec jsme si ukázali
<a href="#k05">v&nbsp;předchozí kapitole</a>. Mnohdy je však mnohem důležitější
provést opačný převod, tedy převod líného rámce na běžný rámec. V&nbsp;tomto
případě však není slovo &bdquo;převod&ldquo; zcela přesné, protože se nejedná o
transformaci dat, ale o &bdquo;realizaci&ldquo; (uskutečnění) všech operací,
které byly pouze naplánovány. Podívejme se na jednoduchý příklad, v&nbsp;němž
se převod/realizace provádí metodou nazvanou <strong>collect</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = <strong>polars.scan_csv("hall_of_fame.csv")</strong>
&nbsp;
<i># zobrazíme líně načtený datový rámec</i>
print(df)
print()
&nbsp;
<i># převod na běžný datový rámec</i>
df2 = <strong>df.collect()</strong>
&nbsp;
<i># zobrazíme běžný (výsledný) datový rámec</i>
print(df2)
print()
print(df2.columns)
print(df2.dtypes)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_03_collect_to_df.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_03_collect_to_df.py</a>.</div></p>

<p>Po spuštění tohoto demonstračního příkladu se nejdříve zobrazí <i>plán</i>
pro líný datový rámec:</p>

<pre>
naive plan: (run LazyFrame.describe_optimized_plan() to see the optimized plan)
&nbsp;
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
</pre>

<p>Ve druhém kroku se zobrazí realizovaný konkrétní datový rámec vytvořený
metodou <strong>collect</strong>:</p>

<pre>
shape: (20, 2)
┌──────┬────────┐
│ Year ┆ Winner │
│ ---  ┆ ---    │
│ i64  ┆ str    │
╞══════╪════════╡
│ 2022 ┆ C++    │
│ 2021 ┆ Python │
│ 2020 ┆ Python │
│ 2019 ┆ C      │
│ ...  ┆ ...    │
│ 2006 ┆ Ruby   │
│ 2005 ┆ Java   │
│ 2004 ┆ PHP    │
│ 2003 ┆ C++    │
└──────┴────────┘
&nbsp;
['Year', 'Winner']
[Int64, Utf8]
</pre>

<p><div class="rs-tip-major">Poznámka: zatímco práce s&nbsp;líným datovým
rámcem není prakticky závislá na volné kapacitě operační paměti, po realizaci
již mohou nastat problémy v&nbsp;případě, že se zpracovává enormní množství dat
(což ovšem není náš případ).</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Ukázka podpory líných operací v&nbsp;knihovně Polars</h2>

<p>Nyní se dostáváme k&nbsp;velmi důležité vlastnosti knihovny <i>Polars</i>.
Připomeňme si, že dokud není nutné pracovat s&nbsp;daty podrobenými nějaké
operaci nebo sérií operací, není vlastně nutné tyto operace ani provádět
&ndash; postačuje si pouze zapamatovat jejich pořadí a případný použitý
parametr nebo parametry. A přesně tímto způsobem se pracuje s&nbsp;línými
datovými rámci, protože každá další operace nad rámcem se &bdquo;pouze&ldquo;
zapíše do <i>plánu</i>.</p>

<p>Samozřejmě si tento koncept můžeme velmi snadno otestovat, a to konkrétně na
demonstračním příkladu, v&nbsp;němž se pokusíme záznamy v&nbsp;líném datovém
rámci seřadit podle sloupce &bdquo;Winner&ldquo;. V&nbsp;případě, že by se
následně nezavolala operace <strong>collect</strong>, k&nbsp;vlastnímu řazení
by vůbec nedošlo:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = <strong>polars.scan_csv("hall_of_fame.csv")</strong>
&nbsp;
<i># zobrazíme líně načtený datový rámec</i>
print(df)
print()
&nbsp;
<i># aplikace operace na líný datový rámec</i>
df2 = <strong>df.sort("Winner")</strong>
&nbsp;
<i># převod na běžný datový rámec</i>
df3 = <strong>df2.collect()</strong>
&nbsp;
<i># zobrazíme druhý líny datový rámec</i>
print(df2)
print()
&nbsp;
<i># zobrazíme běžný (výsledný) datový rámec</i>
print(df3)
print()
print(df3.columns)
print(df3.dtypes)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_04_lazy_sort.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_04_lazy_sort.py</a>.</div></p>

<p>Opět je vhodné si alespoň ve stručnosti okomentovat jednotlivé informace
vypsané po spuštění tohoto demonstračního příkladu. Nejdříve se líně načtou
data ze souboru s&nbsp;formátem CSV. Výsledkem je líný datový rámec, který je
zobrazen formou svého plánu, tedy následovně:</p>

<pre>
naive plan: (run LazyFrame.describe_optimized_plan() to see the optimized plan)
&nbsp;
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
</pre>

<p>Z&nbsp;tohoto líného datového rámce je s&nbsp;využitím operace
<strong>sort</strong> vytvořen nový líný datový rámec, jehož plán je
pochopitelně odlišný &ndash; obsahuje totiž i onu operaci seřazení:</p>

<pre>
naive plan: (run LazyFrame.describe_optimized_plan() to see the optimized plan)
&nbsp;
  SORT BY [col("Winner")]
    CSV SCAN hall_of_fame.csv
    PROJECT */2 COLUMNS
</pre>

<p>A konečně se po provedení operace <strong>collect</strong> <i>realizují</i>
obě naplánované operace, tedy načtení dat ze souboru typu CSV a seřazení
záznamů na základě obsahu sloupce &bdquo;Winner&ldquo;. Výsledkem těchto dvou
operací je již běžný datový rámec s&nbsp;tímto obsahem:</p>

<pre>
shape: (20, 2)
┌──────┬──────────────┐
│ Year ┆ Winner       │
│ ---  ┆ ---          │
│ i64  ┆ str          │
╞══════╪══════════════╡
│ 2019 ┆ C            │
│ 2017 ┆ C            │
│ 2008 ┆ C            │
│ 2022 ┆ C++          │
│ ...  ┆ ...          │
│ 2010 ┆ Python       │
│ 2007 ┆ Python       │
│ 2006 ┆ Ruby         │
│ 2013 ┆ Transact-SQL │
└──────┴──────────────┘
&nbsp;
['Year', 'Winner']
[Int64, Utf8]
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Konstrukce plánu s&nbsp;větším množstvím operací; realizace plánu</h2>

<p>Samotný plán postupně vytvářený pro líné datové rámce pochopitelně může
obsahovat i větší množství operací a dokonce je ho možné i větvit. Nejdříve si
ukažme, jak by vypadal plán se třemi operacemi:</p>

<ol>
<li>(Líné) načtení datového rámce</li>
<li>Seřazení záznamů podle zvoleného sloupce</li>
<li>Otočení pořadí všech záznamů</li>
</ol>

<p>Tyto operace jsou postupně definovány v&nbsp;následujícím skriptu:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = <strong>polars.scan_csv("hall_of_fame.csv")</strong>
&nbsp;
<i># zobrazíme líně načtený datový rámec</i>
print(df)
print()
&nbsp;
<i># aplikace operace na líný datový rámec</i>
df2 = <strong>df.sort("Winner").reverse()</strong>
&nbsp;
<i># převod na běžný datový rámec</i>
df3 = <strong>df2.collect()</strong>
&nbsp;
<i># zobrazíme druhý líny datový rámec</i>
print(df2)
print()
&nbsp;
<i># zobrazíme běžný (výsledný) datový rámec</i>
print(df3)
print()
print(df3.columns)
print(df3.dtypes)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_05_lazy_sort_reverse.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_05_lazy_sort_reverse.py</a>.</div></p>

<p>Povšimněte si, jak se liší druhý plán od plánu z&nbsp;předchozího
demonstračního příkladu &ndash; operace <strong>reverse</strong> je rozepsána
na dvě paralelně probíhající operace:</p>

<pre>
naive plan: (run LazyFrame.describe_optimized_plan() to see the optimized plan)
&nbsp;
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
naive plan: (run LazyFrame.describe_optimized_plan() to see the optimized plan)
&nbsp;
   LOCAL SELECT [col("Year").reverse(), col("Winner").reverse()] FROM
    SORT BY [col("Winner")]
      CSV SCAN hall_of_fame.csv
      PROJECT */2 COLUMNS
&nbsp;
&nbsp;
shape: (20, 2)
┌──────┬──────────────┐
│ Year ┆ Winner       │
│ ---  ┆ ---          │
│ i64  ┆ str          │
╞══════╪══════════════╡
│ 2013 ┆ Transact-SQL │
│ 2006 ┆ Ruby         │
│ 2007 ┆ Python       │
│ 2010 ┆ Python       │
│ ...  ┆ ...          │
│ 2022 ┆ C++          │
│ 2008 ┆ C            │
│ 2017 ┆ C            │
│ 2019 ┆ C            │
└──────┴──────────────┘
&nbsp;
['Year', 'Winner']
[Int64, Utf8]
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Větší množství naplánovaných operací</h2>

<p>Počet operací postupně &bdquo;líně&ldquo; aplikovaných na data není
prakticky nijak omezen, takže ke dvojici operací <strong>scan_csv+sort</strong>
můžeme velmi snadno přidat operaci další, například <strong>reverse</strong>. I
tato operace bude do výsledného plánu přidána a vykonána později, pokud to bude
explicitně požadováno:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = <strong>polars.scan_csv("hall_of_fame.csv")</strong>
&nbsp;
<i># zobrazíme plán pro líně načtený datový rámec</i>
print(<strong>df.describe_plan()</strong>)
print(<strong>df.describe_optimized_plan()</strong>)
print()
&nbsp;
<i># aplikace operace na líný datový rámec</i>
df2 = <strong>df.sort("Winner").reverse()</strong>
&nbsp;
<i># převod na běžný datový rámec</i>
df3 = <strong>df2.collect()</strong>
&nbsp;
<i># zobrazíme plán pro druhý líny datový rámec</i>
print(<strong>df2.describe_plan()</strong>)
print(<strong>df2.describe_optimized_plan()</strong>)
print()
&nbsp;
<i># zobrazíme běžný (výsledný) datový rámec</i>
print(df3)
print()
print(df3.columns)
print(df3.dtypes)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_06_describe_plan.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_06_describe_plan.py</a>.</div></p>

<p>Výsledkem činnosti tohoto skriptu bude plán obsahující operaci
<strong>sort</strong>; výsledný datový rámec je pak složen ze dvou datových řad
(<i>series</i>), jejichž prvky jsou explicitně otočeny. To je ostatně zajímavý
koncept &ndash; <strong>sort</strong> je operace naplánovaná pro celý datový
rámec zatímco <strong>reverse</strong> jako operace aplikované na jednotlivé
sloupce:</p>

<pre>
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
   LOCAL SELECT [col("Year").reverse(), col("Winner").reverse()] FROM
    SORT BY [col("Winner")]
      CSV SCAN hall_of_fame.csv
      PROJECT */2 COLUMNS
&nbsp;
   LOCAL SELECT [col("Year").reverse(), col("Winner").reverse()] FROM
    SORT BY [col("Winner")]
      CSV SCAN hall_of_fame.csv
      PROJECT */2 COLUMNS
&nbsp;
&nbsp;
shape: (20, 2)
┌──────┬──────────────┐
│ Year ┆ Winner       │
│ ---  ┆ ---          │
│ i64  ┆ str          │
╞══════╪══════════════╡
│ 2013 ┆ Transact-SQL │
│ 2006 ┆ Ruby         │
│ 2007 ┆ Python       │
│ 2010 ┆ Python       │
│ ...  ┆ ...          │
│ 2022 ┆ C++          │
│ 2008 ┆ C            │
│ 2017 ┆ C            │
│ 2019 ┆ C            │
└──────┴──────────────┘
&nbsp;
['Year', 'Winner']
[Int64, Utf8]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Ladění naplánovaných operací s&nbsp;využitím omezeného objemu dat</h2>

<p>Prozatím jsme při převodu líného datového rámce na běžný datový rámec
používali metodu <strong>collect</strong>, která spustila všechny operace a
posléze výsledek těchto operací zkonvertovala do běžného datového rámce.
Namísto metody <strong>collect</strong> je však možné použít například i metodu
<strong>fetch</strong>, které se předá požadovaný počet řádků ve výsledku. Tato
metoda se používá například tehdy, pokud je nutné provést ladění celého skriptu
a vstupní data jsou zbytečně objemná (ovšem přesný počet řádků ve výsledku není
garantován &ndash; je pouze přibližný):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = polars.scan_csv("hall_of_fame.csv")
&nbsp;
<i># zobrazíme plán pro líně načtený datový rámec</i>
print(<strong>df.describe_plan()</strong>)
print()
&nbsp;
<i># aplikace operace na líný datový rámec</i>
df2 = <strong>df.sort("Winner").reverse()</strong>
&nbsp;
<i># převod vybraných prvků na běžný datový rámec</i>
df3 = <strong>df2.fetch(5)</strong>
&nbsp;
<i># zobrazíme plán pro druhý líny datový rámec</i>
print(<strong>df2.describe_plan()</strong>)
print()
&nbsp;
<i># zobrazíme běžný (výsledný) datový rámec</i>
print(df3)
print()
print(df3.columns)
print(df3.dtypes)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_07_fetch.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_07_fetch.py</a>.</div></p>

<p>Výsledný plán je naprosto stejný, jako v&nbsp;předchozím příkladu:</p>

<pre>
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
   LOCAL SELECT [col("Year").reverse(), col("Winner").reverse()] FROM
    SORT BY [col("Winner")]
      CSV SCAN hall_of_fame.csv
      PROJECT */2 COLUMNS
</pre>

<p>Liší se ovšem výsledná podoba získaného datového rámce, který bude obsahovat
jen pět řádků (záznamů):</p>

<pre>
shape: (5, 2)
┌──────┬────────┐
│ Year ┆ Winner │
│ ---  ┆ ---    │
│ i64  ┆ str    │
╞══════╪════════╡
│ 2018 ┆ Python │
│ 2020 ┆ Python │
│ 2021 ┆ Python │
│ 2022 ┆ C++    │
│ 2019 ┆ C      │
└──────┴────────┘
&nbsp;
['Year', 'Winner']
[Int64, Utf8]
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Limity operace <strong>fetch</strong> při agregaci dat</h2>

<p>Demonstrační příklad <a href="#k10">z&nbsp;předchozí kapitoly</a> byl
založen na operaci <i>fetch</i>, která z&nbsp;líného datového rámce přečetla
v&nbsp;daném případě přesný počet řádků. Ovšem tak tomu nemusí být vždy.
Podívejme se na následující skript, kde vyžadujeme přečtení pěti řádků, ovšem
z&nbsp;líného datového rámce, který vznikl agregací dat:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = polars.scan_csv("hall_of_fame.csv")
&nbsp;
<i># zobrazíme plán pro líně načtený datový rámec</i>
print(<strong>df.describe_plan()</strong>)
print()
&nbsp;
<i># seskupení podle názvu jazyka</i>
df2 = <strong>df.groupby("Winner", maintain_order=True).agg([polars.col("Year")])</strong>
&nbsp;
<i># převod vybraných prvků na běžný datový rámec</i>
df3 = <strong>df2.fetch(5)</strong>
&nbsp;
<i># zobrazíme plán pro druhý líny datový rámec</i>
print(<strong>df2.describe_plan()</strong>)
print()
&nbsp;
<i># zobrazíme běžný (výsledný) datový rámec</i>
print(df3)
print()
print(df3.columns)
print(df3.dtypes)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_08_group_by.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_08_group_by.py</a>.</div></p>

<p>Za povšimnutí stojí v&nbsp;tomto případě nikoli vlastní plán, ale počet
řádků uložených ve výsledném datovém rámci. Vrátí se tři řádky a nikoli pět
řádků. Je tomu tak proto, že při agregaci se pracuje s&nbsp;pěti hodnotami
&bdquo;Year&ldquo;, které jsou však agregovány do již zmíněných třech
řádků:</p>

<pre>
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
  Aggregate
        [col("Year")] BY [col("Winner")] FROM
          CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
&nbsp;
shape: (3, 2)
┌────────┬────────────────────┐
│ Winner ┆ Year               │
│ ---    ┆ ---                │
│ str    ┆ list[i64]          │
╞════════╪════════════════════╡
│ C++    ┆ [2022]             │
│ Python ┆ [2021, 2020, 2018] │
│ C      ┆ [2019]             │
└────────┴────────────────────┘
&nbsp;
['Winner', 'Year']
[Utf8, List(Int64)]
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Další snížení počtu řádků vracených operací <strong>fetch</strong>: zvýraznění nekorektních výsledků</h2>

<p>Pro zajímavost se podívejme, jaká situace nastane ve chvíli, kdy ještě více
snížíme počet operací pomocí <strong>fetch</strong>, a to konkrétně na pouhé
dva záznamy. Nyní bude výsledný datový rámec získaný po provedení všech operací
obsahovat dva řádky (což bychom mohli očekávat), ale navíc tyto řádky nebudou
obsahovat všechny potřebné údaje:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = polars.scan_csv("hall_of_fame.csv")
&nbsp;
<i># zobrazíme plán pro líně načtený datový rámec</i>
print(<strong>df.describe_plan()</strong>)
print()
&nbsp;
<i># seskupení podle názvu jazyka</i>
df2 = <strong>df.groupby("Winner", maintain_order=True).agg([polars.col("Year")])</strong>
&nbsp;
<i># převod vybraných prvků na běžný datový rámec</i>
df3 = <strong>df2.fetch(2)</strong>
&nbsp;
<i># zobrazíme plán pro druhý líny datový rámec</i>
print(<strong>df2.describe_plan()</strong>)
print()
&nbsp;
<i># zobrazíme běžný (výsledný) datový rámec</i>
print(df3)
print()
print(df3.columns)
print(df3.dtypes)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_09_group_by_fetch_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_09_group_by_fetch_2.py</a>.</div></p>

<p>Nyní obsahuje výsledný datový rámec informaci o tom, že C++ vyhrál pouze
v&nbsp;roce 2022 (a nikoli 2&times;) a Python v&nbsp;roce 2021 (a nikoli celkem
5&times;)! Už z&nbsp;těchto výsledků vyplývá, že <strong>fetch</strong> se
skutečně hodí jen pro ladicí účely a nikoli pro &bdquo;zkrácené&ldquo; výpočty
s&nbsp;reálnými daty a očekávanými reálnými výsledky:</p>

<pre>
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
  Aggregate
        [col("Year")] BY [col("Winner")] FROM
          CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
&nbsp;
shape: (2, 2)
┌────────┬───────────┐
│ Winner ┆ Year      │
│ ---    ┆ ---       │
│ str    ┆ list[i64] │
╞════════╪═══════════╡
│ C++    ┆ [2022]    │
│ Python ┆ [2021]    │
└────────┴───────────┘
&nbsp;
['Winner', 'Year']
[Utf8, List(Int64)]
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Operace <strong>head</strong> aplikovaná na líný rámec</h2>

<p>Pokud skutečně vyžadujeme už v&nbsp;rámci líného vyhodnocování operací
prováděných nad datovými rámci zmenšit množství dat ve zpracovávaných datových
rámcích, musí se namísto poněkud problematické a neintuitivní (viz výše)
operace <strong>fetch</strong> použít líná varianta operace
<strong>head</strong> nebo <strong>tail</strong>. Tyto operace vrací nový líný
rámec, takže pokud se má výsledek vytisknout či jiným způsobem zpracovat, musí
následovat operace <strong>collect</strong>. Podívejme se na jednoduchý
příklad:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = polars.scan_csv("hall_of_fame.csv")
&nbsp;
<i># zobrazíme plán pro líně načtený datový rámec</i>
print(df.describe_plan())
print()
&nbsp;
<i># seskupení podle názvu jazyka</i>
df2 = (
    df.groupby("Winner", maintain_order=True)
    .agg([polars.col("Year").len().alias("Zvítězil")])
    .sort("Zvítězil")
    .reverse()
    <strong>.head(5)</strong>
)
&nbsp;
<i># převod prvků na běžný datový rámec</i>
df3 = df2.collect()
&nbsp;
<i># zobrazíme plán pro druhý líny datový rámec</i>
print(df2.describe_plan())
print()
&nbsp;
<i># zobrazíme běžný (výsledný) datový rámec</i>
print(df3)
print()
print(df3.columns)
print(df3.dtypes)
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto demonstračního
příkladu získáte na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_10_group_by_len_sort_reverse_head.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_10_group_by_len_sort_reverse_head.py</a>.</div></p>

<p>Nyní je zajímavé se podívat na plán, který nově obsahuje operaci
<strong>SLICE</strong>, která z&nbsp;líného datového rámce přečte pouze prvních
pět záznamů:</p>

<pre>
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
  <strong>SLICE[offset: 0, len: 5]</strong>
     LOCAL SELECT [col("Winner").reverse(), col("Zvítězil").reverse()] FROM
      SORT BY [col("Zvítězil")]
        Aggregate
                [col("Year").count().alias("Zvítězil")] BY [col("Winner")] FROM
                  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
</pre>

<p>A výsledný rámec bude vypadat takto:</p>

<pre>
shape: (5, 2)
┌─────────────┬──────────┐
│ Winner      ┆ Zvítězil │
│ ---         ┆ ---      │
│ str         ┆ u32      │
╞═════════════╪══════════╡
│ Python      ┆ 5        │
│ C           ┆ 3        │
│ Objective-C ┆ 2        │
│ Java        ┆ 2        │
│ Go          ┆ 2        │
└─────────────┴──────────┘
&nbsp;
['Winner', 'Zvítězil']
[Utf8, UInt32]
</pre>

<p>Operace <strong>head</strong> a <strong>tail</strong> je možné zřetězit, ale
zajímavé je, že nedojde k&nbsp;optimalizaci těchto operací do jediné operace
<strong>SLICE</strong> (alespoň ne v&nbsp;současné variantě knihovny
Polars):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = polars.scan_csv("hall_of_fame.csv")
&nbsp;
<i># zobrazíme plán pro líně načtený datový rámec</i>
print(df.describe_plan())
print()
&nbsp;
<i># seskupení podle názvu jazyka</i>
df2 = (
    df.groupby("Winner", maintain_order=True)
    .agg([polars.col("Year").len().alias("Zvítězil")])
    .sort("Zvítězil")
    .reverse()
    <strong>.head(10)</strong>
    <strong>.tail(5)</strong>
)
&nbsp;
<i># převod prvků na běžný datový rámec</i>
df3 = df2.collect()
&nbsp;
<i># zobrazíme plán pro druhý líny datový rámec</i>
print(df2.describe_plan())
print(df2.describe_optimized_plan())
print()
&nbsp;
<i># zobrazíme běžný (výsledný) datový rámec</i>
print(df3)
print()
print(df3.columns)
print(df3.dtypes)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
  <strong>SLICE[offset: -5, len: 5]</strong>
    <strong>SLICE[offset: 0, len: 10]</strong>
       LOCAL SELECT [col("Winner").reverse(), col("Zvítězil").reverse()] FROM
        SORT BY [col("Zvítězil")]
          Aggregate
                [col("Year").count().alias("Zvítězil")] BY [col("Winner")] FROM
                  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
  <strong>SLICE[offset: -5, len: 5]</strong>
    <strong>SLICE[offset: 0, len: 10]</strong>
       LOCAL SELECT [col("Winner").reverse(), col("Zvítězil").reverse()] FROM
        SORT BY [col("Zvítězil")]
          Aggregate
                [col("Year").count().alias("Zvítězil")] BY [col("Winner")] FROM
                  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
&nbsp;
shape: (5, 2)
┌──────────────┬──────────┐
│ Winner       ┆ Zvítězil │
│ ---          ┆ ---      │
│ str          ┆ u32      │
╞══════════════╪══════════╡
│ C++          ┆ 2        │
│ PHP          ┆ 1        │
│ Ruby         ┆ 1        │
│ Transact-SQL ┆ 1        │
│ JavaScript   ┆ 1        │
└──────────────┴──────────┘

['Winner', 'Zvítězil']
[Utf8, UInt32]
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Rozvětvení a opětovné spojení plánů</h2>

<p>V&nbsp;předchozím textu jsme si řekli, že může dojít k&nbsp;rozvětvení plánů
(z&nbsp;líného datového rámce je odvozeno více nových datových rámců aplikací
nějaké operace) nebo dokonce i ke spojení plánů. A právě tyto situace si
otestujeme v&nbsp;dnešním posledním demonstračním příkladu, v&nbsp;němž
z&nbsp;jediného zdrojového datového rámce <strong>df1</strong> aplikací různých
operací odvodíme plány <strong>df2</strong>, <strong>df3</strong>,
<strong>df4</strong> a <strong>df5</strong>. A nakonec tyto odvozené líné
datové rámce opět spojíme operací <strong>concat</strong> (tu jsme si sice
ještě nepopisovali, ale v&nbsp;našem případě dojde ke spojení rámců &bdquo;pod
sebou&ldquo;, protože všechny datové rámce mají stejné typy i názvy
sloupců):</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df1 = <strong>polars.scan_csv("hall_of_fame.csv")</strong>
&nbsp;
<i># seřazení podle zvoleného sloupce</i>
df2 = <strong>df1.sort("Year")</strong>
&nbsp;
<i># seřazení podle zvoleného sloupce</i>
df3 = <strong>df1.sort("Year").reverse()</strong>
&nbsp;
<i># seskupení podle názvu jazyka</i>
df4 = (
    <strong>df2.groupby("Winner", maintain_order=True)</strong>
    <strong>.agg([polars.col("Year").len().alias("Zvítězil")])</strong>
    <strong>.sort("Zvítězil")</strong>
)
&nbsp;
<i># otočení prvků + získání pěti výsledků</i>
df5 = <strong>df4.reverse().head(5)</strong>
&nbsp;
<i># spojení několika datových rámců - spojení plánů</i>
df6 = <strong>polars.concat([df2, df3, df4, df5], how="vertical")</strong>
&nbsp;
<i># zobrazíme plány pro všechny líné datové rámce</i>
print("df1")
print(df1.describe_plan())
print()
&nbsp;
print("df2")
print(df2.describe_plan())
print()
&nbsp;
print("df3")
print(df3.describe_plan())
print()
&nbsp;
print("df4")
print(df4.describe_plan())
print()
&nbsp;
print("df5")
print(df5.describe_plan())
print()
&nbsp;
print("df6")
print(df6.describe_plan())
print()
</pre>

<p>Po spuštění tohoto skriptu se všechny plány postupně vypíšou:</p>

<pre>
df1
  CSV SCAN hall_of_fame.csv
  PROJECT */2 COLUMNS
&nbsp;
&nbsp;
df2
  SORT BY [col("Year")]
    CSV SCAN hall_of_fame.csv
    PROJECT */2 COLUMNS
&nbsp;
&nbsp;
df3
   LOCAL SELECT [col("Year").reverse(), col("Winner").reverse()] FROM
    SORT BY [col("Year")]
      CSV SCAN hall_of_fame.csv
      PROJECT */2 COLUMNS
&nbsp;
&nbsp;
df4
  SORT BY [col("Zvítězil")]
    Aggregate
        [col("Year").count().alias("Zvítězil")] BY [col("Winner")] FROM
          SORT BY [col("Year")]
    CSV SCAN hall_of_fame.csv
    PROJECT */2 COLUMNS
&nbsp;
&nbsp;
df5
  SLICE[offset: 0, len: 5]
     LOCAL SELECT [col("Winner").reverse(), col("Zvítězil").reverse()] FROM
      SORT BY [col("Zvítězil")]
        Aggregate
                [col("Year").count().alias("Zvítězil")] BY [col("Winner")] FROM
                  SORT BY [col("Year")]
    CSV SCAN hall_of_fame.csv
    PROJECT */2 COLUMNS
</pre>

<p>Za povšimnutí stojí především poslední plán pro líný datový rámec
<strong>df6</strong>, protože tento plán vznikl sloučením (union) všech
předchozích plánů, což je z&nbsp;výsledku patrné:</p>

<pre>
df6
  RECHUNK
    UNION:
    PLAN 0:
      SORT BY [col("Year")]
        CSV SCAN hall_of_fame.csv
        PROJECT */2 COLUMNS
    PLAN 1:
       LOCAL SELECT [col("Year").reverse(), col("Winner").reverse()] FROM
        SORT BY [col("Year")]
          CSV SCAN hall_of_fame.csv
          PROJECT */2 COLUMNS
    PLAN 2:
      SORT BY [col("Zvítězil")]
        Aggregate
                [col("Year").count().alias("Zvítězil")] BY [col("Winner")] FROM
                  SORT BY [col("Year")]
    CSV SCAN hall_of_fame.csv
    PROJECT */2 COLUMNS
&nbsp;
    PLAN 3:
      SLICE[offset: 0, len: 5]
         LOCAL SELECT [col("Winner").reverse(), col("Zvítězil").reverse()] FROM
          SORT BY [col("Zvítězil")]
            Aggregate
                [col("Year").count().alias("Zvítězil")] BY [col("Winner")] FROM
                  SORT BY [col("Year")]
    CSV SCAN hall_of_fame.csv
    PROJECT */2 COLUMNS
&nbsp;
    END UNION
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vizualizace plánu</h2>

<p>Namísto metody <strong>describe_plan</strong> je možné plány operací nad
líným datovým rámcem zobrazit (resp.&nbsp;přesněji řečeno vizualizovat) metodou
<strong>show_graph</strong>. Pro tuto operaci je nutné mít nainstalovánu <a
href="https://www.root.cz/clanky/tvorba-grafu-v-jupyter-notebooku-s-vyuzitim-knihovny-matplotlib/">knihovnu
Matplotlib</a>. Skript z&nbsp;předchozí kapitoly nepatrně upravíme takovým
způsobem, že namísto tisku plánů na terminál je zobrazíme v&nbsp;grafickém
okně:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df1 = polars.scan_csv("hall_of_fame.csv")
&nbsp;
<i># seřazení podle zvoleného sloupce</i>
df2 = df1.sort("Year")
&nbsp;
<i># seřazení podle zvoleného sloupce</i>
df3 = df1.sort("Year").reverse()
&nbsp;
<i># seskupení podle názvu jazyka</i>
df4 = (
    df2.groupby("Winner", maintain_order=True)
    .agg([polars.col("Year").len().alias("Zvítězil")])
    .sort("Zvítězil")
)
&nbsp;
<i># otočení prvků + získání pěti výsledků</i>
df5 = df4.reverse().head(5)
&nbsp;
<i># spojení několika datových rámců - spojení plánů</i>
df6 = polars.concat([df2, df3, df4, df5], how="vertical")
&nbsp;
<i># zobrazíme plány pro všechny líné datové rámce</i>
<i># v grafické podobě</i>
df1.show_graph()
df2.show_graph()
df3.show_graph()
df4.show_graph()
df5.show_graph()
df6.show_graph()
</pre>

<p>Vizualizované výsledky vypadají následovně:</p>

<img src="https://i.iinfo.cz/images/170/polars-3-1.png" class="image-735745" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="390" />
<p><i>Obrázek 1: Vizualizovaný plán pro datový rámec #1.</i></p>

<img src="https://i.iinfo.cz/images/170/polars-3-2.png" class="image-735746" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="390" />
<p><i>Obrázek 2: Vizualizovaný plán pro datový rámec #2.</i></p>

<img src="https://i.iinfo.cz/images/170/polars-3-3.png" class="image-735747" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="390" />
<p><i>Obrázek 3: Vizualizovaný plán pro datový rámec #3.</i></p>

<img src="https://i.iinfo.cz/images/170/polars-3-4.png" class="image-735748" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="390" />
<p><i>Obrázek 4: Vizualizovaný plán pro datový rámec #4.</i></p>

<img src="https://i.iinfo.cz/images/170/polars-3-5.png" class="image-735749" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="826" />
<p><i>Obrázek 5: Vizualizovaný plán pro datový rámec #5.</i></p>

<img src="https://i.iinfo.cz/images/170/polars-3-6.png" class="image-735750" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="789" />
<p><i>Obrázek 6: Vizualizovaný plán pro datový rámec #5.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Vizualizace plánu s&nbsp;operacemi <strong>SLICE</strong></h2>

<p>Na závěr si ukažme, jak vypadá vizualizovaný plán, v&nbsp;němž jsou použity
operace <strong>SLICE</strong>:</p>

<pre>
<i>#!/usr/bin/env python3</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import polars
&nbsp;
<i># líné přečtení zdrojových dat</i>
df = <strong>polars.scan_csv("hall_of_fame.csv")</strong>
&nbsp;
<i># zobrazíme plán pro líně načtený datový rámec</i>
print(df.describe_plan())
print()
&nbsp;
<i># seskupení podle názvu jazyka</i>
df2 = (
    df.groupby("Winner", maintain_order=True)
    .agg([polars.col("Year").len().alias("Zvítězil")])
    .sort("Zvítězil")
    .reverse()
    .head(10)
    .tail(5)
)
&nbsp;
<i># zobrazíme plán pro druhý líny datový rámec</i>
<i># v grafické podobě</i>
<strong>df2.show_graph()</strong>
</pre>

<p>V&nbsp;tomto případě by se měl zobrazit tento diagram:</p>

<img src="https://i.iinfo.cz/images/170/polars-3-7.png" class="image-735751" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="812" />
<p><i>Obrázek 7: Vizualizovaný plán pro výsledný líný datový rámec.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah závěrečné části seriálu o knihovně Polars</h2>

<p>Ve čtvrté a současně i poslední části miniseriálu o knihovně <i>Pandas</i>
se budeme zabývat velmi častou operací &ndash; spojením dvou (nebo i
v&nbsp;případě potřeby většího množství) datových rámců. V&nbsp;knihovně Polars
je možné rámce spojit jak &bdquo;po řádcích&ldquo;, tak i &bdquo;po
sloupcích&ldquo; a popř.&nbsp;i vyřešit splynutí hodnot z&nbsp;těch sloupců,
které si logicky odpovídají. To však není vše, protože lze provést i operace
typu <strong>join</strong> (což je jméno převzaté ze SQL). K&nbsp;dispozici je
vnitřní join, levý join, pravý join i vnější join.</p>

<p><div class="rs-tip-major">Poznámka: mnohé z&nbsp;těchto operací probíhají
odlišným způsobem, než je tomu v&nbsp;knihovně <i>Pandas</i> a to
z&nbsp;jednoho prostého důvodu &ndash; <i>Polars</i> totiž (alespoň prozatím)
nepodporuje převod jednoho či většího množství sloupců na indexy. V&nbsp;této
knihovně je tedy každému záznamu přiřazen celočíselný index odpovídající pořadí
záznamu v&nbsp;datovém rámci. Při spojování je tudíž nutné namísto indexů
explicitně specifikovat sloupce obsahující odpovídající si hodnoty.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 (nikoli ovšem pro starší verze Pythonu 2!) byly
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>series_01_from_list.py</td><td>konstrukce datové řady ze seznamu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_01_from_list.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_01_from_list.py</a></td></tr>
<tr><td> 2</td><td>series_02_from_tuple.py</td><td>konstrukce datové řady z&nbsp;n-tice</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_02_from_tuple.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_02_from_tuple.py</a></td></tr>
<tr><td> 3</td><td>series_03_from_range.py</td><td>konstrukce datové řady generátorem <strong>range</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_03_from_range.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_03_from_range.py</a></td></tr>
<tr><td> 4</td><td>series_04_from_other_type.py</td><td>použití odlišných datových typů prvků v&nbsp;datové řadě</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_04_from_other_type.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_04_from_other_type.py</a></td></tr>
<tr><td> 5</td><td>series_05_strings.py</td><td>datová řada obsahující řetězce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_05_strings.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_05_strings.py</a></td></tr>
<tr><td> 6</td><td>series_06_booleans.py</td><td>datová řada obsahující pravdivostní hodnoty</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_06_booleans.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_06_booleans.py</a></td></tr>
<tr><td> 7</td><td>series_07_null_value.py</td><td>datová řada obsahující prvky s&nbsp;hodnotou <strong>null</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_07_null_value.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_07_null_value.py</a></td></tr>
<tr><td> 8</td><td>series_08_type_specification.py</td><td>explicitní specifikace datového typu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_08_type_specification.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_08_type_specification.py</a></td></tr>
<tr><td> 9</td><td>series_09_select.py</td><td>výběr prvků z&nbsp;datové řady pomocí indexu, indexů či řezu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_09_select.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_09_select.py</a></td></tr>
<tr><td>10</td><td>series_10_filter.py</td><td>výběr prvků z&nbsp;datové řady pomocí filtru (podmínky)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_10_filter.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_10_filter.py</a></td></tr>
<tr><td>11</td><td>series_11_from_arange.py</td><td>konstrukce datové řady s&nbsp;využitím <strong>numpy.arange</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_11_from_arange.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_11_from_arange.py</a></td></tr>
<tr><td>12</td><td>series_12_from_linspace.py</td><td>konstrukce datové řady s&nbsp;využitím <strong>numpy.linspace</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_12_from_linspace.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/series_12_from_linspace.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>data_frame_01_load_csv.py</td><td>načtení dat ze souboru typu CSV</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_01_load_csv.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_01_load_csv.py</a></td></tr>
<tr><td>14</td><td>data_frame_02_load_csv_no_header_A.py</td><td>práce se soubory typu CSV bez hlavičky (nekorektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_02_load_csv_no_header_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_02_load_csv_no_header_A.py</a></td></tr>
<tr><td>15</td><td>data_frame_03_load_csv_no_header_B.py</td><td>práce se soubory typu CSV bez hlavičky (korektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_03_load_csv_no_header_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_03_load_csv_no_header_B.py</a></td></tr>
<tr><td>16</td><td>data_frame_04_load_csv_no_header_C.py</td><td>práce se soubory typu CSV bez hlavičky (korektní varianta s&nbsp;explicitními jmény sloupců)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_04_load_csv_no_header_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_04_load_csv_no_header_B.py</a></td></tr>
<tr><td>17</td><td>data_frame_05_load_tsv_A.py</td><td>práce se soubory typu TSV (nekorektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_05_load_tsv_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_05_load_tsv_A.py</a></td></tr>
<tr><td>18</td><td>data_frame_06_load_tsv_B.py</td><td>práce se soubory typu TSV (korektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_06_load_tsv_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_06_load_tsv_B.py</a></td></tr>
<tr><td>19</td><td>data_frame_07_describe.py</td><td>získání metainformací o datovém rámci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_07_describe.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_07_describe.py</a></td></tr>
<tr><td>20</td><td>data_frame_08_timestamps_A.py</td><td>načtení dat obsahujících časová razítka</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_08_timestamps_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_08_timestamps_A.py</a></td></tr>
<tr><td>21</td><td>data_frame_09_timestamps_B.py</td><td>načtení dat obsahujících časová razítka</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_09_timestamps_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_09_timestamps_B.py</a></td></tr>
<tr><td>22</td><td>data_frame_10_load_sql_A.py</td><td>načtení dat z&nbsp;relační databáze s&nbsp;uložením výsledku ve formě datového rámce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_10_load_sql_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_10_load_sql_A.py</a></td></tr>
<tr><td>23</td><td>data_frame_11_load_sql_B.py</td><td>načtení dat z&nbsp;relační databáze s&nbsp;uložením výsledku ve formě datového rámce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_11_load_sql_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_11_load_sql_B.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>data_frame_12_head_A.py</td><td>zobrazení hlavičky datového rámce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_12_head_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_12_head_A.py</a></td></tr>
<tr><td>25</td><td>data_frame_13_head_B.py</td><td>zobrazení hlavičky datového rámce se specifikací počtu řádků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_13_head_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_13_head_B.py</a></td></tr>
<tr><td>26</td><td>data_frame_14_head_C.py</td><td>globální změna počtu zobrazených řádků u datového rámce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_14_head_C.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_14_head_C.py</a></td></tr>
<tr><td>27</td><td>data_frame_15_formatting_A.py</td><td>různé způsoby naformátování obsahu datových rámců</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_15_formatting_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_15_formatting_A.py</a></td></tr>
<tr><td>28</td><td>data_frame_16_formatting_B.py</td><td>různé způsoby naformátování obsahu datových rámců</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_16_formatting_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_16_formatting_B.py</a></td></tr>
<tr><td>29</td><td>data_frame_17_sort.py</td><td>seřazení údajů v&nbsp;datovém rámci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_17_sort.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_17_sort.py</a></td></tr>
<tr><td>30</td><td>data_frame_18_sort_reverse.py</td><td>zpětné seřazení údajů v&nbsp;datovém rámci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_18_sort_reverse.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_18_sort_reverse.py</a></td></tr>
<tr><td>31</td><td>data_frame_19_unique.py</td><td>zajištění unikátnosti záznamů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_19_unique.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_19_unique.py</a></td></tr>
<tr><td>32</td><td>data_frame_20_map_conversion.py</td><td>konverze dat ve sloupci s&nbsp;využitím metody <strong>map</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_20_map_conversion.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_20_map_conversion.py</a></td></tr>
<tr><td>33</td><td>data_frame_21_apply_conversion.py</td><td>konverze dat ve sloupci s&nbsp;využitím metody <strong>apply</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_21_apply_conversion.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_21_apply_conversion.py</a></td></tr>
<tr><td>34</td><td>data_frame_22_group_by.py</td><td>seskupení údajů na základě zvoleného sloupce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_22_group_by.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_22_group_by.py</a></td></tr>
<tr><td>35</td><td>data_frame_23_group_by_sort.py</td><td>seskupení a seřazení údajů při agregaci na základě hodnot ve zvoleném sloupci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_23_group_by_sort.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_23_group_by_sort.py</a></td></tr>
<tr><td>36</td><td>data_frame_23_group_by_sort_B.py</td><td>ukázka rozdílů mezi použitím a nepoužitím <strong>sort</strong> při agregaci</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_23_group_by_sort_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_23_group_by_sort_B.py</a></td></tr>
<tr><td>37</td><td>data_frame_24_sort_group_by_sort.py</td><td>kombinace <strong>sort</strong> a <strong>groupby</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_24_sort_group_by_sort.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_24_sort_group_by_sort.py</a></td></tr>
<tr><td>38</td><td>data_frame_25_group_by_len.py</td><td>jednoduchá agregace údajů při seskupení</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_25_group_by_len.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_25_group_by_len.py</a></td></tr>
<tr><td>39</td><td>data_frame_26_group_by_len_sort.py</td><td>jednoduchá agregace údajů při seskupení, kombinace se seřazením</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_26_group_by_len_sort.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_26_group_by_len_sort.py</a></td></tr>
<tr><td>40</td><td>data_frame_27_group_by_len_sort_reverse.py</td><td>jednoduchá agregace údajů při seskupení, kombinace se seřazením</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_27_group_by_len_sort_reverse.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_27_group_by_len_sort_reverse.py</a></td></tr>
<tr><td>41</td><td>data_frame_28_group_by_len_sort_reverse_head.py</td><td>kombinace předchozího s&nbsp;<strong>head</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_28_group_by_len_sort_reverse_head.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/data_frame_28_group_by_len_sort_reverse_head.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>42</td><td>lazy_frame_01_scan_csv.py</td><td>líné načtení dat ze souboru typu CSV</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_01_scan_csv.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_01_scan_csv.py</a></td></tr>
<tr><td>43</td><td>lazy_frame_02_read_csv_and_convert.py</td><td>načtení dat ze souboru typu CSV do datového rámce a konverze na líný datový rámec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_02_read_csv_and_convert.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_02_read_csv_and_convert.py</a></td></tr>
<tr><td>44</td><td>lazy_frame_03_collect_to_df.py</td><td>převod líného datového rámce na běžný datový rámec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_03_collect_to_df.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_03_collect_to_df.py</a></td></tr>
<tr><td>45</td><td>lazy_frame_04_lazy_sort.py</td><td>operace <strong>sort</strong> aplikovaná líně</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_04_lazy_sort.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_04_lazy_sort.py</a></td></tr>
<tr><td>46</td><td>lazy_frame_05_lazy_sort_reverse.py</td><td>dvojice operací <strong>sort</strong> + <strong>reverse</strong>, taktéž aplikovaných líně</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_05_lazy_sort_reverse.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_05_lazy_sort_reverse.py</a></td></tr>
<tr><td>47</td><td>lazy_frame_06_describe_plan.py</td><td>zobrazení informací o plánovaných operacích</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_06_describe_plan.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_06_describe_plan.py</a></td></tr>
<tr><td>48</td><td>lazy_frame_07_fetch.py</td><td>přečtení výseku dat z&nbsp;líného datového rámce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_07_fetch.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_07_fetch.py</a></td></tr>
<tr><td>49</td><td>lazy_frame_08_group_by.py</td><td>operace <strong>groupby</strong> následovaná agregací pro líný datový rámec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_08_group_by.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_08_group_by.py</a></td></tr>
<tr><td>50</td><td>lazy_frame_09_group_by_fetch_2.py</td><td>zjištění, jak vlastně přesně pracuje operace <strong>fetch</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_09_group_by_fetch_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_09_group_by_fetch_2.py</a></td></tr>
<tr><td>51</td><td>lazy_frame_10_group_by_len_sort_reverse_head.py</td><td>&bdquo;pipeline&ldquo; operací aplikovaných na líný datový rámec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_10_group_by_len_sort_reverse_head.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_10_group_by_len_sort_reverse_head.py</a></td></tr>
<tr><td>52</td><td>lazy_frame_11_branching.py</td><td>rozvětvení plánů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_11_branching.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_11_branching.py</a></td></tr>
<tr><td>53</td><td>lazy_frame_12_visualization.py</td><td>vizualizace plánů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_12_visualization.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_12_visualization.py</a></td></tr>
<tr><td>54</td><td>lazy_frame_13_head_tail.py</td><td>kombinace operací <strong>head</strong> a <strong>tail</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_13_head_tail.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_13_head_tail.py</a></td></tr>
<tr><td>55</td><td>lazy_frame_14_head_tail_visualization.py</td><td>kombinace operací <strong>head</strong> a <strong>tail</strong>, vizualizace výsledného plánu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_14_head_tail_visualization.py">https://github.com/tisnik/most-popular-python-libs/blob/master/polars/lazy_frame_14_head_tail_visualization.py</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>Projekt Polars na GitHubu<br />
<a href="https://github.com/pola-rs/polars">https://github.com/pola-rs/polars</a>
</li>

<li>Dokumentace k&nbsp;projektu Polars (popis API)<br />
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/index.html">https://pola-rs.github.io/polars/py-polars/html/reference/index.html</a>
</li>

<li>Polars: The Next Big Python Data Science Library... written in RUST? <br />
<a href="https://www.youtube.com/watch?v=VHqn7ufiilE">https://www.youtube.com/watch?v=VHqn7ufiilE</a>
</li>

<li>Polars API: funkce pro načtení datového rámce z&nbsp;CSV<br />
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.read_csv.html">https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.read_csv.html</a>
</li>

<li>Polars API: funkce pro načtení datového rámce z&nbsp;relační databáze<br />
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.read_sql.html">https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.read_sql.html</a>
</li>

<li>Python’s Pandas vs Polars: Who Wins this Fight in Library <br />
<a href="https://analyticsindiamag.com/pythons-pandas-vs-polars-who-wins-this-fight-in-library/">https://analyticsindiamag.com/pythons-pandas-vs-polars-who-wins-this-fight-in-library/</a>
</li>

<li>Polars vs Pandas: what is more convenient?<br />
<a href="https://medium.com/@ilia.ozhmegov/polars-vs-pandas-what-is-more-convenient-331956742a69">https://medium.com/@ilia.ozhmegov/polars-vs-pandas-what-is-more-convenient-331956742a69</a>
</li>

<li>A Gentle Introduction to Pandas Data Analysis (on Kaggle)<br />
<a href="https://www.youtube.com/watch?v=_Eb0utIRdkw&list=PL7RwtdVQXQ8oYpuIIDWR0SaaSCe8ZeZ7t&index=4">https://www.youtube.com/watch?v=_Eb0utIRdkw&list=PL7RwtdVQXQ8oYpuIIDWR0SaaSCe8ZeZ7t&amp;index=4</a>
</li>

<li>Speed Up Your Pandas Dataframes<br />
<a href="https://www.youtube.com/watch?v=u4_c2LDi4b8&list=PL7RwtdVQXQ8oYpuIIDWR0SaaSCe8ZeZ7t&index=5">https://www.youtube.com/watch?v=u4_c2LDi4b8&list=PL7RwtdVQXQ8oYpuIIDWR0SaaSCe8ZeZ7t&amp;index=5</a>
</li>

<li>pandas.read_csv<br />
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html</a>
</li>

<li>How to define format when using pandas to_datetime?<br />
<a href="https://stackoverflow.com/questions/36848514/how-to-define-format-when-using-pandas-to-datetime">https://stackoverflow.com/questions/36848514/how-to-define-format-when-using-pandas-to-datetime</a>
</li>

<li>Pandas : skip rows while reading csv file to a Dataframe using read_csv() in Python<br />
<a href="https://thispointer.com/pandas-skip-rows-while-reading-csv-file-to-a-dataframe-using-read_csv-in-python/">https://thispointer.com/pandas-skip-rows-while-reading-csv-file-to-a-dataframe-using-read_csv-in-python/</a>
</li>

<li>Skip rows during csv import pandas<br />
<a href="https://stackoverflow.com/questions/20637439/skip-rows-during-csv-import-pandas">https://stackoverflow.com/questions/20637439/skip-rows-during-csv-import-pandas</a>
</li>

<li>Denni kurz<br />
<a href="https://www.cnb.cz/cs/financni_trhy/devizovy_trh/kurzy_devizoveho_trhu/denni_kurz.txt">https://www.cnb.cz/cs/financni_trhy/devizovy_trh/kurzy_devizoveho_trhu/denni_kurz.txt</a>
</li>

<li>UUID objects according to RFC 4122 (knihovna pro Python)<br />
<a href="https://docs.python.org/3.5/library/uuid.html#uuid.uuid4">https://docs.python.org/3.5/library/uuid.html#uuid.uuid4</a>
</li>

<li>Object identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Object_identifier">https://en.wikipedia.org/wiki/Object_identifier</a>
</li>

<li>Digital object identifier (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Digital_object_identifier">https://en.wikipedia.org/wiki/Digital_object_identifier</a>
</li>

<li>voluptuous na (na PyPi)<br />
<a href="https://pypi.python.org/pypi/voluptuous">https://pypi.python.org/pypi/voluptuous</a>
</li>

<li>Repositář knihovny voluptuous na GitHubu<br />
<a href="https://github.com/alecthomas/voluptuous">https://github.com/alecthomas/voluptuous</a>
</li>

<li>pytest-voluptuous 1.0.2 (na PyPi)<br />
<a href="https://pypi.org/project/pytest-voluptuous/">https://pypi.org/project/pytest-voluptuous/</a>
</li>

<li>pytest-voluptuous (na GitHubu)<br />
<a href="https://github.com/F-Secure/pytest-voluptuous">https://github.com/F-Secure/pytest-voluptuous</a>
</li>

<li>schemagic 0.9.1 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schemagic/0.9.1">https://pypi.python.org/pypi/schemagic/0.9.1</a>
</li>

<li>Schemagic / Schemagic.web (na GitHubu)<br />
<a href="https://github.com/Mechrophile/schemagic">https://github.com/Mechrophile/schemagic</a>
</li>

<li>schema 0.6.7 (na PyPi)<br />
<a href="https://pypi.python.org/pypi/schema">https://pypi.python.org/pypi/schema</a>
</li>

<li>schema (na GitHubu)<br />
<a href="https://github.com/keleshev/schema">https://github.com/keleshev/schema</a>
</li>

<li>KX v DBOps Benchmark Results by Ferenc Bodon<br />
<a href="https://community.kx.com/t5/Community-Blogs/KX-v-DBOps-Benchmark-Results-by-Ferenc-Bodon/ba-p/12182">https://community.kx.com/t5/Community-Blogs/KX-v-DBOps-Benchmark-Results-by-Ferenc-Bodon/ba-p/12182</a>
</li>

<li>TIOBE Index for January 2023<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>Lazy evaluation<br />
<a href="https://en.wikipedia.org/wiki/Lazy_evaluation">https://en.wikipedia.org/wiki/Lazy_evaluation</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

