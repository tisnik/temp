<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy</a></p>
<p><a href="#k02">2. Statické typové kontroly</a></p>
<p><a href="#k03">3. Od čistě dynamicky typovaných jazyků k&nbsp;jazykům s&nbsp;volitelnými statickými typy</a></p>
<p><a href="#k04">4. Instalace nástroje Mypy</a></p>
<p><a href="#k05">5. Datový typ <strong>Any</strong>, přidání explicitních informací o typech</a></p>
<p><a href="#k06">6. Způsob překladu informace o datových typech do bajtkódu Pythonu</a></p>
<p><a href="#k07">7. Utilita pro výpis struktury bajtkódu</a></p>
<p><a href="#k08">8. Výsledek překladu do bajtkódu pro kód bez typových informací i s&nbsp;typovými informacemi</a></p>
<p><a href="#k09">9. Vztah typu <strong>bool</strong> a <strong>int</strong></a></p>
<p><a href="#k10">10. Datový typ seznam</a></p>
<p><a href="#k11">11. Rozdíly mezi Pythonem 3.10 a předchozími verzemi</a></p>
<p><a href="#k12">*** 12. Datový typ n-tice</a></p>
<p><a href="#k13">*** 13. Zobrazení typových anotací funkcí</a></p>
<p><a href="#k14">14. Kdy statická typová kontrola selže?</a></p>
<p><a href="#k15">15. Rozdíly v&nbsp;typových systémech: variance</a></p>
<p><a href="#k16">16. Jak je tomu v&nbsp;Javě?</a></p>
<p><a href="#k17">17. Chování Pythonu při práci se seznamy s&nbsp;typem</a></p>
<p><a href="#k18">18. Použití typu <strong>Sequence</strong> namísto typu <strong>List</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy</h2>

<p><i>&bdquo;If it walks like a duck, and talks like a duck, then it is a duck&ldquo;</i></p>

<p></p>

*** image ***
<p><i>Logo nástroje Mypy naznačuje použitou syntaxi při zápisu datových typů.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Statické typové kontroly</h2>

<p>Myšlenka, na níž stojí statická typová kontrola, je snadno pochopitelná,
protože se do značné míry podobá dalším analýzám kódu (které provádí překladač,
lintery atd.). Celá myšlenka je založena na tom, že u každé proměnné
deklarované v&nbsp;programu, u každého parametru funkce a taktéž u každého
návratového parametru funkce se přímo či nepřímo uvede datový typ (nepřímo
v&nbsp;případě, že jazyk umí typ odvodit z&nbsp;použité hodnoty &ndash; jedná
se o takzvanou <i>typovou inferenci</i>). Díky tomu, že je specifikace typu
proměnné/parametru/návratové hodnoty dostupná přímo ve formě zdrojového kódu,
může být typová kontrola skutečně statická &ndash; nevyžaduje tedy, aby se
program spustil. To má své nesporné výhody, protože takto specifikované
informace o typech dokáží zpracovat i moderní (a nejenom moderní) integrovaná
vývojová prostředí, která ji mohou použít v&nbsp;kontextové nápovědě atd.</p>

<p>Ovšem současně zde narážíme na značnou nevýhodu: je velmi složité vytvořit
snadno použitelný a současně i staticky typovaný programovací jazyk. A další
nevýhodou je, že zápis datových typů je vyžadován i v&nbsp;případě, že se tvoří
jednoduché skripty nebo prototypy. Proto není divu, že mnoho jazyků (a nutno
říci, že mnohdy velmi úspěšných jazyků) striktní zápis datových typů nevyžaduje
a tím pádem nebude (zcela) dostupná statická typová kontrola.</p>

<p><div class="rs-tip-major">Poznámka: u staticky typovaných programovacích
jazyků provádí základní typové kontroly už samotný překladač. Ovšem jak uvidíme
v&nbsp;dalším textu, v&nbsp;závislosti na použitém typovém systému (různé typy
variance atd.) se může stát, že některé typové kontroly musí být přesunuty
z&nbsp;času překladu (<i>compile time</i>) do času běhu aplikace
(<i>runtime</i>).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Od čistě dynamicky typovaných jazyků k&nbsp;jazykům s&nbsp;volitelnými statickými typy</h2>

<p>Pokud se podíváme na seznam v&nbsp;současnosti nejpopulárnějších a
nejpoužívanějších programovacích jazyků, nalezneme zde jak typické zástupce
dynamicky typovaných jazyků, tak i zástupce jazyků se statickými typy:</p>

<table>
<tr><th>Dynamicky typovaný</th><th>Staticky typovaný</th></tr>
<tr><td>Python</td><td>C</td></tr>
<tr><td>JavaScript</td><td>C++</td></tr>
<tr><td>Ruby</td><td>Go</td></tr>
<tr><td>Perl</td><td>Rust</td></tr>
<tr><td>Matlab</td><td>Java</td></tr>
<tr><td>PHP</td><td>Scala</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: druhou, nezávislou osou, by bylo
rozdělení podle toho, zda je typový systém silný, či slabý.</div></p>

<p>Zaměřme se nyní na první tři zmíněné dynamicky typované programovací jazyky,
tedy na Python, JavaScript a Ruby. Tyto jazyky se původně používaly na krátké
skripty (v&nbsp;případě JavaScriptu běžící v&nbsp;rámci stránky prohlížeče),
ovšem postupně se rozšířily i do mnoha dalších oblastí, takže v&nbsp;nich
začaly vznikat i velmi rozsáhlé aplikace. A právě u rozsáhlejších aplikací se
začal ukazovat význam staticky zapisovaných a taktéž staticky kontrolovaných
datových typů. Proto pro tyto programovací jazyky postupně vznikla rozšíření,
která do nich přidává volitelný zápis datových typů. A tato rozšíření umožňují
statickou kontrolu datových typů s&nbsp;využitím k&nbsp;tomu určených
nástrojů:</p>

<table>
<tr><th>Původní jazyk</th><th>Rozšíření o statické datové typy</th></tr>
<tr><td>JavaScript</td><td><a href="https://www.typescriptlang.org/">TypeScript</a>, <a href="https://flow.org/">Flow</a></td></tr>
<tr><td>Python</td><td><a href="https://www.mypy-lang.org/">mypy</a>, <a href="https://github.com/microsoft/pyright">Pyright</a>, <a href="https://pyre-check.org/">Pyre</a></td></tr>
<tr><td>Ruby</td><td><a href="https://sorbet.org/">Sorbet</a></td></tr>
</table>

<p>V&nbsp;dnešním článku se zaměříme na nástroj Mypy určený pro statickou
typovou kontrolu zdrojových kódů psaných v&nbsp;Pythonu, ovšem současně si
budeme muset popsat i základní vlastnosti <a
href="https://peps.python.org/pep-0484/">typových anotací</a>, které je možné
v&nbsp;Pythonu používat (od verze 3.5, ve verzi 3.10 pak došlo
k&nbsp;vylepšením). Již na začátku je nutné připomenout, že Python stále
zůstává dynamicky typovaným jazykem a typové anotace jsou sice součástí
specifikace jazyka, ale nejsou striktně vyžadovány (a u krátkých skriptů podle
mého názoru většinou i postrádají smysl).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace nástroje Mypy</h2>

<p>Nástroj Mypy není součástí standardní instalace Pythonu a proto ho je nutné
explicitně nainstalovat. Samotná instalace je snadná (předpokladem je, že je
již nainstalován Python 3.5 či vyšší):</p>

<pre>
$ <strong>pip3 install --user mypy</strong>
&nbsp;
Collecting mypy
  Downloading mypy-1.3.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (12.2 MB)
     |████████████████████████████████| 12.2 MB 779 kB/s 
Requirement already satisfied: typing-extensions&gt;=3.10 in ./.local/lib/python3.8/site-packages (from mypy) (4.4.0)
Collecting tomli&gt;=1.1.0; python_version &lt; "3.11"
  Downloading tomli-2.0.1-py3-none-any.whl (12 kB)
Collecting mypy-extensions&gt;=1.0.0
  Downloading mypy_extensions-1.0.0-py3-none-any.whl (4.7 kB)
Installing collected packages: tomli, mypy-extensions, mypy
Successfully installed mypy-1.3.0 mypy-extensions-1.0.0 tomli-2.0.1
</pre>

<p>Většinou je ovšem ještě nutné provést upgrade balíčku nazvaného
<strong>typing_extensions</strong>:</p>

<pre>
$ pip3 install --upgrade --user typing_extensions
&nbsp;
Collecting typing_extensions
  Downloading typing_extensions-4.6.3-py3-none-any.whl (31 kB)
Installing collected packages: typing-extensions
  Attempting uninstall: typing-extensions
    Found existing installation: typing-extensions 4.4.0
    Uninstalling typing-extensions-4.4.0:
      Successfully uninstalled typing-extensions-4.4.0
Successfully installed typing-extensions-4.6.3
</pre>

<p>Otestování, zda je Mypy spustitelný:</p>

<pre>
$ <strong>mypy --version</strong>
&nbsp;
mypy 1.3.0 (compiled: yes)
</pre>

<p>Pochopitelně si můžeme nechat zobrazit i (dlouhou) nápovědu:</p>

<pre>
$ <strong>mypy --help</strong>
&nbsp;
usage: mypy [-h] [-v] [-V] [more options; see below]
            [-m MODULE] [-p PACKAGE] [-c PROGRAM_TEXT] [files ...]
&nbsp;
Mypy is a program that will type check your Python code.
&nbsp;
Pass in any files or folders you want to type check. Mypy will
recursively traverse any provided folders to find .py files:
&nbsp;
    $ mypy my_program.py my_src_folder
&nbsp;
For more information on getting started, see:
...
...
...
Running code:
  Specify the code you want to type check. For more details, see
  mypy.readthedocs.io/en/stable/running_mypy.html#running-mypy
&nbsp;
  --explicit-package-bases  Use current directory and MYPYPATH to determine
                            module names of files passed (inverse: --no-
                            explicit-package-bases)
  --exclude PATTERN         Regular expression to match file names, directory
                            names or paths which mypy should ignore while
                            recursively discovering files to check, e.g.
                            --exclude '/setup\.py$'. May be specified more
                            than once, eg. --exclude a --exclude b
  -m MODULE, --module MODULE
                            Type-check module; can repeat for more modules
  -p PACKAGE, --package PACKAGE
                            Type-check package recursively; can be repeated
  -c PROGRAM_TEXT, --command PROGRAM_TEXT
                            Type-check program passed in as string
  files                     Type-check given files or directories
&nbsp;
Environment variables:
  Define MYPYPATH for additional module search path entries.
  Define MYPY_CACHE_DIR to override configuration cache_dir path.
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Datový typ <strong>Any</strong>, přidání explicitních informací o typech</h2>

<p>Základní vlastnosti nástroje si můžeme otestovat na triviálním příkladu
&ndash; funkci, která sečte své dva parametry, přičemž termín
&bdquo;sečte&ldquo; má v&nbsp;tomto kontextu mnoho významů (&bdquo;spojí&ldquo;
atd.) kvůli tomu, že funkce nijak neomezuje typy parametrů ani typ návratové
hodnoty:</p>

<pre>
def <strong>add</strong>(a, b):
    return a+b
</pre>

<p>Výsledek statické kontroly nástrojem Mypy může být možná poněkud
překvapující, protože se nenalezne žádný problém:</p>

<pre>
$ <strong>mypy adder1.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p>Je tomu tak z&nbsp;toho důvodu, že si Mypy &bdquo;domyslí&ldquo;, že
parametry neudaného typu i návratové hodnoty bez zadaného typu mají ve
skutečnosti typ <strong>Any</strong>.</p>

<p>Ovšem můžeme taktéž povolit striktní typovou kontrolu, která již tuto
zkratku neumožní:</p>

<pre>
$ <strong>mypy --strict adder1.py</strong>
&nbsp;
adder1.py:1: error: Function is missing a type annotation  [no-untyped-def]
Found 1 error in 1 file (checked 1 source file)
</pre>

<p>Zkusme si nyní kód funkce upravit tak, aby byla silně typovaná.
Tj.&nbsp;explicitně budeme specifikovat jak typy obou parametrů, tak i typ
návratové hodnoty funkce. Povšimněte si způsobu zápisu:</p>

<pre>
def <strong>add</strong>(a:int, b:int) -&gt; int:
    return a+b
</pre>

<p>Nyní proběhne statická typová kontrola (opět) bez chyby:</p>

<pre>
$ <strong>mypy adder2.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p>A dokonce ani striktní typová kontrola již žádnou chybu nenalezne:</p>

<pre>
$ <strong>mypy --strict adder2.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Způsob překladu informace o datových typech do bajtkódu Pythonu</h2>

<p>V&nbsp;dalším textu si ukážeme, jakým způsobem se vlastně informace o
datových typech zařadí do bajtkódu Pythonu. Nejprve si vynutíme překlad obou
výše uvedených příkladů (první bez explicitní specifikace typů, druhý se
specifikací typů) do souborů s&nbsp;koncovkou .pyc, které obsahují bajtkód
příkladů:</p>

<pre>
$ <strong>python3 -m compileall adder1.py</strong>
&nbsp;
Compiling 'adder1.py'...
</pre>

<p>a:</p>

<pre>
$ <strong>python3 -m compileall adder2.py</strong>
&nbsp;
Compiling 'adder2.py'...
</pre>

<p>Výsledkem by měla být dvojice souborů uložená v&nbsp;nově vytvořeném
podadresáři &bdquo;__pycache__&ldquo;:</p>

<pre>
$ <strong>ls -l __pycache__/</strong>
&nbsp;
total 24
-rw-rw-r-- 1 ptisnovs ptisnovs 200 Jun 13 08:47 adder1.cpython-38.pyc
-rw-rw-r-- 1 ptisnovs ptisnovs 235 Jun 13 08:47 adder2.cpython-38.pyc
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Utilita pro výpis struktury bajtkódu</h2>

<p>Pro výpis struktury bajtkódu, tedy obsahu souborů s&nbsp;koncovkou .pyc,
kupodivu neexistuje žádný standardní nástroj. Z&nbsp;tohoto důvodu využijeme
skript, jehož základy jsem zkopíroval ze StackOverflow (což dělám tak jednou za
rok :-) a upravil takovým způsobem, aby se vypisoval i obsah <i>constant
poolu</i>:</p>

<pre>
<i># Based on code snippets mentioned on following page:</i>
<i># https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</i>
&nbsp;
<i># Original authors:</i>
<i># https://stackoverflow.com/users/6003870/padymko</i>
<i># https://stackoverflow.com/users/5065946/powersource97</i>
&nbsp;
import sys
import struct
import marshal
import binascii
import time
import dis
import platform
import types
&nbsp;
def <strong>view_pyc_file</strong>(path):
    <i>"""Read and display a content of the Python`s bytecode in a pyc-file."""</i>
&nbsp;
    with open(path, 'rb') as file:
&nbsp;
        magic = file.read(4)
        bit_field = None
        timestamp = None
        hashstr = None
        size = None
&nbsp;
        if sys.version_info.major == 3 and sys.version_info.minor &gt;= 7:
            bit_field = int.from_bytes(file.read(4), byteorder=sys.byteorder)
            if 1 &amp; bit_field == 1:
                hashstr = file.read(8)
            else:
                timestamp = file.read(4)
                size = file.read(4)
                size = struct.unpack('I', size)[0]
        elif sys.version_info.major == 3 and sys.version_info.minor &gt;= 3:
            timestamp = file.read(4)
            size = file.read(4)
            size = struct.unpack('I', size)[0]
        else:
            timestamp = file.read(4)
&nbsp;
        code = marshal.load(file)
&nbsp;
    magic = binascii.hexlify(magic).decode('utf-8')
    timestamp = time.asctime(time.localtime(struct.unpack('I', timestamp)[0]))
&nbsp;
    dis.disassemble(code)
&nbsp;
    print('-' * 80)
&nbsp;
    <i># print constant pool</i>
    for i, const in enumerate(code.co_consts):
        print(i, "\t"+str(const) + "\t" + str(type(const)))
        <i># constant pool contains function/method bytecode, so let's try to disassemble it</i>
        try:
            dis.disassemble(const)
        except:
            pass
&nbsp;
    print('-' * 80)
    print(
        'Python version: {}\nMagic code: {}\nTimestamp: {}\nSize: {}\nHash: {}\nBitfield: {}'
        .format(platform.python_version(), magic, timestamp, size, hashstr, bit_field)
    )
&nbsp;
if __name__ == '__main__':
    view_pyc_file(sys.argv[1])
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výsledek překladu do bajtkódu pro kód bez typových informací i s&nbsp;typovými informacemi</h2>

<p>Zkusme tedy prozkoumat bajtkód obou variant funkcí <strong>add</strong>.
Nejprve se podívejme na první variantu, v&nbsp;níž nejsou explicitně uvedeny
žádné typové informace:</p>

<pre>
  1           0 LOAD_CONST               0 (&lt;code object add at 0x7f90e76385b0, file "adder1.py", line 1&gt;)
              2 LOAD_CONST               1 ('add')
              4 MAKE_FUNCTION            0
              6 STORE_NAME               0 (add)
              8 LOAD_CONST               2 (None)
             10 RETURN_VALUE
--------------------------------------------------------------------------------
0        &lt;code object add at 0x7f90e76385b0, file "adder1.py", line 1&gt;
  2           0 LOAD_FAST                0 (a)
              2 LOAD_FAST                1 (b)
              4 BINARY_ADD
              6 RETURN_VALUE
1        add
2        None
--------------------------------------------------------------------------------
Python version: 3.8.10
Magic code: 550d0d0a
Timestamp: Thu Jun  8 15:36:13 2023
Size: 30
Hash: None
Bitfield: 0
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že instrukce tvořící tělo
funkce <strong>add</strong> jsou umístěny jako konstanta (s&nbsp;indexem 0),
ovšem zajímavější je zařazení funkce do skriptu: jedná se o první tři instrukce
bajtkódu, které pouze načtou bajtkód funkce, její jméno a vytvoří z&nbsp;této
dvojice novou hodnotu typu &bdquo;funkce&ldquo;:</div></p>

<pre>
  1           0 LOAD_CONST               0 (&lt;code object add at 0x7f90e76385b0, file "adder1.py", line 1&gt;)
              2 LOAD_CONST               1 ('add')
              4 MAKE_FUNCTION            0
</pre>

<p>Druhá varianta:</p>

<pre>
  1           0 LOAD_NAME                0 (int)
              2 LOAD_NAME                0 (int)
              4 LOAD_NAME                0 (int)
              6 LOAD_CONST               0 (('a', 'b', 'return'))
              8 BUILD_CONST_KEY_MAP      3
             10 LOAD_CONST               1 (&lt;code object add at 0x7ff3987475b0, file "adder2.py", line 1&gt;)
             12 LOAD_CONST               2 ('add')
             14 MAKE_FUNCTION            4 (annotations)
             16 STORE_NAME               1 (add)
             18 LOAD_CONST               3 (None)
             20 RETURN_VALUE
--------------------------------------------------------------------------------
0        ('a', 'b', 'return')
1        &lt;code object add at 0x7ff3987475b0, file "adder2.py", line 1&gt;
  2           0 LOAD_FAST                0 (a)
              2 LOAD_FAST                1 (b)
              4 BINARY_ADD
              6 RETURN_VALUE
2        add
3        None
--------------------------------------------------------------------------------
Python version: 3.8.10
Magic code: 550d0d0a
Timestamp: Thu Jun  8 15:36:25 2023
Size: 45
Hash: None
Bitfield: 0
</pre>

<p>Pro druhou variantu funkce <strong>add</strong> můžeme vidět naprosto stejný
bajtkód (tedy tělo funkce zůstává nezměněno!), ovšem mění se způsob definice
funkce &ndash; před instrukci <strong>MAKE_FUNCTION</strong> je umístěna
instrukce <strong>BUILD_CONST_KEY_MAP</strong>, která zpracuje informace o
typech:</p>

<pre>
  1           0 LOAD_NAME                0 (int)
              2 LOAD_NAME                0 (int)
              4 LOAD_NAME                0 (int)
              6 LOAD_CONST               0 (('a', 'b', 'return'))
              8 BUILD_CONST_KEY_MAP      3
</pre>

<p>Druhou část již známe, ovšem je zde jedna změna &ndash;
<strong>MAKE_FUNCTION</strong> nyní vytvoří funkci s&nbsp;typovými
anotacemi:</p>

<pre>
             10 LOAD_CONST               1 (&lt;code object add at 0x7ff3987475b0, file "adder2.py", line 1&gt;)
             12 LOAD_CONST               2 ('add')
             14 MAKE_FUNCTION            4 (annotations)

</pre>

<p><div class="rs-tip-major">Poznámka: opět zdůrazním &ndash; tělo funkce se
nezmění, proto v&nbsp;runtime bude funkce stále akceptovat parametry
libovolného typu!</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vztah typu <strong>bool</strong> a <strong>int</strong></h2>

<p>V&nbsp;programovacím jazyku Python existuje (na tak vysokoúrovňový jazyk)
poněkud zvláštní vztah mezi datovými typy <strong>bool</strong> a
<strong>int</strong>.  Hodnoty <strong>True</strong> a <strong>False</strong>
jsou totiž považovány za ekvivalentní hodnotám <strong>1</strong> a
<strong>0</strong>, což například znamená, že následující demonstrační příklad
bude vyhodnocen jako korektní z&nbsp;hlediska použití datových typů:</p>

<pre>
def <strong>add</strong>(a:int, b:int) -&gt; int:
    return a+b
&nbsp;
print(add(1, 2))
print(add(1, True))
print(add(1, False))
</pre>

<p>Jak běžná, tak i striktní typová kontrola neodhalí v&nbsp;tomto kódu žádné
problémy:</p>

<pre>
$ <strong>mypy adder3.py</strong>
&nbsp;
Success: no issues found in 1 source file
&nbsp;
&nbsp;
&nbsp;
$ <strong>mypy --strict adder3.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p>Zajímavé bude zjistit, jak vlastně vypadá bajtkód a tabulka konstant
v&nbsp;tomto příkladu. Nejprve si tedy vynutíme jeho překlad do bajtkódu:</p>

<pre>
$ <strong>python3 -m compileall adder3.py</strong>
&nbsp;
Compiling 'adder3.py'...
</pre>

<p>Výsledek bude vypadat následovně. Povšimněte si, že se při volání funkce
hodnoty předávaných parametrů načítají do zásobníku instrukcí
<strong>LOAD_CONST</strong>, takže důležitý je obsah tabulky konstant:</p>

<pre>
  1           0 LOAD_NAME                0 (int)
              2 LOAD_NAME                0 (int)
              4 LOAD_NAME                0 (int)
              6 LOAD_CONST               0 (('a', 'b', 'return'))
              8 BUILD_CONST_KEY_MAP      3
             10 LOAD_CONST               1 (&lt;code object add at 0x7f413d3d25b0, file "adder3.py", line 1&gt;)
             12 LOAD_CONST               2 ('add')
             14 MAKE_FUNCTION            4 (annotations)
             16 STORE_NAME               1 (add)
&nbsp;
  4          18 LOAD_NAME                2 (print)
             20 LOAD_NAME                1 (add)
             22 LOAD_CONST               3 (1)
             24 LOAD_CONST               4 (2)
             26 CALL_FUNCTION            2
             28 CALL_FUNCTION            1
             30 POP_TOP
&nbsp;
  5          32 LOAD_NAME                2 (print)
             34 LOAD_NAME                1 (add)
             36 LOAD_CONST               3 (1)
             38 LOAD_CONST               5 (True)
             40 CALL_FUNCTION            2
             42 CALL_FUNCTION            1
             44 POP_TOP
&nbsp;
  6          46 LOAD_NAME                2 (print)
             48 LOAD_NAME                1 (add)
             50 LOAD_CONST               3 (1)
             52 LOAD_CONST               6 (False)
             54 CALL_FUNCTION            2
             56 CALL_FUNCTION            1
             58 POP_TOP
             60 LOAD_CONST               7 (None)
             62 RETURN_VALUE
</pre>

<p>Po instrukcích bajtkódu následuje již zmíněná tabulka konstant.
V&nbsp;prvním sloupci je číslo konstanty (použité u instrukce
<strong>LOAD_CONST</strong>), ve druhém sloupci její hodnota (a nepřímo taktéž
typ):</p>

<pre>
--------------------------------------------------------------------------------
0        ('a', 'b', 'return')
1        &lt;code object add at 0x7f413d3d25b0, file "adder3.py", line 1&gt;
2        add
3        1
4        2
5        True
6        False
7        None
--------------------------------------------------------------------------------
Python version: 3.8.10
Magic code: 550d0d0a
Timestamp: Thu Jun  8 17:13:13 2023
Size: 104
Hash: None
Bitfield: 0
</pre>

<p>Naopak ovšem vztah <strong>bool</strong> a <strong>int</strong> neplatí:</p>

<pre>
def <strong>add</strong>(a:bool, b:bool) -&gt; bool:
    return a and b
&nbsp;
print(add(1, 2))
print(add(1, True))
print(add(1, False))
print(add(True, False))
</pre>

<p>Mypy nyní nalezne hned několik chyb:</p>

<pre>
adder4.py:4: error: Argument 1 to "add" has incompatible type "int"; expected "bool"  [arg-type]
adder4.py:4: error: Argument 2 to "add" has incompatible type "int"; expected "bool"  [arg-type]
adder4.py:5: error: Argument 1 to "add" has incompatible type "int"; expected "bool"  [arg-type]
adder4.py:6: error: Argument 1 to "add" has incompatible type "int"; expected "bool"  [arg-type]
Found 4 errors in 1 file (checked 1 source file)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Datový typ seznam</h2>

<p>Velmi důležitým datovým typem programovacího jazyka Python je seznam
(<i>list</i>). U proměnných či parametrů typu seznam lze specifikovat nejenom
to, že se jedná o seznam (to je neúplná typová informace), ale též typ hodnot
prvků tohoto seznamu. V&nbsp;následujícím demonstračním příkladu je ukázána
deklarace proměnné <strong>l</strong>, která je typu &bdquo;seznam prvků typu
int&ldquo;. Současně je proměnná ihned inicializována tak, že obsahuje prázdný
seznam (či spíše obsahuje referenci na prázdný seznam):</p>

<pre>
from typing import List
&nbsp;
l: List[int] = []
</pre>

<p>Typová kontrola tohoto dvouřádkového příkladu dopadne následovně:</p>

<pre>
$ <strong>mypy list_type2.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p>Samozřejmě nám nic nebrání v&nbsp;tom, aby se při inicializaci použily
hodnoty jednotlivých prvků:</p>

<pre>
from typing import List
&nbsp;
l: List[int] = [1, 2, 3]
</pre>

<p>Typová kontrola:</p>

<pre>
$ <strong>mypy list_type3.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p>Samotný Python nám umožňuje jako prvky seznamu použít libovolné hodnoty
(tudíž bude následující skript spustitelný), ovšem statická typová analýza
odhalí, že hodnota <strong>None</strong> do seznamu nepatří:</p>

<pre>
from typing import List
&nbsp;
l: List[int] = [1, 2, None]
</pre>

<p>Typová kontrola:</p>

<pre>
$ <strong>mypy list_type4.py </strong>
&nbsp;
list_type4.py:3: error: List item 2 has incompatible type "None"; expected "int"  [list-item]
Found 1 error in 1 file (checked 1 source file)
</pre>

<p>A opět se podívejme na to, jak je typovou analýzou řešen vztah mezi typy
<strong>bool</strong> a <strong>int</strong>:</p>

<pre>
from typing import List
&nbsp;
l: List[int] = [1, True, False]
</pre>

<p>Typová kontrola:</p>

<pre>
$ <strong>mypy list_type5.py</strong>
Success: no issues found in 1 source file
</pre>

<p>A naopak:</p>

<pre>
from typing import List
&nbsp;
l: List[bool] = [True, False, 42]
</pre>

<p>Typová kontrola nyní nalezne, podle očekávání, problém:</p>

<pre>
$ <strong>mypy list_type6.py</strong>
&nbsp;
list_type6.py:3: error: List item 2 has incompatible type "int"; expected "bool"  [list-item]
Found 1 error in 1 file (checked 1 source file)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rozdíly mezi Pythonem 3.10 a předchozími verzemi</h2>

<p>V&nbsp;Pythonu 3.10 došlo k&nbsp;vylepšení &ndash; u seznamů (ale i
například u n-tic atd.) se již nemusí při uvádění typů používat speciální jména
explicitně importovaná z&nbsp;modulu <strong>typing</strong>, tedy například
<strong>List</strong>, <strong>Tuple</strong> atd. Namísto toho lze při
specifikaci typu seznamu (včetně typu jeho prvků) použít <strong>list</strong>,
což je jméno standardní třídy, kterou není zapotřebí nijak importovat. Celý
zápis se tak zkrátí na pouhý jediný řádek:</p>

<pre>
l: list[int] = []
</pre>

<p>popř.:</p>

<pre>
l: list[int] = [1, 2, 3]
</pre>

<p>Pozor ovšem na to, že Mypy pro starší verze Pythonu nalezne v&nbsp;těchto
příkladech chyby:</p>

<pre>
list_type1.py:1: error: "list" is not subscriptable, use "typing.List" instead  [misc]
Found 1 error in 1 file (checked 1 source file)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Datový typ n-tice</h2>

<p>Zatímco u seznamů byla specifikace typu poměrně snadná, protože se pouze
musel určit typ <i>všech</i> prvků seznamu, je tomu u n-tic (<i>tuple</i>)
jinak, protože n-tice se (mj.) používají ve funkci záznamů (<i>record</i>).
Proto je zde možné explicitně určit typ všech jejich prvků. Ostatně si to
vyzkoušejme na několika příkladech.</p>

<pre>
from typing import Tuple
&nbsp;
p: Tuple[int] = (1, 2, 3)
</pre>

<p></p>

<pre>
tuple_type1.py:3: error: Incompatible types in assignment (expression has type "Tuple[int, int, int]", variable has type "Tuple[int]")  [assignment]
Found 1 error in 1 file (checked 1 source file)
</pre>

<pre>
from typing import Tuple
&nbsp;
p: Tuple[int, int, int] = (1, 2, 3)
</pre>

<pre>
from typing import Tuple
&nbsp;
p: Tuple[int, float, bool, str] = (1, 3.14, True, "Hello")
</pre>

<pre>
from typing import Tuple
&nbsp;
p: Tuple[int, float, bool, str] = (2.0, 3.14, 1, "Hello")
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zobrazení typových anotací funkcí</h2>

<p></p>

<pre>
def <strong>add</strong>(a, b):
    return a+b
&nbsp;
&nbsp;
print(add.__annotations__)
</pre>

<pre>
{}
</pre>

<pre>
def <strong>add</strong>(a:int, b:int) -&gt; int:
    return a+b
&nbsp;
&nbsp;
print(add.__annotations__)
</pre>

<pre>
{'a': &lt;class 'int'&gt;, 'b': &lt;class 'int'&gt;, 'return': &lt;class 'int'&gt;}
</pre>

<pre>
from typing import List, Set
&nbsp;
def <strong>add</strong>(a:List[Set[int]], b:List[Set[int]]) -&gt; List[Set[int]]:
    return a+b
&nbsp;
&nbsp;
print(add.__annotations__)
</pre>

<pre>
{'a': typing.List[typing.Set[int]], 'b': typing.List[typing.Set[int]], 'return': typing.List[typing.Set[int]]}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Kdy statická typová kontrola selže?</h2>

<p>Mohlo by se zdát, že statická typová kontrola tak, jak je implementována
v&nbsp;nástroji Mypy, dokáže nalézt všechny potenciální problémy související
s&nbsp;typy. Ve skutečnosti tomu tak není a u jazyků typu Python ani být
nemůže, protože proměnné lze modifikovat za běhu, a to kódem, o kterém statický
analyzátor nemůže nic vědět. Ukažme si to na příkladech.</p>

<p>Následující zdrojový kód je plně staticky analyzovatelný (a korektní):</p>

<pre>
x = 21
&nbsp;
&nbsp;
def <strong>adder</strong>(a:int, b:int) -&gt; int:
    return a+b
&nbsp;
&nbsp;
print(adder(x,x))
</pre>

<p>Výsledek statické kontroly:</p>

<pre>
$ <strong>mypy exec_problem_1.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p>V&nbsp;případě, že do proměnné <strong>x</strong> vložíme hodnotu jiného
typu, nástroj Mypy nás na tento problém upozorní:</p>

<pre>
x = "foo"
&nbsp;
&nbsp;
def <strong>adder</strong>(a:int, b:int) -&gt; int:
    return a+b
&nbsp;
&nbsp;
print(adder(x,x))
</pre>

<p>Výsledek statické kontroly chybu odhalí:</p>

<pre>
$ <strong>mypy exec_problem_2.py</strong>
&nbsp;
exec_problem_2.py:8: error: Argument 1 to "adder" has incompatible type "str"; expected "int"  [arg-type]
exec_problem_2.py:8: error: Argument 2 to "adder" has incompatible type "str"; expected "int"  [arg-type]
Found 2 errors in 1 file (checked 1 source file)
</pre>

<p>Ovšem co se stane ve chvíli, kdy zavoláme <strong>exec</strong>, tedy
funkci, která spustí příkaz zapsaný v&nbsp;řetězci (a tento řetězec lze získat
různými způsoby)? Tuto skutečnost již statická analýza kódu nemůže odhalit:</p>

<pre>
x = 21
&nbsp;
&nbsp;
def <strong>adder</strong>(a:int, b:int) -&gt; int:
    return a+b
&nbsp;
&nbsp;
<u>exec("x='foo'")</u>
&nbsp;
print(adder(x,x))
</pre>

<p>Výsledek statické kontroly nyní bude vypadat následovně:</p>

<pre>
$ <strong>mypy exec_problem_3.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p>Ovšem program po svém spuštění vypíše hodnotu, která jasně ukazuje, že byl
použit řetězec:</p>

<pre>
$ <strong>python3 exec_problem_3.py</strong>
&nbsp;
foofoo
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Rozdíly v&nbsp;typových systémech: variance</h2>

<p><i>&bdquo;Argument types must be contra-variant, return types must be co-variant.&ldquo;</i></p>

<p>Mezi jednotlivými typovými systémy může být velké množství rozdílů, které
určují jak jejich sílu, tak i snadnost použití. Zajímavou vlastností typových
systémů je takzvaná <i>typová variance</i> (do češtiny se sice překládá
několika termíny, ovšem pravděpodobně bude lepší zůstat u původního označení).
U datových typů (a odvozeně i od třídní hierarchie) typicky vyžadujeme tuto
vlastnost: nějaký typ T je podtypem dalšího typu U tehdy, když ve všech místech
programového kódu, v&nbsp;nichž je očekávána hodnota typu U, můžeme použít i
hodnotu typu T (v&nbsp;případě třídního OOP máme podobnou vlastnost:
&bdquo;potomek vždy může nahradit předka&ldquo;, která ovšem vychází
z&nbsp;dědičnosti. Dědičnost je ovšem nezávislá vlastnost.).</p>

<p>Variance určuje, jak a zda vůbec se toto pravidlo uplatní například u polí,
resp.&nbsp;v&nbsp;případě Pythonu u seznamů (<strong>List[T]</strong> versus
<strong>List[U]</strong>), map, funkcí (typy parametrů a typ návratové hodnoty)
atd.</p>

<p>Celkem existují čtyři varianty:</p>

<ol>
<li>Covariance</li>
<li>Contravariance</li>
<li>Invariance</li>
<li>Bivariance</li>
</ol>

<p><div class="rs-tip-major">Poznámka: opět používám původní termíny, které se
lépe vyhledávají.</div></p>

<p>Podívejme se nyní na základní vlastnosti jednotlivých variant variancí.
Budeme předpokládat, že máme nadefinovány dva datové typy nazvané
<strong>Ovoce</strong> a <strong>Hruška</strong>, přičemž
<strong>Hruška</strong> je podtypem typu <strong>Ovoce</strong>:</p>

<ol>

<li><i>Covariance</i>: <strong>List[Hruška]</strong> je podtypem typu
<strong>List[Ovoce]</strong>, funkce akceptující <strong>List[Ovoce]</strong>
bude akceptovat <strong>List[Hruška]</strong></li>

<li><i>Contravariance</i>: <strong>List[Ovoce]</strong> je podtypem typu
<strong>List[Hruška]</strong> (což je jen zdánlivě nelogické), funkce
akceptující <strong>List[Hruška]</strong> bude akceptovat
<strong>List[Ovoce]</strong></li>

<li><i>Invariance</i>: <strong>List[Ovoce]</strong> nemá vztah k
<strong>List[Hruška]</strong> a při volání funkcí je tedy nelze zaměňovat</li>

<li><i>Bivariance></i>: <strong>List[Hruška]</strong> je podtypem typu
<strong>List[Ovoce]</strong> a současně <strong>List[Ovoce]</strong> je
podtypem typu <strong>List[Hruška]</strong>, jsou tedy při volání zaměnitelné</li>

</ol>

<p><div class="rs-tip-major">Poznámka: může se to možná zdát divné, ale všechny
typy variance mají svůj význam i použití, i když se mohou zdát na první pohled
&bdquo;nelogické&ldquo;. Ostatně příklady si ukážeme v&nbsp;navazujících
kapitolách i v&nbsp;dalším článku. Situace je zajímavá zejména u funkcí,
resp.&nbsp;u jejich parametrů a návratové hodnoty.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Jak je tomu v&nbsp;Javě?</h2>

<p>Java a TypeScript, na rozdíl od například jazyka Go, při volání funkcí a
metod používají <i>kovarianci</i>, což může vést k&nbsp;běhovým
(<i>runtime</i>) chybám. To si ostatně můžeme ukázat na velmi jednoduchých
příkladech (subtyping je sice odlišný od hierarchie tříd, pro jednoduchost
ovšem nyní budeme na chvíli tyto rozdíly ignorovat).</p>

<p>V&nbsp;prvním příkladu je použita snadno pochopitelná hierarchie tříd
<strong>Ovoce</strong>, <strong>Hruska</strong> a <strong>Jablko</strong>. Ve
statické metodě <strong>smichej</strong> v&nbsp;košíku mícháme hrušky
s&nbsp;jablky. Ovšem této metodě předáváme košík představovaný polem hodnot
typu <strong>Ovoce</strong>, takže vše bude v&nbsp;pořádku &ndash; jak
v&nbsp;<i>compile time</i>, tak v&nbsp;<i>runtime</i>:</p>

<pre>
class <strong>Ovoce</strong> {
}
&nbsp;
class <strong>Hruska</strong> extends <strong>Ovoce</strong> {
    public String toString() {
        return "Hruska";
    }
}
&nbsp;
class <strong>Jablko</strong> extends <strong>Ovoce</strong> {
    public String toString() {
        return "Jablko";
    }
}
&nbsp;
public class <strong>Variance1</strong> {
    public static void <strong>smichej</strong>(Ovoce[] kosik) {
        kosik[0] = new Hruska();
        kosik[1] = new Jablko();
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        Ovoce[] kosik = new Ovoce[2];
        smichej(kosik);
&nbsp;
        for (Ovoce ovoce:kosik) {
            System.out.println(ovoce);
        }
    }
}
</pre>

<p>Až doposud bylo vše v&nbsp;pořádku. Ovšem co se stane ve chvíli, kdy metodě
<strong>smichej</strong> předáme košík, do kterého je možné ukládat pouze
hrušky (a to díky kovarianci můžeme)? Zde ono pověstné míchání hrušek
s&nbsp;jablky nebude možné, ovšem <i>překladač provádějící statickou typovou
kontrolu tento problém neodhalí</i>:</p>

<pre>
class <strong>Ovoce</strong> {
}
&nbsp;
class <strong>Hruska</strong> extends <strong>Ovoce</strong> {
    public String toString() {
        return "Hruska";
    }
}
&nbsp;
class <strong>Jablko</strong> extends <strong>Ovoce</strong> {
    public String toString() {
        return "Jablko";
    }
}
&nbsp;
public class <strong>Variance2</strong> {
    public static void <strong>smichej</strong>(Ovoce[] kosik) {
        kosik[0] = new Hruska();
        kosik[1] = new Jablko();
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        Ovoce[] kosik = new Hruska[2];
        smichej(kosik);
&nbsp;
        for (Ovoce ovoce:kosik) {
            System.out.println(ovoce);
        }
    }
}
</pre>

<p>Chyba je odhalena až za běhu, tedy v&nbsp;<i>runtime</i>:</p>

<pre>
Exception in thread "main" java.lang.ArrayStoreException: Jablko
        at Variance2.smichej(Variance2.java:19)
        at Variance2.main(Variance2.java:24)

</pre>

<p><div class="rs-tip-major">Poznámka: bez čtení dalšího textu se pokuste
zamyslet nad tím, jak (a zda vůbec) lze tento problém nějak uspokojivě
vyřešit.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Chování Pythonu při práci se seznamy s&nbsp;typem</h2>

<p>Podívejme se nyní na podobný příklad, ovšem tentokrát naprogramovaný
v&nbsp;Pythonu s&nbsp;využitím typových anotací. Opět je vytvořena hierarchie
tříd (a tedy i typů) <strong>Ovoce</strong>, <strong>Hruska</strong> a
<strong>Jablko</strong>. Příklad dále obsahuje funkci <strong>smichej</strong>,
která do košíku s&nbsp;ovocem přidá hrušku a jablko. Samotný košík je přitom
představován typem <strong>List[Ovoce]</strong> a celý příklad je tedy bez
problémů spustitelný a i Mypy v&nbsp;něm nenalezne žádný problém:</p>

<pre>
from typing import List
&nbsp;
&nbsp;
class <strong>Ovoce</strong>:
    pass
&nbsp;
&nbsp;
class <strong>Hruska</strong>(Ovoce):
    def __repr__(self):
        return "Hruska"
&nbsp;
&nbsp;
class <strong>Jablko</strong>(Ovoce):
    def __repr__(self):
        return "Jablko"
&nbsp;
&nbsp;
def <strong>smichej</strong>(kosik : List[Ovoce]):
    kosik.append(Hruska())
    kosik.append(Jablko())
&nbsp;
&nbsp;
kosik : List[Ovoce] = []
&nbsp;
smichej(kosik)
&nbsp;
for ovoce in kosik:
    print(ovoce)
</pre>

<p>Výsledek testu, zda je kód typově korektní:</p>

<pre>
$ <strong>mypy Variance1.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p>Nyní předchozí příklad nepatrně pozměníme &ndash; košík nebude typu
<strong>List[Ovoce]</strong> ale typu <strong>List[Hruska]</strong>, přičemž ve
funkci <strong>smichej</strong> opět mícháme jablka s&nbsp;hruškami, ovšem
přidáváme je do seznamu, který akceptuje pouze hrušky:</p>

<pre>
from typing import List
&nbsp;
&nbsp;
class <strong>Ovoce</strong>:
    pass
&nbsp;
&nbsp;
class <strong>Hruska</strong>(Ovoce):
    def __repr__(self):
        return "Hruska"
&nbsp;
&nbsp;
class <strong>Jablko</strong>(Ovoce):
    def __repr__(self):
        return "Jablko"
&nbsp;
&nbsp;
def <strong>smichej</strong>(kosik : List[Ovoce]):
    kosik.append(Hruska())
    kosik.append(Jablko())
&nbsp;
&nbsp;
kosik : List[Hruska] = []
&nbsp;
smichej(kosik)
&nbsp;
for ovoce in kosik:
    print(ovoce)
</pre>

<p>Tentokrát ovšem Mypy v&nbsp;kódy nalezne chyby a dokonce navrhuje způsob
jejich opravy (tuto opravu ovšem nemůžeme použít):</p>

<pre>
$ <strong>mypy Variance2.py</strong>
&nbsp;
Variance2.py:25: error: Argument 1 to "smichej" has incompatible type "List[Hruska]"; expected "List[Ovoce]"  [arg-type]
Variance2.py:25: note: "List" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
Variance2.py:25: note: Consider using "Sequence" instead, which is covariant
Found 1 error in 1 file (checked 1 source file)
</pre>

<p>Zkusme si příklad zjednodušit, a to tak, že vytvoříme funkci tiskni, která
očekává jako svůj parametr typ <strong>List[Ovoce]</strong>. A vyzkoušíme si,
zda je možné této funkci předat seznam s&nbsp;hruškami, tedy
<strong>List[Hruska]</strong>. Při statické kontrole typů by se měl objevit
stejný problém, jako u předchozího příkladu (protože se kontrolují jen typy a
Mypy netuší, jaké operace se budou interně se seznamem provádět):</p>

<pre>
from typing import List
&nbsp;
&nbsp;
class <strong>Ovoce</strong>:
    pass
&nbsp;
&nbsp;
class <strong>Hruska</strong>(Ovoce):
    def __repr__(self):
        return "Hruska"
&nbsp;
&nbsp;
class <strong>Jablko</strong>(Ovoce):
    def __repr__(self):
        return "Jablko"
&nbsp;
&nbsp;
def <strong>tiskni</strong>(kosik : List[Ovoce]):
    for ovoce in kosik:
        print(ovoce)
&nbsp;
&nbsp;
kosik : List[Hruska] = []
&nbsp;
tiskni(kosik)
</pre>

<p>A Mypy skutečně stejnou chybu nalezne:</p>

<pre>
$ <strong>mypy Variance3.py </strong>
&nbsp;
Variance3.py:25: error: Argument 1 to "tiskni" has incompatible type "List[Hruska]"; expected "List[Ovoce]"  [arg-type]
Variance3.py:25: note: "List" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
Variance3.py:25: note: Consider using "Sequence" instead, which is covariant
Found 1 error in 1 file (checked 1 source file)
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Použití typu <strong>Sequence</strong> namísto typu <strong>List</strong></h2>

<p>Jak nástroj Mypy správně napovídá, lze zdrojový kód předchozího příkladu
upravit takovým způsobem, že se namísto datového typu <strong>List</strong>
(což odpovídá klasickému Pythonovskému seznamu) použije typ
<strong>Sequence</strong>, který představuje neměnný (<i>immutable</i>) seznam.
A právě díky této úpravě &ndash; kdy bude i Mypy během statické analýzy kódu
vědět, že do seznamu nelze vložit hodnotu nesprávného typu &ndash; bude příklad
typově korektní:</p>

<pre>
from typing import Sequence
&nbsp;
&nbsp;
class <strong>Ovoce</strong>:
    pass
&nbsp;
&nbsp;
class <strong>Hruska</strong>(Ovoce):
    def __repr__(self):
        return "Hruska"
&nbsp;
&nbsp;
class <strong>Jablko</strong>(Ovoce):
    def __repr__(self):
        return "Jablko"
&nbsp;
&nbsp;
def <strong>tiskni</strong>(kosik : Sequence[Ovoce]):
    for ovoce in kosik:
        print(ovoce)
&nbsp;
&nbsp;
kosik : Sequence[Hruska] = []
&nbsp;
tiskni(kosik)
</pre>

<p>Výsledek statické kontroly nástrojem Mypy:</p>

<pre>
$ <strong>mypy Variance4.py</strong>
&nbsp;
Success: no issues found in 1 source file
</pre>

<p><div class="rs-tip-major">Poznámka: znovu je nutné upozornit na to, že
výsledek je korektní z&nbsp;toho důvodu, že se seznamem (nyní se sekvencí)
pracujeme tak, jakoby se jednalo o neměnnou (<i>immutable</i>) datovou
strukturu.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny Pythonovské skripty i dva zdrojové kódy naprogramované v&nbsp;Javě,
které jsme si v&nbsp;dnešním článku ukázali, naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady (pro jejich spuštění je nutné mít
nainstalován balíček <i>mypy</i>, příklady naprogramované v&nbsp;Javě vyžadují
celé JDK):</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>adder1.py</td><td>funkce <strong>add</strong> bez typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder1.py</a></td></tr>
<tr><td> 2</td><td>adder2.py</td><td>funkce <strong>add</strong> s&nbsp;typovými anotacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder2.py</a></td></tr>
<tr><td> 3</td><td>adder3.py</td><td>funkce <strong>add</strong> volaná s&nbsp;hodnotami <strong>True</strong> a <strong>False</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder3.py</a></td></tr>
<tr><td> 4</td><td>adder4.py</td><td>funkce <strong>add</strong> akceptující hodnoty typu <strong>bool</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder4.py</a></td></tr>
<tr><td> 5</td><td>adder5.py</td><td>zobrazení typových informací pro funkci bez typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder5.py</a></td></tr>
<tr><td> 6</td><td>adder6.py</td><td>zobrazení typových informací pro funkci s&nbsp;typovými anotacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/adder6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>exec_problem_1.py</td><td>funkce <strong>add</strong> s&nbsp;typovými anotacemi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_1.py</a></td></tr>
<tr><td> 6</td><td>exec_problem_2.py</td><td>korektní detekce volání funkce <strong>add</strong> s&nbsp;nekompatibilními hodnotami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_2.py</a></td></tr>
<tr><td> 7</td><td>exec_problem_3.py</td><td>příkaz použitý v&nbsp;<strong>exec</strong> není statickým analyzátorem zachycen</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/exec_problem_3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>list_type1.py</td><td>typ seznam, s&nbsp;inicializací (bez prvků), pro Python 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type1.py</a></td></tr>
<tr><td> 9</td><td>list_type2.py</td><td>typ seznam, s&nbsp;inicializací (bez prvků), pro starší verze Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type2.py</a></td></tr>
<tr><td>10</td><td>list_type3.py</td><td>typ seznam, s&nbsp;inicializací (s&nbsp;prvky), pro starší verze Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type3.py</a></td></tr>
<tr><td>11</td><td>list_type4.py</td><td>typ seznam, kontrola použití prvků s&nbsp;nekorektními typy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type4.py</a></td></tr>
<tr><td>12</td><td>list_type5.py</td><td>typ seznam, kontrola použití prvků s&nbsp;korektními typy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type5.py</a></td></tr>
<tr><td>13</td><td>list_type6.py</td><td>typ seznam, kontrola použití prvků s&nbsp;korektními typy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/list_type6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>tuple_type1.py</td><td>typ n-tice (nekorektní specifikace typu)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type1.py</a></td></tr>
<tr><td>15</td><td>tuple_type2.py</td><td>typ n-tice (korektní specifikace typu)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type2.py</a></td></tr>
<tr><td>16</td><td>tuple_type3.py</td><td>typ n-tice, v&nbsp;níž má každý prvek odlišný typ</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type3.py</a></td></tr>
<tr><td>17</td><td>tuple_type4.py</td><td>typ n-tice, v&nbsp;níž má každý prvek odlišný typ</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/tuple_type4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>json_check.py</td><td>delší kód v&nbsp;Pythonu bez typových anotací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/json_check.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/json_check.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>Variance1.java</td><td>variance v&nbsp;Javě &ndash; korektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.java">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.java</a></td></tr>
<tr><td>20</td><td>Variance2.java</td><td>variance v&nbsp;Javě &ndash; nekorektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.java">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>Variance1.py</td><td>variance v&nbsp;Pythonu &ndash; korektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance1.py</a></td></tr>
<tr><td>22</td><td>Variance2.py</td><td>variance v&nbsp;Pythonu &ndash; nekorektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance2.py</a></td></tr>
<tr><td>23</td><td>Variance3.py</td><td>variance v&nbsp;Pythonu &ndash; nekorektní příklad použití</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance3.py</a></td></tr>
<tr><td>24</td><td>Variance4.py</td><td>použití typu <strong>Sequence</strong> namísto <strong>List</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/Variance4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>view_pyc.py</td><td>jednoduchá prohlížečka souborů .pyc</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/view_pyc.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypy/view_pyc.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>mypy homepage<br />
<a href="https://www.mypy-lang.org/">https://www.mypy-lang.org/</a>
</li>

<li>mypy documentation<br />
<a href="https://mypy.readthedocs.io/en/stable/">https://mypy.readthedocs.io/en/stable/</a>
</li>

<li>Mypy na PyPi Optional static typing for Python<br />
<a href="https://pypi.org/project/mypy/">https://pypi.org/project/mypy/</a>
</li>

<li>5 Reasons Why You Should Use Type Hints In Python<br />
<a href="https://www.youtube.com/watch?v=dgBCEB2jVU0">https://www.youtube.com/watch?v=dgBCEB2jVU0</a>
</li>

<li>Python Typing &ndash; Type Hints &amp; Annotations<br />
<a href="https://www.youtube.com/watch?v=QORvB-_mbZ0">https://www.youtube.com/watch?v=QORvB-_mbZ0</a>
</li>

<li>What Problems Can TypeScript Solve?<br />
<a href="https://www.typescriptlang.org/why-create-typescript">https://www.typescriptlang.org/why-create-typescript</a>
</li>

<li>How to find code that is missing type annotations?<br />
<a href="https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations">https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations</a>
</li>

<li>Do type annotations in Python enforce static type checking?<br />
<a href="https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking">https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking</a>
</li>

<li>Understanding type annotation in Python<br />
<a href="https://blog.logrocket.com/understanding-type-annotation-python/">https://blog.logrocket.com/understanding-type-annotation-python/</a>
</li>

<li>Static type checking with Mypy — Perfect Python<br />
<a href="https://www.youtube.com/watch?v=9gNnhNxra3E">https://www.youtube.com/watch?v=9gNnhNxra3E</a>
</li>

<li>Static Type Checker for Python<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Differences Between Pyright and Mypy<br />
<a href="https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md">https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md</a>
</li>

<li>4 Python type checkers to keep your code clean<br />
<a href="https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html">https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html</a>
</li>

<li>Pyre: A performant type-checker for Python 3<br />
<a href="https://pyre-check.org/">https://pyre-check.org/</a>
</li>

<li>"Typing the Untyped: Soundness in Gradual Type Systems" by Ben Weissmann<br />
<a href="https://www.youtube.com/watch?v=uJHD2xyv7xo">https://www.youtube.com/watch?v=uJHD2xyv7xo</a>
</li>

<li>Covariance and contravariance (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a>
</li>

<li>Functional Programming: Type Systems<br />
<a href="https://www.youtube.com/watch?v=hy1wjkcIBCU">https://www.youtube.com/watch?v=hy1wjkcIBCU</a>
</li>

<li>A Type System From Scratch – Robert Widmann<br />
<a href="https://www.youtube.com/watch?v=IbjoA5xVUq0">https://www.youtube.com/watch?v=IbjoA5xVUq0</a>
</li>

<li>"Type Systems - The Good, Bad and Ugly" by Paul Snively and Amanda Laucher<br />
<a href="https://www.youtube.com/watch?v=SWTWkYbcWU0">https://www.youtube.com/watch?v=SWTWkYbcWU0</a>
</li>

<li>Type Systems: Covariance, Contravariance, Bivariance, and Invariance explained<br />
<a href="https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8">https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8</a>
</li>

<li>Statická vs. dynamická typová kontrola<br />
<a href="https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/">https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/</a>
</li>

<li>Typový systém<br />
<a href="https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m">https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m</a>
</li>

<li>Comparison of programming languages by type system<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system</a>
</li>

<li>Flow<br />
<a href="https://flow.org/">https://flow.org/</a>
</li>

<li>TypeScript<br />
<a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a>
</li>

<li>Sorbet<br />
<a href="https://sorbet.org/">https://sorbet.org/</a>
</li>

<li>Pyright<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Mypy: Type hints cheat sheet<br />
<a href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html</a>
</li>

<li>PEP 484 – Type Hints<br />
<a href="https://peps.python.org/pep-0484/">https://peps.python.org/pep-0484/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

