<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Rychlost CPythonu 3.11 a 3.12 v porovnání s JIT a AOT překladači Pythonu (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Rychlost CPythonu 3.11 a 3.12 v porovnání s JIT a AOT překladači Pythonu (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Rychlost CPythonu 3.11 a 3.12 v&nbsp;porovnání s&nbsp;JIT a AOT překladači Pythonu (2)</a></p>
<p><a href="#k02">2. Měříme skutečně rychlost výpočtů nebo rychlost zápisu výsledného rastrového obrázku?</a></p>
<p><a href="#k03">3. Oddělení výpočtu od kódu pro uložení výsledku benchmarku</a></p>
<p><a href="#k04">4. Vliv pomalosti I/O operací na rychlost běhu benchmarku</a></p>
<p><a href="#k05">5. Grafy s&nbsp;časy výpočtů a I/O operací</a></p>
<p><a href="#k06">6. Eliminace I/O operací</a></p>
<p><a href="#k07">7. Paralelizace výsledného kódu JIT překladačem Numba</a></p>
<p><a href="#k08">8. Paralelizace kódu nemusí být zcela triviálním úkolem</a></p>
<p><a href="#k09">*** 9. Výsledek běhu příkladu upraveného do paralelní podoby</a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Zdrojové kódy benchmarků použitých v&nbsp;dnešním článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady pro nástroj Numba</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Rychlost CPythonu 3.11 a 3.12 v&nbsp;porovnání s&nbsp;JIT a AOT překladači Pythonu (2)</h2>

<p></p>

<img src="https://i.iinfo.cz/images/327/mypyc-1.webp" class="image-1110093" width="400" height="400" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 1: Rastrový obrázek generovaný benchmarky při nastavení rozlišení
400&times;400 pixelů a maximálního počtu iterací 255. Později budeme počet
iterací zásadně zvětšovat, abychom omezili vliv pomalosti I/O operací na
celkovou dobu trvání benchmarku.</i></p>

<p></p>


<p><a name="k02"></a></p>
<h2 id="k02">2. Měříme skutečně rychlost výpočtů nebo rychlost zápisu výsledného rastrového obrázku?</h2>

<p><a
href="https://www.root.cz/clanky/rychlost-cpythonu-3-11-a-3-12-v-porovnani-s-jit-a-aot-prekladaci-pythonu/">V&nbsp;předchozím
článku</a> jsme měřili rychlost vykreslení Mandelbrotovy množiny Pythonním
skriptem, který byl buď přímo spuštěn ve standardním interpretru CPythonu
(verze 3.8 až 3.12), popř.&nbsp;byl přeložen JIT překladačem Numba nebo AOT
překladačem mypyc. Výsledkem měření byl (mj.) i následující graf, v&nbsp;němž
jsou porovnány rychlosti vykreslení Mandelbrotovy množiny do rastrových obrázků
s&nbsp;rozlišením, které se pohybuje od 16&times;16 pixelů až po poměrně velké
obrázky s&nbsp;rozlišením 4096&times;4096 pixelů:</p>

<a href="https://www.root.cz/obrazek/1110420/"><img src="https://i.iinfo.cz/images/210/mypyc-3-1-prev.webp" class="image-1110420" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/210/mypyc-3-1-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/210/mypyc-3-1-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a></p>
<p><i>Obrázek 2: Časy běhu všech benchmarků v&#160;závislosti na požadovaném
rozlišení výsledné bitmapy.</i></p>

<p>Ještě předtím, než vyneseme konečný verdikt, za jakých okolností je vhodné
použít nějakou technologii, je vhodné se zamyslet nad tím, co jsme vlastně
změřili (to platí pro všechny benchmarky). Jedná se o tři operace:</p>

<ol>
<li>JIT překlad popř.&nbsp;překlad bajtkódu (pro mypyc nulový čas)</li>
<li>Čas výpočtu (programové smyčky, podmínky a FP operace)</li>
<li>I/O operace (volání funkce <strong>print</strong> pro vykreslení bitmapy)</li>
</ol>

<p>Na první pohled by se mohlo zdát, že doba I/O operací nebude hrát při
dlouhotrvajících výpočtech žádnou zásadní roli, ovšem je lepší si vše ověřit
(mohli bychom například předpokládat, že doba výpočtu barvy pixelu bude mnohem
delší, než zápis samotné barvy, což je trojice celých čísel).  Ideální by
samozřejmě bylo využití profileru, to je však v&nbsp;případě mypyc a Numby
relativně složitá operace (více příště). Proto se pokusíme o oddělení obou
částí programu přímo ve zdrojovém kódu benchmarku.</p>

<p><div class="rs-tip-major">Poznámka: všechny benchmarky produkují bitmapy ve
formátu PPM (ASCII varianta), aby bylo možné snadno (například
<strong>diff</strong>em) zjistit, zda jsou výsledky totožné. Bitmapa o
rozlišení 16&times;16 pixelů má obecně následující formát (přičemž se do značné
míry ignorují bílé znaky, včetně znaků pro konce řádků):</div></p>

<pre>
P3
16 16
255
224 224 224
224 224 224
224 224 224
224 224 224
216 216 216
216 216 216
216 216 216
216 216 216
232 232 232
232 232 232
216 216 216
...
...
...
208 208 208
208 208 208
208 208 208
216 216 216
216 216 216
216 216 216
216 216 216
216 216 216
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Oddělení výpočtu od kódu pro uložení výsledku benchmarku</h2>

<p>Připomeňme si, že původní tvar benchmarku vypadá následovně. Uvádíme zde
variantu určenou pro JITování nástrojem Numba, takže ve zdrojovém kódu příkladu
nalezneme dekorátor <strong>@jit</strong> s&nbsp;parametrem
<strong>nopython=True</strong>, kterým se určuje, že se nemají volat Pythonní
funkce, ale pouze funkce nativní. Z&nbsp;toho důvodu jsme nuceni použít
zjednodušenou nativní variantu funkcí <strong>print</strong> a
<strong>range</strong> (podtrženo):</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import palette_mandmap
from sys import argv, exit
&nbsp;
from numba import jit
&nbsp;
&nbsp;
@jit(nopython=True)
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
    <u>print("P3")</u>
    <u>print(width)</u>
    <u>print(height)</u>
    <u>print("255")</u>
&nbsp;
    cy = -1.5
    for y in <u>range(0, height)</u>:
        cx = -2.0
        for x in <u>range(0, width)</u>:
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
&nbsp;
            r = palette[i % 256][0]
            g = palette[i % 256][1]
            b = palette[i % 256][2]
            <u>print(r)</u>
            <u>print(g)</u>
            <u>print(b)</u>
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        width = 512
        height = 512
        maxiter = 255
    else:
        width = int(argv[1])
        height = int(argv[2])
        maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p>Pokud se budeme snažit o zachování původního zdrojového kódu v&nbsp;co
největší míře, můžeme provést rozdělení na výpočetní a exportní část například
následujícím způsobem. Povšimněte si použití Numpy, což je ovšem zcela
v&nbsp;pořádku, protože nástroj Numba je optimalizován právě pro dobrou a
rychlou kooperaci s&nbsp;Numpy:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import palette_mandmap
from sys import argv, exit
&nbsp;
import numpy as np
from numba import jit
&nbsp;
&nbsp;
@jit(nopython=True)
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
    iters = np.empty((height, width), dtype=np.uint8)
&nbsp;
    <i># calc part</i>
    cy = -1.5
    for y in <u>range(0, height)</u>:
        cx = -2.0
        for x in <u>range(0, width)</u>:
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
            iters[y][x] = i
&nbsp;
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
    <i># image export part</i>
    <u>print("P3")</u>
    <u>print(width)</u>
    <u>print(height)</u>
    <u>print("255")</u>
    for y in <u>range(0, height)</u>:
        for x in <u>range(0, width)</u>:
            i = iters[y][x]
            r = palette[i % 256][0]
            g = palette[i % 256][1]
            b = palette[i % 256][2]
            <u>print(r)</u>
            <u>print(g)</u>
            <u>print(b)</u>
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        width = 512
        height = 512
        maxiter = 255
    else:
        width = int(argv[1])
        height = int(argv[2])
        maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>

<p><div class="rs-tip-major">Poznámka: velmi snadno je možné si ověřit, že
výsledné soubory generované oběma variantami benchmarků budou produkovat
naprosto totožné rastrové obrázky.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vliv pomalosti I/O operací na rychlost běhu benchmarku</h2>

<p>Nyní benchmark uvedený <a href="#k03">v&nbsp;předchozí kapitole</a> budeme
postupně modifikovat. Nejprve ho na testovacím počítači spustíme tak, jak byl
napsán, samozřejmě s&nbsp;využitím JIT překladače nástroje Numba. Pro rastrové
obrázky o rozlišení od 16&times;16 pixelů do 4096&times;4096 pixelů (a pro
maximální počet iterací roven 255) dostaneme následující výsledky (první
sloupec obsahuje velikost obrázku, druhý čas výpočtu v&nbsp;sekundách a třetí
kapacitu alokované paměti z&nbsp;pohledu operačního systému &ndash; RSS):</p>

<pre>
16 3.45 271180
24 3.44 271444
32 4.27 271384
48 5.16 271136
64 5.13 271148
96 5.12 271184
128 5.07 271312
192 5.13 271304
256 5.13 271308
384 5.19 271268
512 5.25 271124
768 5.48 271316
1024 5.75 271316
1536 6.59 271184
2048 7.83 271008
3072 11.18 271296
4096 15.98 271316
</pre>

<p>Vidíme, že rastrový obrázek s&nbsp;rozlišením 4096&times;4096 byl spočten a
uložen za cca šestnáct sekund.</p>

<p>Dále si zkusme zakomentovat poslední tři příkazy ve smyčce, v&nbsp;níž se
rastrový obrázek ukládá:</p>

<pre>
    <i># image export part</i>
    <u>print("P3")</u>
    <u>print(width)</u>
    <u>print(height)</u>
    <u>print("255")</u>
    for y in <u>range(0, height)</u>:
        for x in <u>range(0, width)</u>:
            i = iters[y][x]
            r = palette[i % 256][0]
            g = palette[i % 256][1]
            b = palette[i % 256][2]
            <u># print(r)</u>
            <u># print(g)</u>
            <u># print(b)</u>
</pre>

<p>Nyní tedy budeme provádět celý výpočet, ovšem nebudeme vykreslovat
jednotlivé pixely výsledného rastrového obrázku. Pokud nyní předpokládáte
(stejně jako původně autor tohoto článku), že výsledné časy budou prakticky
totožné, možná budete překvapeni:</p>

<pre>
16 2.93 266752
24 2.93 266812
32 2.93 266952
48 2.91 267072
64 3.66 266796
96 4.40 267060
128 4.37 266928
192 4.32 266944
256 4.34 266820
384 4.35 266948
512 4.35 266776
768 4.38 266816
1024 4.39 266688
1536 4.42 266820
2048 4.47 266500
3072 4.65 266932
4096 4.97 266804
</pre>

<p>Z&nbsp;výsledků je patrné, že samotný FP výpočet není zdaleka tou
nejkritičtější operací. To má dalekosáhlé důsledky, ke kterým se ještě
vrátíme.</p>

<p>Při třetím běhu naopak vynecháme výpočet a budeme ukládat prázdnou bitmapu (s&nbsp;černými pixely):</p>

<pre>
    <i># calc part</i>
    cy = -1.5
    for y in <u>range(0, height)</u>:
        cx = -2.0
        for x in <u>range(0, width)</u>:
            zx = 0.0
            zy = 0.0
            i = 0
            # while i &lt; maxiter:
            #     zx2 = zx * zx
            #     zy2 = zy * zy
            #     if zx2 + zy2 &gt; 4.0:
            #         break
            #     zy = 2.0 * zx * zy + cy
            #     zx = zx2 - zy2 + cx
            #     i += 1
            iters[y][x] = i
&nbsp;
            cx += 3.0/width
        cy += 3.0/height
</pre>

<p>Nyní již dokážeme výsledek do určité míry predikovat &ndash; samotné uložení
rastrového obrázku je tak náročná I/O operace, že bude nejenom měřitelná, ale
překročí dobu výpočtů:</p>

<pre>
16 3.48 271076
24 3.48 270880
32 3.45 270948
48 4.49 271016
64 5.23 270892
96 5.18 271068
128 5.15 271076
192 5.17 271020
256 5.18 271032
384 5.25 270952
512 5.29 270880
768 5.47 271040
1024 5.77 271212
1536 6.53 270952
2048 7.79 270928
3072 10.92 270868
4096 15.37 270856
</pre>

<p>Jen pro zajímavost vynechme výpočet, ovšem uložme každý pixel dvakrát, čímž
se počet I/O operací prakticky zdvojnásobí (výsledná bitmapa ovšem nebude
korektní):</p>

<pre>
    <i># image export part</i>
    <u>print("P3")</u>
    <u>print(width)</u>
    <u>print(height)</u>
    <u>print("255")</u>
    for y in <u>range(0, height)</u>:
        for x in <u>range(0, width)</u>:
            i = iters[y][x]
            r = palette[i % 256][0]
            g = palette[i % 256][1]
            b = palette[i % 256][2]
            <u>print(r)</u>
            <u>print(g)</u>
            <u>print(b)</u>
            <u>print(r)</u>
            <u>print(g)</u>
            <u>print(b)</u>
</pre>

<p>Časy nebudou dvojnásobné, ale to je již možné predikovat, protože víme, že
samotné JITování kódu trvá cca 3-4 sekundy:</p>

<pre>
16 3.46 271212
24 3.44 271292
32 3.47 271320
48 3.45 271348
64 5.06 271456
96 5.13 271332
128 5.11 271336
192 5.12 271336
256 5.16 271208
384 5.25 271172
512 5.41 271308
768 5.81 271472
1024 6.37 271308
1536 8.35 271588
2048 10.43 271304
3072 16.79 271304
4096 25.89 271304
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Grafy s&nbsp;časy výpočtů a I/O operací</h2>

<p>Porovnání běhu benchmarků je pochopitelně výhodnější provést ve vizuální
podobě, takže se vrátíme ke grafům. Na následujících grafech jsou zobrazeny
časy všech čtyř variant téhož benchmarku popsaných <a
href="#k04">v&nbsp;předchozí kapitole</a>:</p>

<table>
<tr><th>Označení</th><th>Význam</th></tr>
<tr><td>normal</td><td>celý benchmark s&nbsp;výpočtem i exportem</td></tr>
<tr><td>no output</td><td>pouze výpočet</td></tr>
<tr><td>no calc</td><td>pouze export (černého) rastrového obrázku</td></tr>
<tr><td>double output</td><td>výpočet i export, ovšem každý pixel je zapsán dvakrát</td></tr>
</table>

<p>Pro velmi malé rozměry obrázků bude největší roli hrát samotný JIT
překladač:</p>

<a href="https://www.root.cz/obrazek/1110442/"><img src="https://i.iinfo.cz/images/134/numba3-2-prev.webp" class="image-1110442" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/134/numba3-2-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/134/numba3-2-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>
<p><i>Obrázek 3: Vliv JIT překladu na dobu běhu benchmarků.</i></p>

<p>Naopak pro velké rastrové obrázky vychází, že největší vliv mají I/O operace
(tedy konkrétně funkce <strong>print</strong>) a nikoli vlastní výpočet, což je
překvapující:</p>

<a href="https://www.root.cz/obrazek/1110443/"><img src="https://i.iinfo.cz/images/134/numba3-3-prev.webp" class="image-1110443" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/134/numba3-3-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/134/numba3-3-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>
<p><i>Obrázek 4: Vliv opakovaného volání funkce <strong>print</strong> na dobu
běhu benchmarku.</i></p>

<p>A takto vypadá situace, kdy na horizontální osu vyneseme velikost výsledného
obrázku a na osu vertikální dobu běhu benchmarku v&nbsp;sekundách. Jednotlivé
naměřené hodnoty jsou proloženy lineárními úseky:</p>

<a href="https://www.root.cz/obrazek/1110444/"><img src="https://i.iinfo.cz/images/134/numba3-4-prev.webp" class="image-1110444" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/134/numba3-4-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/134/numba3-4-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>
<p><i>Obrázek 5: Rychlosti různých benchmarků pro rozdílné velikosti výsledných
rastrových obrázků.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Eliminace I/O operací</h2>

<p>V&nbsp;dnešním článku nás v&nbsp;prvé řadě zajímá rychlost provádění výpočtů
a nikoli to, jak rychlá či naopak pomalá je implementace funkce
<strong>print</strong>. Z&nbsp;tohoto důvodu se budeme snažit omezit vliv I/O
operací na rozumné minimum. Využijeme přitom faktu, že u výpočtu Mandelbrotovy
množiny lze ponechat relativně malou velikost výsledného rastrového obrázku a
naopak zvýšit maximální počet iterací, což povede k&nbsp;razantnímu zvýšení
počtu FP operací.</p>

<p>Konkrétně to bude v&nbsp;našem konkrétním případě bude znamenat, že
rozlišení obrázku nastavíme na 256&times;256 pixelů, což je dostatečně velké
rozlišení pro odhalení chyby (&bdquo;fast math&ldquo;) ve výpočtu, ale počet
I/O operací se oproti největšímu obrázku z&nbsp;předchozích benchmarků sníží na
1/256, což je méně než 1% (a proto bude jejich vliv malý). A počet iterací
naopak vzroste až na 1000000, takže doby výpočtu budou v&nbsp;některých
případech přesahovat půl hodiny. </p>

<img src="https://i.iinfo.cz/images/656/numba3-1.webp" class="image-1110456" width="400" height="400" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 6: Výsledek výpočtu Mandelbrotovy množiny při nastavení
maximálního množství iterací na 100&nbsp;000.</i></p>

<img src="https://i.iinfo.cz/images/656/numba3-2.webp" class="image-1110457" width="400" height="400" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 7: Výsledek výpočtu Mandelbrotovy množiny při nastavení
maximálního množství iterací na 1&nbsp;000&nbsp;000.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Paralelizace výsledného kódu JIT překladačem Numba</h2>

<p>Další optimalizace, kterou Numba dokáže zajistit, je paralelizace části
kódu, typicky programové smyčky nebo častého volání nějaké funkce. Pro tento
účel se používá parametr <strong>parallel=True</strong> předaný dekorátoru
<strong>@jit</strong> a navíc je vhodné při generování indexů atd. použít
namísto vestavěného generátoru <strong>range</strong> jeho paralelní variantu
<strong>prange</strong>. Jak ale takový paralelní výpočet probíhá? Kód,
resp.&nbsp;jednotlivé iterace nebo celé volání funkce, je spouštěn ve vláknech.
Počet vláken lze nastavit; výchozí hodnota odpovídá počtu procesorových jader.
Co to znamená v&nbsp;praxi? Testování probíhá na počítači se šestnácti jádry a
tudíž <strong>prange</strong> rozdělí výpočet do šestnácti vláken, která běží
samostatně (protože v&nbsp;nativní části nemáme žádný GIL!).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Paralelizace kódu nemusí být zcela triviálním úkolem</h2>

<p>Mohlo by se zdát, že díky tomu, že nástroj Numba nabízí volbu
<strong>parallel=True</strong> a navíc i &bdquo;paralelní&ldquo; generátor
<strong>prange</strong> bude paralelizace kódu zcela triviální.
V&nbsp;některých případech je to samozřejmě pravda, ovšem platí to i pro náš
benchmark? Můžeme se o tom snadno přesvědčit jeho úpravou:</p>

<ol>
<li>Před hlavičku funkce uvedeme <strong>@jit(nopython=True, parallel=True)</strong></li>
<li>Vnější výpočetní smyčka bude používat <strong>prange</strong> a nikoli <strong>range</strong></li>
<li>Smyčka pro uložení bitmapy <i>nepoběží paralelně</i> (je snad zřejmé proč)</li>
<li>Přístup do pole <strong>iters</strong> lze provést z&nbsp;více vláken, pokud se nebude jednat o stejnou buňku</li>
</ol>

<p>Vnější smyčka se tedy změní takto:</p>

<pre>
    <i># calc part</i>
    cy = -1.5
    for y in <u>prange(0, height)</u>:
        ...
        ...
        ...
        cy += 3.0/height
</pre>

<p>Upravený kód demonstračního příkladu bude vypadat následovně:</p>

<pre>
<i>#!/usr/bin/env python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
import palette_mandmap
from sys import argv, exit
&nbsp;
import numpy as np
from numba import jit, prange
&nbsp;
&nbsp;
<u>@jit(nopython=True, parallel=True)</u>
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
    iters = np.empty((height, width), dtype=np.uint8)
&nbsp;
    <i># calc part</i>
    cy = -1.5
    for y in <u>prange(0, height)</u>:
        cx = -2.0
        for x in range(0, width):
            zx = 0.0
            zy = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 &gt; 4.0:
                    break
                zy = 2.0 * zx * zy + cy
                zx = zx2 - zy2 + cx
                i += 1
            iters[y][x] = i
&nbsp;
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
    <i># image export part</i>
    print("P3")
    print(width)
    print(height)
    print("255")
    for y in range(0, height):
        for x in range(0, width):
            i = iters[y][x]
            r = palette[i % 256][0]
            g = palette[i % 256][1]
            b = palette[i % 256][2]
            print(r)
            print(g)
            print(b)
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        width = 512
        height = 512
        maxiter = 255
    else:
        width = int(argv[1])
        height = int(argv[2])
        maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výsledek běhu příkladu upraveného do paralelní podoby</h2>

<p></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<p></p>

<pre>
#!/usr/bin/env python
# vim: set fileencoding=utf-8
&nbsp;
import palette_mandmap
from sys import argv, exit
&nbsp;
import numpy as np
from numba import jit, prange
from numba.types import UniTuple, int64
&nbsp;
&nbsp;
@jit(nopython=True)
def calc_pixel(maxiter, cx, cy):
    zx = 0.0
    zy = 0.0
    i = 0
    while i &lt; maxiter:
        zx2 = zx * zx
        zy2 = zy * zy
        if zx2 + zy2 &gt; 4.0:
            break
        zy = 2.0 * zx * zy + cy
        zx = zx2 - zy2 + cx
        i += 1
    return i
&nbsp;
&nbsp;
@jit((int64, int64, int64, UniTuple(UniTuple(int64, 3), 256)), nopython=True, parallel=True)
def calc_mandelbrot(width, height, maxiter, palette):
    iters = np.empty((height, width), dtype=np.uint8)
&nbsp;
    # calc part
    for y in prange(0, height):
        cy = -1.5 + 3.0*y/height
        cx = -2.0
        for x in range(0, width):
            i = calc_pixel(maxiter, cx, cy)
            iters[y][x] = i
&nbsp;
            cx += 3.0/width
        cy += 3.0/height
&nbsp;
    # image export part
    print("P3")
    print(width)
    print(height)
    print("255")
    for y in range(0, height):
        for x in range(0, width):
            i = iters[y][x]
            r = palette[i % 256][0]
            g = palette[i % 256][1]
            b = palette[i % 256][2]
            print(r)
            print(g)
            print(b)
&nbsp;
&nbsp;
if __name__ == "__main__":
    if len(argv) &lt; 4:
        width = 512
        height = 512
        maxiter = 255
    else:
        width = int(argv[1])
        height = int(argv[2])
        maxiter = int(argv[3])
    calc_mandelbrot(width, height, maxiter, palette_mandmap.palette)
    # calc_mandelbrot.parallel_diagnostics(level=4)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<p></p>

<pre>
iterations="1 10 100 1000 10000 100000 1000000"
&nbsp;
OUTFILE="numba7.times"
PREFIX="numba7"
&nbsp;
rm $OUTFILE
&nbsp;
for iter in $iterations
do
    echo $iter
    echo -n "$iter " &gt;&gt; $OUTFILE
    /usr/bin/time --output $OUTFILE --append --format "%e %M" python3 mandelbrot_python.py 256 256 $iter 255 &gt; "${PREFIX}_${iter}.ppm"
done
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<p></p>




<a href="https://www.root.cz/obrazek/1110445/"><img src="https://i.iinfo.cz/images/134/numba3-5-prev.webp" class="image-1110445" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/134/numba3-5-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/134/numba3-5-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>

<a href="https://www.root.cz/obrazek/1110446/"><img src="https://i.iinfo.cz/images/134/numba3-6-prev.webp" class="image-1110446" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/134/numba3-6-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/134/numba3-6-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>

<a href="https://www.root.cz/obrazek/1110447/"><img src="https://i.iinfo.cz/images/134/numba3-7-prev.webp" class="image-1110447" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/134/numba3-7-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/134/numba3-7-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>

<a href="https://www.root.cz/obrazek/1110448/"><img src="https://i.iinfo.cz/images/134/numba3-8-prev.webp" class="image-1110448" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/134/numba3-8-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/134/numba3-8-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>

<a href="https://www.root.cz/obrazek/1110449/"><img src="https://i.iinfo.cz/images/134/numba3-9-prev.webp" class="image-1110449" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/134/numba3-9-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/134/numba3-9-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>

<a href="https://www.root.cz/obrazek/1110450/"><img src="https://i.iinfo.cz/images/134/numba3-10-prev.webp" class="image-1110450" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/134/numba3-10-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/134/numba3-10-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: Pavel Tisnovsky, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<p></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Zdrojové kódy benchmarků použitých v&nbsp;dnešním článku</h2>

<p>Pro změření výkonnosti různých variant spuštění projektů naprogramovaných
v&nbsp;Pythonu bylo použito celkem deset verzí zdrojových kódů benchmarku.
První verze je určena pro klasický CPython (my jsme využili verze 3.8 až 3.12),
dalších šest verzí jsou určeny pro použití společně s&nbsp;JIT překladačem
Numba (přičemž dvě verze umožní paralelní běh ve více vláknech). Následují dvě
verze určené pro AOT překladač Mypy a konečně poslední verze byla přepsána do
ANSI C, abychom mohli porovnat, jak může být sémanticky totožný kód rychlejší
při použití odlišného ekosystému:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>mandelbrot-v1</td><td>benchmark, v&nbsp;němž se nepoužívají anotace projektu Numba</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v1/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v1/</a></td></tr>
<tr><td> 2</td><td>mandelbrot-v2</td><td>použití anotace <strong>@jit</strong> ve funkci, v&nbsp;níž se provádí mnoho výpočtů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v2/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v2/</a></td></tr>
<tr><td> 3</td><td>mandelbrot-v3</td><td>volání zjednodušených variant funkce <strong>print</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v3/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v3/</a></td></tr>
<tr><td> 4</td><td>mandelbrot-v4</td><td>použití anotace <strong>@jit</strong> s&nbsp;parametrem <strong>nopython</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v4/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v4/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>mandelbrot-v5</td><td>úprava předchozího příkladu: rozdělení části provádějící výpočet od části provádějící export obrázku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v5/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v5/</a></td></tr>
<tr><td> 6</td><td>mandelbrot-v6</td><td>úprava příkladu tak, aby byl umožněn jeho běh ve více vláknech (s&nbsp;nekorektním výsledkem)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v6/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v6/</a></td></tr>
<tr><td> 7</td><td>mandelbrot-v7</td><td>přidání typových informací pro zlepšení rychlosti paralelního běhu benchmarku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v7/">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/mandelbrot-v7/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>mypyc/mandelbrot_5</td><td>varianta benchmarku určená pro překlad s&nbsp;využitím <strong>mypyc</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot_5.py</a></td></tr>
<tr><td> 9</td><td>mypyc/mandelbrot_6</td><td>přidání typových informací využitelných AOT překladačem <strong>mypyc</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>mandelbrot.c</td><td>varianta benchmarku naprogramovaná v&nbsp;ANSI C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot.c">https://github.com/tisnik/most-popular-python-libs/blob/master/mypyc/mandelbrot.c</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady pro nástroj Numba</h2>

<p>Všechny demonstrační příklady ukazující vlastnosti nástroje Numba naleznete
v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 1</td><td>sum1.py</td><td>funkce pro výpočet součtu dvou prvků, které je volána s&nbsp;argumenty typu <strong>int64</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum1.py</a></td></tr>
<tr><td> 2</td><td>sum2.py</td><td>funkce pro výpočet součtu dvou prvků, které je volána s&nbsp;argumenty typu <strong>double/float64</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum2.py</a></td></tr>
<tr><td> 3</td><td>sum3.py</td><td>funkce pro výpočet součtu dvou prvků volaná s&nbsp;argumenty různých typů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum3.py</a></td></tr>
<tr><td> 4</td><td>sum4.py</td><td>součet dvou polí z&nbsp;balíčku <i>Numpy</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum4.py</a></td></tr>
<tr><td> 5</td><td>sum5.py</td><td>porovnání různých variant součtu dvou polí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum5.py</a></td></tr>
<tr><td> 6</td><td>sum6.py</td><td>dtto, ale pro větší počet volání funkce pro provedení součtu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>sum_array.py</td><td>explicitní zápis součtu všech prvků pole</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_array.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_array.py</a></td></tr>
<tr><td> 8</td><td>range_loop.py</td><td>využití funkce <strong>range</strong> ve smyčce <strong>for</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/range_loop.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/range_loop.py</a></td></tr>
<tr><td> 9</td><td>prange_loop.py</td><td>paralelní varianta funkce <strong>range</strong> ve smyčce <strong>for</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/prange_loop.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/prange_loop.py</a></td></tr>
<tr><td>10</td><td>sum_sqrts1.py</td><td>výpočet prováděný ve smyčce s&nbsp;akumulací výsledku</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts1.py</a></td></tr>
<tr><td>11</td><td>sum_sqrts2.py</td><td>dtto, ovšem provedení v&nbsp;režimu <strong>nopython</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts2.py</a></td></tr>
<tr><td>12</td><td>sum_sqrts3.py</td><td>zapnutí režimu <i>fast array</i> při výpočtech</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/numba/sum_sqrts3.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Python 3.12: More Faster and More Efficient Python<br />
<a href="https://medium.com/@HeCanThink/python-3-12-more-faster-and-more-efficient-python-b636f00b047">https://medium.com/@HeCanThink/python-3-12-more-faster-and-more-efficient-python-b636f00b047</a>
</a>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy/</a>
</a>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (2.část)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-2-cast/</a>
</a>

<li>Statické typové kontroly zdrojových kódů Pythonu prováděné nástrojem Mypy (3)<br />
<a href="https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/">https://www.root.cz/clanky/staticke-typove-kontroly-zdrojovych-kodu-pythonu-provadene-nastrojem-mypy-3/</a>
</a>

<li>mypy homepage<br />
<a href="https://www.mypy-lang.org/">https://www.mypy-lang.org/</a>
</li>

<li>mypy documentation<br />
<a href="https://mypy.readthedocs.io/en/stable/">https://mypy.readthedocs.io/en/stable/</a>
</li>

<li>Mypy na PyPi Optional static typing for Python<br />
<a href="https://pypi.org/project/mypy/">https://pypi.org/project/mypy/</a>
</li>

<li>5 Reasons Why You Should Use Type Hints In Python<br />
<a href="https://www.youtube.com/watch?v=dgBCEB2jVU0">https://www.youtube.com/watch?v=dgBCEB2jVU0</a>
</li>

<li>Python Typing &ndash; Type Hints &amp; Annotations<br />
<a href="https://www.youtube.com/watch?v=QORvB-_mbZ0">https://www.youtube.com/watch?v=QORvB-_mbZ0</a>
</li>

<li>What Problems Can TypeScript Solve?<br />
<a href="https://www.typescriptlang.org/why-create-typescript">https://www.typescriptlang.org/why-create-typescript</a>
</li>

<li>How to find code that is missing type annotations?<br />
<a href="https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations">https://stackoverflow.com/questions/59898490/how-to-find-code-that-is-missing-type-annotations</a>
</li>

<li>Do type annotations in Python enforce static type checking?<br />
<a href="https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking">https://stackoverflow.com/questions/54734029/do-type-annotations-in-python-enforce-static-type-checking</a>
</li>

<li>Understanding type annotation in Python<br />
<a href="https://blog.logrocket.com/understanding-type-annotation-python/">https://blog.logrocket.com/understanding-type-annotation-python/</a>
</li>

<li>Static type checking with Mypy — Perfect Python<br />
<a href="https://www.youtube.com/watch?v=9gNnhNxra3E">https://www.youtube.com/watch?v=9gNnhNxra3E</a>
</li>

<li>Static Type Checker for Python<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Differences Between Pyright and Mypy<br />
<a href="https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md">https://github.com/microsoft/pyright/blob/main/docs/mypy-comparison.md</a>
</li>

<li>4 Python type checkers to keep your code clean<br />
<a href="https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html">https://www.infoworld.com/article/3575079/4-python-type-checkers-to-keep-your-code-clean.html</a>
</li>

<li>Pyre: A performant type-checker for Python 3<br />
<a href="https://pyre-check.org/">https://pyre-check.org/</a>
</li>

<li>"Typing the Untyped: Soundness in Gradual Type Systems" by Ben Weissmann<br />
<a href="https://www.youtube.com/watch?v=uJHD2xyv7xo">https://www.youtube.com/watch?v=uJHD2xyv7xo</a>
</li>

<li>Covariance and contravariance (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a>
</li>

<li>Functional Programming: Type Systems<br />
<a href="https://www.youtube.com/watch?v=hy1wjkcIBCU">https://www.youtube.com/watch?v=hy1wjkcIBCU</a>
</li>

<li>A Type System From Scratch – Robert Widmann<br />
<a href="https://www.youtube.com/watch?v=IbjoA5xVUq0">https://www.youtube.com/watch?v=IbjoA5xVUq0</a>
</li>

<li>"Type Systems - The Good, Bad and Ugly" by Paul Snively and Amanda Laucher<br />
<a href="https://www.youtube.com/watch?v=SWTWkYbcWU0">https://www.youtube.com/watch?v=SWTWkYbcWU0</a>
</li>

<li>Type Systems: Covariance, Contravariance, Bivariance, and Invariance explained<br />
<a href="https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8">https://medium.com/@thejameskyle/type-systems-covariance-contravariance-bivariance-and-invariance-explained-35f43d1110f8</a>
</li>

<li>Statická vs. dynamická typová kontrola<br />
<a href="https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/">https://www.root.cz/clanky/staticka-dynamicka-typova-kontrola/</a>
</li>

<li>Typový systém<br />
<a href="https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m">https://cs.wikipedia.org/wiki/Typov%C3%BD_syst%C3%A9m</a>
</li>

<li>Comparison of programming languages by type system<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system</a>
</li>

<li>Flow<br />
<a href="https://flow.org/">https://flow.org/</a>
</li>

<li>TypeScript<br />
<a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a>
</li>

<li>Sorbet<br />
<a href="https://sorbet.org/">https://sorbet.org/</a>
</li>

<li>Pyright<br />
<a href="https://github.com/microsoft/pyright">https://github.com/microsoft/pyright</a>
</li>

<li>Mypy: Type hints cheat sheet<br />
<a href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html</a>
</li>

<li>PEP 484 – Type Hints<br />
<a href="https://peps.python.org/pep-0484/">https://peps.python.org/pep-0484/</a>
</li>

<li>Numba<br />
<a href="http://numba.pydata.org/">http://numba.pydata.org/</a>
</li>

<li>numba 0.57.0<br />
<a href="https://pypi.org/project/numba/">https://pypi.org/project/numba/</a>
</li>

<li>Pushing Python toward C speeds with SIMD <br />
<a href="https://laurenar.net/posts/python-simd/">https://laurenar.net/posts/python-simd/</a>
</li>

<li>Retrieve generated LLVM from Numba<br />
<a href="https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba">https://stackoverflow.com/questions/25213137/retrieve-generated-llvm-from-numba</a>
</li>

<li>Numba documentation<br />
<a href="http://numba.pydata.org/numba-doc/latest/index.html">http://numba.pydata.org/numba-doc/latest/index.html</a>
</li>

<li>Numba na GitHubu<br />
<a href="https://github.com/numba/numba">https://github.com/numba/numba</a>
</li>

<li>First Steps with numba<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_firststeps.html</a>
</li>

<li>Numba and types<br />
<a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html">https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html</a>
</li>

<li>Just-in-time compilation<br />
<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">https://en.wikipedia.org/wiki/Just-in-time_compilation</a>
</li>

<li>Cython (home page)<br />
<a href="http://cython.org/">http://cython.org/</a>
</li>

<li>Cython (wiki)<br />
<a href="https://github.com/cython/cython/wiki">https://github.com/cython/cython/wiki</a>
</li>

<li>Cython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cython">https://en.wikipedia.org/wiki/Cython</a>
</li>

<li>Cython (GitHub)<br />
<a href="https://github.com/cython/cython">https://github.com/cython/cython</a>
</li>

<li>Python Implementations: Compilers<br />
<a href="https://wiki.python.org/moin/PythonImplementations#Compilers">https://wiki.python.org/moin/PythonImplementations#Compilers</a>
</li>

<li>EmbeddingCython<br />
<a href="https://github.com/cython/cython/wiki/EmbeddingCython">https://github.com/cython/cython/wiki/EmbeddingCython</a>
</li>

<li>The Basics of Cython<br />
<a href="http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html">http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html</a>
</li>

<li>Overcoming Python's GIL with Cython<br />
<a href="https://lbolla.info/python-threads-cython-gil">https://lbolla.info/python-threads-cython-gil</a>
</li>

<li>GlobalInterpreterLock<br />
<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>
</li>

<li>The Magic of RPython<br />
<a href="https://refi64.com/posts/the-magic-of-rpython.html">https://refi64.com/posts/the-magic-of-rpython.html</a>
</li>

<li>RPython: Frequently Asked Questions<br />
<a href="http://rpython.readthedocs.io/en/latest/faq.html">http://rpython.readthedocs.io/en/latest/faq.html</a>
</li>

<li>RPython’s documentation<br />
<a href="http://rpython.readthedocs.io/en/latest/index.html">http://rpython.readthedocs.io/en/latest/index.html</a>
</li>

<li>RPython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/PyPy#RPython">https://en.wikipedia.org/wiki/PyPy#RPython</a>
</li>

<li>Getting Started with RPython<br />
<a href="http://rpython.readthedocs.io/en/latest/getting-started.html">http://rpython.readthedocs.io/en/latest/getting-started.html</a>
</li>

<li>PyPy (home page)<br />
<a href="https://pypy.org/">https://pypy.org/</a>
</li>

<li>PyPy (dokumentace)<br />
<a href="http://doc.pypy.org/en/latest/">http://doc.pypy.org/en/latest/</a>
</li>

<li>Localized Type Inference of Atomic Types in Python (2005)<br />
<a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231</a>
</li>

<li>Tutorial: Writing an Interpreter with PyPy, Part 1<br />
<a href="https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html">https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html</a>
</li>

<li>List of numerical analysis software<br />
<a href="https://en.wikipedia.org/wiki/List_of_numerical_analysis_software">https://en.wikipedia.org/wiki/List_of_numerical_analysis_software</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>The future can be written in RPython now (článek z&nbsp;roku 2010)<br />
<a href="http://blog.christianperone.com/2010/05/the-future-can-be-written-in-rpython-now/">http://blog.christianperone.com/2010/05/the-future-can-be-written-in-rpython-now/</a>
</li>

<li>PyPy is the Future of Python (článek z&nbsp;roku 2010)<br />
<a href="https://alexgaynor.net/2010/may/15/pypy-future-python/">https://alexgaynor.net/2010/may/15/pypy-future-python/</a>
</li>

<li>Portal:Python programming<br />
<a href="https://en.wikipedia.org/wiki/Portal:Python_programming">https://en.wikipedia.org/wiki/Portal:Python_programming</a>
</li>

<li>RPython Frontend and C Wrapper Generator<br />
<a href="http://www.codeforge.com/article/383293">http://www.codeforge.com/article/383293</a>
</li>

<li>PyPy’s Approach to Virtual Machine Construction<br />
<a href="https://bitbucket.org/pypy/extradoc/raw/tip/talk/dls2006/pypy-vm-construction.pdf">https://bitbucket.org/pypy/extradoc/raw/tip/talk/dls2006/pypy-vm-construction.pdf</a>
</li>

<li>Tutorial: Writing an Interpreter with PyPy, Part 1<br />
<a href="https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html">https://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html</a>
</li>

<li>A simple interpreter from scratch in Python (part 1)<br />
<a href="http://www.jayconrod.com/posts/37/a-simple-interpreter-from-scratch-in-python-part-1">http://www.jayconrod.com/posts/37/a-simple-interpreter-from-scratch-in-python-part-1</a>
</li>

<li>Brainfuck Interpreter in Python<br />
<a href="https://helloacm.com/brainfuck-interpreter-in-python/">https://helloacm.com/brainfuck-interpreter-in-python/</a>
</li>

<li>Interpretry, překladače, JIT překladače a transpřekladače programovacího jazyka Lua<br />
<a href="https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/">https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (5 – tabulky a pole)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (6 – překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (7 – dokončení popisu mezijazyka LuaJITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (8 – základní vlastnosti trasovacího JITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (9 – další vlastnosti trasovacího JITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (10 – JIT překlad do nativního kódu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (11 – JIT překlad do nativního kódu procesorů s architekturami x86 a ARM)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (12 – překlad operací s reálnými čísly)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

<li>Podpora SIMD (vektorových) instrukcí na RISCových procesorech<br />
<a href="https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/">https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/</a>
</li>

<li>Užitečné rozšíření GCC – podpora SIMD (vektorových) instrukcí: nedostatky technologie<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic pro nízkoúrovňové optimalizace<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic: technologie SSE<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/</a>
</li>

<li>Rozšíření instrukční sady „Advanced Vector Extensions“ na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady F16C, FMA a AVX-512 na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/</a>
</li>

<li>Použití instrukcí SSE a AVX pro zrychlení bitových operací<br />
<a href="https://www.root.cz/clanky/pouziti-instrukci-sse-a-avx-pro-zrychleni-bitovych-operaci/">https://www.root.cz/clanky/pouziti-instrukci-sse-a-avx-pro-zrychleni-bitovych-operaci/</a>
</li>

<li>Rozšíření instrukční sady AVX-512 na platformě x86–64 (dokončení)<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/</a>
</li>

<li>Nuitka<br />
<a href="https://github.com/Nuitka/Nuitka">https://github.com/Nuitka/Nuitka</a>
</li>

<li>SIMD Autovectorization in Numba<br />
<a href="https://tbetcke.github.io/hpc_lecture_notes/simd.html">https://tbetcke.github.io/hpc_lecture_notes/simd.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

