<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetí části článku o lexikální a syntaktické analýze zdrojových kódů napsaných v Pythonu si ukážeme, jak lze analyzovat AST i jak se provádí překlad kódu reprezentovaného AST do bajtkódu Pythonu. Taktéž si ukážeme, jak je možné tento bajtkód zobrazit v čitelné podobě.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)</a></p>
<p><a href="#k02">2. Krátké zopakování z&nbsp;minula &ndash; návrhový vzor Visitor</a></p>
<p><a href="#k03">3. Složitější zdrojový kód, jehož AST budeme analyzovat</a></p>
<p><a href="#k04">4. Průchod abstraktním syntaktickým stromem složitějšího programového kódu</a></p>
<p><a href="#k05">5. Filtrace uzlů v&nbsp;AST &ndash; výpis definic všech funkcí a metod</a></p>
<p><a href="#k06">6. Informace o modulu, definovaných třídách i definovaných funkcích a metodách</a></p>
<p><a href="#k07">7. Příklad dalších typů uzlů AST: hlavička programové smyčky for</a></p>
<p><a href="#k08">*** 8. Uzly AST využívané ve výrazech</a></p>
<p><a href="#k09">*** 9. Realizace průchodu stromem pro zpracování výrazu</a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">13. Bajtkód virtuálního stroje Pythonu</a></p>
<p><a href="#k14">14. Zásobníkové vs. registrové virtuální stroje</a></p>
<p><a href="#k15">15. Příklady funkcí přeložených do bajtkódu Pythonu</a></p>
<p><a href="#k16">16. Dekompilace bajtkódu pro jednoduchý výraz s&nbsp;konstantami</a></p>
<p><a href="#k17">17. Dekompilace bajtkódu složitějšího příkazu</a></p>
<p><a href="#k18">18. Příloha: definice gramatiky programovacího jazyka Python</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)</h2>

<p>V&nbsp;předchozích dvou částech článku o lexikální a syntaktické analýze
zdrojových kódů napsaných v&nbsp;Pythonu [<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">1</a>]
[<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">2</a>]
jsme se seznámili se základními vlastnostmi standardních knihoven nazvaných
<strong>tokenize</strong> a <strong>ast</strong>. Připomeňme si, že knihovna
<strong>tokenize</strong> nám zpřístupňuje takzvaný <i>lexer</i> (někdy
nazývaný právě i <i>tokenizer</i>), zatímco knihovna <strong>ast</strong>
programátorům umožňuje transformovat buď přímo zdrojový kód nebo sekvenci
tokenů do formy abstraktního syntaktického stromu (AST). Dnes si ukážeme, jak
se AST překládá do bajtkódu (s&nbsp;mezikrokem spočívajícím ve vytvoření
tabulky symbolů) i způsob zobrazení bajtkódu v&nbsp;čitelné podobě.</p>

<p>Cesta od zdrojového kódu k&nbsp;bajtkódu se tedy skládá z&nbsp;několika
transformací:</p>

<ol>
<li>Zdrojový kód (tedy vlastně 2D struktura) je transformován na sekvenci tokenů</li>
<li>Sekvence tokenů (lineární struktura) je transformována do formy stromu (AST)</li>
<li>AST je optimalizován (transformace strom-&rarr;strom)</li>
<li>AST je přeložen do bajtkódu (lineární sekvence instrukcí)</li>
</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Krátké zopakování z&nbsp;minula &ndash; návrhový vzor Visitor</h2>

<p>V&nbsp;<a
href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">předchozím
článku o lexikální a syntaktické analýze zdrojových kódů napsaných
v&nbsp;Pythonu</a> jsme si popsali způsob použití návrhového vzoru
&bdquo;visitor&ldquo;. Ten se používá mj.&nbsp;i pro realizaci průchodu
abstraktním syntaktickým stromem za účelem jeho analýzy, provádění různých
manipulací (optimalizací) atd. Připomeňme si ve stručnosti, jak lze průchod
stromem realizovat. Konkrétně se bude jednat o průchod všemi uzly AST, bez
ohledu na typ uzlů:</p>

<pre>
import ast
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>visit</strong>(self, node):
        print(node)
        <strong>self.generic_visit(node)</strong>
&nbsp;
&nbsp;
tree = ast.parse("1+2*3")
&nbsp;
visitor = <strong>Visitor()</strong>
<strong>visitor.visit(tree)</strong>
</pre>

<p>Výsledkem po spuštění tohoto skriptu bude zobrazení informace o devíti
uzlech AST:</p>

<pre>
$ <strong>python3 traverse_expression_2.py </strong>
&nbsp;
&lt;_ast.Module object at 0x7f59ac3320d0&gt;
&lt;_ast.Expr object at 0x7f59ac3324f0&gt;
&lt;_ast.BinOp object at 0x7f59ac26d610&gt;
&lt;_ast.Constant object at 0x7f59ac26d640&gt;
&lt;_ast.Add object at 0x7f59ac28fe50&gt;
&lt;_ast.BinOp object at 0x7f59ac26d820&gt;
&lt;_ast.Constant object at 0x7f59ac26d880&gt;
&lt;_ast.Mult object at 0x7f59ac28ff10&gt;
&lt;_ast.Constant object at 0x7f59ac26d8e0&gt;
</pre>

<p>Výhodnější bude, když vhodným způsobem zvýrazníme úroveň jednotlivých uzlů
v&nbsp;rámci AST, od uzlu kořenového po listy stromu:</p>

<pre>
import ast
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 1
&nbsp;
    def <strong>visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        <strong>self.generic_visit(node)</strong>
        self.nest_level -= 1
&nbsp;
&nbsp;
tree = ast.parse("1+2*3+1")
&nbsp;
visitor = <strong>Visitor()</strong>
<strong>visitor.visit(tree)</strong>
</pre>

<p>Nyní bude již výsledek čitelnější (i když ne příliš):</p>

<pre>
$ <strong>python3 traverse_expression_3.py </strong>
&nbsp;
   &lt;_ast.Module object at 0x7f21f20fc0d0&gt;
     &lt;_ast.Expr object at 0x7f21f20fc4f0&gt;
       &lt;_ast.BinOp object at 0x7f21f20376d0&gt;
         &lt;_ast.BinOp object at 0x7f21f2037700&gt;
           &lt;_ast.Constant object at 0x7f21f20377f0&gt;
           &lt;_ast.Add object at 0x7f21f2059ee0&gt;
           &lt;_ast.BinOp object at 0x7f21f2037910&gt;
             &lt;_ast.Constant object at 0x7f21f2037940&gt;
             &lt;_ast.Mult object at 0x7f21f2059fa0&gt;
             &lt;_ast.Constant object at 0x7f21f2037a00&gt;
         &lt;_ast.Add object at 0x7f21f2059ee0&gt;
         &lt;_ast.Constant object at 0x7f21f2037880&gt;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Složitější zdrojový kód, jehož AST budeme analyzovat</h2>

<p>V&nbsp;rámci navazujících kapitol budeme analyzovat AST <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/sprites.py">tohoto
skriptu</a>. Jedná se o skript, v&nbsp;němž je deklarována třída
s&nbsp;několika metodami a taktéž jsou zde deklarovány běžné funkce (skript je
přitom spustitelný, a to za předpokladu, že máte nainstalovánu knihovnu <a
href="https://www.pygame.org/news">Pygame</a>:</p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>
&nbsp;
<i># Demonstrační příklady využívající knihovnu Pygame</i>
&nbsp;
<i># Příklad číslo 22: použití spritů, pohyblivý sprite</i>
&nbsp;
import pygame
import sys
import os
import math
&nbsp;
<i># Nutno importovat kvůli konstantám QUIT atd.</i>
from pygame.locals import *
&nbsp;
<i># Velikost okna aplikace</i>
WIDTH = 320
HEIGHT = 240
&nbsp;
&nbsp;
<i># Třída představující sprite zobrazený jako jednobarevný čtverec.</i>
class <strong>BlockySprite</strong>(pygame.sprite.Sprite):
    <i># Konstruktor</i>
    def <strong>__init__</strong>(self, color, size, x, y):
        <i># Nejprve je nutné zavolat konstruktor předka,</i>
        <i># tj. konstruktor třídy pygame.sprite.Sprite:</i>
        pygame.sprite.Sprite.__init__(self)
&nbsp;
        <i># Vytvoření obrázku představujícího vizuální obraz spritu:</i>
        self.image = pygame.Surface([size, size])
        self.image.fill(color)
&nbsp;
        <i># Vytvoření obalového obdélníku</i>
        <i># (velikost se získá z rozměru obrázku)</i>
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
&nbsp;
        <i># Počáteční rychlost spritu</i>
        self.speed_x = 0
        self.speed_y = 0
&nbsp;
    <i># Nastavení barvy spritu, který kolidoval s hráčem</i>
    def <strong>yellowColor</strong>(self):
        self.image.fill(YELLOW)
&nbsp;
    <i># Nastavení barvy spritu, který nekolidoval s hráčem</i>
    def <strong>grayColor</strong>(self):
        self.image.fill(GRAY)
&nbsp;
&nbsp;
<i># Inicializace knihovny Pygame</i>
pygame.init()
&nbsp;
clock = pygame.time.Clock()
&nbsp;
<i># Vytvoření okna pro vykreslování</i>
display = pygame.display.set_mode([WIDTH, HEIGHT])
&nbsp;
<i># Nastavení titulku okna</i>
pygame.display.set_caption("Pygame test #22")
&nbsp;
<i># Konstanty s n-ticemi představujícími základní barvy</i>
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GRAY = (128, 128, 128)
YELLOW = (255, 255, 0)
&nbsp;
<i># Objekt sdružující všechny sprity</i>
all_sprites = pygame.sprite.Group()
<i># Objekt sdružující všechny sprity kromě hráče</i>
all_sprites_but_player = pygame.sprite.Group()
&nbsp;
<i># Vytvoření několika typů spritů</i>
<i>#                    barva  x   y velikost</i>
wall1 = BlockySprite(GRAY, 50, 10, 10)
wall2 = BlockySprite(GRAY, 15, 100, 100)
wall3 = BlockySprite(GRAY, 15, 100, 150)
wall4 = BlockySprite(GRAY, 15, 200, 100)
wall5 = BlockySprite(GRAY, 15, 200, 150)
wall6 = BlockySprite(GRAY, 15, 150, 100)
wall7 = BlockySprite(GRAY, 15, 150, 150)
player = BlockySprite(RED, 40, WIDTH / 2 - 20, HEIGHT / 2 - 20)
&nbsp;
<i># Přidání několika dalších spritů do seznamu</i>
<i># (jen jeden sprite - ten poslední - bude ve skutečnosti pohyblivý)</i>
all_sprites.add(wall1)
all_sprites.add(wall2)
all_sprites.add(wall3)
all_sprites.add(wall4)
all_sprites.add(wall5)
all_sprites.add(wall6)
all_sprites.add(wall7)
all_sprites.add(player)
&nbsp;
<i># Seznam všech nepohyblivých spritů</i>
all_sprites_but_player.add(wall1)
all_sprites_but_player.add(wall2)
all_sprites_but_player.add(wall3)
all_sprites_but_player.add(wall4)
all_sprites_but_player.add(wall5)
all_sprites_but_player.add(wall6)
all_sprites_but_player.add(wall7)
&nbsp;
&nbsp;
<i># Posun všech spritů ve skupině na základě jejich rychlosti</i>
def <strong>move_sprites</strong>(sprite_group, playground_width, playground_height):
    for sprite in sprite_group:
        <i># Posun spritu</i>
        sprite.rect.x = sprite.rect.x + sprite.speed_x
        sprite.rect.y = sprite.rect.y + sprite.speed_y
        <i># Kontrola, zda sprite nenarazil do okrajů okna</i>
        if sprite.rect.x &lt; 0:
            sprite.rect.x = 0
            sprite.speed_x = 0
        if sprite.rect.x + sprite.rect.width &gt; playground_width:
            sprite.rect.x = playground_width - sprite.rect.width
            sprite.speed_x = 0
        if sprite.rect.y &lt; 0:
            sprite.rect.y = 0
            sprite.speed_y = 0
        if sprite.rect.y + sprite.rect.height &gt; playground_height:
            sprite.rect.y = playground_height - sprite.rect.height
            sprite.speed_y = 0
&nbsp;
&nbsp;
<i># Vykreslení celé scény na obrazovku</i>
def <strong>draw_scene</strong>(display, background_color, sprite_group):
    <i># Vyplnění plochy okna černou barvou</i>
    display.fill(background_color)
    <i># Vykreslení celé skupiny spritů do bufferu</i>
    sprite_group.draw(display)
    <i># Obnovení obsahu obrazovky (překlopení zadního a předního bufferu)</i>
    pygame.display.update()
&nbsp;
&nbsp;
<i># Změna barvy spritu na základě kolize s hráčem</i>
def <strong>change_colors</strong>(sprite_group, hit_list):
    <i># Projít všemi sprity ze skupiny, kterou detekovala kolizní funkce</i>
    for sprite in sprite_group:
        if sprite in hit_list:
            sprite.yellowColor()
        else:
            sprite.grayColor()
&nbsp;
&nbsp;
<i># Zjistí kolize spritu se "stěnami" (nepohyblivými sprity)</i>
def <strong>check_collisions</strong>(player, sprite_group):
    <i># Vytvoření seznamu spritů, které kolidují s hráčem</i>
    hit_list = pygame.sprite.spritecollide(player, sprite_group, False)
    <i># Změna barev kolidujících spritů</i>
    change_colors(sprite_group, hit_list)
    collisions = len(hit_list)
    <i># Přenastavení titulku okna</i>
    caption = "Pygame test #22: collisions " + str(collisions)
    pygame.display.set_caption(caption)
&nbsp;
&nbsp;
<i># Hlavní herní smyčka</i>
while True:
    <i># Načtení a zpracování všech událostí z fronty</i>
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
        if event.type == KEYDOWN:
            if event.key == K_ESCAPE:
                pygame.quit()
                sys.exit()
            <i># Stiskem kurzorových kláves je možné měnit směr pohybu spritu</i>
            elif event.key == pygame.K_LEFT:
                player.speed_x = -3
            elif event.key == pygame.K_RIGHT:
                player.speed_x = +3
            elif event.key == pygame.K_UP:
                player.speed_y = -3
            elif event.key == pygame.K_DOWN:
                player.speed_y = +3
        if event.type == KEYUP:
            <i># Puštění kurzorových kláves vede k zastavení pohybu spritu</i>
            if event.key == pygame.K_LEFT:
                player.speed_x = 0
            elif event.key == pygame.K_RIGHT:
                player.speed_x = 0
            elif event.key == pygame.K_UP:
                player.speed_y = 0
            elif event.key == pygame.K_DOWN:
                player.speed_y = 0
&nbsp;
    move_sprites(all_sprites, display.get_width(), display.get_height())
    check_collisions(player, all_sprites_but_player)
    draw_scene(display, BLACK, all_sprites)
    clock.tick(20)
&nbsp;
<i># finito</i>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Průchod abstraktním syntaktickým stromem složitějšího programového kódu</h2>

<p>Složitější program, jako například skript uvedený <a
href="#k03">v&nbsp;předchozí kapitole</a>, je transformován do AST stejným
způsobem, jako jednoduchý výraz, což znamená, že i takovým AST je možné
procházet. Nevýhodou je, že AST je v&nbsp;tomto případě obrovský a má minimálně
stovky (spíše tisíce) uzlů:</p>

<pre>
import ast
&nbsp;
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 1
&nbsp;
    def <strong>visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
&nbsp;
with open("sprites.py") as fin:
    code = fin.read()
    tree = ast.parse(code)
    visitor = Visitor()
    visitor.visit(tree)
</pre>

<p>Výsledek je, jak jsme si již ostatně napsali, obrovský, takže v&nbsp;článku
uvedu jen malou část AST:</p>

<pre>
   &lt;_ast.Module object at 0x7fd31f665b80&gt;
     &lt;_ast.Import object at 0x7fd31f665ca0&gt;
       &lt;_ast.alias object at 0x7fd31f5fedf0&gt;
     &lt;_ast.Import object at 0x7fd31f5feeb0&gt;
       &lt;_ast.alias object at 0x7fd31f5fee80&gt;
     &lt;_ast.Import object at 0x7fd31f5fefd0&gt;
       &lt;_ast.alias object at 0x7fd31f5cf880&gt;
     &lt;_ast.Import object at 0x7fd31f5cf700&gt;
       &lt;_ast.alias object at 0x7fd31f5e8070&gt;
       ...
       ...
       ...
     &lt;_ast.ClassDef object at 0x7fd31f5e82b0&gt;
       &lt;_ast.Attribute object at 0x7fd31f5e8280&gt;
         &lt;_ast.Attribute object at 0x7fd31f5e8340&gt;
           &lt;_ast.Name object at 0x7fd31f5e83a0&gt;
             &lt;_ast.Load object at 0x7fd31f5efa60&gt;
           &lt;_ast.Load object at 0x7fd31f5efa60&gt;
         &lt;_ast.Load object at 0x7fd31f5efa60&gt;
       &lt;_ast.FunctionDef object at 0x7fd31f5e83d0&gt;
         &lt;_ast.arguments object at 0x7fd31f5e8430&gt;
           &lt;_ast.arg object at 0x7fd31f5e84c0&gt;
           &lt;_ast.arg object at 0x7fd31f5e84f0&gt;
           &lt;_ast.arg object at 0x7fd31f5e8520&gt;
           &lt;_ast.arg object at 0x7fd31f5e8550&gt;
           &lt;_ast.arg object at 0x7fd31f5e8580&gt;
       ...
       ...
       ...
       &lt;_ast.Expr object at 0x7fd31f5aceb0&gt;
         &lt;_ast.Call object at 0x7fd31f5acee0&gt;
           &lt;_ast.Attribute object at 0x7fd31f5acd60&gt;
             &lt;_ast.Name object at 0x7fd31f5acf10&gt;
               &lt;_ast.Load object at 0x7fd31f5efa60&gt;
             &lt;_ast.Load object at 0x7fd31f5efa60&gt;
           &lt;_ast.Constant object at 0x7fd31f5acf40&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Filtrace uzlů v&nbsp;AST &ndash; výpis definic všech funkcí a metod</h2>

<p>Předností návrhového vzoru &bdquo;Visitor&ldquo; tak, jak je implementován
v&nbsp;knihovně <strong>ast</strong>, je schopnost filtrovat uzly podle jejich
typu. Vše je založeno na gramatice Pythonu (viz <a href="#k18">osmnáctou
kapitolu</a>); podle symbolů v&nbsp;gramatice jsou pojmenovány příslušné metody
volané při &bdquo;návštěvě&ldquo; uzlů. Podívejme se na jednoduchý příklad
&ndash; nalezneme a vypíšeme všechny uzly s&nbsp;definicí funkce
popř.&nbsp;metody:</p>

<pre>
import ast
&nbsp;
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 0
&nbsp;
    def <strong>visit_FunctionDef</strong>(self, node):
        indent = " " * self.nest_level * 2
        print("{}def {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
&nbsp;
with open("sprites.py") as fin:
    code = fin.read()
    tree = ast.parse(code)
    visitor = Visitor()
    visitor.visit(tree)
</pre>

<p>Výsledkem budou v&nbsp;tomto případě skutečně jen jména deklarovaných funkcí
a metod:</p>

<pre>
def __init__:
def yellowColor:
def grayColor:
def move_sprites:
def draw_scene:
def change_colors:
def check_collisions:
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Informace o modulu, definovaných třídách i definovaných funkcích a metodách</h2>

<p>Můžeme jít ještě dále a zjistit, jaký modul je v&nbsp;AST reprezentován a
jaké zde nalezneme definice tříd. Díky tomu, že se v&nbsp;implementaci třídy
<strong>Visitor</strong> korektně pracuje s&nbsp;odsazením uzlů, snadno
rozlišíme i definici metody od definice funkce:</p>

<pre>
import ast
&nbsp;
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 0
&nbsp;
    def <strong>visit_Module</strong>(self, node):
        indent = " " * self.nest_level * 2
        print("{}module begin:".format(indent, node.__dict__))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
        print("{}module end".format(indent))
&nbsp;
    def <strong>visit_ClassDef</strong>(self, node):
        indent = " " * self.nest_level * 2
        print("{}class {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
    def <strong>visit_FunctionDef</strong>(self, node):
        indent = " " * self.nest_level * 2
        print("{}def {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
&nbsp;
with open("sprites.py") as fin:
    code = fin.read()
    tree = ast.parse(code)
    visitor = Visitor()
    visitor.visit(tree)
</pre>

<p>Z&nbsp;výsledku je patrné, že průchod AST nám dává poměrně dobré informace o
struktuře programového kódu (a proto IDE většinou pracují právě s&nbsp;AST a
nikoli přímo se zdrojovým kódem):</p>

<pre>
module begin:
  class BlockySprite:
    def __init__:
    def yellowColor:
    def grayColor:
  def move_sprites:
  def draw_scene:
  def change_colors:
  def check_collisions:
module end
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Příklad dalších typů uzlů AST: hlavička programové smyčky for</h2>

<p>Pro zajímavost se podívejme na to, jaké informace můžeme zjistit o bloku se
smyčkou <strong>for</strong>. I tento blok je v&nbsp;AST reprezentován
podstromem, jehož kořenovým uzlem je právě informace o smyčce
<strong>for</strong>:</p>

<pre>
import ast
&nbsp;
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 0
&nbsp;
    def <strong>visit_Module</strong>(self, node):
        indent = " " * self.nest_level * 2
        print("{}module begin:".format(indent, node.__dict__))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
        print("{}module end".format(indent))
&nbsp;
    def <strong>visit_ClassDef</strong>(self, node):
        indent = " " * self.nest_level * 2
        print("{}class {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
    def <strong>visit_For</strong>(self, node):
        indent = " " * self.nest_level * 2
        iterator = node.iter
        if type(iterator) == ast.Name:
            iterator = iterator.id
        elif type(iterator) == ast.Call:
            iterator = "call()"
&nbsp;
        print("{}for {} in {}:".format(indent, node.target.id, iterator))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
    def <strong>visit_FunctionDef</strong>(self, node):
        indent = " " * self.nest_level * 2
        print("{}def {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
&nbsp;
with open("sprites.py") as fin:
    code = fin.read()
    tree = ast.parse(code)
    visitor = Visitor()
    visitor.visit(tree)
</pre>

<p>Výsledek po spuštění skriptu bude vypadat následovně:</p>

<pre>
module begin:
  class BlockySprite:
    def __init__:
    def yellowColor:
    def grayColor:
  def move_sprites:
    for sprite in sprite_group:
  def draw_scene:
  def change_colors:
    for sprite in sprite_group:
  def check_collisions:
  for event in call():
module end
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Uzly AST využívané ve výrazech</h2>

<p></p>

<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1

    def visit(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node2string(node))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


def node2string(node):
    t = type(node)
    if t == ast.Constant:
        return "Constant: {}".format(node.value)
    elif t == ast.Name:
        return "Variable: {}".format(node.id)
    elif t == ast.Expr:
        return "Expression:"
    elif t == ast.BinOp:
        return "Binary operation"
    elif t == ast.Add:
        return "Operator: +"
    elif t == ast.Sub:
        return "Operator: -"
    elif t == ast.Mult:
        return "Operator: *"
    elif t == ast.Div:
        return "Operator: /"
    return ""


tree = ast.parse("a+2*(1-b/4)+c")

visitor = Visitor()
visitor.visit(tree)
</pre>

<pre>
     Expression:
       Binary operation
         Binary operation
           Variable: a
             
           Operator: +
           Binary operation
             Constant: 2
             Operator: *
             Binary operation
               Constant: 1
               Operator: -
               Binary operation
                 Variable: b
                   
                 Operator: /
                 Constant: 4
         Operator: +
         Variable: c
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Realizace průchodu stromem pro zpracování výrazu</h2>

<p></p>


<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1

    def visit_Constant(self, node):
        indent = " " * self.nest_level * 2
        print("{}Constant: {}".format(indent, node.value))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Name(self, node):
        indent = " " * self.nest_level * 2
        print("{}Variable: {}".format(indent, node.id))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Expr(self, node):
        indent = " " * self.nest_level * 2
        print("{}Expression:".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_BinOp(self, node):
        indent = " " * self.nest_level * 2
        print("{}Binary operator:".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Add(self, node):
        indent = " " * self.nest_level * 2
        print("{}+".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Sub(self, node):
        indent = " " * self.nest_level * 2
        print("{}-".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Mult(self, node):
        indent = " " * self.nest_level * 2
        print("{}*".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Div(self, node):
        indent = " " * self.nest_level * 2
        print("{}/".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


tree = ast.parse("a+2*(1-b/4)+c")

visitor = Visitor()
visitor.visit(tree)
</pre>

<pre>
  Expression:
    Binary operator:
      Binary operator:
        Variable: a
        +
        Binary operator:
          Constant: 2
          *
          Binary operator:
            Constant: 1
            -
            Binary operator:
              Variable: b
              /
              Constant: 4
      +
      Variable: c
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Tabulky symbolů</h2>

<p></p>

<pre>
import symtable


t = symtable.symtable("a+b*c", "<string>", "eval")

print("Symbol table:", t)
print("Type:", t.get_type())
print("Has children:", t.has_children())
print("Identifiers:", t.get_identifiers())

symbols = t.get_symbols()

print("\nList of symbols:")

for symbol in symbols:
    print(symbol.get_name())
</pre>

<pre>
Symbol table: <SymbolTable for module <string>>
Type: module
Has children: False
Identifiers: dict_keys(['a', 'b', 'c'])

List of symbols:
a
b
c
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Tabulka symbolů pro celý skript</h2>

<p></p>

<pre>
import symtable


with open("sprites.py") as fin:
    code = fin.read()
    t = symtable.symtable(code, "sprites.py", "exec")

print("Symbol table:", t)
print("Type:", t.get_type())
print("Has children:", t.has_children())
print("Identifiers:", t.get_identifiers())

symbols = t.get_symbols()

print("\nList of symbols:")

for symbol in symbols:
    print(symbol.get_name())
</pre>

<pre>
Symbol table: <SymbolTable for module sprites.py>
Type: module
Has children: True
Identifiers: dict_keys(['pygame', 'sys', 'os', 'math', 'WIDTH', 'HEIGHT', 'BlockySprite', 'clock', 'display', 'BLACK', 'RED', 'GRAY', 'YELLOW', 'all_sprites', 'all_sprites_but_player', 'wall1', 'wall2', 'wall3', 'wall4', 'wall5', 'wall6', 'wall7', 'player', 'move_sprites', 'draw_scene', 'change_colors', 'check_collisions', 'event', 'QUIT', 'KEYDOWN', 'K_ESCAPE', 'KEYUP'])

List of symbols:
pygame
sys
os
math
WIDTH
HEIGHT
BlockySprite
clock
display
BLACK
RED
GRAY
YELLOW
all_sprites
all_sprites_but_player
wall1
wall2
wall3
wall4
wall5
wall6
wall7
player
move_sprites
draw_scene
change_colors
check_collisions
event
QUIT
KEYDOWN
K_ESCAPE
KEYUP
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Transformace AST do bajtkódu</h2>

<p></p>

<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1

    def visit(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


tree = ast.parse("print(1+2*(1-3/4)+5)", mode="exec")

visitor = Visitor()
visitor.visit(tree)

print("Executing")

exec(compile(tree, filename="<ast>", mode="exec"))

print("Done")
</pre>

<pre>
   <_ast.Module object at 0x7f5898b55430>
     <_ast.Expr object at 0x7f5898a98670>
       <_ast.Call object at 0x7f5898a986a0>
         <_ast.Name object at 0x7f5898a987c0>
           <_ast.Load object at 0x7f5898ab2a00>
         <_ast.BinOp object at 0x7f5898a988b0>
           <_ast.BinOp object at 0x7f5898a988e0>
             <_ast.Constant object at 0x7f5898a98910>
             <_ast.Add object at 0x7f5898ab2e80>
             <_ast.BinOp object at 0x7f5898ac0d00>
               <_ast.Constant object at 0x7f5898ac0d30>
               <_ast.Mult object at 0x7f5898ab2f40>
               <_ast.BinOp object at 0x7f5898ac0d90>
                 <_ast.Constant object at 0x7f5898ac0dc0>
                 <_ast.Sub object at 0x7f5898ab2ee0>
                 <_ast.BinOp object at 0x7f5898ac0e20>
                   <_ast.Constant object at 0x7f5898ac0e80>
                   <_ast.Div object at 0x7f5898ac0040>
                   <_ast.Constant object at 0x7f5898ac0eb0>
           <_ast.Add object at 0x7f5898ab2e80>
           <_ast.Constant object at 0x7f5898a989a0>
Executing
6.5
Done
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Bajtkód virtuálního stroje Pythonu</h2>

<p>V&nbsp;této části článku si ve stručnosti popíšeme bajtkód využívaný
programovacím jazykem Python, konkrétně jeho původní verzí <i>CPython</i>
(kromě tohoto bajtkódu lze najít i další bajtkódy využívané některými
specifickými implementacemi Pythonu). S&nbsp;problematikou bajtkódů jsme se již
na stránkách Roota setkali. Víme například, že bajtkód JVM (Java Virtual
Machine) je poměrně nízkoúrovňový, zejména v&nbsp;porovnání s&nbsp;bajtkódem
používaným v&nbsp;programovacím jazyku Lua (resp.&nbsp;přesněji řečeno
virtuálním strojem tohoto jazyka). Totéž platí, a to dokonce ještě ve větší
míře, i pro bajtkód programovacího jazyka Python. Ten je opět založen na
konceptu zásobníku operandů (jako JVM), ovšem mnohé instrukce pracující
s&nbsp;jedním či dvěma operandy (samozřejmě uloženými na zásobníku) ve
skutečnosti mohou volat metody objektů a nikoli pouze provádět operace nad
primitivními datovými typy. Platí to především pro všechny
&bdquo;aritmetické&ldquo; operace, například i pro operátor +, který se
překládá do instrukce BINARY_ADD.</p>

<p>To například znamená, že se jednoduchá funkce <strong>add()</strong> se
dvěma operandy:</p>

<pre>
def add(x, y):
    return x+y
</pre>

<p>přeloží do následující čtveřice instrukcí bajtkódu:</p>

<pre>
add:
 28           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_ADD
              7 RETURN_VALUE
</pre>

<p>Tuto funkci lze ovšem volat jak s&nbsp;číselnými parametry, tak i
s&nbsp;řetězci, n-ticemi, seznamy či libovolnými objekty s&nbsp;implementovanou
metodou <strong>__add__</strong>, takže instrukce <strong>BINARY_ADD</strong>
není zcela porovnatelná například s&nbsp;JVM instrukcemi <strong>iadd</strong>,
<strong>ladd</strong> atd. operujícími pouze nad konkrétním primitivním datovým
typem.:</p>

<pre>
    print(add(1, 2))
    print(add(1., 2))
    print(add("Hello ", "world!"))
    print(add([1,2,3], [4,5,6]))
    print(add((1,2,3), (4,5,6)))
</pre>

<p>Kromě toho může bajtkód Pythonu obsahovat i instrukce pro snazší tvorbu
smyček (BREAK_LOOP, CONTINUE_LOOP) i pro práci s kolekcemi (LIST_APPEND,
MAP_ADD, BUILD_SLICE apod).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zásobníkové vs. registrové virtuální stroje</h2>

<p>Využívání bajtkódů má v&nbsp;současnosti za sebou zhruba čtyřicet let
postupného vývoje, takže není divu, že za tuto poměrně dlouhou dobu bylo
navrženo a implementováno mnoho různých řešení virtuálního stroje+bajtkódu,
která se od sebe v&nbsp;mnoha ohledech odlišovala, a to jak úrovní abstrakce
bajtkódu (nízkoúrovňové instrukce dobře transformovatelné na strojový kód vs.
vysokoúrovňové instrukce podporující například polymorfismus využívaný
například virtuálním strojem Pythonu), tak i způsobem, jakým jednotlivé
instrukce pracovaly s&nbsp;argumenty. Naprostou většinu existujících a
v&nbsp;současnosti používaných bajtkódů lze rozdělit do dvou skupin.
V&nbsp;první skupině se nachází bajtkódy zpracovávané virtuálními stroji
založenými na zásobníku operandů (<i>operand stack</i>) a v&nbsp;druhé skupině
se nachází bajtkódy využívající sadu registrů (<i>register set</i>) nabízených
virtuálním strojem. Oba přístupy mají své přednosti i zápory a taktéž skalní
zastánce i odpůrce, jak je tomu ostatně v&nbsp;IT dobrým zvykem :-)</p>

<p>Bajtkódy a virtuální stroje využívající zásobník operandů a instrukce pro
práci s&nbsp;argumenty uloženými na tomto zásobníku většinou obsahují mnoho
bezparametrických instrukcí, jejichž operační kódy tak mohou být velmi krátké a
typicky bývají uloženy v&nbsp;jednom bajtu (z&nbsp;toho také ostatně označení
&bdquo;bajtkód&ldquo; vychází). Interpretace takového bajtkódu bývá velmi
jednoduchá a lze ji efektivně provádět i na těch mikroprocesorech, které
obsahují velmi malé množství pracovních registrů, z&nbsp;čehož ostatně vyplývá
i oblíbenost takto navržených bajtkódů v&nbsp;době osmibitových mikroprocesorů
a mikrořadičů (poněkud speciálním případem je jazyk <i>Forth</i>). Před
přibližně deseti lety, kdy se ve větší míře začaly rozšiřovat JIT překladače,
se předpokládalo, že nové JIT překladače budou mít problémy s&nbsp;překladem
instrukcí založených na použití zásobníku operandů do strojového kódu moderních
mikroprocesorů (ty mají většinou velkou sadu pracovních registrů), ovšem
ukázalo se, že JIT dokáží bez větších problémů pracovat jak se zásobníkovými
instrukcemi, tak i s&nbsp;instrukcemi využívajícími sadu pracovních registrů
VM.</p>

<p>Tím se pomalu dostáváme ke druhému rozšířenému typu bajtkódů. Jedná se o
bajtkódy, jejichž instrukce dokážou pracovat s&nbsp;obsahem množiny pracovních
registrů zvoleného virtuálního stroje. Délka instrukčního slova i možnosti
takto navržených bajtkódů závisí především na počtu těchto pracovních registrů;
v&nbsp;moderních VM se setkáme minimálně s&nbsp;použitím šestnácti či 32
registry, což znamená, že mnoho instrukcí má délku minimálně dva bajty, mnohdy
i tři či čtyři bajty. Liší se taktéž počet operandů instrukcí &ndash; některé
bajtkódy využívají takzvaný dvouadresový kód (používají dva registry &ndash;
jeden registr zdrojový a druhý registr současně zdrojový i cílový), jiné se
zaměřují na tříadresový kód (dva zdrojové registry a jeden registr cílový).
Způsob interpretace takto navržených bajtkódů může být problematičtější
v&nbsp;případě, že mikroprocesor, na němž interpret běží, obsahuje menší
množství fyzických pracovních registrů, ovšem (jak již bylo řečeno
v&nbsp;předchozím odstavci), při použití JIT se rozdíly mezi oběma způsoby
práce s&nbsp;operandy do značné míry rozostřují.</p>

<p>Podívejme se nyní na dvě ukázky, jak se může lišit bajtkód založený na
zásobníkovém virtuálním stroji od bajtkódu, který je určen pro registrový
virtuální stroj. V&nbsp;obou příkladech se má vyhodnotit jednoduchý výraz
<strong>result = a+b*c-d</strong>; pro jednoduchost předpokládejme, že všech
pět proměnných je lokálních a současně mají typ celé číslo (integer). Způsob
překladu do bajtkódu využívajícího zásobník operandů (konkrétně je použit
bajtkód JVM) může vypadat následovně:</p>

<pre>
              <i>; 0 je index proměnné <strong>a</strong></i>
              <i>; 1 je index proměnné <strong>b</strong></i>
              <i>; 2 je index proměnné <strong>c</strong></i>
              <i>; 3 je index proměnné <strong>d</strong></i>
              <i>; 4 je index proměnné <strong>result</strong></i>
0: iload  0   <i>; uložení obsahu proměnné <strong>a</strong> na zásobník</i>
1: iload  1   <i>; uložení obsahu proměnné <strong>b</strong> na zásobník</i>
2: iload  2   <i>; uložení obsahu proměnné <strong>c</strong> na zásobník</i>
3: imul       <i>; provedení operace <strong>b*c</strong>, výsledek je ponechán na zásobníku</i>
4: iadd       <i>; provedení operace <strong>a+(b*c)</strong></i>
5: iload  3   <i>; uložení obsahu proměnné <strong>d</strong> na zásobník</i>
6: isub       <i>; dokončit příkaz <strong>a+(b*c)+d</strong></i>
7: istore 4   <i>; uložení výsledku z TOS (obsah zásobníku operandů) do proměnné <strong>result</strong></i>
</pre>

<p>Příklad kompilace téhož příkazu <strong>result = a+b*c-d</strong> do
bajtkódu využívajícího pracovní registry, konkrétně do bajtkódu využívaného
programovacím jazykem Lua:</p>

<pre>
                               <i>; 0 je index proměnné <strong>a</strong></i>
                               <i>; 1 je index proměnné <strong>b</strong></i>
                               <i>; 2 je index proměnné <strong>c</strong></i>
                               <i>; 3 je index proměnné <strong>d</strong></i>
                               <i>; 4 je index proměnné <strong>result</strong></i>
1       [101]   MUL    4 1 2   <i>; přímé vynásobení obsahu proměnných <strong>b</strong> a <strong>c</strong></i>
2       [101]   ADD    4 0 4   <i>; přičíst k obsahu proměnné <strong>a</strong> mezivýsledek, výsledek uložit do proměnné <strong>result</strong></i>
3       [101]   SUB    4 4 3   <i>; odečíst od mezivýsledku obsah proměnné <strong>b</strong>, výsledek uložit do proměnné <strong>result</strong></i>
</pre>

<p>Ve druhém případě se nemusely vůbec použít instrukce pro uložení proměnných
na zásobník ani pro načtení hodnoty zpět ze zásobníku operandů do proměnné,
ovšem na druhou stranu musely mít všechny aritmetické instrukce
v&nbsp;instrukčním slovu uloženy i indexy operandů.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Příklady funkcí přeložených do bajtkódu Pythonu</h2>

<p>Podívejme se nejdříve na zdrojový kód příkladu, který ve své závěrečné části
obsahuje funkci pro disassembling bajtkódu:</p>

<pre>
<i>#</i>
<i># Modul s nekolika jednoduchymi funkcemi</i>
<i># pro otestovani zakladnich vlastnosti bajtkodu jazyka Python</i>
<i>#</i>
&nbsp;
<i>#</i>
<i># Prazdna funkce bez parametru.</i>
<i>#</i>
def <strong>nop1</strong>():
    pass
&nbsp;
<i>#</i>
<i># Taktez prazdna funkce bez parametru.</i>
<i>#</i>
def <strong>nop2</strong>():
    return
&nbsp;
<i>#</i>
<i># Funkce bez parametru vracejici konstantu.</i>
<i>#</i>
def <strong>answer</strong>():
    return 42
&nbsp;
<i>#</i>
<i># Soucet dvou cisel.</i>
<i>#</i>
def <strong>add</strong>(x, y):
    return x+y
&nbsp;
<i>#</i>
<i># Funkce s podminkou.</i>
<i>#</i>
def <strong>isNegative</strong>(x):
    if x &lt; 0:
        return True
    return False
&nbsp;
<i>#</i>
<i># Funkce s podminkou a se smyckou.</i>
<i>#</i>
def <strong>fibonacciIter</strong>(n):
    if n &lt;= 1:
        return n
&nbsp;
    result = 0
    n1 = 0
    n2 = 1
&nbsp;
    for i in xrange(n-1, 0, -1):
        result = n1 + n2
        n1 = n2
        n2 = result
&nbsp;
    return result
&nbsp;
<i>#</i>
<i># Funkce s rekurzi.</i>
<i>#</i>
def <strong>fibonacciRecursive</strong>(n):
    if n &lt;= 1:
        return n
    else:
        return fibonacciRecursive(n-1) + fibonacciRecursive(n-2)
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    nop1()
    nop2()
    print(answer())
    print(add(1, 2))
    print(add("Hello ", "world!"))
    print(isNegative(-10))
&nbsp;
    for n in xrange(0,11):
        print(str(n) + "\t" + str(fibonacciIter(n)) + "\t" + str(fibonacciRecursive(n)))
&nbsp;
<i>#main()</i>
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nnop1:")
    dis(nop1)
&nbsp;
    print("\nnop2:")
    dis(nop2)
&nbsp;
    print("\nanswer:")
    dis(answer)
&nbsp;
    print("\nadd:")
    dis(add)
&nbsp;
    print("\nisNegative:")
    dis(isNegative)
&nbsp;
    print("\nfibonacciIter:")
    dis(fibonacciIter)
&nbsp;
    print("\nfibonacciRecursive:")
    dis(fibonacciRecursive)
&nbsp;
disassemble()
</pre>

<p>Opět se podívejme, jak bude vypadat bajtkód vygenerovaný překladačem
Pythonu, resp.&nbsp;přesněji řečeno CPythonu:</p>

<p>Na překladu funkce <strong>nop1()</strong> pravděpodobně nenajdeme nic
překvapivého:</p>

<pre>
<strong>nop1</strong>:
 10           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE        
</pre>

<p>Stejným způsobem je přeložena i funkce <strong>nop2()</strong>, což je
pochopitelné:</p>

<pre>
<strong>nop2</strong>:
 16           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE        
</pre>

<p>V&nbsp;bajtkódu funkce <strong>answer()</strong> se na zásobník nejdříve
uloží číselná konstanta 42, která je následně instrukcí
<strong>RETURN_VALUE</strong> vrácena volající funkci:</p>

<pre>
<strong>answer</strong>:
 22           0 LOAD_CONST               1 (42)
              3 RETURN_VALUE        
</pre>

<p>Ve funkci <strong>add()</strong> se používá instrukce
<strong>BINARY_ADD</strong>, která však ve skutečnosti může pracovat nejenom
s&nbsp;čísly, ale i s&nbsp;řetězci, n-ticemi apod., což je velký rozdíl oproti
bajtkódu JVM, což jsme ostatně mohli vidět v&nbsp;předchozích kapitolách:</p>

<pre>
<strong>add</strong>:
 28           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_ADD          
              7 RETURN_VALUE        
</pre>

<p>V&nbsp;bajtkódu funkce <strong>isNegative()</strong> je zajímavá především
kombinace instrukcí <strong>COMPARE_OP</strong> (s&nbsp;operandem &lt;) a
<strong>JUMP_IF_FALSE</strong>. Instrukce bajtkódu Pythonu evidentně nejsou
pojmenovány s&nbsp;ohledem na jejich ruční zápis :-):</p>

<pre>
<strong>isNegative</strong>:
 34           0 LOAD_FAST                0 (x)
              3 LOAD_CONST               1 (0)
              6 COMPARE_OP               0 (&lt;)
              9 JUMP_IF_FALSE            5 (to 17)
             12 POP_TOP             
&nbsp;
 35          13 LOAD_GLOBAL              0 (True)
             16 RETURN_VALUE        
        &gt;&gt;   17 POP_TOP             

 36          18 LOAD_GLOBAL              1 (False)
             21 RETURN_VALUE        
</pre>

<p>I v&nbsp;bajtkódu funkce <strong>fibonacciIter()</strong> nalezneme dvojici
instrukcí <strong>COMPARE_OP</strong> s&nbsp;<strong>JUMP_IF_FALSE</strong>.
Kromě toho si povšimněte instrukce <strong>FOR_ITER</strong>, která pro zadaný
iterátor uložený na zásobníku vytvoří základ pro programovou smyčku for:</p>

<pre>
<strong>fibonacciIter</strong>:
 42           0 LOAD_FAST                0 (n)
              3 LOAD_CONST               1 (1)
              6 COMPARE_OP               1 (&lt;=)
              9 JUMP_IF_FALSE            5 (to 17)
             12 POP_TOP             
&nbsp;
 43          13 LOAD_FAST                0 (n)
             16 RETURN_VALUE        
        &gt;&gt;   17 POP_TOP             
&nbsp;
 45          18 LOAD_CONST               2 (0)
             21 STORE_FAST               1 (result)
&nbsp;
 46          24 LOAD_CONST               2 (0)
             27 STORE_FAST               2 (n1)
&nbsp;
 47          30 LOAD_CONST               1 (1)
             33 STORE_FAST               3 (n2)
&nbsp;
 49          36 SETUP_LOOP              52 (to 91)
             39 LOAD_GLOBAL              0 (xrange)
             42 LOAD_FAST                0 (n)
             45 LOAD_CONST               1 (1)
             48 BINARY_SUBTRACT     
             49 LOAD_CONST               2 (0)
             52 LOAD_CONST               3 (-1)
             55 CALL_FUNCTION            3
             58 GET_ITER            
        &gt;&gt;   59 FOR_ITER                28 (to 90)
             62 STORE_FAST               4 (i)
&nbsp;
 50          65 LOAD_FAST                2 (n1)
             68 LOAD_FAST                3 (n2)
             71 BINARY_ADD          
             72 STORE_FAST               1 (result)
&nbsp;
 51          75 LOAD_FAST                3 (n2)
             78 STORE_FAST               2 (n1)
&nbsp;
 52          81 LOAD_FAST                1 (result)
             84 STORE_FAST               3 (n2)
             87 JUMP_ABSOLUTE           59
        &gt;&gt;   90 POP_BLOCK           
&nbsp;
 54     &gt;&gt;   91 LOAD_FAST                1 (result)
             94 RETURN_VALUE        
</pre>

<p>V&nbsp;bajtkódu funkce <strong>fibonacciRecursive()</strong> si povšimněte
zejména instrukce pojmenované <strong>LOAD_GLOBAL</strong>, kterou je možné
využít pro uložení hodnoty globálního symbolu na zásobník:</p>

<pre>
<strong>fibonacciRecursive</strong>:
 60           0 LOAD_FAST                0 (n)
              3 LOAD_CONST               1 (1)
              6 COMPARE_OP               1 (&lt;=)
              9 JUMP_IF_FALSE            5 (to 17)
             12 POP_TOP             
&nbsp;
 61          13 LOAD_FAST                0 (n)
             16 RETURN_VALUE        
        &gt;&gt;   17 POP_TOP             

 63          18 LOAD_GLOBAL              0 (fibonacciRecursive)
             21 LOAD_FAST                0 (n)
             24 LOAD_CONST               1 (1)
             27 BINARY_SUBTRACT     
             28 CALL_FUNCTION            1
             31 LOAD_GLOBAL              0 (fibonacciRecursive)
             34 LOAD_FAST                0 (n)
             37 LOAD_CONST               2 (2)
             40 BINARY_SUBTRACT     
             41 CALL_FUNCTION            1
             44 BINARY_ADD          
             45 RETURN_VALUE        
             46 LOAD_CONST               0 (None)
             49 RETURN_VALUE        
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Dekompilace bajtkódu pro jednoduchý výraz s&nbsp;konstantami</h2>

<p>Díky součinnosti standardních modulů <strong>ast</strong> a
<strong>dis</strong> můžeme jít ještě dále a provést postupně tyto operace:</p>

<ol>
<li>Tokenizaci příkazu (<i>statement</i>)</li>
<li>Transformaci sekvence tokenů na AST (parsing)</li>
<li>Překlad AST do bajtkódu</li>
<li>Zpětný překlad bajtkódu do čitelnější podoby</li>
</ol>

<p>Všechny tyto operace jsou ukázány v&nbsp;následujícím příkladu:</p>

<pre>
import ast
import dis
&nbsp;
&nbsp;
class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1
&nbsp;
    def visit(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
&nbsp;
tree = ast.parse("print(1+2*(1-3/4)+5)", mode="exec")
&nbsp;
visitor = Visitor()
visitor.visit(tree)
&nbsp;
print("Compiling")
&nbsp;
compiled = compile(tree, filename="&lt;ast&gt;", mode="exec")
&nbsp;
print("Decompiling")
&nbsp;
dis.dis(compiled)
&nbsp;
print("Done")
</pre>

<p>Tento demonstrační příklad po svém spuštění nejdříve vypíše obsah AST
(nepříliš formátovaný):</p>

<pre>
   &lt;_ast.Module object at 0x7fd10db86430&gt;
     &lt;_ast.Expr object at 0x7fd10daf1cd0&gt;
       &lt;_ast.Call object at 0x7fd10da84d90&gt;
         &lt;_ast.Name object at 0x7fd10da84dc0&gt;
           &lt;_ast.Load object at 0x7fd10dae39d0&gt;
         &lt;_ast.BinOp object at 0x7fd10da84f40&gt;
           &lt;_ast.BinOp object at 0x7fd10da84eb0&gt;
             &lt;_ast.Constant object at 0x7fd10da84f70&gt;
             &lt;_ast.Add object at 0x7fd10dae3e50&gt;
             &lt;_ast.BinOp object at 0x7fd10da84e80&gt;
               &lt;_ast.Constant object at 0x7fd10daaf130&gt;
               &lt;_ast.Mult object at 0x7fd10dae3f10&gt;
               &lt;_ast.BinOp object at 0x7fd10daaf310&gt;
                 &lt;_ast.Constant object at 0x7fd10daaf2b0&gt;
                 &lt;_ast.Sub object at 0x7fd10dae3eb0&gt;
                 &lt;_ast.BinOp object at 0x7fd10daaf340&gt;
                   &lt;_ast.Constant object at 0x7fd10daaf460&gt;
                   &lt;_ast.Div object at 0x7fd10dae3fd0&gt;
                   &lt;_ast.Constant object at 0x7fd10daaf400&gt;
           &lt;_ast.Add object at 0x7fd10dae3e50&gt;
           &lt;_ast.Constant object at 0x7fd10da84520&gt;
</pre>

<p>Následně se provede překlad AST do bajtkódu a zpětný překlad do čitelné
podoby:</p>

<pre>
Compiling
Decompiling
  1           0 LOAD_NAME                0 (print)
              2 LOAD_CONST               0 (6.5)
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE
Done
</pre>

<p><div class="rs-tip-major">Poznámka: zde je jasně patrné, že překladač
(<i>compiler</i>) provedl radikální optimalizaci &ndash; nahradil celý výraz ve
funkci <strong>print</strong> za jeho výsledek. Přitom při pohledu na AST nic
takového patrné není, protože optimalizaci skutečně provádí překladač a nikoli
parser (ovšem samotná optimalizace je realizována manipulací s&nbsp;AST). Jak
toho bylo dosaženo? To si řekneme příště.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Dekompilace bajtkódu složitějšího příkazu</h2>

<p>Zkusme nyní provést všechny operace vyjmenované <a
href="#k16">v&nbsp;předchozí kapitole</a>, ovšem nyní pro příkaz, který nemůže
překladač zjednodušit. Konkrétně se jedná o tento příkaz:</p>

<pre>
print(a+b*(c-d/e)+f)
</pre>

<p>Tokenizace, parsing, překlad i zpětný překlad zajišťuje tento jednoduchý
skript:</p>

<pre>
import ast
import dis
&nbsp;
&nbsp;
class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1
&nbsp;
    def visit(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
&nbsp;
&nbsp;
tree = ast.parse("print(a+b*(c-d/e)+f)", mode="exec")
&nbsp;
visitor = Visitor()
visitor.visit(tree)
&nbsp;
print("Compiling")
&nbsp;
compiled = compile(tree, filename="&lt;ast&gt;", mode="exec")
&nbsp;
print("Decompiling")
&nbsp;
dis.dis(compiled)
&nbsp;
print("Done")
</pre>

<p>Tento skript po svém spuštění opět nejdříve vypíše strukturu celého AST:</p>

<pre>
   &lt;_ast.Module object at 0x7f21685c2430&gt;
     &lt;_ast.Expr object at 0x7f216852dcd0&gt;
       &lt;_ast.Call object at 0x7f21684c0d90&gt;
         &lt;_ast.Name object at 0x7f21684c0dc0&gt;
           &lt;_ast.Load object at 0x7f216851f9d0&gt;
         &lt;_ast.BinOp object at 0x7f21684c0f40&gt;
           &lt;_ast.BinOp object at 0x7f21684c0eb0&gt;
             &lt;_ast.Name object at 0x7f21684c0f70&gt;
               &lt;_ast.Load object at 0x7f216851f9d0&gt;
             &lt;_ast.Add object at 0x7f216851fe50&gt;
             &lt;_ast.BinOp object at 0x7f21684c0e80&gt;
               &lt;_ast.Name object at 0x7f21684eb130&gt;
                 &lt;_ast.Load object at 0x7f216851f9d0&gt;
               &lt;_ast.Mult object at 0x7f216851ff10&gt;
               &lt;_ast.BinOp object at 0x7f21684eb310&gt;
                 &lt;_ast.Name object at 0x7f21684eb2b0&gt;
                   &lt;_ast.Load object at 0x7f216851f9d0&gt;
                 &lt;_ast.Sub object at 0x7f216851feb0&gt;
                 &lt;_ast.BinOp object at 0x7f21684eb340&gt;
                   &lt;_ast.Name object at 0x7f21684eb460&gt;
                     &lt;_ast.Load object at 0x7f216851f9d0&gt;
                   &lt;_ast.Div object at 0x7f216851ffd0&gt;
                   &lt;_ast.Name object at 0x7f21684eb400&gt;
                     &lt;_ast.Load object at 0x7f216851f9d0&gt;
           &lt;_ast.Add object at 0x7f216851fe50&gt;
           &lt;_ast.Name object at 0x7f21684c0520&gt;
             &lt;_ast.Load object at 0x7f216851f9d0&gt;
</pre>

<p>Následuje překlad a posléze i zpětný překlad:</p>

<pre>
Compiling
Decompiling
  1           0 LOAD_NAME                0 (print)
              2 LOAD_NAME                1 (a)
              4 LOAD_NAME                2 (b)
              6 LOAD_NAME                3 (c)
              8 LOAD_NAME                4 (d)
             10 LOAD_NAME                5 (e)
             12 BINARY_TRUE_DIVIDE
             14 BINARY_SUBTRACT
             16 BINARY_MULTIPLY
             18 BINARY_ADD
             20 LOAD_NAME                6 (f)
             22 BINARY_ADD
             24 CALL_FUNCTION            1
             26 POP_TOP
             28 LOAD_CONST               0 (None)
             30 RETURN_VALUE
Done
</pre>

<p>Zde můžeme vidět, že k&nbsp;žádné optimalizaci nedošlo (a ani nemohlo) a
současně je patrné, že se překladač příliš nesnaží zmenšovat obsazení zásobníku
operandů při vyhodnocování (&bdquo;spuštění&ldquo;) tohoto bajtkódu. Nejprve
jsou na zásobník uloženy reference na funkci <strong>print</strong> i proměnné
<strong>a</strong> až <strong>e</strong>. Posléze je provedena sekvence
binárních aritmetických operací (binárních proto, že každá operace má dva
operandy, které čte ze zásobníku). Teprve poté je na zásobník uložena reference
proměnné <strong>f</strong>, je provedena poslední binární aritmetická operace
a nakonec se zavolá funkce <strong>print</strong> s&nbsp;jedním parametrem.
Funkce nevrací žádnou hodnotu, což v&nbsp;Pythonu ovšem znamená, že ve
skutečnosti vrací <strong>None</strong>, což zajišťuje poslední dvojice
instrukcí.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: definice gramatiky programovacího jazyka Python</h2>

<p>Jména filtrů použitých v&nbsp;návrhovém vzoru <i>Visitor</i> přímo vychází
z&nbsp;gramatiky programovacího jazyka Python. Ta (už) není v&nbsp;žádném
případě jednoduchá, což je ostatně patrné i při pohledu na tuto přílohu:</p>

<pre>
module Python version "$Revision$"
{
        mod = Module(stmt* body)
            | Interactive(stmt* body)
            | Expression(expr body)
&nbsp;
            -- not really an actual node but useful in Jython's typesystem.
            | Suite(stmt* body)
&nbsp;
        stmt = FunctionDef(identifier name, arguments args, 
                            stmt* body, expr* decorator_list)
              | ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)
              | Return(expr? value)
&nbsp;
              | Delete(expr* targets)
              | Assign(expr* targets, expr value)
              | AugAssign(expr target, operator op, expr value)
&nbsp;
              -- not sure if bool is allowed, can always use int
              | Print(expr? dest, expr* values, bool nl)
&nbsp;
              -- use 'orelse' because else is a keyword in target languages
              | For(expr target, expr iter, stmt* body, stmt* orelse)
              | While(expr test, stmt* body, stmt* orelse)
              | If(expr test, stmt* body, stmt* orelse)
              | With(expr context_expr, expr? optional_vars, stmt* body)
&nbsp;
              -- 'type' is a bad name
              | Raise(expr? type, expr? inst, expr? tback)
              | TryExcept(stmt* body, excepthandler* handlers, stmt* orelse)
              | TryFinally(stmt* body, stmt* finalbody)
              | Assert(expr test, expr? msg)
&nbsp;
              | Import(alias* names)
              | ImportFrom(identifier? module, alias* names, int? level)
&nbsp;
              -- Doesn't capture requirement that locals must be
              -- defined if globals is
              -- still supports use as a function!
              | Exec(expr body, expr? globals, expr? locals)
&nbsp;
              | Global(identifier* names)
              | Expr(expr value)
              | Pass | Break | Continue
&nbsp;
              -- XXX Jython will be different
              -- col_offset is the byte offset in the utf8 string the parser uses
              attributes (int lineno, int col_offset)
&nbsp;
              -- BoolOp() can use left &amp; right?
        expr = BoolOp(boolop op, expr* values)
             | BinOp(expr left, operator op, expr right)
             | UnaryOp(unaryop op, expr operand)
             | Lambda(arguments args, expr body)
             | IfExp(expr test, expr body, expr orelse)
             | Dict(expr* keys, expr* values)
             | Set(expr* elts)
             | ListComp(expr elt, comprehension* generators)
             | SetComp(expr elt, comprehension* generators)
             | DictComp(expr key, expr value, comprehension* generators)
             | GeneratorExp(expr elt, comprehension* generators)
             -- the grammar constrains where yield expressions can occur
             | Yield(expr? value)
             -- need sequences for compare to distinguish between
             -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3
             | Compare(expr left, cmpop* ops, expr* comparators)
             | Call(expr func, expr* args, keyword* keywords,
                         expr? starargs, expr? kwargs)
             | Repr(expr value)
             | Num(object n) -- a number as a PyObject.
             | Str(string s) -- need to specify raw, unicode, etc?
             -- other literals? bools?
&nbsp;
             -- the following expression can appear in assignment context
             | Attribute(expr value, identifier attr, expr_context ctx)
             | Subscript(expr value, slice slice, expr_context ctx)
             | Name(identifier id, expr_context ctx)
             | List(expr* elts, expr_context ctx) 
             | Tuple(expr* elts, expr_context ctx)
&nbsp;
              -- col_offset is the byte offset in the utf8 string the parser uses
              attributes (int lineno, int col_offset)
&nbsp;
        expr_context = Load | Store | Del | AugLoad | AugStore | Param
&nbsp;
        slice = Ellipsis | Slice(expr? lower, expr? upper, expr? step) 
              | ExtSlice(slice* dims) 
              | Index(expr value) 
&nbsp;
        boolop = And | Or 
&nbsp;
        operator = Add | Sub | Mult | Div | Mod | Pow | LShift 
                 | RShift | BitOr | BitXor | BitAnd | FloorDiv
&nbsp;
        unaryop = Invert | Not | UAdd | USub
&nbsp;
        cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn
&nbsp;
        comprehension = (expr target, expr iter, expr* ifs)
&nbsp;
        -- not sure what to call the first argument for raise and except
        excepthandler = ExceptHandler(expr? type, expr? name, stmt* body)
                        attributes (int lineno, int col_offset)
&nbsp;
        arguments = (expr* args, identifier? vararg, 
                     identifier? kwarg, expr* defaults)
&nbsp;
        -- keyword arguments supplied to call
        keyword = (identifier arg, expr value)
&nbsp;
        -- import name with optional 'as' alias.
        alias = (identifier name, identifier? asname)
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 (některé přímo pro Python 3.10) byly uloženy do Git
repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující jednoduchý výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py</a></td></tr>
<tr><td> 2</td><td>err_expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující chybný výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py</a></td></tr>
<tr><td> 3</td><td>async.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující async a await</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py</a></td></tr>
<tr><td> 4</td><td>primes.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující výpočet celočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>print_tokens.py</td><td>výpis všech typů a hodnot tokenů pro aktuální verzi Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py</a></td></tr>
<tr><td> 6</td><td>tokenize_expression_1.py</td><td>tokenizace výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py</a></td></tr>
<tr><td> 7</td><td>tokenize_expression_2.py</td><td>tokenizace výrazu, alternativní způsob otevření zdrojového souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py</a></td></tr>
<tr><td> 8</td><td>tokenize_expression_3.py</td><td>tokenizace výrazu s&nbsp;více operátory</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py</a></td></tr>
<tr><td> 9</td><td>tokenize_expression_4.py</td><td>tokenizace výrazu s&nbsp;více operátory, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py</a></td></tr>
<tr><td>10</td><td>tokenize_async.py</td><td>tokenizace zdrojového kódu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py</a></td></tr>
<tr><td>11</td><td>tokenize_primes.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py</a></td></tr>
<tr><td>12</td><td>tokenize_primes_2.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong>, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>parse_expression.py</td><td>parsing zdrojového kódu s&nbsp;výrazem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py</a></td></tr>
<tr><td>14</td><td>parse_expression_3_10.py</td><td>parsing zdrojového kódu s&nbsp;výrazem, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py</a></td></tr>
<tr><td>15</td><td>parse_async.py</td><td>parsing zdrojového kodu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py</a></td></tr>
<tr><td>16</td><td>parse_async_3_10.py</td><td>parsing zdrojového kodu <strong>async.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py</a></td></tr>
<tr><td>17</td><td>parse_primes.py</td><td>parsing zdrojového kodu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py</a></td></tr>
<tr><td>18</td><td>parse_primes_3_10.py</td><td>parsing zdrojového kodu <strong>primes.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>traverse_expression_1.py</td><td>průchod AST, nejjednodušší varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py</a></td></tr>
<tr><td>20</td><td>traverse_expression_2.py</td><td>průchod AST, vzor <i>Visitor</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py</a></td></tr>
<tr><td>21</td><td>traverse_expression_3.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py</a></td></tr>
<tr><td>22</td><td>traverse_expression_4.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py</a></td></tr>
<tr><td>23</td><td>traverse_expression_5.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py</a></td></tr>
<tr><td>24</td><td>traverse_expression_5.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů, vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>ifs1.py</td><td>zdrojový kód s&nbsp;několika zanořenými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py</a></td></tr>
<tr><td>26</td><td>ifs2.py</td><td>zdrojový kód s&nbsp;několika zanořenými úplnými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py</a></td></tr>
<tr><td>27</td><td>tokenize_ifs1.py</td><td>tokenizace zdrojového kódu &bdquo;ifs1.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py</a></td></tr>
<tr><td>28</td><td>tokenize_ifs2.py</td><td>tokenizace zdrojového kódu &bdquo;ifs2.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>compile_tree.py</td><td>překlad a spuštění AST</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>sprites.py</td><td>zdrojový kód, jehož AST se bude zkoumat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/sprites.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/sprites.py</a></td></tr>
<tr><td>31</td><td>traverse_code_1.py</td><td>průchod AST pro zvolený zdrojový kód</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_1.py</a></td></tr>
<tr><td>32</td><td>traverse_code_2.py</td><td>průchod AST, filtrace uzlů s&nbsp;definicí funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_2.py</a></td></tr>
<tr><td>33</td><td>traverse_code_3.py</td><td>průchod AST, filtrace uzlů s&nbsp;definicí modulu, třídy a funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_3.py</a></td></tr>
<tr><td>34</td><td>traverse_code_4.py</td><td>průchod AST, filtrace uzlů se smyčkou for</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_4.py</a></td></tr>
<tr><td>35</td><td>decompile_1.py</td><td>dekompilace bajtkódu konstantního výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/decompile_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/decompile_1.py</a></td></tr>
<tr><td>36</td><td>decompile_2.py</td><td>dekompilace bajtkódu nekonstantního výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/decompile_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/decompile_2.py</a></td></tr>
<tr><td>37</td><td>symbol_table_1.py</td><td>tisk tabulky symbolů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/symbol_table_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/symbol_table_1.py</a></td></tr>
<tr><td>38</td><td>symbol_table_2.py</td><td>tisk tabulky symbolů, vylepšená varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/symbol_table_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/symbol_table_2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>SymbolTable<br />
<a href="https://docs.python.org/3.8/library/symtable.html">https://docs.python.org/3.8/library/symtable.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Pygments - Python syntax highlighter<br />
<a href="http://pygments.org/">http://pygments.org/</a>
</li>

<li>Pygments (dokumentace)<br />
<a href="http://pygments.org/docs/">http://pygments.org/docs/</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Jazyky podporované knihovnou Pygments<br />
<a href="http://pygments.org/languages/">http://pygments.org/languages/</a>
</li>

<li>Pygments FAQ<br />
<a href="http://pygments.org/faq/">http://pygments.org/faq/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

