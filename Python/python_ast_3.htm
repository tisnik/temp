<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetí části článku o lexikální a syntaktické analýze zdrojových kódů napsaných v Pythonu se seznámíme s některými dalšími knihovnami a nástroji, které se v této oblasti používají a které doplňují standardní knihovny tokenize a ast.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Krátké zopakování z&nbsp;minula &ndash; návrhový vzor Visitor</a></p>
<p><a href="#k03">*** 3. Složitější zdrojový kód, jehož AST budeme analyzovat</a></p>
<p><a href="#k04">*** 4. Průchod abstraktním syntaktickým stromem složitějšího programového kódu</a></p>
<p><a href="#k05">*** 5. Filtrace uzlů v&nbsp;AST &ndash; výpis definic všech funkcí a metod</a></p>
<p><a href="#k06">*** 6. Informace o modulu, definovaných třídách i definovaných funkcích a metodách</a></p>
<p><a href="#k07">*** 7. Příklad dalších typů uzlů AST: hlavička programové smyčky for</a></p>
<p><a href="#k08">*** 8. Uzly AST využívané ve výrazech</a></p>
<p><a href="#k09">*** 9. Realizace průchodu stromem pro zpracování výrazu</a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">13. Bajtkód virtuálního stroje Pythonu</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. Příklady funkcí přeložených do bajtkódu Pythonu</a></p>
<p><a href="#k16">*** 16. Dekompilace bajtkódu pro jednoduchý výraz s&nbsp;konstantami</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Příloha: definice gramatiky programovacího jazyka Python</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>V&nbsp;předchozích dvou částech článku o lexikální a syntaktické analýze zdrojových kódů napsaných v&nbsp;Pythonu [<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">1</a>] [<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">2</a>] jsme se seznámili se základními vlastnostmi standardních knihoven nazvaných <strong>tokenize</strong> a <strong>ast</strong>. Připomeňme si, že knihovna <strong>tokenize</strong> nám zpřístupňuje takzvaný <i>lexer</i> (někdy právě i <i>tokenizer</i>)</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Krátké zopakování z&nbsp;minula &ndash; návrhový vzor Visitor</h2>

<p></p>

<pre>
import ast
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>visit</strong>(self, node):
        print(node)
        <strong>self.generic_visit(node)</strong>
&nbsp;
&nbsp;
tree = ast.parse("1+2*3")
&nbsp;
visitor = <strong>Visitor()</strong>
<strong>visitor.visit(tree)</strong>
</pre>

<p>Výsledkem bude opět devět uzlů:</p>

<pre>
$ <strong>python3 traverse_expression_2.py </strong>
&nbsp;
&lt;_ast.Module object at 0x7f59ac3320d0&gt;
&lt;_ast.Expr object at 0x7f59ac3324f0&gt;
&lt;_ast.BinOp object at 0x7f59ac26d610&gt;
&lt;_ast.Constant object at 0x7f59ac26d640&gt;
&lt;_ast.Add object at 0x7f59ac28fe50&gt;
&lt;_ast.BinOp object at 0x7f59ac26d820&gt;
&lt;_ast.Constant object at 0x7f59ac26d880&gt;
&lt;_ast.Mult object at 0x7f59ac28ff10&gt;
&lt;_ast.Constant object at 0x7f59ac26d8e0&gt;
</pre>

<pre>
import ast
&nbsp;
class <strong>Visitor</strong>(ast.NodeVisitor):
    def <strong>__init__</strong>(self):
        self.nest_level = 1
&nbsp;
    def <strong>visit</strong>(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        <strong>self.generic_visit(node)</strong>
        self.nest_level -= 1
&nbsp;
&nbsp;
tree = ast.parse("1+2*3+1")
&nbsp;
visitor = <strong>Visitor()</strong>
<strong>visitor.visit(tree)</strong>
</pre>

<p>Nyní bude již výsledek čitelnější (i když ne příliš):</p>

<pre>
$ <strong>python3 traverse_expression_3.py </strong>
&nbsp;
   &lt;_ast.Module object at 0x7f21f20fc0d0&gt;
     &lt;_ast.Expr object at 0x7f21f20fc4f0&gt;
       &lt;_ast.BinOp object at 0x7f21f20376d0&gt;
         &lt;_ast.BinOp object at 0x7f21f2037700&gt;
           &lt;_ast.Constant object at 0x7f21f20377f0&gt;
           &lt;_ast.Add object at 0x7f21f2059ee0&gt;
           &lt;_ast.BinOp object at 0x7f21f2037910&gt;
             &lt;_ast.Constant object at 0x7f21f2037940&gt;
             &lt;_ast.Mult object at 0x7f21f2059fa0&gt;
             &lt;_ast.Constant object at 0x7f21f2037a00&gt;
         &lt;_ast.Add object at 0x7f21f2059ee0&gt;
         &lt;_ast.Constant object at 0x7f21f2037880&gt;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Složitější zdrojový kód, jehož AST budeme analyzovat</h2>

<p></p>

<pre>
<i>#!/usr/bin/python</i>
<i># vim: set fileencoding=utf-8</i>

<i># Demonstrační příklady využívající knihovnu Pygame</i>

<i># Příklad číslo 22: použití spritů, pohyblivý sprite</i>

import pygame
import sys
import os
import math

<i># Nutno importovat kvůli konstantám QUIT atd.</i>
from pygame.locals import *

<i># Velikost okna aplikace</i>
WIDTH = 320
HEIGHT = 240


<i># Třída představující sprite zobrazený jako jednobarevný čtverec.</i>
class BlockySprite(pygame.sprite.Sprite):
    # Konstruktor
    def __init__(self, color, size, x, y):
        # Nejprve je nutné zavolat konstruktor předka,
        # tj. konstruktor třídy pygame.sprite.Sprite:
        pygame.sprite.Sprite.__init__(self)

        # Vytvoření obrázku představujícího vizuální obraz spritu:
        self.image = pygame.Surface([size, size])
        self.image.fill(color)

        # Vytvoření obalového obdélníku
        # (velikost se získá z rozměru obrázku)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

        # Počáteční rychlost spritu
        self.speed_x = 0
        self.speed_y = 0

    # Nastavení barvy spritu, který kolidoval s hráčem
    def yellowColor(self):
        self.image.fill(YELLOW)

    # Nastavení barvy spritu, který nekolidoval s hráčem
    def grayColor(self):
        self.image.fill(GRAY)


<i># Inicializace knihovny Pygame</i>
pygame.init()

clock = pygame.time.Clock()

<i># Vytvoření okna pro vykreslování</i>
display = pygame.display.set_mode([WIDTH, HEIGHT])

<i># Nastavení titulku okna</i>
pygame.display.set_caption("Pygame test #22")

<i># Konstanty s n-ticemi představujícími základní barvy</i>
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GRAY = (128, 128, 128)
YELLOW = (255, 255, 0)

<i># Objekt sdružující všechny sprity</i>
all_sprites = pygame.sprite.Group()
<i># Objekt sdružující všechny sprity kromě hráče</i>
all_sprites_but_player = pygame.sprite.Group()

<i># Vytvoření několika typů spritů</i>
<i>#                    barva  x   y velikost</i>
wall1 = BlockySprite(GRAY, 50, 10, 10)
wall2 = BlockySprite(GRAY, 15, 100, 100)
wall3 = BlockySprite(GRAY, 15, 100, 150)
wall4 = BlockySprite(GRAY, 15, 200, 100)
wall5 = BlockySprite(GRAY, 15, 200, 150)
wall6 = BlockySprite(GRAY, 15, 150, 100)
wall7 = BlockySprite(GRAY, 15, 150, 150)
player = BlockySprite(RED, 40, WIDTH / 2 - 20, HEIGHT / 2 - 20)

<i># Přidání několika dalších spritů do seznamu</i>
<i># (jen jeden sprite - ten poslední - bude ve skutečnosti pohyblivý)</i>
all_sprites.add(wall1)
all_sprites.add(wall2)
all_sprites.add(wall3)
all_sprites.add(wall4)
all_sprites.add(wall5)
all_sprites.add(wall6)
all_sprites.add(wall7)
all_sprites.add(player)

<i># Seznam všech nepohyblivých spritů</i>
all_sprites_but_player.add(wall1)
all_sprites_but_player.add(wall2)
all_sprites_but_player.add(wall3)
all_sprites_but_player.add(wall4)
all_sprites_but_player.add(wall5)
all_sprites_but_player.add(wall6)
all_sprites_but_player.add(wall7)


<i># Posun všech spritů ve skupině na základě jejich rychlosti</i>
def move_sprites(sprite_group, playground_width, playground_height):
    for sprite in sprite_group:
        # Posun spritu
        sprite.rect.x = sprite.rect.x + sprite.speed_x
        sprite.rect.y = sprite.rect.y + sprite.speed_y
        # Kontrola, zda sprite nenarazil do okrajů okna
        if sprite.rect.x < 0:
            sprite.rect.x = 0
            sprite.speed_x = 0
        if sprite.rect.x + sprite.rect.width > playground_width:
            sprite.rect.x = playground_width - sprite.rect.width
            sprite.speed_x = 0
        if sprite.rect.y < 0:
            sprite.rect.y = 0
            sprite.speed_y = 0
        if sprite.rect.y + sprite.rect.height > playground_height:
            sprite.rect.y = playground_height - sprite.rect.height
            sprite.speed_y = 0


<i># Vykreslení celé scény na obrazovku</i>
def draw_scene(display, background_color, sprite_group):
    # Vyplnění plochy okna černou barvou
    display.fill(background_color)
    # Vykreslení celé skupiny spritů do bufferu
    sprite_group.draw(display)
    # Obnovení obsahu obrazovky (překlopení zadního a předního bufferu)
    pygame.display.update()


<i># Změna barvy spritu na základě kolize s hráčem</i>
def change_colors(sprite_group, hit_list):
    # Projít všemi sprity ze skupiny, kterou detekovala kolizní funkce
    for sprite in sprite_group:
        if sprite in hit_list:
            sprite.yellowColor()
        else:
            sprite.grayColor()


<i># Zjistí kolize spritu se "stěnami" (nepohyblivými sprity)</i>
def check_collisions(player, sprite_group):
    # Vytvoření seznamu spritů, které kolidují s hráčem
    hit_list = pygame.sprite.spritecollide(player, sprite_group, False)
    # Změna barev kolidujících spritů
    change_colors(sprite_group, hit_list)
    collisions = len(hit_list)
    # Přenastavení titulku okna
    caption = "Pygame test #22: collisions " + str(collisions)
    pygame.display.set_caption(caption)


<i># Hlavní herní smyčka</i>
while True:
    # Načtení a zpracování všech událostí z fronty
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
        if event.type == KEYDOWN:
            if event.key == K_ESCAPE:
                pygame.quit()
                sys.exit()
            # Stiskem kurzorových kláves je možné měnit směr pohybu spritu
            elif event.key == pygame.K_LEFT:
                player.speed_x = -3
            elif event.key == pygame.K_RIGHT:
                player.speed_x = +3
            elif event.key == pygame.K_UP:
                player.speed_y = -3
            elif event.key == pygame.K_DOWN:
                player.speed_y = +3
        if event.type == KEYUP:
            # Puštění kurzorových kláves vede k zastavení pohybu spritu
            if event.key == pygame.K_LEFT:
                player.speed_x = 0
            elif event.key == pygame.K_RIGHT:
                player.speed_x = 0
            elif event.key == pygame.K_UP:
                player.speed_y = 0
            elif event.key == pygame.K_DOWN:
                player.speed_y = 0

    move_sprites(all_sprites, display.get_width(), display.get_height())
    check_collisions(player, all_sprites_but_player)
    draw_scene(display, BLACK, all_sprites)
    clock.tick(20)

<i># finito</i>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Průchod abstraktním syntaktickým stromem složitějšího programového kódu</h2>

<p></p>

<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1

    def visit(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


with open("sprites.py") as fin:
    code = fin.read()
    tree = ast.parse(code)
    visitor = Visitor()
    visitor.visit(tree)
</pre>

<pre>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Filtrace uzlů v&nbsp;AST &ndash; výpis definic všech funkcí a metod</h2>

<p></p>

<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 0

    def visit_FunctionDef(self, node):
        indent = " " * self.nest_level * 2
        print("{}def {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


with open("sprites.py") as fin:
    code = fin.read()
    tree = ast.parse(code)
    visitor = Visitor()
    visitor.visit(tree)
</pre>

<pre>
def __init__:
def yellowColor:
def grayColor:
def move_sprites:
def draw_scene:
def change_colors:
def check_collisions:
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Informace o modulu, definovaných třídách i definovaných funkcích a metodách</h2>

<p></p>

<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 0

    def visit_Module(self, node):
        indent = " " * self.nest_level * 2
        print("{}module begin:".format(indent, node.__dict__))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
        print("{}module end".format(indent))

    def visit_ClassDef(self, node):
        indent = " " * self.nest_level * 2
        print("{}class {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_FunctionDef(self, node):
        indent = " " * self.nest_level * 2
        print("{}def {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


with open("sprites.py") as fin:
    code = fin.read()
    tree = ast.parse(code)
    visitor = Visitor()
    visitor.visit(tree)
</pre>

<pre>
module begin:
  class BlockySprite:
    def __init__:
    def yellowColor:
    def grayColor:
  def move_sprites:
  def draw_scene:
  def change_colors:
  def check_collisions:
module end
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Příklad dalších typů uzlů AST: hlavička programové smyčky for</h2>

<p></p>

<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 0

    def visit_Module(self, node):
        indent = " " * self.nest_level * 2
        print("{}module begin:".format(indent, node.__dict__))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1
        print("{}module end".format(indent))

    def visit_ClassDef(self, node):
        indent = " " * self.nest_level * 2
        print("{}class {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_For(self, node):
        indent = " " * self.nest_level * 2
        iterator = node.iter
        if type(iterator) == ast.Name:
            iterator = iterator.id
        elif type(iterator) == ast.Call:
            iterator = "call()"

        print("{}for {} in {}:".format(indent, node.target.id, iterator))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_FunctionDef(self, node):
        indent = " " * self.nest_level * 2
        print("{}def {}:".format(indent, node.name))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


with open("sprites.py") as fin:
    code = fin.read()
    tree = ast.parse(code)
    visitor = Visitor()
    visitor.visit(tree)
</pre>

<pre>
module begin:
  class BlockySprite:
    def __init__:
    def yellowColor:
    def grayColor:
  def move_sprites:
    for sprite in sprite_group:
  def draw_scene:
  def change_colors:
    for sprite in sprite_group:
  def check_collisions:
  for event in call():
module end
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Uzly AST využívané ve výrazech</h2>

<p></p>

<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1

    def visit(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node2string(node))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


def node2string(node):
    t = type(node)
    if t == ast.Constant:
        return "Constant: {}".format(node.value)
    elif t == ast.Name:
        return "Variable: {}".format(node.id)
    elif t == ast.Expr:
        return "Expression:"
    elif t == ast.BinOp:
        return "Binary operation"
    elif t == ast.Add:
        return "Operator: +"
    elif t == ast.Sub:
        return "Operator: -"
    elif t == ast.Mult:
        return "Operator: *"
    elif t == ast.Div:
        return "Operator: /"
    return ""


tree = ast.parse("a+2*(1-b/4)+c")

visitor = Visitor()
visitor.visit(tree)
</pre>

<pre>
     Expression:
       Binary operation
         Binary operation
           Variable: a
             
           Operator: +
           Binary operation
             Constant: 2
             Operator: *
             Binary operation
               Constant: 1
               Operator: -
               Binary operation
                 Variable: b
                   
                 Operator: /
                 Constant: 4
         Operator: +
         Variable: c
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Realizace průchodu stromem pro zpracování výrazu</h2>

<p></p>


<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1

    def visit_Constant(self, node):
        indent = " " * self.nest_level * 2
        print("{}Constant: {}".format(indent, node.value))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Name(self, node):
        indent = " " * self.nest_level * 2
        print("{}Variable: {}".format(indent, node.id))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Expr(self, node):
        indent = " " * self.nest_level * 2
        print("{}Expression:".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_BinOp(self, node):
        indent = " " * self.nest_level * 2
        print("{}Binary operator:".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Add(self, node):
        indent = " " * self.nest_level * 2
        print("{}+".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Sub(self, node):
        indent = " " * self.nest_level * 2
        print("{}-".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Mult(self, node):
        indent = " " * self.nest_level * 2
        print("{}*".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1

    def visit_Div(self, node):
        indent = " " * self.nest_level * 2
        print("{}/".format(indent))
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


tree = ast.parse("a+2*(1-b/4)+c")

visitor = Visitor()
visitor.visit(tree)
</pre>

<pre>
  Expression:
    Binary operator:
      Binary operator:
        Variable: a
        +
        Binary operator:
          Constant: 2
          *
          Binary operator:
            Constant: 1
            -
            Binary operator:
              Variable: b
              /
              Constant: 4
      +
      Variable: c
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Tabulky symbolů</h2>

<p></p>

<pre>
import symtable


t = symtable.symtable("a+b*c", "<string>", "eval")

print("Symbol table:", t)
print("Type:", t.get_type())
print("Has children:", t.has_children())
print("Identifiers:", t.get_identifiers())

symbols = t.get_symbols()

print("\nList of symbols:")

for symbol in symbols:
    print(symbol.get_name())
</pre>

<pre>
Symbol table: <SymbolTable for module <string>>
Type: module
Has children: False
Identifiers: dict_keys(['a', 'b', 'c'])

List of symbols:
a
b
c
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Tabulka symbolů pro celý skript</h2>

<p></p>

<pre>
import symtable


with open("sprites.py") as fin:
    code = fin.read()
    t = symtable.symtable(code, "sprites.py", "exec")

print("Symbol table:", t)
print("Type:", t.get_type())
print("Has children:", t.has_children())
print("Identifiers:", t.get_identifiers())

symbols = t.get_symbols()

print("\nList of symbols:")

for symbol in symbols:
    print(symbol.get_name())
</pre>

<pre>
Symbol table: <SymbolTable for module sprites.py>
Type: module
Has children: True
Identifiers: dict_keys(['pygame', 'sys', 'os', 'math', 'WIDTH', 'HEIGHT', 'BlockySprite', 'clock', 'display', 'BLACK', 'RED', 'GRAY', 'YELLOW', 'all_sprites', 'all_sprites_but_player', 'wall1', 'wall2', 'wall3', 'wall4', 'wall5', 'wall6', 'wall7', 'player', 'move_sprites', 'draw_scene', 'change_colors', 'check_collisions', 'event', 'QUIT', 'KEYDOWN', 'K_ESCAPE', 'KEYUP'])

List of symbols:
pygame
sys
os
math
WIDTH
HEIGHT
BlockySprite
clock
display
BLACK
RED
GRAY
YELLOW
all_sprites
all_sprites_but_player
wall1
wall2
wall3
wall4
wall5
wall6
wall7
player
move_sprites
draw_scene
change_colors
check_collisions
event
QUIT
KEYDOWN
K_ESCAPE
KEYUP
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Transformace AST do bajtkódu</h2>

<p></p>

<pre>
import ast


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1

    def visit(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


tree = ast.parse("print(1+2*(1-3/4)+5)", mode="exec")

visitor = Visitor()
visitor.visit(tree)

print("Executing")

exec(compile(tree, filename="<ast>", mode="exec"))

print("Done")
</pre>

<pre>
   <_ast.Module object at 0x7f5898b55430>
     <_ast.Expr object at 0x7f5898a98670>
       <_ast.Call object at 0x7f5898a986a0>
         <_ast.Name object at 0x7f5898a987c0>
           <_ast.Load object at 0x7f5898ab2a00>
         <_ast.BinOp object at 0x7f5898a988b0>
           <_ast.BinOp object at 0x7f5898a988e0>
             <_ast.Constant object at 0x7f5898a98910>
             <_ast.Add object at 0x7f5898ab2e80>
             <_ast.BinOp object at 0x7f5898ac0d00>
               <_ast.Constant object at 0x7f5898ac0d30>
               <_ast.Mult object at 0x7f5898ab2f40>
               <_ast.BinOp object at 0x7f5898ac0d90>
                 <_ast.Constant object at 0x7f5898ac0dc0>
                 <_ast.Sub object at 0x7f5898ab2ee0>
                 <_ast.BinOp object at 0x7f5898ac0e20>
                   <_ast.Constant object at 0x7f5898ac0e80>
                   <_ast.Div object at 0x7f5898ac0040>
                   <_ast.Constant object at 0x7f5898ac0eb0>
           <_ast.Add object at 0x7f5898ab2e80>
           <_ast.Constant object at 0x7f5898a989a0>
Executing
6.5
Done
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Bajtkód virtuálního stroje Pythonu</h2>

<p>V&nbsp;této části článku si ve stručnosti popíšeme bajtkód využívaný
programovacím jazykem Python, konkrétně jeho původní verzí <i>CPython</i>
(kromě tohoto bajtkódu lze najít i další bajtkódy využívané některými
specifickými implementacemi Pythonu). S&nbsp;problematikou bajtkódů jsme se již
na stránkách Roota setkali. Víme například, že bajtkód JVM (Java Virtual
Machine) je poměrně nízkoúrovňový, zejména v&nbsp;porovnání s&nbsp;bajtkódem
používaným v&nbsp;programovacím jazyku Lua (resp.&nbsp;přesněji řečeno
virtuálním strojem tohoto jazyka). Totéž platí, a to dokonce ještě ve větší
míře, i pro bajtkód programovacího jazyka Python. Ten je opět založen na
konceptu zásobníku operandů (jako JVM), ovšem mnohé instrukce pracující
s&nbsp;jedním či dvěma operandy (samozřejmě uloženými na zásobníku) ve
skutečnosti mohou volat metody objektů a nikoli pouze provádět operace nad
primitivními datovými typy. Platí to především pro všechny
&bdquo;aritmetické&ldquo; operace, například i pro operátor +, který se
překládá do instrukce BINARY_ADD.</p>

<p>To například znamená, že se jednoduchá funkce <strong>add()</strong> se
dvěma operandy:</p>

<pre>
def add(x, y):
    return x+y
</pre>

<p>přeloží do následující čtveřice instrukcí bajtkódu:</p>

<pre>
add:
 28           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_ADD
              7 RETURN_VALUE
</pre>

<p>Tuto funkci lze ovšem volat jak s&nbsp;číselnými parametry, tak i
s&nbsp;řetězci, n-ticemi, seznamy či libovolnými objekty s&nbsp;implementovanou
metodou <strong>__add__</strong>, takže instrukce <strong>BINARY_ADD</strong>
není zcela porovnatelná například s&nbsp;JVM instrukcemi <strong>iadd</strong>,
<strong>ladd</strong> atd. operujícími pouze nad konkrétním primitivním datovým
typem.:</p>

<pre>
    print(add(1, 2))
    print(add(1., 2))
    print(add("Hello ", "world!"))
    print(add([1,2,3], [4,5,6]))
    print(add((1,2,3), (4,5,6)))
</pre>

<p>Kromě toho může bajtkód Pythonu obsahovat i instrukce pro snazší tvorbu
smyček (BREAK_LOOP, CONTINUE_LOOP) i pro práci s kolekcemi (LIST_APPEND,
MAP_ADD, BUILD_SLICE apod).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Příklady funkcí přeložených do bajtkódu Pythonu</h2>

<p>Podívejme se nejdříve na zdrojový kód příkladu, který ve své závěrečné části
obsahuje funkci pro disassembling bajtkódu:</p>

<pre>
<i>#</i>
<i># Modul s nekolika jednoduchymi funkcemi</i>
<i># pro otestovani zakladnich vlastnosti bajtkodu jazyka Python</i>
<i>#</i>
&nbsp;
<i>#</i>
<i># Prazdna funkce bez parametru.</i>
<i>#</i>
def <strong>nop1</strong>():
    pass
&nbsp;
<i>#</i>
<i># Taktez prazdna funkce bez parametru.</i>
<i>#</i>
def <strong>nop2</strong>():
    return
&nbsp;
<i>#</i>
<i># Funkce bez parametru vracejici konstantu.</i>
<i>#</i>
def <strong>answer</strong>():
    return 42
&nbsp;
<i>#</i>
<i># Soucet dvou cisel.</i>
<i>#</i>
def <strong>add</strong>(x, y):
    return x+y
&nbsp;
<i>#</i>
<i># Funkce s podminkou.</i>
<i>#</i>
def <strong>isNegative</strong>(x):
    if x &lt; 0:
        return True
    return False
&nbsp;
<i>#</i>
<i># Funkce s podminkou a se smyckou.</i>
<i>#</i>
def <strong>fibonacciIter</strong>(n):
    if n &lt;= 1:
        return n
&nbsp;
    result = 0
    n1 = 0
    n2 = 1
&nbsp;
    for i in xrange(n-1, 0, -1):
        result = n1 + n2
        n1 = n2
        n2 = result
&nbsp;
    return result
&nbsp;
<i>#</i>
<i># Funkce s rekurzi.</i>
<i>#</i>
def <strong>fibonacciRecursive</strong>(n):
    if n &lt;= 1:
        return n
    else:
        return fibonacciRecursive(n-1) + fibonacciRecursive(n-2)
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    nop1()
    nop2()
    print(answer())
    print(add(1, 2))
    print(add("Hello ", "world!"))
    print(isNegative(-10))
&nbsp;
    for n in xrange(0,11):
        print(str(n) + "\t" + str(fibonacciIter(n)) + "\t" + str(fibonacciRecursive(n)))
&nbsp;
<i>#main()</i>
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nnop1:")
    dis(nop1)
&nbsp;
    print("\nnop2:")
    dis(nop2)
&nbsp;
    print("\nanswer:")
    dis(answer)
&nbsp;
    print("\nadd:")
    dis(add)
&nbsp;
    print("\nisNegative:")
    dis(isNegative)
&nbsp;
    print("\nfibonacciIter:")
    dis(fibonacciIter)
&nbsp;
    print("\nfibonacciRecursive:")
    dis(fibonacciRecursive)
&nbsp;
disassemble()
</pre>

<p>Opět se podívejme, jak bude vypadat bajtkód vygenerovaný překladačem
Pythonu, resp.&nbsp;přesněji řečeno CPythonu:</p>

<p>Na překladu funkce <strong>nop1()</strong> pravděpodobně nenajdeme nic
překvapivého:</p>

<pre>
<strong>nop1</strong>:
 10           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE        
</pre>

<p>Stejným způsobem je přeložena i funkce <strong>nop2()</strong>, což je
pochopitelné:</p>

<pre>
<strong>nop2</strong>:
 16           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE        
</pre>

<p>V&nbsp;bajtkódu funkce <strong>answer()</strong> se na zásobník nejdříve
uloží číselná konstanta 42, která je následně instrukcí
<strong>RETURN_VALUE</strong> vrácena volající funkci:</p>

<pre>
<strong>answer</strong>:
 22           0 LOAD_CONST               1 (42)
              3 RETURN_VALUE        
</pre>

<p>Ve funkci <strong>add()</strong> se používá instrukce
<strong>BINARY_ADD</strong>, která však ve skutečnosti může pracovat nejenom
s&nbsp;čísly, ale i s&nbsp;řetězci, n-ticemi apod., což je velký rozdíl oproti
bajtkódu JVM, což jsme ostatně mohli vidět v&nbsp;předchozích kapitolách:</p>

<pre>
<strong>add</strong>:
 28           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_ADD          
              7 RETURN_VALUE        
</pre>

<p>V&nbsp;bajtkódu funkce <strong>isNegative()</strong> je zajímavá především
kombinace instrukcí <strong>COMPARE_OP</strong> (s&nbsp;operandem &lt;) a
<strong>JUMP_IF_FALSE</strong>. Instrukce bajtkódu Pythonu evidentně nejsou
pojmenovány s&nbsp;ohledem na jejich ruční zápis :-):</p>

<pre>
<strong>isNegative</strong>:
 34           0 LOAD_FAST                0 (x)
              3 LOAD_CONST               1 (0)
              6 COMPARE_OP               0 (&lt;)
              9 JUMP_IF_FALSE            5 (to 17)
             12 POP_TOP             
&nbsp;
 35          13 LOAD_GLOBAL              0 (True)
             16 RETURN_VALUE        
        &gt;&gt;   17 POP_TOP             

 36          18 LOAD_GLOBAL              1 (False)
             21 RETURN_VALUE        
</pre>




<p><a name="k16"></a></p>
<h2 id="k16">16. Dekompilace bajtkódu pro jednoduchý výraz s&nbsp;konstantami</h2>

<p></p>

<pre>
import ast
import dis


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1

    def visit(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


tree = ast.parse("print(1+2*(1-3/4)+5)", mode="exec")

visitor = Visitor()
visitor.visit(tree)

print("Compiling")

compiled = compile(tree, filename="<ast>", mode="exec")

print("Decompiling")

dis.dis(compiled)

print("Done")
</pre>

<pre>
   <_ast.Module object at 0x7fd10db86430>
     <_ast.Expr object at 0x7fd10daf1cd0>
       <_ast.Call object at 0x7fd10da84d90>
         <_ast.Name object at 0x7fd10da84dc0>
           <_ast.Load object at 0x7fd10dae39d0>
         <_ast.BinOp object at 0x7fd10da84f40>
           <_ast.BinOp object at 0x7fd10da84eb0>
             <_ast.Constant object at 0x7fd10da84f70>
             <_ast.Add object at 0x7fd10dae3e50>
             <_ast.BinOp object at 0x7fd10da84e80>
               <_ast.Constant object at 0x7fd10daaf130>
               <_ast.Mult object at 0x7fd10dae3f10>
               <_ast.BinOp object at 0x7fd10daaf310>
                 <_ast.Constant object at 0x7fd10daaf2b0>
                 <_ast.Sub object at 0x7fd10dae3eb0>
                 <_ast.BinOp object at 0x7fd10daaf340>
                   <_ast.Constant object at 0x7fd10daaf460>
                   <_ast.Div object at 0x7fd10dae3fd0>
                   <_ast.Constant object at 0x7fd10daaf400>
           <_ast.Add object at 0x7fd10dae3e50>
           <_ast.Constant object at 0x7fd10da84520>
Compiling
Decompiling
  1           0 LOAD_NAME                0 (print)
              2 LOAD_CONST               0 (6.5)
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE
Done
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>

<pre>
import ast
import dis


class Visitor(ast.NodeVisitor):
    def __init__(self):
        self.nest_level = 1

    def visit(self, node):
        indent = " " * self.nest_level * 2
        print(indent, node)
        self.nest_level += 1
        self.generic_visit(node)
        self.nest_level -= 1


tree = ast.parse("print(a+b*(c-d/e)+f)", mode="exec")

visitor = Visitor()
visitor.visit(tree)

print("Compiling")

compiled = compile(tree, filename="<ast>", mode="exec")

print("Decompiling")

dis.dis(compiled)

print("Done")
</pre>

<pre>
   <_ast.Module object at 0x7f21685c2430>
     <_ast.Expr object at 0x7f216852dcd0>
       <_ast.Call object at 0x7f21684c0d90>
         <_ast.Name object at 0x7f21684c0dc0>
           <_ast.Load object at 0x7f216851f9d0>
         <_ast.BinOp object at 0x7f21684c0f40>
           <_ast.BinOp object at 0x7f21684c0eb0>
             <_ast.Name object at 0x7f21684c0f70>
               <_ast.Load object at 0x7f216851f9d0>
             <_ast.Add object at 0x7f216851fe50>
             <_ast.BinOp object at 0x7f21684c0e80>
               <_ast.Name object at 0x7f21684eb130>
                 <_ast.Load object at 0x7f216851f9d0>
               <_ast.Mult object at 0x7f216851ff10>
               <_ast.BinOp object at 0x7f21684eb310>
                 <_ast.Name object at 0x7f21684eb2b0>
                   <_ast.Load object at 0x7f216851f9d0>
                 <_ast.Sub object at 0x7f216851feb0>
                 <_ast.BinOp object at 0x7f21684eb340>
                   <_ast.Name object at 0x7f21684eb460>
                     <_ast.Load object at 0x7f216851f9d0>
                   <_ast.Div object at 0x7f216851ffd0>
                   <_ast.Name object at 0x7f21684eb400>
                     <_ast.Load object at 0x7f216851f9d0>
           <_ast.Add object at 0x7f216851fe50>
           <_ast.Name object at 0x7f21684c0520>
             <_ast.Load object at 0x7f216851f9d0>
Compiling
Decompiling
  1           0 LOAD_NAME                0 (print)
              2 LOAD_NAME                1 (a)
              4 LOAD_NAME                2 (b)
              6 LOAD_NAME                3 (c)
              8 LOAD_NAME                4 (d)
             10 LOAD_NAME                5 (e)
             12 BINARY_TRUE_DIVIDE
             14 BINARY_SUBTRACT
             16 BINARY_MULTIPLY
             18 BINARY_ADD
             20 LOAD_NAME                6 (f)
             22 BINARY_ADD
             24 CALL_FUNCTION            1
             26 POP_TOP
             28 LOAD_CONST               0 (None)
             30 RETURN_VALUE
Done
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: definice gramatiky programovacího jazyka Python</h2>

<p>Jména filtrů použitých v&nbsp;návrhovém vzoru <i>Visitor</i> přímo vychází
z&nbsp;gramatiky programovacího jazyka Python. Ta (už) není v&nbsp;žádném
případě jednoduchá, což je ostatně patrné i při pohledu na tuto přílohu:</p>

<pre>
module Python version "$Revision$"
{
        mod = Module(stmt* body)
            | Interactive(stmt* body)
            | Expression(expr body)
&nbsp;
            -- not really an actual node but useful in Jython's typesystem.
            | Suite(stmt* body)
&nbsp;
        stmt = FunctionDef(identifier name, arguments args, 
                            stmt* body, expr* decorator_list)
              | ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)
              | Return(expr? value)
&nbsp;
              | Delete(expr* targets)
              | Assign(expr* targets, expr value)
              | AugAssign(expr target, operator op, expr value)
&nbsp;
              -- not sure if bool is allowed, can always use int
              | Print(expr? dest, expr* values, bool nl)
&nbsp;
              -- use 'orelse' because else is a keyword in target languages
              | For(expr target, expr iter, stmt* body, stmt* orelse)
              | While(expr test, stmt* body, stmt* orelse)
              | If(expr test, stmt* body, stmt* orelse)
              | With(expr context_expr, expr? optional_vars, stmt* body)
&nbsp;
              -- 'type' is a bad name
              | Raise(expr? type, expr? inst, expr? tback)
              | TryExcept(stmt* body, excepthandler* handlers, stmt* orelse)
              | TryFinally(stmt* body, stmt* finalbody)
              | Assert(expr test, expr? msg)
&nbsp;
              | Import(alias* names)
              | ImportFrom(identifier? module, alias* names, int? level)
&nbsp;
              -- Doesn't capture requirement that locals must be
              -- defined if globals is
              -- still supports use as a function!
              | Exec(expr body, expr? globals, expr? locals)
&nbsp;
              | Global(identifier* names)
              | Expr(expr value)
              | Pass | Break | Continue
&nbsp;
              -- XXX Jython will be different
              -- col_offset is the byte offset in the utf8 string the parser uses
              attributes (int lineno, int col_offset)
&nbsp;
              -- BoolOp() can use left &amp; right?
        expr = BoolOp(boolop op, expr* values)
             | BinOp(expr left, operator op, expr right)
             | UnaryOp(unaryop op, expr operand)
             | Lambda(arguments args, expr body)
             | IfExp(expr test, expr body, expr orelse)
             | Dict(expr* keys, expr* values)
             | Set(expr* elts)
             | ListComp(expr elt, comprehension* generators)
             | SetComp(expr elt, comprehension* generators)
             | DictComp(expr key, expr value, comprehension* generators)
             | GeneratorExp(expr elt, comprehension* generators)
             -- the grammar constrains where yield expressions can occur
             | Yield(expr? value)
             -- need sequences for compare to distinguish between
             -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3
             | Compare(expr left, cmpop* ops, expr* comparators)
             | Call(expr func, expr* args, keyword* keywords,
                         expr? starargs, expr? kwargs)
             | Repr(expr value)
             | Num(object n) -- a number as a PyObject.
             | Str(string s) -- need to specify raw, unicode, etc?
             -- other literals? bools?
&nbsp;
             -- the following expression can appear in assignment context
             | Attribute(expr value, identifier attr, expr_context ctx)
             | Subscript(expr value, slice slice, expr_context ctx)
             | Name(identifier id, expr_context ctx)
             | List(expr* elts, expr_context ctx) 
             | Tuple(expr* elts, expr_context ctx)
&nbsp;
              -- col_offset is the byte offset in the utf8 string the parser uses
              attributes (int lineno, int col_offset)
&nbsp;
        expr_context = Load | Store | Del | AugLoad | AugStore | Param
&nbsp;
        slice = Ellipsis | Slice(expr? lower, expr? upper, expr? step) 
              | ExtSlice(slice* dims) 
              | Index(expr value) 
&nbsp;
        boolop = And | Or 
&nbsp;
        operator = Add | Sub | Mult | Div | Mod | Pow | LShift 
                 | RShift | BitOr | BitXor | BitAnd | FloorDiv
&nbsp;
        unaryop = Invert | Not | UAdd | USub
&nbsp;
        cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn
&nbsp;
        comprehension = (expr target, expr iter, expr* ifs)
&nbsp;
        -- not sure what to call the first argument for raise and except
        excepthandler = ExceptHandler(expr? type, expr? name, stmt* body)
                        attributes (int lineno, int col_offset)
&nbsp;
        arguments = (expr* args, identifier? vararg, 
                     identifier? kwarg, expr* defaults)
&nbsp;
        -- keyword arguments supplied to call
        keyword = (identifier arg, expr value)
&nbsp;
        -- import name with optional 'as' alias.
        alias = (identifier name, identifier? asname)
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 (některé přímo pro Python 3.10) byly uloženy do Git
repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující jednoduchý výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/expression.py</a></td></tr>
<tr><td> 2</td><td>err_expression.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující chybný výraz</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/err_expression.py</a></td></tr>
<tr><td> 3</td><td>async.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující async a await</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/async.py</a></td></tr>
<tr><td> 4</td><td>primes.py</td><td>zdrojový kód, který se bude tokenizovat a parsovat, obsahující výpočet celočísel</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/primes.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>print_tokens.py</td><td>výpis všech typů a hodnot tokenů pro aktuální verzi Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/print_tokens.py</a></td></tr>
<tr><td> 6</td><td>tokenize_expression_1.py</td><td>tokenizace výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_1.py</a></td></tr>
<tr><td> 7</td><td>tokenize_expression_2.py</td><td>tokenizace výrazu, alternativní způsob otevření zdrojového souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_2.py</a></td></tr>
<tr><td> 8</td><td>tokenize_expression_3.py</td><td>tokenizace výrazu s&nbsp;více operátory</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_3.py</a></td></tr>
<tr><td> 9</td><td>tokenize_expression_4.py</td><td>tokenizace výrazu s&nbsp;více operátory, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_expression_4.py</a></td></tr>
<tr><td>10</td><td>tokenize_async.py</td><td>tokenizace zdrojového kódu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_async.py</a></td></tr>
<tr><td>11</td><td>tokenize_primes.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes.py</a></td></tr>
<tr><td>12</td><td>tokenize_primes_2.py</td><td>tokenizace zdrojového kódu <strong>primes.py</strong>, výpis přesného typu tokenu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_primes_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>parse_expression.py</td><td>parsing zdrojového kódu s&nbsp;výrazem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression.py</a></td></tr>
<tr><td>14</td><td>parse_expression_3_10.py</td><td>parsing zdrojového kódu s&nbsp;výrazem, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_expression_3_10.py</a></td></tr>
<tr><td>15</td><td>parse_async.py</td><td>parsing zdrojového kodu <strong>async.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async.py</a></td></tr>
<tr><td>16</td><td>parse_async_3_10.py</td><td>parsing zdrojového kodu <strong>async.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_async_3_10.py</a></td></tr>
<tr><td>17</td><td>parse_primes.py</td><td>parsing zdrojového kodu <strong>primes.py</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes.py</a></td></tr>
<tr><td>18</td><td>parse_primes_3_10.py</td><td>parsing zdrojového kodu <strong>primes.py</strong>, vylepšený výpis v&nbsp;Pythonu 3.10</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/parse_primes_3_10.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>traverse_expression_1.py</td><td>průchod AST, nejjednodušší varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_1.py</a></td></tr>
<tr><td>20</td><td>traverse_expression_2.py</td><td>průchod AST, vzor <i>Visitor</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_2.py</a></td></tr>
<tr><td>21</td><td>traverse_expression_3.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_3.py</a></td></tr>
<tr><td>22</td><td>traverse_expression_4.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_4.py</a></td></tr>
<tr><td>23</td><td>traverse_expression_5.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_5.py</a></td></tr>
<tr><td>24</td><td>traverse_expression_5.py</td><td>průchod AST, vzor <i>Visitor</i>, odsazení kódu, rozpoznání uzlů, vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_expression_6.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>ifs1.py</td><td>zdrojový kód s&nbsp;několika zanořenými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs1.py</a></td></tr>
<tr><td>26</td><td>ifs2.py</td><td>zdrojový kód s&nbsp;několika zanořenými úplnými podmínkami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/ifs2.py</a></td></tr>
<tr><td>27</td><td>tokenize_ifs1.py</td><td>tokenizace zdrojového kódu &bdquo;ifs1.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs1.py</a></td></tr>
<tr><td>28</td><td>tokenize_ifs2.py</td><td>tokenizace zdrojového kódu &bdquo;ifs2.py&ldquo;</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/tokenize_ifs2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>compile_tree.py</td><td>překlad a spuštění AST</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/compile_tree.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>sprites.py</td><td>zdrojový kód, jehož AST se bude zkoumat</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/sprites.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/sprites.py</a></td></tr>
<tr><td>31</td><td>traverse_code_1.py</td><td>průchod AST pro zvolený zdrojový kód</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_1.py</a></td></tr>
<tr><td>32</td><td>traverse_code_2.py</td><td>průchod AST, filtrace uzlů s&nbsp;definicí funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_2.py</a></td></tr>
<tr><td>33</td><td>traverse_code_3.py</td><td>průchod AST, filtrace uzlů s&nbsp;definicí modulu, třídy a funkce</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_3.py</a></td></tr>
<tr><td>34</td><td>traverse_code_4.py</td><td>průchod AST, filtrace uzlů se smyčkou for</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/traverse_code_4.py</a></td></tr>
<tr><td>35</td><td>decompile_1.py</td><td>dekompilace bajtkódu konstantního výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/decompile_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/decompile_1.py</a></td></tr>
<tr><td>36</td><td>decompile_2.py</td><td>dekompilace bajtkódu nekonstantního výrazu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/decompile_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/decompile_2.py</a></td></tr>
<tr><td>37</td><td>symbol_table_1.py</td><td>tisk tabulky symbolů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/symbol_table_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/symbol_table_1.py</a></td></tr>
<tr><td>38</td><td>symbol_table_2.py</td><td>tisk tabulky symbolů, vylepšená varianta</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ast/symbol_table_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ast/symbol_table_2.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>SymbolTable<br />
<a href="https://docs.python.org/3.8/library/symtable.html">https://docs.python.org/3.8/library/symtable.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Využití knihovny Pygments (nejenom) pro obarvení zdrojových kódů<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/">https://www.root.cz/clanky/vyuziti-knihovny-pygments-nejenom-pro-obarveni-zdrojovych-kodu/</a>
</li>

<li>Pygments - Python syntax highlighter<br />
<a href="http://pygments.org/">http://pygments.org/</a>
</li>

<li>Pygments (dokumentace)<br />
<a href="http://pygments.org/docs/">http://pygments.org/docs/</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Jazyky podporované knihovnou Pygments<br />
<a href="http://pygments.org/languages/">http://pygments.org/languages/</a>
</li>

<li>Pygments FAQ<br />
<a href="http://pygments.org/faq/">http://pygments.org/faq/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

