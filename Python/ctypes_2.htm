<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Propojení Pythonu s nativními knihovnami s využitím balíčku ctypes: struktury a ukazatele</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Propojení Pythonu s nativními knihovnami s využitím balíčku ctypes: struktury a ukazatele</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>S modulem ctypes, který umožňuje z Pythonu volat nativní funkce, jež jsou typicky vytvořené v jazyku C, jsme se již na stránkách Roota setkali. Ovšem ještě si musíme vysvětlit, jakým způsobem se do nativních funkcí předávají struktury, ať již hodnotou nebo odkazem.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Propojení Pythonu s&nbsp;nativními knihovnami s&nbsp;využitím balíčku ctypes: struktury a ukazatele</a></p>
<p><a href="#k02">2. Nativní funkce, které budou volány z&nbsp;Pythonu</a></p>
<p><a href="#k03">3. Pomocná funkce pro vykreslení pixelu</a></p>
<p><a href="#k04">4. Volání nativních funkcí z&nbsp;Pythonu s&nbsp;předáním všech parametrů</a></p>
<p><a href="#k05">5. Úplný zdrojový kód dnešního prvního demonstračního příkladu: céčková i Pythonní část</a></p>
<p><a href="#k06">6. Předání většího množství parametrů do nativních funkcí volaných z&nbsp;Pythonu</a></p>
<p><a href="#k07">7. Modifikace skriptu psaného v&nbsp;Pythonu, který nativní funkce volá</a></p>
<p><a href="#k08">8. Předání struktury do nativních funkcí</a></p>
<p><a href="#k09">9. Konstrukce struktury na straně skriptu psaného v&nbsp;Pythonu</a></p>
<p><a href="#k10">10. Úplný zdrojový kód dnešního třetího demonstračního příkladu: céčková i Pythonní část</a></p>
<p><a href="#k11">11. Nativní funkce akceptující ukazatel na strukturu</a></p>
<p><a href="#k12">12. Předání ukazatele na strukturu z&nbsp;Pythonu do nativních funkcí</a></p>
<p><a href="#k13">13. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu: céčková i Pythonní část</a></p>
<p><a href="#k14">14. Struktura s&nbsp;hodnotami použitými při výpočtech fraktálů</a></p>
<p><a href="#k15">15. Úplný zdrojový kód dnešního pátého demonstračního příkladu: céčková i Pythonní část</a></p>
<p><a href="#k16">16. Správa paměti</a></p>
<p><a href="#k17">17. Ukázka nekorektní práce s&nbsp;pamětí</a></p>
<p><a href="#k18">18. Zarovnání a výplně ve strukturách</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Propojení Pythonu s&nbsp;nativními knihovnami s&nbsp;využitím balíčku ctypes: struktury a ukazatele</h2>

<p>Propojení programovacího jazyka Python s&nbsp;jazykem C
(popř.&nbsp;s&nbsp;Rustem nebo jazykem Zig) přináší zajímavé možnosti a můžeme
tak vyřešit poměrně velké množství praktických problémů. V&nbsp;první řadě tato
technologie umožňuje relativně snadné volání funkcí ze systémových knihoven,
ale i dalších funkcí dostupných formou dynamicky sdílených knihoven. Díky tomu
je možné spojit snadnost a rychlost tvorby aplikací v&nbsp;Pythonu
(vysokoúrovňový jazyk s&nbsp;relativně velkou mírou abstrakce)
s&nbsp;optimalizovaným nativním kódem. Dobrým příkladem takového propojení je
projekt <i>Numpy</i>, v&nbsp;němž se výpočetně náročné části realizují
nativními funkcemi, ovšem programátoři tyto funkce volají přímo z&nbsp;Pythonu.
A příkladem propojení Pythonu s&nbsp;Rustem může být projekt <i>Polars</i>, se
kterým jsme se na stránkách Roota taktéž již setkali v&nbsp;článcích <a
href="https://www.root.cz/clanky/knihovna-polars-vykonnejsi-alternativa-ke-knihovne-pandas/">Knihovna
Polars: výkonnější alternativa ke knihovně Pandas</a> a <a
href="https://www.root.cz/clanky/knihovna-polars-vykonnejsi-alternativa-ke-knihovne-pandas-datove-ramce/">Knihovna
Polars: výkonnější alternativa ke knihovně Pandas (datové rámce)</a>.</p>

<p><a
href="https://www.root.cz/clanky/propojeni-pythonu-s-nativnimi-knihovnami-s-vyuzitim-balicku-ctypes/">V&nbsp;úvodním
článku o knihovně <strong>ctypes</strong></a>, v&nbsp;němž jsme toto téma
probírali, jsme si ukázali, jakým způsobem je možné do nativních (céčkovských)
funkcí předávat celočíselné hodnoty, hodnoty typu float/double a taktéž pole
(resp.&nbsp;přesněji řečeno ukazatele na první prvky polí). Dnes si tyto
informace doplníme o způsob předávání celých datových struktur (<i>struct</i>),
a to jak hodnotou, tak i referencí (tedy přes ukazatel). To nám umožní jak
snížení počtu předávaných parametrů, tak i zajištění větší čitelnosti
výsledných programů: týká se to jak Pythonní části, tak i části naprogramované
v&nbsp;jazyku C.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nativní funkce, které budou volány z&nbsp;Pythonu</h2>

<p>Připomeňme si ve stručnosti, jak vlastně vypadají nativní funkce, které
budeme chtít volat ze skriptu naprogramovaného v&nbsp;Pythonu. Jedná se o
funkce, které dokážou vypočítat klasickou Mandelbrotovu množinu i Juliovy
množiny (pro zadané parametry). Výsledné obrázky jsou reprezentovány
jednorozměrnými poli s&nbsp;prvky typu <strong>unsigned char</strong> (pixely
jsou ukládány po řádcích ve formátu RGB se čtyřmi bajty na pixel) a pixely jsou
obarveny na základě barvové palety (256 trojic hodnot, taktéž typu
<strong>unsigned char</strong>). Tím jsme si do značné míry zjednodušili práci,
protože do funkcí pro výpočet Mandelbrotovy množiny a Juliových množin
předáváme celočíselné hodnoty, hodnoty typu <i>double</i> a taktéž ukazatele na
typ <strong>unsighed char</strong>.</p>

<p>Funkce provádějící výpočet Mandelbrotovy množiny, vypadá následovně (kvůli
jednoduchosti se neprovádí žádné optimalizace):</p>

<pre>
void <strong>render_mandelbrot</strong>(unsigned int width, unsigned int height,
                       const unsigned char *palette, unsigned char *pixels) {
    int x, y;
    double cx, cy;
    double xmin = -2.0, ymin = -1.5, xmax = 1.0, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    cy = ymin;
    for (y = 0; y &lt; height; y++) {
        cx = xmin;
        for (x = 0; x &lt; width; x++) {
            double zx = 0.0;
            double zy = 0.0;
            unsigned int i = 0;
            while (i &lt; 150) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            cx += (xmax - xmin) / width;
        }
        cy += (ymax - ymin) / height;
    }
}
</pre>

<p>Funkce pro výpočet Juliových množin navíc akceptuje další dva parametry
<strong>cx</strong> a <strong>cy</strong>, které jsou typu <i>double</i>:</p>

<pre>
void <strong>render_julia</strong>(unsigned int width, unsigned int height,
                  const unsigned char *palette, unsigned char *pixels,
                  double cx, double cy) {
    int x, y;
    double zx0, zy0;
    double xmin = -1.5, ymin = -1.5, xmax = 1.5, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    zy0 = ymin;
    for (y = 0; y &lt; height; y++) {
        zx0 = xmin;
        for (x = 0; x &lt; width; x++) {
            double zx = zx0;
            double zy = zy0;
            unsigned int i = 0;
            while (i &lt; 150) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            zx0 += (xmax - xmin) / width;
        }
        zy0 += (ymax - ymin) / height;
    }
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pomocná funkce pro vykreslení pixelu</h2>

<p>Pro úplnost si doplníme zdrojový kód pomocné funkce, která slouží pro
vykreslení jednoho pixelu. Této funkci se předá ukazatel na první bajt pixelu
v&nbsp;rastrovém obrázku (přes referenci!), barvová paleta a index do této
palety. Funkce navíc změní referenci na aktivní pixel &ndash; další volání
<strong>putpixel</strong> tedy vybarví následující pixel v&nbsp;rastrovém
obrázku:</p>

<pre>
void <strong>putpixel</strong>(unsigned char **pixel, const unsigned char *palette,
              int color_index) {
    int color_offset = color_index * 3;
    unsigned char *pal = (unsigned char *)(palette + color_offset);
&nbsp;
    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal;
    (*pixel)++;
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Volání nativních funkcí z&nbsp;Pythonu s&nbsp;předáním všech parametrů</h2>

<p>Podívejme se nyní na způsob volání nativních funkcí z&nbsp;Pythonu. Volat
přitom budeme obě výše zmíněné funkce pro výpočet a vykreslení fraktálů, které
mají hlavičky:</p>

<pre>
void <strong>render_mandelbrot</strong>(unsigned int width, unsigned int height,
                       const unsigned char *palette, unsigned char *pixels) {
&nbsp;
void <strong>render_julia</strong>(unsigned int width, unsigned int height,
                  const unsigned char *palette, unsigned char *pixels,
                  double cx, double cy) {
&nbsp;
</pre>

<p>Do těchto funkcí se předává několik typů hodnot:</p>

<ol>
<li>Celočíselné hodnoty typu <strong>unsigned int</strong></li>
<li>Hodnoty typu <strong>double</strong></li>
<li>Hodnoty typu <strong>const unsigned char *</strong> (ve skutečnosti pole 256&times;3 prvky)</li>
<li>Hodnoty typu <strong>unsigned char *</strong> (obrázky šířka&times;výška&times;4 bajty)</li>
</ol>

<p>Předání prvních dvou typů hodnot je triviální &ndash; Pythonovské proměnné
typu <strong>int/long</strong> převedeme do nativní podoby pomocí
<strong>ctypes.c_int()</strong> a proměnné typu <strong>double</strong> pak
pomocí <strong>ctypes.c_double()</strong>.</p>

<p>Pro převod barvové palety (256&times;3 prvky) na nativní pole prvků typu
<strong>unsigned char</strong> si vytvoříme pomocnou funkci, která může vypadat
následovně:</p>

<pre>
def <strong>palette_to_buffer</strong>(p):
    s = <u>create_string_buffer</u>(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
</pre>

<p>Příklad použití:</p>

<pre>
pal = palette_to_buffer(palette)
</pre>

<p><div class="rs-tip-major">Poznámka: nenechte se zmást názvem
<strong>create_string_buffer</strong>; výsledkem bude paměťová oblast, kterou
můžeme v&nbsp;jazyku C považovat za pole prvků typu <strong>char</strong> nebo
<strong>unsigned char</strong>.</div></p>

<p>Následně si necháme (přímo v&nbsp;Pythonu) naalokovat buffer o takové
velikosti, aby do něj bylo možné uložit všechny pixely obrázku. Každý pixel je
uložen ve čtyřech bajtech, takže velikost bude rovna <strong>4 * width *
height</strong>. Pro alokaci bufferu použijeme funkci
<strong>create_string_buffer</strong>, která však (i přes své jméno) akceptuje
velikost v&nbsp;bajtech:</p>

<pre>
from ctypes import create_string_buffer
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
</pre>

<p>Způsob konstrukce obou výše zmíněných objektů a volání nativních funkcí může vypadat takto:</p>

<pre>
pal = palette_to_buffer(palette)
&nbsp;
<i># try to load dynamically linked library</i>
renderer = CDLL("./renderer.so")
&nbsp;
<i># create buffer for raster image</i>
buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
<i># render Mandelbrot set into buffer</i>
renderer.render_mandelbrot(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer)
image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
cx = -0.171119200000000013445
cy = 0.657309400000000000000
&nbsp;
<i># render Julia set into buffer</i>
renderer.render_julia(
    c_int(IMAGE_WIDTH),
    c_int(IMAGE_HEIGHT),
    pal,
    buffer,
    c_double(cx),
    c_double(cy),
)
image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
...
...
...
</pre>

<p><div class="rs-tip-major">Poznámka: výsledek by měl být plně přenositelný
mezi platformami.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Úplný zdrojový kód dnešního prvního demonstračního příkladu: céčková i Pythonní část</h2>

<p>Dnešní první demonstrační příklad má dvě části: nativní (céčkovou) a
Pythonní. Zdrojový kód céčkové části vypadá následovně:</p>

<pre>
void <strong>putpixel</strong>(unsigned char **pixel, const unsigned char *palette,
              int color_index) {
    int color_offset = color_index * 3;
    unsigned char *pal = (unsigned char *)(palette + color_offset);

    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal;
    (*pixel)++;
}
&nbsp;
void <strong>render_mandelbrot</strong>(unsigned int width, unsigned int height,
                       const unsigned char *palette, unsigned char *pixels) {
    int x, y;
    double cx, cy;
    double xmin = -2.0, ymin = -1.5, xmax = 1.0, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    cy = ymin;
    for (y = 0; y &lt; height; y++) {
        cx = xmin;
        for (x = 0; x &lt; width; x++) {
            double zx = 0.0;
            double zy = 0.0;
            unsigned int i = 0;
            while (i &lt; 150) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            cx += (xmax - xmin) / width;
        }
        cy += (ymax - ymin) / height;
    }
}
&nbsp;
void <strong>render_julia</strong>(unsigned int width, unsigned int height,
                  const unsigned char *palette, unsigned char *pixels,
                  double cx, double cy) {
    int x, y;
    double zx0, zy0;
    double xmin = -1.5, ymin = -1.5, xmax = 1.5, ymax = 1.5;
    unsigned char *p = pixels;

    zy0 = ymin;
    for (y = 0; y &lt; height; y++) {
        zx0 = xmin;
        for (x = 0; x &lt; width; x++) {
            double zx = zx0;
            double zy = zy0;
            unsigned int i = 0;
            while (i &lt; 150) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            zx0 += (xmax - xmin) / width;
        }
        zy0 += (ymax - ymin) / height;
    }
}
</pre>

<p>Překlad této části se provede přes Makefile:</p>

<pre>
.PHONY: all clean
&nbsp;
CC=gcc
CFLAGS=-Wall -pedantic -ansi -O2
&nbsp;
all: renderer.so
&nbsp;
clean:
        rm -f renderer.so
&nbsp;
renderer.so:    renderer.c
        $(CC) $(CFLAGS) -shared -Wl,-soname,renderer -o $@ -fPIC $&lt;
</pre>

<p>Část naprogramovaná v&nbsp;Pythonu bude vypadat následovně:</p>

<pre>
import sys
from ctypes import CDLL, c_double, c_int, create_string_buffer
&nbsp;
from palette_mandmap import palette
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    """Initialize Pygame display, drawing surface, and clocks."""
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>palette_to_buffer</strong>(p):
    s = create_string_buffer(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
def <strong>main</strong>():
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    <i># try to load dynamically linked library</i>
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    <i># render Mandelbrot set into buffer</i>
    renderer.render_mandelbrot(c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer)
    image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    cx = -0.171119200000000013445
    cy = 0.657309400000000000000
&nbsp;
    <i># render Julia set into buffer</i>
    renderer.render_julia(
        c_int(IMAGE_WIDTH),
        c_int(IMAGE_HEIGHT),
        pal,
        buffer,
        c_double(cx),
        c_double(cy),
    )
    image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
<i># finito</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Předání většího množství parametrů do nativních funkcí volaných z&nbsp;Pythonu</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu, který jsme si ukázali
v&nbsp;předchozích kapitolách, se vyskytovala magická konstanta 150
představující maximální počet iterací při výpočtu barev pixelů
v&nbsp;Mandelbrotově nebo Juliových množinách. Tuto konstantu pochopitelně
můžeme nahradit za parametr (což by bylo více než vhodné). Obě funkce se
nepatrně změní &ndash; modifikuje se jejich hlavička (což je pochopitelné) i
vnitřní smyčka s&nbsp;výpočtem. Nativní část aplikace se změní následovně
(modifikované části jsou podtrženy):</p>

<pre>
void <strong>putpixel</strong>(unsigned char **pixel, const unsigned char *palette,
              int color_index) {
    int color_offset = color_index * 3;
    unsigned char *pal = (unsigned char *)(palette + color_offset);
&nbsp;
    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal;
    (*pixel)++;
}
&nbsp;
void <strong>render_mandelbrot</strong>(unsigned int width, unsigned int height,
                       const unsigned char *palette, unsigned char *pixels,
                       <u>unsigned int maxiter</u>) {
    int x, y;
    double cx, cy;
    double xmin = -2.0, ymin = -1.5, xmax = 1.0, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    cy = ymin;
    for (y = 0; y &lt; height; y++) {
        cx = xmin;
        for (x = 0; x &lt; width; x++) {
            double zx = 0.0;
            double zy = 0.0;
            unsigned int i = 0;
            while (i &lt; <u>maxiter</u>) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            cx += (xmax - xmin) / width;
        }
        cy += (ymax - ymin) / height;
    }
}
&nbsp;
void <strong>render_julia</strong>(unsigned int width, unsigned int height,
                  const unsigned char *palette, unsigned char *pixels,
                  <u>unsigned int maxiter</u>, double cx, double cy) {
    int x, y;
    double zx0, zy0;
    double xmin = -1.5, ymin = -1.5, xmax = 1.5, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    zy0 = ymin;
    for (y = 0; y &lt; height; y++) {
        zx0 = xmin;
        for (x = 0; x &lt; width; x++) {
            double zx = zx0;
            double zy = zy0;
            unsigned int i = 0;
            while (i &lt; <u>maxiter</u>) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            zx0 += (xmax - xmin) / width;
        }
        zy0 += (ymax - ymin) / height;
    }
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Modifikace skriptu psaného v&nbsp;Pythonu, který nativní funkce volá</h2>

<p>Samozřejmě je nutné modifikovat i Pythonovský skript, který obě <a
href="#k06">výše zmíněné nativní funkce</a> volá. Změny vypadají takto:</p>

<pre>
MAXITER = 150
...
...
...
<i># render Mandelbrot set into buffer</i>
renderer.render_mandelbrot(
    c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer, <u>c_int(MAXITER</u>)
)
...
...
...
<i># render Julia set into buffer</i>
renderer.render_julia(
    c_int(IMAGE_WIDTH),
    c_int(IMAGE_HEIGHT),
    pal,
    buffer,
    c_double(cx),
    c_double(cy),
    <u>c_int(MAXITER)</u>,
)
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě knihovna
<strong>ctypes</strong> neprovádí kontrolu, zda je předán korektní počet a typ
parametrů! Ovšem volání nativní funkce může skončit v&nbsp;nekonečné smyčce,
program může zhavarovat na poškození paměti atd., pokud nepředáme všechny
parametry se správným typem a v&nbsp;korektním pořadí!</div></p>

<p>Pro úplnost si ukažme, jak vypadá celý skript, který je součástí dnešního
druhého demonstračního příkladu. Modifikované části jsou opět podtrženy:</p>

<pre>
import sys
from ctypes import CDLL, c_double, c_int, create_string_buffer
&nbsp;
from palette_mandmap import palette
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
<u>MAXITER = 150</u>
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    """Initialize Pygame display, drawing surface, and clocks."""
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>palette_to_buffer</strong>(p):
    s = create_string_buffer(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
def <strong>main</strong>():
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    <i># try to load dynamically linked library</i>
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    <i># render Mandelbrot set into buffer</i>
    renderer.render_mandelbrot(
        c_int(IMAGE_WIDTH), c_int(IMAGE_HEIGHT), pal, buffer, c_int(MAXITER)
    )
    image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    cx = -0.171119200000000013445
    cy = 0.657309400000000000000
&nbsp;
    <i># render Julia set into buffer</i>
    renderer.render_julia(
        c_int(IMAGE_WIDTH),
        c_int(IMAGE_HEIGHT),
        pal,
        buffer,
        c_double(cx),
        c_double(cy),
        c_int(MAXITER),
    )
    image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
<i># finito</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Předání struktury do nativních funkcí</h2>

<p>Jak jsme mohli vidět v&nbsp;předchozích kapitolách, počet předávaných
parametrů do nativních funkcí poměrně rychle narůstá, což vede k&nbsp;několika
důsledkům. Zejména se jak zápis nativních funkcí, tak i jejich volání
z&nbsp;Pythonu stává poměrně špatně čitelné &ndash; kód je
&bdquo;roztažen&ldquo; na několik řádků zdrojového kódu atd. A navíc
<strong>ctypes</strong> neprovádí striktní kontroly, zda byly skutečně předány
všechny parametry, což může vést k&nbsp;pádům programů, vznikům nekonečných
smyček apod.</p>

<p>Jedno z&nbsp;možných (i když jen částečných) řešení tohoto problému spočívá
v&nbsp;tom, že některé skupiny parametrů budeme předávat formou struktury,
tj.&nbsp;céčku s&nbsp;využitím typu <strong>struct</strong>.</p>

<p>Například první dva parametry předávané do funkcí
<strong>render_mandelbrot</strong> a <strong>render_julia</strong> představují
rozměry obrázku a proto můžeme namísto nich použít tuto jednoduchou
strukturu:</p>

<pre>
typedef struct {
    unsigned int width;
    unsigned int height;
} <strong>image_size_t</strong>;
</pre>

<p><div class="rs-tip-major">Poznámka: prozatím nebudeme řešit zarovnání prvků
ve struktuře. V&nbsp;tomto případě to totiž není nutné.</div></p>

<p>Zdrojový těchto dvou funkcí se změní následovně (změny jsou opět
podtrženy, podobně jako u předchozích příkladů):</p>

<pre>
void <strong>render_mandelbrot</strong>(<u>image_size_t image_size</u>,
                       const unsigned char *palette, unsigned char *pixels,
                       unsigned int maxiter) {
    ...
    ...
    ...
    for (y = 0; y &lt; <u>image_size.height</u>; y++) {
        ...
        for (x = 0; x &lt; <u>image_size.width</u>; x++) {
            ...
            ...
            ...
            cx += (xmax - xmin) / <u>image_size.width</u>;
        }
        cy += (ymax - ymin) / <u>image_size.height</u>;
        ...
    }
}
&nbsp;
&nbsp;
&nbsp;
void <strong>render_julia</strong>(<u>image_size_t image_size</u>,
                  const unsigned char *palette, unsigned char *pixels,
                  unsigned int maxiter, double cx, double cy) {
    ...
    ...
    ...
    for (y = 0; y &lt; <u>image_size.height</u>; y++) {
        zx0 = xmin;
        for (x = 0; x &lt; <u>image_size.width</u>; x++) {
            ...
            ...
            ...
            zx0 += (xmax - xmin) / <u>image_size.width</u>;
        }
        zy0 += (ymax - ymin) / <u>image_size.height</u>;
    }
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Konstrukce struktury na straně skriptu psaného v&nbsp;Pythonu</h2>

<p>Nyní nám zbývají vyřešit dva další kroky. Na straně programovacího jazyka
Python musíme nějakým způsobem vytvořit hodnotu, která odpovídá nativní céčkové
struktuře a následně tuto hodnotu předat do volané nativní funkce. V&nbsp;praxi
se jedná o relativně snadno řešitelné kroky. Vytvoříme třídu odvozenou od třídy
<strong>ctypes.Structure</strong>, ve které nadeklarujeme třídní atribut
nazvaný <strong>_fields_</strong>. Tento atribut bude obsahovat seznam dvojic
&bdquo;jméno nativního atributu&ldquo;+&bdquo;typ nativního atributu&ldquo;</p>

<pre>
class <strong>ImageSize</strong>(Structure):
    _fields_ = [
        ("width", c_uint),
        ("height", c_uint)
    ]
</pre>

<p><div class="rs-tip-major">Poznámka: opět platí, že prozatím nemusíme řešit
zarovnání prvků ve struktuře. Pouze musíme dodržet pořadí prvků i jejich datový
typ tak, aby to odpovídalo deklaraci struktury v&nbsp;nativním kódu!</div></p>

<p>Dále zkonstruujeme instanci této třídy, což je snadné (oba předávané
parametry jsou typu <strong>int/long</strong>):</p>

<pre>
image_size = ImageSize(IMAGE_WIDTH, IMAGE_HEIGHT)
</pre>

<p>A následně již můžeme tuto instanci použít při volání obou nativních
funkcí:</p>

<pre>
<i># render Mandelbrot set into buffer</i>
renderer.render_mandelbrot(<u>image_size</u>, pal, buffer, c_int(MAXITER))
...
...
...
<i># render Julia set into buffer</i>
renderer.render_julia(
    <u>image_size</u>,
    pal,
    buffer,
    c_double(cx),
    c_double(cy),
    c_int(MAXITER),
)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úplný zdrojový kód dnešního třetího demonstračního příkladu: céčková i Pythonní část</h2>

<p>Opět se podívejme na úplný zdrojový kód dnešního v&nbsp;pořadí již třetího
demonstračního příkladu. Nejdříve začneme s&nbsp;jeho céčkovskou částí:</p>

<pre>
typedef struct {
    unsigned int width;
    unsigned int height;
} <strong>image_size_t</strong>;
&nbsp;
void <strong>putpixel</strong>(unsigned char **pixel, const unsigned char *palette,
              int color_index) {
    int color_offset = color_index * 3;
    unsigned char *pal = (unsigned char *)(palette + color_offset);
&nbsp;
    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal;
    (*pixel)++;
}
&nbsp;
void <strong>render_mandelbrot</strong>(image_size_t image_size,
                       const unsigned char *palette, unsigned char *pixels,
                       unsigned int maxiter) {
    int x, y;
    double cx, cy;
    double xmin = -2.0, ymin = -1.5, xmax = 1.0, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    cy = ymin;
    for (y = 0; y &lt; image_size.height; y++) {
        cx = xmin;
        for (x = 0; x &lt; image_size.width; x++) {
            double zx = 0.0;
            double zy = 0.0;
            unsigned int i = 0;
            while (i &lt; maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            cx += (xmax - xmin) / image_size.width;
        }
        cy += (ymax - ymin) / image_size.height;
    }
}
&nbsp;
void <strong>render_julia</strong>(image_size_t image_size,
                  const unsigned char *palette, unsigned char *pixels,
                  unsigned int maxiter, double cx, double cy) {
    int x, y;
    double zx0, zy0;
    double xmin = -1.5, ymin = -1.5, xmax = 1.5, ymax = 1.5;
    unsigned char *p = pixels;

    zy0 = ymin;
    for (y = 0; y &lt; image_size.height; y++) {
        zx0 = xmin;
        for (x = 0; x &lt; image_size.width; x++) {
            double zx = zx0;
            double zy = zy0;
            unsigned int i = 0;
            while (i &lt; maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            zx0 += (xmax - xmin) / image_size.width;
        }
        zy0 += (ymax - ymin) / image_size.height;
    }
}
</pre>

<p>Následuje část naprogramovaná v&nbsp;Pythonu, ze které se volají výše
uvedené funkce <strong>render_mandelbrot</strong> a
<strong>render_julia</strong>:</p>

<pre>
import sys
from ctypes import (
    CDLL,
    c_double,
    c_int,
    c_uint,
    create_string_buffer,
    Structure,
)
&nbsp;
from palette_mandmap import palette
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
MAXITER = 150
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    """Initialize Pygame display, drawing surface, and clocks."""
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>palette_to_buffer</strong>(p):
    s = create_string_buffer(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
class <strong>ImageSize</strong>(Structure):
    _fields_ = [("width", c_uint), ("height", c_uint)]
&nbsp;
&nbsp;
def <strong>main</strong>():
    image_size = ImageSize(IMAGE_WIDTH, IMAGE_HEIGHT)
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    <i># try to load dynamically linked library</i>
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    <i># render Mandelbrot set into buffer</i>
    renderer.render_mandelbrot(image_size, pal, buffer, c_int(MAXITER))
    image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    cx = -0.171119200000000013445
    cy = 0.657309400000000000000
&nbsp;
    <i># render Julia set into buffer</i>
    renderer.render_julia(
        image_size,
        pal,
        buffer,
        c_double(cx),
        c_double(cy),
        c_int(MAXITER),
    )
    image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
<i># finito</i>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nativní funkce akceptující ukazatel na strukturu</h2>

<p>Struktura, kterou do funkcí naprogramovaných v&nbsp;jazyku C předáváme, je
prozatím velmi malá, protože obsahuje pouze dvě hodnoty typu <strong>unsigned
int</strong>:</p>

<pre>
typedef struct {
    unsigned int width;
    unsigned int height;
} <strong>image_size_t</strong>;
</pre>

<p>Ovšem v&nbsp;případě, že by se do struktury přidávaly další prvky, je na
čase se ptát, zda nebude výhodnější nepředávat celou strukturu <i>hodnotou</i>,
ale <i>odkazem</i> (tedy přes ukazatel). V&nbsp;takovém případě se samotné
funkce změní jen nepatrně &ndash; modifikuje se pochopitelně jejich hlavička a
přístup k&nbsp;prvkům struktury bude realizován operátorem -&gt; a nikoli
operátorem tečky (větší je sémantický rozdíl &ndash; nyní je struktura
měnitelná):</p>

<pre>
void <strong>render_mandelbrot</strong>(<u>image_size_t *image_size</u>,
                       const unsigned char *palette, unsigned char *pixels,
                       unsigned int maxiter) {
    ...
    ...
    ...
    for (y = 0; y &lt; <u>image_size-&gt;height</u>; y++) {
        ...
        for (x = 0; x &lt; <u>image_size-&gt;width</u>; x++) {
            ...
            ...
            ...
            cx += (xmax - xmin) / <u>image_size-&gt;width</u>;
        }
        ...
        cy += (ymax - ymin) / <u>image_size-&gt;height</u>;
    }
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Předání ukazatele na strukturu z&nbsp;Pythonu do nativních funkcí</h2>

<p>Pokud nativní funkce volané z&nbsp;Pythonu vyžadují jako některý svůj
parametr ukazatel na strukturu, musíme být schopní takový ukazatel získat přímo
v&nbsp;Pythonu. Celý postup je ve skutečnosti poměrně jednoduchý.</p>

<p>Nejprve musíme naimportovat mj.&nbsp;i funkci <strong>pointer</strong>
z&nbsp;modulu <strong>ctypes</strong>:</p>

<pre>
from ctypes import (
    CDLL,
    c_double,
    c_int,
    c_uint,
    create_string_buffer,
    Structure,
    pointer,
)
</pre>

<p>Samotná definice třídy představující strukturu se nijak nemění:</p>

<pre>
class <strong>ImageSize</strong>(Structure):
    _fields_ = [("width", c_uint), ("height", c_uint)]
</pre>

<p>Totéž platí i pro získání instance této třídy:</p>

<pre>
image_size = ImageSize(IMAGE_WIDTH, IMAGE_HEIGHT)
</pre>

<p>Ovšem při volání nativních funkcí předáváme ukazatel &ndash; viz podtržená
část kódu:</p>

<pre>
pal = palette_to_buffer(palette)
&nbsp;
<i># try to load dynamically linked library</i>
renderer = CDLL("./renderer.so")
&nbsp;
<i># create buffer for raster image</i>
buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
<i># render Mandelbrot set into buffer</i>
renderer.render_mandelbrot(<u>pointer(image_size)</u>, pal, buffer, c_int(MAXITER))
</pre>

<p>Naprosto totéž provedeme i při volání nativní funkce pro výpočet a
vykreslení Juliovy množiny:</p>

<pre>
cx = -0.171119200000000013445
cy = 0.657309400000000000000
&nbsp;
<i># render Julia set into buffer</i>
renderer.render_julia(
    <u>pointer(image_size)</u>,
    pal,
    buffer,
    c_double(cx),
    c_double(cy),
    c_int(MAXITER),
)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu: céčková i Pythonní část</h2>

<p>Dnešní třetí demonstrační příklad se změnami popsanými v&nbsp;předchozí
dvojici kapitol, je opět rozdělený na céčkovou a Pythonní část. Céčková část
vypadá takto:</p>

<pre>
typedef struct {
    unsigned int width;
    unsigned int height;
} <strong>image_size_t</strong>;
&nbsp;
void <strong>putpixel</strong>(unsigned char **pixel, const unsigned char *palette,
              int color_index) {
    int color_offset = color_index * 3;
    unsigned char *pal = (unsigned char *)(palette + color_offset);

    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal;
    (*pixel)++;
}
&nbsp;
void <strong>render_mandelbrot</strong>(image_size_t *image_size,
                       const unsigned char *palette, unsigned char *pixels,
                       unsigned int maxiter) {
    int x, y;
    double cx, cy;
    double xmin = -2.0, ymin = -1.5, xmax = 1.0, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    cy = ymin;
    for (y = 0; y &lt; image_size-&gt;height; y++) {
        cx = xmin;
        for (x = 0; x &lt; image_size-&gt;width; x++) {
            double zx = 0.0;
            double zy = 0.0;
            unsigned int i = 0;
            while (i &lt; maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            cx += (xmax - xmin) / image_size-&gt;width;
        }
        cy += (ymax - ymin) / image_size-&gt;height;
    }
}
&nbsp;
void <strong>render_julia</strong>(image_size_t *image_size,
                  const unsigned char *palette, unsigned char *pixels,
                  unsigned int maxiter, double cx, double cy) {
    int x, y;
    double zx0, zy0;
    double xmin = -1.5, ymin = -1.5, xmax = 1.5, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    zy0 = ymin;
    for (y = 0; y &lt; image_size-&gt;height; y++) {
        zx0 = xmin;
        for (x = 0; x &lt; image_size-&gt;width; x++) {
            double zx = zx0;
            double zy = zy0;
            unsigned int i = 0;
            while (i &lt; maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            zx0 += (xmax - xmin) / image_size-&gt;width;
        }
        zy0 += (ymax - ymin) / image_size-&gt;height;
    }
}
</pre>

<p>Následuje část naprogramovaná v&nbsp;Pythonu, ze které se volají nativní
funkce:</p>

<pre>
import sys
from ctypes import (
    CDLL,
    c_double,
    c_int,
    c_uint,
    create_string_buffer,
    Structure,
    pointer,
)
&nbsp;
from palette_mandmap import palette
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
MAXITER = 150
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    <i>"""Initialize Pygame display, drawing surface, and clocks."""</i>
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>palette_to_buffer</strong>(p):
    s = create_string_buffer(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
class <strong>ImageSize</strong>(Structure):
    _fields_ = [("width", c_uint), ("height", c_uint)]
&nbsp;
&nbsp;
def <strong>main</strong>():
    image_size = ImageSize(IMAGE_WIDTH, IMAGE_HEIGHT)
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    <i># try to load dynamically linked library</i>
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    <i># render Mandelbrot set into buffer</i>
    renderer.render_mandelbrot(pointer(image_size), pal, buffer, c_int(MAXITER))
    image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    cx = -0.171119200000000013445
    cy = 0.657309400000000000000
&nbsp;
    <i># render Julia set into buffer</i>
    renderer.render_julia(
        pointer(image_size),
        pal,
        buffer,
        c_double(cx),
        c_double(cy),
        c_int(MAXITER),
    )
    image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
<i># finito</i>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Struktura s&nbsp;hodnotami použitými při výpočtech fraktálů</h2>

<p>Výpočet Mandelbrotovy množiny a Juliových množin je možné ovlivnit různými
parametry. V&nbsp;první řadě se jedná o údaj o maximálním počtu iterací a u
Juliových množin taktéž o hodnotu komplexní konstanty <strong>c</strong>. Tyto
parametry jsme prozatím předávali samostatně: jako <strong>maxiter</strong>,
<strong>cx</strong> a <strong>cy</strong> (pojmenování reálné a imaginární
složky komplexní konstanty <strong>c</strong>). Ovšem nic nám nebrání
v&nbsp;tom, abychom tyto parametry předali společně v&nbsp;jediné (později
rozšiřitelné) struktuře. Její tvar může být následující:</p>

<pre>
typedef struct {
    unsigned int maxiter;
    double cx;
    double cy;
} <strong>rendering_params_t</strong>;
</pre>

<p>Tuto strukturu můžeme předat referencí, tedy přes ukazatel. Samotné výpočty
se změní jen nepatrně:</p>

<pre>
void <strong>render_mandelbrot</strong>(image_size_t *image_size,
                       const unsigned char *palette, unsigned char *pixels,
                       <u>rendering_params_t *rendering_params</u>) {
    ...
    ...
    ...
    while (i &lt; <u>rendering_params-&gt;maxiter</u>) {
        ...
        ...
        ...
    }
    ...
    ...
    ...
}
</pre>

<p>a:</p>

<pre>
void <strong>render_julia</strong>(image_size_t *image_size,
                  const unsigned char *palette, unsigned char *pixels,
                  <u>rendering_params_t *rendering_params</u>) {
    ...
    ...
    ...
    while (i &lt; <u>rendering_params-&gt;maxiter</u>) {
        ...
        ...
        ...
        zy = 2.0 * zx * zy + <u>rendering_params-&gt;cy</u>;
        zx = zx2 - zy2 + <u>rendering_params-&gt;cx</u>;
        ...
        ...
        ...
    }
    ...
    ...
    ...
}
</pre>

<p>Na straně Pythonu vytvoříme příslušnou třídu, která bude strukturu
reprezentovat:</p>

<pre>
class <strong>RenderingParams</strong>(Structure):
    _fields_ = [("maxiter", c_uint), ("cx", c_double), ("cy", c_double)]
</pre>

<p>Inicializace a předání přes ukazatel bude vypadat následovně:</p>

<pre>
rendering_params = RenderingParams(MAXITER, cx, cy)
...
...
...
<i># try to load dynamically linked library</i>
renderer = CDLL("./renderer.so")
...
...
...
<i># render Mandelbrot set into buffer</i>
renderer.render_mandelbrot(pointer(image_size), pal, buffer, <u>pointer(rendering_params)</u>)
...
...
...
<i># render Julia set into buffer</i>
renderer.render_julia(pointer(image_size), pal, buffer, <u>pointer(rendering_params)</u>)
...
...
...
<i># finito</i>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Úplný zdrojový kód dnešního pátého demonstračního příkladu: céčková i Pythonní část</h2>

<p>Dnešní pátý demonstrační příklad se změnami popsanými v&nbsp;předchozí
kapitole je opět rozdělený na céčkovou a Pythonní část. Céčková část vypadá
takto (povšimněte si definice dvou struktur na jeho začátku):</p>

<pre>
typedef struct {
    unsigned int width;
    unsigned int height;
} <strong>image_size_t</strong>;
&nbsp;
typedef struct {
    unsigned int maxiter;
    double cx;
    double cy;
} <strong>rendering_params_t</strong>;
&nbsp;
void <strong>putpixel</strong>(unsigned char **pixel, const unsigned char *palette,
              int color_index) {
    int color_offset = color_index * 3;
    unsigned char *pal = (unsigned char *)(palette + color_offset);

    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal++;
    *(*pixel)++ = *pal;
    (*pixel)++;
}
&nbsp;
void <strong>render_mandelbrot</strong>(image_size_t *image_size,
                       const unsigned char *palette, unsigned char *pixels,
                       rendering_params_t *rendering_params) {
    int x, y;
    double cx, cy;
    double xmin = -2.0, ymin = -1.5, xmax = 1.0, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    cy = ymin;
    for (y = 0; y &lt; image_size-&gt;height; y++) {
        cx = xmin;
        for (x = 0; x &lt; image_size-&gt;width; x++) {
            double zx = 0.0;
            double zy = 0.0;
            unsigned int i = 0;
            while (i &lt; rendering_params-&gt;maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            cx += (xmax - xmin) / image_size-&gt;width;
        }
        cy += (ymax - ymin) / image_size-&gt;height;
    }
}
&nbsp;
void <strong>render_julia</strong>(image_size_t *image_size,
                  const unsigned char *palette, unsigned char *pixels,
                  rendering_params_t *rendering_params) {
    int x, y;
    double zx0, zy0;
    double xmin = -1.5, ymin = -1.5, xmax = 1.5, ymax = 1.5;
    unsigned char *p = pixels;
&nbsp;
    zy0 = ymin;
    for (y = 0; y &lt; image_size-&gt;height; y++) {
        zx0 = xmin;
        for (x = 0; x &lt; image_size-&gt;width; x++) {
            double zx = zx0;
            double zy = zy0;
            unsigned int i = 0;
            while (i &lt; rendering_params-&gt;maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + rendering_params-&gt;cy;
                zx = zx2 - zy2 + rendering_params-&gt;cx;
                i++;
            }
            putpixel(&amp;p, palette, i);
            zx0 += (xmax - xmin) / image_size-&gt;width;
        }
        zy0 += (ymax - ymin) / image_size-&gt;height;
    }
}
</pre>

<p>Část naprogramovaná v&nbsp;Pythonu má tento tvar:</p>

<pre>
import sys
from ctypes import (
    CDLL,
    c_double,
    c_int,
    c_uint,
    create_string_buffer,
    Structure,
    pointer,
)
&nbsp;
from palette_mandmap import palette
&nbsp;
import pygame
import pygame.locals
&nbsp;
TITLE = "Renderer"
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 300
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
&nbsp;
MAXITER = 150
&nbsp;
&nbsp;
def <strong>initialize_ui</strong>(title, width, height):
    <i>"""Initialize Pygame display, drawing surface, and clocks."""</i>
    <i># set window title</i>
    pygame.display.set_caption(title)
&nbsp;
    <i># initialize window</i>
    display = pygame.display.set_mode([width, height])
    display.fill((0, 0, 0))
&nbsp;
    clock = pygame.time.Clock()
&nbsp;
    return display, clock
&nbsp;
&nbsp;
def <strong>palette_to_buffer</strong>(p):
    s = create_string_buffer(len(p) * 3)
    i = 0
    for color in p:
        s[i] = color[0]
        s[i + 1] = color[1]
        s[i + 2] = color[2]
        i += 3
    return s
&nbsp;
&nbsp;
def <strong>event_loop</strong>(display, image1, image2, clock):
    while True:
        for event in pygame.event.get():
            if event.type == pygame.locals.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.locals.KEYDOWN:
                if event.key == pygame.locals.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
&nbsp;
        <i># all events has been processed - update scene and redraw the screen</i>
        display.blit(image1, (30, 20))
        display.blit(image2, (60 + image1.get_width(), 20))
&nbsp;
        <i># and update the whole display</i>
        pygame.display.update()
        clock.tick(25)
&nbsp;
&nbsp;
def <strong>image_from_buffer</strong>(buffer, width, height, fmt):
    return pygame.image.frombytes(bytes(buffer), (width, height), fmt)
&nbsp;
&nbsp;
class <strong>ImageSize</strong>(Structure):
    _fields_ = [("width", c_uint), ("height", c_uint)]
&nbsp;
&nbsp;
class <strong>RenderingParams</strong>(Structure):
    _fields_ = [("maxiter", c_uint), ("cx", c_double), ("cy", c_double)]
&nbsp;
&nbsp;
def <strong>main</strong>():
    image_size = ImageSize(IMAGE_WIDTH, IMAGE_HEIGHT)
&nbsp;
    cx = -0.171119200000000013445
    cy = 0.657309400000000000000
    rendering_params = RenderingParams(MAXITER, cx, cy)
&nbsp;
    pal = palette_to_buffer(palette)
&nbsp;
    display, clock = initialize_ui(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT)
&nbsp;
    <i># try to load dynamically linked library</i>
    renderer = CDLL("./renderer.so")
&nbsp;
    <i># create buffer for raster image</i>
    buffer = create_string_buffer(4 * IMAGE_WIDTH * IMAGE_HEIGHT)
&nbsp;
    <i># render Mandelbrot set into buffer</i>
    renderer.render_mandelbrot(
        pointer(image_size), pal, buffer, pointer(rendering_params)
    )
    image1 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    <i># render Julia set into buffer</i>
    renderer.render_julia(pointer(image_size), pal, buffer, pointer(rendering_params))
    image2 = image_from_buffer(buffer, IMAGE_WIDTH, IMAGE_HEIGHT, "RGBX")
&nbsp;
    event_loop(display, image1, image2, clock)
&nbsp;
&nbsp;
if __name__ == "__main__":
    main()
&nbsp;
&nbsp;
<i># finito</i>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Správa paměti</h2>

<p>Prozatím jsme si ukázali tu nejjednodušší formu komunikace mezi skriptem
psaným v&nbsp;Pythonu a nativními funkcemi. Tato komunikace spočívala
v&nbsp;tom, že veškeré objekty byly alokovány na straně Pythonu a následně byly
předávány do volaných nativních funkcí. Mohlo by se tedy zdát, že se vůbec
nemusíme starat o správu paměti. V&nbsp;praxi je to samozřejmě mnohem
komplikovanější a mohou nastat situace, kdy je nutné, aby paměť byla alokována
na straně céčkovských funkcí (a vrácena přes ukazatel) nebo aby se prováděla
explicitní dealokace paměti pro objekty vytvořené jak na straně Pythonu, tak i
na straně céčka. To celou komunikaci skutečně komplikuje a vlastně tak do
Pythonu (částečně) zavádíme některé postupy, které zde nebylo nutné realizovat.
V&nbsp;navazující kapitole si ukážeme některé <i>nekorektní</i> operace,
zejména pokus o dealokaci objektů (provedené v&nbsp;céčkových funkcích), které
nejsou dealokovatelné nebo jsou naopak explicitně dealokovány na straně
Pythonu. Později si ukážeme jedno možné řešení tohoto problému, které ovšem
není ani zdaleka ideální.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Ukázka nekorektní práce s&nbsp;pamětí</h2>

<p>Nativní funkce, které byly použity v&nbsp;předchozích demonstračních
příkladech, nyní upravíme, a to konkrétně do takové podoby, aby se
z&nbsp;volaly standardní funkce <strong>free</strong> s&nbsp;předáním ukazatelů
na obě datové struktury (<strong>image_size_t *</strong> a
<strong>rendering_params_t *</strong>). To je pochopitelně zcela nekorektní
chování:</p>

<pre>
#include &lt;stdlib.h&gt;
&nbsp;
typedef struct {
    unsigned int width;
    unsigned int height;
} <strong>image_size_t</strong>;
&nbsp;
typedef struct {
    unsigned int maxiter;
    double cx;
    double cy;
} <strong>rendering_params_t</strong>;
&nbsp;
&nbsp;
void <strong>render_mandelbrot</strong>(image_size_t *image_size,
                       const unsigned char *palette, unsigned char *pixels,
                       rendering_params_t *rendering_params) {
    <u>free(image_size)</u>;
    <u>free(rendering_params)</u>;
}
&nbsp;
void <strong>render_julia</strong>(image_size_t *image_size,
                  const unsigned char *palette, unsigned char *pixels,
                  rendering_params_t *rendering_params) {
    <u>free(image_size)</u>;
    <u>free(rendering_params)</u>;
}
</pre>

<p>Bude zajímavé zjistit, jak se bude aplikace chovat, pokud obě funkce
zavoláme z&nbsp;Pythonu a předáme jim ukazatele na struktury:</p>

<pre>
pygame 2.6.1 (SDL 2.28.4, Python 3.12.10)
Hello from the pygame community. https://www.pygame.org/contribute.html
<strong>free(): invalid pointer</strong>
&nbsp;
Command terminated
</pre>

<p>Nekorektní chování &ndash; pokus o uvolnění paměti na zásobníku &ndash; byl
odhalen a aplikace byla ukončena.</p>

<p>Taktéž nebude dovolena dvojí dealokace paměti s&nbsp;bitmapou:</p>

<pre>
#include &lt;stdlib.h&gt;
&nbsp;
typedef struct {
    unsigned int width;
    unsigned int height;
} <strong>image_size_t</strong>;
&nbsp;
typedef struct {
    unsigned int maxiter;
    double cx;
    double cy;
} <strong>rendering_params_t</strong>;
&nbsp;
&nbsp;
void <strong>render_mandelbrot</strong>(image_size_t *image_size,
                       const unsigned char *palette, unsigned char *pixels,
                       rendering_params_t *rendering_params) {
    <u>free(pixels)</u>;
}

void <strong>render_julia</strong>(image_size_t *image_size,
                  const unsigned char *palette, unsigned char *pixels,
                  rendering_params_t *rendering_params) {
    <u>free(pixels)</u>;
}
</pre>

<p>Chyba bude v&nbsp;tomto případě odlišná, ale opět je snadno detekovatelná
standardními knihovnami a jejich runtime systémem:</p>

<pre>
pygame 2.6.1 (SDL 2.28.4, Python 3.12.10)
Hello from the pygame community. https://www.pygame.org/contribute.html
<strong>double free or corruption (!prev)</strong>
&nbsp;
Command terminated
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Zarovnání a výplně ve strukturách</h2>

<p>V&nbsp;praxi při realizaci komunikace mezi programem psaným v&nbsp;Pythonu a
nativními funkcemi psanými (zejména) v&nbsp;jazyku C narazíme ještě na jeden
problém: jak zajistit korektní inicializaci struktury, ve které jsou prvky
různým způsobem zarovnány a kam jsou popřípadě vloženy nějaké výplně. Prozatím
jsme na tento problém nenarazili, protože knihovna <strong>ctypes</strong>
počítá s&nbsp;tím, že u céčkových struktur budou zachována výchozí pravidla pro
zarovnání/výplně. Ovšem v&nbsp;praxi můžeme narazit i na struktury, ve kterých
je zarovnání ovlivněno programátorem (a to ještě nepočítáme s&nbsp;existencí
bitových polí). V&nbsp;tomto případě se pochopitelně musí Python nové struktuře
s&nbsp;jinou velikostí a jinými offsety prvků přizpůsobit. Jak toho je možné
dosáhnout, si vysvětlíme v&nbsp;samostatném (již mnohem stručnějším)
článku.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;minulém i dnešním článku popsané demonstrační příklady naleznete na
GitHubu:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>&nbsp;</td><th>1</th><th>Vyplnění rastrových obrázků vzorkem přímo z&nbsp;Pythonu</th><th>&nbsp;</th></tr>
<tr><td> 1</td><td>show.py</td><td>Vyplnění rastrových obrázků vzorkem přímo z&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>2</th><th>Zavolání nativní funkce pro vyplnění obrázku vzorkem</th><th>&nbsp;</th></tr>
<tr><td> 1</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/Makefile</a></td></tr>
<tr><td> 2</td><td>renderer.c</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/renderer.c</a></td></tr>
<tr><td> 3</td><td>show.py</td><td>zobrazení dvojice testovacích obrázků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example1/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>3</th><th>Vyplnění rastrového obrázku s&nbsp;využitím barvové palety</th><th>&nbsp;</th></tr>
<tr><td> 5</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/Makefile</a></td></tr>
<tr><td> 5</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/palette_mandmap.py</a></td></tr>
<tr><td> 6</td><td>renderer.c</td><td>vyplnění rastrového obrázku s&nbsp;využitím barvové palety</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/renderer.c</a></td></tr>
<tr><td> 7</td><td>show.py</td><td>zobrazení testovacího obrázku s&nbsp;paletou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example2/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>4</th><th>Výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;jazyku C</th><th>&nbsp;</th></tr>
<tr><td> 8</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/Makefile</a></td></tr>
<tr><td> 9</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/palette_mandmap.py</a></td></tr>
<tr><td>10</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/renderer.c</a></td></tr>
<tr><td>11</td><td>show.py</td><td>realizace výpočtu a zobrazení Mandelbrotovy a Juliovy množiny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example3/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>5</th><th>Interaktivní změna tvaru Juliovy množiny</th><th>&nbsp;</th></tr>
<tr><td>12</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/Makefile</a></td></tr>
<tr><td>13</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/palette_mandmap.py</a></td></tr>
<tr><td>14</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/renderer.c</a></td></tr>
<tr><td>15</td><td>show.py</td><td>interaktivní změna hodnoty C při výpočtu Juliovy množiny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example4/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>6</th><th>Využití jednoho (sdíleného) bufferu pro oba obrázky</th><th>&nbsp;</th></tr>
<tr><td>16</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/Makefile</a></td></tr>
<tr><td>17</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/palette_mandmap.py</a></td></tr>
<tr><td>18</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/renderer.c</a></td></tr>
<tr><td>19</td><td>show.py</td><td>využití jednoho (sdíleného) bufferu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example5/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>7</th><th>Využití dvojice bufferů, jeden buffer pro každý obrázek</th><th>&nbsp;</th></tr>
<tr><td>20</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/Makefile</a></td></tr>
<tr><td>21</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/palette_mandmap.py</a></td></tr>
<tr><td>22</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/renderer.c</a></td></tr>
<tr><td>23</td><td>show.py</td><td>využití dvojice rozličných bufferů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example6/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><th>8</th><th>Přístup k&nbsp;pixelům obrázku po 32bitových slovech</th><th>&nbsp;</th></tr>
<tr><td>24</td><td>Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/Makefile</a></td></tr>
<tr><td>25</td><td>palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/palette_mandmap.py</a></td></tr>
<tr><td>26</td><td>renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/renderer.c</a></td></tr>
<tr><td>27</td><td>show.py</td><td>využití dvojice rozličných bufferů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example7/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>example8/Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example8/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example8/Makefile</a></td></tr>
<tr><td>29</td><td>example8/palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example8/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example8/palette_mandmap.py</a></td></tr>
<tr><td>30</td><td>example8/renderer.c</td><td>výpočet Mandelbrotovy a Juliovy množiny implementovaný v&nbsp;C</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example8/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example8/renderer.c</a></td></tr>
<tr><td>31</td><td>example8/show.py</td><td>volání funkcí <strong>render_mandelbrot</strong> a <strong>render_julia</strong> s&nbsp;předáním všech potřebných parametrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example8/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example8/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>example9/Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example9/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example9/Makefile</a></td></tr>
<tr><td>29</td><td>example9/palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example9/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example9/palette_mandmap.py</a></td></tr>
<tr><td>30</td><td>example9/renderer.c</td><td>úprava předchozího příkladu: předání maximálního počtu iterací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example9/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example9/renderer.c</a></td></tr>
<tr><td>31</td><td>example9/show.py</td><td>volání funkcí <strong>render_mandelbrot</strong> a <strong>render_julia</strong> s&nbsp;předáním všech potřebných parametrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example9/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/example9/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>exampleA/Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleA/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleA/Makefile</a></td></tr>
<tr><td>29</td><td>exampleA/palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleA/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleA/palette_mandmap.py</a></td></tr>
<tr><td>30</td><td>exampleA/renderer.c</td><td>úprava předchozího příkladu: předání velikosti obrázku formou struktury</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleA/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleA/renderer.c</a></td></tr>
<tr><td>31</td><td>exampleA/show.py</td><td>volání funkcí <strong>render_mandelbrot</strong> a <strong>render_julia</strong> s&nbsp;předáním všech potřebných parametrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleA/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleA/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>exampleB/Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleB/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleB/Makefile</a></td></tr>
<tr><td>29</td><td>exampleB/palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleB/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleB/palette_mandmap.py</a></td></tr>
<tr><td>30</td><td>exampleB/renderer.c</td><td>úprava předchozího příkladu: předání velikosti obrázku formou ukazatele na strukturu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleB/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleB/renderer.c</a></td></tr>
<tr><td>31</td><td>exampleB/show.py</td><td>volání funkcí <strong>render_mandelbrot</strong> a <strong>render_julia</strong> s&nbsp;předáním všech potřebných parametrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleB/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleB/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>exampleC/Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleC/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleC/Makefile</a></td></tr>
<tr><td>29</td><td>exampleC/palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleC/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleC/palette_mandmap.py</a></td></tr>
<tr><td>30</td><td>exampleC/renderer.c</td><td>úprava předchozího příkladu: předání parametrů pro výpočet formou ukazatele na strukturu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleC/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleC/renderer.c</a></td></tr>
<tr><td>31</td><td>exampleC/show.py</td><td>volání funkcí <strong>render_mandelbrot</strong> a <strong>render_julia</strong> s&nbsp;předáním všech potřebných parametrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleC/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleC/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>exampleD/Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleD/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleD/Makefile</a></td></tr>
<tr><td>33</td><td>exampleD/palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleD/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleD/palette_mandmap.py</a></td></tr>
<tr><td>34</td><td>exampleD/renderer.c</td><td>pokus o uvolnění paměti s&nbsp;předanými strukturami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleD/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleD/renderer.c</a></td></tr>
<tr><td>35</td><td>exampleD/show.py</td><td>volání funkcí <strong>render_mandelbrot</strong> a <strong>render_julia</strong> s&nbsp;předáním všech potřebných parametrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleD/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleD/show.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>36</td><td>exampleE/Makefile</td><td>Makefile pro překlad kódu <strong>renderer.c</strong> do dynamicky sdílené knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleE/Makefile">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleE/Makefile</a></td></tr>
<tr><td>37</td><td>exampleE/palette_mandmap.py</td><td>definice barvové palety s&nbsp;256 barvami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleE/palette_mandmap.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleE/palette_mandmap.py</a></td></tr>
<tr><td>38</td><td>exampleE/renderer.c</td><td>pokus o uvolnění paměti s&nbsp;předanou bitmapou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleE/renderer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleE/renderer.c</a></td></tr>
<tr><td>39</td><td>exampleE/show.py</td><td>volání funkcí <strong>render_mandelbrot</strong> a <strong>render_julia</strong> s&nbsp;předáním všech potřebných parametrů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleE/show.py">https://github.com/tisnik/most-popular-python-libs/blob/master/ctypes/exampleE/show.py</a></td></tr>
</table>

<p>Navíc si pro úplnost uveďme demonstrační příklady použité v&nbsp;článcích o
knihovně <i>cffi</i>. I v&nbsp;těchto článcích jsme se totiž o <i>ctypes</i>
zmiňovali:</p>

<table>
<tr><th>  #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>  1</td><td>adder/adder.c</td><td>funkce psaná v&nbsp;C, která sečte své dva celočíselné parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/adder.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/adder.c</a></td></tr>
<tr><td>  2</td><td>adder/call_via_cffi1.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;korektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi1.py</a></td></tr>
<tr><td>  3</td><td>adder/call_via_cffi2.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi2.py</a></td></tr>
<tr><td>  4</td><td>adder/call_via_cffi3.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi3.py</a></td></tr>
<tr><td>  5</td><td>adder/call_via_cffi.sh</td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_cffi.sh</a></td></tr>
<tr><td>  6</td><td>adder/call_via_ctypes1.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;korektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes1.py</a></td></tr>
<tr><td>  7</td><td>adder/call_via_ctypes2.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes2.py</a></td></tr>
<tr><td>  8</td><td>adder/call_via_ctypes3.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;nekorektními parametry</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes3.py</a></td></tr>
<tr><td>  9</td><td>adder/call_via_ctypes.sh </td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/call_via_ctypes.sh</a></td></tr>
<tr><td> 10</td><td>adder/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/make_library.sh</a></td></tr>
<tr><td> 11</td><td>adder/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/adder/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 12</td><td>greeter/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/greeter.c</a></td></tr>
<tr><td> 13</td><td>greeter/call_via_cffi1.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;nekorektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi1.py</a></td></tr>
<tr><td> 14</td><td>greeter/call_via_cffi2.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi2.py</a></td></tr>
<tr><td> 15</td><td>greeter/call_via_cffi3.py</td><td>zavolání céčkovské funkce přes <i>cffi</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi3.py</a></td></tr>
<tr><td> 16</td><td>greeter/call_via_cffi.sh</td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_cffi.sh</a></td></tr>
<tr><td> 17</td><td>greeter/call_via_ctypes1.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;nekorektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes1.py</a></td></tr>
<tr><td> 18</td><td>greeter/call_via_ctypes2.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes2.py</a></td></tr>
<tr><td> 19</td><td>greeter/call_via_ctypes3.py</td><td>zavolání céčkovské funkce přes <i>ctypes</i> s&nbsp;korektním parametrem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes3.py</a></td></tr>
<tr><td> 20</td><td>greeter/call_via_ctypes.sh</td><td>nastavení cest a spuštění všech tří předchozích Pythonovských skriptů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/call_via_ctypes.sh</a></td></tr>
<tr><td> 21</td><td>greeter/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/make_library.sh</a></td></tr>
<tr><td> 22</td><td>greeter/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 23</td><td>swapper/swapper.c</td><td>céčkovská funkce prohazující obsah svých dvou parametrů předávaných referencí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/swapper.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/swapper.c</a></td></tr>
<tr><td> 24</td><td>swapper/call_via_cffi1.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python (korektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi1.py</a></td></tr>
<tr><td> 25</td><td>swapper/call_via_cffi2.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python (nekorektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi2.py</a></td></tr>
<tr><td> 26</td><td>swapper/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/call_via_cffi.sh</a></td></tr>
<tr><td> 27</td><td>swapper/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/make_library.sh</a></td></tr>
<tr><td> 28</td><td>swapper/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/swapper/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 29</td><td>filler/filler.c</td><td>céčkovská funkce pro vyplnění části pole zadanou hodnotou</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/filler.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/filler.c</a></td></tr>
<tr><td> 30</td><td>filler/call_via_cffi.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.py</a></td></tr>
<tr><td> 31</td><td>filler/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/call_via_cffi.sh</a></td></tr>
<tr><td> 32</td><td>filler/make_library.sh </td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/make_library.sh</a></td></tr>
<tr><td> 32</td><td>filler/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/filler/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 33</td><td>greeter_h/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/greeter.c</a></td></tr>
<tr><td> 34</td><td>greeter_h/greeter.h</td><td>prototyp (předběžná deklarace) funkce <i>greeter</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/greeter.h</a></td></tr>
<tr><td> 35</td><td>greeter_h/call_via_cffi4.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/call_via_cffi4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/call_via_cffi4.py</a></td></tr>
<tr><td> 36</td><td>greeter_h/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/call_via_cffi.sh</a></td></tr>
<tr><td> 37</td><td>greeter_h/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/make_library.sh</a></td></tr>
<tr><td> 38</td><td>greeter_h/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 39</td><td>greeter_h_2/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/greeter.c</a></td></tr>
<tr><td> 40</td><td>greeter_h_2/greeter.h</td><td>prototyp (předběžná deklarace) funkce <i>greeter</i> obalená v&nbsp;testu na existenci symbolu/makra</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/greeter.h</a></td></tr>
<tr><td> 41</td><td>greeter_h_2/call_via_cffi5.py</td><td>zavolání céčkovské knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/call_via_cffi5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/call_via_cffi5.py</a></td></tr>
<tr><td> 42</td><td>greeter_h_2/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/call_via_cffi.sh</a></td></tr>
<tr><td> 43</td><td>greeter_h_2/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/make_library.sh</a></td></tr>
<tr><td> 44</td><td>greeter_h_2/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_2/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 45</td><td>greeter_h_3/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/greeter.c</a></td></tr>
<tr><td> 46</td><td>greeter_h_3/greeter.h</td><td>test na existenci symbolu/makra, pokud makro neexistuje, provede se vložení dalšího souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/greeter.h</a></td></tr>
<tr><td> 47</td><td>greeter_h_3/_greeter.h</td><td>prototyp (předběžná deklarace) funkce <i>greeter</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/_greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/_greeter.h</a></td></tr>
<tr><td> 48</td><td>greeter_h_3/call_via_cffi5.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/call_via_cffi5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/call_via_cffi5.py</a></td></tr>
<tr><td> 49</td><td>greeter_h_3/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/call_via_cffi.sh</a></td></tr>
<tr><td> 50</td><td>greeter_h_3/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/make_library.sh</a></td></tr>
<tr><td> 51</td><td>greeter_h_3/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_h_3/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 52</td><td>greeter_build/greeter.c</td><td>funkce psaná v&nbsp;C, která na standardní výstup vytiskne řetězec</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/greeter.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/greeter.c</a></td></tr>
<tr><td> 53</td><td>greeter_build/greeter.h</td><td>prototyp (předběžná deklarace) funkce <i>greeter</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/greeter.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/greeter.h</a></td></tr>
<tr><td> 54</td><td>greeter_build/call_via_cffi7.py</td><td>skript pro překlad céčkovské funkce, vytvoření dynamicky linkované knihovny a zavolání funkce z&nbsp;této knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/call_via_cffi7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/call_via_cffi7.py</a></td></tr>
<tr><td> 55</td><td>greeter_build/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/greeter_build/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 56</td><td>vector_printer/vector_printer.c</td><td>funkce psaná v&nbsp;C, která akceptuje jako svůj parametr strukturu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/vector_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/vector_printer.c</a></td></tr>
<tr><td> 57</td><td>vector_printer/vector_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_vector</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/vector_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/vector_printer.h</a></td></tr>
<tr><td> 58</td><td>vector_printer/call_via_cffi.sh</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/call_via_cffi.sh</a></td></tr>
<tr><td> 59</td><td>vector_printer/call_via_cffi.py</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/call_via_cffi.py</a></td></tr>
<tr><td> 60</td><td>vector_printer/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/make_library.sh</a></td></tr>
<tr><td> 61</td><td>vector_printer/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 62</td><td>vector_printer_2/vector_printer.c</td><td>funkce psaná v&nbsp;C, která akceptuje jako svůj parametr ukazatel na strukturu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/vector_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/vector_printer.c</a></td></tr>
<tr><td> 63</td><td>vector_printer_2/vector_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_vector</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/vector_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/vector_printer.h</a></td></tr>
<tr><td> 64</td><td>vector_printer_2/call_via_cffi.sh</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/call_via_cffi.sh</a></td></tr>
<tr><td> 65</td><td>vector_printer_2/call_via_cffi.py</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/call_via_cffi.py</a></td></tr>
<tr><td> 66</td><td>vector_printer_2/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/make_library.sh</a></td></tr>
<tr><td> 67</td><td>vector_printer_2/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/vector_printer_2/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 68</td><td>array_printer_1/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/array_printer.c</a></td></tr>
<tr><td> 69</td><td>array_printer_1/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/array_printer.h</a></td></tr>
<tr><td> 70</td><td>array_printer_1/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/call_via_cffi.sh</a></td></tr>
<tr><td> 71</td><td>array_printer_1/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/call_via_cffi.py</a></td></tr>
<tr><td> 72</td><td>array_printer_1/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/make_library.sh</a></td></tr>
<tr><td> 73</td><td>array_printer_1/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_1/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 74</td><td>array_printer_2/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/array_printer.c</a></td></tr>
<tr><td> 75</td><td>array_printer_2/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/array_printer.h</a></td></tr>
<tr><td> 76</td><td>array_printer_2/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/call_via_cffi.sh</a></td></tr>
<tr><td> 77</td><td>array_printer_2/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/call_via_cffi.py</a></td></tr>
<tr><td> 78</td><td>array_printer_2/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/make_library.sh</a></td></tr>
<tr><td> 79</td><td>array_printer_2/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_2/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 80</td><td>array_printer_3/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/array_printer.c</a></td></tr>
<tr><td> 81</td><td>array_printer_3/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/array_printer.h</a></td></tr>
<tr><td> 82</td><td>array_printer_3/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/call_via_cffi.sh</a></td></tr>
<tr><td> 83</td><td>array_printer_3/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/call_via_cffi.py</a></td></tr>
<tr><td> 84</td><td>array_printer_3/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/make_library.sh</a></td></tr>
<tr><td> 85</td><td>array_printer_3/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_3/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 86</td><td>array_printer_4/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/array_printer.c</a></td></tr>
<tr><td> 87</td><td>array_printer_4/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/array_printer.h</a></td></tr>
<tr><td> 88</td><td>array_printer_4/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/call_via_cffi.sh</a></td></tr>
<tr><td> 89</td><td>array_printer_4/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/call_via_cffi.py</a></td></tr>
<tr><td> 90</td><td>array_printer_4/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/make_library.sh</a></td></tr>
<tr><td> 91</td><td>array_printer_4/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_4/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 92</td><td>array_printer_5/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje pole s&nbsp;prvky typu <strong>vector_t</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/array_printer.c</a></td></tr>
<tr><td> 93</td><td>array_printer_5/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/array_printer.h</a></td></tr>
<tr><td> 94</td><td>array_printer_5/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/call_via_cffi.sh</a></td></tr>
<tr><td> 95</td><td>array_printer_5/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/call_via_cffi.py</a></td></tr>
<tr><td> 96</td><td>array_printer_5/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/make_library.sh</a></td></tr>
<tr><td> 97</td><td>array_printer_5/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_5/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 92</td><td>array_printer_6/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje dvourozměrné pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/array_printer.c</a></td></tr>
<tr><td> 93</td><td>array_printer_6/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/array_printer.h</a></td></tr>
<tr><td> 94</td><td>array_printer_6/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/call_via_cffi.sh</a></td></tr>
<tr><td> 95</td><td>array_printer_6/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/call_via_cffi.py</a></td></tr>
<tr><td> 96</td><td>array_printer_6/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/make_library.sh</a></td></tr>
<tr><td> 97</td><td>array_printer_6/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_6/clean.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 98</td><td>array_printer_7/array_printer.c</td><td>funkce naprogramovaná v&nbsp;C, která akceptuje dvourozměrné pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/array_printer.c">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/array_printer.c</a></td></tr>
<tr><td> 99</td><td>array_printer_7/array_printer.h</td><td>prototyp (předběžná deklarace) funkce <i>print_array</i> bez dalších informací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/array_printer.h">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/array_printer.h</a></td></tr>
<tr><td>100</td><td>array_printer_7/call_via_cffi.py</td><td>zavolání céčkovské funkce z&nbsp;knihovny z&nbsp;jazyka Python</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/call_via_cffi.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/call_via_cffi.sh</a></td></tr>
<tr><td>101</td><td>array_printer_7/call_via_cffi.sh</td><td>nastavení cest a spuštění Pythonovského skriptu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/call_via_cffi.py">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/call_via_cffi.py</a></td></tr>
<tr><td>102</td><td>array_printer_7/make_library.sh</td><td>skript pro překlad céčkovské funkce a vytvoření dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/make_library.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/make_library.sh</a></td></tr>
<tr><td>103</td><td>array_printer_7/clean.sh</td><td>skript pro smazání objektového souboru i dynamicky linkované knihovny</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/clean.sh">https://github.com/tisnik/most-popular-python-libs/blob/master/cffi/array_printer_7/clean.sh</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>ctypes &ndash; A foreign function library for Python<br />
<a href="https://docs.python.org/3/library/ctypes.html">https://docs.python.org/3/library/ctypes.html</a>
</li>

<li>Pygame: display<br />
<a href="https://www.pygame.org/docs/ref/display.html">https://www.pygame.org/docs/ref/display.html</a>
</li>

<li>Pygame: event<br />
<a href="https://www.pygame.org/docs/ref/event.html">https://www.pygame.org/docs/ref/event.html</a>
</li>

<li>Pygame: image<br />
<a href="https://www.pygame.org/docs/ref/image.html">https://www.pygame.org/docs/ref/image.html</a>
</li>

<li>Pygame: clock<br />
<a href="https://www.pygame.org/docs/ref/time.html#pygame.time.Clock">https://www.pygame.org/docs/ref/time.html#pygame.time.Clock</a>
</li>

<li>Fraktály v&nbsp;počítačové grafice XII<br />
<a href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xii/">https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xii/</a>
</li>

<li>Fraktály v&nbsp;počítačové grafice XIII<br />
<a href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xiii/">https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xiii/</a>
</li>

<li>Fraktály v&nbsp;počítačové grafice XIV<br />
<a href="https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xiv/">https://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xiv/</a>
</li>

<li>CFFI documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>cffi 1.15.1 na PyPi<br />
<a href="https://pypi.org/project/cffi/">https://pypi.org/project/cffi/</a>
</li>

<li>Python Bindings: Calling C or C++ From Python<br />
<a href="https://realpython.com/python-bindings-overview/">https://realpython.com/python-bindings-overview/</a>
</li>

<li>Interfacing with C/C++ Libraries<br />
<a href="https://docs.python-guide.org/scenarios/clibs/">https://docs.python-guide.org/scenarios/clibs/</a>
</li>

<li>Cython, pybind11, cffi – which tool should you choose?<br />
<a href="http://blog.behnel.de/posts/cython-pybind11-cffi-which-tool-to-choose.html">http://blog.behnel.de/posts/cython-pybind11-cffi-which-tool-to-choose.html</a>
</li>

<li>Python FFI with ctypes and cffi<br />
<a href="https://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi">https://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi</a>
</li>

<li>Propojení Go s&nbsp;Pythonem s&nbsp;využitím cgo a ctypes<br />
<a href="https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes/">https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes/</a>
</li>

<li>Propojení Go s&nbsp;Pythonem s&nbsp;využitím cgo a ctypes (2. část)<br />
<a href="https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes-2-cast/">https://www.root.cz/clanky/propojeni-go-s-pythonem-s-vyuzitim-cgo-a-ctypes-2-cast/</a>
</li>

<li>Programovací jazyk Rust: použití FFI pro volání funkcí z&nbsp;nativních knihoven<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven/">https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven/</a>
</li>

<li>Programovací jazyk Rust: použití FFI při předávání struktur<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pri-predavani-struktur/">https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pri-predavani-struktur/</a>
</li>

<li>Programovací jazyk Rust: použití FFI pro volání funkcí z&nbsp;nativních knihoven (2. část)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven-2-cast/">https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven-2-cast/</a>
</li>

<li>Dynamic-link library<br />
<a href="https://en.wikipedia.org/wiki/Dynamic-link_library">https://en.wikipedia.org/wiki/Dynamic-link_library</a>
</li>

<li>Úvod do jazyka C: Deklarace funkcí<br />
<a href="https://www.fi.muni.cz/usr/jkucera/pb071/sl5.htm">https://www.fi.muni.cz/usr/jkucera/pb071/sl5.htm</a>
</li>

<li>Using standard library headers with CFFI<br />
<a href="https://stackoverflow.com/questions/57481873/using-standard-library-headers-with-cffi">https://stackoverflow.com/questions/57481873/using-standard-library-headers-with-cffi</a>
</li>

<li>Preparing and Distributing modules<br />
<a href="https://cffi.readthedocs.io/en/latest/cdef.html">https://cffi.readthedocs.io/en/latest/cdef.html</a>
</li>

<li>C Arrays<br />
<a href="https://www.programiz.com/c-programming/c-arrays">https://www.programiz.com/c-programming/c-arrays</a>
</li>

<li>C Arrays<br />
<a href="https://www.w3schools.com/c/c_arrays.php">https://www.w3schools.com/c/c_arrays.php</a>
</li>

<li>Array of Structures in C<br />
<a href="https://overiq.com/c-programming-101/array-of-structures-in-c/#google_vignette">https://overiq.com/c-programming-101/array-of-structures-in-c/#google_vignette</a>
</li>

<li>C Structures (structs)<br />
<a href="https://www.w3schools.com/c/c_structs.php">https://www.w3schools.com/c/c_structs.php</a>
</li>

<li>C Structs and pointers<br />
<a href="https://www.programiz.com/c-programming/c-structures-pointers">https://www.programiz.com/c-programming/c-structures-pointers</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

