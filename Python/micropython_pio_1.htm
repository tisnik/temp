<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovatelné IO na mikrořadičích RP2040</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovatelné IO na mikrořadičích RP2040</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovatelné IO na mikrořadičích RP2040</a></p>
<p><a href="#k02">2. Jednodeskové mikropočítače Raspberry Pi Pico</a></p>
<p><a href="#k03">3. Mikrořadiče RP2040 a RP2350</a></p>
<p><a href="#k04">4. Důvody pro existenci PIO na Raspberry Pi Pico</a></p>
<p><a href="#k05">5. Realizace PIO na čipu RP2040</a></p>
<p><a href="#k06">6. Interní struktura stavových strojů tvořících PIO</a></p>
<p><a href="#k07">7. Výstupní FIFO (fronta) a posuvný registr <strong>OSR</strong></a></p>
<p><a href="#k08">8. Vstupní FIFO (fronta) a posuvný registr <strong>ISR</strong></a></p>
<p><a href="#k09">*** 9. Čítače počtu posunů registrů ISR a OSR</a></p>
<p><a href="#k10">10. Pracovní registry <strong>X</strong> a <strong>Y</strong></a></p>
<p><a href="#k11">11. Dvojice front (FIFO)</a></p>
<p><a href="#k12">12. Instrukční sada PIO</a></p>
<p><a href="#k13">13. Instrukce skoku (<strong>JMP</strong>)</a></p>
<p><a href="#k14">*** 14. Instrukce čekání na událost (<strong>WAIT</strong>)</a></p>
<p><a href="#k15">*** 15. Instrukce <strong>IN</strong></a></p>
<p><a href="#k16">*** 16. Instrukce <strong>OUT</strong></a></p>
<p><a href="#k17">*** 17. Instrukce <strong>PUSH</strong> a <strong>PULL</strong></a></p>
<p><a href="#k18">*** 18. Instrukce <strong>MOV</strong></a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovatelné IO na mikrořadičích RP2040</h2>

<p>Společnost <a href="https://www.raspberrypi.com/">Raspberry Pi Ltd.</a>
pravděpodobně není nutné čtenářům Roota podrobně představovat, protože se
s&nbsp;jejími jednodeskovými mikropočítači setkal prakticky každý. Po hlavičkou
této společnosti vzniklo poměrně velké množství různých desek
s&nbsp;mikrořadiči nebo mikroprocesory, z&nbsp;nichž nejznámější je řada
<i>Raspberry Pi</i> (od Modelu-A z&nbsp;roku 2012 až k&nbsp;Raspberry Pi 5
vydané předloni). Neméně zajímavá je i řada <i>Raspberry Pi Zero</i> a taktéž
<i>Raspberry Pi Pico</i>.</p>

<p>V&nbsp;dnešním článku nás bude zajímat především poslední zmíněná řada, tedy
Raspberry Pi Pico, která je založená na mikrořadičích <i>RP2040</i>
resp.&nbsp;<i>RP2350</i>. Interně se sice tyto mikrořadiče od sebe odlišují
(mají například odlišná procesorová jádra), ovšem jednu vlastnost mají
společnou &ndash; obsahují totiž takzvané <i>PIO (Programmable IO)</i>, což je
označení popisující vstupně-výstupní piny, na které se můžeme dívat jako na
samostatně programovatelné (i když velmi jednoduché) procesory s&nbsp;vlastní
instrukční sadou a během nezávislým na hlavním jádru.</p>

<p>V&nbsp;dnešním článku se nejdříve ve stručnosti seznámíme s&nbsp;celou řadou
Pi Pico a následně si popíšeme jak funkcionalitu PIO, tak i způsob jejich
programování. Přitom použijeme programovací jazyk Python resp.&nbsp;přesněji
řečeno jeho variantu nazvanou <i>MicroPython</i>, kterou lze na Pi Zero bez
problémů provozovat. I s&nbsp;MicroPythonem jsme se na stránkách Roota již
ve stručnosti seznámili a to konkrétně v&nbsp;článcích [<a
href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu/">1</a>]
[<a
href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-2/">2</a>]
[<a
href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-dokonceni/">3</a>]
[<a
href="https://www.root.cz/clanky/preklad-funkci-primo-do-nativniho-kodu-micropythonem/">4</a>]
a (i když nutno připomenout, že ve zcela odlišném kontextu) i v&nbsp;[<a
href="https://www.root.cz/clanky/micropython-ve-webovem-prohlizeci-lehkotonazni-varianta-k-pyodide/">5</a>].</p>

<p><div class="rs-tip-major">Poznámka: může se to sice zdát divné, ale právě
spojení MicroPythonu s&nbsp;PIO je poměrně dobrá kombinace. Umožňuje nám využít
vysokoúrovňový jazyk a současně programovat i časově kritické operace, a to bez
nutnosti použití nativního assembleru (ale i to MicroPython dokáže).</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Jednodeskové mikropočítače Raspberry Pi Pico</h2>

<p>Původní jednodeskový mikropočítač řady Pico se jmenoval jednoduše Raspberry
Pi Pico. Jeho oficiální cena byla čtyři dolary a založen byl na mikrořadiči
RP2040 s&nbsp;264kB RAM (SRAM) a 2MB paměti Flash. Mikrořadič RP2040 má jádro
ARM Cortex-M0+ s&nbsp;taktovací frekvencí 133MHz, ovšem na Pico je frekvence
snížena na 125MHz. Jak kapacita RAM, tak i Flash paměti společně s&nbsp;poměrně
vysokým výpočetním výkonem umožňují běh MicroPythonu, i když mnoho projektů se
píše v&nbsp;céčku, Rustu nebo dokonce i ve FreePascalu. Dnes nás bude zajímat i
to, že původní Pi Pico má 26 GPIO pinů (varianta Pico H je prakticky totožná,
až na odlišné piny pro debugging).</p>

<p>O rok později vznikla varianta &bdquo;W&ldquo;, přičemž toto písmeno
naznačuje, že byl přidán modul pro Wifi. Konkrétně se jedná o čip Infineon
CYW43439, díky němuž bylo možné Pico W použít v&nbsp;těch aplikacích,
v&nbsp;nichž se nasazovaly konkurenční produkty ESP8266 a ESP32 (ale i mnoho
dalších).</p>

<p>Naproti tomu modely Pico 2 a Pico 2 W jsou poněkud odlišné. Především jsou
založeny na odlišném čipu, protože RP2040 nahradil výkonnější čip RP2350 a
dostupná je i větší kapacita RAM i Flash (u obou se dosahují prakticky
dvojnásobné hodnoty kapacity). Ovšem po SW stránce zůstala zachována
kompatibilita na úrovni zdrojových kódů s&nbsp;původní řadou Pico, která se
navíc stále používá (Pico 2 je dražší a výkon původního Pico pro mnoho aplikací
více než dostačuje).</p>

<p>V&nbsp;následující tabulce jsou jednotlivé jednodeskové mikropočítače
(mikrořadiče) Pico porovnány:</p>

<table>
<tr><th>Označení</th><th>Vydáno</th><th></th><th>Mikrořadič</th><th>Wifi</th><th>RAM</th><th>Flash</th></tr>
<tr><td>Raspberry Pi Pico    </td><td>2021</td><td>RP2040</td><td>ne </td><td>264kB</td><td>2MB</td></tr>
<tr><td>Raspberry Pi Pico W  </td><td>2022</td><td>RP2040</td><td>ano</td><td>264kB</td><td>2MB</td></tr>
<tr><td>Raspberry Pi Pico 2  </td><td>2024</td><td>RP2350</td><td>ne </td><td>520kB</td><td>4MB</td></tr>
<tr><td>Raspberry Pi Pico 2 W</td><td>2024</td><td>RP2350</td><td>ano</td><td>520kB</td><td>4MB</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: původní Pico není s&nbsp;Pico 2 binárně
kompatibilní, takže není možné přenášet přeložené binární bloky mezi těmito
dvěma sice podobnými, ale nikoli totožnými systémy.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Mikrořadiče RP2040 a RP2350</h2>

<p>Již z&nbsp;tabulky uvedené <a href="#k02">ve druhé kapitole</a> je zřejmé,
že modely Pi Pico (bez číslovky) a Pi Pico 2 se od sebe v&nbsp;několika
ohledech odlišují, což je do značné míry způsobeno použitím odlišných
mikrořadičů. Rozdílů je však ještě větší množství a vzhledem k&nbsp;tomu, že se
dotýkají i problematiky probírané v&nbsp;dnešním článku (PIO), si tyto rozdíly
taktéž vypíšeme. Zajímat nás budou především údaje o PIO:</p>

<table>
<tr><th>Čip</th><th>RP2040</th><th>RP2350</th><th>Poznámka</th></tr>
<tr><td>Jádra</td><td>2&times;ARM Cortex-M0+</td><td>2&times;ARM Cortex-M33 + 2&times;Hazard3 RISC-V</td><td>volba jader při bootu</td></tr>
<tr><td>FPU</td><td>ne</td><td>ano (ARM)</td><td>pouze jednoduchá přesnost</td></tr>
<tr><td>Frekvence</td><td>133 MHz</td><td>150 MHz</td><td>&nbsp;</td></tr>
<tr><td>(S)RAM</td><td>264 kB</td><td>510 kB</td><td>&nbsp;</td></tr>
<tr><td>OTP paměť</td><td>&times;</td><td>8 kB</td><td>používáno například pro klíče při bootu atd.</td></tr>
<tr><td>DMA</td><td>12 kanálů</td><td>16 kanálů</td><td>přímý přístup do paměti</td></tr>
<tr><td>IRQ pro DMA</td><td>2</td><td>4</td><td>HW přerušení používaná při DMA</td></tr>
<tr><td>PIO</td><td>2 (8 stavových strojů)</td><td>3 (12 stavových strojů)</td><td>bude popsáno dále</td></tr>
<tr><td>PWM</td><td>16</td><td>24</td><td>pulsní šířková modulace</td></tr>
<tr><td>ADC</td><td>4 kanály, 12bitů</td><td>4 kanály, 12 bitů (popř.&nbsp;8 kanálů)</td><td>analogově-digiální převodník</td></tr>
<tr><td>DAC</td><td>&times;</td><td>&times;</td><td>digitálně-analogový převodník</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Důvody pro existenci PIO na Raspberry Pi Pico</h2>

<p>Samotné mikrořadiče RP2040 a RP2350 jsou poměrně rychlé, takže
mj.&nbsp;umožňují provozovat i interpretované programovací jazyky typu
MicroPython (i když i zde lze zařídit překlad vybraných funkcí). Ovšem i přes
samotnou rychlost mikrořadičových jader je mnohdy nutné v&nbsp;reálném čase
pracovat se vstupně-výstupními piny. Příkladem může být například implementace
vlastního sériového přenosu dat bez použití k&nbsp;tomu dedikovaných bloků
mikrořadiče.</p>

<p>Samozřejmě je možné napsat subrutiny s&nbsp;realizací tohoto sériového
přenosu. Používá se k&nbsp;tomu technika zvaná <i>bit banging</i>, tedy
programové ovládání obecných vstupně-výstupních pinů (<i>GPIO</i>).  Nicméně se
mnohdy jedná o operace, které musí být přesně načasovány a v&nbsp;takových
případech nám nemusí hrubá rychlost jader postačovat &ndash; záviset budeme
(možná) na systému přerušení, na tom, jaké další činnosti jádra provádí, zda se
činnost jader nepřerušuje kvůli DMA atd. A už vůbec není možné v&nbsp;těchto
případech použít zmíněný MicroPython; vše by muselo být naprogramováno
v&nbsp;jazyce C nebo přímo v&nbsp;assembleru.</p>

<p>Řešení spočívá právě ve využití programovatelných IO, kdy se samotná logika
ovládání pinů (tj.&nbsp;v&nbsp;tom nejjednodušším případě jejich čtení či
zápis) buď kompletně nebo alespoň částečně naprogramuje v&nbsp;PIO tak, že
poběží nezávisle na jádrech mikrořadiče. Díky tomu, že v&nbsp;tomto případě
přesně známe délku trvání hodinových cyklů, může být časování provedeno tím
nejtriviálnějším způsobem &ndash; použitím instrukcí <strong>nop</strong>.
V&nbsp;extrémním případě tak jádra nebudou moci vykonávat prakticky žádnou
činnost, protože vstupně-výstupní operace poběží přes PIO.</p>

<p><div class="rs-tip-major">Poznámka: jeden z&nbsp;příkladů sériového přenosu
realizovaného přes PIP je dostupný <a
href="https://github.com/Sympatron/pio-uart/tree/master">zde</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Realizace PIO na čipu RP2040</h2>

<p>Podívejme se nyní, jakým způsobem jsou PIO realizovány na čipu RP2040. Tento
mikrořadič obsahuje dvojici bloků PIO (RP2350 má tyto bloky tři). Každý blok je
tvořen čtveřicí stavových strojů (<i>state machine</i>), které dokážou,
nezávisle na ostatních subsystémech, vykonávat krátké specializované programy.
Ty jsou uloženy v&nbsp;samostatné paměti (<i>Instruction Memory</i>), která má
kapacitu pro až 32 instrukcí. Do stavových strojů se přivádí hodinový signál,
který synchronizuje prováděné operace: přečtení, dekódování a vykonání
instrukcí. Samotný repertoár dostupných instrukcí je ve skutečnosti velmi
krátký, protože obsahuje jen devět instrukcí. Konkrétně se jedná o instrukce
<strong>IN</strong>, <strong>OUT</strong>, <strong>PUSH</strong>,
<strong>PULL</strong>, <strong>MOV</strong>, <strong>JMP</strong>,
<strong>WAIT</strong>, <strong>SET</strong> a <strong>IRQ</strong>.
Vstupně-výstupní instrukce mohou pracovat s&nbsp;jakýmkoli GPIO pinem, kterých
je na RP2040 celkem 30 (jsou označeny symboly <strong>GP0</strong> až
<strong>GP29</strong>, teoreticky je ovšem k&nbsp;dispozici celkem 32 GPIO).
Stavové stroje musí komunikovat i se zbytkem mikrořadiče, což je realizováno
přes FIFO (fronty) a systém přerušení.</p>

<p>Interně vypadá propojení stavových strojů s&nbsp;GPIO na straně jedné a
s&nbsp;jádry mikrořadiče na straně druhé následovně:</p>

*** image ***
<p><i>Obrázek 1: Jeden z&nbsp;bloků PIO (druhý má totožnou architekturu)<br />
Zdroj: datasheet k&nbsp;čipu RP2040, dostupné na <a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf</a>.</i></p>

<p><div class="rs-tip-major">Poznámka: fronty jsou konfigurovatelné, takže je
možné například zajistit, aby byly obě použity pro vstup nebo naopak pro výstup
(s&nbsp;dvojnásobnou délkou).</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Interní struktura stavových strojů tvořících PIO</h2>

<p>Z&nbsp;prvního obrázku je patrné, že každý blok PIO interně obsahuje
čtveřici stavových strojů, které jsou přes celkem osm FIFO připojeny
k&nbsp;mikrořadiči a přes mapovací obvod k&nbsp;vybraným GPIO (tedy obecným
vstupně-výstupním pinům). Na PIO se můžeme dívat jako na samostatnou výpočetní
jednotku (CPU), která je zvláštní tím, že neobsahuje plnohodnotnou
aritmeticko-logickou jednotku (a nelze tedy jednoduše realizovat například
součet atd.). Interně stavový stroj obsahuje následující bloky:</p>

<ol>
<li>dva 32bitové posuvné registry <strong>ISR</strong> a <strong>OSR</strong> (<i>shift registers</i>) s&nbsp;volitelným směrem posunu</li>
<li>dva 32bitové registry <strong>X</strong> a <strong>Y</strong> nazývané <i>scratch registers</i>, ovšem ve skutečnosti mají význam univerzálních registrů</li>
<li>registr PC obsahující index instrukce uložené v&nbsp;paměti nazývané <i>instruction memory</i></li>
<li>32bitové fronty (FIFO) pro čtení i zápis dat</li>
<li>dělič hodinového signálu (16+8 bitů)</li>
<li>mapování na GPIO</li>
<li>rozhraní pro DMA</li>
<li>rozhraní pro IRQ (přerušení)</li>
</ol>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že celý blok PIO obsazuje
plochu čipu, která zhruba odpovídá ploše zabrané řadičem SPI nebo
I<sup>2</sup>C. Ovšem PIO je mnohem flexibilnější než tyto řadiče, navíc může
být kdykoli snadno přeprogramován a v&nbsp;určité okamžiky může vykonávat
odlišnou činnost.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výstupní FIFO (fronta) a posuvný registr <strong>OSR</strong><strong>OSR</strong> a <strong>ISR</strong></h2>

<p>Pro komunikaci mezi mikrořadičem a stavovými stroji se používá dvojice
posuvných registrů označovaná zkratkami <strong>OSR</strong> a
<strong>ISR</strong>, jejichž způsob zapojení i ovládání přes instrukce PIO je
nutné znát.</p>

<p><strong>OSR</strong> neboli <i>Output Shift Register</i> slouží pro čtení
dat posílaných z&nbsp;mikrořadiče do stavového stroje. Pro manipulaci
s&nbsp;<strong>OSR</strong> slouží dvojice PIO instrukcí
s&nbsp;mnemotechnickými zkratkami <strong>PULL</strong> a <strong>OUT</strong>.
Instrukce <strong>PULL</strong> přečte 32bitové slovo z&nbsp;výstupní FIFO
(fronty) a zapíše je do <strong>OSR</strong>. A instrukce <strong>OUT</strong>
dokáže provést posun bitů v&nbsp;posuvném registru s&nbsp;jejich vysunutím
(zápisem) na GPIO, do scratch registrů atd. Funkci si tedy můžeme graficky
znázornit následovně:</p>

*** image ***
<p><i>Obrázek 2: Výstupní FIFO a registr <strong>OSR</strong><br />
Zdroj: datasheet k&nbsp;čipu RP2040, dostupné na <a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf</a>.</i></p>

<p><div class="rs-tip-major">Poznámka: název tohoto registr tedy vznikl na
základě toho, jak se chová z&nbsp;pohledu mikrořadiče (jde o výstup).
Z&nbsp;hlediska stavového stroje je to naopak vstupní registr.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vstupní FIFO (fronta) a posuvný registr <strong>ISR</strong></h2>

<p>Posuvný registr <strong>ISR</strong> neboli <i>Input Shift Register</i>
naopak slouží pro (postupné) čtení dat dostupných ve stavovém stroji (GPIO
atd.) s&nbsp;jejich posíláním do vstupní FIFO (fronty). Pro ovládání této části
se používají PIO instrukce s&nbsp;mnemotechnickými zkratkami
<strong>IN</strong> a <strong>PUSH</strong>. Instrukce <strong>IN</strong> do
posuvného registru zapíše 1 až 32 bitů (s&nbsp;posunem zbytku) a instrukce
<strong>PUSH</strong> pošle celý obsah <strong>ISR</strong> do FIFO. Opět
platí, že pojmenování jak registru, tak i fronty je provedeno na základě toho,
jak se jejich činnost jeví z&nbsp;pohledu mikrořadiče (a nikoli stavového
stroje):</p>

*** image ***
<p><i>Obrázek 3: Vstupní FIFO a registr <strong>ISR</strong><br />
Zdroj: datasheet k&nbsp;čipu RP2040, dostupné na <a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf</a>.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Čítače počtu posunů registrů <strong>ISR</strong> a <strong>OSR</strong></h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pracovní registry <strong>X</strong> a <strong>Y</strong></h2>

<p>V&nbsp;každém stavovém stroji (což je, jak již víme, vlastně malý
specializovaný CPU), lze manipulovat s&nbsp;dvojicí 32bitových registrů
pojmenovaných <strong>X</strong> a <strong>Y</strong>. V&nbsp;dokumentaci se
tyto registry označují termínem <i>scratch register</i>, což by mohlo
naznačovat, že je jejich obsah jen dočasný. Ovšem tyto registry jsou
z&nbsp;pohledu stavového stroje plnohodnotnými registry, i když repertoár
operací, které s&nbsp;nimi lze provádět, je omezený. Je tomu tak mj.&nbsp;i
z&nbsp;toho důvodu, že stavové stroje neobsahují plnohodnotnou ALU, takže
například není možné registry <strong>X</strong> a <strong>Y</strong> sečíst
atd. (na druhou stranu je možné například snížit obsah registru o jedničku,
takže lze realizovat počítané programové smyčky).</p>

<p>Tyto registry mohou sloužit jako zdroj nebo naopak cíl dat pro instrukce
<strong>IN</strong>, <strong>OUT</strong>, <strong>SET</strong> a
<strong>MOV</strong>. Taktéž mohou sloužit pro vyhodnocení podmínky u skoků,
tedy u instrukce <strong>JMP</strong>.</p>

<p><div class="rs-tip-major">Poznámka: registr <strong>Y</strong> je použit i u
pseudoinstrukce <strong>NOP</strong>. Tato instrukce sice v&nbsp;instrukčním
souboru PIO neexistuje, ovšem assemblery namísto ní použijí instrukci
<strong>MOV Y, Y</strong>. S&nbsp;touto pseudoinstrukcí se poměrně často
setkáme, protože slouží pro časování operací resp.&nbsp;přesněji řečeno pro
vkládání čekacích cyklů mezi jednotlivé operace.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Dvojice front (FIFO)</h2>

<p>S&nbsp;frontami (FIFO) jsme se již ve stručnosti setkali v&nbsp;předchozím
textu. Připomeňme si tedy, že každý stavový stroj obsahuje dvojici front,
přičemž jedna fronta je typicky určena pro posílání dat z&nbsp;mikrořadiče do
stavového stroje (TX fronta &ndash; transmit) a druhá fronta naopak slouží pro
posílání dat ze stavového stroje do mikrořadiče (RX fronta &ndash; receive). Na
straně mikrořadiče je zápis do fronty prováděn například přes DMA. Díky použití
front bylo možné činnost mikrořadiče prakticky zcela oddělit od činnosti
jednotlivých stavových strojů a do značné míry zajistit jejich nezávislou
činnost (souběh či v&nbsp;tomto případě prakticky plný paralelismus). FIFO
navíc dokážou generovat signál DREQ, který společně s&nbsp;DMA může zajistit
přenosy dat bez toho, aby se musela na straně mikrořadiče spouštět přerušovací
subrutina.</p>

<p>Každá z&nbsp;front má kapacitu na čtyři 32bitová slova, což umožňuje
nezávislou a nepřerušovanou činnost I/O subsystému i v&nbsp;případě, že
mikrořadič provádí jiné činnosti. Ovšem může se stát, že je zapotřebí přes PIO
implementovat rychlé přenosy (displej atd.). V&nbsp;takovém případě lze obě
fronty spojit a vytvořit jedinou FIFO s&nbsp;kapacitou osmi slov. Taková FIFO
ovšem bude jednosměrná &ndash; tedy výstupní pro ovládání displeje a naopak
vstupní, pokud se například bude přijímat video signál.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Instrukční sada PIO</h2>

<p>Instrukční sada PIO obsahuje pouze devět instrukcí, ovšem již nyní je nutné
upřesnit, že některé z&nbsp;těchto instrukcí jsou poměrně univerzální.
Například instrukce <strong>JMP</strong> díky možnosti zakódování podmínky
vlastně odpovídá hned několika instrukcím z&nbsp;jiných instrukčních sad.
Totéž platí například i o instrukci <strong>MOV</strong>, která taktéž dokáže
během přenosu dat provádět jednoduché operace. Všechny instrukce mají
jednotnou šířku šestnácti bitů, přičemž první tři bity obsahují operační kód
instrukce a dalších pět bitů pak počet zpožďovacích cyklů. Do zbylých osmi bitů
jsou zakódovány operandy instrukcí, řídicí bity atd.:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Parametry</th><th>Stručný popis</th></tr>
<tr><td>1</td><td><a href="#k13">JMP</a></td><td>podmínka, adresa</td><td>skok, skok s&nbsp;podmínkou</td></tr>
<tr><td>2</td><td><a href="#k14">WAIT</a></td><td>polarita, zdroj</td><td>čekání na splnění podmínky (stav pinu, IRQ)</td></tr>
<tr><td>3</td><td><a href="#k15">IN</a></td><td>zdroj, počet bitů</td><td>zápis bitů ze zdroje do posuvného registru ISR</td></tr>
<tr><td>4</td><td><a href="#k16">OUT</a></td><td>cíl, počet bitů</td><td>vysunutí bitů z&nbsp;posuvného registru ISR do cíle</td></tr>
<tr><td>5</td><td><a href="#k17">PUSH</a></td><td>blokující zápis</td><td>uložení hodnoty z&nbsp;posuvného registru ISR do RX fronty (FIFO)</td></tr>
<tr><td>6</td><td><a href="#k17">PULL</a></td><td>blokující zápis</td><td>přečtení hodnoty z&nbsp;TX fronty (FIFO) se zápisem do posuvného registru OSR</td></tr>
<tr><td>7</td><td><a href="#k18">MOV</a></td><td>cíl, operace, zdroj</td><td>přenos dat s&nbsp;provedením zvolené operace (negace či otočení bitů)</td></tr>
<tr><td>8</td><td>IRQ </td><td>nastavit/smazat, čekání</td><td>nastavení nebo vymazání příznaku přerušení</td></tr>
<tr><td>9</td><td>SET </td><td>cíl, data (pět bitů)</td><td>zápis dat do zvoleného cíle</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;operačním kódu každé instrukce je
pět bitů rezervováno pro specifikaci počtu cyklů, které budou vloženy mezi tuto
instrukci a instrukci následující. Toho se velmi často využívá a ostatně i
v&nbsp;našich demonstračních příkladech se s&nbsp;tímto konceptem
setkáme.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce skoku (<strong>JMP</strong>)</h2>

<p>Podrobnější popis instrukčního souboru začneme instrukcí nazvanou
<strong>JMP</strong>, kterou je možné realizovat nepodmíněný nebo i podmíněný
skok. Instrukční slovo této instrukce má délku dva bajty (16 bitů) a je
rozděleno do čtyř bitových polí:</p>

<pre>
+-15-14-13-12-11-10--9--8--7--6--5--4--3--2--1--0--+
| 0  0  0 |     delay    |condition|    address    |
+---------+--------------+---------+---------------+
</pre>

<p>O bitovém poli <strong>delay</strong> si řekneme podrobnosti příště, takže
nás nyní budou zajímat pole nazvaná <strong>address</strong> a
<strong>condition</strong>. Bitové pole <strong>address</strong> obsahuje
adresu cíle skoku. Vzhledem k&nbsp;omezené velikosti paměti pro PIO instrukce
je pět bitů dostačujících. Mnohem zajímavější je bitové pole
<strong>condition</strong>, ve kterém je zakódována podmínka, která se
vyhodnocuje. Toto pole má šířku tří bitů, což znamená, že lze rozlišit osm
podmínek:</p>

<table>
<tr><th>#</th><th>Condition bity</th><th>Podmínka, která se testuje</th></tr>
<tr><td>1</td><td>000</td><td>bez podmínky (skok se vždy provede)</td></tr>
<tr><td>2</td><td>001</td><td>X==0</td></tr>
<tr><td>3</td><td>010</td><td>X!=0 před snížením X o jedničku</td></tr>
<tr><td>4</td><td>011</td><td>Y==0</td></tr>
<tr><td>5</td><td>100</td><td>Y!=0 před snížením Y o jedničku</td></tr>
<tr><td>6</td><td>101</td><td>X!=Y</td></tr>
<tr><td>7</td><td>110</td><td>PIN==1 (libovolný dopředu zvolený GPIO)</td></tr>
<tr><td>8</td><td>111</td><td>registr OSR je posunut o nastavený počet bitů</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se v&nbsp;rámci
podmínky (po jejím vyhodnocení) může snížit obsah pracovního registru
<strong>X</strong> nebo <strong>Y</strong>. Jedná se o jednu z&nbsp;mála
aritmetických operací, kterou lze s&nbsp;těmito registry provádět. Ovšem
snížení hodnoty vybraného registru znamená možnost implementace počítaných
programových smyček, což je v&nbsp;praxi poměrně často používáno.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce čekání na událost (<strong>WAIT</strong>)</h2>

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Instrukce <strong>IN</strong></h2>

<p></p>

<pre>
+-15-14-13-12-11-10--9--8--7--6--5--4--3--2--1--0--+
| 0  0  0 |     delay    | source  |   bit count   |
+---------+--------------+---------+---------------+
</pre>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Instrukce <strong>OUT</strong></h2>

<p></p>

<pre>
+-15-14-13-12-11-10--9--8--7--6--5--4--3--2--1--0--+
| 0  0  0 |     delay    |   dest  |   bit count   |
+---------+--------------+---------+---------------+
</pre>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Instrukce <strong>PUSH</strong> a <strong>PULL</strong></h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Instrukce <strong>MOV</strong></h2>

<p>Poslední PIO instrukcí, se kterou se dnes setkáme, je instrukce pro přenos dat. Tato instrukce se jmenuje, jak je ve světě assemblerů zvykem, <strong>MOV</strong>.</p>

<pre>
+-15-14-13-12-11-10--9--8--7--6--5--4--3--2--1--0--+
| 0  0  0 |     delay    |   dest  | op |  source  |
+---------+--------------+---------+----+----------+
</pre>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
MicroPython běžící na čipech RP2040 s&nbsp;architekturou Cortex-M0 byly uloženy
do repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/</a></td></tr>
<tr><td> 2</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/</a></td></tr>
<tr><td> 3</td><td></td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/pio/">https://github.com/tisnik/most-popular-python-libs/blob/master/pio/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu<br />
<a href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu/">https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu/</a>
</li>

<li>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu (2)<br />
<a href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-2/">https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-2/</a>
</li>

<li>Zápis funkcí obsahujících instrukce Thumb a Thumb-2 v MicroPythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-dokonceni/">https://www.root.cz/clanky/zapis-funkci-obsahujicich-instrukce-thumb-a-thumb-2-v-micropythonu-dokonceni/</a>
</li>

<li>Překlad funkcí přímo do nativního kódu MicroPythonem<br />
<a href="https://www.root.cz/clanky/preklad-funkci-primo-do-nativniho-kodu-micropythonem/">https://www.root.cz/clanky/preklad-funkci-primo-do-nativniho-kodu-micropythonem/</a>
</li>

<li>MicroPython ve webovém prohlížeči: lehkotonážní varianta k Pyodide<br />
<a href="https://www.root.cz/clanky/micropython-ve-webovem-prohlizeci-lehkotonazni-varianta-k-pyodide/">https://www.root.cz/clanky/micropython-ve-webovem-prohlizeci-lehkotonazni-varianta-k-pyodide/</a>
</li>

<li>Programmable IO<br />
<a href="https://docs.micropython.org/en/latest/rp2/tutorial/pio.html">https://docs.micropython.org/en/latest/rp2/tutorial/pio.html</a>
</li>

<li>Introduction to the PIO (Programmable Input Output) of the RP2040<br />
<a href="https://tutoduino.fr/en/pio-rp2040-en/">https://tutoduino.fr/en/pio-rp2040-en/</a>
</li>

<li>MicroPython examples: PIO<br />
<a href="https://github.com/raspberrypi/pico-micropython-examples/tree/master/pio">https://github.com/raspberrypi/pico-micropython-examples/tree/master/pio</a>
</li>

<li>PIO: Wikipedia CZ (pozor: jedná se o něco jiného!)<br />
<a href="https://cs.wikipedia.org/wiki/PIO">https://cs.wikipedia.org/wiki/PIO</a>
</li>

<li>RP2040 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RP2040">https://en.wikipedia.org/wiki/RP2040</a>
</li>

<li>Maximising MicroPython speed<br />
<a href="https://docs.micropython.org/en/latest/reference/speed_python.html">https://docs.micropython.org/en/latest/reference/speed_python.html</a>
</li>

<li>Online ARM converter<br />
<a href="https://armconverter.com/?disasm">https://armconverter.com/?disasm</a>
</li>

<li>The 3 different code emitters<br />
<a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832">https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832</a>
</li>

<li>The 3 different code emitters, part 2<br />
<a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145">https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145</a>
</li>

<li>Fast Filters for the Pyboard<br />
<a href="https://github.com/peterhinch/micropython-filters">https://github.com/peterhinch/micropython-filters</a>
</li>

<li>How to load 32 bit constant from assembler with @micropython.asm_thumb<br />
<a href="https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a">https://forum.micropython.org/viewtopic.php?f=21&t=12931&sid=25de8871fa9cfcf8cafb6318f9d8ba3a</a>
</li>

<li>Pi pico, micropython.asm_thumb: ADR Rd, &lt;label&gt; and LDR Rd, &lt;label&gt; not implemented?<br />
<a href="https://github.com/orgs/micropython/discussions/12257">https://github.com/orgs/micropython/discussions/12257</a>
</li>

<li>MicroPython documentation<br />
<a href="https://docs.micropython.org/en/latest/index.html">https://docs.micropython.org/en/latest/index.html</a>
</li>

<li>Inline assembler for Thumb2 architectures<br />
<a href="https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html">https://docs.micropython.org/en/latest/reference/asm_thumb2_index.html</a>
</li>

<li>Inline assembler in MicroPython<br />
<a href="https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler">https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html#pyboard-tutorial-assembler</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/</a>
</li>

<li>RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami (2)<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>Cortex-M0 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M0">https://en.wikipedia.org/wiki/ARM_Cortex-M0</a>
</li>

<li>Cortex-M0+ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B">https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>The Thumb instruction set<br />
<a href="http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf">http://apt.cs.manchester.ac.uk/ftp/pub/apt/peve/PEVE05/Slides/05_Thumb.pdf</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Raspberry Pi Pico Variants &ndash; A Detailed Comparison<br />
<a href="https://circuitdigest.com/article/raspberry-pi-pico-variants-comparison">https://circuitdigest.com/article/raspberry-pi-pico-variants-comparison</a>
</li>

<li>Raspberry Pi Pico 2 vs Original Pico: What’s New?<br />
<a href="https://www.digikey.cz/en/maker/blogs/2024/raspberry-pi-pico-2-vs-original-pico-whats-new">https://www.digikey.cz/en/maker/blogs/2024/raspberry-pi-pico-2-vs-original-pico-whats-new</a>
</li>

<li>pio-uart<br />
<a href="https://github.com/Sympatron/pio-uart">https://github.com/Sympatron/pio-uart</a>
</li>

<li>Datasheet čipu RP2040<br />
<a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

