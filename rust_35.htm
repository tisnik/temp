<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust: knihovna ndarray pro práci s n-rozměrnými poli (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust: knihovna ndarray pro práci s n-rozměrnými poli (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Popis možností velmi užitečné knihovny ndarray vytvořené v&nbsp;Rustu dnes dokončíme. Budeme se zabývat především různými způsoby aplikací funkcí na prvky polí, což je jedna z&nbsp;technik umožňujících vyhnout se nutnosti explicitního psaní programových smyček.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Rust: knihovna ndarray pro práci s n-rozměrnými poli (dokončení)</a></p>
<p><a href="#k02">2. Funkce vyššího řádu <strong>map</strong> a jednorozměrná pole</a></p>
<p><a href="#k03">3. Předávání prvků hodnotou a referencí, automatická dereference prvků</a></p>
<p><a href="#k04">4. Funkce vyššího řádu <strong>map</strong> a dvourozměrná i trojrozměrná pole</a></p>
<p><a href="#k05">5. Složitější příklad: vektory a pole obsahující komplexní čísla</a></p>
<p><a href="#k06">6. Funkce vyššího řádu <strong>map</strong> a pole komplexních čísel</a></p>
<p><a href="#k07">7. Přímá modifikace prvků pole pomocí funkce <strong>mapv_inplace</strong></a></p>
<p><a href="#k08">8. Funkce <strong>mapv_into</strong>: kombinace <strong>mapv</strong> a <strong>mapv_inplace</strong></a></p>
<p><a href="#k09">9. Použití funkce vyššího řádu <strong>fold</strong> (reduce)</a></p>
<p><a href="#k10">10. Makro <strong>azip!</strong> pro manipulaci s&nbsp;prvky většího množství polí</a></p>
<p><a href="#k11">11. Použití struktury <strong>Zip</strong></a></p>
<p><a href="#k12">12. Větší množství producentů při použití struktury <strong>Zip</strong></a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Rust: knihovna ndarray pro práci s n-rozměrnými poli (dokončení)</h2>

<p>Již <a
href="https://www.root.cz/clanky/rust-predavani-parametru-referenci-elegantni-zpusob-prace-se-sekvencemi/">ve
třetí části</a> <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>
jsme se seznámili s&nbsp;funkcemi použitelnými při zpracování sekvencí
vytvářených pomocí iterátorů. Tyto funkce mají jména i sémantiku převzatou
z&nbsp;funkcionálních jazyků (poprvé se objevily v&nbsp;LISPu, který sice není
čistě funkcionální, ale nalezneme v&nbsp;něm mnoho prvků, které se do FP jazyků
posléze dostaly). Mezi zmíněné funkce &ndash; které by byly ve funkcionálních
jazycích implementovány funkcemi vyššího řádu &ndash; patří zejména
<strong>map</strong>, <strong>filter</strong>, <strong>take</strong>,
<strong>take_while</strong> a <strong>fold</strong> (někde se nazývá
<strong>reduce</strong>).</p>

<p>Rustovské funkce vyššího řádu ze standardní knihovny jsou určeny pro
zpracování sekvencí, přičemž výsledkem jejich aplikace může být jiná sekvence
s&nbsp;obecně odlišným počtem prvků. Typickým příkladem je zejména funkce
<strong>filter</strong> vracející odlišnou sekvenci (v&nbsp;extrémním případě i
sekvenci prázdnou). Některé funkce vyššího řádu nalezneme i v&nbsp;knihovně
<i>ndarray</i>, ovšem v&nbsp;tomto případě se pochopitelně bude jednat o
funkce, které na vstupu očekávají pole (jednorozměrný vektor, dvourozměrnou
matici, vícerozměrné pole...) a výsledkem může být opět pole popř.&nbsp;jediná
hodnota libovolného typu. Mezi funkce vyššího řádu, které nalezneme
v&nbsp;knihovně <i>ndarray</i>, patří především:</p>

<table>
<tr><th>Funkce/makro</th><th>Význam</th><th>Popsána v&nbsp;kapitole</th></tr>
<tr><td>map</td><td>postupná aplikace funkce na každý prvek, výsledkem je nové pole</td><td><a href="#k02">2</a></td></tr>
<tr><td>mapv</td><td>postupná aplikace funkce na každý prvek předaný hodnotou</td><td><a href="#k03">3</a></td></tr>
<tr><td>mapv_inplace</td><td>dtto, ale původní pole se změní (nevytvoří se nové)</td><td><a href="#k07">7</a></td></tr>
<tr><td>mapv_into</td><td>kombinace předchozích dvou funkcí</td><td><a href="#k08">8</a></td></tr>
<tr><td>fold</td><td>postupná &bdquo;redukce&ldquo; prvků v&nbsp;poli s&nbsp;akumulací výsledku</td><td><a href="#k09">9</a></td></tr>
<tr><td>azip!</td><td>makro umožňující například kombinaci prvků dvou polí</td><td><a href="#k10">10</a></td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Funkce vyššího řádu <strong>map</strong> a jednorozměrná pole</h2>

<p>Základní funkcí vyššího řádu, kterou v&nbsp;knihovně <i>ndarray</i>
nalezneme, je funkce nazvaná <strong>map</strong>. Ta postupně aplikuje jí
předanou funkci na jednotlivé prvky nějakého pole (nezávisle na počtu dimenzí)
a vytváří tak pole nové. Tento čistě funkcionální přístup, kdy se původní pole
nemění, je sice velmi užitečný a z&nbsp;hlediska teorie &bdquo;čistý&ldquo;,
ovšem lze ho aplikovat jen na relativně malá pole, nikoli například na rozsáhlé
matice s&nbsp;miliony prvků. V&nbsp;takovém případě by se totiž zvyšovaly
paměťové nároky, snižovala by se efektivnost cache atd.</p>

<p>Podívejme se nyní na způsob aplikace (anonymních) funkcí na prvky vektoru
obsahujícího hodnoty 0 až 12. Povšimněte si, že se ve funkci
<strong>map</strong> pracuje s&nbsp;referencí na prvky, což je výhodné, protože
se neprovádí jejich klonování:</p>

<pre>
let vector1 = Array::from_iter(0..12);
&nbsp;
// vektor s prvky 0, 2, 4 ...
let vector2 = vector1.<strong>map(|x| 2* *x)</strong>;
&nbsp;
// vektor s prvky 0, 1, 0, 1, ... (1 pro sudé hodnoty)
let vector3 = vector1.<strong>map(|x| *x % 2)</strong>;
&nbsp;
// vektor s prvky true, false, true, false (test, zda je hodnota sudá)
let vector4 = vector1.<strong>map(|x| *x % 2 == 0)</strong>;
&nbsp;
println!("vector1: {}", vector1);
println!("vector2: {}", vector2);
println!("vector3: {}", vector3);
println!("vector4: {}", vector4);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
vector1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
vector2: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]
vector3: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
vector4: [true, false, true, false, true, false, true, false, true, false, true, false]
</pre>

<p>Poznámka: povšimněte si, že nově vytvořené pole může obsahovat prvky jiného
typu než pole původní.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Předávání prvků hodnotou a referencí, automatická dereference prvků</h2>

<p>Pokud chcete prvky předávat hodnotou a nikoli odkazem (referencí), použijte
namísto funkce <strong>map</strong> funkci nazvanou <strong>mapv</strong>.
V&nbsp;(typicky) anonymní funkci se bude pracovat přímo s&nbsp;hodnotami prvků,
což mj.&nbsp;znamená, že může dojít k&nbsp;jejich klonování:</p>

<pre>
let vector1 = Array::from_iter(0..12);
&nbsp;
// vektor s prvky 0, 2, 4 ...
let vector2 = vector1.<strong>mapv(|x| 2*x)</strong>;
&nbsp;
// vektor s prvky 0, 1, 0, 1, ... (1 pro sudé hodnoty)
let vector3 = vector1.<strong>mapv(|x| x % 2)</strong>;
&nbsp;
// vektor s prvky true, false, true, false (test, zda je hodnota sudá)
let vector4 = vector1.<strong>mapv(|x| x % 2 == 0)</strong>;
&nbsp;
println!("vector1: {}", vector1);
println!("vector2: {}", vector2);
println!("vector3: {}", vector3);
println!("vector4: {}", vector4);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
vector1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
vector2: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]
vector3: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
vector4: [true, false, true, false, true, false, true, false, true, false, true, false]
</pre>

<p>Ve skutečnosti se díky automatickému použití <a
href="https://doc.rust-lang.org/std/ops/trait.Deref.html">traitu Deref</a> může
i v&nbsp;anonymní funkci předané do <strong>map</strong> pracovat přímo
s&nbsp;hodnotami prvků:</p>

<pre>
let vector1 = Array::from_iter(0..12);
&nbsp;
// vektor s prvky 0, 2, 4 ...
let vector2 = vector1.<strong>map(|x| 2*x)</strong>;
&nbsp;
// vektor s prvky 0, 1, 0, 1, ... (1 pro sudé hodnoty)
let vector3 = vector1.<strong>map(|x| x % 2)</strong>;
&nbsp;
// vektor s prvky true, false, true, false (test, zda je hodnota sudá)
let vector4 = vector1.<strong>map(|x| x % 2 == 0)</strong>;
&nbsp;
println!("vector1: {}", vector1);
println!("vector2: {}", vector2);
println!("vector3: {}", vector3);
println!("vector4: {}", vector4);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu je shodný s&nbsp;předchozím
výsledkem:</p>

<pre>
vector1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
vector2: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]
vector3: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
vector4: [true, false, true, false, true, false, true, false, true, false, true, false]
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce vyššího řádu <strong>map</strong> a dvourozměrná i trojrozměrná pole</h2>

<p>Funkci vyššího řádu <strong>map</strong> samozřejmě nemusíme používat pouze
pro jednorozměrné vektory, ale lze ji zavolat i pro dvourozměrné matice či pro
vícerozměrná pole. Podívejme se na aplikaci různých anonymních funkcí na prvky
matice 3&times;4 prvky:</p>

<pre>
let array1 = Array::from_iter(0..12).into_shape((3,4)).unwrap();
&nbsp;
// vektor s prvky 0, 2, 4 ...
let array2 = array1.map(|x| 2* *x);
&nbsp;
// vektor s prvky 0, 1, 0, 1, ... (1 pro sudé hodnoty)
let array3 = array1.map(|x| *x % 2);
&nbsp;
// vektor s prvky true, false, true, false (test, zda je hodnota sudá)
let array4 = array1.map(|x| *x % 2 == 0);
&nbsp;
println!("array1:\n{}\n", array1);
println!("array2:\n{}\n", array2);
println!("array3:\n{}\n", array3);
println!("array4:\n{}\n", array4);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
array1:
[[0, 1, 2, 3],
 [4, 5, 6, 7],
 [8, 9, 10, 11]]
&nbsp;
array2:
[[0, 2, 4, 6],
 [8, 10, 12, 14],
 [16, 18, 20, 22]]
&nbsp;
array3:
[[0, 1, 0, 1],
 [0, 1, 0, 1],
 [0, 1, 0, 1]]
&nbsp;
array4:
[[true, false, true, false],
 [true, false, true, false],
 [true, false, true, false]]
</pre>

<p>Aplikace na trojrozměrné pole o rozměrech 3&times;3&times;3 prvky:</p>

<pre>
let array1 = Array::from_iter(0..27).into_shape((3,3,3)).unwrap();
&nbsp;
// vektor s prvky 0, 2, 4 ...
let array2 = array1.map(|x| 2* *x);
&nbsp;
// vektor s prvky 0, 1, 0, 1, ... (1 pro sudé hodnoty)
let array3 = array1.map(|x| *x % 2);
&nbsp;
// vektor s prvky true, false, true, false (test, zda je hodnota sudá)
let array4 = array1.map(|x| *x % 2 == 0);
&nbsp;
println!("array1:\n{}\n", array1);
println!("array2:\n{}\n", array2);
println!("array3:\n{}\n", array3);
println!("array4:\n{}\n", array4);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu bude nyní následující:</p>

<pre>
array1:
[[[0, 1, 2],
  [3, 4, 5],
  [6, 7, 8]],
 [[9, 10, 11],
  [12, 13, 14],
  [15, 16, 17]],
 [[18, 19, 20],
  [21, 22, 23],
  [24, 25, 26]]]
&nbsp;
array2:
[[[0, 2, 4],
  [6, 8, 10],
  [12, 14, 16]],
 [[18, 20, 22],
  [24, 26, 28],
  [30, 32, 34]],
 [[36, 38, 40],
  [42, 44, 46],
  [48, 50, 52]]]
&nbsp;
array3:
[[[0, 1, 0],
  [1, 0, 1],
  [0, 1, 0]],
 [[1, 0, 1],
  [0, 1, 0],
  [1, 0, 1]],
 [[0, 1, 0],
  [1, 0, 1],
  [0, 1, 0]]]
&nbsp;
array4:
[[[true, false, true],
  [false, true, false],
  [true, false, true]],
 [[false, true, false],
  [true, false, true],
  [false, true, false]],
 [[true, false, true],
  [false, true, false],
  [true, false, true]]]
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Složitější příklad: vektory a pole obsahující komplexní čísla</h2>

<p>Ukažme si nyní nepatrně složitější příklad, v&nbsp;němž budeme používat
vektory a pole obsahující komplexní čísla. Celý příklad je rozdělen do několika
částí. První část specifikuje, které moduly (a jejich jmenné prostory) budeme
využívat:</p>

<pre>
extern crate ndarray;
use ndarray::Array;
use std::fmt;
</pre>

<p>Dále deklarujeme strukturu reprezentující komplexní čísla. Její
nejjednodušší varianta (bez použití generických typů) bude následující:</p>

<pre>
struct Complex {
    real: f32,
    imag: f32,
}
</pre>

<p>Pro komplexní čísla dále implementujeme konstruktor <strong>new</strong> a
funkci pro výpočet absolutní hodnoty <strong>abs</strong>. Právě tato funkce je
v&nbsp;kontextu tohoto příkladu důležitá:</p>

<pre>
impl Complex {
    fn new(real: f32, imag: f32) -&gt; Complex {
        Complex{real:real, imag:imag}
    }
&amp;nbsp;
    fn abs(&amp;self) -&gt; f32 {
        (self.real * self.real + self.imag * self.imag).sqrt()
    }
}
</pre>

<p>Pro snazší výpis vektorů a polí komplexních čísel navíc implementujeme i
funkci <strong>fmt</strong>, která bude automaticky volána v&nbsp;makru
<strong>println!</strong> (funkce <strong>fmt</strong> má podobný význam jako
metoda <strong>toString</strong> v&nbsp;Javě, jen je ji možné použít i pro
zápis do souborů atd.):</p>

<pre>
impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "{}+{}i", self.real, self.imag)
    }
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce vyššího řádu <strong>map</strong> a pole komplexních čísel</h2>

<p>Další funkce definovaná v&nbsp;demonstračním příkladu nejdříve vytvoří
jednorozměrný vektor obsahující pětici komplexních čísel a následně aplikuje
funkci/metodu <strong>Complex::abs</strong> na každý prvek tohoto vektoru.
Výsledkem bude opět vektor, tentokrát však jeho prvky budou mít typ
<strong>f32</strong> a nikoli <strong>Complex</strong>!. Ostatně se o tom
snadno přesvědčíme na výstupu:</p>

<pre>
fn map_complex() {
    println!("map_complex");
&nbsp;
    let vector1 = Array::from_vec(vec![Complex::new(0.0, 0.0),
                                       Complex::new(1.0, 0.0),
                                       Complex::new(0.0, 1.0),
                                       Complex::new(1.0, 1.0),
                                       Complex::new(100.0, 100.0)]);
&nbsp;
    let vector2 = vector1.map(|x| Complex::abs(x));
&nbsp;
    println!("vector1: {:?}", vector1);
    println!("vector2: {:?}", vector2);
&nbsp;
    println!()
}
</pre>

<p>Prakticky stejným způsobem můžeme vytvořit matici komplexních čísel o
rozměrech 3&times;3 prvky. Po aplikaci funkce/metody
<strong>Complex::abs</strong> na jednotlivé prvky této matice získáme matici
novou, tentokrát však budou prvky této matice 3&times;3 prvky typu
<strong>f32</strong>:</p>

<pre>
fn map_complex_2d() {
    println!("map_complex_2d");
&nbsp;
    let array1 = Array::from_shape_vec((3,3), vec![Complex::new(0.0, 0.0),
                                                   Complex::new(1.0, 0.0),
                                                   Complex::new(2.0, 0.0),
                                                   Complex::new(0.0, 1.0),
                                                   Complex::new(1.0, 1.0),
                                                   Complex::new(2.0, 1.0),
                                                   Complex::new(0.0, 2.0),
                                                   Complex::new(1.0, 2.0),
                                                   Complex::new(2.0, 2.0)]).unwrap();
&nbsp;
    let array2 = array1.map(|x| Complex::abs(x));
&nbsp;
    println!("vector1:\n{:?}\n", array1);
    println!("vector2:\n{:?}\n", array2);
&nbsp;
    println!()
}
</pre>

<p>Nyní nám jen zbývá obě výše uvedené funkce zavolat:</p>

<pre>
fn main() {
    map_complex();
    map_complex_2d();
}
</pre>

<p>Po překladu a spuštění tohoto příkladu by se měly na standardní výstup
vypsat následující řádky:</p>

<pre>
map_complex
vector1: [0+0i, 1+0i, 0+1i, 1+1i, 100+100i] shape=[5], strides=[1], layout=C | F (0x3)
vector2: [0, 1, 1, 1.4142135, 141.42136] shape=[5], strides=[1], layout=C | F (0x3)
&nbsp;
map_complex_2d
vector1:
[[0+0i, 1+0i, 2+0i],
 [0+1i, 1+1i, 2+1i],
 [0+2i, 1+2i, 2+2i]] shape=[3, 3], strides=[3, 1], layout=C (0x1)
&nbsp;
vector2:
[[0, 1, 2],
 [1, 1.4142135, 2.236068],
 [2, 2.236068, 2.828427]] shape=[3, 3], strides=[3, 1], layout=C (0x1)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přímá modifikace prvků pole pomocí funkce <strong>mapv_inplace</strong></h2>

<p>Jak jsme si již vysvětlili u popisu funkce <strong>map</strong>, může být
čistě funkcionální přístup při zpracování rozsáhlých polí problematický,
protože vede k&nbsp;neustálému vytváření polí nových. Jedno z&nbsp;řešení
spočívá v&nbsp;aplikaci nějaké zvolené funkce na prvky pole, ovšem s&nbsp;tím
rozdílem, že se původní prvek přepíše výslednou hodnotou dané funkce. Celé
zpracování je tedy skutečně provedeno &bdquo;in situ&ldquo; se všemi výhodami
(žádná další spotřeba paměti) i nevýhodami (měníme stav objektu, což je obecně
postup, kterému se snažíme vyhnout).</p>

<p>Vzhledem k&nbsp;tomu, že se prvky pole modifikují, musí být celé pole
měnitelné (<i>mutable</i>):</p>

<pre>
let <strong>mut</strong> vector1 = Array::from_iter(0..12);
&nbsp;
println!("vector1: {}", vector1);
</pre>

<p>Na takové pole (zde konkrétně jednorozměrný vektor) můžeme volat funkci
<strong>mapv_inplace</strong>. Povšimněte si, jak lze použít rozhodovací
konstrukci <strong>if-then-else</strong>:</p>

<pre>
vector1.<strong>mapv_inplace(|x| x*2)</strong>;
&nbsp;
println!("vector1: {}", vector1);
&nbsp;
vector1.<strong>mapv_inplace(|x| if x&lt;10 {0} else {1})</strong>;
&nbsp;
println!("vector1: {}", vector1);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
vector1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
vector1: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]
vector1: [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1]
</pre>

<p>Podobně budeme postupovat u dvourozměrných polí:</p>

<pre>
let <strong>mut</strong> array1 = Array::from_iter(0..12).into_shape((3,4)).unwrap();
&nbsp;
println!("array1:\n{}\n", array1);
&nbsp;
array1.<strong>mapv_inplace(|x| if x%2 == 0 {0} else {1})</strong>;
&nbsp;
println!("array1:\n{}\n", array1);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
array1:
[[0, 1, 2, 3],
 [4, 5, 6, 7],
 [8, 9, 10, 11]]
&nbsp;
array1:
[[0, 1, 0, 1],
 [0, 1, 0, 1],
 [0, 1, 0, 1]]
</pre>

<p>Aplikace na trojrozměrné pole o rozměrech 3&times;3&times;3 prvky:</p>

<pre>
let <strong>mut</strong> array1 = Array::from_iter(0..27).into_shape((3,3,3)).unwrap();
&nbsp;
println!("array1:\n{}\n", array1);
&nbsp;
array1.<strong>mapv_inplace(|x| if x%2 == 0 {0} else {1})</strong>;
&nbsp;
println!("array1:\n{}\n", array1);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
array1:
[[[0, 1, 2],
  [3, 4, 5],
  [6, 7, 8]],
 [[9, 10, 11],
  [12, 13, 14],
  [15, 16, 17]],
 [[18, 19, 20],
  [21, 22, 23],
  [24, 25, 26]]]
&nbsp;
array1:
[[[0, 1, 0],
  [1, 0, 1],
  [0, 1, 0]],
 [[1, 0, 1],
  [0, 1, 0],
  [1, 0, 1]],
 [[0, 1, 0],
  [1, 0, 1],
  [0, 1, 0]]]
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Funkce <strong>mapv_into</strong>: kombinace <strong>mapv</strong> a <strong>mapv_inplace</strong></h2>

<p>Kromě již popsaných funkcí vyššího řádu <strong>map</strong>,
<strong>mapv</strong> a <strong>mapv_inplace</strong> existuje ještě funkce
nazvaná <strong>mapv_into</strong>, která přebírá vlastnosti obou předchozích
variant <strong>mapv*</strong>. Funkce <strong>mapv_into</strong> totiž
&bdquo;konzumuje&ldquo; původní pole a vrací pole nové. Ve skutečnosti ovšem
opět pracuje &bdquo;in situ&ldquo;, takže je její použití paměťově efektivní,
ovšem navíc se tato funkce chová více funkcionálně, protože po konzumaci
původního pole ho již není možné použít a musíme namísto toho použít návratovou
hodnotu <strong>mapv_into</strong> (toto chování si zkontroluje překladač):</p>

<pre>
let vector1 = Array::from_iter(0..12);
let vector2 = vector1.mapv_into(|x| x*2);
let vector3 = vector2.mapv_into(|x| if x&lt;10 {0} else {1});
&nbsp;
println!("vector3: {}", vector3);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
vector3: [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1]
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Použití funkce vyššího řádu <strong>fold</strong> (reduce)</h2>

<p>Další velmi užitečnou funkcí vyššího řádu, která nesmí chybět
v&nbsp;repertoáru žádné funkcionálně zaměřené knihovny (a tím pádem ani
v&nbsp;repertoáru &bdquo;funkcionální&ldquo; části knihovny <i>ndarray</i>), je
funkce pojmenovaná <strong>reduce</strong> popř.&nbsp;<strong>fold</strong>.
Názvy těchto funkcí naznačují jejich účel &ndash; dochází k&nbsp;postupné
&bdquo;redukci&ldquo; prvků uložených v&nbsp;poli, a to (postupnou) aplikací
zvolené uživatelské funkce na jednotlivé prvky a po krocích počítaný
mezivýsledek (někdy se podle svého chování nazývá akumulátor).</p>

<p>V&nbsp;knihovně <i>ndarray</i> se příslušná metoda, která toto chování pro
libovolné pole zajišťuje, jmenuje <strong>fold</strong> a akceptuje dva
parametry &ndash; počáteční hodnotu akumulátoru (mezivýsledku) a <i>uzávěr</i>,
což je zjednodušeně řečeno funkce (typicky anonymní), která na sebe má navázánu
alespoň jednu volnou proměnnou. Tento uzávěr je postupně volán se dvěma
argumenty, tedy s&nbsp;aktuální hodnotou akumulátoru (mezivýsledku) a prvkem
získaným ze vstupní sekvence. Akumulátor je po každém volání modifikován tak,
že obsahuje hodnotou vrácenou uzávěrem.</p>

<p>Podívejme se na příklad, v&nbsp;němž sečteme všechny prvky jednorozměrného
pole a posléze vypočteme součin všech prvků. Při výpočtu součtu je počáteční
hodnota akumulátoru nulová, u součinu musí být samozřejmě nastavena na
jedničku:</p>

<pre>
let vector1 = Array::from_iter(1..11);
&nbsp;
let sum = vector1.<strong>fold(0, |acc, value| acc+value)</strong>;
&nbsp;
let product = vector1.<strong>fold(1, |acc, value| acc*value)</strong>;
&nbsp;
println!("vector1: {}", vector1);
println!("sum: {}", sum);
println!("product: {}", product);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
vector1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
sum: 55
product: 3628800
</pre>

<p>Ve složitějším příkladu provedeme stejnou operaci, ovšem s&nbsp;maticí
3&times;3 prvky. Navíc ještě vypočteme součet prvků s&nbsp;počáteční hodnotou
akumulátoru nastavenou na 1000:</p>

<pre>
let array = Array::from_shape_vec((3,3), vec![1,2,3,4,5,6,7,8,9]).unwrap();
&nbsp;
let sum = array.<strong>fold(0, |acc, value| acc+value)</strong>;
let sum_offset = array.<strong>fold(1000, |acc, value| acc+value)</strong>;
&nbsp;
let product = array.<strong>fold(1, |acc, value| acc*value)</strong>;
&nbsp;
println!("array:\n{}\n", array);
println!("sum: {}", sum);
println!("sum_offset: {}", sum_offset);
println!("product: {}", product);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
array:
[[1, 2, 3],
 [4, 5, 6],
 [7, 8, 9]]
&nbsp;
sum: 45
sum_offset: 1045
product: 362880
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Makro <strong>azip!</strong> pro manipulaci s&nbsp;prvky většího množství polí</h2>

<p>Minule jsme si mj.&nbsp;popsali i operátory, které byly přetížené takovým
způsobem, aby je bylo možné využít pro součet, rozdíl, součin či podíl
korespondujících prvků dvou polí. Ve skutečnosti je ovšem použití přetížených
operátorů poměrně omezené, což ale nemusí představovat větší problém, a to díky
existenci makra nazvaného <strong>azip!</strong>. Toto makro dokáže zpracovat
větší množství vstupních polí, přičemž aplikuje zvolený výraz na každou
kombinaci korespondujících prvků vstupních polí. Nejlepší bude, když si ukážeme
jednoduchý příklad pro součet dvou vektorů.</p>

<p>Mějme dva vstupní vektory:</p>

<pre>
let vector1 = Array::from_iter(1..11);
let vector2 = Array::from_iter(1..11);
</pre>

<p>A vektor pro uložení výsledku. Tento vektor musí mít shodnou velikost a musí
být samozřejmě měnitelný (<i>mutable</i>):</p>

<pre>
let <strong>mut</strong> result = Array::zeros((10));
</pre>

<p>Nyní korespondující prvky vektoru sečteme použitím makra
<strong>azip!</strong>. Před slovem <strong>in</strong> se specifikuje výsledné
pole i pole vstupní. Výraz ve složených závorkách se aplikuje na korespondující
prvky vektorů:</p>

<pre>
azip!(mut result, vector1, vector2 in { *result = vector1 + vector2 });
&nbsp;
println!("vector1: {}", vector1);
println!("vector2: {}", vector2);
println!("result sum: {}", result);
</pre>

<p>Původní vstupní vektory nejsou &bdquo;zkonzumovány&ldquo;, takže je lze
použít v&nbsp;dalším výpočtu:</p>

<pre>
let mut result_mul = Array::zeros((10));
&nbsp;
azip!(mut result_mul, vector1, vector2 in { *result_mul = vector1 * vector2 });
println!("result_mul: {}", result_mul);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
vector1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
vector2: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result sum: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
result_mul: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Použití struktury <strong>Zip</strong></h2>

<p>Ve skutečnosti se makro <strong>azip!</strong> expanduje na složitější výraz
se strukturou <strong>Zip</strong>. Tato struktura poskytuje (přesněji řečeno
implementuje) několik funkcí umožňujících specifikovat výstupní pole, vstupní
(zdrojová) pole i prováděnou operaci. Tato operace se typicky zadává formou
anonymní funkce předané do funkce vyššího řádu <strong>apply</strong>. Opět se
podívejme na příklad podobný příkladu z&nbsp;předchozí kapitoly.</p>

<p>Mějme dva vstupní vektory:</p>

<pre>
let vector1 = Array::from_iter(1..11);
let vector2 = Array::from_iter(1..11);
</pre>

<p>A vektor pro uložení výsledku. Tento vektor musí mít shodnou velikost a musí
být samozřejmě měnitelný (<i>mutable</i>):</p>

<pre>
let <strong>mut</strong> result = Array::zeros((10));
</pre>

<p>Nyní s&nbsp;využitím metod <strong>from</strong> a <strong>and</strong>
specifikujeme vstupní a výstupní pole a následně přes funkci vyššího řádu
<strong>apply</strong> uvedeme, jaká operace se má provádět
s&nbsp;korespondujícími prvky vstupních polí. Ty se předávají přes
referenci:</p>

<pre>
Zip::from(&amp;mut result)
     .and(&amp;vector1)
     .and(&amp;vector2)
     .apply(|result, &amp;vector1, &amp;vector2| {
          *result = vector1 + vector2
     });
&nbsp;
println!("vector1: {}", vector1);
println!("vector2: {}", vector2);
println!("result sum: {}", result);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
vector1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
vector2: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result sum: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Větší množství producentů při použití struktury <strong>Zip</strong></h2>

<p>Ve skutečnosti je možné specifikovat větší (prakticky libovolné) množství
vstupních polí, což je patrné z&nbsp;následujícího příkladu se čtyřmi vstupními
poli:</p>

<pre>
let vector1 = Array::from_iter(1..11);
let vector2 = Array::from_iter(1..11);
let vector3 = Array::from_vec(vec![1,2,3,1,2,3,1,2,3,1000]);
let vector4 = Array::from_vec(vec![1,1,1,2,2,2,3,3,3,4]);
&nbsp;
let mut result = Array::zeros((10));
&nbsp;
Zip::from(&amp;mut result)
     .and(&amp;vector1)
     .and(&amp;vector2)
     .and(&amp;vector3)
     .and(&amp;vector4)
     .apply(|result, &amp;vector1, &amp;vector2, &amp;vector3, &amp;vector4| {
          *result = vector1 + vector2 * vector3 / vector4
     });
&nbsp;
println!("vector1: {}", vector1);
println!("vector2: {}", vector2);
println!("vector3: {}", vector3);
println!("vector4: {}", vector4);
println!("result sum: {}", result);
</pre>

<p>Výsledek běhu výše uvedeného úryvku kódu:</p>

<pre>
vector1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
vector2: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
vector3: [1, 2, 3, 1, 2, 3, 1, 2, 3, 1000]
vector4: [1, 1, 1, 2, 2, 2, 3, 3, 3, 4]
result sum: [2, 6, 12, 6, 10, 15, 9, 13, 18, 2510]
</pre>

<p>Poznámka: zápis je poměrně složitý, což je i jeden z&nbsp;důvodů, proč je
mnohem jednodušší používat makro <strong>azip!</strong>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady (Rustovské projekty) byly,
ostatně podobně jako ve všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář (ovšem u projektů je lepší mít celý
repositář, abyste nemuseli pracně stahovat všechny potřebné soubory):</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>První projekt</td><td>ndarray-map</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Druhý projekt</td><td>ndarray-map-inplace</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map-inplace/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map-inplace/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map-inplace/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map-inplace/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Třetí projekt</td><td>ndarray-map-for-complex</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map-for-complex/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map-for-complex/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map-for-complex/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-map-for-complex/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Čtvrtý projekt</td><td>ndarray-fold</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-fold/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-fold/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-fold/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-fold/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Pátý projekt</td><td>ndarray-azip</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-azip/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-azip/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-azip/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/ndarray-azip/src/main.rs</a></td></tr>
</table>

<p>Každý projekt se přeloží příkazem:</p>

<pre>
cargo build
</pre>

<p>Jeho následné spuštění zajistí příkaz:</p>

<pre>
cargo clean
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Map (higher-order function)<br />
<a href="https://en.wikipedia.org/wiki/Map_%28higher-order_function%29">https://en.wikipedia.org/wiki/Map_%28higher-order_function%29</a>
</li>

<li>Fold (higher-order function)<br />
<a href="https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29">https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29</a>
</li>

<li>ndarray - dokumentace k&nbsp;modulu<br />
<a href="https://bluss.github.io/rust-ndarray/master/ndarray/index.html">https://bluss.github.io/rust-ndarray/master/ndarray/index.html</a>
</li>

<li>ndarray - Crate<br />
<a href="https://crates.io/crates/ndarray">https://crates.io/crates/ndarray</a>
</li>

<li>rustup<br />
<a href="https://www.rustup.rs/">https://www.rustup.rs/</a>
</li>

<li>rustup: the Rust toolchain installer (Git repositář + dokumentace)<br />
<a href="https://github.com/rust-lang-nursery/rustup.rs">https://github.com/rust-lang-nursery/rustup.rs</a>
</li>

<li>The Rust FFI Omnibus<br />
<a href="http://jakegoulding.com/rust-ffi-omnibus/">http://jakegoulding.com/rust-ffi-omnibus/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Calling Rust From Python<br />
<a href="https://bheisler.github.io/post/calling-rust-in-python/">https://bheisler.github.io/post/calling-rust-in-python/</a>
</li>

<li>Calling Rust in Python (komentáře k předchozímu článku)<br />
<a href="https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/">https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/</a>
</li>

<li>CFFI Documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>ctypes — A foreign function library for Python<br />
<a href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

