<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Ukazatele v Rustu aneb temná strana Síly</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Ukazatele v Rustu aneb temná strana Síly</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;programovacím jazyku Rust nalezneme kromě referencí, jejichž použití je kontrolované překladačem a tudíž i bezpečné, i ukazatele (pointery). S&nbsp;využitím ukazatelů lze realizovat některé &bdquo;triky&ldquo; známé z&nbsp;jazyků C a C++, ovšem na druhou stranu uvidíme, že některé operace jsou potenciálně nebezpečné.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Ukazatele v&nbsp;Rustu aneb temná strana Síly</a></p>
<p><a href="#k02">2. Deklarace a inicializace proměnné typu ukazatel</a></p>
<p><a href="#k03">3. První demonstrační příklad &ndash; deklarace a inicializace ukazatele</a></p>
<p><a href="#k04">4. Přístup k&nbsp;hodnotám proměnných přes ukazatel &ndash; blok <strong>unsafe</strong></a></p>
<p><a href="#k05">5. Kontrola překladačem na použití bloku <strong>unsafe</strong></a></p>
<p><a href="#k06">6. Měnitelné versus neměnitelné ukazatele, měnitelné versus neměnitelné proměnné</a></p>
<p><a href="#k07">7. Ukazatele pro čtení či pro zápis hodnot do referencovaných proměnných</a></p>
<p><a href="#k08">8. Demonstrační příklad &ndash; zápis do proměnné přes ukazatel</a></p>
<p><a href="#k09">9. Kontrola, zda je možné do proměnné skutečně zapisovat</a></p>
<p><a href="#k10">10. Krátká rekapitulace &ndash; deklarace a inicializace ukazatelů různých typů</a></p>
<p><a href="#k11">11. Čtení či zápis do proměnné mimo oblast její životnosti?</a></p>
<p><a href="#k12">12. Ukazatel na datovou strukturu</a></p>
<p><a href="#k13">13. Přístup k&nbsp;prvkům struktury přes ukazatel</a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Ukazatele v&nbsp;Rustu aneb temná strana Síly</h2>

<p><a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">V&nbsp;programovacím
jazyku Rust</a> je možné a v&nbsp;některých případech dokonce i nutné používat
ukazatele reprezentované <a
href="https://doc.rust-lang.org/std/primitive.pointer.html">primitivním typem
<strong>pointer</strong></a>, které se však v&nbsp;některých ohledech liší od
&bdquo;klasických&ldquo; ukazatelů známých z&nbsp;jazyků C či C++. Na základě
mnohaletých zkušeností vývojářů Rustu se zmíněnými programovacími jazyky C/C++
totiž byly ukazatele v&nbsp;Rustu navrženy takovým způsobem, aby práce
s&nbsp;nimi byla poněkud bezpečnější (pokud je to vůbec možné) a aby všechny
potenciálně nebezpečné operace byly umístěny do speciálního bloku nazvaného
<strong>unsafe</strong>. Do určité míry se zjednodušila i ukazatelová
aritmetika (<i>pointer arithmetic/pointer math</i>) díky existenci funkce
<strong>pointer.offset()</strong>. I tak je však při práci s&nbsp;ukazateli
nutné dbát zvýšené opatrnosti, protože překladač například nehlídá to, jestli
ukazatel obsahuje adresu stále živé proměnné atd. V&nbsp;praxi se většinou
snažíme se použití ukazatelů zcela vyhnout, samozřejmě za předpokladu, že je to
možné.</p>

<p>Poznámka: v&nbsp;minulosti existovalo v&nbsp;Rustu několik typů ukazatelů,
navíc je slovo <i>pointer</i> dodnes používáno <a
href="http://cosmic.mearie.org/2014/01/periodic-table-of-rust-types/">v&nbsp;několika
kontextech</a>. Ukazatele popisované dnes spadají do kategorie &bdquo;raw
pointers&ldquo;.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Deklarace a inicializace proměnné typu ukazatel</h2>

<p>V&nbsp;programovacím jazyku Rust rozeznáváme dva typy &bdquo;raw&ldquo;
ukazatelů &ndash; ukazatele používané pro čtení konstantní i měnitelné hodnoty
a ukazatele na hodnoty, které lze přes ukazatel změnit (<i>mutable</i>).
Nejdříve se seznámíme s&nbsp;ukazateli používanými jen pro čtení hodnoty
(<i>read only</i>). Jejich typ je vždy <strong>*const T</strong>, kde
<strong>T</strong> je prakticky libovolný datový typ Rustu. Pokud například
budeme chtít nadefinovat proměnnou nazvanou <strong>pointer</strong>, která je
ukazatelem na konstantní či měnitelnou 32bitovou celou hodnotu se znaménkem,
bude deklarace vypadat následovně:</p>

<pre>
let pointer: <strong>*const</strong> i32;
</pre>

<p>Přiřazení adresy do ukazatele se do značné míry podobá zápisu používaném
v&nbsp;céčku nebo i v&nbsp;Rustu při získávání reference:</p>

<pre>
let value: i32 = 42;
&nbsp;
pointer = &amp;value;
</pre>

<p>Deklaraci ukazatele můžeme spojit s&nbsp;jeho inicializací:</p>

<pre>
let value: i32 = 42;
&nbsp;
let pointer: <strong>*const i32</strong> = &amp;value;
</pre>

<p>Poznámka: v&nbsp;tomto případě ovšem vždy <i>musíte</i> explicitně uvést
datový typ ukazatele, jinak by se vytvořila &bdquo;pouze&ldquo; reference na
hodnotu (což již známe). Následující kód má tedy odlišný význam:</p>

<pre>
let value: i32 = 42;
&nbsp;
let reference = &amp;value;
</pre>

<p>Popř.&nbsp;explicitně:</p>

<pre>
let value: i32 = 42;
&nbsp;
let reference: <strong>&amp;i32</strong> = &amp;value;
</pre>

<p>Poznámka: interně se reference a ukazatele vlastně neliší, protože obsahují
stejnou hodnotu = adresu proměnné. Práce s&nbsp;nimi je však odlišná, stejně
jako kontroly, které provádí překladač.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad &ndash; deklarace a inicializace ukazatele</h2>

<p>V&nbsp;dnešním <a
href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers01.rs">prvním
demonstračním příkladu</a> vytvoříme neměnitelnou (<i>immutable</i>) proměnnou
nazvanou <strong>value</strong>, k&nbsp;ní získáme referenci a taktéž ukazatel
na ni. Následně je na standardní výstup vypsána hodnota proměnné, hodnota téže
proměnné, ale přes referenci a konečně též obsah samotného ukazatele. Ovšem
ukazatel obsahuje <i>adresu</i> proměnné, takže třetí řádek nevypíše 42, ale
hexadecimální adresu <strong>value</strong> umístěné na zásobníkovém rámci
funkce <strong>main</strong> (u reference se naproti tomu automaticky provede
<i>dereference</i> a tudíž přečtení hodnoty proměnné). Povšimněte si, že
získání reference na proměnnou a adresy proměnné se zapisuje stejným znakem
&amp;, jediný rozdíl spočívá v&nbsp;odlišném datovém typu:</p>

<pre>
fn main() {
    let value: i32 = 42;
&nbsp;
    let reference: <strong>&amp;i32</strong> = &amp;value;
    let pointer: <strong>*const i32</strong> = &amp;value;
&nbsp;
    println!("{}", value);
    println!("{}", reference);
    println!("{:?}", pointer);
}
</pre>

<p>Po spuštění může tento příklad vypsat například následující hodnoty. Adresa
proměnné <strong>value</strong> (tedy hodnota ukazatele) se samozřejmě může ve
vašem případě lišit:</p>

<pre>
42
42
0x7fffc7039394
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přístup k&nbsp;hodnotám proměnných přes ukazatel &ndash; blok <strong>unsafe</strong></h2>

<p>K&nbsp;hodnotám proměnných lze samozřejmě přistupovat i přes ukazatel (jinak
by ostatně nemělo smysl s&nbsp;ukazateli pracovat). Zápis je v&nbsp;tomto
případě prakticky stejný, jak ho známe z&nbsp;céčka či z&nbsp;C++:</p>

<pre>
*ukazatel
</pre>

<p>Velký rozdíl mezi Rustem na jedné straně a jazyky C/C++ na straně druhé však
spočívá v&nbsp;tom, že přístup přes ukazatel je považován za potenciálně
nebezpečnou operaci a musí být za všech okolností uzavřen do speciálního bloku
<strong>unsafe</strong>:</p>

<pre>
unsafe {
    ...
    *ukazatel
    ...
}
</pre>

<p>Podívejme se nyní na <a
href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers02.rs">druhý
demonstrační příklad</a>, který na posledním řádku vypíše hodnotu proměnné
získané nepřímo přes ukazatel:</p>

<pre>
fn main() {
    let value: i32 = 42;
&nbsp;
    let reference: &amp;i32 = &amp;value;
    let pointer: *const i32 = &amp;value;
&nbsp;
    println!("{}", value);
    println!("{}", reference);
    println!("{:?}", pointer);
&nbsp;
    <strong>unsafe</strong> {
        println!("{}", <strong>*pointer</strong>);
    }
}
</pre>

<p>Příklad výstupu tohoto demonstračního příkladu (třetí řádek se opět
pravděpodobně bude na vašem počítači lišit):</p>

<pre>
42
42
0x7fff56270904
42
</pre>

<p>Alternativně je možné příklad <a
href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers02_inner_unsafe.rs">přepsat
takto</a> (vložením bloku unsafe dovnitř makra println!):</p>

<pre>
fn main() {
    let value: i32 = 42;
&nbsp;
    let reference: &amp;i32 = &amp;value;
    let pointer: *const i32 = &amp;value;
&nbsp;
    println!("{}", value);
    println!("{}", reference);
    println!("{:?}", pointer);
&nbsp;
    println!("{}", <strong>unsafe {*pointer}</strong>);
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Kontrola překladačem na použití bloku <strong>unsafe</strong></h2>

<p>Ve chvíli, kdy blok <strong>unsafe</strong> nepoužijeme, bude se na nás
překladač zlobit. Ostatně si to můžeme velmi snadno vyzkoušet na <a
href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers02_no_unsafe.rs">nepatrně
upraveném příkladu</a>, tentokrát ovšem bez <strong>unsafe</strong> bloku:</p>

<pre>
fn main() {
    let value: i32 = 42;
&nbsp;
    let reference: &amp;i32 = &amp;value;
    let pointer: *const i32 = &amp;value;
&nbsp;
    println!("{}", value);
    println!("{}", reference);
    println!("{:?}", pointer);
&nbsp;
    println!("{}", <strong>*pointer</strong>);
}
</pre>

<p>Překladač skutečně při pokusu o vytvoření binárního spustitelného souboru
vypíše chybové hlášení:</p>

<pre>
  --&gt; pointers02_no_unsafe.rs:11:20
   |
11 |     println!("{}", *pointer);
   |                    ^^^^^^^^ unsafe call requires unsafe function or block
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
pointers02_no_unsafe.rs:11:5: 11:30 note: in this expansion of println! (defined in &lt;std macros&gt;)
&nbsp;
error: aborting due to previous error
</pre>

<p>Podobně je tomu i u dalších potenciálně nebezpečných operací, tj.&nbsp;u
většiny operací s&nbsp;ukazateli.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Měnitelné versus neměnitelné ukazatele, měnitelné versus neměnitelné proměnné</h2>

<p>Vzhledem k&nbsp;tomu, že ukazatele jsou primitivním datovým typem, rozeznává
Rust měnitelné a neměnitelné ukazatele. Ovšem je rozdíl například mezi
ukazatelem na měnitelnou hodnotu a měnitelným ukazatelem (a aby toho nebylo
málo, rozeznáváme ještě typy <strong>*const</strong> a <strong>*mut</strong>
popsané v&nbsp;navazujících kapitolách). Podívejme se nyní na jednotlivé
varianty.</p>

<p>Neměnitelný ukazatel na neměnitelnou hodnotu &ndash; ten již známe
z&nbsp;předchozích kapitol. Samotnou hodnotu nelze změnit, ovšem ani ukazatel
nelze &bdquo;přesměrovat&ldquo; na jinou proměnnou. Jediná povolená operace
s&nbsp;ukazatelem je přečtení hodnoty proměnné přes její adresu
(tj.&nbsp;dereferencování) v&nbsp;bloku <strong>unsafe</strong>:</p>

<pre>
fn main() {
    let value: i32 = 42;
&nbsp;
    let pointer: <strong>*const i32</strong> = &amp;value;
&nbsp;
    println!("{}", value);
    println!("{:?}", pointer);
}
</pre>

<p>Neměnitelný ukazatel na měnitelnou hodnotu. Samotný ukazatel vždy ukazuje na
jedinou proměnnou, jejíž hodnota se však může změnit. Tento ukazatel lze ovšem
použít pouze pro čtení hodnoty proměnné, nikoli pro zápis (což je velmi
rozumné, jinými slovy kde to jde používejte <strong>*const</strong> a nikoli
dále popsaný <strong>*mut</strong>):</p>

<pre>
fn main() {
    let <strong>mut</strong> value: i32 = 42;
&nbsp;
    let pointer: <strong>*const i32</strong> = &amp;value;
&nbsp;
    println!("{}", value);
    println!("{:?}", pointer);
&nbsp;
    unsafe {
        println!("{}", *pointer);
    }
&nbsp;
    value = 100;
    println!("{}", value);
    println!("{:?}", pointer);
&nbsp;
    unsafe {
        println!("{}", *pointer);
    }
}
</pre>

<p>Měnitelný ukazatel na neměnitelnou (konstantní) hodnotu. Nyní jedna proměnná
<strong>pointer</strong> v&nbsp;první části programu obsahuje adresu proměnné
<strong>value1</strong>, v&nbsp;další části pak adresu proměnné
<strong>value2</strong>. Jinými slovy <i>adresa</i> uložena v&nbsp;proměnné
<i>pointer</i> se sice může změnit, nikoli však hodnoty uložené na této
adrese:</p>

<pre>
fn main() {
    let value1: i32 = 42;
    let value2: i32 = 100;
&nbsp;
    let <strong>mut</strong> pointer: <strong>*const</strong> i32;
&nbsp;
    println!("{}", value1);
&nbsp;
    pointer = &amp;value1;
    println!("{:?}", pointer);
    println!("{}", unsafe {*pointer});
&nbsp;
    pointer = &amp;value2;
    println!("{:?}", pointer);
    println!("{}", unsafe {*pointer});
}
</pre>

<p>Měnitelný je ukazatel i samotná hodnota. Kombinace předchozích dvou příkladů
(stále však platí, že přes ukazatel je možné proměnnou pouze číst, protože typ
ukazatele je <strong>*const i32</strong>):</p>

<pre>
fn main() {
    let <strong>mut</strong> value1: i32 = 1;
    let <strong>mut</strong> value2: i32 = 3;
&nbsp;
    let <strong>mut</strong> pointer: <strong>*const</strong> i32;
&nbsp;
    pointer = &value1;
    println!("{}", unsafe {*pointer});
    value1 = 2;
    println!("{}", unsafe {*pointer});
&nbsp;
    pointer = &value2;
    println!("{}", unsafe {*pointer});
    value2 = 4;
    println!("{}", unsafe {*pointer});
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Ukazatele pro čtení či pro zápis hodnot do referencovaných proměnných</h2>

<p>Aby toho nebylo málo, má klíčové slovo <strong>mut</strong> ještě jeden
význam. Odlišujeme jím totiž ukazatele používané pouze pro čtení a ukazatele,
přes něž můžeme měnit (mutovat) proměnnou, na níž ukazují. Prakticky to
znamená, že se striktně rozlišuje mezi těmito typy:</p>

<pre>
let pointer1: <strong>*const</strong> i32 = &amp;value;
let pointer2: <strong>*mut</strong>   i32 = &amp;mut value;
</pre>

<p>Pokud se použije druhý zápis, <i>musí</i> být i samotná proměnná měnitelná!
Tím je zajištěno, že se nikdo nebude snažit modifikovat immutable hodnotu (tedy
snažit se může, ale překladač mu to nedovolí).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstrační příklad &ndash; zápis do proměnné přes ukazatel</h2>

<p>Rozdíl spočívá v&nbsp;tom, že ve druhém případě můžeme do proměnné zapisovat
přes ukazatel. Podívejme se nyní na <a
href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers04.rs">demonstrační
příklad</a>, z&nbsp;něhož je patrné, že i zápis přes ukazatel je &ndash;
pochopitelně &ndash; potenciálně nebezpečná operace, která musí být uzavřena do
bloku <strong>unsafe</strong>:</p>

<pre>
fn main() {
    let <strong>mut</strong> value: i32 = 42;
&nbsp;
    let pointer: <strong>*mut i32</strong> = &amp;mut value;
&nbsp;
    println!("{}", value);
    unsafe {
        println!("{}", <strong>*pointer</strong>);
    }
&nbsp;
    value = 1;
&nbsp;
    println!("{}", value);
    unsafe {
        println!("{}", <strong>*pointer</strong>);
    }
&nbsp;
    unsafe {
        <strong>*pointer = 20</strong>;
    }
    println!("{}", value);
    unsafe {
        println!("{}", <strong>*pointer</strong>);
    }
}
</pre>

<p>Po překladu a spuštění tohoto příkladu dostaneme tento výstup:</p>

<pre>
42
42
1
1
20
20
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Kontrola, zda je možné do proměnné skutečně zapisovat</h2>

<p>Opět platí, že si překladač hlídá, zda se ukazatel typu
<strong>*mut</strong> skutečně vytváří pro měnitelnou proměnnou. Zkusme na
první modifikátor <strong>mut</strong> <a
href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers04_immut_var.rs">zapomenout</a>:</p>

<pre>
fn main() {
    let <del>mut</del> value: i32 = 42;
&nbsp;
    let pointer: <strong>*mut i32</strong> = &amp;mut value;
&nbsp;
    println!("{}", value);
    unsafe {
        println!("{}", <strong>*pointer</strong>);
    }
&nbsp;
    value = 1;
&nbsp;
    println!("{}", value);
    unsafe {
        println!("{}", <strong>*pointer</strong>);
    }
&nbsp;
    unsafe {
        <strong>*pointer = 20</strong>;
    }
    println!("{}", value);
    unsafe {
        println!("{}", <strong>*pointer</strong>);
    }
}
</pre>

<p>Překladač v&nbsp;takovém případě vypíše chybové hlášení, jehož druhou část
již známe:</p>

<pre>
error: cannot borrow immutable local variable `value` as mutable
 --&gt; pointers04_immut_var.rs:4:34
  |
2 |     let value: i32 = 42;
  |         ----- use `mut value` here to make mutable
3 | 
4 |     let pointer: *mut i32 = &amp;mut value;
  |                                  ^^^^^ cannot borrow mutably
&nbsp;
error[E0384]: re-assignment of immutable variable `value`
  --&gt; pointers04_immut_var.rs:11:5
   |
2  |     let value: i32 = 42;
   |         ----- first assignment to `value`
...
11 |     value = 1;
   |     ^^^^^^^^^ re-assignment of immutable variable
&nbsp;
error: aborting due to 2 previous errors
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Krátká rekapitulace &ndash; deklarace a inicializace ukazatelů různých typů</h2>

<p>Prozatím jsme se setkali se dvěma způsoby deklarace proměnných &ndash;
immutable (výchozí volba) a mutable. U ukazatelů taktéž existují varianty,
přičemž klíčovými slovy <strong>const/mut</strong> se určuje, zda se přes
ukazatel může do proměnné zapisovat či nikoli. Další varianty určují, zda i
samotný ukazatel je immutable či mutable, tj.&nbsp;zde se může ukazatel změnit.
Povšimněte si, že dvě možnosti jsou chybné &ndash; pokus o vytvoření ukazatele
typu <strong>*mut</strong> na neměnitelnou proměnnou:</p>

<table>
<tr><th>Proměnná</th><th>Ukazatel</th><th>Čtení proměnné</th><th>Zápis do proměnné</th><th>Čtení přes ukazatel</th><th>Zápis přes ukazatel</th><th>Ukazatel lze změnit</th></tr>
<tr><td>let v: i32;</td><td>let p: *const i32;</td><td>ano</td><td>ne</td><td>ano</td><td>ne</td><td>ne</td></tr>
<tr><td>let v: i32;</td><td>let mut p: *const i32;</td><td>ano</td><td>ne</td><td>ano</td><td>ne</td><td>ano</td></tr>
<tr><td>let v: i32;</td><td>let p: *mut i32;</td><td>ano</td><td>ne</td><td>chyba</td><td>chyba</td><td>chyba</td></tr>
<tr><td>let v: i32;</td><td>let mut p: *mut i32;</td><td>ano</td><td>ne</td><td>chyba</td><td>chyba</td><td>chyba</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>let mut v: i32;</td><td>let p: *const i32;</td><td>ano</td><td>ano</td><td>ano</td><td>ne</td><td>ne</td></tr>
<tr><td>let mut v: i32;</td><td>let mut p: *const i32;</td><td>ano</td><td>ano</td><td>ano</td><td>ne</td><td>ano</td></tr>
<tr><td>let mut v: i32;</td><td>let p: *mut i32;</td><td>ano</td><td>ano</td><td>ano</td><td>ano</td><td>ne</td></tr>
<tr><td>let mut v: i32;</td><td>let mut p: *mut i32;</td><td>ano</td><td>ano</td><td>ano</td><td>ano</td><td>ano</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Čtení či zápis do proměnné mimo oblast její životnosti?</h2>

<p>Programovací jazyk Rust (resp.&nbsp;přesněji řečeno jeho překladač) sice
hlídá mnoho operací prováděných s&nbsp;ukazateli, ovšem nedokáže (a
pravděpodobně to ani není prakticky možné) určit, zda ukazatel ještě obsahuje
adresu živé proměnné či zda se již proměnná nachází mimo oblast své platnosti.
Proto je možné přeložit <a
href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers05.rs">následující
program</a>, který může (ale také nemusí) fungovat, protože v&nbsp;poslední
části přistupujeme přes ukazatel k&nbsp;proměnné mimo oblast její
viditelnosti:</p>

<pre>
&nbsp;
fn main() {
    let pointer: <strong>*mut i32</strong>;
&nbsp;
    {
        let <strong>mut</strong> value: i32 = 42;
&nbsp;
        pointer = <strong>&amp;mut value</strong>;
&nbsp;
        println!("{}", value);
        unsafe {
            println!("{}", <strong>*pointer</strong>);
        }
&nbsp;
        value = 1;
&nbsp;
        println!("{}", value);
        unsafe {
            println!("{}", <strong>*pointer</strong>);
        }
&nbsp;
        unsafe {
            <strong>*pointer = 20</strong>;
        }
        println!("{}", value);
        unsafe {
            println!("{}", <strong>*pointer</strong>);
        }
    }
&nbsp;
    // !!!
    unsafe {
        <strong>*pointer = 99</strong>;
        println!("{}", <strong>*pointer</strong>);
    }
}
</pre>

<p>Poznámka: toto je asi největší praktický rozdíl mezi <i>referencemi</i> a
<i>ukazateli</i>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Ukazatel na datovou strukturu</h2>

<p>Ukazatel samozřejmě nemusí obsahovat jen adresu primitivní proměnné, ale i
adresu datové struktury. Opět se na chvíli vraťme k&nbsp;naší struktuře
s&nbsp;komplexními čísly, jejíž nejjednodušší varianta vypadá takto:</p>

<pre>
#[derive(Debug)]
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
    fn new(real: f32, imag: f32) -&gt; Complex {
        println!("Constructing complex number: {:}+{:}i", real, imag);
        Complex{real:real, imag:imag}
    }
}
</pre>

<p>Nyní si můžeme vytvořit novou proměnnou typu <i>Complex</i>, deklarovat
ukazatel na tuto datovou strukturu a naplnit ho. Pro zajímavost bude struktura
měnitelná a tudíž si můžeme dovolit vytvořit i ukazatel typu
<strong>*mut</strong>:</p>

<pre>
let mut value: Complex = Complex::new(1.0, 2.0);
let pointer: <strong>*mut Complex</strong>;
&nbsp;
pointer = <strong>&amp;mut value</strong>;
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přístup k&nbsp;prvkům struktury přes ukazatel</h2>

<p>Změna složek datové struktury přímo (přes příslušnou proměnnou) je
triviální:</p>

<pre>
value.real = 10.0;
value.imag = 20.0;
</pre>

<p>Totéž lze provést nepřímo přes ukazatel. Závorky pro dereferenci jsou
nutné:</p>

<pre>
unsafe {
    (*pointer).real = 20.0;
    (*pointer).imag = 40.0;
}
</pre>

<p>Poznámka: kupodivu zde <i>nelze</i> použít operátor -&gt;, což je škoda,
protože mi připadá mnohem čitelnější.</p>

<p>Celý příklad, v&nbsp;němž se použije ukazatel na strukturu typu
<strong>Complex</strong>, může vypadat takto:</p>

<pre>
#[derive(Debug)]
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
    fn new(real: f32, imag: f32) -&gt; Complex {
        println!("Constructing complex number: {:}+{:}i", real, imag);
        Complex{real:real, imag:imag}
    }
}
&nbsp;
fn main() {
    let mut value: Complex = Complex::new(1.0, 2.0);
    let pointer: *mut Complex;
&nbsp;
    pointer = &amp;mut value;
&nbsp;
    println!("{:?}", value);
    unsafe {
        println!("{:?}", *pointer);
    }
&nbsp;
    value.real = 10.0;
    value.imag = 20.0;
&nbsp;
    println!("{:?}", value);
    unsafe {
        println!("{:?}", *pointer);
    }
&nbsp;
    unsafe {
        (*pointer).real = 20.0;
        (*pointer).imag = 40.0;
    }
    println!("{:?}", value);
    unsafe {
        println!("{:?}", *pointer);
    }
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, ostatně podobně jako ve
všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>pointers01.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers01.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers01.rs</a></td></tr>
<tr><td>pointers02.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers02.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers02.rs</a></td></tr>
<tr><td>pointers02_inner_unsafe.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers02_inner_unsafe.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers02_inner_unsafe.rs</a></td></tr>
<tr><td>pointers02_no_unsafe.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers02_no_unsafe.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers02_no_unsafe.rs</a></td></tr>
<tr><td>pointers03.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers03.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers03.rs</a></td></tr>
<tr><td>pointers03_mut_all.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers03_mut_all.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers03_mut_all.rs</a></td></tr>
<tr><td>pointers03_mut_pointer.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers03_mut_pointer.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers03_mut_pointer.rs</a></td></tr>
<tr><td>pointers04.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers04.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers04.rs</a></td></tr>
<tr><td>pointers04_immut_var.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers04_immut_var.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers04_immut_var.rs</a></td></tr>
</table>

<p>Další příklady byly připraveny pro navazující část tohoto seriálu, takže jen
pro úplnost:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>pointers05.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers05.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers05.rs</a></td></tr>
<tr><td>pointers06.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers06.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers06.rs</a></td></tr>
<tr><td>pointers07.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers07.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers07.rs</a></td></tr>
<tr><td>pointers08.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers08.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers08.rs</a></td></tr>
<tr><td>pointers09.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers09.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers09.rs</a></td></tr>
<tr><td>pointers10.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers10.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers10.rs</a></td></tr>
<tr><td>pointers11.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers11.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers11.rs</a></td></tr>
<tr><td>pointers12.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers12.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers12.rs</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (nejnovější data)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

