<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Technologie mezijazyků (mezikódů) a bajtkódů v moderních interpretrech a překladačích: LLVM IR</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Technologie mezijazyků (mezikódů) a bajtkódů v moderních interpretrech a překladačích: LLVM IR</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Technologie mezijazyků (mezikódů) a bajtkódů v moderních interpretrech a překladačích: LLVM IR</a></p>
<p><a href="#k02">*** 2. LLVM IR</a></p>
<p><a href="#k03">3. Nejjednodušší kód přeložitelný do LLVM IR: prázdná funkce bez parametrů</a></p>
<p><a href="#k04">4. Překlad funkce <strong>noop</strong> do LLVM IR</a></p>
<p><a href="#k05">5. Rozdíly ve výsledném mezikódu</a></p>
<p><a href="#k06">6. Překlad do bitkódu</a></p>
<p><a href="#k07">7. Způsob překladu funkce provádějící součet dvou celých čísel bez znaménka</a></p>
<p><a href="#k08">8. Základní instrukce použité v&nbsp;LLVM IR</a></p>
<p><a href="#k09">*** 9. Jak číst kód v&nbsp;LLVM IR (první část)</a></p>
<p><a href="#k10">10. Překlad funkce pro součet dvou celočíselných hodnot se znaménkem: nedefinované chování</a></p>
<p><a href="#k11">11. Základní aritmetické operace a operace pro bitové posuny</a></p>
<p><a href="#k12">12. Instrukce pro aritmetické operace a pro provedení bitových posunů</a></p>
<p><a href="#k13">*** 13. Operace provádějící porovnání celočíselných operandů</a></p>
<p><a href="#k14">*** 14. Instrukce pro porovnání celočíselných operandů</a></p>
<p><a href="#k15">*** 15. Modifikace instrukcí při operacích s&nbsp;různými datovými typy</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. Příloha A: seznam doposud popsaných instrukcí používaných v&nbsp;LLVM IR</a></p>
<p><a href="#k18">18. Příloha B: Makefile soubor pro překlad všech demonstračních příkladů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Technologie mezijazyků (mezikódů) a bajtkódů v moderních interpretrech a překladačích: LLVM IR</h2>

<p><a href="https://www.root.cz/clanky/technologie-mezijazyku-a-bajtkodu-v-interpretrech-a-prekladacich/">V&nbsp;úvodním článku</a> o technologii mezijazyků a bajtkódu jsme si ve stručnosti popsali struktury bajtkódů využívaných virtuálními stroji jazyků Python, Lua a taktéž Javy. Ovšem mezijazyky se velmi často využívají i v&nbsp;oblasti sofistikovaných překladačů. Do této kategorie spadají i překladače, které jsou součástí infrastruktury postavené okolo <a href="https://www.llvm.org/">projektu LLVM</a>. Dnes si nejdříve ve stručnosti popíšeme, jakým způsobem probíhá překlad programů napsaných v&nbsp;programovacím jazyku C a překládaných s&nbsp;využitím <i>Clangu</i> do mezijazyka nazvaného <i>LLVM IR</i>. Posléze si popíšeme základní vlastnosti <i>LLVM IR</i>, které byly navrženy (a postupně rozšiřovány) takovým způsobem, aby na jedné straně pokryly sémantiku všech podporovaných programovacích jazyků (včetně například Rustu) a na straně druhé umožnily optimalizovaný překlad pro všechny cílové platformy (z&nbsp;nichž mnohé podporují pokročilé SIMD operace atd.).</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 283px"><a href="https://www.root.cz/obrazek/1270956/"><img src="https://i.iinfo.cz/images/377/mezikod-1.png" class="image-1270956" width="283" height="281" data-prev-filename="https://i.iinfo.cz/images/377/mezikod-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/377/mezikod-1-prev.webp" data-prev-width="272" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/377/mezikod-1.png" data-large-filename-webp="https://i.iinfo.cz/images/377/mezikod-1.webp" data-large-width="283" data-large-height="281" alt="Mezikód" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 283px" /></a><p>Obrázek 1: Pohled na činnost překladače, který je zde chápán jako černá skříňka, jež transformuje zdrojový kód na strojový kód nebo bajtkód.&#160;<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k02"></a></p>
<h2 id="k02">2. LLVM IR</h2>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 185px"><a href="https://www.root.cz/obrazek/1271184/"><img src="https://i.iinfo.cz/images/221/ir-im-2-1-large.png" class="image-1271184" width="185" height="525" data-prev-filename="https://i.iinfo.cz/images/221/ir-im-2-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/221/ir-im-2-1-prev.webp" data-prev-width="95" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/221/ir-im-2-1-large.png" data-large-filename-webp="https://i.iinfo.cz/images/221/ir-im-2-1-large.webp" data-large-width="185" data-large-height="525" alt="LLVM" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 185px" /></a><p>Obrázek 5: Fáze překladu v rodině Clang+LLVM s rozdělením na frontend a backend fáze. Uprostřed se nachází reprezentace založená na LLVM IR.&#160;<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nejjednodušší kód přeložitelný do LLVM IR: prázdná funkce bez parametrů</h2>

<p>V&nbsp;úvodní části dnešního článku si ukážeme, jak vlastně LLVM IR vypadá.
Začneme tím nejjednodušším zdrojovým kódem, který je přeložitelný do LLVM IR
bez toho, aby byl výsledkem kód bez instrukcí. Jedná se o céčkovskou funkci bez
parametrů, bez návratové hodnoty a s&nbsp;prázdným tělem. Z&nbsp;pohledu
programovacího jazyka C je to však plnohodnotná funkce, která je potenciálně
volatelná a bude tedy přeložena do LLVM IR (později však může být
v&nbsp;dalších fázích překladu zcela odstraněna):</p>

<pre>
void <strong>noop</strong>(void) {
}
</pre>

<p>Jméno <strong>noop</strong> použité v&nbsp;tomto kódu znamená <i>no-op</i>
neboli <i>no operation</i>, někdy též psáno <i>nop</i> (například
v&nbsp;assembleru atd.)</p>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop.c</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad funkce <strong>noop</strong> do LLVM IR</h2>

<p>Pro překlad zdrojových kódů z&nbsp;programovacího jazyka C do mezijazyka
LLVM IR se používá &bdquo;přední&ldquo; překladač <i>Clang</i>. Musíme ovšem
použít přepínače <strong>-S</strong> (překlad do čitelného textového formátu) a
<strong>-emit-llvm</strong>. Výsledkem překladu bude v&nbsp;takovém případě
soubor s&nbsp;koncovkou <strong>.ll</strong>.</p>

<p>Výsledek ovlivňují parametry překladu, především pak zvolené optimalizace
(nebo naopak jejich zákaz) a cílová architektura. Informace o cílové
architektuře se předávají do zadního překladače a současně mohou ovlivnit i to,
zde bude do LLVM IR zahrnut i &bdquo;mrtvý&ldquo; kód.</p>

<p>Při zákazu optimalizací a překladu na aktuální platformu (x86-64) získáme
tento soubor:</p>

<pre>
<i>; ModuleID = 'noop.c'</i>
source_filename = "noop.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-redhat-linux-gnu"
&nbsp;
<i>; Function Attrs: noinline nounwind optnone uwtable</i>
define dso_local void @<strong>noop</strong>() #0 {
  ret void
}
&nbsp;
attributes #0 = { noinline nounwind optnone uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
&nbsp;
!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}
&nbsp;
!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
!2 = !{i32 7, !"frame-pointer", i32 2}
!3 = !{!"clang version 20.1.8 (Fedora 20.1.8-4.fc42)"}
</pre>

<p>Překladem s&nbsp;povolením optimalizací na velikost,
tj.&nbsp;<strong>-Os</strong> vznikne soubor:</p>

<pre>
<i>; ModuleID = 'noop.c'</i>
source_filename = "noop.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-redhat-linux-gnu"
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local void @<strong>noop</strong>() local_unnamed_addr #0 {
  ret void
}
&nbsp;
attributes #0 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
&nbsp;
!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}
&nbsp;
!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
!2 = !{!"clang version 20.1.8 (Fedora 20.1.8-4.fc42)"}
</pre>

<p>Ovšem můžeme provést i překlad pro jiné platformy, například přepínačem
<strong>--target=aarch64</strong> překlad pro ARMovskou architekturu AArch64.
Mezikód bude opět odlišný:</p>

<pre>
<i>; ModuleID = 'noop.c'</i>
source_filename = "noop.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32"
target triple = "aarch64"
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local void @<strong>noop</strong>() local_unnamed_addr #0 {
  ret void
}
&nbsp;
attributes #0 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+v8a,-fmv" }
&nbsp;
!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}
&nbsp;
!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
!2 = !{i32 7, !"frame-pointer", i32 1}
!3 = !{!"clang version 20.1.8 (Fedora 20.1.8-4.fc42)"}
</pre>

<p>A konečně si ukažme překlad pro (pseudo)architekturu WebAssembly, kterou
zajistíme přepínačem <strong>--target=wasm32</strong>:</p>

<pre>
<i>; ModuleID = 'noop.c'</i>
source_filename = "noop.c"
target datalayout = "e-m:e-p:32:32-p10:8:8-p20:8:8-i64:64-i128:128-n32:64-S128-ni:1:10:20"
target triple = "wasm32"
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none)</i>
define hidden void @<strong>noop</strong>() local_unnamed_addr #0 {
  ret void
}
&nbsp;
attributes #0 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+bulk-memory,+bulk-memory-opt,+call-indirect-overlong,+multivalue,+mutable-globals,+nontrapping-fptoint,+reference-types,+sign-ext" }
&nbsp;
!llvm.module.flags = !{!0}
!llvm.ident = !{!1}
&nbsp;
!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 20.1.8 (Fedora 20.1.8-4.fc42)"}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozdíly ve výsledném mezikódu</h2>

<p>Jak je <a href="#k04">z&nbsp;předchozích ukázek</a> patrné, obsahuje mezikód
kromě dalších údajů i velké množství metainformací, které se předávají zadnímu
překladači. Nás ovšem bude zajímat především ta část LLVM IR, ve které je
vypsán mezikód překládané funkce <strong>noop</strong>. Uveďme si tedy výsledky
jednotlivých variant překladu.</p>

<p>Překlad bez povolení optimalizací:</p>

<pre>
<i>; Function Attrs: noinline nounwind optnone uwtable</i>
define dso_local void @<strong>noop</strong>() #0 {
  ret void
}
</pre>

<p>Překlad s&nbsp;povolením optimalizací. Zde se objevuje klauzule
<strong>local_unnamed_addr</strong>, která zadnímu překladači oznamuje, že
funkce není volána a mohl by ji tedy při optimalizacích vynechat:</p>

<pre>
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local void @<strong>noop</strong>() local_unnamed_addr #0 {
  ret void
}
</pre>

<p>Překlad pro platformu AArch64 s&nbsp;povolením optimalizací povede
k&nbsp;naprosto totožné funkci reprezentované v&nbsp;mezikódu:</p>

<pre>
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local void @<strong>noop</strong>() local_unnamed_addr #0 {
  ret void
}
</pre>

<p>Překlad pro platformu WebAssembly s&nbsp;povolením optimalizací. Chybí zde
atribut <strong>uwtable</strong>, který je vyžadován pro formát ELF, ale nikoli
pro WebAssemly:</p>

<pre>
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none)</i>
define hidden void @<strong>noop</strong>() local_unnamed_addr #0 {
  ret void
}
</pre>

<p>Samotné tělo funkce a do značné míry i její hlavička, jsou ve všech čtyřech
případech totožné, ovšem poměrně zásadně se odlišují atributy funkce vypsané na
řádku před její hlavičkou.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překlad do bitkódu</h2>

<p>LLVM IR má dvě formy reprezentace. První forma je textová a viděli jsme ji
v&nbsp;předchozí dvojici kapitol. Druhá forma je binární a nazývá se
<i>bitkód</i> (<i>bitcode</i>). Tato forma je popsána <a
href="https://en.wikipedia.org/wiki/NOP_(code)">zde</a> a získat ji můžeme
překladem při použití přepínačů <strong>-c</strong> a
<strong>-emit-llvm</strong>:</p>

<pre>
$ <strong>clang -c -emit-llvm noop.c</strong>
</pre>

<p>Výsledkem bude v&nbsp;tomto případě soubor nazvaný <strong>noop.bc</strong>
s&nbsp;velikostí přibližně dvou kilobajtů:</p>

<pre>
$ <strong>file noop.bc</strong>
noop.bc: LLVM IR bitcode
&nbsp;
$ <strong>ls -l noop.bc</strong>
-rw-r--r--. 1 ptisnovs ptisnovs 2196 Jan 29 14:28 noop.bc
</pre>

<p>Obsah tohoto souboru je obecně nečitelný (binární):</p>

<pre>
$ <strong>od -tx1 noop.bc | head</strong>
&nbsp;
0000000 42 43 c0 de 35 14 00 00 05 00 00 00 62 0c 30 24
0000020 4a 59 be a6 4d fb b5 cf 0b 51 80 4c 01 00 00 00
0000040 21 0c 00 00 eb 01 00 00 0b 02 21 00 02 00 00 00
0000060 19 00 00 00 07 81 23 91 41 c8 04 49 06 10 32 39
0000100 92 01 84 0c 25 05 08 19 1e 04 8b 62 80 0c 45 02
0000120 42 92 0b 42 64 10 32 14 38 08 18 4b 0a 32 32 88
0000140 48 70 c4 21 23 44 12 87 8c 10 41 92 02 64 c8 08
0000160 b1 14 20 43 46 88 20 c9 01 32 32 84 58 0e 90 91
0000200 21 44 90 a1 82 a2 02 19 c3 07 cb 15 19 32 8c 8c
0000220 25 10 1d 3a 74 c8 00 00 89 20 00 00 0a 00 00 00
</pre>

<p><div class="rs-tip-major">Poznámka: bitkódem se prozatím nebudeme zabývat.
V&nbsp;dalším textu budeme vždy využívat textovou reprezentaci LLVM
IR.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Způsob překladu funkce provádějící součet dvou celých čísel bez znaménka</h2>

<p>Pro studium mezijazyka LLVM IR je pochopitelně vhodnější použít funkce se
složitější vnitřní strukturou, než jakou má výše zmíněná funkce
<strong>noop</strong>. Naprogramujeme tedy funkci nazvanou jednoduše
<strong>add</strong>, která provede součet svých dvou parametrů typu <i>celé
číslo bez znaménka</i> a vrátí výsledek tohoto součtu:</p>

<pre>
unsigned int <strong>add</strong>(unsigned int x, unsigned int y) {
    return x+y;
}
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_unsigned.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_unsigned.c</a>.</div></p>

<p>Pokud jsou při překladu zakázány optimalizace, bude výsledek v&nbsp;mezikódu
vypadat takto:</p>

<pre>
<i>; Function Attrs: noinline nounwind optnone uwtable</i>
define dso_local i32 @<strong>add</strong>(i32 noundef %0, i32 noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  store i32 %0, ptr %3, align 4
  store i32 %1, ptr %4, align 4
  %5 = load i32, ptr %3, align 4
  %6 = load i32, ptr %4, align 4
  %7 = add i32 %5, %6
  ret i32 %7
}
</pre>

<p>Při povolení optimalizací (a je jedno, jestli na velikost nebo na rychlost)
získáme následující výsledek:</p>

<pre>
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i32 @<strong>add</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = add i32 %1, %0
  ret i32 %3
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že před jménem funkce
<strong>add</strong> je uveden symbol @, který se v&nbsp;LLVM IR nazývá
<i>sigil</i> a je použit před každým symbolem získaným z&nbsp;původního
zdrojového kódu. Taktéž si povšimněte, že LLVM IR je typovaný &ndash; typ má
jak funkce <strong>add</strong>, tak i oba její (nepojmenované) parametry
označované symboly %0 a %1.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní instrukce použité v&nbsp;LLVM IR</h2>

<p>V&nbsp;obou variantách funkce <strong>add</strong> přeložené do LLVM IR je
možné najít hned šest různých typů instrukcí. Tyto instrukce jsou vypsány
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Jméno instrukce</th><th>Parametry</th><th>Stručný popis instrukce</th></tr>
<tr><td>1</td><td>alloca</td><td>typ (velikost)</td><td>alokace místa na zásobníku</td></tr>
<tr><td>2</td><td>load</td><td>adresa</td><td>načtení hodnoty z&nbsp;paměti</td></tr>
<tr><td>3</td><td>store</td><td>hodnota, adresa</td><td>uložení hodnoty do paměti</td></tr>
<tr><td>4</td><td>add</td><td>hodnota1, hodnota2</td><td>součet dvou hodnot</td></tr>
<tr><td>5</td><td>ret</td><td>hodnota</td><td>návrat z&nbsp;funkce</td></tr>
</table>

<p>Některé instrukce připomínají klasický assembler, ovšem s&nbsp;tím rozdílem,
že jejich operandy jsou typovány (<strong>i32</strong>, <strong>ptr</strong>
atd.)::</p>

<pre>
  store i32 %0, ptr %3, align 4
  ...
  ...
  ...
  ret i32 %7
</pre>

<p>Povšimněte si dále, že další instrukce jsou použity na levé straně
přiřazovacího výrazu. Jedná se o takové instrukce, které nějakým způsobem
vyhodnocují výslednou hodnotu. Ta se ukládá do (v&nbsp;tomto případě
nepojmenovaného) slotu označovaného symbolem <strong>%x</strong>. Může se
jednat buď o globální hodnotu, hodnotu naalokovanou na zásobníkovém rámci, nebo
o (lokální) pracovní registr &ndash; o tom se do značné míry rozhoduje až
v&nbsp;další fázi překladu:</p>

<pre>
  %3 = alloca i32, align 4
  ...
  ...
  ...
  %5 = load i32, ptr %3, align 4
  ...
  ...
  ...
  %7 = add i32 %5, %6
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Jak číst kód v&nbsp;LLVM IR (první část)</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Překlad funkce pro součet dvou celočíselných hodnot se znaménkem: nedefinované chování</h2>

<p>Předchozí příklad nyní upravíme do takové podoby, aby se namísto
celočíselných hodnot bez znaménka (<i>unsigned</i>) sčítaly celočíselné hodnoty
se znaménkem (<i>signed</i>). Jedná se tedy o (alespoň zdánlivě) triviální
úpravu, která by neměla přinášet žádné další problémy:</p>

<pre>
int <strong>add</strong>(int x, int y) {
    return x+y;
}
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_signed.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_signed.c</a>.</div></p>

<p>Překlad do LLVM IR bude v&nbsp;tomto případě vypadat následovně:</p>

<pre>
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @<strong>add</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = add nsw i32 %1, %0
  ret i32 %3
}
</pre>

<p>Překlad je prakticky totožný, ovšem namísto instrukce:</p>

<pre>
  %3 = add i32 %1, %0
</pre>

<p>zde můžeme vidět instrukci:</p>

<pre>
  %3 = add nsw i32 %1, %0
</pre>

<p>Modifikátor <strong>nsw</strong> označuje instrukci, která má (pro některé
vstupní operandy) nedefinované chování neboli <i>undefined behaviour</i>. To
zadnímu překladači umožňuje provádět různé více či méně sofistikované
optimalizace, například neprovádět test na přetečení (<i>overflow</i>) na
některých architekturách atd. Vše je přitom naprosto korektní, protože
z&nbsp;pohledu specifikace programovacího jazyka C se opravdu o nedefinované
chování jedná.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Základní aritmetické operace a operace pro bitové posuny</h2>

<p>LLVM IR musí obsahovat i instrukce určené pro provádění aritmetických
operací popř.&nbsp;bitových posunů. Prozatím jsme se seznámili jen
s&nbsp;instrukcí <strong>add</strong>, takže si vyzkoušejme, jakým způsobem se
přeloží zdrojový kód obsahující další aritmetické operace a operace pro bitové
posuny. Použijeme makra, aby nebylo nutné ručně zapisovat funkce pro všechny
datové typy parametrů atd.:</p>

<pre>
#define <strong>NEG</strong>NEG(type) type neg_##type(type x) {return -x;}
#define <strong>ADD</strong>ADD(type) type add_##type(type x, type y) {return x+y;}
#define <strong>SUB</strong>SUB(type) type sub_##type(type x, type y) {return x-y;}
#define <strong>MUL</strong>MUL(type) type mul_##type(type x, type y) {return x*y;}
#define <strong>DIV</strong>DIV(type) type div_##type(type x, type y) {return x/y;}
#define <strong>SHL</strong>SHL(type) type shl_##type(type x, type y) {return x&lt;&lt;y;}
#define <strong>SHR</strong>SHR(type) type shr_##type(type x, type y) {return x&gt;&gt;y;}
&nbsp;
#define <strong>ALL</strong>(type) \
    NEG(type) \
    ADD(type) \
    SUB(type) \
    MUL(type) \
    DIV(type) \
    SHL(type) \
    SHR(type)
&nbsp;
ALL(int)
ALL(unsigned)
</pre>

<p>Výsledek činnosti preprocesoru jazyka C:</p>

<pre>
int <strong>neg_int</strong>(int x) {return -x;}
int <strong>add_int</strong>(int x, int y) {return x+y;}
int <strong>sub_int</strong>(int x, int y) {return x-y;}
int <strong>mul_int</strong>(int x, int y) {return x*y;}
int <strong>div_int</strong>(int x, int y) {return x/y;}
int <strong>shl_int</strong>(int x, int y) {return x&lt;&lt;y;}
int <strong>shr_int</strong>(int x, int y) {return x&gt;&gt;y;}
&nbsp;
unsigned <strong>neg_unsigned</strong>(unsigned x) {return -x;}
unsigned <strong>add_unsigned</strong>(unsigned x, unsigned y) {return x+y;}
unsigned <strong>sub_unsigned</strong>(unsigned x, unsigned y) {return x-y;}
unsigned <strong>mul_unsigned</strong>(unsigned x, unsigned y) {return x*y;}
unsigned <strong>div_unsigned</strong>(unsigned x, unsigned y) {return x/y;}
unsigned <strong>shl_unsigned</strong>(unsigned x, unsigned y) {return x&lt;&lt;y;}
unsigned <strong>shr_unsigned</strong>(unsigned x, unsigned y) {return x&gt;&gt;y;}
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/arith_operators.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/arith_operators.c</a>.</div></p>

<p>Výsledek překladu do LLVM IR:</p>

<pre>
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 -2147483647, -2147483648) i32 @<strong>neg_int</strong>(i32 noundef %0) local_unnamed_addr #0 {
  %2 = sub nsw i32 0, %0
  ret i32 %2
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @<strong>add_int</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = add nsw i32 %1, %0
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @<strong>sub_int</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = sub nsw i32 %0, %1
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @<strong>mul_int</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = mul nsw i32 %1, %0
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i32 @<strong>div_int</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = sdiv i32 %0, %1
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @<strong>shl_int</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = shl i32 %0, %1
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @<strong>shr_int</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = ashr i32 %0, %1
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i32 @<strong>neg_unsigned</strong>(i32 noundef %0) local_unnamed_addr #0 {
  %2 = sub i32 0, %0
  ret i32 %2
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i32 @<strong>add_unsigned</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = add i32 %1, %0
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i32 @<strong>sub_unsigned</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = sub i32 %0, %1
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i32 @<strong>mul_unsigned</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = mul i32 %1, %0
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i32 @<strong>div_unsigned</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = udiv i32 %0, %1
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @<strong>shl_unsigned</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = shl i32 %0, %1
  ret i32 %3
}
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @<strong>shr_unsigned</strong>(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = lshr i32 %0, %1
  ret i32 %3
}
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavá je hlavička první funkce
s&nbsp;modifikátorem <strong>range</strong>, který bude popsán
příště:</div></p>

<pre>
define dso_local range(i32 -2147483647, -2147483648) i32 @<strong>neg_int</strong>(i32 noundef %0) local_unnamed_addr #0 {
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Instrukce pro aritmetické operace a pro provedení bitových posunů</h2>

<p><a href="#k11">Z&nbsp;předchozího</a> kódu reprezentovaného v&nbsp;LLVM IR
lze snadno vyčíst názvy všech instrukcí určených pro provádění aritmetických
operací i bitových posunů. Všechny tyto instrukce jsou shrnuty
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Jméno instrukce</th><th>Parametry</th><th>Stručný popis instrukce</th></tr>
<tr><td>1</td><td>add</td><td>hodnota1, hodnota2</td><td>součet dvou hodnot</td></tr>
<tr><td>2</td><td>sub</td><td>hodnota1, hodnota2</td><td>rozdíl dvou hodnot</td></tr>
<tr><td>3</td><td>mul</td><td>hodnota1, hodnota2</td><td>součin dvou hodnot</td></tr>
<tr><td>4</td><td>sdiv</td><td>hodnota1, hodnota2</td><td>podíl dvou hodnot, které mají znaménko (<i>signed</i>)</td></tr>
<tr><td>5</td><td>udiv</td><td>hodnota1, hodnota2</td><td>podíl dvou hodnot, které jsou bezznaménkové (<i>unsigned</i>)</td></tr>
<tr><td>6</td><td>shl</td><td>hodnota, posun</td><td>aritmetický či bitový posun doleva</td></tr>
<tr><td>7</td><td>ashr</td><td>hodnota, posun</td><td>aritmetický posun doprava</td></tr>
<tr><td>8</td><td>lshr</td><td>hodnota, posun</td><td>bitový posun doprava</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: operace změny znaménka byla přeložena
jako <strong>sub 0, operand</strong>; nejedná se tedy o samostatnou instrukci
(na rozdíl od některých assemblerů resp.&nbsp;přesněji řečeno
mikroprocesorů).</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Operace provádějící porovnání celočíselných operandů</h2>

<p></p>

<pre>
#define EQ(type) type eq_##type(type x, type y) {return x==y;}
#define NE(type) type ne_##type(type x, type y) {return x!=y;}
#define LT(type) type lt_##type(type x, type y) {return x<y;}
#define LE(type) type le_##type(type x, type y) {return x<=y;}
#define GT(type) type gt_##type(type x, type y) {return x>y;}
#define GE(type) type ge_##type(type x, type y) {return x>=y;}

#define ALL(type) \
    EQ(type) \
    NE(type) \
    LT(type) \
    LE(type) \
    GT(type) \
    GE(type)

ALL(int)
ALL(unsigned)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/comparison_operators.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/comparison_operators.c</a>.</div></p>

<pre>
</pre>

<pre>
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @eq_int(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp eq i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @ne_int(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp ne i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @lt_int(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp slt i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @le_int(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp sle i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @gt_int(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp sgt i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @ge_int(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp sge i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @eq_unsigned(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp eq i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @ne_unsigned(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp ne i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @lt_unsigned(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp ult i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @le_unsigned(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp ule i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @gt_unsigned(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp ugt i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local range(i32 0, 2) i32 @ge_unsigned(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = icmp uge i32 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce pro porovnání celočíselných operandů</h2>

<p></p>




<p><a name="k15"></a></p>
<h2 id="k15">15. Modifikace instrukcí při operacích s&nbsp;různými datovými typy</h2>

<p></p>

<pre>
#include <stdint.h>

#define ADD(type) type add_##type(type x, type y) {return x+y;}

ADD(int8_t)
ADD(int16_t)
ADD(int32_t)
ADD(int64_t)

ADD(uint8_t)
ADD(uint16_t)
ADD(uint32_t)
ADD(uint64_t)

ADD(float)
ADD(double)
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/numeric_types.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/numeric_types.c</a>.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>

<pre>
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef signext i8 @add_int8_t(i8 noundef signext %0, i8 noundef signext %1) local_unnamed_addr #0 {
  %3 = add i8 %1, %0
  ret i8 %3
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef signext i16 @add_int16_t(i16 noundef signext %0, i16 noundef signext %1) local_unnamed_addr #0 {
  %3 = add i16 %1, %0
  ret i16 %3
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @add_int32_t(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = add nsw i32 %1, %0
  ret i32 %3
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i64 @add_int64_t(i64 noundef %0, i64 noundef %1) local_unnamed_addr #0 {
  %3 = add nsw i64 %1, %0
  ret i64 %3
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef zeroext i8 @add_uint8_t(i8 noundef zeroext %0, i8 noundef zeroext %1) local_unnamed_addr #0 {
  %3 = add i8 %1, %0
  ret i8 %3
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef zeroext i16 @add_uint16_t(i16 noundef zeroext %0, i16 noundef zeroext %1) local_unnamed_addr #0 {
  %3 = add i16 %1, %0
  ret i16 %3
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i32 @add_uint32_t(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = add i32 %1, %0
  ret i32 %3
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i64 @add_uint64_t(i64 noundef %0, i64 noundef %1) local_unnamed_addr #0 {
  %3 = add i64 %1, %0
  ret i64 %3
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef float @add_float(float noundef %0, float noundef %1) local_unnamed_addr #0 {
  %3 = fadd float %0, %1
  ret float %3
}

<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef double @add_double(double noundef %0, double noundef %1) local_unnamed_addr #0 {
  %3 = fadd double %0, %1
  ret double %3
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příloha A: seznam doposud popsaných instrukcí používaných v&nbsp;LLVM IR</h2>

<p>V&nbsp;tabulce vypsané pod tímto odstavcem jsou vypsány všechny doposud
popsané a použité instrukce LLVM IR:</p>

<table>
<tr><th> #</th><th>Jméno instrukce</th><th>Parametry</th><th>Stručný popis instrukce</th></tr>
<tr><td> 1</td><td>alloca</td><td>typ (velikost)</td><td>alokace místa na zásobníku</td></tr>
<tr><td> 2</td><td>load</td><td>adresa</td><td>načtení hodnoty z&nbsp;paměti</td></tr>
<tr><td> 3</td><td>store</td><td>hodnota, adresa</td><td>uložení hodnoty do paměti</td></tr>
<tr><td> 5</td><td>ret</td><td>hodnota</td><td>návrat z&nbsp;funkce</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>add</td><td>hodnota1, hodnota2</td><td>součet dvou hodnot</td></tr>
<tr><td> 7</td><td>sub</td><td>hodnota1, hodnota2</td><td>rozdíl dvou hodnot</td></tr>
<tr><td> 8</td><td>mul</td><td>hodnota1, hodnota2</td><td>součin dvou hodnot</td></tr>
<tr><td> 9</td><td>sdiv</td><td>hodnota1, hodnota2</td><td>podíl dvou hodnot, které mají znaménko (<i>signed</i>)</td></tr>
<tr><td>10</td><td>udiv</td><td>hodnota1, hodnota2</td><td>podíl dvou hodnot, které jsou bezznaménkové (<i>unsigned</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>shl</td><td>hodnota, posun</td><td>aritmetický či bitový posun doleva</td></tr>
<tr><td>12</td><td>ashr</td><td>hodnota, posun</td><td>aritmetický posun doprava</td></tr>
<tr><td>13</td><td>lshr</td><td>hodnota, posun</td><td>bitový posun doprava</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha B: Makefile soubor pro překlad všech demonstračních příkladů</h2>

<p>Všechny demonstrační příklady využívající překladač <i>Clang</i>, které byly
použity v&nbsp;dnešním článku, je možné přeložit do mezijazyka LLVM IR
s&nbsp;využitím souboru <strong>Makefile</strong>, jehož obsah je vypsán pod
tímto odstavcem:</p>

<pre>
CC=clang
&nbsp;
<strong>outputs</strong> := noop.ll noop_no_opt.ll noop_wasm.ll noop_aarch64.ll \
           add_unsigned.ll add_unsigned_no_opt.ll \
           add_signed.ll numeric_types.ll \
           arith_operators.ll comparison_operators.ll \
           branching_1.ll branching_2.ll pointers_1.ll pointers_2.ll \
           add_arrays_1.ll add_arrays_2.ll \
           fibonacci.ll
&nbsp;
<strong>all</strong>:    $(outputs)
&nbsp;
<strong>clean</strong>:
        rm -f *.ll
&nbsp;
.PHONY: all clean
&nbsp;
&nbsp;
<strong>%.ll</strong>:   %.c
        $(CC) -Os -S -emit-llvm $&lt; -o $@
&nbsp;
<strong>add_unsigned_no_opt.ll</strong>: add_unsigned.c
        $(CC) -S -emit-llvm $&lt; -o $@
&nbsp;
<strong>noop_no_opt.ll</strong>: noop.c
        $(CC) -S -emit-llvm $&lt; -o $@
&nbsp;
<strong>noop_wasm.ll</strong>:   noop.c
        $(CC) -Os -S -emit-llvm --target=wasm32 $&lt; -o $@
&nbsp;
<strong>noop_aarch64.ll</strong>:        noop.c
        $(CC) -Os -S -emit-llvm --target=aarch64 $&lt; -o $@
</pre>

<p>Pro překlad všech demonstračních příkladů postačuje zadat příkaz:</p>

<pre>
$ <strong>make</strong>
</pre>

<p>Pro smazání všech vytvářených souborů s&nbsp;LLVM IR (mají koncovku .ll)
použijte příkaz:</p>

<pre>
$ <strong>make clean</strong>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady, s&nbsp;nimiž jsme se v&nbsp;dnešním článku seznámili
a které jsou určeny pro překlad s&nbsp;využitím Clangu, jsou dostupné, jak je
zvykem, na GitHubu. V&nbsp;tabulce níže jsou uvedeny odkazy na jednotlivé
zdrojové kódy psané v&nbsp;jazyku C i soubory v&nbsp;mezijazyku LLVM IR získané
překladem Clangem:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td> 1</td><td>Makefile</td><td>definice cílů pro překlad všech demonstračních příkladů z&nbsp;této tabulky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/Makefile">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>noop.c</td><td>prázdná funkce bez parametrů nevracející žádnou hodnotu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop.c</a></td></tr>
<tr><td> 3</td><td>noop_no_opt.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka bez provádění optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop_no_opt.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop_no_opt.ll</a></td></tr>
<tr><td> 4</td><td>noop.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka s&nbsp;provedením optimalizací na velikost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop.ll</a></td></tr>
<tr><td> 5</td><td>noop_aarch64.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka se specifikami platformy AArch64</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop_aarch64.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop_aarch64.ll</a></td></tr>
<tr><td> 6</td><td>noop_wasm.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka se specifikami platformy WebAssembly</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop_wasm.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/noop_wasm.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>add_unsigned.c</td><td>funkce pro součet dvou celých čísel bez znaménka (<i>unsigned</i>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_unsigned.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_unsigned.c</a></td></tr>
<tr><td> 8</td><td>add_unsigned_no_opt.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka bez provedení optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_unsigned_no_opt.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_unsigned_no_opt.ll</a></td></tr>
<tr><td> 9</td><td>add_unsigned.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka s&nbsp;provedením optimalizací na velikost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_unsigned.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_unsigned.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>add_signed.c</td><td>funkce pro výpočet dvou celých čísel se znaménkem (<i>signed</i>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_signed.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_signed.c</a></td></tr>
<tr><td>11</td><td>add_signed.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_signed.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_signed.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>arith_operators.c</td><td>aritmetické operátory programovacího jazyka C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/arith_operators.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/arith_operators.c</a></td></tr>
<tr><td>13</td><td>arith_operators.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/arith_operators.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/arith_operators.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>numeric_types.c</td><td>práce se základními numerickými datovými typy v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/numeric_types.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/numeric_types.c</a></td></tr>
<tr><td>15</td><td>numeric_types.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/numeric_types.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/numeric_types.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>comparison_operators.c</td><td>relační operátory programovacího jazyka C použité ve výrazech</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/comparison_operators.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/comparison_operators.c</a></td></tr>
<tr><td>17</td><td>comparison_operators.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/comparison_operators.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/comparison_operators.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>pointers_1.c</td><td>základní práce s&nbsp;ukazateli v&nbsp;programovacím jazyku C, první demonstrační příklad</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/pointers_1.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/pointers_1.c</a></td></tr>
<tr><td>19</td><td>pointers_1.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/pointers_1.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/pointers_1.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>pointers_2.c</td><td>základní práce s&nbsp;ukazateli v&nbsp;programovacím jazyku C, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/pointers_2.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/pointers_2.c</a></td></tr>
<tr><td>21</td><td>pointers_2.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/pointers_2.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/pointers_2.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>branching_1.c</td><td>rozeskoky vzniklé překladem podmíněných konstrukcí a programových smyček, první demonstrační příklad</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/branching_1.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/branching_1.c</a></td></tr>
<tr><td>23</td><td>branching_1.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/branching_1.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/branching_1.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>branching_2.c</td><td>rozeskoky vzniklé překladem podmíněných konstrukcí a programových smyček, druhý demonstrační příklad</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/branching_2.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/branching_2.c</a></td></tr>
<tr><td>25</td><td>branching_2.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/branching_2.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/branching_2.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>add_arrays_1.c</td><td>součet prvků polí, předání polí odkazem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_arrays_1.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_arrays_1.c</a></td></tr>
<tr><td>27</td><td>add_arrays_1.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_arrays_1.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_arrays_1.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>add_arrays_2.c</td><td>součet prvků polí, specifikace aliasingu předávaných odkazů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_arrays_2.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_arrays_2.c</a></td></tr>
<tr><td>29</td><td>add_arrays_2.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_arrays_2.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/add_arrays_2.ll</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>fibonacci.c</td><td>výpočet Fibonacciho posloupnosti</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/fibonacci.c">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/fibonacci.c</a></td></tr>
<tr><td>31</td><td>fibonacci.ll</td><td>výsledek překladu céčkovského zdrojového kódu do mezijazyka</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/fibonacci.ll">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/fibonacci.ll</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Is intermediate representation (such as bytecodes or .net IL) still an advantage?<br />
<a href="https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage">https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage</a>
</li>

<li>Intermediate Representation vs Byte Code<br />
<a href="https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code">https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code</a>
</li>

<li>Getting the intermediate representation in gcc<br />
<a href="https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2">https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2</a>
</li>

<li>Intermediate Representations<br />
<a href="https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/">https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/</a>
</li>

<li>Why do we use intermediate representations / languages?<br />
<a href="https://mortoray.com/why-we-use-intermediate-representations/">https://mortoray.com/why-we-use-intermediate-representations/</a>
</li>

<li>Unwrapping intermediate representations<br />
<a href="https://mortoray.com/unwrapping-intermediate-representations/">https://mortoray.com/unwrapping-intermediate-representations/</a>
</li>

<li>Understanding Python Code Flow From Source to Execution<br />
<a href="https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83">https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83</a>
</li>

<li>Why most compilers use AST, instead generate IR directly?<br />
<a href="https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159">https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159</a>
</li>

<li>A Gentle Introduction to LLVM IR<br />
<a href="https://mcyoung.xyz/2023/08/01/llvm-ir/">https://mcyoung.xyz/2023/08/01/llvm-ir/</a>
</li>

<li>Why does the compiler need the intermediate representations for link time optimization?<br />
<a href="https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi">https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi</a>
</li>

<li>pyrefact na PyPi<br />
<a href="https://pypi.org/project/pyrefact/">https://pypi.org/project/pyrefact/</a>
</li>

<li>Repositář projektu pyrefact<br />
<a href="https://github.com/OlleLindgren/pyrefact">https://github.com/OlleLindgren/pyrefact</a>
</li>

<li>pyrefact jako plugin do VSCode<br />
<a href="https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact">https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact</a>
</li>

<li>pyrefact-vscode-extension (repositář)<br />
<a href="https://github.com/OlleLindgren/pyrefact-vscode-extension">https://github.com/OlleLindgren/pyrefact-vscode-extension</a>
</li>

<li>Best Python Refactoring Tools for 2023<br />
<a href="https://www.developer.com/languages/python/best-python-refactoring-tools/">https://www.developer.com/languages/python/best-python-refactoring-tools/</a>
</li>

<li>Python Refactoring: Techniques, Tools, and Best Practices<br />
<a href="https://www.codesee.io/learning-center/python-refactoring">https://www.codesee.io/learning-center/python-refactoring</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů jazyka Python (4.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/</a>
</li>

<li>Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu<br />
<a href="https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/">https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/</a>
</li>

<li>LibCST &ndash; dokumentace<br />
<a href="https://libcst.readthedocs.io/en/latest/index.html">https://libcst.readthedocs.io/en/latest/index.html</a>
</li>

<li>libCST na PyPi<br />
<a href="https://pypi.org/project/libcst/">https://pypi.org/project/libcst/</a>
</li>

<li>libCST na GitHubu<br />
<a href="https://github.com/Instagram/LibCST">https://github.com/Instagram/LibCST</a>
</li>

<li>Inside The Python Virtual Machine<br />
<a href="https://leanpub.com/insidethepythonvirtualmachine">https://leanpub.com/insidethepythonvirtualmachine</a>
</li>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Golang Compilation and Execution<br />
<a href="https://golangtutorial.com/golang-compilation-and-execution/">https://golangtutorial.com/golang-compilation-and-execution/</a>
</li>

<li>Mezijazyk (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/Mezijazyk">https://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://www.llvm.org/">https://www.llvm.org/</a>
</li>

<li>GCC internals<br />
<a href="https://gcc.gnu.org/onlinedocs/gccint/index.html">https://gcc.gnu.org/onlinedocs/gccint/index.html</a>
</li>

<li>GCC Developer Options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html">https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html</a>
</li>

<li>What is Gimple?<br />
<a href="https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/">https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/</a>
</li>

<li>The Conceptual Structure of GCC<br />
<a href="https://www.cse.iitb.ac.in/grc/intdocs/gcc-conceptual-structure.html">https://www.cse.iitb.ac.in/grc/intdocs/gcc-conceptual-structure.html</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojů využívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (před verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>SymbolTable<br />
<a href="https://docs.python.org/3.8/library/symtable.html">https://docs.python.org/3.8/library/symtable.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

<li>Playing with GCC’s GIMPLE: How to Generate, Save, and Modify Intermediate Code (Tutorial + Examples)<br />
<a href="https://www.tutorialpedia.org/blog/playing-with-gcc-s-intermediate-gimple-format/">https://www.tutorialpedia.org/blog/playing-with-gcc-s-intermediate-gimple-format/</a>
</li>

<li>A Deep Dive Into LLVM IR<br />
<a href="https://medium.com/@abdulraheembeigh/a-deep-dive-into-llvm-ir-b5aa81beb474">https://medium.com/@abdulraheembeigh/a-deep-dive-into-llvm-ir-b5aa81beb474</a>
</li>

<li>Nulová operace<br />
<a href="https://cs.wikipedia.org/wiki/Nulov%C3%A1_operace">https://cs.wikipedia.org/wiki/Nulov%C3%A1_operace</a>
</li>

<li>NOP (code)<br />
<a href="https://en.wikipedia.org/wiki/NOP_(code)">https://en.wikipedia.org/wiki/NOP_(code)</a>
</li>

<li>LLVM Bitcode File Format<br />
<a href="https://llvm.org/docs/BitCodeFormat.html">https://llvm.org/docs/BitCodeFormat.html</a>
</li>

<li>LLVM IR Language Reference<br />
<a href="https://deepwiki.com/llvm-mirror/llvm/2.1-llvm-ir-language-reference">https://deepwiki.com/llvm-mirror/llvm/2.1-llvm-ir-language-reference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2026</small></p>
</body>

</html>

