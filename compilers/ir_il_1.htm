<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Technologie mezijazyků (mezikódů) a bajtkódů v moderních interpretrech a překladačích</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Technologie mezijazyků (mezikódů) a bajtkódů v moderních interpretrech a překladačích</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Technologie mezijazyků (mezikódů) a bajtkódů v&nbsp;moderních interpretrech a překladačích</a></p>
<p><a href="#k02">*** 2. Typická sekvence transformací prováděných při překladu zdrojového kódu</a></p>
<p><a href="#k03">*** 3. Význam mezijazyka v&nbsp;oblasti moderních překladačů</a></p>
<p><a href="#k04">*** 4. Mezijazyk vs bajtkód</a></p>
<p><a href="#k05">*** 5. Historie vývoje bajtkódu a jeho využití</a></p>
<p><a href="#k06">*** 6. Bajtkód pro zásobníkové vs.&nbsp;registrové virtuální stroje</a></p>
<p><a href="#k07">*** 7. Praktická ukázka rozdílu mezi bajtkódem určeným pro zásobníkový a registrový virtuální stroj</a></p>
<p><a href="#k08">*** 8. Bajtkód virtuálního stroje jazyka Java (JVM)</a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Obsah navazujícího článku</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Technologie mezijazyků (mezikódů) a bajtkódů v&nbsp;moderních interpretrech a překladačích</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Typická sekvence transformací prováděných při překladu zdrojového kódu</h2>

<p>Při zpracování zdrojových kódů se postupně provádí jednotlivé dílčí kroky, a to jak v&nbsp;klasických překladačích (Go), tak i v&nbsp;jazycích, které provádí překlad &bdquo;jen&ldquo; do bajtkódu s&nbsp;jeho pozdější interpretací (Python). Díky rozdělení celého zpracování do několika konfigurovatelných kroků je zajištěna velká flexibilita a možnost případného relativně snadného rozšiřování o další syntaktické prvky, existuje možnost použití jediné sady nástrojů více jazyky, lze přidat podporu pro různé výstupní formáty (překlad do nativního kódu nebo do WebAssembly atd.), podporu speciální filtry apod.  (nehledě na to, že každá činnost je založena na odlišné teorii). Celý průběh zpracování vypadá při určitém zjednodušení následovně:</p>

<ol>

<li>Na začátku zpracování se nachází takzvaný <i>lexer</i>, který postupně načítá jednotlivé znaky ze vstupního řetězce (resp.&nbsp;ze vstupního souboru) a vytváří z&nbsp;nich lexikální <i>tokeny</i>. Teoreticky se pro každý programovací jazyk používá odlišný lexer a samozřejmě je možné v&nbsp;případě potřeby si napsat lexer vlastní. V&nbsp;případě Pythonu můžeme použít standardní modul <a href="https://docs.python.org/3.8/library/tokenize.html">tokenizer</a>, nebo lze alternativně použít například projekt <i>Pygments</i>, jenž obsahuje lexery pro mnoho dalších programovacích jazyků.</li>

<li>Výstup z&nbsp;lexeru může procházet libovolným počtem <i>filtrů</i> sloužících pro odstranění nebo (častěji) modifikaci jednotlivých tokenů; ať již jejich typů či přímo textu, který tvoří hodnotu tokenu. Díky existenci filtrů je například možné nechat si zvýraznit vybrané bílé znaky, slova se speciálním významem v&nbsp;komentářích (TODO:, FIX:) apod. Některé lexery obsahují filtr přímo ve svém modulu.</li>

<li>Sekvence <i>tokenů</i> tvoří základ pro syntaktickou analýzu. Nástroj, který syntaktickou analýzu provádí, se většinou nazývá <i>parser</i> a proto se taktéž někdy setkáme s&nbsp;pojmem <i>parsing</i> (tento termín je ovšem chybně používán i v&nbsp;těch případech, kdy se provádí &bdquo;pouze&ldquo; lexikální analýza). Výsledkem činnosti parseru je vhodně zvolená datová struktura, typicky abstraktní syntaktický strom (AST); někdy též strom derivační. V&nbsp;případě Pythonu vypadá postupné zpracování vstupního zdrojového textu takto: lexer &rarr; derivační strom (<i>parse tree</i>) &rarr; AST.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: díky tomu, že se prakticky veškeré zpracování zdrojových textů odehrává na úrovni tokenů, není nutné, aby byl celý zpracovávaný zdrojový kód (nebo jeho tokenizovaná podoba) uložen v&nbsp;operační paměti. Je tedy možné zpracovávat i velmi rozsáhlé zdrojové texty, a to bez větších nároků na operační paměť. Tento princip je použit například v&nbsp;již popsaném balíčku <strong>go/scanner</strong>, ovšem v&nbsp;případě Pythonu a jeho standardních modulů s&nbsp;lexerem a parserem <i>jsme</i> omezeni dostupnou kapacitou paměti (což v&nbsp;praxi nevadí, kromě extrémních případů).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Význam mezijazyka v&nbsp;oblasti moderních překladačů</h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. Mezijazyk vs bajtkód</h2>

<p>Pojem <i>mezijazyk</i> je většinou používán v&nbsp;souvislosti se sofistikovanými překladači, které překlad provádí v&nbsp;několika fázích zmíněných v&nbsp;předchozím textu.</p>

<p>Nejprve se však ve stručnosti seznámíme s&nbsp;historií používání bajtkódu, která je poměrně dlouhá a přitom i z&nbsp;programátorského hlediska zajímavá, protože úspěch mnoha programovacích jazyků vycházel mj.&nbsp;i z&nbsp;toho, že se díky použití bajtkódů (a s&nbsp;nimi souvisejících virtuálních strojů) mohly jejich překladače snadno a relativně rychle rozšiřovat na různé platformy a architektury počítačů (a to se v&nbsp;žádném případě netýká pouze Javy, ale dříve například i Pascalu či BPCL, což je pradávný předchůdce rodiny jazyků C a C++).</p>

<p>Bajtkód je využíván především dvěma nástroji. Na jedné straně se jedná o překladač (například v&nbsp;případě Javy to může být překladač <strong>javac</strong>, API tohoto překladače dostupné v&nbsp;moderních JDK či interní překladač využívaný nějakým integrovaným vývojovým prostředím), který překládá zdrojový kód napsaný programátorem (či poloautomaticky vygenerovaný v&nbsp;IDE :-) do bajtkódu; což mj.&nbsp;znamená, že je překlad zcela nezávislý na použité platformě. Na straně druhé již jednou přeložený bajtkód využívá interpret či dnes již v&nbsp;mnoha případech spíše JIT (<i>just in time</i>) překladač. Ve skutečnosti však s&nbsp;bajtkódem může pracovat i mnoho dalších nástrojů. Příkladem ve světě Javy a bajtkódu JVM mohou být například nástroje typu <i>Cobertura</i> a <i>EMMA</i> sloužící pro zjištění, které části zdrojového kódu aplikací jsou pokryty (jednotkovými) testy. Tyto nástroje musí umět dobře kooperovat s&nbsp;virtuálním strojem Javy, proto nejprve modifikují bajtkódy testovaných tříd, aby bylo možné při běhu testů dynamicky zjistit, které řádky kódu jsou skutečně z&nbsp;testů volány.</p>

<p>Podobným způsobem je bajtkód modifikován nástroji podporujícími aspektově orientované programování (<i>aspect oriented programming</i>), které taktéž mohou zasahovat do bajtkódu vygenerovaného překladačem. Teoreticky je sice možné při použití aspektově orientovaného programování transformovat přímo zdrojové kódy programů (což je použito především v&nbsp;jiných programovacích jazycích), ale transformace bajtkódu je v&nbsp;případě Javy mnohem snazší. Ze stejného důvodu (analýza bajtkódu je jednodušší než analýza zdrojového textu) je bajtkód použit pro statickou analýzu a hledání potenciálních chyb nástrojem <i>FindBugs</i>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Historie vývoje bajtkódu a jeho využití</h2>

<p>Myšlenka na využití bajtkódu pro překlad a následnou interpretaci programů je v&nbsp;informatice úspěšně využívána poměrně dlouho. Jedním z&nbsp;prvních známých a rozšířených bajtkódů byl <strong>OPCODE</strong>, který byl vyvinut pro potřeby programovacího jazyka <strong>BCPL</strong>. Jazyk <strong>BPCL</strong> (<i>Basic Combined Programming Language</i>), jenž byl vytvořen Martinem Richardsem již v&nbsp;roce 1966, je z&nbsp;hlediska historie IT důležitý především proto, že z&nbsp;něho Ken Thompson odvodil nový programovací jazyk nazvaný jednoduše <strong>B</strong> a z&nbsp;jazyka <strong>B</strong> se postupně vyvinulo klasické Céčko (nejdříve K&amp;R C a posléze dodnes používané ANSI/ISO C). Bajtkód nazvaný <strong>OPCODE</strong> byl založen na instrukcích pracujících se zásobníkem operandů a v&nbsp;práci s&nbsp;daty dostupnými přes indexové registry. Například výraz <strong>x / y + z</strong> se pro proměnné <strong>x</strong>, <strong>y</strong> a <strong>z</strong> uložené na pozicích 1, 2 a 10 přeložil do bajtkódu <strong>OPCODE</strong> následujícím způsobem, který se nápadně podobá bajtkódu JVM (což ostatně není náhoda, jak si řekneme dále):</p>

<pre>
LP   1
LP   2
DIV
LP   10
PLUS
</pre>

<p>Popularita používání bajtkódu byla úzce spojena i s&nbsp;úspěšností takzvaného <strong>p-code</strong>, což byl (a ostatně stále ještě je) bajtkód využívaný některými překladači programovacího jazyka Pascal (to se ovšem netýká Turbo Pascalu). Díky využití <strong>p-code</strong> bylo snadnější portovat jak překladač Pascalu na různé platformy, tak i interpret vlastního p-kódu.  Tento bajtkód je v&nbsp;současnosti ještě využíván na některých školách při výuce IT; mj.&nbsp;i z&nbsp;tohoto důvodu se jedná o stále živý projekt, o čemž ostatně mohou svědčit i stránky projektu UCSD p-system Virtual Machine dostupné na adrese <a href="http://ucsd-psystem-vm.sourceforge.net/">http://ucsd-psystem-vm.sourceforge.net/</a>.  Dále je vhodné zmínit bajtkód využívaný <i>Smalltalkem</i>. Jedná se o poměrně vysokoúrovňový bajtkód, který se v&nbsp;některých ohledech přibližuje bajtkódu používaném Pythonem (posílání zpráv je v&nbsp;tomto případě velmi podobné volání virtuálních metod apod.). Mimochodem &ndash; velká část bajtkódu <i>Smalltalku</i> je reflexivně dostupná i z&nbsp;vlastního jazyka, viz například <a href="http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png">http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Bajtkód pro zásobníkové vs.&nbsp;registrové virtuální stroje</h2>

<p>Využívání bajtkódů má v&nbsp;současnosti za sebou zhruba čtyřicet let postupného vývoje, takže není divu, že za tuto poměrně dlouhou dobu bylo navrženo a implementováno mnoho různých řešení virtuálního stroje+bajtkódu, která se od sebe v&nbsp;mnoha ohledech odlišovala, a to jak úrovní abstrakce bajtkódu (nízkoúrovňové instrukce dobře transformovatelné na strojový kód vs.  vysokoúrovňové instrukce podporující například polymorfismus využívaný například virtuálním strojem Pythonu), tak i způsobem, jakým jednotlivé instrukce pracovaly s&nbsp;argumenty. Naprostou většinu existujících a v&nbsp;současnosti používaných bajtkódů lze rozdělit do dvou skupin.  V&nbsp;první skupině se nachází bajtkódy zpracovávané virtuálními stroji založenými na zásobníku operandů (<i>operand stack</i>) a v&nbsp;druhé skupině se nachází bajtkódy využívající sadu registrů (<i>register set</i>) nabízených virtuálním strojem. Oba přístupy mají své přednosti i zápory a taktéž skalní zastánce i odpůrce, jak je tomu ostatně v&nbsp;IT dobrým zvykem :-)</p>

<p>Bajtkódy a virtuální stroje využívající zásobník operandů a instrukce pro práci s&nbsp;argumenty uloženými na tomto zásobníku většinou obsahují mnoho bezparametrických instrukcí, jejichž operační kódy tak mohou být velmi krátké a typicky bývají uloženy v&nbsp;jednom bajtu (z&nbsp;toho také ostatně označení &bdquo;bajtkód&ldquo; vychází). Interpretace takového bajtkódu bývá velmi jednoduchá a lze ji efektivně provádět i na těch mikroprocesorech, které obsahují velmi malé množství pracovních registrů, z&nbsp;čehož ostatně vyplývá i oblíbenost takto navržených bajtkódů v&nbsp;době osmibitových mikroprocesorů a mikrořadičů (poněkud speciálním případem je jazyk <i>Forth</i>). Před přibližně deseti lety, kdy se ve větší míře začaly rozšiřovat JIT překladače, se předpokládalo, že nové JIT překladače budou mít problémy s&nbsp;překladem instrukcí založených na použití zásobníku operandů do strojového kódu moderních mikroprocesorů (ty mají většinou velkou sadu pracovních registrů), ovšem ukázalo se, že JIT dokáží bez větších problémů pracovat jak se zásobníkovými instrukcemi, tak i s&nbsp;instrukcemi využívajícími sadu pracovních registrů VM.</p>

<p>Tím se pomalu dostáváme ke druhému rozšířenému typu bajtkódů. Jedná se o bajtkódy, jejichž instrukce dokážou pracovat s&nbsp;obsahem množiny pracovních registrů zvoleného virtuálního stroje. Délka instrukčního slova i možnosti takto navržených bajtkódů závisí především na počtu těchto pracovních registrů; v&nbsp;moderních VM se setkáme minimálně s&nbsp;použitím šestnácti či 32 registry, což znamená, že mnoho instrukcí má délku minimálně dva bajty, mnohdy i tři či čtyři bajty. Liší se taktéž počet operandů instrukcí &ndash; některé bajtkódy využívají takzvaný dvouadresový kód (používají dva registry &ndash; jeden registr zdrojový a druhý registr současně zdrojový i cílový), jiné se zaměřují na tříadresový kód (dva zdrojové registry a jeden registr cílový).  Způsob interpretace takto navržených bajtkódů může být problematičtější v&nbsp;případě, že mikroprocesor, na němž interpret běží, obsahuje menší množství fyzických pracovních registrů, ovšem (jak již bylo řečeno v&nbsp;předchozím odstavci), při použití JIT se rozdíly mezi oběma způsoby práce s&nbsp;operandy do značné míry rozostřují.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Praktická ukázka rozdílu mezi bajtkódem určeným pro zásobníkový a registrový virtuální stroj</h2>

<p>Podívejme se nyní na dvě ukázky, jak se může lišit bajtkód založený na zásobníkovém virtuálním stroji od bajtkódu, který je určen pro registrový virtuální stroj. V&nbsp;obou příkladech se má vyhodnotit jednoduchý výraz <strong>result = a+b*c-d</strong>; pro jednoduchost předpokládejme, že všech pět proměnných je lokálních a současně mají typ celé číslo (integer). Způsob překladu do bajtkódu využívajícího zásobník operandů (konkrétně je použit bajtkód JVM) může vypadat následovně:</p>

<pre>
              <i>; 0 je index proměnné <strong>a</strong></i>
              <i>; 1 je index proměnné <strong>b</strong></i>
              <i>; 2 je index proměnné <strong>c</strong></i>
              <i>; 3 je index proměnné <strong>d</strong></i>
              <i>; 4 je index proměnné <strong>result</strong></i>
0: iload  0   <i>; uložení obsahu proměnné <strong>a</strong> na zásobník</i>
1: iload  1   <i>; uložení obsahu proměnné <strong>b</strong> na zásobník</i>
2: iload  2   <i>; uložení obsahu proměnné <strong>c</strong> na zásobník</i>
3: imul       <i>; provedení operace <strong>b*c</strong>, výsledek je ponechán na zásobníku</i>
4: iadd       <i>; provedení operace <strong>a+(b*c)</strong></i>
5: iload  3   <i>; uložení obsahu proměnné <strong>d</strong> na zásobník</i>
6: isub       <i>; dokončit příkaz <strong>a+(b*c)+d</strong></i>
7: istore 4   <i>; uložení výsledku z TOS (obsah zásobníku operandů) do proměnné <strong>result</strong></i>
</pre>

<p>Příklad kompilace téhož příkazu <strong>result = a+b*c-d</strong> do bajtkódu využívajícího pracovní registry, konkrétně do bajtkódu využívaného programovacím jazykem Lua:</p>

<pre>
                               <i>; 0 je index proměnné <strong>a</strong></i>
                               <i>; 1 je index proměnné <strong>b</strong></i>
                               <i>; 2 je index proměnné <strong>c</strong></i>
                               <i>; 3 je index proměnné <strong>d</strong></i>
                               <i>; 4 je index proměnné <strong>result</strong></i>
1       [101]   MUL    4 1 2   <i>; přímé vynásobení obsahu proměnných <strong>b</strong> a <strong>c</strong></i>
2       [101]   ADD    4 0 4   <i>; přičíst k obsahu proměnné <strong>a</strong> mezivýsledek, výsledek uložit do proměnné <strong>result</strong></i>
3       [101]   SUB    4 4 3   <i>; odečíst od mezivýsledku obsah proměnné <strong>b</strong>, výsledek uložit do proměnné <strong>result</strong></i>
</pre>

<p>Ve druhém případě se nemusely vůbec použít instrukce pro uložení proměnných na zásobník ani pro načtení hodnoty zpět ze zásobníku operandů do proměnné, ovšem na druhou stranu musely mít všechny aritmetické instrukce v&nbsp;instrukčním slovu uloženy i indexy operandů.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Bajtkód virtuálního stroje jazyka Java (JVM)</h2>

<p>První typ v&nbsp;současnosti používaného bajtkódu, s&nbsp;nímž se ve stručnosti seznámíme, je bajtkód využívaný JVM. Virtuální stroj jazyka Java samozřejmě využívá jiný soubor &bdquo;strojových&ldquo; instrukcí, než fyzický mikroprocesor, na němž jsou Javovské programy spouštěny. Dokonce ani mikroprocesory určené pro přímé spouštění bajtkódu &ndash; dnes již zpola zapomenuté projekty <i>MicroJava</i> a <i>PicoJava</i>, dokonce i ARM procesory s&nbsp;technologií <i>Jazelle</i> &ndash; nedokázaly nativně vykonávat všechny instrukce bajtkódu. V&nbsp;prvních několika letech existence Javy byly instrukce bajtkódu (tvořící těla jednotlivých metod) v&nbsp;naprosté většině případů pouze interpretovány, a to mnohdy velmi jednoduchým způsobem: v&nbsp;programové smyčce se postupně načítaly kódy jednotlivých instrukcí a následně se pro každou instrukci zavolala nativní funkce, která danou instrukci vykonala, většinou s&nbsp;parametry uloženými v&nbsp;zásobníkovém rámci nebo v&nbsp;zásobníku operandů (bližší popis bude uveden v&nbsp;následujících kapitolách).</p>

<p>Naprogramování naivního interpretru pro bajtkód virtuálního stroje Javy není příliš složité, protože samotná instrukční sada je poměrně jednoduchá. Moderní interpretry, například již v&nbsp;tomto seriálu popsaný <a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">JamVM</a>, jsou navíc naprogramovány takovým způsobem, aby byl jejich přenos na další procesorové architektury snadný a přitom se bajtkód interpretoval co nejefektivnějším způsobem, ideálně s&nbsp;ručně optimalizovanou vnitřní smyčkou (naprogramovanou v&nbsp;případě ručně prováděných optimalizací většinou assembleru).</p>

<p>Ovšem i přes veškerou snahu programátorů interpretrů nemůže běh programů napsaných v&nbsp;Javě a spouštěných v&nbsp;JVM s&nbsp;interpretovaným bajtkódem v&nbsp;rychlosti soutěžit s&nbsp;nativními aplikacemi. Právě z&nbsp;tohoto důvodu vznikly takzvané <i>just-in-time (JIT)</i> překladače, které dokážou přeložit buď jen určitou sekvenci instrukcí JVM nebo i celý bajtkód do nativního strojového kódu, který je následně spuštěn. Některé JIT překladače, například stále populární <i>HotSpot</i> původně vyvinutý společností Sun Microsystems, používají <i>adaptivní překlad</i>, v&nbsp;němž je bajtkód analyzován v&nbsp;době běhu, takže má JIT překladač k&nbsp;dispozici mnohem více informací, než při statickém překladu. <i>HotSpot</i> navíc umožňuje pomocí takzvaný sond (<i>probes</i> sledovat, který kód je překládán a jaký typ překladu je přitom použit, to je však již poměrně pokročilá a nepříliš často používaná technologie. Ovšem nezávisle na tom, zda jsou instrukce JVM &bdquo;pouze&ldquo; interpretovány, nebo je nejdříve použit <i>JIT</i>, musí být vždy dodrženy všechny vlastnosti jazyka Java i JVM. <i>JIT</i> například může odstranit kontrolu mezí při indexování polí, ale jen tehdy, když je zřejmé, že nedojde k&nbsp;překročení těchto mezí.</p>

<p>V&nbsp;této kapitole si ve stručnosti připomeneme základní vlastnosti bajtkódu virtuálního stroje Javy. Struktura i vlastnosti JVM jsou přesně popsány ve specifikaci JVM, včetně přesného formátu všech datových typů (znaků, celých čísel, čísel s&nbsp;plovoucí řádovou tečkou). Díky dodržování této specifikace různými výrobci virtuálního stroje Javy je zaručeno, že programy napsané v&nbsp;Javě jsou přenositelné na počítače s&nbsp;mnohdy velmi rozdílnou architekturou: od smartphonů s&nbsp;jednojádrovými mikroprocesory až po superpočítače s&nbsp;velkým množstvím výpočetních uzlů a mnohdy s&nbsp;několika desítkami tisíc procesorových jader. Různé nekompatibility, s&nbsp;nimiž programátoři bojovali především v&nbsp;minulosti (ale samozřejmě i dnes, i když v&nbsp;mnohem menší míře), bývají způsobeny buď chybami v&nbsp;implementaci některého virtuálního stroje (a nedodržení specifikace lze považovat za chybu) či nekompatibilitami ve standardních knihovnách, popř.&nbsp;chybami v&nbsp;nativních knihovnách, které lze z&nbsp;JVM volat.</p>

<p>Specifikace virtuálního stroje Javy popisuje některé jeho části velmi precizně (například se jedná o již zmíněné datové typy či o formát instrukcí nebo o strukturu zásobníkového rámce), ovšem u některých dalších částí jsou popsány jen základní vlastnosti a zůstává pouze na tvůrci konkrétní JVM, jakým způsobem se bude daná část virtuálního stroje ve skutečnosti implementovat. Asi nejtypičtějším příkladem je specifikace haldy (<i>heap</i>), u níž se sice předpokládá využití automatické správy paměti, ale nikde již není řečeno, jaký konkrétní algoritmus správy paměti se má použít (v&nbsp;současnosti se využívá hned několik algoritmů) ani jaký formát má být použit pro ukládání referencí na objekty. Díky tomu bylo možné Javu jednoduše přenést z&nbsp;původní 32bitové architektury jak na 16bitové procesory, tak i na procesory pracující s&nbsp;64bitovými ukazateli (u nichž lze navíc v&nbsp;případě potřeby využít i <a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">komprimované ukazatele na objekty</a>) &ndash; to vše bez nutnosti zásahu do zdrojových kódů Javovských programů i bez nutnosti jejich rekompilace.</p>

<p>Virtuální stroj jazyka Java obsahuje instrukce, které pracují s&nbsp;operandy několika datových typů. Na rozdíl od mnoha fyzických procesorů se v&nbsp;případě JVM provádí kontroly, zda jsou operace skutečně aplikovány na správné operandy. Není například možné, aby se operace součtu prováděla s&nbsp;jedním operandem typu <strong>int</strong> a druhým operandem typu <strong>long</strong> &ndash; takový bajtkód by byl při svém načítání odmítnut a vůbec by nebyl spuštěn (to však jinými slovy znamená, že bajtkód je zbytečně redundantní, zejména v&nbsp;porovnání s&nbsp;bajtkódy jazyků Lua a Python).  Zajímavé je, že jen velmi málo instrukcí JVM podporuje práci s&nbsp;datovými typy <strong>boolean</strong>, <strong>byte</strong>, <strong>short</strong> a <strong>char</strong>. Proměnné a parametry metod těchto typů musí být například před provedením některé aritmetické operace nejprve převedeny na typ <strong>int</strong> pomocí konverzních instrukcí (těch existuje celkem patnáct).</p>

<p>Většina instrukcí virtuálního stroje Javy pracuje s&nbsp;operandy uloženými na takzvaném <i>zásobníku operandů (operand stack)</i>. Zásobník operandů (v&nbsp;tomto případě se již jedná o skutečný zásobník typu <i>LIFO &ndash; Last In, First Out</i>) je vytvářen v&nbsp;čase běhu aplikace pro každou zavolanou metodu, což mj.&nbsp;znamená, že je při spuštění metody vždy prázdný (zásobník operandů je podle specifikace součástí zásobníkového rámce, jeho konkrétní umístění však je libovolné). Již v&nbsp;čase překladu zdrojového kódu je pro každou metodu zjištěno, jak velká oblast paměti má být pro zásobník operandů vyhrazena a samozřejmě je prováděna kontrola, zda se v&nbsp;době běhu aplikace tato velikost nepřekročí (to by se nemělo u validního bajtkódu stát).</p>

<p>Virtuální stroj Javy kontroluje typy operandů uložených na zásobník operandů a zajišťuje, že se nad těmito operandy budou provádět pouze typově bezpečné operace. V&nbsp;praxi to například znamená, že není možné na zásobník uložit dvě hodnoty typu <strong>float</strong> a následně provést instrukci <strong>iadd</strong>, protože tato instrukce vyžaduje, aby na zásobníku byly uloženy dvě hodnoty typu <strong>int</strong> (i když <strong>float</strong> i <strong>int</strong> mají shodnou bitovou šířku).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Obsah navazujícího článku</h2>

<p></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Is intermediate representation (such as bytecodes or .net IL) still an advantage?<br />
<a href="https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage">https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage</a>
</li>

<li>Intermediate Representation vs Byte Code<br />
<a href="https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code">https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code</a>
</li>

<li>Getting the intermediate representation in gcc<br />
<a href="https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2">https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2</a>
</li>

<li>Intermediate Representations<br />
<a href="https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/">https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/</a>
</li>

<li>Why do we use intermediate representations / languages?<br />
<a href="https://mortoray.com/why-we-use-intermediate-representations/">https://mortoray.com/why-we-use-intermediate-representations/</a>
</li>

<li>Unwrapping intermediate representations<br />
<a href="https://mortoray.com/unwrapping-intermediate-representations/">https://mortoray.com/unwrapping-intermediate-representations/</a>
</li>

<li>Understanding Python Code Flow From Source to Execution<br />
<a href="https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83">https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83</a>
</li>

<li>Why most compilers use AST, instead generate IR directly?<br />
<a href="https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159">https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159</a>
</li>

<li>A Gentle Introduction to LLVM IR<br />
<a href="https://mcyoung.xyz/2023/08/01/llvm-ir/">https://mcyoung.xyz/2023/08/01/llvm-ir/</a>
</li>

<li>Why does the compiler need the intermediate representations for link time optimization?<br />
<a href="https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi">https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi</a>
</li>

<li>pyrefact na PyPi<br />
<a href="https://pypi.org/project/pyrefact/">https://pypi.org/project/pyrefact/</a>
</li>

<li>Repositář projektu pyrefact<br />
<a href="https://github.com/OlleLindgren/pyrefact">https://github.com/OlleLindgren/pyrefact</a>
</li>

<li>pyrefact jako plugin do VSCode<br />
<a href="https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact">https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact</a>
</li>

<li>pyrefact-vscode-extension (repositář)<br />
<a href="https://github.com/OlleLindgren/pyrefact-vscode-extension">https://github.com/OlleLindgren/pyrefact-vscode-extension</a>
</li>

<li>Best Python Refactoring Tools for 2023<br />
<a href="https://www.developer.com/languages/python/best-python-refactoring-tools/">https://www.developer.com/languages/python/best-python-refactoring-tools/</a>
</li>

<li>Python Refactoring: Techniques, Tools, and Best Practices<br />
<a href="https://www.codesee.io/learning-center/python-refactoring">https://www.codesee.io/learning-center/python-refactoring</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů jazyka Python (4.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/</a>
</li>

<li>Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu<br />
<a href="https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/">https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/</a>
</li>

<li>LibCST &ndash; dokumentace<br />
<a href="https://libcst.readthedocs.io/en/latest/index.html">https://libcst.readthedocs.io/en/latest/index.html</a>
</li>

<li>libCST na PyPi<br />
<a href="https://pypi.org/project/libcst/">https://pypi.org/project/libcst/</a>
</li>

<li>libCST na GitHubu<br />
<a href="https://github.com/Instagram/LibCST">https://github.com/Instagram/LibCST</a>
</li>

<li>Inside The Python Virtual Machine<br />
<a href="https://leanpub.com/insidethepythonvirtualmachine">https://leanpub.com/insidethepythonvirtualmachine</a>
</li>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Golang Compilation and Execution<br />
<a href="https://golangtutorial.com/golang-compilation-and-execution/">https://golangtutorial.com/golang-compilation-and-execution/</a>
</li>

<li>Mezijazyk (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/Mezijazyk">https://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://www.llvm.org/">https://www.llvm.org/</a>
</li>

<li>GCC internals<br />
<a href="https://gcc.gnu.org/onlinedocs/gccint/index.html">https://gcc.gnu.org/onlinedocs/gccint/index.html</a>
</li>

<li>GCC Developer Options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html">https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html</a>
</li>

<li>What is Gimple?<br />
<a href="https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/">https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/</a>
</li>

<li>The Conceptual Structure of GCC<br />
<a href="https://www.cse.iitb.ac.in/grc/intdocs/gcc-conceptual-structure.html">https://www.cse.iitb.ac.in/grc/intdocs/gcc-conceptual-structure.html</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojů využívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (před verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2026</small></p>
</body>

</html>

