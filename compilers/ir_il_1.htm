<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Technologie mezijazyků (mezikódů) a bajtkódů v moderních interpretrech a překladačích</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Technologie mezijazyků (mezikódů) a bajtkódů v moderních interpretrech a překladačích</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Technologie mezijazyků (mezikódů) a bajtkódů v&nbsp;moderních interpretrech a překladačích</a></p>
<p><a href="#k02">2. Typická sekvence transformací prováděných při překladu zdrojového kódu</a></p>
<p><a href="#k03">3. AST a CST</a></p>
<p><a href="#k04">4. Příklad zobrazení struktury výsledného CST</a></p>
<p><a href="#k05">*** 5. Význam mezijazyka v&nbsp;oblasti moderních překladačů</a></p>
<p><a href="#k06">6. Mezijazyk vs bajtkód</a></p>
<p><a href="#k07">7. Historie vývoje bajtkódu a jeho využití</a></p>
<p><a href="#k08">8. Bajtkód pro zásobníkové vs.&nbsp;registrové virtuální stroje</a></p>
<p><a href="#k09">9. Praktická ukázka rozdílu mezi bajtkódem určeným pro zásobníkový a registrový virtuální stroj</a></p>
<p><a href="#k10">*** 10. Bajtkód virtuálního stroje jazyka Java (JVM)</a></p>
<p><a href="#k11">*** 11. Příklady metod přeložených do bajtkódu JVM</a></p>
<p><a href="#k12">12. Bajtkód využívaný interpretrem jazyka Lua</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">15. Mezikódy používané v&nbsp;GCC</a></p>
<p><a href="#k16">16. Překlad výpočtu do mezikódu GIMPLE a RTL</a></p>
<p><a href="#k17">17. LLVM IR</a></p>
<p><a href="#k18">18. Překlad výpočtu do LLVM IR</a></p>
<p><a href="#k19">19. Obsah navazujícího článku</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Technologie mezijazyků (mezikódů) a bajtkódů v&nbsp;moderních interpretrech a překladačích</h2>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 283px"><a href="https://www.root.cz/obrazek/1270956/"><img src="https://i.iinfo.cz/images/377/mezikod-1.png" class="image-1270956" width="283" height="281" data-prev-filename="https://i.iinfo.cz/images/377/mezikod-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/377/mezikod-1-prev.webp" data-prev-width="272" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/377/mezikod-1.png" data-large-filename-webp="https://i.iinfo.cz/images/377/mezikod-1.webp" data-large-width="283" data-large-height="281" alt="Mezikód" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 283px" /></a><p>Obrázek 1: Pohled na činnost překladače, který je zde chápán jako černá skříňka, jež transformuje zdrojový kód na strojový kód nebo bajtkód.&#160;<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k02"></a></p>
<h2 id="k02">2. Typická sekvence transformací prováděných při překladu zdrojového kódu</h2>

<p>Při zpracování zdrojových kódů se postupně provádí jednotlivé dílčí kroky, a
to jak v&nbsp;klasických překladačích (C, C++, C3, Go, Rust), tak i v&nbsp;těch
programovacích jazycích, které provádí překlad &bdquo;jen&ldquo; do bajtkódu
s&nbsp;jeho pozdější interpretací (Python, Lua). Díky rozdělení celého
zpracování do několika konfigurovatelných a relativně samostatných kroků je
zajištěna velká flexibilita a možnost případného relativně snadného rozšiřování
o další syntaktické prvky, existuje možnost použití jediné sady nástrojů více
programovacími jazyky (GCC, LLVM), lze přidat podporu pro různé výstupní
formáty (typický je překlad do nativního kódu pro různé platformy nebo do
WebAssembly atd.), podporu pro speciální filtry apod. (nehledě na to, že každá
činnost je založena na odlišné teorii). Celý průběh zpracování vypadá při
určitém zjednodušení následovně:</p>

<ol>

<li>U jazyků typu C a C++ se nejdříve zdrojové kódy transformují
s&nbsp;využitím preprocesoru, který expanduje makra, řeší podmínky
preprocesoru, vkládání obsahu dalších souborů, expanzi jmen funkcí atd.</li>

<li>Většinou se však na samotném začátku zpracování nachází takzvaný
<i>lexer</i>, který postupně načítá jednotlivé znaky ze vstupního řetězce
(resp.&nbsp;většinou ze vstupního souboru) a vytváří z&nbsp;nich lexikální
<i>tokeny</i>. Teoreticky se pro každý programovací jazyk používá odlišný lexer
a samozřejmě je možné v&nbsp;případě potřeby si napsat lexer vlastní.
V&nbsp;případě Pythonu můžeme použít standardní modul <a
href="https://docs.python.org/3.8/library/tokenize.html">tokenizer</a>, nebo
lze alternativně použít například projekt <i>Pygments</i>, jenž obsahuje lexery
pro mnoho dalších programovacích jazyků a navíc je snadno rozšiřitelný pro
přidání dalších jazyků.</li>

<li>Výstup z&nbsp;lexeru může procházet libovolným počtem <i>filtrů</i>
sloužících pro odstranění nebo (častěji) modifikaci jednotlivých tokenů; ať již
jejich typů či přímo textu, který tvoří hodnotu tokenu. Díky existenci filtrů
je například možné nechat si zvýraznit vybrané bílé znaky, slova se speciálním
významem v&nbsp;komentářích (TODO:, FIX:) apod. Některé lexery obsahují filtr
přímo ve svém modulu. V&nbsp;běžných překladačích bývá filtrace omezena na
odstranění komentářů atd.</li>

<li>Sekvence <i>tokenů</i> tvoří základ pro syntaktickou analýzu. Nástroj,
který syntaktickou analýzu provádí, se většinou nazývá <i>parser</i> a proto se
taktéž někdy setkáme s&nbsp;pojmem <i>parsing</i> (tento termín je ovšem chybně
používán i v&nbsp;těch případech, kdy se provádí &bdquo;pouze&ldquo; lexikální
analýza). Výsledkem činnosti parseru je vhodně zvolená datová struktura,
typicky abstraktní syntaktický strom (AST); někdy též strom derivační nebo CST.
V&nbsp;případě interpretru jazyka Python vypadá postupné zpracování vstupního
zdrojového textu takto: lexer &rarr; derivační strom (<i>parse tree</i>) &rarr;
AST.</li>

<li>Z&nbsp;AST nebo CST se další transformací typicky vytváří buď přímo bajtkód
(Lua, Python) nebo struktura v&nbsp;mezikódu nebo mezijazyku. Záleží na
konkrétním překladači nebo interpretru, jakou sémantiku bude tento mezijazyk
mít. Moderní překladače navíc mají hned několik mezijazyků popř.&nbsp;se
provádí několik transformací mezi různými fázemi překladu. Pokud je výsledkem
bajtkód, bude použit interpretrem nebo JITem, pokud se jedná o mezikód,
pokračuje se dalším krokem.</li>

<li>Mezikód/mezijazyk je přeložen <i>backend překladačem</i> do finálního
spustitelného kódu určeného pro konkrétní platformu. Touto fází překladu se
ovšem dnes zabývat nebudeme.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: díky tomu, že se prakticky veškeré
zpracování zdrojových textů odehrává na úrovni tokenů, není nutné, aby byl celý
zpracovávaný zdrojový kód (nebo jeho tokenizovaná podoba) uložen
v&nbsp;operační paměti. Je tedy možné zpracovávat i velmi rozsáhlé zdrojové
texty, a to bez větších nároků na operační paměť. Tento princip je použit
například v&nbsp;balíčku <strong>go/scanner</strong> (jenž byl popsán
v&nbsp;seriálu o programovacím jazyku Go), ovšem například v&nbsp;případě
Pythonu a jeho standardních modulů s&nbsp;lexerem a parserem ve skutečnosti
<i>jsme</i> omezeni dostupnou kapacitou paměti (což v&nbsp;praxi nevadí, kromě
extrémních případů).</div></p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 214px"><a href="https://www.root.cz/obrazek/1270959/"><img src="https://i.iinfo.cz/images/377/mezikod-2-large.png" class="image-1270959" width="214" height="525" data-prev-filename="https://i.iinfo.cz/images/377/mezikod-2-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/377/mezikod-2-prev.webp" data-prev-width="110" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/377/mezikod-2-large.png" data-large-filename-webp="https://i.iinfo.cz/images/377/mezikod-2-large.webp" data-large-width="214" data-large-height="525" alt="Mezikód" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 214px" /></a><p>Obrázek 2: Jak překladače, tak i interpretry ve skutečnosti provádí několik transformací. Ze zdrojového kódu vzniká AST a následně bajtkód nebo mezikód.&#160;<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k03"></a></p>
<h2 id="k03">3. AST a CST</h2>

<p>Standardní abstraktní syntaktický strom (AST), o kterém jsme se několikrát
zmínili <a href="#k02">v&nbsp;předchozí kapitole</a>, má ovšem jednu poměrně
zásadní nevýhodu &ndash; v&nbsp;případě, že <i>AST</i> upravíme a necháme si
z&nbsp;něho zpětně vygenerovat zdrojový kód, ztratíme veškeré původní
formátování, tedy například mezery zapsané ve výrazech, přesné umístění
komentářů, v&nbsp;některých případech i dekorátorů atd. Z&nbsp;tohoto důvodu se
pro ty nástroje, které musí modifikovat zdrojový kód (nepřímo &ndash; přes
strom) používají nepatrně odlišné typy stromů, které se nazývají <i>Concrete
Syntax Tree</i> neboli zkráceně <i>CST</i> (popř.&nbsp;<i>derivační stromy</i>
nebo <i>parse tree</i>).</p>

<p>Tyto stromové datové struktury, jak již ostatně jejich název napovídá,
reprezentují syntaktickou strukturu daného bloku programového kódu (což může
být konstanta, výraz, příkaz, složený blok, funkce, třída, či celý modul). Díky
tomu, že si <i>CST</i> pamatuje původní zápis syntaktických prvků, je umožněna
relativně snadná tvorba nástrojů pro refaktoring kódu. Příkladem může být
knihovna <i>LibCST</i>, která slouží pro manipulaci s&nbsp;<i>CST</i>
v&nbsp;Pythonu.</p>

<p><div class="rs-tip-major">Poznámka: u běžných překladačů se setkáme spíše
s&nbsp;tím, že se do běžných AST přidávají informace o tom, jakému místu ve
zdrojovém kódu (jméno souboru+řádek+znak na řádku) odpovídá každý uzel stromu.
Ovšem konkrétní způsoby reprezentace se mnohdy značně odlišují.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příklad zobrazení struktury výsledného CST</h2>

<p>Ukažme si na několika jednoduchých příkladech, jaké informace jsou vlastně
v&nbsp;CST uloženy. Začneme výrazem, který obsahuje dva operandy, jeden
operátor a mezery:</p>

<pre>
6 * 7
</pre>

<p>Výsledný CST lze reprezentovat například následujícím způsobem:</p>

<pre>
BinaryOperation(
    left=Integer(
        value='6',
        lpar=[],
        rpar=[],
    ),
    operator=Multiply(
        whitespace_before=SimpleWhitespace(
            value=' ',
        ),
        whitespace_after=SimpleWhitespace(
            value=' ',
        ),
    ),
    right=Integer(
        value='7',
        lpar=[],
        rpar=[],
    ),
    lpar=[],
    rpar=[],
)
</pre>

<p>Výraz bez mezer, ovšem uložený do kulatých závorek:</p>

<pre>
(6*7)
</pre>

<p>Výsledný CST:</p>

<pre>
BinaryOperation(
    left=Integer(
        value='6',
        lpar=[],
        rpar=[],
    ),
    operator=Multiply(
        whitespace_before=SimpleWhitespace(
            value='',
        ),
        whitespace_after=SimpleWhitespace(
            value='',
        ),
    ),
    right=Integer(
        value='7',
        lpar=[],
        rpar=[],
    ),
    lpar=[
        LeftParen(
            whitespace_after=SimpleWhitespace(
                value='',
            ),
        ),
    ],
    rpar=[
        RightParen(
            whitespace_before=SimpleWhitespace(
                value='',
            ),
        ),
    ],
)
</pre>

<p>Složitější výraz s&nbsp;několika operátory s&nbsp;různou prioritou
(<strong>**</strong> je v&nbsp;Pythonu operátorem umocnění):</p>

<pre>
(1+2)*3/2**4
</pre>

<p>Výsledný CST:</p>

<pre>
BinaryOperation(
    left=BinaryOperation(
        left=BinaryOperation(
            left=Integer(
                value='1',
                lpar=[],
                rpar=[],
            ),
            operator=Add(
                whitespace_before=SimpleWhitespace(
                    value='',
                ),
                whitespace_after=SimpleWhitespace(
                    value='',
                ),
            ),
            right=Integer(
                value='2',
                lpar=[],
                rpar=[],
            ),
            lpar=[
                LeftParen(
                    whitespace_after=SimpleWhitespace(
                        value='',
                    ),
                ),
            ],
            rpar=[
                RightParen(
                    whitespace_before=SimpleWhitespace(
                        value='',
                    ),
                ),
            ],
        ),
        operator=Multiply(
            whitespace_before=SimpleWhitespace(
                value='',
            ),
            whitespace_after=SimpleWhitespace(
                value='',
            ),
        ),
        right=Integer(
            value='3',
            lpar=[],
            rpar=[],
        ),
        lpar=[],
        rpar=[],
    ),
    operator=Divide(
        whitespace_before=SimpleWhitespace(
            value='',
        ),
        whitespace_after=SimpleWhitespace(
            value='',
        ),
    ),
    right=BinaryOperation(
        left=Integer(
            value='2',
            lpar=[],
            rpar=[],
        ),
        operator=Power(
            whitespace_before=SimpleWhitespace(
                value='',
            ),
            whitespace_after=SimpleWhitespace(
                value='',
            ),
        ),
        right=Integer(
            value='4',
            lpar=[],
            rpar=[],
        ),
        lpar=[],
        rpar=[],
    ),
    lpar=[],
    rpar=[],
)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Význam mezijazyka v&nbsp;oblasti moderních překladačů</h2>

<p></p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 133px"><a href="https://www.root.cz/obrazek/1270962/"><img src="https://i.iinfo.cz/images/377/mezikod-3-large.png" class="image-1270962" width="133" height="525" data-prev-filename="https://i.iinfo.cz/images/377/mezikod-3-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/377/mezikod-3-prev.webp" data-prev-width="68" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/377/mezikod-3-large.png" data-large-filename-webp="https://i.iinfo.cz/images/377/mezikod-3-large.webp" data-large-width="133" data-large-height="525" alt="Mezikód" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 133px" /></a><p>Obrázek 3: Některé moderní překladače provádí hned několik fází transformace mezikódu.&#160;<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k06"></a></p>
<h2 id="k06">6. Mezijazyk vs bajtkód</h2>

<p>Pojem <i>mezijazyk</i> nebo též <i>mezikód</i> je většinou používán
v&nbsp;souvislosti se sofistikovanými překladači, které překlad provádí
v&nbsp;několika fázích zmíněných <a href="#k02">v&nbsp;předchozím textu</a>.
Naproti tomu mnohé interpretry sice taktéž provádí překlad, ale výsledek se
namísto mezijazyk/mezikód nazývá <i>bajtkód</i>. Po technologické stránce se
mezijazyky a bajtkódy mohou do značné míry podobat, takže mnohdy význam obou
termínů splývá. Typicky obě technologie musí dokázat reprezentovat sekvenci
více či méně abstraktních instrukcí a navíc je nutné ukládat i metainformace
(jména souborů, čísla řádků, přístupová práva k&nbsp;funkcím a metodám atd.).
V&nbsp;operační paměti se v&nbsp;obou případech jedná o &bdquo;netextové&ldquo;
struktury. Samotný bajtkód je uložen do binárních souborů (mezikód se naproti
tomu většinou na disk neukládá).</p>

<p>Nejprve se ve stručnosti seznámíme s&nbsp;historií používání bajtkódu, která
je poměrně dlouhá a přitom i z&nbsp;programátorského hlediska zajímavá, protože
úspěch mnoha programovacích jazyků vycházel mj.&nbsp;i z&nbsp;toho, že se díky
použití bajtkódů (a s&nbsp;nimi souvisejících virtuálních strojů) mohly jejich
překladače snadno a relativně rychle rozšiřovat na různé platformy a
architektury počítačů (a to se v&nbsp;žádném případě netýká pouze Javy, jejíž
bajtkód se rozšířil na prakticky všechny architektury, ale dříve například i
Pascalu či BPCL, což je pradávný předchůdce rodiny jazyků C a C++).</p>

<p>Bajtkód je využíván především dvěma nástroji. Na jedné straně se jedná o
překladač (například v&nbsp;případě Javy to může být překladač
<strong>javac</strong>, API tohoto překladače dostupné v&nbsp;moderních JDK či
interní překladač využívaný nějakým integrovaným vývojovým prostředím), který
překládá zdrojový kód napsaný programátorem (či poloautomaticky vygenerovaný
v&nbsp;IDE :-) do bajtkódu; což mj.&nbsp;znamená, že je překlad zcela nezávislý
na použité platformě. Na straně druhé již jednou přeložený bajtkód využívá
interpret či dnes již v&nbsp;mnoha případech spíše JIT (<i>just in time</i>)
překladač. Ve skutečnosti však s&nbsp;bajtkódem může pracovat i mnoho dalších
nástrojů. Příkladem ve světě Javy a bajtkódu JVM mohou být například nástroje
typu <i>Cobertura</i> a <i>EMMA</i> sloužící pro zjištění, které části
zdrojového kódu aplikací jsou pokryty (jednotkovými) testy. Tyto nástroje musí
umět dobře kooperovat s&nbsp;virtuálním strojem Javy, proto nejprve modifikují
bajtkódy testovaných tříd, aby bylo možné při běhu testů dynamicky zjistit,
které řádky kódu jsou skutečně z&nbsp;testů volány.</p>

<p>Podobným způsobem je bajtkód modifikován nástroji podporujícími aspektově
orientované programování (<i>aspect oriented programming</i>), které taktéž
mohou zasahovat do bajtkódu vygenerovaného překladačem. Teoreticky je sice
možné při použití aspektově orientovaného programování transformovat přímo
zdrojové kódy programů (což je použito především v&nbsp;jiných programovacích
jazycích), ale transformace bajtkódu je v&nbsp;případě Javy mnohem snazší. Ze
stejného důvodu (analýza bajtkódu je jednodušší než analýza zdrojového textu)
je bajtkód použit pro statickou analýzu a hledání potenciálních chyb nástrojem
<i>FindBugs</i>.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je však mnohdy
výhodnější, když podobné nástroje pracují s&nbsp;AST a nikoli až
s&nbsp;výsledným bajtkódem.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Historie vývoje bajtkódu a jeho využití</h2>

<p>Myšlenka na využití bajtkódu pro překlad a následnou interpretaci programů
je v&nbsp;informatice úspěšně realizována a využívána již poměrně dlouhou dobu.
Jedním z&nbsp;prvních známých a rozšířených bajtkódů byl bajtkód nazvaný
<strong>OPCODE</strong>, který byl vyvinut pro potřeby programovacího jazyka
<strong>BCPL</strong>. Jazyk <strong>BPCL</strong> (<i>Basic Combined
Programming Language</i>), jenž byl vytvořen Martinem Richardsem již
v&nbsp;roce 1966, je z&nbsp;hlediska historie výpočetní techniky důležitý
především proto, že z&nbsp;něho Ken Thompson odvodil nový programovací jazyk
nazvaný jednoduše <strong>B</strong> a z&nbsp;jazyka <strong>B</strong> se
postupně vyvinulo klasické Céčko (nejdříve K&amp;R C, posléze dodnes používané
ANSI/ISO C následované C99, C11, C17, C23 a C2Y).</p>

<p>Výše zmíněný bajtkód <strong>OPCODE</strong> byl založen na instrukcích
pracujících se zásobníkem operandů (<i>operand stack</i>, viz další kapitoly) a
v&nbsp;práci s&nbsp;daty dostupnými přes indexové registry. Například výraz
<strong>x / y + z</strong> se pro proměnné <strong>x</strong>,
<strong>y</strong> a <strong>z</strong> uložené na pozicích 1, 2 a 10 přeložil
do bajtkódu <strong>OPCODE</strong> následujícím způsobem, který se nápadně
podobá bajtkódu JVM (což ostatně není náhoda, jak si řekneme dále):</p>

<pre>
LP   1
LP   2
DIV
LP   10
PLUS
</pre>

<p>Popularita používání bajtkódu byla úzce spojena i s&nbsp;úspěšností
takzvaného <strong>p-code</strong>, což byl (a ostatně stále ještě je) bajtkód
využívaný některými překladači programovacího jazyka Pascal (to se ovšem netýká
Turbo Pascalu, který se vydal vlastní značně odlišnou cestou). Díky využití
<strong>p-code</strong> bylo snadnější portovat jak překladač Pascalu na různé
platformy, tak i interpret vlastního p-kódu. Tento bajtkód je
v&nbsp;současnosti ještě využíván na některých školách při výuce IT; mj.&nbsp;i
z&nbsp;tohoto důvodu se jedná o stále živý projekt, o čemž ostatně mohou
svědčit i stránky projektu UCSD p-system Virtual Machine dostupné na adrese <a
href="http://ucsd-psystem-vm.sourceforge.net/">http://ucsd-psystem-vm.sourceforge.net/</a>.</p>

<p>Dále je na tomto místě vhodné zmínit bajtkód využívaný v&nbsp;ekosystému
programovacího jazyka <i>Smalltalk</i>. Jedná se o poměrně vysokoúrovňový
bajtkód, který se v&nbsp;některých ohledech přibližuje bajtkódu používaném
Pythonem (posílání zpráv je v&nbsp;tomto případě velmi podobné volání
virtuálních metod apod.). Mimochodem &ndash; velká část bajtkódu
<i>Smalltalku</i> je reflexivně dostupná i z&nbsp;vlastního jazyka, viz
například <a
href="http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png">http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png</a>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Bajtkód pro zásobníkové vs.&nbsp;registrové virtuální stroje</h2>

<p>Využívání bajtkódů má v&nbsp;současnosti za sebou zhruba čtyřicet let
postupného vývoje, takže pravděpodobně nebude příliš překvapující, že za tuto
(na IT) poměrně dlouhou dobu bylo navrženo a implementováno mnoho různých
řešení virtuálního stroje+bajtkódu, která se od sebe v&nbsp;mnoha ohledech
odlišovala, a to jak úrovní abstrakce bajtkódu (nízkoúrovňové instrukce dobře
transformovatelné na strojový kód vs.&nbsp;vysokoúrovňové instrukce podporující
například polymorfismus využívaný například virtuálním strojem Pythonu), tak i
způsobem, jakým jednotlivé instrukce pracovaly s&nbsp;argumenty
(resp.&nbsp;s&nbsp;operandy).</p>

<p>Naprostou většinu existujících a v&nbsp;současnosti používaných bajtkódů je
možné rozdělit do dvou skupin. V&nbsp;první skupině se nachází bajtkódy
zpracovávané virtuálními stroji založenými na zásobníku operandů (<i>operand
stack</i>) a ve druhé skupině se nachází bajtkódy využívající sadu registrů
(<i>register set</i>) nabízených virtuálním strojem (počet registrů může být
buď omezen na několik jednotek až desítek registrů nebo naopak prakticky
neomezen, takže se spíše jedná o paměť s&nbsp;izolovanými buňkami). Oba zmíněné
přístupy mají své přednosti i zápory a taktéž skalní zastánce i odpůrce, jak je
tomu ostatně v&nbsp;IT dobrým zvykem :-)</p>

<p>Bajtkódy a virtuální stroje využívající zásobník operandů a instrukce pro
práci s&nbsp;argumenty uloženými na tomto zásobníku většinou obsahují mnoho
bezparametrických instrukcí, jejichž operační kódy tak mohou být velmi krátké a
typicky bývají uloženy v&nbsp;jediném bajtu (z&nbsp;toho také ostatně označení
&bdquo;bajtkód&ldquo; vychází). Interpretace takového bajtkódu bývá velmi
jednoduchá a lze ji efektivně provádět i na těch mikroprocesorech, které
obsahují velmi malé množství pracovních registrů, z&nbsp;čehož ostatně vyplývá
i oblíbenost takto navržených bajtkódů v&nbsp;době osmibitových mikroprocesorů
a mikrořadičů (poněkud speciálním případem je jazyk <i>Forth</i>).</p>

<p>Před přibližně dvaceti lety, kdy se ve větší míře začaly rozšiřovat JIT
překladače, se předpokládalo, že nové JIT překladače budou mít problémy
s&nbsp;překladem instrukcí založených na použití zásobníku operandů do
strojového kódu moderních mikroprocesorů (ty mají většinou velkou sadu
pracovních registrů), ovšem ukázalo se, že JIT dokáží bez větších problémů
pracovat jak se zásobníkovými instrukcemi, tak i s&nbsp;instrukcemi
využívajícími sadu pracovních registrů VM (viz například JIT v&nbsp;JVM).</p>

<p>Tím se pomalu dostáváme ke druhému rozšířenému typu bajtkódů. Jedná se o
bajtkódy, jejichž instrukce dokážou pracovat s&nbsp;obsahem množiny pracovních
registrů zvoleného virtuálního stroje. Délka instrukčního slova i možnosti
takto navržených bajtkódů závisí především na počtu těchto pracovních registrů;
v&nbsp;moderních VM se setkáme minimálně s&nbsp;použitím šestnácti či 32
registry, což znamená, že mnoho instrukcí má délku minimálně dva bajty, mnohdy
i tři či čtyři bajty.</p>

<p>Liší se taktéž počet operandů instrukcí &ndash; některé bajtkódy využívají
takzvaný dvouadresový kód (používají dva registry &ndash; jeden registr
zdrojový a druhý registr současně zdrojový i cílový), jiné se zaměřují na
tříadresový kód (dva zdrojové registry a jeden registr cílový). Způsob
interpretace takto navržených bajtkódů může být problematičtější
v&nbsp;případě, že mikroprocesor, na němž interpret běží, obsahuje menší
množství fyzických pracovních registrů, ovšem (jak již bylo řečeno
v&nbsp;předchozím odstavci), při použití JIT se rozdíly mezi oběma způsoby
práce s&nbsp;operandy do značné míry rozostřují.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Praktická ukázka rozdílu mezi bajtkódem určeným pro zásobníkový a registrový virtuální stroj</h2>

<p>Podívejme se nyní na dvě ukázky, ze kterých bude patrné, jak se může lišit
bajtkód založený na zásobníkovém virtuálním stroji od bajtkódu, který je určen
pro registrový virtuální stroj. V&nbsp;obou příkladech se má vyhodnotit
jednoduchý výraz <strong>result = a+b*c-d</strong>; pro jednoduchost
předpokládejme, že všech pět proměnných je lokálních a současně mají typ celé
číslo (<i>integer</i>). Způsob překladu do bajtkódu využívajícího zásobník
operandů (konkrétně je v&nbsp;tomto případě použit bajtkód JVM) může vypadat
následovně:</p>

<pre>
              <i>; 0 je index proměnné <strong>a</strong></i>
              <i>; 1 je index proměnné <strong>b</strong></i>
              <i>; 2 je index proměnné <strong>c</strong></i>
              <i>; 3 je index proměnné <strong>d</strong></i>
              <i>; 4 je index proměnné <strong>result</strong></i>
0: iload  0   <i>; uložení obsahu proměnné <strong>a</strong> na zásobník</i>
1: iload  1   <i>; uložení obsahu proměnné <strong>b</strong> na zásobník</i>
2: iload  2   <i>; uložení obsahu proměnné <strong>c</strong> na zásobník</i>
3: imul       <i>; provedení operace <strong>b*c</strong>, výsledek je ponechán na zásobníku</i>
4: iadd       <i>; provedení operace <strong>a+(b*c)</strong></i>
5: iload  3   <i>; uložení obsahu proměnné <strong>d</strong> na zásobník</i>
6: isub       <i>; dokončit příkaz <strong>a+(b*c)+d</strong></i>
7: istore 4   <i>; uložení výsledku z TOS (obsah zásobníku operandů) do proměnné <strong>result</strong></i>
</pre>

<p>Příklad kompilace téhož příkazu <strong>result = a+b*c-d</strong> do
bajtkódu využívajícího pracovní registry, konkrétně do bajtkódu využívaného
programovacím jazykem Lua:</p>

<pre>
                               <i>; 0 je index proměnné <strong>a</strong></i>
                               <i>; 1 je index proměnné <strong>b</strong></i>
                               <i>; 2 je index proměnné <strong>c</strong></i>
                               <i>; 3 je index proměnné <strong>d</strong></i>
                               <i>; 4 je index proměnné <strong>result</strong></i>
1       [101]   MUL    4 1 2   <i>; přímé vynásobení obsahu proměnných <strong>b</strong> a <strong>c</strong></i>
2       [101]   ADD    4 0 4   <i>; přičíst k obsahu proměnné <strong>a</strong> mezivýsledek, výsledek uložit do proměnné <strong>result</strong></i>
3       [101]   SUB    4 4 3   <i>; odečíst od mezivýsledku obsah proměnné <strong>b</strong>, výsledek uložit do proměnné <strong>result</strong></i>
</pre>

<p>Ve druhém případě se nemusely vůbec použít instrukce pro uložení proměnných
na zásobník ani pro načtení hodnoty zpět ze zásobníku operandů do proměnné,
ovšem na druhou stranu musely mít všechny aritmetické instrukce
v&nbsp;instrukčním slovu uloženy i indexy operandů.</p>

<p><div class="rs-tip-major">Poznámka: bajtkód Pythonu je postaven na zásobníku
operandů a překlad stejného výrazu bude proveden následovně:</div></p>

<pre>
LOAD_FAST_BORROW_LOAD_FAST_BORROW 1 (a, b)  <i>; uložení dvou proměnných <strong>a</strong> a <strong>b</strong> na zásobník</i>
LOAD_FAST_BORROW         2 (c)              <i>; uložení proměnné <strong>c</strong> na zásobník</i>
BINARY_OP                5 (*)              <i>; provedení výpočtu <strong>b*c</strong> s&nbsp;uložením výsledku</i>
BINARY_OP                0 (+)              <i>; provedení výpočtu <strong>a+b*c</strong> s&nbsp;uložením výsledku</i>
LOAD_FAST_BORROW         3 (d)              <i>; uložení proměnné <strong>d</strong> na zásobník</i>
BINARY_OP               10 (-)              <i>; provedení výpočtu <strong>a+b*c-d</strong> s&nbsp;uložením výsledku</i>
STORE_FAST               4 (result)         <i>; výsledek je ze zásobníku umístěn do proměnné <strong>result</strong></i>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Bajtkód virtuálního stroje jazyka Java (JVM)</h2>

<p>První typ v&nbsp;současnosti používaného bajtkódu, s&nbsp;nímž se ve stručnosti seznámíme, je bajtkód využívaný JVM. Virtuální stroj jazyka Java samozřejmě využívá jiný soubor &bdquo;strojových&ldquo; instrukcí, než fyzický mikroprocesor, na němž jsou Javovské programy spouštěny. Dokonce ani mikroprocesory určené pro přímé spouštění bajtkódu &ndash; dnes již zpola zapomenuté projekty <i>MicroJava</i> a <i>PicoJava</i>, dokonce i ARM procesory s&nbsp;technologií <i>Jazelle</i> &ndash; nedokázaly nativně vykonávat všechny instrukce bajtkódu. V&nbsp;prvních několika letech existence Javy byly instrukce bajtkódu (tvořící těla jednotlivých metod) v&nbsp;naprosté většině případů pouze interpretovány, a to mnohdy velmi jednoduchým způsobem: v&nbsp;programové smyčce se postupně načítaly kódy jednotlivých instrukcí a následně se pro každou instrukci zavolala nativní funkce, která danou instrukci vykonala, většinou s&nbsp;parametry uloženými v&nbsp;zásobníkovém rámci nebo v&nbsp;zásobníku operandů (bližší popis bude uveden v&nbsp;následujících kapitolách).</p>

<p>Naprogramování naivního interpretru pro bajtkód virtuálního stroje Javy není příliš složité, protože samotná instrukční sada je poměrně jednoduchá. Moderní interpretry, například již v&nbsp;tomto seriálu popsaný <a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">JamVM</a>, jsou navíc naprogramovány takovým způsobem, aby byl jejich přenos na další procesorové architektury snadný a přitom se bajtkód interpretoval co nejefektivnějším způsobem, ideálně s&nbsp;ručně optimalizovanou vnitřní smyčkou (naprogramovanou v&nbsp;případě ručně prováděných optimalizací většinou assembleru).</p>

<p>Ovšem i přes veškerou snahu programátorů interpretrů nemůže běh programů napsaných v&nbsp;Javě a spouštěných v&nbsp;JVM s&nbsp;interpretovaným bajtkódem v&nbsp;rychlosti soutěžit s&nbsp;nativními aplikacemi. Právě z&nbsp;tohoto důvodu vznikly takzvané <i>just-in-time (JIT)</i> překladače, které dokážou přeložit buď jen určitou sekvenci instrukcí JVM nebo i celý bajtkód do nativního strojového kódu, který je následně spuštěn. Některé JIT překladače, například stále populární <i>HotSpot</i> původně vyvinutý společností Sun Microsystems, používají <i>adaptivní překlad</i>, v&nbsp;němž je bajtkód analyzován v&nbsp;době běhu, takže má JIT překladač k&nbsp;dispozici mnohem více informací, než při statickém překladu. <i>HotSpot</i> navíc umožňuje pomocí takzvaný sond (<i>probes</i> sledovat, který kód je překládán a jaký typ překladu je přitom použit, to je však již poměrně pokročilá a nepříliš často používaná technologie. Ovšem nezávisle na tom, zda jsou instrukce JVM &bdquo;pouze&ldquo; interpretovány, nebo je nejdříve použit <i>JIT</i>, musí být vždy dodrženy všechny vlastnosti jazyka Java i JVM. <i>JIT</i> například může odstranit kontrolu mezí při indexování polí, ale jen tehdy, když je zřejmé, že nedojde k&nbsp;překročení těchto mezí.</p>

<p>V&nbsp;této kapitole si ve stručnosti připomeneme základní vlastnosti bajtkódu virtuálního stroje Javy. Struktura i vlastnosti JVM jsou přesně popsány ve specifikaci JVM, včetně přesného formátu všech datových typů (znaků, celých čísel, čísel s&nbsp;plovoucí řádovou tečkou). Díky dodržování této specifikace různými výrobci virtuálního stroje Javy je zaručeno, že programy napsané v&nbsp;Javě jsou přenositelné na počítače s&nbsp;mnohdy velmi rozdílnou architekturou: od smartphonů s&nbsp;jednojádrovými mikroprocesory až po superpočítače s&nbsp;velkým množstvím výpočetních uzlů a mnohdy s&nbsp;několika desítkami tisíc procesorových jader. Různé nekompatibility, s&nbsp;nimiž programátoři bojovali především v&nbsp;minulosti (ale samozřejmě i dnes, i když v&nbsp;mnohem menší míře), bývají způsobeny buď chybami v&nbsp;implementaci některého virtuálního stroje (a nedodržení specifikace lze považovat za chybu) či nekompatibilitami ve standardních knihovnách, popř.&nbsp;chybami v&nbsp;nativních knihovnách, které lze z&nbsp;JVM volat.</p>

<p>Specifikace virtuálního stroje Javy popisuje některé jeho části velmi precizně (například se jedná o již zmíněné datové typy či o formát instrukcí nebo o strukturu zásobníkového rámce), ovšem u některých dalších částí jsou popsány jen základní vlastnosti a zůstává pouze na tvůrci konkrétní JVM, jakým způsobem se bude daná část virtuálního stroje ve skutečnosti implementovat. Asi nejtypičtějším příkladem je specifikace haldy (<i>heap</i>), u níž se sice předpokládá využití automatické správy paměti, ale nikde již není řečeno, jaký konkrétní algoritmus správy paměti se má použít (v&nbsp;současnosti se využívá hned několik algoritmů) ani jaký formát má být použit pro ukládání referencí na objekty. Díky tomu bylo možné Javu jednoduše přenést z&nbsp;původní 32bitové architektury jak na 16bitové procesory, tak i na procesory pracující s&nbsp;64bitovými ukazateli (u nichž lze navíc v&nbsp;případě potřeby využít i <a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">komprimované ukazatele na objekty</a>) &ndash; to vše bez nutnosti zásahu do zdrojových kódů Javovských programů i bez nutnosti jejich rekompilace.</p>

<p>Virtuální stroj jazyka Java obsahuje instrukce, které pracují s&nbsp;operandy několika datových typů. Na rozdíl od mnoha fyzických procesorů se v&nbsp;případě JVM provádí kontroly, zda jsou operace skutečně aplikovány na správné operandy. Není například možné, aby se operace součtu prováděla s&nbsp;jedním operandem typu <strong>int</strong> a druhým operandem typu <strong>long</strong> &ndash; takový bajtkód by byl při svém načítání odmítnut a vůbec by nebyl spuštěn (to však jinými slovy znamená, že bajtkód je zbytečně redundantní, zejména v&nbsp;porovnání s&nbsp;bajtkódy jazyků Lua a Python).  Zajímavé je, že jen velmi málo instrukcí JVM podporuje práci s&nbsp;datovými typy <strong>boolean</strong>, <strong>byte</strong>, <strong>short</strong> a <strong>char</strong>. Proměnné a parametry metod těchto typů musí být například před provedením některé aritmetické operace nejprve převedeny na typ <strong>int</strong> pomocí konverzních instrukcí (těch existuje celkem patnáct).</p>

<p>Většina instrukcí virtuálního stroje Javy pracuje s&nbsp;operandy uloženými na takzvaném <i>zásobníku operandů (operand stack)</i>. Zásobník operandů (v&nbsp;tomto případě se již jedná o skutečný zásobník typu <i>LIFO &ndash; Last In, First Out</i>) je vytvářen v&nbsp;čase běhu aplikace pro každou zavolanou metodu, což mj.&nbsp;znamená, že je při spuštění metody vždy prázdný (zásobník operandů je podle specifikace součástí zásobníkového rámce, jeho konkrétní umístění však je libovolné). Již v&nbsp;čase překladu zdrojového kódu je pro každou metodu zjištěno, jak velká oblast paměti má být pro zásobník operandů vyhrazena a samozřejmě je prováděna kontrola, zda se v&nbsp;době běhu aplikace tato velikost nepřekročí (to by se nemělo u validního bajtkódu stát).</p>

<p>Virtuální stroj Javy kontroluje typy operandů uložených na zásobník operandů a zajišťuje, že se nad těmito operandy budou provádět pouze typově bezpečné operace. V&nbsp;praxi to například znamená, že není možné na zásobník uložit dvě hodnoty typu <strong>float</strong> a následně provést instrukci <strong>iadd</strong>, protože tato instrukce vyžaduje, aby na zásobníku byly uloženy dvě hodnoty typu <strong>int</strong> (i když <strong>float</strong> i <strong>int</strong> mají shodnou bitovou šířku).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příklady metod přeložených do bajtkódu JVM</h2>

<p>Základní vlastnosti bajtkódu virtuálního stroje Javy si ukážeme na způsobu překladu testovací třídy obsahující několik statických metod. Tím, že jsou všechny testované metody statické, je zajištěno, že se jim nebude předávat další (ve zdrojovém kódu skrytý) parametr <strong>this</strong>, jiný významnější rozdíl mezi statickými a nestatickými metodami v&nbsp;bajtkódu nenajdeme. První dvě metody <strong>nop1()</strong> a <strong>nop2()</strong> jsou bezparametrické, mají prázdné tělo a nevrací žádnou hodnotu, takže lze předpokládat, že jejich bajtkód bude velmi jednoduchý. Další metoda, která se jmenuje <strong>answer()</strong>, je taktéž bezparametrická, ale vrací konstantní celočíselnou hodnotu 42. Následuje přetížená metoda <strong>add()</strong>, jejíž jednotlivé varianty akceptují různé celočíselné i reálné hodnoty; poslední varianta této metody spojuje řetězce (a to stejným operátorem +). Na příkladu metod <strong>add()</strong> si povšimněte toho, že operace + není pro datové typy <strong>byte</strong> a <strong>short</strong> uzavřena (výsledkem je hodnota typu <strong>int</strong>), což vychází z&nbsp;vlastností bajtkódu. Ostatně ani další aritmetické operace pro tyto datové typy taktéž nejsou uzavřeny.</p>

<p>Následuje další testovací metoda pojmenovaná <strong>isNegative()</strong> obsahující podmíněný příkaz. Ten by zde ve skutečnosti nemusel být uveden, neboť celé tělo metody lze zkrátit do jediného výrazu, jehož výsledek by byl vracen příkazem <strong>return</strong>, ovšem my potřebujeme zjistit, jakým způsobem se do bajtkódu JVM překládají konstrukce typu <strong>if-then-else</strong>. Ve zdrojovém kódu metody <strong>fibonacciIter()</strong> jsou použity jak podmínky, tak i počítaná programová smyčka typu <strong>for</strong> a v&nbsp;poslední testované metodě <strong>fibonacciRecursive()</strong> je použita rekurze, tj.&nbsp;metoda přímo volá samu sebe. Podívejme se nyní na celý zdrojový kód testovací třídy::</p>

<pre>
<i>/**</i>
<i> * Trida s nekolika jednoduchymi statickymi metodami</i>
<i> * pro otestovani zakladnich vlastnosti bajtkodu JVM.</i>
<i> */</i>
public class <strong>Test</strong> {
&nbsp;
    <i>/**</i>
    <i> * Prazdna metoda bez parametru.</i>
    <i> */</i>
    public static void <strong>nop1</strong>() {
    }
&nbsp;
    <i>/**</i>
    <i> * Taktez prazdna metoda bez parametru.</i>
    <i> */</i>
    public static void <strong>nop2</strong>() {
        return;
    }
&nbsp;
    <i>/**</i>
    <i> * Metoda bez parametru vracejici konstantu.</i>
    <i> */</i>
    public static int <strong>answer</strong>() {
        return 42;
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu byte.</i>
    <i> */</i>
    public static byte <strong>add</strong>(byte x, byte y) {
        return (byte)(x+y);
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu short.</i>
    <i> */</i>
    public static short <strong>add</strong>(short x, short y) {
        return (short)(x+y);
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu int.</i>
    <i> */</i>
    public static int <strong>add</strong>(int x, int y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu long.</i>
    <i> */</i>
    public static long <strong>add</strong>(long x, long y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu float.</i>
    <i> */</i>
    public static float <strong>add</strong>(float x, float y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu double.</i>
    <i> */</i>
    public static double <strong>add</strong>(double x, double y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Spojeni dvou retezcu.</i>
    <i> */</i>
    public static String <strong>add</strong>(String x, String y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Metoda s podminkou.</i>
    <i> */</i>
    public static boolean <strong>isNegative</strong>(int x) {
        if (x &lt; 0) {
            return true;
        }
        return false;
    }
&nbsp;
    <i>/**</i>
    <i> * Metoda s podminkou a se smyckou.</i>
    <i> */</i>
    public static long <strong>fibonacciIter</strong>(int n) {
        if (n &lt;= 1) {
            return n;
        }
        long result = 0;
        long n1 = 0;
        long n2 = 1;
        for(n--; n &gt; 0; n--) {
            result = n1 + n2;
            n1 = n2;
            n2 = result;
        }
        return result;
    }
&nbsp;
    <i>/**</i>
    <i> * Metoda s rekurzi.</i>
    <i> */</i>
    public static long <strong>fibonacciRecursive</strong>(int n) {
        if (n &lt;= 1) {
            return n;
        }
        else {
            return fibonacciRecursive(n-1) + fibonacciRecursive(n-2);
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Vse je nutne otestovat.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        nop1();
        nop2();
        System.out.println(answer());
        System.out.println(add((byte)1, (byte)2));
        System.out.println(add((short)1, (short)2));
        System.out.println(add(1, 2));
        System.out.println(add(1L, 2L));
        System.out.println(add(1f, 2f));
        System.out.println(add(1., 2.));
        System.out.println(add("Hello ", "world!"));
        System.out.println(isNegative(-10));
&nbsp;
        for (int n=0; n &lt;= 10; n++) {
            System.out.println(n + "\t" + fibonacciIter(n) + "\t" + fibonacciRecursive(n));
        }
&nbsp;
    }
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Bajtkód využívaný interpretrem jazykem Lua</h2>

<p>Dalším bajtkódem, s&nbsp;nímž se v&nbsp;dnešním článku alespoň ve stručnosti
seznámíme, je bajtkód využívaný programovacím jazykem <i>Lua</i>. Bajtkód
tohoto jazyka se v&nbsp;mnoha ohledech odlišuje od bajtkódu JVM. Pravděpodobně
nejnápadnějším rozdílem mezi bajtkódem JVM a bajtkódem jazyka Lua je fakt, že
se v&nbsp;Lua VM nepoužívá zásobník operandů, protože indexy operandů jsou
přímo součástí instrukčního slova.</p>

<p>I formát instrukčních kódů je od JVM velmi odlišný, protože zatímco
v&nbsp;případě bajtkódu JVM je kód instrukce uložen v&nbsp;celém bajtu
(s&nbsp;několika málo výjimkami), je u Lua VM kód instrukce uložen
v&nbsp;pouhých šesti bitech, zatímco zbylých 26 bitů instrukčního slova je
rezervováno pro uložení indexů operandů či konstant. Bytekód Lua VM taktéž
obsahuje spíše vysokoúrovňové instrukce, které dobře reflektují vlastnosti
tohoto programovacího jazyka. Existují například instrukce pro implementaci
programové smyčky <strong>for</strong>, instrukce pro práci
s&nbsp;(asociativními) poli tvořícími nejdůležitější strukturovaný datový typ
jazyka Lua a dokonce se v&nbsp;bajtkódu nachází instrukce pro vytvoření uzávěru
(<i>closure</i>) a pro tail call.</p>

<p>Instrukce mohou mít jeden z&nbsp;následujících formátů:</p>

<h3>iABC</h3>

<table>
<tr><th>#</th><th>Označení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index či hodnota prvního operandu</td></tr>
<tr><td>3</td><td>B</td><td>9</td><td>index či hodnota druhého operandu</td></tr>
<tr><td>4</td><td>C</td><td>9</td><td>index či hodnota třetího operandu</td></tr>
</table>

<h3>iABx</h3>

<table>
<tr><th>#</th><th>Označení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index či hodnota prvního operandu</td></tr>
<tr><td>3</td><td>Bx</td><td>18</td><td>index či hodnota druhého operandu</td></tr>
</table>

<h3>iAsBx</h3>

<table>
<tr><th>#</th><th>Označení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index či hodnota prvního operandu</td></tr>
<tr><td>3</td><td>sBx</td><td>18</td><td>index či hodnota druhého operandu (zde se znaménkem)</td></tr>
</table>

<h3>iAx</h3>

<table>
<tr><th>#</th><th>Označení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>Ax</td><td>26</td><td>index či hodnota prvního (jediného) operandu</td></tr>
</table>

<h3>isJ</h3>

<table>
<tr><th>#</th><th>Označení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>5</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>sJ</td><td>26</td><td>cíl skoku</td></tr>
<tr><td>3</td><td>k</td><td>1</td><td>registr nebo konstanta</td></tr>
</table>

*** image ***



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Mezikódy používané v&nbsp;GCC</h2>

<p>V&nbsp;ekosystému překladačů GCC se můžeme setkat s&nbsp;několika typy
mezijazyků resp.&nbsp;mezikódu. Celý proces překladu je totiž rozdělen do mnoha
fází a v&nbsp;každé fázi je možné si výsledek příslušné transformace
prohlédnout, i když je nutné na tomto místě poznamenat, že (na rozdíl od dále
zmíněného LLVM IR) jsou mezijazyky GCC považovány za interní záležitost
překladače a nemusí tak být příliš stabilní (je tomu tak naschvál &ndash; aby
se zamezilo využití/zneužití části GCC v&nbsp;komerčních překladačích).
V&nbsp;každém případě se v&nbsp;moderním GCC setkáme s&nbsp;mezijazyky
<i>GIMPLE (GNU IMPLEmentation)</i> a <i>RTL (Register Transfer Language)</i>.
Těmto mezijazykům bude věnován celý samostatný článek, ovšem v&nbsp;navazující
kapitole si alespoň ve stručnosti ukážeme, jak mohou výsledky jednotlivých fází
překladu vypadat v&nbsp;případě, že si vyžádáme jejich výpis (jedná se o
operaci typu <i>dump</i>, ostatně přesně tak se jmenují i přepínače GCC, které
výpis zajistí).</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Překlad výpočtu do mezikódu GIMPLE a RTL</h2>

<p>Překládat budeme dvojici funkcí, které provádí součet, součin a rozdíl
celočíselných hodnot. První z&nbsp;těchto funkcí zpracovává hodnoty bez
znaménka:</p>

<pre>
unsigned int <strong>addX</strong>(unsigned int a, unsigned int b, unsigned int c, unsigned int d) {
    return a+b*c-d;
}
</pre>

<p>Druhá funkce zpracovává hodnoty se znaménkem (a přitom neřešení přetečení,
což je nedefinovaná operace):</p>

<pre>
signed int <strong>addX</strong>(signed int a, signed int b, signed int c, signed int d) {
    return a+b*c-d;
}
</pre>

<p>Výsledek transformace přes AST do mezijazyka GIMPLE dopadne takto:</p>

<pre>
unsigned int <strong>addX</strong> (unsigned int a, unsigned int b, unsigned int c, unsigned int d)
{
  unsigned int D.2838;
&nbsp;
  _1 = b * c;
  _2 = a + _1;
  D.2838 = _2 - d;
  return D.2838;
}
</pre>

<p>a:</p>

<pre>
int <strong>addX</strong> (int a, int b, int c, int d)
{
  int D.2838;
&nbsp;
  _1 = b * c;
  _2 = a + _1;
  D.2838 = _2 - d;
  return D.2838;
}
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o typovaný kód, který má ovšem
jednodušší výrazy (jsou maximálně tříadresové).</div></p>

<p>Překlad v&nbsp;pozdější fázi už vypadá odlišně:</p>

<pre>
unsigned int addX (unsigned int a, unsigned int b, unsigned int c, unsigned int d)
{
  unsigned int D.2838;
  unsigned int _1;
  unsigned int _2;
  unsigned int _7;
&nbsp;
  &lt;bb 2&gt; :
  _1 = b_3(D) * c_4(D);
  _2 = a_5(D) + _1;
  _7 = _2 - d_6(D);
&nbsp;
  &lt;bb 3&gt; :
&lt;L0&gt;:
  return _7;
}
</pre>

<p>Dtto pro druhou funkci:</p>

<pre>
int addX (int a, int b, int c, int d)
{
  int D.2838;
  int _1;
  int _2;
  int _7;
&nbsp;
  &lt;bb 2&gt; :
  _1 = b_3(D) * c_4(D);
  _2 = a_5(D) + _1;
  _7 = _2 - d_6(D);
&nbsp;
  &lt;bb 3&gt; :
&lt;L0&gt;:
  return _7;
}
</pre>

<p>Výstup do RTL používá LISPovskou notaci (RMS se nezapře):</p>

<pre>
(note 1 0 7 NOTE_INSN_DELETED)
(note 7 1 26 2 [bb 2] NOTE_INSN_BASIC_BLOCK)
(insn/f 26 7 27 2 (set (mem:DI (pre_dec:DI (reg/f:DI 7 sp)) [0  S8 A8])
        (reg/f:DI 6 bp)) "add_unsigned.c":1:82 69 {*pushdi2_rex64}
     (nil))
(insn/f 27 26 28 2 (set (reg/f:DI 6 bp)
        (reg/f:DI 7 sp)) "add_unsigned.c":1:82 95 {*movdi_internal}
     (nil))
(insn 28 27 29 2 (set (mem/v:BLK (scratch:DI) [0  A8])
        (unspec:BLK [
                (mem/v:BLK (scratch:DI) [0  A8])
            ] UNSPEC_MEMORY_BLOCKAGE)) "add_unsigned.c":1:82 1487 {*memory_blockage}
     (nil))
(note 29 28 2 2 NOTE_INSN_PROLOGUE_END)
(insn 2 29 3 2 (set (mem/c:SI (plus:DI (reg/f:DI 6 bp)
                (const_int -4 [0xfffffffffffffffc])) [1 a+0 S4 A32])
        (reg:SI 5 di [ a ])) "add_unsigned.c":1:82 96 {*movsi_internal}
     (nil))
(insn 3 2 4 2 (set (mem/c:SI (plus:DI (reg/f:DI 6 bp)
                (const_int -8 [0xfffffffffffffff8])) [1 b+0 S4 A32])
        (reg:SI 4 si [ b ])) "add_unsigned.c":1:82 96 {*movsi_internal}
     (nil))
(insn 4 3 5 2 (set (mem/c:SI (plus:DI (reg/f:DI 6 bp)
                (const_int -12 [0xfffffffffffffff4])) [1 c+0 S4 A32])
        (reg:SI 1 dx [ c ])) "add_unsigned.c":1:82 96 {*movsi_internal}
     (nil))
(insn 5 4 6 2 (set (mem/c:SI (plus:DI (reg/f:DI 6 bp)
                (const_int -16 [0xfffffffffffffff0])) [1 d+0 S4 A32])
        (reg:SI 2 cx [ d ])) "add_unsigned.c":1:82 96 {*movsi_internal}
     (nil))
(note 6 5 9 2 NOTE_INSN_FUNCTION_BEG)
(insn 9 6 10 2 (set (reg:SI 0 ax [102])
        (mem/c:SI (plus:DI (reg/f:DI 6 bp)
                (const_int -8 [0xfffffffffffffff8])) [1 b+0 S4 A32])) "add_unsigned.c":2:15 96 {*movsi_internal}
     (nil))
(insn 10 9 25 2 (parallel [
            (set (reg:SI 0 ax [102])
                (mult:SI (reg:SI 0 ax [102])
                    (mem/c:SI (plus:DI (reg/f:DI 6 bp)
                            (const_int -12 [0xfffffffffffffff4])) [1 c+0 S4 A32])))
            (clobber (reg:CC 17 flags))
        ]) "add_unsigned.c":2:15 593 {*mulsi3_1}
     (nil))
(insn 25 10 11 2 (set (reg:SI 1 dx [orig:98 _1 ] [98])
        (reg:SI 0 ax [102])) "add_unsigned.c":2:15 96 {*movsi_internal}
     (nil))
(insn 11 25 12 2 (set (reg:SI 0 ax [103])
        (mem/c:SI (plus:DI (reg/f:DI 6 bp)
                (const_int -4 [0xfffffffffffffffc])) [1 a+0 S4 A32])) "add_unsigned.c":2:13 96 {*movsi_internal}
     (nil))
(insn 12 11 13 2 (parallel [
            (set (reg:SI 0 ax [orig:99 _2 ] [99])
                (plus:SI (reg:SI 0 ax [103])
                    (reg:SI 1 dx [orig:98 _1 ] [98])))
            (clobber (reg:CC 17 flags))
        ]) "add_unsigned.c":2:13 283 {*addsi_1}
     (expr_list:REG_EQUAL (plus:SI (reg:SI 1 dx [orig:98 _1 ] [98])
            (mem/c:SI (plus:DI (reg/f:DI 19 frame)
                    (const_int -4 [0xfffffffffffffffc])) [1 a+0 S4 A32]))
        (nil)))
(insn 13 12 21 2 (parallel [
            (set (reg:SI 0 ax [orig:100 _7 ] [100])
                (minus:SI (reg:SI 0 ax [orig:99 _2 ] [99])
                    (mem/c:SI (plus:DI (reg/f:DI 6 bp)
                            (const_int -16 [0xfffffffffffffff0])) [1 d+0 S4 A32])))
            (clobber (reg:CC 17 flags))
        ]) "add_unsigned.c":2:17 389 {*subsi_1}
     (nil))
(insn 21 13 30 2 (use (reg/i:SI 0 ax)) "add_unsigned.c":3:1 -1
     (nil))
(note 30 21 31 2 NOTE_INSN_EPILOGUE_BEG)
(insn 31 30 32 2 (set (mem/v:BLK (scratch:DI) [0  A8])
        (unspec:BLK [
                (mem/v:BLK (scratch:DI) [0  A8])
            ] UNSPEC_MEMORY_BLOCKAGE)) "add_unsigned.c":3:1 1487 {*memory_blockage}
     (nil))
(insn/f 32 31 33 2 (set (reg/f:DI 6 bp)
        (mem:DI (post_inc:DI (reg/f:DI 7 sp)) [0  S8 A8])) "add_unsigned.c":3:1 77 {*popdi1}
     (expr_list:REG_CFA_DEF_CFA (plus:DI (reg/f:DI 7 sp)
            (const_int 8 [0x8]))
        (nil)))
(jump_insn 33 32 34 2 (simple_return) "add_unsigned.c":3:1 1489 {simple_return_internal}
     (nil)
 -&gt; simple_return)
(barrier 34 33 23)
(note 23 34 0 NOTE_INSN_DELETED)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. LLVM IR</h2>

<p>V&nbsp;závěru dnešního článku se ještě musíme zmínit o pravděpodobně
největší konkurenci ke GCC. Je jím ekosystém postavený okolo projektu LLVM,
kterému se budeme podrobněji věnovat v&nbsp;navazujícím článku. V&nbsp;LLVM je
překlad rozdělen do většího množství fází. První fáze překladu jsou provedeny
<i>frontend</i> překladači, mezi něž patří například Clang. A naopak závěrečné
fáze překladu (cílené pro konkrétní operační systém a architekturu
mikroprocesorů) jsou prováděny v&nbsp;<i>backend</i> překladači. Mezi těmito
fázemi je překládaný program reprezentován v&nbsp;mezikódu/mezijazyku nazývaném
<i>LLVM IR</i> (<i>IR=Intermediate Representation</i>). Ten se do určité míry
podobá assemblerům RISCových mikroprocesorů, ovšem veškeré argumenty předávané
do funkcí, lokální proměnné atd. jsou silně typované. Navíc je LLVM IR navržen
takovým způsobem, aby umožňoval překlad pro všechny moderní typy mikroprocesorů
a mikrořadičů.</p>

*** image ***



<p><a name="k18"></a></p>
<h2 id="k18">18. Překlad výpočtu do LLVM IR</h2>

<p>Abychom si alespoň ve stručnosti přiblížili, jak LLVM IR vypadá, necháme si
do něj přeložit funkci pro součet, součin a rozdíl celočíselných hodnot bez
znaménka:</p>

<pre>
unsigned int <strong>addX</strong>(unsigned int a, unsigned int b, unsigned int c, unsigned int d) {
    return a+b*c-d;
}
</pre>

<p>Příslušný soubor s&nbsp;výsledkem překladu do LLVM IR (pro architekturu
x86-64 a se zapnutými optimalizacemi) bude mít tvar:</p>

<pre>
<i>; ModuleID = 'add_unsigned.c'</i>
source_filename = "add_unsigned.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-redhat-linux-gnu"
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local noundef i32 @addX(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #0 {
  %5 = mul i32 %2, %1
  %6 = add i32 %5, %0
  %7 = sub i32 %6, %3
  ret i32 %7
}
&nbsp;
attributes #0 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
&nbsp;
!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}
&nbsp;
!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
!2 = !{!"clang version 20.1.8 (Fedora 20.1.8-4.fc42)"}
</pre>

<p>Kromě mnoha dalších (meta)informací zde nalezneme i funkci přeloženou do
mezikódu. Povšimněte si, že se jedná o kód, ve kterém zůstaly informace o
datových typech parametrů i návratové hodnoty funkce:</p>

<pre>
define dso_local noundef i32 @addX(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #0 {
  %5 = mul i32 %2, %1
  %6 = add i32 %5, %0
  %7 = sub i32 %6, %3
  ret i32 %7
}
</pre>

<p>Zajímavěji dopadne překlad podobné funkce, ovšem zpracovávající celočíselné
hodnoty se znaménkem:</p>

<pre>
signed int <strong>addX</strong>(signed int a, signed int b, signed int c, signed int d) {
    return a+b*c-d;
}
</pre>

<p>Výsledek překladu do LLVM IR:</p>

<pre>
<i>; ModuleID = 'add_signed.c'</i>
source_filename = "add_signed.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-redhat-linux-gnu"
&nbsp;
<i>; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable</i>
define dso_local i32 @addX(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #0 {
  %5 = mul nsw i32 %2, %1
  %6 = add nsw i32 %5, %0
  %7 = sub i32 %6, %3
  ret i32 %7
}
&nbsp;
attributes #0 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
&nbsp;
!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}
&nbsp;
!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
!2 = !{!"clang version 20.1.8 (Fedora 20.1.8-4.fc42)"}
</pre>

<p>Mohlo by se zdát, že výsledné pseudoinstrukce jsou prakticky totožné, ale
povšimněte si slov <strong>nsw</strong>. V&nbsp;tomto konkrétním případě to
znamená, že pokud dojde k&nbsp;přetečení výsledku operace, je výsledek obecně
nedefinovaný (<i>undefined behaviour</i>) a tudíž má backend překladač velkou
volnost při optimalizacích a generování výsledného strojového kódu:</p>

<pre>
define dso_local i32 @add(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #0 {
  %5 = mul <strong>nsw</strong> i32 %2, %1
  %6 = add <strong>nsw</strong> i32 %5, %0
  %7 = sub i32 %6, %3
  ret i32 %7
}
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se jen o malou ukázku toho, že
LLVM IR není ani zdaleka pouze &bdquo;primitivním&ldquo; assemblerem.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Obsah navazujícího článku</h2>

<p>V&nbsp;dnešním článku byly popsány různé technologie a postupy, které jsou
využívané různými typy překladačů a interpretrů. Jelikož se jednotlivé
technologie od sebe mnohdy značně odlišují, nebylo je možné popsat podrobněji.
Z&nbsp;tohoto důvodu se v&nbsp;navazujícím článku zaměříme pouze na jediný
překladač, a to konkrétně na <i>Clang</i> a <i>LLVM</i>. Popíšeme si zejména
mezijazyk <i>LLVM IR</i>, který je navržen takovým způsobem, aby na jedné
straně dokázal s&nbsp;rozumnou úrovní abstrakce popsat zdrojové kódy zapisované
v&nbsp;různých programovacích jazycích a na straně druhé aby ho bylo možné
použít pro vygenerování spustitelného strojového kódu pro různé platformy, a to
včetně těch platforem, které podporují pokročilé SIMD operace a popř.&nbsp;i
souběh různých částí kódu běžících v&nbsp;odlišných vláknech. Jak v&nbsp;článku
uvidíme, je <i>LLVM IR</i> sice zpočátku poměrně nečitelný, ale po krátkém
zaučení umožňuje sledovat fáze překladu, použité optimalizační metody atd.</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Is intermediate representation (such as bytecodes or .net IL) still an advantage?<br />
<a href="https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage">https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage</a>
</li>

<li>Intermediate Representation vs Byte Code<br />
<a href="https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code">https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code</a>
</li>

<li>Getting the intermediate representation in gcc<br />
<a href="https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2">https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2</a>
</li>

<li>Intermediate Representations<br />
<a href="https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/">https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/</a>
</li>

<li>Why do we use intermediate representations / languages?<br />
<a href="https://mortoray.com/why-we-use-intermediate-representations/">https://mortoray.com/why-we-use-intermediate-representations/</a>
</li>

<li>Unwrapping intermediate representations<br />
<a href="https://mortoray.com/unwrapping-intermediate-representations/">https://mortoray.com/unwrapping-intermediate-representations/</a>
</li>

<li>Understanding Python Code Flow From Source to Execution<br />
<a href="https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83">https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83</a>
</li>

<li>Why most compilers use AST, instead generate IR directly?<br />
<a href="https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159">https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159</a>
</li>

<li>A Gentle Introduction to LLVM IR<br />
<a href="https://mcyoung.xyz/2023/08/01/llvm-ir/">https://mcyoung.xyz/2023/08/01/llvm-ir/</a>
</li>

<li>Why does the compiler need the intermediate representations for link time optimization?<br />
<a href="https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi">https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi</a>
</li>

<li>pyrefact na PyPi<br />
<a href="https://pypi.org/project/pyrefact/">https://pypi.org/project/pyrefact/</a>
</li>

<li>Repositář projektu pyrefact<br />
<a href="https://github.com/OlleLindgren/pyrefact">https://github.com/OlleLindgren/pyrefact</a>
</li>

<li>pyrefact jako plugin do VSCode<br />
<a href="https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact">https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact</a>
</li>

<li>pyrefact-vscode-extension (repositář)<br />
<a href="https://github.com/OlleLindgren/pyrefact-vscode-extension">https://github.com/OlleLindgren/pyrefact-vscode-extension</a>
</li>

<li>Best Python Refactoring Tools for 2023<br />
<a href="https://www.developer.com/languages/python/best-python-refactoring-tools/">https://www.developer.com/languages/python/best-python-refactoring-tools/</a>
</li>

<li>Python Refactoring: Techniques, Tools, and Best Practices<br />
<a href="https://www.codesee.io/learning-center/python-refactoring">https://www.codesee.io/learning-center/python-refactoring</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů jazyka Python (4.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/</a>
</li>

<li>Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu<br />
<a href="https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/">https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/</a>
</li>

<li>LibCST &ndash; dokumentace<br />
<a href="https://libcst.readthedocs.io/en/latest/index.html">https://libcst.readthedocs.io/en/latest/index.html</a>
</li>

<li>libCST na PyPi<br />
<a href="https://pypi.org/project/libcst/">https://pypi.org/project/libcst/</a>
</li>

<li>libCST na GitHubu<br />
<a href="https://github.com/Instagram/LibCST">https://github.com/Instagram/LibCST</a>
</li>

<li>Inside The Python Virtual Machine<br />
<a href="https://leanpub.com/insidethepythonvirtualmachine">https://leanpub.com/insidethepythonvirtualmachine</a>
</li>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Golang Compilation and Execution<br />
<a href="https://golangtutorial.com/golang-compilation-and-execution/">https://golangtutorial.com/golang-compilation-and-execution/</a>
</li>

<li>Mezijazyk (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/Mezijazyk">https://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://www.llvm.org/">https://www.llvm.org/</a>
</li>

<li>GCC internals<br />
<a href="https://gcc.gnu.org/onlinedocs/gccint/index.html">https://gcc.gnu.org/onlinedocs/gccint/index.html</a>
</li>

<li>GCC Developer Options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html">https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html</a>
</li>

<li>What is Gimple?<br />
<a href="https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/">https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/</a>
</li>

<li>The Conceptual Structure of GCC<br />
<a href="https://www.cse.iitb.ac.in/grc/intdocs/gcc-conceptual-structure.html">https://www.cse.iitb.ac.in/grc/intdocs/gcc-conceptual-structure.html</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojů využívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (před verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

<li>Lexical analysis<br />
<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>
</li>

<li>Parser<br />
<a href="https://en.wikipedia.org/wiki/Parsing#Parser">https://en.wikipedia.org/wiki/Parsing#Parser</a>
</li>

<li>Parse tree<br />
<a href="https://en.wikipedia.org/wiki/Parse_tree">https://en.wikipedia.org/wiki/Parse_tree</a>
</li>

<li>Derivační strom<br />
<a href="https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom">https://cs.wikipedia.org/wiki/Deriva%C4%8Dn%C3%AD_strom</a>
</li>

<li>Python doc: ast — Abstract Syntax Trees<br />
<a href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>
</li>

<li>Python doc: tokenize — Tokenizer for Python source<br />
<a href="https://docs.python.org/3/library/tokenize.html">https://docs.python.org/3/library/tokenize.html</a>
</li>

<li>SymbolTable<br />
<a href="https://docs.python.org/3.8/library/symtable.html">https://docs.python.org/3.8/library/symtable.html</a>
</li>

<li>5 Amazing Python AST Module Examples<br />
<a href="https://www.pythonpool.com/python-ast/">https://www.pythonpool.com/python-ast/</a>
</li>

<li>Intro to Python ast Module<br />
<a href="https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7">https://medium.com/@wshanshan/intro-to-python-ast-module-bbd22cd505f7</a>
</li>

<li>Golang AST Package<br />
<a href="https://golangdocs.com/golang-ast-package">https://golangdocs.com/golang-ast-package</a>
</li>

<li>AP8, IN8 Regulární jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap8">http://statnice.dqd.cz/home:inf:ap8</a>
</li>

<li>AP9, IN9 Konečné automaty<br />
<a href="http://statnice.dqd.cz/home:inf:ap9">http://statnice.dqd.cz/home:inf:ap9</a>
</li>

<li>AP10, IN10 Bezkontextové jazyky<br />
<a href="http://statnice.dqd.cz/home:inf:ap10">http://statnice.dqd.cz/home:inf:ap10</a>
</li>

<li>AP11, IN11 Zásobníkové automaty, Syntaktická analýza<br />
<a href="http://statnice.dqd.cz/home:inf:ap11">http://statnice.dqd.cz/home:inf:ap11</a>
</li>

<li>Introduction to YACC<br />
<a href="https://www.geeksforgeeks.org/introduction-to-yacc/">https://www.geeksforgeeks.org/introduction-to-yacc/</a>
</li>

<li>Introduction of Lexical Analysis<br />
<a href="https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp">https://www.geeksforgeeks.org/introduction-of-lexical-analysis/?ref=lbp</a>
</li>

<li>Write your own filter<br />
<a href="http://pygments.org/docs/filterdevelopment/">http://pygments.org/docs/filterdevelopment/</a>
</li>

<li>Write your own lexer<br />
<a href="http://pygments.org/docs/lexerdevelopment/">http://pygments.org/docs/lexerdevelopment/</a>
</li>

<li>Write your own formatter<br />
<a href="http://pygments.org/docs/formatterdevelopment/">http://pygments.org/docs/formatterdevelopment/</a>
</li>

<li>Compiler Construction/Lexical analysis<br />
<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis</a>
</li>

<li>Compiler Design - Lexical Analysis<br />
<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm">https://www.tutorialspoint.com/compiler_design/compiler_design_lexical_analysis.htm</a>
</li>

<li>Lexical Analysis - An Intro<br />
<a href="https://www.scribd.com/document/383765692/Lexical-Analysis">https://www.scribd.com/document/383765692/Lexical-Analysis</a>
</li>

<li>Python AST Visualizer<br />
<a href="https://github.com/pombredanne/python-ast-visualizer">https://github.com/pombredanne/python-ast-visualizer</a>
</li>

<li>What is an Abstract Syntax Tree<br />
<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27">https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27</a>
</li>

<li>Why is AST so important<br />
<a href="https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260">https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260</a>
</li>

<li>Emily Morehouse-Valcarcel - The AST and Me - PyCon 2018<br />
<a href="https://www.youtube.com/watch?v=XhWvz4dK4ng">https://www.youtube.com/watch?v=XhWvz4dK4ng</a>
</li>

<li>Python AST Parsing and Custom Linting<br />
<a href="https://www.youtube.com/watch?v=OjPT15y2EpE">https://www.youtube.com/watch?v=OjPT15y2EpE</a>
</li>

<li>Chase Stevens - Exploring the Python AST Ecosystem<br />
<a href="https://www.youtube.com/watch?v=Yq3wTWkoaYY">https://www.youtube.com/watch?v=Yq3wTWkoaYY</a>
</li>

<li>Full Grammar specification<br />
<a href="https://docs.python.org/3/reference/grammar.html">https://docs.python.org/3/reference/grammar.html</a>
</li>

<li>Playing with GCC’s GIMPLE: How to Generate, Save, and Modify Intermediate Code (Tutorial + Examples)<br />
<a href="https://www.tutorialpedia.org/blog/playing-with-gcc-s-intermediate-gimple-format/">https://www.tutorialpedia.org/blog/playing-with-gcc-s-intermediate-gimple-format/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2026</small></p>
</body>

</html>

