<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. Mezijazyk vs bajtkód</a></p>
<p><a href="#k05">*** 5. Historie vývoje bajtkódu a jeho využití</a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

<p>Při zpracování zdrojových kódů se postupně provádí jednotlivé dílčí kroky, a to jak v&nbsp;klasických překladačích (Go), tak i v&nbsp;jazycích, které provádí překlad &bdquo;jen&ldquo; do bajtkódu s&nbsp;jeho pozdější interpretací (Python). Díky rozdělení celého zpracování do několika konfigurovatelných kroků je zajištěna velká flexibilita a možnost případného relativně snadného rozšiřování o další syntaktické prvky, existuje možnost použití jediné sady nástrojů více jazyky, lze přidat podporu pro různé výstupní formáty (překlad do nativního kódu nebo do WebAssembly atd.), podporu speciální filtry apod.  (nehledě na to, že každá činnost je založena na odlišné teorii). Celý průběh zpracování vypadá při určitém zjednodušení následovně:</p>

<ol>

<li>Na začátku zpracování se nachází takzvaný <i>lexer</i>, který postupně načítá jednotlivé znaky ze vstupního řetězce (resp.&nbsp;ze vstupního souboru) a vytváří z&nbsp;nich lexikální <i>tokeny</i>. Teoreticky se pro každý programovací jazyk používá odlišný lexer a samozřejmě je možné v&nbsp;případě potřeby si napsat lexer vlastní. V&nbsp;případě Pythonu můžeme použít standardní modul <a href="https://docs.python.org/3.8/library/tokenize.html">tokenizer</a>, nebo lze alternativně použít například projekt <i>Pygments</i>, jenž obsahuje lexery pro mnoho dalších programovacích jazyků.</li>

<li>Výstup z&nbsp;lexeru může procházet libovolným počtem <i>filtrů</i> sloužících pro odstranění nebo (častěji) modifikaci jednotlivých tokenů; ať již jejich typů či přímo textu, který tvoří hodnotu tokenu. Díky existenci filtrů je například možné nechat si zvýraznit vybrané bílé znaky, slova se speciálním významem v&nbsp;komentářích (TODO:, FIX:) apod. Některé lexery obsahují filtr přímo ve svém modulu.</li>

<li>Sekvence <i>tokenů</i> tvoří základ pro syntaktickou analýzu. Nástroj, který syntaktickou analýzu provádí, se většinou nazývá <i>parser</i> a proto se taktéž někdy setkáme s&nbsp;pojmem <i>parsing</i> (tento termín je ovšem chybně používán i v&nbsp;těch případech, kdy se provádí &bdquo;pouze&ldquo; lexikální analýza). Výsledkem činnosti parseru je vhodně zvolená datová struktura, typicky abstraktní syntaktický strom (AST); někdy též strom derivační. V&nbsp;případě Pythonu vypadá postupné zpracování vstupního zdrojového textu takto: lexer &rarr; derivační strom (<i>parse tree</i>) &rarr; AST.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: díky tomu, že se prakticky veškeré zpracování zdrojových textů odehrává na úrovni tokenů, není nutné, aby byl celý zpracovávaný zdrojový kód (nebo jeho tokenizovaná podoba) uložen v&nbsp;operační paměti. Je tedy možné zpracovávat i velmi rozsáhlé zdrojové texty, a to bez větších nároků na operační paměť. Tento princip je použit například v&nbsp;již popsaném balíčku <strong>go/scanner</strong>, ovšem v&nbsp;případě Pythonu a jeho standardních modulů s&nbsp;lexerem a parserem <i>jsme</i> omezeni dostupnou kapacitou paměti (což v&nbsp;praxi nevadí, kromě extrémních případů).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. </h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. Mezijazyk vs bajtkód</h2>

<p>Pojem <i>mezijazyk</i> je většinou používán v&nbsp;souvislosti se sofistikovanými překladači, které překlad provádí v&nbsp;několika fázích zmíněných v&nbsp;předchozím textu.</p>

<p>Nejprve se však ve stručnosti seznámíme s&nbsp;historií používání bajtkódu, která je poměrně dlouhá a přitom i z&nbsp;programátorského hlediska zajímavá, protože úspěch mnoha programovacích jazyků vycházel mj.&nbsp;i z&nbsp;toho, že se díky použití bajtkódů (a s&nbsp;nimi souvisejících virtuálních strojů) mohly jejich překladače snadno a relativně rychle rozšiřovat na různé platformy a architektury počítačů (a to se v&nbsp;žádném případě netýká pouze Javy, ale dříve například i Pascalu či BPCL, což je pradávný předchůdce rodiny jazyků C a C++).</p>

<p>Bajtkód je využíván především dvěma nástroji. Na jedné straně se jedná o překladač (například v&nbsp;případě Javy to může být překladač <strong>javac</strong>, API tohoto překladače dostupné v&nbsp;moderních JDK či interní překladač využívaný nějakým integrovaným vývojovým prostředím), který překládá zdrojový kód napsaný programátorem (či poloautomaticky vygenerovaný v&nbsp;IDE :-) do bajtkódu; což mj.&nbsp;znamená, že je překlad zcela nezávislý na použité platformě. Na straně druhé již jednou přeložený bajtkód využívá interpret či dnes již v&nbsp;mnoha případech spíše JIT (<i>just in time</i>) překladač. Ve skutečnosti však s&nbsp;bajtkódem může pracovat i mnoho dalších nástrojů. Příkladem ve světě Javy a bajtkódu JVM mohou být například nástroje typu <i>Cobertura</i> a <i>EMMA</i> sloužící pro zjištění, které části zdrojového kódu aplikací jsou pokryty (jednotkovými) testy. Tyto nástroje musí umět dobře kooperovat s&nbsp;virtuálním strojem Javy, proto nejprve modifikují bajtkódy testovaných tříd, aby bylo možné při běhu testů dynamicky zjistit, které řádky kódu jsou skutečně z&nbsp;testů volány.</p>

<p>Podobným způsobem je bajtkód modifikován nástroji podporujícími aspektově orientované programování (<i>aspect oriented programming</i>), které taktéž mohou zasahovat do bajtkódu vygenerovaného překladačem. Teoreticky je sice možné při použití aspektově orientovaného programování transformovat přímo zdrojové kódy programů (což je použito především v&nbsp;jiných programovacích jazycích), ale transformace bajtkódu je v&nbsp;případě Javy mnohem snazší. Ze stejného důvodu (analýza bajtkódu je jednodušší než analýza zdrojového textu) je bajtkód použit pro statickou analýzu a hledání potenciálních chyb nástrojem <i>FindBugs</i>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Historie vývoje bajtkódu a jeho využití</h2>

<p>Myšlenka na využití bajtkódu pro překlad a následnou interpretaci programů je v&nbsp;informatice úspěšně využívána poměrně dlouho. Jedním z&nbsp;prvních známých a rozšířených bajtkódů byl <strong>OPCODE</strong>, který byl vyvinut pro potřeby programovacího jazyka <strong>BCPL</strong>. Jazyk <strong>BPCL</strong> (<i>Basic Combined Programming Language</i>), jenž byl vytvořen Martinem Richardsem již v&nbsp;roce 1966, je z&nbsp;hlediska historie IT důležitý především proto, že z&nbsp;něho Ken Thompson odvodil nový programovací jazyk nazvaný jednoduše <strong>B</strong> a z&nbsp;jazyka <strong>B</strong> se postupně vyvinulo klasické Céčko (nejdříve K&amp;R C a posléze dodnes používané ANSI/ISO C). Bajtkód nazvaný <strong>OPCODE</strong> byl založen na instrukcích pracujících se zásobníkem operandů a v&nbsp;práci s&nbsp;daty dostupnými přes indexové registry. Například výraz <strong>x / y + z</strong> se pro proměnné <strong>x</strong>, <strong>y</strong> a <strong>z</strong> uložené na pozicích 1, 2 a 10 přeložil do bajtkódu <strong>OPCODE</strong> následujícím způsobem, který se nápadně podobá bajtkódu JVM (což ostatně není náhoda, jak si řekneme dále):</p>

<pre>
LP   1
LP   2
DIV
LP   10
PLUS
</pre>

<p>Popularita používání bajtkódu byla úzce spojena i s&nbsp;úspěšností takzvaného <strong>p-code</strong>, což byl (a ostatně stále ještě je) bajtkód využívaný některými překladači programovacího jazyka Pascal (to se ovšem netýká Turbo Pascalu). Díky využití <strong>p-code</strong> bylo snadnější portovat jak překladač Pascalu na různé platformy, tak i interpret vlastního p-kódu.  Tento bajtkód je v&nbsp;současnosti ještě využíván na některých školách při výuce IT; mj.&nbsp;i z&nbsp;tohoto důvodu se jedná o stále živý projekt, o čemž ostatně mohou svědčit i stránky projektu UCSD p-system Virtual Machine dostupné na adrese <a href="http://ucsd-psystem-vm.sourceforge.net/">http://ucsd-psystem-vm.sourceforge.net/</a>.  Dále je vhodné zmínit bajtkód využívaný <i>Smalltalkem</i>. Jedná se o poměrně vysokoúrovňový bajtkód, který se v&nbsp;některých ohledech přibližuje bajtkódu používaném Pythonem (posílání zpráv je v&nbsp;tomto případě velmi podobné volání virtuálních metod apod.). Mimochodem &ndash; velká část bajtkódu <i>Smalltalku</i> je reflexivně dostupná i z&nbsp;vlastního jazyka, viz například <a href="http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png">http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis příkladu</th><th>Adresa</th></tr>
<tr><td> 1</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/">https://github.com/tisnik/8bit-fame/blob/master/LLVM_IR/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Is intermediate representation (such as bytecodes or .net IL) still an advantage?<br />
<a href="https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage">https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage</a>
</li>

<li>Intermediate Representation vs Byte Code<br />
<a href="https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code">https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code</a>
</li>

<li>Getting the intermediate representation in gcc<br />
<a href="https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2">https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2</a>
</li>

<li>Intermediate Representations<br />
<a href="https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/">https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/</a>
</li>

<li>Why do we use intermediate representations / languages?<br />
<a href="https://mortoray.com/why-we-use-intermediate-representations/">https://mortoray.com/why-we-use-intermediate-representations/</a>
</li>

<li>Unwrapping intermediate representations<br />
<a href="https://mortoray.com/unwrapping-intermediate-representations/">https://mortoray.com/unwrapping-intermediate-representations/</a>
</li>

<li>Understanding Python Code Flow From Source to Execution<br />
<a href="https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83">https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83</a>
</li>

<li>Why most compilers use AST, instead generate IR directly?<br />
<a href="https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159">https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159</a>
</li>

<li>A Gentle Introduction to LLVM IR<br />
<a href="https://mcyoung.xyz/2023/08/01/llvm-ir/">https://mcyoung.xyz/2023/08/01/llvm-ir/</a>
</li>

<li>Why does the compiler need the intermediate representations for link time optimization?<br />
<a href="https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi">https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi</a>
</li>

<li>pyrefact na PyPi<br />
<a href="https://pypi.org/project/pyrefact/">https://pypi.org/project/pyrefact/</a>
</li>

<li>Repositář projektu pyrefact<br />
<a href="https://github.com/OlleLindgren/pyrefact">https://github.com/OlleLindgren/pyrefact</a>
</li>

<li>pyrefact jako plugin do VSCode<br />
<a href="https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact">https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact</a>
</li>

<li>pyrefact-vscode-extension (repositář)<br />
<a href="https://github.com/OlleLindgren/pyrefact-vscode-extension">https://github.com/OlleLindgren/pyrefact-vscode-extension</a>
</li>

<li>Best Python Refactoring Tools for 2023<br />
<a href="https://www.developer.com/languages/python/best-python-refactoring-tools/">https://www.developer.com/languages/python/best-python-refactoring-tools/</a>
</li>

<li>Python Refactoring: Techniques, Tools, and Best Practices<br />
<a href="https://www.codesee.io/learning-center/python-refactoring">https://www.codesee.io/learning-center/python-refactoring</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů jazyka Python (4.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/</a>
</li>

<li>Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu<br />
<a href="https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/">https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/</a>
</li>

<li>LibCST &ndash; dokumentace<br />
<a href="https://libcst.readthedocs.io/en/latest/index.html">https://libcst.readthedocs.io/en/latest/index.html</a>
</li>

<li>libCST na PyPi<br />
<a href="https://pypi.org/project/libcst/">https://pypi.org/project/libcst/</a>
</li>

<li>libCST na GitHubu<br />
<a href="https://github.com/Instagram/LibCST">https://github.com/Instagram/LibCST</a>
</li>

<li>Inside The Python Virtual Machine<br />
<a href="https://leanpub.com/insidethepythonvirtualmachine">https://leanpub.com/insidethepythonvirtualmachine</a>
</li>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Golang Compilation and Execution<br />
<a href="https://golangtutorial.com/golang-compilation-and-execution/">https://golangtutorial.com/golang-compilation-and-execution/</a>
</li>

<li>Mezijazyk (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/Mezijazyk">https://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://www.llvm.org/">https://www.llvm.org/</a>
</li>

<li>GCC internals<br />
<a href="https://gcc.gnu.org/onlinedocs/gccint/index.html">https://gcc.gnu.org/onlinedocs/gccint/index.html</a>
</li>

<li>GCC Developer Options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html">https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html</a>
</li>

<li>What is Gimple?<br />
<a href="https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/">https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2026</small></p>
</body>
</html>

