<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Typická sekvence transformací prováděných při překladu zdrojového kódu</a></p>
<p><a href="#k03">*** 3. Význam mezijazyka v&nbsp;oblasti moderních překladačů</a></p>
<p><a href="#k04">*** 4. Mezijazyk vs bajtkód</a></p>
<p><a href="#k05">*** 5. Historie vývoje bajtkódu a jeho využití</a></p>
<p><a href="#k06">*** 6. Bajtkod pro zásobníkové vs.&nbsp;registrové virtuální stroje</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Obsah navazujícího článku</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Typická sekvence transformací prováděných při překladu zdrojového kódu</h2>

<p>Při zpracování zdrojových kódů se postupně provádí jednotlivé dílčí kroky, a to jak v&nbsp;klasických překladačích (Go), tak i v&nbsp;jazycích, které provádí překlad &bdquo;jen&ldquo; do bajtkódu s&nbsp;jeho pozdější interpretací (Python). Díky rozdělení celého zpracování do několika konfigurovatelných kroků je zajištěna velká flexibilita a možnost případného relativně snadného rozšiřování o další syntaktické prvky, existuje možnost použití jediné sady nástrojů více jazyky, lze přidat podporu pro různé výstupní formáty (překlad do nativního kódu nebo do WebAssembly atd.), podporu speciální filtry apod.  (nehledě na to, že každá činnost je založena na odlišné teorii). Celý průběh zpracování vypadá při určitém zjednodušení následovně:</p>

<ol>

<li>Na začátku zpracování se nachází takzvaný <i>lexer</i>, který postupně načítá jednotlivé znaky ze vstupního řetězce (resp.&nbsp;ze vstupního souboru) a vytváří z&nbsp;nich lexikální <i>tokeny</i>. Teoreticky se pro každý programovací jazyk používá odlišný lexer a samozřejmě je možné v&nbsp;případě potřeby si napsat lexer vlastní. V&nbsp;případě Pythonu můžeme použít standardní modul <a href="https://docs.python.org/3.8/library/tokenize.html">tokenizer</a>, nebo lze alternativně použít například projekt <i>Pygments</i>, jenž obsahuje lexery pro mnoho dalších programovacích jazyků.</li>

<li>Výstup z&nbsp;lexeru může procházet libovolným počtem <i>filtrů</i> sloužících pro odstranění nebo (častěji) modifikaci jednotlivých tokenů; ať již jejich typů či přímo textu, který tvoří hodnotu tokenu. Díky existenci filtrů je například možné nechat si zvýraznit vybrané bílé znaky, slova se speciálním významem v&nbsp;komentářích (TODO:, FIX:) apod. Některé lexery obsahují filtr přímo ve svém modulu.</li>

<li>Sekvence <i>tokenů</i> tvoří základ pro syntaktickou analýzu. Nástroj, který syntaktickou analýzu provádí, se většinou nazývá <i>parser</i> a proto se taktéž někdy setkáme s&nbsp;pojmem <i>parsing</i> (tento termín je ovšem chybně používán i v&nbsp;těch případech, kdy se provádí &bdquo;pouze&ldquo; lexikální analýza). Výsledkem činnosti parseru je vhodně zvolená datová struktura, typicky abstraktní syntaktický strom (AST); někdy též strom derivační. V&nbsp;případě Pythonu vypadá postupné zpracování vstupního zdrojového textu takto: lexer &rarr; derivační strom (<i>parse tree</i>) &rarr; AST.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: díky tomu, že se prakticky veškeré zpracování zdrojových textů odehrává na úrovni tokenů, není nutné, aby byl celý zpracovávaný zdrojový kód (nebo jeho tokenizovaná podoba) uložen v&nbsp;operační paměti. Je tedy možné zpracovávat i velmi rozsáhlé zdrojové texty, a to bez větších nároků na operační paměť. Tento princip je použit například v&nbsp;již popsaném balíčku <strong>go/scanner</strong>, ovšem v&nbsp;případě Pythonu a jeho standardních modulů s&nbsp;lexerem a parserem <i>jsme</i> omezeni dostupnou kapacitou paměti (což v&nbsp;praxi nevadí, kromě extrémních případů).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Význam mezijazyka v&nbsp;oblasti moderních překladačů</h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. Mezijazyk vs bajtkód</h2>

<p>Pojem <i>mezijazyk</i> je většinou používán v&nbsp;souvislosti se sofistikovanými překladači, které překlad provádí v&nbsp;několika fázích zmíněných v&nbsp;předchozím textu.</p>

<p>Nejprve se však ve stručnosti seznámíme s&nbsp;historií používání bajtkódu, která je poměrně dlouhá a přitom i z&nbsp;programátorského hlediska zajímavá, protože úspěch mnoha programovacích jazyků vycházel mj.&nbsp;i z&nbsp;toho, že se díky použití bajtkódů (a s&nbsp;nimi souvisejících virtuálních strojů) mohly jejich překladače snadno a relativně rychle rozšiřovat na různé platformy a architektury počítačů (a to se v&nbsp;žádném případě netýká pouze Javy, ale dříve například i Pascalu či BPCL, což je pradávný předchůdce rodiny jazyků C a C++).</p>

<p>Bajtkód je využíván především dvěma nástroji. Na jedné straně se jedná o překladač (například v&nbsp;případě Javy to může být překladač <strong>javac</strong>, API tohoto překladače dostupné v&nbsp;moderních JDK či interní překladač využívaný nějakým integrovaným vývojovým prostředím), který překládá zdrojový kód napsaný programátorem (či poloautomaticky vygenerovaný v&nbsp;IDE :-) do bajtkódu; což mj.&nbsp;znamená, že je překlad zcela nezávislý na použité platformě. Na straně druhé již jednou přeložený bajtkód využívá interpret či dnes již v&nbsp;mnoha případech spíše JIT (<i>just in time</i>) překladač. Ve skutečnosti však s&nbsp;bajtkódem může pracovat i mnoho dalších nástrojů. Příkladem ve světě Javy a bajtkódu JVM mohou být například nástroje typu <i>Cobertura</i> a <i>EMMA</i> sloužící pro zjištění, které části zdrojového kódu aplikací jsou pokryty (jednotkovými) testy. Tyto nástroje musí umět dobře kooperovat s&nbsp;virtuálním strojem Javy, proto nejprve modifikují bajtkódy testovaných tříd, aby bylo možné při běhu testů dynamicky zjistit, které řádky kódu jsou skutečně z&nbsp;testů volány.</p>

<p>Podobným způsobem je bajtkód modifikován nástroji podporujícími aspektově orientované programování (<i>aspect oriented programming</i>), které taktéž mohou zasahovat do bajtkódu vygenerovaného překladačem. Teoreticky je sice možné při použití aspektově orientovaného programování transformovat přímo zdrojové kódy programů (což je použito především v&nbsp;jiných programovacích jazycích), ale transformace bajtkódu je v&nbsp;případě Javy mnohem snazší. Ze stejného důvodu (analýza bajtkódu je jednodušší než analýza zdrojového textu) je bajtkód použit pro statickou analýzu a hledání potenciálních chyb nástrojem <i>FindBugs</i>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Historie vývoje bajtkódu a jeho využití</h2>

<p>Myšlenka na využití bajtkódu pro překlad a následnou interpretaci programů je v&nbsp;informatice úspěšně využívána poměrně dlouho. Jedním z&nbsp;prvních známých a rozšířených bajtkódů byl <strong>OPCODE</strong>, který byl vyvinut pro potřeby programovacího jazyka <strong>BCPL</strong>. Jazyk <strong>BPCL</strong> (<i>Basic Combined Programming Language</i>), jenž byl vytvořen Martinem Richardsem již v&nbsp;roce 1966, je z&nbsp;hlediska historie IT důležitý především proto, že z&nbsp;něho Ken Thompson odvodil nový programovací jazyk nazvaný jednoduše <strong>B</strong> a z&nbsp;jazyka <strong>B</strong> se postupně vyvinulo klasické Céčko (nejdříve K&amp;R C a posléze dodnes používané ANSI/ISO C). Bajtkód nazvaný <strong>OPCODE</strong> byl založen na instrukcích pracujících se zásobníkem operandů a v&nbsp;práci s&nbsp;daty dostupnými přes indexové registry. Například výraz <strong>x / y + z</strong> se pro proměnné <strong>x</strong>, <strong>y</strong> a <strong>z</strong> uložené na pozicích 1, 2 a 10 přeložil do bajtkódu <strong>OPCODE</strong> následujícím způsobem, který se nápadně podobá bajtkódu JVM (což ostatně není náhoda, jak si řekneme dále):</p>

<pre>
LP   1
LP   2
DIV
LP   10
PLUS
</pre>

<p>Popularita používání bajtkódu byla úzce spojena i s&nbsp;úspěšností takzvaného <strong>p-code</strong>, což byl (a ostatně stále ještě je) bajtkód využívaný některými překladači programovacího jazyka Pascal (to se ovšem netýká Turbo Pascalu). Díky využití <strong>p-code</strong> bylo snadnější portovat jak překladač Pascalu na různé platformy, tak i interpret vlastního p-kódu.  Tento bajtkód je v&nbsp;současnosti ještě využíván na některých školách při výuce IT; mj.&nbsp;i z&nbsp;tohoto důvodu se jedná o stále živý projekt, o čemž ostatně mohou svědčit i stránky projektu UCSD p-system Virtual Machine dostupné na adrese <a href="http://ucsd-psystem-vm.sourceforge.net/">http://ucsd-psystem-vm.sourceforge.net/</a>.  Dále je vhodné zmínit bajtkód využívaný <i>Smalltalkem</i>. Jedná se o poměrně vysokoúrovňový bajtkód, který se v&nbsp;některých ohledech přibližuje bajtkódu používaném Pythonem (posílání zpráv je v&nbsp;tomto případě velmi podobné volání virtuálních metod apod.). Mimochodem &ndash; velká část bajtkódu <i>Smalltalku</i> je reflexivně dostupná i z&nbsp;vlastního jazyka, viz například <a href="http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png">http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Bajtkod pro zásobníkové vs.&nbsp;registrové virtuální stroje</h2>

<p>Využívání bajtkódů má v&nbsp;současnosti za sebou zhruba čtyřicet let postupného vývoje, takže není divu, že za tuto poměrně dlouhou dobu bylo navrženo a implementováno mnoho různých řešení virtuálního stroje+bajtkódu, která se od sebe v&nbsp;mnoha ohledech odlišovala, a to jak úrovní abstrakce bajtkódu (nízkoúrovňové instrukce dobře transformovatelné na strojový kód vs.  vysokoúrovňové instrukce podporující například polymorfismus využívaný například virtuálním strojem Pythonu), tak i způsobem, jakým jednotlivé instrukce pracovaly s&nbsp;argumenty. Naprostou většinu existujících a v&nbsp;současnosti používaných bajtkódů lze rozdělit do dvou skupin.  V&nbsp;první skupině se nachází bajtkódy zpracovávané virtuálními stroji založenými na zásobníku operandů (<i>operand stack</i>) a v&nbsp;druhé skupině se nachází bajtkódy využívající sadu registrů (<i>register set</i>) nabízených virtuálním strojem. Oba přístupy mají své přednosti i zápory a taktéž skalní zastánce i odpůrce, jak je tomu ostatně v&nbsp;IT dobrým zvykem :-)</p>

<p>Bajtkódy a virtuální stroje využívající zásobník operandů a instrukce pro práci s&nbsp;argumenty uloženými na tomto zásobníku většinou obsahují mnoho bezparametrických instrukcí, jejichž operační kódy tak mohou být velmi krátké a typicky bývají uloženy v&nbsp;jednom bajtu (z&nbsp;toho také ostatně označení &bdquo;bajtkód&ldquo; vychází). Interpretace takového bajtkódu bývá velmi jednoduchá a lze ji efektivně provádět i na těch mikroprocesorech, které obsahují velmi malé množství pracovních registrů, z&nbsp;čehož ostatně vyplývá i oblíbenost takto navržených bajtkódů v&nbsp;době osmibitových mikroprocesorů a mikrořadičů (poněkud speciálním případem je jazyk <i>Forth</i>). Před přibližně deseti lety, kdy se ve větší míře začaly rozšiřovat JIT překladače, se předpokládalo, že nové JIT překladače budou mít problémy s&nbsp;překladem instrukcí založených na použití zásobníku operandů do strojového kódu moderních mikroprocesorů (ty mají většinou velkou sadu pracovních registrů), ovšem ukázalo se, že JIT dokáží bez větších problémů pracovat jak se zásobníkovými instrukcemi, tak i s&nbsp;instrukcemi využívajícími sadu pracovních registrů VM.</p>

<p>Tím se pomalu dostáváme ke druhému rozšířenému typu bajtkódů. Jedná se o bajtkódy, jejichž instrukce dokážou pracovat s&nbsp;obsahem množiny pracovních registrů zvoleného virtuálního stroje. Délka instrukčního slova i možnosti takto navržených bajtkódů závisí především na počtu těchto pracovních registrů; v&nbsp;moderních VM se setkáme minimálně s&nbsp;použitím šestnácti či 32 registry, což znamená, že mnoho instrukcí má délku minimálně dva bajty, mnohdy i tři či čtyři bajty. Liší se taktéž počet operandů instrukcí &ndash; některé bajtkódy využívají takzvaný dvouadresový kód (používají dva registry &ndash; jeden registr zdrojový a druhý registr současně zdrojový i cílový), jiné se zaměřují na tříadresový kód (dva zdrojové registry a jeden registr cílový).  Způsob interpretace takto navržených bajtkódů může být problematičtější v&nbsp;případě, že mikroprocesor, na němž interpret běží, obsahuje menší množství fyzických pracovních registrů, ovšem (jak již bylo řečeno v&nbsp;předchozím odstavci), při použití JIT se rozdíly mezi oběma způsoby práce s&nbsp;operandy do značné míry rozostřují.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Praktická ukázka rozdílu mezi bajtkódem určeným pro zásobníkový a registrový VM</h2>

<p>Podívejme se nyní na dvě ukázky, jak se může lišit bajtkód založený na zásobníkovém virtuálním stroji od bajtkódu, který je určen pro registrový virtuální stroj. V&nbsp;obou příkladech se má vyhodnotit jednoduchý výraz <strong>result = a+b*c-d</strong>; pro jednoduchost předpokládejme, že všech pět proměnných je lokálních a současně mají typ celé číslo (integer). Způsob překladu do bajtkódu využívajícího zásobník operandů (konkrétně je použit bajtkód JVM) může vypadat následovně:</p>

<pre>
              <i>; 0 je index proměnné <strong>a</strong></i>
              <i>; 1 je index proměnné <strong>b</strong></i>
              <i>; 2 je index proměnné <strong>c</strong></i>
              <i>; 3 je index proměnné <strong>d</strong></i>
              <i>; 4 je index proměnné <strong>result</strong></i>
0: iload  0   <i>; uložení obsahu proměnné <strong>a</strong> na zásobník</i>
1: iload  1   <i>; uložení obsahu proměnné <strong>b</strong> na zásobník</i>
2: iload  2   <i>; uložení obsahu proměnné <strong>c</strong> na zásobník</i>
3: imul       <i>; provedení operace <strong>b*c</strong>, výsledek je ponechán na zásobníku</i>
4: iadd       <i>; provedení operace <strong>a+(b*c)</strong></i>
5: iload  3   <i>; uložení obsahu proměnné <strong>d</strong> na zásobník</i>
6: isub       <i>; dokončit příkaz <strong>a+(b*c)+d</strong></i>
7: istore 4   <i>; uložení výsledku z TOS (obsah zásobníku operandů) do proměnné <strong>result</strong></i>
</pre>

<p>Příklad kompilace téhož příkazu <strong>result = a+b*c-d</strong> do bajtkódu využívajícího pracovní registry, konkrétně do bajtkódu využívaného programovacím jazykem Lua:</p>

<pre>
                               <i>; 0 je index proměnné <strong>a</strong></i>
                               <i>; 1 je index proměnné <strong>b</strong></i>
                               <i>; 2 je index proměnné <strong>c</strong></i>
                               <i>; 3 je index proměnné <strong>d</strong></i>
                               <i>; 4 je index proměnné <strong>result</strong></i>
1       [101]   MUL    4 1 2   <i>; přímé vynásobení obsahu proměnných <strong>b</strong> a <strong>c</strong></i>
2       [101]   ADD    4 0 4   <i>; přičíst k obsahu proměnné <strong>a</strong> mezivýsledek, výsledek uložit do proměnné <strong>result</strong></i>
3       [101]   SUB    4 4 3   <i>; odečíst od mezivýsledku obsah proměnné <strong>b</strong>, výsledek uložit do proměnné <strong>result</strong></i>
</pre>

<p>Ve druhém případě se nemusely vůbec použít instrukce pro uložení proměnných na zásobník ani pro načtení hodnoty zpět ze zásobníku operandů do proměnné, ovšem na druhou stranu musely mít všechny aritmetické instrukce v&nbsp;instrukčním slovu uloženy i indexy operandů.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Obsah navazujícího článku</h2>

<p></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Is intermediate representation (such as bytecodes or .net IL) still an advantage?<br />
<a href="https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage">https://stackoverflow.com/questions/35061333/is-intermediate-representation-such-as-bytecodes-or-net-il-still-an-advantage</a>
</li>

<li>Intermediate Representation vs Byte Code<br />
<a href="https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code">https://cs.stackexchange.com/questions/163398/intermediate-representation-vs-byte-code</a>
</li>

<li>Getting the intermediate representation in gcc<br />
<a href="https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2">https://forum.osdev.org/viewtopic.php?t=22845&amp;sid=11f6e77d24bda7fcc2c9ef6a5be4e6b2</a>
</li>

<li>Intermediate Representations<br />
<a href="https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/">https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/</a>
</li>

<li>Why do we use intermediate representations / languages?<br />
<a href="https://mortoray.com/why-we-use-intermediate-representations/">https://mortoray.com/why-we-use-intermediate-representations/</a>
</li>

<li>Unwrapping intermediate representations<br />
<a href="https://mortoray.com/unwrapping-intermediate-representations/">https://mortoray.com/unwrapping-intermediate-representations/</a>
</li>

<li>Understanding Python Code Flow From Source to Execution<br />
<a href="https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83">https://medium.com/@azan96593/understanding-python-code-flow-from-source-to-execution-ebeea870ef83</a>
</li>

<li>Why most compilers use AST, instead generate IR directly?<br />
<a href="https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159">https://stackoverflow.com/questions/60870622/why-most-compilers-use-ast-instead-generate-ir-directly#60902159</a>
</li>

<li>A Gentle Introduction to LLVM IR<br />
<a href="https://mcyoung.xyz/2023/08/01/llvm-ir/">https://mcyoung.xyz/2023/08/01/llvm-ir/</a>
</li>

<li>Why does the compiler need the intermediate representations for link time optimization?<br />
<a href="https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi">https://stackoverflow.com/questions/75586563/why-does-the-compiler-need-the-intermediate-representations-for-link-time-optimi</a>
</li>

<li>pyrefact na PyPi<br />
<a href="https://pypi.org/project/pyrefact/">https://pypi.org/project/pyrefact/</a>
</li>

<li>Repositář projektu pyrefact<br />
<a href="https://github.com/OlleLindgren/pyrefact">https://github.com/OlleLindgren/pyrefact</a>
</li>

<li>pyrefact jako plugin do VSCode<br />
<a href="https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact">https://marketplace.visualstudio.com/items?itemName=olleln.pyrefact</a>
</li>

<li>pyrefact-vscode-extension (repositář)<br />
<a href="https://github.com/OlleLindgren/pyrefact-vscode-extension">https://github.com/OlleLindgren/pyrefact-vscode-extension</a>
</li>

<li>Best Python Refactoring Tools for 2023<br />
<a href="https://www.developer.com/languages/python/best-python-refactoring-tools/">https://www.developer.com/languages/python/best-python-refactoring-tools/</a>
</li>

<li>Python Refactoring: Techniques, Tools, and Best Practices<br />
<a href="https://www.codesee.io/learning-center/python-refactoring">https://www.codesee.io/learning-center/python-refactoring</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (2.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-2-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů programovacího jazyka Python (3.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-programovaciho-jazyka-python-3-cast/</a>
</li>

<li>Lexikální a syntaktická analýza zdrojových kódů jazyka Python (4.část)<br />
<a href="https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/">https://www.root.cz/clanky/lexikalni-a-syntakticka-analyza-zdrojovych-kodu-jazyka-python-4-cast/</a>
</li>

<li>Knihovna LibCST umožňující snadnou modifikaci zdrojových kódů Pythonu<br />
<a href="https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/">https://www.root.cz/clanky/knihovna-libcst-umoznujici-snadnou-modifikaci-zdrojovych-kodu-pythonu/</a>
</li>

<li>LibCST &ndash; dokumentace<br />
<a href="https://libcst.readthedocs.io/en/latest/index.html">https://libcst.readthedocs.io/en/latest/index.html</a>
</li>

<li>libCST na PyPi<br />
<a href="https://pypi.org/project/libcst/">https://pypi.org/project/libcst/</a>
</li>

<li>libCST na GitHubu<br />
<a href="https://github.com/Instagram/LibCST">https://github.com/Instagram/LibCST</a>
</li>

<li>Inside The Python Virtual Machine<br />
<a href="https://leanpub.com/insidethepythonvirtualmachine">https://leanpub.com/insidethepythonvirtualmachine</a>
</li>

<li>module-py_compile<br />
<a href="https://docs.python.org/3.8/library/py_compile.html">https://docs.python.org/3.8/library/py_compile.html</a>
</li>

<li>Given a python .pyc file, is there a tool that let me view the bytecode?<br />
<a href="https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode">https://stackoverflow.com/questions/11141387/given-a-python-pyc-file-is-there-a-tool-that-let-me-view-the-bytecode</a>
</li>

<li>The structure of .pyc files<br />
<a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Golang Compilation and Execution<br />
<a href="https://golangtutorial.com/golang-compilation-and-execution/">https://golangtutorial.com/golang-compilation-and-execution/</a>
</li>

<li>Mezijazyk (Wikipedie)<br />
<a href="https://cs.wikipedia.org/wiki/Mezijazyk">https://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://www.llvm.org/">https://www.llvm.org/</a>
</li>

<li>GCC internals<br />
<a href="https://gcc.gnu.org/onlinedocs/gccint/index.html">https://gcc.gnu.org/onlinedocs/gccint/index.html</a>
</li>

<li>GCC Developer Options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html">https://gcc.gnu.org/onlinedocs/gcc/Developer-Options.html</a>
</li>

<li>What is Gimple?<br />
<a href="https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/">https://mschiralli1.wordpress.com/2024/12/01/what-is-gimple/</a>
</li>

<li>The Conceptual Structure of GCC<br />
<a href="https://www.cse.iitb.ac.in/grc/intdocs/gcc-conceptual-structure.html">https://www.cse.iitb.ac.in/grc/intdocs/gcc-conceptual-structure.html</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojů využívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (před verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2026</small></p>
</body>

</html>

