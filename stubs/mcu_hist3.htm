<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vznik mikrořadičů: dokončení popisu čtyřbitového čipu Atmel MARC4</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vznik mikrořadičů: dokončení popisu čtyřbitového čipu Atmel MARC4</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnešní článek o čtyřbitových mikrořadičích Atmel MARC4 bude rozdělen na dvě části. V&nbsp;první části dokončíme popis instrukční sady a v&nbsp;části druhé si řekneme, jakým způsobem a v&nbsp;jakém programovacím jazyku se pro tyto čipy vyvíjí ovládací software.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vznik mikrořadičů: dokončení popisu čtyřbitového čipu Atmel MARC4</a></p>
<p><a href="#k02">2. Nastavení příznaku <strong>branch</strong> na základě vypočtené podmínky</a></p>
<p><a href="#k03">3. Operace s&nbsp;příznakovými bity</a></p>
<p><a href="#k04">4. Přesuny dat mezi registry X, Y, SP a RP</a></p>
<p><a href="#k05">5. Operace typu load &amp; store</a></p>
<p><a href="#k06">6. Základní podpora pro počítané programové smyčky</a></p>
<p><a href="#k07">7. Vstupy a výstupy</a></p>
<p><a href="#k08">8. Ostatní instrukce</a></p>
<p><a href="#k09">9. Programování čipů MARC4</a></p>
<p><a href="#k10">10. Vznik a vývoj programovacího jazyka Forth</a></p>
<p><a href="#k11">11. Forth: programovací jazyk, vývojové prostředí či operační systém?</a></p>
<p><a href="#k12">12. Abstraktní dvouzásobníkový procesor</a></p>
<p><a href="#k13">13. Základy programování ve Forthu: zásobník operandů</a></p>
<p><a href="#k14">14. Vytváření nových slov</a></p>
<p><a href="#k15">15. Podmínky a programové smyčky</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vznik mikrořadičů: dokončení popisu čtyřbitového čipu Atmel MARC4</h2>

<p><a
href="https://www.root.cz/clanky/vznik-mikroradicu-ctyrbitovy-mcu-atmel-marc4/">V&nbsp;předchozím
článku</a> jsme se seznámili s&nbsp;architekturou poměrně zajímavých
čtyřbitových mikrořadičů Atmel MARC4. Připomeňme si, že tyto mikrořadiče jsou
založeny na zásobníkové architektuře, v&nbsp;níž je dvojice zásobníků (zásobník
návratových adres a zásobník operandů) doplněna o čtveřici registrů
<strong>X</strong>, <strong>Y</strong>, <strong>SP</strong> a
<strong>RP</strong> s&nbsp;adresami do paměti dat. Zjednodušené schéma tohoto
čipu můžeme vidět na prvním obrázku:</p>

<img src="https://i.iinfo.cz/images/641/marc4-1-3.png" class="image-285049" alt="&#160;" width="660" height="492" />
<p><i>Obrázek 1: Zjednodušené schéma čtyřbitových mikrořadičů MARC4.</i></p>

<p>V&nbsp;instrukčním souboru nalezneme celkem osmdesát instrukcí, které je
možné rozdělit do několika skupin. Prvních šest skupin jsme si již popsali
minule, dalších sedm skupin instrukcí bude popsáno v&nbsp;navazujících
kapitolách:</p>

<table>
<tr><th>Skupina instrukcí</th><th>Počet instrukcí ve skupině</th></tr>
<tr><td><a href="https://www.root.cz/clanky/vznik-mikroradicu-ctyrbitovy-mcu-atmel-marc4/#k09">Aritmetické instrukce</a></td><td>7</td></tr>
<tr><td><a href="https://www.root.cz/clanky/vznik-mikroradicu-ctyrbitovy-mcu-atmel-marc4/#k10">Logické instrukce</a></td><td>4</td></tr>
<tr><td><a href="https://www.root.cz/clanky/vznik-mikroradicu-ctyrbitovy-mcu-atmel-marc4/#k11">Rotace a posuny</a></td><td>4</td></tr>
<tr><td><a href="https://www.root.cz/clanky/vznik-mikroradicu-ctyrbitovy-mcu-atmel-marc4/#k12">Skoky a volání podprogramů</a></td><td>5</td></tr>
<tr><td><a href="https://www.root.cz/clanky/vznik-mikroradicu-ctyrbitovy-mcu-atmel-marc4/#k13">Operace se zásobníky</a></td><td>10</td></tr>
<tr><td><a href="https://www.root.cz/clanky/vznik-mikroradicu-ctyrbitovy-mcu-atmel-marc4/#k14">Načtení konstanty</a></td><td>1</td></tr>
<tr><td><a href="#k02">Podmínky, nastavení příznaku branch</a></td><td>6</td></tr>
<tr><td><a href="#k03">Operace s&nbsp;příznakovými bity</a></td><td>4</td></tr>
<tr><td><a href="#k04">Přesuny dat mezi registry X, Y, SP a RP</a></td><td>12</td></tr>
<tr><td><a href="#k05">Operace typu load &amp; store</a></td><td>16</td></tr>
<tr><td><a href="#k06">Základní podpora pro počítané programové smyčky</a></td><td>3</td></tr>
<tr><td><a href="#k07">Vstupy a výstupy</a></td><td>2</td></tr>
<tr><td><a href="#k08">Ostatní instrukce</a></td><td>6</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Celkem:</td><td>80</td></tr>
</table>

<img src="https://i.iinfo.cz/images/641/marc4-1-4.png" class="image-285050" alt="&#160;" width="532" height="736" />
<p><i>Obrázek 2: Obsazení všech 256 osmibitových kombinací instrukcemi (zdroj:
Atmel).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nastavení příznaku <strong>branch</strong> na základě vypočtené podmínky</h2>

<p>Následující skupina šesti instrukcí porovná dva operandy ležící na zásobníku
operandů a následně nastaví příznakový bit <i>branch</i> na základě porovnání
těchto operandů. Posléze je operand ležící na vrcholu zásobníku (tedy na TOS)
odstraněn, což je praktické, neboť se většinou provádí porovnání
s&nbsp;konstantou:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>CMP_EQ</td><td>nastav B=1 za podmínky, že n1 = n2</td></tr>
<tr><td>CMP_NE</td><td>nastav B=1 za podmínky, že n1 &ne; n2</td></tr>
<tr><td>CMP_LT</td><td>nastav B=1 za podmínky, že n1 &lt; n2</td></tr>
<tr><td>CMP_LE</td><td>nastav B=1 za podmínky, že n1 &le; n2</td></tr>
<tr><td>CMP_GT</td><td>nastav B=1 za podmínky, že n1 &gt; n2</td></tr>
<tr><td>CMP_GE</td><td>nastav B=1 za podmínky, že n1 &ge; n2</td></tr>
</table>

<p>Poznámka: to, že se nastavuje příznak <i>branch</i> a nikoli <i>carry</i>,
je velmi praktické, neboť <i>branch</i> se používá u podmíněných skoků:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>BRA</td><td>podmíněný skok při splnění <i>branch</i>==1 (dlouhá varianta s&nbsp;12bitovou adresou)</td></tr>
<tr><td>SBRA</td><td>podmíněný skok při splnění <i>branch</i>==1 (krátká varianta se šestibitovou adresou)</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Operace s&nbsp;příznakovými bity</h2>

<p>Další čtyři instrukce slouží k&nbsp;manipulaci s&nbsp;příznakovými bity.
Připomeňme si, že existují pouze dva příznakové bity nazvané <i>carry</i> a
<i>branch</i>, které jsou uložené ve čtyřbitovém registru nazvaném
<strong>CCR</strong> (další dva bity jsou neobsazené). To mj.&nbsp;znamená, že
je možné registr <strong>CCR</strong> uložit na zásobník operandů nebo ho
naopak ze zásobníku obnovit:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>CCR@</td><td>uložení příznakových bitů na vrchol zásobníku operandů (TOS)</td></tr>
<tr><td>CCR!</td><td>obnovení příznakových bitů ze zásobníku operandů (z&nbsp;TOS)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SET_BCF</td><td>nastavení příznakových bitů <i>carry</i> i <i>branch</i> na jedničku</td></tr>
<tr><td>TOG_BF</td><td>negace příznakového bitu <i>branch</i></td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přesuny dat mezi registry X, Y, SP a RP</h2>

<p>Minule jsme si řekli, že mezi registry viditelné programátorům patří i
čtveřice osmibitových registrů s&nbsp;uloženou adresou. Dva z&nbsp;těchto
registrů <strong>RP</strong> a <strong>SP</strong> obsahují adresu vrcholu
zásobníku návratových nebo vrcholu zásobníku operandů, další dva registry
<strong>X</strong> a <strong>Y</strong> pak například adresu v&nbsp;poli atd.
&ndash; tyto dva registry jsou využívané programátory:</p>

<table>
<tr><th>Registr</th><th>Šířka</th><th>Význam</th></tr>
<tr><td>RP</td><td>8 bitů</td><td>ukazuje na vrchol zásobníku návratových adres, který je umístěný v&nbsp;RAM</td></tr>
<tr><td>SP</td><td>8 bitů</td><td>ukazuje na druhý prvek uložený na zásobníku operandů, který je umístěný v&nbsp;RAM</td></tr>
<tr><td>X</td><td>8 bitů</td><td>obecný (index) registr použitý při adresování</td></tr>
<tr><td>Y</td><td>8 bitů</td><td>obecný (index) registr použitý při adresování</td></tr>
</table>

<p>Pro načtení hodnoty do těchto registrů popř.&nbsp;naopak pro uložení obsahu
registrů slouží následujících dvanáct instrukcí. Prvních osm instrukcí načítá a
ukládá obsah registrů na zásobník operandů, což znamená, že se vždycky bude
pracovat se dvěma prvky (registry mají šířku osm bitů, zatímco prvky na
zásobníku mají šířku jen čtyři bity):</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>SP@</td><td>na zásobník operandů se uloží obsah registru SP (do dvou prvků), SP se zvýší o 2</td></tr>
<tr><td>RP@</td><td>na zásobník operandů se uloží obsah registru RP (do dvou prvků)</td></tr>
<tr><td>X@ </td><td>na zásobník operandů se uloží obsah registru X (do dvou prvků)</td></tr>
<tr><td>Y@ </td><td>na zásobník operandů se uloží obsah registru Y (do dvou prvků)</td></tr>
<tr><td>SP!</td><td>dva prvky ze zásobníku operandů se použijí pro zápis nové hodnoty do SP</td></tr>
<tr><td>RP!</td><td>dva prvky ze zásobníku operandů se použijí pro zápis nové hodnoty do RP</td></tr>
<tr><td>X! </td><td>dva prvky ze zásobníku operandů se použijí pro zápis nové hodnoty do X</td></tr>
<tr><td>Y! </td><td>dva prvky ze zásobníku operandů se použijí pro zápis nové hodnoty do Y</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&gt;SP konstanta</td><td>konstanta (bajt) se zapíše do registru SP</td></tr>
<tr><td>&gt;RP konstanta</td><td>konstanta (bajt) se zapíše do registru RP</td></tr>
<tr><td>&gt;X konstanta</td><td>konstanta (bajt) se zapíše do registru X</td></tr>
<tr><td>&gt;Y konstanta</td><td>konstanta (bajt) se zapíše do registru Y</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace typu load &amp; store</h2>

<p>Poměrně rozsáhlá skupina instrukcí slouží pro načtení či uložení dat na
vrchol zásobníku operandů (TOS). Při adresování operandů se používají
adresovací registry <strong>X</strong> a <strong>Y</strong>, jejichž obsah
(adresa) může být instrukcí modifikována, neboť jsou podporovány pre-inkrementy
a post-dekrementy adresy. Díky tomu lze velmi efektivním způsobem procházet
poli, a to mnohem efektivnějším způsobem, než je tomu i u některých
výkonnějších osmibitových mikrořadičů:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>[X]@ </td><td>z&nbsp;RAM na adrese uložené v registru X se načtou data a uloží na TOS</td></tr>
<tr><td>[Y]@ </td><td>z&nbsp;RAM na adrese uložené v registru Y se načtou data a uloží na TOS</td></tr>
<tr><td>[+X]@</td><td>nejprve se zvýší obsah registru X a posléze se provede instrukce [X]@</td></tr>
<tr><td>[+Y]@</td><td>nejprve se zvýší obsah registru Y a posléze se provede instrukce [Y]@</td></tr>
<tr><td>[X–]@</td><td>nejprve se provede instrukce [X]@ a poté se sníží obsah registru X</td></tr>
<tr><td>[Y–]@</td><td>nejprve se provede instrukce [Y]@ a poté se sníží obsah registru Y</td></tr>
<tr><td>[&gt;X]@ konstanta</td><td>provede se instrukce [X]@ a poté se do registru X načte nová konstanta</td></tr>
<tr><td>[&gt;Y]@ konstanta</td><td>provede se instrukce [Y]@ a poté se do registru Y načte nová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[X]! </td><td>obsah TOS se uloží do RAM na adresu uloženou v&nbsp;registru X</td></tr>
<tr><td>[Y]! </td><td>obsah TOS se uloží do RAM na adresu uloženou v&nbsp;registru Y</td></tr>
<tr><td>[+X]!</td><td>nejprve se zvýší obsah registru X a posléze se provede instrukce [X]!</td></tr>
<tr><td>[+Y]!</td><td>nejprve se zvýší obsah registru Y a posléze se provede instrukce [Y]!</td></tr>
<tr><td>[X–]!</td><td>nejprve se provede instrukce [X]! a poté se sníží obsah registru X</td></tr>
<tr><td>[Y–]!</td><td>nejprve se provede instrukce [Y]! a poté se sníží obsah registru Y</td></tr>
<tr><td>[&gt;X]! konstanta</td><td>nejprve se provede instrukce [X]! a poté se do registru X načte nová konstanta</td></tr>
<tr><td>[&gt;Y]! konstanta</td><td>nejprve se provede instrukce [Y]! a poté se do registru Y načte nová konstanta</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní podpora pro počítané programové smyčky</h2>

<p>Při implementaci počítaných programových smyček se většinou počitadlo smyčky
ukládá na zásobník návratových adres. To s&nbsp;sebou přináší několik výhod,
například uvolnění zásobníku operandů pro výpočty, uvolnění registrů
<strong>X</strong> a <strong>Y</strong> pro indexování prvků v&nbsp;polích atd.
Aby nebylo nutné při přepočtu hodnoty počitadla neustále přesunovat hodnotu ze
zásobníku návratových adres na zásobník operandů a zpět, byla do instrukčního
souboru čipů MARC4 přidána instrukce <strong>DECR</strong>, která počitadlo
sníží přímo na zásobníku návratových adres a současně nastaví příznak
<i>branch</i> podle toho, zda se dosáhlo nuly či nikoli. Následně je možné
použít podmíněný skok používající právě tento příznak:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>&gt;R</td><td>přesun hodnoty z&nbsp;TOS zásobníku operandů na zásobník návratových adres s&nbsp;rozšířením na 12 bitů</td></tr>
<tr><td>R@</td><td>opak předchozí instrukce</td></tr>
<tr><td>I</td><td>alias předchozí instrukce</td></tr>
<tr><td>DECR</td><td>snížení indexu (počitadla) uloženého na vrcholu zásobníku návratových adres, nastavení příznaku <i>branch</i></td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vstupy a výstupy</h2>

<p>Tato kapitola bude velmi krátká, protože v&nbsp;instrukčním souboru čipů
MARC4 najdeme pouze dvě instrukce určené pro ovládání vstupních a výstupních
pinů. Tyto instrukce vždy pracují se čtyřmi piny a proto se mohou přečtené
hodnoty či naopak hodnoty, na něž se mají piny nastavit, přenášet
z&nbsp;vrcholu zásobníku operandů (TOS):</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>IN</td><td>čtyři bity přečtené z&nbsp;I/O portu jsou zapsány na vrchol zásobníku operandů</td></tr>
<tr><td>OUT</td><td>opačná instrukce, zápis čtyř bitů z&nbsp;TOS zásobníku operandů na I/O port</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Ostatní instrukce</h2>

<p>Na závěr se krátce zmiňme o instrukcích, které nespadají do žádné výše
uvedené kategorie:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>NOP</td><td>pravděpodobně není nutné zdlouhavě popisovat :-)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>DI</td><td>zákaz všech přerušení</td></tr>
<tr><td>RTI</td><td>návrat z&nbsp;rutiny přerušení</td></tr>
<tr><td>SWI</td><td>vyvolání softwarového přerušení</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SLEEP</td><td>přechod MCU do režimu spánku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>TABLE</td><td>načtení osmibitové konstanty z&nbsp;paměti ROM a uložení na TOS</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Programování čipů MARC4</h2>

<p>Pro čipy MARC4 je možné vytvářet programy buď v&nbsp;assembleru nebo
v&nbsp;programovacím jazyce Forth, konkrétně v&nbsp;jeho variantě nazvané
<strong>qFORTH</strong>. Tento dialekt Forthu podporuje všechny základní řídicí
konstrukce, tedy BEGIN .. AGAIN, BEGIN .. UNTIL, CASE .. ENDCASE, DO .. LOOP,
IF .. THEN, IF .. ELSE .. THEN, BEGIN .. WHILE .. REPEAT (setkáme se
s&nbsp;nimi <a href="#k15">v&nbsp;patnácté kapitole</a>). Kromě toho podporuje
práci se čtyřbitovými a osmibitovými operandy, přičemž při použití osmibitových
operandů je generován poměrně neefektivní kód (což je ovšem vzhledem
k&nbsp;interní architektuře čipu pochopitelné). Kromě toho podporuje
<strong>qFORTH</strong> i direktivy preprocesoru, které se vzdáleně podobají
direktivám známým z&nbsp;céčka:</p>

<pre>
$IFDEF MUX4–LCD
$INCLUDE LCD–MUX4.SCR
$ELSE
$INCLUDE LCD–MUX3.SCR
$ENDIF
</pre>

<p>Většina implementací Forthu sice umožňuje interaktivní tvorbu programu i
jeho interaktivní ladění, ovšem v&nbsp;případě qFORTHu je tomu jinak, protože
se jedná o překladač. Tato vlastnost je opět pochopitelná, zvláště když si
uvědomíme, jak <a
href="https://www.root.cz/clanky/vznik-mikroradicu-ctyrbitovy-mcu-atmel-marc4/#k06">malá
je kapacita paměti RAM</a>. Překlad je poměrně přímočarý a to díky chytře
zvolené instrukční sadě čipů MARC4. Pro qFORTH je dodáváno vývojové prostředí,
které je s&nbsp;velkou pravděpodobností vytvořeno v&nbsp;TurboVision a vypadá
tedy podobně, jako například známé IDE společnosti Borland (TurboPascal, Turbo
C, Borland C++ atd.).</p>

<p>Poznámka: vzhledem k&nbsp;minimálním kapacitám RAM i ROM, instrukční sadě,
možnostem adresování a ostatně i čtyřbitové šířce ALU nemá pro tyto čipy
použití jazyka typu C vlastně žádný velký praktický význam.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vznik a vývoj programovacího jazyka Forth</h2>

<p>Vývoj programovacího jazyka <i>Forth</i> probíhal velmi zajímavě. Nikdy se
totiž nejednalo o čistě &bdquo;akademický produkt&ldquo;, který by měl
reprezentovat nějakou nosnou revoluční myšlenku (a tím méně o jazyk určený pro
výuku programování), ale o programovací jazyk, který vytvořil v&nbsp;podstatě
jeden člověk pro svoji osobní potřebu tak, aby přesně splňoval jeho pracovní
požadavky. Tento programátor se jmenuje <a
href="https://en.wikipedia.org/wiki/Charles_H._Moore">Charles
&bdquo;Chuck&ldquo; Moore </a> a dodnes patří mezi zajímavé a současně velmi
rozporuplné osobnosti, které se podílely na rozvoji výpočetní techniky, zejména
vestavěných (embedded) řídících systémů a systémů běžících v&nbsp;reálném čase.
Moore byl prý překvapen, když zjistil, že systém, který vyvinul pro své
potřeby, používají i další lidé, kterým v&nbsp;jejich práci vyhovuje více než
v&nbsp;té době komerčně prosazovaný Fortran).</p>

<p>Do značně heterogenního prostředí počítačů a operačních systémů sedmdesátých
let přišel Moore se svým jazykem (či lépe řečeno celou vývojovou platformou)
Forth. Vývojové prostředí Forthu obsahovalo interaktivní editor, interpret
jazyka Forth a univerzální vazbu na assembler upravený na právě provozovaný
systém. Toto prostředí umožňovalo spouštět souběžně více procesů a současně
mohlo v&nbsp;systému nezávisle pracovat až 64 uživatelů, a to i na platformách,
jejichž operační systém nebyl multiuživatelský a dokonce ani multitaskový.</p>

<p>Ve skutečnosti Forth (resp.&nbsp;jeho vývojové prostředí, tyto dva pojmy
však většinou splývají) nepotřeboval pro své spuštění žádný operační systém,
pracoval totiž přímo s&nbsp;periferními zařízeními &ndash; z&nbsp;toho také
vyplývá skutečnost, že se zdrojové kódy vytvářených aplikací neukládaly tak
jako dnes do textových souborů, ale byly v&nbsp;předkompilované či přímo
přeložené podobě uloženy v&nbsp;blocích pevné délky (takzvaných obrazovkách),
které se podle potřeby nahrávaly do operační paměti počítače. Tyto programové
bloky u mnoha systémů odpovídaly velikosti bloků na disku (typická velikost je
512 B a 1 kB), což značně urychlovalo práci s&nbsp;disky, protože se nemusely
provádět složité přepočty adres na bloky. Na druhou stranu se nejedná o příliš
efektivní způsob uložení a ani násilné rozdělování programů na obrazovky nemusí
všem programátorům vyhovovat (zejména v&nbsp;současnosti).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Forth: programovací jazyk, vývojové prostředí či operační systém?</h2>

<p>Chuck Moore začal vytvářet programovací jazyk Forth docela nevinně &ndash;
zpočátku se jednalo pouze o jakási makra, která používal při programování
aplikací z&nbsp;oblasti astronomie (jednalo se o poměrně složité astronomické
výpočty a řízení radioteleskopů). Tato makra se postupným vývojem proměnila
v&nbsp;translátor vyšších operací do jazyka symbolických adres (assembleru) a
v&nbsp;dalších letech pak do plnohodnotného i když dosti neobvyklého
interaktivního programovacího jazyka s&nbsp;vlastním vývojovým prostředím.</p>

<p>Jedná se přitom o jazyk interpretovaný, i když jiným způsobem, než je dnes
zvykem, a současně plně a oboustranně interaktivní. Z&nbsp;tohoto důvodu se
v&nbsp;něm aplikace vyvíjí a především testují velmi jednoduše, zejména
v&nbsp;porovnání s&nbsp;jazyky kompilovanými, jako jsou dnes často používané
programovací jazyky C, C++, (polomrtvý) Pascal, C# a v&nbsp;podstatě i Java.
Všechny vyjmenované kompilované jazyky potřebují pro vývoj programů mnoho
podpůrných prostředků (editor, překladač, linker, debugger), které však mezi
sebou nejsou (a ani nemohou být) příliš propojeny &ndash; proto je v&nbsp;nich
ladění programů poměrně těžkopádné, vyžaduje knihovny s&nbsp;debug symboly
atd.</p>

<p>Ve Forthu jsou všechny tyto prostředky sloučeny, ale to v&nbsp;žádném
případě neznamená, že by vznikl mnohasetkilobajtový moloch. Naopak, celé
vývojové prostředí Forthu zabírá jednotky, maximálně desítky kilobytů. Vývojové
prostředí Forthu je totiž účelně vytvořeno tak, že obsahuje jen nejnutnější
součásti (ostatně Chuck Moore zapřísáhlý minimalista, což je patrné i při
pohledu na design čipů, které navrhl).</p>

<p>Výpočetní výkon počítačů v&nbsp;té době nebyl příliš vysoký, k&nbsp;čemuž se
dále přidávala poměrně vysoká cena za jednotku strojového času. Programátoři
byli nuceni vytvářet programy co nejrychlejší a s&nbsp;co nejmenšími nároky na
kapacitu operační paměti (v&nbsp;té době se to vyplatilo, v&nbsp;dnešním světě
je v&nbsp;mnoha případech jednodušší programovat resp. &bdquo;bastlit&ldquo; co
nejrychleji a ušetřené prostředky investovat do nového hardwaru). Časově
kritické úseky aplikací se tedy neustále tvořily v&nbsp;assembleru,
k&nbsp;čemuž byl Forth dokonale připraven, neboť existovalo jednoduché
programátorské i aplikační rozhraní pro přístup k&nbsp;assembleru.</p>

<p>Také fakt, že Forth využíval vlastní blokový souborový systém
(v&nbsp;dnešních OS se kromě toho používá &bdquo;proudový&ldquo; souborový
systém, i když nejmenší adresovatelná jednotka na disku je právě jeden blok),
v&nbsp;některých aplikacích značně urychlil práci se soubory. Týká se to
zejména databázových aplikací a aplikací pro zpracování obrazu.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Abstraktní dvouzásobníkový procesor</h2>

<p>Programovací jazyk Forth byl určen zejména pro implementaci na takzvaných
zásobníkových procesorech, přesněji řečeno na procesorech s&nbsp;minimálně
dvěma zásobníky &ndash; zásobníkem operandů (<i>operand stack</i> nebo pouze
<i>stack</i>) a zásobníkem návratových adres (<i>return stack</i>). Tyto
procesory se od dnes nejpoužívanějších registrových procesorů liší především
způsobem provádění aritmetických a logických operací. Prosím povšimněte si, že
právě tyto dva zásobníky najdeme na čtyřbitových mikrořadičích MARC4. To však
zdaleka není všechno &ndash; většina instrukcí MARC4 přímo odpovídá slovům
(příkazům) programovacího jazyka Forth, což ostatně uvidíme v&nbsp;navazujících
třech kapitolách.</p>

<p>Poznámka: &bdquo;pravé&ldquo; zásobníkové procesory mají zásobníky uloženy
ve specializovaných blocích paměti, zatímco u MARC4 jsou součástí operační
(datové) paměti. U takto malých čipů to má svůj význam, u větších procesorů se
naopak vyžadoval větší výpočetní výkon a tudíž i paralelní přístup
k&nbsp;zásobníkům.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Základy programování ve Forthu: zásobník operandů</h2>

<p>Forth je mezi programátory znám především jako jazyk, ve kterém se
aritmetické a logické výrazy zapisují pomocí <i>RPN</i> &ndash; <i>Reverse
Polish Notation</i> (obrácené polské notace) označované také jako <i>postfixová
notace</i>. Při tomto způsobu zápisu se nejdříve uvádějí operandy a teprve poté
operace, která se s&nbsp;těmito operandy může provádět.</p>

<p>Už na základní škole se však každý člověk učí takzvanou <i>infixovou
notaci</i> zápisu, ve které se operátory píšou mezi operandy. Vzhledem
k&nbsp;prioritě operátorů je však nutné v&nbsp;infixové notaci používat
závorky. Rozdíl mezi následujícími dvěma výrazy uvedenými v&nbsp;infixové
notaci je snad zřejmý:</p>

<pre>
a+b*c
(a+b)*c
</pre>

<p>Při použití postfixové notace nejsou závorky zapotřebí, protože se priorita
operací vyjadřuje přímo posloupností operátorů. Výše uvedené výrazy lze tedy do
postfixové notace přepsat následovně:</p>

<pre>
a b c * + nebo též b c * a +
a b + c * nebo též c a b + *
</pre>

<p>Všimněte si, že u výrazů napsaných na levé straně se oproti infixové notaci
nemění pořadí operátorů.</p>

<p>Pomocí postfixové notace je možné zapisovat všechny operace i funkce,
dokonce ani nezáleží na počtu operandů (stírá se rozdíl mezi unárními.
binárními, ternárními apod. operacemi). Ve skutečnosti není v&nbsp;postfixové
notaci prakticky žádný rozdíl mezi operacemi a funkcemi, takže pro ně není
nutné zavádět nějaká zvláštní syntaktická pravidla.</p>

<p>Důsledkem výše uvedených skutečností je fakt, že znaky běžně používané pro
operátory je možné použít pro jiné účely, podobně jako například v&nbsp;jazyce
Lisp nebo Scheme (což jsou mimochodem jazyky používající prefixovou
notaci).</p>

<p>Aritmetické operace se ve Forthu zapisují přesně podle infixové notace
s&nbsp;tou podmínkou, že jednotlivé operátory od sebe musí být odděleny
mezerou, znakem tabelátoru či znakem pro konec řádku. Příklad zápisu některých
aritmetických operací a jejich kombinací:</p>

<pre>
10 20 +
10 20 *
10 20 -
10 20 + 30 *
5 4 3 2 1 * / + -
</pre>

<p>Význam výše uvedených operací ve Forthu je následující: samotný zápis čísla
znamená, že se toto číslo uloží do zásobníku. Zápis operátoru způsobí, že se
operandy vyberou ze zásobníku, provede se s&nbsp;nimi operace a výsledek se
uloží zpět na zásobník. Vzhledem k&nbsp;tomu, že všechny zmíněné operace jsou
binární, vyberou se ze zásobníku dvě hodnoty a zpět se zapíše pouze jediná
hodnota, tj.&nbsp;počet položek na zásobníku se o jednu sníží.</p>

<p>S&nbsp;operandy umístěnými na zásobníku operandů lze provádět některé
operace, jejichž názvy přitom odpovídají názvům instrukcí mikrořadiče MARC4
(což samozřejmě není náhoda, ale záměr):</p>

<p>Prohození dvou operandů:</p>

<pre>
1 2 swap
</pre>

<p>Duplikace (kopie) operandu na TOS:</p>

<pre>
1 dup
</pre>

<p>Opak předchozí operace &ndash; odstranění operandu z&nbsp;TOS:</p>

<pre>
1 2 drop
</pre>

<p>Slovo <strong>over</strong> se podobá výše popsanému slovu <strong>dup</strong>, tj.&nbsp;provádí se kopie hodnoty uložené v&nbsp;zásobníku. V&nbsp;tomto případě se však jedná o hodnotu uloženou pod vrcholem zásobníku, nikoli o hodnotu uloženou přímo na vrcholu zásobníku:</p>

<pre>
1 2 over
</pre>

<p>Slovo <strong>rot</strong> manipuluje hned se třemi položkami uloženými na zásobníku. Jak již název tohoto slova napovídá, provádí se rotace položek, a to tak, že datová položka na třetí nejvyšší pozici v&nbsp;zásobníku operandů je vyjmuta a uložena na jeho vrchol:</p>

<pre>
1 2 3 rot
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vytváření nových slov</h2>

<p>Forth místo funkcí, operací a řídicích struktur používá pouze slova. Slova
se zadávají z&nbsp;klávesnice nebo ze vstupního souboru a jsou určena svým
jménem. Jméno je ve Forthu libovolný řetězec znaků, který je oddělen (ukončen)
mezerou nebo v&nbsp;novějších verzích libovolným &bdquo;bílým znakem&ldquo;.
Každé volání funkce je ve forthovském programu nahrazeno jejím jménem bez
dalších znaků (závorek apod.), protože veškeré parametry funkce i její
návratová hodnota jsou uloženy na zásobníku:</p>

<p>Příkladem slova může být například mocnina. Toto slovo vezme ze zásobníku
hodnotu a na zásobník vrátí její druhou mocninu. Slovo může vypadat
následovně:</p>

<pre>
: mocnina dup * ;
</pre>

<p>Nejdříve se tedy provede duplikace hodnoty na vrcholu zásobníku. Poté se obě
(shodné) hodnoty ze zásobníku vyjmou, vynásobí a na zásobník se uloží výsledek
operace násobení. Použití tohoto slova je opět velmi jednoduché:</p>

<pre>
2 mocnina
</pre>

<p>Poznámka: závěrečný středník na konci slova se překládá do instrukce
<strong>EXIT</strong>.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Podmínky a programové smyčky</h2>

<p>Nedílnou součástí všech imperativních programovacích jazyků je i jazyková
konstrukce pro podmínky. Forth se k&nbsp;této problematice staví poněkud
odlišným způsobem: pro zápis podmínek používá tři slova, nejedná se tedy o
speciální jazykovou konstrukci, ale o mimořádně flexibilní mechanismus, který
umožňuje přidávat i další &bdquo;strukturované&ldquo; konstrukce bez zásahu do
překladače:</p>

<pre>
logický_výraz
if
    příkazy_1_větve
else
    příkazy_2_větve
then
</pre>

<p>Interně se provede překlad do vyhodnocení podmínky (na zásobníku),
<strong>if</strong> a <strong>else</strong> se přeloží jako podmíněný skok a
<strong>then</strong> slouží jako návěští pro konec bloku
<strong>if</strong>.</p>

<p>Jedním ze základních typů cyklů ve Forthu je smyčka typu
<strong>do-loop</strong>. Jedná se o počítanou smyčku, která zhruba odpovídá
smyčce for z&nbsp;Pascalu, Fortranu či Basicu:</p>

<pre>
10 1 do loop
</pre>

<p>Pro tvorbu prvního typu nepočítaných smyček, kdy se podmínka pro ukončení
smyčky testuje ještě před první iterací, se používají slova
<strong>begin</strong>, <strong>while</strong> a <strong>repeat</strong>.
Způsob jejich použití ilustruje následující kód:</p>

<pre>
begin
podmínka
while
    tělo smyčky
repeat
</pre>

<p>Další formou nepočítané smyčky je smyčka, při které se test provádí až na
konci. Tato smyčka se konstruuje pomocí slov <strong>begin</strong> a
<strong>until</strong>. Způsob použití je následující:</p>

<pre>
: gcd
    begin
        swap over mod
        dup 0=
    until
    drop
    . cr
;
</pre>

<p>V&nbsp;některých případech se hodí testovat podmínku na ukončení smyčky
uvnitř jejího těla, tj.&nbsp;nikoli přísně na začátku a na konci. Pro tento typ
problémů je možné použít nekonečné smyčky, které se tvoří pomocí slov
<strong>begin</strong> a <strong>again</strong>. Způsob použití tohoto typu
smyček je jednoduchý:</p>

<pre>
begin
    tělo smyčky
again
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Zero-power Microcontrollers for Low-power and High-temperature Applications<br />
<a href="http://en.wikichip.org/w/images/1/17/Atmel_MARC4_brochure.pdf">http://en.wikichip.org/w/images/1/17/Atmel_MARC4_brochure.pdf</a>
</li>

<li>MARC4 Micro-Controller (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MARC4_Micro-Controller">https://en.wikipedia.org/wiki/MARC4_Micro-Controller</a>
</li>

<li>MARC4 - Atmel<br />
<a href="https://en.wikichip.org/wiki/atmel/marc4">https://en.wikichip.org/wiki/atmel/marc4</a>
</li>

<li>MARC 4bit Microcontrollers Programmer's Guide<br />
<a href="https://en.wikichip.org/w/images/4/44/MARC4_4-bit_Microcontrollers_Programmer%27s_Guide.pdf">https://en.wikichip.org/w/images/4/44/MARC4_4-bit_Microcontrollers_Programmer%27s_Guide.pdf</a>
</li>

<li>MARC4 User's Guide qFORTH Compiler<br />
<a href="https://en.wikichip.org/w/images/2/25/MARC4_User%27s_Guide_qFORTH_Compiler.pdf">https://en.wikichip.org/w/images/2/25/MARC4_User%27s_Guide_qFORTH_Compiler.pdf</a>
</li>

<li>Programovací jazyk Forth a zásobníkové procesory<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/">http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/</a>
</li>

<li>Seriál Programovací jazyk Forth<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-forth/">http://www.root.cz/serialy/programovaci-jazyk-forth/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-factor/">http://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="http://www.root.cz/clanky/graficky-metaformat-postscript/">http://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

<li>PMOS<br />
<a href="https://en.wikipedia.org/wiki/PMOS_logic">https://en.wikipedia.org/wiki/PMOS_logic</a>
</li>

<li>NMOS<br />
<a href="https://en.wikipedia.org/wiki/NMOS_logic">https://en.wikipedia.org/wiki/NMOS_logic</a>
</li>

<li>CMOS<br />
<a href="https://en.wikipedia.org/wiki/CMOS">https://en.wikipedia.org/wiki/CMOS</a>
</li>

<li>Vacuum Fluorescent Display<br />
<a href="https://en.wikipedia.org/wiki/Vacuum_fluorescent_display">https://en.wikipedia.org/wiki/Vacuum_fluorescent_display</a>
</li>

<li>Computer History Museum: TMS 1000 4-Bit microcontroller<br />
<a href="http://www.computerhistory.org/collections/catalog/102711697">http://www.computerhistory.org/collections/catalog/102711697</a>
</li>

<li>Texas Instruments TMS1000 microcontroller family<br />
<a href="http://www.cpu-world.com/CPUs/TMS1000/">http://www.cpu-world.com/CPUs/TMS1000/</a>
</li>

<li>Invention History of Microcontroller<br />
<a href="http://www.circuitstoday.com/microcontroller-invention-history">http://www.circuitstoday.com/microcontroller-invention-history</a>
</li>

<li>TMS1000 Series - TI<br />
<a href="https://en.wikichip.org/wiki/ti/tms1000">https://en.wikichip.org/wiki/ti/tms1000</a>
</li>

<li>TMX1795 - TI<br />
<a href="https://en.wikichip.org/wiki/ti/tmx1795">https://en.wikichip.org/wiki/ti/tmx1795</a>
</li>

<li>Milton Bradley Microvision (U.S.) (1979, LCD, 9 Volt (1 or 2), Model# 4952)<br />
<a href="http://www.handheldmuseum.com/MB/uVUS.htm">http://www.handheldmuseum.com/MB/uVUS.htm</a>
</li>

<li>8051 Microcontroller<br />
<a href="http://www.circuitstoday.com/8051-microcontroller">http://www.circuitstoday.com/8051-microcontroller</a>
</li>

<li>4-bit (computer architectures)<br />
<a href="https://en.wikipedia.org/wiki/4-bit">https://en.wikipedia.org/wiki/4-bit</a>
</li>

<li>TMS 1000 Data Manual<br />
<a href="http://blog.kevtris.org/blogfiles/TMS_1000_Data_Manual.pdf">http://blog.kevtris.org/blogfiles/TMS_1000_Data_Manual.pdf</a>
</li>

<li>Considerations for 4-bit processing<br />
<a href="http://www.embeddedinsights.com/channels/2010/12/10/considerations-for-4-bit-processing/">http://www.embeddedinsights.com/channels/2010/12/10/considerations-for-4-bit-processing/</a>
</li>

<li>Are you, or would you consider, using a 4-bit microcontroller?<br />
<a href="http://www.embeddedinsights.com/channels/2010/11/24/are-you-or-would-you-consider-using-a-4-bit-microcontroller/">http://www.embeddedinsights.com/channels/2010/11/24/are-you-or-would-you-consider-using-a-4-bit-microcontroller/</a>
</li>

<li>MARC4 Micro-Controller<br />
<a href="https://en.wikipedia.org/wiki/MARC4_Micro-Controller">https://en.wikipedia.org/wiki/MARC4_Micro-Controller</a>
</li>

<li>The Texas Instruments TMX 1795: the (almost) first, forgotten microprocessor <br />
<a href="http://www.righto.com/2015/05/the-texas-instruments-tmx-1795-first.html">http://www.righto.com/2015/05/the-texas-instruments-tmx-1795-first.html</a>
</li>

<li>O2 Homepage<br />
<a href="http://www.the-nextlevel.com/odyssey2/">http://www.the-nextlevel.com/odyssey2/</a>
</li>

<li>Magnavox Odyssey2 (1978), Philips Videopac G7000 / C52 (1979)<br />
<a href="http://www.mess.org/sysinfo:odyssey2">http://www.mess.org/sysinfo:odyssey2</a>
</li>

<li>The Video Game Critic's Odyssey 2 Reviews <br />
<a href="http://videogamecritic.net/odd.htm">http://videogamecritic.net/odd.htm</a>
</li>

<li>Computer Closet Collection: Magnavox Odyssey^2<br />
<a href="http://www.computercloset.org/MagnavoxOdyssey2.htm">http://www.computercloset.org/MagnavoxOdyssey2.htm</a>
</li>

<li>PHILIPS Videopac C52<br />
<a href="http://old-computers.com/museum/computer.asp?c=1060">http://old-computers.com/museum/computer.asp?c=1060</a>
</li>

<li>O2 Tech. Manual V.1.1 (PDF dokument)<br />
<a href="http://www.atarihq.com/danb/files/o2doc.pdf">http://www.atarihq.com/danb/files/o2doc.pdf</a>
</li>

<li>Magnavox Odyssey<sup>2</sup><br />
<a href="http://www.game-machines.com/consoles/odyssey2.php">http://www.game-machines.com/consoles/odyssey2.php</a>
</li>

<li>Magnavox Odyssey<sup>2</sup> (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Odyssey_2">http://en.wikipedia.org/wiki/Odyssey_2</a>
</li>

<li>Magnavox Odyssey<sup>2</sup> Games (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/List_of_Videopac_games">http://en.wikipedia.org/wiki/List_of_Videopac_games</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

