<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>2D grafika s využitím knihovny OpenVG (nejenom) na Raspberry Pi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>2D grafika s využitím knihovny OpenVG (nejenom) na Raspberry Pi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na předchozí článek popisující základní postupy používané v knihovně EGL dnes navážeme, protože si vysvětlíme, jak je možné s využitím EGL vytvořit kreslicí plochu a následně do ní vykreslovat 2D grafiku přes funkce nabízené knihovnou OpenVG.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. 2D grafika s&nbsp;využitím knihovny OpenVG (nejenom) na Raspberry Pi</a></p>
<p><a href="#k02">2. Výběr vhodné konfigurace framebufferu</a></p>
<p><a href="#k03">3. Vytvoření kontextu pro kreslení a kreslicí plochy (surface)</a></p>
<p><a href="#k04">4. Specifikace chování zadního bufferu při operaci &bdquo;swap&ldquo; a propojení kontextu pro kreslení s&nbsp;kreslicí plochou</a></p>
<p><a href="#k05">5. Vymazání obrazovky černou barvou</a></p>
<p><a href="#k06">6. Nakreslení vyplněného obdélníku</a></p>
<p><a href="#k07">7. Úplný zdrojový kód dnešního prvního demonstračního příkladu</a></p>
<p><a href="#k08">8. Vykreslování úseček, polyčar a polygonů</a></p>
<p><a href="#k09">9. Styly štětce</a></p>
<p><a href="#k10">10. Úplný zdrojový kód dnešního druhého demonstračního příkladu</a></p>
<p><a href="#k11">11. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. 2D grafika s&nbsp;využitím knihovny OpenVG (nejenom) na Raspberry Pi</h2>

<p><a
href="http://www.root.cz/clanky/pouziti-knihoven-openvg-a-egl-nejenom-na-raspberry-pi/">V&nbsp;předchozím
článku</a> jsme si vysvětlili, jaká je úloha knihovny <i>EGL</i> při
programování aplikací využívajících OpenGL, OpenGL ES či OpenVG. Připomeňme si,
že <i>EGL</i> tvoří poměrně tenkou ale unifikovanou vrstvu ležící mezi
zmíněnými platformově nezávislými knihovnami (OpenGL, OpenGL ES či OpenVG) na
jedné straně a nativními knihovnami určenými pro ovládání oken či
celoobrazovkových režimů na straně druhé. Použitím <i>EGL</i> je tak možné
z&nbsp;aplikací odstranit platformově závislý kód, který by jinak bylo nutné
implementovat několikrát, což je neefektivní a současně to i klade větší
požadavky na dostupnost testovacího hardware atd. Minule jsme si taktéž
ukázali, jakým způsobem je možné použít funkce poskytované knihovnou <i>EGL</i>
pro základní inicializaci framebufferu při spouštění aplikace (několik kroků si
však ještě budeme muset popsat dnes) a jak naopak při ukončování aplikace
provést &bdquo;finalizaci&ldquo; framebufferu a na něj navázaných datových
struktur.</p>

<p>Před použitím knihovny <i>OpenVG</i> však ještě musíme provést několik
dalších operací, které budou stručně popsány v&nbsp;navazujících kapitolách
(pro většinu aplikací psaných v&nbsp;<i>OpenVG</i> je možné popsané funkce
přímo převzít a začít používat; většinou není nutné je podrobněji zkoumat).
Druhá polovina článku již bude konečně věnována použití <i>OpenVG</i>. Pokud
vás tedy zajímá hlavně <i>OpenVG</i>, klidně přeskočte <a href="#k05">na pátou
kapitolu</a>.</p>

<p>V&nbsp;demonstračních příkladech jsme stav grafického subsystému ukládali do
jednoduché datové struktury, kterou budeme používat i dnes:</p>

<pre>
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
<strong>typedef struct</strong>
{
    <strong>uint32_t</strong> screen_width;
    <strong>uint32_t</strong> screen_height;
&nbsp;
    <strong>uint32_t</strong> window_x;
    <strong>uint32_t</strong> window_y;
    <strong>int32_t</strong>  window_width;
    <strong>int32_t</strong>  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
</pre>

<p>První verze funkce pro inicializaci grafického subsystému s&nbsp;využitím
<i>EGL</i> vypadala takto:</p>

<pre>
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
<strong>void</strong> initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    <i>/* propojeni na vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda inicializace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
}
</pre>

<p>Ještě si připomeňme, jak vypadá &bdquo;finalizér&ldquo; (ten je již dokonalý
a nebudeme ho tedy muset měnit):</p>

<pre>
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
<strong>void</strong> finalize_egl(EGL_STATE_T *state)
{
    <i>/* nyni jsou tyto kroky prozatim zbytecne, v dalsich prikladech se vsak budou hodit */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Výběr vhodné konfigurace framebufferu</h2>

<p>Po prvních krocích spočívajících ve volání funkcí
<strong>eglGetDisplay</strong> a <strong>eglInitialize</strong> je nutné si
vybrat vhodnou konfiguraci framebufferu takovým způsobem, aby to přesně
odpovídalo požadavkům aplikace. Již naposledy si připomeňme, že konkrétně na
Raspberry Pi je k&nbsp;dispozici celkem 28 různých kombinací framebufferu,
které se od sebe odlišují jak hloubkou barvového bufferu, tak i přítomností
alpha bufferu (resp.&nbsp;průhlednosti v&nbsp;color bufferu), Z-bufferu či
stencil bufferu. Jedná se o tyto kombinace (získané demonstračním příkladem
popsaným minule):</p>

<pre>
EGL has 28 configurations available
Configuration  R   G   B   A   bpp   depth stencil bind RGB/RGBA
  0            8   8   8   8   32     24       8      no   yes
  1            8   8   8   0   24     24       8      yes  yes
  2            8   8   8   8   32     24       0      no   yes
  3            8   8   8   0   24     24       0      yes  yes
  4            8   8   8   8   32      0       8      no   yes
  5            8   8   8   0   24      0       8      yes  yes
  6            8   8   8   8   32      0       0      no   yes
  7            8   8   8   0   24      0       0      yes  yes
  8            8   8   8   8   32     24       8      no   no 
  9            8   8   8   0   24     24       8      no   no 
 10            8   8   8   8   32     24       0      no   no 
 11            8   8   8   0   24     24       0      no   no 
 12            8   8   8   8   32      0       8      no   no 
 13            8   8   8   0   24      0       8      no   no 
 14            8   8   8   8   32      0       0      no   no 
 15            8   8   8   0   24      0       0      no   no 
 16            5   6   5   0   16     24       8      yes  yes
 17            5   6   5   0   16     24       0      yes  yes
 18            5   6   5   0   16      0       8      yes  yes
 19            5   6   5   0   16      0       0      yes  yes
 20            5   6   5   0   16     24       8      no   no 
 21            5   6   5   0   16     24       0      no   no 
 22            5   6   5   0   16      0       8      no   no 
 23            5   6   5   0   16      0       0      no   no 
 24            8   8   8   8   32      0       0      no   yes
 25            8   8   8   0   24      0       0      yes  yes
 26            5   6   5   0   16      0       0      yes  yes
 27            5   6   5   0   16     16       0      yes  yes
</pre>

<p>Při práci s&nbsp;knihovnou <i>OpenVG</i>, která je orientovaná výhradně na
kvalitní 2D grafiku, se počet vhodných kombinací zmenšuje &ndash; nepotřebujeme
totiž používat paměť hloubky (Z-buffer, depth buffer), nepotřebujeme dokonce
ani stencil buffer a většinou nás nezajímá vazba vykreslovacích rutin na
textury. Počet vhodných kombinací se tak rapidně snižuje:</p>

<pre>
Configuration  R   G   B   A   bpp   depth stencil bind RGB/RGBA
 14            8   8   8   8   32      0       0      no   no 
 15            8   8   8   0   24      0       0      no   no 
 23            5   6   5   0   16      0       0      no   no 
</pre>

<p>Ukažme si nyní, jak se vhodná konfigurace framebufferu vybírá. Používá se
k&nbsp;tomu funkce nazvaná (celkem logicky) <strong>eglChooseConfig</strong>.
Hlavička této funkce vypadá poměrně děsivě:</p>

<pre>
EGLBoolean eglChooseConfig(EGLDisplay    dpy,
                           const EGLint *attrib_list,
                           EGLConfig    *configs,
                           EGLint        config_size,
                           EGLint       *num_config)
</pre>

<p>Ve skutečnosti není použití této funkce tak složité, jak to možná na první
pohled může vypadat. Prvním parametrem je struktura obsahující informace o
primárním displeji; tu již máme k&nbsp;dispozici. Zajímavější je druhý
parametr, což je pole obsahující požadované atributy framebufferu, a to
konkrétně dvojice identifikátor_atributu (celočíselná konstanta) a hodnota.
V&nbsp;céčku jsou prvky 2D polí uloženy za sebou, takže není problém všechny
požadované atributy uložit za sebou do jediného 1D pole. Celé pole je ukončeno
speciální hodnotou <strong>EGL_NONE</strong>. Pokud požadujeme vytvoření
framebufferu s&nbsp;hloubkou 24bpp a osmibitovým alfa kanálem, bude pole
s&nbsp;atributy vypadat takto:</p>

<pre>
<strong>static</strong> <strong>const</strong> EGLint attribute_list[] = {
    EGL_RED_SIZE, 8,
    EGL_GREEN_SIZE, 8,
    EGL_BLUE_SIZE, 8,
    EGL_ALPHA_SIZE, 8,
    EGL_SURFACE_TYPE, EGL_WINDOW_BIT, // typ kreslicí plochy
    EGL_NONE
};
</pre>

<p>Ve čtvrtém parametru se specifikuje, kolik konfigurací framebufferu
odpovídajících zadaným atributům se má vrátit. Nás bude zajímat jediná (první
vhodná) kombinace, tudíž zde předáme jedničku. Pole s&nbsp;konfiguracemi se
předává přes třetí parametr. Pole=ukazatel na jeho první prvek, takže
v&nbsp;našem případě postačuje předat přímo ukazatel na strukturu typu
<strong>EGLConfig</strong>. Poslední parametr je ukazatel na proměnnou typu
<strong>EGLint</strong> (celé číslo). Do této proměnné se přes předaný ukazatel
předá počet nalezených konfigurací (přičemž předpokládáme, že se nalezne aspoň
jedna vhodná konfigurace). Celý kód volající funkci
<strong>eglChooseConfig</strong> může vypadat takto:</p>

<pre>
EGLint     num_config;
EGLConfig  config;
EGLDisplay display;
&nbsp;
<i>/* vychozi displej */</i>
display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
<i>/* inicializace displeje */</i>
eglInitialize(display, NULL, NULL);
&nbsp;
<i>/* ziskani konfigurace framebufferu */</i>
eglChooseConfig(display, attribute_list, &amp;config, 1, &amp;num_config);
</pre>

<p>Samozřejmě musíme ještě přidat kontrolu, zda všechny funkce proběhly
v&nbsp;pořádku, takže vylepšený kód může vypadat následovně:</p>

<pre>
EGLBoolean result;
EGLint     num_config;
EGLConfig  config;
EGLDisplay display;
&nbsp;
<i>/* vychozi displej */</i>
display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
<i>/* inicializace displeje */</i>
result = eglInitialize(display, NULL, NULL);
<i>/* kontrola, zda operace probehla v poradku */</i>
<strong>if</strong> (result == EGL_FALSE) {
    puts("EGL init failed");
    exit(1);
}
&nbsp;
<i>/* ziskani konfigurace framebufferu */</i>
result = eglChooseConfig(display, attribute_list, &amp;config, 1, &amp;num_config);
<i>/* kontrola, zda operace probehla v poradku */</i>
<strong>if</strong> (result == EGL_FALSE) {
    puts("EGL choose config failed");
    exit(1);
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vytvoření kontextu pro kreslení a kreslicí plochy (surface)</h2>

<p>Předpokládejme, že předchozí operace proběhla v&nbsp;pořádku, takže
v&nbsp;proměnné <strong>config</strong> máme uloženou vhodnou konfiguraci
framebufferu. V&nbsp;dalším kroku specifikujeme, že na knihovnu <i>EGL</i> je
navázána knihovna <i>OpenVG</i>. To je snadné &ndash; použije se funkce
<strong>eglBindAPI</strong>, která akceptuje hodnoty
<strong>EGL_OPENGL_API</strong>, <strong>EGL_OPENGL_ES_API</strong> nebo
<strong>EGL_OPENVG_API</strong> (význam je zřejmý):</p>

<pre>
<i>/* navazani EGL na OpenVG */</i>
eglBindAPI(EGL_OPENVG_API);
</pre>

<p>Nyní již nastal čas na využití proměnné <strong>config</strong>, kterou jsme
tak pracně naplnili. Vytvoříme takzvaný rendering kontext zavoláním funkce
<strong>eglCreateContext</strong>. V&nbsp;nejjednodušším případě bude volání
této funkce vypadat takto (poslední dva parametry by se použily při sdílení
kontextu):</p>

<pre>
EGLContext context;
&nbsp;
<i>/* vytvoreni kontextu */</i>
context = eglCreateContext(display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
<i>/* kontrola, zda operace probehla v poradku */</i>
<strong>if</strong> (context == EGL_NO_CONTEXT) {
    puts("EGL create context failed");
    exit(1);
}
</pre>

<p>Další část programového kódu slouží k&nbsp;inicializaci takzvaného nativního
okna či celoobrazovkového režimu. V&nbsp;tomto úryvku kódu se volají funkce
z&nbsp;knihovny Dispman, kterou si prozatím (alespoň dnes) nebudeme popisovat;
proto prosím následující řádky pouze použijte, nic zlého se vašemu Raspberry Pi
ani připojenému monitoru nestane :-)</p>

<pre>
<i>/* vytvoreni surface */</i>
int32_t success = graphics_get_display_size(0, &amp;screen_width, &amp;screen_height);
&nbsp;
<i>/* kontrola, zda operace probehla v poradku */</i>
<strong>if</strong> (success &lt; 0) {
    puts("get display size failed");
    exit(1);
}
&nbsp;
dispman_display = vc_dispmanx_display_open(0);
dispman_update = vc_dispmanx_update_start(0);
&nbsp;
dispman_element = vc_dispmanx_element_add(dispman_update,
                                          dispman_display, 0 /*layer */ ,
                                          &amp;dst_rect, 0 /*src */ ,
                                          &amp;src_rect,
                                          DISPMANX_PROTECTION_NONE,
                                          &amp;alpha, 0 /*clamp */ ,
                                          0 /*transform */ );
&nbsp;
nativewindow.element = dispman_element;
nativewindow.width = state-&gt;window_width;
nativewindow.height = state-&gt;window_height;
vc_dispmanx_update_submit_sync(dispman_update);
</pre>

<p>Následuje již pochopitelnější kód sloužící pro vytvoření kreslicí plochy
(surface). Ta se vytváří pomocí funkce <strong>eglCreateWindowSurface</strong>
s&nbsp;následující hlavičkou:</p>

<pre>
EGLSurface eglCreateWindowSurface(EGLDisplay dpy,
                                  EGLConfig  config,
                                  EGLNativeWindowType win,
                                  const EGLint *attrib_list)
</pre>

<p>Hodnoty dosazované pro první dva parametry již máme připraveny (viz popis
<strong>eglGetDisplay</strong> a <strong>eglChooseConfig</strong>). Ve třetím
parametru se předává struktura popisující okno či celoobrazovkový režim (zde
získaná přes knihovnu Dispman), čtvrtý parametr může (ale nemusí) opět
obsahovat seznam požadovaných atributů:</p>

<pre>
EGLSurface surface;
&nbsp;
<i>/* vytvoreni surface */</i>
surface = eglCreateWindowSurface(display, config, &amp;nativewindow, NULL);
&nbsp;
<i>/* kontrola, zda operace probehla v poradku */</i>
<strong>if</strong> (surface == EGL_NO_SURFACE) {
    puts("no surface!");
    exit(1);
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Specifikace chování zadního bufferu při operaci &bdquo;swap&ldquo; a propojení kontextu pro kreslení s&nbsp;kreslicí plochou</h2>

<p>Už jsme skoro připraveni na použití knihovny <i>OpenVG</i>; zbývá nám pouze
specifikovat chování zadního bufferu při prohazování předního a zadního bufferu
(překreslení scény). Prozatím netvoříme žádné dynamické scény, které by se
neustále překreslovaly, takže nám bude vyhovovat, když se nový zadní buffer
automaticky NEvymaže. Nastavení tohoto chování je jednoduché:</p>

<pre>
<i>/* nastaveni chovani bufferu pri operaci swap */</i>
result = eglSurfaceAttrib(display, surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
<i>/* kontrola, zda operace probehla v poradku */</i>
<strong>if</strong> (result == EGL_FALSE) {
    puts("can not set surface attributes!");
    exit(1);
}
</pre>

<p>Úplně nakonec specifikujeme, která kreslicí plocha bude výchozí pro všechny
další operace. Knihovna <i>EGL</i> a <i>OpenVG</i> bude nastavenou kreslicí
plochu implicitně používat, aniž by bylo nutné neustále přenášet její
identifikátor při volání ostatních funkcí (což je vlastnost, která může být
někdy výhodná a někdy nikoli, záleží na množství připojených displejů
atd.):</p>

<pre>
<i>/* propojeni kontextu se surface */</i>
result = eglMakeCurrent(display, surface, surface, context);
&nbsp;
<i>/* kontrola, zda operace probehla v poradku */</i>
<strong>if</strong> (result == EGL_FALSE) {
    puts("can not connect context with the surface!");
    exit(1);
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vymazání obrazovky černou barvou</h2>

<p>Inicializace grafického subsystému Raspberry Pi (či jiného počítače
s&nbsp;EGL) se snad podařila, takže se konečně dostáváme k&nbsp;popisu možností
knihovny <i>OpenVG</i>. Tato knihovna je určena pro tvorbu kvalitní 2D grafiky,
protože právě s&nbsp;2D grafikou se uživatelé v&nbsp;současnosti setkávají při
práci na desktopu, tabletu či smartphonu nejčastěji. Typickou 2D aplikací
dneška je webový prohlížeč, od něhož se mj.&nbsp;vyžaduje i co nejrychlejší
vykreslení mnohdy velmi složitého layoutu stránek, plynulý scrolling, kvalitně
zobrazené písmo, dynamické změny ve stránkách, podpora HTML 5 canvasu apod.
Dalšími 2D aplikacemi mohou být některé oblíbené hry, ať již se jedná o typicky
dvourozměrné Angry Birds či o hry s&nbsp;isometrickou grafikou. Na tabletech,
smartphonech a některých &bdquo;moderních&ldquo; desktopech se taktéž velmi
často požaduje zmenšení aplikace do živé ikony či použití vektorových ikon a
widgetů (škálovatelné grafické uživatelské rozhraní).</p>

<p>Právě na tento segment se soustředí knihovna <i>OpenVG</i>, která dokonce
vyžaduje, aby její implementace prošly poměrně velkým množstvím testů, které
zjišťují, jakým způsobem a jak kvalitně je rendering 2D grafiky proveden.
Podívejme se na některé základní operace. Začneme skutečně od triviálních
operací, ovšem i na nich si lze ukázat některé vlastnosti <i>OpenVG</i>. První
nutnou operací je vymazání obrazovky (resp.&nbsp;většinou zadního bufferu). Pro
tyto účely použijeme funkci <strong>vgClear</strong>, které se předají
souřadnice jednoho vrcholu a rozměry osově orientovaného obdélníku, který se má
vymazat (rozměry framebufferu už máme zjištěné z&nbsp;předchozího kódu):</p>

<pre>
vgClear(0, 0, window_width, window_height);
</pre>

<p>Ještě předtím je ale nutné specifikovat barvu mazání, a to s&nbsp;využitím
&bdquo;setteru&ldquo; nazvaného <strong>vgSetfv</strong>. U názvu této funkce
se na chvíli zastavme, protože je z&nbsp;něj patrné, že se používá podobný
(nikoli však totožný) způsob pojmenování, jaký možná čtenáři znají
z&nbsp;knihovny <i>OpenGL</i>. Ve skutečnosti je &bdquo;setter&ldquo;
realizován hned několika funkcemi, které se odlišují typem a počtem předávaných
parametrů:</p>

<table>
<tr><td>void vgSeti(VGParamType paramType, VGint val)                      </td><td>nastavení jednoho parametru typu int</td></tr>
<tr><td>void vgSetf(VGParamType paramType, VGfloat val)                    </td><td>nastavení jednoho parametru typu float</td></tr>
<tr><td>void vgSetiv(VGParamType paramType, VGint cnt, const VGint * val)  </td><td>nastavení pole parametrů typu int</td></tr>
<tr><td>void vgSetfv(VGParamType paramType, VGint cnt, const VGfloat * val)</td><td>nastavení pole parametrů typu float</td></tr>
</table>

<p>Pokud je zapotřebí nastavit barvu mazání, je jméno příslušného parametru
<strong>VG_CLEAR_COLOR</strong> a jeho hodnotou může být například pole čtyř
hodnot typu float (RGBA), i když existují i další možnosti. Délka pole (počet
prvků) je tedy 4 a celý kód pro vymazání bufferu může vypadat takto:</p>

<pre>
<i>/* vymazani pozadi cernou barvou */</i>
VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
vgSetfv(VG_CLEAR_COLOR, 4, color1);
vgClear(0, 0, window_width, window_height);
</pre>

<p>Poznámka: v&nbsp;<i>OpenVG</i> se pro nastavení stavu (narozdíl od
<i>OpenGL</i>) skutečně důsledně používají výše zmíněné čtyři funkce. Stav
vykreslovací pipeline je součástí aktuálního kontextu nastaveného funkcí
<strong>eglMakeCurrent</strong> (viz též předchozí kapitoly).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nakreslení vyplněného obdélníku</h2>

<p>Pohled na černou obrazovku asi není příliš zajímavý, proto do scény přidáme
další grafický prvek. Bude se jednat o vyplněný osově orientovaný obdélník.
Barva výplně a barva okrajů obdélníka bude odlišná. Nejprve se podívejme, jak
se nastaví barva okrajů vykreslovaných objektů (to není zcela přesný termín,
protože se nastavuje barva vykreslované &bdquo;cesty&ldquo;, která je u
obdélníka současně i jeho hranicí, u otevřených cest to však samozřejmě
neplatí, neboť ty žádný vyplňovatelný vnitřek nemají). Nejprve se vytvoří
objekt typu &bdquo;paint&ldquo; funkcí <strong>vgCreatePaint</strong>. Přes
tento objekt se nastaví vnitřní stav knihovny OpenVG, která si udržuje dvě
důležité informace: jak vykreslovat cesty a jak vyplňovat vnitřky uzavřených
cest. Posléze nastavíme dva parametry udržované tímto objektem: typ
(vykreslování cest) a barvu. Následně se pomocí funkce
<strong>vgSetPaint</strong> určí, že nastavené parametry se mají uložit do
vnitřního stavu OpenVG udržujícího informace o vykreslování cest (a nikoli
výplní). Nakonec se může objekt typu &bdquo;paint&ldquo; zrušit a uvolnit tak
jeho paměť:</p>

<pre>
<i>/* barva stetce */</i>
VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
VGPaint strokePaint = vgCreatePaint();
vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
vgSetPaint(strokePaint, VG_STROKE_PATH);
vgDestroyPaint(strokePaint);
</pre>

<p>Zcela stejný postup použijeme při nastavení barvy výplně. Zde se bude lišit
pouze typ objektu typu &bdquo;paint&ldquo;: namísto
<strong>VG_STROKE_PATH</strong> použijeme <strong>VG_FILL_PATH</strong> a
následně se objekt opět zruší:</p>

<pre>
<i>/* barva vyplne */</i>
VGfloat color3[4] = {0.25f, 0.25f, 0.75f, 1.0f};
VGPaint fillPaint = vgCreatePaint();
vgSetParameteri(fillPaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
vgSetParameterfv(fillPaint, VG_PAINT_COLOR, 4, color3);
vgSetPaint(fillPaint, VG_FILL_PATH);
vgDestroyPaint(fillPaint);
</pre>

<p>Zbývá nám nastavit šířku vykreslovaných cest, způsob vykreslení jejich
zalomení a taktéž konců. Tímto tématem se budeme zabývat v&nbsp;dalších
kapitolách, proto jen stručně:</p>

<pre>
<i>/* sirka a styl stetce */</i>
vgSetf(VG_STROKE_LINE_WIDTH, 10);
vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
</pre>

<p>Samotný obdélník je tvořen &bdquo;cestou&ldquo; vytvořenou pomocí funkce
<strong>vgCreatePath</strong>. Při definici vrcholů vytvářené křivky máme více
možností, já jsem zde pro jednoduchost použil knihovnu <i>VGU</i> a v&nbsp;ní
deklarovanou funkci <strong>vguRect</strong>. Cesta se vykreslí do zadního
bufferu příkazem <strong>vgDrawPath</strong> a nakonec se může paměť alokovaná
pro cestu uvolnit přes funkci <strong>vgDestroyPath</strong>:</p>

<pre>
<i>/* vykresleni obdelnika */</i>
VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
vguRect(path, x, y, width, height);
vgDrawPath(path, VG_FILL_PATH | VG_STROKE_PATH);
vgDestroyPath(path);
</pre>

<p>Parametry funkce <strong>vgCreatePath</strong> budou přesněji popsány
příště.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód dnešního prvního demonstračního příkladu</h2>

<p>Všechny kroky popsané ve druhé až šesté kapitole jsou součástí dnešního
prvního demonstračního příkladu, jehož <a
href="https://github.com/tisnik/presentations/blob/master/openvg/example4/example4.c">úplný
zdrojový kód</a> i příslušný soubor <a
href="https://github.com/tisnik/presentations/blob/master/openvg/example4/Makefile">Makefile</a>
samozřejmě naleznete na GitHubu. Příklad je plně funkční na Raspberry Pi
(konkrétně byl otestován na RPi 1 Modelu B):</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - ctvrty demonstracni priklad */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
<strong>typedef</strong> <strong>struct</strong>
{
    <strong>uint32_t</strong> screen_width;
    <strong>uint32_t</strong> screen_height;
&nbsp;
    <strong>uint32_t</strong> window_x;
    <strong>uint32_t</strong> window_y;
    <strong>int32_t</strong>  window_width;
    <strong>int32_t</strong>  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
<strong>void</strong> initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    <strong>static</strong> EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    <strong>static</strong> VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    <strong>static</strong> <strong>const</strong> EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    <strong>int32_t</strong> success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    <strong>if</strong> ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    <strong>if</strong> ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 /*layer */ , &amp;dst_rect, 0 /*src */ ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 /*clamp */ ,
                          0 /*transform */ );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
<strong>void</strong> finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni vyplneneho obdelnika.</i>
<i> */</i>
<strong>void</strong> draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* barva stetce */</i>
    VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
    VGPaint strokePaint = vgCreatePaint();
    vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
    vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
    vgSetPaint(strokePaint, VG_STROKE_PATH);
    vgDestroyPaint(strokePaint);
&nbsp;
    <i>/* barva vyplne */</i>
    VGfloat color3[4] = {0.25f, 0.25f, 0.75f, 1.0f};
    VGPaint fillPaint = vgCreatePaint();
    vgSetParameteri(fillPaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
    vgSetParameterfv(fillPaint, VG_PAINT_COLOR, 4, color3);
    vgSetPaint(fillPaint, VG_FILL_PATH);
    vgDestroyPaint(fillPaint);
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 10);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* vykresleni obdelnika */</i>
    VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
    vguRect(path, state-&gt;window_width/3, state-&gt;window_height/3, state-&gt;window_width/3, state-&gt;window_height/3);
    vgDrawPath(path, VG_FILL_PATH | VG_STROKE_PATH);
    vgDestroyPath(path);
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    <strong>return</strong> 0;
}
</pre>

<p>Soubor <strong>Makefile</strong> použitý pro překlad dnešního prvního
demonstračního příkladu vypadá následovně:</p>

<pre>
<i># Makefile pro preklad ctvrteho prikladu ukazujiciho</i>
<i># praci s OpenVG a EGL.</i>
&nbsp;
<i># Parametry prekladace.</i>
CFLAGS=-Wall
&nbsp;
<i># Dalsi parametry prekladace, zde adresare, kde se maji </i>
<i># hledat hlavickove soubory.</i>
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
<i># Parametry linkeru.</i>
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example4
&nbsp;
<i># Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.</i>
all:    $(PROGNAME)
&nbsp;
clean:
        rm -f *.o
        rm -f $(PROGNAME)
&nbsp;
<i># Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni</i>
<i># vysledne spustitelne aplikace.</i>
$(PROGNAME):    $(PROGNAME).o
        $(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
<i># Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho</i>
<i># objektoveho souboru.</i>
%.o:    %.c
        $(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vykreslování úseček, polyčar a polygonů</h2>

<p>Pro vykreslování samostatných úseček, polyčar (lomených čar) či polygonů
(uzavřených polyčar) je nejjednodušší postupovat následovně:</p>

<ol>
<li>Vytvořit cestu pomocí funkce <strong>vgCreatePath</strong></li>
<li>Zavolat funkci <strong>vguPolygon</strong> a předat jí pole vrcholů (jednorozměrné pole či pole dvojic)</li>
<li>Vykreslit cestu funkcí <strong>vgDrawPath</strong></li>
<li>Zrušit cestu funkcí <strong>vgDestroyPath</strong></li>
</ol>

<p>V&nbsp;praxi to může vypadat následovně:</p>

<pre>
<i>/*</i>
<i> * Vykresleni polycary slozene ze dvou usesek.</i>
<i> */</i>
<strong>void</strong> drawPolyline(<strong>int</strong> xoffset, <strong>int</strong> yoffset)
{
    <i>/* vykresleni polycary */</i>
    VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
    float vertexes2[] = {xoffset+100, yoffset+100, xoffset+200, yoffset+100, xoffset+200, yoffset+200};
    vguPolygon(path, vertexes2, 3, VG_FALSE);
    vgDrawPath(path, VG_STROKE_PATH);
    vgDestroyPath(path);
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Styly štětce</h2>

<p>Styly vykreslování cest (a tedy i úseček, polyčar apod.) se nastavují
funkcemi <strong>vgSeti</strong>, <strong>vgSetf</strong>,
<strong>vgSetiv</strong> a <strong>vgSetfv</strong> (viz též <a
href="#k05">pátou kapitolu</a>). Nás nyní budou zajímat tři základní parametry:
šířka vykreslované stopy, tvar stopy při zakončení křivek (konce úseček) a tvar
stopy při lomení křivek (jak se například vykreslí rohy obdélníka):</p>

<table>
<tr><th>Parametr      </th><th>Funkce</th><th>Hodnota parametru</th></tr>
<tr><td>Šířka stopy   </td><td>vgSetf(VG_STROKE_LINE_WIDTH, ...)</td><td>float (šířka v&nbsp;pixelech)</td></tr>
<tr><td>Tvar zakončení</td><td>vgSeti(VG_STROKE_CAP_STYLE, ...) </td><td>VG_CAP_BUTT, VG_CAP_ROUND, VG_CAP_SQUARE</td></tr>
<tr><td>Tvar zalomení </td><td>vgSeti(VG_STROKE_JOIN_STYLE, ...)</td><td>VG_JOIN_MITER, VG_JOIN_BEVEL, VG_JOIN_ROUND</td></tr>
</table>

<p>Pokud tedy budeme požadovat stopu kreslenou šířkou deseti pixelů se
zakulacenými konci i zalomeními, stačí napsat:</p>

<pre>
vgSetf(VG_STROKE_LINE_WIDTH, 10);
vgSeti(VG_STROKE_CAP_STYLE,  VG_CAP_ROUND);
vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
</pre>

<p>Funkci <strong>drawPolyline</strong>, kterou jsme si ukázali <a
href="#k08">v&nbsp;předchozí kapitole</a>, můžeme rozšířit takovým způsobem,
aby bylo možné nastavit šířku štětce, způsob vykreslení zakončení křivek a
taktéž způsob vykreslení zalomení křivek:</p>

<pre>
<i>/*</i>
<i> * Vykresleni polycary slozene ze dvou usesek.</i>
<i> */</i>
<strong>void</strong> drawPolyline(<strong>int</strong> xoffset, <strong>int</strong> yoffset, VGfloat strokeWidth, VGCapStyle capStyle, VGJoinStyle joinStyle)
{
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, strokeWidth);
    vgSeti(VG_STROKE_CAP_STYLE, capStyle);
    vgSeti(VG_STROKE_JOIN_STYLE, joinStyle);
&nbsp;
    <i>/* vykresleni polycary */</i>
    VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
    float vertexes2[] = {xoffset+100, yoffset+100, xoffset+200, yoffset+100, xoffset+200, yoffset+200};
    vguPolygon(path, vertexes2, 3, VG_FALSE);
    vgDrawPath(path, VG_STROKE_PATH);
    vgDestroyPath(path);
}
</pre>

<p>Všechny kombinace stylů zakončení a zalomení si můžeme ihned odzkoušet na
dostatečně širokých polyčárách:</p>

<pre>
<i>/* vykresleni nekolika polycar */</i>
drawPolyline(  0,   0,  1, VG_CAP_BUTT, VG_JOIN_MITER);
&nbsp;
drawPolyline(  0, 150, 20, VG_CAP_BUTT,   VG_JOIN_MITER);
drawPolyline(150, 150, 20, VG_CAP_ROUND,  VG_JOIN_MITER);
drawPolyline(300, 150, 20, VG_CAP_SQUARE, VG_JOIN_MITER);
&nbsp;
drawPolyline(  0, 300, 20, VG_CAP_BUTT,   VG_JOIN_ROUND);
drawPolyline(150, 300, 20, VG_CAP_ROUND,  VG_JOIN_ROUND);
drawPolyline(300, 300, 20, VG_CAP_SQUARE, VG_JOIN_ROUND);
&nbsp;
drawPolyline(  0, 450, 20, VG_CAP_BUTT,   VG_JOIN_BEVEL);
drawPolyline(150, 450, 20, VG_CAP_ROUND,  VG_JOIN_BEVEL);
drawPolyline(300, 450, 20, VG_CAP_SQUARE, VG_JOIN_BEVEL);
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úplný zdrojový kód dnešního druhého demonstračního příkladu</h2>

<p>Předchozí úryvek kódu byl zakomponován do dnešního druhého demonstračního
příkladu, jehož <a
href="https://github.com/tisnik/presentations/blob/master/openvg/example5/example4.c">úplný
zdrojový kód</a> i příslušný soubor <a
href="https://github.com/tisnik/presentations/blob/master/openvg/example5/Makefile">Makefile</a>
opět naleznete na GitHubu:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - paty demonstracni priklad */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
<strong>typedef</strong> <strong>struct</strong>
{
    <strong>uint32_t</strong> screen_width;
    <strong>uint32_t</strong> screen_height;
&nbsp;
    <strong>uint32_t</strong> window_x;
    <strong>uint32_t</strong> window_y;
    <strong>int32_t</strong>  window_width;
    <strong>int32_t</strong>  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
<strong>void</strong> initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    <strong>static</strong> EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    <strong>static</strong> VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    <strong>static</strong> const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    <strong>int32_t</strong> success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    <strong>if</strong> ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    <strong>if</strong> ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 /*layer */ , &amp;dst_rect, 0 /*src */ ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 /*clamp */ ,
                          0 /*transform */ );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
<strong>void</strong> finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni polycary slozene ze dvou usesek.</i>
<i> */</i>
<strong>void</strong> drawPolyline(<strong>int</strong> xoffset, <strong>int</strong> yoffset, VGfloat strokeWidth, VGCapStyle capStyle, VGJoinStyle joinStyle)
{
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, strokeWidth);
    vgSeti(VG_STROKE_CAP_STYLE, capStyle);
    vgSeti(VG_STROKE_JOIN_STYLE, joinStyle);
&nbsp;
    <i>/* vykresleni polycary */</i>
    VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
    float vertexes2[] = {xoffset+100, yoffset+100, xoffset+200, yoffset+100, xoffset+200, yoffset+200};
    vguPolygon(path, vertexes2, 3, VG_FALSE);
    vgDrawPath(path, VG_STROKE_PATH);
    vgDestroyPath(path);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni vyplneneho obdelnika.</i>
<i> */</i>
<strong>void</strong> draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* barva stetce */</i>
    VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
    VGPaint strokePaint = vgCreatePaint();
    vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
    vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
    vgSetPaint(strokePaint, VG_STROKE_PATH);
    vgDestroyPaint(strokePaint);
&nbsp;
    <i>/* vykresleni nekolika polycar */</i>
    drawPolyline(  0,   0,  1, VG_CAP_BUTT, VG_JOIN_MITER);
&nbsp;
    drawPolyline(  0, 150, 20, VG_CAP_BUTT,   VG_JOIN_MITER);
    drawPolyline(150, 150, 20, VG_CAP_ROUND,  VG_JOIN_MITER);
    drawPolyline(300, 150, 20, VG_CAP_SQUARE, VG_JOIN_MITER);
&nbsp;
    drawPolyline(  0, 300, 20, VG_CAP_BUTT,   VG_JOIN_ROUND);
    drawPolyline(150, 300, 20, VG_CAP_ROUND,  VG_JOIN_ROUND);
    drawPolyline(300, 300, 20, VG_CAP_SQUARE, VG_JOIN_ROUND);
&nbsp;
    drawPolyline(  0, 450, 20, VG_CAP_BUTT,   VG_JOIN_BEVEL);
    drawPolyline(150, 450, 20, VG_CAP_ROUND,  VG_JOIN_BEVEL);
    drawPolyline(300, 450, 20, VG_CAP_SQUARE, VG_JOIN_BEVEL);
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    <strong>return</strong> 0;
}
</pre>

<p>Soubor <strong>Makefile</strong> použitý pro překlad dnešního prvního
demonstračního příkladu vypadá následovně:</p>

<pre>
<i># Makefile pro preklad pateho prikladu ukazujiciho</i>
<i># praci s OpenVG a EGL.</i>
&nbsp;
<i># Parametry prekladace.</i>
CFLAGS=-Wall
&nbsp;
<i># Dalsi parametry prekladace, zde adresare, kde se maji </i>
<i># hledat hlavickove soubory.</i>
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
<i># Parametry linkeru.</i>
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example5
&nbsp;
<i># Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.</i>
all:    $(PROGNAME)
&nbsp;
clean:
        rm -f *.o
        rm -f $(PROGNAME)
&nbsp;
<i># Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni</i>
<i># vysledne spustitelne aplikace.</i>
$(PROGNAME):    $(PROGNAME).o
        $(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
<i># Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho</i>
<i># objektoveho souboru.</i>
%.o:    %.c
        $(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositář s&nbsp;demonstračními příklady</h2>

<p>Oba dva demonstrační příklady, které jsme si v&nbsp;dnešním článku popsali,
byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy oboi
zmíněných demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad/knihovna</th><th>Github</th></tr>
<tr><td>1</td><td>example4</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example4">https://github.com/tisnik/presentations/tree/master/openvg/example4</a></td></tr>
<tr><td>2</td><td>example5</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example5">https://github.com/tisnik/presentations/tree/master/openvg/example5</a></td></tr>
</table>

<p>Poznámka<sup>1</sup>: pro zjednodušení překladu je ke každému demonstračnímu
příkladu přiložen i příslušný soubor Makefile.</p>

<p>Poznámka<sup>2</sup>: nenechte se prosím zmást číslováním &ndash; příklady
example1 až example3 byly totiž popsány v&nbsp;předchozí části tohoto
seriálu.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>EGL quick reference card<br />
<a href="https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf">https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf</a>
</li>

<li>EGL Reference Pages Index<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php">https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php</a>
</li>

<li>Funkce eglInitialize<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml</a>
</li>

<li>Funkce eglGetDisplay<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml</a>
</li>

<li>Funkce eglGetConfigs<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml</a>
</li>

<li>Funkce eglGetConfigAttrib<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml</a>
</li>

<li>Funkce eglDestroySurface<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml</a>
</li>

<li>Funkce eglDestroyContext<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml</a>
</li>

<li>Funkce eglTerminate<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml</a>
</li>

<li>Khronos Native Platform Graphics Interface<br />
<a href="https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf">https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf</a>
</li>

<li>Khronos Group<br />
<a href="https://www.khronos.org/">https://www.khronos.org/</a>
</li>

<li>Khronos Group (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Khronos_Group">https://en.wikipedia.org/wiki/Khronos_Group</a>
</li>

<li>Raspberry Pi VideoCore APIs<br />
<a href="http://elinux.org/Raspberry_Pi_VideoCore_APIs">http://elinux.org/Raspberry_Pi_VideoCore_APIs</a>
</li>

<li>Programming AudioVideo on the Raspberry Pi GPU<br />
<a href="https://jan.newmarch.name/RPi/index.html">https://jan.newmarch.name/RPi/index.html</a>
</li>

<li>The Standard for Vector Graphics Acceleration<br />
<a href="https://www.khronos.org/openvg/">https://www.khronos.org/openvg/</a>
</li>

<li>OpenVG (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenVG">https://en.wikipedia.org/wiki/OpenVG</a>
</li>

<li>OpenVG Quick Reference Card<br />
<a href="https://www.khronos.org/files/openvg-quick-reference-card.pdf">https://www.khronos.org/files/openvg-quick-reference-card.pdf</a>
</li>

<li>OpenVG on the Raspberry Pi<br />
<a href="http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html">http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html</a>
</li>

<li>ShivaVG: open-source ANSI C OpenVG <br />
<a href="http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html">http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html</a>
</li>

<li>Testbed for exploring OpenVG on the Raspberry Pi<br />
<a href="https://github.com/ajstarks/openvg">https://github.com/ajstarks/openvg</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame prakticky<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: práce s bitmapami a TrueType fonty<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: sprity v knihovně Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: detekce kolize spritů<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: transformace rastrových obrázků<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/</a>
</li>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

