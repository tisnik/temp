<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Spouštění aplikací psaných v C či C++ využívajících knihovnu SDL v okně webového prohlížeče</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Spouštění aplikací psaných v C či C++ využívajících knihovnu SDL v okně webového prohlížeče</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku si ukážeme, jakým způsobem je možné spouštět aplikace psané v C či C++, které využívají knihovny SDL nebo SDL2, přímo v okně webového prohlížeče. Zdrojové kódy těchto aplikací totiž lze přeložit nástrojem Emscripten buď do WebAssembly nebo do asm.js (podmnožiny JavaScriptu).</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Spouštění aplikací psaných v&nbsp;C či C++ využívajících knihovnu SDL v&nbsp;okně webového prohlížeče</a></p>
<p><a href="#k02">2. Malé ohlédnutí: způsob využití různých programovacích jazyků na webových stránkách</a></p>
<p><a href="#k03">3. Transpřekladače do JavaScriptu</a></p>
<p><a href="#k04">4. WebAssembly</a></p>
<p><a href="#k05">5. Nástroj Emscripten se představuje</a></p>
<p><a href="#k06">6. Stručný popis využití celého toolchainu Emscriptenu</a></p>
<p><a href="#k07">*** 7. Běh grafických aplikací naprogramovaných v&nbsp;céčku a využívajících SDL a SDL2 ve webovém prohlížeči</a></p>
<p><a href="#k08">*** 8. Podpora SDL i SDL2</a></p>
<p><a href="#k09">9. Instalace závislostí pro Emscripten (Fedora 36)</a></p>
<p><a href="#k10">10. Instalace samotného Emscriptenu</a></p>
<p><a href="#k11">*** 11. Testovací příklad určený pro překlad do binární nativní aplikace</a></p>
<p><a href="#k12">*** 12. Úprava příkladu pro Emscripten</a></p>
<p><a href="#k13">*** 13. Překlad příkladu do WebAssembly s&nbsp;jeho spuštěním</a></p>
<p><a href="#k14">*** 14. Překlad příkladu do JavaScriptu (asm.js) s&nbsp;jeho spuštěním</a></p>
<p><a href="#k15">*** 15. Příklad s&nbsp;jednoduchou animací: nativní verze</a></p>
<p><a href="#k16">*** 16. Příklad s&nbsp;jednoduchou animací: úprava pro Emscripten</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Spouštění aplikací psaných v&nbsp;C či C++ využívajících knihovnu SDL v&nbsp;okně webového prohlížeče</h2>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Malé ohlédnutí: způsob využití různých programovacích jazyků na webových stránkách</h2>

<p><i>JavaScript is an assembly language. The JavaScript + HTML generate is
like a .NET assembly. The browser can execute it, but no human should really
care what's there.<br />
Erik Meijer</i></p>

<p>Pravděpodobně nejjednodušší a taktéž i nejpřímější cestou podpory nového
programovacího jazyka ve webových prohlížečích je integrace jeho interpretru
přímo do prohlížeče popř.&nbsp;použití pluginu s&nbsp;tímto interpretrem. Ovšem
i přes snahy některých vývojářů a softwarových společností o začlenění dalších
skriptovacích jazyků do webových prohlížečů (z&nbsp;historického pohledu se
jednalo minimálně o Tcl, později VBScript, a v&nbsp;neposlední řadě o Dart
v&nbsp;Dartiu apod.) je patrné, že v&nbsp;současnosti je jediným široce
akceptovaným <i>skriptovacím jazykem</i> na straně webového prohlížeče pouze
JavaScript se všemi přednostmi a zápory, které tato monokultura přináší. To
však v&nbsp;žádném případě neznamená, že by se ty části aplikace, které mají
být spouštěny na straně klienta, musely psát pouze v&nbsp;JavaScriptu, jenž
nemusí zdaleka všem vývojářům vyhovovat, ať již z&nbsp;objektivních či ze
subjektivních příčin (například kvůli dosti <a
href="https://www.youtube.com/watch?v=et8xNAc2ic8">zvláštně navrženému typovému
systému</a>, který ovšem umožnil realizovat například <a
href="http://www.jsfuck.com/">JSF*ck</a>).</p>

<p>V&nbsp;relativně nedávné minulosti proto vzniklo a pořád ještě vzniká mnoho
projektů, jejichž cílem je umožnit tvorbu webových aplikací pro prohlížeč
v&nbsp;jiných programovacích jazycích. Zdrojové kódy je pak nutné nějakým
způsobem zpracovat (transpřeložit, přeložit, ...) takovým způsobem, aby je bylo
možné ve webovém prohlížeči spustit. Možností je hned několik &ndash; lze
použít plugin (velmi problematické a dnes značně nepopulární řešení &ndash;
ovlivněné především bezpečnostními problémy, které se v&nbsp;minulosti některým
nejmenovaným pluginům nevyhnuly), <i>transpřekladač</i> do JavaScriptu či
virtuální stroj popř.&nbsp;interpret daného jazyka implementovaný opět
v&nbsp;JavaScriptu. Právě posledními dvěma zmíněnými možnostmi se budeme ve
stručnosti zabývat v&nbsp;navazujících kapitolách. A zapomenout v&nbsp;žádném
případě nesmíme na technologii <a
href="https://webassembly.org/">WebAssembly</a> (WASM), kterou ostatně dnes
využijeme.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Transpřekladače do JavaScriptu</h2>

<p>Jednu z&nbsp;dnes velmi populárních(*) technik umožňujících použití
prakticky libovolného programovacího jazyka pro tvorbu aplikací běžících na
straně webového prohlížeče, představuje použití takzvaných <i>transcompilerů
(source-to-source compiler)</i> zajišťujících překlad programu napsaného ve
zdrojovém programovacím jazyce do funkčně identického programu napsaného
v&nbsp;JavaScriptu (někdy se setkáme i s&nbsp;označením <a
href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them">transpiler</a>).
Transpřekladač se většinou spouští jen jednou na vývojářském počítači, samotní
klienti již mají k&nbsp;dispozici JavaScriptový kód &ndash; což znamená, že
vývojář může použít jakýkoli vhodný jazyk, zatímco uživatel si vystačí
s&nbsp;běžným webovým prohlížečem.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti není technologie
transpřekladačů žádným způsobem svázána právě s&nbsp;JavaScriptem, protože se
používala (a používá) i pro další manipulace se zdrojovými kódy; ostatně jedná
se o téma, kterému jsme se na stránkách Roota již několikrát věnovali &ndash;
připomeňme si například projekt <a
href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">Coconut</a>,
<a
href="https://www.root.cz/clanky/moonscript-jazyk-inspirovany-coffeescriptem-urceny-pro-ekosystem-jazyka-lua/">MoonScript</a>
či <a
href="https://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">ClojureScript</a>).</div></p>

<p>Existuje však i druhá možnost, kdy je samotný transpřekladač naprogramován
v&nbsp;JavaScriptu a spouštěn přímo ve webovém prohlížeči klientů. Oba přístupy
mají své přednosti, ale pochopitelně i nějaké zápory (například tvůrci
uzavřených aplikací pravděpodobně budou upřednostňovat první možnost, protože
výstupy transcompilerů jsou většinou dosti nečitelné; dokonce by mohla snaha o
prozkoumání kódu spadat pod reverse engineering). Druhá možnost je relativně
elegantní v&nbsp;tom ohledu, že se z&nbsp;pohledu programátora webové aplikace
skutečně jedná o nový programovací jazyk, který je jakoby přímo zpracováván
prohlížečem na stejné úrovni jako JavaScript. Příkladem může být kombinace
JavaScriptu a jazyka <a
href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">WISP</a>
(což je z&nbsp;dnešního pohledu už obskurní jazyk):</p>

<pre>
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Jazyk WISP na webové stránce&lt;/title&gt;
        &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;
&nbsp;
        &lt;script src="wisp.min.js" type="application/javascript"&gt;
        &lt;/script&gt;
&nbsp;
        &lt;script type="application/wisp"&gt;
        (print "část naprogramovaná ve WISPu")
        &lt;/script&gt;
&nbsp;
        &lt;script type="application/javascript"&gt;
        console.log("část naprogramovaná v JavaScriptu")
        &lt;/script&gt;
&nbsp;
    &lt;/head&gt;
&nbsp;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Z&nbsp;praxe můžeme uvést například následující projekty založené na
transpřekladači. Některé z&nbsp;nich je možné použít přímo v&nbsp;prohlížeči,
jiné provádí překlad do JavaScriptu na příkazovém řádku, existují i kombinace
obou způsobů (opět viz WISP podporující oba režimy):</p>:

<table>
<tr><th>#</th><th>Jazyk</th><th>Poznámka</th></tr>
<tr><td>1</td><td>CoffeeScript</td><td>přidání syntaktického cukru do JavaScriptu</td></tr>
<tr><td>2</td><td>JSweet</td><td>překlad programů z&nbsp;Javy do JavaScriptu popř.&nbsp;do TypeScriptu</td></tr>
<tr><td>3</td><td>Transcrypt</td><td>překlad Pythonu do JavaScriptu (tomuto nástroji se budeme věnovat v&nbsp;dalším článku)</td></tr>
<tr><td>4</td><td>ClojureScript</td><td>překlad aplikací psaných v&nbsp;Clojure do JavaScriptu</td></tr>
<tr><td>5</td><td>Kaffeine</td><td>rozšíření JavaScriptu o nové vlastnosti</td></tr>
<tr><td>6</td><td>RedScript</td><td>jazyk inspirovaný Ruby</td></tr>
<tr><td>7</td><td>GorillaScript</td><td>další rozšíření JavaScriptu</td></tr>
<tr><td>8</td><td>ghcjs</td><td>transpřekladač pro fanoušky programovacího jazyka Haskell</td></tr>
<tr><td>9</td><td>wisp</td><td>zjednodušená a dnes již nevyvíjená varianta ClojureScriptu</td></tr>
<tr><td>10</td><td>Babel</td><td>překlad novějších variant JavaScript (ES2015) a TypeScriptu do zvolené (starší) verze JavaScriptu, stále populární, i přesto, že nové prohlížeče ES2015 podporují</td></tr>
<tr><td>11</td><td>GopherJS</td><td>překladač programů naprogramovaných v&nbsp;jazyce Go do JavaScriptu</td></tr>
<tr><td>12</td><td>Fable</td><td>transpřekladač jazyka F# do JavaScriptu (přes Babel)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: seznam všech (či alespoň většiny)
známých transpřekladačů do JavaScriptu naleznete například na stránce <a
href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>,
i když je nutné varovat, že některé projekty (kromě výše zmíněných) jsou
v&nbsp;dosti špatném stavu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. WebAssembly</h2>

<p>Konečně se dostáváme k&nbsp;technologii <i>WebAssembly</i>. Již <a
href="#01">v&nbsp;úvodní kapitole</a> jsme si řekli, že se v&nbsp;první řadě
jedná o specifikaci virtuálního stroje, především jeho <a
href="https://webassembly.github.io/spec/core/index.html">struktury</a> (je
založen na zásobníku operandů, podobně jako například <a
href="https://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">virtuální
stroj Javy</a>) a taktéž ze specifikace jeho <a
href="https://webassembly.github.io/spec/core/appendix/index-instructions.html#index-instr">instrukčního
souboru</a>. Důležité přitom je, že současně používaná varianta WebAssembly je
skutečně dosti nízkoúrovňová, takže neobsahuje například ani podporu pro
automatickou správu paměti a i specifikace runtime je dosti minimalistická
(například v&nbsp;případě virtuálního stroje Javy &ndash; JVM &ndash; je tomu
jinak). To je ovšem v&nbsp;mnoha ohledech výhoda, protože u jazyků typu C, C++
či Rust není automatická správa paměti relevantní a jejich runtime je malý a
naopak u jazyků typu Go je správce paměti přímo součástí <i>runtime</i>
(zjednodušeně řečeno knihoven, které jsou slinkovány a tvoří výsledný bajtkód
předávaný WebAssembly) a u Rustu je řešen již v&nbsp;čase překladu. Správa
paměti řízená přímo WebAssembly je prozatím ve fázi vývoje a dnes ji nebudeme
potřebovat.</p>

<p>Již v&nbsp;předchozím odstavci jsme se zmínili o problematice
<i>runtime</i>. Virtuální stroj WebAssembly akceptuje soubory s&nbsp;MIME typem
<i>application/wasm</i>, které by měly obsahovat jak vlastní kód aplikace
přeložený do bajtkódu, tak i veškerý podpůrný kód.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nástroj Emscripten se představuje</h2>

<p>Co však mají společného technologie zmíněné <a href="#k03">ve třetí</a> a <a
href="#k04">ve čtvrté</a> kapitole? Obě technologie (kromě jiného) ve větší či
menší míře umožňují resp.&nbsp;usnadňují tvorbu aplikací určených pro běh
v&nbsp;rámci webového prohlížeče, a to napsaného nikoli přímo
v&nbsp;JavaScriptu, ale v&nbsp;prakticky libovolném programovacím jazyku.
Existuje zde jedna podmínka: pro daný jazyk musí existovat buď transpřekladač
do JavaScriptu nebo překladač do bajtkódu kompatibilního s&nbsp;WebAssembly. A
právě na tomto místě se setkáváme s&nbsp;nástrojem s&nbsp;poněkud
nevyslovitelným názvem <i>Emscripten</i>. Tento nástroj umožňuje &ndash; nyní
z&nbsp;pohledu běžného vývojáře &ndash; překlad kódu z&nbsp;libovolného jazyka
podporovaného LLVM (Rust, C, C++, Objective C, D, Ada, Fortran atd.) buď do
JavaScriptu nebo do bajtkódu WebAssembly.</p>

<p>Přitom jsou pro tento účel využívány další nástroje, typicky překladače výše
zmíněných jazyků do <i>LLVM IR</i> (takzvaný <i>intermediate code</i> neboli
<i>mezikód</i>). Příkladem takového překladače je <i>Clang</i> určený pro
programovací jazyky C, C++ a Objective-C. Výsledkem překladu a současně i první
fáze optimalizací je právě mezikód neboli již zmíněný LLVM IR. Tento mezikód se
následně přeloží buď do nativního kódu (což nás dnes nezajímá) nebo přes
<i>Emscripten</i> do JavaScriptu (<a href="http://asmjs.org/">asm.js</a>)
popř.&nbsp;do bajtkódu WebAssembly. Přitom jsou prováděny další optimalizace,
tentokrát již s&nbsp;ohledem na cílovou platformu.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Stručný popis využití celého toolchainu Emscriptenu</h2>

<p>Podívejme se nyní ve stručnosti na základní kroky, které je zapotřebí
provést proto, aby se původní zdrojový kód napsaný například v&nbsp;Céčku, mohl
nějakým způsobem spustit ve webovém prohlížeči:</p>

<ol>
<li>Na vstupu celého procesu je program napsaný v&nbsp;céčku</li>
<li>Nejprve je proveden překlad pomocí <strong>clang</strong> do mezikódu LLVM IR (<i>LLVM Intermediate Representation</i>)</li>
<li>Následně je zavolán <strong>Fastcomp</strong> (což je jádro překladače Emscriptenu) pro překlad mezikódu z&nbsp;předchozího kroku do JavaScriptu</li>
<li>Výsledkem překladu je jak kód v&nbsp;JavaScriptu, tak i kód webové stránky určený pro spuštění tohoto kódu</li>
<li>Výsledný JavaScriptový zdrojový kód je možné využít různými způsoby (node.js na serveru, na WWW stránce atd.)</li>
</ol>

<p><div class="rs-tip-major">Poznámka: poslední překlad (do JavaScriptu)
generuje kód kompatibilní s&nbsp;<i>asm.js</i>, tj.&nbsp;používá se zde cíleně
omezená podmnožina konstrukcí JavaScriptu. Více informací o <i>asm.js</i>
naleznete například na stránkách <a
href="https://developer.mozilla.org/en-US/docs/Games/Tools/asm.js">https://developer.mozilla.org/en-US/docs/Games/Tools/asm.js</a>
a <a href="http://asmjs.org/">http://asmjs.org/</a> (původní verze
specifikace).</div></p>

<p>Překlad do WebAssembly je jen nepatrně odlišný:</p>

<ol>
<li>Na vstupu celého procesu je program napsaný v&nbsp;céčku</li>
<li>Nejprve je proveden překlad pomocí <strong>clang</strong> do mezikódu LLVM IR (<i>LLVM Intermediate Representation</i>)</li>
<li>Následně je zavolán <strong>Fastcomp</strong> (což je jádro překladače Emscriptenu) pro překlad mezikódu z&nbsp;předchozího kroku do bajtkódu WebAssembly</li>
<li>Výsledkem překladu je jak binární soubor .wasm, tak i podpůrný kód v&nbsp;JavaScriptu i kód webové stránky určený pro spuštění nové aplikace</li>
</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Běh grafických aplikací naprogramovaných v&nbsp;céčku a využívajících SDL a SDL2 ve webovém prohlížeči</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podpora SDL i SDL2</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instalace závislostí pro Emscripten (Fedora 36)</h2>

<p>Pro lokální instalaci Emscriptenu je vyžadováno, aby operační systém
obsahoval několik balíčků. Většinou mají vývojáři tyto balíčky již dávno
nainstalovány, ovšem pro úplnost si ukažme instalaci těchto závislostí na
minimální instalaci Fedory 36 (podobné je tomu ovšem například i na Debianu
atd. &ndash; pouze se použije odlišný správce balíčků).</p>

<p>Další kroky byly provedeny na systému:</p>

<pre>
# <strong>cat /etc/redhat-release</strong>
&nbsp;
Fedora release 36 (Thirty Six)
</pre>

<p>Pro některé dále popsané operace je vyžadován nástroj <a
href="https://cmake.org/">CMake</a>:</p>

<pre>
# <strong>dnf install cmake</strong>
&nbsp;
Last metadata expiration check: 0:15:51 ago on Fri 09 Sep 2022 01:58:11 PM EDT.
Dependencies resolved.
================================================================================
 Package              Arch       Version                Repository         Size
================================================================================
Installing:
 cmake                x86_64     3.22.2-1.fc36          beaker-Fedora     6.3 M
Installing dependencies:
 cmake-data           noarch     3.22.2-1.fc36          beaker-Fedora     1.6 M
 cmake-filesystem     x86_64     3.22.2-1.fc36          beaker-Fedora      18 k
 cmake-rpm-macros     noarch     3.22.2-1.fc36          beaker-Fedora      17 k
 jsoncpp              x86_64     1.9.5-2.fc36           beaker-Fedora      98 k
 libuv                x86_64     1:1.44.2-1.fc36        updates           151 k
 rhash                x86_64     1.4.2-2.fc36           beaker-Fedora     185 k
&nbsp;
Transaction Summary
================================================================================
Install  7 Packages
&nbsp;
Total download size: 8.3 M
Installed size: 31 M
Is this ok [y/N]:
</pre>

<p>Dále je vyžadován Git (ale ten pravděpodobně již máte dávno nainstalovaný):</p>

<pre>
# <strong>dnf install git</strong>
&nbsp;
Last metadata expiration check: 0:18:15 ago on Fri 09 Sep 2022 01:58:11 PM EDT.
Dependencies resolved.
================================================================================
 Package              Arch       Version                Repository         Size
================================================================================
Installing:
 git                  x86_64     2.37.3-1.fc36          updates            65 k
Installing dependencies:
 git-core             x86_64     2.37.3-1.fc36          updates           4.0 M
 git-core-doc         noarch     2.37.3-1.fc36          updates           2.4 M
 perl-Error           noarch     1:0.17029-8.fc36       beaker-Fedora      41 k
 perl-File-Find       noarch     1.39-486.fc36          beaker-Fedora      30 k
 perl-Git             noarch     2.37.3-1.fc36          updates            42 k
 perl-TermReadKey     x86_64     2.38-12.fc36           beaker-Fedora      36 k
 perl-lib             x86_64     0.65-486.fc36          beaker-Fedora      20 k
&nbsp;
Transaction Summary
================================================================================
Install  8 Packages
&nbsp;
Total download size: 6.7 M
Installed size: 34 M
Is this ok [y/N]:
</pre>

<p>V&nbsp;průběhu instalace se používá i klasický nástroj <i>tar</i>, který
kupodivu v&nbsp;minimální instalaci Fedory 36 nenajdeme:</p>

<pre>
# <strong>dnf install tar</strong>
&nbsp;
Last metadata expiration check: 0:23:59 ago on Fri 09 Sep 2022 01:58:11 PM EDT.
Dependencies resolved.
================================================================================
 Package     Architecture   Version                 Repository             Size
================================================================================
Installing:
 tar         x86_64         2:1.34-3.fc36           beaker-Fedora         877 k
&nbsp;
Transaction Summary
================================================================================
Install  1 Package
&nbsp;
Total download size: 877 k
Installed size: 3.0 M
Is this ok [y/N]: y
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instalace samotného Emscriptenu</h2>

<p>Další kroky, které si popíšeme v&nbsp;této kapitole, povedou
k&nbsp;instalaci samotného Emscriptenu. Výhodou přitom je, že celá instalace je
&bdquo;lokální&ldquo; v&nbsp;tom ohledu, že nezasahuje do systémových adresářů
a tudíž ani nevyžaduje práva roota. Do určité míry se tak podobá například
<i>virtual environmentu</i> Pythonu.</p>

<p>Nejprve si naklonujeme repositář s&nbsp;podpůrnými skripty Emscriptenu:</p>

<pre>
$ <strong>git clone https://github.com/emscripten-core/emsdk.git</strong>
&nbsp;
Cloning into 'emsdk'...
remote: Enumerating objects: 3390, done.
remote: Counting objects: 100% (6/6), done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 3390 (delta 0), reused 4 (delta 0), pack-reused 3384
Receiving objects: 100% (3390/3390), 1.96 MiB | 9.75 MiB/s, done.
Resolving deltas: 100% (2220/2220), done.
</pre>

<p>Přesuneme se do naklonovaného repositáře:</p>

<pre>
$ <strong>cd emsdk</strong>
</pre>

<p>Provedeme lokální instalaci poslední verze Emscriptenu:</p>

<pre>
$ <strong>./emsdk install latest</strong>
&nbsp;
Resolving SDK alias 'latest' to '3.1.20'
Resolving SDK version '3.1.20' to 'sdk-releases-upstream-d92c8639f406582d70a5dde27855f74ecf602f45-64bit'
Installing SDK 'sdk-releases-upstream-d92c8639f406582d70a5dde27855f74ecf602f45-64bit'..
&nbsp;
Done installing tool 'releases-upstream-d92c8639f406582d70a5dde27855f74ecf602f45-64bit'.
Done installing SDK 'sdk-releases-upstream-d92c8639f406582d70a5dde27855f74ecf602f45-64bit'.
</pre>

<p>A následně tuto verzi aktivujeme:</p>

<pre>
$ <strong>./emsdk activate latest</strong>
&nbsp;
Resolving SDK alias 'latest' to '3.1.20'
Resolving SDK version '3.1.20' to 'sdk-releases-upstream-d92c8639f406582d70a5dde27855f74ecf602f45-64bit'
Setting the following tools as active:
   node-14.18.2-64bit
   releases-upstream-d92c8639f406582d70a5dde27855f74ecf602f45-64bit
&nbsp;
Next steps:
- To conveniently access emsdk tools from the command line,
  consider adding the following directories to your PATH:
    /home/tester/emsdk
    /home/tester/emsdk/node/14.18.2_64bit/bin
    /home/tester/emsdk/upstream/emscripten
- This can be done for the current shell by running:
    source "/home/tester/emsdk/emsdk_env.sh"
- Configure emsdk in your shell startup scripts by running:
    echo 'source "/home/tester/emsdk/emsdk_env.sh"' &gt;&gt; $HOME/.bash_profile
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Testovací příklad určený pro překlad do binární nativní aplikace</h2>

<p></p>

<pre>
#include &lt;SDL2/SDL.h&gt;
&nbsp;
#define TITLE "SDL2 demo #1"
#define WIDTH  256
#define HEIGHT 256
&nbsp;
typedef struct State {
    SDL_Window *window;
    SDL_Surface *screen_surface;
} State;
&nbsp;
static void init_sdl(State * state, const int width, const int height)
{
    state-&gt;window = NULL;
    state-&gt;screen_surface = NULL;
&nbsp;
    <i>/* vlastni inicializace SDL */</i>
    if (SDL_Init(SDL_INIT_VIDEO) &lt; 0) {
        fprintf(stderr, "Error initializing SDL: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_Init ok");
    }
&nbsp;
    <i>/* inicializace okna pro vykreslovani */</i>
    state-&gt;window =
        SDL_CreateWindow(TITLE, SDL_WINDOWPOS_UNDEFINED,
                         SDL_WINDOWPOS_UNDEFINED, width, height,
                         SDL_WINDOW_SHOWN);
&nbsp;
    if (!state-&gt;window) {
        puts("Error creating window");
        puts(SDL_GetError());
        exit(1);
    } else {
        puts("SDL_CreateWindow ok");
    }
&nbsp;
    <i>/* ziskani kreslici plochy okna */</i>
    state-&gt;screen_surface = SDL_GetWindowSurface(state-&gt;window);
&nbsp;
    if (!state-&gt;screen_surface) {
        fprintf(stderr, "Error setting video mode: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_GetWindowSurface ok");
    }
}
&nbsp;
static void show_pixmap(State * state, SDL_Surface * surface)
{
    <i>/* vykresleni pixmapy do plochy okna */</i>
    SDL_BlitSurface(surface, NULL, state-&gt;screen_surface, NULL);
    SDL_UpdateWindowSurface(state-&gt;window);
}
&nbsp;
static void draw_palette(SDL_Surface * surface)
{
    Uint8 *pixel;
    int x, y;
&nbsp;
    if (SDL_MUSTLOCK(surface)) {
        SDL_LockSurface(surface);
    }
&nbsp;
    <i>/* nyni jiz muzeme pristupovat k pixelum pixmapy */</i>
    pixel = (Uint8 *) surface-&gt;pixels;
&nbsp;
    for (y = 0; y &lt; surface-&gt;h; y++) {
        for (x = 0; x &lt; surface-&gt;w; x++) {
            <i>/* nastaveni barvy pixelu, ignorovani pruhlednosti */</i>
            *pixel++ = x;
            *pixel++ = y;
            *pixel++ = 128;
            pixel++;
        }
    }
&nbsp;
    if (SDL_MUSTLOCK(surface))
        SDL_UnlockSurface(surface);
&nbsp;
}
&nbsp;
static void main_event_loop(void)
{
    SDL_Event event;
&nbsp;
    while (1) {
        <i>/*SDL_WaitEvent(&amp;event); */</i>
        while (SDL_PollEvent(&amp;event)) {
            switch (event.type) {
            case SDL_QUIT:
                return;
                break;          <i>/* zbytecne, ale musime uchlacholit linter */</i>
            case SDL_KEYDOWN:
                switch (event.key.keysym.sym) {
                case SDLK_ESCAPE:
                case SDLK_q:
                    return;
                    break;      <i>/* zbytecne, ale musime uchlacholit linter */</i>
                default:
                    break;
                }
                break;
            default:
                break;
            }
        }
    }
}
&nbsp;
static void finalize(State * state, SDL_Surface * pixmap)
{
    <i>/* uvolneni vsech prostredku */</i>
    SDL_FreeSurface(pixmap);
    SDL_FreeSurface(state-&gt;screen_surface);
    SDL_DestroyWindow(state-&gt;window);
}
&nbsp;
static SDL_Surface *create_pixmap(const int width, const int height)
{
    SDL_Surface *pixmap;
    pixmap =
        SDL_CreateRGBSurface(SDL_SWSURFACE, WIDTH, HEIGHT, 32, 0x00ff0000,
                             0x0000ff00, 0x000000ff, 0x00000000);
    if (!pixmap) {
        puts("Can not create pixmap");
        exit(1);
    } else {
        puts("Off screen pixmap created");
    }
    return pixmap;
}
&nbsp;
int main(int argc, char **argv)
{
    State state;
    SDL_Surface *pixmap;
&nbsp;
    <i>/* inicializace SDL, vytvoreni okna a ziskani kreslici plochy okna */</i>
    init_sdl(&amp;state, WIDTH, HEIGHT);
&nbsp;
    <i>/* vytvoreni offscreen pixmapy */</i>
    pixmap = create_pixmap(WIDTH, HEIGHT);
&nbsp;
    <i>/* vykresleni palety */</i>
    draw_palette(pixmap);
&nbsp;
    <i>/* zobrazeni palety */</i>
    show_pixmap(&amp;state, pixmap);
&nbsp;
    <i>/* cekani na stisk klavesy */</i>
    main_event_loop();
&nbsp;
    <i>/* uvolneni prostredku */</i>
    finalize(&amp;state, pixmap);
&nbsp;
    return 0;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úprava příkladu pro Emscripten</h2>

<pre>
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

#include <SDL2/SDL.h>

#define TITLE "SDL2 demo #1"
#define WIDTH  256
#define HEIGHT 256

typedef struct State {
    SDL_Window *window;
    SDL_Surface *screen_surface;
} State;

static void init_sdl(State * state, const int width, const int height)
{
    state-&gt;window = NULL;
    state-&gt;screen_surface = NULL;

    <i>/* vlastni inicializace SDL */</i>
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        fprintf(stderr, "Error initializing SDL: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_Init ok");
    }

    <i>/* inicializace okna pro vykreslovani */</i>
    state-&gt;window =
        SDL_CreateWindow(TITLE, SDL_WINDOWPOS_UNDEFINED,
                         SDL_WINDOWPOS_UNDEFINED, width, height,
                         SDL_WINDOW_SHOWN);

    if (!state-&gt;window) {
        puts("Error creating window");
        puts(SDL_GetError());
        exit(1);
    } else {
        puts("SDL_CreateWindow ok");
    }

    <i>/* ziskani kreslici plochy okna */</i>
    state-&gt;screen_surface = SDL_GetWindowSurface(state-&gt;window);

    if (!state-&gt;screen_surface) {
        fprintf(stderr, "Error setting video mode: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_GetWindowSurface ok");
    }
}

static void show_pixmap(State * state, SDL_Surface * surface)
{
    <i>/* vykresleni pixmapy do plochy okna */</i>
    SDL_BlitSurface(surface, NULL, state-&gt;screen_surface, NULL);
    SDL_UpdateWindowSurface(state-&gt;window);
}

static void draw_palette(SDL_Surface * surface)
{
    Uint8 *pixel;
    int x, y;

    if (SDL_MUSTLOCK(surface)) {
        SDL_LockSurface(surface);
    }

    <i>/* nyni jiz muzeme pristupovat k pixelum pixmapy */</i>
    pixel = (Uint8 *) surface-&gt;pixels;

    for (y = 0; y &lt; surface-&gt;h; y++) {
        for (x = 0; x &lt; surface-&gt;w; x++) {
            <i>/* nastaveni barvy pixelu, ignorovani pruhlednosti */</i>
            *pixel++ = x;
            *pixel++ = y;
            *pixel++ = 128;
            pixel++;
        }
    }

    if (SDL_MUSTLOCK(surface))
        SDL_UnlockSurface(surface);

}

static void main_event_loop(void)
{
    SDL_Event event;

    while (1) {
        <i>/*SDL_WaitEvent(&amp;event); */</i>
        while (SDL_PollEvent(&amp;event)) {
            switch (event.type) {
            case SDL_QUIT:
                return;
                break;          <i>/* zbytecne, ale musime uchlacholit linter */</i>
            case SDL_KEYDOWN:
                switch (event.key.keysym.sym) {
                case SDLK_ESCAPE:
                case SDLK_q:
                    return;
                    break;      <i>/* zbytecne, ale musime uchlacholit linter */</i>
                default:
                    break;
                }
                break;
            default:
                break;
            }
        }
    }
}

static void finalize(State * state, SDL_Surface * pixmap)
{
    <i>/* uvolneni vsech prostredku */</i>
    SDL_FreeSurface(pixmap);
    SDL_FreeSurface(state-&gt;screen_surface);
    SDL_DestroyWindow(state-&gt;window);
}

static SDL_Surface *create_pixmap(const int width, const int height)
{
    SDL_Surface *pixmap;
    pixmap =
        SDL_CreateRGBSurface(SDL_SWSURFACE, WIDTH, HEIGHT, 32, 0x00ff0000,
                             0x0000ff00, 0x000000ff, 0x00000000);
    if (!pixmap) {
        puts("Can not create pixmap");
        exit(1);
    } else {
        puts("Off screen pixmap created");
    }
    return pixmap;
}

int main(int argc, char **argv)
{
    State state;
    SDL_Surface *pixmap;

    <i>/* inicializace SDL, vytvoreni okna a ziskani kreslici plochy okna */</i>
    init_sdl(&amp;state, WIDTH, HEIGHT);

    <i>/* vytvoreni offscreen pixmapy */</i>
    pixmap = create_pixmap(WIDTH, HEIGHT);

    <i>/* vykresleni palety */</i>
    draw_palette(pixmap);

    <i>/* zobrazeni palety */</i>
    show_pixmap(&amp;state, pixmap);

#ifndef __EMSCRIPTEN__
    <i>/* cekani na stisk klavesy */</i>
    main_event_loop();

    <i>/* uvolneni prostredku */</i>
    finalize(&amp;state, pixmap);
#endif

    return 0;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Překlad příkladu do WebAssembly s&nbsp;jeho spuštěním</h2>

<pre>
$ source ./emsdk_env.sh
Setting up EMSDK environment (suppress these messages with EMSDK_QUIET=1)
Adding directories to PATH:
PATH += /home/tester/emsdk
PATH += /home/tester/emsdk/upstream/emscripten
PATH += /home/tester/emsdk/node/14.18.2_64bit/bin

Setting environment variables:
PATH = /home/tester/emsdk:/home/tester/emsdk/upstream/emscripten:/home/tester/emsdk/node/14.18.2_64bit/bin:/home/tester/.local/bin:/home/tester/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin
EMSDK = /home/tester/emsdk
EM_CONFIG = /home/tester/emsdk/.emscripten
EMSDK_NODE = /home/tester/emsdk/node/14.18.2_64bit/bin/node
</pre>


$ emcc -c sdl_test1.c -o sdl_test1.o -s USE_SDL=2
ports:INFO: retrieving port: sdl2 from https://github.com/libsdl-org/SDL/archive/0fcfaf9e9482953ee425cc15b91160b92de3df7f.zip
ports:INFO: unpacking port: sdl2
cache:INFO: generating port: sysroot/lib/wasm32-emscripten/libSDL2.a... (this will be cached in "/home/tester/emsdk/upstream/emscripten/cache/sysroot/lib/wasm32-emscripten/libSDL2.a" for subsequent builds)
cache:INFO:  - ok

$ emcc sdl_test1.o -o sdl_test1.html -s USE_SDL=2

$ python3 -m http.server 9000
Serving HTTP on 0.0.0.0 port 9000 (http://0.0.0.0:9000/) ...
127.0.0.1 - - [09/Sep/2022 20:31:52] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [09/Sep/2022 20:31:52] code 404, message File not found
127.0.0.1 - - [09/Sep/2022 20:31:52] "GET /favicon.ico HTTP/1.1" 404 -
127.0.0.1 - - [09/Sep/2022 20:31:55] "GET /sdl_test1.html HTTP/1.1" 200 -
127.0.0.1 - - [09/Sep/2022 20:31:55] "GET /sdl_test1.js HTTP/1.1" 200 -
127.0.0.1 - - [09/Sep/2022 20:31:55] "GET /sdl_test1.wasm HTTP/1.1" 200 -



<p><a name="k14"></a></p>
<h2 id="k14">14. Překlad příkladu do JavaScriptu (asm.js) s&nbsp;jeho spuštěním</h2>

emcc -c t2.c -o t2.o -s USE_SDL=2
emcc t2.o -o t2.html -s USE_SDL=2 -s WASM=0



<p><a name="k15"></a></p>
<h2 id="k15">15. Příklad s&nbsp;jednoduchou animací: nativní verze</h2>

<pre>
#include <SDL2/SDL.h>
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif
#include <stdlib.h>

#define TITLE "SDL2 demo #2"
#define WIDTH  256
#define HEIGHT 256

typedef struct State {
    SDL_Window *window;
    SDL_Renderer *renderer;
    SDL_Surface *screen_surface;
} State;

static void init_sdl(State * state, const int width, const int height)
{
    state->window = NULL;
    state->screen_surface = NULL;

    <i>/* vlastni inicializace SDL */</i>
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        fprintf(stderr, "Error initializing SDL: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_Init ok");
    }

    <i>/* inicializace okna pro vykreslovani */</i>
    state->window =
        SDL_CreateWindow(TITLE, SDL_WINDOWPOS_UNDEFINED,
                         SDL_WINDOWPOS_UNDEFINED, width, height,
                         SDL_WINDOW_SHOWN);
    if (!state->window) {
        puts("Error creating window");
        puts(SDL_GetError());
        exit(1);
    } else {
        puts("SDL_CreateWindow ok");
    }

    state->renderer =
        SDL_CreateRenderer(state->window, -1, SDL_RENDERER_ACCELERATED);
    if (!state->renderer) {
        puts("Error creating renderer");
        puts(SDL_GetError());
        exit(1);
    } else {
        puts("SDL_CreateRenderer ok");
    }

    <i>/* ziskani kreslici plochy okna */</i>
    state->screen_surface = SDL_GetWindowSurface(state->window);

    if (!state->screen_surface) {
        fprintf(stderr, "Error setting video mode: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_GetWindowSurface ok");
    }
}

void draw_snowcrash(SDL_Surface * surface)
{
    Uint8 *pixel;
    int x, y;

    if (SDL_MUSTLOCK(surface)) {
        SDL_LockSurface(surface);
    }

    <i>/* nyni jiz muzeme pristupovat k pixelum pixmapy */</i>
    pixel = surface->pixels;

    for (y = 0; y < surface->h; y++) {
        for (x = 0; x < surface->w; x++) {
            <i>/* nastaveni barvy pixelu, ignorovani pruhlednosti */</i>
            *pixel++ = rand() % 255;
            *pixel++ = rand() % 255;
            *pixel++ = rand() % 255;
            pixel++;
        }
    }

    if (SDL_MUSTLOCK(surface))
        SDL_UnlockSurface(surface);
}

static void show_pixmap(State * state, SDL_Surface * surface)
{
    <i>/* vykresleni pixmapy do plochy okna */</i>
    SDL_Texture *screenTexture =
        SDL_CreateTextureFromSurface(state->renderer, surface);

    SDL_RenderClear(state->renderer);
    SDL_RenderCopy(state->renderer, screenTexture, NULL, NULL);
    SDL_RenderPresent(state->renderer);

    SDL_DestroyTexture(screenTexture);
}

static SDL_Surface *create_pixmap(const int width, const int height)
{
    SDL_Surface *pixmap;
    pixmap =
        SDL_CreateRGBSurface(SDL_SWSURFACE, WIDTH, HEIGHT, 32, 0x00ff0000,
                             0x0000ff00, 0x000000ff, 0x00000000);
    if (!pixmap) {
        puts("Can not create pixmap");
        exit(1);
    } else {
        puts("Off screen pixmap created");
    }
    return pixmap;
}

static void main_event_loop(State * state, SDL_Surface * pixmap)
{
    SDL_Event event;

    while (1) {
        <i>/*SDL_WaitEvent(&event); */</i>
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
            case SDL_QUIT:
                return;
                break;          <i>/* zbytecne, ale musime uchlacholit linter */</i>
            case SDL_KEYDOWN:
                switch (event.key.keysym.sym) {
                case SDLK_ESCAPE:
                case SDLK_q:
                    return;
                    break;      <i>/* zbytecne, ale musime uchlacholit linter */</i>
                default:
                    break;
                }
                break;
            default:
                break;
            }
        }
        draw_snowcrash(pixmap);
        show_pixmap(state, pixmap);
        SDL_Delay(16);
    }
}

static void finalize(State * state, SDL_Surface * pixmap)
{
    <i>/* uvolneni vsech prostredku */</i>
    SDL_FreeSurface(pixmap);
    SDL_FreeSurface(state->screen_surface);
    SDL_DestroyRenderer(state->renderer);
    SDL_DestroyWindow(state->window);
}

int main(int argc, char *argv[])
{
    State state;
    SDL_Surface *pixmap;

    <i>/* inicializace SDL, vytvoreni okna a ziskani kreslici plochy okna */</i>
    init_sdl(&state, WIDTH, HEIGHT);

    <i>/* vytvoreni offscreen pixmapy */</i>
    pixmap = create_pixmap(WIDTH, HEIGHT);

#ifdef __EMSCRIPTEN__
    emscripten_set_main_loop(drawRandomPixels, 0, 1);
#else
    main_event_loop(&state, pixmap);
#endif

    finalize(&state, pixmap);

    return 0;
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Příklad s&nbsp;jednoduchou animací: úprava pro Emscripten</h2>

<pre>
#include <SDL2/SDL.h>
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif
#include <stdlib.h>

#define TITLE "SDL2 demo #2"
#define WIDTH  256
#define HEIGHT 256

typedef struct State {
    SDL_Window *window;
    SDL_Renderer *renderer;
    SDL_Surface *screen_surface;
} State;

State state;

SDL_Surface *pixmap;

static void init_sdl(State * state, const int width, const int height)
{
    state->window = NULL;
    state->screen_surface = NULL;

    <i>/* vlastni inicializace SDL */</i>
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        fprintf(stderr, "Error initializing SDL: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_Init ok");
    }

    <i>/* inicializace okna pro vykreslovani */</i>
    state->window =
        SDL_CreateWindow(TITLE, SDL_WINDOWPOS_UNDEFINED,
                         SDL_WINDOWPOS_UNDEFINED, width, height,
                         SDL_WINDOW_SHOWN);
    if (!state->window) {
        puts("Error creating window");
        puts(SDL_GetError());
        exit(1);
    } else {
        puts("SDL_CreateWindow ok");
    }

    state->renderer =
        SDL_CreateRenderer(state->window, -1, SDL_RENDERER_ACCELERATED);
    if (!state->renderer) {
        puts("Error creating renderer");
        puts(SDL_GetError());
        exit(1);
    } else {
        puts("SDL_CreateRenderer ok");
    }

    <i>/* ziskani kreslici plochy okna */</i>
    state->screen_surface = SDL_GetWindowSurface(state->window);

    if (!state->screen_surface) {
        fprintf(stderr, "Error setting video mode: %s\n", SDL_GetError());
        exit(1);
    } else {
        puts("SDL_GetWindowSurface ok");
    }
}

void draw_snowcrash(SDL_Surface * surface)
{
    Uint8 *pixel;
    int x, y;

    if (SDL_MUSTLOCK(surface)) {
        SDL_LockSurface(surface);
    }

    <i>/* nyni jiz muzeme pristupovat k pixelum pixmapy */</i>
    pixel = surface->pixels;

    for (y = 0; y < surface->h; y++) {
        for (x = 0; x < surface->w; x++) {
            <i>/* nastaveni barvy pixelu, ignorovani pruhlednosti */</i>
            *pixel++ = rand() % 255;
            *pixel++ = rand() % 255;
            *pixel++ = rand() % 255;
            pixel++;
        }
    }

    if (SDL_MUSTLOCK(surface))
        SDL_UnlockSurface(surface);
}

static void show_pixmap(State * state, SDL_Surface * surface)
{
    <i>/* vykresleni pixmapy do plochy okna */</i>
    SDL_Texture *screenTexture =
        SDL_CreateTextureFromSurface(state->renderer, surface);

    SDL_RenderClear(state->renderer);
    SDL_RenderCopy(state->renderer, screenTexture, NULL, NULL);
    SDL_RenderPresent(state->renderer);

    SDL_DestroyTexture(screenTexture);
}

void draw_and_show_snowcrash()
{
    draw_snowcrash(pixmap);
    show_pixmap(&state, pixmap);
}

static SDL_Surface *create_pixmap(const int width, const int height)
{
    SDL_Surface *pixmap;
    pixmap =
        SDL_CreateRGBSurface(SDL_SWSURFACE, WIDTH, HEIGHT, 32, 0x00ff0000,
                             0x0000ff00, 0x000000ff, 0x00000000);
    if (!pixmap) {
        puts("Can not create pixmap");
        exit(1);
    } else {
        puts("Off screen pixmap created");
    }
    return pixmap;
}

static void main_event_loop(State * state, SDL_Surface * pixmap)
{
    SDL_Event event;

    while (1) {
        <i>/*SDL_WaitEvent(&event); */</i>
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
            case SDL_QUIT:
                return;
                break;          <i>/* zbytecne, ale musime uchlacholit linter */</i>
            case SDL_KEYDOWN:
                switch (event.key.keysym.sym) {
                case SDLK_ESCAPE:
                case SDLK_q:
                    return;
                    break;      <i>/* zbytecne, ale musime uchlacholit linter */</i>
                default:
                    break;
                }
                break;
            default:
                break;
            }
        }
        draw_snowcrash(pixmap);
        show_pixmap(state, pixmap);
        SDL_Delay(16);
    }
}

static void finalize(State * state, SDL_Surface * pixmap)
{
    <i>/* uvolneni vsech prostredku */</i>
    SDL_FreeSurface(pixmap);
    SDL_FreeSurface(state->screen_surface);
    SDL_DestroyRenderer(state->renderer);
    SDL_DestroyWindow(state->window);
}

int main(int argc, char *argv[])
{
    <i>/* inicializace SDL, vytvoreni okna a ziskani kreslici plochy okna */</i>
    init_sdl(&state, WIDTH, HEIGHT);

    <i>/* vytvoreni offscreen pixmapy */</i>
    pixmap = create_pixmap(WIDTH, HEIGHT);

#ifdef __EMSCRIPTEN__
    emscripten_set_main_loop(draw_and_show_snowcrash, 0, 1);
#else
    main_event_loop(&state, pixmap);
#endif

    finalize(&state, pixmap);

    return 0;
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
jak s&nbsp;využitím běžného překladače (gcc, clang), tak i pomocí Emscriptenu,
byly uložen do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již velmi rozsáhlý) repositář:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>sdl_demo_1A.c</td><td>vykreslení barvové palety</td><td><a href="https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/sdl_demo_1A.c">https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/sdl_demo_1A.c</a></td></tr>
<tr><td>2</td><td>sdl_demo_1B.c</td><td>úprava předchozího příkladu pro Emscripten</td><td><a href="https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/sdl_demo_1B.c">https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/sdl_demo_1B.c</a></td></tr>
<tr><td>3</td><td>sdl_demo_2A.c</td><td>vykreslení TV šumu</td><td><a href="https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/sdl_demo_2A.c">https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/sdl_demo_2A.c</a></td></tr>
<tr><td>4</td><td>sdl_demo_2B.c</td><td>úprava předchozího příkladu pro Emscripten</td><td><a href="https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/sdl_demo_2B.c">https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/sdl_demo_2B.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>Makefile</td><td>soubor pro překlad demonstračních příkladů</td><a href="https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/Makefile.c">https://github.com/tisnik/presentations/blob/master/WebAssembly_SDL/Makefile</a></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Stránka projektu Emscripten<br />
<a href="https://emscripten.org/">https://emscripten.org/</a>
</li>

<li>Emscripten (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emscripten">https://en.wikipedia.org/wiki/Emscripten</a>
</li>

<li>Building to WebAssembly<br />
<a href="https://emscripten.ru/docs/compiling/WebAssembly.html">https://emscripten.ru/docs/compiling/WebAssembly.html</a>
</li>

<li>Emscripten and WebAssembly<br />
<a href="https://kripken.github.io/talks/wasm.html#/">https://kripken.github.io/talks/wasm.html#/</a>
</li>

<li>Compiling to WebAssembly: It’s Happening!<br />
<a href="https://hacks.mozilla.org/2015/12/compiling-to-webassembly-its-happening/">https://hacks.mozilla.org/2015/12/compiling-to-webassembly-its-happening/</a>
</li>

<li>WebAssembly<br />
<a href="https://webassembly.org/">https://webassembly.org/</a>
</li>

<li>Blogy o WASM a Emscripten<br />
<a href="https://www.jamesfmackenzie.com/sitemap/#emscripten">https://www.jamesfmackenzie.com/sitemap/#emscripten</a>
</li>

<li>wat2wasm demo<br />
<a href="https://webassembly.github.io/wabt/demo/wat2wasm/">https://webassembly.github.io/wabt/demo/wat2wasm/</a>
</li>

<li>WABT: The WebAssembly Binary Toolkit<br />
<a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a>
</li>

<li>Programming using Web Assembly<br />
<a href="https://medium.com/@alexc73/programming-using-web-assembly-c4c73a4e09a9">https://medium.com/@alexc73/programming-using-web-assembly-c4c73a4e09a9</a>
</li>

<li>Experiments with image manipulation in WASM using Go<br />
<a href="https://agniva.me/wasm/2018/06/18/shimmer-wasm.html">https://agniva.me/wasm/2018/06/18/shimmer-wasm.html</a>
</li>

<li>WebAssembly Lesson 2: Graphics with SDL<br />
<a href="https://www.jamesfmackenzie.com/2019/12/01/webassembly-graphics-with-sdl/">https://www.jamesfmackenzie.com/2019/12/01/webassembly-graphics-with-sdl/</a>
</li>

<li>Image transformation in wasm using Go<br />
<a href="https://github.com/agnivade/shimmer">https://github.com/agnivade/shimmer</a>
</li>

<li>Hexy (demo)<br />
<a href="https://stdiopt.github.io/gowasm-experiments/hexy/">https://stdiopt.github.io/gowasm-experiments/hexy/</a>
</li>

<li>Bumpu<br />
<a href="https://stdiopt.github.io/gowasm-experiments/bumpy/">https://stdiopt.github.io/gowasm-experiments/bumpy/</a>
</li>

<li>HTML canvas createImageData() Method<br />
<a href="https://www.w3schools.com/Tags/canvas_createimagedata.asp">https://www.w3schools.com/Tags/canvas_createimagedata.asp</a>
</li>

<li>HTML canvas putImageData() Method<br />
<a href="https://www.w3schools.com/Tags/canvas_putimagedata.asp">https://www.w3schools.com/Tags/canvas_putimagedata.asp</a>
</li>

<li>HTML canvas getImageData() Method<br />
<a href="https://www.w3schools.com/Tags/canvas_getimagedata.asp">https://www.w3schools.com/Tags/canvas_getimagedata.asp</a>
</li>

<li>Fable<br />
<a href="https://fable.io/">https://fable.io/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

