<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG (okomentované demonstrační příklady)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG (okomentované demonstrační příklady)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Osmá část seriálu o grafické knihovně OpenVG přímo navazuje na obě části předchozí, v&nbsp;nichž jsme se seznámili se všemi funkcemi určenými pro operace s&nbsp;různými typy rastrových obrázků. Dnes budou tyto operace použity v&nbsp;šestici demonstračních příkladů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG (okomentované demonstrační příklady)</a></p>
<p><a href="#k02">2. Funkce <strong>vgCreateImage</strong>, <strong>vgDestroyImage</strong> a <strong>vgClearImage</strong></a></p>
<p><a href="#k03">3. Vykreslení obrázku funkcí <strong>vgDrawImage</strong></a></p>
<p><a href="#k04">4. Demonstrační příklad číslo 15: vytvoření, vybarvení a smazání rastrového obrázku</a></p>
<p><a href="#k05">5. Použití funkce <strong>vgImageSubData</strong> pro přenos pixelů do obrázku</a></p>
<p><a href="#k06">6. Demonstrační příklad číslo 16: nakreslení vzorku do rastrového obrázku</a></p>
<p><a href="#k07">7. Přímé vykreslení rastrového obrázku funkcí <strong>vgWritePixels</strong></a></p>
<p><a href="#k08">8. Demonstrační příklad číslo 17: použití funkce <strong>vgWritePixels</strong></a></p>
<p><a href="#k09">9. Vytvoření screenshotu obrazovky funkcí <strong>vgReadPixels</strong></a></p>
<p><a href="#k10">10. Rastrový formát TGA</a></p>
<p><a href="#k11">11. Rastrový formát BMP</a></p>
<p><a href="#k12">12. Demonstrační příklad číslo 18: uložení screenshotu do rastrového formátu typu TGA (32bpp)</a></p>
<p><a href="#k13">13. Demonstrační příklad číslo 19: použití formátu typu TGA s&nbsp;24bpp</a></p>
<p><a href="#k14">14. Demonstrační příklad číslo 20: použití formátu typu BMP (BitMap)</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG (okomentované demonstrační příklady)</h2>

<p>Všechny funkce, které jsou nabízené knihovnou <i>OpenVG</i> pro provádění
operací s&nbsp;rastrovými obrázky, jsme si podrobně popsali v&nbsp;předchozích
dvou částech tohoto seriálu [<a
href="http://www.root.cz/clanky/prace-s-rastrovymi-obrazky-v-knihovne-openvg/">1</a>]
[<a
href="http://www.root.cz/clanky/prace-s-nbsp-rastrovymi-obrazky-v-nbsp-knihovne-openvg-pokracovani/">2</a>],
ovšem prozatím jsme si neukázali žádné praktické použití těchto funkcí. Proto
si dnes na šesti demonstračních příkladech předvedeme, jakým způsobem je možné
použít funkce <strong>vgCreateImage()</strong>,
<strong>vgDestroyImage()</strong>, <strong>vgClearImage()</strong>,
<strong>vgDrawImage()</strong>, <strong>vgImageSubData()</strong>,
<strong>vgWritePixels()</strong> a taktéž <strong>vgReadPixels()</strong>.
Poslední příklady obsahují funkce pro vytvoření screenshotu obrazovky, což je
operace, která se může v&nbsp;mnoha případech hodit, zejména tehdy, pokud je
vykreslování prováděno ve <i>fullscreen</i> režimu a není tedy možné využít
další nástroje.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Funkce <strong>vgCreateImage</strong>, <strong>vgDestroyImage</strong> a <strong>vgClearImage</strong></h2>

<p>Základní funkcí, kterou použijeme pro vytvoření nového obrázku, je funkce
nazvaná <strong>vgCreateImage()</strong>, která  má následující hlavičku:</p>

<pre>
VGImage <strong>vgCreateImage</strong>(
    VGImageFormat format,
    VGint         width,
    VGint         height,
    VGbitfield    allowedQuality);
</pre>

<p>Této funkci se předá symbolická konstanta popisující formát uložení pixelů a
způsob kódování barvy, dále pak rozměry obrázku (šířka a výška v&nbsp;pixelech)
a posledním parametrem se ovlivňují ty operace, při nichž dochází k&nbsp;rotaci
či ke změně měřítka bitmapy (tyto operace dnes nebudeme používat). Pokud je
zaručeno mapování pixelů na obrazovku 1:1, nemá tento parametr žádný vliv.</p>

<p>Pro odstranění obrázku z&nbsp;paměti GPU se používá funkce nazvaná
<strong>vgDestroyImage()</strong>:</p>

<pre>
void <strong>vgDestroyImage</strong>(
    VGImage       image);
</pre>

<p>Ovšem ve chvíli, kdy je obrázek používán jiným objektem (cíl pro
vykreslování, obrázek použitý pro vyplnění uzavřených cest atd.), dojde
k&nbsp;jeho skutečnému uvolnění až ve chvíli, kdy jsou uvolněny i na obrázek
navázané objekty (interně se tedy pro každý obrázek pamatuje příznak
&bdquo;může být automaticky odstraněn&ldquo;). Ani tento problém nebudeme muset
v&nbsp;demonstračních příkladech řešit a tudíž tato funkce uvolní obrázek
okamžitě.</p>

<p>Smazání či přesněji řečeno vybarvení zvolené obdélníkové části obrázku
zajistí funkce nazvaná <strong>vgClearImage()</strong>:</p>

<pre>
void <strong>vgClearImage</strong>(
    VGImage       image,
    VGint         x,
    VGint         y,
    VGint         width,
    VGint         height)
</pre>

<p>Tato funkce použije barvu nastavenou parametrem
<strong>VG_CLEAR_COLOR</strong> a region, který se má vymazat, je specifikován
osově orientovaným obdélníkem začínajícím na souřadnicích [x,y], jehož strany
mají délku width a height. Vymazání je samozřejmě rychlejší, než přenos
(konstantních) pixelů.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vykreslení obrázku funkcí <strong>vgDrawImage</strong></h2>

<p>Ve chvíli, kdy je zapotřebí vykreslit obrázek na zvolenou kreslicí plochu
(<i>surface</i>), zavolá se funkce nazvaná <strong>vgDrawImage()</strong>.
Hlavička této funkce je skutečně velmi jednoduchá:</p>

<pre>
void <strong>vgDrawImage</strong>(
    VGImage       image);
</pre>

<p>Chování této funkce je do jisté míry podobné nám již známé funkci
<strong>vgDrawPath()</strong> &ndash; ani zde se totiž nespecifikuje cíl
vykreslování ani umístění obrázku na plochu. Obrázek může být vykreslen třemi
způsoby: jako skutečný obrázek (jedná se tedy o operaci typu <i>BitBLT</i>),
zapisované barvy pixelů se mohou násobit s&nbsp;nastavenou barvou (takto lze
vykreslit poloprůhledný obrázek atd.) a dokonce je možné obrázek (pixely)
použít jako masku (<i>stencil</i>) při vykreslování cest.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstrační příklad číslo 15: vytvoření, vybarvení a smazání rastrového obrázku</h2>

<p>V&nbsp;prvním demonstračním příkladu si ukážeme všechny čtyři výše zmíněné
funkce nabízené knihovnou <i>OpenVG</i>. Úplný zdrojový kód tohoto příkladu lze
nalézt na adrese <a
href="https://github.com/tisnik/presentations/tree/master/openvg/example15">https://github.com/tisnik/presentations/tree/master/openvg/example15</a>,
takže zde uvedu pouze ty nejzajímavější části.</p>

<p>Nejprve si ukažme použití funkcí <strong>vgCreateImage()</strong> a
<strong>vgClearImage()</strong>. Ve funkci <strong>vgCreateImage()</strong>
požadujeme formát uložení pixelů RGB (truecolor) bez alfa kanálu, takže se
v&nbsp;prvním parametru této funkci předá symbolická konstanta
<strong>VG_sRGBX_8888</strong>. Dále si povšimněte, že funkce
<strong>vgClearImage()</strong> by se klidně mohla jmenovat
<strong>vgFillRect()</strong> (narážka na <strong>SDL_FillRect</strong>),
protože ji můžeme použít pro obarvení libovolné osově orientované obdélníkové
části obrázku:</p>

<pre>
<i>/*</i>
<i> * Vytvoreni testovaci bitmapy.</i>
<i> */</i>
VGImage createImage(width, height)
{
    <i>/* pouzije se RGB format bez alfa kanalu */</i>
    VGImage image = <strong>vgCreateImage(VG_sRGBX_8888, width, height, VG_IMAGE_QUALITY_BETTER);</strong>
&nbsp;
    <i>/* prvni barva */</i>
    VGfloat color1[4] = {1.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
&nbsp;
    <i>/* obdelnik ci ctverec vykresleny prvni barvou */</i>
    <strong>vgClearImage(image, 0, 0, width&gt;&gt;1, height&gt;&gt;1);</strong>
&nbsp;
    <i>/* druha barva */</i>
    VGfloat color2[4] = {0.0f, 0.0f, 1.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color2);
&nbsp;
    <i>/* obdelnik ci ctverec vykresleny druhou barvou */</i>
    <strong>vgClearImage(image, width&gt;&gt;1, height&gt;&gt;1, width&gt;&gt;1, height&gt;&gt;1);</strong>
&nbsp;
    <i>/* treti barva */</i>
    VGfloat color3[4] = {1.0f, 1.0f, 1.0f, 0.5f};
    vgSetfv(VG_CLEAR_COLOR, 4, color3);
&nbsp;
    <i>/* obdelnik ci ctverec vykresleny treti barvou */</i>
    <strong>vgClearImage(image, width&gt;&gt;2, height&gt;&gt;2, width&gt;&gt;1, height&gt;&gt;1);</strong>
&nbsp;
    return image;
}
</pre>

<p>Při vykreslení obrázku se použije funkce <strong>vgDrawImage()</strong>.
Případný přesun obrázku na jiné místo na obrazovce je provedeno přes
transformační matici, což je téma dalšího pokračování tohoto seriálu:</p>

<pre>
<i>/*</i>
<i> * Vykresleni cele sceny.</i>
<i> */</i>
void draw(EGL_STATE_T *state, VGImage image)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* vykresleni rastroveho obrazku */</i>
    <strong>vgDrawImage(image);</strong>
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
</pre>

<p>Na samotném konci aplikace je nutné uvolnit obrázek z&nbsp;paměti GPU, což
je v&nbsp;našem demonstračním příkladu implementováno ve funkci
<strong>main()</strong>:</p>

<pre>
    ...
    ...
    ...
    <i>/* uvolneni rastroveho obrazku z pameti */</i>
    <strong>vgDestroyImage(image);</strong>
&nbsp;
    finalize_egl(&amp;egl_state);
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití funkce <strong>vgImageSubData</strong> pro přenos pixelů do obrázku</h2>

<p>Velmi často potřebujeme provést přenos pixelů z&nbsp;operační paměti do
vybraného rastrového obrázku. Pro tento účel se používá funkce pojmenovaná
<strong>vgImageSubData()</strong> s&nbsp;následující hlavičkou:</p>

<pre>
void <strong>vgImageSubData</strong>(
     VGImage       image,
     const void   *data,
     VGint         dataStride,
     VGImageFormat dataFormat,
     VGint         x,
     VGint         y,
     VGint         width,
     VGint         height);
</pre>

<p>Ve skutečnosti se při přenosu pixelů mohou provádět i transformace pixelů
mezi různými reprezentacemi (formát uložení a barvový model). Knihovna OpenVG
totiž ví, jaký je formát již vytvořeného obrázku a ve funkci
<strong>vgImageSubData</strong> se specifikuje formát zapisovaných pixelů,
takže všechny údaje nutné pro konverzi jsou k&nbsp;dispozici. Dalším důležitým
parametrem je parametr <strong>dataStride</strong>, kterým lze specifikovat
mezery mezi jednotlivými obrazovými řádky (<i>stride</i>).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstrační příklad číslo 16: nakreslení vzorku do rastrového obrázku</h2>

<p>V&nbsp;dalším demonstračním příkladu, jehož úplný zdrojový kód i příslušný
soubor Makefile určený pro řízení překladu naleznete na stránce <a
href="https://github.com/tisnik/presentations/tree/master/openvg/example16">https://github.com/tisnik/presentations/tree/master/openvg/example16</a>,
je ve funkci <strong>createImage()</strong> nejprve vytvořen obrázek o
rozměrech <i>width&times;height</i> s&nbsp;formátem pixelů RGB bez alfa kanálu.
Následně je v&nbsp;běžné operační paměti vytvořeno pole 256&times;256&times;4
bajty představující zdrojové hodnoty pixelů. Do tohoto pole se zapíšou barvy
pixelů (dodržuje se formát RGB) a posléze se celé pole přenese do již
připraveného obrázku funkcí <strong>vgImageSubData()</strong>:</p>

<pre>
<i>/*</i>
<i> * Vytvoreni testovaci bitmapy.</i>
<i> */</i>
VGImage createImage(width, height)
{
    <i>/* pouzije se RGB format bez alfa kanalu */</i>
    VGImage image = <strong>vgCreateImage(VG_sRGBX_8888, width, height, VG_IMAGE_QUALITY_BETTER);</strong>
&nbsp;
    <i>/* oblast pameti pro ulozeni pixelu rastroveho obrazku */</i>
    unsigned char *data = (unsigned char*)malloc(256*256*4);
    unsigned int x, y;
    unsigned char *p=data;
&nbsp;
    <i>/* vykresleni vzorku */</i>
    for (y=0; y&lt;256; y++) {
        for (x=0; x&lt;256; x++) {
            *p++=0x00; <i>/* alfa (ignorovano) */</i>
            *p++=x;    <i>/* blue */</i>
            *p++=x+y;  <i>/* green */</i>
            *p++=y;    <i>/* red */</i>
        }
    }
&nbsp;
    <i>/* prenos barev pixelu do rastroveho obrazku */</i>
    <strong>vgImageSubData(image, data, 256*4, VG_sRGBA_8888, 0, 0, 256, 256);</strong>
&nbsp;
    <i>/* oblast pameti muzeme uvolnit - jiz ji nepotrebujeme */</i>
    free(data);
&nbsp;
    return image;
}
</pre>

<p>Poznámka &ndash; povšimněte si nastavení parametru <i>dataStride</i> na
hodnotu 256&times;4, což je délka obrazového řádku v&nbsp;bajtech. Pokud toto
číslo změníte, bude výsledkem různě nakloněný vzorek.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přímé vykreslení rastrového obrázku funkcí <strong>vgWritePixels</strong></h2>

<p>Pokud má programátor v&nbsp;operační paměti již přichystané pole
s&nbsp;uloženými hodnotami (barvami) pixelů ve vhodném formátu, není nutné se
snažit o vytvoření obrázku funkcí <strong>vgCreateImage()</strong> a následně
do tohoto obrázku pixely přenést funkcí <strong>vgImageSubData()</strong>. Tuto
možnost jsme si již ukázali, ale existuje i přímější cesta představovaná funkcí
nazvanou <strong>vgWritePixels()</strong>:</p>

<pre>
void <strong>vgWritePixels</strong>(
     const void    *data,
     VGint         dataStride,
     VGImageFormat dataFormat,
     VGint         dx,
     VGint         dy,
     VGint         width,
     VGint         height);
</pre>

<p>Této mnohdy velmi užitečné funkci se musí předat ukazatel na datovou oblast
v&nbsp;operační paměti a formát uložení pixelů. Dalším důležitým parametrem je
parametr <strong>dataStride</strong>, kterým lze specifikovat mezery mezi
jednotlivými obrazovými řádky (<i>stride</i>). Kromě toho se specifikuje i
velikost a umístění obdélníkové oblasti kreslicí plochy, do níž se bude obrázek
přenášet. To znamená, že můžeme přímo určit, kam se má obdélníkové pole pixelů
vykreslit.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstrační příklad číslo 17: použití funkce <strong>vgWritePixels</strong></h2>

<p>Postup při použití výše zmíněné funkce <strong>vgWritePixels()</strong> je
ukázán <a
href="https://github.com/tisnik/presentations/tree/master/openvg/example17">v&nbsp;dalším
demonstračním příkladu</a>. Všechny důležité prvky jsou součástí jediné funkce
<strong>draw()</strong>, v&nbsp;níž se nejprve smaže zadní buffer funkcí
<strong>vgClear()</strong>, vytvoří a naplní se pole v&nbsp;operační paměti
(formát RGBA) a posléze se toto pole přenese do zadního bufferu funkcí
<strong>vgWritePixels()</strong>. Povšimněte si, že bitmapa se ve skutečnosti
vykreslí celkem třikrát &ndash; dvakrát v&nbsp;originální velikosti a jednou
s&nbsp;poloviční výškou. Toho je dosaženo malým trikem &ndash; výška je snížena
na 128 obrazových řádků z&nbsp;256 původních řádků a vzdálenost mezi řádky je
nastavena na hodnotu odpovídající offsetu mezi dvojicí řádků &ndash; vždy jeden
obrazový řádek je tedy při vykreslování přeskočen:</p>

<pre>
<i>/*</i>
<i> * Vykresleni cele sceny.</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* oblast pameti pro ulozeni pixelu rastroveho obrazku */</i>
    unsigned char *data = (unsigned char*)malloc(256*256*4);
    unsigned int   x, y;
    unsigned char *p=data;
&nbsp;
    <i>/* vykresleni vzorku */</i>
    for (y=0; y&lt;256; y++) {
        for (x=0; x&lt;256; x++) {
            *p++=0x00; <i>/* alfa (ignorovano) */</i>
            *p++=x;    <i>/* blue */</i>
            *p++=x+y;  <i>/* green */</i>
            *p++=y;    <i>/* red */</i>
        }
    }
&nbsp;
    <i>/* prime vykresleni rastroveho obrazku */</i>
    <strong>vgWritePixels(data, 256*4, VG_sRGBA_8888, 0, 0, 256, 256);</strong>
&nbsp;
    <i>/* vykresleni stejneho obrazku, ale o 300 pixelu napravo */</i>
    <strong>vgWritePixels(data, 256*4, VG_sRGBA_8888, 300, 0, 256, 256);</strong>
&nbsp;
    <i>/* vykresleni obrazku polovicni vysky, ale o 300 pixelu vyse */</i>
    <i>/* - zmena "stride" */</i>
    <i>/* - zmena vysky */</i>
    <strong>vgWritePixels(data, 256*4*2, VG_sRGBA_8888, 0, 300, 256, 128);</strong>
&nbsp;
    <i>/* oblast pameti muzeme uvolnit - jiz ji nepotrebujeme */</i>
    free(data);
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vytvoření screenshotu obrazovky funkcí <strong>vgReadPixels</strong></h2>

<p>Při vytváření screenshotů či při provádění podobných operací se může hodit
funkce nazvaná <strong>vgReadPixels()</strong>, která dokáže získat obsah části
kreslicí plochy (či samozřejmě celou plochu, pokud je tak specifikováno) a
uložit ji do již alokovaného regionu operační paměti. Tato funkce je opakem
funkce <strong>vgWritePixels()</strong>, takže nás její parametry s&nbsp;velkou
pravděpodobností nepřekvapí:</p>

<pre>
void <strong>vgReadPixels</strong>(
     void         *data,
     VGint         dataStride,
     VGImageFormat dataFormat,
     VGint         sx,
     VGint         sy,
     VGint         width,
     VGint         height);
</pre>

<p>Velmi důležité je, aby byla oblast pro zápis pixelů již dopředu alokováno
v&nbsp;potřebné velikosti, jinak s&nbsp;velkou pravděpodobností dojde
k&nbsp;pádu aplikace.</p>

<p>A právě tuto funkci použijeme v&nbsp;příkladech, v&nbsp;nichž se vytváří
screenshoty obrazovky. Tyto příklady vlastně provedou pouze dvě operace:</p>

<ol>
<li>Přenos pixelů z&nbsp;obrazovky (bufferu) do operační paměti.</li>
<li>Uložení pixelů do vhodného obrazového formátu.</li>
</ol>

<p>Pro druhý krok je možné využít již existující knihovny, kterým se pouze
předá vhodně dekódovaný obsah framebufferu, což je typický příklad aplikací
v&nbsp;nichž se má framebuffer ukládat například do formátů GIF, JPEG či PNG
(protože asi nemá smysl si psát vlastní komprimační rutiny, i když by to bylo
z&nbsp;hlediska sebevzdělávání zajímavé). Alternativně lze použít jednodušší
formáty (bez komprese), do nichž se budou obrazová data zapisovat
v&nbsp;programové smyčce. Touto oblastí jsme se již zabývali při popisu <a
href="http://www.root.cz/clanky/operace-s-framebufferem-na-raspberry-pi-dokonceni/#k03">framebufferu
Raspberry Pi</a>, kde jsme použili formáty PGM, PPM či PMA, dnes budou použity
přece jen poněkud známější formáty <i>TGA (Targa)</i> a <i>BMP
(BitMaP)</i>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Rastrový formát TGA</h2>

<p>Grafický formát <i>Targa</i> (zkráceně <strong>TGA</strong>) byl již
v&nbsp;poměrně dávné počítačové minulosti navržen firmou <i>Truevision</i>,
která několik variant tohoto formátu využívala pro ukládání snímků získávaných
pomocí svých video grabberů nazvaných <i>Targa</i>. Video grabber je,
zjednodušeně řečeno, zařízení pro zachytávání a digitalizaci videa
v&nbsp;reálném čase (tehdy s&nbsp;podporou specializovaného hardwaru), podobnou
funkci nabízí dnešní televizní karty (TV-card). Grabberů typu <i>Targa</i>
existovalo několik typů a pro každý typ byla vytvořena varianta vlastní
grafického formátu TGA (lišily se především v&nbsp;počtu bitů na pixel).</p>

<p>Později, zejména se stále rostoucí oblibou formátu TGA mezi programátory i
uživateli, došlo k&nbsp;dalšímu rozšíření variant způsobů ukládání pixelů a
současně i k&nbsp;unifikaci, přičemž výsledkem je dnešní stav, kdy je možné
formát TGA použít jak pro rastrové obrázky s&nbsp;barvovou paletou
(<i>palette-based images</i>), tak i pro obrázky uložené ve stupních šedi
(<i>grayscale</i>) či obrázky typu true color (2<sup>24</sup> barev).
Podporován je i plnohodnotný osmibitový alfa kanál, pro některé aplikace si
však vystačíme s&nbsp;jednobitovým alfa kanálem, resp.&nbsp;maskou
průhlednosti.</p>

<p>Díky své jednoduchosti a širokým možnostem se grafický formát
<strong>TGA</strong> značně rozšířil a byl použit v&nbsp;mnoha aplikacích,
zejména těch, které musely pracovat s&nbsp;plnobarevnými obrázky.
V&nbsp;minulosti, zejména v&nbsp;době operačního systému DOS na počítačích typu
PC, se jednalo například o raytracery, ale i některé skenovací programy.
Zajímavé je, že v&nbsp;různých aplikačních oblastech se prosadily i rozdílné
grafické formáty &ndash; fotorealistická grafika byla většinou založena na TGA,
desktop publishing se stále ještě v&nbsp;některých případech drží
supersložitého formátu (resp.&nbsp;spíše pouhého kontejneru) TIFF, pro web se
(logicky) používají formáty s&nbsp;dobrým komprimačním poměrem (PNG), ztrátovou
kompresí (JPEG) či alespoň základní podporou pro animace (GIF).</p>

<p>Všechny informace jsou v&nbsp;souborech typu TGA rozděleny do čtyř sekcí,
přičemž pouze první sekce je povinná, ostatní sekce mohou či nemusí být
použity. Sekce jsou do značné míry podobné blokům v&nbsp;grafickém formátu GIF
či chunkům ve formátu PNG, ovšem s&nbsp;tím rozdílem, že nemusí obsahovat
identifikační hlavičku &ndash; pozice sekcí v&nbsp;souboru je možné zjistit již
po načtení informační hlavičky souboru. Význam jednotlivých sekcí je
následující:</p>

<ol>

<li>V&nbsp;první sekci umístěné na začátku souboru je uložena
<strong>informační hlavička</strong>, jejíž velikost je vždy rovna 18 bytům.
V&nbsp;hlavičce jsou uloženy základní informace o obraze, zejména jeho
rozlišení, způsob kódování barev pixelů a orientace obrázku.</li>

<li>Za informační hlavičkou může následovat <strong>identifikační pole
obrázku</strong>, což je textový řetězec o maximální délce 255 znaků. Tato
sekce je však nepovinná a málokdy se s&nbsp;ní v&nbsp;obrazových souborech
setkáváme.</li>

<li>Ve třetí sekci může být uložena <strong>barvová paleta</strong>. Tato sekce
je, podobně jako sekce předchozí, opět nepovinná. Používá se pouze u některých
obrázků s&nbsp;formátem 8 bitů na pixel (8bpp).</li>

<li>V&nbsp;sekci čtvrté jsou uložena vlastní <strong>rastrová data</strong>,
tj.&nbsp;barvy jednotlivých pixelů. Posloupnost rastrových dat (zejména
orientaci vertikální osy) lze ve formátu TGA specifikovat přímo
v&nbsp;hlavičce, je například možné obrázky ukládat od prvního řádku do řádku
posledního či naopak (tak pracovaly původní video grabbery <i>Targa</i>).
Rastrová data mohou být komprimována jednoduchým RLE algoritmem.</li>

</ol>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rastrový formát BMP</h2>

<p>Grafický formát <strong>BMP</strong> (<i>BitMaP)</i> patří
v&nbsp;současnosti mezi nejpoužívanější grafické formáty, což je
z&nbsp;technologického pohledu docela paradoxní, protože je poměrně složitý na
zpracování a přitom nabízí pouze minimum užitečných vlastností, nicméně jeho
nespornou výhodou je široká podpora v&nbsp;mnoha různých prohlížečích obrázků,
konverzních utilitách, grafických editorech atd. Právě proto může být výhodné
BMP pro screenshoty použít, pokud samozřejmě nechcete raději přilinkovat
knihovnu pro práci s&nbsp;formáty PNG či JPEG (což vůbec není složité, i když
mnohdy spíše zbytečné).</p>

<p>V&nbsp;čem však tkví taková rozšířenost BMP, pro kterou nemluví
technologické parametry? Je to z&nbsp;prozaického důvodu: tento formát byl
navržen firmami IBM a Microsoft (každá firma navrhla jinou variantu, jak jinak)
jako základní rastrový obrazový formát pro jejich operační systémy (OS/2 a
Microsoft Windows). Tím pádem je načítání i ukládání obrázků v&nbsp;tomto
formátu podporováno přímo v&nbsp;aplikačním rozhraní daného operačního systému
a tvůrci programů mohou toto rozhraní využít bez toho, aby daný formát detailně
znali (poznámka: dnes WinAPI podporuje i další formáty, včetně JPEG). Obzvlášť
zajímavé je ukládání interních obrázků aplikací v&nbsp;BMP, především dnes, kdy
se rozdíl mezi rychlostí zpracování dat v&nbsp;CPU a rychlostí přenosu či
ukládání dat na datová média stále zvyšuje &ndash; jinými slovy, výhodnější je
provádět komprimaci náročnou na CPU než zatěžovat přenosové linky nebo datová
média.</p>

<p>Rastrové (obrazové) soubory typu BMP jsou uloženy v&nbsp;takzvaném formátu
nezávislém na zařízení (<i>Device Independent Bitmap</i>), ostatně místo
zkratky <strong>BMP</strong> se v&nbsp;minulosti používala také zkratka
<strong>DIB</strong>. Nejedná se o nic jiného, než o rastrový obrázek uložený
způsobem, který není závislý na interních metodách práce s&nbsp;barvou nebo
uspořádáním pixelů. Prakticky všechny dnes používané obrazové formáty jsou
nezávislé na zařízení, mezi formáty závislé patří interní formát (či spíše
pseudoformát) využívaný u digitálních fotoaparátů &ndash; jde o
&bdquo;surový&ldquo; (<strong>RAW</strong>) formát odpovídající datům přečteným
ze světlocitlivé matice čipu CCD.</p>

<p>Formát BMP je navržen tak, že umožňuje ukládání rastrových dat ve čtyřech
formátech:</p>

<ul>
<li><strong>1 bit na pixel</strong> &ndash; dvoubarevné obrázky (používá se
barevná paleta, nemusí se tedy jednat pouze o černobílé grafiky, ale o
libovolnou kombinaci dvou barev)</li>
<li><strong>4 bity na pixel</strong> &ndash; 16ti barevné obrázky (taktéž se
používá barevná paleta o délce 64 bytů, v&nbsp;minulosti nejpoužívanější typ,
zejména na grafických kartách EGA a VGA)</li>
<li><strong>8 bitů na pixel</strong> &ndash; 256ti barevné obrázky (opět se
používá barevná paleta, tentokrát o délce 1024 bytů)</li>
<li><strong>24 bitů na pixel</strong> &ndash; TrueColor obrázky (16 milionů
barev, barevná paleta se nepoužívá,
protože každý pixel je reprezentován přímo svou barvou).</li>
</ul>

<p>Nás bude v&nbsp;kontextu OpenVG pochopitelně zajímat pouze poslední
případ.</p>

<p>Každý korektní soubor typu BMP obsahuje následující datové struktury,
jejichž název odpovídá C-čkovským strukturám definovaným ve WinAPI:</p>

<table>
<tr><th>Název struktury</th><th>Význam</th></tr>
<tr><td><strong>BITMAPFILEHEADER</strong></td><td>hlavička BMP souboru</td></tr>
<tr><td><strong>BITMAPINFOHEADER</strong></td><td>informační hlavička o obrázku</td></tr>
<tr><td><strong>RGBQUAD[]</strong></td><td>tabulka barev (barvová paleta)</td></tr>
<tr><td><strong>BITS</strong></td><td>pole bitů obsahujících vlastní rastrová data (pixely)</td></tr>
</table>

<p>Význam těchto datových struktur je následující:</p>

<ol>

<li><strong>BITMAPFILEHEADER</strong>: jedná se o datovou strukturu, která
obsahuje základní informace o souboru typu BMP. Velikost této struktury je
konstantní a má hodnotu 14 bytů.</li>

<li><strong>BITMAPINFOHEADER</strong>: tato datová struktura obsahuje základní
metainformace o uloženém obraze. Velikost této struktury je opět konstantní,
zde jde o 40 bytů.</li>

<li><strong>RGBQUAD[]</strong>: pole obsahující barvovou paletu ve formě složek
RGB. Typická délka barvové palety, tj.&nbsp;počet barev, je 2, 16 a 256.</li>

<li><strong>BITS</strong>: v&nbsp;této datové struktuře jsou uložena vlastní
obrazová data. Konkrétní formát těchto dat závisí na použité komprimační metodě
(i na tom, zda je vůbec použita) a na celkovém počtu barev v&nbsp;obrázku.</li>

</ol>

<p>Vícebajtové sekvence jsou uloženy ve formátu little-endian, tj.&nbsp;byte
s&nbsp;nejvyšší váhou je uložený jako poslední. To platí jak pro dvoubajtové,
tak i pro čtyřbajtové sekvence (a také pro barvovou paletu).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Demonstrační příklad číslo 18: uložení screenshotu do rastrového formátu typu TGA (32bpp)</h2>

<p>Podívejme se nyní na to, jak lze pro vytvoření screenshotu použít formát TGA
s&nbsp;32bitovou hloubkou. Nejprve si připravíme pole s&nbsp;hlavičkou obrázku
a předvyplněnými hodnotami:</p>

<pre>
<i>/*</i>
<i> * Hlavicka souboru TGA (Targa)</i>
<i> */</i>
unsigned char true_color_tga_header[] =
{
    0x00,       <i>/* typ hlavicky formatu typu TGA */</i>
    0x00,       <i>/* nepouzivame paletu */</i>
    0x02,       <i>/* typ obrazku je RGB TrueColor */</i>
    0x00, 0x00, <i>/* delka barvove palety je nulova */</i>
    0x00, 0x00, <i>/* pozice v barvove palete */</i>
    0x00,       <i>/* pocet bitu na jeden prvek v palete */</i>
    0x00, 0x00,
    0x00, 0x00, <i>/* obrazek je umisteny na pozici [0,0] */</i>
    0x00, 0x00, <i>/* sirka obrazku */</i>
    0x00, 0x00, <i>/* vyska obrazku */</i>
    0x20,       <i>/* format je 32 bitu na pixel */</i>
    0x20        <i>/* orientace bitmapy v obrazku */</i>
};
</pre>

<p>Vlastní uložení pak zprostředkovává funkce <strong>savePixmap()</strong>.
V&nbsp;ní se vyplní dva údaje do hlavičky &ndash; šířka a výška bitmapy &ndash;
a následně se bez jakékoli komprimace zapíšou jednotlivé pixely:</p>

<pre>
<i>/*</i>
<i> * Ulozeni pixmapy do externiho souboru</i>
<i> */</i>
void savePixmap(const unsigned int width, const unsigned int height,
                const unsigned char *pixels, const char *fileName)
{
    FILE *fout;
    unsigned int j;
&nbsp;
    <i>/* do hlavicky TGA zapsat velikost obrazku */</i>
    true_color_tga_header[12]=(width) &amp; 0xff;
    true_color_tga_header[13]=(width) &gt;&gt;8;
    true_color_tga_header[14]=(height) &amp; 0xff;
    true_color_tga_header[15]=(height) &gt;&gt;8;
&nbsp;
    fout=fopen(fileName, "wb");
    if (fout) {
        fwrite(true_color_tga_header, 18, 1, fout); <i>/* zapsat hlavicku TGA */</i>
        for (j=height; j; j--) {                <i>/* radky zapisovat v opacnem poradi */</i>
            unsigned int yoff=(j-1)*4*width;    <i>/* y-ovy offset v poli */</i>
            fwrite(pixels+yoff, width*4, 1, fout);
        }
        fclose(fout);
    }
}
</pre>

<p>Poznámka &ndash; jak je z&nbsp;kódu patrné, zapisují se vždy celé obrazové
řádky, což je relativně rychlá operace.</p>

<p>Ještě se podívejme na to, jakým způsobem lze přečíst jednotlivé pixely a
přenést je z&nbsp;framebufferu do operační paměti:</p>

<pre>
    unsigned int width  = state-&gt;window_width;
    unsigned int height = state-&gt;window_height;
    unsigned char *data = (unsigned char*)malloc(width*height*4);
&nbsp;
    <i>/* precist obsah obrazovky */</i>
    vgReadPixels(data, width * 4, VG_sXRGB_8888, 0, 0, width, height);
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Demonstrační příklad číslo 19: použití formátu typu TGA s&nbsp;24bpp</h2>

<p>Poměrně běžné je použití obrázků s&nbsp;24bitovou hloubkou, což představuje
menší problém, protože tento formát grafická knihovna <i>OpenVG</i>
nepodporuje. Screenshot se tedy provede s&nbsp;původní 32bitovou hloubkou:</p>

<pre>
    unsigned int width  = state-&gt;window_width;
    unsigned int height = state-&gt;window_height;
    unsigned char *data = (unsigned char*)malloc(width*height*4);
&nbsp;
    <i>/* precteni obsahu cele obrazovky do pametove oblasti 'data' */</i>
    <i>/* format je 32bitovy */</i>
    vgReadPixels(data, width * 4, VG_sBGRX_8888, 0, 0, width, height);
</pre>

<p>Před zápisem či přímo při zápisu je však nutné pixely vhodným způsobem
zkonvertovat. Pomalý způsob může vypadat takto:</p>

<pre>
<i>/*</i>
<i> * Ulozeni pixmapy do externiho souboru</i>
<i> */</i>
void savePixmap(const unsigned int width, const unsigned int height,
                const unsigned char *pixels, const char *fileName)
{
    FILE *fout;
    unsigned int i, j, k;
&nbsp;
    <i>/* do hlavicky TGA zapsat velikost obrazku */</i>
&nbsp;
    <i>/* sirka bitmapy je ulozena ve dvou bajtech */</i>
    true_color_tga_header[12]=(width) &amp; 0xff;
    true_color_tga_header[13]=(width) &gt;&gt;8;
&nbsp;
    <i>/* vyska bitmapy je ulozena taktez ve dvou bajtech */</i>
    true_color_tga_header[14]=(height) &amp; 0xff;
    true_color_tga_header[15]=(height) &gt;&gt;8;
&nbsp;
    fout=fopen(fileName, "wb");
    if (fout) {
        fwrite(true_color_tga_header, 18, 1, fout);     <i>/* zapsat hlavicku TGA do souboru */</i>
        for (j=height; j; j--) {                        <i>/* radky zapisovat v opacnem poradi */</i>
            unsigned int yoff=(j-1)*4*width;            <i>/* y-ovy offset v poli */</i>
            unsigned int xoff=0;                        <i>/* x-ovy offset v poli */</i>
&nbsp;
            <i>/* Poznamka: v nasledujicim demonstracnim prikladu bude tato */</i>
            <i>/*           programova smycka vyresena mnohem efektivnejsim zpusobem */</i>
            for (i=0; i&lt;width; i++) {                   <i>/* pro kazdy pixel na radku */</i>
                for (k=0; k&lt;3; k++) {                   <i>/* prohodit barvy RGB na BGR */</i>
                    fputc(pixels[xoff+yoff+3-k], fout); <i>/* a zapsat do souboru */</i>
                }                                       <i>/* (zde velmi primitivne a neefektivne bajt po bajtu) */</i>
                xoff+=4;                                <i>/* posun na dalsi pixel */</i>
                                                        <i>/* (zdrojova data maji 32 bitu na pixel */</i>
            }
        }
        fclose(fout);
    }
}
</pre>

<p>Poznámka: tento způsob je skutečně relativně pomalý. Na Raspberry Pi
(původní model B s&nbsp;jednojádrovým mikroprocesorem) trvá uložení screenshotu
obrazovky o rozlišení 1280&times;1024 pixelů cca 1,5 sekundy.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Demonstrační příklad číslo 20: použití formátu typu BMP (BitMap)</h2>

<p>Poněkud efektivnější způsob konverze 32bpp&rarr;24bpp je ukázán
v&nbsp;dnešním posledním demonstračním příkladu, v&nbsp;němž se screenshot
uloží do souboru typu BMP (BitMaP). Opět budeme potřebovat předvyplněnou
hlavičku, do níž se posléze doplní jen některé variabilní údaje &ndash; šířka a
výška obrázku:</p>

<pre>
<i>/*</i>
<i> * Hlavicka souboru BMP (BitMap)</i>
<i> */</i>
unsigned char bmp_header[] =
{
    0x42, 0x4d,             <i>/* magicke cislo */</i>
    0x46, 0x00, 0x00, 0x00, <i>/* velikost hlavicky=70 bajtu */</i>
    0x00, 0x00,             <i>/* nepouzito */</i>
    0x00, 0x00,             <i>/* nepouzito */</i>
    0x36, 0x00, 0x00, 0x00, <i>/* 54 bajtu - offset na zacatek vlastnich dat */</i>
    0x28, 0x00, 0x00, 0x00, <i>/* 40 bajtu - velikost hlavicky DIB */</i>
    0x00, 0x00, 0x00, 0x00, <i>/* sirka bitmapy */</i>
    0x00, 0x00, 0x00, 0x00, <i>/* vyska bitmapy */</i>
    0x01, 0x0,              <i>/* 1 pixel plane */</i>
    0x18, 0x00,             <i>/* 24 bpp */</i>
    0x00, 0x00, 0x00, 0x00, <i>/* bez komprese */</i>
    0x00, 0x00, 0x00, 0x00, <i>/* velikost pole pixelu */</i>
    0x13, 0x0b, 0x00, 0x00, <i>/* 2835 pixels/meter (vetsina SW ignoruje) */</i>
    0x13, 0x0b, 0x00, 0x00, <i>/* 2835 pixels/meter (vetsina SW ignoruje)  */</i>
    0x00, 0x00, 0x00, 0x00, <i>/* barvova paleta */</i>
    0x00, 0x00, 0x00, 0x00, <i>/* pocet dulezitych barev v palete (v 24 bpp ignorujeme) */</i>
};
</pre>

<p>Samotné uložení bitmapy může být naprogramováno tak, že se vždy zapíše celá
trojice bajtů tvořících barvu jednoho pixelu a posléze se ukazatel přesune o
hodnotu 4 (nikoli 3), tedy na začátek dalšího pixelu:</p>

<pre>
<i>/*</i>
<i> * Ulozeni pixmapy do externiho souboru</i>
<i> */</i>
void savePixmap(const unsigned int width, const unsigned int height,
                const unsigned char *pixels, const char *fileName)
{
    FILE *fout;
    unsigned int i;
&nbsp;
    <i>/* sirka bitmapy je zapsana ve ctverici bajtu */</i>
    bmp_header[18] =  width &amp; 0xff;
    bmp_header[19] = (width &gt;&gt; 8) &amp; 0xff;
    bmp_header[20] = (width &gt;&gt; 16) &amp; 0xff;
    bmp_header[21] = (width &gt;&gt; 24) &amp; 0xff;
&nbsp;
    <i>/* vyska bitmapy je taktez zapsana ve ctverici bajtu */</i>
    bmp_header[22] =  height &amp; 0xff;
    bmp_header[23] = (height &gt;&gt; 8) &amp; 0xff;
    bmp_header[24] = (height &gt;&gt; 16) &amp; 0xff;
    bmp_header[25] = (height &gt;&gt; 24) &amp; 0xff;
&nbsp;
    fout=fopen(fileName, "wb");
    if (fout) {
                                           <i>/* zapis hlavicky */</i>
        fwrite(bmp_header, sizeof(bmp_header), 1, fout);
        unsigned char *p=pixels+1;         <i>/* adresa prvniho pixelu (preskocime alfa slozku) */</i>
&nbsp;
        <i>/* nyni zapiseme celou bitmapu do souboru, */</i>
        <i>/* z formatu 32bpp se jednoduchou konverzi vytvori format 24bpp */</i>
        for (i=0; i&lt;width*height; i++) {<i>/* projit celou zdrojovou bitmapou */</i>
            fwrite(p, 3, 1, fout);         <i>/* zapisujeme po cele trojici RGB */</i>
            p+=4;                          <i>/* posun na dalsi pixel ve zdrojovych datech */</i>
        }
        fclose(fout);
    }
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všech šest demonstračních příkladů, které jsme si v&nbsp;dnešním článku
popsali, bylo uloženo do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy všech
šesti zmíněných demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>GitHub</th></tr>
<tr><td>1</td><td>example15</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example15">https://github.com/tisnik/presentations/tree/master/openvg/example15</a></td></tr>
<tr><td>2</td><td>example16</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example16">https://github.com/tisnik/presentations/tree/master/openvg/example16</a></td></tr>
<tr><td>3</td><td>example17</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example17">https://github.com/tisnik/presentations/tree/master/openvg/example17</a></td></tr>
<tr><td>4</td><td>example18</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example18">https://github.com/tisnik/presentations/tree/master/openvg/example18</a></td></tr>
<tr><td>5</td><td>example19</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example19">https://github.com/tisnik/presentations/tree/master/openvg/example19</a></td></tr>
<tr><td>6</td><td>example20</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example20">https://github.com/tisnik/presentations/tree/master/openvg/example20</a></td></tr>
</table>

<p>Poznámka: pro zjednodušení překladu je ke každému demonstračnímu příkladu
přiložen i příslušný soubor Makefile (otestovaný na Raspberry Pi).</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Alpha matting &amp; premultiplication<br />
<a href="http://dvd-hq.info/alpha_matting.php">http://dvd-hq.info/alpha_matting.php</a>
</li>

<li>Alpha compositing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

<li>So What's the Big Deal with Horizontal and Vertical Bezier Handles Anyway? (pro grafiky)<br />
<a href="http://theagsc.com/blog/tutorials/so-whats-the-big-deal-with-horizontal-vertical-bezier-handles-anyway/">http://theagsc.com/blog/tutorials/so-whats-the-big-deal-with-horizontal-vertical-bezier-handles-anyway/</a>
</li>

<li>EGL quick reference card<br />
<a href="https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf">https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf</a>
</li>

<li>EGL Reference Pages Index<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php">https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php</a>
</li>

<li>Funkce eglInitialize<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml</a>
</li>

<li>Funkce eglGetDisplay<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml</a>
</li>

<li>Funkce eglGetConfigs<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml</a>
</li>

<li>Funkce eglGetConfigAttrib<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml</a>
</li>

<li>Funkce eglDestroySurface<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml</a>
</li>

<li>Funkce eglDestroyContext<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml</a>
</li>

<li>Funkce eglTerminate<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml</a>
</li>

<li>Khronos Native Platform Graphics Interface<br />
<a href="https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf">https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf</a>
</li>

<li>Khronos Group<br />
<a href="https://www.khronos.org/">https://www.khronos.org/</a>
</li>

<li>Khronos Group (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Khronos_Group">https://en.wikipedia.org/wiki/Khronos_Group</a>
</li>

<li>Raspberry Pi VideoCore APIs<br />
<a href="http://elinux.org/Raspberry_Pi_VideoCore_APIs">http://elinux.org/Raspberry_Pi_VideoCore_APIs</a>
</li>

<li>Programming AudioVideo on the Raspberry Pi GPU<br />
<a href="https://jan.newmarch.name/RPi/index.html">https://jan.newmarch.name/RPi/index.html</a>
</li>

<li>The Standard for Vector Graphics Acceleration<br />
<a href="https://www.khronos.org/openvg/">https://www.khronos.org/openvg/</a>
</li>

<li>OpenVG (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenVG">https://en.wikipedia.org/wiki/OpenVG</a>
</li>

<li>OpenVG Quick Reference Card<br />
<a href="https://www.khronos.org/files/openvg-quick-reference-card.pdf">https://www.khronos.org/files/openvg-quick-reference-card.pdf</a>
</li>

<li>OpenVG on the Raspberry Pi<br />
<a href="http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html">http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html</a>
</li>

<li>ShivaVG: open-source ANSI C OpenVG <br />
<a href="http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html">http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html</a>
</li>

<li>Testbed for exploring OpenVG on the Raspberry Pi<br />
<a href="https://github.com/ajstarks/openvg">https://github.com/ajstarks/openvg</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame prakticky<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: práce s bitmapami a TrueType fonty<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: sprity v knihovně Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: detekce kolize spritů<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: transformace rastrových obrázků<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/</a>
</li>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

<li>Vykreslovací pipeline OpenVG (schéma)<br />
<a href="https://www.khronos.org/assets/uploads/apis/openvg_pipeline1.jpg">https://www.khronos.org/assets/uploads/apis/openvg_pipeline1.jpg</a>
</li>

<li>sRGB<br />
<a href="https://cs.wikipedia.org/wiki/SRGB">https://cs.wikipedia.org/wiki/SRGB</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

