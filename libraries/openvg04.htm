<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>2D grafika s využitím knihovny OpenVG (nejenom) na Raspberry Pi: práce s cestami</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>2D grafika s využitím knihovny OpenVG (nejenom) na Raspberry Pi: práce s cestami</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve čtvrté části článku o grafické knihovně OpenVG si na několika demonstračních příkladech ukážeme, jak je možné vykreslit složitější dvourozměrné objekty s&nbsp;využitím takzvaných &bdquo;cest&ldquo;, s&nbsp;jejichž konceptem jsme se seznámili minule. Taktéž se zmíníme o pomocných funkcích z&nbsp;knihovny VGU.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;cestami v&nbsp;knihovně OpenVG</a></p>
<p><a href="#k02">2. Základní funkce určené pro práci s&nbsp;cestami</a></p>
<p><a href="#k03">3. Funkce <strong>vgCreatePath</strong></a></p>
<p><a href="#k04">4. Funkce <strong>vgDestroyPath</strong></a></p>
<p><a href="#k05">5. Funkce <strong>vgClearPath</strong></a></p>
<p><a href="#k06">6. Funkce <strong>vgDrawPath</strong></a></p>
<p><a href="#k07">7. Funkce <strong>vgAppendPathData</strong></a></p>
<p><a href="#k08">8. První demonstrační příklad (šestý v&nbsp;celkovém pořadí): vykreslení cesty obsahující jediný segment &ndash; úsečku</a></p>
<p><a href="#k09">9. Druhý demonstrační příklad (sedmý v&nbsp;celkovém pořadí): vykreslení uzavřené cesty složené z&nbsp;úseček</a></p>
<p><a href="#k10">10. Třetí demonstrační příklad (osmý v&nbsp;celkovém pořadí): použití příkazů pro vykreslení vodorovných a svislých úseček</a></p>
<p><a href="#k11">11. Čtvrtý demonstrační příklad (devátý v&nbsp;celkovém pořadí): vykreslení Bézierovy křivky</a></p>
<p><a href="#k12">12. Vysokoúrovňové funkce <strong>vguLine</strong>, <strong>vguRect</strong>, <strong>vguRoundRect</strong> a <strong>vguPolygon</strong></a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;cestami v&nbsp;knihovně OpenVG</h2>

<p><a
href="http://www.root.cz/clanky/2d-grafika-s-vyuzitim-knihovny-openvg-nejenom-na-raspberry-pi-cesty/">V&nbsp;předchozí
části</a> článku o grafické knihovně <i>OpenVG</i> jsme si vysvětlili koncept
takzvaných cest (<i>paths</i>), protože právě s&nbsp;využitím cest jsou
v&nbsp;této knihovně vykreslovány prakticky všechny složitější dvourozměrné
objekty, ať již se jedná o objekty otevřené (úsečky, lomené čáry &ndash;
polyčáry, oblouky, křivky) či objekty uzavřené (kruhy, vyplněné mnohoúhelníky
apod.). Připomeňme si, že každá cesta se skládá z&nbsp;prakticky libovolného
množství segmentů (<i>segments</i>), přičemž je zajímavé a pro některé účely i
velmi důležité, že jednotlivé segmenty na sebe nutně nemusí graficky navazovat,
ale mohou být mezi nimi mezery. Minule jsme si taktéž řekli, že použití
konceptu cest není v&nbsp;oblasti 2D grafiky samozřejmě nic nového, protože
jsme se s&nbsp;nimi mohli setkat například <a
href="http://www.root.cz/clanky/vytvarime-krivky-v-postscriptu/">v&nbsp;PostScriptu</a>
či <a
href="http://www.root.cz/clanky/vlastnosti-cest-a-zakladnich-geometrickych-tvaru-v-svg/">v&nbsp;grafickém
formátu SVG</a> (PostScript lze přitom podle jeho konkrétního způsobu použití
chápat jako souborový formát, programovací jazyk a současně i
renderovací/vykreslovací knihovnu).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní funkce určené pro práci s&nbsp;cestami</h2>

<p>Pro práci s&nbsp;cestami je v&nbsp;grafické knihovně <i>OpenVG</i>
připraveno několik funkcí, ovšem pro začátek si vystačíme s&nbsp;pouhými pěti
funkcemi, jejichž jména a stručný popis je vypsán v&nbsp;následující
tabulce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>vgCreatePath()</td><td>vytvoření datové struktury obsahující (prozatím) prázdnou cestu</td></tr>
<tr><td>2</td><td>vgDestroyPath()</td><td>odstranění cesty z&nbsp;aktuálního kontextu a uvolnění operační paměti</td></tr>
<tr><td>3</td><td>vgAppendPathData()</td><td>přidání dalších segmentů do existující cesty (původně je cesta bez segmentů)</td></tr>
<tr><td>4</td><td>vgClearPath()</td><td>odstranění všech segmentů z&nbsp;existující cesty (lze použít i pro právě vytvořenou cestu bez segmentů)</td></tr>
<tr><td>5</td><td>vgDrawPath()</td><td>vykreslení cesty s&nbsp;využitím aktuálního kontextu a tedy i nastaveného stylu vykreslování</td></tr>
</table>

<p>Můžeme se však setkat i s&nbsp;dalšími funkcemi, které souvisí
s&nbsp;cestami, například:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>vgGetPathCapabilities()</td><td>získání aktuálního nastavení parametrů cesty</td></tr>
<tr><td>2</td><td>vgRemovePathCapabilities()</td><td>odstranění některého nastavení cesty (zadává se bitovým polem)</td></tr>
<tr><td>3</td><td>vgAppendPath()</td><td>spojení dvou cest do cesty jediné</td></tr>
<tr><td>4</td><td>vgTransformPath()</td><td>aplikace lineární transformace na vybranou cestu (posun, změna měřítka, ...)</td></tr>
<tr><td>5</td><td>vgPathLength()</td><td>výpočet délky cesty</td></tr>
<tr><td>6</td><td>vgPathBounds()</td><td>výpočet obalového obdélníku pro zadanou cestu</td></tr>
</table>

<p>Další zajímavou (ale ne vždy intuitivně použitelnou) funkcí je
<strong>vgInterpolatePath</strong>, kterou si popíšeme příště:</p>

<pre>
VGboolean <strong>vgInterpolatePath</strong>(
    VGPath    dstPath,
    VGPath    startPath,
    VGPath    endPath,
    VGfloat   amount)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce <strong>vgCreatePath</strong></h2>

<p><a href="#k02">Z&nbsp;předchozí kapitoly</a> již víme, že se prázdná cesta
vytváří s&nbsp;využitím funkce <strong>vgCreatePath()</strong>. Tato funkce má
následující hlavičku:</p>

<pre>
VGPath <strong>vgCreatePath</strong>(
    VGint          pathFormat,
    VGPathDatatype datatype,
    VGfloat        scale,
    VGfloat        bias,
    VGint          segmentCapacityHint,
    VGint          coordCapacityHint,
    VGbitfield     capabilities);
</pre>

<p>Funkce <strong>vgCreatePath</strong> sice vyžaduje předání sedmi parametrů,
ale ve skutečnosti se do mnoha parametrů většinou předává stále stejná hodnota.
To je případ prvního parametru, který bývá nastaven na konstantu se jménem
<strong>VG_PATH_FORMAT_STANDARD</strong>. Ve druhém parametru se specifikuje
formát hodnot použitých pro uložení vrcholů jednotlivých segmentů (určuje se
tím způsob zpracování pole s&nbsp;vrcholy segmentů):</p>

<table>
<tr><th>datatype</th><th>Význam</th></tr>
<tr><td>VG_PATH_DATATYPE_S_8 </td><td>osmibitové hodnoty se znaménkem</td></tr>
<tr><td>VG_PATH_DATATYPE_S_16</td><td>16bitové hodnoty se znaménkem</td></tr>
<tr><td>VG_PATH_DATATYPE_S_32</td><td>32bitové hodnoty se znaménkem</td></tr>
<tr><td>VG_PATH_DATATYPE_F   </td><td>formát s&nbsp;plovoucí řádovou čárkou podle IEEE 754 (<i>float</i>)</td></tr>
</table>

<p>Následuje dvojice parametrů <strong>scale</strong> a <strong>bias</strong>,
které slouží pro jednoduchou transformaci všech souřadnic podle vzorce
<strong>scale*x+bias</strong>. Typicky se předává <strong>scale=1.0</strong> a
<strong>bias=0.0</strong>, pokud je ovšem vstupní formát souřadnic nějak
specifický, můžete hodnoty těchto parametrů pochopitelně změnit, a to právě na
tomto jediném místě (nemusí se zdlouhavě přepočítávat jednotlivé souřadnice).
Parametry <strong>segmentCapacityHint</strong> a
<strong>coordCapacityHint</strong> slouží pouze pro optimalizaci alokátoru
paměti &ndash; předává se zde předpokládaná velikost cesty (počet segmentů,
celkový počet souřadnic). Pokud tyto hodnoty dopředu neznáte, nebo je nechcete
počítat, předává se 0 značící <strong>unknown</strong>.</p>

<p>Poslední formát určuje možnosti a povolené operace, které budeme chtít
s&nbsp;cestou provádět. Jedná se o celočíselnou konstantu získanou operací OR
či + nad následujícími konstantami:</p>

<pre>
VG_PATH_CAPABILITY_APPEND_FROM
VG_PATH_CAPABILITY_APPEND_TO
VG_PATH_CAPABILITY_MODIFY
VG_PATH_CAPABILITY_TRANSFORM_FROM
VG_PATH_CAPABILITY_TRANSFORM_TO
VG_PATH_CAPABILITY_INTERPOLATE_FROM
VG_PATH_CAPABILITY_INTERPOLATE_TO
VG_PATH_CAPABILITY_PATH_LENGTH
VG_PATH_CAPABILITY_POINT_ALONG_PATH
VG_PATH_CAPABILITY_TANGENT_ALONG_PATH
VG_PATH_CAPABILITY_PATH_BOUNDS
VG_PATH_CAPABILITY_PATH_TRANSFORMED_BOUNDS
VG_PATH_CAPABILITY_ALL
</pre>

<p>Důležitá je především konstanta nazvaná
<strong>VG_PATH_CAPABILITY_APPEND_TO</strong>, protože právě ta povoluje
použití funkce <strong>vgAppendPathData()</strong> popsané v&nbsp;dalších
kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce <strong>vgDestroyPath</strong></h2>

<p>Druhou důležitou funkcí při práci s&nbsp;cestami je funkce nazvaná
<strong>vgDestroyPath()</strong>. Tato funkce, která je vlastně opakem výše
popsané funkce <strong>vgCreatePath()</strong>, cestu z&nbsp;aktuálního
kontextu odstraní a uvolní paměť (buď na grafickém akcelerátoru nebo
&bdquo;obyčejnou&ldquo; operační paměť). V&nbsp;aplikacích je vhodné tuto
funkci zavolat co nejdříve a nenechávat v&nbsp;paměti uloženo zbytečně velké
množství cest (paměť pro cesty totiž může být alokována v&nbsp;paměťovém
prostoru grafického akcelerátoru, záleží ovšem na konkrétní implementaci):</p>

<pre>
void <strong>vgDestroyPath</strong>(
    VGPath path);
</pre>

<p>Povšimněte si návratového typu, který naznačuje, že tato funkce nevrací
žádnou hodnotu, ovšem případná chyba může být nahlášena:
<strong>VG_BAD_HANDLE_ERROR</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Funkce <strong>vgClearPath</strong></h2>

<p>Segmenty se z&nbsp;vybrané cesty dají kdykoli odstranit s&nbsp;využitím
funkce <strong>vgClearPath()</strong>, jejíž hlavička je velmi jednoduchá:</p>

<pre>
void <strong>vgClearPath</strong>(
    VGPath     path,
    VGbitfield capabilities);
</pre>

<p>Tuto funkci je možné zavolat i v&nbsp;případě, že se jedná o novou cestu bez
segmentů.</p>

<p>U hlavičky této funkce si povšimněte toho, že se kromě odstranění všech
segmentů, z&nbsp;nichž se cesta skládá, mohou nastavit nové vlastnosti cesty, a
to díky druhému parametru pojmenovanému <strong>capabilities</strong>.</p>

<p>Tato funkce má význam ve chvíli, kdy je zapotřebí vykreslit větší množství
cest. V&nbsp;takovém okamžiku je neustálé používání dvojice funkcí
<strong>vgCreatePaint()</strong> a <strong>vgDestroyPath()</strong>
neefektivní; lepší je jednu cestu vykreslit, smazat její data pomocí
<strong>vgClearPath()</strong> a nadefinovat cestu novou.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce <strong>vgDrawPath</strong></h2>

<p>Čtvrtá funkce důležitá při práci s&nbsp;cestami se jmenuje
<strong>vgDrawPath</strong> a její hlavička vypadá následovně:</p>

<pre>
void <strong>vgDrawPath</strong>(
    VGPath     path,
    VGbitfield paintModes)
</pre>

<p>Prvním parametrem této funkce je reference na již vytvořenou a
inicializovanou cestu (ideálně obsahující nějaké segmenty, které se mají
vykreslit, ve skutečnosti to však není nutné &ndash; vykreslit lze i prázdnou
cestu, ovšem s&nbsp;pochopitelným výsledkem). Zajímavý je druhý parametr,
kterým se určuje styl vykreslení cesty:</p>

<table>
<tr><th>paintModes</th><th>Operace</th></tr>
<tr><td>VG_STROKE_PATH</td><td>vykreslí se obrys cesty</td></tr>
<tr><td>VG_FILL_PATH</td><td>vyplní se vnitřek cesty</td></tr>
<tr><td>VG_STROKE_PATH | VG_FILL_PATH</td><td>kombinace vykreslení a současného vyplnění</td></tr>
</table>

<p>Poznámka: styl vykreslení a styl výplně se může odlišovat, což znamená, že
obrys může mít jinou barvu, než samotná výplň.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce <strong>vgAppendPathData</strong></h2>

<p>Poslední důležitou funkcí, s&nbsp;níž se dnes musíme seznámit, je funkce
nazvaná <strong>vgAppendPathData</strong>. Tato funkce slouží k&nbsp;připojení
dalších segmentů ke specifikované cestě. Funkce
<strong>vgAppendPathData</strong> má následující hlavičku:</p>

<pre>
void <strong>vgAppendPathData</strong>(
    VGPath         dstPath,
    VGint          numSeg,
    const VGubyte *pathSeg,
    const void    *pathData)
</pre>

<p>Význam prvního argumentu je zřejmý &ndash; jde o referenci na vytvořenou
cestu, k&nbsp;níž se mají připojit další segmenty. Ve druhém parametru je
předán počet připojovaných segmentů, protože ze samotných dat není možné tuto
informaci zjistit. Zajímavý je třetí argument. Jedná se o pole obsahující
jednotlivé příkazy pro tvorbu segmentů (jejich význam jsme si vysvětlili
minule):</p>

<table>
<tr><th> #</th><th>Symbolická konstanta</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td> 1</td><td>VG_CLOSE_PATH</td><td>0</td><td>uzavření cesty</td></tr>
<tr><td> 2</td><td>VG_MOVE_TO   </td><td>2</td><td>přesun aktivního bodu bez kreslení</td></tr>
<tr><td> 3</td><td>VG_LINE_TO   </td><td>4</td><td>lineární segment (úsečka)</td></tr>
<tr><td> 4</td><td>VG_HLINE_TO  </td><td>6</td><td>horizontální úsečka</td></tr>
<tr><td> 5</td><td>VG_VLINE_TO  </td><td>8</td><td>vertikální úsečka</td></tr>
<tr><td> 6</td><td>VG_QUAD_TO   </td><td>10</td><td>kvadratická Bézierova křivka</td></tr>
<tr><td> 7</td><td>VG_CUBIC_TO  </td><td>12</td><td>kubická Bézierova křivka</td></tr>
<tr><td> 8</td><td>VG_SQUAD_TO  </td><td>14</td><td>segment s&nbsp;G1 spojitostí tvořený kvadratickou křivkou</td></tr>
<tr><td> 9</td><td>VG_SCUBIC_TO </td><td>16</td><td>segment s&nbsp;G1 spojitostí tvořený kubickou křivkou</td></tr>
<tr><td>10</td><td>VG_SCCWARC_TO</td><td>18</td><td>kratší segment tvořený eliptickým obloukem</td></tr>
<tr><td>11</td><td>VG_SCWARC_TO </td><td>20</td><td>kratší segment tvořený eliptickým obloukem</td></tr>
<tr><td>12</td><td>VG_LCCWARC_TO</td><td>22</td><td>delší segment tvořený eliptickým obloukem</td></tr>
<tr><td>13</td><td>VG_LCWARC_TO </td><td>24</td><td>delší segment tvořený eliptickým obloukem</td></tr>
</table>

<p>Každý příkaz může používat absolutní souřadnice (vztažené vůči počátku
souřadného systému) či souřadnice relativní (vztažené vůči poslední zadané či
vypočtené souřadnici). Rozhodnutí o použití relativních či absolutních
souřadnicích se provádí na základě nejnižšího bitu příkazu, který může nabývat
hodnot:</p>

<table>
<tr><th>#</th><th>Symbolická konstanta</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td>1</td><td>VG_ABSOLUTE</td><td>0</td><td>příznak použití absolutních souřadnic</td></tr>
<tr><td>2</td><td>VG_RELATIVE</td><td>1</td><td>příznak použití relativních souřadnic</td></tr>
</table>

<p>Výsledkem jsou následující kombinace:</p>

<table>
<tr><th> #</th><th>Symbolická konstanta</th><th>Vypočteno z</th></tr>
<tr><td> 1</td><td>VG_MOVE_TO_ABS   </td><td>VG_MOVE_TO    | VG_ABSOLUTE</td></tr>
<tr><td> 2</td><td>VG_MOVE_TO_REL   </td><td>VG_MOVE_TO    | VG_RELATIVE</td></tr>
<tr><td> 3</td><td>VG_LINE_TO_ABS   </td><td>VG_LINE_TO    | VG_ABSOLUTE</td></tr>
<tr><td> 4</td><td>VG_LINE_TO_REL   </td><td>VG_LINE_TO    | VG_RELATIVE</td></tr>
<tr><td> 5</td><td>VG_HLINE_TO_ABS  </td><td>VG_HLINE_TO   | VG_ABSOLUTE</td></tr>
<tr><td> 6</td><td>VG_HLINE_TO_REL  </td><td>VG_HLINE_TO   | VG_RELATIVE</td></tr>
<tr><td> 7</td><td>VG_VLINE_TO_ABS  </td><td>VG_VLINE_TO   | VG_ABSOLUTE</td></tr>
<tr><td> 8</td><td>VG_VLINE_TO_REL  </td><td>VG_VLINE_TO   | VG_RELATIVE</td></tr>
<tr><td> 9</td><td>VG_QUAD_TO_ABS   </td><td>VG_QUAD_TO    | VG_ABSOLUTE</td></tr>
<tr><td>10</td><td>VG_QUAD_TO_REL   </td><td>VG_QUAD_TO    | VG_RELATIVE</td></tr>
<tr><td>11</td><td>VG_CUBIC_TO_ABS  </td><td>VG_CUBIC_TO   | VG_ABSOLUTE</td></tr>
<tr><td>12</td><td>VG_CUBIC_TO_REL  </td><td>VG_CUBIC_TO   | VG_RELATIVE</td></tr>
<tr><td>13</td><td>VG_SQUAD_TO_ABS  </td><td>VG_SQUAD_TO   | VG_ABSOLUTE</td></tr>
<tr><td>14</td><td>VG_SQUAD_TO_REL  </td><td>VG_SQUAD_TO   | VG_RELATIVE</td></tr>
<tr><td>15</td><td>VG_SCUBIC_TO_ABS </td><td>VG_SCUBIC_TO  | VG_ABSOLUTE</td></tr>
<tr><td>16</td><td>VG_SCUBIC_TO_REL </td><td>VG_SCUBIC_TO  | VG_RELATIVE</td></tr>
<tr><td>17</td><td>VG_SCCWARC_TO_ABS</td><td>VG_SCCWARC_TO | VG_ABSOLUTE</td></tr>
<tr><td>18</td><td>VG_SCCWARC_TO_REL</td><td>VG_SCCWARC_TO | VG_RELATIVE</td></tr>
<tr><td>19</td><td>VG_SCWARC_TO_ABS </td><td>VG_SCWARC_TO  | VG_ABSOLUTE</td></tr>
<tr><td>20</td><td>VG_SCWARC_TO_REL </td><td>VG_SCWARC_TO  | VG_RELATIVE</td></tr>
<tr><td>21</td><td>VG_LCCWARC_TO_ABS</td><td>VG_LCCWARC_TO | VG_ABSOLUTE</td></tr>
<tr><td>22</td><td>VG_LCCWARC_TO_REL</td><td>VG_LCCWARC_TO | VG_RELATIVE</td></tr>
<tr><td>23</td><td>VG_LCWARC_TO_ABS </td><td>VG_LCWARC_TO  | VG_ABSOLUTE</td></tr>
<tr><td>24</td><td>VG_LCWARC_TO_REL </td><td>VG_LCWARC_TO  | VG_RELATIVE</td></tr>
</table>

<p>Poslední parametr obsahuje pole souřadnic pro jednotlivé segmenty. Formát
souřadnic (celé číslo, float...) byl určen již při vytváření cesty funkcí
<strong>vgCreatePath()</strong>. Souřadnice jsou v&nbsp;poli uloženy za sebou:
x1, y1, x2, y2, ...</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. První demonstrační příklad (šestý v&nbsp;celkovém pořadí): vykreslení cesty obsahující jediný segment &ndash; úsečku</h2>

<p>Všech pět funkcí důležitých pro tvorbu cest jsme si již popsali, takže nám
již zbývá si ukázat jejich použití v&nbsp;demonstračních příkladech. Dnešní
první demonstrační příklad (který je celkově již osmým příkladem na OpenVG) je
sice poměrně dlouhý, ovšem jeho základem je vykreslení jednoduché úsečky. Po
inicializaci EGL apod. (viz též předchozí části tohoto seriálu) se zavolá
funkce <strong>draw</strong>, která:</p>

<ol>
<li>Vymaže obrazovku černou barvou</li>
<li>Nastaví barvu štětce pro vykreslovanou úsečku</li>
<li>Nastaví šířku štětce i styl zakončení (zde konkrétně kulaté konce)</li>
<li>Vytvoří cestu</li>
<li>Přidá do cesty segment dvěma příkazy: VG_MOVE_TO_ABS, VG_LINE_TO_REL</li>
<li>Cestu zruší</li>
<li>Prohodí přední a zadní buffer</li>
</ol>

<p>Podívejme se na kód této funkce:</p>

<pre>
<i>/*</i>
<i> * Vykresleni usecky sestrojene pomoci "cesty" (path).</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* barva stetce vykreslovane usecky */</i>
    VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
    VGPaint strokePaint = vgCreatePaint();
    vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
    vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
    vgSetPaint(strokePaint, VG_STROKE_PATH);
    vgDestroyPaint(strokePaint);
&nbsp;
    <i>/* sirka a styl stetce pouziteho pro kresbu usecky */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 10);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* vykresleni prvni usecky */</i>
    VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
    <i>/* deklarace useckoveho segmentu */</i>
    VGubyte commands[] = {VG_MOVE_TO_ABS, VG_LINE_TO_REL};
    VGfloat coordinates[] = {state-&gt;window_width &gt;&gt; 1, state-&gt;window_height &gt;&gt; 1, 100, 50};
&nbsp;
    <i>/* pridani useckoveho segmentu */</i>
    vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
    <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
    vgDrawPath(path, VG_STROKE_PATH);
    vgDestroyPath(path);
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
</pre>

<p>Úplný zdrojový kód demonstračního příkladu je vypsán pod tímto odstavce:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - sesty demonstracni priklad */</i>
<i>/* Vykresleni usecky s vyuzitim jednoho "segmentu" cesty. */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
typedef struct
{
    uint32_t screen_width;
    uint32_t screen_height;
&nbsp;
    uint32_t window_x;
    uint32_t window_y;
    int32_t  window_width;
    int32_t  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
void initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    static EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    static VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    static const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    int32_t success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    if ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    if ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 /*layer */ , &amp;dst_rect, 0 /*src */ ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 <i>/*clamp */</i> ,
                          0 <i>/*transform */</i> );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
void finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni usecky sestrojene pomoci "cesty" (path).</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* barva stetce vykreslovane usecky */</i>
    VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
    VGPaint strokePaint = vgCreatePaint();
    vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
    vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
    vgSetPaint(strokePaint, VG_STROKE_PATH);
    vgDestroyPaint(strokePaint);
&nbsp;
    <i>/* sirka a styl stetce pouziteho pro kresbu usecky */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 10);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* vykresleni prvni usecky */</i>
    VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
    <i>/* deklarace useckoveho segmentu */</i>
    VGubyte commands[] = {VG_MOVE_TO_ABS, VG_LINE_TO_REL};
    VGfloat coordinates[] = {state-&gt;window_width &gt;&gt; 1, state-&gt;window_height &gt;&gt; 1, 100, 50};
&nbsp;
    <i>/* pridani useckoveho segmentu */</i>
    vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
    <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
    vgDrawPath(path, VG_STROKE_PATH);
    vgDestroyPath(path);
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
int main(int argc, char *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    return 0;
}
</pre>

<p>Soubor <strong>Makefile</strong> určený pro překlad tohoto příkladu:</p>

<pre>
# Makefile pro preklad sesteho prikladu ukazujiciho
# praci s OpenVG a EGL.
&nbsp;
# Parametry prekladace.
CFLAGS=-Wall
&nbsp;
# Dalsi parametry prekladace, zde adresare, kde se maji 
# hledat hlavickove soubory.
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
# Parametry linkeru.
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example6
&nbsp;
# Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.
all:	$(PROGNAME)
&nbsp;
clean:
	rm -f *.o
	rm -f $(PROGNAME)
&nbsp;
# Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni
# vysledne spustitelne aplikace.
$(PROGNAME):	$(PROGNAME).o
	$(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
# Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho
# objektoveho souboru.
%.o:	%.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Druhý demonstrační příklad (sedmý v&nbsp;celkovém pořadí): vykreslení uzavřené cesty složené z&nbsp;úseček</h2>

<p>V&nbsp;dnešním druhém demonstračním příkladu je ukázána tvorba uzavřené
cesty. Okolo celé obrazovky je vykreslen široký žlutý okraj se zkosenými
hranami. Nastavení stylu vykreslování je provedeno následovně:</p>

<pre>
<i>/* barva stetce druhe cesty */</i>
VGfloat color2[4] = {0.75f, 0.75f, 0.25f, 1.0f};
VGPaint strokePaint = vgCreatePaint();
vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
vgSetPaint(strokePaint, VG_STROKE_PATH);
vgDestroyPaint(strokePaint);
&nbsp;
<i>/* sirka a styl stetce druhe cesty */</i>
vgSetf(VG_STROKE_LINE_WIDTH, 20);
vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);    <i>/* siroke stopy konci presne na stanovenych souradnicich */</i>
vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL); <i>/* vnejsi okraje spoju jsou "oseknute" */</i>
</pre>

<p>Pro uzavřenou cestu bylo zvoleno pět příkazů (povšimněte si způsobu uzavření
&ndash; to je důležité, aby byly správně zkoseny všechny okraje cesty):</p>

<pre>
<i>/* deklarace useckoveho segmentu */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                      VG_LINE_TO_REL,                  <i>/* prvni usecka (vodorovna) */</i>
                      VG_LINE_TO_REL,                  <i>/* druha usecka (svisla) */</i>
                      VG_LINE_TO_REL,                  <i>/* treti usecka (vodorovna) */</i>
                      VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
</pre>

<p>se souřadnicemi jednotlivých vrcholů:</p>

<pre>
VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                         state-&gt;window_width-40, 0,    <i>/* prvni usecka (vodorovna) */</i>
                         0, state-&gt;window_height-40,   <i>/* druha usecka (svisla) */</i>
                         -state-&gt;window_width+40, 0};  <i>/* treti usecka (vodorovna) */</i>
</pre>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - sedmy demonstracni priklad */</i>
<i>/* Vykresleni uzavreneho segmentu slozeneho z usecek. */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
typedef struct
{
    uint32_t screen_width;
    uint32_t screen_height;
&nbsp;
    uint32_t window_x;
    uint32_t window_y;
    int32_t  window_width;
    int32_t  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
void initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    static EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    static VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    static const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    int32_t success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    if ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    if ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 /*layer */ , &amp;dst_rect, 0 /*src */ ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 <i>/*clamp */</i> ,
                          0 <i>/*transform */</i> );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
void finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni nekolika usecek.</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* barva stetce prvni cesty */</i>
    {
        VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 10);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    {
        <i>/* vykresleni prvni cesty */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL};       <i>/* vodorovna usecka */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 100, state-&gt;window_height &gt;&gt; 1, 200, 0};
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* barva stetce druhe cesty */</i>
    {
        VGfloat color2[4] = {0.75f, 0.75f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce druhe cesty */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 20);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);    <i>/* siroke stopy konci presne na stanovenych souradnicich */</i>
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL); <i>/* vnejsi okraje spoju jsou "oseknute" */</i>
&nbsp;
    {
        <i>/* vykresleni polycary */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,                  <i>/* prvni usecka (vodorovna) */</i>
                              VG_LINE_TO_REL,                  <i>/* druha usecka (svisla) */</i>
                              VG_LINE_TO_REL,                  <i>/* treti usecka (vodorovna) */</i>
                              VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
&nbsp;
        VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                                 state-&gt;window_width-40, 0,    <i>/* prvni usecka (vodorovna) */</i>
                                 0, state-&gt;window_height-40,   <i>/* druha usecka (svisla) */</i>
                                 -state-&gt;window_width+40, 0};  <i>/* treti usecka (vodorovna) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 5, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
int main(int argc, char *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    return 0;
}
</pre>

<p>Soubor <strong>Makefile</strong> určený pro překlad tohoto příkladu se
vlastně nijak neliší od předchozího Makefile:</p>

<pre>
# Makefile pro preklad sedmeho prikladu ukazujiciho
# praci s OpenVG a EGL.
&nbsp;
# Parametry prekladace.
CFLAGS=-Wall
&nbsp;
# Dalsi parametry prekladace, zde adresare, kde se maji 
# hledat hlavickove soubory.
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
# Parametry linkeru.
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example7
&nbsp;
# Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.
all:	$(PROGNAME)
&nbsp;
clean:
	rm -f *.o
	rm -f $(PROGNAME)
&nbsp;
# Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni
# vysledne spustitelne aplikace.
$(PROGNAME):	$(PROGNAME).o
	$(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
# Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho
# objektoveho souboru.
%.o:	%.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Třetí demonstrační příklad (osmý v&nbsp;celkovém pořadí): použití příkazů pro vykreslení vodorovných a svislých úseček</h2>

<p>Pokud si ještě pamatujete, že jsme v&nbsp;třetí části tohoto seriálku
hovořili o možnosti jednoduché kresby vodorovných a svislých úseček, pak vás
nepřekvapí, že příkazy z&nbsp;předchozího příkladu:</p>

<pre>
<i>/* deklarace useckoveho segmentu */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                      VG_LINE_TO_REL,                  <i>/* prvni usecka (vodorovna) */</i>
                      VG_LINE_TO_REL,                  <i>/* druha usecka (svisla) */</i>
                      VG_LINE_TO_REL,                  <i>/* treti usecka (vodorovna) */</i>
                      VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
</pre>

<p>je možné převést na příkazy pro vykreslení vodorovných čar (<i>horizontal
line</i>) a čar vertikálních (<i>vertical line</i>):</p>

<pre>
<i>/* deklarace useckoveho segmentu */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                      VG_HLINE_TO_REL,                 <i>/* prvni usecka (vodorovna) */</i>
                      VG_VLINE_TO_REL,                 <i>/* druha usecka (svisla) */</i>
                      VG_HLINE_TO_REL,                 <i>/* treti usecka (vodorovna) */</i>
                      VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
</pre>

<p>Změní se především pole se souřadnicemi (resp.&nbsp;se toto pole zmenší, což
je jeden z&nbsp;účelů použití horizontálních a vertikálních čar, který se
projeví zejména u komplikovaných cest). Staré pole:</p>

<pre>
VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                         state-&gt;window_width-40, 0,    <i>/* prvni usecka (vodorovna) */</i>
                         0, state-&gt;window_height-40,   <i>/* druha usecka (svisla) */</i>
                         -state-&gt;window_width+40, 0};  <i>/* treti usecka (vodorovna) */</i>
</pre>

<p>Nové pole (chybí zde nuly na druhém, třetím i čtvrtém řádku):</p>

<pre>
VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                         state-&gt;window_width-40,       <i>/* prvni usecka (vodorovna) */</i>
                         state-&gt;window_height-40,      <i>/* druha usecka (svisla) */</i>
                         -state-&gt;window_width+40};     <i>/* treti usecka (vodorovna) */</i>
</pre>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - osmy demonstracni priklad */</i>
<i>/* Vykresleni uzavreneho segmentu slozeneho z vodorovnych a svislych usecek. */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
typedef struct
{
    uint32_t screen_width;
    uint32_t screen_height;
&nbsp;
    uint32_t window_x;
    uint32_t window_y;
    int32_t  window_width;
    int32_t  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
void initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    static EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    static VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    static const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    int32_t success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    if ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    if ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 /*layer */ , &amp;dst_rect, 0 /*src */ ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 <i>/*clamp */</i> ,
                          0 <i>/*transform */</i> );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
void finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni nekolika usecek.</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* barva stetce prvni cesty */</i>
    {
        VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 10);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    {
        <i>/* vykresleni prvni cesty */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_HLINE_TO_REL};      <i>/* vodorovna usecka */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 100, state-&gt;window_height &gt;&gt; 1,
                                 200}; <i>/* delka vodorovne usecky */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* barva stetce druhe cesty */</i>
    {
        VGfloat color2[4] = {0.75f, 0.75f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce druhe cesty */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 20);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);    <i>/* siroke stopy konci presne na stanovenych souradnicich */</i>
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL); <i>/* vnejsi okraje spoju jsou "oseknute" */</i>
&nbsp;
    {
        <i>/* vykresleni polycary */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                              VG_HLINE_TO_REL,                 <i>/* prvni usecka (vodorovna) */</i>
                              VG_VLINE_TO_REL,                 <i>/* druha usecka (svisla) */</i>
                              VG_HLINE_TO_REL,                 <i>/* treti usecka (vodorovna) */</i>
                              VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
&nbsp;
        VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                                 state-&gt;window_width-40,       <i>/* prvni usecka (vodorovna) */</i>
                                 state-&gt;window_height-40,      <i>/* druha usecka (svisla) */</i>
                                 -state-&gt;window_width+40};     <i>/* treti usecka (vodorovna) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 5, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
int main(int argc, char *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    return 0;
}
</pre>

<p>Soubor <strong>Makefile</strong> určený pro překlad tohoto příkladu se opět
nijak neliší od předchozího Makefile:</p>

<pre>
# Makefile pro preklad osmeho prikladu ukazujiciho
# praci s OpenVG a EGL.
&nbsp;
# Parametry prekladace.
CFLAGS=-Wall
&nbsp;
# Dalsi parametry prekladace, zde adresare, kde se maji 
# hledat hlavickove soubory.
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
# Parametry linkeru.
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example8
&nbsp;
# Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.
all:	$(PROGNAME)
&nbsp;
clean:
	rm -f *.o
	rm -f $(PROGNAME)
&nbsp;
# Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni
# vysledne spustitelne aplikace.
$(PROGNAME):	$(PROGNAME).o
	$(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
# Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho
# objektoveho souboru.
%.o:	%.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Čtvrtý demonstrační příklad (devátý v&nbsp;celkovém pořadí): vykreslení Bézierovy křivky</h2>

<p>Kubické Bézierovy křivky většina uživatelů používajících vektorové grafické
editory již velmi dobře zná (ale nalezneme je i v&nbsp;rastrových grafických
editorech, například v&nbsp;GIMPu). Připomeňme si tedy, že tyto křivky jsou
definovány počátečním bodem, koncovým bodem a dvojicí řídicích bodů. Větší
množství řídicích bodů dává uživatelům i větší možnosti tvarování křivky,
protože je možné vytvořit i esíčko atd. V&nbsp;knihovně <i>OpenVG</i> se tyto
křivky (resp.&nbsp;segmenty složené z&nbsp;kubických Bézierových křivek)
specifikují příkazy <strong>VG_CUBIC_TO_ABS</strong> a
<strong>VG_CUBIC_TO_REL</strong>, přičemž se očekávají tři body (tedy šest
souřadnic), protože počáteční bod již známe &ndash; je jím dočasný poslední bod
aktuálně vytvářené cesty. Pozor je zapotřebí dávat na to, že i relativně zadané
souřadnice jsou vždy vztaženy k&nbsp;tomu bodu, kde křivka začíná, nikoli
k&nbsp;poslednímu zadanému bodu:</p>

<pre>
<i>/* deklarace useckoveho segmentu */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                      VG_CUBIC_TO_REL};      <i>/* Bezierova kubicka krivka */</i>
&nbsp;
VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                         200,  250,
                         400, -250,
                         600,  0};           <i>/* koncovy bod Bezierovy kubicke krivky */</i>
</pre>

<p>Kromě samotné kubické Bézierovy křivky je do 2D scény vykreslena i polyčára
spojující koncové body křivky s&nbsp;jejími řídicími body. Zde jsou samozřejmě
relativní souřadnice vztaženy vždy k&nbsp;poslední vykreslené úsečce:</p>

<pre>
<i>/* deklarace useckoveho segmentu */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                      VG_LINE_TO_REL,
                      VG_LINE_TO_REL,
                      VG_LINE_TO_REL};
&nbsp;
VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                         200,  250,
                         200, -500,
                         200,  250};
</pre>

<p>Úplný zdrojový kód tohoto příkladu vypadá takto:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - devaty demonstracni priklad */</i>
<i>/* Segmenty slozene z Berierovych krivek. */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
typedef struct
{
    uint32_t screen_width;
    uint32_t screen_height;
&nbsp;
    uint32_t window_x;
    uint32_t window_y;
    int32_t  window_width;
    int32_t  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
void initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    static EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    static VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    static const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    int32_t success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    if ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    if ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 /*layer */ , &amp;dst_rect, 0 /*src */ ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 <i>/*clamp */</i> ,
                          0 <i>/*transform */</i> );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
void finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni nekolika usecek a Bezierovych krivek.</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 1);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce prvni polycary */</i>
    {
        VGfloat color2[4] = {0.25f, 0.25f, 0.75f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni druhe cesty slozene z usecek */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,
                              VG_LINE_TO_REL,
                              VG_LINE_TO_REL};
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                                 200,  250,
                                 200, -500,
                                 200,  250};
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 4, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 3);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce Bezierovych krivek */</i>
    {
        VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni prvni cesty slozene z Bezierovych krivek */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_CUBIC_TO_REL};      <i>/* Bezierova kubicka krivka */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                                 200,  250,
                                 400, -250,
                                 600,  0};           <i>/* koncovy bod Bezierovy kubicke krivky */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* barva stetce polycary */</i>
    {
        VGfloat color2[4] = {0.75f, 0.75f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 20);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);    <i>/* siroke stopy konci presne na stanovenych souradnicich */</i>
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL); <i>/* vnejsi okraje spoju jsou "oseknute" */</i>
&nbsp;
    {
        <i>/* vykresleni polycary */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,                  <i>/* prvni usecka (vodorovna) */</i>
                              VG_LINE_TO_REL,                  <i>/* druha usecka (svisla) */</i>
                              VG_LINE_TO_REL,                  <i>/* treti usecka (vodorovna) */</i>
                              VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
&nbsp;
        VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                                 state-&gt;window_width-40, 0,    <i>/* prvni usecka (vodorovna) */</i>
                                 0, state-&gt;window_height-40,   <i>/* druha usecka (svisla) */</i>
                                 -state-&gt;window_width+40, 0};  <i>/* treti usecka (vodorovna) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 5, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
int main(int argc, char *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    return 0;
}
</pre>

<p>Soubor <strong>Makefile</strong> určený pro překlad tohoto příkladu se opět
podle očekávání nijak neliší od předchozího Makefile:</p>

<pre>
# Makefile pro preklad devateho prikladu ukazujiciho
# praci s OpenVG a EGL.
&nbsp;
# Parametry prekladace.
CFLAGS=-Wall
&nbsp;
# Dalsi parametry prekladace, zde adresare, kde se maji 
# hledat hlavickove soubory.
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
# Parametry linkeru.
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example9
&nbsp;
# Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.
all:	$(PROGNAME)
&nbsp;
clean:
	rm -f *.o
	rm -f $(PROGNAME)
&nbsp;
# Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni
# vysledne spustitelne aplikace.
$(PROGNAME):	$(PROGNAME).o
	$(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
# Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho
# objektoveho souboru.
%.o:	%.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vysokoúrovňové funkce <strong>vguLine</strong>, <strong>vguRect</strong>, <strong>vguRoundRect</strong> a <strong>vguPolygon</strong></h2>

<p>V&nbsp;některých případech nemá příliš význam ručně tvořit cesty, pokud je
vykreslovaný tvar podporovaný pomocnou knihovnou VGU (OpenVG Utility Library).
Jedná se o samostatnou úsečku, osově orientovaný obdélník, osově orientovaný
obdélník se zaoblenými rohy a obecný polygon:</p>

<pre>
vguErrorCode vguLine(VGPath path,
                     VGfloat x0, VGfloat y0,
                     VGfloat x1, VGfloat y1);
</pre>

<pre>
vguErrorCode vguRect(VGPath path,
                     VGfloat x, VGfloat y,
                     VGfloat width, VGfloat height);
</pre>

<pre>
vguErrorCode vguRoundRect(VGPath path,
                          VGfloat x, VGfloat y,
                          VGfloat width, VGfloat height,
                          VGfloat arcW, VGfloat arcH);
</pre>

<pre>
vguErrorCode vguPolygon(VGPath path,
                        const VGfloat * points, VGint count,
                        VGboolean closed);
</pre>

<p>Praktické příklady si ukážeme příště.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny čtyři demonstrační příklady, které jsme si v&nbsp;dnešním článku
popsali, byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy všech
čtyř zmíněných demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad/knihovna</th><th>Github</th></tr>
<tr><td>1</td><td>example6</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example6">https://github.com/tisnik/presentations/tree/master/openvg/example6</a></td></tr>
<tr><td>2</td><td>example7</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example7">https://github.com/tisnik/presentations/tree/master/openvg/example7</a></td></tr>
<tr><td>3</td><td>example8</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example8">https://github.com/tisnik/presentations/tree/master/openvg/example8</a></td></tr>
<tr><td>4</td><td>example9</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example9">https://github.com/tisnik/presentations/tree/master/openvg/example9</a></td></tr>
</table>

<p>Poznámka<sup>1</sup>: pro zjednodušení překladu je ke každému demonstračnímu
příkladu přiložen i příslušný soubor Makefile (otestovaný na Raspberry Pi).</p>

<p>Poznámka<sup>2</sup>: nenechte se prosím zmást číslováním &ndash; příklady
example1 až example5 byly totiž popsány v&nbsp;předchozích třech částech tohoto
seriálu.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>EGL quick reference card<br />
<a href="https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf">https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf</a>
</li>

<li>EGL Reference Pages Index<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php">https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php</a>
</li>

<li>Funkce eglInitialize<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml</a>
</li>

<li>Funkce eglGetDisplay<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml</a>
</li>

<li>Funkce eglGetConfigs<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml</a>
</li>

<li>Funkce eglGetConfigAttrib<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml</a>
</li>

<li>Funkce eglDestroySurface<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml</a>
</li>

<li>Funkce eglDestroyContext<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml</a>
</li>

<li>Funkce eglTerminate<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml</a>
</li>

<li>Khronos Native Platform Graphics Interface<br />
<a href="https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf">https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf</a>
</li>

<li>Khronos Group<br />
<a href="https://www.khronos.org/">https://www.khronos.org/</a>
</li>

<li>Khronos Group (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Khronos_Group">https://en.wikipedia.org/wiki/Khronos_Group</a>
</li>

<li>Raspberry Pi VideoCore APIs<br />
<a href="http://elinux.org/Raspberry_Pi_VideoCore_APIs">http://elinux.org/Raspberry_Pi_VideoCore_APIs</a>
</li>

<li>Programming AudioVideo on the Raspberry Pi GPU<br />
<a href="https://jan.newmarch.name/RPi/index.html">https://jan.newmarch.name/RPi/index.html</a>
</li>

<li>The Standard for Vector Graphics Acceleration<br />
<a href="https://www.khronos.org/openvg/">https://www.khronos.org/openvg/</a>
</li>

<li>OpenVG (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenVG">https://en.wikipedia.org/wiki/OpenVG</a>
</li>

<li>OpenVG Quick Reference Card<br />
<a href="https://www.khronos.org/files/openvg-quick-reference-card.pdf">https://www.khronos.org/files/openvg-quick-reference-card.pdf</a>
</li>

<li>OpenVG on the Raspberry Pi<br />
<a href="http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html">http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html</a>
</li>

<li>ShivaVG: open-source ANSI C OpenVG <br />
<a href="http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html">http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html</a>
</li>

<li>Testbed for exploring OpenVG on the Raspberry Pi<br />
<a href="https://github.com/ajstarks/openvg">https://github.com/ajstarks/openvg</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame prakticky<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: práce s bitmapami a TrueType fonty<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: sprity v knihovně Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: detekce kolize spritů<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: transformace rastrových obrázků<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/</a>
</li>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti?novsk?</a> &nbsp; 2016</small></p>
</body>
</html>

