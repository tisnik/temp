<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG (pokračování)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG (pokračování)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;sedmé části seriálu o grafické knihovně OpenVG budeme pokračovat v&nbsp;popisu způsobu práce s&nbsp;rastrovými obrázky. Již minule jsme se seznámili se základními funkcemi, ovšem zbývá nám popsat šestici důležitých funkcí určených pro přímou i nepřímou manipulaci s&nbsp;pixely.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG (pokračování)</a></p>
<p><a href="#k02">2. Typy objektů, které lze použít pro čtení či zápis barev pixelů</a></p>
<p><a href="#k03">3. Souhrn všech funkcí určených pro přenos barev pixelů mezi různými objekty</a></p>
<p><a href="#k04">4. Kopie pixelů mezi dvojicí obrázků</a></p>
<p><a href="#k05">5. Funkce <strong>vgCopyImage()</strong></a></p>
<p><a href="#k06">6. Přenosy pixelů mezi obrázkem a kreslicí plochou</a></p>
<p><a href="#k07">7. Funkce <strong>vgSetPixels()</strong></a></p>
<p><a href="#k08">8. Funkce <strong>vgGetPixels()</strong></a></p>
<p><a href="#k09">9. Přenosy pixelů v&nbsp;rámci aktuálně vybrané kreslicí plochy</a></p>
<p><a href="#k10">10. Funkce <strong>vgCopyPixels()</strong></a></p>
<p><a href="#k11">11. Nízkoúrovňové operace pro přímý zápis či čtení pixelů do kreslicí plochy</a></p>
<p><a href="#k12">12. Funkce <strong>vgWritePixels()</strong></a></p>
<p><a href="#k13">13. Funkce <strong>vgReadPixels()</strong></a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG (pokračování)</h2>

<p>V&nbsp;dnešním článku o grafické knihovně <i>OpenVG</i> se budeme téměř
výhradně zabývat grafickou operací nazývanou <strong>BitBLT</strong> (<i>Bit
Block Transfer</i>). Tato operace umožňuje provádět, jak ostatně její název
naznačuje, blokové přenosy bitmap nebo jejich výřezů, popř.&nbsp;v&nbsp;rámci
přenosu nad bitmapami provádět i různé další operace, například negaci barev
zdrojové či cílové bitmapy, provedení bitové operace AND, XOR atd. (posléze se
přidalo i zpracování alfa kanálu). První implementace operace
<strong>BitBLT</strong> byla použita již v&nbsp;roce 1975 ve
<i>Smalltalku-72</i> a od té doby ji najdeme prakticky v&nbsp;každé
implementaci tohoto programovacího jazyka, která obsahuje i knihovny pro práci
s&nbsp;grafikou (mj.&nbsp;se jedná i o <i>Squeak</i>).</p>

<p>Pro <i>Smalltalk-74</i> vytvořil Daniel Ingalls optimalizovanou variantu
operace <strong>BitBLT</strong> implementovanou v&nbsp;mikrokódu. Operace
<strong>BitBLT</strong> se tak stala součástí operačního systému a bylo ji
možné volat jak z&nbsp;assembleru, tak i z&nbsp;programů napsaných
v&nbsp;jazyce <i>BCPL</i> a samozřejmě i ze <i>Smalltalku</i> (právě tuto
implementaci můžeme považovat za vůbec první grafickou akceleraci). Posléze se
díky své univerzalitě tato funkce rozšířila i do mnoha dalších operačních
systémů a grafických knihoven.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Typy objektů, které lze použít pro čtení či zápis barev pixelů</h2>

<p>Vzhledem k&nbsp;tomu, že vykreslování rastrových obrázků do vytvářené
dvoudimenzionální scény je velmi často používaná operace, není příliš
překvapující, že se s&nbsp;touto operací můžeme setkat v&nbsp;API mnoha
grafických knihoven či dokonce v&nbsp;API operačních systémů (asi nejznámějším
příkladem je WinAPI). Tyto operace se většinou nazývají <i>BitBlt</i>,
<i>BitBLT</i>, <i>Blit</i> či méně často <i>PIXT (Pixel Transfer)</i> a
<i>PIXBLT</i>. V&nbsp;grafické knihovně <i>OpenVG</i> se s&nbsp;funkcemi
určenými pro přenos pixelů samozřejmě setkáme taktéž. Navíc &ndash; což je
minimálně zpočátku poměrně matoucí &ndash; se v&nbsp;této knihovně nachází hned
osm (!) různých funkcí, které se od sebe odlišují především tím, jakého typu je
zdrojový objekt a jakého typu je objekt cílový:</p>

<table>
<tr><th>#</th><th>Objekt</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>void*</td><td>blok operační paměti považovaný za bitmapu</td></tr>
<tr><td>2</td><td>VGImage</td><td>objekt reprezentující rastrový obrázek a jeho metadata (formát atd.)</td></tr>
<tr><td>3</td><td>EGLSurface</td><td>vykreslovací plocha nastavená funkcí <strong>eglMakeCurrent()</strong></td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Souhrn všech funkcí určených pro přenos barev pixelů mezi různými objekty</h2>

<p>Vzhledem k&nbsp;tomu, že existují tři typy objektů, z&nbsp;nichž lze pixely
číst či do kterých je možné pixely naopak zapisovat, je možných devět různých
kombinací zdroj+cíl. Z&nbsp;těchto devíti kombinací je osm kombinací pokryto
funkcemi <i>OpenVG</i> a zbývající operaci lze realizovat například
s&nbsp;využitím standardní funkce <strong>memcpy()</strong>, jak ostatně
ukazuje následující tabulka:</p>

<table>
<tr><th>Zdroj/Cíl </th><th>void*</th><th>VGImage</th><th>EGLSurface</th></tr>
<tr><td>void*     </td><td><a href="http://linux.die.net/man/3/memcpy">memcpy()</a></td><td><a href="http://www.root.cz/clanky/prace-s-rastrovymi-obrazky-v-knihovne-openvg/#k12">vgImageSubData()</a></td><td><a href="#k12">vgWritePixels()</a></td></tr>
<tr><td>VGImage   </td><td><a href="http://www.root.cz/clanky/prace-s-rastrovymi-obrazky-v-knihovne-openvg/#k13">vgGetImageSubData()</a></td><td><a href="#k05">vgCopyImage()</a></td><td><a href="#k07">vgSetPixels()</a></td></tr>
<tr><td>EGLSurface</td><td><a href="#k13">vgReadPixels()</a></td><td><a href="#k08">vgGetPixels()</a></td><td><a href="#k10">vgCopyPixels()</a></td></tr>
</table>

<p>Poznámka: odkazy v&nbsp;tabulce vedou na příslušný článek a kapitolu,
v&nbsp;níž je daná funkce popsána.</p>

<p>Poznámka<sup>2</sup>: funkce <a
href="http://www.root.cz/clanky/prace-s-rastrovymi-obrazky-v-knihovne-openvg/#k12">vgImageSubData()</a>
a <a
href="http://www.root.cz/clanky/prace-s-rastrovymi-obrazky-v-knihovne-openvg/#k13">vgGetImageSubData()</a>
byly popsány <a
href="http://www.root.cz/clanky/prace-s-rastrovymi-obrazky-v-knihovne-openvg/">v&nbsp;předchozí
části</a> seriálu:</p>

<pre>
void <strong>vgImageSubData</strong>(
     VGImage       image,
     const void   *data,
     VGint         dataStride,
     VGImageFormat dataFormat,
     VGint         x,
     VGint         y,
     VGint         width,
     VGint         height);
</pre>

<pre>
void <strong>vgGetImageSubData</strong>(
     VGImage       image,
     void         *data,
     VGint         dataStride,
     VGImageFormat dataFormat,
     VGint         x,
     VGint         y,
     VGint         width,
     VGint         height);
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Kopie pixelů mezi dvojicí obrázků</h2>

<p>Poměrně často se setkáme se situací, kdy je zapotřebí zkopírovat oblast
z&nbsp;jednoho obrázku (typu <strong>VGImage</strong>) do jiného obrázku. Může
se například jednat o operaci typu copy&amp;paste atd. Přenášená oblast je vždy
tvořena osově orientovaným obdélníkem, u něhož se nastavují jeho rozměry a
taktéž pozice jak ve zdrojovém, tak i v&nbsp;cílovém obrázku. Samozřejmě, že se
při kopírování oblasti provedou případné převody barev pixelů v&nbsp;závislosti
na tom, jaký formát je nastaven u zdrojového a cílového obrázku.
V&nbsp;případě, že bitová hloubka cílového obrázku je menší, než hloubka
obrázku zdrojového, může se při přenosu pixelů aplikovat operace
<i>ditheringu</i> v&nbsp;závislosti na tom, jaké nastavení programátor
použije.</p>

<p>Při kopírování pixelů se taktéž správně detekuje situace, kdy je zdrojový a
cílový obrázek totožný. V&nbsp;tomto případě se testuje, zda se oblasti zdroje
a cíle překrývají. Pokud k&nbsp;takové situaci dojde, použije se při přenosu
buffer či se operace provede takovým způsobem, jako by byl buffer použit.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Funkce <strong>vgCopyImage()</strong></h2>

<p>Funkce, která se používá pro kopii obdélníkové oblasti pixelů mezi dvěma
objekty typu <strong>VGImage</strong> (či mezi jedním a tím samým objektem) se
jmenuje <strong>vgCopyImage</strong> a má následující hlavičku:</p>

<pre>
void <strong>vgCopyImage</strong>(
     VGImage dst, VGint dx, VGint dy,
     VGImage src, VGint sx, VGint sy,
     VGint width, VGint height,
     VGboolean    dither);
</pre>

<p>Této funkci se předává devět parametrů:</p>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>dst</td><td>objekt představující cílový obrázek</td></tr>
<tr><td>2</td><td>dx</td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci cílového obrázku</td></tr>
<tr><td>3</td><td>dy</td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci cílového obrázku</td></tr>
<tr><td>4</td><td>src</td><td>objekt představující zdrojový obrázek</td></tr>
<tr><td>5</td><td>sx</td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci zdrojového obrázku</td></tr>
<tr><td>6</td><td>sy</td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci zdrojového obrázku</td></tr>
<tr><td>7</td><td>width</td><td>šířka kopírované obdélníkové oblasti</td></tr>
<tr><td>8</td><td>height</td><td>výška kopírované obdélníkové oblasti</td></tr>
<tr><td>9</td><td>dither</td><td>povoluje či zakazuje dithering, pokud má cílový obrázek menší bitovou hloubku</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přenosy pixelů mezi obrázkem a kreslicí plochou</h2>

<p>Celý subsystém pro práci s&nbsp;rastrovými obrázky v&nbsp;knihovně
<i>OpenVG</i> má prakticky pouze dva cíle &ndash; dosáhnout zobrazení dané
bitmapy ve vytvářené 2D scéně či naopak přečíst již vykreslenou scénu a
vytvořit z&nbsp;ní screenshot. Tím se dostáváme k&nbsp;dalším dvěma funkcím
sloužícím pro přenosy pixelů mezi obrázky typu <strong>VGImage</strong> a
kreslicí plochou, tj.&nbsp;objektem typu <strong>EGLSurface</strong>. Jednu
z&nbsp;těchto operací již známe &ndash; jedná se o vysokoúrovňovou funkci
nazvanou <strong>vgDrawImage()</strong>. Pokud se tato funkce zavolá, aplikují
se automaticky i další operace, například ořezávání, lineární transformace,
volba výstupního bufferu (color buffer, stencil buffer atd.). To má současně i
svoje nevýhody, protože operace <strong>vgDrawImage()</strong> může být poměrně
pomalá. Při požadavcích na co nejvyšší rychlost přenosu pixelů (BitBLT) mezi
objektem typu <strong>VGImage</strong> a <strong>EGLSurface</strong> lze použít
nízkoúrovňové funkce nazvané <a href="#k07">vgSetPixels()</a> a <a
href="#k08">vgGetPixels()</a>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce <strong>vgSetPixels()</strong></h2>

<p>Pro přenos pixelů z&nbsp;vybraného obrázku typu <strong>VGImage</strong> na
kreslicí plochu (tedy většinou přímo na obrazovku) slouží funkce nazvaná
<strong>vgSetPixels()</strong> s&nbsp;následující hlavičkou:</p>

<pre>
void <strong>vgSetPixels</strong>(
     VGint dx,    VGint dy,
     VGImage src, VGint sx, VGint sy,
     VGint width, VGint height);
</pre>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>dx</td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>2</td><td>dy</td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>3</td><td>src</td><td>objekt představující zdrojový obrázek</td></tr>
<tr><td>4</td><td>sx</td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci zdrojového obrázku</td></tr>
<tr><td>5</td><td>sy</td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci zdrojového obrázku</td></tr>
<tr><td>6</td><td>width</td><td>šířka kopírované obdélníkové oblasti</td></tr>
<tr><td>7</td><td>height</td><td>výška kopírované obdélníkové oblasti</td></tr>
</table>

<p>Vidíme, že se parametry funkce <strong>vgSetPixels()</strong> do značné míry
podobají parametrům <a href="#k05">výše popsané funkce</a>
<strong>vgCopyImage()</strong>, chybí však určení cíle (ten je implicitní) a
taktéž zde nenajdeme volbu ditheringu (opět implicitně nastaveno mimo tuto
funkci).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Funkce <strong>vgGetPixels()</strong></h2>

<p>Opakem funkce <strong>vgSetPixels()</strong> je podle očekávání funkce
nazvaná <strong>vgGetPixels()</strong>. Tu je možné použít například při
vytváření screenshotů popř.&nbsp;při podobných operacích. Hlavička této funkce
vypadá následovně:</p>

<pre>
void <strong>vgGetPixels</strong>(
     VGImage dst, VGint dx, VGint dy,
     VGint sx,    VGint sy,
     VGint width, VGint height);
</pre>

<p>Parametry, které se této funkci předávají, opět slouží především pro
specifikaci přesného umístění a rozměru obdélníkové oblasti, jež se má touto
funkcí zkopírovat:</p>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>dst</td><td>objekt představující cílový obrázek</td></tr>
<tr><td>2</td><td>dx</td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci cílového obrázku</td></tr>
<tr><td>3</td><td>dy</td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci cílového obrázku</td></tr>
<tr><td>4</td><td>sx</td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>5</td><td>sy</td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>6</td><td>width</td><td>šířka kopírované obdélníkové oblasti</td></tr>
<tr><td>7</td><td>height</td><td>výška kopírované obdélníkové oblasti</td></tr>
</table>

<p>Povšimněte si chybějící explicitní specifikace zdrojového objektu (kreslicí
plochy). Ta je vždy určena při inicializaci aplikace funkcí
<strong>eglMakeCurrent</strong>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přenosy pixelů v&nbsp;rámci aktuálně vybrané kreslicí plochy</h2>

<p>Pokud je zapotřebí zkopírovat nějakou oblast z&nbsp;jednoho místa kreslicí
plochy do jiného místa (představme si například scrolling v&nbsp;určitém
regionu), nemá smysl pro tuto operaci používat pomocný obrázek typu
<strong>VGImage</strong> a volat dvojici funkcí <strong>vgGetPixels()</strong>
a <strong>vgSetPixels()</strong>. To by bylo zbytečně zdlouhavé a taktéž zde
existuje určité riziko: pokud nemá GPU dostatek paměti pro uložení rastrového
obrázku, je <strong>VGImage</strong> uložen do operační paměti, takže funkce
<strong>vgGetPixels()</strong> a <strong>vgSetPixels()</strong> přenáší data po
sběrnici počítače, což je relativně pomalé. Ovšem knihovna <i>OpenVG</i> nabízí
řešení i tohoto problému &ndash; je jím funkce nazvaná
<strong>vgCopyPixels()</strong> umožňující kopii dat v&nbsp;rámci vybrané
kreslicí plochy. Tato funkce, podobně jako již <a href="#k05">výše popsaná</a>
funkce <strong>vgCopyImage()</strong>, pracuje korektně i ve chvíli, kdy se
zdrojový a cílový region překrývají.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce <strong>vgCopyPixels()</strong></h2>

<p>Hlavička funkce <strong>vgCopyPixels()</strong> je poměrně jednoduchá, neboť
se v&nbsp;ní pouze specifikuje velikost obdélníkové oblasti i její umístění
v&nbsp;rámci jedné kreslicí plochy:</p>

<pre>
void <strong>vgCopyPixels</strong>(
     VGint dx,    VGint dy,
     VGint sx,    VGint sy,
     VGint width, VGint height);
</pre>

<p>Význam parametrů této funkce:</p>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>dx</td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>2</td><td>dy</td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>3</td><td>sx</td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>4</td><td>sy</td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>5</td><td>width</td><td>šířka kopírované obdélníkové oblasti</td></tr>
<tr><td>6</td><td>height</td><td>výška kopírované obdélníkové oblasti</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nízkoúrovňové operace pro přímý zápis či čtení pixelů do kreslicí plochy</h2>

<p>Většina aplikací používá při tvorbě 2D scén již předem připravené (či
vypočtené) rastrové obrázky, které se nějakým způsobem do aplikace načtou
(například ze souborů typu PNG) a následně je je možné zobrazit. V&nbsp;takovém
případě má význam ze všech rastrových dat nejprve (jedenkrát) vytvořit objekty
typu <strong>VGImage</strong> a následně tyto objekty vykreslit funkcí typu
<strong>vgDrawImage()</strong>. Ovšem existují i situace a aplikace,
v&nbsp;nichž se bitmapy teprve vytváří a postupně mění. Pravděpodobně
nejtypičtějším příkladem jsou rastrové grafické editory (Photoshop, GIMP, můj
oblíbený mtPaint apod.). U takových aplikací, u nichž se často přistupuje
k&nbsp;jednotlivým pixelům, může být výhodnější přeskočit krok vytváření
objektů typu <strong>VGImage</strong> a namísto toho přímo přenášet pixely
z&nbsp;operační paměti na kreslicí plochu &ndash; ve skutečnosti je právě tato
operace asi nejbližší <a href="#k01">v&nbsp;úvodu zmíněné</a> původní operaci
typu <strong>BitBLT</strong>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Funkce <strong>vgWritePixels()</strong></h2>

<p>V&nbsp;případě, že má programátor v&nbsp;operační paměti již přichystanou
oblast s&nbsp;hodnotami (barvami) pixelů a tyto hodnoty odpovídají některému <a
href="http://www.root.cz/clanky/prace-s-rastrovymi-obrazky-v-knihovne-openvg/#k05">podporovanému
formátu</a>, je možné tuto oblast ihned vykreslit funkcí nazvanou
<strong>vgWritePixels()</strong>. Této funkci se musí předat ukazatel na
datovou oblast v&nbsp;paměti a formát uložení pixelů. Dalším důležitým
parametrem je parametr <strong>dataStride</strong>, kterým lze specifikovat
mezery mezi jednotlivými obrazovými řádky (<i>stride</i>). Pozor na to, že
některé jiné knihovny používají namísto hodnoty <i>stride</i> hodnotu
<i>pitch</i>, což je ve skutečnosti offset mezi obrazovými řádky:
<i>pitch=width+stride</i>. Kromě toho se specifikuje i velikost a umístění
obdélníkové oblasti kreslicí plochy, do níž se bude obrázek přenášet:</p>

<pre>
void <strong>vgWritePixels</strong>(
     const void    *data,
     VGint         dataStride,
     VGImageFormat dataFormat,
     VGint         dx,
     VGint         dy,
     VGint         width,
     VGint         height);
</pre>

<p>Parametry této funkce:</p>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>*data,    </td><td>region v&nbsp;operační paměti, o jehož alokaci a naplnění se musí postarat programátor</td></tr>
<tr><td>2</td><td>dataStride</td><td>mezery mezi obrazovými řádky (na vstupu), hodnota je v&nbsp;bajtech</td></tr>
<tr><td>3</td><td>dataFormat</td><td>vstupní formát pixelů, jedna ze symbolických konstant popsaných minule</td></tr>
<tr><td>4</td><td>dx        </td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>5</td><td>dy        </td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>6</td><td>width     </td><td>šířka kopírované obdélníkové oblasti</td></tr>
<tr><td>7</td><td>height    </td><td>výška kopírované obdélníkové oblasti</td></tr>
</table>

<p>Volání:</p>

<pre>
vgWritePixels(data, dataStride, dataFormat, dx, dy, width, height);
</pre>

<p>by mělo být &ndash; alespoň co se týká funkcionality &ndash;
ekvivalentní:</p>

<pre>
VGImage image = vgCreateImage(dataFormat, width, height, 0);
vgImageSubData(image, data, dataStride, dataFormat, 0, 0, width, height);
vgSetPixels(dx, dy, image, width, height);
vgDestroyImage(image);
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce <strong>vgReadPixels()</strong></h2>

<p>Při vytváření screenshotů apod. se může hodit funkce
<strong>vgReadPixels()</strong>, která dokáže získat obsah části kreslicí
plochy (či samozřejmě celou plochu, pokud je tak specifikováno) a uložit ji do
již alokovaného regionu operační paměti. Tato funkce je opakem funkce
<strong>vgWritePixels()</strong>, takže nás její parametry s&nbsp;velkou
pravděpodobností nepřekvapí:</p>

<pre>
void <strong>vgReadPixels</strong>(
     void         *data,
     VGint         dataStride,
     VGImageFormat dataFormat,
     VGint         sx,
     VGint         sy,
     VGint         width,
     VGint         height);
</pre>

<p>Parametry této funkce:</p>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>*data,    </td><td>region v&nbsp;operační paměti, o jehož alokaci se musí postarat programátor</td></tr>
<tr><td>2</td><td>dataStride</td><td>mezery mezi obrazovými řádky (na výstupu), hodnota je v&nbsp;bajtech</td></tr>
<tr><td>3</td><td>dataFormat</td><td>vstupní formát pixelů, jedna ze symbolických konstant popsaných minule</td></tr>
<tr><td>4</td><td>sx        </td><td>x-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>5</td><td>sy        </td><td>y-ová souřadnice levého horního rohu obdélníkové oblasti v&nbsp;rámci kreslicí plochy</td></tr>
<tr><td>6</td><td>width     </td><td>šířka kopírované obdélníkové oblasti</td></tr>
<tr><td>7</td><td>height    </td><td>výška kopírované obdélníkové oblasti</td></tr>
</table>

<p>Opět platí, že volání:</p>

<pre>
vgReadPixels(data, dataStride, dataFormat, sx, sy, width, height);
</pre>

<p>je funkčně ekvivalentní kódu:</p>

<pre>
VGImage image = vgCreateImage(dataFormat, width, height, 0);
vgGetPixels(image, 0, 0, sx, sy, width, height);
vgGetImageSubData(image, data, dataStride, dataFormat, width, height);
vgDestroyImage(image);
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>So What's the Big Deal with Horizontal and Vertical Bezier Handles Anyway? (pro grafiky)<br />
<a href="http://theagsc.com/blog/tutorials/so-whats-the-big-deal-with-horizontal-vertical-bezier-handles-anyway/">http://theagsc.com/blog/tutorials/so-whats-the-big-deal-with-horizontal-vertical-bezier-handles-anyway/</a>
</li>

<li>EGL quick reference card<br />
<a href="https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf">https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf</a>
</li>

<li>EGL Reference Pages Index<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php">https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php</a>
</li>

<li>Funkce eglInitialize<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml</a>
</li>

<li>Funkce eglGetDisplay<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml</a>
</li>

<li>Funkce eglGetConfigs<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml</a>
</li>

<li>Funkce eglGetConfigAttrib<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml</a>
</li>

<li>Funkce eglDestroySurface<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml</a>
</li>

<li>Funkce eglDestroyContext<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml</a>
</li>

<li>Funkce eglTerminate<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml</a>
</li>

<li>Khronos Native Platform Graphics Interface<br />
<a href="https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf">https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf</a>
</li>

<li>Khronos Group<br />
<a href="https://www.khronos.org/">https://www.khronos.org/</a>
</li>

<li>Khronos Group (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Khronos_Group">https://en.wikipedia.org/wiki/Khronos_Group</a>
</li>

<li>Raspberry Pi VideoCore APIs<br />
<a href="http://elinux.org/Raspberry_Pi_VideoCore_APIs">http://elinux.org/Raspberry_Pi_VideoCore_APIs</a>
</li>

<li>Programming AudioVideo on the Raspberry Pi GPU<br />
<a href="https://jan.newmarch.name/RPi/index.html">https://jan.newmarch.name/RPi/index.html</a>
</li>

<li>The Standard for Vector Graphics Acceleration<br />
<a href="https://www.khronos.org/openvg/">https://www.khronos.org/openvg/</a>
</li>

<li>OpenVG (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenVG">https://en.wikipedia.org/wiki/OpenVG</a>
</li>

<li>OpenVG Quick Reference Card<br />
<a href="https://www.khronos.org/files/openvg-quick-reference-card.pdf">https://www.khronos.org/files/openvg-quick-reference-card.pdf</a>
</li>

<li>OpenVG on the Raspberry Pi<br />
<a href="http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html">http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html</a>
</li>

<li>ShivaVG: open-source ANSI C OpenVG <br />
<a href="http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html">http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html</a>
</li>

<li>Testbed for exploring OpenVG on the Raspberry Pi<br />
<a href="https://github.com/ajstarks/openvg">https://github.com/ajstarks/openvg</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame prakticky<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: práce s bitmapami a TrueType fonty<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: sprity v knihovně Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: detekce kolize spritů<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: transformace rastrových obrázků<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/</a>
</li>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

<li>Vykreslovací pipeline OpenVG (schéma)<br />
<a href="https://www.khronos.org/assets/uploads/apis/openvg_pipeline1.jpg">https://www.khronos.org/assets/uploads/apis/openvg_pipeline1.jpg</a>
</li>

<li>sRGB<br />
<a href="https://cs.wikipedia.org/wiki/SRGB">https://cs.wikipedia.org/wiki/SRGB</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

