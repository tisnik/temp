<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovny libmill a libdill: implementace korutin a kanálů pro jazyk C</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovny libmill a libdill: implementace korutin a kanálů pro jazyk C</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku si popíšeme základní vlastnosti knihovny libmill. Jedná se o čistě céčkovou knihovnu (použitelnou pochopitelně i v C++), která do tohoto programovacího jazyka přináší technologie známé z jazyka Go - především korutiny a kanály určené pro komunikaci mezi nimi.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Knihovny libmill a libdill: implementace korutin a kanálů pro jazyk C</a></p>
<p><a href="#k02">2. Několik poznámek a autorovi knihoven libmill a libdill</a></p>
<p><a href="#k03">3. Souběžné provádění operací</a></p>
<p><a href="#k04">4. Communicating Sequential Processes</a></p>
<p><a href="#k05">5. Konstrukce používané v&nbsp;moderních implementacích odvozených od CSP</a></p>
<p><a href="#k06">6. Kanály a gorutiny v&nbsp;programovacím jazyce Go</a></p>
<p><a href="#k07">7. Implementace kanálů a go-bloků v&nbsp;jazyce Clojure</a></p>
<p><a href="#k08">8. Knihovna <strong>libmill</strong> se představuje</a></p>
<p><a href="#k09">9. Překlad knihovny <strong>libmill</strong></a></p>
<p><a href="#k10">10. Vytvoření a zavolání korutin</a></p>
<p><a href="#k11">11. Vytvoření většího množství korutin bez vzájemné synchronizace</a></p>
<p><a href="#k12">12. Koncept <i>deadline</i></a></p>
<p><a href="#k13">13. Přepnutí běhu na jinou korutinu</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovny libmill a libdill: implementace korutin a kanálů pro jazyk C</h2>

<p>Jedním z&nbsp;důvodů, proč se poměrně často setkáme s&nbsp;použitím <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">programovacího jazyka
Go</a>, je velmi dobrá podpora pro práci s&nbsp;takzvanými <i>gorutinami</i> a
taktéž s&nbsp;<i>kanály</i>, které tvoří programové prostředky určené pro
komunikaci mezi nimi. Díky existenci těchto prostředků lze relativně snadno
vytvářet programy využívající souběžnost a přitom netrpících problémy typu
deadlock, souběžný přístup ke sdílené proměnné/paměti bez zajištění výlučnosti
či atomičnosti přístupu atd. Ovšem <i>gorutiny</i> (i když toto je název
používaný výhradně v&nbsp;Go) a kanály nejsou v&nbsp;žádném případě výsadou
tohoto jediného programovacího jazyka. Můžeme se s&nbsp;nimi setkat například i
v&nbsp;jazyku <a
href="https://www.root.cz/vyhledavani/?qs=clojure">Clojure</a>, částečně
dokonce i <a href="https://www.root.cz/n/python/">v&nbsp;Pythonu</a> (jedná se
o knihovnu <a href="https://goless.readthedocs.io/en/latest/">goless</a>, která
je ovšem prozatím spíše ve stadiu vývoje, což je škoda) a &ndash; což může být
překvapivé &ndash; i ve starém dobrém programovacím jazyku C.</p>

<p>Pro tento postarší, ale stále velmi často používaný programovací jazyk totiž
existuje knihovna nazvaná <i>libmill</i> a taktéž poněkud odlišně postavená
knihovna <i>libdill</i>. V&nbsp;knihovně <i>libmill</i> se její autor snaží
napodobit sémantiku používanou programovacím jazykem Go, knihovna
<i>libdill</i> (pocházející ovšem od stejného autora) je naopak orientována
spíše přímo na céčkové programátory a nabízí sémantiku v&nbsp;mnoha ohledech
odlišnou od jazyka Go. Již na úvod je nutné říci, že výkonnost knihovny
<i>libmill</i> je přitom úctyhodná &ndash; ostatně sám její autor uvádí, že je
možné spustit až 20 milionů korutin a provést více než 50 milionů přepnutí
kontextů za sekundu (zde pochopitelně za předpokladu, že procesor nebude
provádět žádné další výpočetně náročné činnosti). Knihovna <i>libdill</i> je
ovšem realizována odlišným způsobem a tím pádem se liší i její výkonnost.
Přepnutí kontextu lze provést za cca 6 ns, korutina se vytvoří za 26 ns a
poslání zprávy přes kanál může trvat okolo 40 ns.</p>

<p>V&nbsp;první části článku si ukážeme některé společné vlastnosti již
existujících knihoven a jazyků založených na konceptu popsaného ve slavném
článku CSP. V&nbsp;části druhé si pak řekneme, jaké možnosti nám nabízí právě
knihovna <i>libmill</i>.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti existuje mnohem větší
množství knihoven pro podporu korutin pro jazyk C. Kromě <i>libmill</i> a
<i>libdill</i> můžeme jmenovat například <i>libpcl</i>, <i>coro</i>,
<i>libconcurrency</i>, <i>libcoro</i>, <i>ribs</i>, <i>libco</i> a další. Pro
programovací jazyk C++ se zmiňme především o <i>coroutine</i> a
<i>coroutine2</i> z&nbsp;Boostu. Autorem obou knihoven je Oliver
Kowalke.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Několik poznámek a autorovi knihoven libmill a libdill</h2>

<p>Autorem obou výše zmíněných knihoven <i>libmill</i> a <i>libdill</i> je
<i>Martin Sustrik</i> (<a href="http://250bpm.com/">http://250bpm.com/</a>),
s&nbsp;nímž jsme se již na stránkách <a href="https://www.root.cz">Rootu</a>
několikrát setkali, protože je mj.&nbsp;i autorem či spoluautorem knihoven
<i>ØMQ</i> a <i>nanomsg</i>. Viz též následující články ze <a
href="https://www.root.cz/serialy/message-brokery/">seriálu o message
brokerech</a>, v&nbsp;nichž jsme se těmito zajímavými a užitečnými nástroji
zabývali:</div></p>

<ol>

<li>ØMQ: knihovna pro asynchronní předávání zpráv<br />
<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/</a>
</li>

<li>Další možnosti poskytované knihovnou ØMQ<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/</a>
</li>

<li>Využití zařízení v knihovně ØMQ při tvorbě systému se složitější architekturou<br />
<a href="https://www.root.cz/clanky/vyuziti-zarizeni-v-knihovne-mq-pri-tvorbe-systemu-se-slozitejsi-architekturou/">https://www.root.cz/clanky/vyuziti-zarizeni-v-knihovne-mq-pri-tvorbe-systemu-se-slozitejsi-architekturou/</a>
</li>

<li>Další možnosti nabízené knihovnou ØMQ, implementace protokolů ØMQ v čisté Javě<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/</a>
</li>

<li>Implementace různých komunikačních strategií s využitím knihovny nanomsg<br />
<a href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/">https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/</a>
</li>

<li>Dokončení popisu komunikačních strategií poskytovaných knihovnou nanomsg<br />
<a href="https://www.root.cz/clanky/dokonceni-popisu-komunikacnich-strategii-poskytovanych-knihovnou-nanomsg/">https://www.root.cz/clanky/dokonceni-popisu-komunikacnich-strategii-poskytovanych-knihovnou-nanomsg/</a>
</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Souběžné provádění operací</h2>

<p>Knihovny či nové jazykové konstrukce umožňující používání kanálů (či front)
pro synchronní popř.&nbsp;asynchronní komunikaci mezi různými částmi vyvíjených
aplikací, se v&nbsp;posledních několika letech těší poměrně velké popularitě.
Ta je způsobena dvěma faktory. První důvod spočívá ve snaze o zjednodušení
návrhu (či porozumění) vyvíjené aplikace, zejména ve chvíli, kdy se
v&nbsp;rámci jednoho programu předávají data (resp.&nbsp;objekty) mezi částmi,
jejichž funkce může být dobře izolována od částí ostatních a která již
z&nbsp;principu mají běžet souběžně (UI, hry atd.). Druhý důvod je poněkud
prozaičtější &ndash; v&nbsp;některých situacích je nutné dosáhnout zvýšení
efektivity aplikace (například zvýšit počet odpovědí, které může server
vygenerovat za určitou časovou jednotku) a přitom není možné či vhodné využívat
přímočaré ale dosti nízkoúrovňové řešení založené na použití většího množství
vláken spravovaných systémem. Naprosto typickým příkladem jsou některé
virtuální stroje JavaScriptu, které povětšinou umožňují běh aplikace
v&nbsp;jediném vláknu (což je ovšem s&nbsp;ohledem na &bdquo;kvalitu&ldquo;
některých programových kódů spíše výhodou...).</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti používá node.js více
vláken, ovšem pouze jediné vlákno se smyčkou událostí.</div></p>

<p>Některé programovací jazyky, zejména pak již v&nbsp;první kapitole zmíněný
jazyk <i>Go</i>, obsahují prostředky sloužící pro zajištění synchronní a
asynchronní komunikace přímo v&nbsp;syntaxi (a samozřejmě též v&nbsp;sémantice)
jazyka. Konkrétně v&nbsp;případě jazyka <i>Go</i> se jedná o takzvané
&bdquo;gorutiny&ldquo; představované klíčovým slovem <strong>go</strong> a
taktéž o operace sloužící pro zápis či čtení dat z&nbsp;kanálů, které jsou
představovány operátorem <strong>&lt;-</strong> (ten má dva významy
v&nbsp;závislosti na tom, zda je před operátorem uveden identifikátor
představující kanál či nikoli). V&nbsp;programovacím jazyku <i>Clojure</i> však
naproti tomu nebylo nutné zavádět speciální syntaxi a vlastně ani nebylo nutné
zasahovat do překladače. Celá knihovna <strong>core.async</strong>, která
nabízí podobný koncept, jako jazyk Go, je založena na několika běžných funkcích
a hlavně pak na makrech, které manipulací s&nbsp;předaným programovým kódem
dokážou z&nbsp;běžného příkazového bloku vytvořit blok zpracovávaný asynchronně
(opět se zde ukazuje přednost homoikonických jazyků). Použít ji lze dokonce i
v&nbsp;<i>ClojureScriptu</i>, tedy v&nbsp;implementaci jazyka <i>Clojure</i>
postavené nad mnohdy &bdquo;jednovláknovým&ldquo; JavaScriptem.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto kontextu je dobré
rozlišovat mezi pojmy <i>concurrency</i> a <i>parallelism</i>, které se mnohdy
překládají stejně &ndash; <i>souběžnost</i>. Pěkně je rozdíl mezi těmito pojmy
popsán <a href="https://blog.golang.org/concurrency-is-not-parallelism">na
tomto videu</a>. Slajdy k&nbsp;videu jsou dostupné na adrese <a
href="https://talks.golang.org/2012/waza.slide#1">Concurrency is not
Parallelism</a>; důležitý je především <a
href="https://talks.golang.org/2012/waza.slide#8">osmý slajd</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Communicating Sequential Processes</h2>

<p>Použití asynchronních kanálů a z&nbsp;nich odvozených asynchronních
vstupně-výstupních operací (<i>async I/O</i>), se mezi širší programátorskou
komunitu rozšířilo pravděpodobně až s&nbsp;vývojem známého systému <a
href="https://nodejs.org/en/">Node.js</a>. Ve skutečnosti je však realizovaný
princip mnohem starší, protože sahá až do šedesátých a sedmdesátých let
minulého století, kdy se postupně vyvíjely metody umožňující lepší využití
strojového času tehdejších počítačů (lepším využitím se zde nutně nemyslí
škálovatelnost!). Za strojový čas se tehdy samozřejmě platilo, což přeneseně
platí (sic) i dnes. Poznatky vypracovávané v&nbsp;šedesátých a sedmdesátých
letech byly formalizovány a následně shrnuty do teorie popsané ve známém článku
<i>Communicating Sequential Processes</i>, jejímž autorem je C.A.R Hoare.
Zmíněný článek byl vydán již v&nbsp;roce 1978 a kvůli jeho oblibě a známosti se
mnohdy setkáme pouze se zkratkou <i>CSP</i>. CSP měl velký vliv na design
několika programovacích jazyků, mezi jinými i jazyka <i>occam</i> a nepřímo i
jazyků Limbo, Go a Crystal.</p>

<p><div class="rs-tip-major">Poznámka: elektronickou a rozšířenou verzi CSP
(nikoli původní článek) lze získat ze stránky <a
href="http://www.usingcsp.com/">http://www.usingcsp.com/</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Konstrukce používané v&nbsp;moderních implementacích odvozených od CSP</h2>

<p>Moderní implementace CSP je většinou založena na dvou základních
konstrukcích podporovaných buď přímo v&nbsp;programovacím jazyku nebo
v&nbsp;jeho knihovně (popř.&nbsp;s&nbsp;využitím makrosystému daného jazyka).
Jedná se o již zmíněné kanály, které lze v&nbsp;některých případech
nakonfigurovat takovým způsobem, že fungují jako fronty či buffery
(nejjednodušší kanál vlastnosti fronty nemá, proto jsou všechny operace nad ním
blokující, někdy se přeneseně a poněkud nepřesně používá označení
<i>mailbox</i>). Pro operace s&nbsp;kanály je typicky deklarováno několik
funkcí či jazykových konstrukcí: vytvoření kanálu, zavření kanálu, zápis dat,
čtení dat, čtení dat z&nbsp;libovolného kanálu, čtení dat s&nbsp;určením
priority jednotlivých kanálů atd. Kanál lze použít i jako takzvané
synchronizační primitivum a jak uvidíme dále, některé speciální kanály lze
použít například i pro pouhé pozastavení výpočtu. Druhou konstrukcí jsou
většinou takzvané <i>go bloky</i> (ostatně stejně se jmenují i v&nbsp;knihovně
<i>libmill</i>).</p>

<p>Kanály umožňují snadno realizovat například konstrukci typu
<i>producent&ndash;konzument</i>:</p>

<pre>
+-----------+                              +-----------+
| producent |           +-----+            | konzument |
|           |... &gt;! ... |kanál} ... &lt;! ... |           |
| go block  |           +-----+            | go block  |
+-----------+                              +-----------+
</pre>

<p><div class="rs-tip-major">Poznámka: to ovšem nemusí nutně znamenat, že
producent a konzument musí za všech okolností skutečně běžet zcela paralelně.
Souběh (<i>concurrency</i>) totiž lze zajistit i na jednovláknovém
mikroprocesoru.</div></p>

<p>Kanál může být využíván více producenty (i konzumenty), takže se původní
schéma změní následovně:</p>

<pre>
+-----------+ 
| producent |
|     #1    |... &gt;!.........
| go block  |              :
+-----------+              :
                           :
+-----------+              :               +-----------+
| producent |           +-----+            | konzument |
|     #2    |... &gt;! ... |kanál} ... &lt;! ... |           |
| go block  |           +-----+            | go block  |
+-----------+              :               +-----------+
                           :
+-----------+              :
| producent |              :
|     #3    |... &gt;!........:
| go block  |
+-----------+
</pre>

<p>Náhodný výběr je zde důležitý, protože pokud by se kanály neustále vybíraly
podle uvedeného pořadí, mohlo by docházet k&nbsp;efektu, který je znám pod
termínem &bdquo;vyhladovění&ldquo; (starvation) u těch kanálů, které se ve
vektoru nachází na posledních pozicích. Kromě dvou již uvedených schémat tedy
ještě přibývá třetí schéma + všechny jeho varianty:</p>

<pre>
+-----------+ 
| producent |           +------+
|     #1    |... &gt;!.....|kanál1}.......
| go block  |           +------+      :
+-----------+                         :
                                      :
+-----------+                         :        +-----------+
| producent |           +------+      :        | konzument |
|     #2    |... &gt;! ... |kanál2} ... alts! ... |           |
| go block  |           +------+      :        | go block  |
+-----------+                         :        +-----------+
                                      :
+-----------+                         :
| producent |           +------+      :
|     #3    |... &gt;!.....|kanál3}......:
| go block  |           +------+
+-----------+
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Kanály a gorutiny v&nbsp;programovacím jazyce Go</h2>

<p>Nejprve se před popisem možností nabízených knihovnou <i>libmill</i>
podívejme na to, jak je problematika kanálů a gorutin řešena
v&nbsp;programovacím jazyce Go. V&nbsp;Go se gorutiny vytváří a volají velmi
snadno &ndash; s&nbsp;použitím klíčového slova <strong>go</strong>.
V&nbsp;následujícím příkladu je ukázáno, jak lze dvakrát zavolat funkci
<strong>message</strong>, a to pokaždé v&nbsp;samostatné gorutině běžící
nezávisle na gorutině hlavní (<strong>main</strong>). Ve skutečnosti je však
velmi pravděpodobné, že se tato funkce v&nbsp;praxi nestihne zavolat ani
jednou, protože mezitím dojde k&nbsp;ukončení hlavní gorutiny a tím pádem i
k&nbsp;ukončení činnosti celé aplikace:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>message</strong>(id int) {
        fmt.Printf("gorutina %d\n", id)
}
&nbsp;
func <strong>main</strong>() {
        fmt.Println("main begin")
        go message(1)
        go message(2)
        fmt.Println("main end")
}
</pre>

<p>Ve druhém příkladu je použit <i>kanál</i> sloužící jako komunikační médium
mezi dvěma gorutinami, konkrétně mezi gorutinou hlavní a gorutinou
představovanou funkcí <strong>message</strong>. Hlavní gorutina kanál vytvoří,
otevře a následně čeká, až do něj druhá gorutina provede zápis. Pro zápis i
čtení z&nbsp;kanálu, což jsou potenciálně blokující operace, slouží
v&nbsp;programovacím jazyce Go specializované operátory:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>message</strong>(id int, channel chan int) {
        fmt.Printf("gorutina %d\n", id)
        channel &lt;- 1
}
&nbsp;
func <strong>main</strong>() {
        channel := make(chan int)
&nbsp;
        fmt.Println("main begin")
        go message(1, channel)
&nbsp;
        fmt.Println("waiting...")
&nbsp;
        code, status := &lt;-channel
&nbsp;
        fmt.Printf("received code: %d and status: %t\n", code, status)
        fmt.Println("main end")
}
</pre>

<p>Ve třetím příkladu je ukázáno řešení klasické úlohy producent-konzument,
v&nbsp;níž konzument (nebo taktéž <i>worker</i>) běží ve vlastní gorutině,
zpracovává data posílaná do kanálu <strong>taskChannel</strong> a ve chvíli,
kdy je tento kanál zavřený, ukončí se. Ovšem ještě předtím o svém ukončení
informuje producenta, a to zápisem zprávy do kanálu nazvaného
<strong>workerDone</strong>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>worker</strong>(taskChannel chan int, workerDone chan bool) {
        fmt.Println("worker started")
        for {
                value, more := &lt;-taskChannel
                if more {
                        fmt.Printf("worker received task with parameter %d\n", value)
                } else {
                        fmt.Println("finishing worker")
                        workerDone &lt;- true
                        fmt.Println("worker finished")
                        return
                }
        }
}
&nbsp;
func <strong>main</strong>() {
        taskChannel := make(chan int)
        workerDone := make(chan bool)
&nbsp;
        fmt.Println("main begin")
&nbsp;
        go worker(taskChannel, workerDone)
&nbsp;
        for i := 1; i &lt;= 10; i++ {
                fmt.Printf("sending task with parameter %d\n", i)
                taskChannel &lt;- i
        }
        close(taskChannel)
&nbsp;
        fmt.Println("waiting for workers...")
&nbsp;
        code, status := &lt;-workerDone
&nbsp;
        fmt.Printf("received code: %t and status: %t\n", code, status)
        fmt.Println("main end")
}
</pre>

<p>V&nbsp;příkladu následujícím je ukázáno jednoduché použití jazykové
konstrukce <strong>select-case</strong> při čekání na data, která mohou být
poslána do jednoho ze dvou kanálů ch1 a ch2. V&nbsp;tomto programu jsou
nejdříve vytvořeny dva kanály. Následně jsou spuštěny dvě gorutiny,
z&nbsp;nichž první pošle data do prvního kanálu ch1 a druhá do druhého kanálu
ch2. Nakonec v&nbsp;programové konstrukci <strong>select-case</strong> počkáme
na to, až jsou data dostupná v&nbsp;libovolném z&nbsp;těchto kanálů (teoreticky
ani nemusíme jeden z&nbsp;workerů-gorutin spouštět):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func <strong>worker</strong>(channel chan int, worker int) {
        fmt.Printf("Worker %d spuštěn\n", worker)
        time.Sleep(2 * time.Second)
        channel &lt;- 1
        fmt.Printf("Worker %d ukončen\n", worker)
}
&nbsp;
func <strong>main</strong>() {
        ch1 := make(chan int)
        ch2 := make(chan int)
&nbsp;
        go worker(ch1, 1)
        go worker(ch2, 2)
&nbsp;
        for true {
                select {
                case &lt;-ch1:
                        fmt.Println("Data z kanálu 1")
                case &lt;-ch2:
                        fmt.Println("Data z kanálu 2")
                default:
                        fmt.Println("Žádná data nejsou k dispozici")
                }
                time.Sleep(1 * time.Second)
        }
}
</pre>

<p>V&nbsp;posledním demonstračním příkladu, v&nbsp;němž použijeme konstrukci
<strong>select-case</strong>, zkombinujeme jak čtení, tak i zápis do různých
kanálů. I tuto kombinaci je možné v&nbsp;programovacím jazyku Go bez větších
problémů použít. V&nbsp;konstrukci <strong>select-case</strong> se vybere vždy
pouze jediná větev v&nbsp;závislosti na tom, zda jsou v&nbsp;prvních dvou
kanálech data popř.&nbsp;zda jsou druhé dva kanály prázdné či obsazené.</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "time"
)
&nbsp;
func <strong>receiver</strong>(channel chan int, receiver int) {
        for true {
                value, ok := &lt;-channel
                if ok {
                        fmt.Printf("Příjemce %d přijal hodnotu %d\n", receiver, value)
                } else {
                        fmt.Printf("Kanál je pro příjemce %d uzavřen\n", receiver)
                }
                time.Sleep(2 * time.Second)
        }
}
&nbsp;
func <strong>sender</strong>(channel chan int, sender int) {
        fmt.Printf("Odesílatel %d byl spuštěn\n", sender)
        for i := 1; i &lt;= 5; i++ {
                time.Sleep(1 * time.Second)
                channel &lt;- i
        }
        fmt.Printf("Odesílatel %d byl ukončen\n", sender)
}
&nbsp;
func <strong>main</strong>() {
        ch1 := make(chan int)
        ch2 := make(chan int)
        ch3 := make(chan int)
        // ch1 := make(chan int, 20)
&nbsp;
        go receiver(ch1, 1)
        go receiver(ch1, 2)
        go sender(ch2, 1)
        go sender(ch3, 2)
&nbsp;
        for i := 0; i &lt; 20; i++ {
                select {
                case ch1 &lt;- 0:
                        fmt.Println("Poslána nula")
                case ch1 &lt;- 1:
                        fmt.Println("Poslána jednička")
                case data, ok := &lt;-ch2:
                        if ok {
                                fmt.Printf("Přijata data %d z kanálu 2\n", data)
                        }
                case data, ok := &lt;-ch3:
                        if ok {
                                fmt.Printf("Přijata data %d z kanálu 3\n", data)
                        }
                }
        }
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Implementace kanálů a go-bloků v&nbsp;jazyce Clojure</h2>

<p>Nyní se podívejme na způsob implementace kanálů a go-bloku
v&nbsp;programovacím jazyce Clojure. Zde se namísto nových klíčových slov a
nových jazykových konstrukcí používají převážně makra.</p>

<p>V&nbsp;prvním demonstračním příkladu je vytvořen producent, který do kanálu
postupně posílá sekvenci čísel 0 až 9, přičemž mezi čísly je určitý čekací
interval simulující nějaký výpočet či I/O operaci. Konzument je naproti tomu
realizován nekonečnou smyčkou čekající na data z&nbsp;kanálu.  Pro
<strong>go</strong> bloky je typické právě použití smyček, ovšem lze použít i
<strong>go-loop</strong> atd.:</p>

<pre>
(<strong>ns</strong> async1.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;!])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 15000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanal</i>
    (<strong>let</strong> [channel (chan)]
        <i>; kontinualni posilani zprav do kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (dotimes [i 10]
                (Thread/sleep 1000)
                (&gt;! channel i)))
&nbsp;
        (println "1st go block started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (println (&lt;! channel))))
&nbsp;
        (println "2nd go block started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish"))
</pre>

<p>Ve skutečnosti není použití <strong>(Thread/sleep 1000)</strong> příliš
idiomatické. Mnohem lepší je použití speciálního kanálu vytvořeného zavoláním
<strong>(timeout x)</strong>. Tento kanál je po uplynutí určeného časového
intervalu automaticky uzavřen. Co to znamená? Pokud z&nbsp;kanálu pouze čteme,
jedná se o blokující operaci (to již víme), ovšem po uplynutí určeného času je
kanál uzavřen a vrátí se hodnota <strong>nil</strong>. Čtením z&nbsp;kanálu
typu <strong>timeout</strong> tedy můžeme elegantně realizovat efektivně
implementované čekání. Upravený producent vypadá takto:</p>

<pre>
<i>; kontinualni posilani zprav do kanalu v asynchronnim bloku</i>
(<strong>go</strong>
    (dotimes [i 10]
        <i>;(Thread/sleep 1000)</i>
        (&lt;! (timeout 1000))
        (&gt;! channel i)))
</pre>

<p>Kanál může být pochopitelně využíván více producenty (i konzumenty). Toto
uspořádání je samozřejmě v&nbsp;jazyce Clojure plně podporováno, o čemž nás
přesvědčí další programový kód s&nbsp;trojicí producentů a jediným konzumentem,
který vypadá následovně:</p>

<pre>
(<strong>ns</strong> async2.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;! timeout)])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 10000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanal</i>
    (<strong>let</strong> [channel (chan)]
        <i>; kontinualni posilani zprav do kanalu v trojici asynchronnich bloku</i>
        (<strong>go</strong>
            (while true
                (&lt;! (timeout 500))
                (&gt;! channel "first")))
&nbsp;
        (<strong>go</strong>
            (while true
                (&lt;! (timeout 1000))
                (&gt;! channel "second")))
&nbsp;
        (<strong>go</strong>
            (while true
                (&lt;! (timeout 2000))
                (&gt;! channel "third")))
&nbsp;
        (println "producers started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (println (&lt;! channel))))
&nbsp;
        (println "consumer started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish")
    (System/exit 0))
</pre>

<p>Použití většího množství producentů jsme si již ukázali v&nbsp;předchozím
příkladu. Nyní si řekněme, jak může jediný konzument načítat data
z&nbsp;většího množství kanálů. To je možné, ovšem namísto operace &lt;! se
použije funkce <strong>alts!</strong>, které se předá vektor kanálů. Funkce
<strong>alts!</strong> ve výchozím nastavení <i>náhodně</i> vybere kanál, ze
kterého bude číst. Náhodný výběr je zde důležitý, protože pokud by se kanály
neustále vybíraly podle uvedeného pořadí, mohlo by docházet k&nbsp;efektu,
který je znám pod termínem &bdquo;vyhladovění&ldquo; (<i>starvation</i>) u těch
kanálů, které se ve vektoru nachází na posledních pozicích.</p>

<p>Funkce <strong>alts!</strong> je použita ve třetím demonstračním příkladu.
Povšimněte si, že návratovou hodnotou této funkce je dvojice, protože je nutné
nějakým způsobem vrátit jak referenci na kanál, ze kterého se čte, tak i
vlastní přečtenou hodnotu. My referenci na kanál použijeme ve výstupu pro
určení tisknutého prefixu:</p>

<pre>
(<strong>ns</strong> async3.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;! timeout alts!)])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 10000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanaly</i>
    (<strong>let</strong> [channel1 (chan)
          channel2 (chan)
          channel3 (chan)]
&nbsp;
        <i>; kontinualni posilani zprav do trech kanalu v trojici asynchronnich bloku</i>
        (<strong>go</strong>
            (doseq [i (range)]
                (&lt;! (timeout 500))
                (&gt;! channel1 i)))
&nbsp;
        (<strong>go</strong>
            (doseq [i (range)]
                (&lt;! (timeout 1000))
                (&gt;! channel2 i)))
&nbsp;
        (<strong>go</strong>
            (doseq [i (range)]
                (&lt;! (timeout 2000))
                (&gt;! channel3 i)))
&nbsp;
        (println "producers started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (<strong>let</strong> [[item channel] (alts! [channel1 channel2 channel3])]
                    (condp = channel
                        channel1 (println "channel #1: " item)
                        channel2 (println "channel #2: " item)
                        channel3 (println "channel #3: " item)))))
&nbsp;
        (println "consumer started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish")
    (System/exit 0))
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Knihovna <strong>libmill</strong> se představuje</h2>

<p>Nejprve malé shrnutí: viděli jsme, že jak v&nbsp;jazyce Go, tak i ve zcela
odlišně pojatém programovacím jazyce Clojure, existuje několik užitečných
technologií:</p>

<ol>
<li>Koncept korutin či gorutin</li>
<li>Kanály jako komunikační médium mezi gorutinami</li>
<li>Možnost číst či zapisovat do jednoho kanálu z&nbsp;nabízeného seznamu/vektoru na základě toho, který kanál je připravený</li>
</ol>

<p>Všechny tyto tři technologie nalezneme i v&nbsp;knihovně
<strong>libmill</strong>. Způsob implementace se však nutně odlišuje.
V&nbsp;jazyce Go je práce s&nbsp;gorutinami součástí vlastního jazyka,
v&nbsp;Clojure se jedná o systém funkcí a maker a v&nbsp;případě knihovny
libmill je použit stejně znějící, ovšem interně zcela odlišný mechanismus
založený taktéž na specializovaných funkcích a značně složitých makrech
preprocesoru programovacího jazyka C. Ovšem z&nbsp;hlediska programátora se
zejména Go a libmill značně podobá: stačí se podívat na porovnání uvedené přímo
na stránce <a href="http://libmill.org/">http://libmill.org/</a>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Překlad knihovny <strong>libmill</strong></h2>

<p>Nejprve je pochopitelně nutné knihovnu <strong>libmill</strong>
nainstalovat. To je snadné, budete přitom potřebovat jen základní sadu
nástrojů, které má většinou k&nbsp;dispozici prakticky každý céčkový vývojář
&ndash; překladač, linker, program <strong>make</strong>, nechvalně známé
autotools (autoconf) atd.</p>

<p>V&nbsp;prvním kroku stáhneme zdrojové kódy knihovny:</p>

<pre>
$ <strong>curl http://libmill.org/libmill-1.18.tar.gz</strong>
</pre>

<p>V&nbsp;kroku druhém rozbalíme získaný tarball:</p>

<pre>
$ <strong>tar xvfz libmill-1.18.tar.gz</strong>
</pre>

<p>Provedeme konfiguraci programu:</p>

<pre>
$ <strong>cd libmill-1.18</strong>
&nbsp;
$ <strong>./configure</strong>
&nbsp;
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
...
...
...
config.status: creating Makefile
config.status: creating libmill.pc
config.status: executing depfiles commands
config.status: executing libtool commands
</pre>

<p>Následuje překlad s&nbsp;využitím utility <strong>make</strong>:</p>

<pre>
$ <strong>make</strong>
&nbsp;
  CC       libmill_la-chan.lo
  CC       libmill_la-cr.lo
  CC       libmill_la-debug.lo
  CC       libmill_la-ip.lo
  CC       libmill_la-list.lo
  CC       libmill_la-mfork.lo
  ...
  ...
  ...
  CC       tutorial/step6.o
  CCLD     tutorial/step6
  CC       tutorial/step7.o
  CCLD     tutorial/step7
  CC       tutorial/step8.o
  CCLD     tutorial/step8
</pre>

<p>Výsledkem by měl být (mj.) i podadresář <strong>.libs</strong> obsahující
statickou i dynamickou variantu knihovny <strong>libmill</strong>.</p>

<p>Můžeme provést i instalaci knihovny a jejích hlavičkových soubor, nyní ovšem
s&nbsp;právy superuživatele:</p>

<pre>
$ <strong>sudo make install</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: kromě vlastní knihovny se přeloží i sada
testovacích a demonstračních příkladů, které si pochopitelně můžete odzkoušet.
Naleznete je v&nbsp;podadresáři <strong>tutorial</strong>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vytvoření a zavolání korutin</h2>

<p>Základním úkolem, v&nbsp;němž knihovnu <i>libmill</i> využijeme, bude
přepsání následujícího prográmku takovým způsobem, aby se funkce
<strong>foo</strong> a <strong>bar</strong> zavolaly každá ve své vlastní
korutině:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
void <strong>foo</strong>() {
    puts("foo");
}
&nbsp;
void <strong>bar</strong>() {
    puts("bar");
}
&nbsp;
int <strong>main</strong>(void) {
    foo();
    bar();
    return 0;
}
</pre>

<p>Prvním přiblížením může být použití makra <strong>go</strong>, které má
podobný význam, jako stejně pojmenované klíčové slovo <strong>go</strong>
v&nbsp;programovacím jazyce Go. Makro <strong>go</strong> se zapisuje podobně
jako volání funkce, ovšem samotné volání je provedeno (v&nbsp;obecném případě)
souběžně:</p>

<pre>
#include &lt;stdio.h&gt;
#include "libmill.h"
&nbsp;
void <strong>foo</strong>() {
    puts("foo");
}
&nbsp;
void <strong>bar</strong>() {
    puts("bar");
}
&nbsp;
int <strong>main</strong>(void) {
    <u>go</u>(foo());
    <u>go</u>(bar());
    return 0;
}
</pre>

<p>Ve skutečnosti však není výše uvedený kód za všech okolností korektní,
protože korutiny pracují s&nbsp;vlastními daty atd. Pro zcela korektní chování
je nutné před funkce volané v&nbsp;korutinách přidat slovo
<strong>coroutine</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
#include "libmill.h"
&nbsp;
<u>coroutine</u> void <strong>foo</strong>() {
    puts("foo");
}
&nbsp;
<u>coroutine</u> void <strong>bar</strong>() {
    puts("bar");
}
&nbsp;
int <strong>main</strong>(void) {
    <u>go</u>(foo());
    <u>go</u>(bar());
    return 0;
}
</pre>

<p>Překlad tohoto příkladu se provede způsobem:</p>

<pre>
$ <strong>gcc test1.c -lmill -L{cesta_k_přeložené_knihovně_libmill}</strong>
</pre>

<p>Před spuštěním je nutné zajistit, aby se našla dynamicky linkovaná knihovna
<strong>libmill</strong>:</p>

<pre>
$ <strong>export LD_LIBRARY_PATH={cesta_k_přeložené_knihovně_libmill}</strong>
$ <strong>./a.out </strong>
</pre>

<p>Pro zajímavost se můžete podívat na to, jak vlastně program vypadá po
zpracování preprocesorem:</p>

<pre>
$ <strong>cpp test1.c</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: výsledek zde ukazovat nebudu, neboť je
obrovský a prakticky nečitelný. Důležité je si jen uvědomit, že samotné použití
makra <strong>go</strong> není interně zcela triviální.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vytvoření většího množství korutin bez vzájemné synchronizace</h2>

<p>Nic nám pochopitelně nebrání použít jednu a tu samou funkci ve více
korutinách, což je ukázáno v&nbsp;následujícím demonstračním příkladu:</p>

<pre>
#include &lt;stdio.h&gt;
#include "libmill.h"
&nbsp;
<u>coroutine</u> void <strong>print</strong>(char what) {
    putchar(what);
}
&nbsp;
int <strong>main</strong>(void) {
    char ch;
    for (ch='a'; ch&lt;='z'; ch++) {
        <u>go</u>(print(ch));
    }
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: tento demonstrační příklad nebude po
překladu a spuštění fungovat tak, jak očekáváte, protože se v&nbsp;korutinách
používají I/O operace a navíc se vlastní způsob práce s&nbsp;korutinami
v&nbsp;knihovně <i>libmill</i> odlišuje od jazyka Go. Obecně platí, že I/O
operace jsou nějakým způsobem serializovány, a to na úrovni, která je mimo
dosah knihovny <i>libmill</i>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Koncept <i>deadline</i></h2>

<p>V&nbsp;knihovně <i>libmill</i> se setkáme i s&nbsp;konceptem
<i>deadline</i>. Jedná se o absolutní časový údaj určující, v&nbsp;jakém
okamžiku by měla být nějaká činnost ukončena. V&nbsp;jiných knihovnách se
většinou setkáme spíše s&nbsp;<i>timeoutem</i>, což je relativní časový údaj,
tedy za jak dlouho by měla být činnost ukončena. Rozdíly mezi oběma koncepty
jsou většinou z&nbsp;pohledu konstrukce programu minimální (jen si to nesmíme
poplést). Příkladem použití <i>timeoutu</i> může být standardní funkce:</p>

<pre>
unsigned int <strong>sleep</strong>(unsigned int seconds);
</pre>

<p>V&nbsp;této funkci se parametrem specifikuje, na jak dlouho má být aktuální
vlákno uspáno, což znamená, že pokud budeme vždy volat tuto funkci
s&nbsp;parametrem 1, bude vlákno uspáno na přibližně jednu sekundu, nezávisle
na tom, zda byla funkce zavolána nyní, či před hodinou.</p>

<p>Naproti tomu v&nbsp;knihovně <i>libmill</i> existuje funkce:</p>

<pre>
void <strong>msleep</strong>(int64_t deadline);
</pre>

<p>V&nbsp;níž se určuje absolutní čas zadaný v&nbsp;tomto případě pro větší
přesnost v&nbsp;milisekundách. Pokud budeme chtít (v&nbsp;tomto případě
korutinu) uspat na jednu sekundu, je následující volání špatně, protože 1000
znamená absolutní čas, konkrétně jednu sekundu na samotném počátku epochy:</p>

<pre>
<strong>msleep</strong>(1000);
</pre>

<p>Korektní volání by mělo používat funkci <strong>now()</strong> vracející
aktuální čas:</p>

<pre>
<strong>msleep</strong>(now() + 1000);
</pre>

<p>Použití <i>deadline</i> si můžeme ukázat na následujícím příkladu, který
většinou skončí dříve, než stačí korutiny vypsat všechny znaky:</p>

<pre>
#include &lt;stdio.h&gt;
#include "libmill.h"
&nbsp;
<u>coroutine</u> <strong>void</strong> print(char what) {
    <u>msleep</u>(now() + 1000);
    putchar(what);
}
&nbsp;
int <strong>main</strong>(void) {
    char ch;
    for (ch='a'; ch&lt;='z'; ch++) {
        <u>go</u>(print(ch));
    }
    return 0;
}
</pre>

<p>Další, tentokrát nepatrně složitější příklad, v&nbsp;němž je čekání vloženo
i do hlavní korutiny:</p>

<pre>
#include &lt;stdio.h&gt;
#include "libmill.h"
&nbsp;
<u>coroutine</u> void <strong>print</strong>(char what) {
    int i;
&nbsp;
    for (i=0; i&lt;10; i++) {
        <u>msleep</u>(now() + 100);
        putchar(what);
    }
}
&nbsp;
int <strong>main</strong>(void) {
    char ch;
    for (ch='a'; ch&lt;='z'; ch++) {
        <u>go</u>(print(ch));
    }
    <u>msleep</u>(now() + 200);
    return 0;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přepnutí běhu na jinou korutinu</h2>

<p>V&nbsp;knihovně <i>libmill</i> nalezneme i funkci:</p>

<pre>
void <strong>yield</strong>(void);
</pre>

<p>V&nbsp;případě, že je tato funkce zavolána v&nbsp;nějaké korutině, provede
se přepnutí kontextu na jinou korutinu a stávající korutina je pozastavena:</p>

<pre>
#include &lt;stdio.h&gt;
#include "libmill.h"
&nbsp;
<u>coroutine</u> void <strong>print</strong>(char what) {
    int i;
&nbsp;
    for (i=0; i&lt;10; i++) {
        putchar(what);
        <u>yield</u>();
        <u>msleep</u>(now() + 100);
    }
}
&nbsp;
int <strong>main</strong>(void) {
    char ch;
    for (ch='a'; ch&lt;='z'; ch++) {
        <u>go</u>(print(ch));
    }
    <u>msleep</u>(now() + 200);
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: chování funkce <strong>yield</strong> se
poněkud odlišuje například od klíčového slova <strong>yield</strong>, které je
použito v&nbsp;Pythonu. Základní myšlenka je však podobná &ndash; pozastavení
vykonávání aktuálního kódu a přepnutí kontextu do kódu jiného.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/
concurrency-demos">https://github.com/tisnik/concurrency-demos</a> (stále na
GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je
ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má přibližně jednotky
kilobajtů), můžete namísto toho použít odkazy na jednotlivé demonstrační
příklady, které naleznete v&nbsp;následující tabulce:</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Libmill: Go-style concurrency in C<br />
<a href="http://libmill.org/">http://libmill.org/</a>
</li>

<li>Libmill na GitHubu<br />
<a href="https://github.com/sustrik/libmill">https://github.com/sustrik/libmill</a>
</li>

<li>libdill: Structured Concurrency for C<br />
<a href="http://libdill.org/">http://libdill.org/</a>
</li>

<li>libdill na GitHubu<br />
<a href="https://github.com/sustrik/libdill">https://github.com/sustrik/libdill</a>
</li>

<li>Libdill: Structured Concurrency for C (2016)<br />
<a href="https://news.ycombinator.com/item?id=15977983">https://news.ycombinator.com/item?id=15977983</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async<br />
<a href="https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (pokračování)<br />
<a href="https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Communicating sequential processes (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">https://en.wikipedia.org/wiki/Communicating_sequential_processes</a>
</li>

<li>Go Block Best Practices<br />
<a href="https://www.clojure.org/guides/core_async_go">https://www.clojure.org/guides/core_async_go</a>
</li>

<li>Clojure core.async and Go: A Code Comparison<br />
<a href="https://blog.drewolson.org/clojure-go-comparison">https://blog.drewolson.org/clojure-go-comparison</a>
</li>

<li>core.async API Reference<br />
<a href="https://clojure.github.io/core.async/">https://clojure.github.io/core.async/</a>
</li>

<li>Clojure core.async Channels<br />
<a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html</a>
</li>

<li>FLOSS Weekly 358: Libmill<br />
<a href="https://www.youtube.com/watch?v=zUDhcN-8oQo">https://www.youtube.com/watch?v=zUDhcN-8oQo</a>
</li>

<li>Structured Concurrency Finding our way out of callback hell<br />
<a href="https://www.youtube.com/watch?v=llYv1AitDH8">https://www.youtube.com/watch?v=llYv1AitDH8</a>
</li>

<li>Go part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Go part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Communicating Sequential Processes. The First 25 Years<br />
<a href="https://www.springer.com/gp/book/9783540258131">https://www.springer.com/gp/book/9783540258131</a>
</li>

<li>Dokumentace k&nbsp;Pythonovské knihovně goless<br />
<a href="https://goless.readthedocs.io/en/latest/">https://goless.readthedocs.io/en/latest/</a>
</li>

<li>Coroutine<br />
<a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Coroutine z&nbsp;Boostu<br />
<a href="https://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/index.html">https://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/index.html</a>
</li>

<li>Coroutine2 z&nbsp;Boostu<br />
<a href="https://www.boost.org/doc/libs/1_61_0/libs/coroutine2/doc/html/index.html">https://www.boost.org/doc/libs/1_61_0/libs/coroutine2/doc/html/index.html</a>
</li>

<li>Concurrency is not parallelism<br />
<a href="https://blog.golang.org/concurrency-is-not-parallelism">https://blog.golang.org/concurrency-is-not-parallelism</a>
</li>

<li>Why is node.js asynchronous?<br />
<a href="https://stackoverflow.com/questions/17607280/why-is-node-js-asynchronous">https://stackoverflow.com/questions/17607280/why-is-node-js-asynchronous</a>
</li>

<li>Stránka projektu node.js<br />
<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>
</li>

<li>CSP (elektronická podoba)<br />
<a href="http://www.usingcsp.com/">http://www.usingcsp.com/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

