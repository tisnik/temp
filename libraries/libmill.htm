<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. Knihovna <strong>libmill</strong> se představuje</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>Knihovny či nové jazykové konstrukce umožňující používání kanálů (či front) pro asynchronní komunikaci mezi různými částmi vyvíjených aplikací, se v&nbsp;posledních několika letech těší poměrně velké popularitě. Ta je způsobena dvěma faktory. První důvod spočívá ve snaze o zjednodušení návrhu (či porozumění) vyvíjené aplikace, zejména ve chvíli, kdy se v&nbsp;rámci jednoho programu předávají data (resp.&nbsp;objekty) mezi částmi, jejichž funkce může být dobře izolována od částí ostatních. Druhý důvod je poněkud prozaičtější &ndash; v&nbsp;některých situacích je nutné dosáhnout zvýšení efektivity aplikace (například zvýšit počet odpovědí, které může server vygenerovat za určitou časovou jednotku) a přitom není možné či vhodné využívat řešení založené na použití většího množství vláken spravovaných systémem. Naprosto typickým příkladem jsou virtuální stroje JavaScriptu, které povětšinou umožňují běh aplikace v&nbsp;jediném vláknu (což je ovšem s&nbsp;ohledem na &bdquo;kvalitu&ldquo; některých programových kódů spíše výhodou...).</p>

<p>Některé programovací jazyky, zejména pak jazyk <i>Go</i>, obsahují prostředky sloužící pro zajištění asynchronní komunikace přímo v&nbsp;syntaxi (a samozřejmě též v&nbsp;sémantice) jazyka. Konkrétně v&nbsp;případě jazyka <i>Go</i> se jedná o takzvané &bdquo;gorutiny&ldquo; představované klíčovým slovem <strong>go</strong> a taktéž o operace sloužící pro zápis či čtení dat z&nbsp;kanálů, které jsou představovány operátorem <strong>&lt;-</strong> (ten má dva významy v&nbsp;závislosti na tom, zda je před operátorem uveden identifikátor představující kanál či nikoli). V&nbsp;programovacím jazyku <i>Clojure</i> však naproti tomu nebylo nutné zavádět speciální syntaxi a vlastně ani nebylo nutné zasahovat do překladače. Celá knihovna <strong>core.async</strong> je založena na několika běžných funkcích a hlavně pak na makrech, které manipulací s&nbsp;předaným programovým kódem dokážou z&nbsp;běžného příkazového bloku vytvořit blok zpracovávaný asynchronně (opět se zde ukazuje přednost homoikonických jazyků). Použít ji lze dokonce i v&nbsp;<i>ClojureScriptu</i>, tedy v&nbsp;implementaci jazyka <i>Clojure</i> postavené nad &bdquo;jednovláknovým&ldquo; JavaScriptem.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

<p>Použití asynchronních kanálů a z&nbsp;nich odvozených asynchronních vstupně-výstupních operací (<i>async I/O</i>), se mezi širší programátorskou komunitu rozšířilo pravděpodobně až s&nbsp;vývojem známého systému <a href="https://nodejs.org/en/">Node.js</a>. Ve skutečnosti je však realizovaný princip mnohem starší, protože sahá až do šedesátých a sedmdesátých let minulého století, kdy se postupně vyvíjely metody umožňující lepší využití strojového času tehdejších počítačů (lepším využitím se zde nutně nemyslí škálovatelnost!). Za strojový čas se tehdy samozřejmě platilo, což přeneseně platí i dnes. Poznatky vypracovávané v&nbsp;šedesátých a sedmdesátých letech byly formalizovány a následně shrnuty do teorie popsané ve známém článku <i>Communicating Sequential Processes</i>, jejímž autorem je C.A.R Hoare. Ten byl vydán již v&nbsp;roce 1978 a kvůli jeho oblibě a známosti se mnohdy setkáme pouze se zkratkou <i>CSP</i>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. </h2>

<p>Moderní implementace CSP je většinou založena na dvou základních konstrukcích. Jedná se o již zmíněné kanály, které lze v&nbsp;některých případech nakonfigurovat takovým způsobem, že fungují jako fronty či buffery (nejjednodušší kanál vlastnosti fronty nemá, proto jsou všechny operace nad ním blokující). Pro operace s&nbsp;kanály je typicky deklarováno několik funkcí či jazykových konstrukcí: vytvoření kanálu, zavření kanálu, zápis dat, čtení dat, čtení dat z&nbsp;libovolného kanálu, čtení dat s&nbsp;určením priority jednotlivých kanálů atd. Kanál lze použít i jako takzvané synchronizační primitivum a jak uvidíme dále, některé speciální kanály lze použít například i pro pouhé pozastavení výpočtu. Druhou konstrukcí jsou většinou takzvané <i>go bloky</i>.</p>

<p>Ty umožňují snadno realizovat například konstrukci typu <i>producent&ndash;konzument</i>:</p>

<pre>
+-----------+                              +-----------+
| producent |           +-----+            | konzument |
|           |... &gt;! ... |kanál} ... &lt;! ... |           |
| go block  |           +-----+            | go block  |
+-----------+                              +-----------+
</pre>

<p>Kanál může být využíván více producenty (i konzumenty), takže se původní schéma změní následovně:</p>

<pre>
+-----------+ 
| producent |
|     #1    |... &gt;!.........
| go block  |              :
+-----------+              :
                           :
+-----------+              :               +-----------+
| producent |           +-----+            | konzument |
|     #2    |... &gt;! ... |kanál} ... &lt;! ... |           |
| go block  |           +-----+            | go block  |
+-----------+              :               +-----------+
                           :
+-----------+              :
| producent |              :
|     #3    |... &gt;!........:
| go block  |
+-----------+
</pre>

Náhodný výběr je zde důležitý, protože pokud by se kanály
neustále vybíraly podle uvedeného pořadí, mohlo by docházet k&nbsp;efektu,
který je znám pod termínem &bdquo;vyhladovění&ldquo; (starvation) u těch
kanálů, které se ve vektoru nachází na posledních pozicích. Kromě dvou již
uvedených schémat tedy ještě přibývá třetí schéma + všechny jeho varianty:</p>

<pre>
+-----------+ 
| producent |           +------+
|     #1    |... &gt;!.....|kanál1}.......
| go block  |           +------+      :
+-----------+                         :
                                      :
+-----------+                         :        +-----------+
| producent |           +------+      :        | konzument |
|     #2    |... &gt;! ... |kanál2} ... alts! ... |           |
| go block  |           +------+      :        | go block  |
+-----------+                         :        +-----------+
                                      :
+-----------+                         :
| producent |           +------+      :
|     #3    |... &gt;!.....|kanál3}......:
| go block  |           +------+
+-----------+
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>

<p></p>

<pre>
package main

import "fmt"

func message(id int) {
        fmt.Printf("gorutina %d\n", id)
}

func main() {
        fmt.Println("main begin")
        go message(1)
        go message(2)
        fmt.Println("main end")
}
</pre>

<pre>
package main

import "fmt"

func message(id int, channel chan int) {
	fmt.Printf("gorutina %d\n", id)
	channel <- 1
}

func main() {
	channel := make(chan int)

	fmt.Println("main begin")
	go message(1, channel)

	fmt.Println("waiting...")

	code, status := <-channel

	fmt.Printf("received code: %d and status: %t\n", code, status)
	fmt.Println("main end")
}
</pre>

<pre>
package main

import "fmt"

func worker(taskChannel chan int, workerDone chan bool) {
	fmt.Println("worker started")
	for {
		value, more := <-taskChannel
		if more {
			fmt.Printf("worker received task with parameter %d\n", value)
		} else {
			fmt.Println("finishing worker")
			workerDone <- true
			fmt.Println("worker finished")
			return
		}
	}
}

func main() {
	taskChannel := make(chan int)
	workerDone := make(chan bool)

	fmt.Println("main begin")

	go worker(taskChannel, workerDone)

	for i := 1; i <= 10; i++ {
		fmt.Printf("sending task with parameter %d\n", i)
		taskChannel <- i
	}
	close(taskChannel)

	fmt.Println("waiting for workers...")

	code, status := <-workerDone

	fmt.Printf("received code: %t and status: %t\n", code, status)
	fmt.Println("main end")
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<p></p>

<pre>
(<strong>ns</strong> async2.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;!])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 15000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanal</i>
    (<strong>let</strong> [channel (chan)]
        <i>; kontinualni posilani zprav do kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (dotimes [i 10]
                (Thread/sleep 1000)
                (&gt;! channel i)))
&nbsp;
        (println "1st go block started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (println (&lt;! channel))))
&nbsp;
        (println "2nd go block started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish"))
</pre>

<pre>
(<strong>ns</strong> async4.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;! timeout)])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 10000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanal</i>
    (<strong>let</strong> [channel (chan)]
        <i>; kontinualni posilani zprav do kanalu v trojici asynchronnich bloku</i>
        (<strong>go</strong>
            (while true
                (&lt;! (timeout 500))
                (&gt;! channel "first")))
&nbsp;
        (<strong>go</strong>
            (while true
                (&lt;! (timeout 1000))
                (&gt;! channel "second")))
&nbsp;
        (<strong>go</strong>
            (while true
                (&lt;! (timeout 2000))
                (&gt;! channel "third")))
&nbsp;
        (println "producers started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (println (&lt;! channel))))
&nbsp;
        (println "consumer started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish")
    (System/exit 0))
</pre>

<pre>
(<strong>ns</strong> async5.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;! timeout alts!)])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 10000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanaly</i>
    (<strong>let</strong> [channel1 (chan)
          channel2 (chan)
          channel3 (chan)]
&nbsp;
        <i>; kontinualni posilani zprav do trech kanalu v trojici asynchronnich bloku</i>
        (<strong>go</strong>
            (doseq [i (range)]
                (&lt;! (timeout 500))
                (&gt;! channel1 i)))
&nbsp;
        (<strong>go</strong>
            (doseq [i (range)]
                (&lt;! (timeout 1000))
                (&gt;! channel2 i)))
&nbsp;
        (<strong>go</strong>
            (doseq [i (range)]
                (&lt;! (timeout 2000))
                (&gt;! channel3 i)))
&nbsp;
        (println "producers started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (<strong>let</strong> [[item channel] (alts! [channel1 channel2 channel3])]
                    (condp = channel
                        channel1 (println "channel #1: " item)
                        channel2 (println "channel #2: " item)
                        channel3 (println "channel #3: " item)))))
&nbsp;
        (println "consumer started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish")
    (System/exit 0))
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Knihovna <strong>libmill</strong> se představuje</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<p></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<p></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Libmill: Go-style concurrency in C<br />
<a href="http://libmill.org/">http://libmill.org/</a>
</li>

<li>Libmill na GitHubu<br />
<a href="https://github.com/sustrik/libmill">https://github.com/sustrik/libmill</a>
</li>

<li>libdill: Structured Concurrency for C<br />
<a href="http://libdill.org/">http://libdill.org/</a>
</li>

<li>libdill na GitHubu<br />
<a href="https://github.com/sustrik/libdill">https://github.com/sustrik/libdill</a>
</li>

<li>Libdill: Structured Concurrency for C (2016)<br />
<a href="https://news.ycombinator.com/item?id=15977983">https://news.ycombinator.com/item?id=15977983</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async<br />
<a href="https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (pokračování)<br />
<a href="https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">https://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Communicating sequential processes (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">https://en.wikipedia.org/wiki/Communicating_sequential_processes</a>
</li>

<li>Go Block Best Practices<br />
<a href="https://www.clojure.org/guides/core_async_go">https://www.clojure.org/guides/core_async_go</a>
</li>

<li>Clojure core.async and Go: A Code Comparison<br />
<a href="https://blog.drewolson.org/clojure-go-comparison">https://blog.drewolson.org/clojure-go-comparison</a>
</li>

<li>FLOSS Weekly 358: Libmill<br />
<a href="https://www.youtube.com/watch?v=zUDhcN-8oQo">https://www.youtube.com/watch?v=zUDhcN-8oQo</a>
</li>

<li>Structured Concurrency Finding our way out of callback hell<br />
<a href="https://www.youtube.com/watch?v=llYv1AitDH8">https://www.youtube.com/watch?v=llYv1AitDH8</a>
</li>

<li>Go part 21: Goroutines<br />
<a href="https://golangbot.com/goroutines/">https://golangbot.com/goroutines/</a>
</li>

<li>Go part 22: Channels<br />
<a href="https://golangbot.com/channels/">https://golangbot.com/channels/</a>
</li>

<li>[Go] Lightweight eventbus with async compatibility for Go<br />
<a href="https://github.com/asaskevich/EventBus">https://github.com/asaskevich/EventBus</a>
</li>

<li>Goroutine IDs<br />
<a href="https://blog.sgmansfield.com/2015/12/goroutine-ids/">https://blog.sgmansfield.com/2015/12/goroutine-ids/</a>
</li>

<li>Different ways to pass channels as arguments in function in go (golang)<br />
<a href="https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang">https://stackoverflow.com/questions/24868859/different-ways-to-pass-channels-as-arguments-in-function-in-go-golang</a>
</li>

<li>Select waits on a group of channels<br />
<a href="https://yourbasic.org/golang/select-explained/">https://yourbasic.org/golang/select-explained/</a>
</li>

<li>Communicating Sequential Processes. The First 25 Years<br />
<a href="https://www.springer.com/gp/book/9783540258131">https://www.springer.com/gp/book/9783540258131</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

