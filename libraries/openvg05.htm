<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>2D grafika s využitím knihovny OpenVG (nejenom) na Raspberry Pi: práce s cestami (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>2D grafika s využitím knihovny OpenVG (nejenom) na Raspberry Pi: práce s cestami (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>S&nbsp;konceptem takzvaných &bdquo;cest&ldquo; v&nbsp;knihovně OpenVG jsme se již seznámili v&nbsp;předchozí části tohoto seriálu. Ještě si však musíme vysvětlit způsob tvorby na sebe hladce navazujících Bézierových křivek a taktéž tvorbu kružnicových a popř.&nbsp;i eliptických oblouků.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. 2D grafika s&nbsp;využitím knihovny OpenVG (nejenom) na Raspberry Pi: práce s cestami (dokončení)</a></p>
<p><a href="#k02">2. Rekapitulace již popsaných příkladů pro tvorbu a vykreslení cest</a></p>
<p><a href="#k03">3. Kvadratické a kubické Bézierovy křivky v&nbsp;knihovně OpenVG</a></p>
<p><a href="#k04">4. Desátý demonstrační příklad: vykreslení kvadratické Bézierovy křivky</a></p>
<p><a href="#k05">5. Hladké napojení Bézierových křivek</a></p>
<p><a href="#k06">6. Jedenáctý demonstrační příklad: hladké napojení tří kvadratických Bézierových křivek</a></p>
<p><a href="#k07">7. Dvanáctý demonstrační příklad: hladké napojení dvou kubických Bézierových křivek</a></p>
<p><a href="#k08">8. Kruhové a eliptické oblouky</a></p>
<p><a href="#k09">9. Třináctý demonstrační příklad: křivka složená z&nbsp;kruhového oblouku</a></p>
<p><a href="#k10">10. Čtrnáctý demonstrační příklad: eliptické oblouky</a></p>
<p><a href="#k11">11. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. 2D grafika s&nbsp;využitím knihovny OpenVG (nejenom) na Raspberry Pi: práce s cestami (dokončení)</h2>

<p><a
href="http://www.root.cz/clanky/2d-grafika-s-vyuzitim-knihovny-openvg-nejenom-na-raspberry-pi-cesty-1/">V&nbsp;předchozím
článku</a> o grafické knihovně <i>OpenVG</i> určené pro tvorbu kvalitní 2D
grafiky s&nbsp;případnou podporou GPU (čipu s&nbsp;grafickým akcelerátorem)
jsme si nejprve popsali všechny základní funkce používané při práci
s&nbsp;takzvanými cestami (<i>paths</i>) a následně jsme si ukázali způsob
použití těchto funkcí na čtyřech demonstračních příkladech. Připomeňme si, že
cesty jsou tvořeny segmenty, přičemž definice každého segmentu je specifikována
příkazem typu <strong>VG_LINE_TO</strong>, <strong>VG_QUAD_TO</strong> atd. a
samozřejmě taktéž souřadnicemi koncových bodů úseček, řídicích bodů křivek či
dalších údajů (poloměr oblouku apod.). Mezi funkce určené pro vytváření,
modifikaci i rušení cest patří především funkce pojmenované
<strong>vgCreatePath()</strong>, <strong>vgDestroyPath()</strong>,
<strong>vgClearPath()</strong>, <strong>vgDrawPath()</strong> a konečně pak
nejsložitější funkce nazvaná <strong>vgAppendPathData()</strong> sloužící pro
přidání dalších segmentů do vytvářené cesty (je totiž nutné si uvědomit, že
každá cesta vytvořená pomocí <strong>vgCreatePath</strong> je totiž zpočátku
prázdná).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rekapitulace již popsaných příkladů pro tvorbu a vykreslení cest</h2>

<p><a
href="https://github.com/tisnik/presentations/tree/master/openvg/example6">V&nbsp;celkovém
pořadí šestém demonstračním příkladu</a> jsme si ukázali vykreslení úsečky
s&nbsp;využitím cesty specifikované pouze dvěma příkazy:
<strong>VG_MOVE_TO</strong> a <strong>VG_LINE_TO</strong>. Oba dva zmíněné
příkazy je samozřejmě možné použít i pro vykreslení lomené čáry (polyčáry)
popř.&nbsp;i několika úseček, které na sebe nemusí navazovat (cesta může
obsahovat &bdquo;skoky&ldquo;). V&nbsp;případě, že je zapotřebí vytvořit (a
popř.&nbsp;i vyplnit) uzavřený tvar, je nutné použít cestu končící příkazem
<strong>VG_CLOSE_PATH</strong>. Tento příkaz spojí naposledy zapamatovaný
vrchol s&nbsp;počátečním bodem cesty a pokud je nastavený styl výplně a je
povoleno vyplňování uzavřených cest (<strong>VG_FILL_PATH</strong>) je cesta
skutečně vyplněna. Tímto způsobem, který byl minule prakticky ukázán <a
href="https://github.com/tisnik/presentations/tree/master/openvg/example7">v&nbsp;sedmém
demonstračním příkladu</a>, je možné tvořit objekty vyplněné konstantní barvou,
gradientním přechodem, vzorkem, poloprůhlednou barvou atd.</p>

<p><a
href="https://github.com/tisnik/presentations/tree/master/openvg/example8">Osmý
demonstrační příklad popsaný minule</a> byl určen pro ukázku použití příkazů
<strong>VG_HLINE_TO</strong> a <strong>VG_VLINE_TO</strong>. Jak již názvy
těchto příkazů naznačují, jsou určeny pro vykreslení vodorovných či svislých
čar. Ve skutečnosti je však možné celý vykreslovaný tvar (cestu) natočit, a to
volbou vhodné transformační matice, takže pojem &bdquo;vodorovná&ldquo; a
&bdquo;svislá&ldquo; je nutné chápat pouze v&nbsp;rámci lokálního souřadného
systému vytvořeného pro každou cestu. A konečně jsme se <a
href="https://github.com/tisnik/presentations/tree/master/openvg/example9">v&nbsp;devátém
příkladu</a> seznámili s&nbsp;problematikou tvorby Bézierových křivek.
V&nbsp;knihovně OpenVG jsou podporovány jak kvadratické tak i kubické Bézierovy
křivky, což je jen dobře, protože kvadratické křivky jsou často používány
například při definici fontů zatímco křivky kubické najdeme například
v&nbsp;mnoha vektorových grafických editorech a tím pádem i v&nbsp;souborech
exportovaných z&nbsp;těchto nástrojů.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Kvadratické a kubické Bézierovy křivky v&nbsp;knihovně OpenVG</h2>

<p>A u Bézierových křivek se ještě na chvíli zastavíme, protože si musíme
vysvětlit jeden poměrně důležitý koncept &ndash; způsob navazování jednotlivých
křivek. Začneme u kvadratických Bézierových křivek, protože ty jsou
v&nbsp;tomto ohledu jednodušší. Připomeňme si, že kvadratické Bézierovy křivky
jsou specifikovány trojicí řídicích bodů, přičemž křivka obecně prochází pouze
svým prvním a posledním bodem (jedná se o takzvané kotvicí body) a prostřední
bod &bdquo;pouze&ldquo; ovlivňuje tvar křivky (tvar a velikost oblouku). Ve
speciálních případech však křivka může procházet i prostředním řídicím bodem,
například tehdy, když všechny tři body leží na jedné přímce nebo jsou dva či
dokonce všechny tři body totožné. Pokud se má do vytvářené cesty přidat
kvadratická Bézierova křivka, použije se příkaz <strong>VG_QUAD_TO_ABS</strong>
a <strong>VG_QUAD_TO_REL</strong>. Navíc se pochopitelně musí do pole vrcholů
přidat souřadnice řídicích bodů této křivky, ovšem ve skutečnosti se musí
specifikovat jen dva řídicí body &ndash; prostřední a koncový &ndash; a to
proto, že počáteční bod odpovídá naposledy definovanému bodu na cestě.</p>

<a href="http://www.root.cz/obrazek/241573/"><img src="https://i.iinfo.cz/images/90/openvg2-1-prev.png" class="image-241573" alt="&#160;" width="360" height="270" /></a>
<p><i>Obrázek 1: Řídicí body kvadratických a kubických Bézierových křivek.</i></p>

<p>V&nbsp;praxi může cesta složená ze dvou kvadratických Bézierových křivek
vypadat následovně:</p>

<img src="https://i.iinfo.cz/images/600/beziers-1.png" class="image-256831" alt="&#160;" height="238" width="403" />
<p><i>Obrázek 2: Cesta složená ze dvou kvadratických Bézierových křivek.</i></p>

<p>Popis jednotlivých vrcholů na obrázku:</p>

<table>
<tr><th>Barva</th><th>Význam</th></tr>
<tr><td>šedá</td><td>vrchol nastavený předchozím příkazem, například VG_MOVE_TO</td></tr>
<tr><td>červená</td><td>vrcholy první kvadratické Bézierovy křivky</td></tr>
<tr><td>modrá</td><td>vrcholy druhé kvadratické Bézierovy křivky</td></tr>
</table>

<p>Povšimněte si, že kromě společného vrcholu není tvar obou Bézierových křivek
vytvořených příkazy <strong>VG_QUAD_TO_*</strong> nijak omezen &ndash; cesta se
může v&nbsp;místě napojení lámat atd.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Desátý demonstrační příklad: vykreslení kvadratické Bézierovy křivky</h2>

<p>Ještě předtím, než si ukážeme, jak je možné automaticky hladce spojit dvě
Bézierovy křivky, se seznámíme se způsobem vykreslení jediné kvadratické
Bézierovy křivky. To je ve skutečnosti velmi jednoduché a postačí nám cesta
s&nbsp;pouhými dvěma příkazy: <strong>VG_MOVE_TO*</strong> a
<strong>VG_QUAD_TO*</strong>:</p>

<pre>
<i>/* vykresleni druhe cesty slozene z kvadraticke Bezierovy krivky */</i>
VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
<i>/* deklarace useckoveho segmentu */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                      VG_QUAD_TO_REL};       <i>/* Bezierova kvadraticka krivka */</i>
</pre>

<p>Pole obsahující souřadnice vrcholů musí mít šest prvků, což odpovídá třem
bodům: první bod je pro příkaz <strong>VG_MOVE_TO_ABS</strong> a druhé dva body
pro příkaz <strong>VG_QUAD_TO_REL</strong> (řídicí bod a koncový či kotvicí
bod):</p>

<pre>
VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                         150, 200,           <i>/* ridici bod Bezierovy krivky */</i>
                         300, 000};          <i>/* koncovy bod Bezierovy krivky */</i>
&nbsp;
<i>/* pridani vsech segmentu */</i>
vgAppendPathData(path, 2, commands, coordinates); 
</pre>

<p>Nakonec vykreslíme obrys cesty:</p>

<pre>
<i>/* Bezierova krivka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
vgDrawPath(path, VG_STROKE_PATH);
vgDestroyPath(path);
</pre>

<p>Úplný zdrojový kód upravený pro Raspberry Pi vypadá následovně:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - desaty demonstracni priklad */</i>
<i>/* Kvadraticka Bezierova krivka. */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
typedef struct
{
    uint32_t screen_width;
    uint32_t screen_height;
&nbsp;
    uint32_t window_x;
    uint32_t window_y;
    int32_t  window_width;
    int32_t  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
void initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    static EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    static VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    static const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    int32_t success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    if ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    if ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 <i>/*layer */ , &amp;dst_rect, 0 /*src */</i> ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 <i>/*clamp */</i> ,
                          0 <i>/*transform */</i> );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
void finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni nekolika usecek a Bezierovych krivek.</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 1);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce prvni polycary */</i>
    {
        VGfloat color2[4] = {0.25f, 0.25f, 0.75f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni prvni cesty slozene z usecek */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,        <i>/* prvni useckovy segment */</i>
                              VG_LINE_TO_REL,
                              VG_LINE_TO_REL};       <i>/* dalsi useckove segmenty */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                                 150,  200,
                                 150, -200};
&nbsp;
        <i>/* pridani vsech useckovych segmentu */</i>
        vgAppendPathData(path, 4, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 3);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce Bezierovych krivek */</i>
    {
        VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni druhe cesty slozene z kvadraticke Bezierovy krivky */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_QUAD_TO_REL};       <i>/* Bezierova kvadraticka krivka */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                                 150, 200,           <i>/* ridici bod Bezierovy krivky */</i>
                                 300, 000};          <i>/* koncovy bod Bezierovy krivky */</i>
&nbsp;
        <i>/* pridani vsech segmentu */</i>
        vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
        <i>/* Bezierova krivka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* barva stetce polycary */</i>
    {
        VGfloat color2[4] = {0.75f, 0.75f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 20);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);    <i>/* siroke stopy konci presne na stanovenych souradnicich */</i>
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL); <i>/* vnejsi okraje spoju jsou "oseknute" */</i>
&nbsp;
    {
        <i>/* vykresleni polycary */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,                  <i>/* prvni usecka (vodorovna) */</i>
                              VG_LINE_TO_REL,                  <i>/* druha usecka (svisla) */</i>
                              VG_LINE_TO_REL,                  <i>/* treti usecka (vodorovna) */</i>
                              VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
&nbsp;
        VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                                 state-&gt;window_width-40, 0,    <i>/* prvni usecka (vodorovna) */</i>
                                 0, state-&gt;window_height-40,   <i>/* druha usecka (svisla) */</i>
                                 -state-&gt;window_width+40, 0};  <i>/* treti usecka (vodorovna) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 5, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
int main(int argc, char *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    return 0;
}
</pre>

<p>Soubor Makefile:</p>

<pre>
# Makefile pro preklad desateho prikladu ukazujiciho
# praci s OpenVG a EGL.
&nbsp;
# Parametry prekladace.
CFLAGS=-Wall
&nbsp;
# Dalsi parametry prekladace, zde adresare, kde se maji 
# hledat hlavickove soubory.
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
# Parametry linkeru.
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example10
&nbsp;
# Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.
all:	$(PROGNAME)
&nbsp;
clean:
	rm -f *.o
	rm -f $(PROGNAME)
&nbsp;
# Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni
# vysledne spustitelne aplikace.
$(PROGNAME):	$(PROGNAME).o
	$(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
# Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho
# objektoveho souboru.
%.o:	%.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Hladké napojení Bézierových křivek</h2>

<p>To však není všechno. V&nbsp;některých situacích potřebujeme, aby na sebe
Bézierovy křivky hladce navazovaly s&nbsp;geometrickou spojitostí
G<sup>1</sup>, což je použito například v&nbsp;definicích tvaru znaků ve
vektorových či obrysových fontech. Knihovna OpenVG tuto vlastnost podporuje,
což vlastně není nic překvapivého, neboť se jedná o vlastnost převzatou
z&nbsp;grafického formátu <i>SVG</i>, s&nbsp;nímž musí být knihovna OpenVG co
nejvíce kompatibilní. V&nbsp;případě kvadratické Bézierovy křivky se pro její
hladké navázání na předchozí segment používají příkazy
<strong>VG_SQUAD_TO_ABS</strong> a <strong>VG_SQUAD_TO_REL</strong>, u nichž se
specifikuje pouze jediný vrchol, kterým je koncový bod křivky. Její začátek
samozřejmě známe a jediný řídicí body je vypočten z&nbsp;pozice řídicího bodu
předchozí křivky (podobně je tomu v&nbsp;TrueType fontech). Interně si knihovna
OpenVG při tvorbě cesty udržuje následující informace: poslední bod předchozího
segmentu [o<sub>x</sub>, o<sub>y</sub>] a poslední interní řídicí bod
předchozího segmentu [p<sub>x</sub>, p<sub>y</sub>]. V&nbsp;případě použití
příkazů <strong>VG_SQUAD_TO_*</strong> se prostřední řídicí bod kvadratické
Bézierovy křivky vypočte následovně:</p>

<p>[x,y]=[2*o<sub>x</sub>-p<sub>x</sub>, 2*o<sub>y</sub>-p<sub>y</sub>]</p>

<p>Tatáž hodnota (dvě souřadnice) se následně uloží do interní proměnné
[p<sub>x</sub>, p<sub>y</sub>], takže je možné na sebe navázat větší množství
křivek. První křivka je zadána příkazem <strong>VG_QUAD_TO_*</strong>, další
pak příkazy <strong>VG_SQUAD_TO_*</strong>; ovšem v&nbsp;případě potřeby lze
použít i kombinaci kvadratických a kubických Bézierových křivek.</p>

<p>Dvě na sebe hladce navazující segmenty vytvořené z&nbsp;Bézierových
kvadratických křivek:</p>

<img src="https://i.iinfo.cz/images/600/beziers-2.png" class="image-256832" alt="&#160;" height="712" width="715" />
<p><i>Obrázek 3: Cesta složená ze dvou hladce navázaných kvadratických
Bézierových křivek.</i></p>


<p>Popis jednotlivých vrcholů na obrázku:</p>

<table>
<tr><th>Barva</th><th>Význam</th></tr>
<tr><td>šedá</td><td>vrchol nastavený předchozím příkazem, například VG_MOVE_TO</td></tr>
<tr><td>červená</td><td>vrcholy první kvadratické Bézierovy křivky</td></tr>
<tr><td>modrá</td><td>explicitně zadaný vrchol druhé kvadratické Bézierovy křivky</td></tr>
<tr><td>zelená</td><td>automaticky dopočtený vrchol druhé kvadratické Bézierovy křivky (není explicitně zadán)</td></tr>
</table>

<p>Poznámka: u úsečkových segmentů se interně zapamatované body [o<sub>x</sub>,
o<sub>y</sub>] a [p<sub>x</sub>, p<sub>y</sub>] nastaví na stejné hodnoty (tím
jsou souřadnice koncového bodu úsečky), což je škoda, protože to znamená, že
nelze snadno zkombinovat příkazy <strong>VG_LINE_TO_*</strong>
s&nbsp;<strong>VG_SQUAD_TO_*</strong>. Totéž platí i pro oblouky a navíc i pro
příkaz <strong>VG_CLOSE_PATH</strong>, který je možné považovat za speciální
případ úsečkového segmentu.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Jedenáctý demonstrační příklad: hladké napojení tří kvadratických Bézierových křivek</h2>

<p>Podívejme se, jak lze hladce napojit tři kvadratické Bézierovy křivky a
vytvořit tak na obrazovce &bdquo;vlny&ldquo;. Nejprve zkonstruujeme prázdnou
cestu:</p>

<pre>
<i>/* vykresleni druhe cesty slozene z kvadratickych Bezierovych krivek */</i>
VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
</pre>

<p>Dále vytvoříme pole, v&nbsp;němž jsou uloženy příkazy pro vytvoření cesty
složené z&nbsp;úplně zadané Bézierovy křivky a dvou křivek s&nbsp;hladkým
napojením (specifikovaným jen jediným bodem):</p>

<pre>
<i>/* deklarace useckoveho segmentu */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                      VG_QUAD_TO_REL,        <i>/* Bezierova kvadraticka krivka */</i>
                      VG_SQUAD_TO_REL,       <i>/* Bezierova kvadraticka krivka s hladkym napojenim */</i>
                      VG_SQUAD_TO_REL};      <i>/* Bezierova kvadraticka krivka s hladkym napojenim */</i>
</pre>

<p>Pole s&nbsp;vrcholy musí v&nbsp;tomto případě obsahovat deset hodnot
odpovídajících pěti bodům: začátek cesty, dva body pro první Bézierovu křivku,
jediný bod pro druhou Bézierovu křivku a konečně poslední bod pro třetí
Bézierovu křivku:</p>

<pre>
VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                         150, 200,           <i>/* ridici bod Bezierovy krivky */</i>
                         300, 000,           <i>/* koncovy bod Bezierovy krivky */</i>
                         300, 000,           <i>/* koncovy bod druhe Bezierovy krivky s hladkym napojenim */</i>
                         300, 000};          <i>/* koncovy bod treti Bezierovy krivky s hladkym napojenim */</i>
&nbsp;
<i>/* pridani vsech segmentu */</i>
vgAppendPathData(path, 4, commands, coordinates); 
</pre>

<p>Způsob vykreslení již dobře známe:</p>

<pre>
<i>/* Bezierova krivka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
vgDrawPath(path, VG_STROKE_PATH);
vgDestroyPath(path);
</pre>

<p>Úplný zdrojový kód celého demonstračního příkladu upravený pro Raspberry Pi
vypadá následovně:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - jedenacty demonstracni priklad */</i>
<i>/* Hladke napojeni tri kvadratickych Bezierovych krivek. */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
typedef struct
{
    uint32_t screen_width;
    uint32_t screen_height;
&nbsp;
    uint32_t window_x;
    uint32_t window_y;
    int32_t  window_width;
    int32_t  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
void initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    static EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    static VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    static const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    int32_t success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    if ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    if ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 <i>/*layer */ , &amp;dst_rect, 0 /*src */</i> ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 <i>/*clamp */</i> ,
                          0 <i>/*transform */</i> );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
void finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni nekolika usecek a Bezierovych krivek.</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 1);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce prvni polycary */</i>
    {
        VGfloat color2[4] = {0.25f, 0.25f, 0.75f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni prvni cesty slozene z usecek */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,        <i>/* prvni useckovy segment */</i>
                              VG_LINE_TO_REL,
                              VG_LINE_TO_REL};       <i>/* dalsi useckove segmenty */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                                 150,  200,
                                 150, -200};
&nbsp;
        <i>/* pridani vsech useckovych segmentu */</i>
        vgAppendPathData(path, 4, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 3);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce Bezierovych krivek */</i>
    {
        VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni druhe cesty slozene z kvadratickych Bezierovych krivek */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_QUAD_TO_REL,        <i>/* Bezierova kvadraticka krivka */</i>
                              VG_SQUAD_TO_REL,       <i>/* Bezierova kvadraticka krivka s hladkym napojenim */</i>
                              VG_SQUAD_TO_REL};      <i>/* Bezierova kvadraticka krivka s hladkym napojenim */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                                 150, 200,           <i>/* ridici bod Bezierovy krivky */</i>
                                 300, 000,           <i>/* koncovy bod Bezierovy krivky */</i>
                                 300, 000,           <i>/* koncovy bod druhe Bezierovy krivky s hladkym napojenim */</i>
                                 300, 000};          <i>/* koncovy bod treti Bezierovy krivky s hladkym napojenim */</i>
&nbsp;
        <i>/* pridani vsech segmentu */</i>
        vgAppendPathData(path, 4, commands, coordinates); 
&nbsp;
        <i>/* Bezierova krivka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* barva stetce polycary */</i>
    {
        VGfloat color2[4] = {0.75f, 0.75f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 20);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);    <i>/* siroke stopy konci presne na stanovenych souradnicich */</i>
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL); <i>/* vnejsi okraje spoju jsou "oseknute" */</i>
&nbsp;
    {
        <i>/* vykresleni polycary */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,                  <i>/* prvni usecka (vodorovna) */</i>
                              VG_LINE_TO_REL,                  <i>/* druha usecka (svisla) */</i>
                              VG_LINE_TO_REL,                  <i>/* treti usecka (vodorovna) */</i>
                              VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
&nbsp;
        VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                                 state-&gt;window_width-40, 0,    <i>/* prvni usecka (vodorovna) */</i>
                                 0, state-&gt;window_height-40,   <i>/* druha usecka (svisla) */</i>
                                 -state-&gt;window_width+40, 0};  <i>/* treti usecka (vodorovna) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 5, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
int main(int argc, char *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    return 0;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Dvanáctý demonstrační příklad: hladké napojení dvou kubických Bézierových křivek</h2>

<p>U kvadratických Bézierových křivek, které se na sebe hladce napojovaly
příkazem <strong>VG_SQUAD_TO_*</strong> se nikdy nezadávaly prostřední řídicí
body, protože ty byly automaticky dopočteny. U hladkého napojení kubických
Bézierových křivek je tomu poněkud jinak, a to z&nbsp;toho důvodu, že musíme
pracovat se dvěma &bdquo;prostředními&ldquo; řídicími body. První z&nbsp;těchto
bodů je spočten stejným způsobem, jako tomu bylo u kvadratických křivek, ovšem
druhý bod je nutné určit explicitně. Výhodou je větší flexibilita a obecně
menší množství křivek nutných pro vytvoření požadovaného tvaru. Zkusme si tedy
vytvořit cestu, v&nbsp;níž se zobrazí dvě hladce napojené kubické Bézierovy
křivky:</p>

<pre>
<i>/* vykresleni druhe cesty slozene z kubickychBezierovych krivek */</i>
VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
</pre>

<p>Následuje deklarace pole s&nbsp;trojicí příkazů pro tvorbu cesty. Povšimněte
si, že hladké napojení kubických křivek zajišťuje příkaz
<strong>VG_SCUBIC_TO_*</strong>, kde písmeno &bdquo;s&ldquo; znamená
&bdquo;smooth&ldquo;:</p>

<pre>
<i>/* deklarace useckoveho segmentu a dvou krivek */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                      VG_CUBIC_TO_REL,       <i>/* Bezierova kubicka krivka */</i>
                      VG_SCUBIC_TO_REL};     <i>/* Bezierova kubicka krivka s hladkym napojenim */</i>
</pre>

<p>Počet vrcholů musí být roven šesti (dvanáct prvků pole), přičemž jen
poslední dva vrcholy platí pro druhou Bézierovu křivku:</p>

<pre>
VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                         100, 200,           <i>/* prvni ridici bod Bezierovy krivky */</i>
                         200, 200,           <i>/* druhy ridici bod Bezierovy krivky */</i>
                         300, 000,           <i>/* koncovy bod prvni Bezierovy krivky */</i>
                         200, 300,           <i>/* ridici bod druhe Bezierovy krivky s hladkym napojenim */</i>
                         300, 000};          <i>/* koncovy bod druhe Bezierovy krivky s hladkym napojenim */</i>
&nbsp;
<i>/* pridani vsech segmentu */</i>
vgAppendPathData(path, 3, commands, coordinates); 
</pre>

<p>Způsob vykreslení cesty již dobře známe z&nbsp;předchozích dvou
demonstračních příkladů:</p>

<pre>
<i>/* Bezierova krivka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
vgDrawPath(path, VG_STROKE_PATH);
vgDestroyPath(path);
</pre>

<p>Opět si ukažme úplný kód tohoto příkladu odladěného pro Raspberry Pi:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - dvanacty demonstracni priklad */</i>
<i>/* Hladke napojeni dvou kubickych Bezierovych krivek. */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
typedef struct
{
    uint32_t screen_width;
    uint32_t screen_height;
&nbsp;
    uint32_t window_x;
    uint32_t window_y;
    int32_t  window_width;
    int32_t  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
void initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    static EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    static VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    static const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    int32_t success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    if ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    if ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 <i>/*layer */ , &amp;dst_rect, 0 /*src */</i> ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 <i>/*clamp */</i> ,
                          0 <i>/*transform */</i> );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
void finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni nekolika usecek a Bezierovych krivek.</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 1);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce prvni polycary */</i>
    {
        VGfloat color2[4] = {0.25f, 0.25f, 0.75f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni prvni cesty slozene z usecek */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,        <i>/* prvni useckovy segment */</i>
                              VG_LINE_TO_REL,
                              VG_LINE_TO_REL,
                              VG_LINE_TO_REL};       <i>/* dalsi useckove segmenty */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                                 100,  200,
                                 100,    0,
                                 100, -200};
&nbsp;
        <i>/* pridani vsech useckovych segmentu */</i>
        vgAppendPathData(path, 5, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 3);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce Bezierovych krivek */</i>
    {
        VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni druhe cesty slozene z kubickychBezierovych krivek */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_CUBIC_TO_REL,       <i>/* Bezierova kubicka krivka */</i>
                              VG_SCUBIC_TO_REL};     <i>/* Bezierova kubicka krivka s hladkym napojenim */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 400, state-&gt;window_height &gt;&gt; 1,
                                 100, 200,           <i>/* prvni ridici bod Bezierovy krivky */</i>
                                 200, 200,           <i>/* druhy ridici bod Bezierovy krivky */</i>
                                 300, 000,           <i>/* koncovy bod prvni Bezierovy krivky */</i>
                                 200, 300,           <i>/* ridici bod druhe Bezierovy krivky s hladkym napojenim */</i>
                                 300, 000};          <i>/* koncovy bod druhe Bezierovy krivky s hladkym napojenim */</i>
&nbsp;
        <i>/* pridani vsech segmentu */</i>
        vgAppendPathData(path, 3, commands, coordinates); 
&nbsp;
        <i>/* Bezierova krivka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* barva stetce polycary */</i>
    {
        VGfloat color2[4] = {0.75f, 0.75f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 20);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);    <i>/* siroke stopy konci presne na stanovenych souradnicich */</i>
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL); <i>/* vnejsi okraje spoju jsou "oseknute" */</i>
&nbsp;
    {
        <i>/* vykresleni polycary */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,                  <i>/* prvni usecka (vodorovna) */</i>
                              VG_LINE_TO_REL,                  <i>/* druha usecka (svisla) */</i>
                              VG_LINE_TO_REL,                  <i>/* treti usecka (vodorovna) */</i>
                              VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
&nbsp;
        VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                                 state-&gt;window_width-40, 0,    <i>/* prvni usecka (vodorovna) */</i>
                                 0, state-&gt;window_height-40,   <i>/* druha usecka (svisla) */</i>
                                 -state-&gt;window_width+40, 0};  <i>/* treti usecka (vodorovna) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 5, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
int main(int argc, char *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    return 0;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Kruhové a eliptické oblouky</h2>

<p>Jedním z&nbsp;problémů, které musí řešit především uživatelé CAD nástrojů,
je fakt, že kvadratické ani kubické Bézierovy křivky nemohou geometricky přesně
nahradit kruhové a eliptické oblouky (k&nbsp;tomuto účelu by bylo nutné použít
racionální křivky, například NURBS, se všemi komplikacemi, které to přináší).
Z&nbsp;tohoto důvodu byly v&nbsp;knihovně OpenVG do repertoáru příkazů určených
pro vytváření cest přidány i příkazy sloužící pro přidání segmentu vytvořeného
z&nbsp;eliptického oblouku do konstruované cesty. Kruhový oblouk je samozřejmě
speciálním případem eliptického oblouku, stejně jako elipsa či kruh &ndash; pro
vytvoření všech těchto tvarů si tedy vystačíme s&nbsp;pouhými čtyřmi příkazy,
které se od sebe odlišují v&nbsp;tom, zda se vykreslí delší či kratší část
oblouku a zda je oblouk specifikován po směru či proti směru hodinových
ručiček (ve skutečnosti není možné jedním segmentem vykreslit přesný kruh či
kružnici, jak si ostatně ukážeme dále).</p>

<table>
<tr><th>Příkaz</th><th>Parametry</th><th>Význam</th></tr>
<tr><td>VG_SCCWARC_TO</td><td>rh,rv,rot,x0,y0</td><td>menší oblouk, proti směru hodinových ručiček</td></tr>
<tr><td>VG_SCWARC_TO </td><td>rh,rv,rot,x0,y0</td><td>menší oblouk, po směru hodinových ručiček</td></tr>
<tr><td>VG_LCCWARC_TO</td><td>rh,rv,rot,x0,y0</td><td>větší oblouk, proti směru hodinových ručiček</td></tr>
<tr><td>VG_LCWARC_TO </td><td>rh,rv,rot,x0,y0</td><td>větší oblouk, po směru hodinových ručiček</td></tr>
</table>

<p>Význam parametrů lze zjistit z&nbsp;nákresu:</p>

<a href="http://www.root.cz/obrazek/241574/"><img src="https://i.iinfo.cz/images/309/openvg3-1.png" class="image-241574" alt="&#160;" width="292" height="196" /></a>
<p><i>Obrázek 4: Čtyři možné eliptické oblouky při znalosti dvou bodů, dvou
poloměrů (a zde neuvedené rotace celé elipsy).</i></p>

<p>Pokud jsou oba poloměry <i>rh</i> a <i>rv</i> shodné, vykreslí se kruhový
oblouk. Třetí parametr <i>rot</i> může být použit pro natočení oblouku
libovolným směrem (hodnota je zadána ve stupních, nikoli v&nbsp;radiánech, což
je praktické, zejména tehdy, pokud pole vrcholů obsahuje celočíselné hodnoty).
Hodnoty <i>x0</i> a <i>y0</i> představují koncový bod oblouku, protože
počáteční bod je znám, podobně jako u Bézierových křivek.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Třináctý demonstrační příklad: křivka složená z&nbsp;kruhového oblouku</h2>

<p>V&nbsp;tomto demonstračním příkladu jsou vykresleny dva kruhové oblouky.
První oblouk je &bdquo;kratší&ldquo;, což určuje jeho natočení, protože oba
koncové body oblouku leží na stejné vodorovné přímce. Poloměry jsou stejné,
takže se vykreslí kruhový oblouk (zde konkrétně polovina kružnice):</p>

<pre>
<i>/* vykresleni prvni cesty */</i>
VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
<i>/* deklarace oblouku - polokruhu */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                      VG_SCCWARC_TO_REL};    <i>/* oblouk */</i>
&nbsp;
VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 300, state-&gt;window_height &gt;&gt; 1,
                         100,  100,          <i>/* polomery */</i>
                         0,                  <i>/* rotace */</i>
                         200,    0};         <i>/* koncovy bod (relativni souradnice) */</i>
&nbsp;
<i>/* pridani useckoveho segmentu */</i>
vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
<i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
vgDrawPath(path, VG_STROKE_PATH);
vgDestroyPath(path);
</pre>

<p>Druhý oblouk je vytvořen tak, aby se vykreslila prakticky celá kružnice,
protože oba krajní body jsou od sebe vodorovně vzdáleny pouze o jednu jednotku
délky (typicky jeden pixel). Body nemohou být shodné, takže by bylo nutné cestu
uzavřít příkazem <strong>VG_CLOSE_PATH</strong>:</p>

<pre>
<i>/* vykresleni druhe cesty - "kruznice" */</i>
VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
<i>/* deklarace oblouku */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                      VG_LCCWARC_TO_REL};    <i>/* oblouk */</i>
&nbsp;
VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) + 300, state-&gt;window_height &gt;&gt; 1,
                         100,  100,          <i>/* polomery */</i>
                          0,                 <i>/* rotace */</i>
                          1,     0};         <i>/* koncovy bod (relativni souradnice) */</i>
&nbsp;
<i>/* pridani vsech segmentu segmentu */</i>
vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
<i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
vgDrawPath(path, VG_STROKE_PATH);
vgDestroyPath(path);
</pre>

<p>Následuje úplný zdrojový kód příkladu:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - trinacty demonstracni priklad */</i>
<i>/* Krivka slozena z oblouku. */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
typedef struct
{
    uint32_t screen_width;
    uint32_t screen_height;
&nbsp;
    uint32_t window_x;
    uint32_t window_y;
    int32_t  window_width;
    int32_t  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
void initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    static EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    static VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    static const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    int32_t success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    if ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    if ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 <i>/*layer */ , &amp;dst_rect, 0 /*src */</i> ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 <i>/*clamp */</i> ,
                          0 <i>/*transform */</i> );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
void finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni nekolika usecek a Bezierovych krivek.</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 1);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce prvni cesty */</i>
    {
        VGfloat color2[4] = {0.25f, 0.25f, 0.75f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni prvni cesty */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace oblouku - polokruhu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_SCCWARC_TO_REL};    <i>/* oblouk */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 300, state-&gt;window_height &gt;&gt; 1,
                                 100,  100,          <i>/* polomery */</i>
                                 0,                  <i>/* rotace */</i>
                                 200,    0};         <i>/* koncovy bod (relativni souradnice) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 1);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce druhe cesty */</i>
    {
        VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni druhe cesty - "kruznice" */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace oblouku */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_LCCWARC_TO_REL};    <i>/* oblouk */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) + 300, state-&gt;window_height &gt;&gt; 1,
                                 100,  100,          <i>/* polomery */</i>
                                  0,                 <i>/* rotace */</i>
                                  1,     0};         <i>/* koncovy bod (relativni souradnice) */</i>
&nbsp;
        <i>/* pridani vsech segmentu segmentu */</i>
        vgAppendPathData(path, 2, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* barva stetce polycary */</i>
    {
        VGfloat color2[4] = {0.75f, 0.75f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 20);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);    <i>/* siroke stopy konci presne na stanovenych souradnicich */</i>
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL); <i>/* vnejsi okraje spoju jsou "oseknute" */</i>
&nbsp;
    {
        <i>/* vykresleni polycary */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,                  <i>/* prvni usecka (vodorovna) */</i>
                              VG_LINE_TO_REL,                  <i>/* druha usecka (svisla) */</i>
                              VG_LINE_TO_REL,                  <i>/* treti usecka (vodorovna) */</i>
                              VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
&nbsp;
        VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                                 state-&gt;window_width-40, 0,    <i>/* prvni usecka (vodorovna) */</i>
                                 0, state-&gt;window_height-40,   <i>/* druha usecka (svisla) */</i>
                                 -state-&gt;window_width+40, 0};  <i>/* treti usecka (vodorovna) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 5, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
int main(int argc, char *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    return 0;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Čtrnáctý demonstrační příklad: eliptické oblouky</h2>

<p>V&nbsp;dnešním posledním příkladu je ukázána práce s&nbsp;eliptickými
oblouky. Ty se tvoří, jak jste již zajisté uhodli, zadáním rozdílných poloměrů
ve směru horizontální a vertikální osy. My v&nbsp;jediné cestě vykreslíme
úplnou elipsu složenou ze dvou prakticky shodných (jen zrcadlově otočených)
eliptických oblouků:</p>

<pre>
<i>/* deklarace oblouku - poloelipsy */</i>
VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                      VG_LCCWARC_TO_REL,     <i>/* oblouk */</i>
                      VG_LCCWARC_TO_REL};    <i>/* oblouk */</i>
&nbsp;
VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 300, state-&gt;window_height &gt;&gt; 1,
                         <i>/* prvni elipticky oblouk */</i>
                         100,   60,          <i>/* polomery */</i>
                         0,                  <i>/* rotace */</i>
                         200,    0,          <i>/* koncovy bod (relativni souradnice) */</i>
                         <i>/* druhu elipticky oblouk */</i>
                         100,   60,          <i>/* polomery */</i>
                         0,                  <i>/* rotace */</i>
                         -200,   0};         <i>/* koncovy bod (relativni souradnice) */</i>
</pre>

<p>Následuje úplný zdrojový kód posledního demonstračního příkladu:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - ctrnacty demonstracni priklad */</i>
<i>/* Elipticke oblouky. */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
typedef struct
{
    uint32_t screen_width;
    uint32_t screen_height;
&nbsp;
    uint32_t window_x;
    uint32_t window_y;
    int32_t  window_width;
    int32_t  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
void initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     num_config;
    EGLConfig  config;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    static EGL_DISPMANX_WINDOW_T nativewindow;
&nbsp;
    DISPMANX_ELEMENT_HANDLE_T dispman_element;
    DISPMANX_DISPLAY_HANDLE_T dispman_display;
    DISPMANX_UPDATE_HANDLE_T dispman_update;
    VC_RECT_T dst_rect;
    VC_RECT_T src_rect;
&nbsp;
    static VC_DISPMANX_ALPHA_T alpha = {
        DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS,
        255, 0
    };
&nbsp;
    static const EGLint attribute_list[] = {
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_NONE
    };
&nbsp;
    <i>/* vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* navazani EGL na OpenVG */</i>
    eglBindAPI(EGL_OPENVG_API);
&nbsp;
    <i>/* ziskani konfigurace framebufferu */</i>
    result = eglChooseConfig(state-&gt;display, attribute_list, &amp;config, 1, &amp;num_config);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("EGL choose config failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni kontextu */</i>
    state-&gt;context = eglCreateContext(state-&gt;display, config, EGL_NO_CONTEXT, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;context == EGL_NO_CONTEXT) {
        puts("EGL create context failed");
        exit(1);
    }
&nbsp;
    <i>/* vytvoreni surface */</i>
    int32_t success = graphics_get_display_size(0, &amp;state-&gt;screen_width, &amp;state-&gt;screen_height);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (success &lt; 0) {
        puts("get display size failed");
        exit(1);
    }
&nbsp;
    if ((state-&gt;window_width == 0) || (state-&gt;window_width &gt; state-&gt;screen_width))
        state-&gt;window_width = state-&gt;screen_width;
    if ((state-&gt;window_height == 0) || (state-&gt;window_height &gt; state-&gt;screen_height))
        state-&gt;window_height = state-&gt;screen_height;
&nbsp;
    dispman_display = vc_dispmanx_display_open(0);
    dispman_update = vc_dispmanx_update_start(0);
&nbsp;
    dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display, 0 <i>/*layer */ , &amp;dst_rect, 0 /*src */</i> ,
                          &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, 0 <i>/*clamp */</i> ,
                          0 <i>/*transform */</i> );
&nbsp;
    nativewindow.element = dispman_element;
    nativewindow.width = state-&gt;window_width;
    nativewindow.height = state-&gt;window_height;
    vc_dispmanx_update_submit_sync(dispman_update);
&nbsp;
    <i>/* vytvoreni surface */</i>
    state-&gt;surface = eglCreateWindowSurface(state-&gt;display, config, &amp;nativewindow, NULL);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (state-&gt;surface == EGL_NO_SURFACE) {
        puts("no surface!");
        exit(1);
    }
&nbsp;
    <i>/* nastaveni chovani bufferu pri operaci swap */</i>
    result = eglSurfaceAttrib(state-&gt;display, state-&gt;surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not set surface attributes!");
        exit(1);
    }
&nbsp;
    <i>/* propojeni kontextu se surface */</i>
    result = eglMakeCurrent(state-&gt;display, state-&gt;surface, state-&gt;surface, state-&gt;context);
&nbsp;
    <i>/* kontrola, zda operace probehla v poradku */</i>
    if (result == EGL_FALSE) {
        puts("can not connect context with the surface!");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
void finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vykresleni nekolika usecek a Bezierovych krivek.</i>
<i> */</i>
void draw(EGL_STATE_T *state)
{
    <i>/* vymazani pozadi cernou barvou */</i>
    VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    vgSetfv(VG_CLEAR_COLOR, 4, color1);
    vgClear(0, 0, state-&gt;window_width, state-&gt;window_height);
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 1);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce prvni cesty */</i>
    {
        VGfloat color2[4] = {0.25f, 0.25f, 0.75f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni prvni cesty */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace oblouku - polokruhu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_LCCWARC_TO_REL,     <i>/* oblouk */</i>
                              VG_LCCWARC_TO_REL};    <i>/* oblouk */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) - 300, state-&gt;window_height &gt;&gt; 1,
                                 <i>/* prvni elipticky oblouk */</i>
                                 100,   60,          <i>/* polomery */</i>
                                 0,                  <i>/* rotace */</i>
                                 200,    0,          <i>/* koncovy bod (relativni souradnice) */</i>
                                 <i>/* druhu elipticky oblouk */</i>
                                 100,   60,          <i>/* polomery */</i>
                                 0,                  <i>/* rotace */</i>
                                 -200,   0};         <i>/* koncovy bod (relativni souradnice) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 3, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 1);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_ROUND);
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_ROUND);
&nbsp;
    <i>/* barva stetce druhe cesty */</i>
    {
        VGfloat color2[4] = {0.75f, 0.25f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    {
        <i>/* vykresleni druhe cesty - "kruznice" */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace oblouku */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,        <i>/* pocatecni bod */</i>
                              VG_LCCWARC_TO_REL,     <i>/* oblouk */</i>
                              VG_LCCWARC_TO_REL};    <i>/* oblouk */</i>
&nbsp;
        VGfloat coordinates[] = {(state-&gt;window_width &gt;&gt; 1) + 300, state-&gt;window_height &gt;&gt; 1,
                                 <i>/* prvni elipticky oblouk */</i>
                                 60,   100,          <i>/* polomery */</i>
                                 0,                  <i>/* rotace */</i>
                                 200,    0,          <i>/* koncovy bod (relativni souradnice) */</i>
                                 <i>/* druhu elipticky oblouk */</i>
                                 60,   100,          <i>/* polomery */</i>
                                 0,                  <i>/* rotace */</i>
                                 -200,   0};         <i>/* koncovy bod (relativni souradnice) */</i>
&nbsp;
        <i>/* pridani vsech segmentu segmentu */</i>
        vgAppendPathData(path, 3, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* barva stetce polycary */</i>
    {
        VGfloat color2[4] = {0.75f, 0.75f, 0.25f, 1.0f};
        VGPaint strokePaint = vgCreatePaint();
        vgSetParameteri(strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
        vgSetParameterfv(strokePaint, VG_PAINT_COLOR, 4, color2);
        vgSetPaint(strokePaint, VG_STROKE_PATH);
        vgDestroyPaint(strokePaint);
    }
&nbsp;
    <i>/* sirka a styl stetce */</i>
    vgSetf(VG_STROKE_LINE_WIDTH, 20);
    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);    <i>/* siroke stopy konci presne na stanovenych souradnicich */</i>
    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL); <i>/* vnejsi okraje spoju jsou "oseknute" */</i>
&nbsp;
    {
        <i>/* vykresleni polycary */</i>
        VGPath path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_APPEND_TO);
&nbsp;
        <i>/* deklarace useckoveho segmentu */</i>
        VGubyte commands[] = {VG_MOVE_TO_ABS,                  <i>/* pocatecni bod */</i>
                              VG_LINE_TO_REL,                  <i>/* prvni usecka (vodorovna) */</i>
                              VG_LINE_TO_REL,                  <i>/* druha usecka (svisla) */</i>
                              VG_LINE_TO_REL,                  <i>/* treti usecka (vodorovna) */</i>
                              VG_CLOSE_PATH};                  <i>/* uzavreni cesty */</i>
&nbsp;
        VGfloat coordinates[] = {20, 20,                       <i>/* pocatecni bod */</i>
                                 state-&gt;window_width-40, 0,    <i>/* prvni usecka (vodorovna) */</i>
                                 0, state-&gt;window_height-40,   <i>/* druha usecka (svisla) */</i>
                                 -state-&gt;window_width+40, 0};  <i>/* treti usecka (vodorovna) */</i>
&nbsp;
        <i>/* pridani useckoveho segmentu */</i>
        vgAppendPathData(path, 5, commands, coordinates); 
&nbsp;
        <i>/* usecka nema "vnitrek", proto se pouzije pouze VG_STROKE_PATH */</i>
        vgDrawPath(path, VG_STROKE_PATH);
        vgDestroyPath(path);
    }
&nbsp;
    <i>/* prohozeni predniho a zadniho bufferu (pokud je to zapotrebi) */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
int main(int argc, char *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    draw(&amp;egl_state);
    getchar();
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    return 0;
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všech pět demonstračních příkladů, které jsme si v&nbsp;dnešním článku
popsali, bylo uloženo do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy všech
pěti zmíněných demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>GitHub</th></tr>
<tr><td>1</td><td>example10</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example10">https://github.com/tisnik/presentations/tree/master/openvg/example10</a></td></tr>
<tr><td>2</td><td>example11</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example11">https://github.com/tisnik/presentations/tree/master/openvg/example11</a></td></tr>
<tr><td>3</td><td>example12</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example12">https://github.com/tisnik/presentations/tree/master/openvg/example12</a></td></tr>
<tr><td>4</td><td>example13</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example13">https://github.com/tisnik/presentations/tree/master/openvg/example13</a></td></tr>
<tr><td>5</td><td>example14</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example14">https://github.com/tisnik/presentations/tree/master/openvg/example14</a></td></tr>
</table>

<p>Poznámka<sup>1</sup>: pro zjednodušení překladu je ke každému demonstračnímu
příkladu přiložen i příslušný soubor Makefile (otestovaný na Raspberry Pi).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>So What's the Big Deal with Horizontal and Vertical Bezier Handles Anyway? (pro grafiky)<br />
<a href="http://theagsc.com/blog/tutorials/so-whats-the-big-deal-with-horizontal-vertical-bezier-handles-anyway/">http://theagsc.com/blog/tutorials/so-whats-the-big-deal-with-horizontal-vertical-bezier-handles-anyway/</a>
</li>

<li>EGL quick reference card<br />
<a href="https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf">https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf</a>
</li>

<li>EGL Reference Pages Index<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php">https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php</a>
</li>

<li>Funkce eglInitialize<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml</a>
</li>

<li>Funkce eglGetDisplay<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml</a>
</li>

<li>Funkce eglGetConfigs<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml</a>
</li>

<li>Funkce eglGetConfigAttrib<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml</a>
</li>

<li>Funkce eglDestroySurface<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml</a>
</li>

<li>Funkce eglDestroyContext<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml</a>
</li>

<li>Funkce eglTerminate<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml</a>
</li>

<li>Khronos Native Platform Graphics Interface<br />
<a href="https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf">https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf</a>
</li>

<li>Khronos Group<br />
<a href="https://www.khronos.org/">https://www.khronos.org/</a>
</li>

<li>Khronos Group (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Khronos_Group">https://en.wikipedia.org/wiki/Khronos_Group</a>
</li>

<li>Raspberry Pi VideoCore APIs<br />
<a href="http://elinux.org/Raspberry_Pi_VideoCore_APIs">http://elinux.org/Raspberry_Pi_VideoCore_APIs</a>
</li>

<li>Programming AudioVideo on the Raspberry Pi GPU<br />
<a href="https://jan.newmarch.name/RPi/index.html">https://jan.newmarch.name/RPi/index.html</a>
</li>

<li>The Standard for Vector Graphics Acceleration<br />
<a href="https://www.khronos.org/openvg/">https://www.khronos.org/openvg/</a>
</li>

<li>OpenVG (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenVG">https://en.wikipedia.org/wiki/OpenVG</a>
</li>

<li>OpenVG Quick Reference Card<br />
<a href="https://www.khronos.org/files/openvg-quick-reference-card.pdf">https://www.khronos.org/files/openvg-quick-reference-card.pdf</a>
</li>

<li>OpenVG on the Raspberry Pi<br />
<a href="http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html">http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html</a>
</li>

<li>ShivaVG: open-source ANSI C OpenVG <br />
<a href="http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html">http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html</a>
</li>

<li>Testbed for exploring OpenVG on the Raspberry Pi<br />
<a href="https://github.com/ajstarks/openvg">https://github.com/ajstarks/openvg</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame prakticky<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: práce s bitmapami a TrueType fonty<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: sprity v knihovně Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: detekce kolize spritů<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: transformace rastrových obrázků<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/</a>
</li>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

