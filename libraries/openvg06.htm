<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;šesté části seriálu o grafické knihovně OpenVG se seznámíme se způsoby manipulace s&nbsp;rastrovými obrázky, protože prakticky ve všech aplikacích, v&nbsp;nichž by se knihovna OpenVG mohla použít, se kromě 2D objektů popsaných vektorově setkáme i s&nbsp;běžnými bitmapami.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG</a></p>
<p><a href="#k02">2. Vykreslovací pipeline implementovaná v&nbsp;knihovně OpenVG</a></p>
<p><a href="#k03">3. Jednotlivé operace prováděné ve vykreslovací pipeline</a></p>
<p><a href="#k04">4. Rastrové obrázky v&nbsp;OpenVG</a></p>
<p><a href="#k05">5. Formáty RGB (pixely bez průhlednosti)</a></p>
<p><a href="#k06">6. Formáty RGBA (pixely s&nbsp;průhledností)</a></p>
<p><a href="#k07">7. Speciální formáty (černobílý obrázek, obrázek ve stupních šedi atd.)</a></p>
<p><a href="#k08">8. Základní funkce určené pro operace s&nbsp;rastrovými obrázky</a></p>
<p><a href="#k09">9. Vytvoření obrázku &ndash; funkce <strong>vgCreateImage()</strong></a></p>
<p><a href="#k10">10. Odstranění obrázku &ndash; funkce <strong>vgDestroyImage()</strong></a></p>
<p><a href="#k11">11. Smazání vybraného regionu &ndash; funkce <strong>vgClearImage()</strong></a></p>
<p><a href="#k12">12. Zápis pixelů do rastrového obrázku &ndash; funkce <strong>vgImageSubData()</strong></a></p>
<p><a href="#k13">13. Přečtení pixelů z&nbsp;rastrového obrázku &ndash; funkce <strong>vgGetImageSubData()</strong></a></p>
<p><a href="#k14">14. Vykreslení rastrového obrázku &ndash; funkce <strong>vgDrawImage()</strong></a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;rastrovými obrázky v&nbsp;knihovně OpenVG</h2>

<p>V&nbsp;knihovně OpenVG se pracuje se dvěma velmi odlišnými typy 2D objektů.
Prvním typem 2D objektů jsou cesty (<i>paths</i>), kterým jsme se již podrobně
věnovali v&nbsp;předchozích třech částech tohoto seriálu a druhým typem 2D
objektů jsou rastrové obrázky (bitmapy, pixmapy). V&nbsp;knihovně OpenVG je
možné provádět následující operace nad rastrovými obrázky:</p>

<ol>
<li>Vytvoření nového objektu typu obrázek (<strong>VGImage</strong>) se zvoleným formátem.</li>
<li>Zrušení obrázku a jeho následné odstranění z&nbsp;paměti GPU.</li>
<li>Vytvoření podobrázku (child image)</li>
<li>Vykreslení obrázku na aktuální kreslicí plochu.</li>
<li>Vymazání zvoleného regionu (osově orientovaného obdélníku) v&nbsp;obrázku.</li>
<li>Přečtení všech pixelů ve zvoleném regionu (osově orientovaného obdélníku).</li>
<li>Zápis všech pixelů do zvoleného regionu (osově orientovaného obdélníku).</li>
<li>Kopie dat mezi dvěma obrázky popř.&nbsp;provedení konverze pixelů.</li>
<li>Přenos pixelů mezi obrázkem a kreslicí plochou.</li>
</ol>

<p>Jednotlivé operace si postupně popíšeme v&nbsp;navazujících kapitolách.</p>

<p>Co v&nbsp;OpenVG naopak nenajdeme:</p>

<ol>
<li>Funkce pro načítání a ukládání obrázků z&nbsp;rastrových formátů (GIF, PNG, JPEG, BMP...).</li>
<li>Funkce pro DCT, filtraci, aplikaci barvové palety apod.</li>
</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vykreslovací pipeline implementovaná v&nbsp;knihovně OpenVG</h2>

<p>S&nbsp;principem činnosti vykreslovací pipeline jsme se sice již ve
stručnosti seznámili v&nbsp;článku obsahujícím stručný <a
href="https://www.root.cz/clanky/strucny-prehled-grafickych-knihoven-pro-raspberry-pi/">přehled
grafických knihoven určených (nejenom) pro jednodeskové mikropočítače Raspberry
Pi</a>, ovšem některé probíhající operace, zejména pak operace týkající se
práce s&nbsp;rastrovými obrázky, je vhodné si dnes popsat podrobněji. Podívejme
se nyní na typický způsob realizace vykreslovací pipeline v&nbsp;knihovně
OpenVG, protože způsob postupné aplikace jednotlivých operací v&nbsp;pipeline
vlastně přímo určuje, jakým způsobem se budou jednotlivé grafické prvky
vykreslovat.</p>

<p>Vykreslování probíhá v&nbsp;několika krocích popsaných <a
href="#k03">v&nbsp;navazující kapitole</a>, které mohou být skutečně prováděny
v&nbsp;pipeline za účelem urychlení vykreslování, při softwarové implementaci
však pravděpodobně budou prováděny sekvenčně (z&nbsp;principu činnosti
hardwarové pipeline implementované v&nbsp;GPU samozřejmě vyplývá, že jakmile je
jedna operace vykonána nad jednou sadou dat, může se začít vykonávat nad další
sadou, takže vlastně všechny operace probíhají současně, i když nad jinými
částmi renderovaného obrazu a nad odlišnými vstupními daty).</p>

<p>Všech osm operací prováděných ve vykreslovací pipeline je zobrazeno <a
href="https://www.khronos.org/openvg/#openvg_rendering">v&nbsp;tomto dokumentu</a>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jednotlivé operace prováděné ve vykreslovací pipeline</h2>

<ol>

<li>Na vstupu do vykreslovací pipeline se nachází informace o dvourozměrných
grafických objektech, které se mají vykreslit. Jedná se především o cesty
(<i>path</i>), s&nbsp;nimiž jsme se seznámili v&nbsp;předchozích třech článcích
[<a
href="https://www.root.cz/clanky/2d-grafika-s-vyuzitim-knihovny-openvg-nejenom-na-raspberry-pi-cesty/">1</a>]
[<a
href="https://www.root.cz/clanky/2d-grafika-s-vyuzitim-knihovny-openvg-nejenom-na-raspberry-pi-cesty-1/">2</a>]
[<a
href="https://www.root.cz/clanky/2d-grafika-s-vyuzitim-knihovny-openvg-prace-s-cestami-dokonceni/">3</a>],
informace o lineárních transformacích, které se mají provést
(<i>transformation</i>), <a
href="https://www.root.cz/clanky/2d-grafika-s-vyuzitim-knihovny-openvg-nejenom-na-raspberry-pi/#k09">informace
o štětcích</a> použitých při vykreslování (<i>stroke</i>) a konečně informace o
způsobu vykreslení výplně uzavřených křivek resp.&nbsp;cest
(<i>paint</i>).</li>

<li>Prvním krokem je aplikace štětců (<i>stroke</i>) na cesty (<i>path</i>).
Výsledkem této operace je datová struktura popisující vrcholy mnohoúhelníků,
které budou následně při vlastní rasterizaci pospojovány. Pokud se má například
vykreslit široká úsečka, vznikne aplikací štětce úzký obdélník. V&nbsp;případě
čárkované úsečky pak sekvence obdélníků. V&nbsp;průběhu této operace se
samozřejmě berou v&nbsp;úvahu i styly štětce, tj.&nbsp;případné zaoblení konců
cesty a zakulacení všech zlomů. Je dobré si uvědomit, že tato operace není
příliš rychlá, zejména ve chvíli, kdy jsou použity kruhové a eliptické oblouky
či Bézierovy křivky.</li>

<li>V&nbsp;dalším kroku následuje transformace souřadnic vrcholů na základě
vstupních informací (transformačních matic). Transformovány jsou samozřejmě
vrcholy vypočtené v&nbsp;předchozím kroku, tj.&nbsp;nikoli vrcholy původní
cesty zadané uživatelem/programátorem, ale vrcholy popisující obrysy cesty. Pod
pojmem transformace si můžeme představit především posun, změnu měřítka či
otočení (popř.&nbsp;kombinaci těchto transformací). Transformovány jsou i
obrysy rastrových obrázků, což je téma, které nás dnes zajímá.</li>

<li>V&nbsp;dalším kroku je prováděna takzvaná <i>rasterizace</i>,
tj.&nbsp;převod geometrického tvaru představujícího obrys cesty na pixely. My
jsme se již s&nbsp;rasterizací setkali dříve, a to konkrétně při implementaci
algoritmů určených pro vykreslování úseček. Ovšem vzhledem k&nbsp;podpoře
složitějších tvarů a zejména kvůli dosažení lepší kvality výsledného obrázku
v&nbsp;OpenVG jsou zde implementované rasterizační algoritmy složitější
(v&nbsp;pozdějších krocích se volitelně provádí i antialiasing pro zmenšení
viditelnosti &bdquo;schodků&ldquo; šikmých úseček). Navíc se rasterizace nemusí
provádět přímo do framebufferu, ale například do bitmapy uložené v&nbsp;paměti
GPU (to z&nbsp;toho důvodu, aby bylo možné jednoduše a poměrně přímočaře
aplikovat další tři kroky vykreslovací pipeline).</li>

<li>Již během rasterizace popř.&nbsp;v&nbsp;navazujícím kroku se provádí
ořezání (<i>clipping</i> a <i>scissoring</i>) a popř.&nbsp;maskování
(<i>masking</i>), opět na základě údajů získaných z&nbsp;uživatelské aplikace
(ořezové obdélníky, bitová maska apod.). Ořezání je nejdříve provedeno takovým
způsobem, aby se odstranily fragmenty ležící mimo vykreslovací plochu (typicky
obrazovku). Současně je možné provést další ořezání, a to s&nbsp;využitím
takzvaných ořezových obdélníků (<i>scissoring rectangles</i>), kterých může
uživatel zadat větší množství a vytvořit z&nbsp;nich popř.&nbsp;i složitější
tvar.</li>

<li>Následuje případná výplň uzavřených tvarů (<i>paint</i>). Nejjednodušší
výplní je konstantní barva (to jsme si již ukázali v&nbsp;několika
demonstračních příkladech), lze však použít i složitější styl výplně, včetně
gradientních přechodů a textur.</li>

<li>Při některých operacích s&nbsp;rastrovými obrázky je nutné aplikovat
(bilineární) interpolaci. Jedná se zejména o zvětšení, zmenšení či otočení
obrázku před jeho vykreslením do framebufferu. Tuto důležitou operaci si
vysvětlíme dále.</li>

<li>Poslední prováděnou operací je <i>blending</i>, tj.&nbsp;aplikace nějaké
funkce (například lineární interpolace) na barvy pixelů ve zdrojovém obrázku
(získaném rasterizací a vyplněním uzavřených ploch) a v&nbsp;obrázku cílovém
(což může být například framebuffer).</li>

</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rastrové obrázky v&nbsp;OpenVG</h2>

<p>V&nbsp;pojetí knihovny OpenVG nejsou rastrové obrázky nic jiného než
obdélníková mřížka tvořená jednotlivými pixely s&nbsp;přidanými metainformacemi
(rozměry bitmapy, formát atd.). Pixely nemusí v&nbsp;paměti tvořit kontinuální
region, protože mezi jednotlivými obrazovými řádky mohou být vytvořeny mezery
(<i>stride</i>). Formát jednotlivých pixelů je volitelný &ndash;
k&nbsp;dispozici je několik dostupných formátů, i když například obrázky
s&nbsp;barvovou paletou zde nenajdeme. Mnoho formátů pixelů je vytvořeno
takovým způsobem, že je každému pixelu přiřazena i průhlednost (alfa kanál).
Ovšem formát pixelů popsaný ve specifikaci (a taktéž v&nbsp;navazujících
kapitolách) se projevuje &bdquo;pouze&ldquo; při čtení či zápisu pixelů do
obrázku. Naproti tomu interní formát uložení pixelů (a vlastně i celých bitmap)
použitý v&nbsp;paměti GPU není nikde specifikován, takže se tvůrci každé
implementace mohou sami rozhodnout, jakým způsobem se budou obrázky ukládat do
obrazové paměti. Případné konverze však musí probíhat beze ztráty kvality, což
je mj.&nbsp;kontrolováno akceptačními testy každé implementace.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Formáty RGB (pixely bez průhlednosti)</h2>

<p>V&nbsp;první skupině formátů pixelů nalezneme takové formáty, v&nbsp;nichž
není použit alfa kanál. K&nbsp;dispozici je celkem deset alternativ, přičemž
první dva formáty mají 16 bitů na pixel (bpp), takže barvová složka R a B
využívá pět bitů a barvová složka G šest bitů (vyšší citlivost oka v&nbsp;této
frekvenční oblasti). Dalších osm formátů již používá pro každou barvovou složku
osm bitů, přičemž zbývajících osm bitů do 32 bitového slova je nevyužito (může
v&nbsp;nich být zapsáno cokoli, ale tyto hodnoty se nijak neinterpretují).
Formáty začínající na <strong>VG_s</strong> využívají nelineární barvový
prostor sRGB (převod mezi lineárními složkami a složkami nelineárními je <a
href="https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation">popsán
zde</a>) zatímco formáty začínající na <strong>VG_l</strong> používají lineární
RGB &ndash; zde tedy záleží na tom, jak jsou reprezentována vstupní data a zda
se neprovádí konverze již při jejich načítání (libpng atd.):</p>

<table>
<tr><th> #</th><th>Konstanta</th><th>Bitů/pixel</th><th>Další vlastnosti</th></tr>
<tr><td> 1</td><td>VG_sRGB_565  </td><td>16</td><td>nelineární barvový prostor <a href="https://cs.wikipedia.org/wiki/SRGB">sRGB</a></td></tr>
<tr><td> 2</td><td>VG_sBGR_565  </td><td>16</td><td>nelineární barvový prostor <a href="https://cs.wikipedia.org/wiki/SRGB">sRGB</a></td></tr>
<tr><td> 3</td><td>VG_sRGBX_8888</td><td>32</td><td>nelineární barvový prostor <a href="https://cs.wikipedia.org/wiki/SRGB">sRGB</a></td></tr>
<tr><td> 4</td><td>VG_lRGBX_8888</td><td>32</td><td>lineární barvový prostor</td></tr>
<tr><td> 5</td><td>VG_sXRGB_8888</td><td>32</td><td>nelineární barvový prostor <a href="https://cs.wikipedia.org/wiki/SRGB">sRGB</a></td></tr>
<tr><td> 6</td><td>VG_lXRGB_8888</td><td>32</td><td>lineární barvový prostor</td></tr>
<tr><td> 7</td><td>VG_sBGRX_8888</td><td>32</td><td>nelineární barvový prostor <a href="https://cs.wikipedia.org/wiki/SRGB">sRGB</a></td></tr>
<tr><td> 8</td><td>VG_lBGRX_8888</td><td>32</td><td>lineární barvový prostor</td></tr>
<tr><td> 9</td><td>VG_sXBGR_8888</td><td>32</td><td>nelineární barvový prostor <a href="https://cs.wikipedia.org/wiki/SRGB">sRGB</a></td></tr>
<tr><td>10</td><td>VG_lXBGR_8888</td><td>32</td><td>lineární barvový prostor</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Formáty RGBA (pixely s&nbsp;průhledností)</h2>

<p>Dalších 24 formátů je navrženo takovým způsobem, že se u každého pixelu
kromě barvových složek R, G a B používá i alfa kanál, ať již plnohodnotný
4bitový či 8bitový alfa kanál či jen jednobitová informace o průhlednosti
pixelu (0 nebo 1, resp. 0% nebo 100%). Těchto 24 formátů vlastně vzniklo
kombinací čtyř parametrů:</p>

<ol>
<li>Lineární prostor RGB nebo sRGB: <strong>VG_s/VG_l</strong></li>
<li>Uložení složek v&nbsp;pořadí <strong>RGBA/ARGB/BGRA/ABGR</strong></li>
<li>Počet bitů: 8+8+8+8, 5+5+5+1 (zde je alfa kanál jen jednobitový), 4+4+4+4</li>
<li>Zda jsou barvové složky dopředu vynásobeny alfa hodnotou: (R, G, B, α) versus (α* R, α* G, α* B, α)</li>
</ol>

<p>Povšimněte si, že koncovka <strong>_PRE</strong> je použita pouze u formátů,
v&nbsp;nichž jsou všechny tři barvové složky reprezentovány osmi bity (stejně
jako alfa kanál):</p>

<table>
<tr><th> #</th><th>Konstanta</th><th>Bitů/pixel</th><th>Další vlastnosti</th></tr>
<tr><td> 1</td><td>VG_sRGBA_8888    </td><td>32</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>VG_sRGBA_8888_PRE</td><td>32</td><td>složky R, G, B jsou vynásobeny hodnotou α</td></tr>
<tr><td> 3</td><td>VG_sRGBA_5551    </td><td>16</td><td>jednobitový alfa kanál</td></tr>
<tr><td> 4</td><td>VG_sRGBA_4444    </td><td>16</td><td>všechny složky mají pouze čtyři bity (12bitová hloubka)</td></tr>
<tr><td> 5</td><td>VG_lRGBA_8888    </td><td>32</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>VG_lRGBA_8888_PRE</td><td>32</td><td>složky R, G, B jsou vynásobeny hodnotou α</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>VG_sARGB_8888    </td><td>32</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>VG_sARGB_8888_PRE</td><td>32</td><td>složky R, G, B jsou vynásobeny hodnotou α</td></tr>
<tr><td> 9</td><td>VG_sARGB_1555    </td><td>16</td><td>jednobitový alfa kanál</td></tr>
<tr><td>10</td><td>VG_sARGB_4444    </td><td>16</td><td>všechny složky mají pouze čtyři bity (12bitová hloubka)</td></tr>
<tr><td>11</td><td>VG_lARGB_8888    </td><td>32</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>VG_lARGB_8888_PRE</td><td>32</td><td>složky R, G, B jsou vynásobeny hodnotou α</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>VG_sBGRA_8888    </td><td>32</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>VG_sBGRA_8888_PRE</td><td>32</td><td>složky R, G, B jsou vynásobeny hodnotou α</td></tr>
<tr><td>15</td><td>VG_sBGRA_5551    </td><td>16</td><td>jednobitový alfa kanál</td></tr>
<tr><td>16</td><td>VG_sBGRA_4444    </td><td>16</td><td>všechny složky mají pouze čtyři bity (12bitová hloubka)</td></tr>
<tr><td>17</td><td>VG_lBGRA_8888    </td><td>32</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>VG_lBGRA_8888_PRE</td><td>32</td><td>složky R, G, B jsou vynásobeny hodnotou α</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>VG_sABGR_8888    </td><td>32</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>VG_sABGR_8888_PRE</td><td>32</td><td>složky R, G, B jsou vynásobeny hodnotou α</td></tr>
<tr><td>21</td><td>VG_sABGR_1555    </td><td>16</td><td>jednobitový alfa kanál</td></tr>
<tr><td>22</td><td>VG_sABGR_4444    </td><td>16</td><td>všechny složky mají pouze čtyři bity (12bitová hloubka)</td></tr>
<tr><td>23</td><td>VG_lABGR_8888    </td><td>32</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>VG_lABGR_8888_PRE</td><td>32</td><td>složky R, G, B jsou vynásobeny hodnotou α</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Speciální formáty (černobílý obrázek, obrázek ve stupních šedi atd.)</h2>

<p>Posledních šest dostupných formátů pixelů je možné rozdělit na tři skupiny.
Nejjednodušší je formát <strong>VG_BW_1</strong> pro specifikaci černobílých
obrázků (0=černý pixel, 1=bílý pixel), následují dva formáty pixelů
reprezentujících stupně šedi (dostupná je ovšem pouze osmibitová hloubka) a
speciální použití mají formáty obsahující pouze alfa kanál. Takové obrázky je
možné použít například pro ztmavení části 2D scény, pro poloprůhlednou výplň
cest atd.:</p>

<table>
<tr><th>#</th><th>Konstanta</th><th>Bitů/pixel</th><th>Další vlastnosti</th></tr>
<tr><td>1</td><td>VG_BW_1</td><td>1</td><td>černobílý obrázek</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>VG_sL_8</td><td>8</td><td>stupně šedi (grayscale)</td></tr>
<tr><td>3</td><td>VG_lL_8</td><td>8</td><td>stupně šedi (grayscale)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>VG_A_1 </td><td>1</td><td>pouze alfa kanál</td></tr>
<tr><td>5</td><td>VG_A_4 </td><td>4</td><td>pouze alfa kanál</td></tr>
<tr><td>6</td><td>VG_A_8 </td><td>8</td><td>pouze alfa kanál</td></tr>
</table>

<p>Poznámka: pokud máte na vstupu aplikace obrázky s&nbsp;barvovou paletou,
jsou případné konverze ponechány na samotných programátorech aplikace či na
vývojářích pomocných knihoven (libpng, ...). Tuto problematiku OpenVG vůbec
neřeší.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní funkce určené pro operace s&nbsp;rastrovými obrázky</h2>

<p>V&nbsp;následujících šesti kapitolách si ve stručnosti popíšeme šest
základních funkcí určených pro práci s&nbsp;rastrovými obrázky. Dovolím si
říci, že pro většinu aplikací postačuje znát pouze těchto šest funkcí, i když
knihovna OpenVG ve skutečnosti nabízí i další funkce (které budou popsány
příště). Mezi základní šestici patří:</p>

<ol>
<li>Vytvoření nového obrázku: <a href="#k09"><strong>vgCreateImage()</strong></a>.</li>
<li>Zrušení obrázku a jeho následné odstranění z&nbsp;paměti GPU: <a href="#k10"><strong>vgDestroyImage()</strong></a>.</li>
<li>Vymazání zvoleného regionu (obdélníku): <a href="#k11"><strong>vgClearImage()</strong></a>.</li>
<li>Zápis všech pixelů do zvoleného regionu: <a href="#k12"><strong>vgImageSubData()</strong></a>.</li>
<li>Přečtení všech pixelů ve zvoleném regionu: <a href="#k13"><strong>vgGetImageSubData()</strong></a>.</li>
<li>Vykreslení obrázku na aktuální kreslicí plochu: <a href="#k14"><strong>vgDrawImage()</strong></a>.</li>
</ol>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vytvoření obrázku &ndash; funkce <strong>vgCreateImage()</strong></h2>

<p>První operací při práci s&nbsp;rastrovými obrázky je (pochopitelně) jejich
vytvoření, o což se stará funkce:</p>

<pre>
VGImage <strong>vgCreateImage</strong>(
    VGImageFormat format,
    VGint         width,
    VGint         height,
    VGbitfield    allowedQuality);
</pre>

<p>Této funkci se předávají čtyři parametry:</p>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>format        </td><td>jedna ze symbolických konstant popsaných v&nbsp;předchozích kapitolách</td></tr>
<tr><td>2</td><td>width         </td><td>šířka v&nbsp;pixelech, musí být menší než VG_MAX_IMAGE_WIDTH</td></tr>
<tr><td>3</td><td>height        </td><td>výška v&nbsp;pixelech, musí být menší než VG_MAX_IMAGE_HEIGHT</td></tr>
<tr><td>4</td><td>allowedQuality</td><td>VG_IMAGE_QUALITY_NONANTIALIASED kombinované s&nbsp;VG_IMAGE_QUALITY_FASTER či VG_IMAGE_QUALITY_BETTER</td></tr>
</table>

<p>Poslední parametr ovlivňuje všechny operace, při nichž dochází k&nbsp;rotaci
či ke změně měřítka bitmapy. Pokud je zaručeno mapování pixelů na obrazovku
1:1, nemá tento parametr žádný vliv.</p>

<p>Vrácena je hodnota typu <strong>VGImage</strong>, která je použita ve všech
dalších pěti funkcích.</p>

<p>Povšimněte si, že se skutečně pouze vytvoří nový obrázek, ale zatím se do
něj nezapisují žádné pixely. Je to podobné situaci s&nbsp;cestami &ndash; tam
se taktéž nejprve vytvořila prázdná cesta, do níž se dalšími funkcemi mohly
přidat nové segmenty.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odstranění obrázku &ndash; funkce <strong>vgDestroyImage()</strong></h2>

<p>Opakem funkce <strong>vgCreateImage()</strong> je podle očekávání funkce
<strong>vgDestroyImage()</strong>, která celý obrázek odstraní z&nbsp;paměti
GPU. Ovšem ve chvíli, kdy je obrázek používán jiným objektem (cíl pro
vykreslování, obrázek použitý pro vyplnění uzavřených cest atd.), dojde
k&nbsp;jeho skutečnému uvolnění až ve chvíli, kdy jsou uvolněny i na obrázek
navázané objekty (interně se tedy pro každý obrázek pamatuje příznak
&bdquo;může být automaticky odstraněn&ldquo;):</p>

<pre>
void <strong>vgDestroyImage</strong>(
    VGImage       image);
</pre>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>image</td><td>reference na obrázek vytvořený funkcí <strong>vgCreateImage</strong></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Smazání vybraného regionu &ndash; funkce <strong>vgClearImage()</strong></h2>

<p>Pokud je zapotřebí vymazat nějaký region v&nbsp;obrázku konstantní barvou,
je možné pro tuto operaci použít funkci <strong>vgClearImage()</strong>. Tato
funkce použije barvu nastavenou parametrem <strong>VG_CLEAR_COLOR</strong> a
region, který se má vymazat, je specifikován osově orientovaným obdélníkem
začínajícím na souřadnicích [x,y], jehož strany mají délku width a height.
Vymazání je samozřejmě rychlejší, než přenos (konstantních) pixelů::</p>

<pre>
void <strong>vgClearImage</strong>(
    VGImage       image,
    VGint         x,
    VGint         y,
    VGint         width,
    VGint         height)
</pre>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>image</td><td>reference na obrázek vytvořený funkcí <strong>vgCreateImage</strong></td></tr>
<tr><td>2</td><td>x</td><td>x-ová souřadnice vrcholu obdélníka</td></tr>
<tr><td>3</td><td>y</td><td>y-ová souřadnice vrcholu obdélníka</td></tr>
<tr><td>4</td><td>width</td><td>šířka obdélníka</td></tr>
<tr><td>5</td><td>height</td><td>výška obdélníka</td></tr>
</table>

<p>Barvu pro vymazání lze nastavit takto:</p>

<pre>
/* vymazani casti obrazku cernou barvou */
VGfloat color1[4] = {0.0f, 0.0f, 0.0f, 1.0f};
vgSetfv(VG_CLEAR_COLOR, 4, color1);
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zápis pixelů do rastrového obrázku &ndash; funkce <strong>vgImageSubData()</strong></h2>

<p>Pro zápis pixelů z&nbsp;operační paměti do obrázku se používá funkce
pojmenovaná <strong>vgImageSubData()</strong>. Ve skutečnosti se při zápisu
mohou provádět i transformace pixelů mezi různými reprezentacemi. Knihovna
OpenVG totiž ví, jaký je formát již vytvořeného obrázku a ve funkci
<strong>vgImageSubData</strong> se specifikuje formát zapisovaných pixelů,
takže všechny údaje nutné pro konverzi jsou k&nbsp;dispozici. Dalším důležitým
parametrem je parametr <strong>dataStride</strong>, kterým lze specifikovat
mezery mezi jednotlivými obrazovými řádky (<i>stride</i>). Pozor na to, že
některé jiné knihovny používají namísto hodnoty <i>stride</i> hodnotu
<i>pitch</i>, což je ve skutečnosti offset mezi obrazovými řádky:
<i>pitch=width+stride</i>. Povšimněte si, že lze zapisovat jen do zvoleného
regionu:</p>

<pre>
void <strong>vgImageSubData</strong>(
    VGImage       image,
    const void   *data,
    VGint         dataStride,
    VGImageFormat dataFormat,
    VGint         x,
    VGint         y,
    VGint         width,
    VGint         height)
</pre>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>image</td><td>reference na obrázek vytvořený funkcí <strong>vgCreateImage</strong></td></tr>
<tr><td>2</td><td>data</td><td>ukazatel na zdrojová data pixelů uložených v&nbsp;operační paměti</td></tr>
<tr><td>3</td><td>dataStride</td><td>mezery mezi obrazovými řádky (na vstupu), hodnota je v&nbsp;bajtech</td></tr>
<tr><td>4</td><td>dataFormat</td><td>vstupní formát pixelů, jedna ze symbolických konstant popsaných v&nbsp;předchozích kapitolách</td></tr>
<tr><td>5</td><td>x</td><td>x-ová souřadnice vrcholu obdélníka</td></tr>
<tr><td>6</td><td>y</td><td>y-ová souřadnice vrcholu obdélníka</td></tr>
<tr><td>7</td><td>width</td><td>šířka obdélníka</td></tr>
<tr><td>8</td><td>height</td><td>výška obdélníka</td></tr>
</table>

<p>Jak tedy zobrazit nějaký obrázek?</p>

<ol>
<li>Načtení obrázku z&nbsp;externího souboru</li>
<li>Vytvoření nového objektu typu VGImage funkcí <strong>vgCreateImage</strong></li>
<li>Zápis pixelů do objektu typu VGImage funkcí <strong>vgImageSubData</strong></li>
<li>Vlastní vykreslení funkcí <strong>vgDrawPath</strong></li>
</ol>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přečtení pixelů z&nbsp;rastrového obrázku &ndash; funkce <strong>vgGetImageSubData()</strong></h2>

<p>Opakem funkce <strong>vgImageSubData</strong> je funkce nazvaná
<strong>vgGetImageSubData</strong> určená pro čtení pixelů z&nbsp;obrázku typu
VGImage, konverzi dat (pixelů) a následné uložení konvertovaných dat do zvolené
oblasti operační paměti:</p>

<pre>
void <strong>vgGetImageSubData</strong>(
    VGImage       image,
    void         *data,
    VGint         dataStride,
    VGImageFormat dataFormat,
    VGint         x,
    VGint         y,
    VGint         width,
    VGint         height);
</pre>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>image</td><td>reference na obrázek vytvořený funkcí <strong>vgCreateImage</strong></td></tr>
<tr><td>2</td><td>data</td><td>region v&nbsp;operační paměti, o jehož alokaci se musí postarat programátor</td></tr>
<tr><td>3</td><td>dataStride</td><td>mezery mezi obrazovými řádky (na výstupu), hodnota je v&nbsp;bajtech</td></tr>
<tr><td>4</td><td>dataFormat</td><td>výstupní formát pixelů, jedna ze symbolických konstant popsaných v&nbsp;předchozích kapitolách</td></tr>
<tr><td>5</td><td>x</td><td>x-ová souřadnice vrcholu obdélníka</td></tr>
<tr><td>6</td><td>y</td><td>y-ová souřadnice vrcholu obdélníka</td></tr>
<tr><td>7</td><td>width</td><td>šířka obdélníka</td></tr>
<tr><td>8</td><td>height</td><td>výška obdélníka</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vykreslení rastrového obrázku &ndash; funkce <strong>vgDrawImage()</strong></h2>

<p>Poslední dnes popisovaná funkce se jmenuje <strong>vgDrawImage()</strong> a
jak již její název napovídá, slouží tato funkce k&nbsp;vykreslení obrázku na
aktivní kreslicí plochu (<i>surface</i>). Chování této funkce je tedy do jisté
míry podobné funkci <strong>vgDrawPath()</strong> &ndash; ani zde se totiž
nespecifikuje cíl vykreslování. Obrázek může být vykreslen třemi způsoby: jako
skutečný obrázek (jedná se tedy o operaci typu <i>BitBLT</i>), zapisované barvy
pixelů se mohou násobit s&nbsp;nastavenou barvou (takto lze vykreslit
poloprůhledný obrázek atd.) a dokonce je možné obrázek (pixely) použít jako
masku (<i>stencil</i>) při vykreslování cest:</p>

<pre>
void <strong>vgDrawImage</strong>(
    VGImage       image);
</pre>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>image</td><td>reference na obrázek vytvořený funkcí <strong>vgCreateImage</strong></td></tr>
</table>

<p>Poznámka: všech šest dnes popisovaných funkcí bude příště použito
v&nbsp;demonstračních příkladech.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>So What's the Big Deal with Horizontal and Vertical Bezier Handles Anyway? (pro grafiky)<br />
<a href="http://theagsc.com/blog/tutorials/so-whats-the-big-deal-with-horizontal-vertical-bezier-handles-anyway/">http://theagsc.com/blog/tutorials/so-whats-the-big-deal-with-horizontal-vertical-bezier-handles-anyway/</a>
</li>

<li>EGL quick reference card<br />
<a href="https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf">https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf</a>
</li>

<li>EGL Reference Pages Index<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php">https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php</a>
</li>

<li>Funkce eglInitialize<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml</a>
</li>

<li>Funkce eglGetDisplay<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml</a>
</li>

<li>Funkce eglGetConfigs<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml</a>
</li>

<li>Funkce eglGetConfigAttrib<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml</a>
</li>

<li>Funkce eglDestroySurface<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml</a>
</li>

<li>Funkce eglDestroyContext<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml</a>
</li>

<li>Funkce eglTerminate<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml</a>
</li>

<li>Khronos Native Platform Graphics Interface<br />
<a href="https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf">https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf</a>
</li>

<li>Khronos Group<br />
<a href="https://www.khronos.org/">https://www.khronos.org/</a>
</li>

<li>Khronos Group (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Khronos_Group">https://en.wikipedia.org/wiki/Khronos_Group</a>
</li>

<li>Raspberry Pi VideoCore APIs<br />
<a href="http://elinux.org/Raspberry_Pi_VideoCore_APIs">http://elinux.org/Raspberry_Pi_VideoCore_APIs</a>
</li>

<li>Programming AudioVideo on the Raspberry Pi GPU<br />
<a href="https://jan.newmarch.name/RPi/index.html">https://jan.newmarch.name/RPi/index.html</a>
</li>

<li>The Standard for Vector Graphics Acceleration<br />
<a href="https://www.khronos.org/openvg/">https://www.khronos.org/openvg/</a>
</li>

<li>OpenVG (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenVG">https://en.wikipedia.org/wiki/OpenVG</a>
</li>

<li>OpenVG Quick Reference Card<br />
<a href="https://www.khronos.org/files/openvg-quick-reference-card.pdf">https://www.khronos.org/files/openvg-quick-reference-card.pdf</a>
</li>

<li>OpenVG on the Raspberry Pi<br />
<a href="http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html">http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html</a>
</li>

<li>ShivaVG: open-source ANSI C OpenVG <br />
<a href="http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html">http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html</a>
</li>

<li>Testbed for exploring OpenVG on the Raspberry Pi<br />
<a href="https://github.com/ajstarks/openvg">https://github.com/ajstarks/openvg</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame prakticky<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: práce s bitmapami a TrueType fonty<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: sprity v knihovně Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: detekce kolize spritů<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: transformace rastrových obrázků<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/</a>
</li>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

<li>Vykreslovací pipeline OpenVG (schéma)<br />
<a href="https://www.khronos.org/assets/uploads/apis/openvg_pipeline1.jpg">https://www.khronos.org/assets/uploads/apis/openvg_pipeline1.jpg</a>
</li>

<li>sRGB<br />
<a href="https://cs.wikipedia.org/wiki/SRGB">https://cs.wikipedia.org/wiki/SRGB</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

