<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>2D grafika s využitím knihovny OpenVG (nejenom) na Raspberry Pi: cesty</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>2D grafika s využitím knihovny OpenVG (nejenom) na Raspberry Pi: cesty</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Vykreslování je v&nbsp;grafické knihovně OpenVG z&nbsp;velké části založeno na konceptu takzvaných cest (paths), takže se v&nbsp;dnešním článku budeme zabývat především popisem segmentů, z&nbsp;nichž se jednotlivé cesty mohou skládat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. 2D grafika s&nbsp;využitím knihovny OpenVG (nejenom) na Raspberry Pi: cesty</a></p>
<p><a href="#k02">2. Nastavení kvality vykreslování</a></p>
<p><a href="#k03">3. Specifikace fyzického formátu a tvarů pixelů pro subpixelový antialiasing</a></p>
<p><a href="#k04">4. Koncept cest v&nbsp;knihovně OpenVG</a></p>
<p><a href="#k05">5. Příkazy používané při tvorbě cesty</a></p>
<p><a href="#k06">6. Formát numerických hodnot pro specifikaci vrcholů</a></p>
<p><a href="#k07">7. Příkaz pro uzavření křivky</a></p>
<p><a href="#k08">8. Příkaz typu &bdquo;move to&ldquo;</a></p>
<p><a href="#k09">9. Lineární části cesty</a></p>
<p><a href="#k10">10. Kvadratické Bézierovy křivky</a></p>
<p><a href="#k11">11. Kubické Bézierovy křivky</a></p>
<p><a href="#k12">12. Křivkové segmenty garantující geometrickou spojitost G1</a></p>
<p><a href="#k13">13. Křivkové segmenty vytvořené z&nbsp;eliptických oblouků</a></p>
<p><a href="#k14">14. Operace, které je možné s&nbsp;cestami provádět</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. 2D grafika s&nbsp;využitím knihovny OpenVG (nejenom) na Raspberry Pi: cesty</h2>

<p>V&nbsp;dnešním článku o grafické knihovně <i>OpenVG</i> se budeme zabývat
popisem konceptu takzvaných cest (<i>paths</i>), protože z&nbsp;cest jsou
složeny prakticky všechny vykreslované 2D objekty, ať již se jedná o objekty
otevřené (úsečky, polyčáry, oblouky, křivky) či uzavřené (kruh, vyplněné
mnohoúhelníky apod.). Každá cesta se skládá z&nbsp;prakticky libovolného
množství segmentů (<i>segments</i>), přičemž je zajímavé, že jednotlivé
segmenty na sebe nemusí navazovat. Použití cest v&nbsp;2D grafice samozřejmě
není nic nového; spíš by se dalo říci, že se jedná o dlouhým časem prověřenou
technologii použitou například <a
href="http://www.root.cz/clanky/vytvarime-krivky-v-postscriptu/">v&nbsp;PostScriptu</a>
či <a
href="http://www.root.cz/clanky/vlastnosti-cest-a-zakladnich-geometrickych-tvaru-v-svg/">v&nbsp;SVG</a>
(PostScript lze přitom chápat jako souborový formát, programovací jazyk a
současně i vykreslovací knihovnu).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nastavení kvality vykreslování</h2>

<p>Před popisem způsobu tvorby cest se na chvíli zastavme u kvality jejich
vykreslování. To je možné v&nbsp;knihovně <i>OpenVG</i> do určité míry řídit
parametrem <strong>VG_RENDERING_QUALITY</strong>, jehož hodnota se nastavuje
funkcí <strong>vgSeti</strong>, s&nbsp;níž jsme se již seznámili minule. Zde si
jen připomeňme, že jednou provedené nastavení je platné pro celý kontext
&ndash; <i>rendering context</i> &ndash; a je možné ho kdykoli změnit.
Programátor si může zvolit tři úrovně: vypnutí antialiasingu při vykreslování,
režim co nejrychlejšího vykreslování a naopak režim co nejkvalitnějšího (a
většinou i nejpomalejšího) vykreslování:</p>

<pre>
vgSeti(VG_RENDERING_QUALITY, VG_RENDERING_QUALITY_NONANTIALIASED);
vgSeti(VG_RENDERING_QUALITY, VG_RENDERING_QUALITY_FASTER);
vgSeti(VG_RENDERING_QUALITY, VG_RENDERING_QUALITY_BETTER);
</pre>

<p>Výchozí volbou nastavenou při vytvoření nového kontextu je
<strong>VG_RENDERING_QUALITY_BETTER</strong>, takže pokud máte například ve hře
problém s&nbsp;výkonem či počtem snímků vykreslených za sekundu, můžete se
pokusit nastavit horší kvalitu.</p>

<p>Poznámka: specifikace ponechává způsob vykreslování na autorech konkrétní
implementace <i>OpenVG</i>, což mj.&nbsp;znamená, že dvě stejné scény se mohou
na různých implementacích odlišovat v&nbsp;barvě pixelů výsledné bitmapy.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Specifikace fyzického formátu a tvarů pixelů pro subpixelový antialiasing</h2>

<p>S&nbsp;kvalitou vykreslování velmi úzce souvisí i použití takzvaného
subpixelového antialiasingu, které se používá například při vykreslování písma.
Způsob výpočtu se ovlivňuje volbou <strong>VG_PIXEL_LAYOUT</strong>, pomocí níž
můžete určit, jaký je fyzický formát pixelů na displeji. Pixely jsou totiž na
většině displejů vytvořeny trojicí barevných pásků, které mohou být umístěny
horizontálně či vertikálně a odlišovat se mohou i pořadí barev (existují však i
různé další fyzické formáty pixelů). Ve většině případů je vhodné se spolehnout
na informace dodané samotným systémem, ale skutečně záleží jen na
programátorech, zda si do každé aplikace přidají dialog pro nastavení formátu
pixelů (který stejné uživatelé neznají, takže se musí spolehnout na vizuální
zpětnou vazbu).</p>

<pre>
vgSeti(VG_PIXEL_LAYOUT, VG_PIXEL_LAYOUT_UNKNOWN);
vgSeti(VG_PIXEL_LAYOUT, VG_PIXEL_LAYOUT_RGB_VERTICAL);
vgSeti(VG_PIXEL_LAYOUT, VG_PIXEL_LAYOUT_BGR_VERTICAL);
vgSeti(VG_PIXEL_LAYOUT, VG_PIXEL_LAYOUT_RGB_HORIZONTAL);
vgSeti(VG_PIXEL_LAYOUT, VG_PIXEL_LAYOUT_BGR_HORIZONTAL);
</pre>

<p>Poznámka: i pro toto nastavení platí, že specifikace knihovny <i>OpenVG</i>
přesně neurčuje, jakým způsobem (a zda vůbec) se subpixelový antialiasing při
vykreslování použije.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Koncept cest v&nbsp;knihovně OpenVG</h2>

<p>Po krátké odbočce k&nbsp;problematice kvality vykreslování se vraťme
k&nbsp;popisu cest v&nbsp;knihovně <i>OpenVG</i>. Jak jsme si již řekli
v&nbsp;úvodním odstavci, může se každá cesta skládat z&nbsp;libovolného
množství segmentů, přičemž segmentem může být úsečka, kvadratická Bézierova
křivka, kubická Bézierova křivka, kruhový oblouk či eliptický oblouk. Prázdná
cesta se vytváří funkcí <strong>vgCreatePath</strong>:</p>

<pre>
VGPath <strong>vgCreatePath</strong>(
    VGint          pathFormat,
    VGPathDatatype datatype,
    VGfloat        scale,
    VGfloat        bias,
    VGint          segmentCapacityHint,
    VGint          coordCapacityHint,
    VGbitfield     capabilities);
</pre>

<p>Tato funkce sice vyžaduje předání sedmi parametrů, ale ve skutečnosti se do
mnoha parametrů předává stále stejná hodnota. To je případ prvního parametru,
který bývá nastaven na <strong>VG_PATH_FORMAT_STANDARD</strong>. Ve druhém
parametru se specifikuje formát hodnot použitých pro uložení vrcholů
jednotlivých segmentů, což je problematika, které se věnuji <a
href="#k06">v&nbsp;šesté kapitole</a>. Následuje dvojice parametrů
<strong>scale</strong> a <strong>bias</strong>, které slouží pro jednoduchou
transformaci všech souřadnic podle vzorce <strong>scale*x+bias</strong>.
Typicky se předává <strong>scale=1.0</strong> a <strong>bias=0.0</strong>,
pokud je ovšem vstupní formát souřadnic nějak specifický, můžete hodnoty těchto
parametrů pochopitelně změnit. Parametry <strong>segmentCapacityHint</strong> a
<strong>coordCapacityHint</strong> slouží pouze pro optimalizaci alokátoru
paměti &ndash; předává se zde předpokládaná velikost cesty (počet segmentů,
celkový počet souřadnic). Pokud tyto hodnoty dopředu neznáte, nebo je nechcete
počítat, předává se 0 značící <strong>unknown</strong>. Význam posledního
parametru <strong>capabilities</strong> popisuji <a href="#k14">ve čtrnácté
kapitole</a>.</p>

<p>Segmenty se z&nbsp;cesty dají kdykoli odstranit funkcí
<strong>vgClearPath</strong>, jejíž hlavička je velmi jednoduchá (druhý
parametr bude opět vysvětlen <a href="#k14">ve čtrnácté kapitole</a>):</p>

<pre>
void <strong>vgClearPath</strong>(
    VGPath     path,
    VGbitfield capabilities);
</pre>

<p>Předposlední důležitou funkcí při práci s&nbsp;cestami je funkce nazvaná
<strong>vgDestroyPath</strong>, která cestu z&nbsp;aktuálního kontextu odstraní
a uvolní paměť (buď na grafickém akcelerátoru nebo obyčejnou operační paměť).
V&nbsp;aplikacích je vhodné tuto funkci zavolat co nejdříve a nenechávat
v&nbsp;paměti uloženo zbytečně velké množství cest:</p>

<pre>
void <strong>vgDestroyPath</strong>(
    VGPath path);
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Příkazy používané při tvorbě cesty</h2>

<p>Ve specifikaci <i>OpenVG</i> je popsáno celkem třináct různých příkazů pro
definici segmentů cest. Jednotlivé typy segmentů budou podrobněji popsány
v&nbsp;navazujících kapitolách, proto si zde pouze uveďme symbolické konstanty,
které jsou k&nbsp;typům segmentů přiřazeny:</p>

<table>
<tr><th> #</th><th>Symbolická konstanta</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td> 1</td><td>VG_CLOSE_PATH</td><td>0</td><td>uzavření cesty</td></tr>
<tr><td> 2</td><td>VG_MOVE_TO   </td><td>2</td><td>přesun aktivního bodu bez kreslení</td></tr>
<tr><td> 3</td><td>VG_LINE_TO   </td><td>4</td><td>lineární segment (úsečka)</td></tr>
<tr><td> 4</td><td>VG_HLINE_TO  </td><td>6</td><td>horizontální úsečka</td></tr>
<tr><td> 5</td><td>VG_VLINE_TO  </td><td>8</td><td>vertikální úsečka</td></tr>
<tr><td> 6</td><td>VG_QUAD_TO   </td><td>10</td><td>kvadratická Bézierova křivka</td></tr>
<tr><td> 7</td><td>VG_CUBIC_TO  </td><td>12</td><td>kubická Bézierova křivka</td></tr>
<tr><td> 8</td><td>VG_SQUAD_TO  </td><td>14</td><td>segment s&nbsp;G1 spojitostí tvořený kvadratickou křivkou</td></tr>
<tr><td> 9</td><td>VG_SCUBIC_TO </td><td>16</td><td>segment s&nbsp;G1 spojitostí tvořený kubickou křivkou</td></tr>
<tr><td>10</td><td>VG_SCCWARC_TO</td><td>18</td><td>kratší segment tvořený eliptickým obloukem</td></tr>
<tr><td>11</td><td>VG_SCWARC_TO </td><td>20</td><td>kratší segment tvořený eliptickým obloukem</td></tr>
<tr><td>12</td><td>VG_LCCWARC_TO</td><td>22</td><td>delší segment tvořený eliptickým obloukem</td></tr>
<tr><td>13</td><td>VG_LCWARC_TO </td><td>24</td><td>delší segment tvořený eliptickým obloukem</td></tr>
</table>

<p>Každý příkaz může používat absolutní souřadnice (vztažené vůči počátku
souřadného systému) či souřadnice relativní (vztažené vůči poslední zadané či
vypočtené souřadnici). Rozhodnutí o použití relativních či absolutních
souřadnicích se provádí na základě nejnižšího bitu příkazu, který může nabývat
hodnot:</p>

<table>
<tr><th>#</th><th>Symbolická konstanta</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td>1</td><td>VG_ABSOLUTE</td><td>0</td><td>příznak použití absolutních souřadnic</td></tr>
<tr><td>2</td><td>VG_RELATIVE</td><td>1</td><td>příznak použití relativních souřadnic</td></tr>
</table>

<p>Povšimněte si, že hodnoty symbolických konstant pro kreslení se zvyšují
s&nbsp;krokem 2, takže je zajištěno, že spodní bit bude vždy nulový. Díky tomu
lze zkombinovat příkaz pro kreslení s&nbsp;příznakem absolutních či relativních
souřadnic.  Bitovou aritmetiku (ve skutečnosti prosté OR) nemusíte provádět
ručně, protože příslušné kombinace konstant jsou již připraveny
v&nbsp;hlavičkových souborech.  První příkaz <strong>VG_CLOSE_PATH</strong> zde
samozřejmě není zahrnut, protože ten žádné souřadnice nepotřebuje:</p>

<table>
<tr><th> #</th><th>Symbolická konstanta</th><th>Vypočteno z</th></tr>
<tr><td> 1</td><td>VG_MOVE_TO_ABS   </td><td>VG_MOVE_TO    | VG_ABSOLUTE</td></tr>
<tr><td> 2</td><td>VG_MOVE_TO_REL   </td><td>VG_MOVE_TO    | VG_RELATIVE</td></tr>
<tr><td> 3</td><td>VG_LINE_TO_ABS   </td><td>VG_LINE_TO    | VG_ABSOLUTE</td></tr>
<tr><td> 4</td><td>VG_LINE_TO_REL   </td><td>VG_LINE_TO    | VG_RELATIVE</td></tr>
<tr><td> 5</td><td>VG_HLINE_TO_ABS  </td><td>VG_HLINE_TO   | VG_ABSOLUTE</td></tr>
<tr><td> 6</td><td>VG_HLINE_TO_REL  </td><td>VG_HLINE_TO   | VG_RELATIVE</td></tr>
<tr><td> 7</td><td>VG_VLINE_TO_ABS  </td><td>VG_VLINE_TO   | VG_ABSOLUTE</td></tr>
<tr><td> 8</td><td>VG_VLINE_TO_REL  </td><td>VG_VLINE_TO   | VG_RELATIVE</td></tr>
<tr><td> 9</td><td>VG_QUAD_TO_ABS   </td><td>VG_QUAD_TO    | VG_ABSOLUTE</td></tr>
<tr><td>10</td><td>VG_QUAD_TO_REL   </td><td>VG_QUAD_TO    | VG_RELATIVE</td></tr>
<tr><td>11</td><td>VG_CUBIC_TO_ABS  </td><td>VG_CUBIC_TO   | VG_ABSOLUTE</td></tr>
<tr><td>12</td><td>VG_CUBIC_TO_REL  </td><td>VG_CUBIC_TO   | VG_RELATIVE</td></tr>
<tr><td>13</td><td>VG_SQUAD_TO_ABS  </td><td>VG_SQUAD_TO   | VG_ABSOLUTE</td></tr>
<tr><td>14</td><td>VG_SQUAD_TO_REL  </td><td>VG_SQUAD_TO   | VG_RELATIVE</td></tr>
<tr><td>15</td><td>VG_SCUBIC_TO_ABS </td><td>VG_SCUBIC_TO  | VG_ABSOLUTE</td></tr>
<tr><td>16</td><td>VG_SCUBIC_TO_REL </td><td>VG_SCUBIC_TO  | VG_RELATIVE</td></tr>
<tr><td>17</td><td>VG_SCCWARC_TO_ABS</td><td>VG_SCCWARC_TO | VG_ABSOLUTE</td></tr>
<tr><td>18</td><td>VG_SCCWARC_TO_REL</td><td>VG_SCCWARC_TO | VG_RELATIVE</td></tr>
<tr><td>19</td><td>VG_SCWARC_TO_ABS </td><td>VG_SCWARC_TO  | VG_ABSOLUTE</td></tr>
<tr><td>20</td><td>VG_SCWARC_TO_REL </td><td>VG_SCWARC_TO  | VG_RELATIVE</td></tr>
<tr><td>21</td><td>VG_LCCWARC_TO_ABS</td><td>VG_LCCWARC_TO | VG_ABSOLUTE</td></tr>
<tr><td>22</td><td>VG_LCCWARC_TO_REL</td><td>VG_LCCWARC_TO | VG_RELATIVE</td></tr>
<tr><td>23</td><td>VG_LCWARC_TO_ABS </td><td>VG_LCWARC_TO  | VG_ABSOLUTE</td></tr>
<tr><td>24</td><td>VG_LCWARC_TO_REL </td><td>VG_LCWARC_TO  | VG_RELATIVE</td></tr>
</table>

<a href="http://www.root.cz/obrazek/241572/"><img src="https://i.iinfo.cz/images/224/openvg1-1.png" class="image-241572" alt="&#160;" width="125" height="170" /></a>
<p><i>Obrázek 1: Příklad cesty vytvořené z&nbsp;několika úsečkových (lineárních) segmentů.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Formát numerických hodnot pro specifikaci vrcholů</h2>

<p>Při specifikaci vrcholů jednotlivých křivkových segmentů, z&nbsp;nichž se
skládá celá cesta, je možné použít různé formáty numerických hodnot (každá
hodnota samozřejmě reprezentuje souřadnici <i>x</i>, souřadnici <i>y</i> či
relativní posun oproti předchozí hodnotě/souřadnici). Již při vytváření cesty
příkazem <strong>vgCreatePath</strong> se určuje, v&nbsp;jakém formátu budou
souřadnice jednotlivých vrcholů uloženy. Samozřejmě je vhodné zvolit takový
formát, který co nejlépe vyhovuje potřebám aplikace popř.&nbsp;formátu použitém
pro uložení vektorové grafiky (SVG, PostScript, SLD, starobylé WMF či EMF
atd.):</p>

<table>
<tr><th>#</th><th>Konstanta předaná do vgCreatePath</th><th>Formát</th><th>Bajtů/souřadnici</th></tr>
<tr><td>1</td><td>VG_PATH_DATATYPE_S_8 </td><td>8bitový integer se znaménkem </td><td>1</td></tr>
<tr><td>2</td><td>VG_PATH_DATATYPE_S_16</td><td>16bitový integer se znaménkem</td><td>2</td></tr>
<tr><td>3</td><td>VG_PATH_DATATYPE_S_32</td><td>32bitový integer se znaménkem</td><td>4</td></tr>
<tr><td>4</td><td>VG_PATH_DATATYPE_F   </td><td>typ float/single dle IEEE 754</td><td>4</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Příkaz pro uzavření křivky</h2>

<p>Nejjednodušším příkazem sloužícím pro vytvoření nového segmentu v&nbsp;cestě
je příkaz <strong>VG_CLOSE_PATH</strong>. Tento příkaz jednoduše do cesty přidá
úsečku spojující poslední vrchol s&nbsp;vrcholem prvním. Cesta se tak uzavře a
je jí možné v&nbsp;případě potřeby vyplnit (<i>paint</i>). Na rozdíl od všech
ostatních příkazů nepotřebuje <strong>VG_CLOSE_PATH</strong> specifikaci ani
jednoho vrcholu a navíc se i (celkem logicky) ignorují příznaky
<strong>VG_ABSOLUTE</strong> a <strong>VG_RELATIVE</strong>. Interně je tento
příkaz reprezentován jediným bajtem.</p>

<p>V&nbsp;SVG tomuto příkazu odpovídají dva příkazy:</p>

<table>
<tr><th>Příkaz</th><th>Parametry</th><th>Popis</th></tr>
<tr><td><strong>Z</strong></td><td>(nejsou)</td><td>uzavření cesty úsečkovým segmentem</td></tr>
<tr><td><strong>z</strong></td><td>(nejsou)</td><td>má stejný význam jako příkaz <strong>Z</strong></td></tr>
</table>

<p>Poznámka: ve skutečnosti může být tento příkaz použitý vícekrát a současně
se nemusí jednat o poslední příkaz při definici cesty.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Příkaz typu &bdquo;move to&ldquo;</h2>

<p>Jak jsme si již řekli v&nbsp;úvodních kapitolách, nemusí na sebe jednotlivé
segmenty, z&nbsp;nichž se cesta skládá, přímo navazovat. Jinými slovy mohou
cestu tvořit i izolované segmenty či skupiny segmentů (tyto na sebe navazující
segmenty se nazývají subpath). Pro přeskok na začátek dalšího segmentu (a
ukončení poslední subpath) se používá příkaz <strong>VG_MOVE_TO</strong>,
resp.&nbsp;jedna z&nbsp;jeho variant <strong>VG_MOVE_TO_ABS</strong> či
<strong>VG_MOVE_TO_REL</strong>. V&nbsp;obou případech tento příkaz akceptuje
dvojici souřadnic <i>x0</i>, <i>y0</i>, které se po obvyklé transformaci (viz
část textu o parametrech <i>scale</i> a <i>bias</i>) buď přičtou
k&nbsp;posledním známým souřadnicím či se přímo tyto souřadnice nastaví. Tímto
příkazem většinou definice cesty začíná.</p>

<p>V&nbsp;SVG tomuto příkazu odpovídají dva příkazy:</p>

<table>
<tr><th>Příkaz</th><th>Parametry</th><th>Popis</th></tr>
<tr><td><strong>M</strong></td><td>(x y)+</td><td>absolutní pohyb na souřadnice <i>[x, y]</i> bez kreslení. Pokud je uvedeno více párů <i>[x, y]</i>, všechny následující páry jsou považovány za parametry příkazu <i>lineto</i></td></tr>
<tr><td><strong>m</strong></td><td>(x y)+</td><td>relativní pohyb o souřadnice <i>[x, y]</i> bez kreslení. Pokud je uvedeno více párů <i>[x, y]</i>, všechny následující páry jsou považovány za parametry příkazu <i>lineto</i></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Lineární části cesty</h2>

<p>V&nbsp;cestě se může nacházet libovolné množství úseček. Pro jejich tvorbu
se používají tři základní příkazy <strong>VG_LINE_TO</strong>,
<strong>VG_HLINE_TO</strong> a <strong>VG_VLINE_TO</strong>, které se opět
modifikují příponami <strong>_REL</strong> a <strong>_ABS</strong>. Příkaz
<strong>VG_LINE_TO</strong> vyžaduje zadání obou relativních či absolutních
souřadnic (horizontální a vertikální), zatímco u příkazu
<strong>VG_HLINE_TO</strong> se očekává jen x-ová souřadnice a u příkazu
<strong>VG_VLINE_TO</strong> pouze souřadnice y-ová. Můžeme zde opět vidět
souvislost s&nbsp;knihovnou <i>SVG</i>, protože i v&nbsp;této knihovně
nalezneme při deklaraci cesty příkazy &bdquo;H&ldquo;, &bdquo;h&ldquo;,
&bdquo;L&ldquo; a &bdquo;l&ldquo; (ostatně jedním z&nbsp;důvodů vzniku
<i>OpenVG</i> je podpora <i>SVG</i>):</p>

<table>
<tr><th>Příkaz</th><th>Parametry</th><th>Popis</th></tr>
<tr><td><strong>L</strong></td><td>(x y)+</td><td>absolutní pohyb na souřadnice <i>[x, y]</i> s&nbsp;kreslením úsečkového segmentu. Je možné zapsat libovolné množství párů <i>[x, y]</i>, výsledkem jejich vykreslení je lomená čára.</td></tr>
<tr><td><strong>l</strong></td><td>(x y)+</td><td>relativní pohyb o souřadnice <i>[x, y]</i> s&nbsp;kreslením úsečkového segmentu. Je možné zapsat libovolné množství párů <i>[x, y]</i>, výsledkem jejich vykreslení je lomená čára.</td></tr>
<tr><td><strong>H</strong></td><td>x+</td><td> horizontální posun na absolutní souřadnici <i>x</i> s&nbsp;kreslením (vykreslení vodorovné úsečky). Je možné zapsat i více souřadnic, většinou to však nemá smysl (záleží však na nastaveném stylu cesty).</td></tr>
<tr><td><strong>h</strong></td><td>x+</td><td> relativní posun o hodnotu <i>x</i> v&nbsp;horizontálním směru (vykreslení vodorovné úsečky)</td></tr>
<tr><td><strong>V</strong></td><td>y+</td><td> vertikální posun na absolutní souřadnici <i>y</i> s&nbsp;kreslením (vykreslení svislé úsečky)</td></tr>
<tr><td><strong>v</strong></td><td>y+</td><td> relativní posun o hodnotu <i>y</i> ve vertikálním směru (vykreslení svislé úsečky)</td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Kvadratické Bézierovy křivky</h2>

<p>Cesta může obsahovat i segmenty složené z&nbsp;Bézierových křivek.
V&nbsp;knihovně <i>OpenVG</i> jsou podporovány jak Bézierovy kvadratické
křivky, tak i Bézierovy křivky kubické. Kvadratické křivky jsou specifikovány
trojicí řídicích bodů, zatímco křivky kubické potřebují pro zadání svého tvaru
čtyři řídicí body. Bézierova křivka obecně prochází pouze svým prvním a
posledním bodem (kotvicí body), ostatní body &bdquo;pouze&ldquo; ovlivňují
výsledný tvar křivky &ndash; jedná se tedy o aproximační křivky, i když je lze
po programových výpočtech použít i pro interpolaci. Ve speciálních případech
však křivka může procházet i dalšími (řídicími) body, například tehdy, když
všechny body leží na jedné přímce.</p>

<p>S&nbsp;využitím prvního bodu (kotvicího) a druhého bodu (řídicího) se určuje
tečný vektor na začátku křivky. Předposlední bod (řídicí) a poslední bod
(kotvicí) zase určují tečný vektor na konci křivky. Této vlastnosti se velmi
často využívá při hladkém navazování Bézierových křivek. Samozřejmě je také
možné stejným postupem hladce navázat Bézierovu křivku na úsečku či kruhový
oblouk.</p>

<a href="http://www.root.cz/obrazek/241573/"><img src="https://i.iinfo.cz/images/90/openvg2-1-prev.png" class="image-241573" alt="&#160;" width="360" height="270" /></a>
<p><i>Obrázek 2: Řídicí body kvadratických a kubických Bézierových křivek.</i></p>

<p>V&nbsp;knihovně <i>OpenVG</i> se Bézierovy křivky zadávají pomocí čtyř
variant příkazů, přičemž každá varianta existuje ve své absolutní a relativní
podobě podle toho, jakým způsobem jsou zadávány (a případně i dopočítávány)
souřadnice řídicích bodů.</p>

<p>Pro vytvoření Bézierovy kvadratické křivky se používá příkaz
<strong>VG_QUAD_TO_ABS</strong> popř.&nbsp;<strong>VG_QUAD_TO_REL</strong>,
který očekává dva vrcholy. Prvním vrcholem je řídicí bod křivky, druhým
vrcholem pak její koncový bod (počáteční bod již známe, je to aktuální konec
cesty). Ostatně jeden z&nbsp;důvodů oblíbenosti tohoto typu křivek
v&nbsp;počítačové grafice, zejména v&nbsp;oblasti fontů, spočívá v&nbsp;tom, že
pro definici křivky potřebujeme znát jen velmi malý počet řídicích bodů.</p>

<p>V&nbsp;SVG opět existuje obdoba pro výše zmíněné příkazy:</p>

<table>
<tr><th>Příkaz</th><th>Parametry</th><th>Popis</th></tr>
<tr><td><strong>Q</strong></td><td>(x1 y1 x y)+</td><td>kvadratická Bézierova křivka zadaná trojicí řídicích bodů s&nbsp;absolutními souřadnicemi.</td></tr>
<tr><td><strong>q</strong></td><td>(x1 y1 x y)+</td><td>má stejný význam jako příkaz <strong>Q</strong> s&nbsp;tím rozdílem, že souřadnice řídicích bodů jsou zadány relativně (vůči předchozím souřadnicím).</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kubické Bézierovy křivky</h2>

<p>Kubické Bézierovy křivky většina uživatelů používajících vektorové grafické
editory již velmi dobře zná (ale nalezneme je i v&nbsp;rastrových grafických
editorech, například v&nbsp;GIMPu). Připomeňme si tedy, že tyto křivky jsou
definovány počátečním bodem, koncovým bodem a dvojicí řídicích bodů. Větší
množství řídicích bodů dává uživatelům i větší možnosti tvarování křivky,
protože je možné vytvořit i esíčko atd. V&nbsp;knihovně <i>OpenVG</i> se tyto
křivky (resp.&nbsp;segmenty složené z&nbsp;kubických Bézierových křivek)
specifikují příkazy <strong>VG_CUBIC_TO_ABS</strong> a
<strong>VG_CUBIC_TO_REL</strong>, přičemž se očekávají tři body (tedy šest
souřadnic), protože počáteční bod již známe &ndash; je jím dočasný poslední bod
aktuálně vytvářené cesty.</p>

<p>V&nbsp;SVG samozřejmě existuje obdoba pro výše zmíněné příkazy:</p>

<table>
<tr><th>Příkaz</th><th>Parametry</th><th>Popis</th></tr>
<tr><td><strong>C</strong></td><td>(x1 y1 x2 y2 x y)+</td><td>kubická Bézierova křivka. Souřadnice řídicích bodů jsou zadány absolutně.</td></tr>
<tr><td><strong>c</strong></td><td>(x1 y1 x2 y2 x y)+</td><td>má stejný význam jako příkaz <strong>C</strong> s&nbsp;tím rozdílem, že souřadnice řídicích bodů jsou zadány relativně (vůči předchozím souřadnicím).</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Křivkové segmenty garantující geometrickou spojitost G1</h2>

<p>Knihovna <i>OpenVG</i> podporuje i tvorbu segmentů složených z&nbsp;na sebe
navazujících křivkových segmentů, přičemž je dodržena geometrická spojitost
G<sup>1</sup> (křivka je tedy hladká). Tato podpora přináší dvě výhody: ušetří
se několik bajtů v&nbsp;deklaraci cesty, neboť odpadne nutnost zadání jednoho
řídicího bodu a navíc se mohou zjednodušit některé výpočty v&nbsp;aplikaci.
V&nbsp;případě kvadratické Bézierovy křivky se pro její hladké navázání na
předchozí segment používají příkazy <strong>VG_SQUAD_TO_ABS</strong> a
<strong>VG_SQUAD_TO_REL</strong>, u nichž se specifikuje pouze jediný vrchol,
kterým je koncový bod křivky. Její začátek samozřejmě známe a jediný řídicí
body je vypočten z&nbsp;pozice řídicího bodu předchozí křivky (podobně je tomu
v&nbsp;TrueType fontech). U kubické Bézierovy křivky je při použití příkazů
<strong>VG_SCUBIC_TO_ABS</strong> a <strong>VG_SCUBIC_TO_REL</strong> zapotřebí
zadat souřadnice druhého řídicího bodu (první je opět dopočten) a samozřejmě i
koncový bod křivky. Podrobnosti si možná ukážeme příště v&nbsp;demonstračním
příkladu.</p>

<p>Pokud vás zajímá, zda existují obdobné příkazy v&nbsp;SVG, odpověď naleznete
v&nbsp;tabulce:</p>

<table>
<tr><th>Příkaz</th><th>Parametry</th><th>Popis</th></tr>
<tr><td><strong>T</strong></td><td>(x y)+</td><td>kvadratická Bézierova křivka vedoucí od konce vytvářené cesty do zadaného bodu se souřadnicemi <i>[x, y]</i>. Řídicí bod této křivky není zadán, protože je dopočítán z&nbsp;pozice řídicího bodu předchozí kvadratické Bézierovy křivky tak, aby na sebe křivky hladce navazovaly (to znamená, že před příkazem <strong>T</strong> by měl být příkaz <strong>Q</strong>, <strong>q</strong>, <strong>T</strong> či <strong>t</strong>).</td></tr>
<tr><td><strong>t</strong></td><td>(x y)+</td><td>má stejný význam jako příkaz <strong>T</strong> s&nbsp;tím rozdílem, že souřadnice koncového bodu Bézierovy kvadratické křivky jsou zadány relativně vůči koncovému bodu cesty.</td></tr>
<tr><td><strong>S</strong></td><td>(x2 y2 x y)+</td><td>tento příkaz je podobný příkazu <strong>T</strong>, ovšem s&nbsp;tím rozdílem, že se vytvoří kubická Bézierova křivka. První řídicí bod křivky je automaticky vypočítán ze druhého řídicího bodu předchozí kubické Bézierovy křivky, tak, aby na sebe křivky hladce navazovaly. To znamená, že před tímto příkazem by měl předcházet příkaz <strong>C</strong> či <strong>S</strong>. Norma neurčuje, že by se měly dopočítat návaznosti kvadratických a kubických křivek, proto kombinace příkazů <strong>Q</strong> a <strong>S</strong> nemusí dát očekávané výsledky (podobně není možné automaticky navázat kruhový oblouk na křivku).</td></tr>
<tr><td><strong>s</strong></td><td>(x2 y2 x y)+</td><td>podobné příkazu <strong>S</strong>, ale všechny souřadnice řídicích bodů jsou zadány relativně.</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Křivkové segmenty vytvořené z&nbsp;eliptických oblouků</h2>

<p>Kvadratické ani kubické Bézierovy křivky popsané v&nbsp;předchozích třech
kapitolách nemohou geometricky přesně nahradit kruhové a eliptické oblouky
(k&nbsp;tomuto účelu by bylo nutné použít racionální křivky, například NURBS).
Z&nbsp;tohoto důvodu byly do repertoáru příkazů určených pro vytváření cest
přidány i příkazy sloužící pro přidání segmentu vytvořeného z&nbsp;eliptického
oblouku do konstruované cesty. Kruhový oblouk je samozřejmě speciálním případem
eliptického oblouku, stejně jako elipsa či kruh &ndash; pro vytvoření všech
těchto tvarů si tedy vystačíme s&nbsp;pouhými čtyřmi příkazy, které se od sebe
odlišují v&nbsp;tom, zda se vykreslí delší či kratší část oblouku a zda je
oblouk specifikován po směru či proti směru hodinových ručiček.</p>

<table>
<tr><th>Příkaz</th><th>Parametry</th><th>Význam</th></tr>
<tr><td>VG_SCCWARC_TO</td><td>rh,rv,rot,x0,y0</td><td>menší oblouk, proti směru hodinových ručiček</td></tr>
<tr><td>VG_SCWARC_TO </td><td>rh,rv,rot,x0,y0</td><td>menší oblouk, po směru hodinových ručiček</td></tr>
<tr><td>VG_LCCWARC_TO</td><td>rh,rv,rot,x0,y0</td><td>větší oblouk, proti směru hodinových ručiček</td></tr>
<tr><td>VG_LCWARC_TO </td><td>rh,rv,rot,x0,y0</td><td>větší oblouk, po směru hodinových ručiček</td></tr>
</table>

<p>Význam parametrů lze zjistit z&nbsp;nákresu:</p>

<a href="http://www.root.cz/obrazek/241574/"><img src="https://i.iinfo.cz/images/309/openvg3-1.png" class="image-241574" alt="&#160;" width="292" height="196" /></a>
<p><i>Obrázek 3: Čtyři možné eliptické oblouky při znalosti dvou bodů, dvou
poloměrů (a zde neuvedené rotace celé elipsy).</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Operace, které je možné s&nbsp;cestami provádět</h2>

<p>Operace, které lze s&nbsp;cestami provádět, jsou specifikovány bitovým polem
<strong>VGbitfield</strong> při zakládání nové cesty funkcí
<strong>vgCreatePath</strong> či při mazání všech segmentů funkcí
<strong>vgClearPath</strong>. Bitové pole se skládá z&nbsp;několika
příznaků:</p>

<table>
<tr><th>Příznak</th><th>Význam</th></tr>
<tr><td>VG_PATH_CAPABILITY_APPEND_FROM            </td><td>povolení operace pro spojení dvou cest</td></tr>
<tr><td>VG_PATH_CAPABILITY_APPEND_TO              </td><td>povolení operace pro spojení dvou cest</td></tr>
<tr><td>VG_PATH_CAPABILITY_MODIFY                 </td><td>modifikace segmentů</td></tr>
<tr><td>VG_PATH_CAPABILITY_TRANSFORM_FROM         </td><td>lineární transformace aplikovaná na cestu</td></tr>
<tr><td>VG_PATH_CAPABILITY_TRANSFORM_TO           </td><td>lineární transformace aplikovaná na cestu</td></tr>
<tr><td>VG_PATH_CAPABILITY_INTERPOLATE_FROM       </td><td>povolení operace vgInterpolatePath</td></tr>
<tr><td>VG_PATH_CAPABILITY_INTERPOLATE_TO         </td><td>povolení operace vgInterpolatePath</td></tr>
<tr><td>VG_PATH_CAPABILITY_PATH_LENGTH            </td><td>povolení operace pro výpočet délky cesty</td></tr>
<tr><td>VG_PATH_CAPABILITY_POINT_ALONG_PATH       </td><td>povolení vgPointAlongPath</td></tr>
<tr><td>VG_PATH_CAPABILITY_TANGENT_ALONG_PATH     </td><td>povolení vgPointAlongPath</td></tr>
<tr><td>VG_PATH_CAPABILITY_PATH_BOUNDS            </td><td>povolení vgPathBounds</td></tr>
<tr><td>VG_PATH_CAPABILITY_PATH_TRANSFORMED_BOUNDS</td><td>povolení vgPathTransformedBounds</td></tr>
<tr><td>VG_PATH_CAPABILITY_ALL</td><td>(toto jediné není bitový příznak, ale OR všech ostatních příznaků)</td></tr>
</table>

<p>Většina těchto příznaků si vyžádá podrobnější vysvětlení příště.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>EGL quick reference card<br />
<a href="https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf">https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf</a>
</li>

<li>EGL Reference Pages Index<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php">https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php</a>
</li>

<li>Funkce eglInitialize<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml</a>
</li>

<li>Funkce eglGetDisplay<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml</a>
</li>

<li>Funkce eglGetConfigs<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml</a>
</li>

<li>Funkce eglGetConfigAttrib<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml</a>
</li>

<li>Funkce eglDestroySurface<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml</a>
</li>

<li>Funkce eglDestroyContext<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml</a>
</li>

<li>Funkce eglTerminate<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml</a>
</li>

<li>Khronos Native Platform Graphics Interface<br />
<a href="https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf">https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf</a>
</li>

<li>Khronos Group<br />
<a href="https://www.khronos.org/">https://www.khronos.org/</a>
</li>

<li>Khronos Group (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Khronos_Group">https://en.wikipedia.org/wiki/Khronos_Group</a>
</li>

<li>Raspberry Pi VideoCore APIs<br />
<a href="http://elinux.org/Raspberry_Pi_VideoCore_APIs">http://elinux.org/Raspberry_Pi_VideoCore_APIs</a>
</li>

<li>Programming AudioVideo on the Raspberry Pi GPU<br />
<a href="https://jan.newmarch.name/RPi/index.html">https://jan.newmarch.name/RPi/index.html</a>
</li>

<li>The Standard for Vector Graphics Acceleration<br />
<a href="https://www.khronos.org/openvg/">https://www.khronos.org/openvg/</a>
</li>

<li>OpenVG (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenVG">https://en.wikipedia.org/wiki/OpenVG</a>
</li>

<li>OpenVG Quick Reference Card<br />
<a href="https://www.khronos.org/files/openvg-quick-reference-card.pdf">https://www.khronos.org/files/openvg-quick-reference-card.pdf</a>
</li>

<li>OpenVG on the Raspberry Pi<br />
<a href="http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html">http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html</a>
</li>

<li>ShivaVG: open-source ANSI C OpenVG <br />
<a href="http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html">http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html</a>
</li>

<li>Testbed for exploring OpenVG on the Raspberry Pi<br />
<a href="https://github.com/ajstarks/openvg">https://github.com/ajstarks/openvg</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame prakticky<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: práce s bitmapami a TrueType fonty<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: sprity v knihovně Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: detekce kolize spritů<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: transformace rastrových obrázků<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-transformace-rastrovych-obrazku/</a>
</li>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

