<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití knihoven OpenVG a EGL (nejenom) na Raspberry Pi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití knihoven OpenVG a EGL (nejenom) na Raspberry Pi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnešní článek o počítačové grafice na jednodeskových mikropočítačích Raspberry Pi bude zaměřen na vysvětlení základních postupů využívaných v knihovně EGL. Ukážeme si inicializaci EGL i způsob zjištění dostupných konfigurací framebufferu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití knihoven OpenVG a EGL (nejenom) na Raspberry Pi</a></p>
<p><a href="#k02">2. Základní datové typy a objekty, s&nbsp;nimiž se v&nbsp;EGL pracuje</a></p>
<p><a href="#k03">3. Datová struktura se stavem EGL, kterou použijeme v&nbsp;demonstračních příkladech</a></p>
<p><a href="#k04">4. Inicializace a finalizace EGL</a></p>
<p><a href="#k05">5. První demonstrační příklad &ndash; inicializace a finalizace EGL</a></p>
<p><a href="#k06">6. Funkce <strong>eglGetConfigs()</strong></a></p>
<p><a href="#k07">7. Funkce <strong>eglGetConfigAttrib()</strong></a></p>
<p><a href="#k08">8. Zjištění základních informací o konfiguraci framebufferu</a></p>
<p><a href="#k09">9. Druhý demonstrační příklad &ndash; výpis základních informací o konfiguraci framebufferu</a></p>
<p><a href="#k10">10. Výsledky vypsané druhým demonstračním příkladem</a></p>
<p><a href="#k11">11. Informace o Z-bufferu, stencil bufferu a o možnosti navázání barvových bufferů na textury</a></p>
<p><a href="#k12">12. Třetí demonstrační příklad &ndash; výpis podrobnějších informací o konfiguraci framebufferu</a></p>
<p><a href="#k13">13. Výsledky vypsané třetím demonstračním příkladem</a></p>
<p><a href="#k14">14. Obsah následující části seriálu</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití knihoven OpenVG a EGL (nejenom) na Raspberry Pi</h2>

<p>V&nbsp;dnešním článku o programování počítačové grafiky (nejenom) na
jednodeskovém mikropočítači Raspberry Pi si přiblížíme problematiku použití
knihovny <i>EGL</i> a následně pak v&nbsp;navazující části i knihovny
<i>OpenVG</i>. Připomeňme si, že <i>EGL</i> neboli též <i>Native Platform
Interface</i>, tvoří mezivrstvu mezi grafickým procesorem (přičemž každý
grafický procesor může mít zcela odlišný způsob ovládání) a systémem pro správu
oken na jedné straně a knihovnou OpenGL, OpenVG či OpenGL ES na straně druhé.
Díky použití <i>EGL</i> je možné zajistit, aby se v&nbsp;knihovnách OpenGL,
OpenVG a OpenGL ES nemusely implementovat a samozřejmě ani specifikovat funkce
určené pro otevření okna či funkce pro zpřístupnění framebufferu; dokonce tyto
knihovny ani nemusí poskytovat funkce pro zjištění schopností grafického
subsystému. Před vznikem <i>EGL</i> byla situace poměrně komplikovaná, protože
všechny aplikace, které například volaly funkce OpenGL, musely nějakým způsobem
otevřít okno, získat přístup k&nbsp;vykreslovací ploše atd. K&nbsp;tomu se
používaly různé knihovny a rozhraní: SDL, WinAPI, GLX, GLUT. S&nbsp;využitím
<i>EGL</i> se situace zjednodušuje, což je patrné z&nbsp;následujícího
diagramu, kde můžeme vidět použití <i>EGL</i> na třech odlišných
platformách:</p>

<pre>
+-----------+                       +---------------------------------+
| OpenGL    |........       ........| Linux (Display, Pixmap, Window) |
+-----------+        \     /        +---------------------------------+
                      \   /        
+-----------+        +-----+        +---------------------------------+
| OpenGL ES |........| EGL |........| Windows (HDC, HBITMAP, HWND)    |
+-----------+        +-----+        +---------------------------------+
                      /   \        
+-----------+        /     \        +---------------------------------+
| OpenVG    |......./       \.......| Android (ANativeWindow, ...)    |
+-----------+                       +---------------------------------+
</pre>

<p>Za vývojem knihovny <i>EGL</i> stojí sdružení Khronos, které kromě této
knihovny &bdquo;pečuje&ldquo; i o specifikace a implementace OpenGL, OpenGL ES,
OpenVG, dnes tak populárního nástupce OpenGL jménem Vulkan atd. (viz též <a
href="https://www.khronos.org/">https://www.khronos.org/</a>). Jedním ze
základních úkolů, které musí knihovna <i>EGL</i> zabezpečit, je vytvoření a
správa grafického kontextu, ploch (<i>surface</i>), do kterých je možné přes
knihovny OpenGL ES a OpenVG provádět vykreslování atd. Mimochodem &ndash;
plochy (<i>surface</i>) mohou být vytvořeny tak, aby aplikace běžela
v&nbsp;systému X Window (i v&nbsp;okně), přes framebuffer nebo lze vykreslování
provádět do zadního bufferu. Další důležitou funkcí nabízenou <i>EGL</i> je
kopie obsahu bitmap mezi jednotlivými plochami, tj.&nbsp;operace typu
<strong>bitblt</strong>. Zapomenout nesmíme ani na funkce pro zjištění či
nastavení konfigurace grafického subsystému, ostatně právě tyto funkce budou
použity v&nbsp;dnešních třech demonstračních příkladech.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní datové typy a objekty, s&nbsp;nimiž se v&nbsp;EGL pracuje</h2>

<p>V&nbsp;hlavičkovém souboru dodávaném s&nbsp;knihovnou <i>EGL</i> nalezneme
několik deklarací datových typů použitých při volání funkcí <i>EGL</i>. Tyto
datové typy jsou vypsány v&nbsp;následující tabulce společně s&nbsp;jejich
stručným popisem. Posledních pět typů je sice deklarovaných jako ukazatele
(typu <strong>void*</strong>), interně se však samozřejmě jedná o záznamy
(<i>struct</i>), jejichž vnitřní struktura se ve specifikaci nepopisuje (a ani
nás vlastně nezajímá):</p>

<table>
<tr><th>#</th><th>Typ v&nbsp;C</th><th>Jméno typu</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>unsigned int</td><td>EGLBoolean</td><td>může nabývat jen hodnot EGL_TRUE nebo EGL_FALSE, typicky výsledek (návratová hodnota) mnoha funkcí</td></tr>
<tr><td>2</td><td>unsigned int</td><td>EGLenum</td><td>použito pro všechny symbolické konstanty i bitové masky</td></tr>
<tr><td>3</td><td>int32_t</td><td>EGLint</td><td>celé číslo, použito v&nbsp;mnoha funkcích</td></tr>
<tr><td>4</td><td>void *</td><td>EGLConfig</td><td>popisuje formát, typ a velikost bufferů</td></tr>
<tr><td>5</td><td>void *</td><td>EGLContext</td><td>udržuje takzvaný kontext, který propojuje stav na klientovi a serveru</td></tr>
<tr><td>6</td><td>void *</td><td>EGLDisplay</td><td>abstraktní displej, na RPi displej jde o konkrétní displej připojený k&nbsp;počítači (teoreticky ale lze vykreslovat i do paměti apod.)</td></tr>
<tr><td>7</td><td>void *</td><td>EGLSurface</td><td>buffer, do něhož se vykresluje (je buď viditelný nebo tzv.off-screen)</td></tr>
<tr><td>8</td><td>void *</td><td>EGLClientBuffer</td><td>buffer na klientovi, použito právě v&nbsp;OpenVG pro kreslení</td></tr>
</table>

<p>Poznámka: jak jste asi (správně) poznali, budu se v&nbsp;dalším textu
soustředit na programování v&nbsp;céčku, takže vlastně navážeme na předchozí
části seriálu, kde jsme použili céčko pro přístup do framebufferu Raspberry
Pi.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Datová struktura se stavem EGL, kterou použijeme v&nbsp;demonstračních příkladech</h2>

<p>Ve všech demonstračních příkladech bude stav EGL (a vlastně i stav celé
grafické pipeline) reprezentován jednoduchým záznamem
(<strong>struct</strong>), jehož struktura vypadá následovně:</p>

<pre>
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
<strong>typedef</strong> <strong>struct</strong>
{
    <strong>uint32_t</strong> screen_width;
    <strong>uint32_t</strong> screen_height;
&nbsp;
    <strong>uint32_t</strong> window_x;
    <strong>uint32_t</strong> window_y;
    <strong>int32_t</strong>  window_width;
    <strong>int32_t</strong>  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
</pre>

<p>Způsob korektního naplnění většiny prvků této datové struktury si ukážeme až
příště, protože se bude jednat o poměrně dlouhý programový kód. Nicméně význam
by měl být zřejmý: budeme si pamatovat rozměry obrazovky, rozměry okna, do
něhož se bude vykreslovat a taktéž aktuální konfiguraci EGL, přiřazený displej
(ten je u Raspberry Pi jen jeden), vykreslovací plochu (pokud bude vytvořena) a
taktéž kontext propojující stav klienta (OpenGL/OpenVG/OpenGL ES) a serveru
(což zde znamená stav okenního systému a grafického procesoru).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Inicializace a finalizace EGL</h2>

<p>Při používání knihovny <i>EGL</i> je nutné nejdříve provést její
inicializaci a při ukončení práce taktéž takzvanou &bdquo;finalizaci&ldquo;.
V&nbsp;případě inicializace se postupně provádí několik kroků. Typickým prvním
krokem je získání datové struktury popisující primární displej, dále pak
vlastní inicializace interních datových struktur <i>EGL</i>, napojení některé
z&nbsp;knihoven OpenGL, OpenGL ES nebo OpenVG na <i>EGL</i> a nakonec i získání
přístupu k&nbsp;plochám (<i>surface</i>), do nichž je možné provádět
vykreslování (na tomto místě se může vývojář rozhodnout, zda preferuje
vykreslování do okna či naopak vykreslování na celou obrazovku, což se
pochopitelně týká především počítačových her, přehrávačů videa apod.). Ve
skutečnosti je celá inicializace poměrně složitá (jedná se o více než 100 řádků
programového kódu, pokud počítáme i reakci na chyby), takže se většina vývojářů
spolehne na další knihovnu, která inicializaci provede za ně. My prozatím
takový luxus nevyužijeme, ale postupně si všechny důležité kroky popíšeme a
ukážeme.</p>

<p>První důležitou funkcí volanou při inicializaci je funkce nazvaná
<strong>eglGetDisplay()</strong>, která slouží pro získání datové struktury
popisující zvolený reálný či virtuální displej:</p>

<pre>
EGLDisplay <strong>eglGetDisplay</strong>(
    NativeDisplayType native_display);
</pre>

<p>Na mikropočítači Raspberry Pi a dalších počítačích s&nbsp;jediným displejem
se této funkci předává konstanta <strong>EGL_DEFAULT_DISPLAY</strong>.
V&nbsp;případě chyby se vrátí hodnota <strong>EGL_NO_DISPLAY</strong>, jakákoli
odlišná hodnota znamená skutečný displej.</p>

<p>Poznámka: návratová hodnota funkce <strong>eglGetDisplay()</strong> je velmi
důležitá, protože se předává do prakticky všech dalších funkcí knihovny
<i>EGL</i>.</p>

<p>Druhou funkcí používanou při inicializaci knihovny <i>EGL</i> je funkce
<strong>eglInitialize()</strong>. V&nbsp;prvním parametru se předává (primární)
displej, druhé dva parametry jsou ukazatele na celočíselné proměnné, které
mohou být naplněny verzí knihovny <i>EGL</i>. Pokud nás tato informace
nezajímá, mohou být namísto ukazatelů předány konstanty <strong>NULL</strong>.
Výsledkem této funkce je pravdivostní hodnota značící, zda se inicializace
podařila či nikoli:</p>

<pre>
EGLBoolean <strong>eglInitialize</strong>(
    EGLDisplay display,
    EGLint * major,
    EGLint * minor);
</pre>

<p>Základní inicializace knihovny EGL (prozatím bez bufferů a kreslicích ploch)
bude vypadat takto:</p>

<pre>
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
<strong>void</strong> initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    <i>/* propojeni na vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda inicializace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
}
</pre>

<p>Důvody vedoucí k&nbsp;nutnosti napsání programového kódu, který provádí
inicializaci <i>EGL</i> a její napojení na OpenGL, OpenGL ES či OpenVG, jsou
pochopitelné. Ovšem stejně důležitá je i &bdquo;finalizace&ldquo; prováděná ve
chvíli, kdy se má aplikace ukončit. Ve fázi finalizace je nutné uvolnit všechnu
paměť používanou GPU, což se týká jak samotného framebufferu, tak i případných
textur apod. Dále je nutné aplikaci odpojit od vykreslovací plochy i primárního
displeje, takže se tyto systémové prostředky uvolní a může je začít používat
další aplikace. &bdquo;Finalizace&ldquo; může vypadat následovně:</p>

<pre>
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
<strong>void</strong> finalize_egl(EGL_STATE_T *state)
{
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
</pre>

<p>Vidíme, že se provádí tyto kroky:</p>

<ol>
<li>Prohození předního a zadního bufferu (tímto se vynutí dokončení všech operací v&nbsp;grafické pipeline).</li>
<li>Odstranění vazby na výchozí kreslicí plochu.</li>
<li>Uvolnění kreslicí plochy (pokud existuje).</li>
<li>Uvolnění kontextu mezi EGL a další knihovnou (OpenGL/OpenGL ES/OpenVG).</li>
<li>Vlastní ukončení knihovny EGL.</li>
</ol>

<p>V&nbsp;dnešních příkladech sice &bdquo;finalizátor&ldquo; budeme volat,
ovšem ve skutečnosti by postačovalo zavolat jen poslední funkci.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. První demonstrační příklad &ndash; inicializace a finalizace EGL</h2>

<p>Funkce, které jsme si popsali v&nbsp;předchozích kapitolách, jsou použity
v&nbsp;dnešním prvním demonstračním příkladu, který je vlastně velmi
jednoduchý, protože obsahuje jen základní inicializaci a finalizaci <i>EGL</i>.
V&nbsp;příkladu je použita již zmíněná datová struktura držící informace o
stavu <i>EGL</i>, přičemž většina prvků této struktury není prozatím použita
(ovšem příště již všechny prvky využijeme). Nejprve se podívejme na úplný
zdrojový kód tohoto příkladu, v&nbsp;němž upozorním především na řádek, který
je specifický pro <i>Raspberry Pi</i>. Jedná se o řádek s&nbsp;voláním funkce
<strong>bcm_host_init()</strong>, jejíž hlavičku nalezneme v&nbsp;souboru
<strong>bcm_host.h</strong>:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - prvni demonstracni priklad */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
<strong>typedef struct</strong>
{
    <strong>uint32_t</strong> screen_width;
    <strong>uint32_t</strong> screen_height;
&nbsp;
    <strong>uint32_t</strong> window_x;
    <strong>uint32_t</strong> window_y;
    <strong>int32_t</strong>  window_width;
    <strong>int32_t</strong>  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
<strong>void</strong> initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    <i>/* propojeni na vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda inicializace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
<strong>void</strong> finalize_egl(EGL_STATE_T *state)
{
    <i>/* nyni jsou tyto kroky prozatim zbytecne, v dalsich prikladech se vsak budou hodit */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    <strong>return</strong> 0;
}
</pre>

<p>Jakým způsobem se tento demonstrační příklad překládá? Předpokládejme, že je
použita standardní instalace Raspbianu. Na tomto systému je přítomen
v&nbsp;určitém ohledu speciální adresář <strong>/opt/vc/</strong>, v&nbsp;němž
jsou kromě několika dem (podle mého názoru zbytečně komplikovaných :-) uloženy
i hlavičkové soubory a knihovny, které jsou v&nbsp;příkladu použity. Abychom se
vyhnuli nutnosti předávání parametrů na příkazové řádce, bude lepší použít
následující Makefile soubor. Celý překlad se potom provede jednoduše příkazem
<strong>make</strong>, adresář dostaneme do původního stavu příkazem
<strong>make clean</strong>:</p>

<pre>
<i># Makefile pro preklad tretiho prikladu ukazujiciho</i>
<i># praci s OpenVG a EGL.</i>
&nbsp;
<i># Parametry prekladace.</i>
CFLAGS=-Wall
&nbsp;
<i># Dalsi parametry prekladace, zde adresare, kde se maji </i>
<i># hledat hlavickove soubory.</i>
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
<i># Parametry linkeru.</i>
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example1
&nbsp;
<i># Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.</i>
all:    $(PROGNAME)
&nbsp;
clean:
        rm -f *.o
        rm -f $(PROGNAME)
&nbsp;
<i># Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni</i>
<i># vysledne spustitelne aplikace.</i>
$(PROGNAME):    $(PROGNAME).o
        $(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
<i># Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho</i>
<i># objektoveho souboru.</i>
%.o:    %.c
        $(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>

<p>Poznámka: hlavičkové soubory uložené v&nbsp;adresáři
<strong>/opt/vc/</strong> jsou napsány takovým způsobem, že při překladu není
možné použít přepínač <strong>-ansi</strong>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce <strong>eglGetConfigs()</strong></h2>

<p>Ještě předtím, než je možné zahájit vykreslování (například s&nbsp;použitím
OpenVG), je nutné zjistit všechny dostupné konfigurace framebufferu a vybrat
z&nbsp;nich tu správnou konfiguraci (bitovou hloubku barvového bufferu, bitovou
hloubku Z-bufferu, stencil bufferu atd.). K&nbsp;tomuto účelu slouží funkce
nazvaná <strong>eglGetConfigs()</strong>:</p>

<pre>
EGLBoolean <strong>eglGetConfigs</strong>(
    EGLDisplay   display,
    EGLConfig  * configs,
    EGLint       config_size,
    EGLint     * num_config);
</pre>

<p>Typicky se tato funkce volá dvakrát. Poprvé se jí ve druhém parametru předá
hodnota NULL. V&nbsp;tomto případě funkce <strong>eglGetConfigs()</strong> do
proměnné, jejíž adresa je předána v&nbsp;posledním parametru, vloží celkový
dostupný počet konfigurací. Tato hodnota se následně použije pro alokaci pole
prvků typu <strong>EGLConfig</strong>. Při druhém volání funkce
<strong>eglGetConfigs()</strong> se toto pole předá ve druhém parametru
(pole==adresa prvního prvku, což nikdy nebude NULL) a následně je toto pole
naplněno (přesněji řečeno se naplní maximálně <strong>config_size</strong>
položek).</p>

<p>Pokud tato funkce z&nbsp;nějakého důvodu skončí s&nbsp;chybou, vrátí se
hodnota <strong>EGL_FALSE</strong> a současně nedojde ke změně datových
struktur a proměnných, jejichž ukazatele jsou předány ve druhém a čtvrtém
parametru. Pokud naopak funkce skončí v&nbsp;pořádku, vrátí se podle očekávání
hodnota <strong>EGL_TRUE</strong> a obě datové struktury by měly být nastaveny
správně.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce <strong>eglGetConfigAttrib()</strong></h2>

<p>Pole získané funkcí <strong>eglGetConfigs()</strong> obsahuje prvky typu
<strong>EGLConfig</strong>, přičemž každý prvek popisuje jednu možnou (či možná
lépe řečeno dostupnou) konfiguraci framebufferu. Pro získání jednotlivých
atributů každé konfigurace je nutné použít funkci nazvanou
<strong>eglGetConfigAttrib()</strong>, jejíž hlavička vypadá následovně:</p>

<pre>
EGLBoolean <strong>eglGetConfigAttrib</strong>(
    EGLDisplay display,
    EGLConfig  config,
    EGLint     attribute,
    EGLint    *value);
</pre>

<p>Význam prvního parametru již známe. Druhým parametrem je jeden z&nbsp;prvků
pole přečteného přes <strong>eglGetConfigs()</strong>, třetím parametrem
konstanta představující jméno atributu (viz též další kapitolu) a
v&nbsp;posledním parametru se předává adresa proměnné. Tato proměnná je
naplněna hodnotou vybraného atributu (samozřejmě jen v&nbsp;případě, že funkce
neskončí s&nbsp;chybou).</p>

<p>V&nbsp;následující tabulce jsou vypsány konstanty představující symbolická
jména atributů. Tyto konstanty se předávají ve třetím parametru:</p>

<table>
<tr><th>Symbolická konstanta</th></tr>
<tr><td>EGL_ALPHA_SIZE</td></tr>
<tr><td>EGL_ALPHA_MASK_SIZE</td></tr>
<tr><td>EGL_BIND_TO_TEXTURE_RGB</td></tr>
<tr><td>EGL_BIND_TO_TEXTURE_RGBA</td></tr>
<tr><td>EGL_BLUE_SIZE</td></tr>
<tr><td>EGL_BUFFER_SIZE</td></tr>
<tr><td>EGL_COLOR_BUFFER_TYPE</td></tr>
<tr><td>EGL_CONFIG_CAVEAT</td></tr>
<tr><td>EGL_CONFIG_ID</td></tr>
<tr><td>EGL_CONFORMANT</td></tr>
<tr><td>EGL_DEPTH_SIZE</td></tr>
<tr><td>EGL_GREEN_SIZE</td></tr>
<tr><td>EGL_LEVEL</td></tr>
<tr><td>EGL_LUMINANCE_SIZE</td></tr>
<tr><td>EGL_MAX_PBUFFER_WIDTH</td></tr>
<tr><td>EGL_MAX_PBUFFER_HEIGHT</td></tr>
<tr><td>EGL_MAX_PBUFFER_PIXELS</td></tr>
<tr><td>EGL_MAX_SWAP_INTERVAL</td></tr>
<tr><td>EGL_MIN_SWAP_INTERVAL</td></tr>
<tr><td>EGL_NATIVE_RENDERABLE</td></tr>
<tr><td>EGL_NATIVE_VISUAL_ID</td></tr>
<tr><td>EGL_NATIVE_VISUAL_TYPE</td></tr>
<tr><td>EGL_RED_SIZE</td></tr>
<tr><td>EGL_RENDERABLE_TYPE</td></tr>
<tr><td>EGL_SAMPLE_BUFFERS</td></tr>
<tr><td>EGL_SAMPLES</td></tr>
<tr><td>EGL_STENCIL_SIZE</td></tr>
<tr><td>EGL_SURFACE_TYPE</td></tr>
<tr><td>EGL_TRANSPARENT_TYPE</td></tr>
<tr><td>EGL_TRANSPARENT_RED_VALUE</td></tr>
<tr><td>EGL_TRANSPARENT_GREEN_VALUE</td></tr>
<tr><td>EGL_TRANSPARENT_BLUE_VALUE</td></tr>
</table>

<p>V&nbsp;případě, že tato funkce skončí s&nbsp;chybou, vrátí se hodnota
<strong>EGL_FALSE</strong> a současně nedojde ke změně hodnoty proměnné, jejíž
ukazatel byl předán ve čtvrtém parametru. Pokud naopak funkce skončí
v&nbsp;pořádku, vrátí se podle očekávání hodnota <strong>EGL_TRUE</strong> a
proměnná bude nastavena korektně.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zjištění základních informací o konfiguraci framebufferu</h2>

<p>Podívejme se nyní na postup používaný pro zjištění základních informací o
barvovém bufferu, což je jedna součást celého framebufferu sloužící pro uložení
zobrazované scény (v&nbsp;případě knihovny OpenVG potřebujeme pouze barvový
buffer!). Nejprve zjistíme počet všech dostupných konfigurací (druhý parametr
je NULL):</p>

<pre>
<i>/* precteni poctu konfiguraci dostupnych pres EGL */</i>
<i>/* pocet se ulozi do promenne configurations_count */</i>
eglGetConfigs(state-&gt;display, NULL, 0, &amp;configurations_count);
printf("EGL has %d configurations available\n", configurations_count);
</pre>

<p>Následně se alokuje pole s&nbsp;prvky typu <strong>EGLConfig</strong> a
prvky tohoto pole se naplní aktuálními konfiguracemi (druhý parametr je
ukazatel na první prvek pole):</p>

<pre>
<i>/* nacteni vsech konfiguraci do pripraveneho pole */</i>
all_configurations = malloc(configurations_count * sizeof(*all_configurations));
eglGetConfigs(state-&gt;display, all_configurations, configurations_count, &amp;configurations_count);
</pre>

<p>Nyní v&nbsp;programové smyčce procházíme všemi prvky pole a voláme funkci,
která vypíše základní atributy:</p>

<pre>
<strong>int</strong> i;
<strong>for</strong> (i = 0; i &lt; configurations_count; i++) {
    printf("%3d            ", i);
    print_egl_configuration(state-&gt;display, &amp;all_configurations[i]);
}
</pre>

<p>Samotná volaná funkce je již jednoduchá &ndash; nejprve přečte všechny
hledané atributy:</p>

<pre>
<strong>int</strong> red, green, blue, alpha, buffer;
&nbsp;
eglGetConfigAttrib(display, *config, EGL_RED_SIZE, &amp;red);
eglGetConfigAttrib(display, *config, EGL_BLUE_SIZE, &amp;green);
eglGetConfigAttrib(display, *config, EGL_GREEN_SIZE, &amp;blue);
eglGetConfigAttrib(display, *config, EGL_ALPHA_SIZE, &amp;alpha);
eglGetConfigAttrib(display, *config, EGL_BUFFER_SIZE, &amp;buffer);
</pre>

<p>A posléze jejich hodnoty vypíše na standardní výstup:</p>

<pre>
<strong>if</strong> (alpha) {
    printf("%1d   %1d   %1d   %1d   %2d\n", red, green, blue, alpha, buffer);
}
<strong>else</strong> {
    printf("%1d   %1d   %1d   x   %2d\n", red, green, blue, buffer);
}
</pre>

<p>Na konci jenom pro pořádek dealokujeme pole s&nbsp;konfiguracemi:</p>

<pre>
free(all_configurations);
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Druhý demonstrační příklad &ndash; výpis základních informací o konfiguraci framebufferu</h2>

<p>Obě funkce popsané v&nbsp;předchozích třech kapitolách jsou použity
v&nbsp;dnešním druhém demonstračním příkladu pro zjištění a následný výpis
základních informací o dostupných konfiguracích framebufferu. Nejprve je
provedena inicializace knihovny <i>EGL</i>, následně se zjistí počet dostupných
konfigurací, tyto konfigurace se načtou do pole a nakonec se pro každý prvek
tohoto pole zjistí pět atributů: počet bitů rezervovaných pro červenou barvovou
složku, počet bitů rezervovaných pro zelenou barvovou složku, počet bitů
rezervovaných pro modrou barvovou složku, počet bitů rezervovaných pro alfa
kanál (průhlednost pixelu) a konečně celková bitová hloubka barvového bufferu.
Následuje výpis zdrojového kódu tohoto demonstračního příkladu:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - druhy demonstracni priklad */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
<strong>typedef struct</strong>
{
    <strong>uint32_t</strong> screen_width;
    <strong>uint32_t</strong> screen_height;
&nbsp;
    <strong>uint32_t</strong> window_x;
    <strong>uint32_t</strong> window_y;
    <strong>int32_t</strong>  window_width;
    <strong>int32_t</strong>  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vypis konfigurace displeje nabizene pres EGL</i>
<i> */</i>
<strong>void</strong> print_egl_configuration(EGLDisplay display, EGLConfig *config)
{
    <strong>int</strong> red, green, blue, alpha, buffer;
&nbsp;
    eglGetConfigAttrib(display, *config, EGL_RED_SIZE, &amp;red);
    eglGetConfigAttrib(display, *config, EGL_BLUE_SIZE, &amp;green);
    eglGetConfigAttrib(display, *config, EGL_GREEN_SIZE, &amp;blue);
    eglGetConfigAttrib(display, *config, EGL_ALPHA_SIZE, &amp;alpha);
    eglGetConfigAttrib(display, *config, EGL_BUFFER_SIZE, &amp;buffer);
    <strong>if</strong> (alpha) {
        printf("%1d   %1d   %1d   %1d   %2d\n", red, green, blue, alpha, buffer);
    }
    <strong>else</strong> {
        printf("%1d   %1d   %1d   x   %2d\n", red, green, blue, buffer);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
<strong>void</strong> initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     configurations_count;
    EGLConfig *all_configurations;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    <i>/* propojeni na vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda inicializace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* precteni poctu konfiguraci dostupnych pres EGL */</i>
    eglGetConfigs(state-&gt;display, NULL, 0, &amp;configurations_count);
    printf("EGL has %d configurations available\n", configurations_count);
&nbsp;
    <i>/* nacteni vsech konfiguraci do pripraveneho pole */</i>
    all_configurations = malloc(configurations_count * sizeof(*all_configurations));
    eglGetConfigs(state-&gt;display, all_configurations, configurations_count, &amp;configurations_count);
&nbsp;
    puts("Configuration  R   G   B   A   bpp");
    <i>/* postupny vypis vsech konfiguraci */</i>
    <strong>int</strong> i;
    <strong>for</strong> (i = 0; i &lt; configurations_count; i++) {
        printf("%3d            ", i);
        print_egl_configuration(state-&gt;display, &amp;all_configurations[i]);
    }
    free(all_configurations);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
<strong>void</strong> finalize_egl(EGL_STATE_T *state)
{
    <i>/* nyni jsou tyto kroky prozatim zbytecne, v dalsich prikladech se vsak budou hodit */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    <strong>return</strong> 0;
}
</pre>

<p>Soubor Makefile je prakticky shodný se souborem použitým v&nbsp;prvním
demonstračním příkladu:</p>

<pre>
<i># Makefile pro preklad tretiho prikladu ukazujiciho</i>
<i># praci s OpenVG a EGL.</i>
&nbsp;
<i># Parametry prekladace.</i>
CFLAGS=-Wall
&nbsp;
<i># Dalsi parametry prekladace, zde adresare, kde se maji </i>
<i># hledat hlavickove soubory.</i>
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
<i># Parametry linkeru.</i>
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example2
&nbsp;
<i># Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.</i>
all:    $(PROGNAME)
&nbsp;
clean:
        rm -f *.o
        rm -f $(PROGNAME)
&nbsp;
<i># Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni</i>
<i># vysledne spustitelne aplikace.</i>
$(PROGNAME):    $(PROGNAME).o
        $(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
<i># Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho</i>
<i># objektoveho souboru.</i>
%.o:    %.c
        $(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výsledky vypsané druhým demonstračním příkladem</h2>

<p>Podívejme se nyní na výstup, který získáme po spuštění druhého
demonstračního příkladu na jednodeskovém mikropočítači <i>Raspberry Pi</i>.
Tento výstup by měl vypadat následovně:</p>

<pre>
EGL has 28 configurations available
Configuration  R   G   B   A   bpp
  0            8   8   8   8   32
  1            8   8   8   x   24
  2            8   8   8   8   32
  3            8   8   8   x   24
  4            8   8   8   8   32
  5            8   8   8   x   24
  6            8   8   8   8   32
  7            8   8   8   x   24
  8            8   8   8   8   32
  9            8   8   8   x   24
 10            8   8   8   8   32
 11            8   8   8   x   24
 12            8   8   8   8   32
 13            8   8   8   x   24
 14            8   8   8   8   32
 15            8   8   8   x   24
 16            5   5   6   x   16
 17            5   5   6   x   16
 18            5   5   6   x   16
 19            5   5   6   x   16
 20            5   5   6   x   16
 21            5   5   6   x   16
 22            5   5   6   x   16
 23            5   5   6   x   16
 24            8   8   8   8   32
 25            8   8   8   x   24
 26            5   5   6   x   16
 27            5   5   6   x   16
initialize_egl OK
finalize_egl OK
</pre>

<p>Můžeme zde rozeznat tři skupiny konfigurací:</p>

<ol>
<li>Framebuffer s&nbsp;bitovou hloubkou 16bpp bez alfa kanálu (hi-color).</li>
<li>Framebuffer s&nbsp;bitovou hloubkou 24bpp bez alfa kanálu (true color).</li>
<li>Framebuffer s&nbsp;bitovou hloubkou 32bpp s&nbsp;alfa kanálem (true color).</li>
</ol>



<p><a name="k11"></a></p>
<h2 id="k11">11. Informace o Z-bufferu, stencil bufferu a o možnosti navázání barvových bufferů na textury</h2>

<p>Na výpisu uvedeném <a href="#k10">v&nbsp;předchozí kapitole</a> si
povšimněte toho, že některé řádky popisují (alespoň zdánlivě) stejnou
konfiguraci framebufferu. To není chyba v&nbsp;programu ani chyba
v&nbsp;knihovně <i>EGL</i>, protože tyto zdánlivé duplicity jsou způsobeny tím,
že prozatím nezískáváme všechny důležité informace o tom, jaké formáty
framebufferu jsou dostupné. Pojďme si tedy naše znalosti rozšířit. Již dokážeme
načíst a zpracovat všechny důležité informace o barvovém bufferu (RGB) i o
případném alfa kanálu. Dále nás může zajímat informace o paměti hloubky neboli
Z-bufferu (to v&nbsp;případě 3D grafiky, nikoli u OpenVG). U některých aplikací
taktéž využijeme takzvaný stencil buffer, který lze použít pro implementaci
některých vizualizačních algoritmů, například pro výpočty stínů apod. Rendering
lze navázat i na textury, což je poslední zajímavá a užitečná informace (více
viz příště). Tyto informace lze opět velmi snadno přečíst a zobrazit:</p>

<pre>
#define yes_no(x) ((x)==EGL_TRUE ? "yes":"no ")
&nbsp;
<strong>int</strong> depth, stencil;
<strong>int</strong> bind_to_rgb, bind_to_rgba;
&nbsp;
eglGetConfigAttrib(display, *config, EGL_DEPTH_SIZE, &amp;depth);
eglGetConfigAttrib(display, *config, EGL_STENCIL_SIZE, &amp;stencil);
&nbsp;
eglGetConfigAttrib(display, *config,  EGL_BIND_TO_TEXTURE_RGB,  &amp;bind_to_rgb);
eglGetConfigAttrib(display, *config,  EGL_BIND_TO_TEXTURE_RGBA, &amp;bind_to_rgba);
&nbsp;
printf("%1d   %1d   %1d   %1d   %2d     %2d      %2d      %s  %s\n",
        red, green, blue, alpha, buffer,
        depth, stencil,
        yes_no(bind_to_rgb),
        yes_no(bind_to_rgba));
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Třetí demonstrační příklad &ndash; výpis podrobnějších informací o konfiguraci framebufferu</h2>

<p>Ve třetím demonstračním příkladu se po inicializaci knihovny <i>EGL</i>
zjistí základní i podrobnější informace o všech dostupných konfiguracích
framebufferu. Vzhledem k&nbsp;tomu, že je struktura tohoto příkladu prakticky
shodná s&nbsp;příkladem předchozím, se můžeme přímo podívat na jeho zdrojový
kód:</p>

<pre>
<i>/* OpenVG (nejenom) na Raspberry Pi - treti demonstracni priklad */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
#include &lt;VG/openvg.h&gt;
#include &lt;VG/vgu.h&gt;
#include &lt;EGL/egl.h&gt;
#include &lt;bcm_host.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Datova struktura obsahujici cely stav EGL "sezeni".</i>
<i> */</i>
<strong>typedef struct</strong>
{
    <strong>uint32_t</strong> screen_width;
    <strong>uint32_t</strong> screen_height;
&nbsp;
    <strong>uint32_t</strong> window_x;
    <strong>uint32_t</strong> window_y;
    <strong>int32_t</strong>  window_width;
    <strong>int32_t</strong>  window_height;
&nbsp;
    EGLDisplay display;
    EGLSurface surface;
    EGLContext context;
    EGLConfig  config;
} EGL_STATE_T;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vypis konfigurace displeje nabizene pres EGL</i>
<i> */</i>
<strong>void</strong> print_egl_configuration(EGLDisplay display, EGLConfig *config)
{
#define yes_no(x) ((x)==EGL_TRUE ? "yes":"no ")
&nbsp;
    <strong>int</strong> red, green, blue, alpha, buffer;
    <strong>int</strong> depth, stencil;
    <strong>int</strong> bind_to_rgb, bind_to_rgba;
&nbsp;
    eglGetConfigAttrib(display, *config, EGL_RED_SIZE, &amp;red);
    eglGetConfigAttrib(display, *config, EGL_BLUE_SIZE, &amp;green);
    eglGetConfigAttrib(display, *config, EGL_GREEN_SIZE, &amp;blue);
    eglGetConfigAttrib(display, *config, EGL_ALPHA_SIZE, &amp;alpha);
    eglGetConfigAttrib(display, *config, EGL_BUFFER_SIZE, &amp;buffer);
    eglGetConfigAttrib(display, *config, EGL_DEPTH_SIZE, &amp;depth);
    eglGetConfigAttrib(display, *config, EGL_STENCIL_SIZE, &amp;stencil);
&nbsp;
    eglGetConfigAttrib(display, *config,  EGL_BIND_TO_TEXTURE_RGB,  &amp;bind_to_rgb);
    eglGetConfigAttrib(display, *config,  EGL_BIND_TO_TEXTURE_RGBA, &amp;bind_to_rgba);
&nbsp;
    printf("%1d   %1d   %1d   %1d   %2d     %2d      %2d      %s  %s\n",
            red, green, blue, alpha, buffer,
            depth, stencil,
            yes_no(bind_to_rgb),
            yes_no(bind_to_rgba));
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Inicializace EGL.</i>
<i> */</i>
<strong>void</strong> initialize_egl(EGL_STATE_T *state)
{
    EGLBoolean result;
    EGLint     configurations_count;
    EGLConfig *all_configurations;
&nbsp;
    <i>/* nutne pro RPi */</i>
    bcm_host_init();
&nbsp;
    <i>/* pro jistotu vymazeme datovou strukturu nesouci stav EGL */</i>
    memset(state, 0, sizeof(*state));
&nbsp;
    <i>/* propojeni na vychozi displej */</i>
    state-&gt;display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
&nbsp;
    <i>/* inicializace displeje */</i>
    result = eglInitialize(state-&gt;display, NULL, NULL);
&nbsp;
    <i>/* kontrola, zda inicializace probehla v poradku */</i>
    <strong>if</strong> (result == EGL_FALSE) {
        puts("EGL init failed");
        exit(1);
    }
&nbsp;
    <i>/* precteni poctu konfiguraci dostupnych pres EGL */</i>
    eglGetConfigs(state-&gt;display, NULL, 0, &amp;configurations_count);
    printf("EGL has %d configurations available\n", configurations_count);
&nbsp;
    <i>/* nacteni vsech konfiguraci do pripraveneho pole */</i>
    all_configurations = malloc(configurations_count * sizeof(*all_configurations));
    eglGetConfigs(state-&gt;display, all_configurations, configurations_count, &amp;configurations_count);
&nbsp;
    puts("Configuration  R   G   B   A   bpp   depth stencil bind RGB/RGBA");
    <i>/* postupny vypis vsech konfiguraci */</i>
    <strong>int</strong> i;
    <strong>for</strong> (i = 0; i &lt; configurations_count; i++) {
        printf("%3d            ", i);
        print_egl_configuration(state-&gt;display, &amp;all_configurations[i]);
    }
    free(all_configurations);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Ukonceni prace s EGL.</i>
<i> */</i>
<strong>void</strong> finalize_egl(EGL_STATE_T *state)
{
    <i>/* nyni jsou tyto kroky prozatim zbytecne, v dalsich prikladech se vsak budou hodit */</i>
    eglSwapBuffers(state-&gt;display, state-&gt;surface);
    eglMakeCurrent(state-&gt;display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(state-&gt;display, state-&gt;surface);
    eglDestroyContext(state-&gt;display, state-&gt;context);
    eglTerminate(state-&gt;display);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Vstupni bod do programu.</i>
<i> */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> *argv[])
{
    EGL_STATE_T egl_state;
&nbsp;
    initialize_egl(&amp;egl_state);
    puts("initialize_egl OK");
&nbsp;
    finalize_egl(&amp;egl_state);
    puts("finalize_egl OK");
&nbsp;
    <strong>return</strong> 0;
}
</pre>

<p>Soubor Makefile použitý pro překlad a slinkování třetího příkladu má tento
obsah:</p>

<pre>
<i># Makefile pro preklad tretiho prikladu ukazujiciho</i>
<i># praci s OpenVG a EGL.</i>
&nbsp;
<i># Parametry prekladace.</i>
CFLAGS=-Wall
&nbsp;
<i># Dalsi parametry prekladace, zde adresare, kde se maji </i>
<i># hledat hlavickove soubory.</i>
INCLUDES=-I/opt/vc/include/ -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux
&nbsp;
<i># Parametry linkeru.</i>
LDFLAGS=-L/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm
&nbsp;
PROGNAME=example3
&nbsp;
<i># Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.</i>
all:    $(PROGNAME)
&nbsp;
clean:
        rm -f *.o
        rm -f $(PROGNAME)
&nbsp;
<i># Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni</i>
<i># vysledne spustitelne aplikace.</i>
$(PROGNAME):    $(PROGNAME).o
        $(CC) -o $@ $(LDFLAGS) $&lt;
&nbsp;
<i># Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho</i>
<i># objektoveho souboru.</i>
%.o:    %.c
        $(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Výsledky vypsané třetím demonstračním příkladem</h2>

<p>Podívejme se nyní na výstup, který získáme po spuštění třetího
demonstračního příkladu na jednodeskovém mikropočítači <i>Raspberry Pi</i>.
Tento výstup by měl vypadat následovně:</p>

<pre>
EGL has 28 configurations available
Configuration  R   G   B   A   bpp   depth stencil bind RGB/RGBA
  0            8   8   8   8   32     24       8      no   yes
  1            8   8   8   0   24     24       8      yes  yes
  2            8   8   8   8   32     24       0      no   yes
  3            8   8   8   0   24     24       0      yes  yes
  4            8   8   8   8   32      0       8      no   yes
  5            8   8   8   0   24      0       8      yes  yes
  6            8   8   8   8   32      0       0      no   yes
  7            8   8   8   0   24      0       0      yes  yes
  8            8   8   8   8   32     24       8      no   no 
  9            8   8   8   0   24     24       8      no   no 
 10            8   8   8   8   32     24       0      no   no 
 11            8   8   8   0   24     24       0      no   no 
 12            8   8   8   8   32      0       8      no   no 
 13            8   8   8   0   24      0       8      no   no 
 14            8   8   8   8   32      0       0      no   no 
 15            8   8   8   0   24      0       0      no   no 
 16            5   5   6   0   16     24       8      yes  yes
 17            5   5   6   0   16     24       0      yes  yes
 18            5   5   6   0   16      0       8      yes  yes
 19            5   5   6   0   16      0       0      yes  yes
 20            5   5   6   0   16     24       8      no   no 
 21            5   5   6   0   16     24       0      no   no 
 22            5   5   6   0   16      0       8      no   no 
 23            5   5   6   0   16      0       0      no   no 
 24            8   8   8   8   32      0       0      no   yes
 25            8   8   8   0   24      0       0      yes  yes
 26            5   5   6   0   16      0       0      yes  yes
 27            5   5   6   0   16     16       0      yes  yes
initialize_egl OK
finalize_egl OK
</pre>

<p>Získané informace jsou již mnohem zajímavější, protože původní tři
skupiny:</p>

<ol>
<li>Framebuffer s&nbsp;bitovou hloubkou 16bpp bez alfa kanálu (hi-color).</li>
<li>Framebuffer s&nbsp;bitovou hloubkou 24bpp bez alfa kanálu (true color).</li>
<li>Framebuffer s&nbsp;bitovou hloubkou 32bpp s&nbsp;alfa kanálem (true color).</li>
</ol>

<p>se nyní rozpadají na další podskupiny:</p>

<ol>
<li>Bez paměti hloubky (Z-bufferu).</li>
<li>S&nbsp;pamětí hloubky (Z-bufferem), 24bpp (resp.&nbsp;přesněji 24 bits per fragment).</li>
</ol>

<ol>
<li>Bez stencil bufferu.</li>
<li>Se stencil bufferem (ten má hloubku 8 bitů, což lze využít při implementaci
čítačů atd., nejenom pro čistě bitovou masku).</li>
</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Obsah následující části seriálu</h2>

<p>Dnešní článek byl pravděpodobně pro některé čtenáře dosti nezáživný, protože
jsme se v&nbsp;něm zabývali pouze problematikou řešenou knihovnou <i>EGL</i>,
tj.&nbsp;relativně nízkoúrovňovými věcmi. Nicméně i tuto část je dobré pochopit
a nejenom bez rozmyslu použít již hotové knihovny tvořící uživatelsky
přívětivější vrstvu nad EGL. Příště si však již ukážeme, jakým způsobem je
možné prakticky využít knihovnu <i>OpenVG</i> pro tvorbu dvoudimenzionálních
scén složených jak z&nbsp;rastrových obrázků, tak i z&nbsp;různých 2D primitiv
(úsečka, obdélník, Bézierova křivka, kružnice, elipsa apod.). Zájemci se mohou
&ndash; prozatím ovšem bez dalšího popisu &ndash; podívat na demonstrační
příklad, kterým se budeme zabývat příště. Tento příklad je dostupný na adrese
<a
href="https://github.com/tisnik/presentations/tree/master/openvg/example4">https://github.com/tisnik/presentations/tree/master/openvg/example4</a>
(zdrojový kód byl opět odladěn na Raspberry Pi s&nbsp;Raspbiannem).</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny tři demonstrační příklady, které jsme si v&nbsp;dnešním článku
popsali, byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy všech
tří zmíněných demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad/knihovna</th><th>Github</th></tr>
<tr><td>1</td><td>example1</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example1">https://github.com/tisnik/presentations/tree/master/openvg/example1</a></td></tr>
<tr><td>2</td><td>example2</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example2">https://github.com/tisnik/presentations/tree/master/openvg/example2</a></td></tr>
<tr><td>3</td><td>example3</td><td><a href="https://github.com/tisnik/presentations/tree/master/openvg/example3">https://github.com/tisnik/presentations/tree/master/openvg/example3</a></td></tr>
</table>

<p>Pro zjednodušení překladu je ke každému příkladu přiložen i příslušný
Makefile.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>EGL quick reference card<br />
<a href="https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf">https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf</a>
</li>

<li>EGL Reference Pages Index<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php">https://www.khronos.org/registry/egl/sdk/docs/man/html/indexflat.php</a>
</li>

<li>Funkce eglInitialize<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglInitialize.xhtml</a>
</li>

<li>Funkce eglGetDisplay<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetDisplay.xhtml</a>
</li>

<li>Funkce eglGetConfigs<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigs.xhtml</a>
</li>

<li>Funkce eglGetConfigAttrib<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglGetConfigAttrib.xhtml</a>
</li>

<li>Funkce eglDestroySurface<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroySurface.xhtml</a>
</li>

<li>Funkce eglDestroyContext<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglDestroyContext.xhtml</a>
</li>

<li>Funkce eglTerminate<br />
<a href="https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml">https://www.khronos.org/registry/egl/sdk/docs/man/html/eglTerminate.xhtml</a>
</li>

<li>Khronos Native Platform Graphics Interface<br />
<a href="https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf">https://www.khronos.org/registry/egl/specs/eglspec.1.4.pdf</a>
</li>

<li>Khronos Group<br />
<a href="https://www.khronos.org/">https://www.khronos.org/</a>
</li>

<li>Khronos Group (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Khronos_Group">https://en.wikipedia.org/wiki/Khronos_Group</a>
</li>

<li>Raspberry Pi VideoCore APIs<br />
<a href="http://elinux.org/Raspberry_Pi_VideoCore_APIs">http://elinux.org/Raspberry_Pi_VideoCore_APIs</a>
</li>

<li>Programming AudioVideo on the Raspberry Pi GPU<br />
<a href="https://jan.newmarch.name/RPi/index.html">https://jan.newmarch.name/RPi/index.html</a>
</li>

<li>The Standard for Vector Graphics Acceleration<br />
<a href="https://www.khronos.org/openvg/">https://www.khronos.org/openvg/</a>
</li>

<li>OpenVG (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenVG">https://en.wikipedia.org/wiki/OpenVG</a>
</li>

<li>OpenVG Quick Reference Card<br />
<a href="https://www.khronos.org/files/openvg-quick-reference-card.pdf">https://www.khronos.org/files/openvg-quick-reference-card.pdf</a>
</li>

<li>OpenVG on the Raspberry Pi<br />
<a href="http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html">http://mindchunk.blogspot.cz/2012/09/openvg-on-raspberry-pi.html</a>
</li>

<li>ShivaVG: open-source ANSI C OpenVG <br />
<a href="http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html">http://ivanleben.blogspot.cz/2007/07/shivavg-open-source-ansi-c-openvg.html</a>
</li>

<li>Testbed for exploring OpenVG on the Raspberry Pi<br />
<a href="https://github.com/ajstarks/openvg">https://github.com/ajstarks/openvg</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: knihovna Pygame prakticky<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-knihovna-pygame-prakticky/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: práce s bitmapami a TrueType fonty<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-prace-s-bitmapami-a-truetype-fonty/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: sprity v knihovně Pygame<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-sprity-v-knihovne-pygame/</a>
</li>

<li>Programovací jazyky a knihovny určené pro výuku základů počítačové grafiky: detekce kolize spritů<br />
<a href="http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/">http://mojefedora.cz/programovaci-jazyky-a-knihovny-urcene-pro-vyuku-zakladu-pocitacove-grafiky-detekce-kolize-spritu/</a>
</li>

<li>Seriál Grafické karty a grafické akcelerátory<br />
<a href="http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/">http://www.root.cz/serialy/graficke-karty-a-graficke-akceleratory/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>Xiaolin_Wu's Line Algorithm<br />
<a href="https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm">https://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm</a>
</li>

<li>Grafické čipy v osmibitových počítačích Atari<br />
<a href="http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/">http://www.root.cz/clanky/graficke-cipy-v-osmibitovych-pocitacich-atari/</a>
</li>

<li>Osmibitové počítače Commodore a čip VIC-II<br />
<a href="http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/">http://www.root.cz/clanky/osmibitove-pocitace-commodore-a-cip-vic-ii/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Apple<br />
<a href="http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/">http://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-apple/</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">http://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">http://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>Grafické karty MCGA a VGA<br />
<a href="http://www.root.cz/clanky/graficke-karty-mcga-a-vga/">http://www.root.cz/clanky/graficke-karty-mcga-a-vga/</a>
</li>

<li>Grafický subsystém počítačů Amiga<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga/</a>
</li>

<li>Grafický subsystém počítačů Amiga II<br />
<a href="http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/">http://www.root.cz/clanky/graficky-subsystem-pocitacu-amiga-ii/</a>
</li>

<li>Raspberry Pi pages<br />
<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>
</li>

<li>BCM2835 registers<br />
<a href="http://elinux.org/BCM2835_registers">http://elinux.org/BCM2835_registers</a>
</li>

<li>VideoCore (archiv stránek společnosti Alphamosaic)<br />
<a href="http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/">http://web.archive.org/web/20030209213838/www.alphamosaic.com/videocore/</a>
</li>

<li>VideoCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Videocore">https://en.wikipedia.org/wiki/Videocore</a>
</li>

<li>RPi lessons: Lesson 6 Screen01<br />
<a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html</a>
</li>

<li>Raspberry Pi forum: Bare metal<br />
<a href="https://www.raspberrypi.org/forums/viewforum.php?f=72">https://www.raspberrypi.org/forums/viewforum.php?f=72</a>
</li>

<li>C library for Broadcom BCM 2835 as used in Raspberry Pi<br />
<a href="http://www.airspayce.com/mikem/bcm2835/">http://www.airspayce.com/mikem/bcm2835/</a>
</li>

<li>Raspberry Pi Hardware Components<br />
<a href="http://elinux.org/RPi_Hardware#Components">http://elinux.org/RPi_Hardware#Components</a>
</li>

<li>(Linux) Framebuffer<br />
<a href="http://wiki.linuxquestions.org/wiki/Framebuffer">http://wiki.linuxquestions.org/wiki/Framebuffer</a>
</li>

<li>(Linux) Framebuffer HOWTO<br />
<a href="http://tldp.org/HOWTO/Framebuffer-HOWTO/">http://tldp.org/HOWTO/Framebuffer-HOWTO/</a>
</li>

<li>Linux framebuffer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Linux_framebuffer">https://en.wikipedia.org/wiki/Linux_framebuffer</a>
</li>

<li>RPi Framebuffer<br />
<a href="http://elinux.org/RPi_Framebuffer">http://elinux.org/RPi_Framebuffer</a>
</li>

<li>HOWTO: Boot your Raspberry Pi into a fullscreen browser kiosk<br />
<a href="http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/">http://blogs.wcode.org/2013/09/howto-boot-your-raspberry-pi-into-a-fullscreen-browser-kiosk/</a>
</li>

<li>Zdrojový kód fb.c pro RPI<br />
<a href="https://github.com/jncronin/rpi-boot/blob/master/fb.c">https://github.com/jncronin/rpi-boot/blob/master/fb.c</a>
</li>

<li>RPiconfig<br />
<a href="http://elinux.org/RPi_config.txt">http://elinux.org/RPi_config.txt</a>
</li>

<li>Mailbox framebuffer interface<br />
<a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface">https://github.com/raspberrypi/firmware/wiki/Mailbox-framebuffer-interface</a>
</li>

<li>Seriál Grafické formáty<br />
<a href="http://www.root.cz/serialy/graficke-formaty/">http://www.root.cz/serialy/graficke-formaty/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

