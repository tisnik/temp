<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu formátu WebAssembly: SIMD (vektorové) operace</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu formátu WebAssembly: SIMD (vektorové) operace</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Do specifikace WebAssembly byly přidány rozšiřující instrukce, mezi něž patří i SIMD (vektorové) operace. Překladače LLVM tyto instrukce podporují a navíc pro ně máme přímou podporu přímo v Clangu. Právě s tímto velmi důležitým rozšířením WebAssembly se budeme zabývat dnes.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. WebAssembly a vektorové operace</a></p>
<p><a href="#k02">2. Podpora SIMD operací na historických i současných architekturách mikroprocesorů</a></p>
<p><a href="#k03">3. Podpora SIMD operací ve WebAssembly</a></p>
<p><a href="#k04">4. Typ <strong>v128</strong></a></p>
<p><a href="#k05">5. Instrukční prefix <strong>0xFD</strong></a></p>
<p><a href="#k06">6. Jakým způsobem lze SIMD využít pro programy psané v&nbsp;jazyku C?</a></p>
<p><a href="#k07">7. Definice vektorů podporované překladači jazyka C</a></p>
<p><a href="#k08">8. Vektory shodné bitové šířky, ovšem obsahující prvky odlišných typů</a></p>
<p><a href="#k09">9. Operace prováděné s&nbsp;celými vektory</a></p>
<p><a href="#k10">10. Překlad funkce pro součet dvou vektorů do WebAssembly</a></p>
<p><a href="#k11">11. Překlad do WebAssembly s&nbsp;explicitním povolením vektorových instrukcí</a></p>
<p><a href="#k12">12. Součet vektorů s&nbsp;dvojnásobným počtem prvků</a></p>
<p><a href="#k13">13. Součet vektorů s&nbsp;celočíselnými prvky různých typů</a></p>
<p><a href="#k14">14. Součet vektorů s&nbsp;prvky s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k15">15. Všechny instrukce pro součet vektorů</a></p>
<p><a href="#k16">16. Další celočíselné operace prováděné s&nbsp;prvky vektorů</a></p>
<p><a href="#k17">17. Obsah navazujícího článku</a></p>
<p><a href="#k18">18. Tabulka se všemi doposud popsanými instrukcemi</a></p>
<p><a href="#k19">19. Články o SIMD, které doposud na Rootu vyšly</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. WebAssembly a vektorové operace</h2>

<p>Do specifikace WebAssembly byly k&nbsp;základním instrukcím později přidány
i další rozšiřující instrukce a dokonce celé sady nových instrukcí. Mezi tyto
instrukce patří zejména instrukce umožňující provádět vektorové operace
(resp.&nbsp;přesněji řečeno SIMD operace). Překladače LLVM tyto instrukce
podporují a navíc pro ně máme přímou podporu i přímo v&nbsp;Clangu (a to
dokonce na několika úrovních). A právě s&nbsp;tímto (ve světě videí a umělé
inteligence) velmi důležitým rozšířením WebAssembly se budeme zabývat
v&nbsp;dnešním článku.</p>

<p><i>"...sequential computers are approaching a fundamental physical limit on
their potential power. Such a limit is the speed of light..."</i></p>

<p>Budeme se tedy zabývat popisem způsobu implementace operací typu <i>SIMD</i>
(<i>Single Instruction, Multiple Data</i>) ve WebAssembly. Jedná se o velmi
důležitou technologii protože <i>SIMD</i> neboli (poněkud nepřesně řečeno)
vektorové instrukce v&nbsp;současnosti patří ke standardní výbavě prakticky
všech variant moderních mikroprocesorů. Připomeňme si, že z&nbsp;hlediska
dosahovaného výpočetního výkonu leží na samém &bdquo;výkonnostním dně&ldquo;
klasické skalární mikroprocesory s&nbsp;architekturou <i>CISC</i>, které
vykonávají všechny instrukce postupně a dokončení jedné instrukce může
v&nbsp;závislosti na jejich složitosti trvat i několik desítek strojových
taktů.</p>

<p><div class="rs-tip-major">Poznámka: WebAssemby a jiné podobně koncipované
virtuální stroje můžeme považovat za specifikaci &bdquo;virtuálního&ldquo; CPU,
i když se typicky omezujeme pouze na popis instrukční sady, způsobu organizace
operační paměti atd., ovšem bez přesného popisu časování instrukcí.</div></p>

<p>Předností těchto procesorů (v&nbsp;případě WebAssembly pak virtuálních
strojů) může být poměrně velká informační hustota instrukční sady (například i
díky tomu, že operandy některých instrukcí jsou zadány implicitně
popř.&nbsp;jsou podporovány instrukce proměnné délky), což mj.&nbsp;znamená, že
se procesory tohoto typu po poměrně dlouhou dobu obešly bez nutnosti využití
drahých vyrovnávacích pamětí první a druhé úrovně (<i>L1 cache</i>, <i>L2
cache</i>). Klasické procesory s&nbsp;architekturou <i>CISC</i> byly založeny
na mikroprogramovém řadiči vybaveném pamětí mikroinstrukcí a teprve později
začaly být tyto procesory doplňovány technologiemi získanými z&nbsp;jiných
architektur &ndash; instrukční pipeline, prediktorem skoků, vektorovými
instrukcemi (což byly oblasti klasických RISCových architektur) atd. Moderní
mikroprocesory se tak od klasických CISC prakticky ve všech technologických
detailech odlišují.</p>

<p>Výpočetní výkon mikroprocesorů se podařilo poměrně výrazným způsobem zvýšit
u konkurenční architektury <i>RISC</i> zavedením takzvané <i>instrukční
pipeline</i>. Provedení jedné instrukce sice stále trvalo větší počet
strojových cyklů, ovšem díky rozfázování operací v&nbsp;instrukční pipeline
bylo umožněno překrývání většího množství instrukcí, a to bez nutnosti zavádění
skutečné paralelizace (která vede k&nbsp;velkému nárůstu složitosti a tím i
ceny čipu). Spolu se zavedením mikroprocesorů <i>RISC</i> se skutečně stalo, že
reálný i špičkový výpočetní výkon procesorů vzrostl, ale relativně brzy bylo
nutné k&nbsp;těmto čipům přidat vyrovnávací paměti (<i>cache</i>), jelikož
rychlost procesorů rostla mnohem rychleji, než vybavovací doba pamětí. Tento
rozpor mezi rychlostmi obou nejdůležitějších součástí moderních počítačů
ostatně trvá dodnes.</p>

<p>Pro další zvýšení výpočetního výkonu však bylo nutné použít další
technologie, například instrukční sadu <i>VLIW</i> (<i>Very Long Instruction
Word</i>), která však &ndash; opět &ndash; měla velké nároky na rychlost
pamětí. Podobně jako u procesorů <i>RISC</i>, i u <i>VLIW</i> bylo pro zmírnění
požadavků na rychlost pamětí možné použít Harvardskou architekturu,
tj.&nbsp;oddělení paměti programu od paměti dat (programová paměť navíc mohla
mít větší šířku datové sběrnice odpovídající šířce instrukčních slov).
Kombinace <i>VLIW</i> a Harvardské architektury byla používána například u
digitálních signálových procesorů (DSP).</p>

<p>Další zvýšení výkonu umožňují právě vektorové instrukce (přesněji
<i>SIMD</i> instrukce), které ale mají jeden poměrně zásadní nedostatek &ndash;
<i>sémantickou mezeru</i> mezi imperativním &bdquo;skalárním&ldquo; kódem
psaným například v&nbsp;jazyku C (C++ atd.) a instrukční sadou, která je SIMD
(jinými slovy &ndash; běžné programovací jazyky neumožňují dostatečně popsat
vektorové operace). Totéž ostatně platí i pro WebAssembly, takže si dnes
ukážeme, jakým způsobem je tato problematika řešena a jak lze vektorové
instrukce ve WebAssembly využít.</p>

<p><div class="rs-tip-major">Poznámka: ovšem nemusíte se obávat, že by
instrukce WebAssembly používaly tolik způsobů kódování, jako je tomu na
platformě x86-64. Z&nbsp;tohoto pohledu je řešení vektorových instrukcí ve
WebAssembly poměrně čisté a vlastně i do jisté míry elegantní. Navíc je vlastní
využití vektorů v&nbsp;jazyku C relativně přímočaré, jak ostatně uvidíme
v&nbsp;demonstračních příkladech.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podpora SIMD operací na historických i současných architekturách mikroprocesorů</h2>

<p>SIMD operace nalezneme v&nbsp;mnoha historických architekturách
mikroprocesorů, ale (což je důležitější) i v&nbsp;prakticky všech moderních
mikroprocesorech. V&nbsp;této kapitole se o nejvýznamnějších historických i
současných technologiích zmíníme.</p>

<p>Nejznámější implementace instrukcí typu <i>SIMD</i> na mikroprocesorech
s&nbsp;architekturou <i>RISC</i>, ať již se jedná o instrukce určené pro
operace s&nbsp;celými čísly či s&nbsp;čísly reálnými (přesněji řečeno
s&nbsp;plovoucí řádovou čárkou), jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Zkratka/název</th><th>Plný název</th><th>Rodina procesorů</th></tr>
<tr><td>1</td><td>MAX-1</td><td>Multimedia Acceleration eXtensions v1</td><td>HP-PA RISC</td></tr>
<tr><td>2</td><td>MAX-2</td><td>Multimedia Acceleration eXtensions v2</td><td>HP-PA RISC</td></tr>
<tr><td>3</td><td>VIS 1</td><td>Visual Instruction v1</td><td>Set SPARC V9</td></tr>
<tr><td>4</td><td>VIS 2</td><td>Visual Instruction v2</td><td>Set SPARC V9</td></tr>
<tr><td>5</td><td>AltiVec</td><td>(obchodní názvy Velocity Engine, VMX)</td><td>PowerPC</td></tr>
<tr><td>6</td><td>MDMX</td><td>MIPS Digital Media eXtension (MaDMaX)</td><td>MIPS</td></tr>
<tr><td>7</td><td>MIPS-3D</td><td>MIPS-3D</td><td>MIPS</td></tr>
<tr><td>8</td><td>MVI</td><td>Motion Video Instructions</td><td>DEC Alpha</td></tr>
<tr><td>9</td><td>NEON</td><td>Advanced SIMD</td><td>Cortex (ARMv7, ARMv8)</td></tr>
<tr><td>10</td><td>Packed SIMD</td><td>Packed SIMD</td><td>RISC-V</td></tr>
<tr><td>11</td><td>Vector Set</td><td>Vector Set</td><td>RISC-V</td></tr>
<tr><td>12</td><td>Scalable Vector Extension (SVE)</td><td>ARMv8.2-A a novější</td></tr>
<tr><td>13</td><td>VFP</td><td>Vector Floating Point</td><td>původně nikoli SIMD, ale pouze sekvenční operace nad vektory</td></tr>
<tr><td>14</td><td>Helium</td><td>MVE pro čipy Cortex-M</td><td>vybraná jádra Cortex-M</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;současnosti se v&nbsp;praxi
nejčastěji setkáme s&nbsp;technologiemi NEON, SVE a Helium.</div></p>

<p>Zkusme se nyní podívat na seznam různých SIMD (neboli nesprávně řečeno
&bdquo;vektorových&ldquo;) rozšíření původní instrukční sady x86:</p>

<table>
<tr><th>Technologie</th><th>Rok uvedení</th><th>Společnost</th><th>Poprvé použito v&nbsp;čipu</th></tr>
<tr><td>MMX</td><td>1996</td><td>Intel</td><td>Intel Pentium P5</td></tr>
<tr><td>3DNow!</td><td>1998</td><td>AMD</td><td>AMD K6-2</td></tr>
<tr><td>SSE</td><td>1999</td><td>Intel</td><td>Intel Pentium III (mikroarchitektura P6)</td></tr>
<tr><td>SSE2</td><td>2001</td><td>Intel</td><td>Intel Pentium 4 (mikroarchitektura NetBurst)</td></tr>
<tr><td>SSE3</td><td>2004</td><td>Intel</td><td>Intel Pentium 4 (Prescott)</td></tr>
<tr><td>SSSE3</td><td>2006</td><td>Intel</td><td>mikroarchitektura Intel Core</td></tr>
<tr><td>SSE4</td><td>2006</td><td>Intel+AMD</td><td>AMD K10 (SSE4a) , mikroarchitektura Intel Core</td></tr>
<tr><td>SSE5</td><td>2007</td><td>AMD</td><td>(nakonec rozděleno do menších celků), mikroarchitektura Bulldozer</td></tr>
<tr><td>AVX</td><td>2008</td><td>Intel</td><td>mikroarchitektura Sandy Bridge</td></tr>
<tr><td>F16C (CVT16)</td><td>2009</td><td>AMD</td><td>Jaguar, Puma, Bulldozer atd.</td></tr>
<tr><td>XOP</td><td>2009</td><td>AMD</td><td>mikroarchitektura Bulldozer</td></tr>
<tr><td>FMA3</td><td>2012</td><td>AMD</td><td>mikroarchitektura Piledriver, Intel: Haswell a Broadwell</td></tr>
<tr><td>FMA4</td><td>2011</td><td>AMD</td><td>mikroarchitektura Bulldozer (pozdější architektury po Zen 1 již ne)</td></tr>
<tr><td>AVX2</td><td>2013</td><td>Intel</td><td>mikroarchitektura Haswell</td></tr>
<tr><td>AVX-512</td><td>2013</td><td>Intel</td><td>Knights Landing</td></tr>
<tr><td>AMX</td><td>2020</td><td>Intel</td><td>Sapphire Rapids</td></tr>
</table>

<p>Pro někoho může být taktéž zajímavá i informace o tom, jak velké změny
v&nbsp;instrukční sadě mikroprocesorů byly vlastně při přidávání nových
&bdquo;vektorových&ldquo; rozšiřujících instrukčních sad typu <i>SIMD</i>
provedeny. To nám ukáže další tabulka. Je pouze nutné dát si pozor na to, že
počty nových instrukcí zavedených v&nbsp;rámci těchto nových technologií, které
jsou vypsány v&nbsp;tabulce pod odstavcem, nemusí přesně souhlasit s&nbsp;počty
uváděnými v&nbsp;jiných informačních materiálech. Je tomu tak především
z&nbsp;toho důvodu, že se v&nbsp;některých případech rozlišuje i datový typ,
s&nbsp;nímž instrukce pracují (například se může jednat o součet vektoru
s&nbsp;32 bitovými hodnotami nebo 64bitovými hodnotami reprezentovanými
v&nbsp;obou případech ve formátu s&nbsp;plovoucí řádovou čárkou) a někdy se
taková instrukce do celkové sumy započítává pouze jedenkrát. Nicméně údaje
vypsané v&nbsp;níže uvedené tabulce by měly být konzistentní, protože se jedná
o počty nově přidaných operačních kódů instrukcí (například u dále zmíněné
instrukční sady <i>SSE2</i> končí instrukce znakem <strong>D</strong>,
<strong>S</strong>, <strong>I</strong> či <strong>Q</strong> podle typu
zpracovávaných dat/operandů):</p>

<table>
<tr><th>Název technologie</th><th>Počet nových instrukcí</th></tr>
<tr><td>MMX</td><td> 56</td></tr>
<tr><td>3DNow!</td><td> 21</td></tr>
<tr><td>SSE</td><td> 70</td></tr>
<tr><td>SSE2</td><td>144</td></tr>
<tr><td>SSE3</td><td> 13</td></tr>
<tr><td>SSSE3</td><td> 32 (ve skutečnosti vlastně jen 16 instrukcí, ovšem pro dva datové typy)</td></tr>
<tr><td>SSE4</td><td> 54 (z&nbsp;toho 47 v&nbsp;rámci SSE4.1, zbytek v&nbsp;rámci SSE4.2)</td></tr>
<tr><td>SSE5</td><td>170 (z&nbsp;toho 46 základních instrukcí)</td></tr>
<tr><td>F16C</td><td> 4</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Podpora SIMD operací ve WebAssembly</h2>

<p>Nyní se konečně dostáváme k&nbsp;WebAssembly. Původní instrukční sada
WebAssembly byla čistě &bdquo;skalární&ldquo;, což znamená, že veškeré operace
(výpočty, podmínky pro smyčky a rozvětvení atd.) probíhaly se skalárními
hodnotami. Ovšem v&nbsp;době uvádění WebAssembly se na mainstreamových
platformách mikroprocesorů začaly poměrně rychlým způsobem rozvíjet instrukční
sady se SIMD operacemi. To, společně s&nbsp;tím, že bylo nutné podporovat
například přehrávání videí a popř.&nbsp;i celé SW kodeky, vedlo k&nbsp;tomu, že
do WebAssembly byla přidána podpora pro operace s&nbsp;vektory hodnot. Tyto
vektory mají vždy šířku 128 bitů (minimálně v&nbsp;současné verzi WebAssembly),
přičemž těchto 128 bitů může být rozděleno do různých typů prvků. Typicky se
pracuje s&nbsp;vektory obsahujícími čtyři hodnoty typu <i>single/float</i>, ale
může se jednat i o osmici celých čísel atd.</p>

<p>Toto vektorové rozšíření WebAssembly je v&nbsp;současnosti široce podporováno:</p>

<table>
<tr><th>Prohlížeč</th><th>Verze</th><th>Vydáno</th></tr>
<tr><td>Chrome </td><td>≥ 91  </td><td>Květen 2021</td></tr>
<tr><td>Firefox</td><td>≥ 89  </td><td>Červen 2021</td></tr>
<tr><td>Safari </td><td>≥ 16.4</td><td>Březen 2023</td></tr>
<tr><td>Node.js</td><td>≥ 16.4</td><td>Červen 2021</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: to v&nbsp;praxi znamená, že vektorové
instrukce je možné v&nbsp;současnosti používat prakticky bez omezení, protože
se dá předpokládat, že kdo má povolenu technologii WebAssembly, bude mít
současně nové WebAssembly s&nbsp;podporou vektorových operací.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Typ <strong>v128</strong></h2>

<p>O datových typech, které jsou podporovány běžnými skalárními instrukcemi
WebAssembly, jsme se již zmínili v&nbsp;úvodním článku. Připomeňme si, že se
jedná o typy se jmény <strong>i32</strong>, <strong>i64</strong>,
<strong>f32</strong> a <strong>f64</strong>. V&nbsp;rámci rozšíření WebAssembly
o SIMD operace byla přidána podpora pro další datový typ nazvaný
<strong>v128</strong>. Název tohoto typu prozrazuje jeho základní vlastnosti
&ndash; jedná se o vektor, který je uložen ve 128 bitech. Ovšem jaké prvky
budou ve vektoru uloženy závisí na konkrétní instrukci &ndash; může se jednat o
celá čísla se znaménkem nebo bez znaménka, hodnoty s&nbsp;plovoucí řádovou
čárkou s&nbsp;jednoduchou nebo dvojitou přesností nebo dokonce o jedinou
128bitovou hodnotu (ostatně i některé skalární instrukce mají různé varianty,
podle použitých typů operandů).</p>

<p>V&nbsp;jazyce C je tento typ definován následujícím způsobem:</p>

<pre>
typedef int32_t <strong>v128_t</strong> __attribute__((__vector_size__(16), __aligned__(16)));
</pre>

<p>S&nbsp;tím, jakým způsobem se 128bitový vektor &bdquo;rozpadá&ldquo; do
jednotlivých prvků vektorů (různého typu) se podrobněji seznámíme
v&nbsp;praktické části dnešního článku. V&nbsp;Clangu ovšem můžeme
v&nbsp;případě potřeby využít následující definice (ovšem podtržítka naznačují,
že se jedná o interní identifikátory):</p>

<pre>
typedef int32_t            <strong>__v128_u</strong> __attribute__((__vector_size__(16), __aligned__(1)));
typedef signed char        <strong>__i8x16</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef unsigned char      <strong>__u8x16</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef short              <strong>__i16x8</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef unsigned short     <strong>__u16x8</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef int                <strong>__i32x4</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef unsigned int       <strong>__u32x4</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef long long          <strong>__i64x2</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef unsigned long long <strong>__u64x2</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef float              <strong>__f32x4</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef double             <strong>__f64x2</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef __fp16             <strong>__f16x8</strong> __attribute__((__vector_size__(16), __aligned__(16)));
typedef signed char        <strong>__i8x8</strong> __attribute__((__vector_size__(8), __aligned__(8)));
typedef unsigned char      <strong>__u8x8</strong> __attribute__((__vector_size__(8), __aligned__(8)));
typedef short              <strong>__i16x4</strong> __attribute__((__vector_size__(8), __aligned__(8)));
typedef unsigned short     <strong>__u16x4</strong> __attribute__((__vector_size__(8), __aligned__(8)));
typedef int                <strong>__i32x2</strong> __attribute__((__vector_size__(8), __aligned__(8)));
typedef unsigned int       <strong>__u32x2</strong> __attribute__((__vector_size__(8), __aligned__(8)));
typedef float              <strong>__f32x2</strong> __attribute__((__vector_size__(8), __aligned__(8)));
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukční prefix <strong>0xFD</strong></h2>

<p>Všechny doposud popsané instrukce WebAssembly používaly jediný bajt pro
uložení operačního kódu instrukce a většinou i pro určení, s&nbsp;jakými
operandy se má instrukce provést (připomeňme si například několik variant
instrukce pro součet dvou skalárních hodnot). Teoreticky tedy byla instrukční
sada WebAssembly omezena na 256 instrukcí. U SIMD instrukcí je tomu jinak,
protože těchto instrukcí existuje takové množství, že bylo nutné je všechny
sjednotit do jediné skupiny. Tato skupina začíná prefixem
<strong>0xFD</strong>, za kterým následuje operační kód instrukce &ndash; SIMD
instrukcí tedy může být definováno až 256 &ndash; a nutno říci, že prakticky
všechny dostupné operační kódy z&nbsp;této skupiny byly skutečně využity.</p>

<p><div class="rs-tip-major">Poznámka: jednotlivé instrukce si popíšeme
postupně, takže zde (alespoň prozatím) neuvádím celou tabulku s&nbsp;256 novými
instrukcemi SIMD.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Jakým způsobem lze SIMD využít pro programy psané v&nbsp;jazyku C?</h2>

<p>SIMD operace (resp.&nbsp;přesněji řečeno instrukce) podporované ve
WebAssembly je v&nbsp;praxi možné generovat různými způsoby, které se od sebe
odlišují mírou abstrakce (a tedy vlastně i pracností):</p>

<ol>

<li>Povolením automatické vektorizace kódu, což kombinace frontend překladače
Clang a backend překladače LLVM v&nbsp;současné verzi plně podporuje. Výhodou
tohoto řešení je fakt, že není nutné modifikovat existující zdrojové kódy,
nevýhodou pak stále ještě nedokonalosti překladačů v&nbsp;této oblasti (i když
se situace stále zlepšuje).</li>

<li>Taktéž je možné využít takzvané <i>vektorové rozšíření</i> Clangu, které se
podobá vektorovému rozšíření GCC, jímž jsme se na stránkách Roota již zabývali
(viz též <a href="#k19">odkazy na příslušné články uvedené na konci
článku</a>). Základní operace s&nbsp;vektory definovanými tímto způsobem jsou
totiž prováděny právě SIMD instrukcemi definovanými ve WebAssembly.</li>

<li>Další nabízenou možností je použití specializovaných <i>intrinsic</i>
definujících SIMD operace podporované ve WebAssembly. Tyto intrinsic jsou
definovány v&nbsp;hlavičkovém souboru <strong>wasm_simd128.h</strong>. Pozor:
jedná se o odlišné intrinsic, než jaké jsme si popsali v&nbsp;souvislosti
s&nbsp;GCC (viz další dva body).</li>

<li>Alternativně je možné použít původní intrinsic pro rozšíření instrukční
sady x86: x86 SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2 nebo AVX-512
(popř.&nbsp;různé podsady instrukcí). Tyto intrinsic jsou definovány
v&nbsp;hlavičkových souborech <strong>*mmintrin.h</strong> a ještě se
k&nbsp;nim později vrátíme.</li>

<li>Podobné intrinsic existují i pro architekturu ARM a rozšíření instrukční
sady NEON. Tyto intrinsic jsou definovány v&nbsp;hlavičkovém souboru
<strong>arm_neon.h</strong>.</li>

</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Definice vektorů podporované překladači jazyka C</h2>

<p>V&nbsp;oblasti SIMD vládne &bdquo;instrukční babylon&ldquo;, a to jak na
architektuře x86, tak i u ARMu. Ani vývojářům a ani autorům překladačů to nijak
neulehčuje život. Jedno z&nbsp;řešení tohoto stavu spočívá v&nbsp;tom, že
překladače jazyka C podporují takzvané <i>obecné vektorové operace</i>. A
jednou z&nbsp;realizací této myšlenky je rozšíření Clangu i GCC C (a C++) o de
facto nové datové typy &bdquo;vektor určité bajtové délky&ldquo; (dále se
soustředíme pouze na Clang).</p>

<p>Podívejme se na následující demonstrační příklad, v&nbsp;němž je definován
nový datový typ nazvaný <strong>i8x16</strong> (jméno může být pochopitelně
jakékoli). Jedná se o vektor o délce šestnácti bajtů, který obsahuje prvky
typu <strong>signed char</strong>, což zde konkrétně může znamenat, že se do
vektoru vejde celkem šestnáct těchto prvků za předpokladu, že
<strong>sizeof(signed char)==1</strong> (a to při překladu pro WebAssembly
pochopitelně platí):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp; 
typedef signed char <strong>i8x16</strong> __attribute__((vector_size(16)));
&nbsp; 
int <strong>main</strong>(void)
{
    printf("scalar signed byte:   %ld byte(s)\n", sizeof(signed char));
    printf("vector signed bytes:  %ld byte(s)\n", sizeof(i8x16));
    return 0;
}
</pre>

<p>Výsledek, který získáme po překladu a spuštění tohoto demonstračního
příkladu:</p>

<pre>
scalar signed byte:   1 byte(s)
vector signed bytes:  16 byte(s)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vektory shodné bitové šířky, ovšem obsahující prvky odlišných typů</h2>

<p>Naprosto stejným způsobem si můžeme nadefinovat vektory o šířce šestnácti
bajtů (tedy stále 128 bitů) s&nbsp;prvky různých typů:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp; 
typedef signed   char      <strong>i8x16</strong> __attribute__((vector_size(16)));
typedef unsigned char      <strong>u8x16</strong> __attribute__((vector_size(16)));
typedef signed   short int <strong>i16x8</strong> __attribute__((vector_size(16)));
typedef unsigned short int <strong>u16x8</strong> __attribute__((vector_size(16)));
typedef signed   int       <strong>i32x4</strong> __attribute__((vector_size(16)));
typedef unsigned int       <strong>u32x4</strong> __attribute__((vector_size(16)));
typedef   signed long int  <strong>i64x2</strong> __attribute__((vector_size(16)));
typedef unsigned long int  <strong>u64x2</strong> __attribute__((vector_size(16)));
&nbsp; 
int <strong>main</strong>(void)
{
    printf("signed char:    %ld bytes\n", sizeof(signed char));
    printf("unsigned char:  %ld bytes\n", sizeof(unsigned char));
    printf("signed short:   %ld bytes\n", sizeof(signed short int));
    printf("unsigned short: %ld bytes\n", sizeof(unsigned short int));
    printf("signed int:     %ld bytes\n", sizeof(signed int));
    printf("unsigned int:   %ld bytes\n", sizeof(unsigned int));
    printf("signed long:    %ld bytes\n", sizeof(signed long int));
    printf("unsigned long:  %ld bytes\n", sizeof(unsigned long int));
&nbsp; 
    printf("\n");
&nbsp; 
    printf("vector signed char:    %ld bytes\n", sizeof(i8x16));
    printf("vector unsigned char:  %ld bytes\n", sizeof(u8x16));
    printf("vector signed short:   %ld bytes\n", sizeof(i16x8));
    printf("vector unsigned short: %ld bytes\n", sizeof(u16x8));
    printf("vector signed int:     %ld bytes\n", sizeof(i32x4));
    printf("vector unsigned int:   %ld bytes\n", sizeof(u32x4));
    printf("vector signed long:    %ld bytes\n", sizeof(i64x2));
    printf("vector unsigned long:  %ld bytes\n", sizeof(u64x2));
 &nbsp; 
    return 0;
}
</pre>

<p>Výsledky by měly vypadat následovně:</p>

<pre>
signed char:    1 bytes
unsigned char:  1 bytes
signed short:   2 bytes
unsigned short: 2 bytes
signed int:     4 bytes
unsigned int:   4 bytes
signed long:    8 bytes
unsigned long:  8 bytes
&nbsp;
vector signed char:    16 bytes
vector unsigned char:  16 bytes
vector signed short:   16 bytes
vector unsigned short: 16 bytes
vector signed int:     16 bytes
vector unsigned int:   16 bytes
vector signed long:    16 bytes
vector unsigned long:  16 bytes
</pre>

<p>A konečně &ndash; vyzkoušíme si definici vektorů o šířce 128bitů, které
budou obsahovat čtyři prvky typu <strong>float</strong> (jednoduchá přesnost)
nebo dva prvky typu <strong>double</strong> (dvojnásobná přesnost)
popř.&nbsp;osm prvků typu <strong>fp16</strong> (poloviční přesnost):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp; 
typedef float  <strong>f32x4</strong> __attribute__((vector_size(16)));
typedef double <strong>f64x2</strong> __attribute__((vector_size(16)));
typedef __fp16 <strong>f16x8</strong> __attribute__((vector_size(16)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("float:  %ld bytes\n", sizeof(float));
    printf("double: %ld bytes\n", sizeof(double));
    printf("fp16:   %ld bytes\n", sizeof(__fp16));
&nbsp; 
    printf("\n");
&nbsp; 
    printf("vector float:  %ld bytes\n", sizeof(f32x4));
    printf("vector double: %ld bytes\n", sizeof(f64x2));
    printf("vector fp16:   %ld bytes\n", sizeof(f16x8));
&nbsp; 
    return 0;
}
</pre>

<p>Opět se podívejme na zobrazené výsledky:</p>

<pre>
float:  4 bytes
double: 8 bytes
fp16:   2 bytes
&nbsp;
vector float:  16 bytes
vector double: 16 bytes
vector fp16:   16 bytes
</pre>

<p><div class="rs-tip-major">Poznámka: jména nově definovaných datových typů
nebyla zvolena náhodně, protože to odpovídá způsobu značení vektorových
instrukcí ve WebAssembly.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Operace prováděné s&nbsp;celými vektory</h2>

<p>S&nbsp;celými vektory (definovanými tak, jak jsme si ukázali
v&nbsp;předchozích dvou kapitolách) lze pochopitelně provádět i základní
aritmetické operace, což je ukázáno na dalším příkladu, společně s&nbsp;ukázkou
toho, jak se vlastně vektory naplní daty. Budeme provádět součet vektorů
obsahujících šestnáct prvků typu <strong>signed char</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef signed char <strong>i8x16</strong> __attribute__((vector_size(16)));
&nbsp;
i8x16 <strong>add</strong>(i8x16 x, i8x16 y) {
    return x+y;
}
&nbsp;
void <strong>print_vector</strong>(i8x16 *v) {
    int i;
&nbsp;
    printf("[");
    for (i=0; i&lt;16; i++) {
        printf(" %2d", (*v)[i]);
    }
    printf("]\n");
}
&nbsp;
int <strong>main</strong>(void) {
    i8x16 v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
    i8x16 v2 = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10};
    i8x16 v3 = v1+v2;
&nbsp;
    print_vector(&amp;v1);
    print_vector(&amp;v2);
    print_vector(&amp;v3);
&nbsp;
    return 0;
}
</pre>

<p>Po překladu a spuštění tohoto demonstračního příkladu (na běžné platformě
x86 atd.) by se měly napřed zobrazit obsahy původních vektorů a následně i
vektor, který vznikne jejich součtem:</p>

<pre>
[  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16]
[ 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10]
[ 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26]
</pre>

<p>Pro účely překladu do WebAssembly příklad zkrátíme do jediné funkce
<strong>add</strong>, pochopitelně doplněné definicí typu vektorů, které se
budou sčítat:</p>

<pre>
typedef signed char <strong>i8x16</strong> __attribute__((vector_size(16)));
&nbsp; 
i8x16 <strong>add</strong>(i8x16 x, i8x16 y) {
    return x+y;
}
</pre>

<p><div class="rs-tip-major">Poznámka: naprosto stejným způsobem samozřejmě
můžeme implementovat i další &bdquo;vektorové&ldquo; operace prováděné stylem
prvek po prvku, a to i s&nbsp;vektory, které obsahují prvky odlišných typů.
Podrobnosti si uvedeme v&nbsp;navazujících kapitolách.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Překlad funkce pro součet dvou vektorů do WebAssembly</h2>

<p>Funkci <strong>add</strong> <a href="#k09">z&nbsp;předchozí kapitoly</a>
přeložíme standardním způsobem, který jsme až doposud (úspěšně) používali, tedy
s&nbsp;využitím tohoto skriptu:</p>

<pre>
clang -Os --target=wasm32 -emit-llvm -c -S ${1}.c
llc -march=wasm32 -filetype=obj ${1}.ll -o ${1}.wasm
wasm-objdump -d ${1}.wasm
</pre>

<p>Výsledek může vypadat následovně (ovšem různé verze Clangu generují nepatrně
odlišný kód):</p>

<pre>
simd_5.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000062 func[0] <strong>&lt;add&gt;</strong>:
 000063: 20 00                      | local.get 0
 000065: 20 19                      | local.get 25
 000067: 20 09                      | local.get 9
 000069: 6a                         | i32.add
 00006a: 3a 00 08                   | i32.store8 0 8
 00006d: 20 00                      | local.get 0
 00006f: 20 15                      | local.get 21
 000071: 20 05                      | local.get 5
 000073: 6a                         | i32.add
 000074: 3a 00 04                   | i32.store8 0 4
 000077: 20 00                      | local.get 0
 000079: 20 13                      | local.get 19
 00007b: 20 03                      | local.get 3
 00007d: 6a                         | i32.add
 00007e: 3a 00 02                   | i32.store8 0 2
 000081: 20 00                      | local.get 0
 000083: 20 12                      | local.get 18
 000085: 20 02                      | local.get 2
 000087: 6a                         | i32.add
 000088: 3a 00 01                   | i32.store8 0 1
 00008b: 20 00                      | local.get 0
 00008d: 20 11                      | local.get 17
 00008f: 20 01                      | local.get 1
 000091: 6a                         | i32.add
 000092: 3a 00 00                   | i32.store8 0 0
 000095: 20 00                      | local.get 0
 000097: 41 0f                      | i32.const 15
 000099: 6a                         | i32.add
 00009a: 20 20                      | local.get 32
 00009c: 20 10                      | local.get 16
 00009e: 6a                         | i32.add
 00009f: 3a 00 00                   | i32.store8 0 0
 0000a2: 20 00                      | local.get 0
 0000a4: 41 0e                      | i32.const 14
 0000a6: 6a                         | i32.add
 0000a7: 20 1f                      | local.get 31
 0000a9: 20 0f                      | local.get 15
 0000ab: 6a                         | i32.add
 0000ac: 3a 00 00                   | i32.store8 0 0
 0000af: 20 00                      | local.get 0
 0000b1: 41 0d                      | i32.const 13
 0000b3: 6a                         | i32.add
 0000b4: 20 1e                      | local.get 30
 0000b6: 20 0e                      | local.get 14
 0000b8: 6a                         | i32.add
 0000b9: 3a 00 00                   | i32.store8 0 0
 0000bc: 20 00                      | local.get 0
 0000be: 41 0c                      | i32.const 12
 0000c0: 6a                         | i32.add
 0000c1: 20 1d                      | local.get 29
 0000c3: 20 0d                      | local.get 13
 0000c5: 6a                         | i32.add
 0000c6: 3a 00 00                   | i32.store8 0 0
 0000c9: 20 00                      | local.get 0
 0000cb: 41 0b                      | i32.const 11
 0000cd: 6a                         | i32.add
 0000ce: 20 1c                      | local.get 28
 0000d0: 20 0c                      | local.get 12
 0000d2: 6a                         | i32.add
 0000d3: 3a 00 00                   | i32.store8 0 0
 0000d6: 20 00                      | local.get 0
 0000d8: 41 0a                      | i32.const 10
 0000da: 6a                         | i32.add
 0000db: 20 1b                      | local.get 27
 0000dd: 20 0b                      | local.get 11
 0000df: 6a                         | i32.add
 0000e0: 3a 00 00                   | i32.store8 0 0
 0000e3: 20 00                      | local.get 0
 0000e5: 41 09                      | i32.const 9
 0000e7: 6a                         | i32.add
 0000e8: 20 1a                      | local.get 26
 0000ea: 20 0a                      | local.get 10
 0000ec: 6a                         | i32.add
 0000ed: 3a 00 00                   | i32.store8 0 0
 0000f0: 20 00                      | local.get 0
 0000f2: 41 07                      | i32.const 7
 0000f4: 6a                         | i32.add
 0000f5: 20 18                      | local.get 24
 0000f7: 20 08                      | local.get 8
 0000f9: 6a                         | i32.add
 0000fa: 3a 00 00                   | i32.store8 0 0
 0000fd: 20 00                      | local.get 0
 0000ff: 41 06                      | i32.const 6
 000101: 6a                         | i32.add
 000102: 20 17                      | local.get 23
</pre>

<p>Povšimněte si, že se v&nbsp;tomto případě ve skutečnosti žádná vektorová
operace neprovedla, protože zde můžeme vidět sérii &bdquo;skalárních&ldquo;
součtů:</p>

<pre>
 000069: 6a                         | i32.add
 ...
 000073: 6a                         | i32.add
 ...
 00007d: 6a                         | i32.add
 ...
 000087: 6a                         | i32.add
 ...
 000091: 6a                         | i32.add
 ...
 000099: 6a                         | i32.add
 ...
 00009e: 6a                         | i32.add
 ...
 0000a6: 6a                         | i32.add
 ...
 0000ab: 6a                         | i32.add
 ...
 0000b3: 6a                         | i32.add
 ...
 0000b8: 6a                         | i32.add
 ...
 0000c0: 6a                         | i32.add
 ...
 0000c5: 6a                         | i32.add
 ...
 0000cd: 6a                         | i32.add
 ...
 0000d2: 6a                         | i32.add
 ...
 0000da: 6a                         | i32.add
 ...
 0000df: 6a                         | i32.add
 ...
 0000e7: 6a                         | i32.add
 ...
 0000ec: 6a                         | i32.add
 ...
 0000f4: 6a                         | i32.add
 ...
 0000f9: 6a                         | i32.add
 ...
 000101: 6a                         | i32.add
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Překlad do WebAssembly s&nbsp;explicitním povolením vektorových instrukcí</h2>

<p>Aby se ve WebAssembly používaly vektorové instrukce, je nutné skript určený
pro překlad nepatrným způsobem upravit. Budeme muset překladači Clang
explicitně povolit generování SIMD instrukcí, a to přepínačem
<strong>-msimd128</strong>. Upravený skript by tedy mohl vypadat
následovně:</p>

<pre>
clang -Os <strong>-msimd128</strong> --target=wasm32 -emit-llvm -c -S ${1}.c
llc -march=wasm32 -filetype=obj ${1}.ll -o ${1}.wasm
wasm-objdump -d ${1}.wasm
</pre>

<p>Nyní se funkce <strong>add</strong> skutečně přeloží do podoby, v&nbsp;níž
je použita SIMD instrukce nazvaná <strong>i8x16.add</strong>, tedy
&bdquo;vektorová&ldquo; podoba skalární operace <strong>add</strong>:</p>

<pre>
simd_5.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000043 func[0] <strong>&lt;add&gt;</strong>:
 000044: 20 01                      | local.get 1
 000046: 20 00                      | local.get 0
 000048: fd 6e                      | i8x16.add
 00004a: 0b                         | end
</pre>

<p>Výsledek by tedy měl být při interpretaci nebo JITování cca 16&times;
rychlejší!</p>

<p><div class="rs-tip-major">Poznámka: název instrukce
<strong>i8x16.add</strong> nijak nesouvisí s&nbsp;tím, že jsme náš typ vektoru
pojmenovali právě <strong>i8x16</strong>. Mohli bychom použít libovolné jméno a
výsledek překladu by byl stále stejný.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Součet vektorů s&nbsp;dvojnásobným počtem prvků</h2>

<p>WebAssembly sice omezuje vektorové operace na 128bitové vektory, ovšem to
neznamená, že se musíme tímto omezením řídit i v&nbsp;céčku. Pokusme se nyní
realizovat funkci pro součet vektorů, které budou obsahovat 32 prvků typu
<strong>signed char</strong>. Bude se tedy jednat o 256bitové vektory:</p>

<pre>
typedef signed char <strong>i8x32</strong> __attribute__((vector_size(32)));
&nbsp; 
i8x32 add(i8x32 x, i8x32 y) {
    return x+y;
}
</pre>

<p>Z&nbsp;výsledku překladu do WebAssembly je patrné, že se vektory sečtou po
částech (nyní zcela přesně po polovinách):</p>

<pre>
simd_6.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000045 func[0] <strong>&lt;add&gt;</strong>:
 000046: 20 00                      | local.get 0
 000048: 20 04                      | local.get 4
 00004a: 20 02                      | local.get 2
 00004c: fd 6e                      | i8x16.add
 00004e: fd 0b 04 10                | v128.store 4 16
 000052: 20 00                      | local.get 0
 000054: 20 03                      | local.get 3
 000056: 20 01                      | local.get 1
 000058: fd 6e                      | i8x16.add
 00005a: fd 0b 04 00                | v128.store 4 0
 00005e: 0b                         | end
</pre>

<p><div class="rs-tip-major">Poznámka: mimochodem zde kromě vektorové instrukce
součtu můžeme vidět i instrukci určenou pro uložení celého 128bitového
vektoru.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Součet vektorů s&nbsp;celočíselnými prvky různých typů</h2>

<p>Prozatím víme, jakým způsobem je realizován součet vektorů s&nbsp;prvky typu
<strong>signed char</strong>. Pokusme se nyní o realizaci součtu vektorů
s&nbsp;celočíselnými prvky jiných typů (s&nbsp;odlišnou bitovou šířkou a
popř.&nbsp;bez znaménka). Předchozí demonstrační příklad bude rozšířen do
podoby:</p>

<pre>
typedef signed   char      <strong>i8x16</strong> __attribute__((vector_size(16)));
typedef unsigned char      <strong>u8x16</strong> __attribute__((vector_size(16)));
typedef signed   short int <strong>i16x8</strong> __attribute__((vector_size(16)));
typedef unsigned short int <strong>u16x8</strong> __attribute__((vector_size(16)));
typedef signed   int       <strong>i32x4</strong> __attribute__((vector_size(16)));
typedef unsigned int       <strong>u32x4</strong> __attribute__((vector_size(16)));
typedef   signed long int  <strong>i64x2</strong> __attribute__((vector_size(16)));
typedef unsigned long int  <strong>u64x2</strong> __attribute__((vector_size(16)));
&nbsp; 
i8x16 <strong>add_i8x16</strong>(i8x16 x, i8x16 y) {
    return x+y;
}
&nbsp;
u8x16 <strong>add_u8x16</strong>(u8x16 x, u8x16 y) {
    return x+y;
}
&nbsp;
i16x8 <strong>add_i16x8</strong>(i16x8 x, i16x8 y) {
    return x+y;
}
&nbsp;
u16x8 <strong>add_u16x8</strong>(u16x8 x, u16x8 y) {
    return x+y;
}
&nbsp;
i32x4 <strong>add_i32x4</strong>(i32x4 x, i32x4 y) {
    return x+y;
}
&nbsp;
u32x4 <strong>add_u32x4</strong>(u32x4 x, u32x4 y) {
    return x+y;
}
&nbsp;
i64x2 <strong>add_i64x2</strong>(i64x2 x, i64x2 y) {
    return x+y;
}
&nbsp;
u64x2 <strong>add_u64x2</strong>(u64x2 x, u64x2 y) {
    return x+y;
}
</pre>

<p>Ve výsledném bajtkódu můžeme vidět různé varianty vektorových instrukcí pro
součet, u kterých se však (logicky) nerozlišuje mezi tím, zda jsou prvky
vektorů se znaménkem nebo bez znaménka:</p>

<pre>
simd_7.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
00004a func[0] <strong>&lt;add_i8x16&gt;</strong>:
 00004b: 20 01                      | local.get 1
 00004d: 20 00                      | local.get 0
 00004f: fd 6e                      | i8x16.add
 000051: 0b                         | end
&nbsp;
000053 func[1] <strong>&lt;add_u8x16&gt;</strong>:
 000054: 20 01                      | local.get 1
 000056: 20 00                      | local.get 0
 000058: fd 6e                      | i8x16.add
 00005a: 0b                         | end
&nbsp;
00005c func[2] <strong>&lt;add_i16x8&gt;</strong>:
 00005d: 20 01                      | local.get 1
 00005f: 20 00                      | local.get 0
 000061: fd 8e 01                   | i16x8.add
 000064: 0b                         | end
&nbsp;
000066 func[3] <strong>&lt;add_u16x8&gt;</strong>:
 000067: 20 01                      | local.get 1
 000069: 20 00                      | local.get 0
 00006b: fd 8e 01                   | i16x8.add
 00006e: 0b                         | end
&nbsp;
000070 func[4] <strong>&lt;add_i32x4&gt;</strong>:
 000071: 20 01                      | local.get 1
 000073: 20 00                      | local.get 0
 000075: fd ae 01                   | i32x4.add
 000078: 0b                         | end
&nbsp;
00007a func[5] <strong>&lt;add_u32x4&gt;</strong>:
 00007b: 20 01                      | local.get 1
 00007d: 20 00                      | local.get 0
 00007f: fd ae 01                   | i32x4.add
 000082: 0b                         | end
&nbsp;
000084 func[6] <strong>&lt;add_i64x2&gt;</strong>:
 000085: 20 01                      | local.get 1
 000087: 20 00                      | local.get 0
 000089: fd ae 01                   | i32x4.add
 00008c: 0b                         | end
&nbsp;
00008e func[7] <strong>&lt;add_u64x2&gt;</strong>:
 00008f: 20 01                      | local.get 1
 000091: 20 00                      | local.get 0
 000093: fd ae 01                   | i32x4.add
 000096: 0b                         | end
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Součet vektorů s&nbsp;prvky s&nbsp;plovoucí řádovou čárkou</h2>

<p>Vektory mohou obsahovat prvky s&nbsp;plovoucí řádovou čárkou. Datové typy
jednotlivých prvků mohou být s&nbsp;poloviční přesností (<i>half float</i>,
k&nbsp;tomuto tématu se ještě vrátíme), s&nbsp;jednoduchou přesností
(<i>single</i>) i s&nbsp;dvojitou přesností (<i>double</i>). To si pochopitelně
můžeme snadno ověřit:</p>

<pre>
typedef float  <strong>f32x4</strong> __attribute__((vector_size(16)));
typedef double <strong>f64x2</strong> __attribute__((vector_size(16)));
typedef __fp16 <strong>f16x8</strong> __attribute__((vector_size(16)));
&nbsp; 
f16x8 <strong>add_f16x8</strong>(f16x8 x, f16x8 y) {
    return x+y;
}
&nbsp; 
f32x4 <strong>add_f32x4</strong>(f32x4 x, f32x4 y) {
    return x+y;
}
&nbsp; 
f64x2 <strong>add_f64x2</strong>(f64x2 x, f64x2 y) {
    return x+y;
}
</pre>

<p>Překlad do WebAssembly dopadne následovně:</p>

<pre>
simd_8.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000045 func[0] <strong>&lt;add_f16x8&gt;</strong>:
 000046: 20 01                      | local.get 1
 000048: 20 00                      | local.get 0
 00004a: fd 8e 01                   | i16x8.add
 00004d: 0b                         | end
&nbsp;
00004f func[1] <strong>&lt;add_f32x4&gt;</strong>:
 000050: 20 00                      | local.get 0
 000052: 20 01                      | local.get 1
 000054: fd e4 01                   | f32x4.add
 000057: 0b                         | end
&nbsp;
000059 func[2] <strong>&lt;add_f64x2&gt;</strong>:
 00005a: 20 00                      | local.get 0
 00005c: 20 01                      | local.get 1
 00005e: fd f0 01                   | f64x2.add
 000061: 0b                         | end
</pre>

<p><div class="rs-tip-major">Poznámka: zde je chyba &ndash; instrukce
<strong>i16x8.add</strong> se má jmenovat <strong>f16x8.add</strong>.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Všechny instrukce pro součet vektorů</h2>

<p>Nyní si již můžeme vytvořit soupis všech instrukcí WebAssembly, které
dokážou sečíst dvojici vektorů. Všechny tyto instrukce byly použity
v&nbsp;předchozích demonstračních příkladech:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Struktura vektorů, které se sčítají</th></tr>
<tr><td>fd 6e   </td><td>i8x16.add</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 8e 01</td><td>i16x8.add</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd ae 01</td><td>i32x4.add</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd e4 01</td><td>f32x4.add</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd f0 01</td><td>f64x2.add</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Další celočíselné operace prováděné s&nbsp;prvky vektorů</h2>

<p>Pokusme se o implementaci dalších základních aritmetických operací
prováděných s&nbsp;prvky vektorů. Použijeme vektory se čtyřmi 32bitovými prvky
a budeme implementovat operaci změny znaménka a dále součet (ten už známe),
rozdíl, součin i podíl:</p>

<pre>
typedef unsigned int <strong>i32x4</strong> __attribute__((vector_size(16)));
&nbsp; 
i32x4 <strong>neg</strong>(i32x4 x) {
    return -x;
}
&nbsp; 
i32x4 <strong>add</strong>(i32x4 x, i32x4 y) {
    return x+y;
}
&nbsp; 
i32x4 <strong>sub</strong>(i32x4 x, i32x4 y) {
    return x-y;
}
&nbsp; 
i32x4 <strong>mul</strong>(i32x4 x, i32x4 y) {
    return x*y;
}
&nbsp; 
i32x4 <strong>div</strong>(i32x4 x, i32x4 y) {
    return x/y;
}
</pre>

<p>Většina operací bude přeložena do jediné instrukce WebAssembly, ovšem
s&nbsp;výjimkou podílu (k&nbsp;tomu, proč výsledek vypadá tak jak vypadá, se
vrátíme příště):</p>

<pre>
simd_9.wasm:    file format wasm 0x1

Code Disassembly:

00004c func[0] &lt;neg&gt;:
 00004d: 20 00                      | local.get 0
 00004f: fd a1 01                   | i32x4.neg
 000052: 0b                         | end
&nbsp;
000054 func[1] &lt;add&gt;:
 000055: 20 01                      | local.get 1
 000057: 20 00                      | local.get 0
 000059: fd ae 01                   | i32x4.add
 00005c: 0b                         | end
&nbsp;
00005e func[2] &lt;sub&gt;:
 00005f: 20 00                      | local.get 0
 000061: 20 01                      | local.get 1
 000063: fd b1 01                   | i32x4.sub
 000066: 0b                         | end
&nbsp;
000068 func[3] &lt;mul&gt;:
 000069: 20 01                      | local.get 1
 00006b: 20 00                      | local.get 0
 00006d: fd b5 01                   | i32x4.mul
 000070: 0b                         | end
&nbsp;
000072 func[4] &lt;div&gt;:
 000073: 20 00                      | local.get 0
 000075: fd 1b 00                   | i32x4.extract_lane 0
 000078: 20 01                      | local.get 1
 00007a: fd 1b 00                   | i32x4.extract_lane 0
 00007d: 6e                         | i32.div_u
 00007e: fd 11                      | i32x4.splat
 000080: 20 00                      | local.get 0
 000082: fd 1b 01                   | i32x4.extract_lane 1
 000085: 20 01                      | local.get 1
 000087: fd 1b 01                   | i32x4.extract_lane 1
 00008a: 6e                         | i32.div_u
 00008b: fd 1c 01                   | i32x4.replace_lane 1
 00008e: 20 00                      | local.get 0
 000090: fd 1b 02                   | i32x4.extract_lane 2
 000093: 20 01                      | local.get 1
 000095: fd 1b 02                   | i32x4.extract_lane 2
 000098: 6e                         | i32.div_u
 000099: fd 1c 02                   | i32x4.replace_lane 2
 00009c: 20 00                      | local.get 0
 00009e: fd 1b 03                   | i32x4.extract_lane 3
 0000a1: 20 01                      | local.get 1
 0000a3: fd 1b 03                   | i32x4.extract_lane 3
 0000a6: 6e                         | i32.div_u
 0000a7: fd 1c 03                   | i32x4.replace_lane 3
 0000aa: 0b                         | end
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah navazujícího článku</h2>

<p>Ve skutečnosti je ve WebAssembly definováno přibližně dvě stě různých
vektorových instrukcí. Některé z&nbsp;těchto instrukcí si popíšeme
v&nbsp;navazujícím článku.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Tabulka se všemi doposud popsanými instrukcemi</h2>

<p>Všechny instrukce WebAssembly, které jsme si až doposud popsali, jsou
vypsány v&nbsp;následující tabulce, kde jsou seřazeny podle svého operačního
kódu (tedy na základě hodnoty svého prvního bajtu). Aby bylo zřejmé, jaký
rozsah instrukčního souboru již byl popsán, obsahuje tabulka i (prozatím)
prázdné řádky:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Stručný popis</th></tr>
<tr><td>0x00</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x01</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x02</td><td>block</td><td>uloží na zásobník řízení toku (<i>control-flow stack</i>)</td></tr>
<tr><td>0x03</td><td>loop</td><td>návěští je nastavena na současnou pozici v&nbsp;bajtkódu a zapamatováno</td></tr>
<tr><td>0x04</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x05</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x06</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x07</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x08</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x09</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x0a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x0b</td><td>end</td><td>konec bloku nebo konec celé funkce</td></tr>
<tr><td>0x0c</td><td>br</td><td>provede se nepodmíněný skok</td></tr>
<tr><td>0x0d</td><td>br_if</td><td>pokud je na zásobníku uložena nenulová hodnota, provede se skok, jinak se neprovede žádná operace</td></tr>
<tr><td>0x0e</td><td>br_table</td><td>rozeskok mezi více bloky</td></tr>
<tr><td>0x0f</td><td>return</td><td>ukončení funkce s&nbsp;předáním návratových hodnot přes zásobník</td></tr>
<tr><td>0x10</td><td>call</td><td>zavolání funkce</td></tr>
<tr><td>0x11</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x12</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x13</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x14</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x15</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x16</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x17</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x18</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x19</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1a</td><td>drop</td><td>odstranění hodnoty nebo hodnot ze zásobníku operandů</td></tr>
<tr><td>0x1b</td><td>select</td><td>ze zásobníku přečte tři hodnoty, na základě výsledku podmínky vrátí na zásobník druhou nebo třetí hodnotu</td></tr>
<tr><td>0x1c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x20</td><td>local.get</td><td>uložení hodnoty lokální proměnné na zásobník</td></tr>
<tr><td>0x21</td><td>local.set</td><td>přenos hodnoty z&nbsp;vrcholu zásobníku do lokální proměnné</td></tr>
<tr><td>0x22</td><td>local.tee</td><td>kopie hodnoty z&nbsp;vrcholu zásobníku do lokální proměnné</td></tr>
<tr><td>0x23</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x24</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x25</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x26</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x27</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x28</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x29</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x30</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x31</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x32</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x33</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x34</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x35</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x36</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x37</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x38</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x39</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x41</td><td>i32.const</td><td>uložení 32bitové celočíselné konstanty na zásobník</td></tr>
<tr><td>0x42</td><td>i64.const</td><td>uložení 64bitové celočíselné konstanty na zásobník</td></tr>
<tr><td>0x43</td><td>f32.const</td><td>uložení 32bitové konstanty s&nbsp;plovoucí řádovou čárkou na zásobník</td></tr>
<tr><td>0x44</td><td>f64.const</td><td>uložení 64bitové konstanty s&nbsp;plovoucí řádovou čárkou na zásobník</td></tr>
<tr><td>0x44</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x45</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x46</td><td>i32.eq</td><td>porovnání operandů typu int32 na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x47</td><td>i32.ne</td><td>porovnání operandů typu int32 na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x48</td><td>i32.lt_s</td><td>porovnání operandů typu int32 na relaci &bdquo;menší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x49</td><td>i32.lt_u</td><td>porovnání operandů typu int32 na relaci &bdquo;menší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x4a</td><td>i32.gt_s</td><td>porovnání operandů typu int32 na relaci &bdquo;větší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x4b</td><td>i32.gt_u</td><td>porovnání operandů typu int32 na relaci &bdquo;větší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x4c</td><td>i32.le_s</td><td>porovnání operandů typu int32 na relaci &bdquo;menší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x4d</td><td>i32.le_u</td><td>porovnání operandů typu int32 na relaci &bdquo;menší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x4e</td><td>i32.ge_s</td><td>porovnání operandů typu int32 na relaci &bdquo;větší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x4f</td><td>i32.ge_u</td><td>porovnání operandů typu int32 na relaci &bdquo;větší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x50</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x51</td><td>i64.eq</td><td>porovnání operandů typu int64 na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x52</td><td>i64.ne</td><td>porovnání operandů typu int64 na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x53</td><td>i64.lt_s</td><td>porovnání operandů typu int64 na relaci &bdquo;menší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x54</td><td>i64.lt_u</td><td>porovnání operandů typu int64 na relaci &bdquo;menší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x55</td><td>i64.gt_s</td><td>porovnání operandů typu int64 na relaci &bdquo;větší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x56</td><td>i64.gt_u</td><td>porovnání operandů typu int64 na relaci &bdquo;větší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x57</td><td>i64.le_s</td><td>porovnání operandů typu int64 na relaci &bdquo;menší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x58</td><td>i64.le_u</td><td>porovnání operandů typu int64 na relaci &bdquo;menší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x59</td><td>i64.ge_s</td><td>porovnání operandů typu int64 na relaci &bdquo;větší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x5a</td><td>i64.ge_u</td><td>porovnání operandů typu int64 na relaci &bdquo;větší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x5b</td><td>f32.eq</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x5c</td><td>f32.ne</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x5d</td><td>f32.lt</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;menší než&ldquo;</td></tr>
<tr><td>0x5e</td><td>f32.gt</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td>0x5f</td><td>f32.le</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>0x60</td><td>f32.ge</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td>0x61</td><td>f64.eq</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x62</td><td>f64.ne</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x63</td><td>f64.lt</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;menší než&ldquo;</td></tr>
<tr><td>0x64</td><td>f64.gt</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td>0x65</td><td>f64.le</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>0x66</td><td>f64.ge</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td>0x67</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x68</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x69</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x6a</td><td>i32.add</td><td>součet dvou celých 32bitových hodnot</td></tr>
<tr><td>0x6b</td><td>i32.sub</td><td>rozdíl dvou celých 32bitových hodnot</td></tr>
<tr><td>0x6c</td><td>i32.mul</td><td>součin dvou celých 32bitových hodnot</td></tr>
<tr><td>0x6d</td><td>i32.div_s</td><td>podíl dvou celých 32bitových hodnot se znaménkem</td></tr>
<tr><td>0x6e</td><td>i32.div_u</td><td>podíl dvou celých 32bitových hodnot bez znaménka</td></tr>
<tr><td>0x6f</td><td>i32.rem_s</td><td>zbytek po dělení dvou celých 32bitových hodnot se znaménkem</td></tr>
<tr><td>0x70</td><td>i32.rem_u</td><td>zbytek po dělení dvou celých 32bitových hodnot bez znaménka</td></tr>
<tr><td>0x71</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x72</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x73</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x74</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x75</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x76</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x77</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x78</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x79</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7c</td><td>i64.add</td><td>součet dvou celých 64bitových hodnot</td></tr>
<tr><td>0x7d</td><td>i64.sub</td><td>rozdíl dvou celých 64bitových hodnot</td></tr>
<tr><td>0x7e</td><td>i64.mul</td><td>součin dvou celých 64bitových hodnot</td></tr>
<tr><td>0x7f</td><td>i64.div_s</td><td>podíl dvou celých 64bitových hodnot se znaménkem</td></tr>
<tr><td>0x80</td><td>i64.div_u</td><td>podíl dvou celých 64bitových hodnot bez znaménka</td></tr>
<tr><td>0x81</td><td>i64.rem_s</td><td>zbytek po dělení dvou celých 64bitových hodnot se znaménkem</td></tr>
<tr><td>0x82</td><td>i64.rem_u</td><td>zbytek po dělení dvou celých 64bitových hodnot bez znaménka</td></tr>
<tr><td>0x83</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x84</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x85</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x86</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x87</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x88</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x89</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8b</td><td>f32.abs</td><td>absolutní hodnota typu <i>single/float</i></td></tr>
<tr><td>0x8c</td><td>f32.neg</td><td>otočení znaménka u hodnoty typu <i>single/float</i></td></tr>
<tr><td>0x8d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x90</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x91</td><td>f32.sqrt</td><td>druhá odmocnina z&nbsp;hodnoty typu <i>single/float</i></td></tr>
<tr><td>0x92</td><td>f32.add</td><td>součet dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x93</td><td>f32.sub</td><td>rozdíl dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x94</td><td>f32.mul</td><td>součin dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x95</td><td>f32.div</td><td>podíl dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x96</td><td>f32.min</td><td>součet dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x97</td><td>f32.max</td><td>součet dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x98</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x99</td><td>f64.abs</td><td>absolutní hodnota typu <i>double</i></td></tr>
<tr><td>0x9a</td><td>f64.neg</td><td>otočení znaménka u hodnoty typu <i>double</i></td></tr>
<tr><td>0x9b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9f</td><td>f64.sqrt</td><td>druhá odmocnina z&nbsp;hodnoty typu <i>double</i></td></tr>
<tr><td>0xa0</td><td>f64.add</td><td>součet dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa1</td><td>f64.sub</td><td>rozdíl dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa2</td><td>f64.mul</td><td>součin dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa3</td><td>f64.div</td><td>podíl dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa4</td><td>f64.min</td><td>součet dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa5</td><td>f64.max</td><td>součet dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xa7</td><td>i32.wrap_i64</td><td>de facto opak instrukce <strong>extend</strong>, převod hodnoty se ztrátou informace 64 na 32 bitů</td></tr>
<tr><td>0xa8</td><td>i32.trunc_f32_s</td><td>převod hodnoty typu <i>float</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xa9</td><td>i32.trunc_f32_u</td><td>převod hodnoty typu <i>float</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xaa</td><td>i32.trunc_f64_s</td><td>převod hodnoty typu <i>double</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xab</td><td>i32.trunc_f64_u</td><td>převod hodnoty typu <i>double</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xac</td><td>i64.extend_i32_s</td><td>znaménkové rozšíření hodnoty (32 na 64 bitů)</td></tr>
<tr><td>0xad</td><td>i64.extend_i32_u</td><td>bezznaménkové rozšíření hodnoty (32 na 64 bitů)</td></tr>
<tr><td>0xae</td><td>i64.trunc_f32_s</td><td>převod hodnoty typu <i>float</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xaf</td><td>i64.trunc_f32_u</td><td>převod hodnoty typu <i>float</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xb0</td><td>i64.trunc_f64_s</td><td>převod hodnoty typu <i>double</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xb1</td><td>i64.trunc_f64_u</td><td>převod hodnoty typu <i>double</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xb2</td><td>f32.convert_i32_s</td><td>konverze celého čísla se znaménkem (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb3</td><td>f32.convert_i32_u</td><td>konverze celého čísla bez znaménka (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb4</td><td>f32.convert_i64_s</td><td>konverze celého čísla se znaménkem (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb5</td><td>f32.convert_i64_u</td><td>konverze celého čísla bez znaménka (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb6</td><td>f32.demote_f64</td><td>převod hodnoty typu <i>double</i> na typ <i>float</i></td></tr>
<tr><td>0xb7</td><td>f64.convert_i32_s</td><td>konverze celého čísla se znaménkem (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xb8</td><td>f64.convert_i32_u</td><td>konverze celého čísla bez znaménka (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xb9</td><td>f64.convert_i64_s</td><td>konverze celého čísla se znaménkem (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xba</td><td>f64.convert_i64_u</td><td>konverze celého čísla bez znaménka (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xbb</td><td>f64.promote_f32</td><td>převod hodnoty typu <i>float</i> na typ <i>double</i></td></tr>
<tr><td>0xbc</td><td>i32.reinterpret_f32</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xbd</td><td>i64.reinterpret_f64</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xbe</td><td>f32.reinterpret_i32</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xbf</td><td>f64.reinterpret_i64</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xc0</td><td>i32.extend8_s</td><td>znaménkové rozšíření hodnoty z&nbsp;8 bitů na 32 bitů</td></tr>
<tr><td>0xc1</td><td>i32.extend16_s</td><td>znaménkové rozšíření hodnoty ze 16 bitů na 32 bitů</td></tr>
<tr><td>0xc2</td><td>i64.extend8_s</td><td>znaménkové rozšíření hodnoty z&nbsp;8 bitů na 64 bitů</td></tr>
<tr><td>0xc3</td><td>i64.extend16_s</td><td>znaménkové rozšíření hodnoty ze 16 bitů na 64 bitů</td></tr>
<tr><td>0xc4</td><td>i64.extend32_s</td><td>znaménkové rozšíření hodnoty z&nbsp;8 bitů na 64 bitů</td></tr>
<tr><td>0xc5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xca</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcc</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcd</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xce</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcf</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd0</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd3</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd4</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xda</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdc</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdd</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xde</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdf</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe0</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe3</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe4</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xea</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xeb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xec</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xed</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xee</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xef</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf0</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf3</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf4</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfa</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfc</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd 6e</td><td>i8x16.add</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 8e 01</td><td>i16x8.add</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd ae 01</td><td>i32x4.add</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd e4 01</td><td>f32x4.add</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd f0 01</td><td>f64x2.add</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>0xfe</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xff</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Články o SIMD, které doposud na Rootu vyšly</h2>

<p>Podporou SIMD instrukcí na úrovni takzvaných <i>intrinsic</i> v&nbsp;jazyku
C jsme se už na Rootu zabývali, stejně jako samotnými SIMD instrukcemi na
úrovni assembleru (i když jen pro platformu x86 či x86-64 a nikoli pro
WebAssembly). Pro úplnost jsou v&nbsp;této příloze uvedeny odkazy na příslušné
články:</p>

<ol>

<li>Užitečné rozšíření GCC: podpora SIMD (vektorových) instrukcí<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/</a>
</li>

<li>Užitečné rozšíření GCC – podpora SIMD (vektorových) instrukcí: nedostatky technologie<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/</a>
</li>

<li>Podpora SIMD (vektorových) instrukcí na RISCových procesorech<br />
<a href="https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/">https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic pro nízkoúrovňové optimalizace<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic: technologie SSE<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/</a>
</li>

<li>Rozšíření instrukční sady „Advanced Vector Extensions“ na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady F16C, FMA a AVX-512 na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady AVX-512 na platformě x86–64 (dokončení)<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/</a>
</li>

<li>SIMD instrukce na platformě 80×86: instrukční sada MMX<br />
<a href="https://www.root.cz/clanky/simd-instrukce-na-platforme-80x86-instrukcni-sada-mmx/">https://www.root.cz/clanky/simd-instrukce-na-platforme-80x86-instrukcni-sada-mmx/</a>
</li>

<li>SIMD instrukce na 80×86: dokončení popisu MMX, instrukce 3DNow! <br />
<a href="https://www.root.cz/clanky/simd-instrukce-na-80-86-dokonceni-popisu-mmx-instrukce-3dnow/">https://www.root.cz/clanky/simd-instrukce-na-80-86-dokonceni-popisu-mmx-instrukce-3dnow/</a>
</li>

<li>SIMD instrukce v rozšíření SSE<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse/">https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse/</a>
</li>

<li>SIMD instrukce v rozšíření SSE (2. část)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse-2-cast/">https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse-2-cast/</a>
</li>

<li>Pokročilejší SSE operace: přeskupení, promíchání a rozbalování prvků vektorů<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-sse-operace-preskupeni-promichani-a-rozbalovani-prvku-vektoru/">https://www.root.cz/clanky/pokrocilejsi-sse-operace-preskupeni-promichani-a-rozbalovani-prvku-vektoru/</a>
</li>

<li>Od instrukční sady SSE k sadě SSE2<br />
<a href="https://www.root.cz/clanky/od-instrukcni-sady-sse-k-sade-sse2/">https://www.root.cz/clanky/od-instrukcni-sady-sse-k-sade-sse2/</a>
</li>

<li>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC<br />
<a href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/">https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/</a>
</li>

<li>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (2)<br />
<a href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc-2/">https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Compiling C to WebAssembly without Emscripten<br />
<a href="https://surma.dev/things/c-to-webassembly/">https://surma.dev/things/c-to-webassembly/</a>
</li>

<li>Web Assemply: Text Format<br />
<a href="https://webassembly.github.io/spec/core/text/index.html">https://webassembly.github.io/spec/core/text/index.html</a>
</li>

<li>WebAssembly: Binary Format<br />
<a href="https://webassembly.github.io/spec/core/binary/index.html">https://webassembly.github.io/spec/core/binary/index.html</a>
</li>

<li>WebAssembly<br />
<a href="https://webassembly.org/">https://webassembly.org/</a>
</li>

<li>WebAssembly na Wiki Golangu<br />
<a href="https://github.com/golang/go/wiki/WebAssembly">https://github.com/golang/go/wiki/WebAssembly</a>
</li>

<li>The future of WebAssembly - A look at upcoming features and proposals<br />
<a href="https://blog.scottlogic.com/2018/07/20/wasm-future.html">https://blog.scottlogic.com/2018/07/20/wasm-future.html</a>
</li>

<li>WebAssembly Design<br />
<a href="https://github.com/WebAssembly/design">https://github.com/WebAssembly/design</a>
</li>

<li>Využití WebAssembly z programovacího jazyka Go <br />
<a href="https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/</a>
</li>

<li>WebAssembly slibuje podstatné zrychlení webů, konec JavaScriptu se ale nekoná<br />
<a href="https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/">https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>Top 23 WASM Open-Source Projects<br />
<a href="https://www.libhunt.com/topic/wasm">https://www.libhunt.com/topic/wasm</a>
</li>

<li>Made with WebAssembly<br />
<a href="https://madewithwebassembly.com/">https://madewithwebassembly.com/</a>
</li>

<li>The Top 1,790 Wasm Open Source Projects on Github<br />
<a href="https://awesomeopensource.com/projects/wasm">https://awesomeopensource.com/projects/wasm</a>
</li>

<li>Sanspiel<br />
<a href="https://sandspiel.club/">https://sandspiel.club/</a>
</li>

<li>Painting on HTML5 Canvas with Rust WASM<br />
<a href="https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html">https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html</a>
</li>

<li>Writing WebAssembly By Hand<br />
<a href="https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html">https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html</a>
</li>

<li>WebAssembly Specification<br />
<a href="https://webassembly.github.io/spec/core/index.html">https://webassembly.github.io/spec/core/index.html</a>
</li>

<li>Index of Instructions<br />
<a href="https://webassembly.github.io/spec/core/appendix/index-instructions.html">https://webassembly.github.io/spec/core/appendix/index-instructions.html</a>
</li>

<li>The WebAssembly Binary Toolkit<br />
<a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a>
</li>

<li>Will WebAssembly replace JavaScript? Or Will WASM Make JavaScript More Valuable in Future?<br />
<a href="https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e">https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e</a>
</li>

<li>Webassembly as 32bit and 64bit<br />
<a href="https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit">https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit</a>
</li>

<li>Portability<br />
<a href="https://webassembly.org/docs/portability/">https://webassembly.org/docs/portability/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Nástroj objdump: švýcarský nožík pro vývojáře<br />
<a href="https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/">https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/</a>
</li>

<li>Getting Started: Building and Running Clang<br />
<a href="https://clang.llvm.org/get_started.html">https://clang.llvm.org/get_started.html</a>
</li>

<li>Clang: a C language family frontend for LLVM<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Scheduling LLVM Passes with the New Pass Manager<br />
<a href="https://stephenverderame.github.io/blog/scheduling_llvm/">https://stephenverderame.github.io/blog/scheduling_llvm/</a>
</li>

<li>C data types<br />
<a href="https://en.wikipedia.org/wiki/C_data_types">https://en.wikipedia.org/wiki/C_data_types</a>
</li>

<li>WebAssembly data types<br />
<a href="https://webassembly.github.io/spec/core/syntax/types.html">https://webassembly.github.io/spec/core/syntax/types.html</a>
</li>

<li>WebAssembly Opcodes<br />
<a href="https://pengowray.github.io/wasm-ops/">https://pengowray.github.io/wasm-ops/</a>
</li>

<li>Advanced tools (for WebAssembly)<br />
<a href="https://webassembly.org/getting-started/advanced-tools/">https://webassembly.org/getting-started/advanced-tools/</a>
</li>

<li>Binaryen<br />
<a href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a>
</li>

<li>Using SIMD with WebAssembly<br />
<a href="https://emscripten.org/docs/porting/simd.html">https://emscripten.org/docs/porting/simd.html</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Arm Helium<br />
<a href="https://www.arm.com/technologies/helium">https://www.arm.com/technologies/helium</a>
</li>

<li>SIMD proposal for WebAssembly<br />
<a href="https://github.com/webassembly/simd/">https://github.com/webassembly/simd/</a>
</li>

<li>Single instruction, multiple data<br />
<a href="https://en.wikipedia.org/wiki/Single_instruction%2C_multiple_data">https://en.wikipedia.org/wiki/Single_instruction%2C_multiple_data</a>
</li>

<li>Parallel computing<br />
<a href="https://en.wikipedia.org/wiki/Parallel_computing">https://en.wikipedia.org/wiki/Parallel_computing</a>
</li>

<li>Flynn's taxonomy<br />
<a href="https://en.wikipedia.org/wiki/Flynn%27s_taxonomy">https://en.wikipedia.org/wiki/Flynn%27s_taxonomy</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

