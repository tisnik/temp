<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Alternativa či nahrazení JavaScriptu?</a></p>
<p><a href="#k03">*** 3. Způsob využití různých programovacích jazyků na webových stránkách</a></p>
<p><a href="#k04">*** 4. Svět transpřekladačů do JavaScriptu</a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Alternativa či nahrazení JavaScriptu?</h2>

<p><i>JavaScript is an assembly language. The JavaScript + HTML generate is
like a .NET assembly. The browser can execute it, but no human should really
care what's there.<br />
Erik Meijer</i></p>

VBScript, applety v jazyce Java, Flash, Silverlight, Adobe Air, Dart



<p><a name="k03"></a></p>
<h2 id="k03">3. Způsob využití různých programovacích jazyků na webových stránkách</h2>

<p>Pravděpodobně nejjednodušší a nejpřímější cestou podpory nového programovacího jazyka ve webových prohlížečích je integrace jeho interpretru přímo do prohlížeče popř.&nbsp;použití pluginu s&nbsp;tímto interpretrem. Ovšem i přes snahy některých vývojářů a softwarových společností o začlenění dalších skriptovacích jazyků do webových prohlížečů (z&nbsp;historického pohledu se jednalo minimálně o Tcl, VBScript, Dart v&nbsp;Dartiu apod.) je patrné, že v&nbsp;současnosti je jediným široce akceptovaným <i>skriptovacím jazykem</i> na straně webového prohlížeče pouze JavaScript se všemi přednostmi a zápory, které tato monokultura přináší. To však v&nbsp;žádném případě neznamená, že by se ty části aplikace, které mají být spouštěny na straně klienta, musely psát pouze v&nbsp;JavaScriptu, jenž nemusí zdaleka všem vývojářům vyhovovat, ať již z&nbsp;objektivních či ze subjektivních příčin (například kvůli dosti <a href="https://www.youtube.com/watch?v=et8xNAc2ic8">zvláštně navrženému typovému systému</a>, který ovšem umožnil realizovat například <a href="http://www.jsfuck.com/">JSF*ck</a>).</p>

<p>V&nbsp;relativně nedávné minulosti proto vzniklo a pořád ještě vzniká mnoho projektů, jejichž cílem je umožnit tvorbu webových aplikací pro prohlížeč v&nbsp;jiných programovacích jazycích. Zdrojové kódy je pak nutné nějakým způsobem zpracovat (transpřeložit, přeložit, ...) takovým způsobem, aby je bylo možné ve webovém prohlížeči spustit. Možností je hned několik &ndash; lze použít plugin (velmi problematické a dnes značně nepopulární řešení), <i>transpřekladač</i> do JavaScriptu či virtuální stroj popř.&nbsp;interpret daného jazyka implementovaný opět v&nbsp;JavaScriptu. Právě posledními dvěma zmíněnými možnostmi se budeme zabývat v&nbsp;navazujících kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Svět transpřekladačů do JavaScriptu</h2>

<p>Jednu z&nbsp;dnes velmi populárních technik umožňujících použití prakticky libovolného programovacího jazyka pro tvorbu aplikací běžících na straně webového prohlížeče, představuje použití takzvaných <i>transcompilerů (source-to-source compiler)</i> zajišťujících překlad programu napsaného ve zdrojovém programovacím jazyce do funkčně identického programu napsaného v&nbsp;JavaScriptu (někdy se setkáme i s&nbsp;označením <a href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them">transpiler</a>). Transpřekladač se většinou spouští jen jednou na vývojářském počítači, samotní klienti již mají k&nbsp;dispozici JavaScriptový kód.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti není technologie transpřekladačů žádným způsobem svázána právě s&nbsp;JavaScriptem, protože se používala (a používá) i pro další manipulace se zdrojovými kódy.</div></p>

<p>Existuje však i druhá možnost, kdy je samotný transpřekladač naprogramován v&nbsp;JavaScriptu a spouštěn přímo ve webovém prohlížeči klientů. Oba přístupy mají své přednosti, ale pochopitelně i nějaké zápory (například tvůrci uzavřených aplikací pravděpodobně budou upřednostňovat první možnost, protože výstupy transcompilerů jsou většinou dosti nečitelné; dokonce by mohla snaha o prozkoumání kódu spadat pod reverse engineering). Druhá možnost je relativně elegantní v&nbsp;tom ohledu, že se z&nbsp;pohledu programátora webové aplikace skutečně jedná o nový programovací jazyk, který je jakoby přímo zpracováván prohlížečem na stejné úrovni jako JavaScript. Příkladem může být kombinace JavaScriptu a jazyka <a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">WISP</a>:</p>

<pre>
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Jazyk WISP na webové stránce&lt;/title&gt;
        &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;
&nbsp;
        &lt;script src="wisp.min.js" type="application/javascript"&gt;
        &lt;/script&gt;
&nbsp;
        &lt;script type="application/wisp"&gt;
        (print "část naprogramovaná ve WISPu")
        &lt;/script&gt;
&nbsp;
        &lt;script type="application/javascript"&gt;
        console.log("část naprogramovaná v JavaScriptu")
        &lt;/script&gt;
&nbsp;
    &lt;/head&gt;
&nbsp;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Z&nbsp;praxe můžeme uvést například následující projekty založené na transpřekladači. Některé z&nbsp;nich je možné použít přímo v&nbsp;prohlížeči, jiné provádí překlad do JavaScriptu na příkazovém řádku, existují i kombinace obou způsobů (opět viz WISP podporující oba režimy):</p>:

<table>
<tr><th>#</th><th>Jazyk</th><th>Poznámka</th></tr>
<tr><td>1</td><td>CoffeeScript</td><td>přidání syntaktického cukru do JavaScriptu</td></tr>
<tr><td>2</td><td>JSweet</td><td>překlad programů z&nbsp;Javy do JavaScriptu popř.&nbsp;do TypeScriptu</td></tr>
<tr><td>3</td><td>Transcrypt</td><td>překlad Pythonu do JavaScriptu (tomuto nástroji se budeme věnovat v&nbsp;dalším článku)</td></tr>
<tr><td>4</td><td>ClojureScript</td><td>překlad aplikací psaných v&nbsp;Clojure do JavaScriptu</td></tr>
<tr><td>5</td><td>Kaffeine</td><td>rozšíření JavaScriptu o nové vlastnosti</td></tr>
<tr><td>6</td><td>RedScript</td><td>jazyk inspirovaný Ruby</td></tr>
<tr><td>7</td><td>GorillaScript</td><td>další rozšíření JavaScriptu</td></tr>
<tr><td>8</td><td>ghcjs</td><td>transpřekladač pro fanoušky programovacího jazyka Haskell</td></tr>
<tr><td>9</td><td>wisp</td><td>zjednodušená a dnes již nevyvíjená varianta ClojureScriptu</td></tr>
<tr><td>10</td><td>Babel</td><td>překlad novějších variant JavaScript (ES2015) a TypeScriptu do zvolené (starší) verze JavaScriptu, stále populární, i přesto, že nové prohlížeče ES2015 podporují</td></tr>
<tr><td>11</td><td>GopherJS</td><td>překladač programů naprogramovaných v&nbsp;jazyce Go do JavaScriptu</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: seznam všech (či alespoň většiny) známých transpřekladačů do JavaScriptu naleznete například na stránce <a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>, i když je nutné varovat, že některé projekty (kromě výše zmíněných) jsou v&nbsp;dosti špatném stavu nebo již nejsou dále vyvíjeny.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nástroj Emscripten</h2>

<p>Další alternativní technologii, která mi osobně přijde velmi zajímavá a v&nbsp;budoucnu možná i přelomová, představují transpřekladače provádějící překlad z&nbsp;bajtkódu či mezikódu do JavaScriptu (vstupem zde tedy není zdrojový kód v&nbsp;nějakém lidsky čitelném programovacím jazyku, ale většinou binárně reprezentovaný výsledek předchozího překladu). Příkladem tohoto typu transpřekladače je především nástroj <i>Emscripten</i> [<a href="https://emscripten.org/">1</a>] umožňující překlad kódu z&nbsp;libovolného jazyka podporovaného LLVM (Rust, C, C++, Objective C, D, Ada, Fortran atd.) do JavaScriptu. Podívejme se nyní ve stručnosti na kroky, které je zapotřebí provést proto, aby se původní zdrojový kód napsaný například v&nbsp;Céčku, mohl nějakým způsobem spustit ve webovém prohlížeči:</p>

<ol>
<li>Na vstupu celého procesu je program napsaný v&nbsp;céčku</li>
<li>Nejprve je proveden překlad pomocí <strong>clang</strong> do mezikódu LLVM
(<i>LLVM Intermediate Representation</i>)</li>
<li>Následně je zavolán <strong>Fastcomp</strong> (jádro překladače
Emscriptenu) pro překlad mezikódu z&nbsp;předchozího kroku do JavaScriptu</li>
<li>Výsledný JavaScriptový zdrojový kód je možné využít různými způsoby
(node.js na serveru, na WWW stránce atd.)</li>
</ol>

<p><div class="rs-tip-major">Poznámka: poslední překlad (do JavaScriptu) generuje kód kompatibilní s&nbsp;<i>asm.js</i>, tj.&nbsp;používá se zde cíleně omezená podmnožina konstrukcí JavaScriptu. Více informací o <i>asm.js</i> naleznete například na stránkách <a href="https://developer.mozilla.org/en-US/docs/Games/Tools/asm.js">https://developer.mozilla.org/en-US/docs/Games/Tools/asm.js</a> a <a href="http://asmjs.org/">http://asmjs.org/</a> (původní verze specifikace). Alternativně může být výsledkem i bajtkód pro WebAssembly, o čemž se zmíníme v&nbsp;dalších kapitolách.</div></p>

<p>Právě projekt <i>Emscripten</i> zmíněný <a href="#k05">v&nbsp;předchozí kapitole</a> do značné míry usnadnil další způsob zajištění běhu programů napsaných v&nbsp;různých programovacích jazycích ve webovém prohlížeči. Pokud je totiž možné přeložit jakýkoli program napsaný v&nbsp;jazycích C či C++ do JavaScriptu (samozřejmě za předpokladu, že se vhodným způsobem budou emulovat použité knihovní funkce), proč by nebylo možné do JavaScriptu rovnou přeložit celý virtuální stroj používaný daným programovacím jazykem? Samozřejmě to možné je, a to zejména v&nbsp;těch případech, kdy je překládaný virtuální stroj (alespoň z&nbsp;dnešního pohledu) malý, což je příklad VM pro jazyk Lua, tak i například poněkud většího virtuálního stroje Pythonu (.NET resp.&nbsp;CLR či Java VM už je pochopitelně mnohem těžší oříšek).</p>

<p>Překladem VM do JavaScriptu získáme poměrně mnoho výhod, zejména pak možnost mít přímo v&nbsp;HTML stránkách původní zdrojové kódy (Lua, Python atd.) a nikoli nečitelný výstup z&nbsp;transpřekladačů. Za tento postup však také zaplatíme, zejména pomalejším během aplikací v&nbsp;porovnání s&nbsp;nativní VM. V&nbsp;praxi se může jednat o výkonnostní propad zhruba na polovinu, což ovšem v&nbsp;mnoha aplikacích vůbec není tak špatný výsledek.</p>

<p>Příkladem takového typu virtuálního stroje je <a href="https://github.com/Doridian/LuaJS">LuaJS</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. WebAssembly</h2>

<p>Konečně se dostáváme k&nbsp;technologii <i>WebAssembly</i>. Již <a href="#01">v&nbsp;úvodní kapitole</a> jsme si řekli, že se v&nbsp;první řadě jedná o specifikaci virtuálního stroje, především jeho <a href="https://webassembly.github.io/spec/core/index.html">struktury</a> (je založen na zásobníku operandů, podobně jako například <a href="https://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">virtuální stroj Javy</a>) a taktéž ze specifikace jeho <a href="https://webassembly.github.io/spec/core/appendix/index-instructions.html#index-instr">instrukčního souboru</a>. Důležité přitom je, že současně používaná varianta WebAssembly je skutečně dosti nízkoúrovňová, takže neobsahuje například ani podporu pro automatickou správu paměti a i specifikace runtime je dosti minimalistická. To je ovšem v&nbsp;mnoha ohledech výhoda, protože u jazyků typu C, C++ či Rust není automatická správa paměti relevantní a jejich runtime je malý a naopak u jazyků typu Go je správce paměti přímo součástí <i>runtime</i> (zjednodušeně řečeno knihoven, které jsou slinkovány a tvoří výsledný bajtkód předávaný WebAssembly). Správa paměti řízená přímo WebAssembly je prozatím ve fázi vývoje a dnes ji nebudeme potřebovat.</p>

<p>Již v&nbsp;předchozím odstavci jsme se zmínili o problematice <i>runtime</i>. Virtuální stroj WebAssembly akceptuje soubory s&nbsp;MIME typem <i>application/wasm</i>, které by měly obsahovat jak vlastní kód aplikace přeložený do bajtkódu, tak i veškerý podpůrný kód. V&nbsp;případě jazyka Go to konkrétně znamená, že soubory s&nbsp;přeloženou aplikací jsou poměrně velké. I ta nejjednodušší aplikace přeložená do WebAssembly má velikost cca 1300 kB, protože je ve výsledku obsažený celý potřebný runtime i automatický správce paměti. Pokud je použit Rust, je výsledná velikost souborů menší, protože tento jazyk má (obecně) menší runtime.</p>

<p>Velikost výsledného souboru se zvětšujícím se zdrojovým kódem aplikace dále již roste jen pomalu, ovšem i přesto je nutné počítat s&nbsp;tím, že první načtení a inicializace bajtkódu může být pomalá (mobilní připojení atd.) a může se tedy jednat o jeden z&nbsp;důvodů, proč WebAssembly a Go v&nbsp;praxi spíše nepoužívat. Na druhou stranu si představme například aplikaci typu &bdquo;webové IDE&ldquo; nebo Google Docs &ndash; zde se doba nutná pro přenos cca jednoho či dvou megabajtů runtime pravděpodobně ztratí mezi stovkami kilobajtů dalších souborů (navíc se vlastně mnohdy mohou odstranit všechny JavaScriptové knihovny); u podobných aplikací se navíc očekává, že budou spuštěny delší dobu, na rozdíl od běžných webových prezentací.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>


$ sudo dnf install wabt
[sudo] password for ptisnovs:
Last metadata expiration check: 2:13:33 ago on Fri 07 Nov 2025 01:28:29 PM CET.
Dependencies resolved.
========================================================================================================================================
 Package                      Architecture                   Version                               Repository                      Size
========================================================================================================================================
Installing:
 wabt                         x86_64                         1.0.33-3.fc40                         fedora                         2.2 M

Transaction Summary
========================================================================================================================================
Install  1 Package

Total download size: 2.2 M
Installed size: 18 M
Is this ok [y/N]: y
Downloading Packages:
wabt-1.0.33-3.fc40.x86_64.rpm                                                                           2.1 MB/s | 2.2 MB     00:01
----------------------------------------------------------------------------------------------------------------------------------------
Total                                                                                                   1.3 MB/s | 2.2 MB     00:01

Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                                                                                1/1
  Installing       : wabt-1.0.33-3.fc40.x86_64                                                                                      1/1
  Running scriptlet: wabt-1.0.33-3.fc40.x86_64                                                                                      1/1

Installed:
  wabt-1.0.33-3.fc40.x86_64

Complete!

$ wasm2wat --help
usage: wasm2wat [options] filename

  Read a file in the WebAssembly binary format, and convert it to
  the WebAssembly text format.

examples:
  # parse binary file test.wasm and write text file test.wast
  $ wasm2wat test.wasm -o test.wat

  # parse test.wasm, write test.wat, but ignore the debug names, if any
  $ wasm2wat test.wasm --no-debug-names -o test.wat



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

int add(int a, int b) {
    return a + b;
}

clang --target=wasm32 -emit-llvm -c -S add.c

<pre>
; ModuleID = 'add.c'
source_filename = "add.c"
target datalayout = "e-m:e-p:32:32-p10:8:8-p20:8:8-i64:64-n32:64-S128-ni:1:10:20"
target triple = "wasm32"

; Function Attrs: noinline nounwind optnone
define hidden i32 @add(i32 noundef %0, i32 noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  store i32 %0, ptr %3, align 4
  store i32 %1, ptr %4, align 4
  %5 = load i32, ptr %3, align 4
  %6 = load i32, ptr %4, align 4
  %7 = add nsw i32 %5, %6
  ret i32 %7
}

attributes #0 = { noinline nounwind optnone "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+mutable-globals,+sign-ext" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 18.1.8 (Fedora 18.1.8-2.fc40)"}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

llc -march=wasm32 -filetype=obj add.ll -o add.wasm



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

$ wasm-objdump add.wasm -d

add.wasm:       file format wasm 0x1

Code Disassembly:

00005a func[0] <add>:
 00005b: 01 7f                      | local[2] type=i32
 00005d: 23 80 80 80 80 00          | global.get 0 <env.__stack_pointer>
 000063: 41 10                      | i32.const 16
 000065: 6b                         | i32.sub
 000066: 22 02                      | local.tee 2
 000068: 20 00                      | local.get 0
 00006a: 36 02 0c                   | i32.store 2 12
 00006d: 20 02                      | local.get 2
 00006f: 20 01                      | local.get 1
 000071: 36 02 08                   | i32.store 2 8
 000074: 20 02                      | local.get 2
 000076: 28 02 0c                   | i32.load 2 12
 000079: 20 02                      | local.get 2
 00007b: 28 02 08                   | i32.load 2 8
 00007e: 6a                         | i32.add
 00007f: 0b                         | end

$ wasm-objdump add.wasm -x

add.wasm:       file format wasm 0x1

Section Details:

Type[1]:
 - type[0] (i32, i32) -> i32
Import[2]:
 - memory[0] pages: initial=0 <- env.__linear_memory
 - global[0] i32 mutable=1 <- env.__stack_pointer
Function[1]:
 - func[0] sig=0 <add>
Code[1]:
 - func[0] size=38 <add>
Custom:
 - name: "linking"
  - symbol table [count=2]
   - 0: F <add> func=0 [ binding=global vis=hidden ]
   - 1: G <env.__stack_pointer> global=0 [ undefined binding=global vis=default ]
Custom:
 - name: "reloc.CODE"
  - relocations for section: 3 (Code) [1]
   - R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x00005e) symbol=1 <env.__stack_pointer>
Custom:
 - name: "producers"
Custom:
 - name: "target_features"
  - [+] mutable-globals
  - [+] sign-ext



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

$ wasm-decompile add.wasm

<pre>
import memory env_linear_memory;

import global env_stack_pointer:int;

function add(a:int, b:int):int {
  var c:int_ptr = env_stack_pointer - 16;
  c[3] = a;
  c[2] = b;
  return c[3] + c[2];
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

wasm2wat add.wasm -o add.wat

<pre>
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (import "env" "__linear_memory" (memory (;0;) 0))
  (import "env" "__stack_pointer" (global (;0;) (mut i32)))
  (func $add (type 0) (param i32 i32) (result i32)
    (local i32)
    global.get 0
    i32.const 16
    i32.sub
    local.tee 2
    local.get 0
    i32.store offset=12
    local.get 2
    local.get 1
    i32.store offset=8
    local.get 2
    i32.load offset=12
    local.get 2
    i32.load offset=8
    i32.add))
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

$ clang --target=wasm32 -emit-llvm -c -S gcd.c
$ llc -march=wasm32 -filetype=obj gcd.ll -o gcd.wasm


<pre>
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (import "env" "__linear_memory" (memory (;0;) 0))
  (import "env" "__stack_pointer" (global (;0;) (mut i32)))
  (func $gcd (type 0) (param i32 i32) (result i32)
    (local i32)
    global.get 0
    i32.const 16
    i32.sub
    local.tee 2
    local.get 0
    i32.store offset=12
    local.get 2
    local.get 1
    i32.store offset=8
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=8
        i32.eqz
        br_if 1 (;@1;)
        local.get 2
        local.get 2
        i32.load offset=12
        i32.store offset=4
        local.get 2
        local.get 2
        i32.load offset=8
        i32.store offset=12
        local.get 2
        local.get 2
        i32.load offset=4
        local.get 2
        i32.load offset=8
        i32.rem_s
        i32.store offset=8
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=12))
</pre>

<pre>
gcd.wasm:	file format wasm 0x1

Code Disassembly:

00005a func[0] <gcd>:
 00005b: 01 7f                      | local[2] type=i32
 00005d: 23 80 80 80 80 00          | global.get 0 <env.__stack_pointer>
 000063: 41 10                      | i32.const 16
 000065: 6b                         | i32.sub
 000066: 22 02                      | local.tee 2
 000068: 20 00                      | local.get 0
 00006a: 36 02 0c                   | i32.store 2 12
 00006d: 20 02                      | local.get 2
 00006f: 20 01                      | local.get 1
 000071: 36 02 08                   | i32.store 2 8
 000074: 02 40                      | block
 000076: 03 40                      |   loop
 000078: 20 02                      |     local.get 2
 00007a: 28 02 08                   |     i32.load 2 8
 00007d: 45                         |     i32.eqz
 00007e: 0d 01                      |     br_if 1
 000080: 20 02                      |     local.get 2
 000082: 20 02                      |     local.get 2
 000084: 28 02 0c                   |     i32.load 2 12
 000087: 36 02 04                   |     i32.store 2 4
 00008a: 20 02                      |     local.get 2
 00008c: 20 02                      |     local.get 2
 00008e: 28 02 08                   |     i32.load 2 8
 000091: 36 02 0c                   |     i32.store 2 12
 000094: 20 02                      |     local.get 2
 000096: 20 02                      |     local.get 2
 000098: 28 02 04                   |     i32.load 2 4
 00009b: 20 02                      |     local.get 2
 00009d: 28 02 08                   |     i32.load 2 8
 0000a0: 6f                         |     i32.rem_s
 0000a1: 36 02 08                   |     i32.store 2 8
 0000a4: 0c 00                      |     br 0
 0000a6: 0b                         |   end
 0000a7: 0b                         | end
 0000a8: 20 02                      | local.get 2
 0000aa: 28 02 0c                   | i32.load 2 12
 0000ad: 0b                         | end
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Compiling C to WebAssembly without Emscripten<br />
<a href="https://surma.dev/things/c-to-webassembly/">https://surma.dev/things/c-to-webassembly/</a>
</li>

<li>Web Assemply: Text Format<br />
<a href="https://webassembly.github.io/spec/core/text/index.html">https://webassembly.github.io/spec/core/text/index.html</a>
</li>

<li>Web Assembly: Binary Format<br />
<a href="https://webassembly.github.io/spec/core/binary/index.html">https://webassembly.github.io/spec/core/binary/index.html</a>
</li>

<li>WebAssembly<br />
<a href="https://webassembly.org/">https://webassembly.org/</a>
</li>

<li>WebAssembly na Wiki Golangu<br />
<a href="https://github.com/golang/go/wiki/WebAssembly">https://github.com/golang/go/wiki/WebAssembly</a>
</li>

<li>The future of WebAssembly - A look at upcoming features and proposals<br />
<a href="https://blog.scottlogic.com/2018/07/20/wasm-future.html">https://blog.scottlogic.com/2018/07/20/wasm-future.html</a>
</li>

<li>WebAssembly Design<br />
<a href="https://github.com/WebAssembly/design">https://github.com/WebAssembly/design</a>
</li>

<li>Využití WebAssembly z programovacího jazyka Go <br />
<a href="https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/</a>
</li>

<li>WebAssembly slibuje podstatné zrychlení webů, konec JavaScriptu se ale nekoná<br />
<a href="https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/">https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>Top 23 WASM Open-Source Projects<br />
<a href="https://www.libhunt.com/topic/wasm">https://www.libhunt.com/topic/wasm</a>
</li>

<li>Made with WebAssembly<br />
<a href="https://madewithwebassembly.com/">https://madewithwebassembly.com/</a>
</li>

<li>The Top 1,790 Wasm Open Source Projects on Github<br />
<a href="https://awesomeopensource.com/projects/wasm">https://awesomeopensource.com/projects/wasm</a>
</li>

<li>Sanspiel<br />
<a href="https://sandspiel.club/">https://sandspiel.club/</a>
</li>

<li>Painting on HTML5 Canvas with Rust WASM<br />
<a href="https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html">https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html</a>
</li>

<li>Writing WebAssembly By Hand<br />
<a href="https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html">https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html</a>
</li>

<li>WebAssembly Specification<br />
<a href="https://webassembly.github.io/spec/core/index.html">https://webassembly.github.io/spec/core/index.html</a>
</li>

<li>Index of Instructions<br />
<a href="https://webassembly.github.io/spec/core/appendix/index-instructions.html">https://webassembly.github.io/spec/core/appendix/index-instructions.html</a>
</li>

<li>The WebAssembly Binary Toolkit<br />
<a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a>
</li>

<li>Will WebAssembly replace JavaScript? Or Will WASM Make JavaScript More Valuable in Future?<br />
<a href="https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e">https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e</a>
</li>

<li>Webassembly as 32bit and 64bit<br />
<a href="https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit">https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit</a>
</li>

<li>Portability<br />
<a href="https://webassembly.org/docs/portability/">https://webassembly.org/docs/portability/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

