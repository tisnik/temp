<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu formátu WebAssembly</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu formátu WebAssembly</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s technologiemi, na kterých je založen formát WebAssembly. Tento formát umožňuje spouštění aplikací v rámci webových prohlížečů popř. na serverech nebo jako součást složitějších aplikací uvnitř takzvaného sandboxu (což lze považovat za jednu z forem virtualizace).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu formátu WebAssembly</a></p>
<p><a href="#k02">2. Alternativa či nahrazení JavaScriptu?</a></p>
<p><a href="#k03">3. Způsob využití různých programovacích jazyků na webových stránkách</a></p>
<p><a href="#k04">4. Svět transpřekladačů do JavaScriptu</a></p>
<p><a href="#k05">5. Nástroj Emscripten</a></p>
<p><a href="#k06">6. WebAssembly</a></p>
<p><a href="#k07">7. Instrukční sada definovaná pro WebAssembly</a></p>
<p><a href="#k08">8. Instalace nástrojů pro manipulaci s&nbsp;formátem WebAssembly</a></p>
<p><a href="#k09">9. Základní nástroje dostupné v&nbsp;balíčku <strong>wabt</strong></a></p>
<p><a href="#k10">10. Překlad do WebAssembly s&nbsp;využitím základních nástrojů Clangu</a></p>
<p><a href="#k11">11. První demonstrační příklad &ndash; překlad funkce pro součet dvou celých čísel do WebAssembly</a></p>
<p><a href="#k12">12. Analýza obsahu souboru <strong>add.wasm</strong></a></p>
<p><a href="#k13">13. Zpětný překlad z&nbsp;WebAssembly do vysokoúrovňového jazyka</a></p>
<p><a href="#k14">14. Vygenerování optimalizovaného kódu ve WebAssembly</a></p>
<p><a href="#k15">15. Bližší pohled na sekvenci instrukcí v&nbsp;přeložené funkci <strong>add</strong></a></p>
<p><a href="#k16">16. Druhý demonstrační příklad &ndash; překlad funkce pro součet dvou čísel typu <i>float/single</i></a></p>
<p><a href="#k17">17. Třetí demonstrační příklad &ndash; překlad funkce pro výpočet největšího společného dělitele</a></p>
<p><a href="#k18">18. Analýza obsahu souboru <strong>gcd.wasm</strong></a></p>
<p><a href="#k19">19. Bližší pohled na sekvenci instrukcí v&nbsp;přeložené funkci <strong>gcd</strong></a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu formátu WebAssembly</h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;technologiemi, na kterých je
založen formát <a href="https://webassembly.org/">WebAssembly</a>. Tento formát
umožňuje spouštění aplikací v&nbsp;rámci webových prohlížečů
popř.&nbsp;například na serverech nebo jako součást složitějších aplikací
uvnitř takzvaného <i>sandboxu</i> (což můžeme považovat za jednu z&nbsp;forem
virtualizace). Na WebAssembly se můžeme dívat i jako na popis formátu uložení
strojových instrukcí virtuálního stroje (bajtkódu); jedná se tedy o obdobu
souborů <strong>.class</strong> ze světa virtuálního stroje Javy nebo souborů
<strong>.pyc</strong> používaných virtuálním strojem Pythonu.  WebAssembly
popisuje jak samotný formát uložení strojových instrukcí (virtuálního stroje),
tak i vlastní instrukce, které jsou tímto virtuálním strojem podporovány.
Samotné WebAssembly se postupně vyvíjí, takže například ve WebAssembly 2.0 byla
přidána podpora pro další SIMD operace atd.</p>

<p>Ukážeme si i způsob překladu funkcí z&nbsp;jazyka C do WebAssembly (a to bez
použití <i>Emscriptenu</i>) a pro analýzu výsledných souborů použijeme nástroje
dostupné v&nbsp;balíčku <strong>wabt</strong>. Pracovat tedy budeme na poměrně
nízké úrovni, bez dalších přidaných vrstev abstrakce (například Emscripten je
sám o sobě dosti komplikovaný, takže nám do značné míry ztěžuje pochopení
interních vlastností WebAssembly).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Alternativa či nahrazení JavaScriptu?</h2>

<p><i>JavaScript is an assembly language. The JavaScript + HTML generate is
like a .NET assembly. The browser can execute it, but no human should really
care what's there.<br />
Erik Meijer</i></p>

<p>Na WebAssembly se můžeme dívat jako na další (tentokrát úspěšný) pokus o
nabídnutí alternativní technologie k&nbsp;JavaScriptu, což je ve většině
prohlížečů jediný podporovaný programovací jazyk. Podobných pokusů už
v&nbsp;minulosti existovala celá řada, například VBScript, applety
v&nbsp;jazyce Java (resp.&nbsp;přeložené do bajtkódu JVM), Flash, Silverlight,
Adobe Air, Dart atd. atd. Ovšem každá z&nbsp;těchto technologií měla různé
problémy (závislost na jednom prohlížeči, problém s&nbsp;instalací JVM,
bezpečnost atd.), takže se sice používala, ale postupně byla nahrazena &ndash;
buď řešením postaveným na JavaScriptu (asm.js apod.) nebo právě WebAssembly (to
se ovšem z&nbsp;pohledu použité technologie do značné míry podobá právě JVM,
ovšem bez nutnosti instalovat desítky megabajtů potenciálně problematických
balíčků).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Způsob využití různých programovacích jazyků na webových stránkách</h2>

<p>Pravděpodobně nejjednodušší a (alespoň teoreticky) nejpřímější cestou
podpory nového programovacího jazyka ve webových prohlížečích je integrace jeho
interpretru přímo do prohlížeče popř.&nbsp;použití přídavného modulu
(<i>pluginu</i>) s&nbsp;tímto interpretrem. Ovšem i přes snahy některých
vývojářů a softwarových společností o začlenění pluginů určených pro podporu
dalších skriptovacích jazyků do webových prohlížečů (z&nbsp;historického
pohledu se jednalo minimálně o jazyk Tcl, dále VBScript firmy Microsoft, Dart
v&nbsp;Dartiu apod.) je patrné, že v&nbsp;současnosti je jediným široce
akceptovaným <i>skriptovacím jazykem</i> na straně webového prohlížeče pouze
JavaScript se všemi přednostmi a zápory, které tato monokultura do světa IT
přináší.</p>

<p>To však v&nbsp;žádném případě neznamená, že by se ty části aplikace, které
mají být spouštěny na straně klienta (v&nbsp;jeho webovém prohlížeči), musely
psát pouze v&nbsp;JavaScriptu. Tento jazyk totiž nemusí zdaleka všem vývojářům
vyhovovat, ať již z&nbsp;objektivních či ze subjektivních příčin (například
kvůli dosti <a href="https://www.youtube.com/watch?v=et8xNAc2ic8">zvláštně
navrženému typovému systému</a>, který ovšem umožnil realizovat například <a
href="http://www.jsfuck.com/">JSF*ck</a>).</p>

<p>V&nbsp;relativně nedávné minulosti proto vzniklo a stále ještě vzniká mnoho
projektů, jejichž cílem je umožnit tvorbu webových aplikací pro prohlížeč
napsaných v&nbsp;jiných programovacích jazycích, než je JavaScript. Zdrojové
kódy těchto aplikací je posléze nutné nějakým vhodným způsobem zpracovat
(transpřeložit, přeložit, ...) takovým způsobem, aby je bylo možné ve webovém
prohlížeči spustit. Možností, které máme v&nbsp;současnosti k&nbsp;dispozici,
je hned několik &ndash; lze použít výše zmíněný plugin (velmi problematické a
dnes značně nepopulární řešení), <i>transpřekladač</i> do JavaScriptu či
virtuální stroj popř.&nbsp;interpret daného jazyka implementovaný opět
v&nbsp;JavaScriptu. Právě posledními dvěma zmíněnými možnostmi se budeme
zabývat v&nbsp;navazujících kapitolách; posléze se zaměříme na využití
virtuálního stroje běžícího ve webovém prohlížeči &ndash; protože právě zde se
setkáme s&nbsp;<i>WebAssembly</i>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Svět transpřekladačů do JavaScriptu</h2>

<p>Jednu z&nbsp;dnes velmi populárních technik umožňujících použití prakticky
libovolného programovacího jazyka pro tvorbu aplikací běžících na straně
webového prohlížeče, představuje použití takzvaných <i>transcompilerů
(source-to-source compiler)</i> zajišťujících překlad programu napsaného ve
zdrojovém programovacím jazyce do funkčně identického programu napsaného
v&nbsp;JavaScriptu (někdy se setkáme i s&nbsp;označením <a
href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them">transpiler</a>).
Transpřekladač se většinou spouští pouze jedenkrát na vývojářském počítači,
samotní klienti již mají k&nbsp;dispozici &bdquo;univerzální&ldquo;
JavaScriptový kód spustitelný v&nbsp;prakticky jakémkoli moderním webovém
prohlížeči.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti není technologie
transpřekladačů žádným způsobem svázána právě s&nbsp;JavaScriptem, protože se
používala (a používá) i pro další manipulace se zdrojovými kódy. Ovšem právě
v&nbsp;oblasti webového vývoje se používá velmi často, protože zde neexistuje
možnost výběru cílového jazyka.</div></p>

<p>Existuje však i druhá možnost, kdy je samotný transpřekladač naprogramován
v&nbsp;JavaScriptu a spouštěn přímo ve webovém prohlížeči klientů. Oba přístupy
mají své přednosti, ale pochopitelně i nějaké zápory (například tvůrci
uzavřených aplikací pravděpodobně budou upřednostňovat první možnost, protože
výstupy transcompilerů jsou většinou dosti nečitelné; dokonce by mohla snaha o
prozkoumání kódu spadat pod reverse engineering). Druhá možnost je relativně
elegantní v&nbsp;tom ohledu, že se z&nbsp;pohledu programátora webové aplikace
skutečně jedná o nový programovací jazyk, který je jakoby přímo zpracováván
prohlížečem na stejné úrovni jako JavaScript. Příkladem může být kombinace
JavaScriptu a jazyka <a
href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">WISP</a>:</p>

<pre>
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Jazyk WISP na webové stránce&lt;/title&gt;
        &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;
&nbsp;
        &lt;script src="wisp.min.js" type="application/javascript"&gt;
        &lt;/script&gt;
&nbsp;
        &lt;script type="application/wisp"&gt;
        (print "část naprogramovaná ve WISPu")
        &lt;/script&gt;
&nbsp;
        &lt;script type="application/javascript"&gt;
        console.log("část naprogramovaná v JavaScriptu")
        &lt;/script&gt;
&nbsp;
    &lt;/head&gt;
&nbsp;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Z&nbsp;praxe můžeme uvést například následující projekty založené na
transpřekladači. Některé z&nbsp;nich je možné použít přímo prostředí webového
prohlížeče, jiné provádí překlad do JavaScriptu na příkazovém řádku a existují
i kombinace obou způsobů (opět viz jazyk WISP podporující oba režimy):</p>:

<table>
<tr><th>#</th><th>Jazyk</th><th>Poznámka</th></tr>
<tr><td>1</td><td>CoffeeScript</td><td>přidání syntaktického cukru do JavaScriptu</td></tr>
<tr><td>2</td><td>JSweet</td><td>překlad programů z&nbsp;Javy do JavaScriptu popř.&nbsp;do TypeScriptu</td></tr>
<tr><td>3</td><td>Transcrypt</td><td>překlad Pythonu do JavaScriptu (tomuto nástroji se budeme věnovat v&nbsp;dalším článku)</td></tr>
<tr><td>4</td><td>ClojureScript</td><td>překlad aplikací psaných v&nbsp;Clojure do JavaScriptu</td></tr>
<tr><td>5</td><td>Kaffeine</td><td>rozšíření JavaScriptu o nové vlastnosti</td></tr>
<tr><td>6</td><td>RedScript</td><td>jazyk inspirovaný Ruby</td></tr>
<tr><td>7</td><td>GorillaScript</td><td>další rozšíření JavaScriptu</td></tr>
<tr><td>8</td><td>ghcjs</td><td>transpřekladač pro fanoušky programovacího jazyka Haskell</td></tr>
<tr><td>9</td><td>wisp</td><td>zjednodušená a dnes již nevyvíjená varianta ClojureScriptu</td></tr>
<tr><td>10</td><td>Babel</td><td>překlad novějších variant JavaScript (ES2015) a TypeScriptu do zvolené (starší) verze JavaScriptu, stále populární, i přesto, že nové prohlížeče ES2015 podporují</td></tr>
<tr><td>11</td><td>GopherJS</td><td>překladač programů naprogramovaných v&nbsp;jazyce Go do JavaScriptu</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: seznam všech (či alespoň většiny)
známých transpřekladačů do JavaScriptu naleznete například na stránce <a
href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>,
i když je nutné varovat, že některé projekty (kromě výše zmíněných) jsou
v&nbsp;dosti špatném stavu nebo již nejsou dále vyvíjeny.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nástroj Emscripten</h2>

<p>Další alternativní technologii, která mi osobně přijde velmi zajímavá a
v&nbsp;budoucnu možná i přelomová, představují transpřekladače provádějící
překlad z&nbsp;bajtkódu či mezikódu do JavaScriptu (vstupem zde tedy není
zdrojový kód v&nbsp;nějakém lidsky čitelném programovacím jazyku, ale většinou
binárně reprezentovaný výsledek předchozího překladu). Příkladem tohoto typu
transpřekladače je především nástroj <i>Emscripten</i> [<a
href="https://emscripten.org/">1</a>] umožňující překlad kódu
z&nbsp;libovolného jazyka podporovaného LLVM (Rust, C, C++, Objective C, D,
Ada, Fortran atd.) do JavaScriptu. Podívejme se nyní ve stručnosti na kroky,
které je zapotřebí provést proto, aby se původní zdrojový kód napsaný například
v&nbsp;Céčku, mohl nějakým způsobem spustit ve webovém prohlížeči:</p>

<ol>
<li>Na vstupu celého procesu je program napsaný v&nbsp;céčku</li>
<li>Nejprve je proveden překlad pomocí <strong>clang</strong> do mezikódu LLVM
(<i>LLVM Intermediate Representation</i>)</li>
<li>Následně je zavolán <strong>Fastcomp</strong> (jádro překladače
Emscriptenu) pro překlad mezikódu z&nbsp;předchozího kroku do JavaScriptu</li>
<li>Výsledný JavaScriptový zdrojový kód je možné využít různými způsoby
(node.js na serveru, na WWW stránce atd.)</li>
</ol>

<p><div class="rs-tip-major">Poznámka: poslední překlad (do JavaScriptu)
generuje kód kompatibilní s&nbsp;<i>asm.js</i>, tj.&nbsp;používá se zde cíleně
omezená podmnožina konstrukcí JavaScriptu. Více informací o <i>asm.js</i>
naleznete například na stránkách <a
href="https://developer.mozilla.org/en-US/docs/Games/Tools/asm.js">https://developer.mozilla.org/en-US/docs/Games/Tools/asm.js</a>
a <a href="http://asmjs.org/">http://asmjs.org/</a> (původní verze
specifikace). Alternativně může být výsledkem i bajtkód pro WebAssembly, o čemž
se zmíníme v&nbsp;dalších kapitolách, protože se jedná o hlavní téma dnešního
článku.</div></p>

<p>Právě projekt <i>Emscripten</i> do značné míry usnadnil další způsob
zajištění běhu programů napsaných v&nbsp;různých programovacích jazycích ve
webovém prohlížeči. Pokud je totiž možné přeložit jakýkoli program napsaný
v&nbsp;jazycích C či C++ do JavaScriptu (samozřejmě za předpokladu, že se
vhodným způsobem budou emulovat použité knihovní funkce), proč by nebylo možné
do JavaScriptu rovnou přeložit celý virtuální stroj používaný daným
programovacím jazykem? Samozřejmě to možné je, a to zejména v&nbsp;těch
případech, kdy je překládaný virtuální stroj (alespoň z&nbsp;dnešního pohledu)
malý, což je příklad VM pro jazyk Lua, tak i například poněkud většího
virtuálního stroje Pythonu (.NET resp.&nbsp;CLR či Java VM už je pochopitelně
mnohem těžší oříšek).</p>

<p>Překladem VM do JavaScriptu získáme poměrně mnoho výhod, zejména pak možnost
mít přímo v&nbsp;HTML stránkách původní zdrojové kódy (Lua, Python atd.) a
nikoli nečitelný výstup z&nbsp;transpřekladačů. Za tento postup však také
zaplatíme, zejména pomalejším během aplikací v&nbsp;porovnání s&nbsp;nativní
VM. V&nbsp;praxi se může jednat o výkonnostní propad zhruba na polovinu, což
ovšem v&nbsp;mnoha aplikacích vůbec není tak špatný výsledek.</p>

<p>Příkladem takového typu virtuálního stroje je <a
href="https://github.com/Doridian/LuaJS">LuaJS</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. WebAssembly</h2>

<p>Konečně se dostáváme k&nbsp;technologii nazvané <i>WebAssembly</i>. Již <a
href="#01">v&nbsp;úvodní kapitole</a> jsme si řekli, že se v&nbsp;první řadě
jedná o specifikaci virtuálního stroje, především jeho <a
href="https://webassembly.github.io/spec/core/index.html">struktury</a>
(mimochodem: je založen na zásobníku operandů, podobně jako například <a
href="https://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">virtuální
stroj Javy</a>) a taktéž ze specifikace jeho <a
href="https://webassembly.github.io/spec/core/appendix/index-instructions.html#index-instr">instrukčního
souboru</a>.</p>

<p>Důležité přitom je, že současně používaná varianta <i>WebAssembly</i> je
skutečně dosti nízkoúrovňová, takže neobsahuje například ani podporu pro
automatickou správu paměti a i specifikace runtime je dosti minimalistická. To
je ovšem v&nbsp;mnoha ohledech výhoda, protože u programovacích jazyků typu C,
C++ či Rust není automatická správa paměti relevantní a jejich runtime je malý
a naopak u jazyků typu Go je správce paměti přímo součástí <i>runtime</i>
(zjednodušeně řečeno knihoven, které jsou slinkovány a tvoří výsledný bajtkód
předávaný WebAssembly &ndash; ten ovšem dosti &bdquo;nabobtná&ldquo;). Správa
paměti řízená přímo virtuálním strojem WebAssembly je prozatím ve fázi vývoje a
v&nbsp;dnešním článku ji nebudeme potřebovat.</p>

<p><div class="rs-tip-major">Poznámka: příště se zmíníme o Wasm-GC, který se
snaží problém automatického správce paměti centralizovaně řešit, bez návaznosti
na konkrétní runtime nějakého programovacího jazyka.</div></p>

<p>Již v&nbsp;předchozím odstavci jsme se zmínili o problematice
<i>runtime</i>. Virtuální stroj WebAssembly akceptuje soubory s&nbsp;MIME typem
<i>application/wasm</i>, které by měly obsahovat jak vlastní kód aplikace
přeložený do bajtkódu, tak i veškerý podpůrný kód. V&nbsp;případě jazyka Go to
konkrétně znamená, že soubory s&nbsp;přeloženou aplikací jsou poměrně velké. I
ta nejjednodušší aplikace přeložená do WebAssembly má velikost cca 1300 kB,
protože je ve výsledku obsažený celý potřebný runtime i automatický správce
paměti. Pokud je použit Rust, je výsledná velikost souborů menší, protože tento
jazyk má (obecně) menší runtime.</p>

<p><div class="rs-tip-major">Poznámka: naše testovací projekty s&nbsp;jedinou
funkcí budou mít velikost nepřesahující několik stovek bajtů.</p></div></p>

<p>Velikost výsledného souboru se zvětšujícím se zdrojovým kódem aplikace dále
již roste jen pomalu, ovšem i přesto je nutné počítat s&nbsp;tím, že první
načtení a inicializace bajtkódu může být pomalá (mobilní připojení atd.) a může
se tedy jednat o jeden z&nbsp;důvodů, proč například WebAssembly a Go
v&nbsp;praxi spíše nepoužívat. Na druhou stranu si představme například
aplikaci typu &bdquo;webové IDE&ldquo;, CAD nebo Google Docs &ndash; zde se
doba nutná pro přenos cca jednoho či dvou megabajtů runtime pravděpodobně
ztratí mezi stovkami kilobajtů dalších souborů (navíc se vlastně mnohdy mohou
odstranit všechny JavaScriptové knihovny); u podobných aplikací se navíc
očekává, že budou spuštěny delší dobu, na rozdíl od běžných webových
prezentací.</p>

<p>Dnes již existuje relativně velké množství překladačů, které dokážou
generovat kód určený pro WebAssembly:</p>

<table>
<tr><th>Programovací jazyk</th><th>Překlad do WebAssembly</th></tr>
<tr><td>C</td><td>Emscripten nebo Clang</td></tr>
<tr><td>C++</td><td>Emscripten nebo Clang</td></tr>
<tr><td>Rust</td><td>rustc</td></tr>
<tr><td>Go</td><td>go build</td></tr>
<tr><td>C#</td><td>Blazor</td></tr>
<tr><td>F#</td><td>Bolero</td></tr>
<tr><td>Python</td><td>Pyodide atd.</td></tr>
<tr><td>Java</td><td>CheerpJ, JWebAssembly, TeaVM</td></tr>
<tr><td>Kotlin</td><td>přímý překlad</td></tr>
<tr><td>Ruby</td><td>MRuby</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukční sada definovaná pro WebAssembly</h2>

<p>Většina instrukcí WebAssembly pracuje s&nbsp;operandy uloženými na takzvaném
<i>zásobníku operandů (operand stack)</i>. V&nbsp;tomto případě se již jedná o
skutečný zásobník typu <i>LIFO &ndash; Last In, First Out</i>). Virtuální stroj
typicky již při načítání souborů <strong>.wasm</strong> kontroluje typy
operandů uložených na zásobník operandů a zajišťuje, že se nad těmito operandy
budou provádět pouze typově bezpečné operace.  V&nbsp;praxi to například
znamená, že není možné na zásobník uložit dvě hodnoty typu
<strong>float</strong> (resp.<strong>f32</strong>) a následně provést instrukci
<strong>i32.add</strong>, protože tato instrukce vyžaduje, aby na zásobníku
byly uloženy dvě hodnoty typu <strong>int</strong> (i když <strong>f32</strong>
i <strong>i32</strong> mají v&nbsp;tomto případě shodnou bitovou šířku).</p>

<p>Instrukce jsou rozděleny do několika oblastí:</p>

<ol>
<li>Řízení toku programu</li>
<li>Operace typu Load a Store (práce s&nbsp;operační pamětí)</li>
<li>Práce s&nbsp;proměnnými a parametry</li>
<li>Aritmetické instrukce pro celočíselné operandy</li>
<li>Aritmetické instrukce pro operandy s&nbsp;plovoucí řádovou čárkou</li>
<li>Instrukce pro porovnání celočíselných operandů</li>
<li>Instrukce pro porovnání operandů s&nbsp;plovoucí řádovou čárkou</li>
<li>Konverzní operace</li>
</ol>

<p>Aritmetické, logické a relační instrukce typicky pracují s&nbsp;operandy
těchto typů:</p>

<table>
<tr><th>Označení typu</th><th>Stručný popis</th></tr>
<tr><td>i8</td><td>osmibitová celá čísla</td></tr>
<tr><td>i16</td><td>16bitová celá čísla</td></tr>
<tr><td>i32</td><td>32bitová celá čísla</td></tr>
<tr><td>i64</td><td>64bitová celá čísla</td></tr>
<tr><td>f32</td><td>odpovídá typu <i>single</i> podle IEEE 754</td></tr>
<tr><td>f64</td><td>odpovídá typu <i>double</i> podle IEEE 754</td></tr>
</table>

<p>Nověji je taktéž k&nbsp;dispozici datový typ <strong>v128</strong>, což je
128bitový vektor využívaný pro uložení operandů pro SIMD (vektorové)
operace.</p>

<p>Jednotlivé instrukce si ukážeme v&nbsp;demonstračních příkladech, které jsou
součástí praktické části dnešního článku.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instalace nástrojů pro manipulaci s&nbsp;formátem WebAssembly</h2>

<p>V&nbsp;praktické části dnešního článku budeme zkoumat obsah souborů
s&nbsp;koncovkou <strong>.wasm</strong>. Jedná se o binární soubory, takže pro
manipulaci s&nbsp;nimi použijeme specializované nástroje (i když by teoreticky
mohl postačovat i nějaký <a
href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">hexadecimální
prohlížeč nebo editor</a>). Pro formát WebAssembly je dostupný balíček nazvaný
<strong>wabt</strong>, který poskytuje základní nástroje pro manipulaci
s&nbsp;<strong>.wasm</strong>.</p>

<p><strong>wabt</strong> je v&nbsp;některých distribucích Linuxu dostupný ve
formě standardního balíčku, takže jeho instalace je jednoduchá. Příkladem jsou
distribuce založené na RPM:</p>

<pre>
$ <strong>sudo dnf install wabt</strong>
&nbsp;
Last metadata expiration check: 2:13:33 ago on Fri 07 Nov 2025 01:28:29 PM CET.
Dependencies resolved.
========================================================================================================================================
 Package                      Architecture                   Version                               Repository                      Size
========================================================================================================================================
Installing:
 wabt                         x86_64                         1.0.33-3.fc40                         fedora                         2.2 M
&nbsp;
Transaction Summary
========================================================================================================================================
Install  1 Package
&nbsp;
Total download size: 2.2 M
Installed size: 18 M
Is this ok [y/N]: y
Downloading Packages:
wabt-1.0.33-3.fc40.x86_64.rpm                                                                           2.1 MB/s | 2.2 MB     00:01
----------------------------------------------------------------------------------------------------------------------------------------
Total                                                                                                   1.3 MB/s | 2.2 MB     00:01
&nbsp;
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                                                                                1/1
  Installing       : wabt-1.0.33-3.fc40.x86_64                                                                                      1/1
  Running scriptlet: wabt-1.0.33-3.fc40.x86_64                                                                                      1/1
&nbsp;
Installed:
  wabt-1.0.33-3.fc40.x86_64
&nbsp;
Complete!
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Základní nástroje dostupné v&nbsp;balíčku <strong>wabt</strong></h2>

<p>V&nbsp;balíčku <strong>wabt</strong> se nachází celkem dvanáct nástrojů
určených pro manipulaci s&nbsp;binárními soubory, které mají koncovku
<strong>.wasm</strong> popř.&nbsp;s&nbsp;jejich textovými variantami
s&nbsp;koncovkou <strong>.wat</strong>. Získání seznamu nainstalovaných
nástrojů je jednoduché:</p>

<pre>
$ <strong>sudo dnf repoquery -l wabt | grep "/usr/bin"</strong>
&nbsp;
/usr/bin/spectest-interp
/usr/bin/wasm-decompile
/usr/bin/wasm-interp
/usr/bin/wasm-objdump
/usr/bin/wasm-opcodecnt
/usr/bin/wasm-strip
/usr/bin/wasm-validate
/usr/bin/wasm2c
/usr/bin/wasm2wat
/usr/bin/wast2json
/usr/bin/wat-desugar
/usr/bin/wat2wasm
</pre>

<p>Pro potřeby dnešního článku využijeme pouze dva z&nbsp;těchto nástrojů.
Konkrétně se jedná o <strong>wasm2wat</strong>, který dokáže převést binární
soubor ve formátu <strong>.wasm</strong> na jeho textovou (čitelnou)
variantu:</p>

<pre>
$ <strong>wasm2wat --help</strong>
&nbsp;
usage: wasm2wat [options] filename
&nbsp;
  Read a file in the WebAssembly binary format, and convert it to
  the WebAssembly text format.
&nbsp;
examples:
  # parse binary file test.wasm and write text file test.wast
  $ wasm2wat test.wasm -o test.wat

  # parse test.wasm, write test.wat, but ignore the debug names, if any
  $ wasm2wat test.wasm --no-debug-names -o test.wat
</pre>

<p>Druhým nástrojem, který dnes využijeme, je nástroj nazvaný
<strong>wasm-objdump</strong>, který do jisté míry odpovídá standardnímu
&bdquo;céčkovému&ldquo; nástroji <strong>objdump</strong>, s&nbsp;nímž jsme se
seznámili v&nbsp;článku <a
href="https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/">Nástroj
objdump: švýcarský nožík pro vývojáře</a>:</p>

<pre>
$ <strong>wasm-objdump --help</strong>
&nbsp;
usage: wasm-objdump [options] filename+
&nbsp;
  Print information about the contents of wasm binaries.
&nbsp;
examples:
  $ wasm-objdump test.wasm
&nbsp;
options:
      --help                   Print this help message
      --version                Print version information
  -h, --headers                Print headers
  -j, --section=SECTION        Select just one section
  -s, --full-contents          Print raw section contents
  -d, --disassemble            Disassemble function bodies
      --debug                  Print extra debug information
  -x, --details                Show section details
  -r, --reloc                  Show relocations inline with disassembly
      --section-offsets        Print section offsets instead of file offsets in code disassembly
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Překlad do WebAssembly s&nbsp;využitím základních nástrojů Clangu</h2>

<p>Pro překlad rozsáhlejších aplikací naprogramovaných v&nbsp;jazyku C nebo C++
do WebAssembly se většinou využívá překladač <i>Clang</i> kombinovaný
s&nbsp;<i>Emscriptenem</i>, což umožňuje zařazení i všech potřebných knihoven
do výsledné (binární) distribuce aplikace spustitelné ve webovém prohlížeči.
Nás ovšem bude nyní zajímat především WebAssembly, takže se pokusíme
<i>Emscripten</i> z&nbsp;celé &bdquo;pipeline&ldquo; vynechat. Ve skutečnosti
to je v&nbsp;jednoduchých případech možné, protože si vystačíme s&nbsp;dvojicí
nástrojů, tvořících jednoduchou pipeline:</p>

<ol>
<li>Samotného překladače <strong>clang</strong>, který dokáže provést překlad do mezikódu</li>
<li>Druhého překladače <strong>llc</strong>, který mezikód přeloží do WebAssembly</li>
</ol>

<p>Popř.&nbsp;můžeme do pipeline zařadit i explicitní volání nástroje
<strong>opt</strong>, který dokáže provádět transformaci
mezijazyk-&gt;mezijazyk s&nbsp;aplikací optimalizací:</p>

<ol>
<li>Překladač <strong>clang</strong>, který dokáže provést překlad do mezikódu</li>
<li>Nástroj <strong>opt</strong> transformující mezikód do jiného mezikódu s&nbsp;aplikací optimalizací</li>
<li>Druhý překladač <strong>llc</strong>, který mezikód přeloží do WebAssembly</li>
</ol>



<p><a name="k11"></a></p>
<h2 id="k11">11. První demonstrační příklad &ndash; překlad funkce pro součet dvou celých čísel do WebAssembly</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu se pokusíme o překlad
následující (triviální) funkce do WebAssembly:</p>

<pre>
int <strong>add</strong>(int a, int b) {
    return a + b;
}
</pre>

<p>V&nbsp;prvním kroku provedeme překlad do mezikódu (prozatím bez
optimalizací). Musíme uvést přepínač <strong>-S</strong> zapínající výstup do
mezikódu a nastavíme i výslednou architekturu na WebAssembly:</p>

<pre>
$ <strong>clang --target=wasm32 -emit-llvm -c -S add.c</strong>
</pre>

<p>Výsledkem překladu by měl být soubor nazvaný <strong>add.ll</strong>, ve
kterém je uložen zápis funkce <strong>add</strong> v&nbsp;mezikódu LLVM. Jedná
se o obdobu klasického assembleru, ovšem určenou především pro zpracování
automatizovanými nástroji, nikoli pro zápis lidmi. K&nbsp;tomuto strojovému
kódu jsou přidána i další metadata:</p>

<pre>
; ModuleID = 'add.c'
source_filename = "add.c"
target datalayout = "e-m:e-p:32:32-p10:8:8-p20:8:8-i64:64-n32:64-S128-ni:1:10:20"
target triple = "wasm32"
&nbsp;
; Function Attrs: noinline nounwind optnone
define hidden i32 @add(i32 noundef %0, i32 noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  store i32 %0, ptr %3, align 4
  store i32 %1, ptr %4, align 4
  %5 = load i32, ptr %3, align 4
  %6 = load i32, ptr %4, align 4
  %7 = add nsw i32 %5, %6
  ret i32 %7
}
&nbsp;
attributes #0 = { noinline nounwind optnone "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+mutable-globals,+sign-ext" }
&nbsp;
!llvm.module.flags = !{!0}
!llvm.ident = !{!1}
&nbsp;
!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 18.1.8 (Fedora 18.1.8-2.fc40)"}
</pre>

<p>Ve druhém kroku zavoláme druhý (backend) překladač <strong>llc</strong>,
který již vygeneruje WebAssembly:</p>

<pre>
$ <strong>llc -march=wasm32 -filetype=obj add.ll -o add.wasm</strong>
</pre>

<p>Výsledkem je soubor <strong>add.wasm</strong>, který je poměrně velký &ndash; má 299 bajtů:</p>

<pre>
$ <strong>ls -l *</strong>
&nbsp;
-rw-r--r--. 1 ptisnovs ptisnovs  44 Nov  7 15:56 add.c
-rw-r--r--. 1 ptisnovs ptisnovs 801 Nov  9 10:47 add.ll
-rw-r--r--. 1 ptisnovs ptisnovs 299 Nov  9 10:49 add.wasm
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Analýza obsahu souboru <strong>add.wasm</strong></h2>

<p>Pro prohlédnutí obsahu binárního souboru <strong>add.wasm</strong> použijeme
výše zmíněný nástroj <strong>wasm-objdump</strong> s&nbsp;přepínačem
<strong>-d</strong>:</p>

<pre>
$ <strong>wasm-objdump add.wasm -d</strong>
</pre>

<p>Výstupem by měl být &bdquo;disassemblovaný&ldquo; obsah funkce
<strong>add</strong>, tj.&nbsp;sekvence instrukcí WebAssembly:</p>

<pre>
add.wasm:       file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
00005a func[0] &lt;add&gt;:
 00005b: 01 7f                      | local[2] type=i32
 00005d: 23 80 80 80 80 00          | global.get 0 &lt;env.__stack_pointer&gt;
 000063: 41 10                      | i32.const 16
 000065: 6b                         | i32.sub
 000066: 22 02                      | local.tee 2
 000068: 20 00                      | local.get 0
 00006a: 36 02 0c                   | i32.store 2 12
 00006d: 20 02                      | local.get 2
 00006f: 20 01                      | local.get 1
 000071: 36 02 08                   | i32.store 2 8
 000074: 20 02                      | local.get 2
 000076: 28 02 0c                   | i32.load 2 12
 000079: 20 02                      | local.get 2
 00007b: 28 02 08                   | i32.load 2 8
 00007e: 6a                         | i32.add
 00007f: 0b                         | end
</pre>

<p>Po zadání přepínače <strong>-x</strong> si můžeme zobrazit metadata uložená
společně s&nbsp;kódem funkce <strong>add</strong>:</p>

<pre>
$ <strong>wasm-objdump add.wasm -x</strong>
</pre>

<p>Výsledek by měl vypadat následovně (obsahuje i typovou signaturu funkce
<strong>add</strong>):</p>

<pre>
add.wasm:       file format wasm 0x1
&nbsp;
Section Details:
&nbsp;
Type[1]:
 - type[0] (i32, i32) -&gt; i32
Import[2]:
 - memory[0] pages: initial=0 &lt;- env.__linear_memory
 - global[0] i32 mutable=1 &lt;- env.__stack_pointer
Function[1]:
 - func[0] sig=0 &lt;add&gt;
Code[1]:
 - func[0] size=38 &lt;add&gt;
Custom:
 - name: "linking"
  - symbol table [count=2]
   - 0: F &lt;add&gt; func=0 [ binding=global vis=hidden ]
   - 1: G &lt;env.__stack_pointer&gt; global=0 [ undefined binding=global vis=default ]
Custom:
 - name: "reloc.CODE"
  - relocations for section: 3 (Code) [1]
   - R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x00005e) symbol=1 &lt;env.__stack_pointer&gt;
Custom:
 - name: "producers"
Custom:
 - name: "target_features"
  - [+] mutable-globals
  - [+] sign-ext
</pre>

<p>Taktéž si můžeme nechat převést binární soubor <strong>.wasm</strong> na
jeho textovou variantu <strong>.wat</strong> (což je sémantický ekvivalent,
ovšem mnohem delší):</p>

<pre>
$ <strong>wasm2wat add.wasm -o add.wat</strong>
</pre>

<p>Takto by měl vypadat výsledek:</p>

<pre>
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (import "env" "__linear_memory" (memory (;0;) 0))
  (import "env" "__stack_pointer" (global (;0;) (mut i32)))
  (func $add (type 0) (param i32 i32) (result i32)
    (local i32)
    global.get 0
    i32.const 16
    i32.sub
    local.tee 2
    local.get 0
    i32.store offset=12
    local.get 2
    local.get 1
    i32.store offset=8
    local.get 2
    i32.load offset=12
    local.get 2
    i32.load offset=8
    i32.add))
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zpětný překlad z&nbsp;WebAssembly do vysokoúrovňového jazyka</h2>

<p>Potenciálně užitečný je i nástroj nazvaný <strong>wasm-decompile</strong>.
Tento nástroj dokáže z&nbsp;binárního souboru <strong>.wasm</strong>
vygenerovat zápis funkcí nikoli ve formě sekvence instrukcí, ale ve
vysokoúrovňovém jazyku, který se do určité míry podobá céčku. Můžeme si to
snadno otestovat:</p>

<pre>
$ <strong>wasm-decompile add.wasm</strong>
</pre>

<p>Výsledkem bude tento zápis, který by skutečně měl připomínat céčko (i když
se například hlavička funkce podobá jazyku Go nebo spíše Pascalu):</p>

<pre>
import memory env_linear_memory;
&nbsp;
import global env_stack_pointer:int;
&nbsp;
function add(a:int, b:int):int {
  var c:int_ptr = env_stack_pointer - 16;
  c[3] = a;
  c[2] = b;
  return c[3] + c[2];
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vygenerování optimalizovaného kódu ve WebAssembly</h2>

<p>Za povšimnutí stojí, že se ve vysokoúrovňovém kódu, který jsme si ukázali <a
href="#k13">v&nbsp;předchozí kapitole</a>, přistupuje do zdánlivě
neexistujícího pole <strong>c</strong>, jehož začátek byl vypočítán na základě
ukazatele na vrchol zásobníku. Tímto zápisem se vlastně simulují lokální
proměnné.</p>

<p>Ovšem funkce <strong>add</strong> by žádné pomocné lokální proměnné nemusela
potřebovat. Skutečně je tomu tak, ovšem nejprve musíme vygenerovat
optimalizovaný kód ve WebAssembly. Nejjednodušší je provést tyto optimalizace
přímo na úrovni <strong>clangu</strong>, například následovně:</p>

<p>Překlad do WebAssembly:</p>

<pre>
$ <strong>clang -O3 --target=wasm32 -emit-llvm -c -S add.c</strong>
$ <strong>llc -march=wasm32 -filetype=obj add.ll -o add.wasm</strong>
</pre>

<p>Výsledkem bude soubor <strong>add.wasm</strong>, který bude mít délku jen
220 bajtů.</p>

<p>Prohlédnutí bajtkódu/strojového kódu:</p>

<pre>
$ <strong>wasm-objdump -d add.wasm</strong>
&nbsp;
add.wasm:       file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000043 func[0] &lt;add&gt;:
 000044: 20 01                      | local.get 1
 000046: 20 00                      | local.get 0
 000048: 6a                         | i32.add
 000049: 0b                         | end
</pre>

<p>A zpětný překlad do vysokúrovňového jazyka:</p>

<pre>
$ <strong>wasm-decompile add.wasm</strong>
&nbsp;
&nbsp;
import memory env_linear_memory;
&nbsp;
function add(a:int, b:int):int {
  return b + a
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Bližší pohled na sekvenci instrukcí v&nbsp;přeložené funkci <strong>add</strong></h2>

<p>Ve výsledném bajtkódu funkce <strong>add</strong> přeložené do WebAssembly
nalezneme pouze čtyři instrukce:</p>

<pre>
 000044: 20 01                      | local.get 1
 000046: 20 00                      | local.get 0
 000048: 6a                         | i32.add
 000049: 0b                         | end
</pre>

<p>Význam jednotlivých instrukcí je následující:</p>

<ol>

<li>Instrukce <strong>local.get</strong> načte obsah lokální proměnné určené
svým indexem a uloží obsah této proměnné na zásobník operandů. Po provedení
prvních dvou instrukcí tedy bude zásobník operandů obsahovat dvě hodnoty,
přičemž na nejvyšším místě bude obsah <i>první</i> proměnné (jde o zásobník
LIFO).</li>

<li>Instrukce <strong>i32.add</strong> přečte ze zásobníku operandů obě hodnoty
(více jich tam uloženo stejně není), provede jejich součet a výsledek součtu
uloží zpět na zásobník operandů. Tato instrukce existuje ve čtyřech základních
variantách: <strong>i32</strong>, <strong>i64</strong>, <strong>f32</strong> a
<strong>f64</strong>.</li>

<li>Poslední instrukce <strong>end</strong> ukončuje tělo bloku. V&nbsp;tomto
konkrétním případě se jedná o ukončení celé funkce (což je taktéž blok) a
návrat do volajícího kódu. Tento kód si sám zpracuje obsah zásobníku operandů,
kde je uložen výsledek součtu.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: zde se skutečně použije instrukce
<strong>end</strong> a nikoli <strong>return</strong>!</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Druhý demonstrační příklad &ndash; překlad funkce pro součet dvou čísel typu <i>float/single</i></h2>

<p>V&nbsp;dnešním druhém demonstračním příkladu se pokusíme o překlad funkce,
která opět vrátí součet dvou čísel, nyní ovšem typu <i>float/single</i>:</p>

<pre>
float <strong>fadd</strong>(float a, float b) {
    return a + b;
}
</pre>

<p>Překlad do WebAssembly provedeme známým způsobem:</p>

<pre>
$ <strong>clang --target=wasm32 -emit-llvm -c -S fadd.c</strong>
$ <strong>llc -march=wasm32 -filetype=obj fadd.ll -o fadd.wasm</strong>
</pre>

<p>Analýza výsledného bajtkódu:</p>

<pre>
$ <strong>wasm-objdump fadd.wasm -d</strong>
&nbsp;
fadd.wasm:      file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
00005a func[0] &lt;fadd&gt;:
 00005b: 01 7f                      | local[2] type=i32
 00005d: 23 80 80 80 80 00          | global.get 0 &lt;env.__stack_pointer&gt;
 000063: 41 10                      | i32.const 16
 000065: 6b                         | i32.sub
 000066: 22 02                      | local.tee 2
 000068: 20 00                      | local.get 0
 00006a: 38 02 0c                   | f32.store 2 12
 00006d: 20 02                      | local.get 2
 00006f: 20 01                      | local.get 1
 000071: 38 02 08                   | f32.store 2 8
 000074: 20 02                      | local.get 2
 000076: 2a 02 0c                   | f32.load 2 12
 000079: 20 02                      | local.get 2
 00007b: 2a 02 08                   | f32.load 2 8
 00007e: 92                         | f32.add
 00007f: 0b                         | end
</pre>

<p>Již zde je vidět, že sekvence instrukcí je příliš dlouhá na tak jednoduchou
funkci. Proto donutíme <strong>clang</strong> k&nbsp;optimalizacím:</p>

<pre>
$ <strong>clang -O3 --target=wasm32 -emit-llvm -c -S fadd.c</strong>
$ <strong>llc -march=wasm32 -filetype=obj fadd.ll -o fadd.wasm</strong>
$ <strong>wasm-objdump -d fadd.wasm</strong>
</pre>

<p>Celá funkce je přeložena do čtyř instrukcí:</p>

<pre>
fadd.wasm:	file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000043 func[0] &lt;fadd&gt;:
 000044: 20 00                      | local.get 0
 000046: 20 01                      | local.get 1
 000048: 92                         | f32.add
 000049: 0b                         | end
</pre>

<p>Výsledek pokusu o zpětný překlad dopadne velmi dobře:</p>

<pre>
import memory env_linear_memory;
&nbsp;
function fadd(a:float, b:float):float {
  return a + b
}
</pre>

<p><div class="rs-tip-major">Poznámka: oba výsledné bajtkódy se odlišují pouze
třetí instrukcí. Vždy se provede součet dvou hodnot získaných ze zásobníku
operandů, ovšem v&nbsp;prvním příkladu se předpokládá, že hodnoty jsou dvě celá
čísla, kdežto ve druhém případě se jedná o hodnoty typu
<i>float/single</i>:</div></p>

<pre>
 000044: 20 01     | local.get 1             000044: 20 00     | local.get 0
 000046: 20 00     | local.get 0             000046: 20 01     | local.get 1
 000048: 6a        | i32.add                 000048: 92        | f32.add
 000049: 0b        | end                     000049: 0b        | end
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Třetí demonstrační příklad &ndash; překlad funkce pro výpočet největšího společného dělitele</h2>

<p>V&nbsp;dnešním posledním demonstračním příkladu si ukážeme překlad funkce
pro výpočet největšího společného dělitele dvou celých (kladných) čísel. Jedna
z&nbsp;možných implementací tohoto algoritmu vypadá následovně (samozřejmě je
možné použít různé triky, aby se zamezilo použití pomocné proměnné
<strong>t</strong> atd.):</p>

<pre>
int <strong>gcd</strong>(int u, int v) {
    while (v) {
        int t = u;
        u = v;
        v = t % v;
    }
    return u;
}
</pre>

<p>Překlad do WebAssembly provedeme nám již známým způsobem:</p>

<pre>
$ <strong>clang --target=wasm32 -emit-llvm -c -S gcd.c</strong>
$ <strong>llc -march=wasm32 -filetype=obj gcd.ll -o gcd.wasm</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě lze povolit optimalizace
přepínačem -O3 (na rychlost) nebo -Os (na velikost).</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Analýza obsahu souboru <strong>gcd.wasm</strong></h2>

<p>Výsledek překladu funkce <strong>gcd</strong> bez povolení optimalizací vede
k&nbsp;poměrně složitému výslednému kódu (zde je zobrazen obsah textové
varianty WebAssembly i se všemi dalšími metainformacemi):</p>

<pre>
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (import "env" "__linear_memory" (memory (;0;) 0))
  (import "env" "__stack_pointer" (global (;0;) (mut i32)))
  (func $gcd (type 0) (param i32 i32) (result i32)
    (local i32)
    global.get 0
    i32.const 16
    i32.sub
    local.tee 2
    local.get 0
    i32.store offset=12
    local.get 2
    local.get 1
    i32.store offset=8
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=8
        i32.eqz
        br_if 1 (;@1;)
        local.get 2
        local.get 2
        i32.load offset=12
        i32.store offset=4
        local.get 2
        local.get 2
        i32.load offset=8
        i32.store offset=12
        local.get 2
        local.get 2
        i32.load offset=4
        local.get 2
        i32.load offset=8
        i32.rem_s
        i32.store offset=8
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=12))
</pre>

<p>Na tentýž kód se můžeme podívat i nástrojem
<strong>wasm-objdump</strong>:</p>

<pre>
gcd.wasm:       file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
00005a func[0] &lt;gcd&gt;:
 00005b: 01 7f                      | local[2] type=i32
 00005d: 23 80 80 80 80 00          | global.get 0 &lt;env.__stack_pointer&gt;
 000063: 41 10                      | i32.const 16
 000065: 6b                         | i32.sub
 000066: 22 02                      | local.tee 2
 000068: 20 00                      | local.get 0
 00006a: 36 02 0c                   | i32.store 2 12
 00006d: 20 02                      | local.get 2
 00006f: 20 01                      | local.get 1
 000071: 36 02 08                   | i32.store 2 8
 000074: 02 40                      | block
 000076: 03 40                      |   loop
 000078: 20 02                      |     local.get 2
 00007a: 28 02 08                   |     i32.load 2 8
 00007d: 45                         |     i32.eqz
 00007e: 0d 01                      |     br_if 1
 000080: 20 02                      |     local.get 2
 000082: 20 02                      |     local.get 2
 000084: 28 02 0c                   |     i32.load 2 12
 000087: 36 02 04                   |     i32.store 2 4
 00008a: 20 02                      |     local.get 2
 00008c: 20 02                      |     local.get 2
 00008e: 28 02 08                   |     i32.load 2 8
 000091: 36 02 0c                   |     i32.store 2 12
 000094: 20 02                      |     local.get 2
 000096: 20 02                      |     local.get 2
 000098: 28 02 04                   |     i32.load 2 4
 00009b: 20 02                      |     local.get 2
 00009d: 28 02 08                   |     i32.load 2 8
 0000a0: 6f                         |     i32.rem_s
 0000a1: 36 02 08                   |     i32.store 2 8
 0000a4: 0c 00                      |     br 0
 0000a6: 0b                         |   end
 0000a7: 0b                         | end
 0000a8: 20 02                      | local.get 2
 0000aa: 28 02 0c                   | i32.load 2 12
 0000ad: 0b                         | end
</pre>

<p>Zajímavější ovšem bude provedení překladu s&nbsp;povolením optimalizací:</p>

<pre>
$ <strong>clang -O3 --target=wasm32 -emit-llvm -c -S gcd.c</strong>
$ <strong>llc -march=wasm32 -filetype=obj gcd.ll -o gcd.wasm</strong>
</pre>

<p>Zajímavé je, že i po provedení optimalizací je stále možné
&bdquo;zrekonstruovat&ldquo; původní algoritmus nástrojem
<strong>wasm-decompile</strong>, přičemž výsledný pseudokód bude velmi dobře
čitelný:</p>

<pre>
$ <strong>wasm-decompile gcd.wasm</strong>
&nbsp;
import memory env_linear_memory;
&nbsp;
function gcd(a:int, b:int):int {
  var c:int;
  if (b) goto B_a;
  return a;
  label B_a:
  loop L_b {
    b = a % (c = b);
    a = c;
    if (b) continue L_b;
  }
  return c;
}
</pre>

<p><div class="rs-tip-major">Poznámka: to ovšem znamená, že i když je
WebAssembly binárním formátem, není možné se spoléhat na to, že
&bdquo;skryjete&ldquo; nějaký sofistikovaný algoritmus před jeho zkoumáním
dalšími vývojáři.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Bližší pohled na sekvenci instrukcí v&nbsp;přeložené funkci <strong>gcd</strong></h2>

<p>Nyní se pokusme analyzovat instrukce, které vznikly překladem funkce
<strong>gcd</strong> do WebAssembly s&nbsp;povolením optimalizací. Použijeme
nám již dobře známý příkaz <strong>wasm-objdump</strong>:</p>

<pre>
$ <strong>wasm-objdump -d gcd.wasm</strong>
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
gcd.wasm:	file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000043 func[0] &lt;gcd&gt;:
 000044: 01 7f                      | local[2] type=i32
 000046: 02 40                      | block
 000048: 20 01                      |   local.get 1
 00004a: 0d 00                      |   br_if 0
 00004c: 20 00                      |   local.get 0
 00004e: 0f                         |   return
 00004f: 0b                         | end
 000050: 03 40                      | loop
 000052: 20 00                      |   local.get 0
 000054: 20 01                      |   local.get 1
 000056: 22 02                      |   local.tee 2
 000058: 6f                         |   i32.rem_s
 000059: 21 01                      |   local.set 1
 00005b: 20 02                      |   local.get 2
 00005d: 21 00                      |   local.set 0
 00005f: 20 01                      |   local.get 1
 000061: 0d 00                      |   br_if 0
 000063: 0b                         | end
 000064: 20 02                      | local.get 2
 000066: 0b                         | end
</pre>

<p>V&nbsp;tomto kódu se objevují nové typy instrukcí. V&nbsp;první řadě můžeme
vidět rozdělení instrukcí do bloků. První blok začíná instrukcí
<strong>block</strong> a končí instrukcí <strong>end</strong>. Druhý blok tvoří
dvojice <strong>loop</strong> a <strong>end</strong>, je tedy zřejmé, že se
jedná o implementaci smyčky.</p>

<p>Instrukce <strong>local.get</strong> již známe. Jejich opakem je
<strong>local.set</strong>, které naopak uloží do lokální proměnné definované
svým indexem hodnotu ze zásobníku operandů (tato hodnota se ze zásobníku
odstraní). Nová je funkce <strong>local.tee</strong>, která se od
<strong>local.set</strong> odlišuje tím, že neodstraňuje hodnotu ze zásobníku
operandů.</p>

<p>Další novou instrukcí je <strong>i32.rem_s</strong> provádějící výpočet
zbytku po dělení (klasicky se získáním operandů ze zásobníku a uložením
výsledku zpět na zásobník). Tato instrukce existuje jen v&nbsp;celočíselné
variantě pro typy <strong>i32</strong> a <strong>i64</strong>. Navíc se
postfixem určuje její varianta bez znaménka <strong>_u</strong> nebo se
znaménkem <strong>_s</strong>.</p>

<p>Předposlední novou instrukcí je instrukce <strong>return</strong>, která
ukončí provádění aktuální funkce a vrací řízení kódu, ze kterého byla tato
instrukce volána. Návratové hodnoty jsou určeny obsahem zásobníku operandů a
taktéž signaturou funkce. Pokud zásobník operandů obsahuje více hodnot, než je
specifikováno v&nbsp;signatuře funkce, jsou tyto nadbytečné hodnoty
ignorovány.</p>

<p>Prozatím nejsložitější instrukcí je <strong>br_if</strong>, což je zkratka
sousloví <i>branch if</i>. Tato instrukce přečte hodnotu ze zásobníku operandů,
kterou považuje za pravdivostní hodnotu. Na základě této hodnoty se buď provede
nebo naopak neprovede skok na konec bloku nebo na začátek smyčky (nová iterace
smyčky). Povšimněte si, jak se tato instrukce liší od klasického podmíněného
skoku, který pracuje s&nbsp;absolutními nebo relativními adresami. Typicky se
před touto instrukcí nachází výpočet vracející 0 nebo 1 na zásobník, ovšem
v&nbsp;našem konkrétním algoritmu je výsledek získán přímo z&nbsp;počítané
hodnoty (<strong>while(v) ...</strong>.</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Compiling C to WebAssembly without Emscripten<br />
<a href="https://surma.dev/things/c-to-webassembly/">https://surma.dev/things/c-to-webassembly/</a>
</li>

<li>Web Assemply: Text Format<br />
<a href="https://webassembly.github.io/spec/core/text/index.html">https://webassembly.github.io/spec/core/text/index.html</a>
</li>

<li>Web Assembly: Binary Format<br />
<a href="https://webassembly.github.io/spec/core/binary/index.html">https://webassembly.github.io/spec/core/binary/index.html</a>
</li>

<li>WebAssembly<br />
<a href="https://webassembly.org/">https://webassembly.org/</a>
</li>

<li>WebAssembly na Wiki Golangu<br />
<a href="https://github.com/golang/go/wiki/WebAssembly">https://github.com/golang/go/wiki/WebAssembly</a>
</li>

<li>The future of WebAssembly - A look at upcoming features and proposals<br />
<a href="https://blog.scottlogic.com/2018/07/20/wasm-future.html">https://blog.scottlogic.com/2018/07/20/wasm-future.html</a>
</li>

<li>WebAssembly Design<br />
<a href="https://github.com/WebAssembly/design">https://github.com/WebAssembly/design</a>
</li>

<li>Využití WebAssembly z programovacího jazyka Go <br />
<a href="https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/</a>
</li>

<li>WebAssembly slibuje podstatné zrychlení webů, konec JavaScriptu se ale nekoná<br />
<a href="https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/">https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>Top 23 WASM Open-Source Projects<br />
<a href="https://www.libhunt.com/topic/wasm">https://www.libhunt.com/topic/wasm</a>
</li>

<li>Made with WebAssembly<br />
<a href="https://madewithwebassembly.com/">https://madewithwebassembly.com/</a>
</li>

<li>The Top 1,790 Wasm Open Source Projects on Github<br />
<a href="https://awesomeopensource.com/projects/wasm">https://awesomeopensource.com/projects/wasm</a>
</li>

<li>Sanspiel<br />
<a href="https://sandspiel.club/">https://sandspiel.club/</a>
</li>

<li>Painting on HTML5 Canvas with Rust WASM<br />
<a href="https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html">https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html</a>
</li>

<li>Writing WebAssembly By Hand<br />
<a href="https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html">https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html</a>
</li>

<li>WebAssembly Specification<br />
<a href="https://webassembly.github.io/spec/core/index.html">https://webassembly.github.io/spec/core/index.html</a>
</li>

<li>Index of Instructions<br />
<a href="https://webassembly.github.io/spec/core/appendix/index-instructions.html">https://webassembly.github.io/spec/core/appendix/index-instructions.html</a>
</li>

<li>The WebAssembly Binary Toolkit<br />
<a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a>
</li>

<li>Will WebAssembly replace JavaScript? Or Will WASM Make JavaScript More Valuable in Future?<br />
<a href="https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e">https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e</a>
</li>

<li>Webassembly as 32bit and 64bit<br />
<a href="https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit">https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit</a>
</li>

<li>Portability<br />
<a href="https://webassembly.org/docs/portability/">https://webassembly.org/docs/portability/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Nástroj objdump: švýcarský nožík pro vývojáře<br />
<a href="https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/">https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/</a>
</li>

<li>Getting Started: Building and Running Clang<br />
<a href="https://clang.llvm.org/get_started.html">https://clang.llvm.org/get_started.html</a>
</li>

<li>Clang: a C language family frontend for LLVM<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Scheduling LLVM Passes with the New Pass Manager<br />
<a href="https://stephenverderame.github.io/blog/scheduling_llvm/">https://stephenverderame.github.io/blog/scheduling_llvm/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

