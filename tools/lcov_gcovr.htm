<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

<p>Základní vlastnosti nástrojů <i>gcovr</i> a <i>lcov</i> si otestujeme na několika demonstračních příkladech. První demonstrační příklad, který si v&nbsp;dnešním článku ukážeme, je napsaný v&nbsp;programovacím jazyku C. Najdeme v&nbsp;něm triviální implementaci konstrukce binárního stromu (<i>binary tree</i>) určeného pro uložení řetězců společně s&nbsp;funkcí určenou pro realizaci průchodu (traverzace) tímto stromem. Ovšem průchod stromem je (alespoň prozatím) realizován nad prázdným stromem, takže již dopředu můžeme odhadnout, že zdaleka ne všechny řádky programového kódu budou v&nbsp;čase běhu programu (tedy v&nbsp;runtime) využity (zavolány):</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
&nbsp;
typedef struct <strong>Node</strong>
{
    struct Node *left;
    struct Node *right;
    char *value;
} Node;
&nbsp;
void <strong>insert_new_node</strong>(Node **root, char *value)
{
    int cmp;
&nbsp;
    if (*root == NULL)
    {
        *root = (Node *)malloc(sizeof(Node));
        (*root)-&gt;value = (char*)calloc(strlen(value), sizeof(char));
        strcpy((*root)-&gt;value, value);
        (*root)-&gt;left = NULL;
        (*root)-&gt;right = NULL;
        return;
    }
    cmp = strcmp(value, (*root)-&gt;value);
    if (cmp &lt; 0)
    {
        insert_new_node(&amp;(*root)-&gt;left, value);
    }
    else
    {
        insert_new_node(&amp;(*root)-&gt;right, value);
    }
}
&nbsp;
void <strong>traverse_tree</strong>(Node *root, void (*callback_function)(char *))
{
    if (root == NULL)
    {
        return;
    }
    traverse_tree(root-&gt;left, callback_function);
    callback_function(root-&gt;value);
    traverse_tree(root-&gt;right, callback_function);
}
&nbsp;
void <strong>callback_function</strong>(char *value)
{
    printf("%s\n", value);
}
&nbsp;
int <strong>main</strong>(void)
{
    static Node *root = NULL;
&nbsp;
    traverse_tree(root, callback_function);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto příkladu
naleznete na adrese <a
href="https://github.com/tisnik/slides/blob/master/sources/tree1.c">https://github.com/tisnik/slides/blob/master/sources/tree1.c</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Příprava pro analýzu kódu s&nbsp;využitím nástroje <strong>gcov</strong></h2>

<p>Pro zjištění, které části kódu jsou živé (volané) a které nikoli, je zapotřebí provést překlad zdrojového kódu s&nbsp;využitím přepínačů <strong>-fprofile-arcs</strong> a <strong>-ftest-coverage tree1.c</strong> (navíc je více než vhodné nepoužívat optimalizace):</p>

<pre>
$ <strong>gcc -v -fprofile-arcs -ftest-coverage tree1.c -o tree1</strong>
</pre>

<pre>
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/15/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-redhat-linux
Configured with: ../configure --enable-bootstrap --enable-languages=c,c++,fortran,objc,obj-c++,ada,go,d,m2,cobol,lto --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --enable-libstdcxx-backtrace --with-libstdcxx-zoneinfo=/usr/share/zoneinfo --with-linker-hash-style=gnu --enable-plugin --enable-initfini-array --with-isl=/builddir/build/BUILD/gcc-15.2.1-build/gcc-15.2.1-20251111/obj-x86_64-redhat-linux/isl-install --enable-offload-targets=nvptx-none,amdgcn-amdhsa --enable-offload-defaulted --without-cuda-driver --enable-gnu-indirect-function --enable-cet --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux --with-build-config=bootstrap-lto --enable-link-serialization=1
Thread model: posix
Supported LTO compression algorithms: zlib zstd
gcc version 15.2.1 20251111 (Red Hat 15.2.1-4) (GCC) 
COLLECT_GCC_OPTIONS='-v' '-fprofile-arcs' '-ftest-coverage' '-o' 'tree1' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/15/cc1 -quiet -v tree1.c -quiet -dumpbase tree1.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -fprofile-arcs -ftest-coverage -o /tmp/ccRLbcUX.s
GNU C23 (GCC) version 15.2.1 20251111 (Red Hat 15.2.1-4) (x86_64-redhat-linux)
        compiled by GNU C version 15.2.1 20251111 (Red Hat 15.2.1-4), GMP version 6.3.0, MPFR version 4.2.2, MPC version 1.3.1, isl version isl-0.24-GMP

GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/15/include-fixed"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/15/../../../../x86_64-redhat-linux/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-redhat-linux/15/include
 /usr/local/include
 /usr/include
End of search list.
Compiler executable checksum: cb5b2100d753cda12335fdede84b8cff
COLLECT_GCC_OPTIONS='-v' '-fprofile-arcs' '-ftest-coverage' '-o' 'tree1' '-mtune=generic' '-march=x86-64'
 as -v --64 -o /tmp/ccOQH5cZ.o /tmp/ccRLbcUX.s
GNU assembler version 2.44 (x86_64-redhat-linux) using BFD version version 2.44-12.fc42
COMPILER_PATH=/usr/libexec/gcc/x86_64-redhat-linux/15/:/usr/libexec/gcc/x86_64-redhat-linux/15/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/15/:/usr/lib/gcc/x86_64-redhat-linux/
LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/15/:/usr/lib/gcc/x86_64-redhat-linux/15/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/15/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-fprofile-arcs' '-ftest-coverage' '-o' 'tree1' '-mtune=generic' '-march=x86-64' '-dumpdir' 'tree1.'
 /usr/libexec/gcc/x86_64-redhat-linux/15/collect2 -plugin /usr/libexec/gcc/x86_64-redhat-linux/15/liblto_plugin.so -plugin-opt=/usr/libexec/gcc/x86_64-redhat-linux/15/lto-wrapper -plugin-opt=-fresolution=/tmp/ccZZUkQZ.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o tree1 /usr/lib/gcc/x86_64-redhat-linux/15/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/15/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/15/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/15 -L/usr/lib/gcc/x86_64-redhat-linux/15/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/15/../../.. -L/lib -L/usr/lib /tmp/ccOQH5cZ.o -lgcov -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-redhat-linux/15/crtend.o /usr/lib/gcc/x86_64-redhat-linux/15/../../../../lib64/crtn.o
COLLECT_GCC_OPTIONS='-v' '-fprofile-arcs' '-ftest-coverage' '-o' 'tree1' '-mtune=generic' '-march=x86-64' '-dumpdir' 'tree1.'
</pre>

<p>Výsledkem překladu bude (podle očekávání) soubor <strong>a.out</strong> a navíc i soubor <strong>tree1.gcno</strong> obsahující &ndash; jak jsme si již ve stručnosti řekli &ndash; mapování mezi řádky ve zdrojovém kódu a adresami v&nbsp;paměťové oblasti alokované pro běžící program</p>

<pre>
$ <strong>ls -l</strong>
&nbsp;
total 108
<strong>-rwxrwxr-x 1 ptisnovs ptisnovs 28776 Jan 15 12:28 tree1</strong>
-rw-r--r-- 1 ptisnovs ptisnovs  1111 Jan 13 18:50 tree1.c
<strong>-rw-rw-r-- 1 ptisnovs ptisnovs  1471 Jan 15 12:28 tree1.gcno</strong>
</pre>

<p>Nyní spustíme testovaný program <strong>tree1</strong> stejným způsobem, jako bychom ho spouštěli bez zjišťování volaných řádků:</p>

<pre>
$ <strong>./tree1</strong>
</pre>

<p>Po ukončení běhu programu by měl být vytvořen nový soubor <strong>tree1.gcda</strong> s&nbsp;čítači přístupů k&nbsp;jednotlivým řádkům:</p>

<pre>
$ <strong>ls -l</strong>
&nbsp;
total 120
<strong>-rwxrwxr-x 1 ptisnovs ptisnovs 28776 Jan 15 12:28 tree1</strong>
-rw-r--r-- 1 ptisnovs ptisnovs  1111 Jan 13 18:50 tree1.c
-rw-rw-r-- 1 ptisnovs ptisnovs  1471 Jan 15 12:28 tree1.gcno
<strong>-rw-rw-r-- 1 ptisnovs ptisnovs   204 Jan 15 12:29 tree1.gcda</strong>
</pre>

<p>Oba dva výše zmíněné soubory, tedy <strong>tree1.gcno</strong> a <strong>tree1.gcda</strong> je nyní nutné sloučit nástrojem <i>gcov</i>, popř.&nbsp;přímo zpracovat dalšími nástroji.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vygenerování čitelného protokolu</h2>

<p>Nyní nastal čas na vygenerování čitelného protokolu, z&nbsp;něhož zjistíme, které řádky ve vstupním zdrojovém textu jsou skutečně volány a které naopak nikoli. Tento protokol si necháme vygenerovat příkazem:</p>

<pre>
$ <strong>gcov tree1.c</strong>
</pre>

<p>Nástroj <i>gcov</i> v&nbsp;průběhu své činnosti zobrazí, které vstupní soubory se zdrojovými texty jsou zpracovávány a mj.&nbsp;taktéž ukáže velmi důležitou informaci &ndash; jaké procento řádků se zdrojovým kódem obsahuje živý kód. V&nbsp;našem konkrétním případě se reálně využila jen čtvrtina zapsaného kódu, což je z&nbsp;výsledku patrné:</p>

<pre>
File 'tree1.c'
Lines executed:25.00% of 24
Creating 'tree1.c.gcov'
&nbsp;
Lines executed:25.00% of 24
</pre>

<p>Navíc je možné zjistit podrobnější informace o jednotlivých funkcích (metodách):</p>

<pre>
$ <strong>gcov -f tree1.c</strong>
</pre>

<pre>
Function 'main'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1
&nbsp;
Function 'callback_function'
Lines executed:0.00% of 3
No branches
Calls executed:0.00% of 1
&nbsp;
Function 'traverse_tree'
Lines executed:50.00% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
Calls executed:0.00% of 3
&nbsp;
Function 'insert_new_node'
Lines executed:0.00% of 12
Branches executed:0.00% of 4
Taken at least once:0.00% of 4
Calls executed:0.00% of 2
&nbsp;
File 'tree1.c'
Lines executed:25.00% of 24
Creating 'tree1.c.gcov'
&nbsp;
Lines executed:25.00% of 24
</pre>

<pre>
        -:    0:Source:tree1.c
        -:    0:Graph:tree1.gcno
        -:    0:Data:tree1.gcda
        -:    0:Runs:1
        -:    1:#include &lt;stdlib.h&gt;
        -:    2:#include &lt;stdio.h&gt;
        -:    3:#include &lt;string.h&gt;
        -:    4:
        -:    5:typedef struct Node
        -:    6:{
        -:    7:    struct Node *left;
        -:    8:    struct Node *right;
        -:    9:    char *value;
        -:   10:} Node;
        -:   11:
    #####:   12:void insert_new_node(Node **root, char *value)
        -:   13:{
        -:   14:    int cmp;
        -:   15:
    #####:   16:    if (*root == NULL)
        -:   17:    {
    #####:   18:        *root = (Node *)malloc(sizeof(Node));
    #####:   19:        (*root)-&gt;value = (char*)calloc(strlen(value), sizeof(char));
    #####:   20:        strcpy((*root)-&gt;value, value);
    #####:   21:        (*root)-&gt;left = NULL;
    #####:   22:        (*root)-&gt;right = NULL;
    #####:   23:        return;
        -:   24:    }
    #####:   25:    cmp = strcmp(value, (*root)-&gt;value);
    #####:   26:    if (cmp &lt; 0)
        -:   27:    {
    #####:   28:        insert_new_node(&amp;(*root)-&gt;left, value);
        -:   29:    }
        -:   30:    else
        -:   31:    {
    #####:   32:        insert_new_node(&amp;(*root)-&gt;right, value);
        -:   33:    }
        -:   34:}
        -:   35:
        1:   36:void traverse_tree(Node *root, void (*callback_function)(char *))
        -:   37:{
        1:   38:    if (root == NULL)
        -:   39:    {
        1:   40:        return;
        -:   41:    }
    #####:   42:    traverse_tree(root-&gt;left, callback_function);
    #####:   43:    callback_function(root-&gt;value);
    #####:   44:    traverse_tree(root-&gt;right, callback_function);
        -:   45:}
        -:   46:
    #####:   47:void callback_function(char *value)
        -:   48:{
    #####:   49:    printf("%s\n", value);
    #####:   50:}
        -:   51:
        1:   52:int main(void)
        -:   53:{
        -:   54:    static Node *root = NULL;
        -:   55:
        1:   56:    traverse_tree(root, callback_function);
        -:   57:
        1:   58:    return 0;
        -:   59:}
        -:   60:
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<pre>
usage: gcovr [options] [search_paths...]
&nbsp;
A utility to run gcov and summarize the coverage in simple reports.
&nbsp;
Options:
  -h, --help            Show this help message, then exit.
  --version             Print the version number, then exit.
  -v, --verbose         Print progress messages. Please include this output in bug reports. Config key(s): verbose.
  --no-color            Turn off colored logging. Is also set if environment variable NO_COLOR is present. Ignored if --force-color is
                        used. Config key(s): no-color.
  --force-color         Force colored logging, this is the default for a terminal. Is also set if environment variable FORCE_COLOR is
                        present. Has precedence over --no-color. Config key(s): force-color.
  -r, --root ROOT       The root directory of your source files. Defaults to '.', the current directory. File names are reported
                        relative to this root. The --root is the default --filter. Config key(s): root.
  --config CONFIG       Load that configuration file. Defaults to gcovr.cfg in the --root directory.
  --no-markers          Turn off exclusion markers. Any exclusion markers specified in source files will be ignored. Config key(s):
                        no-markers.
  --fail-under-line MIN
                        Exit with a status of 2 if the total line coverage is less than MIN. Can be ORed with exit status of '--fail-
                        under-branch', '--fail-under-decision', and '--fail-under-function' option. Config key(s): fail-under-line.
  --fail-under-branch MIN
                        Exit with a status of 4 if the total branch coverage is less than MIN. Can be ORed with exit status of '--
                        fail-under-line', '--fail-under-decision', and '--fail-under-function' option. Config key(s): fail-under-
                        branch.
  --fail-under-decision MIN
                        Exit with a status of 8 if the total decision coverage is less than MIN. Can be ORed with exit status of '--
                        fail-under-line', '--fail-under-branch', and '--fail-under-function' option. Config key(s): fail-under-
                        decision.
  --fail-under-function MIN
                        Exit with a status of 16 if the total function coverage is less than MIN. Can be ORed with exit status of '--
                        fail-under-line', '--fail-under-branch', and '--fail-under-decision' option. Config key(s): fail-under-
                        function.
  --source-encoding SOURCE_ENCODING
                        Select the source file encoding. Defaults to the system default encoding (UTF-8). Config key(s): source-
                        encoding.
                        ...
                        ...
                        ...
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<pre>
$ <strong>gcovr </strong>
</pre>

<pre>
(INFO) Reading coverage data...
(INFO) Writing coverage report...
------------------------------------------------------------------------------
                           GCC Code Coverage Report
Directory: .
------------------------------------------------------------------------------
File                                       Lines    Exec  Cover   Missing
------------------------------------------------------------------------------
tree1.c                                       24       6    25%   12,16,18-23,25-26,28,32,42-44,47,49-50
------------------------------------------------------------------------------
TOTAL                                         24       6    25%
------------------------------------------------------------------------------
</pre>

<pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;coverage clover="1768559261" generated="1768559261"&gt;
  &lt;project timestamp="1768559261"&gt;
    &lt;metrics complexity="0" elements="24" coveredelements="6" conditionals="0" coveredconditionals="0" statements="0" coveredstatements="0" coveredmethods="0" methods="0" packages="1" classes="1" files="1" loc="58" ncloc="24"/&gt;
    &lt;package name="root"&gt;
      &lt;metrics complexity="0" elements="24" coveredelements="6" conditionals="0" coveredconditionals="0" statements="0" coveredstatements="0" coveredmethods="0" methods="0" classes="1" files="1" loc="58" ncloc="24"/&gt;
      &lt;file name="tree1.c" path="tree1.c"&gt;
        &lt;metrics complexity="0" elements="24" coveredelements="6" conditionals="0" coveredconditionals="0" statements="0" coveredstatements="0" coveredmethods="0" methods="0" classes="1" loc="58" ncloc="24"/&gt;
        &lt;class name="id$d135ac4a322c826db586ae97a7367d33"&gt;
          &lt;metrics complexity="0" elements="24" coveredelements="6" conditionals="0" coveredconditionals="0" statements="0" coveredstatements="0" coveredmethods="0" methods="0"/&gt;
        &lt;/class&gt;
        &lt;line num="12" type="stmt" count="0"/&gt;
        &lt;line num="16" type="stmt" count="0"/&gt;
        &lt;line num="18" type="stmt" count="0"/&gt;
        &lt;line num="19" type="stmt" count="0"/&gt;
        &lt;line num="20" type="stmt" count="0"/&gt;
        &lt;line num="21" type="stmt" count="0"/&gt;
        &lt;line num="22" type="stmt" count="0"/&gt;
        &lt;line num="23" type="stmt" count="0"/&gt;
        &lt;line num="25" type="stmt" count="0"/&gt;
        &lt;line num="26" type="stmt" count="0"/&gt;
        &lt;line num="28" type="stmt" count="0"/&gt;
        &lt;line num="32" type="stmt" count="0"/&gt;
        &lt;line num="36" type="stmt" count="1"/&gt;
        &lt;line num="38" type="stmt" count="1"/&gt;
        &lt;line num="40" type="stmt" count="1"/&gt;
        &lt;line num="42" type="stmt" count="0"/&gt;
        &lt;line num="43" type="stmt" count="0"/&gt;
        &lt;line num="44" type="stmt" count="0"/&gt;
        &lt;line num="47" type="stmt" count="0"/&gt;
        &lt;line num="49" type="stmt" count="0"/&gt;
        &lt;line num="50" type="stmt" count="0"/&gt;
        &lt;line num="52" type="stmt" count="1"/&gt;
        &lt;line num="56" type="stmt" count="1"/&gt;
        &lt;line num="58" type="stmt" count="1"/&gt;
      &lt;/file&gt;
    &lt;/package&gt;
  &lt;/project&gt;
  &lt;testproject timestamp="1768559261"&gt;
    &lt;metrics complexity="0" elements="0" coveredelements="0" conditionals="0" coveredconditionals="0" statements="0" coveredstatements="0" coveredmethods="0" methods="0"/&gt;
    &lt;package name="dummy"&gt;
      &lt;metrics complexity="0" elements="0" coveredelements="0" conditionals="0" coveredconditionals="0" statements="0" coveredstatements="0" coveredmethods="0" methods="0"/&gt;
      &lt;file name="dummy" path="dummy"&gt;
        &lt;metrics complexity="0" elements="0" coveredelements="0" conditionals="0" coveredconditionals="0" statements="0" coveredstatements="0" coveredmethods="0" methods="0"/&gt;
        &lt;class name="id$275876e34cf609db118f3d84b799a790"&gt;
          &lt;metrics complexity="0" elements="0" coveredelements="0" conditionals="0" coveredconditionals="0" statements="0" coveredstatements="0" coveredmethods="0" methods="0"/&gt;
        &lt;/class&gt;
      &lt;/file&gt;
    &lt;/package&gt;
  &lt;/testproject&gt;
&lt;/coverage&gt;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Reálný příklad</h2>

<p></p>

<pre>
#ifndef _IMAGE_H_
#define _IMAGE_H_
&nbsp;
<i>/* Image types */</i>
#define GRAYSCALE 1
#define RGB 3
#define RGBA 4
&nbsp;
<i>/* Maximum image resolution */</i>
#define MAX_WIDTH 8192
#define MAX_HEIGHT 8192
&nbsp;
<i>/**</i>
<i> * Structure that represents raster image of configurable resolution and bits</i>
<i> * per pixel format.</i>
<i> */</i>
typedef struct {
    unsigned int   width;
    unsigned int   height;
    unsigned int   bpp;
    unsigned char *pixels;
} image_t;
&nbsp;
enum error {
    OK,
    NULL_POINTER,
    NULL_IMAGE_POINTER,
    NULL_PIXELS_POINTER,
    INVALID_IMAGE_DIMENSION,
    INVALID_IMAGE_TYPE
};
&nbsp;
<i>/* function headers */</i>
size_t image_size(const image_t *image);
image_t image_create(const unsigned int width, const unsigned int height, const unsigned int bpp);
&nbsp;
#endif
</pre>

<pre>
#include &lt;stdlib.h&gt;
&nbsp;
#include "image.h"
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Compute the total size in bytes of an image's pixel buffer.</i>
<i> *</i>
<i> * @param image Pointer to the image whose buffer size will be computed.</i>
<i> *</i>
<i> * @returns Total number of bytes required for the image's pixel buffer</i>
<i> *          (width * height * bpp).</i>
<i> */</i>
size_t image_size(const image_t *image) {
    if (image == NULL) {
        return 0;
    }
    /* cast to size_t before multiplication to prevent overflow */
    return (size_t)image-&gt;width * (size_t)image-&gt;height * (size_t)image-&gt;bpp;
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Create an image_t with the given width, height, and bytes-per-pixel,</i>
<i> * allocating a pixel buffer.</i>
<i> *</i>
<i> * The returned image_t fields width, height, and bpp are initialized and</i>
<i> * pixels points to a newly allocated buffer of size width * height * bpp. If</i>
<i> * allocation fails, pixels will be NULL.</i>
<i> *</i>
<i> * @param width  Image width specified in pixels.</i>
<i> * @param height Image height specified in pixels.</i>
<i> * @param bpp    Bytes per pixel (bytes used to store a single pixel).</i>
<i> *</i>
<i> * @returns The initialized image_t; its `pixels` member points to the</i>
<i> *          allocated buffer or NULL on allocation failure.</i>
<i> */</i>
image_t image_create(const unsigned int width, const unsigned int height, const unsigned int bpp) {
    image_t image;
&nbsp;
    <i>/* validate image size */</i>
    if (width == 0 || height == 0 || width &gt; MAX_WIDTH || height &gt; MAX_HEIGHT) {
        image.width = 0;
        image.height = 0;
        image.bpp = 0;
        image.pixels = NULL;
        return image;
    }
&nbsp;
    <i>/* validate image type */</i>
    if (bpp != GRAYSCALE &amp;&amp; bpp != RGB &amp;&amp; bpp != RGBA) {
        image.width = 0;
        image.height = 0;
        image.bpp = 0;
        image.pixels = NULL;
        return image;
    }
&nbsp;
    <i>/* initialize image */</i>
    image.width = width;
    image.height = height;
    image.bpp = bpp;
&nbsp;
    <i>/* callers must check that image.pixels != NULL */</i>
    image.pixels = (unsigned char *)malloc(image_size(&amp;image));
&nbsp;
    <i>/* make sure the image will be 'zero value' when pixels are not allocated */</i>
    if (image.pixels == NULL) {
        image.width = 0;
        image.height = 0;
        image.bpp = 0;
    }
    return image;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Testy funkce <strong>image_create</strong></h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
&nbsp;
#include "image.h"
&nbsp;
#define TEST_BEGIN \
    puts(__FUNCTION__); \
    {
&nbsp;
#define TEST_END \
    }
&nbsp;
void test_image_create_zero_width(void) {
    TEST_BEGIN
    image_t image = image_create(0, 100, 4);
    assert(image.width == 0);
    assert(image.height == 0);
    assert(image.bpp == 0);
    assert(image.pixels == NULL);
    TEST_END
}
&nbsp;
void test_image_create_too_wide(void) {
    TEST_BEGIN
    image_t image = image_create(MAX_WIDTH+1, 100, 4);
    assert(image.width == 0);
    assert(image.height == 0);
    assert(image.bpp == 0);
    assert(image.pixels == NULL);
    TEST_END
}
&nbsp;
void test_image_create_zero_height(void) {
    TEST_BEGIN
    image_t image = image_create(100, 0, 4);
    assert(image.width == 0);
    assert(image.height == 0);
    assert(image.bpp == 0);
    assert(image.pixels == NULL);
    TEST_END
}
&nbsp;
void test_image_create_wrong_image_type(void) {
    TEST_BEGIN
    image_t image = image_create(100, 100, 0);
    assert(image.width == 0);
    assert(image.height == 0);
    assert(image.bpp == 0);
    assert(image.pixels == NULL);
    TEST_END
}
&nbsp;
void test_image_create_grayscale(void) {
    TEST_BEGIN
    image_t image = image_create(100, 100, GRAYSCALE);
    assert(image.pixels != NULL);
    free(image.pixels);
    TEST_END
}
&nbsp;
void test_image_create_rgba(void) {
    TEST_BEGIN
    image_t image = image_create(100, 100, RGBA);
    assert(image.pixels != NULL);
    free(image.pixels);
    TEST_END
}
&nbsp;
int main(void) {
    test_image_create_zero_width();
    test_image_create_too_wide();
    test_image_create_zero_height();
    test_image_create_wrong_image_type();
    test_image_create_grayscale();
    test_image_create_rgba();
    return 0;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Překlad knihovny současně s&nbsp;testy</h2>

<p></p>

<pre>
gcc -v -c -fprofile-arcs -ftest-coverage image.c -o image.o
</pre>

<p></p>

<pre>
gcc -v -c -fprofile-arcs -ftest-coverage test.c -o test.o
</pre>

<p></p>

<pre>
gcc -v image.o test.o -lgcov -o test
</pre>

<p></p>

<pre>
$ ls -l
total 80
-rw-r--r--. 1 ptisnovs ptisnovs  2175 Jan 16 14:13 image.c
-rw-r--r--. 1 ptisnovs ptisnovs  1410 Jan 16 14:20 image.gcno
-rw-r--r--. 1 ptisnovs ptisnovs   740 Jan 16 14:15 image.h
-rw-r--r--. 1 ptisnovs ptisnovs  4264 Jan 16 14:20 image.o
-rwxr-xr-x. 1 ptisnovs ptisnovs 30472 Jan 16 14:20 test
-rw-r--r--. 1 ptisnovs ptisnovs  1749 Jan 16 14:19 test.c
-rw-r--r--. 1 ptisnovs ptisnovs  4775 Jan 16 14:19 test.gcno
-rw-r--r--. 1 ptisnovs ptisnovs 12120 Jan 16 14:19 test.o
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Spuštění testů</h2>

<p></p>

<pre>
total 88
-rw-r--r--. 1 ptisnovs ptisnovs  2175 Jan 16 14:13 image.c
-rw-r--r--. 1 ptisnovs ptisnovs   188 Jan 16 14:21 image.gcda
-rw-r--r--. 1 ptisnovs ptisnovs  1410 Jan 16 14:20 image.gcno
-rw-r--r--. 1 ptisnovs ptisnovs   740 Jan 16 14:15 image.h
-rw-r--r--. 1 ptisnovs ptisnovs  4264 Jan 16 14:20 image.o
-rwxr-xr-x. 1 ptisnovs ptisnovs 30472 Jan 16 14:20 test
-rw-r--r--. 1 ptisnovs ptisnovs  1749 Jan 16 14:19 test.c
-rw-r--r--. 1 ptisnovs ptisnovs   576 Jan 16 14:21 test.gcda
-rw-r--r--. 1 ptisnovs ptisnovs  4775 Jan 16 14:19 test.gcno
-rw-r--r--. 1 ptisnovs ptisnovs 12120 Jan 16 14:19 test.o
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vyhodnocení pokrytí kódu testy: základní varianta</h2>

<pre>
$ gcov -f image.c
</pre>

<pre>
Function 'image_create'
Lines executed:86.36% of 22
Branches executed:100.00% of 16
Taken at least once:81.25% of 16
Calls executed:100.00% of 1
&nbsp;
Function 'image_size'
Lines executed:75.00% of 4
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls
&nbsp;
File 'image.c'
Lines executed:84.62% of 26
Creating 'image.c.gcov'
&nbsp;
Lines executed:84.62% of 26
</pre>

<pre>
        -:    0:Source:image.c
        -:    0:Graph:image.gcno
        -:    0:Data:image.gcda
        -:    0:Runs:1
        -:    1:#include &lt;stdlib.h&gt;
        -:    2:
        -:    3:#include "image.h"
        -:    4:
        -:    5:
        -:    6:
        -:    7:/**
        -:    8: * Compute the total size in bytes of an image's pixel buffer.
        -:    9: *
        -:   10: * @param image Pointer to the image whose buffer size will be computed.
        -:   11: *
        -:   12: * @returns Total number of bytes required for the image's pixel buffer
        -:   13: *          (width * height * bpp).
        -:   14: */
        2:   15:size_t image_size(const image_t *image) {
        2:   16:    if (image == NULL) {
    #####:   17:        return 0;
        -:   18:    }
        -:   19:    /* cast to size_t before multiplication to prevent overflow */
        2:   20:    return (size_t)image-&gt;width * (size_t)image-&gt;height * (size_t)image-&gt;bpp;
        -:   21:}
        -:   22:
        -:   23:
        -:   24:
        -:   25:/**
        -:   26: * Create an image_t with the given width, height, and bytes-per-pixel,
        -:   27: * allocating a pixel buffer.
        -:   28: *
        -:   29: * The returned image_t fields width, height, and bpp are initialized and
        -:   30: * pixels points to a newly allocated buffer of size width * height * bpp. If
        -:   31: * allocation fails, pixels will be NULL.
        -:   32: *
        -:   33: * @param width  Image width specified in pixels.
        -:   34: * @param height Image height specified in pixels.
        -:   35: * @param bpp    Bytes per pixel (bytes used to store a single pixel).
        -:   36: *
        -:   37: * @returns The initialized image_t; its `pixels` member points to the
        -:   38: *          allocated buffer or NULL on allocation failure.
        -:   39: */
        6:   40:image_t image_create(const unsigned int width, const unsigned int height, const unsigned int bpp) {
        -:   41:    image_t image;
        -:   42:
        -:   43:    /* validate image size */
        6:   44:    if (width == 0 || height == 0 || width &gt; MAX_WIDTH || height &gt; MAX_HEIGHT) {
        3:   45:        image.width = 0;
        3:   46:        image.height = 0;
        3:   47:        image.bpp = 0;
        3:   48:        image.pixels = NULL;
        3:   49:        return image;
        -:   50:    }
        -:   51:
        -:   52:    /* validate image type */
        3:   53:    if (bpp != GRAYSCALE &amp;&amp; bpp != RGB &amp;&amp; bpp != RGBA) {
        1:   54:        image.width = 0;
        1:   55:        image.height = 0;
        1:   56:        image.bpp = 0;
        1:   57:        image.pixels = NULL;
        1:   58:        return image;
        -:   59:    }
        -:   60:
        -:   61:    /* initialize image */
        2:   62:    image.width = width;
        2:   63:    image.height = height;
        2:   64:    image.bpp = bpp;
        -:   65:
        -:   66:    /* callers must check that image.pixels != NULL */
        2:   67:    image.pixels = (unsigned char *)malloc(image_size(&amp;image));
        -:   68:
        -:   69:    /* make sure the image will be 'zero value' when pixels are not allocated */
        2:   70:    if (image.pixels == NULL) {
    #####:   71:        image.width = 0;
    #####:   72:        image.height = 0;
    #####:   73:        image.bpp = 0;
        -:   74:    }
        2:   75:    return image;
        -:   76:}
        -:   77:
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

https://tisnik.github.io/test-dependabot-no-devs/image_coverage_1/coverage.html
https://tisnik.github.io/test-dependabot-no-devs/image_coverage_2/coverage.html



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační soubory použité v&nbsp;dnešním článku byly uloženy do Git
repositáře, jenž je dostupný na adrese <a
href="https://github.com/tisnik/slides/">https://github.com/tisnik/slides/</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář, můžete namísto toho
použít odkazy na jednotlivé zdrojové soubory, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>tree1.c</td><td>průchod prázdným binárním stromem bez jeho konstrukce</td><td><a href="https://github.com/tisnik/slides/blob/master/sources/tree1.c">https://github.com/tisnik/slides/blob/master/sources/tree1.c</a></td></tr>
<tr><td>2</td><td>tree2.c</td><td>konstrukce binárního stromu s&nbsp;jediným uzlem; průchod tímto stromem</td><td><a href="https://github.com/tisnik/slides/blob/master/sources/tree2.c">https://github.com/tisnik/slides/blob/master/sources/tree2.c</a></td></tr>
<tr><td>3</td><td>tree3.c</td><td>konstrukce binárního stromu s&nbsp;více uzly; průchod tímto stromem</td><td><a href="https://github.com/tisnik/slides/blob/master/sources/tree3.c">https://github.com/tisnik/slides/blob/master/sources/tree3.c</a></td></tr>
<tr><td>4</td><td>factorial.c</td><td>naivní rekurzivní výpočet faktoriálu</td><td><a href="https://github.com/tisnik/slides/blob/master/sources/factorial.c">https://github.com/tisnik/slides/blob/master/sources/factorial.c</a></td></tr>
<tr><td>5</td><td>test.c</td><td>několik funkcí s&nbsp;různým počtem parametrů, které jsou volány z&nbsp;<strong>main</strong></td><td><a href="https://github.com/tisnik/slides/blob/master/sources/test.c">https://github.com/tisnik/slides/blob/master/sources/test.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>image.h</td><td>datová struktura představující obrázek, hlavičky funkcí pro práci s&nbsp;obrázkem, chybové kódy</td><td><a href="https://github.com/tisnik/test-dependabot-no-devs/blob/master/image/image.h">https://github.com/tisnik/test-dependabot-no-devs/blob/master/image/image.h</a></td></tr>
<tr><td>7</td><td>image.c</td><td>implementace základních funkcí pro konstrukci rastrového obrázku</td><td><a href="https://github.com/tisnik/test-dependabot-no-devs/blob/master/image/image.c">https://github.com/tisnik/test-dependabot-no-devs/blob/master/image/image.c</a></td></tr>
<tr><td>8</td><td>test.c</td><td>testy funkce určené pro konstrukci rastrového obrázku</td><td><a href="https://github.com/tisnik/test-dependabot-no-devs/blob/master/image/test.c">https://github.com/tisnik/test-dependabot-no-devs/blob/master/image/test.c</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>gcovr: online dokumentace<br />
<a href="https://gcovr.com/en/stable/">https://gcovr.com/en/stable/</a>
</li>

<li>lcov: online dokumentace<br />
<a href="https://lcov.readthedocs.io/en/latest/index.html">https://lcov.readthedocs.io/en/latest/index.html</a>
</li>

<li>gcov manual: Test Coverage Program<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Gcov.html">https://gcc.gnu.org/onlinedocs/gcc/Gcov.html</a>
</li>

<li>How to Analyze Code Coverage with gcov<br />
<a href="https://www.linuxtoday.com/blog/analyzing-code-coverage-with-gcov/">https://www.linuxtoday.com/blog/analyzing-code-coverage-with-gcov/</a>
</li>

<li>gcov - Unix, Linux Command<br />
<a href="https://www.tutorialspoint.com/unix_commands/gcov.htm">https://www.tutorialspoint.com/unix_commands/gcov.htm</a>
</li>

<li>Testing code coverage in C using GCOV<br />
<a href="https://www.youtube.com/watch?v=UOGMNRcV9-4">https://www.youtube.com/watch?v=UOGMNRcV9-4</a>
</li>

<li>Nástroj objdump: švýcarský nožík pro vývojáře<br />
<a href="https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/">https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/</a>
</li>

<li>What is code coverage?<br />
<a href="https://www.atlassian.com/continuous-delivery/software-testing/code-coverage">https://www.atlassian.com/continuous-delivery/software-testing/code-coverage</a>
</li>

<li>Everything you need to know about code coverage<br />
<a href="https://www.codegrip.tech/productivity/everything-you-need-to-know-about-code-coverage/">https://www.codegrip.tech/productivity/everything-you-need-to-know-about-code-coverage/</a>
</li>

<li>GCC, the GNU Compiler Collection<br />
<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>
</li>

<li>Clang 17.0.0: Source-based Code Coverage<br />
<a href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">https://clang.llvm.org/docs/SourceBasedCodeCoverage.html</a>
</li>

<li>Clang 17.0.0: SanitizerCoverage<br />
<a href="https://clang.llvm.org/docs/SanitizerCoverage.html">https://clang.llvm.org/docs/SanitizerCoverage.html</a>
</li>

<li>Name mangling<br />
<a href="https://en.wikipedia.org/wiki/Name_mangling">https://en.wikipedia.org/wiki/Name_mangling</a>
</li>

<li>Pokrytí kódu testy (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Pokryt%C3%AD_k%C3%B3du_testy">https://cs.wikipedia.org/wiki/Pokryt%C3%AD_k%C3%B3du_testy</a>
</li>

<li>Code coverage (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Code_coverage">https://en.wikipedia.org/wiki/Code_coverage</a>
</li>

<li>Using the GNU Compiler Collection (GCC)<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/index.html#Top">https://gcc.gnu.org/onlinedocs/gcc/index.html#Top</a>
</li>

<li>Programming Languages Supported by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/G_002b_002b-and-GCC.html#G_002b_002b-and-GCC">https://gcc.gnu.org/onlinedocs/gcc/G_002b_002b-and-GCC.html#G_002b_002b-and-GCC</a>
</li>

<li>Generating Code Coverage Report Using GNU Gcov &amp; Lcov.<br />
<a href="https://medium.com/@naveen.maltesh/generating-code-coverage-report-using-gnu-gcov-lcov-ee54a4de3f11">https://medium.com/@naveen.maltesh/generating-code-coverage-report-using-gnu-gcov-lcov-ee54a4de3f11</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2026</small></p>
</body>
</html>

