<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu formátu WebAssembly: instrukce pro řízení toku dat</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu formátu WebAssembly: instrukce pro řízení toku dat</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Pohled pod kapotu formátu WebAssembly: instrukce pro řízení toku dat</a></p>
<p><a href="#k02">2. Instrukce <strong>select</strong></a></p>
<p><a href="#k03">3. Příklad využití instrukce <strong>select</strong></a></p>
<p><a href="#k04">4. Překlad ternárního operátoru, ve kterém se nevyskytují pouze konstanty</a></p>
<p><a href="#k05">5. Koncept bloků ve WebAssembly</a></p>
<p><a href="#k06">6. Instrukce <strong>br</strong> a <strong>br_if</strong></a></p>
<p><a href="#k07">7. Překlad ternárního operátoru s&nbsp;využitím instrukce <strong>br_if</strong></a></p>
<p><a href="#k08">8. Instrukce WebAssembly určená pro realizaci programových smyček</a></p>
<p><a href="#k09">9. Nekonečná programová smyčka</a></p>
<p><a href="#k10">*** 10. Příklady překladu počítaných programových smyček</a></p>
<p><a href="#k11">*** 11. Výpočty vykonávané uvnitř počítané programové smyčky</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Obsah navazujícího článku</a></p>
<p><a href="#k19">19. Tabulka se všemi doposud popsanými instrukcemi</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu formátu WebAssembly: instrukce pro řízení toku dat</h2>

<p></p>

<pre>
clang -Os --target=wasm32 -emit-llvm -c -S ${1}.c
llc -march=wasm32 -filetype=obj ${1}.ll -o ${1}.wasm
wasm-objdump -d ${1}.wasm
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instrukce <strong>select</strong></h2>

<p>S&nbsp;instrukcí nazvanou <strong>select</strong> jsme se již částečně
seznámili v&nbsp;předchozím článku, takže jen krátce pro připomenutí:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Stručný popis</th></tr>
<tr><td>0x1b</td><td>select</td><td>ze zásobníku přečte tři hodnoty, na základě výsledku podmínky vrátí na zásobník druhou nebo třetí hodnotu</td></tr>
</table>

<p>Tato instrukce se typicky používá pro překlad výrazu s&nbsp;céčkovským
ternárním operátorem ?:, tedy například tohoto výrazu:</p>

<pre>
podmínka ? první_podvýraz : druhý_podvýraz
</pre>

<p>Ovšem je nutné si uvědomit, že instrukce <strong>select</strong> vybírá ze
zásobníku již předem vypočtené <i>hodnoty</i>, neprovádí tedy žádný rozeskok.
To ovšem znamená, že v&nbsp;předchozím případě budou muset být oba podvýrazy
<strong>první_podvýraz</strong> i <strong>druhý_podvýraz</strong> nejdříve
vyhodnoceny &ndash; není zde realizováno takzvané zkrácené vyhodnocování
(<i>short-circuit</i>). To ovšem znamená, že použití instrukce
<strong>select</strong> je omezeno a zdaleka na všechny výrazy s&nbsp;ternárním
operátorem budou přeloženy tak, aby tuto instrukci použily (což si ostatně
ukážeme v&nbsp;dalších kapitolách).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Příklad využití instrukce <strong>select</strong></h2>

<p>Vyzkoušejme si, jestli Clang (resp.&nbsp;tomto případě backend překladač
v&nbsp;LLVM) instrukci <strong>select</strong> dokáže využít. Pokusíme se
přeložit následující jednoduchou céčkovou funkci s&nbsp;ternárním výrazem,
který vrací jednu z&nbsp;konstant:</p>

<pre>
int <strong>foo</strong>(int x) {
    return x &lt; 10 ? 1 : 2;
}
</pre>

<p>Z&nbsp;výsledného bajtkódu je zřejmé, že se instrukce
<strong>select</strong> skutečně použila:</p>

<pre>
condition_1.wasm:       file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000042 func[0] <strong>&lt;foo&gt;</strong>:
 000043: 41 01                      | i32.const 1
 000045: 41 02                      | i32.const 2
 000047: 20 00                      | local.get 0
 000049: 41 0a                      | i32.const 10
 00004b: 48                         | i32.lt_s
 00004c: 1b                         | select
 00004d: 0b                         | end
</pre>

<p>Nejdříve se na zásobník uložily obě konstanty, z&nbsp;nichž jedna se bude
vracet (a druhá se zahodí):</p>

<pre>
 000043: 41 01                      | i32.const 1
 000045: 41 02                      | i32.const 2
</pre>

<p>Následně se vyhodnotila podmínka a na zásobníku zůstala její výsledná
hodnota <strong>true</strong> nebo <strong>false</strong>:</p>

<pre>
 000049: 41 0a                      | i32.const 10
 00004b: 48                         | i32.lt_s
</pre>

<p>A následovala instrukce <strong>select</strong>, která na základě výsledku
podmínky ponechá na zásobníku první nebo druhou konstantu:</p>

<pre>
 00004c: 1b                         | select
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad ternárního operátoru, ve kterém se nevyskytují pouze konstanty</h2>

<p>Jak ovšem bude vypadat překlad výrazu s&nbsp;ternárním operátorem, ve kterém
se nevyskytují pouze konstantní výrazy. Opět si to můžeme ověřit na jednoduchém
příkladu:</p>

<pre>
int <strong>foo</strong>(int x) {
    return x &lt; 10 ? x+1 : x*3;
}
</pre>

<p>Překlad do bajtkódu WebAssembly proběhne takto (resp.&nbsp;tak může
proběhnout):</p>

<pre>
condition_2.wasm:       file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000042 func[0] <strong>&lt;foo&gt;</strong>:
 000043: 20 00                      | local.get 0
 000045: 41 01                      | i32.const 1
 000047: 6a                         | i32.add
 000048: 20 00                      | local.get 0
 00004a: 41 03                      | i32.const 3
 00004c: 6c                         | i32.mul
 00004d: 20 00                      | local.get 0
 00004f: 41 0a                      | i32.const 10
 000051: 48                         | i32.lt_s
 000052: 1b                         | select
 000053: 0b                         | end
</pre>

<p>Toto je ovšem zajímavé, protože se ve skutečnosti vyhodnotily oba podvýrazy
&ndash; jeden ovšem zbytečně. Vyhodnocení prvního podvýrazu s&nbsp;uložením
výsledku na zásobník:</p>

<pre>
 000043: 20 00                      | local.get 0
 000045: 41 01                      | i32.const 1
 000047: 6a                         | i32.add
</pre>

<p>Vyhodnocení podvýrazu druhého, opět s&nbsp;uložením výsledku na
zásobník:</p>

<pre>
 000048: 20 00                      | local.get 0
 00004a: 41 03                      | i32.const 3
 00004c: 6c                         | i32.mul
</pre>

<p>Výběr jednoho z&nbsp;výsledků na základě vyhodnocené podmínky:</p>

<pre>
 00004d: 20 00                      | local.get 0
 00004f: 41 0a                      | i32.const 10
 000051: 48                         | i32.lt_s
 000052: 1b                         | select
</pre>

<p>Prakticky stejně dopadneme při překladu programu, který pracuje
s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou:</p>

<pre>
float <strong>foo</strong>(float x) {
    return x &lt; 10 ? x+1 : x*3;
}
</pre>

<p>Výsledek překladu do WebAssembly:</p>

<pre>
condition_3.wasm:       file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000042 func[0] <strong>&lt;foo&gt;</strong>:
 000043: 20 00                      | local.get 0
 000045: 43 00 00 80 3f             | f32.const 0x1p+0
 00004a: 92                         | f32.add
 00004b: 20 00                      | local.get 0
 00004d: 43 00 00 40 40             | f32.const 0x1.8p+1
 000052: 94                         | f32.mul
 000053: 20 00                      | local.get 0
 000055: 43 00 00 20 41             | f32.const 0x1.4p+3
 00005a: 5d                         | f32.lt
 00005b: 1b                         | select
 00005c: 0b                         | end
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Koncept bloků ve WebAssembly</h2>

<p>Bajtkód WebAssembly je v&nbsp;mnoha ohledech podobný dalším typům bajtkódů,
zejména těch, které jsou založeny na výpočtech s&nbsp;hodnotami uloženými na
zásobníku operandů (<i>operand stack</i>). Ovšem realizace skoků a rozeskoků je
ve WebAssembly poněkud odlišná. V&nbsp;dalších bajtkódech najdeme instrukce
určené pro skok na určitou adresu, ať již absolutní nebo relativní, zatímco
WebAssembly je založena na konceptu takzvaných <i>bloků</i>. Základ tohoto
konceptu tvoří dvojice instrukcí nazvaných <strong>block</strong> a
<strong>end</strong>, které určují začátek a konec bloku. Při vykonávání těchto
instrukcí se na takzvaný zásobník řízení toku (<i>control-flow stack</i>)
ukládají nebo naopak odstraňují návěští (<i>label</i>):</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Stručný popis</th></tr>
<tr><td>0x02</td><td>block</td><td>uloží návěští na zásobník řízení toku (<i>control-flow stack</i>)</td></tr>
<tr><td>0x0b</td><td>end</td><td>odstraní návěští ze zásobníku řízení toku (<i>control-flow stack</i>)</td></tr>
</table>

<p>Dále existují instrukce, které dokážou provést podmíněný nebo nepodmíněný
skok na začátek nebo na konec bloku. U těchto instrukcí je navíc možné zvolit,
začátek či konec kterého bloku bude použit &ndash; bloky totiž mohou být
vnořeny a bajtkód musí nabízet instrukce pro výskok z&nbsp;několika vnořených
bloků atd.</p>

<p><div class="rs-tip-major">Poznámka: toto je pravděpodobně největší rozdíl
bajtkódu WebAssembly v&nbsp;porovnání s&nbsp;například bajtkódem JVM, Pythonu
či (dnes již dávno historického) virtuálnímu stroji Pascalu.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce <strong>br</strong> a <strong>br_if</strong></h2>

<p>Nyní již máme k&nbsp;dispozici všechny důležité informace potřebné pro popis
instrukcí <strong>br</strong> a <strong>br_if</strong>. Jedná se o instrukce
nepodmíněného resp.&nbsp;ve druhém případě podmíněného skoku, což je patrné
z&nbsp;mnemotechnických zkratek těchto instrukcí, které znamenají
&bdquo;branch&ldquo; a &bdquo;branch if&ldquo;:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Stručný popis</th></tr>
<tr><td>0x0c</td><td>br</td><td>provede se nepodmíněný skok</td></tr>
<tr><td>0x0d</td><td>br_if</td><td>pokud je na zásobníku uložena nenulová hodnota, provede se skok, jinak se neprovede žádná operace</td></tr>
</table>

<p>Instrukce <strong>br_if</strong> očekává, že se na vrcholu zásobníku
operandů nachází hodnota libovolného typu. Pokud je tato hodnota nenulová (což
odpovídá <strong>true</strong>), provede se skok. Pokud je hodnota nulová,
pokračuje se další instrukcí. Instrukce <strong>br</strong> provede skok vždy,
bez ohledu na obsah zásobníku operandů. Nyní je ovšem důležité vysvětlit, co
vlastně znamená sousloví &bdquo;provede se skok&ldquo;. Pracuje se zde se
zásobníkem řízení toku (<i>control-flow stack</i>), ze kterého se přečte TOP-n
tá položka. Typicky se setkáme s&nbsp;instrukcí <strong>br_if 0</strong>, která
pracuje s&nbsp;nejvyšší položkou na zásobníku. Na základě přečtené položky se
hledá konec příslušného bloku a skok je proveden za tento konec (samozřejmě se
v&nbsp;praxi adresy konců bloků mohou předpočítat dopředu).</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že je
<strong>br</strong> nebo <strong>br_if</strong> použita uvnitř klasického bloku
<strong>block-end</strong>, můžeme namísto &bdquo;branch&ldquo; chápat tuto
instrukci i jako &bdquo;break&ldquo;. To ovšem neplatí uvnitř bloku
<strong>loop-end</strong>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad ternárního operátoru s&nbsp;využitím instrukce <strong>br_if</strong></h2>

<p>Instrukce <strong>br_if</strong> musí být použita například v&nbsp;případě,
že se ve výrazu s&nbsp;ternárním operátorem volají nějaké funkce
popř.&nbsp;jsou zde zapsány podvýrazy, které mění obsah proměnné (++, --).
V&nbsp;takových případech již není možné vypočítat hodnoty podvýrazů
v&nbsp;obou větvích a poté pouze instrukcí <strong>SELECT</strong> vybrat jeden
z&nbsp;výsledků, ale musí se použít skutečný podmíněný skok.</p>

<p>Ukažme si tento koncept na jednoduchém programu, který ve funkci
<strong>foo</strong> provádí rozvětvení na základě zapsané podmínky, která je
vhodně nastavena tak, aby ji překladač nemohl vyhodnotit již v&nbsp;době
překladu:</p>

<pre>
int <strong>bar</strong>(int x);
int <strong>baz</strong>(int x);
&nbsp;
int <strong>foo</strong>(int x) {
    return x &lt; 42 ? bar(x) : baz(x);
}
</pre>

<p>Překlad tohoto programu do bajtkódu WebAssembly bude vypadat následovně:</p>

<pre>
condition_4.wasm:       file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000056 func[2] <strong>&lt;foo&gt;</strong>:
 000057: 02 40                      | block
 000059: 20 00                      |   local.get 0
 00005b: 41 29                      |   i32.const 41
 00005d: 4a                         |   i32.gt_s
 00005e: 0d 00                      |   br_if 0
 000060: 20 00                      |   local.get 0
 000062: 10 80 80 80 80 00          |   call 0 &lt;env.bar&gt;
 000068: 0f                         |   return
 000069: 0b                         | end
 00006a: 20 00                      | local.get 0
 00006c: 10 81 80 80 80 00          | call 1 &lt;env.baz&gt;
 000072: 0b                         | end
</pre>

<p>V&nbsp;bajtkódu je definován samostatný blok. V&nbsp;rámci tohoto bloku je
vypočtena podmínka a na základě jejího výsledku buď dojde k&nbsp;výskoku
z&nbsp;tohoto bloku instrukcí <strong>br_if</strong> nebo se pokračuje
v&nbsp;dalších instrukcích které zavolají funkci <strong>bar</strong> a
následně se funkce ukončí. Při skoku (výskoku z&nbsp;bloku) se naopak zavolá
funkce <strong>baz</strong> a opět dojde k&nbsp;ukončení funkce.</p>

<p>Pro zajímavost se podívejme, jak se bude bajtkód odlišovat v&nbsp;případě,
že všechny výpočty budou používat hodnoty s&nbsp;plovoucí řádovou čárkou:</p>

<pre>
float <strong>bar</strong>(float x);
float <strong>baz</strong>(float x);
&nbsp;
float <strong>foo</strong>(float x) {
    return x &lt; 42 ? bar(x) : baz(x);
}
</pre>

<p>Výsledek překladu do bajtkódu WebAssembly ukazuje, že se vlastně pouze mění
způsob výpočtu podmínky. Další instrukce zůstanou prakticky stejné:</p>

<pre>
condition_5.wasm:       file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000056 func[2] <strong>&lt;foo&gt;</strong>:
 000057: 02 40                      | block
 000059: 20 00                      |   local.get 0
 00005b: 43 00 00 28 42             |   f32.const 0x1.5p+5
 000060: 5d                         |   f32.lt
 000061: 45                         |   i32.eqz
 000062: 0d 00                      |   br_if 0
 000064: 20 00                      |   local.get 0
 000066: 10 80 80 80 80 00          |   call 0 &lt;env.bar&gt;
 00006c: 0f                         |   return
 00006d: 0b                         | end
 00006e: 20 00                      | local.get 0
 000070: 10 81 80 80 80 00          | call 1 &lt;env.baz&gt;
 000076: 0b                         | end
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukce WebAssembly určená pro realizaci programových smyček</h2>

<p>V&nbsp;klasických virtuálních strojích se většinou programové smyčky (jak
počítané, tak i nepočítané) realizují nějakou formou podmíněného skoku. Podobně
je tomu i v&nbsp;běžných instrukčních sadách. Instrukce podmíněného skoku
v&nbsp;takových případech obsahuje absolutní nebo relativní adresu, na kterou
bude skok proveden. Ovšem ve WebAssembly je tomu jinak. Už v&nbsp;předchozím
textu jsme se setkali s&nbsp;konceptem bloků realizovaných instrukcemi
<strong>block</strong> a <strong>end</strong>. Tyto instrukce jsou doplněny
instrukcemi podmíněného a nepodmíněného skoku: <strong>br_if</strong> a
<strong>br</strong>. Ovšem, jak již víme, tyto instrukce neobsahují adresy cíle
skoku, ale &bdquo;pouze&ldquo; relativní číslo bloku, z&nbsp;něhož má být
výskok proveden.</p>

<p>Instrukce <strong>br</strong> a <strong>br_if</strong> tedy v&nbsp;takovém
případě skáčou na (za) konec bloku, tedy <i>za</i> instrukci
<strong>end</strong>. Ovšem ve WebAssembly nalezneme ještě jednu instrukci,
která se jmenuje <strong>loop</strong>:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Stručný popis</th></tr>
<tr><td>0x03</td><td>loop</td><td>návěští je nastavena na současnou pozici v&nbsp;bajtkódu a zapamatováno</td></tr>
</table>

<p>Tato instrukce se používá na stejném místě, jako již popsaná instrukce
<strong>block</strong>, ovšem její sémantika je odlišná. Pokud se provede
instrukce <strong>br</strong> nebo <strong>br_if</strong>, bude skok realizován
nikoli <i>za</i> konec bloku (tedy za <strong>end</strong>), ale naopak
<i>za</i> instrukci <strong>loop</strong>, tedy vlastně na začátek bloku
<strong>loop-end</strong>.</p>

<p>Nekonečná smyčka by tedy mohla vypadat přibližně takto:</p>

<pre>
loop
  ...
  ...
  ...
  br 0
end
</pre>

<p>Naopak programová smyčka s&nbsp;testem na konci by mohla vypadat
následovně:</p>

<pre>
loop
  ...
  ...
  ....
  br_if 0
end
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Nekonečná programová smyčka</h2>

<p>Základ konceptu smyček ve WebAssembly si ukážeme na příkladu, ve kterém je
definována nekonečná smyčka, v&nbsp;níž se volá nějaká další funkce:</p>

<pre>
void <strong>foo</strong>(void);
&nbsp;
void <strong>loop</strong>(void) {
    while (1) {
        foo();
    }
}
</pre>

<p>V&nbsp;bajtkódu můžeme vidět blok smyčky vytvořený dvojicí instrukcí
<strong>loop</strong> a <strong>end</strong>. Uvnitř smyčky se pak nachází
instrukce <strong>br 0</strong>, která provádí nepodmíněný skok na začátek
smyčky, protože samotná instrukce <strong>loop</strong> ve skutečnosti
<i>není</i> implementací smyčky, ale jen definice bloku:</p>

<pre>
loop_0.wasm:	file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
00004a func[1] <strong>&lt;loop&gt;</strong>:
 00004b: 03 40                      | loop
 00004d: 10 80 80 80 80 00          |   call 0 &lt;env.foo&gt;
 000053: 0c 00                      |   br 0
 000055: 0b                         | end
 000056: 0b                         | end
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Příklady překladu počítaných programových smyček</h2>

<p></p>

<pre>
int <strong>foo</strong>(void);
&nbsp;
void <strong>loop</strong>(void) {
    int i;
    for (i=0; i&lt;10; i++) {
        foo();
    }
}
</pre>

<pre>
loop_1.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
00004e func[1] &lt;loop&gt;:
 00004f: 01 7f                      | local[0] type=i32
 000051: 41 0a                      | i32.const 10
 000053: 21 00                      | local.set 0
 000055: 03 40                      | loop
 000057: 10 80 80 80 80 00          |   call 0 &lt;env.foo&gt;
 00005d: 1a                         |   drop
 00005e: 20 00                      |   local.get 0
 000060: 41 7f                      |   i32.const 4294967295
 000062: 6a                         |   i32.add
 000063: 22 00                      |   local.tee 0
 000065: 0d 00                      |   br_if 0
 000067: 0b                         | end
 000068: 0b                         | end
</pre>

<p></p>

<pre>
int <strong>foo</strong>(int);
&nbsp;
void <strong>loop</strong>(void) {
    int i;
    for (i=0; i&lt;10; i++) {
        foo(i);
    }
}
</pre>

<p></p>

<pre>
loop_2.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
00004f func[1] &lt;loop&gt;:
 000050: 01 7f                      | local[1] type=i32
 000052: 41 00                      | i32.const 0
 000054: 21 00                      | local.set 0
 000056: 03 40                      | loop
 000058: 20 00                      |   local.get 0
 00005a: 10 80 80 80 80 00          |   call 0 &lt;env.foo&gt;
 000060: 1a                         |   drop
 000061: 20 00                      |   local.get 0
 000063: 41 01                      |   i32.const 1
 000065: 6a                         |   i32.add
 000066: 22 00                      |   local.tee 0
 000068: 41 0a                      |   i32.const 10
 00006a: 47                         |   i32.ne
 00006b: 0d 00                      |   br_if 0
 00006d: 0b                         | end
 00006e: 0b                         | end
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výpočty vykonávané uvnitř počítané programové smyčky</h2>

<pre>
int loop(int start) {
    int i;
    int s=start;
    for (i=0; i&lt;10; i++) {
        s*=42;
    }
    return s;
}
</pre>

<pre>
loop_3.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000042 func[0] &lt;loop&gt;:
 000043: 01 7f                      | local[1] type=i32
 000045: 41 0a                      | i32.const 10
 000047: 21 01                      | local.set 1
 000049: 03 40                      | loop
 00004b: 20 00                      |   local.get 0
 00004d: 41 2a                      |   i32.const 42
 00004f: 6c                         |   i32.mul
 000050: 21 00                      |   local.set 0
 000052: 20 01                      |   local.get 1
 000054: 41 7f                      |   i32.const 4294967295
 000056: 6a                         |   i32.add
 000057: 22 01                      |   local.tee 1
 000059: 0d 00                      |   br_if 0
 00005b: 0b                         | end
 00005c: 20 00                      | local.get 0
 00005e: 0b                         | end
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vnořené počítané programové smyčky</h2>

<p></p>

<pre>
void <strong>print</strong>(int);
&nbsp;
void <strong>nested_loops</strong>(void) {
    int x, y;
    for (y=1; y&lt;=10; y++) {
        for (x=1; x&lt;=10; x++) {
            print(x*y);
        }
    }
}
</pre>

<p></p>

<pre>
loop_4.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000050 func[1] <strong>&lt;nested_loops&gt;</strong>:
 000051: 03 7f                      | local[1..3] type=i32
 000053: 41 01                      | i32.const 1
 000055: 21 00                      | local.set 0
 000057: 03 40                      | loop
 000059: 41 0a                      |   i32.const 10
 00005b: 21 01                      |   local.set 1
 00005d: 20 00                      |   local.get 0
 00005f: 21 02                      |   local.set 2
 000061: 03 40                      |   loop
 000063: 20 02                      |     local.get 2
 000065: 10 80 80 80 80 00          |     call 0 &lt;env.print&gt;
 00006b: 20 02                      |     local.get 2
 00006d: 20 00                      |     local.get 0
 00006f: 6a                         |     i32.add
 000070: 21 02                      |     local.set 2
 000072: 20 01                      |     local.get 1
 000074: 41 7f                      |     i32.const 4294967295
 000076: 6a                         |     i32.add
 000077: 22 01                      |     local.tee 1
 000079: 0d 00                      |     br_if 0
 00007b: 0b                         |   end
 00007c: 20 00                      |   local.get 0
 00007e: 41 01                      |   i32.const 1
 000080: 6a                         |   i32.add
 000081: 22 00                      |   local.tee 0
 000083: 41 0b                      |   i32.const 11
 000085: 47                         |   i32.ne
 000086: 0d 00                      |   br_if 0
 000088: 0b                         | end
 000089: 0b                         | end
</pre>

<pre>
void print(double);
&nbsp;
void <strong>nested_loops</strong>(void) {
    double x, y;
    for (y=1; y&lt;=10; y++) {
        for (x=1; x&lt;=10; x++) {
            print(x*y);
        }
    }
}
</pre>

<pre>
loop_5.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000050 func[1] <strong>&lt;nested_loops&gt;</strong>:
 000051: 01 7c                      | local[1] type=f64
 000053: 02 7f                      | local[2..3] type=i32
 000055: 01 7c                      | local[4] type=f64
 000057: 44 00 00 00 00 00 00 f0 3f | f64.const 0x1p+0
 000060: 21 00                      | local.set 0
 000062: 41 01                      | i32.const 1
 000064: 21 01                      | local.set 1
 000066: 03 40                      | loop
 000068: 41 0a                      |   i32.const 10
 00006a: 21 02                      |   local.set 2
 00006c: 44 00 00 00 00 00 00 f0 3f |   f64.const 0x1p+0
 000075: 21 03                      |   local.set 3
 000077: 03 40                      |   loop
 000079: 20 00                      |     local.get 0
 00007b: 20 03                      |     local.get 3
 00007d: a2                         |     f64.mul
 00007e: 10 80 80 80 80 00          |     call 0 &lt;env.print&gt;
 000084: 20 03                      |     local.get 3
 000086: 44 00 00 00 00 00 00 f0 3f |     f64.const 0x1p+0
 00008f: a0                         |     f64.add
 000090: 21 03                      |     local.set 3
 000092: 20 02                      |     local.get 2
 000094: 41 7f                      |     i32.const 4294967295
 000096: 6a                         |     i32.add
 000097: 22 02                      |     local.tee 2
 000099: 0d 00                      |     br_if 0
 00009b: 0b                         |   end
 00009c: 20 00                      |   local.get 0
 00009e: 44 00 00 00 00 00 00 f0 3f |   f64.const 0x1p+0
 0000a7: a0                         |   f64.add
 0000a8: 21 00                      |   local.set 0
 0000aa: 20 01                      |   local.get 1
 0000ac: 41 01                      |   i32.const 1
 0000ae: 6a                         |   i32.add
 0000af: 22 01                      |   local.tee 1
 0000b1: 41 0b                      |   i32.const 11
 0000b3: 47                         |   i32.ne
 0000b4: 0d 00                      |   br_if 0
 0000b6: 0b                         | end
 0000b7: 0b                         | end
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<p></p>




<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
void <strong>positive_case</strong>(void);
void <strong>negative_case</strong>(void);
void <strong>finish</strong>(void);
&nbsp;
void <strong>bar</strong>(int i) {
    if (i&gt;0) {
        goto positive;
    }
    positive_case();
    goto end;
positive:
    negative_case();
end:
    finish();
}
</pre>

<p></p>

<pre>
goto_1.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000079 func[3] &lt;bar&gt;:
 00007a: 02 40                      | block
 00007c: 02 40                      |   block
 00007e: 20 00                      |     local.get 0
 000080: 41 00                      |     i32.const 0
 000082: 4a                         |     i32.gt_s
 000083: 0d 00                      |     br_if 0
 000085: 10 80 80 80 80 00          |     call 0 &lt;env.positive_case&gt;
 00008b: 0c 01                      |     br 1
 00008d: 0b                         |   end
 00008e: 10 81 80 80 80 00          |   call 1 &lt;env.negative_case&gt;
 000094: 0b                         | end
 000095: 10 82 80 80 80 00          | call 2 &lt;env.finish&gt;
 00009b: 0b                         | end
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>

<pre>
void foo(void);
void bar(void);
void baz(void);
void bzz(void);
&nbsp;
void numeric_value(int x) {
    switch (x) {
        case 0:
            foo();
            break;
        case 1:
            bar();
            break;
        case 2:
            baz();
            break;
        case 3:
            bzz();
            break;
    }
}
</pre>

<pre>
switch_1.wasm:  file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
00006c func[4] &lt;numeric_value&gt;:
 00006d: 02 40                      | block
 00006f: 02 40                      |   block
 000071: 02 40                      |     block
 000073: 02 40                      |       block
 000075: 02 40                      |         block
 000077: 20 00                      |           local.get 0
 000079: 0e 04 00 01 02 03 04       |           br_table 0 1 2 3 4
 000080: 0b                         |         end
 000081: 10 80 80 80 80 00          |         call 0 &lt;env.foo&gt;
 000087: 0f                         |         return
 000088: 0b                         |       end
 000089: 10 81 80 80 80 00          |       call 1 &lt;env.bar&gt;
 00008f: 0f                         |       return
 000090: 0b                         |     end
 000091: 10 82 80 80 80 00          |     call 2 &lt;env.baz&gt;
 000097: 0f                         |     return
 000098: 0b                         |   end
 000099: 10 83 80 80 80 00          |   call 3 &lt;env.bzz&gt;
 00009f: 0b                         | end
 0000a0: 0b                         | end
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>

<pre>
void foo(void);
void bar(void);
void baz(void);
void bzz(void);
&nbsp;
void numeric_value(int x) {
    switch (x) {
        case 0:
            foo();
            break;
        case 1:
            bar();
            break;
        case 2:
            baz();
            break;
        default:
            bzz();
            break;
    }
}
</pre>

<pre>
switch_2.wasm:  file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
00006c func[4] &lt;numeric_value&gt;:
 00006d: 02 40                      | block
 00006f: 02 40                      |   block
 000071: 02 40                      |     block
 000073: 02 40                      |       block
 000075: 20 00                      |         local.get 0
 000077: 0e 03 00 01 02 03          |         br_table 0 1 2 3
 00007d: 0b                         |       end
 00007e: 10 80 80 80 80 00          |       call 0 &lt;env.foo&gt;
 000084: 0f                         |       return
 000085: 0b                         |     end
 000086: 10 81 80 80 80 00          |     call 1 &lt;env.bar&gt;
 00008c: 0f                         |     return
 00008d: 0b                         |   end
 00008e: 10 82 80 80 80 00          |   call 2 &lt;env.baz&gt;
 000094: 0f                         |   return
 000095: 0b                         | end
 000096: 10 83 80 80 80 00          | call 3 &lt;env.bzz&gt;
 00009c: 0b                         | end
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujícího článku</h2>

<p>Do specifikace WebAssembly byly později přidány i další rozšiřující
instrukce. Mezi tyto instrukce patří zejména instrukce umožňující provádět
vektorové operace (resp.&nbsp;přesněji řečeno SIMD operace). Překladače LLVM
tyto instrukce podporují a navíc pro ně máme přímou podporu i přímo
v&nbsp;Clangu (dokonce na několika úrovních). A právě s&nbsp;tímto (ve světě
videí a umělé inteligence) velmi důležitým rozšířením WebAssembly se budeme
zabývat v&nbsp;navazujícím článku.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Tabulka se všemi doposud popsanými instrukcemi</h2>

<p>Všechny instrukce WebAssembly, které jsme si až doposud popsali, jsou
vypsány v&nbsp;následující tabulce, kde jsou seřazeny podle svého operačního
kódu (tedy na základě hodnoty svého prvního bajtu). Aby bylo zřejmé, jaký
rozsah instrukčního souboru již byl popsán, obsahuje tabulka i (prozatím)
prázdné řádky:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Stručný popis</th></tr>
<tr><td>0x00</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x01</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x02</td><td>block</td><td>uloží na zásobník řízení toku (<i>control-flow stack</i>)</td></tr>
<tr><td>0x03</td><td>loop</td><td>návěští je nastavena na současnou pozici v&nbsp;bajtkódu a zapamatováno</td></tr>
<tr><td>0x04</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x05</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x06</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x07</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x08</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x09</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x0a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x0b</td><td>end</td><td>konec bloku nebo konec celé funkce</td></tr>
<tr><td>0x0c</td><td>br</td><td>provede se nepodmíněný skok</td></tr>
<tr><td>0x0d</td><td>br_if</td><td>pokud je na zásobníku uložena nenulová hodnota, provede se skok, jinak se neprovede žádná operace</td></tr>
<tr><td>0x0e</td><td>br_table</td><td>rozeskok mezi více bloky</td></tr>
<tr><td>0x0f</td><td>return</td><td>ukončení funkce s&nbsp;předáním návratových hodnot přes zásobník</td></tr>
<tr><td>0x10</td><td>call</td><td>zavolání funkce</td></tr>
<tr><td>0x11</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x12</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x13</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x14</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x15</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x16</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x17</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x18</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x19</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1a</td><td>drop</td><td>odstranění hodnoty nebo hodnot ze zásobníku operandů</td></tr>
<tr><td>0x1b</td><td>select</td><td>ze zásobníku přečte tři hodnoty, na základě výsledku podmínky vrátí na zásobník druhou nebo třetí hodnotu</td></tr>
<tr><td>0x1c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x20</td><td>local.get</td><td>uložení hodnoty lokální proměnné na zásobník</td></tr>
<tr><td>0x21</td><td>local.set</td><td>přenos hodnoty z&nbsp;vrcholu zásobníku do lokální proměnné</td></tr>
<tr><td>0x22</td><td>local.tee</td><td>kopie hodnoty z&nbsp;vrcholu zásobníku do lokální proměnné</td></tr>
<tr><td>0x23</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x24</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x25</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x26</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x27</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x28</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x29</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x30</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x31</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x32</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x33</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x34</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x35</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x36</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x37</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x38</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x39</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x41</td><td>i32.const</td><td>uložení 32bitové celočíselné konstanty na zásobník</td></tr>
<tr><td>0x42</td><td>i64.const</td><td>uložení 64bitové celočíselné konstanty na zásobník</td></tr>
<tr><td>0x43</td><td>f32.const</td><td>uložení 32bitové konstanty s&nbsp;plovoucí řádovou čárkou na zásobník</td></tr>
<tr><td>0x44</td><td>f64.const</td><td>uložení 64bitové konstanty s&nbsp;plovoucí řádovou čárkou na zásobník</td></tr>
<tr><td>0x44</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x45</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x46</td><td>i32.eq</td><td>porovnání operandů typu int32 na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x47</td><td>i32.ne</td><td>porovnání operandů typu int32 na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x48</td><td>i32.lt_s</td><td>porovnání operandů typu int32 na relaci &bdquo;menší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x49</td><td>i32.lt_u</td><td>porovnání operandů typu int32 na relaci &bdquo;menší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x4a</td><td>i32.gt_s</td><td>porovnání operandů typu int32 na relaci &bdquo;větší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x4b</td><td>i32.gt_u</td><td>porovnání operandů typu int32 na relaci &bdquo;větší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x4c</td><td>i32.le_s</td><td>porovnání operandů typu int32 na relaci &bdquo;menší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x4d</td><td>i32.le_u</td><td>porovnání operandů typu int32 na relaci &bdquo;menší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x4e</td><td>i32.ge_s</td><td>porovnání operandů typu int32 na relaci &bdquo;větší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x4f</td><td>i32.ge_u</td><td>porovnání operandů typu int32 na relaci &bdquo;větší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x50</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x51</td><td>i64.eq</td><td>porovnání operandů typu int64 na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x52</td><td>i64.ne</td><td>porovnání operandů typu int64 na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x53</td><td>i64.lt_s</td><td>porovnání operandů typu int64 na relaci &bdquo;menší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x54</td><td>i64.lt_u</td><td>porovnání operandů typu int64 na relaci &bdquo;menší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x55</td><td>i64.gt_s</td><td>porovnání operandů typu int64 na relaci &bdquo;větší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x56</td><td>i64.gt_u</td><td>porovnání operandů typu int64 na relaci &bdquo;větší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x57</td><td>i64.le_s</td><td>porovnání operandů typu int64 na relaci &bdquo;menší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x58</td><td>i64.le_u</td><td>porovnání operandů typu int64 na relaci &bdquo;menší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x59</td><td>i64.ge_s</td><td>porovnání operandů typu int64 na relaci &bdquo;větší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x5a</td><td>i64.ge_u</td><td>porovnání operandů typu int64 na relaci &bdquo;větší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x5b</td><td>f32.eq</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x5c</td><td>f32.ne</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x5d</td><td>f32.lt</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;menší než&ldquo;</td></tr>
<tr><td>0x5e</td><td>f32.gt</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td>0x5f</td><td>f32.le</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>0x60</td><td>f32.ge</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td>0x61</td><td>f64.eq</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x62</td><td>f64.ne</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x63</td><td>f64.lt</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;menší než&ldquo;</td></tr>
<tr><td>0x64</td><td>f64.gt</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td>0x65</td><td>f64.le</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>0x66</td><td>f64.ge</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td>0x67</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x68</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x69</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x6a</td><td>i32.add</td><td>součet dvou celých 32bitových hodnot</td></tr>
<tr><td>0x6b</td><td>i32.sub</td><td>rozdíl dvou celých 32bitových hodnot</td></tr>
<tr><td>0x6c</td><td>i32.mul</td><td>součin dvou celých 32bitových hodnot</td></tr>
<tr><td>0x6d</td><td>i32.div_s</td><td>podíl dvou celých 32bitových hodnot se znaménkem</td></tr>
<tr><td>0x6e</td><td>i32.div_u</td><td>podíl dvou celých 32bitových hodnot bez znaménka</td></tr>
<tr><td>0x6f</td><td>i32.rem_s</td><td>zbytek po dělení dvou celých 32bitových hodnot se znaménkem</td></tr>
<tr><td>0x70</td><td>i32.rem_u</td><td>zbytek po dělení dvou celých 32bitových hodnot bez znaménka</td></tr>
<tr><td>0x71</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x72</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x73</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x74</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x75</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x76</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x77</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x78</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x79</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7c</td><td>i64.add</td><td>součet dvou celých 64bitových hodnot</td></tr>
<tr><td>0x7d</td><td>i64.sub</td><td>rozdíl dvou celých 64bitových hodnot</td></tr>
<tr><td>0x7e</td><td>i64.mul</td><td>součin dvou celých 64bitových hodnot</td></tr>
<tr><td>0x7f</td><td>i64.div_s</td><td>podíl dvou celých 64bitových hodnot se znaménkem</td></tr>
<tr><td>0x80</td><td>i64.div_u</td><td>podíl dvou celých 64bitových hodnot bez znaménka</td></tr>
<tr><td>0x81</td><td>i64.rem_s</td><td>zbytek po dělení dvou celých 64bitových hodnot se znaménkem</td></tr>
<tr><td>0x82</td><td>i64.rem_u</td><td>zbytek po dělení dvou celých 64bitových hodnot bez znaménka</td></tr>
<tr><td>0x83</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x84</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x85</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x86</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x87</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x88</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x89</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8b</td><td>f32.abs</td><td>absolutní hodnota typu <i>single/float</i></td></tr>
<tr><td>0x8c</td><td>f32.neg</td><td>otočení znaménka u hodnoty typu <i>single/float</i></td></tr>
<tr><td>0x8d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x90</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x91</td><td>f32.sqrt</td><td>druhá odmocnina z&nbsp;hodnoty typu <i>single/float</i></td></tr>
<tr><td>0x92</td><td>f32.add</td><td>součet dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x93</td><td>f32.sub</td><td>rozdíl dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x94</td><td>f32.mul</td><td>součin dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x95</td><td>f32.div</td><td>podíl dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x96</td><td>f32.min</td><td>součet dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x97</td><td>f32.max</td><td>součet dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x98</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x99</td><td>f64.abs</td><td>absolutní hodnota typu <i>double</i></td></tr>
<tr><td>0x9a</td><td>f64.neg</td><td>otočení znaménka u hodnoty typu <i>double</i></td></tr>
<tr><td>0x9b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9f</td><td>f64.sqrt</td><td>druhá odmocnina z&nbsp;hodnoty typu <i>double</i></td></tr>
<tr><td>0xa0</td><td>f64.add</td><td>součet dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa1</td><td>f64.sub</td><td>rozdíl dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa2</td><td>f64.mul</td><td>součin dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa3</td><td>f64.div</td><td>podíl dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa4</td><td>f64.min</td><td>součet dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa5</td><td>f64.max</td><td>součet dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xa7</td><td>i32.wrap_i64</td><td>de facto opak instrukce <strong>extend</strong>, převod hodnoty se ztrátou informace 64 na 32 bitů</td></tr>
<tr><td>0xa8</td><td>i32.trunc_f32_s</td><td>převod hodnoty typu <i>float</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xa9</td><td>i32.trunc_f32_u</td><td>převod hodnoty typu <i>float</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xaa</td><td>i32.trunc_f64_s</td><td>převod hodnoty typu <i>double</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xab</td><td>i32.trunc_f64_u</td><td>převod hodnoty typu <i>double</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xac</td><td>i64.extend_i32_s</td><td>znaménkové rozšíření hodnoty (32 na 64 bitů)</td></tr>
<tr><td>0xad</td><td>i64.extend_i32_u</td><td>bezznaménkové rozšíření hodnoty (32 na 64 bitů)</td></tr>
<tr><td>0xae</td><td>i64.trunc_f32_s</td><td>převod hodnoty typu <i>float</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xaf</td><td>i64.trunc_f32_u</td><td>převod hodnoty typu <i>float</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xb0</td><td>i64.trunc_f64_s</td><td>převod hodnoty typu <i>double</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xb1</td><td>i64.trunc_f64_u</td><td>převod hodnoty typu <i>double</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xb2</td><td>f32.convert_i32_s</td><td>konverze celého čísla se znaménkem (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb3</td><td>f32.convert_i32_u</td><td>konverze celého čísla bez znaménka (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb4</td><td>f32.convert_i64_s</td><td>konverze celého čísla se znaménkem (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb5</td><td>f32.convert_i64_u</td><td>konverze celého čísla bez znaménka (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb6</td><td>f32.demote_f64</td><td>převod hodnoty typu <i>double</i> na typ <i>float</i></td></tr>
<tr><td>0xb7</td><td>f64.convert_i32_s</td><td>konverze celého čísla se znaménkem (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xb8</td><td>f64.convert_i32_u</td><td>konverze celého čísla bez znaménka (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xb9</td><td>f64.convert_i64_s</td><td>konverze celého čísla se znaménkem (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xba</td><td>f64.convert_i64_u</td><td>konverze celého čísla bez znaménka (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xbb</td><td>f64.promote_f32</td><td>převod hodnoty typu <i>float</i> na typ <i>double</i></td></tr>
<tr><td>0xbc</td><td>i32.reinterpret_f32</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xbd</td><td>i64.reinterpret_f64</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xbe</td><td>f32.reinterpret_i32</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xbf</td><td>f64.reinterpret_i64</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xc0</td><td>i32.extend8_s</td><td>znaménkové rozšíření hodnoty z&nbsp;8 bitů na 32 bitů</td></tr>
<tr><td>0xc1</td><td>i32.extend16_s</td><td>znaménkové rozšíření hodnoty ze 16 bitů na 32 bitů</td></tr>
<tr><td>0xc2</td><td>i64.extend8_s</td><td>znaménkové rozšíření hodnoty z&nbsp;8 bitů na 64 bitů</td></tr>
<tr><td>0xc3</td><td>i64.extend16_s</td><td>znaménkové rozšíření hodnoty ze 16 bitů na 64 bitů</td></tr>
<tr><td>0xc4</td><td>i64.extend32_s</td><td>znaménkové rozšíření hodnoty z&nbsp;8 bitů na 64 bitů</td></tr>
<tr><td>0xc5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xca</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcc</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcd</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xce</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcf</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd0</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd3</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd4</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xda</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdc</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdd</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xde</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdf</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe0</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe3</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe4</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xea</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xeb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xec</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xed</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xee</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xef</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf0</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf3</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf4</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfa</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfc</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfd</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfe</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xff</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Compiling C to WebAssembly without Emscripten<br />
<a href="https://surma.dev/things/c-to-webassembly/">https://surma.dev/things/c-to-webassembly/</a>
</li>

<li>Web Assemply: Text Format<br />
<a href="https://webassembly.github.io/spec/core/text/index.html">https://webassembly.github.io/spec/core/text/index.html</a>
</li>

<li>WebAssembly: Binary Format<br />
<a href="https://webassembly.github.io/spec/core/binary/index.html">https://webassembly.github.io/spec/core/binary/index.html</a>
</li>

<li>WebAssembly<br />
<a href="https://webassembly.org/">https://webassembly.org/</a>
</li>

<li>WebAssembly na Wiki Golangu<br />
<a href="https://github.com/golang/go/wiki/WebAssembly">https://github.com/golang/go/wiki/WebAssembly</a>
</li>

<li>The future of WebAssembly - A look at upcoming features and proposals<br />
<a href="https://blog.scottlogic.com/2018/07/20/wasm-future.html">https://blog.scottlogic.com/2018/07/20/wasm-future.html</a>
</li>

<li>WebAssembly Design<br />
<a href="https://github.com/WebAssembly/design">https://github.com/WebAssembly/design</a>
</li>

<li>Využití WebAssembly z programovacího jazyka Go <br />
<a href="https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/</a>
</li>

<li>WebAssembly slibuje podstatné zrychlení webů, konec JavaScriptu se ale nekoná<br />
<a href="https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/">https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>Top 23 WASM Open-Source Projects<br />
<a href="https://www.libhunt.com/topic/wasm">https://www.libhunt.com/topic/wasm</a>
</li>

<li>Made with WebAssembly<br />
<a href="https://madewithwebassembly.com/">https://madewithwebassembly.com/</a>
</li>

<li>The Top 1,790 Wasm Open Source Projects on Github<br />
<a href="https://awesomeopensource.com/projects/wasm">https://awesomeopensource.com/projects/wasm</a>
</li>

<li>Sanspiel<br />
<a href="https://sandspiel.club/">https://sandspiel.club/</a>
</li>

<li>Painting on HTML5 Canvas with Rust WASM<br />
<a href="https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html">https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html</a>
</li>

<li>Writing WebAssembly By Hand<br />
<a href="https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html">https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html</a>
</li>

<li>WebAssembly Specification<br />
<a href="https://webassembly.github.io/spec/core/index.html">https://webassembly.github.io/spec/core/index.html</a>
</li>

<li>Index of Instructions<br />
<a href="https://webassembly.github.io/spec/core/appendix/index-instructions.html">https://webassembly.github.io/spec/core/appendix/index-instructions.html</a>
</li>

<li>The WebAssembly Binary Toolkit<br />
<a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a>
</li>

<li>Will WebAssembly replace JavaScript? Or Will WASM Make JavaScript More Valuable in Future?<br />
<a href="https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e">https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e</a>
</li>

<li>Webassembly as 32bit and 64bit<br />
<a href="https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit">https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit</a>
</li>

<li>Portability<br />
<a href="https://webassembly.org/docs/portability/">https://webassembly.org/docs/portability/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Nástroj objdump: švýcarský nožík pro vývojáře<br />
<a href="https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/">https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/</a>
</li>

<li>Getting Started: Building and Running Clang<br />
<a href="https://clang.llvm.org/get_started.html">https://clang.llvm.org/get_started.html</a>
</li>

<li>Clang: a C language family frontend for LLVM<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Scheduling LLVM Passes with the New Pass Manager<br />
<a href="https://stephenverderame.github.io/blog/scheduling_llvm/">https://stephenverderame.github.io/blog/scheduling_llvm/</a>
</li>

<li>C data types<br />
<a href="https://en.wikipedia.org/wiki/C_data_types">https://en.wikipedia.org/wiki/C_data_types</a>
</li>

<li>WebAssembly data types<br />
<a href="https://webassembly.github.io/spec/core/syntax/types.html">https://webassembly.github.io/spec/core/syntax/types.html</a>
</li>

<li>WebAssembly Opcodes<br />
<a href="https://pengowray.github.io/wasm-ops/">https://pengowray.github.io/wasm-ops/</a>
</li>

<li>Advanced tools (for WebAssembly)<br />
<a href="https://webassembly.org/getting-started/advanced-tools/">https://webassembly.org/getting-started/advanced-tools/</a>
</li>

<li>Binaryen<br />
<a href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a>
</li>

<li>Using SIMD with WebAssembly<br />
<a href="https://emscripten.org/docs/porting/simd.html">https://emscripten.org/docs/porting/simd.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

