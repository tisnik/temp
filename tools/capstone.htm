<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Framework Capstone aneb univerzální disassembler</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Framework Capstone aneb univerzální disassembler</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku, jenž navazuje na článek o frameworku Keystone, se seznámíme s frameworkem Capstone. Jedná se o univerzální disassembler podporující všechny mainstreamové architektury, jenž je implementován formou knihovny a je možné ho volat z různých programovacích jazyků.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Framework Capstone aneb univerzální disassembler</a></p>
<p><a href="#k02">2. Základní způsob použití frameworku Capstone: disassembling obsahu binárního souboru</a></p>
<p><a href="#k03">3. Demonstrační příklad</a></p>
<p><a href="#k04">4. Výpis operačních kódů instrukcí</a></p>
<p><a href="#k05">5. Demonstrační příklad</a></p>
<p><a href="#k06">6. Explicitní specifikace bázové adresy kódu (org)</a></p>
<p><a href="#k07">7. Demonstrační příklad</a></p>
<p><a href="#k08">8. Binární kód uložený v&nbsp;souboru od zadaného nenulového offsetu</a></p>
<p><a href="#k09">9. Demonstrační příklady: korektní a nekorektní varianty</a></p>
<p><a href="#k10">10. Disassembling binárního souboru s&nbsp;nativním kódem pro odlišnou architekturu CPU</a></p>
<p><a href="#k11">*** 11. Kombinace Keystone+Capstone</a></p>
<p><a href="#k12">*** 12. Kód v&nbsp;assembleru pro platformu x86-64</a></p>
<p><a href="#k13">*** 13. Explicitní změna bázové adresy</a></p>
<p><a href="#k14">*** 14. Kód v&nbsp;assembleru pro 32bitovou platformu ARM</a></p>
<p><a href="#k15">*** 15. Využití instrukční sady ARM Thumb</a></p>
<p><a href="#k16">*** 16. Přepis příkladů pro architekturu AArch64</a></p>
<p><a href="#k17">*** 17. Další možnosti poskytované nástrojem Capstone</a></p>
<p><a href="#k18">*** 18. Závěrečné zhodnocení</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Framework Capstone aneb univerzální disassembler</h2>

<p>V&nbsp;dnešním článku, jenž navazuje <a href="">na předchozí článek o frameworku Keystone</a>, se seznámíme s&nbsp;frameworkem nazvaným <i>Capstone</i>. Zatímco výše zmíněný framework <i>Keystone</i> je univerzálním assemblerem, jedná se v&nbsp;případě frameworku <i>Capstone</i> o univerzální disassembler, který podporuje všechny v&nbsp;současnosti mainstreamové architektury (x86, x86-64, 32bitový ARM, AArch64 atd.) a je implementován formou nativní knihovny, kterou je možné volat z&nbsp;různých programovacích jazyků. Oba zmíněné frameworky, tedy jak Capstone, tak i Keystone, lze přitom používat společně. Příkladem mohou být systémy, které nejprve provedou disassembling vybraného binárního bloku dat s&nbsp;úpravou kódu v&nbsp;assembleru a s&nbsp;jeho následným překladem zpět do nativního binárního kódu.</p>

<p>Možný a podporovaný je pochopitelně i opačný přístup, tj.&nbsp;překlad kódu
napsaného v&nbsp;assembleru do nativního kódu s&nbsp;jeho následným zpětným
překladem do assembleru (s&nbsp;doplněním informací o způsobu zakódování
jednotlivých strojových instrukcí). Tento přístup je možné použít například při
výuce a ukážeme si ho na několika demonstračních příkladech, kde porovnáme
podobný kód (dvojice vnořených programových smyček) zapsaný pro architekturu
x86(64), klasický 32bitový ARM, 32bitový ARM s&nbsp;instrukční sadou
<i>Thumb</i> a konečně 64bitovou architekturu AArch64.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní způsob použití frameworku Capstone: disassembling obsahu binárního souboru</h2>

<p>Podívejme se nejprve na základní způsob využití frameworku <i>Capstone</i>.
Budeme se snažit o zpětný překlad (<i>disassembling</i>) nativního binárního
kódu, který vznikl překladem zdrojového kódu v&nbsp;assembleru pro platformu
x86-64 (resp.&nbsp;přesněji řečeno pro platformu x86 v&nbsp;64bitovém režimu).
Konkrétně se jedná o sekvenci strojových instrukcí, které realizují dvojici
vnořených programových smyček. V&nbsp;assembleru vypadá zápis těchto
programových smyček následovně:</p>

<pre>
    MOV EBX, 10
<strong>OUTER_LOOP</strong>:
    MOV EAX, 100
<strong>INNER_LOOP</strong>:
    DEC EAX
    JNZ <strong>INNER_LOOP</strong>
    DEC EBX
    JNZ <strong>OUTER_LOOP</strong>
</pre>

<p>Překladem (konkrétně překladem s&nbsp;využitím minule popsaného assembleru
<i>Keystone</i>) vznikl binární soubor nazvaný &bdquo;loops.bin&ldquo; o délce
osmnácti bajtů. Obsah tohoto souboru je následující:</p>

<pre>
$ <strong>od -tx1 loops.bin</strong>
&nbsp;
0000000 bb 0a 00 00 00 b8 64 00 00 00 ff c8 75 fc ff cb
0000020 75 f3
0000022
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstrační příklad</h2>

<p>A právě obsah binárního souboru představeného v&nbsp;rámci <a
href="#k02">předchozí kapitoly</a> se budeme snažit zpětně přeložit do
assembleru s&nbsp;využitím frameworku <i>Capstone</i>. K&nbsp;tomuto účelu
poslouží následující skript, jenž obsah binárního souboru načte a následně se
pokusí o zpětný překlad. Povšimněte si, že při zpětném překladu musíme (vcelku
logicky) určit architekturu a taktéž režim &ndash; jinými slovy jak instrukční
sadu, tak i způsob kódování instrukcí (tyto informace není možné nijak
automaticky odvodit):</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from capstone import Cs, CS_ARCH_X86, CS_MODE_64
&nbsp;
&nbsp;
<i># otevřít binární soubor a přečíst jeho obsah</i>
with open("loops.bin", "rb") as fin:
    code = fin.read()
&nbsp;
<i># disassembling obsahu binárního souboru</i>
md = <strong>Cs(CS_ARCH_X86, CS_MODE_64)</strong>
&nbsp;
<i># vypsat podrobnější informace o každé instrukci</i>
for i in <strong>md.disasm(code, 0x0000):</strong>
    <i># výpis informací o instrukci</i>
    print("0x{:02x}:\t{:s}\t{:s}".format(<strong>i.address</strong>, <strong>i.mnemonic</strong>, <strong>i.op_str</strong>))
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64.py</a>.</div></p>

<p>Z&nbsp;výsledků vypsaných výše uvedeným skriptem je patrné, že máme
k&nbsp;dispozici prakticky všechny důležité informace o strojových instrukcích
&ndash; jejich adresu, jméno instrukce i seznam operandů (pokud se jedná o
instrukci s&nbsp;operandem či s&nbsp;operandy):</p>

<pre>
0x00:   mov     ebx, 0xa
0x05:   mov     eax, 0x64
0x0a:   dec     eax
0x0c:   jne     0xa
0x0e:   dec     ebx
0x10:   jne     5
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpis operačních kódů instrukcí</h2>

<p>Naprostá většina v&nbsp;současnosti používaných disassemblerů dokáže kromě
jména instrukce a seznamu operandů vypsat i bajty obsahující operační kód
instrukce i zakódované operandy. Příkladem může být nástroj
<strong>objdump</strong>, s&nbsp;nímž jsme se již setkali minule a jenž dokáže
provést například tuto operaci:</p>

<pre>
$ <strong>objdump -b binary -D -m i386:x86-64 -M intel loops.bin &gt; loops_dump.asm</strong>
&nbsp;
loops.bin:     file format binary
&nbsp;
&nbsp;
Disassembly of section .data:
&nbsp;
0000000000000000 &lt;.data&gt;:
   0:   bb 0a 00 00 00          mov    ebx,0xa
   5:   b8 64 00 00 00          mov    eax,0x64
   a:   ff c8                   dec    eax
   c:   75 fc                   jne    0xa
   e:   ff cb                   dec    ebx
  10:   75 f3                   jne    0x5
</pre>

<p>I tyto informace nám pochopitelně framework <i>Capstone</i> dává
k&nbsp;dispozici, protože při procházení jednotlivými instrukcemi jsou
v&nbsp;atributu <strong>bytes</strong> uložené jednotlivé bajty reprezentující
instrukci v&nbsp;nativním kódu. Hodnoty těchto bajtů je pouze nutné převést do
čitelné podoby. Je zvykem hodnoty těchto bajtů vypisovat v&nbsp;hexadecimálním
tvaru, takže použijeme standardní metodu <strong>hex()</strong>, která převod
sekvence bajtů do řetězce s&nbsp;hexadecimálními hodnotami provede za nás, a to
i s&nbsp;využitím oddělovače:</p>

<pre>
dump = <strong>i.bytes.hex(" ")</strong>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstrační příklad</h2>

<p>Skript <a href="#k03">ze třetí kapitoly</a> upravíme takovým způsobem, aby
se kromě adresy, mnemotechnické zkratky instrukce a operandů instrukce vypsaly
i hodnoty bajtů reprezentujících instrukci v&nbsp;nativním kódu. Délka
instrukce v&nbsp;nativním strojovém kódu sice není obecně omezena, ovšem skript
kvůli jednoduchosti počítá s&nbsp;tím, že se bude jednat o maximálně šest bajtů
(i delší instrukce se pochopitelně vypíše, ovšem jednotlivé sloupce již
v&nbsp;tomto případě nebudou zarovnány pěkně pod sebou):</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from capstone import Cs, CS_ARCH_X86, CS_MODE_64
&nbsp;
&nbsp;
<i># otevřít binární soubor a přečíst jeho obsah</i>
with open("loops.bin", "rb") as fin:
    code = fin.read()
&nbsp;
<i># disassembling obsahu binárního souboru</i>
md = <strong>Cs(CS_ARCH_X86, CS_MODE_64)</strong>
&nbsp;
<i># vypsat podrobnější informace o každé instrukci</i>
for i in <strong>md.disasm(code, 0x0000):</strong>
    <i># převod pole bajtů na řetězec s hexa hodnotami</i>
    dump = <strong>i.bytes.hex(" ")</strong>
&nbsp;
    <i># výpis informací o instrukci</i>
    print("0x{:02x}:\t{:20s}\t{:s}\t{:s}".format(<strong>i.address</strong>, <strong>dump</strong>, <strong>i.mnemonic</strong>, <strong>i.op_str</strong>))
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_bytes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_bytes.py</a>.</div></p>

<p>Získaný výsledek již vypadá (alespoň podle mého skromného názoru) značně
profesionálně:</p>

<pre>
0x00:   bb 0a 00 00 00          mov     ebx, 0xa
0x05:   b8 64 00 00 00          mov     eax, 0x64
0x0a:   ff c8                   dec     eax
0x0c:   75 fc                   jne     0xa
0x0e:   ff cb                   dec     ebx
0x10:   75 f3                   jne     5
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Explicitní specifikace bázové adresy kódu (org)</h2>

<p>V&nbsp;obou předchozích demonstračních příkladech jste si mohli povšimnout,
že při volání metody <strong>md.disassemble()</strong> se kromě sekvence bajtů
představujících nativní (strojový) kód do této metody ve druhém parametru
předává i celočíselná konstanta 0x0000. Modifikací této konstanty je možné
změnit počáteční adresu celého bloku instrukcí; jedná se tedy o (i když ne
zcela přesnou) obdobu direktivy <strong>.org</strong>, kterou známe
z&nbsp;běžných assemblerů, například z&nbsp;<i>GNU Assembleru</i> (viz
například <a
href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html#SEC112">https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html#SEC112</a>).
V&nbsp;případě, že hodnotu této konstanty změníme, pochopitelně dojde jak ke
změně adres instrukcí zobrazených v&nbsp;prvním sloupci, tak i
k&nbsp;modifikaci adres relativních skoků (a podmíněné skoky se typicky
překládají právě na relativní skoky, což mj.&nbsp;umožňuje generování
přemístitelného strojového kódu).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstrační příklad</h2>

<p>Následující skript se od skriptu předchozího liší jen v&nbsp;maličkosti
&ndash; namísto offsetu 0x0000 metody <strong>Cs.disasm()</strong> se této
metodě předá offset 0x1234:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from capstone import Cs, CS_ARCH_X86, CS_MODE_64
&nbsp;
&nbsp;
<i># otevřít binární soubor a přečíst jeho obsah</i>
with open("loops.bin", "rb") as fin:
    code = fin.read()
&nbsp;
<i># disassembling obsahu binárního souboru</i>
md = Cs(CS_ARCH_X86, CS_MODE_64)
&nbsp;
<i># vypsat podrobnější informace o každé instrukci</i>
for i in <strong>md.disasm(code, 0x1234)</strong>:
    <i># převod pole bajtů na řetězec s hexa hodnotami</i>
    dump = i.bytes.hex(" ")
&nbsp;
    <i># výpis informací o instrukci</i>
    print("0x{:02x}:\t{:20s}\t{:s}\t{:s}".format(i.address, dump, i.mnemonic, i.op_str))
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_A.py</a>.</div></p>

<p>Výsledek bude ovšem v&nbsp;tomto případě zcela odlišný, protože se budou
odlišovat například i cílové adresy (relativních) skoků:</p>

<pre>
0x1234: bb 0a 00 00 00          mov     ebx, 0xa
0x1239: b8 64 00 00 00          mov     eax, 0x64
0x123e: ff c8                   dec     eax
0x1240: 75 fc                   jne     <strong>0x123e</strong>
0x1242: ff cb                   dec     ebx
0x1244: 75 f3                   jne     <strong>0x1239</strong>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Binární kód uložený v&nbsp;souboru od zadaného nenulového offsetu</h2>

<p>Nyní si (poněkud uměle) připravíme soubor s&nbsp;binárním obsahem, který
bude nejprve obsahovat obecně náhodná data (resp.&nbsp;v&nbsp;našem případě
nuly, ale může se jednat i o jiné hodnoty) a teprve poté v&nbsp;něm bude
umístěn kód nativních instrukcí vzniklých překladem assemblerem
<i>Capstone</i>. Jak lze takový soubor vytvořit? Cest je mnoho, můžeme
například použít například základní nástroje Linuxu. Nejdříve si necháme
vygenerovat binární soubor obsahující tisíc nulových hodnot:</p>

<pre>
$ <strong>truncate -s 1000 zeros</strong>
</pre>

<p>Výsledkem předchozího příkazu bude soubor nazvaný &bdquo;zeros&ldquo; o
délce přesně 1000 bajtů:</p>

<pre>
$ <strong>ls -l zeros</strong>
&nbsp;
-rw-rw-r-- 1 ptisnovs ptisnovs 1000 Dec 31 11:07 zeros
</pre>

<p>Následně jednoduše spojíme soubor &bdquo;zeros&ldquo; s&nbsp;binárním
souborem &bdquo;loops.bin&ldquo;, který byl analyzován v&nbsp;rámci předchozích
kapitol:</p>

<pre>
$ <strong>cat zeros loops.bin &gt; loops_x.bin</strong>
</pre>

<p>Výsledkem by měl být soubor &bdquo;loops_x.bin&ldquo; o délce 1018
bajtů:</p>

<pre>
$ <strong>ls -l loops_x.bin </strong>
&nbsp;
-rw-rw-r-- 1 ptisnovs ptisnovs 1018 Dec 27 09:43 loops_x.bin
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstrační příklady: korektní a nekorektní varianty</h2>

<p>Nejprve se pokusme takto vzniklý binární soubor přeložit běžným způsobem,
tedy i s&nbsp;ignorováním faktu, že prvních tisíc bajtů ve skutečnosti žádné
instrukce neobsahuje:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from capstone import Cs, CS_ARCH_X86, CS_MODE_64
&nbsp;
<i># otevřít binární soubor a přečíst jeho obsah</i>
with open("loops_x.bin", "rb") as fin:
    code = fin.read()
&nbsp;
<i># disassembling obsahu binárního souboru</i>
md = Cs(CS_ARCH_X86, CS_MODE_64)
&nbsp;
<i># vypsat podrobnější informace o každé instrukci</i>
for i in md.disasm(code, 0x0000):
    <i># převod pole bajtů na řetězec s hexa hodnotami</i>
    dump = i.bytes.hex(" ")
&nbsp;
    <i># výpis informací o instrukci</i>
    print("0x{:02x}:\t{:20s}\t{:s}\t{:s}".format(i.address, dump, i.mnemonic, i.op_str))
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_B.py</a>.</div></p>

<p>Výsledek bude pochopitelně obsahovat nekorektní informace a až na konci
nalezneme korektní sekvenci instrukcí:</p>

<pre>
0x00:   00 00                   add     byte ptr [rax], al
0x02:   00 00                   add     byte ptr [rax], al
0x04:   00 00                   add     byte ptr [rax], al
0x06:   00 00                   add     byte ptr [rax], al
0x08:   00 00                   add     byte ptr [rax], al
0x0a:   00 00                   add     byte ptr [rax], al
0x0c:   00 00                   add     byte ptr [rax], al
0x0e:   00 00                   add     byte ptr [rax], al
0x10:   00 00                   add     byte ptr [rax], al
0x12:   00 00                   add     byte ptr [rax], al
0x14:   00 00                   add     byte ptr [rax], al
...
...
...
0x3e6:  00 00                   add     byte ptr [rax], al
0x3e8:  bb 0a 00 00 00          mov     ebx, 0xa
0x3ed:  b8 64 00 00 00          mov     eax, 0x64
0x3f2:  ff c8                   dec     eax
0x3f4:  75 fc                   jne     0x3f2
0x3f6:  ff cb                   dec     ebx
0x3f8:  75 f3                   jne     0x3ed
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je stejně dobře možné, že
se disassembler vůbec do začátku instrukcí &bdquo;netrefí&ldquo; (například
kdyby nul bylo 999 nebo naopak 1001) a celý výsledek bude nekorektní.</div></p>

<p>Řešení tohoto problémku je ve skutečnosti jednoduché &ndash; oněch 1000
bajtů musíme explicitně přeskočit a disassembleru předat pouze vybranou
podsekvenci bajtů.  Přeskočení lze realizovat buď operací <i>seek</i> nad
souborem, nebo (což je méně efektivní) načtením celého binárního souboru
následovaného operací <i>slice</i>:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from capstone import Cs, CS_ARCH_X86, CS_MODE_64
&nbsp;
<i># pozice v binárním souboru, od níž jsou instrukce uloženy</i>
OFFSET = 1000
&nbsp;
<i># otevřít binární soubor a přečíst jeho obsah</i>
with open("loops_x.bin", "rb") as fin:
    code = fin.read()
    <strong>code = code[OFFSET:]</strong>
&nbsp;
<i># disassembling obsahu binárního souboru</i>
md = Cs(CS_ARCH_X86, CS_MODE_64)
&nbsp;
<i># vypsat podrobnější informace o každé instrukci</i>
for i in md.disasm(code, 0x0000):
    <i># převod pole bajtů na řetězec s hexa hodnotami</i>
    dump = i.bytes.hex(" ")
&nbsp;
    <i># výpis informací o instrukci</i>
    print("0x{:02x}:\t{:20s}\t{:s}\t{:s}".format(i.address, dump, i.mnemonic, i.op_str))
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_C.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_C.py</a>.</div></p>

<p>Výsledek:</p>

<pre>
0x00:   bb 0a 00 00 00          mov     ebx, 0xa
0x05:   b8 64 00 00 00          mov     eax, 0x64
0x0a:   ff c8                   dec     eax
0x0c:   75 fc                   jne     0xa
0x0e:   ff cb                   dec     ebx
0x10:   75 f3                   jne     5
</pre>

<p>popř.&nbsp;s&nbsp;korektním offsetem (začátkem instrukcí) nastaveným na
1000:</p>

<pre>
0x3e8:  bb 0a 00 00 00          mov     ebx, 0xa
0x3ed:  b8 64 00 00 00          mov     eax, 0x64
0x3f2:  ff c8                   dec     eax
0x3f4:  75 fc                   jne     0x3f2
0x3f6:  ff cb                   dec     ebx
0x3f8:  75 f3                   jne     0x3ed
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Disassembling binárního souboru s&nbsp;nativním kódem pro odlišnou architekturu CPU</h2>

<p>Vzhledem k&nbsp;tomu, že <i>Capstone</i> je (či měl by být) univerzálním
disassemblerem, dokáže zpětně překládat i nativní kód určený pro odlišné
architektury mikroprocesorů. Podívejme se na velmi jednoduchý příklad.
Překladem následujícího céčkového kódu:</p>

<pre>
int add(int x, int y) {
    return x+y;
}
</pre>

<p>na <a
href="https://www.root.cz/clanky/procesory-s-architekturou-risc-v-pracovnich-stanicich-a-serverech/">32bitové
platformě MIPS</a> získáme tento (zcela neoptimalizovaný) kód:</p>

<pre>
add:
 addiu	sp,sp,-8
 sw	s8,4(sp)
 move	s8,sp
 sw	a0,8(s8)
 sw	a1,12(s8)
 lw	v1,8(s8)
 lw	v0,12(s8)
 nop
 addu	v0,v1,v0
 move	sp,s8
 lw	s8,4(sp)
 addiu	sp,sp,8
 jr	ra
 nop
</pre>

<p>Nativní kód je uložen do binárního souboru nazvaného &bdquo;mips.bin&ldquo;
o délce šedesáti bajtů:</p>

<pre>
$ <strong>od -tx1 mips.bin </strong>
&nbsp;
0000000 f8 ff bd 27 04 00 be af 25 f0 a0 03 08 00 c4 af
0000020 0c 00 c5 af 08 00 c3 8f 0c 00 c2 8f 00 00 00 00
0000040 21 10 62 00 25 e8 c0 03 04 00 be 8f 08 00 bd 27
0000060 08 00 e0 03 00 00 00 00 00 00 00 00
0000074
</pre>

<p>Pokusme se nyní o zpětný překlad. Povšimněte si, že je opět nutné
specifikovat jak architekturu CPU, tak i režim:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from capstone import Cs, <strong>CS_ARCH_MIPS</strong>, <strong>CS_MODE_MIPS32</strong>
&nbsp;
&nbsp;
<i># otevřít binární soubor a přečíst jeho obsah</i>
with open("mips.bin", "rb") as fin:
    code = fin.read()
&nbsp;
<i># disassembling obsahu binárního souboru</i>
md = <strong>Cs(CS_ARCH_MIPS, CS_MODE_MIPS32)</strong>
&nbsp;
<i># vypsat podrobnější informace o každé instrukci</i>
for i in md.disasm(code, 0x0000):
    # výpis informací o instrukci
    print("0x{:02x}:\t{:s}\t{:s}".format(i.address, i.mnemonic, i.op_str))
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_mips.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_mips.py</a>.</div></p>

<p>Výsledek bude vypadat následovně &ndash; skutečně jsme tedy dokázali provést
zpětný překlad i na zcela odlišné platformě, a to bez nutnosti instalace
dalších nástrojů:</p>

<pre>
0x00:   addiu   $sp, $sp, -8
0x04:   sw      $fp, 4($sp)
0x08:   move    $fp, $sp
0x0c:   sw      $a0, 8($fp)
0x10:   sw      $a1, 0xc($fp)
0x14:   lw      $v1, 8($fp)
0x18:   lw      $v0, 0xc($fp)
0x1c:   nop
0x20:   addu    $v0, $v1, $v0
0x24:   move    $sp, $fp
0x28:   lw      $fp, 4($sp)
0x2c:   addiu   $sp, $sp, 8
0x30:   jr      $ra
0x34:   nop
0x38:   nop
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kombinace Keystone+Capstone</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Kód v&nbsp;assembleru pro platformu x86-64</h2>

<pre>
<i># import všech symbolů assembleru použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_64, KsError
&nbsp;
<i># import všech symbolů disassembleru použitých ve skriptu</i>
from capstone import Cs, CS_ARCH_X86, CS_MODE_64
&nbsp;
&nbsp;
<i># instrukce, které se mají přeložit assemblerem</i>
CODE = """
    MOV EBX, 10
OUTER_LOOP:
    MOV EAX, 100
INNER_LOOP:
    DEC EAX
    JNZ INNER_LOOP
    DEC EBX
    JNZ OUTER_LOOP
"""
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = Ks(KS_ARCH_X86, KS_MODE_64)
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = ks.asm(CODE)
&nbsp;
    <i># disassembling binární sekvence kódů</i>
    md = Cs(CS_ARCH_X86, CS_MODE_64)
&nbsp;
    <i># vypsat podrobnější informace o každé instrukci</i>
    for i in md.disasm(bytes(encoding), 0x0000):
        <i># převod pole bajtů na řetězec s hexa hodnotami</i>
        dump = i.bytes.hex(" ")
&nbsp;
        <i># výpis informací o instrukci</i>
        print("0x{:02x}:\t{:20s}\t{:s}\t{:s}".format(i.address, dump, i.mnemonic, i.op_str))
&nbsp;
except KsError as e:
    print("ERROR: %s" % e)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Explicitní změna bázové adresy</h2>

<pre>
# import všech symbolů assembleru použitých ve skriptu
from keystone import Ks, KS_ARCH_X86, KS_MODE_64, KsError
&nbsp;
# import všech symbolů disassembleru použitých ve skriptu
from capstone import Cs, CS_ARCH_X86, CS_MODE_64
&nbsp;
&nbsp;
# instrukce, které se mají přeložit assemblerem
CODE = """
    MOV EBX, 10
OUTER_LOOP:
    MOV EAX, 100
INNER_LOOP:
    DEC EAX
    JNZ INNER_LOOP
    DEC EBX
    JNZ OUTER_LOOP
"""
&nbsp;
try:
    # inicializace assembleru se specifikací architektury a popř. i režimu
    ks = Ks(KS_ARCH_X86, KS_MODE_64)
&nbsp;
    # vlastní překlad (assembling)
    encoding, count = ks.asm(CODE)
&nbsp;
    # disassembling binární sekvence kódů
    md = Cs(CS_ARCH_X86, CS_MODE_64)
&nbsp;
    # vypsat podrobnější informace o každé instrukci
    for i in md.disasm(bytes(encoding), 0x1234):
        # převod pole bajtů na řetězec s hexa hodnotami
        dump = i.bytes.hex(" ")
&nbsp;
        # výpis informací o instrukci
        print("0x{:02x}:\t{:20s}\t{:s}\t{:s}".format(i.address, dump, i.mnemonic, i.op_str))
&nbsp;
except KsError as e:
    print("ERROR: %s" % e)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Kód v&nbsp;assembleru pro 32bitovou platformu ARM</h2>

<pre>
# import všech symbolů assembleru použitých ve skriptu
from keystone import Ks, KS_ARCH_ARM, KS_MODE_ARM, KsError
&nbsp;
# import všech symbolů disassembleru použitých ve skriptu
from capstone import Cs, CS_ARCH_ARM, CS_MODE_ARM
&nbsp;
&nbsp;
# instrukce, které se mají přeložit assemblerem
CODE = """
    MOV R0, 10
OUTER_LOOP:
    MOV R1, 100
INNER_LOOP:
    SUB R1, R1, 1
    BNE INNER_LOOP
    SUB R0, R0, 1
    BNE OUTER_LOOP
"""
&nbsp;
try:
    # inicializace assembleru se specifikací architektury a popř. i režimu
    ks = Ks(KS_ARCH_ARM, KS_MODE_ARM)
&nbsp;
    # vlastní překlad (assembling)
    encoding, count = ks.asm(CODE)
&nbsp;
    # disassembling binární sekvence kódů
    md = Cs(CS_ARCH_ARM, CS_MODE_ARM)
&nbsp;
    # vypsat podrobnější informace o každé instrukci
    for i in md.disasm(bytes(encoding), 0x0000):
        # převod pole bajtů na řetězec s hexa hodnotami
        dump = i.bytes.hex(" ")
&nbsp;
        # výpis informací o instrukci
        print("0x{:02x}:\t{:20s}\t{:s}\t{:s}".format(i.address, dump, i.mnemonic, i.op_str))
&nbsp;
except KsError as e:
    print("ERROR: %s" % e)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Využití instrukční sady ARM Thumb</h2>

<pre>
# import všech symbolů assembleru použitých ve skriptu
from keystone import Ks, KS_ARCH_ARM, KS_MODE_THUMB, KsError
&nbsp;
# import všech symbolů disassembleru použitých ve skriptu
from capstone import Cs, CS_ARCH_ARM, CS_MODE_THUMB
&nbsp;
&nbsp;
# instrukce, které se mají přeložit assemblerem
CODE = """
    MOV R0, 10
OUTER_LOOP:
    MOV R1, 100
INNER_LOOP:
    SUB R1, R1, 1
    BNE INNER_LOOP
    SUB R0, R0, 1
    BNE OUTER_LOOP
"""
&nbsp;
try:
    # inicializace assembleru se specifikací architektury a popř. i režimu
    ks = Ks(KS_ARCH_ARM, KS_MODE_THUMB)
&nbsp;
    # vlastní překlad (assembling)
    encoding, count = ks.asm(CODE)
&nbsp;
    # disassembling binární sekvence kódů
    md = Cs(CS_ARCH_ARM, CS_MODE_THUMB)
&nbsp;
    # vypsat podrobnější informace o každé instrukci
    for i in md.disasm(bytes(encoding), 0x0000):
        # převod pole bajtů na řetězec s hexa hodnotami
        dump = i.bytes.hex(" ")
&nbsp;
        # výpis informací o instrukci
        print("0x{:02x}:\t{:20s}\t{:s}\t{:s}".format(i.address, dump, i.mnemonic, i.op_str))
&nbsp;
except KsError as e:
    print("ERROR: %s" % e)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Přepis příkladů pro architekturu AArch64</h2>

<pre>
# import všech symbolů assembleru použitých ve skriptu
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN, KsError

# import všech symbolů disassembleru použitých ve skriptu
from capstone import Cs, CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN


# instrukce, které se mají přeložit assemblerem
CODE = """
    MOV W0, 10
OUTER_LOOP:
    MOV W1, 100
INNER_LOOP:
    SUB W1, W1, 1
    BNE INNER_LOOP
    SUB W0, W0, 1
    BNE OUTER_LOOP
"""

try:
    # inicializace assembleru se specifikací architektury a popř. i režimu
    ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN)

    # vlastní překlad (assembling)
    encoding, count = ks.asm(CODE)

    # disassembling binární sekvence kódů
    md = Cs(CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN)

    # vypsat podrobnější informace o každé instrukci
    for i in md.disasm(bytes(encoding), 0x0000):
        # převod pole bajtů na řetězec s hexa hodnotami
        dump = i.bytes.hex(" ")

        # výpis informací o instrukci
        print("0x{:02x}:\t{:20s}\t{:s}\t{:s}".format(i.address, dump, i.mnemonic, i.op_str))

except KsError as e:
    print("ERROR: %s" % e)
</pre>


<p><a name="k17"></a></p>
<h2 id="k17">17. Další možnosti poskytované nástrojem Capstone</h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Závěrečné zhodnocení</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 (nikoli ovšem pro starší verze Pythonu 2!) byly
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>disasm_x86_64.py</td><td>zpětný překlad obsahu binárního souboru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64.py</a></td></tr>
<tr><td> 2</td><td>disasm_x86_64_bytes.py</td><td>zpětný překlad obsahu binárního souboru, výpis zakódovaných instrukcí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_bytes.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_bytes.py</a></td></tr>
<tr><td> 3</td><td>disasm_x86_64_offset_A.py</td><td>explicitní specifikace bázové adresy</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_A.py</a></td></tr>
<tr><td> 4</td><td>disasm_x86_64_offset_B.py</td><td>práce s&nbsp;binárním souborem, kde instrukce začínají od zadaného offsetu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_B.py</a></td></tr>
<tr><td> 5</td><td>disasm_x86_64_offset_C.py</td><td>práce s&nbsp;binárním souborem, kde instrukce začínají od zadaného offsetu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_C.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_C.py</a></td></tr>
<tr><td> 6</td><td>disasm_x86_64_offset_D.py</td><td>práce s&nbsp;binárním souborem, kde instrukce začínají od zadaného offsetu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_D.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_x86_64_offset_D.py</a></td></tr>
<tr><td> 7</td><td>disasm_mips.py</td><td>zpětný překlad nativního kódu určeného pro architekturu MIPS</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_mips.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/disasm_mips.py</a></td></tr>
<tr><td> 8</td><td>asm_disasm_x86_64.py</td><td>překlad assembleru do nativního kódu a zpět na platformě x86-64</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_x86_64.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_x86_64.py</a></td></tr>
<tr><td> 9</td><td>asm_disasm_x86_64_offset.py</td><td>specifikace offsetu při překladu a zpětném překladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_x86_64_offset.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_x86_64_offset.py</a></td></tr>
<tr><td>10</td><td>asm_disasm_arm.py</td><td>překlad assembleru do nativního kódu a zpět na platformě ARM32</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_arm.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_arm.py</a></td></tr>
<tr><td>11</td><td>asm_disasm_thumb.py</td><td>překlad assembleru do nativního kódu a zpět na platformě ARM32 s Thumb</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_thumb.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_thumb.py</a></td></tr>
<tr><td>12</td><td>asm_disasm_aarch64.py</td><td>překlad assembleru do nativního kódu a zpět na platformě AArch64</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_aarch64.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_aarch64.py</a></td></tr>
<tr><td>13</td><td>asm_disasm_mips_1.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_mips_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_mips_1.py</a></td></tr>
<tr><td>14</td><td>asm_disasm_mips_2.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_mips_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_mips_2.py</a></td></tr>
<tr><td>15</td><td>asm_disasm_mips_3.py</td><td></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_mips_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/capstone/asm_disasm_mips_3.py</a></td></tr>
</table>

<p>Pro úplnost si uveďme i odkazy na demonstrační příklady založené na
frameworku <i>Keystone</i>, které byly popsané minule:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>first_steps_16bit_A.py</td><td>překlad 16bitového kódu (zapsaného na jediném řádku) mikroprocesorů řady x86</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_A.py</a></td></tr>
<tr><td> 2</td><td>first_steps_16bit_B.py</td><td>překlad 16bitového kódu (zapsaného na více řádcích) mikroprocesorů řady x86</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_B.py</a></td></tr>
<tr><td> 3</td><td>first_steps_32bit.py</td><td>překlad 32bitového kódu mikroprocesorů řady x86</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_32bit.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_32bit.py</a></td></tr>
<tr><td> 4</td><td>first_steps_64bit.py</td><td>překlad 32bitového kódu mikroprocesorů řady x86-64</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_64bit.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_64bit.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>att_syntax_A.py</td><td>kód zapsaný v&nbsp;assembleru, který využívá syntaxi AT&amp;T (nekorektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_A.py</a></td></tr>
<tr><td> 6</td><td>att_syntax_B.py</td><td>kód zapsaný v&nbsp;assembleru, který využívá syntaxi AT&amp;T (korektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_B.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>loop_A.py</td><td>kód zapsaný v&nbsp;assembleru, v&nbsp;němž je použita programová smyčka</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_A.py</a></td></tr>
<tr><td> 8</td><td>loop_B.py</td><td>kód zapsaný v&nbsp;assembleru, v&nbsp;němž jsou použity vnořené programové smyčky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_B.py</a></td></tr>
<tr><td> 9</td><td>loops_dump.asm</td><td>výsledek získaný skriptem <strong>loop_A.py</strong> a nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loops_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loops_dump.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>into_binary_A.py</td><td>překlad assembleru do binární formy (smyčky)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_A.py</a></td></tr>
<tr><td>11</td><td>into_binary_B.py</td><td>překlad assembleru do binární formy (&bdquo;Hello world&ldquo;)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_B.py</a></td></tr>
<tr><td>12</td><td>into_binary_C.py</td><td>překlad assembleru do binární formy (&bdquo;Hello world&ldquo;)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_C.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_C.py</a></td></tr>
<tr><td>13</td><td>into_binary_D.py</td><td>překlad assembleru do binární formy (využití AT&amp;T syntaxe)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_D.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_D.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>hello_world.asm</td><td>program typu &bdquo;Hello world&ldquo; napsaný v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world.asm</a></td></tr>
<tr><td>15</td><td>hello_world_2.asm</td><td>upravený program typu &bdquo;Hello world&ldquo; napsaný v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world_2.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world_2.asm</a></td></tr>
<tr><td>16</td><td>hello_dump.asm</td><td>zpětný překlad nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_dump.asm</a></td></tr>
<tr><td>17</td><td>hello_2_dump.asm</td><td>zpětný překlad nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_2_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_2_dump.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>subroutines.py</td><td>překlad programu v&nbsp;assembleru, jenž používá podprogramy (subrutiny)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines.py</a></td></tr>
<tr><td>19</td><td>subroutines.asm</td><td>program zapsaný v&nbsp;assembleru, jenž používá podprogramy (subrutiny)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines.asm</a></td></tr>
<tr><td>20</td><td>subroutines_dump.asm</td><td>zpětný překlad nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines_dump.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>disasm.py</td><td>zpětný disassembling binárního kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/disasm.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/disasm.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>att_syntax.asm</td><td>kód v&nbsp;assembleru se syntaxí AT&amp;T</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax.asm</a></td></tr>
<tr><td>23</td><td>att_syntax_dump.asm</td><td>zpětný překlad nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_dump.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Keystone Engine na GitHubu<br />
<a href="https://github.com/keystone-engine/keystone">https://github.com/keystone-engine/keystone</a>
</li>

<li>Keystone: The Ultimate Assembler<br />
<a href="https://www.keystone-engine.org/">https://www.keystone-engine.org/</a>
</li>

<li>The Ultimate Disassembler<br />
<a href="http://www.capstone-engine.org/">http://www.capstone-engine.org/</a>
</li>

<li>Tutorial for Keystone<br />
<a href="https://www.keystone-engine.org/docs/tutorial.html">https://www.keystone-engine.org/docs/tutorial.html</a>
</li>

<li>Rozhraní pro Capstone na PyPi<br />
<a href="https://pypi.org/project/capstone/">https://pypi.org/project/capstone/</a>
</li>

<li>Rozhraní pro Keystone na PyPi<br />
<a href="https://pypi.org/project/keystone-engine/">https://pypi.org/project/keystone-engine/</a>
</li>

<li>KEYSTONE: Next Generation Assembler Framework<br />
<a href="https://www.keystone-engine.org/docs/BHUSA2016-keystone.pdf">https://www.keystone-engine.org/docs/BHUSA2016-keystone.pdf</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="http://web.mit.edu/rhel-doc/3/rhel-as-en-3/i386-syntax.html">http://web.mit.edu/rhel-doc/3/rhel-as-en-3/i386-syntax.html</a>
</li>

<li>AT&amp;T assembly syntax and IA-32 instructions<br />
<a href="https://gist.github.com/mishurov/6bcf04df329973c15044">https://gist.github.com/mishurov/6bcf04df329973c15044</a>
</li>

<li>ARM GCC Inline Assembler Cookbook<br />
<a href="http://www.ethernut.de/en/documents/arm-inline-asm.html">http://www.ethernut.de/en/documents/arm-inline-asm.html</a>
</li>

<li>Extended Asm - Assembler Instructions with C Expression Operands<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</a>
</li>

<li>ARM inline asm secrets<br />
<a href="http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/">http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/</a>
</li>

<li>How to Use Inline Assembly Language in C Code<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a>
</li>

<li>GCC-Inline-Assembly-HOWTO<br />
<a href="http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a>
</li>

<li>A Brief Tutorial on GCC inline asm (x86 biased)<br />
<a href="http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm">http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm</a>
</li>

<li>GCC Inline ASM<br />
<a href="http://locklessinc.com/articles/gcc_asm/">http://locklessinc.com/articles/gcc_asm/</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v&nbsp;assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>Online x86 / x64 Assembler and Disassembler<br />
<a href="https://defuse.ca/online-x86-assembler.htm#disassembly">https://defuse.ca/online-x86-assembler.htm#disassembly</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

