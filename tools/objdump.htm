<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">4. Aplikace typu &bdquo;Hello World&ldquo; naprogramovaná v&nbsp;assembleru</a></p>
<p><a href="#k05">5. Zjištění podrobnějších informací o objektovém souboru <strong>hello_world.o</strong></a></p>
<p><a href="#k06">6. Zobrazení obsahu všech sekcí v&nbsp;objektovém kódu</a></p>
<p><a href="#k07">7. Zpětný překlad (disassembling) z&nbsp;objektového souboru</a></p>
<p><a href="#k08">8. Zjištění podrobnějších informací o nativním spustitelném souboru <strong>a.out</strong></a></p>
<p><a href="#k09">*** 9. Zpětný překlad (disassembling) ze souboru <strong>a.out</strong></a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. Zdrojový kód příkladu naprogramovaného v&nbsp;jazyku C, jenž závisí na dynamické knihovně</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">16. Deklarace většího množství prázdných sekcí s&nbsp;různými atributy</a></p>
<p><a href="#k17">17. Výpis všech sekcí z&nbsp;objektového souboru i z&nbsp;výsledného binárního souboru</a></p>
<p><a href="#k18">18. Deklarace většího množství sekcí obsahujících statická data</a></p>
<p><a href="#k19">19. Opětovný výpis všech sekcí z&nbsp;objektového souboru i z&nbsp;výsledného binárního souboru</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>



<p><a name="k03"></a></p>
<h2 id="k03">3. </h2>

<pre>
$ <strong>objdump</strong>
&nbsp;
Usage: objdump &lt;option(s)&gt; &lt;file(s)&gt;
 Display information from object &lt;file(s)&gt;.
 At least one of the following switches must be given:
  -a, --archive-headers    Display archive header information
  -f, --file-headers       Display the contents of the overall file header
  -p, --private-headers    Display object format specific file header contents
  -P, --private=OPT,OPT... Display object format specific contents
  -h, --[section-]headers  Display the contents of the section headers
  -x, --all-headers        Display the contents of all headers
  -d, --disassemble        Display assembler contents of executable sections
  -D, --disassemble-all    Display assembler contents of all sections
      --disassemble=<sym>  Display assembler contents from <sym>
  -S, --source             Intermix source code with disassembly
      --source-comment[=<txt>] Prefix lines of source code with <txt>
  -s, --full-contents      Display the full contents of all sections requested
  -g, --debugging          Display debug information in object file
  -e, --debugging-tags     Display debug information using ctags style
  -G, --stabs              Display (in raw form) any STABS info in the file
  -W[lLiaprmfFsoRtUuTgAckK] or
  --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,
          =frames-interp,=str,=loc,=Ranges,=pubtypes,
          =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,
          =addr,=cu_index,=links,=follow-links]
                           Display DWARF info in the file
  --ctf=SECTION            Display CTF info from SECTION
  -t, --syms               Display the contents of the symbol table(s)
  -T, --dynamic-syms       Display the contents of the dynamic symbol table
  -r, --reloc              Display the relocation entries in the file
  -R, --dynamic-reloc      Display the dynamic relocation entries in the file
  @<file>                  Read options from <file>
  -v, --version            Display this program's version number
  -i, --info               List object formats and architectures supported
  -H, --help               Display this information
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Aplikace typu &bdquo;Hello World&ldquo; naprogramovaná v&nbsp;assembleru</h2>

<p>V&nbsp;navazujících kapitolách budeme zkoumat objektový soubor a taktéž
výsledný nativní soubor vygenerovaný assemblerem resp.&nbsp;linkerem ze
zdrojového kódu klasického demonstračního příkladu typu &bdquo;Hello
World&ldquo;. Námi použitá varianta je naprogramována v&nbsp;assembleru
mikroprocesorů x86 a v&nbsp;jejím zápisu je použita syntaxe používaná firmou
Intel a nikoli AT&amp;T syntaxe. Zdrojový kód tohoto příkladu naleznete na
adrese <a
href="https://github.com/tisnik/presentations/blob/master/assembler/06_gas_intel_hello_world/hello_world.s">https://github.com/tisnik/presentations/blob/master/assembler/06_gas_intel_hello_world/hello_world.s</a>:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Jednoducha aplikace typu "Hello world!" naprogramovana</i>
<i># v assembleru GNU as - pouzita je "Intel" syntaxe.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
.intel_syntax noprefix
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=1
sys_write=4
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"     <i># string, ktery JE ukoncen nulou</i>
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        mov   eax, sys_write         <i># cislo syscallu pro funkci "write"</i>
        mov   ebx, 1                 <i># standardni vystup</i>
        mov   ecx, offset hello_lbl  <i># adresa retezce, ktery se ma vytisknout</i>
        mov   edx, 13                <i># pocet znaku, ktere se maji vytisknout</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
&nbsp;
        mov   eax, sys_exit          <i># cislo sycallu pro funkci "exit"</i>
        mov   ebx, 0                 <i># exit code = 0</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>

</pre>

<p>Tento demonstrační příklad nejprve přeložíme assemblerem do objektového kódu
<strong>hello_world.o</strong> a následně linkerem vytvoříme spustitelný soubor
<strong>a.out</strong> (lze samozřejmě zvolit jiné jméno, ale proč nezůstat u
klasiky):</p>

<pre>
$ <strong>as hello_world.s -o hello_world.o</strong>
$ <strong>ld -s hello_world.o</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: překlad i spuštění je možný jak na
32bitové platformě x86, tak i na 64bitové platformě x86-64.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zjištění podrobnějších informací o objektovém souboru <strong>hello_world.o</strong></h2>

<p>V&nbsp;této kapitole si ukážeme, jakým způsobem je možné získat podrobnější
informace o objektovém souboru <strong>hello_world.o</strong>, jenž vznikl
překladem <a href="#k04">výše uvedeného</a> zdrojového souboru
<strong>hello_world.s</strong> assemblerem, konkrétně GNU Assemblerem. Pro
získání informací o objektovém souboru pochopitelně použijeme nástroj
<strong>objdump</strong>.</p>

<p>Nejprve si necháme zobrazit hlavičku objektového souboru. Pro tento účel se
používá přepínač <strong>-f</strong>. Povšimněte si, že se především zobrazí
použitý formát (zde konkrétně <i>ELF</i> neboli <i>Executable and Linkable
Format</i>, což je dnes na Linuxu standard), cílová architektura (x86-64) a
příznaky určující, že soubor má relokační tabulku (bitová maska 0x01) a tabulku
symbolů (bitová maska 0x10), příznakové slovo má tedy hodnotu 0x01+0x10=0x11. A
konečně se vypíše počáteční adresa, k&nbsp;jejímuž významu se ještě
vrátíme:</p>

<pre>
$ <strong>objdump -f hello_world.o</strong>
&nbsp;
hello_world.o:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x0000000000000000
</pre>

<p>Z&nbsp;předchozího výpisu je zřejmé, že objektový soubor obsahuje i
takzvanou tabulku symbolů. Její obsah si můžeme zobrazit, a to použitím
přepínače <strong>-t</strong>:</p>

<pre>
$ <strong>objdump -t hello_world.o</strong>
&nbsp;
hello_world.o:     file format elf64-x86-64
&nbsp;
SYMBOL TABLE:
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000001 l       *ABS*  0000000000000000 sys_exit
0000000000000004 l       *ABS*  0000000000000000 sys_write
0000000000000000 l       .data  0000000000000000 hello_lbl
0000000000000000 g       .text  0000000000000000 _start
</pre>

<p>Každý symbol z&nbsp;tabulky symbolů je vypsán na samostatném řádku.
Jednotlivé sloupce mají tento význam:</p>

<table>
<tr><th>Sloupec</th><th>Příklad</th><th>Význam</th></tr>
<tr><td>1</td><td>0000000000000001</td><td>hodnota symbolu</td></tr>
<tr><td>2</td><td>l    d</td><td>sedm skupin s&nbsp;popisem symbolu, každá skupina reprezentovaná jedním znakem</td></tr>
<tr><td>3</td><td>.bss</td><td>sekce (segment), v&nbsp;němž je symbol definován (*ABS* značí bez sekce)</td></tr>
<tr><td>4</td><td>0000000000000000</td><td>velikost symbolu nebo zarovnání</td></tr>
<tr><td>5</td><td>sys_exit</td><td>jméno symbolu</td></tr>
</table>

<p>Druhý sloupec je nejzajímavější. Je v&nbsp;něm zakódováno mnoho informací o
daném symbolu, a to sedmi znaky (z&nbsp;nichž některé mohou být nahrazeny
mezerou):</p>

<p></p>

<table>
<tr><th>Skupina</th><th>Znak</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>l,g,mezera,!</td><td>lokální či globální symbol, popř. oboje</td></tr>
<tr><td>2</td><td>w,mezera</td><td>označuje tzv. weak symbol</td></tr>
<tr><td>3</td><td>C,mezera</td><td>konstruktor nebo běžný symbol</td></tr>
<tr><td>4</td><td>W,mezera</td><td>warning nebo běžný symbol</td></tr>
<tr><td>5</td><td>I,mezera</td><td>odkaz na jiný symbol (či běžný symbol)</td></tr>
<tr><td>6</td><td>d,D,mezera</td><td>symbol pro ladění, dynamický symbol či běžný symbol</td></tr>
<tr><td>7</td><td>F,f,O</td><td>jméno funkce, jméno souboru, běžný symbol</td></tr>
</table>

<p>A konečně si ukažme, jak je možné přepínačem <strong>-x</strong> zobrazit
všechny hlavičky v&nbsp;objektovém souboru. Jedná se vlastně o kombinaci
přepínačů <strong>-f</strong>, <strong>-t</strong>, <strong>-a</strong>,
<strong>-h</strong> a <strong>-p</strong>:</p>

<pre>
$ <strong>objdump -x hello_world.o</strong>
&nbsp;
hello_world.o:     file format elf64-x86-64
hello_world.o
architecture: i386:x86-64, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x0000000000000000
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000022  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         0000000e  0000000000000000  0000000000000000  00000062  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000070  2**0
                  ALLOC
SYMBOL TABLE:
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000001 l       *ABS*  0000000000000000 sys_exit
0000000000000004 l       *ABS*  0000000000000000 sys_write
0000000000000000 l       .data  0000000000000000 hello_lbl
0000000000000000 g       .text  0000000000000000 _start
&nbsp;
&nbsp;
RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE 
000000000000000b R_X86_64_32       .data
</pre>

<p><div class="rs-tip-major">Poznámka: významem části <strong>Sections</strong>
se budeme zabývat v&nbsp;samostatné kapitole.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zobrazení obsahu všech sekcí v&nbsp;objektovém kódu</h2>

<p>V&nbsp;případě, že použijeme přepínač <strong>-s</strong>, můžeme si nechat
zobrazit obsah všech sekcí (segmentů) nalezených v&nbsp;objektovém kódu &ndash;
a to jak v&nbsp;hexadecimální podobě, tak i ve formě řetězce (ovšem jen pro
ASCII znaky). Výsledek bude v&nbsp;našem případě vypadat následovně:</p>

<pre>
$ <strong>objdump -s hello_world.o</strong>
&nbsp;
hello_world.o:     file format elf64-x86-64
&nbsp;
Contents of section .text:
 0000 b8040000 00bb0100 0000b900 000000ba  ................
 0010 0d000000 cd80b801 000000bb 00000000  ................
 0020 cd80                                 ..              
Contents of section .data:
 0000 48656c6c 6f20576f 726c6421 0a00      Hello World!..  
</pre>

<p><div class="rs-tip-major">Poznámka: formát výpisu je v&nbsp;tomto případě
zřejmý z&nbsp;předchozího příkladu:<br /> offset, obsah šestnácti bajtů vypsaný
formou hexa číslic sdružených do slov, ASCII znaky zobrazené formou řetězce
(popř.&nbsp;tečky pro ty znaky, které nepatří do ASCII).</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zpětný překlad (disassembling) z&nbsp;objektového souboru</h2>

<p>Nástroj <strong>objdump</strong> dokáže zjistit i mnohé další užitečné
informace z&nbsp;dat uložených v&nbsp;objektovém souboru. Mezi nejzajímavější
vlastnost patří zpětný překlad (neboli <i>disassembling</i>), což se typicky
týká obsahu sekce (segmentu) nazvané <strong>.text</strong>, v&nbsp;níž je
uložen přeložený objektový kód. Podívejme se nyní na to, jak dobře nástroj
<strong>objdump</strong> porozumí sekvenci instrukcí uložených v&nbsp;této
sekci:</p>

<pre>
$ <strong>objdump -d hello_world.o</strong>
&nbsp;
hello_world.o:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000000000 &lt;_start&gt;:
   0:   b8 04 00 00 00          mov    $0x4,%eax
   5:   bb 01 00 00 00          mov    $0x1,%ebx
   a:   b9 00 00 00 00          mov    $0x0,%ecx
   f:   ba 0d 00 00 00          mov    $0xd,%edx
  14:   cd 80                   int    $0x80
  16:   b8 01 00 00 00          mov    $0x1,%eax
  1b:   bb 00 00 00 00          mov    $0x0,%ebx
  20:   cd 80                   int    $0x80
</pre>

<p>V&nbsp;porovnání se zdrojovým kódem <a href="#k04">ze čtvrté kapitoly</a> je
patrné, že ve výchozím nastavení použil nástroj <strong>objdump</strong> formát
instrukcí (tedy mnemotechnická jména instrukcí) i operandů (pořadí, formát
zápisu), který odpovídá syntaxi zavedenou společností <a
href="https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax">AT&amp;T</a>.
Pokud preferujete, podobně jako autor tohoto článku, spíše syntax používanou
společností Intel, je nutné použít přepínač <strong>-M intel_mnemonic</strong>
nebo jen <strong>-M intel</strong>.  Výsledek se již bude do značné míry
podobat původnímu zdrojovému kódu:</p>

<pre>
$ <strong>objdump -d -M intel_mnemonic hello_world.o</strong>
&nbsp;
hello_world.o:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000000000 &lt;_start&gt;:
   0:   b8 04 00 00 00          mov    eax,0x4
   5:   bb 01 00 00 00          mov    ebx,0x1
   a:   b9 00 00 00 00          mov    ecx,0x0
   f:   ba 0d 00 00 00          mov    edx,0xd
  14:   cd 80                   int    0x80
  16:   b8 01 00 00 00          mov    eax,0x1
  1b:   bb 00 00 00 00          mov    ebx,0x0
  20:   cd 80                   int    0x80
</pre>

<p><div class="rs-tip-major">Poznámka: ne vždy ovšem bude disassembling
úspěšný, protože se může stát, že <strong>objdump</strong> nenalezne začátky
instrukcí. To se týká zejména těch platforem, kde mohou mít instrukce různou
délku: x86, x86-64, ARM Thumb-2 atd.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zjištění podrobnějších informací o nativním spustitelném souboru <strong>a.out</strong></h2>

<p>Prozatím jsme nástroj <strong>objdump</strong> používali pro zjištění
informací z&nbsp;objektových souborů &ndash; ostatně právě kvůli této
vlastnosti získal tento nástroj své jméno. Ovšem podobné informace je možné
v&nbsp;případě potřeby získat i z&nbsp;výsledných spustitelných (nativních)
souborů <strong>a.out</strong> (které samozřejmě mohou mít odlišné jméno a na
Linuxu typicky nemají žádnou koncovku).</p>

<p><div class="rs-tip-major">Poznámka: samotné <strong>a.out</strong> je
starobylý název pocházející z&nbsp;originálního Unixu a znamená <i>assembler
output</i> (což vlastně není pravda, protože se dnes jedná o výsledek činnosti
linkeru). Pro větší zmatení čtenářů se navíc jméno <strong>a.out</strong>
používá i pro pojmenování <a href="https://wiki.osdev.org/A.out">staršího
formátu</a> nativních binárních souborů. Tento formát je však formátem ELF
překonán (i když má jednu výhodu &ndash; kratší délku souboru, i když
starobylému <a href="https://wiki.osdev.org/COM">COM</a> konkurovat
nemůže).</div></p>

<p>Vraťme se však k&nbsp;souboru <strong>a.out</strong>, který vznikl překladem
a slinkováním zdrojového kódu <a href="#k04">ze čtvrté kapitoly</a>. Nejdříve
si necháme zobrazit hlavičku tohoto souboru:</p>

<pre>
$ <strong>objdump -f a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x0000000000401000
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si nyní již reálné počáteční
adresy, která se odlišuje od nulové adresy pro objektové soubory.</div></p>

<p>Zobrazit si můžeme i souhrnné základní informace o zkoumaném souboru. Opět
použijeme přepínač, který již známe &ndash; <strong>-x</strong>:</p>

<pre>
$ <strong>objdump -x a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
a.out
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x0000000000401000
&nbsp;
Program Header:
    LOAD off    0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**12
         filesz 0x00000000000000e8 memsz 0x00000000000000e8 flags r--
    LOAD off    0x0000000000001000 vaddr 0x0000000000401000 paddr 0x0000000000401000 align 2**12
         filesz 0x0000000000000022 memsz 0x0000000000000022 flags r-x
    LOAD off    0x0000000000002000 vaddr 0x0000000000402000 paddr 0x0000000000402000 align 2**12
         filesz 0x000000000000000e memsz 0x000000000000000e flags rw-
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000022  0000000000401000  0000000000401000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  0000000000402000  0000000000402000  00002000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
no symbols
</pre>

<p><div class="rs-tip-major">Poznámka: významem části <strong>Sections</strong>
se budeme, jak jsme si již ostatně řekli, zabývat v&nbsp;samostatné kapitole.
Zajímavé taktéž je, že <a href="https://wiki.osdev.org/Symbol_Table">tabulka
symbolů</a> je prázdná &ndash; ve výsledném programu tedy nejsou žádné externě
viditelné symboly.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zpětný překlad (disassembling) ze souboru <strong>a.out</strong></h2>

<p></p>

<pre>
$ <strong>objdump -d a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000401000 &lt;.text&gt;:
  401000:       b8 04 00 00 00          mov    $0x4,%eax
  401005:       bb 01 00 00 00          mov    $0x1,%ebx
  40100a:       b9 00 20 40 00          mov    $0x402000,%ecx
  40100f:       ba 0d 00 00 00          mov    $0xd,%edx
  401014:       cd 80                   int    $0x80
  401016:       b8 01 00 00 00          mov    $0x1,%eax
  40101b:       bb 00 00 00 00          mov    $0x0,%ebx
  401020:       cd 80                   int    $0x80
</pre>

<p>Opět pochopitelně můžeme </p>

<pre>
$ <strong>objdump -M intel -d a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000401000 &lt;.text&gt;:
  401000:       b8 04 00 00 00          mov    eax,0x4
  401005:       bb 01 00 00 00          mov    ebx,0x1
  40100a:       b9 00 20 40 00          mov    ecx,0x402000
  40100f:       ba 0d 00 00 00          mov    edx,0xd
  401014:       cd 80                   int    0x80
  401016:       b8 01 00 00 00          mov    eax,0x1
  40101b:       bb 00 00 00 00          mov    ebx,0x0
  401020:       cd 80                   int    0x80
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<p></p>

<pre>
$ <strong>objdump -s a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
&nbsp;
Contents of section .text:
 401000 b8040000 00bb0100 0000b900 204000ba  ............ @..
 401010 0d000000 cd80b801 000000bb 00000000  ................
 401020 cd80                                 ..              
Contents of section .data:
 402000 48656c6c 6f20576f 726c6421 0a00      Hello World!..  
</pre>

<pre>
$ <strong>objdump -s -j.data a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
&nbsp;
Contents of section .data:
 402000 48656c6c 6f20576f 726c6421 0a00      Hello World!..  
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zdrojový kód příkladu naprogramovaného v&nbsp;jazyku C, jenž závisí na dynamické knihovně</h2>

<p></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
&nbsp;
double <strong>compute_sin</strong>(double x)
{
    return sin(x);
}
&nbsp;
int <strong>main</strong>(void)
{
    double x;

    for (x = 0; x &lt; M_PI/2.0; x+=M_PI/40.0) {
        double y = compute_sin(x);
        printf("%f\t%f\n", x, y);
    }
}
</pre>

<p></p>

<pre>
$ <strong>gcc test.c -lm</strong>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<p></p>

<pre>
$ <strong>readelf -h a.out</strong>
&nbsp;
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1080
  Start of program headers:          64 (bytes into file)
  Start of section headers:          14792 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 30
</pre>

<pre>
$ <strong>objdump -p a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
&nbsp;
Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000000040 paddr 0x0000000000000040 align 2**3
         filesz 0x00000000000002d8 memsz 0x00000000000002d8 flags r--
  INTERP off    0x0000000000000318 vaddr 0x0000000000000318 paddr 0x0000000000000318 align 2**0
         filesz 0x000000000000001c memsz 0x000000000000001c flags r--
    LOAD off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**12
         filesz 0x0000000000000660 memsz 0x0000000000000660 flags r--
    LOAD off    0x0000000000001000 vaddr 0x0000000000001000 paddr 0x0000000000001000 align 2**12
         filesz 0x0000000000000295 memsz 0x0000000000000295 flags r-x
    LOAD off    0x0000000000002000 vaddr 0x0000000000002000 paddr 0x0000000000002000 align 2**12
         filesz 0x0000000000000198 memsz 0x0000000000000198 flags r--
    LOAD off    0x0000000000002da0 vaddr 0x0000000000003da0 paddr 0x0000000000003da0 align 2**12
         filesz 0x0000000000000270 memsz 0x0000000000000278 flags rw-
 DYNAMIC off    0x0000000000002db0 vaddr 0x0000000000003db0 paddr 0x0000000000003db0 align 2**3
         filesz 0x0000000000000200 memsz 0x0000000000000200 flags rw-
    NOTE off    0x0000000000000338 vaddr 0x0000000000000338 paddr 0x0000000000000338 align 2**3
         filesz 0x0000000000000020 memsz 0x0000000000000020 flags r--
    NOTE off    0x0000000000000358 vaddr 0x0000000000000358 paddr 0x0000000000000358 align 2**2
         filesz 0x0000000000000044 memsz 0x0000000000000044 flags r--
0x6474e553 off    0x0000000000000338 vaddr 0x0000000000000338 paddr 0x0000000000000338 align 2**3
         filesz 0x0000000000000020 memsz 0x0000000000000020 flags r--
EH_FRAME off    0x0000000000002020 vaddr 0x0000000000002020 paddr 0x0000000000002020 align 2**2
         filesz 0x000000000000004c memsz 0x000000000000004c flags r--
   STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
   RELRO off    0x0000000000002da0 vaddr 0x0000000000003da0 paddr 0x0000000000003da0 align 2**0
         filesz 0x0000000000000260 memsz 0x0000000000000260 flags r--
&nbsp;
Dynamic Section:
  NEEDED               libm.so.6
  NEEDED               libc.so.6
  INIT                 0x0000000000001000
  FINI                 0x0000000000001288
  INIT_ARRAY           0x0000000000003da0
  INIT_ARRAYSZ         0x0000000000000008
  FINI_ARRAY           0x0000000000003da8
  FINI_ARRAYSZ         0x0000000000000008
  GNU_HASH             0x00000000000003a0
  STRTAB               0x0000000000000488
  SYMTAB               0x00000000000003c8
  STRSZ                0x0000000000000092
  SYMENT               0x0000000000000018
  DEBUG                0x0000000000000000
  PLTGOT               0x0000000000003fb0
  PLTRELSZ             0x0000000000000030
  PLTREL               0x0000000000000007
  JMPREL               0x0000000000000630
  RELA                 0x0000000000000570
  RELASZ               0x00000000000000c0
  RELAENT              0x0000000000000018
  FLAGS                0x0000000000000008
  FLAGS_1              0x0000000008000001
  VERNEED              0x0000000000000530
  VERNEEDNUM           0x0000000000000002
  VERSYM               0x000000000000051a
  RELACOUNT            0x0000000000000003
&nbsp;
Version References:
  required from libm.so.6:
    0x09691a75 0x00 03 GLIBC_2.2.5
  required from libc.so.6:
    0x09691a75 0x00 02 GLIBC_2.2.5
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
$ <strong>ldd a.out</strong>
</pre>

<pre>
        linux-vdso.so.1 (0x00007fff88572000)
        libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f58652b1000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f58650bf000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f586541d000)
</pre>

<p></p>

<pre>
$ <strong>objdump -p a.out | grep NEEDED</strong>
&nbsp;
  NEEDED               libm.so.6
  NEEDED               libc.so.6
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>
<pre>
$ objdump -d -M intel a.out | awk -v RS= '/^[[:xdigit:]]+ <main>/'
000000000000118a <main>:
    118a:       f3 0f 1e fa             endbr64 
    118e:       55                      push   rbp
    118f:       48 89 e5                mov    rbp,rsp
    1192:       48 83 ec 10             sub    rsp,0x10
    1196:       66 0f ef c0             pxor   xmm0,xmm0
    119a:       f2 0f 11 45 f0          movsd  QWORD PTR [rbp-0x10],xmm0
    119f:       eb 50                   jmp    11f1 <main+0x67>
    11a1:       48 8b 45 f0             mov    rax,QWORD PTR [rbp-0x10]
    11a5:       66 48 0f 6e c0          movq   xmm0,rax
    11aa:       e8 ba ff ff ff          call   1169 <compute_sin>
    11af:       66 48 0f 7e c0          movq   rax,xmm0
    11b4:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
    11b8:       f2 0f 10 45 f8          movsd  xmm0,QWORD PTR [rbp-0x8]
    11bd:       48 8b 45 f0             mov    rax,QWORD PTR [rbp-0x10]
    11c1:       66 0f 28 c8             movapd xmm1,xmm0
    11c5:       66 48 0f 6e c0          movq   xmm0,rax
    11ca:       48 8d 3d 37 0e 00 00    lea    rdi,[rip+0xe37]        # 2008 <_IO_stdin_used+0x8>
    11d1:       b8 02 00 00 00          mov    eax,0x2
    11d6:       e8 85 fe ff ff          call   1060 <printf@plt>
    11db:       f2 0f 10 4d f0          movsd  xmm1,QWORD PTR [rbp-0x10]
    11e0:       f2 0f 10 05 28 0e 00    movsd  xmm0,QWORD PTR [rip+0xe28]        # 2010 <_IO_stdin_used+0x10>
    11e7:       00 
    11e8:       f2 0f 58 c1             addsd  xmm0,xmm1
    11ec:       f2 0f 11 45 f0          movsd  QWORD PTR [rbp-0x10],xmm0
    11f1:       f2 0f 10 05 1f 0e 00    movsd  xmm0,QWORD PTR [rip+0xe1f]        # 2018 <_IO_stdin_used+0x18>
    11f8:       00 
    11f9:       66 0f 2f 45 f0          comisd xmm0,QWORD PTR [rbp-0x10]
    11fe:       77 a1                   ja     11a1 <main+0x17>
    1200:       b8 00 00 00 00          mov    eax,0x0
    1205:       c9                      leave  
    1206:       c3                      ret    
    1207:       66 0f 1f 84 00 00 00    nop    WORD PTR [rax+rax*1+0x0]
    120e:       00 00 
</pre>

<pre>
$ objdump -d -M intel a.out | awk -v RS= '/^[[:xdigit:]]+ <compute_sin>/'
0000000000001169 <compute_sin>:
    1169:       f3 0f 1e fa             endbr64 
    116d:       55                      push   rbp
    116e:       48 89 e5                mov    rbp,rsp
    1171:       48 83 ec 10             sub    rsp,0x10
    1175:       f2 0f 11 45 f8          movsd  QWORD PTR [rbp-0x8],xmm0
    117a:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
    117e:       66 48 0f 6e c0          movq   xmm0,rax
    1183:       e8 e8 fe ff ff          call   1070 <sin@plt>
    1188:       c9                      leave  
    1189:       c3                      ret    
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
$ <strong>objdump -d -M intel --disassemble=compute_sin a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .init:
&nbsp;
Disassembly of section .plt:
&nbsp;
Disassembly of section .plt.got:
&nbsp;
Disassembly of section .plt.sec:
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000001169 &lt;compute_sin&gt;:
    1169:       f3 0f 1e fa             endbr64 
    116d:       55                      push   rbp
    116e:       48 89 e5                mov    rbp,rsp
    1171:       48 83 ec 10             sub    rsp,0x10
    1175:       f2 0f 11 45 f8          movsd  QWORD PTR [rbp-0x8],xmm0
    117a:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
    117e:       66 48 0f 6e c0          movq   xmm0,rax
    1183:       e8 e8 fe ff ff          call   1070 &lt;sin@plt&gt;
    1188:       c9                      leave
    1189:       c3                      ret
&nbsp;
Disassembly of section .fini:
</pre>


<pre>
$ <strong>objdump -d -M intel -j.text --disassemble=compute_sin a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000001169 &lt;compute_sin&gt;:
    1169:       f3 0f 1e fa             endbr64 
    116d:       55                      push   rbp
    116e:       48 89 e5                mov    rbp,rsp
    1171:       48 83 ec 10             sub    rsp,0x10
    1175:       f2 0f 11 45 f8          movsd  QWORD PTR [rbp-0x8],xmm0
    117a:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
    117e:       66 48 0f 6e c0          movq   xmm0,rax
    1183:       e8 e8 fe ff ff          call   1070 &lt;sin@plt&gt;
    1188:       c9                      leave
    1189:       c3                      ret
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Deklarace většího množství prázdných sekcí s&nbsp;různými atributy</h2>

<p>V&nbsp;dalším textu se pokusíme analyzovat objektový soubor (a taktéž
výsledný binární soubor vytvořený linkerem), v&nbsp;němž je definováno větší
množství sekcí (segmentů). U jednotlivých sekcí jsou uvedeny i jejich atributy,
tj.&nbsp;zda daná sekce obsahuje kód nebo data, zda je možné do sekce zapisovat
či z&nbsp;ní jenom číst atd. Povšimněte si způsobu zápisu jmen sekcí
s&nbsp;tečkou na začátku i způsobu specifikace atributů realizovaného formou
řetězce. Tento zdrojový kód naleznete na adrese <a
href="https://github.com/tisnik/presentations/blob/master/assembler/multiple_sections_1/sections1.s">https://github.com/tisnik/presentations/blob/master/assembler/multiple_sections_1/sections1.s</a>:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
.intel_syntax noprefix
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=1
sys_write=4
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
&nbsp;
<i># ruzne sekce (segmenty) se specifickymi atributy</i>
&nbsp;
<strong>.section .section_a</strong>
<strong>.section .section_b,"x"</strong>
<strong>.section .section_c,"a"</strong>
<strong>.section .section_d,"l"</strong>
<strong>.section .section_e,"w"</strong>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"     <i># string, ktery JE ukoncen nulou</i>
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        mov   eax, sys_write         <i># cislo syscallu pro funkci "write"</i>
        mov   ebx, 1                 <i># standardni vystup</i>
        mov   ecx, offset hello_lbl  <i># adresa retezce, ktery se ma vytisknout</i>
        mov   edx, 13                <i># pocet znaku, ktere se maji vytisknout</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
&nbsp;
        mov   eax, sys_exit          <i># cislo sycallu pro funkci "exit"</i>
        mov   ebx, 0                 <i># exit code = 0</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výpis všech sekcí z&nbsp;objektového souboru i z&nbsp;výsledného binárního souboru</h2>

<p>V&nbsp;prvním kroku provedeme překlad <a href="#k16">výše uvedeného</a>
zdrojového textu do objektového souboru a ve druhém kroku necháme linker
vytvořit spustitelný nativní soubor <strong>a.out</strong>:</p>

<pre>
$ <strong>as sections1.s -o sections1.o</strong>
$ <strong>ld -s sections1.o</strong>
</pre>

<p>V&nbsp;objektovém souboru by se měly nacházet deklarace všech sekcí, a to
včetně našich pěti sekcí. To ostatně jednoduše zjistíme nástrojem
<strong>objdump</strong>. Povšimněte si, že tyto sekce mají nulovou velikost a
různě nastavené atributy (READONLY, CODE, ALLOC, CONTENTS, DATA atd.):</p>

<pre>
$ <strong>objdump -h sections1.o</strong>
&nbsp;
sections1.o:     file format elf64-x86-64
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000022  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         0000000e  0000000000000000  0000000000000000  00000062  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000070  2**0
                  ALLOC
  3 .section_a    00000000  0000000000000000  0000000000000000  00000070  2**0
                  CONTENTS, READONLY
  4 .section_b    00000000  0000000000000000  0000000000000000  00000070  2**0
                  CONTENTS, READONLY, CODE
  5 .section_c    00000000  0000000000000000  0000000000000000  00000070  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .section_d    00000000  0000000000000000  0000000000000000  00000070  2**0
                  CONTENTS, READONLY
  7 .section_e    00000000  0000000000000000  0000000000000000  00000070  2**0
                  CONTENTS
</pre>

<p>Naproti tomu se ve spustitelném souboru <strong>a.out</strong> nachází pouze
sekce s&nbsp;nenulovou délkou. Opět si to velmi snadno ověříme nástrojem
<strong>objdump</strong>:</p>

<pre>
$ <strong>objdump -h a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000022  0000000000401000  0000000000401000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  0000000000402000  0000000000402000  00002000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Deklarace většího množství sekcí obsahujících statická data</h2>

<p>Zdrojový kód <a href="#k16">ze šestnácté kapitoly</a> nyní nepatrně
upravíme, a to konkrétně takovým způsobem, že do každé nově definované sekce
bude přidán řetězec, tedy statická data. Výsledný zdrojový kód je dostupný na
adrese <a
href="https://github.com/tisnik/presentations/blob/master/assembler/multiple_sections_2/sections2.s">https://github.com/tisnik/presentations/blob/master/assembler/multiple_sections_2/sections2.s</a>:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
.intel_syntax noprefix
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=1
sys_write=4
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
&nbsp;
<i># ruzne sekce (segmenty) se specifickymi atributy</i>
&nbsp;
<strong>.section .section_a</strong>
       <strong>.string "SECTION A"</strong>
&nbsp;
<strong>.section .section_b,"x"</strong>
       <strong>.string "SECTION B"</strong>
&nbsp;
<strong>.section .section_c,"a"</strong>
       <strong>.string "SECTION C"</strong>
&nbsp;
<strong>.section .section_d,"l"</strong>
       <strong>.string "SECTION D"</strong>
&nbsp;
<strong>.section .section_e,"w"</strong>
       <strong>.string "SECTION E"</strong>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"     <i># string, ktery JE ukoncen nulou</i>
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        mov   eax, sys_write         <i># cislo syscallu pro funkci "write"</i>
        mov   ebx, 1                 <i># standardni vystup</i>
        mov   ecx, offset hello_lbl  <i># adresa retezce, ktery se ma vytisknout</i>
        mov   edx, 13                <i># pocet znaku, ktere se maji vytisknout</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
&nbsp;
        mov   eax, sys_exit          <i># cislo sycallu pro funkci "exit"</i>
        mov   ebx, 0                 <i># exit code = 0</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Opětovný výpis všech sekcí z&nbsp;objektového souboru i z&nbsp;výsledného binárního souboru</h2>

<p>Opět si po překladu a slinkování zdrojového kódu příkazy:</p>

<pre>
$ <strong>as sections2.s -o sections2.o</strong>
$ <strong>ld -s sections2.o</strong>
</pre>

<p>vypišme všechny sekce, které nástroj <strong>objdump</strong> nalezne
v&nbsp;objektovém kódu. U každé sekce se vypisuje její velikost, virtuální i
fyzická adresa, zarovnání a atributy sekce (segmentu):</p>

<pre>
$ <strong>objdump -h sections2.o</strong>
&nbsp;
sections2.o:     file format elf64-x86-64
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000022  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         0000000e  0000000000000000  0000000000000000  00000062  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000070  2**0
                  ALLOC
  3 .section_a    0000000a  0000000000000000  0000000000000000  00000070  2**0
                  CONTENTS, READONLY
  4 .section_b    0000000a  0000000000000000  0000000000000000  0000007a  2**0
                  CONTENTS, READONLY, CODE
  5 .section_c    0000000a  0000000000000000  0000000000000000  00000084  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .section_d    0000000a  0000000000000000  0000000000000000  0000008e  2**0
                  CONTENTS, READONLY
  7 .section_e    0000000a  0000000000000000  0000000000000000  00000098  2**0
                  CONTENTS
</pre>

<p>Vidíme, že jsou vypsány všechny sekce a námi vytvořené sekce již nejsou
prázdné (mají délku 0xa=10 bajtů).</p>

<p>Neprázdné sekce jsou zachovány i ve výsledném nativním spustitelném souboru,
o čemž se můžeme snadno přesvědčit:</p>

<pre>
$ <strong>objdump -h a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000022  0000000000401000  0000000000401000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .section_c    0000000a  0000000000402000  0000000000402000  00002000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         0000000e  000000000040300a  000000000040300a  0000200a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .section_a    0000000a  0000000000000000  0000000000000000  00002018  2**0
                  CONTENTS, READONLY
  4 .section_b    0000000a  0000000000000000  0000000000000000  00002022  2**0
                  CONTENTS, READONLY, CODE
  5 .section_d    0000000a  0000000000000000  0000000000000000  0000202c  2**0
                  CONTENTS, READONLY
  6 .section_e    0000000a  0000000000000000  0000000000000000  00002036  2**0
                  CONTENTS
</pre>

<p>Názvy sekcí nalezneme i v&nbsp;tabulce symbolů:</p>

<pre>
$ <strong>objdump -t sections2.o</strong>
&nbsp;
sections2.o:     file format elf64-x86-64
&nbsp;
SYMBOL TABLE:
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000001 l       *ABS*  0000000000000000 sys_exit
0000000000000004 l       *ABS*  0000000000000000 sys_write
0000000000000000 l    d  .section_a     0000000000000000 .section_a
0000000000000000 l    d  .section_b     0000000000000000 .section_b
0000000000000000 l    d  .section_c     0000000000000000 .section_c
0000000000000000 l    d  .section_d     0000000000000000 .section_d
0000000000000000 l    d  .section_e     0000000000000000 .section_e
0000000000000000 l       .data  0000000000000000 hello_lbl
0000000000000000 g       .text  0000000000000000 _start
</pre>

<p>A konečně si ukažme výpis obsahu jednotlivých sekcí. I zde nám pomůže
nástroj <strong>objdump</strong>:</p>

<pre>
$ <strong>objdump -s sections2.o</strong>
&nbsp;
sections2.o:     file format elf64-x86-64
&nbsp;
Contents of section .text:
 0000 b8040000 00bb0100 0000b900 000000ba  ................
 0010 0d000000 cd80b801 000000bb 00000000  ................
 0020 cd80                                 ..              
Contents of section .data:
 0000 48656c6c 6f20576f 726c6421 0a00      Hello World!..  
Contents of section .section_a:
 0000 53454354 494f4e20 4100               SECTION A.      
Contents of section .section_b:
 0000 53454354 494f4e20 4200               SECTION B.      
Contents of section .section_c:
 0000 53454354 494f4e20 4300               SECTION C.      
Contents of section .section_d:
 0000 53454354 494f4e20 4400               SECTION D.      
Contents of section .section_e:
 0000 53454354 494f4e20 4500               SECTION E.      
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;výpisu to sice není příliš
patrné, ale například <strong>SECTION A.</strong> je řetězec.</div></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Objdump Command in Linux with Examples<br />
<a href="https://www.geeksforgeeks.org/objdump-command-in-linux-with-examples/">https://www.geeksforgeeks.org/objdump-command-in-linux-with-examples/</a>
</li>

<li>Linux objdump Command Explained for Beginners (7 Examples)<br />
<a href="https://www.howtoforge.com/linux-objdump-command/">https://www.howtoforge.com/linux-objdump-command/</a>
</li>

<li>objdump - Unix, Linux Command<br />
<a href="https://www.tutorialspoint.com/unix_commands/objdump.htm">https://www.tutorialspoint.com/unix_commands/objdump.htm</a>
</li>

<li>objdump (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Objdump">https://en.wikipedia.org/wiki/Objdump</a>
</li>

<li>Linux Objdump Command Examples (Disassemble a Binary File)<br />
<a href="https://www.thegeekstuff.com/2012/09/objdump-examples/">https://www.thegeekstuff.com/2012/09/objdump-examples/</a>
</li>

<li>How to use the ObjDump tool with x86<br />
<a href="https://resources.infosecinstitute.com/topic/how-to-use-the-objdump-tool-with-x86/">https://resources.infosecinstitute.com/topic/how-to-use-the-objdump-tool-with-x86/</a>
</li>

<li>10+ objdump Command Examples in Linux<br />
<a href="https://www.sanfoundry.com/objdump-command-usage-examples-in-linux/">https://www.sanfoundry.com/objdump-command-usage-examples-in-linux/</a>
</li>

<li>objdump(1) &ndash; Linux manual page<br />
<a href="https://www.man7.org/linux/man-pages/man1/objdump.1.html">https://www.man7.org/linux/man-pages/man1/objdump.1.html</a>
</li>

<li>Object file (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Object_file">https://en.wikipedia.org/wiki/Object_file</a>
</li>

<li>Executable and Linkable Format<br />
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a>
</li>

<li>Basic Linker Script Concepts<br />
<a href="https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/binutils/docs/ld/Basic-Script-Concepts.html#Basic-Script-Concepts">https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/binutils/docs/ld/Basic-Script-Concepts.html#Basic-Script-Concepts</a>
</li>

<li>virtual and physical addresses of sections in elf files<br />
<a href="https://stackoverflow.com/questions/6218384/virtual-and-physical-addresses-of-sections-in-elf-files">https://stackoverflow.com/questions/6218384/virtual-and-physical-addresses-of-sections-in-elf-files</a>
</li>

<li>Executable and Linkable Format<br />
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a>
</li>

<li>ELF 101: a Linux executable walkthrough<br />
<a href="https://upload.wikimedia.org/wikipedia/commons/e/e4/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png">https://upload.wikimedia.org/wikipedia/commons/e/e4/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png</a>
</li>

<li>ELF (Executable and Linkable Format)<br />
<a href="https://wiki.osdev.org/ELF">https://wiki.osdev.org/ELF</a>
</li>

<li>elf(5) — Linux manual page<br />
<a href="https://www.man7.org/linux/man-pages/man5/elf.5.html">https://www.man7.org/linux/man-pages/man5/elf.5.html</a>
</li>

<li>What does each column of objdump's Symbol table mean?<br />
<a href="https://stackoverflow.com/questions/6666805/what-does-each-column-of-objdumps-symbol-table-mean">https://stackoverflow.com/questions/6666805/what-does-each-column-of-objdumps-symbol-table-mean</a>
</li>

<li>Category:book:X86 Assembly<br />
<a href="https://en.wikibooks.org/wiki/Category:Book:X86_Assembly">https://en.wikibooks.org/wiki/Category:Book:X86_Assembly</a>
</li>

<li>x86 Assembly/GNU assembly syntax<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax">https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax</a>
</li>

<li>Symbol Table<br />
<a href="https://wiki.osdev.org/Symbol_Table">https://wiki.osdev.org/Symbol_Table</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

