<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu formátu WebAssembly: SIMD (vektorové) operace, druhá část</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu formátu WebAssembly: SIMD (vektorové) operace, druhá část</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve WebAssembly je definováno přibližně dvě stě různých SIMD (vektorových) instrukcí. Minule jsme si ukázali jen některé z nich. Dnes si popíšeme některé další vektorové instrukce, z nichž některé umožňují provádění i dosti složitých operací (zhruba na úrovni SSE2).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu formátu WebAssembly: SIMD (vektorové) operace, 2 část</a></p>
<p><a href="#k02">2. Krátké připomenutí: instrukce určené pro součet vektorů</a></p>
<p><a href="#k03">3. Aritmetické operace součtu, rozdílu a změny znaménka prováděné s&nbsp;celými vektory</a></p>
<p><a href="#k04">4. Způsob překladu funkcí z&nbsp;demonstračního příkladu do instrukcí WebAssembly</a></p>
<p><a href="#k05">5. Tabulka se všemi instrukcemi pro součet, rozdíl a změnu znaménka celých vektorů</a></p>
<p><a href="#k06">6. Aritmetická operace součinu prvků vektorů</a></p>
<p><a href="#k07">7. Překlad operace součinu prvků vektorů s&nbsp;využitím podporovaných instrukcí</a></p>
<p><a href="#k08">8. Tabulka s&nbsp;instrukcemi pro součin odpovídajících si prvků vektorů</a></p>
<p><a href="#k09">9. Způsob překladu součinu prvků vektorů typu <strong>byte</strong></a></p>
<p><a href="#k10">10. Aritmetická operace podílu prvků vektorů</a></p>
<p><a href="#k11">11. Překlad operace podílu prvků vektorů s&nbsp;využitím podporovaných instrukcí</a></p>
<p><a href="#k12">12. Tabulka s&nbsp;instrukcemi pro podíl odpovídajících si prvků vektorů</a></p>
<p><a href="#k13">13. Instrukce pro konstrukci nového vektoru</a></p>
<p><a href="#k14">14. Instrukce pro extrakci prvku i pro zpětný zápis prvku do vektoru</a></p>
<p><a href="#k15">15. Překlad složitějších vektorových operací: výpočet skalárního součinu dvou vektorů</a></p>
<p><a href="#k16">16. Výpočet druhé odmocniny prvků vektorů typu <strong>float</strong> a <strong>double</strong></a></p>
<p><a href="#k17">17. Instrukce sloužící pro porovnání odpovídajících si prvků vektorů</a></p>
<p><a href="#k18">18. Tabulka se všemi doposud popsanými instrukcemi</a></p>
<p><a href="#k19">19. Články o SIMD, které doposud na Rootu vyšly</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu formátu WebAssembly: SIMD (vektorové) operace, druhá část</h2>

<p>Na <a
href="https://www.root.cz/clanky/pohled-pod-kapotu-formatu-webassembly-simd-vektorove-operace/">předchozí
článek</a> dnes navážeme. Popíšeme si totiž další SIMD (vektorové) instrukce,
které jsou oficiálně popsány ve WebAssembly a jsou i podporovány většinou
implementací tohoto virtuálního stroje (důležité je zejména to, že jsou
podporovány všemi prohlížeči). Ve WebAssembly je přitom definováno přibližně
200 těchto instrukcí &ndash; zajímavé však je, že některé instrukce chybí
(resp.&nbsp;chybí jejich varianty pro určité typy vektorů), takže instrukční
soubor není z&nbsp;tohoto pohledu ortogonální.</p>

<p>Překlad všech dále uvedených demonstračních příkladů budeme provádět
následující sekvenci příkazů. První dva příkazy slouží pro překlad do Web
Assembly, poslední příkaz pak zpětným překladem ukáže, jaké instrukce jsou
uloženy ve výsledném binárním souboru:</p>

<pre>
clang -Os <strong>-msimd128</strong> --target=wasm32 -emit-llvm -c -S ${1}.c
llc -march=wasm32 -filetype=obj ${1}.ll -o ${1}.wasm
wasm-objdump -d ${1}.wasm
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Krátké připomenutí: instrukce určené pro součet vektorů</h2>

<p>V&nbsp;předchozím článku jsme si kromě dalších informací popsali i
instrukce, které zajišťují součet vektorů, tj.&nbsp;takové instrukce, jež
provádí součet prvek po prvku. Těchto instrukcí je ve WebAssembly definováno
celkem šest, což odpovídá i všem v&nbsp;současnosti podporovaným typům vektorů.
Všechny instrukce určené pro součet vektorů jsou vypsány v&nbsp;následující
tabulce. Z&nbsp;pohledu pojmenování instrukcí se jedná o &bdquo;běžný&ldquo;
součet (<strong>add</strong>), ovšem prováděný s&nbsp;hodnotami typu, které
jsou uvedeny v&nbsp;prefixu názvu instrukce (což je pro WebAssembly
typické):</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Struktura vektorů, které se sčítají</th></tr>
<tr><td>fd 6e   </td><td>i8x16.add</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 8e 01</td><td>i16x8.add</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd ae 01</td><td>i32x4.add</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd ce 01</td><td>i64x2.add</td><td>2 prvky typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd e4 01</td><td>f32x4.add</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd f0 01</td><td>f64x2.add</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že všechny tyto vektorové
instrukce začínají prefixem <strong>0xfd</strong>, což je prefix použitý pro
naprostou většinu vektorových instrukcí. Dále je zajímavé, že operační kód
instrukce pro součet vektorů, které obsahují prvky typu <strong>byte</strong>,
má délku dvou bajtů (včetně již zmíněného prefixu), zatímco u ostatních čtyř
typů vektorů je instrukční kód o bajt delší.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Aritmetické operace součtu, rozdílu a změny znaménka prováděné s&nbsp;celými vektory</h2>

<p>Kromě součtu vektorů nabízí WebAssembly i možnost provádění dalších operací
s&nbsp;odpovídajícími si prvky dvou vektorů nebo s&nbsp;prvky jediného vektoru.
Nabídka těchto operací se liší podle toho, zda vektory obsahují celočíselné
hodnoty nebo hodnoty s&nbsp;plovoucí řádovou čárkou, ovšem nezávisle na typu
prvků jsou tři operace společné a plně podporované: součet vektorů (ten již
známe), rozdíl vektorů a otočení znaménka u všech prvků jednoho vektoru.</p>

<p>V&nbsp;dnešním prvním demonstračním příkladu si vyzkoušíme, jakým způsobem
jsou tyto operace přeloženy do instrukcí WebAssembly. V&nbsp;příkladu nejdříve
nadefinovány všechny podporované typy vektorů, tj.&nbsp;vektory se šestnácti
prvky typu <i>bajt (byte)</i> až po vektory se dvěma prvky typu <i>double</i>
(ovšem šířka vektorů je stále 128 bitů):</p>

<pre>
typedef   signed char           <strong>i8x16</strong> __attribute__((vector_size(16)));
typedef unsigned char           <strong>u8x16</strong> __attribute__((vector_size(16)));
typedef   signed short int      <strong>i16x8</strong> __attribute__((vector_size(16)));
typedef unsigned short int      <strong>u16x8</strong> __attribute__((vector_size(16)));
typedef   signed int            <strong>i32x4</strong> __attribute__((vector_size(16)));
typedef unsigned int            <strong>u32x4</strong> __attribute__((vector_size(16)));
typedef   signed long long int  <strong>i64x2</strong> __attribute__((vector_size(16)));
typedef unsigned long long int  <strong>u64x2</strong> __attribute__((vector_size(16)));
typedef float                   <strong>f32x4</strong> __attribute__((vector_size(16)));
typedef double                  <strong>f64x2</strong> __attribute__((vector_size(16)));
</pre>

<p>Následně, abychom nemuseli stále opisovat prakticky stejný kód, jsou
jednotlivé operace nadefinovány formou maker:</p>

<pre>
#define NEG(type) type <strong>neg_##type</strong>(type x) {return -x;}
#define ADD(type) type <strong>add_##type</strong>(type x, type y) {return x+y;}
#define SUB(type) type <strong>sub_##type</strong>(type x, type y) {return x-y;}
</pre>

<p>Každé makro je expandováno na funkci, která ve svém jménu obsahuje příslušný
typ. Pokud například zavoláme první makro s&nbsp;typem <strong>i8x16</strong>,
provede se expanze na:</p>

<pre>
i8x16 <strong>neg_i8x16</strong>(i8x16 x)
{
    return -x;
}
</pre>

<p>Dále si vytvoříme další pomocné makro, které se expanduje na sekvenci tří
předchozích maker. Zavoláním tohoto makra dosáhneme expanzi do třiceti
funkcí:</p>

<pre>
#define ALL(type) \
    NEG(type) \
    ADD(type) \
    SUB(type)
&nbsp;
ALL(i8x16)
ALL(u8x16)
ALL(i16x8)
ALL(u16x8)
ALL(i32x4)
ALL(u32x4)
ALL(i64x2)
ALL(u64x2)
ALL(f32x4)
ALL(f64x2)
</pre>

<p><div class="rs-tip-major">Poznámka: makrosystém jazyka C sice můžeme
považovat za nebezpečný, ale může být velmi užitečný.</div></p>

<p>Celý zdrojový kód dnešního prvního demonstračního příkladu vypadá
následovně:</p>

<pre>
typedef   signed char           <strong>i8x16</strong> __attribute__((vector_size(16)));
typedef unsigned char           <strong>u8x16</strong> __attribute__((vector_size(16)));
typedef   signed short int      <strong>i16x8</strong> __attribute__((vector_size(16)));
typedef unsigned short int      <strong>u16x8</strong> __attribute__((vector_size(16)));
typedef   signed int            <strong>i32x4</strong> __attribute__((vector_size(16)));
typedef unsigned int            <strong>u32x4</strong> __attribute__((vector_size(16)));
typedef   signed long long int  <strong>i64x2</strong> __attribute__((vector_size(16)));
typedef unsigned long long int  <strong>u64x2</strong> __attribute__((vector_size(16)));
typedef float                   <strong>f32x4</strong> __attribute__((vector_size(16)));
typedef double                  <strong>f64x2</strong> __attribute__((vector_size(16)));
&nbsp; 
#define NEG(type) type <strong>neg_##type</strong>(type x) {return -x;}
#define ADD(type) type <strong>add_##type</strong>(type x, type y) {return x+y;}
#define SUB(type) type <strong>sub_##type</strong>(type x, type y) {return x-y;}
&nbsp; 
#define ALL(type) \
    NEG(type) \
    ADD(type) \
    SUB(type)
&nbsp; 
ALL(i8x16)
ALL(u8x16)
ALL(i16x8)
ALL(u16x8)
ALL(i32x4)
ALL(u32x4)
ALL(i64x2)
ALL(u64x2)
ALL(f32x4)
ALL(f64x2)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Způsob překladu funkcí z&nbsp;demonstračního příkladu do instrukcí WebAssembly</h2>

<p>Po překladu demonstračního příkladu <a href="#k03">z&nbsp;předchozí
kapitoly</a> z&nbsp;céčka do WebAssembly můžeme použít již dříve popsaný
nástroj <strong>wasm-objdump</strong> pro zpětný překlad z&nbsp;bajtkódu do
čitelné sekvence (strojových) instrukcí. Získat bychom měli zpětný překlad
celkem třiceti funkcí, protože jsme (přes makra) vygenerovali tři céčkovské
funkce pro každý z&nbsp;deseti datových typů.</p>

<p>Všechny přeložené funkce mají podobnou strukturu. Pro funkce s&nbsp;jediným
parametrem vypadá tato struktura následovně:</p>

<pre>
func[0] <strong>&lt;jméno_operace_jméno_datového_typu&gt;</strong>:
  local.get 0
  <i>... příslušná vektorová operace ...</i>
  end
</pre>

<p>Naopak pro funkce se dvěma parametry se struktura nepatrně změní do
podoby:</p>

<pre>
func[0] <strong>&lt;jméno_operace_jméno_datového_typu&gt;</strong>:
  local.get 0
  local.get 1
  <i>... příslušná vektorová operace ...</i>
  end
</pre>

<p><div class="rs-tip-major">Poznámka: to ovšem znamená, že i když jsou do
přeložených funkcí předávány vektory, je bajtkód do značné míry shodný
s&nbsp;funkcemi, do kterých by se předávaly skalární hodnoty (či jen jedna
hodnota).</div></p>

<p>Podívejme se nyní na výsledek překladu:</p>

<pre>
simd_B.wasm:    file format wasm 0x1
&nbsp;
Code Disassembly:
&nbsp;
000065 func[0] <strong>&lt;neg_i8x16&gt;</strong>:
 000066: 20 00                      | local.get 0
 000068: fd 61                      | i8x16.neg
 00006a: 0b                         | end
&nbsp;
00006c func[1] <strong>&lt;add_i8x16&gt;</strong>:
 00006d: 20 01                      | local.get 1
 00006f: 20 00                      | local.get 0
 000071: fd 6e                      | i8x16.add
 000073: 0b                         | end
&nbsp;
000075 func[2] <strong>&lt;sub_i8x16&gt;</strong>:
 000076: 20 00                      | local.get 0
 000078: 20 01                      | local.get 1
 00007a: fd 71                      | i8x16.sub
 00007c: 0b                         | end
&nbsp;
00007e func[3] <strong>&lt;neg_u8x16&gt;</strong>:
 00007f: 20 00                      | local.get 0
 000081: fd 61                      | i8x16.neg
 000083: 0b                         | end
&nbsp;
000085 func[4] <strong>&lt;add_u8x16&gt;</strong>:
 000086: 20 01                      | local.get 1
 000088: 20 00                      | local.get 0
 00008a: fd 6e                      | i8x16.add
 00008c: 0b                         | end
&nbsp;
00008e func[5] <strong>&lt;sub_u8x16&gt;</strong>:
 00008f: 20 00                      | local.get 0
 000091: 20 01                      | local.get 1
 000093: fd 71                      | i8x16.sub
 000095: 0b                         | end
&nbsp;
000097 func[6] <strong>&lt;neg_i16x8&gt;</strong>:
 000098: 20 00                      | local.get 0
 00009a: fd 81 01                   | i16x8.neg
 00009d: 0b                         | end
&nbsp;
00009f func[7] <strong>&lt;add_i16x8&gt;</strong>:
 0000a0: 20 01                      | local.get 1
 0000a2: 20 00                      | local.get 0
 0000a4: fd 8e 01                   | i16x8.add
 0000a7: 0b                         | end
&nbsp;
0000a9 func[8] <strong>&lt;sub_i16x8&gt;</strong>:
 0000aa: 20 00                      | local.get 0
 0000ac: 20 01                      | local.get 1
 0000ae: fd 91 01                   | i16x8.sub
 0000b1: 0b                         | end
&nbsp;
0000b3 func[9] <strong>&lt;neg_u16x8&gt;</strong>:
 0000b4: 20 00                      | local.get 0
 0000b6: fd 81 01                   | i16x8.neg
 0000b9: 0b                         | end
&nbsp;
0000bb func[10] <strong>&lt;add_u16x8&gt;</strong>:
 0000bc: 20 01                      | local.get 1
 0000be: 20 00                      | local.get 0
 0000c0: fd 8e 01                   | i16x8.add
 0000c3: 0b                         | end
&nbsp;
0000c5 func[11] <strong>&lt;sub_u16x8&gt;</strong>:
 0000c6: 20 00                      | local.get 0
 0000c8: 20 01                      | local.get 1
 0000ca: fd 91 01                   | i16x8.sub
 0000cd: 0b                         | end
&nbsp;
0000cf func[12] <strong>&lt;neg_i32x4&gt;</strong>:
 0000d0: 20 00                      | local.get 0
 0000d2: fd a1 01                   | i32x4.neg
 0000d5: 0b                         | end
&nbsp;
0000d7 func[13] <strong>&lt;add_i32x4&gt;</strong>:
 0000d8: 20 01                      | local.get 1
 0000da: 20 00                      | local.get 0
 0000dc: fd ae 01                   | i32x4.add
 0000df: 0b                         | end
&nbsp;
0000e1 func[14] <strong>&lt;sub_i32x4&gt;</strong>:
 0000e2: 20 00                      | local.get 0
 0000e4: 20 01                      | local.get 1
 0000e6: fd b1 01                   | i32x4.sub
 0000e9: 0b                         | end
&nbsp;
0000eb func[15] <strong>&lt;neg_u32x4&gt;</strong>:
 0000ec: 20 00                      | local.get 0
 0000ee: fd a1 01                   | i32x4.neg
 0000f1: 0b                         | end
&nbsp;
0000f3 func[16] <strong>&lt;add_u32x4&gt;</strong>:
 0000f4: 20 01                      | local.get 1
 0000f6: 20 00                      | local.get 0
 0000f8: fd ae 01                   | i32x4.add
 0000fb: 0b                         | end
&nbsp;
0000fd func[17] <strong>&lt;sub_u32x4&gt;</strong>:
 0000fe: 20 00                      | local.get 0
 000100: 20 01                      | local.get 1
 000102: fd b1 01                   | i32x4.sub
 000105: 0b                         | end
&nbsp;
000107 func[18] <strong>&lt;neg_i64x2&gt;</strong>:
 000108: 20 00                      | local.get 0
 00010a: fd c1 01                   | i64x2.neg
 00010d: 0b                         | end
&nbsp;
00010f func[19] <strong>&lt;add_i64x2&gt;</strong>:
 000110: 20 01                      | local.get 1
 000112: 20 00                      | local.get 0
 000114: fd ce 01                   | i64x2.add
 000117: 0b                         | end
&nbsp;
000119 func[20] <strong>&lt;sub_i64x2&gt;</strong>:
 00011a: 20 00                      | local.get 0
 00011c: 20 01                      | local.get 1
 00011e: fd d1 01                   | i64x2.sub
 000121: 0b                         | end
&nbsp;
000123 func[21] <strong>&lt;neg_u64x2&gt;</strong>:
 000124: 20 00                      | local.get 0
 000126: fd c1 01                   | i64x2.neg
 000129: 0b                         | end
&nbsp;
00012b func[22] <strong>&lt;add_u64x2&gt;</strong>:
 00012c: 20 01                      | local.get 1
 00012e: 20 00                      | local.get 0
 000130: fd ce 01                   | i64x2.add
 000133: 0b                         | end
&nbsp;
000135 func[23] <strong>&lt;sub_u64x2&gt;</strong>:
 000136: 20 00                      | local.get 0
 000138: 20 01                      | local.get 1
 00013a: fd d1 01                   | i64x2.sub
 00013d: 0b                         | end
&nbsp;
00013f func[24] <strong>&lt;neg_f32x4&gt;</strong>:
 000140: 20 00                      | local.get 0
 000142: fd e1 01                   | f32x4.neg
 000145: 0b                         | end
&nbsp;
000147 func[25] <strong>&lt;add_f32x4&gt;</strong>:
 000148: 20 00                      | local.get 0
 00014a: 20 01                      | local.get 1
 00014c: fd e4 01                   | f32x4.add
 00014f: 0b                         | end
&nbsp;
000151 func[26] <strong>&lt;sub_f32x4&gt;</strong>:
 000152: 20 00                      | local.get 0
 000154: 20 01                      | local.get 1
 000156: fd e5 01                   | f32x4.sub
 000159: 0b                         | end
&nbsp;
00015b func[27] <strong>&lt;neg_f64x2&gt;</strong>:
 00015c: 20 00                      | local.get 0
 00015e: fd ed 01                   | f64x2.neg
 000161: 0b                         | end
&nbsp;
000163 func[28] <strong>&lt;add_f64x2&gt;</strong>:
 000164: 20 00                      | local.get 0
 000166: 20 01                      | local.get 1
 000168: fd f0 01                   | f64x2.add
 00016b: 0b                         | end
&nbsp;
00016d func[29] <strong>&lt;sub_f64x2&gt;</strong>:
 00016e: 20 00                      | local.get 0
 000170: 20 01                      | local.get 1
 000172: fd f1 01                   | f64x2.sub
 000175: 0b                         | end
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tabulka se všemi instrukcemi pro součet, rozdíl a změnu znaménka celých vektorů</h2>

<p>Všechny doposud popsané vektorové instrukce jsou shrnuty v&nbsp;následující
tabulce. Opět je z&nbsp;ní patrné použití prefixu <strong>0xFD</strong> a
taktéž to, že operace s&nbsp;vektory s&nbsp;prvky typu bajt mají kratší
operační kód:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Operace</th><th>Struktura vektorů</th></tr>
<tr><td>fd 61</td><td>i8x16.neg</td><td>otočení znaménka</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 6e</td><td>i8x16.add</td><td>součet vektorů</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 71</td><td>i8x16.sub</td><td>rozdíl vektorů</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd 81 01</td><td>i16x8.neg</td><td>otočení znaménka</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 8e 01</td><td>i16x8.add</td><td>součet vektorů</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 91 01</td><td>i16x8.sub</td><td>rozdíl vektorů</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd a1 01</td><td>i32x4.neg</td><td>otočení znaménka</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd ae 01</td><td>i32x4.add</td><td>součet vektorů</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd b1 01</td><td>i32x4.sub</td><td>rozdíl vektorů</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd c1 01</td><td>i64x2.neg</td><td>otočení znaménka</td><td>2 prvky typu <i>quat word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd ce 01</td><td>i64x2.add</td><td>součet vektorů</td><td>2 prvky typu <i>quat word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d1 01</td><td>i64x2.sub</td><td>rozdíl vektorů</td><td>2 prvky typu <i>quat word</i> (2&times;64 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd e1 01</td><td>f32x4.neg</td><td>otočení znaménka</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd e4 01</td><td>f32x4.add</td><td>součet vektorů</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd e5 01</td><td>f32x4.sub</td><td>rozdíl vektorů</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd ed 01</td><td>f64x2.neg</td><td>otočení znaménka</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd f0 01</td><td>f64x2.add</td><td>součet vektorů</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd f1 01</td><td>f64x2.sub</td><td>rozdíl vektorů</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Aritmetická operace součinu prvků vektorů</h2>

<p>Další typickou aritmetickou operací je operace součinu odpovídajících si
prvků vektorů (tedy nikoli vektorový součin). Tuto operaci vysvětlujeme
v&nbsp;samostatné kapitole z&nbsp;toho důvodu, že není podporovaná pro všechny
typy vektorů a z&nbsp;tohoto důvodu musí překladače do WebAssembly používat
&bdquo;rozepsání&ldquo; této operace do poměrně dlouhé sekvence instrukcí. Tuto
vlastnost WebAssembly je nutné znát, protože v&nbsp;opačném případě by se
mohlo stát, že přepisem algoritmu do vektorové podoby by se rychlost výsledného
programu mohla (paradoxně) snížit.</p>

<p>Součin prvků vektorů prvek po prvku si otestujeme na příkladu, který vznikl
nepatrnou úpravou původního demonstračního příkladu:</p>

<pre>
typedef signed   char           <strong>i8x16</strong> __attribute__((vector_size(16)));
typedef unsigned char           <strong>u8x16</strong> __attribute__((vector_size(16)));
typedef signed   short int      <strong>i16x8</strong> __attribute__((vector_size(16)));
typedef unsigned short int      <strong>u16x8</strong> __attribute__((vector_size(16)));
typedef signed   int            <strong>i32x4</strong> __attribute__((vector_size(16)));
typedef unsigned int            <strong>u32x4</strong> __attribute__((vector_size(16)));
typedef   signed long long int  <strong>i64x2</strong> __attribute__((vector_size(16)));
typedef unsigned long long int  <strong>u64x2</strong> __attribute__((vector_size(16)));
typedef float                   <strong>f32x4</strong> __attribute__((vector_size(16)));
typedef double                  <strong>f64x2</strong> __attribute__((vector_size(16)));
&nbsp; 
#define MUL(type) type <strong>mul_##type</strong>(type x, type y) {return (type)(x*y);}
&nbsp; 
#define ALL(type) \
    MUL(type)
&nbsp; 
ALL(i8x16)
ALL(u8x16)
ALL(i16x8)
ALL(u16x8)
ALL(i32x4)
ALL(u32x4)
ALL(i64x2)
ALL(u64x2)
ALL(f32x4)
ALL(f64x2)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad operace součinu prvků vektorů s&nbsp;využitím podporovaných instrukcí</h2>

<p>Výsledek zpětného překladu z&nbsp;bajtkódu WebAssembly do čitelné podoby je
poměrně rozsáhlý &ndash; jeho celková velikost dosahuje dvanácti kilobajtů! Je
tomu tak z&nbsp;toho důvodu, že násobení vektorů prvek po prvku není
podporováno pro všechny typy vektorů. Ukažme si prozatím výsledky pro
podporované typy vektorů (a tedy pro existující instrukce WebAssembly):</p>

<pre>
000212 func[2] <strong>&lt;mul_i16x8&gt;</strong>:
 000213: 20 01                      | local.get 1
 000215: 20 00                      | local.get 0
 000217: fd 95 01                   | i16x8.mul
 00021a: 0b                         | end
&nbsp;
00021c func[3] <strong>&lt;mul_u16x8&gt;</strong>:
 00021d: 20 01                      | local.get 1
 00021f: 20 00                      | local.get 0
 000221: fd 95 01                   | i16x8.mul
 000224: 0b                         | end
&nbsp;
000226 func[4] <strong>&lt;mul_i32x4&gt;</strong>:
 000227: 20 01                      | local.get 1
 000229: 20 00                      | local.get 0
 00022b: fd b5 01                   | i32x4.mul
 00022e: 0b                         | end
&nbsp;
000230 func[5] <strong>&lt;mul_u32x4&gt;</strong>:
 000231: 20 01                      | local.get 1
 000233: 20 00                      | local.get 0
 000235: fd b5 01                   | i32x4.mul
 000238: 0b                         | end
&nbsp;
00023a func[6] <strong>&lt;mul_i64x2&gt;</strong>:
 00023b: 20 01                      | local.get 1
 00023d: 20 00                      | local.get 0
 00023f: fd d5 01                   | i64x2.mul
 000242: 0b                         | end
&nbsp;
000244 func[7] <strong>&lt;mul_u64x2&gt;</strong>:
 000245: 20 01                      | local.get 1
 000247: 20 00                      | local.get 0
 000249: fd d5 01                   | i64x2.mul
 00024c: 0b                         | end
&nbsp;
00024e func[8] <strong>&lt;mul_f32x4&gt;</strong>:
 00024f: 20 00                      | local.get 0
 000251: 20 01                      | local.get 1
 000253: fd e6 01                   | f32x4.mul
 000256: 0b                         | end
&nbsp;
000258 func[9] <strong>&lt;mul_f64x2&gt;</strong>:
 000259: 20 00                      | local.get 0
 00025b: 20 01                      | local.get 1
 00025d: fd f2 01                   | f64x2.mul
 000260: 0b                         | end
</pre>

<p></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Tabulka s&nbsp;instrukcemi pro součin odpovídajících si prvků vektorů</h2>

<p>Všechny instrukce součinu prvků vektorů implementované ve WebAssembly jsou
vypsány v&nbsp;následující tabulce. Opět zde můžeme vidět využití instrukčního
prefixu <strong>fd</strong> a operační kódy instrukcí mají stejnou délku tří
bajtů:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Struktura vektorů, které se násobí</th></tr>
<tr><td>fd 95 01</td><td>i16x8.mul</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd b5 01</td><td>i32x4.mul</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd d5 01</td><td>i64x2.mul</td><td>2 prvky typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd e6 01</td><td>f32x4.mul</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd f2 01</td><td>f64x2.mul</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Způsob překladu součinu prvků vektorů typu <strong>byte</strong></h2>

<p>V&nbsp;případě, že se pokusíme o realizaci vynásobení odpovídajících si
prvků vektorů typu <strong>byte</strong>, bude výsledek překladu do bajtkódu
WebAssembly vypadat zcela odlišně od překladu, který jsme mohli vidět <a
href="#k07">v&nbsp;sedmé kapitole</a>. Je tomu tak z&nbsp;toho důvodu, že chybí
příslušná SIMD instrukce, která by se měla jmenovat <strong>i8x16.mul</strong>.
Překladač tedy musí provádět násobení skutečně prvek po prvku, což nebude
příliš rychlé. Ve výsledném bajtkódu můžeme vidět opakující se sekvenci
instrukcí:</p>

<pre>
local.get 1
i8x16.extract_lane_u <strong>n</strong> (pro n=1..15)
local.get 0
i8x16.extract_lane_u <strong>n</strong> (pro n=1..15)
i32.mul
i8x16.replace_lane <strong>n</strong> (pro n=1..15)
</pre>

<p>Výjimkou je vynásobení nejnižších prvků, kde se namísto
<strong>replace_lane</strong> použije instrukce <strong>splat</strong>:</p>

<pre>
local.get 1
i8x16.extract_lane_u 0
local.get 0
i8x16.extract_lane_u 0
i32.mul
i8x16.splat
</pre>

<p><div class="rs-tip-major">Poznámka: instrukce <strong>extract_lane</strong>,
<strong>replace_lane</strong> a <strong>splat</strong> budou vysvětleny <a
href="#k14">ve čtrnácté kapitole</a>.</div></p>

<p>Celá funkce <strong>mul_i8x16</strong> přeložená do bajtkódu bude vypadat
následovně:</p>

<pre>
00004d func[0] <strong>&lt;mul_i8x16&gt;:</strong>
 00004e: 20 01                      | local.get 1
 000050: fd 16 00                   | i8x16.extract_lane_u 0
 000053: 20 00                      | local.get 0
 000055: fd 16 00                   | i8x16.extract_lane_u 0
 000058: 6c                         | i32.mul
 000059: fd 0f                      | i8x16.splat
 00005b: 20 01                      | local.get 1
 00005d: fd 16 01                   | i8x16.extract_lane_u 1
 000060: 20 00                      | local.get 0
 000062: fd 16 01                   | i8x16.extract_lane_u 1
 000065: 6c                         | i32.mul
 000066: fd 17 01                   | i8x16.replace_lane 1
 000069: 20 01                      | local.get 1
 00006b: fd 16 02                   | i8x16.extract_lane_u 2
 00006e: 20 00                      | local.get 0
 000070: fd 16 02                   | i8x16.extract_lane_u 2
 000073: 6c                         | i32.mul
 000074: fd 17 02                   | i8x16.replace_lane 2
 000077: 20 01                      | local.get 1
 000079: fd 16 03                   | i8x16.extract_lane_u 3
 00007c: 20 00                      | local.get 0
 00007e: fd 16 03                   | i8x16.extract_lane_u 3
 000081: 6c                         | i32.mul
 000082: fd 17 03                   | i8x16.replace_lane 3
 000085: 20 01                      | local.get 1
 000087: fd 16 04                   | i8x16.extract_lane_u 4
 00008a: 20 00                      | local.get 0
 00008c: fd 16 04                   | i8x16.extract_lane_u 4
 00008f: 6c                         | i32.mul
 000090: fd 17 04                   | i8x16.replace_lane 4
 000093: 20 01                      | local.get 1
 000095: fd 16 05                   | i8x16.extract_lane_u 5
 000098: 20 00                      | local.get 0
 00009a: fd 16 05                   | i8x16.extract_lane_u 5
 00009d: 6c                         | i32.mul
 00009e: fd 17 05                   | i8x16.replace_lane 5
 0000a1: 20 01                      | local.get 1
 0000a3: fd 16 06                   | i8x16.extract_lane_u 6
 0000a6: 20 00                      | local.get 0
 0000a8: fd 16 06                   | i8x16.extract_lane_u 6
 0000ab: 6c                         | i32.mul
 0000ac: fd 17 06                   | i8x16.replace_lane 6
 0000af: 20 01                      | local.get 1
 0000b1: fd 16 07                   | i8x16.extract_lane_u 7
 0000b4: 20 00                      | local.get 0
 0000b6: fd 16 07                   | i8x16.extract_lane_u 7
 0000b9: 6c                         | i32.mul
 0000ba: fd 17 07                   | i8x16.replace_lane 7
 0000bd: 20 01                      | local.get 1
 0000bf: fd 16 08                   | i8x16.extract_lane_u 8
 0000c2: 20 00                      | local.get 0
 0000c4: fd 16 08                   | i8x16.extract_lane_u 8
 0000c7: 6c                         | i32.mul
 0000c8: fd 17 08                   | i8x16.replace_lane 8
 0000cb: 20 01                      | local.get 1
 0000cd: fd 16 09                   | i8x16.extract_lane_u 9
 0000d0: 20 00                      | local.get 0
 0000d2: fd 16 09                   | i8x16.extract_lane_u 9
 0000d5: 6c                         | i32.mul
 0000d6: fd 17 09                   | i8x16.replace_lane 9
 0000d9: 20 01                      | local.get 1
 0000db: fd 16 0a                   | i8x16.extract_lane_u 10
 0000de: 20 00                      | local.get 0
 0000e0: fd 16 0a                   | i8x16.extract_lane_u 10
 0000e3: 6c                         | i32.mul
 0000e4: fd 17 0a                   | i8x16.replace_lane 10
 0000e7: 20 01                      | local.get 1
 0000e9: fd 16 0b                   | i8x16.extract_lane_u 11
 0000ec: 20 00                      | local.get 0
 0000ee: fd 16 0b                   | i8x16.extract_lane_u 11
 0000f1: 6c                         | i32.mul
 0000f2: fd 17 0b                   | i8x16.replace_lane 11
 0000f5: 20 01                      | local.get 1
 0000f7: fd 16 0c                   | i8x16.extract_lane_u 12
 0000fa: 20 00                      | local.get 0
 0000fc: fd 16 0c                   | i8x16.extract_lane_u 12
 0000ff: 6c                         | i32.mul
 000100: fd 17 0c                   | i8x16.replace_lane 12
 000103: 20 01                      | local.get 1
 000105: fd 16 0d                   | i8x16.extract_lane_u 13
 000108: 20 00                      | local.get 0
 00010a: fd 16 0d                   | i8x16.extract_lane_u 13
 00010d: 6c                         | i32.mul
 00010e: fd 17 0d                   | i8x16.replace_lane 13
 000111: 20 01                      | local.get 1
 000113: fd 16 0e                   | i8x16.extract_lane_u 14
 000116: 20 00                      | local.get 0
 000118: fd 16 0e                   | i8x16.extract_lane_u 14
 00011b: 6c                         | i32.mul
 00011c: fd 17 0e                   | i8x16.replace_lane 14
 00011f: 20 01                      | local.get 1
 000121: fd 16 0f                   | i8x16.extract_lane_u 15
 000124: 20 00                      | local.get 0
 000126: fd 16 0f                   | i8x16.extract_lane_u 15
 000129: 6c                         | i32.mul
 00012a: fd 17 0f                   | i8x16.replace_lane 15
 00012d: 0b                         | end
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Aritmetická operace podílu prvků vektorů</h2>

<p>Z&nbsp;pohledu implementace ve WebAssembly je nejvíce problematická operace
podílu prováděná prvek po prvku. Tato operace totiž není podporována pro
všechny typy vektorů, což se může negativně projevit na výkonu některých
aplikací, které například provádí váhování, normalizaci atd. Ovšem nejdříve si
zopakujme, tak bude vypadat zdrojový kód demonstračního příkladu, který po svém
překladu vygeneruje WebAssembly pro celkem deset variant funkcí pro podíl
odpovídajících si prvků vektorů:</p>

<pre>
typedef signed   char           <strong>i8x16</strong> __attribute__((vector_size(16)));
typedef unsigned char           <strong>u8x16</strong> __attribute__((vector_size(16)));
typedef signed   short int      <strong>i16x8</strong> __attribute__((vector_size(16)));
typedef unsigned short int      <strong>u16x8</strong> __attribute__((vector_size(16)));
typedef signed   int            <strong>i32x4</strong> __attribute__((vector_size(16)));
typedef unsigned int            <strong>u32x4</strong> __attribute__((vector_size(16)));
typedef   signed long long int  <strong>i64x2</strong> __attribute__((vector_size(16)));
typedef unsigned long long int  <strong>u64x2</strong> __attribute__((vector_size(16)));
typedef float                   <strong>f32x4</strong> __attribute__((vector_size(16)));
typedef double                  <strong>f64x2</strong> __attribute__((vector_size(16)));
&nbsp; 
#define DIV(type) type <strong>div_##type</strong>(type x, type y) {return (type)(x/y);}
&nbsp; 
#define ALL(type) \
    DIV(type)
&nbsp; 
ALL(i8x16)
ALL(u8x16)
ALL(i16x8)
ALL(u16x8)
ALL(i32x4)
ALL(u32x4)
ALL(i64x2)
ALL(u64x2)
ALL(f32x4)
ALL(f64x2)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Překlad operace podílu prvků vektorů s&nbsp;využitím podporovaných instrukcí</h2>

<p>Současné verze WebAssembly podporují pouze omezenou možnost výpočtu podílů
odpovídajících si prvků vektorů. Velmi dobře je tato operace podporována pro
vektory obsahující čtyři prvky typu <i>float</i>:</p>

<pre>
0003a6 func[8] <strong>&lt;div_f32x4&gt;</strong>:
 0003a7: 20 00                      | local.get 0
 0003a9: 20 01                      | local.get 1
 0003ab: fd e7 01                   | f32x4.div
 0003ae: 0b                         | end
</pre>

<p>Totéž platí pro vektory obsahující dva prvky typu <i>double</i>:</p>

<pre>
0003b0 func[9] <strong>&lt;div_f64x2&gt;</strong>:
 0003b1: 20 00                      | local.get 0
 0003b3: 20 01                      | local.get 1
 0003b5: fd f3 01                   | f64x2.div
 0003b8: 0b                         | end
</pre>

<p>Ovšem pro vektory obsahující celočíselné hodnoty je již nutné provést
výpočet podílu explicitně prvek po prvku (a tedy dosti neefektivním způsobem).
Příkladem může být podíl 32bitových celočíselných prvků bez znaménka:</p>

<pre>
000330 func[5] <strong>&lt;div_u32x4&gt;</strong>:
 000331: 20 00                      | local.get 0
 000333: fd 1b 00                   | i32x4.extract_lane 0
 000336: 20 01                      | local.get 1
 000338: fd 1b 00                   | i32x4.extract_lane 0
 00033b: 6e                         | i32.div_u
 00033c: fd 11                      | i32x4.splat
 00033e: 20 00                      | local.get 0
 000340: fd 1b 01                   | i32x4.extract_lane 1
 000343: 20 01                      | local.get 1
 000345: fd 1b 01                   | i32x4.extract_lane 1
 000348: 6e                         | i32.div_u
 000349: fd 1c 01                   | i32x4.replace_lane 1
 00034c: 20 00                      | local.get 0
 00034e: fd 1b 02                   | i32x4.extract_lane 2
 000351: 20 01                      | local.get 1
 000353: fd 1b 02                   | i32x4.extract_lane 2
 000356: 6e                         | i32.div_u
 000357: fd 1c 02                   | i32x4.replace_lane 2
 00035a: 20 00                      | local.get 0
 00035c: fd 1b 03                   | i32x4.extract_lane 3
 00035f: 20 01                      | local.get 1
 000361: fd 1b 03                   | i32x4.extract_lane 3
 000364: 6e                         | i32.div_u
 000365: fd 1c 03                   | i32x4.replace_lane 3
 000368: 0b                         | end
</pre>

<p>Totéž platí pro vektory obsahující dva 64bitové prvky bez znaménka:</p>

<pre>
000388 func[7] <strong>&lt;div_u64x2&gt;</strong>:
 000389: 20 00                      | local.get 0
 00038b: fd 1d 00                   | i64x2.extract_lane 0
 00038e: 20 01                      | local.get 1
 000390: fd 1d 00                   | i64x2.extract_lane 0
 000393: 80                         | i64.div_u
 000394: fd 12                      | i64x2.splat
 000396: 20 00                      | local.get 0
 000398: fd 1d 01                   | i64x2.extract_lane 1
 00039b: 20 01                      | local.get 1
 00039d: fd 1d 01                   | i64x2.extract_lane 1
 0003a0: 80                         | i64.div_u
 0003a1: fd 1e 01                   | i64x2.replace_lane 1
 0003a4: 0b                         | end
</pre>

<p><div class="rs-tip-major">Poznámka: podobně se podíl prvků vektorů počítá i
v&nbsp;dalších případech (jen je počet instrukcí delší).</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Tabulka s&nbsp;instrukcemi pro podíl odpovídajících si prvků vektorů</h2>

<p>V&nbsp;bajtkódu funkcí přeložených do WebAssembly, který jsme si ukázali <a
href="#k11">v&nbsp;předchozí kapitole</a>, byly přítomny pouze dvě nové SIMD
instrukce, a to konkrétně instrukce <strong>f32x4.div</strong> a
<strong>f64x2.div</strong>. Tyto instrukce jsou pro úplnost uvedeny
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Struktura vektorů, které se dělí</th></tr>
<tr><td>fd e7 01</td><td>f32x4.div</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd f3 01</td><td>f64x2.div</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce pro konstrukci nového vektoru</h2>

<p>V&nbsp;předchozích demonstračních příkladech jsme se setkali
s&nbsp;instrukcí nazvanou <strong>splat</strong>. Jedná se o instrukci, která
z&nbsp;jediné skalární hodnoty vytvoří celý vektor. Typ vektoru je určen
prefixem instrukce a od typu vektoru se pochopitelně odvozuje i počet jeho
prvků. Těchto instrukcí existuje celkem šest. Není totiž zapotřebí rozlišovat
mezi typy se znaménkem a typy bez znaménka:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Struktura vektorů, které se konstruují</th></tr>
<tr><td>fd 0f</td><td>i8x16.splat</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 10</td><td>i16x8.splat</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 11</td><td>i32x4.splat</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 12</td><td>i64x2.splat</td><td>2 prvky typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 13</td><td>f32x4.splat</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 14</td><td>f64x2.splat</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>

<p>Kromě toho existují i instrukce typu <i>load</i>, které jsou nepatrně
komplikovanější a seznámíme se s&nbsp;nimi příště.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce pro extrakci prvku i pro zpětný zápis prvku do vektoru</h2>

<p>Další sada osmi instrukcí slouží k&nbsp;přečtení hodnoty jediného prvku
z&nbsp;vektoru. Index čteného prvku je uložen ve třetím bajtu tvořícím operační
kód instrukce:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Struktura vektorů</th></tr>
<tr><td>fd 15</td><td>i8x16.extract_lane_s</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 16</td><td>i8x16.extract_lane_u</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 18</td><td>i16x8.extract_lane_s</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 19</td><td>i16x8.extract_lane_u</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 1b</td><td>i32x4.extract_lane  </td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 1d</td><td>i64x2.extract_lane  </td><td>2 prvky typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 1f</td><td>f32x4.extract_lane  </td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 21</td><td>f64x2.extract_lane  </td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>

<p>Ve WebAssembly existují i instrukce s&nbsp;opačným významem, konkrétně
takové instrukce, které ve vektoru změní jediný prvek. Skalární hodnota, která
má být do prvku uložena, musí být umístěna na zásobníku, index modifikovaného
prvku je opět uložen ve třetím bajtu tvořícím operační kód instrukce:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Struktura vektorů</th></tr>
<tr><td>fd 17</td><td>i8x16.replace_lane</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 1a</td><td>i16x8.replace_lane</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 1c</td><td>i32x4.replace_lane</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 1e</td><td>i64x2.replace_lane</td><td>2 prvky typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 20</td><td>f32x4.replace_lane</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 22</td><td>f64x2.replace_lane</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Překlad složitějších vektorových operací: výpočet skalárního součinu dvou vektorů</h2>

<p>S&nbsp;rozvojem neuronových sítí a umělé inteligence (ale nejenom zde) se
začal masivně využívat známý algoritmus pro výpočet skalárního součinu (<i>dot
product</i>, <i>scalar product</i>). Tento algoritmus se používá v&nbsp;oblasti
velkých jazykových modelů (LLM) pro zjišťování podobnosti dlouhých vektorů
s&nbsp;numerickými hodnotami (<i>vector similarity</i>). Kromě klasického
skalárního součinu se v&nbsp;této oblasti používá i tzv.&nbsp;<i>cosinus
similarity</i>, což je varianta skalárního součinu, v&nbsp;níž nezáleží na
délce vektorů, ale pouze na jejich vzájemné orientaci (výpočet je tedy doplněn
o normalizaci vektorů). A toto porovnávání vektorů se v&nbsp;LLM provádí
neustále a většinou je optimalizováno a výpočty běží na GPU.</p>

<p>To však není zdaleka vše. Pokud se zaměříme na oblast klasických neuronových
sítí (<i>NN &ndash; neural networks</i>), zjistíme, že se tyto sítě skládají
z&nbsp;takzvaných <i>perceptronů</i>, což je vlastně značně zjednodušený model
neuronu. A na vstup perceptronu se přivádí nějaké množství numerických vstupů.
Každý z&nbsp;těchto vstupů je váhován, tj.&nbsp;vynásoben určitou konstantou a
výsledky tohoto váhování jsou nakonec sečteny. Když se ovšem nad touto operací
zamyslíme, zjistíme, že se vlastně nejedná o nic jiného, než o aplikaci výpočtu
skalárního součinu. První z&nbsp;vektorů, který do tohoto součinu vstupuje jako
operand, jsou vstupy do neuronu, druhým vektorem je pak vektor vah, které si
neuron zapamatoval. A samotný trénink neuronové sítě vlastně není nic jiného,
než rekonfigurace těchto vah &ndash; vektorů:</p>

<p>Vyzkoušejme si, jakým způsobem se přeloží operace skalárního součinu dvou
vektorů, které obsahují buď čtyři prvky typu <strong>float</strong> nebo osm
prvků typu <strong>double</strong>. Realizace těchto operací v&nbsp;jazyku C je
jednoduchá:</p>

<pre>
typedef float   <strong>f32x4</strong> __attribute__((vector_size(16)));
typedef double  <strong>f64x2</strong> __attribute__((vector_size(16)));
&nbsp;
float <strong>dot_float</strong>(f32x4 x, f32x4 y) {
    return x[0]*y[0]+x[1]*y[1]+x[2]*y[2]+x[3]*y[3];
}
&nbsp;
double <strong>dot_double</strong>(f64x2 x, f64x2 y) {
    return x[0]*y[0]+x[1]*y[1];
}
</pre>

<p>Výsledek překladu první z&nbsp;těchto funkcí do bajtkódu ukazuje, že se pro
výpočet nepoužila žádná specializovaná instrukce určená pro výpočet skalárního
součinu, ale provedl se explicitní součin odpovídajících si prvků, za nimiž
následuje součet všech čtyř mezivýsledků:</p>

<pre>
00004a func[0] <strong>&lt;dot_float&gt;</strong>:
 00004b: 20 00                      | local.get 0
 00004d: fd 1f 03                   | f32x4.extract_lane 3
 000050: 20 01                      | local.get 1
 000052: fd 1f 03                   | f32x4.extract_lane 3
 000055: 94                         | f32.mul
 000056: 20 00                      | local.get 0
 000058: fd 1f 02                   | f32x4.extract_lane 2
 00005b: 20 01                      | local.get 1
 00005d: fd 1f 02                   | f32x4.extract_lane 2
 000060: 94                         | f32.mul
 000061: 20 00                      | local.get 0
 000063: fd 1f 00                   | f32x4.extract_lane 0
 000066: 20 01                      | local.get 1
 000068: fd 1f 00                   | f32x4.extract_lane 0
 00006b: 94                         | f32.mul
 00006c: 20 00                      | local.get 0
 00006e: 20 01                      | local.get 1
 000070: fd e6 01                   | f32x4.mul
 000073: fd 1f 01                   | f32x4.extract_lane 1
 000076: 92                         | f32.add
 000077: 92                         | f32.add
 000078: 92                         | f32.add
 000079: 0b                         | end
</pre>

<p>Totéž platí i pro druhou funkci. Zde se (logicky) provádí jen polovina
výpočtů, protože vektory, které skalárně násobíme, mají poloviční počet
prvků:</p>

<pre>
00007b func[1] <strong>&lt;dot_double&gt;</strong>:
 00007c: 20 00                      | local.get 0
 00007e: fd 21 00                   | f64x2.extract_lane 0
 000081: 20 01                      | local.get 1
 000083: fd 21 00                   | f64x2.extract_lane 0
 000086: a2                         | f64.mul
 000087: 20 00                      | local.get 0
 000089: 20 01                      | local.get 1
 00008b: fd f2 01                   | f64x2.mul
 00008e: fd 21 01                   | f64x2.extract_lane 1
 000091: a0                         | f64.add
 000092: 0b                         | end
</pre>

<p><div class="rs-tip-major">Poznámka: u této důležité operace tedy nejsou SIMD
instrukce použity, což by se však mělo změnit v&nbsp;nové verzi
WebAssembly.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Výpočet druhé odmocniny prvků vektorů typu <strong>float</strong> a <strong>double</strong></h2>

<p>Další často používanou operací, například při zpracování signálů nebo
v&nbsp;počítačové grafice, je výpočet druhé odmocniny všech prvků vektoru. Opět
si ukážeme, jakým způsobem je tato operace přeložena do WebAssembly
v&nbsp;případě, že vektory budou obsahovat prvky typu <strong>float</strong>
nebo <strong>double</strong> (pro celočíselné prvky se druhá odmocnina počítá
méně často a neexistují pro ni ani odpovídající instrukce WebAssembly):</p>

<pre>
float <strong>sqrtf</strong>(float x);
double <strong>sqrt</strong>(double x);
&nbsp;
typedef float   <strong>f32x4</strong> __attribute__((vector_size(16)));
typedef double  <strong>f64x2</strong> __attribute__((vector_size(16)));
&nbsp; 
f32x4 <strong>vector_sqrt_f32x4</strong>(f32x4 x) {
    f32x4 result;
    int i;
    for (i=0; i&lt;4; i++) {
        result[i] = sqrtf(x[i]);
    }
    return result;
}
&nbsp; 
f64x2 <strong>vector_sqrt_f64x2</strong>(f64x2 x) {
    f64x2 result;
    int i;
    for (i=0; i&lt;2; i++) {
        result[i] = sqrt(x[i]);
    }
    return result;
}
</pre>

<p><div class="rs-tip-major">Poznámka: ve funkcích sice používám počítanou
programovou smyčku, ovšem moderní překladače céčka ji dokážou transformovat do
vektorizovaného kódu.</div></p>

<p>Výsledek překladu první funkce do bajtkódu WebAssembly ukazuje, že se
skutečně použila specializovaná instrukce pro výpočet druhé odmocniny prvků
vektorů typu <strong>f32x4</strong>:</p>

<pre>
000043 func[0] <strong>&lt;vector_sqrt_f32x4&gt;</strong>:
 000044: 20 00                      | local.get 0
 000046: fd e3 01                   | f32x4.sqrt
 000049: 0b                         | end
</pre>

<p>V&nbsp;případě druhé funkce se použila opět instrukce <strong>sqrt</strong>,
ovšem tentokrát s&nbsp;prefixem <strong>f64x2</strong>:</p>

<pre>
00004b func[1] <strong>&lt;vector_sqrt_f64x2&gt;</strong>:
 00004c: 20 00                      | local.get 0
 00004e: fd ef 01                   | f64x2.sqrt
 000051: 0b                         | end
</pre>

<p>Zjistili jsme tedy, že v&nbsp;bajtkódu WebAssembly jsou podporovány další
dvě vektorové instrukce:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Struktura vektorů, pro které se počítá druhá odmocnina</th></tr>
<tr><td>fd e3 01</td><td>f32x4.sqrt</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd ef 01</td><td>f64x2.sqrt</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Instrukce sloužící pro porovnání odpovídajících si prvků vektorů</h2>

<p>Poslední sadou instrukcí WebAssembly, s&nbsp;níž se dnes seznámíme, jsou
instrukce, které porovnají odpovídající si prvky dvou vektorů na zvolenou
relaci. Výsledkem těchto operací přitom bude nový vektor obsahující pouze
jedničky a nuly. V&nbsp;případě, že prvky zvolené relaci (například
&bdquo;menší než&ldquo;) odpovídají, bude ve výsledném vektoru zapsána
jednička, v&nbsp;opačném případě nula. Ukažme si jednoduchý příklad:</p>

<pre>
v1:     [1, 2, 3, 4]
v2:     [1, 1, 4, 4]
v1==v2: [1, 0, 0, 1]
v1&gt;v2:  [0, 1, 0, 0]
</pre>

<p>Existuje celkem šest testů na relaci: rovnost, nerovnost, menší než, menší
nebo rovno, větší než a větší nebo rovno. Teoreticky by mělo být možné porovnat
prvky vektorů libovolných typů, přičemž celé porovnání by bylo realizováno
jedinou instrukcí. Ovšem jak uvidíme po překladu dalšího příkladu, některé
instrukce v&nbsp;současné verzi WebAssembly chybí a tudíž bude porovnání prvků
vektorů provedeno pomalu &ndash; prvek po prvku.</p>

<p>V&nbsp;dnešním posledním demonstračním příkladu si ověříme, které porovnání
vektorů bude realizováno jedinou instrukcí a které nikoli (tedy bude se muset
provést porovnání prvek po prvku):</p>

<pre>
typedef signed   char           <strong>i8x16</strong> __attribute__((vector_size(16)));
typedef unsigned char           <strong>u8x16</strong> __attribute__((vector_size(16)));
typedef signed   short int      <strong>i16x8</strong> __attribute__((vector_size(16)));
typedef unsigned short int      <strong>u16x8</strong> __attribute__((vector_size(16)));
typedef signed   int            <strong>i32x4</strong> __attribute__((vector_size(16)));
typedef unsigned int            <strong>u32x4</strong> __attribute__((vector_size(16)));
typedef   signed long long int  <strong>i64x2</strong> __attribute__((vector_size(16)));
typedef unsigned long long int  <strong>u64x2</strong> __attribute__((vector_size(16)));
typedef float                   <strong>f32x4</strong> __attribute__((vector_size(16)));
typedef double                  <strong>f64x2</strong> __attribute__((vector_size(16)));
&nbsp; 
#define EQ(type) type <strong>eq_##type</strong>(type x, type y) {return x==y;}
#define LT(type) type <strong>lt_##type</strong>(type x, type y) {return x&lt;y;}
#define LE(type) type <strong>le_##type</strong>(type x, type y) {return x&lt;=y;}
#define GT(type) type <strong>gt_##type</strong>(type x, type y) {return x&gt;y;}
#define GE(type) type <strong>ge_##type</strong>(type x, type y) {return x&gt;=y;}
#define NE(type) type <strong>ne_##type</strong>(type x, type y) {return x!=y;}
&nbsp; 
#define ALL(type) \
    EQ(type) \
    LT(type) \
    LE(type) \
    GT(type) \
    GE(type) \
    NE(type)
&nbsp;
ALL(i8x16)
ALL(u8x16)
ALL(i16x8)
ALL(u16x8)
ALL(i32x4)
ALL(u32x4)
ALL(i64x2)
ALL(u64x2)
ALL(f32x4)
ALL(f64x2)
</pre>

<p>Porovnání, které <strong>lze</strong> realizovat jedinou instrukcí:</p>

<pre>
00007e func[0] <strong>&lt;eq_i8x16</strong>&gt;:
 00007f: 20 00                      | local.get 0
 000081: 20 01                      | local.get 1
 000083: fd 23                      | i8x16.eq
 000085: 0b                         | end
&nbsp;
000087 func[1] <strong>&lt;lt_i8x16</strong>&gt;:
 000088: 20 00                      | local.get 0
 00008a: 20 01                      | local.get 1
 00008c: fd 25                      | i8x16.lt_s
 00008e: 0b                         | end
&nbsp;
000090 func[2] <strong>&lt;le_i8x16</strong>&gt;:
 000091: 20 00                      | local.get 0
 000093: 20 01                      | local.get 1
 000095: fd 29                      | i8x16.le_s
 000097: 0b                         | end
&nbsp;
000099 func[3] <strong>&lt;gt_i8x16</strong>&gt;:
 00009a: 20 00                      | local.get 0
 00009c: 20 01                      | local.get 1
 00009e: fd 27                      | i8x16.gt_s
 0000a0: 0b                         | end
&nbsp;
0000a2 func[4] <strong>&lt;ge_i8x16</strong>&gt;:
 0000a3: 20 00                      | local.get 0
 0000a5: 20 01                      | local.get 1
 0000a7: fd 2b                      | i8x16.ge_s
 0000a9: 0b                         | end
&nbsp;
0000ab func[5] <strong>&lt;ne_i8x16</strong>&gt;:
 0000ac: 20 00                      | local.get 0
 0000ae: 20 01                      | local.get 1
 0000b0: fd 24                      | i8x16.ne
 0000b2: 0b                         | end
&nbsp;
0000b4 func[6] <strong>&lt;eq_u8x16</strong>&gt;:
 0000b5: 20 00                      | local.get 0
 0000b7: 20 01                      | local.get 1
 0000b9: fd 23                      | i8x16.eq
 0000bb: 0b                         | end
&nbsp;
0000bd func[7] <strong>&lt;lt_u8x16</strong>&gt;:
 0000be: 20 00                      | local.get 0
 0000c0: 20 01                      | local.get 1
 0000c2: fd 26                      | i8x16.lt_u
 0000c4: 0b                         | end
&nbsp;
0000c6 func[8] <strong>&lt;le_u8x16</strong>&gt;:
 0000c7: 20 00                      | local.get 0
 0000c9: 20 01                      | local.get 1
 0000cb: fd 2a                      | i8x16.le_u
 0000cd: 0b                         | end
&nbsp;
0000cf func[9] <strong>&lt;gt_u8x16</strong>&gt;:
 0000d0: 20 00                      | local.get 0
 0000d2: 20 01                      | local.get 1
 0000d4: fd 28                      | i8x16.gt_u
 0000d6: 0b                         | end
&nbsp;
0000d8 func[10] <strong>&lt;ge_u8x16</strong>&gt;:
 0000d9: 20 00                      | local.get 0
 0000db: 20 01                      | local.get 1
 0000dd: fd 2c                      | i8x16.ge_u
 0000df: 0b                         | end
&nbsp;
0000e1 func[11] <strong>&lt;ne_u8x16</strong>&gt;:
 0000e2: 20 00                      | local.get 0
 0000e4: 20 01                      | local.get 1
 0000e6: fd 24                      | i8x16.ne
 0000e8: 0b                         | end
&nbsp;
0000ea func[12] <strong>&lt;eq_i16x8</strong>&gt;:
 0000eb: 20 00                      | local.get 0
 0000ed: 20 01                      | local.get 1
 0000ef: fd 2d                      | i16x8.eq
 0000f1: 0b                         | end
&nbsp;
0000f3 func[13] <strong>&lt;lt_i16x8</strong>&gt;:
 0000f4: 20 00                      | local.get 0
 0000f6: 20 01                      | local.get 1
 0000f8: fd 2f                      | i16x8.lt_s
 0000fa: 0b                         | end
&nbsp;
0000fc func[14] <strong>&lt;le_i16x8</strong>&gt;:
 0000fd: 20 00                      | local.get 0
 0000ff: 20 01                      | local.get 1
 000101: fd 33                      | i16x8.le_s
 000103: 0b                         | end
&nbsp;
000105 func[15] <strong>&lt;gt_i16x8</strong>&gt;:
 000106: 20 00                      | local.get 0
 000108: 20 01                      | local.get 1
 00010a: fd 31                      | i16x8.gt_s
 00010c: 0b                         | end
&nbsp;
00010e func[16] <strong>&lt;ge_i16x8</strong>&gt;:
 00010f: 20 00                      | local.get 0
 000111: 20 01                      | local.get 1
 000113: fd 35                      | i16x8.ge_s
 000115: 0b                         | end
&nbsp;
000117 func[17] <strong>&lt;ne_i16x8</strong>&gt;:
 000118: 20 00                      | local.get 0
 00011a: 20 01                      | local.get 1
 00011c: fd 2e                      | i16x8.ne
 00011e: 0b                         | end
&nbsp;
000120 func[18] <strong>&lt;eq_u16x8</strong>&gt;:
 000121: 20 00                      | local.get 0
 000123: 20 01                      | local.get 1
 000125: fd 2d                      | i16x8.eq
 000127: 0b                         | end
&nbsp;
000129 func[19] <strong>&lt;lt_u16x8</strong>&gt;:
 00012a: 20 00                      | local.get 0
 00012c: 20 01                      | local.get 1
 00012e: fd 30                      | i16x8.lt_u
 000130: 0b                         | end
&nbsp;
000132 func[20] <strong>&lt;le_u16x8</strong>&gt;:
 000133: 20 00                      | local.get 0
 000135: 20 01                      | local.get 1
 000137: fd 34                      | i16x8.le_u
 000139: 0b                         | end
&nbsp;
00013b func[21] <strong>&lt;gt_u16x8</strong>&gt;:
 00013c: 20 00                      | local.get 0
 00013e: 20 01                      | local.get 1
 000140: fd 32                      | i16x8.gt_u
 000142: 0b                         | end
&nbsp;
000144 func[22] <strong>&lt;ge_u16x8</strong>&gt;:
 000145: 20 00                      | local.get 0
 000147: 20 01                      | local.get 1
 000149: fd 36                      | i16x8.ge_u
 00014b: 0b                         | end
&nbsp;
00014d func[23] <strong>&lt;ne_u16x8</strong>&gt;:
 00014e: 20 00                      | local.get 0
 000150: 20 01                      | local.get 1
 000152: fd 2e                      | i16x8.ne
 000154: 0b                         | end
&nbsp;
000156 func[24] <strong>&lt;eq_i32x4</strong>&gt;:
 000157: 20 00                      | local.get 0
 000159: 20 01                      | local.get 1
 00015b: fd 37                      | i32x4.eq
 00015d: 0b                         | end
&nbsp;
00015f func[25] <strong>&lt;lt_i32x4</strong>&gt;:
 000160: 20 00                      | local.get 0
 000162: 20 01                      | local.get 1
 000164: fd 39                      | i32x4.lt_s
 000166: 0b                         | end
&nbsp;
000168 func[26] <strong>&lt;le_i32x4</strong>&gt;:
 000169: 20 00                      | local.get 0
 00016b: 20 01                      | local.get 1
 00016d: fd 3d                      | i32x4.le_s
 00016f: 0b                         | end
&nbsp;
000171 func[27] <strong>&lt;gt_i32x4</strong>&gt;:
 000172: 20 00                      | local.get 0
 000174: 20 01                      | local.get 1
 000176: fd 3b                      | i32x4.gt_s
 000178: 0b                         | end
&nbsp;
00017a func[28] <strong>&lt;ge_i32x4</strong>&gt;:
 00017b: 20 00                      | local.get 0
 00017d: 20 01                      | local.get 1
 00017f: fd 3f                      | i32x4.ge_s
 000181: 0b                         | end
&nbsp;
000183 func[29] <strong>&lt;ne_i32x4</strong>&gt;:
 000184: 20 00                      | local.get 0
 000186: 20 01                      | local.get 1
 000188: fd 38                      | i32x4.ne
 00018a: 0b                         | end
&nbsp;
00018c func[30] <strong>&lt;eq_u32x4</strong>&gt;:
 00018d: 20 00                      | local.get 0
 00018f: 20 01                      | local.get 1
 000191: fd 37                      | i32x4.eq
 000193: 0b                         | end
&nbsp;
000195 func[31] <strong>&lt;lt_u32x4</strong>&gt;:
 000196: 20 00                      | local.get 0
 000198: 20 01                      | local.get 1
 00019a: fd 3a                      | i32x4.lt_u
 00019c: 0b                         | end
&nbsp;
00019e func[32] <strong>&lt;le_u32x4</strong>&gt;:
 00019f: 20 00                      | local.get 0
 0001a1: 20 01                      | local.get 1
 0001a3: fd 3e                      | i32x4.le_u
 0001a5: 0b                         | end
&nbsp;
0001a7 func[33] <strong>&lt;gt_u32x4</strong>&gt;:
 0001a8: 20 00                      | local.get 0
 0001aa: 20 01                      | local.get 1
 0001ac: fd 3c                      | i32x4.gt_u
 0001ae: 0b                         | end
&nbsp;
0001b0 func[34] <strong>&lt;ge_u32x4</strong>&gt;:
 0001b1: 20 00                      | local.get 0
 0001b3: 20 01                      | local.get 1
 0001b5: fd 40                      | i32x4.ge_u
 0001b7: 0b                         | end
&nbsp;
0001b9 func[35] <strong>&lt;ne_u32x4</strong>&gt;:
 0001ba: 20 00                      | local.get 0
 0001bc: 20 01                      | local.get 1
 0001be: fd 38                      | i32x4.ne
 0001c0: 0b                         | end
&nbsp;
0001c2 func[36] <strong>&lt;eq_i64x2</strong>&gt;:
 0001c3: 20 00                      | local.get 0
 0001c5: 20 01                      | local.get 1
 0001c7: fd d6 01                   | i64x2.eq
 0001ca: 0b                         | end
&nbsp;
0001cc func[37] <strong>&lt;lt_i64x2</strong>&gt;:
 0001cd: 20 00                      | local.get 0
 0001cf: 20 01                      | local.get 1
 0001d1: fd d8 01                   | i64x2.lt_s
 0001d4: 0b                         | end
&nbsp;
0001d6 func[38] <strong>&lt;le_i64x2</strong>&gt;:
 0001d7: 20 00                      | local.get 0
 0001d9: 20 01                      | local.get 1
 0001db: fd da 01                   | i64x2.le_s
 0001de: 0b                         | end
&nbsp;
0001e0 func[39] <strong>&lt;gt_i64x2</strong>&gt;:
 0001e1: 20 00                      | local.get 0
 0001e3: 20 01                      | local.get 1
 0001e5: fd d9 01                   | i64x2.gt_s
 0001e8: 0b                         | end
&nbsp;
0001ea func[40] <strong>&lt;ge_i64x2</strong>&gt;:
 0001eb: 20 00                      | local.get 0
 0001ed: 20 01                      | local.get 1
 0001ef: fd db 01                   | i64x2.ge_s
 0001f2: 0b                         | end
&nbsp;
0001f4 func[41] <strong>&lt;ne_i64x2</strong>&gt;:
 0001f5: 20 00                      | local.get 0
 0001f7: 20 01                      | local.get 1
 0001f9: fd d7 01                   | i64x2.ne
 0001fc: 0b                         | end
&nbsp;
0001fe func[42] <strong>&lt;eq_u64x2</strong>&gt;:
 0001ff: 20 00                      | local.get 0
 000201: 20 01                      | local.get 1
 000203: fd d6 01                   | i64x2.eq
 000206: 0b                         | end
&nbsp;
0002a8 func[47] <strong>&lt;ne_u64x2</strong>&gt;:
 0002a9: 20 00                      | local.get 0
 0002ab: 20 01                      | local.get 1
 0002ad: fd d7 01                   | i64x2.ne
 0002b0: 0b                         | end
&nbsp;
0002b2 func[48] <strong>&lt;eq_f32x4</strong>&gt;:
 0002b3: 20 00                      | local.get 0
 0002b5: 20 01                      | local.get 1
 0002b7: fd 41                      | f32x4.eq
 0002b9: 0b                         | end
&nbsp;
0002bb func[49] <strong>&lt;lt_f32x4</strong>&gt;:
 0002bc: 20 00                      | local.get 0
 0002be: 20 01                      | local.get 1
 0002c0: fd 43                      | f32x4.lt
 0002c2: 0b                         | end
&nbsp;
0002c4 func[50] <strong>&lt;le_f32x4</strong>&gt;:
 0002c5: 20 00                      | local.get 0
 0002c7: 20 01                      | local.get 1
 0002c9: fd 45                      | f32x4.le
 0002cb: 0b                         | end
&nbsp;
0002cd func[51] <strong>&lt;gt_f32x4</strong>&gt;:
 0002ce: 20 00                      | local.get 0
 0002d0: 20 01                      | local.get 1
 0002d2: fd 44                      | f32x4.gt
 0002d4: 0b                         | end
&nbsp;
0002d6 func[52] <strong>&lt;ge_f32x4</strong>&gt;:
 0002d7: 20 00                      | local.get 0
 0002d9: 20 01                      | local.get 1
 0002db: fd 46                      | f32x4.ge
 0002dd: 0b                         | end
&nbsp;
0002df func[53] <strong>&lt;ne_f32x4</strong>&gt;:
 0002e0: 20 00                      | local.get 0
 0002e2: 20 01                      | local.get 1
 0002e4: fd 42                      | f32x4.ne
 0002e6: 0b                         | end
&nbsp;
0002e8 func[54] <strong>&lt;eq_f64x2</strong>&gt;:
 0002e9: 20 00                      | local.get 0
 0002eb: 20 01                      | local.get 1
 0002ed: fd 47                      | f64x2.eq
 0002ef: 0b                         | end
&nbsp;
0002f1 func[55] <strong>&lt;lt_f64x2</strong>&gt;:
 0002f2: 20 00                      | local.get 0
 0002f4: 20 01                      | local.get 1
 0002f6: fd 49                      | f64x2.lt
 0002f8: 0b                         | end
&nbsp;
0002fa func[56] <strong>&lt;le_f64x2</strong>&gt;:
 0002fb: 20 00                      | local.get 0
 0002fd: 20 01                      | local.get 1
 0002ff: fd 4b                      | f64x2.le
 000301: 0b                         | end
&nbsp;
000303 func[57] <strong>&lt;gt_f64x2</strong>&gt;:
 000304: 20 00                      | local.get 0
 000306: 20 01                      | local.get 1
 000308: fd 4a                      | f64x2.gt
 00030a: 0b                         | end
&nbsp;
00030c func[58] <strong>&lt;ge_f64x2</strong>&gt;:
 00030d: 20 00                      | local.get 0
 00030f: 20 01                      | local.get 1
 000311: fd 4c                      | f64x2.ge
 000313: 0b                         | end
&nbsp;
000315 func[59] <strong>&lt;ne_f64x2</strong>&gt;:
 000316: 20 00                      | local.get 0
 000318: 20 01                      | local.get 1
 00031a: fd 48                      | f64x2.ne
 00031c: 0b                         | end
</pre>

<p>Kupodivu však nejsou podporovány některé instrukce pro porovnání vektorů
s&nbsp;prvky typu <strong>unsigned long long</strong>. Ovšem tyto vektory jsou
velmi krátké (dva prvky), takže výsledný kód ve WebAssembly není příliš
dlouhý:</p>

<pre>
000208 func[43] <strong>&lt;lt_u64x2</strong>&gt;:
 000209: 42 7f                      | i64.const 18446744073709551615
 00020b: 42 00                      | i64.const 0
 00020d: 20 00                      | local.get 0
 00020f: fd 1d 00                   | i64x2.extract_lane 0
 000212: 20 01                      | local.get 1
 000214: fd 1d 00                   | i64x2.extract_lane 0
 000217: 54                         | i64.lt_u
 000218: 1b                         | select
 000219: fd 12                      | i64x2.splat
 00021b: 42 7f                      | i64.const 18446744073709551615
 00021d: 42 00                      | i64.const 0
 00021f: 20 00                      | local.get 0
 000221: fd 1d 01                   | i64x2.extract_lane 1
 000224: 20 01                      | local.get 1
 000226: fd 1d 01                   | i64x2.extract_lane 1
 000229: 54                         | i64.lt_u
 00022a: 1b                         | select
 00022b: fd 1e 01                   | i64x2.replace_lane 1
 00022e: 0b                         | end
&nbsp;
000230 func[44] <strong>&lt;le_u64x2</strong>&gt;:
 000231: 42 7f                      | i64.const 18446744073709551615
 000233: 42 00                      | i64.const 0
 000235: 20 00                      | local.get 0
 000237: fd 1d 00                   | i64x2.extract_lane 0
 00023a: 20 01                      | local.get 1
 00023c: fd 1d 00                   | i64x2.extract_lane 0
 00023f: 58                         | i64.le_u
 000240: 1b                         | select
 000241: fd 12                      | i64x2.splat
 000243: 42 7f                      | i64.const 18446744073709551615
 000245: 42 00                      | i64.const 0
 000247: 20 00                      | local.get 0
 000249: fd 1d 01                   | i64x2.extract_lane 1
 00024c: 20 01                      | local.get 1
 00024e: fd 1d 01                   | i64x2.extract_lane 1
 000251: 58                         | i64.le_u
 000252: 1b                         | select
 000253: fd 1e 01                   | i64x2.replace_lane 1
 000256: 0b                         | end
&nbsp;
000258 func[45] <strong>&lt;gt_u64x2</strong>&gt;:
 000259: 42 7f                      | i64.const 18446744073709551615
 00025b: 42 00                      | i64.const 0
 00025d: 20 00                      | local.get 0
 00025f: fd 1d 00                   | i64x2.extract_lane 0
 000262: 20 01                      | local.get 1
 000264: fd 1d 00                   | i64x2.extract_lane 0
 000267: 56                         | i64.gt_u
 000268: 1b                         | select
 000269: fd 12                      | i64x2.splat
 00026b: 42 7f                      | i64.const 18446744073709551615
 00026d: 42 00                      | i64.const 0
 00026f: 20 00                      | local.get 0
 000271: fd 1d 01                   | i64x2.extract_lane 1
 000274: 20 01                      | local.get 1
 000276: fd 1d 01                   | i64x2.extract_lane 1
 000279: 56                         | i64.gt_u
 00027a: 1b                         | select
 00027b: fd 1e 01                   | i64x2.replace_lane 1
 00027e: 0b                         | end
&nbsp;
000280 func[46] <strong>&lt;ge_u64x2</strong>&gt;:
 000281: 42 7f                      | i64.const 18446744073709551615
 000283: 42 00                      | i64.const 0
 000285: 20 00                      | local.get 0
 000287: fd 1d 00                   | i64x2.extract_lane 0
 00028a: 20 01                      | local.get 1
 00028c: fd 1d 00                   | i64x2.extract_lane 0
 00028f: 5a                         | i64.ge_u
 000290: 1b                         | select
 000291: fd 12                      | i64x2.splat
 000293: 42 7f                      | i64.const 18446744073709551615
 000295: 42 00                      | i64.const 0
 000297: 20 00                      | local.get 0
 000299: fd 1d 01                   | i64x2.extract_lane 1
 00029c: 20 01                      | local.get 1
 00029e: fd 1d 01                   | i64x2.extract_lane 1
 0002a1: 5a                         | i64.ge_u
 0002a2: 1b                         | select
 0002a3: fd 1e 01                   | i64x2.replace_lane 1
 0002a6: 0b                         | end
</pre>

<p>Shrňme si výsledky, které jsme právě získali, do tabulky:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Prováděná operace</th><th>Struktura vektorů, které se porovnávají</th></tr>
<tr><td>fd 23</td><td>i8x16.eq</td><td>test na rovnost prvků</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 24</td><td>i8x16.ne</td><td>test na nerovnost prvků</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 25</td><td>i8x16.lt_s</td><td>relace &bdquo;menší než&ldquo;</td><td>16 prvků typu <i>signed char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 29</td><td>i8x16.le_s</td><td>relace &bdquo;menší nebo rovno&ldquo;</td><td>16 prvků typu <i>signed char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 27</td><td>i8x16.gt_s</td><td>relace &bdquo;větší než&ldquo;</td><td>16 prvků typu <i>signed char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 2b</td><td>i8x16.ge_s</td><td>relace &bdquo;větší nebo rovno&ldquo;</td><td>16 prvků typu <i>signed char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 26</td><td>i8x16.lt_u</td><td>relace &bdquo;menší než&ldquo;</td><td>16 prvků typu <i>unsigned char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 2a</td><td>i8x16.le_u</td><td>relace &bdquo;menší nebo rovno&ldquo;</td><td>16 prvků typu <i>unsigned char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 28</td><td>i8x16.gt_u</td><td>relace &bdquo;větší než&ldquo;</td><td>16 prvků typu <i>unsigned char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 2c</td><td>i8x16.ge_u</td><td>relace &bdquo;větší nebo rovno&ldquo;</td><td>16 prvků typu <i>unsigned char</i> (16&times;8 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd 2d</td><td>i16x8.eq</td><td>test na rovnost prvků</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 2e</td><td>i16x8.ne</td><td>test na nerovnost prvků</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 2f</td><td>i16x8.lt_s</td><td>relace &bdquo;menší než&ldquo;</td><td>8 prvků typu <i>signed word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 33</td><td>i16x8.le_s</td><td>relace &bdquo;menší nebo rovno&ldquo;</td><td>8 prvků typu <i>signed word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 31</td><td>i16x8.gt_s</td><td>relace &bdquo;větší než&ldquo;</td><td>8 prvků typu <i>signed word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 35</td><td>i16x8.ge_s</td><td>relace &bdquo;větší nebo rovno&ldquo;</td><td>8 prvků typu <i>signed word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 30</td><td>i16x8.lt_u</td><td>relace &bdquo;menší než&ldquo;</td><td>8 prvků typu <i>usigned word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 34</td><td>i16x8.le_u</td><td>relace &bdquo;menší nebo rovno&ldquo;</td><td>8 prvků typu <i>usigned word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 32</td><td>i16x8.gt_u</td><td>relace &bdquo;větší než&ldquo;</td><td>8 prvků typu <i>usigned word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 36</td><td>i16x8.ge_u</td><td>relace &bdquo;větší nebo rovno&ldquo;</td><td>8 prvků typu <i>usigned word</i> (8&times;16 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd 37</td><td>i32x4.eq</td><td>test na rovnost prvků</td><td>4 prvky typu <i>long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 38</td><td>i32x4.ne</td><td>test na nerovnost prvků</td><td>4 prvky typu <i>long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 39</td><td>i32x4.lt_s</td><td>relace &bdquo;menší než&ldquo;</td><td>4 prvky typu <i>signed long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3d</td><td>i32x4.le_s</td><td>relace &bdquo;menší nebo rovno&ldquo;</td><td>4 prvky typu <i>signed long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3b</td><td>i32x4.gt_s</td><td>relace &bdquo;větší než&ldquo;</td><td>4 prvky typu <i>signed long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3f</td><td>i32x4.ge_s</td><td>relace &bdquo;větší nebo rovno&ldquo;</td><td>4 prvky typu <i>signed long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3a</td><td>i32x4.lt_u</td><td>relace &bdquo;menší než&ldquo;</td><td>4 prvky typu <i>usigned long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3e</td><td>i32x4.le_u</td><td>relace &bdquo;menší nebo rovno&ldquo;</td><td>4 prvky typu <i>usigned long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3c</td><td>i32x4.gt_u</td><td>relace &bdquo;větší než&ldquo;</td><td>4 prvky typu <i>usigned long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 40</td><td>i32x4.ge_u</td><td>relace &bdquo;větší nebo rovno&ldquo;</td><td>4 prvky typu <i>usigned long</i> (4&times;32 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd d6 01</td><td>i64x2.eq</td><td>test na rovnost prvků</td><td>2 prvky typu <i>long long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d7 01</td><td>i64x2.ne</td><td>test na nerovnost prvků</td><td>2 prvky typu <i>long long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d8 01</td><td>i64x2.lt_s</td><td>relace &bdquo;menší než&ldquo;</td><td>2 prvky typu <i>long signed long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd da 01</td><td>i64x2.le_s</td><td>relace &bdquo;menší nebo rovno&ldquo;</td><td>2 prvky typu <i>long signed long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d9 01</td><td>i64x2.gt_s</td><td>relace &bdquo;větší než&ldquo;</td><td>2 prvky typu <i>long signed long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd db 01</td><td>i64x2.ge_s</td><td>relace &bdquo;větší nebo rovno&ldquo;</td><td>2 prvky typu <i>long signed long</i> (2&times;64 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd 41</td><td>f32x4.eq</td><td>test na rovnost prvků</td><td>4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 43</td><td>f32x4.lt</td><td>test na nerovnost prvků</td><td>4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 45</td><td>f32x4.le</td><td>relace &bdquo;menší než&ldquo;</td><td>4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 44</td><td>f32x4.gt</td><td>relace &bdquo;menší nebo rovno&ldquo;</td><td>4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 46</td><td>f32x4.ge</td><td>relace &bdquo;větší než&ldquo;</td><td>4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 42</td><td>f32x4.ne</td><td>relace &bdquo;větší nebo rovno&ldquo;</td><td>4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd 47</td><td>f64x2.eq</td><td>test na rovnost prvků</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 49</td><td>f64x2.lt</td><td>test na nerovnost prvků</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 4b</td><td>f64x2.le</td><td>relace &bdquo;menší než&ldquo;</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 4a</td><td>f64x2.gt</td><td>relace &bdquo;menší nebo rovno&ldquo;</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 4c</td><td>f64x2.ge</td><td>relace &bdquo;větší než&ldquo;</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 48</td><td>f64x2.ne</td><td>relace &bdquo;větší nebo rovno&ldquo;</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Tabulka se všemi doposud popsanými instrukcemi</h2>

<p>Všechny instrukce WebAssembly, které jsme si až doposud popsali, jsou
vypsány v&nbsp;následující tabulce, kde jsou seřazeny podle svého operačního
kódu (tedy na základě hodnoty svého prvního bajtu). Aby bylo zřejmé, jaký
rozsah instrukčního souboru již byl popsán, obsahuje tabulka i (prozatím)
prázdné řádky:</p>

<table>
<tr><th>Operační kód</th><th>Jméno instrukce</th><th>Stručný popis</th></tr>
<tr><td>0x00</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x01</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x02</td><td>block</td><td>uloží na zásobník řízení toku (<i>control-flow stack</i>)</td></tr>
<tr><td>0x03</td><td>loop</td><td>návěští je nastavena na současnou pozici v&nbsp;bajtkódu a zapamatováno</td></tr>
<tr><td>0x04</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x05</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x06</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x07</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x08</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x09</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x0a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x0b</td><td>end</td><td>konec bloku nebo konec celé funkce</td></tr>
<tr><td>0x0c</td><td>br</td><td>provede se nepodmíněný skok</td></tr>
<tr><td>0x0d</td><td>br_if</td><td>pokud je na zásobníku uložena nenulová hodnota, provede se skok, jinak se neprovede žádná operace</td></tr>
<tr><td>0x0e</td><td>br_table</td><td>rozeskok mezi více bloky</td></tr>
<tr><td>0x0f</td><td>return</td><td>ukončení funkce s&nbsp;předáním návratových hodnot přes zásobník</td></tr>
<tr><td>0x10</td><td>call</td><td>zavolání funkce</td></tr>
<tr><td>0x11</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x12</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x13</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x14</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x15</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x16</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x17</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x18</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x19</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1a</td><td>drop</td><td>odstranění hodnoty nebo hodnot ze zásobníku operandů</td></tr>
<tr><td>0x1b</td><td>select</td><td>ze zásobníku přečte tři hodnoty, na základě výsledku podmínky vrátí na zásobník druhou nebo třetí hodnotu</td></tr>
<tr><td>0x1c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x1f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x20</td><td>local.get</td><td>uložení hodnoty lokální proměnné na zásobník</td></tr>
<tr><td>0x21</td><td>local.set</td><td>přenos hodnoty z&nbsp;vrcholu zásobníku do lokální proměnné</td></tr>
<tr><td>0x22</td><td>local.tee</td><td>kopie hodnoty z&nbsp;vrcholu zásobníku do lokální proměnné</td></tr>
<tr><td>0x23</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x24</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x25</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x26</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x27</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x28</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x29</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x2f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x30</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x31</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x32</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x33</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x34</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x35</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x36</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x37</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x38</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x39</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x3f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x41</td><td>i32.const</td><td>uložení 32bitové celočíselné konstanty na zásobník</td></tr>
<tr><td>0x42</td><td>i64.const</td><td>uložení 64bitové celočíselné konstanty na zásobník</td></tr>
<tr><td>0x43</td><td>f32.const</td><td>uložení 32bitové konstanty s&nbsp;plovoucí řádovou čárkou na zásobník</td></tr>
<tr><td>0x44</td><td>f64.const</td><td>uložení 64bitové konstanty s&nbsp;plovoucí řádovou čárkou na zásobník</td></tr>
<tr><td>0x44</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x45</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x46</td><td>i32.eq</td><td>porovnání operandů typu int32 na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x47</td><td>i32.ne</td><td>porovnání operandů typu int32 na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x48</td><td>i32.lt_s</td><td>porovnání operandů typu int32 na relaci &bdquo;menší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x49</td><td>i32.lt_u</td><td>porovnání operandů typu int32 na relaci &bdquo;menší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x4a</td><td>i32.gt_s</td><td>porovnání operandů typu int32 na relaci &bdquo;větší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x4b</td><td>i32.gt_u</td><td>porovnání operandů typu int32 na relaci &bdquo;větší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x4c</td><td>i32.le_s</td><td>porovnání operandů typu int32 na relaci &bdquo;menší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x4d</td><td>i32.le_u</td><td>porovnání operandů typu int32 na relaci &bdquo;menší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x4e</td><td>i32.ge_s</td><td>porovnání operandů typu int32 na relaci &bdquo;větší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x4f</td><td>i32.ge_u</td><td>porovnání operandů typu int32 na relaci &bdquo;větší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x50</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x51</td><td>i64.eq</td><td>porovnání operandů typu int64 na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x52</td><td>i64.ne</td><td>porovnání operandů typu int64 na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x53</td><td>i64.lt_s</td><td>porovnání operandů typu int64 na relaci &bdquo;menší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x54</td><td>i64.lt_u</td><td>porovnání operandů typu int64 na relaci &bdquo;menší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x55</td><td>i64.gt_s</td><td>porovnání operandů typu int64 na relaci &bdquo;větší než&ldquo; (se znaménkem)</td></tr>
<tr><td>0x56</td><td>i64.gt_u</td><td>porovnání operandů typu int64 na relaci &bdquo;větší než&ldquo; (bez znaménka)</td></tr>
<tr><td>0x57</td><td>i64.le_s</td><td>porovnání operandů typu int64 na relaci &bdquo;menší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x58</td><td>i64.le_u</td><td>porovnání operandů typu int64 na relaci &bdquo;menší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x59</td><td>i64.ge_s</td><td>porovnání operandů typu int64 na relaci &bdquo;větší nebo rovno&ldquo; (se znaménkem)</td></tr>
<tr><td>0x5a</td><td>i64.ge_u</td><td>porovnání operandů typu int64 na relaci &bdquo;větší nebo rovno&ldquo; (bez znaménka)</td></tr>
<tr><td>0x5b</td><td>f32.eq</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x5c</td><td>f32.ne</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x5d</td><td>f32.lt</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;menší než&ldquo;</td></tr>
<tr><td>0x5e</td><td>f32.gt</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td>0x5f</td><td>f32.le</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>0x60</td><td>f32.ge</td><td>porovnání dvou hodnot typu <i>single</i> na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td>0x61</td><td>f64.eq</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;rovno&ldquo;</td></tr>
<tr><td>0x62</td><td>f64.ne</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;nerovno&ldquo;</td></tr>
<tr><td>0x63</td><td>f64.lt</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;menší než&ldquo;</td></tr>
<tr><td>0x64</td><td>f64.gt</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td>0x65</td><td>f64.le</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>0x66</td><td>f64.ge</td><td>porovnání dvou hodnot typu <i>double</i> na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td>0x67</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x68</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x69</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x6a</td><td>i32.add</td><td>součet dvou celých 32bitových hodnot</td></tr>
<tr><td>0x6b</td><td>i32.sub</td><td>rozdíl dvou celých 32bitových hodnot</td></tr>
<tr><td>0x6c</td><td>i32.mul</td><td>součin dvou celých 32bitových hodnot</td></tr>
<tr><td>0x6d</td><td>i32.div_s</td><td>podíl dvou celých 32bitových hodnot se znaménkem</td></tr>
<tr><td>0x6e</td><td>i32.div_u</td><td>podíl dvou celých 32bitových hodnot bez znaménka</td></tr>
<tr><td>0x6f</td><td>i32.rem_s</td><td>zbytek po dělení dvou celých 32bitových hodnot se znaménkem</td></tr>
<tr><td>0x70</td><td>i32.rem_u</td><td>zbytek po dělení dvou celých 32bitových hodnot bez znaménka</td></tr>
<tr><td>0x71</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x72</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x73</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x74</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x75</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x76</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x77</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x78</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x79</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7c</td><td>i64.add</td><td>součet dvou celých 64bitových hodnot</td></tr>
<tr><td>0x7d</td><td>i64.sub</td><td>rozdíl dvou celých 64bitových hodnot</td></tr>
<tr><td>0x7e</td><td>i64.mul</td><td>součin dvou celých 64bitových hodnot</td></tr>
<tr><td>0x7f</td><td>i64.div_s</td><td>podíl dvou celých 64bitových hodnot se znaménkem</td></tr>
<tr><td>0x80</td><td>i64.div_u</td><td>podíl dvou celých 64bitových hodnot bez znaménka</td></tr>
<tr><td>0x81</td><td>i64.rem_s</td><td>zbytek po dělení dvou celých 64bitových hodnot se znaménkem</td></tr>
<tr><td>0x82</td><td>i64.rem_u</td><td>zbytek po dělení dvou celých 64bitových hodnot bez znaménka</td></tr>
<tr><td>0x83</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x84</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x85</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x86</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x87</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x88</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x89</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8a</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8b</td><td>f32.abs</td><td>absolutní hodnota typu <i>single/float</i></td></tr>
<tr><td>0x8c</td><td>f32.neg</td><td>otočení znaménka u hodnoty typu <i>single/float</i></td></tr>
<tr><td>0x8d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x8f</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x90</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x91</td><td>f32.sqrt</td><td>druhá odmocnina z&nbsp;hodnoty typu <i>single/float</i></td></tr>
<tr><td>0x92</td><td>f32.add</td><td>součet dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x93</td><td>f32.sub</td><td>rozdíl dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x94</td><td>f32.mul</td><td>součin dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x95</td><td>f32.div</td><td>podíl dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x96</td><td>f32.min</td><td>součet dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x97</td><td>f32.max</td><td>součet dvou hodnot typu <i>single/float</i></td></tr>
<tr><td>0x98</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x99</td><td>f64.abs</td><td>absolutní hodnota typu <i>double</i></td></tr>
<tr><td>0x9a</td><td>f64.neg</td><td>otočení znaménka u hodnoty typu <i>double</i></td></tr>
<tr><td>0x9b</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9c</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9d</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9e</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x9f</td><td>f64.sqrt</td><td>druhá odmocnina z&nbsp;hodnoty typu <i>double</i></td></tr>
<tr><td>0xa0</td><td>f64.add</td><td>součet dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa1</td><td>f64.sub</td><td>rozdíl dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa2</td><td>f64.mul</td><td>součin dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa3</td><td>f64.div</td><td>podíl dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa4</td><td>f64.min</td><td>součet dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa5</td><td>f64.max</td><td>součet dvou hodnot typu <i>double</i></td></tr>
<tr><td>0xa6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xa7</td><td>i32.wrap_i64</td><td>de facto opak instrukce <strong>extend</strong>, převod hodnoty se ztrátou informace 64 na 32 bitů</td></tr>
<tr><td>0xa8</td><td>i32.trunc_f32_s</td><td>převod hodnoty typu <i>float</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xa9</td><td>i32.trunc_f32_u</td><td>převod hodnoty typu <i>float</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xaa</td><td>i32.trunc_f64_s</td><td>převod hodnoty typu <i>double</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xab</td><td>i32.trunc_f64_u</td><td>převod hodnoty typu <i>double</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xac</td><td>i64.extend_i32_s</td><td>znaménkové rozšíření hodnoty (32 na 64 bitů)</td></tr>
<tr><td>0xad</td><td>i64.extend_i32_u</td><td>bezznaménkové rozšíření hodnoty (32 na 64 bitů)</td></tr>
<tr><td>0xae</td><td>i64.trunc_f32_s</td><td>převod hodnoty typu <i>float</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xaf</td><td>i64.trunc_f32_u</td><td>převod hodnoty typu <i>float</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xb0</td><td>i64.trunc_f64_s</td><td>převod hodnoty typu <i>double</i> na celé číslo se znaménkem</td></tr>
<tr><td>0xb1</td><td>i64.trunc_f64_u</td><td>převod hodnoty typu <i>double</i> na celé číslo bez znaménka</td></tr>
<tr><td>0xb2</td><td>f32.convert_i32_s</td><td>konverze celého čísla se znaménkem (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb3</td><td>f32.convert_i32_u</td><td>konverze celého čísla bez znaménka (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb4</td><td>f32.convert_i64_s</td><td>konverze celého čísla se znaménkem (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb5</td><td>f32.convert_i64_u</td><td>konverze celého čísla bez znaménka (32 bitů) na typ <i>float</i></td></tr>
<tr><td>0xb6</td><td>f32.demote_f64</td><td>převod hodnoty typu <i>double</i> na typ <i>float</i></td></tr>
<tr><td>0xb7</td><td>f64.convert_i32_s</td><td>konverze celého čísla se znaménkem (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xb8</td><td>f64.convert_i32_u</td><td>konverze celého čísla bez znaménka (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xb9</td><td>f64.convert_i64_s</td><td>konverze celého čísla se znaménkem (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xba</td><td>f64.convert_i64_u</td><td>konverze celého čísla bez znaménka (64 bitů) na typ <i>double</i></td></tr>
<tr><td>0xbb</td><td>f64.promote_f32</td><td>převod hodnoty typu <i>float</i> na typ <i>double</i></td></tr>
<tr><td>0xbc</td><td>i32.reinterpret_f32</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xbd</td><td>i64.reinterpret_f64</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xbe</td><td>f32.reinterpret_i32</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xbf</td><td>f64.reinterpret_i64</td><td>pouze změna typu, nezmění se však jednotlivé bity slova</td></tr>
<tr><td>0xc0</td><td>i32.extend8_s</td><td>znaménkové rozšíření hodnoty z&nbsp;8 bitů na 32 bitů</td></tr>
<tr><td>0xc1</td><td>i32.extend16_s</td><td>znaménkové rozšíření hodnoty ze 16 bitů na 32 bitů</td></tr>
<tr><td>0xc2</td><td>i64.extend8_s</td><td>znaménkové rozšíření hodnoty z&nbsp;8 bitů na 64 bitů</td></tr>
<tr><td>0xc3</td><td>i64.extend16_s</td><td>znaménkové rozšíření hodnoty ze 16 bitů na 64 bitů</td></tr>
<tr><td>0xc4</td><td>i64.extend32_s</td><td>znaménkové rozšíření hodnoty z&nbsp;8 bitů na 64 bitů</td></tr>
<tr><td>0xc5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xc9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xca</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcc</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcd</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xce</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xcf</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd0</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd3</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd4</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xd9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xda</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdc</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdd</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xde</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xdf</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe0</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe3</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe4</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xe9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xea</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xeb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xec</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xed</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xee</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xef</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf0</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf1</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf2</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf3</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf4</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf5</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf6</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf7</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf8</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xf9</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfa</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfb</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xfc</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>fd 0f</td><td>i8x16.splat</td><td>skalár převedený na 16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 10</td><td>i16x8.splat</td><td>skalár převedený na 8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 11</td><td>i32x4.splat</td><td>skalár převedený na 4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 12</td><td>i64x2.splat</td><td>skalár převedený na 2 prvky typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 13</td><td>f32x4.splat</td><td>skalár převedený na 4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 14</td><td>f64x2.splat</td><td>skalár převedený na 2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 15</td><td>i8x16.extract_lane_s</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 16</td><td>i8x16.extract_lane_u</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 17</td><td>i8x16.replace_lane</td><td>16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 18</td><td>i16x8.extract_lane_s</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 19</td><td>i16x8.extract_lane_u</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 1a</td><td>i16x8.replace_lane</td><td>8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 1b</td><td>i32x4.extract_lane  </td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 1c</td><td>i32x4.replace_lane</td><td>4 prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 1d</td><td>i64x2.extract_lane  </td><td>2 prvky typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 1e</td><td>i64x2.replace_lane</td><td>2 prvky typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 1f</td><td>f32x4.extract_lane  </td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 20</td><td>f32x4.replace_lane</td><td>4 prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 21</td><td>f64x2.extract_lane  </td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 22</td><td>f64x2.replace_lane</td><td>2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 23</td><td>i8x16.eq</td><td>test na rovnost prvků; 16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 24</td><td>i8x16.ne</td><td>test na nerovnost prvků; 16 prvků typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 25</td><td>i8x16.lt_s</td><td>relace &bdquo;menší než&ldquo;; 16 prvků typu <i>signed char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 26</td><td>i8x16.lt_u</td><td>relace &bdquo;menší než&ldquo;; 16 prvků typu <i>unsigned char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 27</td><td>i8x16.gt_s</td><td>relace &bdquo;větší než&ldquo;; 16 prvků typu <i>signed char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 28</td><td>i8x16.gt_u</td><td>relace &bdquo;větší než&ldquo;; 16 prvků typu <i>unsigned char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 29</td><td>i8x16.le_s</td><td>relace &bdquo;menší nebo rovno&ldquo;; 16 prvků typu <i>signed char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 2a</td><td>i8x16.le_u</td><td>relace &bdquo;menší nebo rovno&ldquo;; 16 prvků typu <i>unsigned char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 2b</td><td>i8x16.ge_s</td><td>relace &bdquo;větší nebo rovno&ldquo;; 16 prvků typu <i>signed char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 2c</td><td>i8x16.ge_u</td><td>relace &bdquo;větší nebo rovno&ldquo;; 16 prvků typu <i>unsigned char</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 2d</td><td>i16x8.eq</td><td>test na rovnost prvků; 8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 2e</td><td>i16x8.ne</td><td>test na nerovnost prvků; 8 prvků typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 2f</td><td>i16x8.lt_s</td><td>relace &bdquo;menší než&ldquo;; 8 prvků typu <i>signed word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 30</td><td>i16x8.lt_u</td><td>relace &bdquo;menší než&ldquo;; 8 prvků typu <i>usigned word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 31</td><td>i16x8.gt_s</td><td>relace &bdquo;větší než&ldquo;; 8 prvků typu <i>signed word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 32</td><td>i16x8.gt_u</td><td>relace &bdquo;větší než&ldquo;; 8 prvků typu <i>usigned word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 33</td><td>i16x8.le_s</td><td>relace &bdquo;menší nebo rovno&ldquo;; 8 prvků typu <i>signed word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 34</td><td>i16x8.le_u</td><td>relace &bdquo;menší nebo rovno&ldquo;; 8 prvků typu <i>usigned word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 35</td><td>i16x8.ge_s</td><td>relace &bdquo;větší nebo rovno&ldquo;; 8 prvků typu <i>signed word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 36</td><td>i16x8.ge_u</td><td>relace &bdquo;větší nebo rovno&ldquo;; 8 prvků typu <i>usigned word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 37</td><td>i32x4.eq</td><td>test na rovnost prvků; 4 prvky typu <i>long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 38</td><td>i32x4.ne</td><td>test na nerovnost prvků; 4 prvky typu <i>long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 39</td><td>i32x4.lt_s</td><td>relace &bdquo;menší než&ldquo;; 4 prvky typu <i>signed long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3a</td><td>i32x4.lt_u</td><td>relace &bdquo;menší než&ldquo;; 4 prvky typu <i>usigned long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3b</td><td>i32x4.gt_s</td><td>relace &bdquo;větší než&ldquo;; 4 prvky typu <i>signed long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3c</td><td>i32x4.gt_u</td><td>relace &bdquo;větší než&ldquo;; 4 prvky typu <i>usigned long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3d</td><td>i32x4.le_s</td><td>relace &bdquo;menší nebo rovno&ldquo;; 4 prvky typu <i>signed long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3e</td><td>i32x4.le_u</td><td>relace &bdquo;menší nebo rovno&ldquo;; 4 prvky typu <i>usigned long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 3f</td><td>i32x4.ge_s</td><td>relace &bdquo;větší nebo rovno&ldquo;; 4 prvky typu <i>signed long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 40</td><td>i32x4.ge_u</td><td>relace &bdquo;větší nebo rovno&ldquo;; 4 prvky typu <i>usigned long</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 41</td><td>f32x4.eq</td><td>test na rovnost prvků; 4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 42</td><td>f32x4.ne</td><td>relace &bdquo;větší nebo rovno&ldquo;; 4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 43</td><td>f32x4.lt</td><td>test na nerovnost prvků; 4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 44</td><td>f32x4.gt</td><td>relace &bdquo;menší nebo rovno&ldquo;; 4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 45</td><td>f32x4.le</td><td>relace &bdquo;menší než&ldquo;; 4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 46</td><td>f32x4.ge</td><td>relace &bdquo;větší než&ldquo;; 4 prvky typu <i>float</i> (4&times;32 bitů)</td></tr>
<tr><td>fd 47</td><td>f64x2.eq</td><td>test na rovnost prvků; 2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 48</td><td>f64x2.ne</td><td>relace &bdquo;větší nebo rovno&ldquo;; 2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 49</td><td>f64x2.lt</td><td>test na nerovnost prvků; 2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 4a</td><td>f64x2.gt</td><td>relace &bdquo;menší nebo rovno&ldquo;; 2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 4b</td><td>f64x2.le</td><td>relace &bdquo;menší než&ldquo;; 2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 4c</td><td>f64x2.ge</td><td>relace &bdquo;větší než&ldquo;; 2 prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd 61</td><td>i8x16.neg</td><td>otočení znaménka vektorů se šestnácti prvky typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 6e</td><td>i8x16.add</td><td>součet vektorů se šestnácti prvky typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 71</td><td>i8x16.sub</td><td>rozdíl vektorů se šestnácti prvky typu <i>byte</i> (16&times;8 bitů)</td></tr>
<tr><td>fd 81 01</td><td>i16x8.neg</td><td>otočení znaménka vektorů s&nbsp;osmi typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 8e 01</td><td>i16x8.add</td><td>součet vektorů s&nbsp;osmi prvky typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 91 01</td><td>i16x8.sub</td><td>rozdíl vektorů s&nbsp;osmi prvky typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd 95 01</td><td>i16x8.mul</td><td>součin odpovídajících si prvků vektorů typu <i>word</i> (8&times;16 bitů)</td></tr>
<tr><td>fd a1 01</td><td>i32x4.neg</td><td>otočení znaménka vektorů se čtyřmi prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd ae 01</td><td>i32x4.add</td><td>součet vektorů se čtyřmi prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd b1 01</td><td>i32x4.sub</td><td>rozdíl vektorů se čtyřmi prvky typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd b5 01</td><td>i32x4.mul</td><td>součin odpovídajících si prvků vektorů typu <i>double word</i> (4&times;32 bitů)</td></tr>
<tr><td>fd c1 01</td><td>i64x2.neg</td><td>otočení znaménka vektorů se dvěma prvky typu <i>quat word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd ce 01</td><td>i64x2.add</td><td>součet vektorů se dvěma prvky typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d1 01</td><td>i64x2.sub</td><td>rozdíl vektorů se dvěma prvky typu <i>quat word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d5 01</td><td>i64x2.mul</td><td>součin odpovídajících si prvků vektorů typu <i>quad word</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d6 01</td><td>i64x2.eq</td><td>test na rovnost prvků; 2 prvky typu <i>long long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d7 01</td><td>i64x2.ne</td><td>test na nerovnost prvků; 2 prvky typu <i>long long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d8 01</td><td>i64x2.lt_s</td><td>relace &bdquo;menší než&ldquo;; 2 prvky typu <i>long signed long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd d9 01</td><td>i64x2.gt_s</td><td>relace &bdquo;větší než&ldquo;; 2 prvky typu <i>long signed long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd da 01</td><td>i64x2.le_s</td><td>relace &bdquo;menší nebo rovno&ldquo;; 2 prvky typu <i>long signed long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd db 01</td><td>i64x2.ge_s</td><td>relace &bdquo;větší nebo rovno&ldquo;; 2 prvky typu <i>long signed long</i> (2&times;64 bitů)</td></tr>
<tr><td>fd e1 01</td><td>f32x4.neg</td><td>otočení znaménka vektorů se čtyřmi prvky tyypu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd e3 01</td><td>f32x4.sqrt</td><td>výpočet druhé odmocniny čtyř prvků typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd e6 01</td><td>f32x4.mul</td><td>součin odpovídajících si prvků vektorů typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd e7 01</td><td>f32x4.div</td><td>podíl odpovídajících si prvků vektorů typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd e4 01</td><td>f32x4.add</td><td>součet vektorů se čtyřmi prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd e5 01</td><td>f32x4.sub</td><td>rozdíl vektorů se čtyřmi prvky typu <i>single</i> (4&times;32 bitů)</td></tr>
<tr><td>fd ed 01</td><td>f64x2.neg</td><td>otočení znaménka vektorů se dvěma prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd ef 01</td><td>f64x2.sqrt</td><td>výpočet druhé odmocniny dvou prvků typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd f0 01</td><td>f64x2.add</td><td>součet vektorů se dvěma prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd f1 01</td><td>f64x2.sub</td><td>rozdíl vektorů se dvěma prvky typu <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd f2 01</td><td>f64x2.mul</td><td>součin odpovídajících prvků vektorů <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>fd f3 01</td><td>f64x2.div</td><td>podíl odpovídajících prvků vektorů <i>double</i> (2&times;64 bitů)</td></tr>
<tr><td>0xfe</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0xff</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Články o SIMD, které doposud na Rootu vyšly</h2>

<p>Podporou SIMD instrukcí na úrovni takzvaných <i>intrinsic</i> v&nbsp;jazyku
C jsme se už na Rootu zabývali, stejně jako samotnými SIMD instrukcemi na
úrovni assembleru (i když jen pro platformu x86 či x86-64 a nikoli pro
WebAssembly). Pro úplnost jsou v&nbsp;této příloze uvedeny odkazy na příslušné
články:</p>

<ol>

<li>Užitečné rozšíření GCC: podpora SIMD (vektorových) instrukcí<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/</a>
</li>

<li>Užitečné rozšíření GCC – podpora SIMD (vektorových) instrukcí: nedostatky technologie<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/</a>
</li>

<li>Podpora SIMD (vektorových) instrukcí na RISCových procesorech<br />
<a href="https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/">https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic pro nízkoúrovňové optimalizace<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic: technologie SSE<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/</a>
</li>

<li>Rozšíření instrukční sady „Advanced Vector Extensions“ na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady F16C, FMA a AVX-512 na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady AVX-512 na platformě x86–64 (dokončení)<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/</a>
</li>

<li>SIMD instrukce na platformě 80×86: instrukční sada MMX<br />
<a href="https://www.root.cz/clanky/simd-instrukce-na-platforme-80x86-instrukcni-sada-mmx/">https://www.root.cz/clanky/simd-instrukce-na-platforme-80x86-instrukcni-sada-mmx/</a>
</li>

<li>SIMD instrukce na 80×86: dokončení popisu MMX, instrukce 3DNow! <br />
<a href="https://www.root.cz/clanky/simd-instrukce-na-80-86-dokonceni-popisu-mmx-instrukce-3dnow/">https://www.root.cz/clanky/simd-instrukce-na-80-86-dokonceni-popisu-mmx-instrukce-3dnow/</a>
</li>

<li>SIMD instrukce v rozšíření SSE<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse/">https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse/</a>
</li>

<li>SIMD instrukce v rozšíření SSE (2. část)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse-2-cast/">https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse-2-cast/</a>
</li>

<li>Pokročilejší SSE operace: přeskupení, promíchání a rozbalování prvků vektorů<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-sse-operace-preskupeni-promichani-a-rozbalovani-prvku-vektoru/">https://www.root.cz/clanky/pokrocilejsi-sse-operace-preskupeni-promichani-a-rozbalovani-prvku-vektoru/</a>
</li>

<li>Od instrukční sady SSE k sadě SSE2<br />
<a href="https://www.root.cz/clanky/od-instrukcni-sady-sse-k-sade-sse2/">https://www.root.cz/clanky/od-instrukcni-sady-sse-k-sade-sse2/</a>
</li>

<li>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC<br />
<a href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/">https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/</a>
</li>

<li>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (2)<br />
<a href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc-2/">https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc-2/</a>
</li>

<li>Pohled pod kapotu formátu WebAssembly: SIMD (vektorové) operace<br />
<a href="https://www.root.cz/clanky/pohled-pod-kapotu-formatu-webassembly-simd-vektorove-operace/">https://www.root.cz/clanky/pohled-pod-kapotu-formatu-webassembly-simd-vektorove-operace/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Compiling C to WebAssembly without Emscripten<br />
<a href="https://surma.dev/things/c-to-webassembly/">https://surma.dev/things/c-to-webassembly/</a>
</li>

<li>Web Assemply: Text Format<br />
<a href="https://webassembly.github.io/spec/core/text/index.html">https://webassembly.github.io/spec/core/text/index.html</a>
</li>

<li>WebAssembly: Binary Format<br />
<a href="https://webassembly.github.io/spec/core/binary/index.html">https://webassembly.github.io/spec/core/binary/index.html</a>
</li>

<li>WebAssembly<br />
<a href="https://webassembly.org/">https://webassembly.org/</a>
</li>

<li>WebAssembly na Wiki Golangu<br />
<a href="https://github.com/golang/go/wiki/WebAssembly">https://github.com/golang/go/wiki/WebAssembly</a>
</li>

<li>The future of WebAssembly - A look at upcoming features and proposals<br />
<a href="https://blog.scottlogic.com/2018/07/20/wasm-future.html">https://blog.scottlogic.com/2018/07/20/wasm-future.html</a>
</li>

<li>WebAssembly Design<br />
<a href="https://github.com/WebAssembly/design">https://github.com/WebAssembly/design</a>
</li>

<li>Využití WebAssembly z programovacího jazyka Go <br />
<a href="https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/vyuziti-webassembly-z-programovaciho-jazyka-go/</a>
</li>

<li>WebAssembly slibuje podstatné zrychlení webů, konec JavaScriptu se ale nekoná<br />
<a href="https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/">https://www.lupa.cz/clanky/webassembly-slibuje-podstatne-zrychleni-webu-konec-javascriptu-se-ale-nekona/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>Top 23 WASM Open-Source Projects<br />
<a href="https://www.libhunt.com/topic/wasm">https://www.libhunt.com/topic/wasm</a>
</li>

<li>Made with WebAssembly<br />
<a href="https://madewithwebassembly.com/">https://madewithwebassembly.com/</a>
</li>

<li>The Top 1,790 Wasm Open Source Projects on Github<br />
<a href="https://awesomeopensource.com/projects/wasm">https://awesomeopensource.com/projects/wasm</a>
</li>

<li>Sanspiel<br />
<a href="https://sandspiel.club/">https://sandspiel.club/</a>
</li>

<li>Painting on HTML5 Canvas with Rust WASM<br />
<a href="https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html">https://www.subarctic.org/painting_on_html5_canvas_with_rust_wasm.html</a>
</li>

<li>Writing WebAssembly By Hand<br />
<a href="https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html">https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html</a>
</li>

<li>WebAssembly Specification<br />
<a href="https://webassembly.github.io/spec/core/index.html">https://webassembly.github.io/spec/core/index.html</a>
</li>

<li>Index of Instructions<br />
<a href="https://webassembly.github.io/spec/core/appendix/index-instructions.html">https://webassembly.github.io/spec/core/appendix/index-instructions.html</a>
</li>

<li>The WebAssembly Binary Toolkit<br />
<a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a>
</li>

<li>Will WebAssembly replace JavaScript? Or Will WASM Make JavaScript More Valuable in Future?<br />
<a href="https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e">https://dev.to/vaibhavshah/will-webassembly-replace-javascript-or-will-wasm-make-javascript-more-valuable-in-future-5c6e</a>
</li>

<li>Webassembly as 32bit and 64bit<br />
<a href="https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit">https://stackoverflow.com/questions/78580226/webassembly-as-32bit-and-64bit</a>
</li>

<li>Portability<br />
<a href="https://webassembly.org/docs/portability/">https://webassembly.org/docs/portability/</a>
</li>

<li>Hexadecimální prohlížeče a editory s textovým uživatelským rozhraním<br />
<a href="https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/">https://www.root.cz/clanky/hexadecimalni-prohlizece-a-editory-s-textovym-uzivatelskym-rozhranim/</a>
</li>

<li>Nástroj objdump: švýcarský nožík pro vývojáře<br />
<a href="https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/">https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/</a>
</li>

<li>Getting Started: Building and Running Clang<br />
<a href="https://clang.llvm.org/get_started.html">https://clang.llvm.org/get_started.html</a>
</li>

<li>Clang: a C language family frontend for LLVM<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Scheduling LLVM Passes with the New Pass Manager<br />
<a href="https://stephenverderame.github.io/blog/scheduling_llvm/">https://stephenverderame.github.io/blog/scheduling_llvm/</a>
</li>

<li>C data types<br />
<a href="https://en.wikipedia.org/wiki/C_data_types">https://en.wikipedia.org/wiki/C_data_types</a>
</li>

<li>WebAssembly data types<br />
<a href="https://webassembly.github.io/spec/core/syntax/types.html">https://webassembly.github.io/spec/core/syntax/types.html</a>
</li>

<li>WebAssembly Opcodes<br />
<a href="https://pengowray.github.io/wasm-ops/">https://pengowray.github.io/wasm-ops/</a>
</li>

<li>Advanced tools (for WebAssembly)<br />
<a href="https://webassembly.org/getting-started/advanced-tools/">https://webassembly.org/getting-started/advanced-tools/</a>
</li>

<li>Binaryen<br />
<a href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a>
</li>

<li>Using SIMD with WebAssembly<br />
<a href="https://emscripten.org/docs/porting/simd.html">https://emscripten.org/docs/porting/simd.html</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Arm Helium<br />
<a href="https://www.arm.com/technologies/helium">https://www.arm.com/technologies/helium</a>
</li>

<li>SIMD proposal for WebAssembly<br />
<a href="https://github.com/webassembly/simd/">https://github.com/webassembly/simd/</a>
</li>

<li>Single instruction, multiple data<br />
<a href="https://en.wikipedia.org/wiki/Single_instruction%2C_multiple_data">https://en.wikipedia.org/wiki/Single_instruction%2C_multiple_data</a>
</li>

<li>Parallel computing<br />
<a href="https://en.wikipedia.org/wiki/Parallel_computing">https://en.wikipedia.org/wiki/Parallel_computing</a>
</li>

<li>Flynn's taxonomy<br />
<a href="https://en.wikipedia.org/wiki/Flynn%27s_taxonomy">https://en.wikipedia.org/wiki/Flynn%27s_taxonomy</a>
</li>

<li>WebAssembly opcode table<br />
<a href="https://pengowray.github.io/wasm-ops/">https://pengowray.github.io/wasm-ops/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

