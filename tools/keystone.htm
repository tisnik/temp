<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Frameworky Capstone a Keystone: základ pro tvorbu assemblerů a disassemblerů</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Frameworky Capstone a Keystone: základ pro tvorbu assemblerů a disassemblerů</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Frameworky Capstone a Keystone: základ pro tvorbu assemblerů a disassemblerů</a></p>
<p><a href="#k02">2. Proč je vlastně zapotřebí &bdquo;nový&ldquo; assembler a disassembler?</a></p>
<p><a href="#k03">3. Instalace rozhraní mezi Pythonem a frameworky Capstone a Keystone</a></p>
<p><a href="#k04">4. Ruční překlad knihovny Capstone</a></p>
<p><a href="#k05">5. První kroky s&nbsp;knihovnou Keystone &ndash; zavolání assembleru s&nbsp;výpisem přeloženého kódu</a></p>
<p><a href="#k06">6. 32bitový režim mikroprocesorů x86</a></p>
<p><a href="#k07">7. 64bitový režim mikroprocesorů x86-64</a></p>
<p><a href="#k08">8. Zápis instrukcí a operandů s&nbsp;využitím AT&amp;T syntaxe</a></p>
<p><a href="#k09">9. Návěští (<i>labels</i>), skoky a programové smyčky</a></p>
<p><a href="#k10">10. Vnořené programové smyčky</a></p>
<p><a href="#k11">11. Překlad do souboru s&nbsp;binárním kódem</a></p>
<p><a href="#k12">12. Program typu &bdquo;Hello world&ldquo; napsaný v&nbsp;assembleru procesorů x86 určený pro Linux</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Frameworky Capstone a Keystone: základ pro tvorbu assemblerů a disassemblerů</h2>

<p>V&nbsp;dnešním článku se ve stručnosti seznámíme s&nbsp;frameworky nazvanými
<a href="http://www.capstone-engine.org/">Capstone</a> a <a
href="https://www.keystone-engine.org/">Keystone</a>. Jedná se o
&bdquo;univerzální&ldquo; assembler a disassembler, které však nejsou přímo
volatelné z&nbsp;příkazového řádku tak, jako klasické assemblery (jmenujme
například GAS nebo NASM). Namísto toho je jak assembler, tak i disassembler
dostupný ve formě nativní knihovny, kterou je možné přímo volat z&nbsp;C i C++
(nebo z&nbsp;jiného jazyka přes FFI). Navíc ovšem existují i rozhraní pro další
programovací jazyky, abecedně pro D, Clojure, F#, Common Lisp, Visual Basic,
PHP, PowerShell, Haskell, Perl, Python, Ruby, C#, NodeJS, Java, Go, C++, OCaml,
Lua, Rust, Delphi, Free Pascal a pro Valu. Proč se však jedná o
&bdquo;univerzální&ldquo; assembler a disassembler? Cílem autorů těchto
frameworků je nabídnout podporu pro mnoho procesorových architektur. Samozřejmě
se v&nbsp;první řadě jedná o x86 (s&nbsp;podporou 16bitového, 32bitového i
64bitového režimu) a o AArch64. Podporovány jsou ovšem i další procesorové
architektury, například 32bitový ARM, MIPS, PowerPC, SPARC a SystemZ.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Proč je vlastně zapotřebí &bdquo;nový&ldquo; assembler a disassembler?</h2>

<p>Na tomto místě si možná čtenáři tohoto článku kladou otázku, proč je vlastně
zapotřebí vytvářet nový assembler a disassembler. Autoři frameworků Capstone a
Keystone pracují mj.&nbsp;na nástrojích z&nbsp;oblasti kyberbezpečnosti,
analýzy kódů atd. A v&nbsp;těchto oblastech je někdy zapotřebí provést zpětný
překlad krátké sekvence bajtů (<i>disassembling</i>), úpravu takto získaného
kódu v&nbsp;assembleru následovaného překladem do nativního kódu
(<i>assembling</i>). Pro tyto účely se klasické assemblery a disassemblery
ovládané z&nbsp;příkazového řádku příliš nehodí, takže může být vhodnější
použít k&nbsp;tomuto účelu vytvořené nativní knihovny. Navíc v&nbsp;současnosti
vlastně ani neexistuje skutečně univerzální assembler a disassembler
s&nbsp;podporou různých způsobů zápisu instrukcí (GAS s&nbsp;Intel syntaxí, GAS
s&nbsp;AT&amp;T syntaxí, NASM, MASM, atd.). <i>Keystone</i> a <i>Capstone</i>
se snaží (i když prozatím jen s&nbsp;částečným úspěchem) o dosažení plné
kompatibility s&nbsp;těmito syntaxemi a současně o podporu co největšího
množství procesorových architektur.</p>

<p><div class="rs-tip-major">Poznámka: navíc je možné takto pojaté assemblery a
disassemblery velmi jednoduše integrovat do různých IDE či jiných
(specializovaných) nástrojů.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace rozhraní mezi Pythonem a frameworky Capstone a Keystone</h2>

<p>V&nbsp;této kapitole si ukážeme instalaci balíčků pro Python, které
zajišťují rozhraní mezi skripty napsanými v&nbsp;Pythonu na jedné straně
s&nbsp;frameworky Capstone a Keystone na straně druhé.</p>

<p>Vzhledem k&nbsp;tomu, že rozhraní mezi Pythonem a frameworky <i>Capstone</i>
a <i>Keystone</i> je dostupné ve formě klasických Pythonovských balíčků na PyPi
(<a
href="https://pypi.org/project/capstone/">https://pypi.org/project/capstone/</a>,
<a
href="https://pypi.org/project/keystone-engine/">https://pypi.org/project/keystone-engine/</a>),
je samotná instalace zcela bezproblémová. Nejdříve nainstalujeme jak vlastní
<i>Capstone</i> (tedy disassembler), tak i příslušné rozhraní pro Python:</p>

<pre>
$ <strong>pip3 install --user capstone</strong>
&nbsp;
Collecting capstone
  Downloading capstone-4.0.2-py2.py3-none-manylinux1_x86_64.whl (2.1 MB)
     |████████████████████████████████| 2.1 MB 1.4 MB/s
Installing collected packages: capstone
Successfully installed capstone-4.0.2
</pre>

<p>Následně nainstalujeme i <i>Keystone</i> (tedy assembler), pochopitelně opět
s&nbsp;rozhraním pro Python:</p>

<pre>
$ <strong>pip3 install --user keystone-engine</strong>
&nbsp;
Collecting keystone-engine
  Downloading keystone_engine-0.9.2-py2.py3-none-manylinux1_x86_64.whl (1.8 MB)
     |████████████████████████████████| 1.8 MB 1.6 MB/s
Installing collected packages: keystone-engine
Successfully installed keystone-engine-0.9.2
</pre>

<p><div class="rs-tip-major">Poznámka: lokální instalace pro aktuálně
přihlášeného uživatele typicky probíhá do adresáře
<strong>~/.local/lib/Python{verze}/site-packages</strong>, jehož minimální
struktura by po instalaci měla vypadat přibližně takto:</div></p>

<pre>
.
├── <strong>capstone</strong>
│   ├── include
│   │   └── capstone
│   ├── lib
│   └── __pycache__
├── <strong>capstone-4.0.2.dist-info</strong>
├── keystone
│   └── __pycache__
├── <strong>keystone_engine-0.9.2.dist-info</strong>
├── pep517
│   ├── in_process
│   │   └── __pycache__
│   └── __pycache__
└── pep517-0.12.0.dist-info
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ruční překlad knihovny Capstone</h2>

<p>V&nbsp;případě, že budete chtít využít nástroje <i>Capstone</i> a
<i>Keystone</i> z&nbsp;programovacího jazyka C (popř.&nbsp;pochopitelně
z&nbsp;C++) a nikoli z&nbsp;Pythonu, je možné si nechat tyto knihovny přeložit
přímo překladačem jazyka (<i>Capstone</i>) nebo C++ (<i>Keystone</i>), a to ze
zdrojových kódů dostupných na GitHubu. Ukažme si pro ilustraci postup při
překladu knihovny <i>Capstone</i>, která vyžaduje pouze překladač jazyka C.</p>

<p>Naklonujeme repositář se zdrojovými kódy této knihovny:</p>

<pre>
$ <strong>git clone git@github.com:capstone-engine/capstone.git</strong>
&nbsp;
Cloning into 'capstone'...
remote: Enumerating objects: 30861, done.
remote: Counting objects: 100% (1604/1604), done.
remote: Compressing objects: 100% (1045/1045), done.
remote: Total 30861 (delta 631), reused 1367 (delta 535), pack-reused 29257
Receiving objects: 100% (30861/30861), 48.27 MiB | 2.03 MiB/s, done.
Resolving deltas: 100% (21692/21692), done.
</pre>

<p>Ve druhém kroku se přepneme do větve <strong>next</strong>. To je velmi
důležité, protože výchozí větev <strong>master</strong> se v&nbsp;tomto
projektu nepoužívá:</p>

<pre>
$ <strong>cd capstone/</strong>
&nbsp;
✔ /tmp/ramdisk/capstone [master|✔]
&nbsp;
$ <strong>git checkout next</strong>
&nbsp;
Branch 'next' set up to track remote branch 'next' from 'origin'.
Switched to a new branch 'next'
</pre>

<p>Vlastní překlad je založen na klasickém Makefile:</p>

<pre>
$ <strong>make</strong>
&nbsp;
  CC      cs.o
  CC      utils.o
  CC      SStream.o
  CC      MCInstrDesc.o
  CC      MCRegisterInfo.o
  CC      arch/ARM/ARMModule.o
  CC      arch/ARM/ARMMapping.o
  CC      arch/ARM/ARMInstPrinter.o
  CC      arch/ARM/ARMDisassembler.o
  CC      arch/AArch64/AArch64Disassembler.o
  CC      arch/AArch64/AArch64Module.o
  CC      arch/AArch64/AArch64Mapping.o
  CC      arch/AArch64/AArch64InstPrinter.o
  CC      arch/AArch64/AArch64BaseInfo.o
  CC      arch/M68K/M68KInstPrinter.o
  ...
  ...
  ...
  LINK    test_m680x.static
  LINK    test_evm
  LINK    test_evm.static
  LINK    test_riscv
  LINK    test_riscv.static
  LINK    test_wasm
  LINK    test_wasm.static
  LINK    test_mos65xx
  LINK    test_mos65xx.static
  LINK    test_bpf
  LINK    test_bpf.static
make[1]: Leaving directory '/tmp/ramdisk/capstone/tests'
install -m0755 ./libcapstone.so.5 ./tests/
cd ./tests/ &amp;&amp; rm -f libcapstone.so &amp;&amp; ln -s libcapstone.so.5 libcapstone.so
</pre>

<p>Výsledkem bude především nativní knihovna <strong>libcapstone.so</strong>,
kterou bude možné využít způsobem popsaným v&nbsp;navazujícím článku.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. První kroky s&nbsp;knihovnou Keystone &ndash; zavolání assembleru s&nbsp;výpisem přeloženého kódu</h2>

<p>Nyní se můžeme podívat na základní způsob použití knihovny <i>Keystone</i>,
která implementuje assembler (jenž je do značné míry nezávislý na architektuře
procesorů). Pokusíme se z&nbsp;Pythonu přeložit tři jednoduché instrukce ve
starobylém šestnáctibitovém režimu mikroprocesorů s&nbsp;architekturou x86.
Instrukce jsou zapsány v&nbsp;bytovém poli a oddělené jsou středníkem. Před
překladem je nutné zvolit jak architekturu (<strong>KS_ARCH_X86</strong>), tak
i režim (zde konkrétně <strong>KS_MODE_16</strong>). Výsledkem překladu je buď
výjimka (která nese základní informaci o tom, k&nbsp;jaké chybě došlo) nebo
sekvence bajtů představujících binární strojový kód:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_16, KsError
&nbsp;
<i># instrukce, které se mají assemblerem přeložit</i>
CODE = b"MOV AX, 100; INC AX; MOV BX, AX"
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_16)</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(CODE)</strong>
nbsp;
    <i># tisk výsledku činnosti assembleru</i>
    print("%s = %s (number of statements: %u)" % (CODE, encoding, count))
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_A.py</a>.</div></p>

<p>Výsledek získaný po spuštění tohoto skriptu by měl vypadat následovně:</p>

<pre>
b'MOV AX, 100; INC AX; MOV BX, AX' = <strong>[184, 100, 0, 64, 137, 195]</strong> (number of statements: 3)
</pre>

<p>Alternativně je možné každou instrukci zapsat na samostatném řádku,
tj.&nbsp;namísto středníků se použije znak pro konec řádku. Současně namísto
pole bajtů použijeme klasický řetězec. V&nbsp;Pythonu může upravený skript
vypadat takto:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_16, KsError
&nbsp;
<i># instrukce, které se mají assemblerem přeložit</i>
CODE = """
    MOV AX, 100
    INC AX
    MOV BX, AX
"""
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_16)</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(CODE)</strong>
&nbsp;
    <i># tisk výsledku činnosti assembleru</i>
    print("%s = %s (number of statements: %u)" % (CODE, encoding, count))
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_B.py</a>.</div></p>

<p>Výsledek činnosti skriptu by měl být totožný se skriptem předchozím:</p>

<pre>
    MOV AX, 100
    INC AX
    MOV BX, AX
 = <strong>[184, 100, 0, 64, 137, 195]</strong> (number of statements: 4)
</pre>

<p><div class="rs-tip-major">Poznámka: položka &bdquo;number of
statements&ldquo; zahrnuje i první prázdný řádek zdrojového kódu.</div></p>

<p>Konkrétně nyní překlad vypadá takto:</p>

<table>
<tr><th>Offset</th><th>Decimal</th><th>Hexa</th><th>Instrukce</th></tr>
<tr><td>0</td><td>184 100 0</td><td>b8 64 00</td><td>mov ax,0x64</td></tr>
<tr><td>3</td><td>64</td><td>40</td><td>inc ax</td></tr>
<tr><td>4</td><td>137 195</td><td>89 c3</td><td>mov bx,ax</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. 32bitový režim mikroprocesorů x86</h2>

<p>V&nbsp;případě, že se pokusíme o překlad tří <a href="#k05">výše
zmíněných</a> instrukcí v&nbsp;32bitovém režimu mikroprocesorů, překlad se
podaří, ovšem výsledný binární kód bude odlišný, a to z&nbsp;toho důvodu, že
odlišné je i samotné kódování instrukcí:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_32, KsError
&nbsp;
<i># instrukce, které se mají assemblerem přeložit</i>
CODE = """
    MOV AX, 100
    INC AX
    MOV BX, AX
"""
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_32)</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(CODE)</strong>
&nbsp;
    <i># tisk výsledku činnosti assembleru</i>
    print("%s = %s (number of statements: %u)" % (CODE, encoding, count))
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_32bit.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_32bit.py</a>.</div></p>

<p>Povšimněte si, jak je výsledný binární kód dlouhý. Je tomu tak kvůli odlišným
prefixům (102=0x66) u prakticky všech šestnáctibitových instrukcí:</p>

<pre>
    MOV AX, 100
    INC AX
    MOV BX, AX
 = <strong>[102, 184, 100, 0, 102, 64, 102, 137, 195]</strong> (number of statements: 4)
</pre>

<p>Konkrétně nyní překlad vypadá takto:</p>

<table>
<tr><th>Offset</th><th>Decimal</th><th>Hexa</th><th>Instrukce</th></tr>
<tr><td>0</td><td>102 184 100 0</td><td>66 b8 64 00</td><td>mov ax,0x64</td></tr>
<tr><td>4</td><td>102 64</td><td>66 40</td><td>inc ax</td></tr>
<tr><td>6</td><td>102 137 195</td><td>66 89 c3</td><td>mov bx,ax</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. 64bitový režim mikroprocesorů x86-64</h2>

<p>Pro úplnost přeložíme ten samý kód, ovšem v&nbsp;64bitovém režimu
mikroprocesorů s&nbsp;architekturou x86-64. I v&nbsp;tomto režimu je totiž
možné využít původní šestnáctibitové registry, když je to skutečně zapotřebí
(většinou však není):</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_64, KsError
&nbsp;
<i># instrukce, které se mají assemblerem přeložit</i>
CODE = """
    MOV AX, 100
    INC AX
    MOV BX, AX
"""
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_64)</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(CODE)</strong>
&nbsp;
    <i># tisk výsledku činnosti assembleru</i>
    print("%s = %s (number of statements: %u)" % (CODE, encoding, count))
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_64bit.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_64bit.py</a>.</div></p>

<p>S&nbsp;výsledkem:</p>

<pre>
    MOV AX, 100
    INC AX
    MOV BX, AX
 = <strong>[102, 184, 100, 0, 102, 255, 192, 102, 137, 195]</strong> (number of statements: 4)
</pre>

<p>Konkrétně nyní překlad vypadá takto (opět odlišně &ndash; viz prostřední
instrukci!):</p>

<table>
<tr><th>Offset</th><th>Decimal</th><th>Hexa</th><th>Instrukce</th></tr>
<tr><td>0</td><td>102 184 100 0</td><td>66 b8 64 00</td><td>mov ax,0x64</td></tr>
<tr><td>4</td><td>102 255 192</td><td>66 ff c0</td><td>inc ax</td></tr>
<tr><td>7</td><td>102 137 195</td><td>66 89 c3</td><td>mov bx,ax</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;šestnáctibitovém režimu byla
instrukce <strong>INC AX</strong> zakódována v&nbsp;jediném bajtu.
V&nbsp;32bitovém režimu bylo nutné přidat jednobajtový prefix, zatímco
v&nbsp;režimu 64bitovém se kvůli většímu množství instrukcí, registrů a
adresovacích režimů kódování zcela změnilo a původně velmi krátké instrukce se
kódují delší sekvencí bajtů.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zápis instrukcí a operandů s&nbsp;využitím AT&amp;T syntaxe</h2>

<p>Při použití různých assemblerů (zejména <i>GNU Assembleru</i>) na
mikroprocesorech s&nbsp;architekturou i386 či x86-64 je možné použít dvě různé
syntaxe zápisu programů. Proč ale vlastně k&nbsp;tomuto stavu došlo? Původní
verze <i>GNU Assembleru</i> z&nbsp;historických důvodů používala zápis
používaný v&nbsp;AT&amp;T (resp.&nbsp;přesněji řečeno v&nbsp;Bell Labs při
vývoji Unixu). Tento zápis je sice (samozřejmě jen do určité míry)
konzistentní mezi různými platformami, ovšem pro mnoho programátorů pracujících
na platformách s&nbsp;procesory s&nbsp;architekturou i386 je AT&amp;T syntaxe
velmi nezvyklá a taktéž nekompatibilní s&nbsp;dalšími typy assemblerů (dnes již
historický <i>Turbo Assembler &ndash; TASM</i>, <i>Microsoft Macro Assembler
&ndash; MASM</i> atd.). Proto mj.&nbsp;vznikl i projekt <i>Netwide Assembler
(NASM)</i>, který i na Linux (resp.&nbsp;přesněji řečeno do jeho toolchainu)
přidal podporu pro zápis programů v&nbsp;assembleru podle zvyklostí
z&nbsp;jiných systémů. Změny později nastaly i v&nbsp;<i>GNU Assembleru</i>,
což mj.&nbsp;znamená, že od verze 2.10 je možné se jedinou direktivou přepnout
do režimu částečně kompatibilního s&nbsp;TASM/MASM.</p>

<p>AT&amp;T syntaxe je podporována i v&nbsp;<i>Keystone</i>, jen musíme
explicitně specifikovat její použití (viz též zvýrazněnou část skriptu):</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_16, KS_OPT_SYNTAX_ATT, KsError
&nbsp;
<i># instrukce, které se mají assemblerem přeložit</i>
CODE = """
    MOV %AX, 100
    INC %AX
    MOV %BX, %AX
"""
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_16)</strong>
&nbsp;
    <i># exlicitní specifikace použité syntaxe</i>
    <strong>ks.syntax = KS_OPT_SYNTAX_ATT</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(CODE)</strong>
&nbsp;
    <i># tisk výsledku činnosti assembleru</i>
    print("%s = %s (number of statements: %u)" % (CODE, encoding, count))
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_A.py</a>.</div></p>

<p>Ve skutečnosti ovšem tento skript neobsahuje korektní sekvenci instrukcí,
takže i výsledek nebude korektní:</p>

<pre>
    MOV %AX, 100
    INC %AX
    MOV %BX, %AX
 = [163, 0, 1, 64, 137, 216] (number of statements: 4)
</pre>

<p>V&nbsp;AT&amp;T syntaxi se totiž operandy instrukcí uvádí v&nbsp;opačném
pořadí (zdroj, cíl). Navíc se odlišně zapisují i konstanty. Provedeme tedy malé
úpravy do podoby:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_16, KS_OPT_SYNTAX_ATT, KsError
&nbsp;
<i># instrukce, které se mají assemblerem přeložit</i>
CODE = """
    MOV $64, %AX
    INC %AX
    MOV %AX, %BX
"""
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_16)</strong>
&nbsp;
    <i># exlicitní specifikace použité syntaxe</i>
    <strong>ks.syntax = KS_OPT_SYNTAX_ATT</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(CODE)</strong>
&nbsp;
    <i># tisk výsledku činnosti assembleru</i>
    print("%s = %s (number of statements: %u)" % (CODE, encoding, count))
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_B.py</a>.</div></p>

<p>Nyní by již mělo dojít k&nbsp;překladu, a to do stejné sekvence bajtů, jako
tomu bylo u příkladů uvedených <a href="#k05">v&nbsp;páté kapitole</a>:</p>

<pre>
    MOV $64, %AX
    INC %AX
    MOV %AX, %BX
 = [184, 100, 0, 64, 137, 195] (number of statements: 4)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Návěští (<i>labels</i>), skoky a programové smyčky</h2>

<p>V&nbsp;prakticky všech programech zapsaných v&nbsp;assembleru se setkáme se
skoky a programovými smyčkami (realizovanými opět skoky). Cíle skoků jsou
přitom označeny pojmenovaným návěštím (<i>label</i>), přičemž za jméno návěští
se zapisuje dvojtečka a samotné návěští typicky začíná na začátku
assemblerovského řádku. Podívejme se nyní na realizaci velmi jednoduché
programové smyčky, v&nbsp;níž je ve funkci počitadla použit 32bitový registr
<strong>EAX</strong>, jehož hodnota se postupně snižuje od 100 k&nbsp;nule.
Jakmile se dosáhne nulové hodnoty, skok <strong>JNZ</strong> (<i>Jump if Not
Zero</i>) se již neprovede:</p>

<pre>
    MOV EAX, 100
LOOP:
    DEC EAX
    JNZ LOOP
</pre>

<p>Tuto smyčku lze přeložit do sekvence strojových instrukcí takto:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_64, KsError
&nbsp;
<i># instrukce, které se mají assemblerem přeložit</i>
CODE = """
    MOV EAX, 100
LOOP:
    DEC EAX
    JNZ LOOP
"""
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_64)</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(CODE)</strong>
&nbsp;
    <i># tisk výsledku činnosti assembleru</i>
    print("%s = %s (number of statements: %u)" % (CODE, encoding, count))
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_A.py</a>.</div></p>

<p>Podívejme se nyní na způsob překladu výše uvedené programové smyčky do
assembleru:</p>

<pre>
    MOV EAX, 100
LOOP:
    DEC EAX
    JNZ LOOP
 = [184, 100, 0, 0, 0, 255, 200, 117, 252] (number of statements: 5)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vnořené programové smyčky</h2>

<p>Ve strojovém kódu (a tedy i v&nbsp;assembleru) je možné realizovat skoky na
prakticky libovolnou adresu v&nbsp;kódovém segmentu (i když některé
architektury omezují cílové adresy na hodnoty dělitelné 4, 8 atd.). To
mj.&nbsp;znamená, že je možné realizovat vnořené programové smyčky; ovšem fakt,
že se jedná o strukturované vnořené smyčky a nikoli o &bdquo;špagetový
kód&ldquo; záleží jen na vývojáři.</p>

<p>Podívejme se nyní na triviální příklad s&nbsp;dvojicí vnořených smyček. Jako
počitadlo vnější smyčky slouží pracovní registr <strong>EBX</strong>, pro
vnitřní smyčku je jako počitadlo použit pracovní registr <strong>EAX</strong>.
Počitadla jsou vždy snižována o jedničku a skok na začátek smyčky je proveden
v&nbsp;případě, že hodnota počitadla ještě nedosáhla nuly:</p>

<pre>
    MOV EBX, 10
<strong>OUTER_LOOP</strong>:
    MOV EAX, 100
<strong>INNER_LOOP</strong>:
    DEC EAX
    JNZ <strong>INNER_LOOP</strong>
    DEC EBX
    JNZ <strong>OUTER_LOOP</strong>
</pre>

<p>Výše uvedenou dvojici programových smyček je možné přeložit do sekvence
strojových instrukcí následovně:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_64, KsError
&nbsp;
<i># instrukce, které se mají assemblerem přeložit</i>
CODE = """
    MOV EBX, 10
OUTER_LOOP:
    MOV EAX, 100
INNER_LOOP:
    DEC EAX
    JNZ INNER_LOOP
    DEC EBX
    JNZ OUTER_LOOP
"""
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_64)</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(CODE)</strong>
&nbsp;
    <i># tisk výsledku činnosti assembleru</i>
    print("%s = %s (number of statements: %u)" % (CODE, encoding, count))
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_B.py</a>.</div></p>

<p>Opět si ukažme, jakým způsobem se předchozí kód přeloží do assembleru:</p>

<pre>
    MOV EBX, 10
OUTER_LOOP:
    MOV EAX, 100
INNER_LOOP:
    DEC EAX
    JNZ INNER_LOOP
    DEC EBX
    JNZ OUTER_LOOP
 = [187, 10, 0, 0, 0, 184, 100, 0, 0, 0, 255, 200, 117, 252, 255, 203, 117, 243] (number of statements: 9)
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že vám vygenerovaný
strojový kód připadá příliš dlouhý, je vhodné si připomenout, že obě počitadla
smyčky jsou realizována 32bitovými registry a tudíž načtení konstanty do
takového registru je realizováno pětibajtovou instrukcí (první bajt je
operačním kódem, další čtyři bajty obsahují hodnotu).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Překlad do souboru s&nbsp;binárním kódem</h2>

<p>Vzhledem k&nbsp;tomu, že výsledkem překladu je v&nbsp;případě frameworku
<i>Keystone</i> sekvence bajtů, je možné velmi snadno realizovat překlad do
souboru obsahujícího binární kód. Pozor ovšem na to, že se nebude jednat o
spustitelný soubor ani o nativní knihovnu, ale skutečně &bdquo;pouze&ldquo; o
sekvenci bajtů se zakódovanými strojovými instrukcemi.</p>

<p>Kód s&nbsp;vnořenými smyčkami přeložíme do binárního souboru nazvaného
&bdquo;loops.bin&ldquo; takto:</p>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_64, KsError
&nbsp;
<i># instrukce, které se mají assemblerem přeložit</i>
CODE = """
    MOV EBX, 10
OUTER_LOOP:
    MOV EAX, 100
INNER_LOOP:
    DEC EAX
    JNZ INNER_LOOP
    DEC EBX
    JNZ OUTER_LOOP
"""
&nbsp;
try:
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_64)</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(CODE)</strong>
&nbsp;
    <i># uložení výsledného nativního kódu do souboru</i>
    with open("loops.bin", "wb") as fout:
        fout.write(<strong>bytes(encoding)</strong>)
    print("Binary file written")
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_A.py</a>.</div></p>

<p>Vygenerovaný soubor &bdquo;loops.bin&ldquo; bude mít délku osmnácti bajtů,
jejichž obsah si můžeme snadno prohlédnout v&nbsp;hexadecimálním prohlížeči
(nenechte se zmýlit tím, že <strong>od</strong> původně znamenalo <i>octal
dump</i>):</p>

<pre>
$ <strong>od -tx1 loops.bin</strong>
&nbsp;
0000000 bb 0a 00 00 00 b8 64 00 00 00 ff c8 75 fc ff cb
0000020 75 f3
0000022
</pre>

<p>Nástrojem <strong>objdump</strong> se můžeme pokusit o disassembling
binárního souboru, tedy vlastně o obnovu původního kódu napsaného
v&nbsp;assembleru a doplněného o konkrétní adresy:</p>

<pre>
$ <strong>objdump -b binary -D -m i386:x86-64 -M intel loops.bin &gt; loops_dump.asm</strong>
</pre>

<p>S&nbsp;tímto výsledkem:</p>

<pre>
loops.bin:     file format binary
&nbsp;
&nbsp;
Disassembly of section .data:
&nbsp;
0000000000000000 &lt;.data&gt;:
   0:   bb 0a 00 00 00          mov    ebx,0xa
   5:   b8 64 00 00 00          mov    eax,0x64
   a:   ff c8                   dec    eax
   c:   75 fc                   jne    0xa
   e:   ff cb                   dec    ebx
  10:   75 f3                   jne    0x5
</pre>

<p><div class="rs-tip-major">Poznámka: právě na tomto výpisu je patrné, proč je
šest instrukcí uloženo v&nbsp;osmnácti bajtech: první dvě instrukce mají délku
pěti bajtů.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Program typu &bdquo;Hello world&ldquo; napsaný v&nbsp;assembleru procesorů x86 určený pro Linux</h2>

<p>Podívejme se nyní, jak může vypadat zápis programu typu &bdquo;Hello
world!&ldquo; napsaný v&nbsp;GNU Assembleru a určený pro spuštění na
architektuře i386 s&nbsp;Linuxem. Celý program vlastně volá jen dvě služby
jádra: <strong>sys_write</strong> a <strong>sys_exit</strong>. V&nbsp;případě
<strong>sys_exit</strong> je nutné nastavit tuto dvojici pracovních
registrů:</p>

<table>
<tr><th>Registr</th><th>Význam</th><th>Obsah</th></tr>
<tr><td>eax</td><td>číslo syscallu</td><td>sys_write=1</td></tr>
<tr><td>ebx</td><td>návratová hodnota</td><td>exit code = 0</td></tr>
</table>

<p>U volání <strong>sys_write</strong> se naproti tomu nastaví pracovní
registry takto:</p>

<table>
<tr><th>Registr</th><th>Význam</th><th>Obsah</th></tr>
<tr><td>eax</td><td>číslo syscallu</td><td>sys_write=4</td></tr>
<tr><td>ebx</td><td>číslo deskriptoru</td><td>stdout=1</td></tr>
<tr><td>ecx</td><td>adresa řetězce/bajtů</td><td>nastaví se do .data segmentu</td></tr>
<tr><td>edx</td><td>počet bajtů pro zápis</td><td>strlen("Hello world!\n")=13</td></tr>
</table>

<p>Zajímavý je obsah pracovního registru <strong>ecx</strong>, protože ten musí
obsahovat adresu řetězce (resp.&nbsp;bloku bajtů). V&nbsp;AT&amp;T syntaxi to
vypadá následovně:</p>

<pre>
mov   $hello_lbl,%ecx
</pre>

<p>kdežto v&nbsp;syntaxi Intelu se namísto toho použije:</p>

<pre>
mov   ecx, hello_lbl
</pre>

<p>Přičemž <strong>hello_lbl</strong> je návěští (<i>label</i>) neboli
pojmenovaná adresa. Povšimněte si, že řetězec není ukončen znakem s&nbsp;ASCII
kódem 0. To není nutné, protože systémová služba přesně zná délku řetězce
(bloku bajtů):</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Jednoducha aplikace typu "Hello world!" naprogramovana</i>
<i># v assembleru GNU as - pouzita je "Intel" syntaxe.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
.intel_syntax noprefix
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=1
sys_write=4
&nbsp;
&nbsp;
&nbsp;
_start:
        mov   eax, sys_write         <i># cislo syscallu pro funkci "write"</i>
        mov   ebx, 1                 <i># standardni vystup</i>
        mov   ecx, hello_lbl         <i># adresa retezce, ktery se ma vytisknout</i>
        mov   edx, 13                <i># pocet znaku, ktere se maji vytisknout</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
&nbsp;
        mov   eax, sys_exit          <i># cislo sycallu pro funkci "exit"</i>
        mov   ebx, 0                 <i># exit code = 0</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
&nbsp;
&nbsp;
hello_lbl:
        .string "Hello World!\n"     <i># string, ktery JE ukoncen nulou</i>
</pre>

<p><div class="rs-tip-major">Poznámka: tento prográmek napsaný
v&nbsp;assembleru naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world.asm</a>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
<i># import všech symbolů použitých ve skriptu</i>
from keystone import Ks, KS_ARCH_X86, KS_MODE_64, KsError
&nbsp;
&nbsp;
try:
    <i># načtení kódu v assembleru ze souboru</i>
    with open("hello_world.asm", "r") as fin:
        code = fin.read()
&nbsp;
    <i># kontrolní výpis, jaký kód budeme překládat</i>
    print(code)
&nbsp;
    <i># inicializace assembleru se specifikací architektury a popř. i režimu</i>
    ks = <strong>Ks(KS_ARCH_X86, KS_MODE_64)</strong>
&nbsp;
    <i># vlastní překlad (assembling)</i>
    encoding, count = <strong>ks.asm(code)</strong>
&nbsp;
    <i># uložení výsledného nativního kódu do souboru</i>
    with open("hello.bin", "wb") as fout:
        fout.write(<strong>bytes(encoding)</strong>)
    print("Binary file written")
except KsError as e:
    print("ERROR: %s" % e)
</pre>

<p><div class="rs-tip-major">Poznámka: tento skript naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_B.py</a>.</div></p>

<pre>
$ <strong>od -tx1 hello.bin</strong>
&nbsp;
0000000 b8 04 00 00 00 bb 01 00 00 00 b9 22 00 00 00 ba
0000020 0d 00 00 00 cd 80 b8 01 00 00 00 bb 00 00 00 00
0000040 cd 80 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 0a 00
0000060
</pre>

<pre>
hello.bin:     file format binary
&nbsp;
&nbsp;
Disassembly of section .data:
&nbsp;
0000000000000000 &lt;.data&gt;:
   0:   b8 04 00 00 00          mov    eax,0x4
   5:   bb 01 00 00 00          mov    ebx,0x1
   a:   b9 22 00 00 00          mov    ecx,0x22
   f:   ba 0d 00 00 00          mov    edx,0xd
  14:   cd 80                   int    0x80
  16:   b8 01 00 00 00          mov    eax,0x1
  1b:   bb 00 00 00 00          mov    ebx,0x0
  20:   cd 80                   int    0x80
  22:   48                      rex.W
  23:   65 6c                   gs ins BYTE PTR es:[rdi],dx
  25:   6c                      ins    BYTE PTR es:[rdi],dx
  26:   6f                      outs   dx,DWORD PTR ds:[rsi]
  27:   20 57 6f                and    BYTE PTR [rdi+0x6f],dl
  2a:   72 6c                   jb     0x98
  2c:   64 21 0a                and    DWORD PTR fs:[rdx],ecx
        ...
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Jednoducha aplikace typu "Hello world!" naprogramovana</i>
<i># v assembleru GNU as - pouzita je "Intel" syntaxe.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
.intel_syntax noprefix
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=1
sys_write=4
&nbsp;
&nbsp;
hello_lbl:
        .string "Hello World!\n"     <i># string, ktery JE ukoncen nulou</i>
&nbsp;
&nbsp;
_start:
        mov   eax, sys_write         <i># cislo syscallu pro funkci "write"</i>
        mov   ebx, 1                 <i># standardni vystup</i>
        mov   ecx, hello_lbl         <i># adresa retezce, ktery se ma vytisknout</i>
        mov   edx, 13                <i># pocet znaku, ktere se maji vytisknout</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
&nbsp;
        mov   eax, sys_exit          <i># cislo sycallu pro funkci "exit"</i>
        mov   ebx, 0                 <i># exit code = 0</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: tento prográmek napsaný
v&nbsp;assembleru naleznete na adrese <a
href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world_2.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world_2.asm</a>.</div></p>

<pre>
$ <strong>od -tx1 hello_2.bin</strong>
&nbsp;
0000000 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 0a 00 b8 04
0000020 00 00 00 bb 01 00 00 00 b9 00 00 00 00 ba 0d 00
0000040 00 00 cd 80 b8 01 00 00 00 bb 00 00 00 00 cd 80
0000060
</pre>

<pre>
hello_2.bin:     file format binary
&nbsp;
&nbsp;
Disassembly of section .data:
&nbsp;
0000000000000000 &lt;.data&gt;:
   0:   48                      rex.W
   1:   65 6c                   gs ins BYTE PTR es:[rdi],dx
   3:   6c                      ins    BYTE PTR es:[rdi],dx
   4:   6f                      outs   dx,DWORD PTR ds:[rsi]
   5:   20 57 6f                and    BYTE PTR [rdi+0x6f],dl
   8:   72 6c                   jb     0x76
   a:   64 21 0a                and    DWORD PTR fs:[rdx],ecx
   d:   00 b8 04 00 00 00       add    BYTE PTR [rax+0x4],bh
  13:   bb 01 00 00 00          mov    ebx,0x1
  18:   b9 00 00 00 00          mov    ecx,0x0
  1d:   ba 0d 00 00 00          mov    edx,0xd
  22:   cd 80                   int    0x80
  24:   b8 01 00 00 00          mov    eax,0x1
  29:   bb 00 00 00 00          mov    ebx,0x0
  2e:   cd 80                   int    0x80
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>

<pre>
# asmsyntax=as

# Program pro otestovani chovani instrukci CALL a RET
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix


# Linux kernel system call table
sys_exit   = 1
sys_write  = 4

# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1



message1:                            # adresa prvni zpravy
        .string "Hello World\n"
message1len = 13                     # delka prvni zpravy

message2:                            # adresa druhe zpravy
        .string "Assembler je fajn\n"
message2len = 18                     # delka druhe zpravy


_start:
        call  writeFirstMessage      # zavolani podprogramu pro vytisteni prvni zpravy
        call  writeSecondMessage     # zavolani podprogramu pro vytisteni druhe zpravy
        call  exit                   # zavolani podprogramu pro ukonceni procesu



# Podprogram pro vytisteni prvni zpravy
writeFirstMessage:
        mov   ecx, message1          # adresa retezce, ktery se ma vytisknout
        mov   edx, message1len       # pocet znaku, ktere se maji vytisknout
        call  writeMessage           # zavolani podprogramu pro vytisteni zpravy
        ret                          # navrat z podprogramu



# Podprogram pro vytisteni druhe zpravy
writeSecondMessage:
        mov   ecx, message2          # adresa retezce, ktery se ma vytisknout
        mov   edx, message2len       # pocet znaku, ktere se maji vytisknout
        call  writeMessage           # zavolani podprogramu pro vytisteni zpravy
        ret                          # navrat z podprogramu



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
writeMessage:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80                   # volani Linuxoveho kernelu
        ret                          # navrat z podprogramu



# Podprogram pro ukonceni procesu zavolanim syscallu
exit:
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu

# finito
</pre>

<pre>
from keystone import *

try:
    with open("subroutines.asm", "r") as fin:
        code = fin.read()

    print(code)

    ks = Ks(KS_ARCH_X86, KS_MODE_32)
    encoding, count = ks.asm(code)
    with open("subroutines.bin", "wb") as fout:
        fout.write(bytes(encoding))
except KsError as e:
    print("ERROR: %s" %e)
</pre>

<pre>
subroutines.bin:     file format binary


Disassembly of section .data:

0000000000000000 <.data>:
   0:   48                      rex.W
   1:   65 6c                   gs ins BYTE PTR es:[rdi],dx
   3:   6c                      ins    BYTE PTR es:[rdi],dx
   4:   6f                      outs   dx,DWORD PTR ds:[rsi]
   5:   20 57 6f                and    BYTE PTR [rdi+0x6f],dl
   8:   72 6c                   jb     0x76
   a:   64 0a 00                or     al,BYTE PTR fs:[rax]
   d:   41 73 73                rex.B jae 0x83
  10:   65 6d                   gs ins DWORD PTR es:[rdi],dx
  12:   62                      (bad)  
  13:   6c                      ins    BYTE PTR es:[rdi],dx
  14:   65 72 20                gs jb  0x37
  17:   6a 65                   push   0x65
  19:   20 66 61                and    BYTE PTR [rsi+0x61],ah
  1c:   6a 6e                   push   0x6e
  1e:   0a 00                   or     al,BYTE PTR [rax]
  20:   e8 0a 00 00 00          call   0x2f
  25:   e8 15 00 00 00          call   0x3f
  2a:   e8 2d 00 00 00          call   0x5c
  2f:   b9 00 00 00 00          mov    ecx,0x0
  34:   ba 0d 00 00 00          mov    edx,0xd
  39:   e8 11 00 00 00          call   0x4f
  3e:   c3                      ret    
  3f:   b9 0d 00 00 00          mov    ecx,0xd
  44:   ba 12 00 00 00          mov    edx,0x12
  49:   e8 01 00 00 00          call   0x4f
  4e:   c3                      ret    
  4f:   b8 04 00 00 00          mov    eax,0x4
  54:   bb 01 00 00 00          mov    ebx,0x1
  59:   cd 80                   int    0x80
  5b:   c3                      ret    
  5c:   b8 01 00 00 00          mov    eax,0x1
  61:   bb 00 00 00 00          mov    ebx,0x0
  66:   cd 80                   int    0x80
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>

<pre>
from capstone import *


with open("loops.bin", "rb") as fin:
    code = fin.read()

md = Cs(CS_ARCH_X86, CS_MODE_64)
for i in md.disasm(code, 0x0000):
    print("0x%x:\t%s\t%s" %(i.address, i.mnemonic, i.op_str))
</pre>

<pre>
0x0:    mov     ebx, 0xa
0x5:    mov     eax, 0x64
0xa:    dec     eax
0xc:    jne     5
0xe:    dec     ebx
0x10:   jne     0
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
programovací jazyk Python 3 (nikoli ovšem pro starší verze Pythonu 2!) byly
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem stále
velmi malý, dnes má velikost zhruba několik desítek kilobajtů), můžete namísto
toho použít odkazy na jednotlivé příklady, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>first_steps_16bit_A.py</td><td>překlad 16bitového kódu (zapsaného na jediném řádku) mikroprocesorů řady x86</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_A.py</a></td></tr>
<tr><td> 2</td><td>first_steps_16bit_B.py</td><td>překlad 16bitového kódu (zapsaného na více řádcích) mikroprocesorů řady x86</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_16bit_B.py</a></td></tr>
<tr><td> 3</td><td>first_steps_32bit.py</td><td>překlad 32bitového kódu mikroprocesorů řady x86</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_32bit.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_32bit.py</a></td></tr>
<tr><td> 4</td><td>first_steps_64bit.py</td><td>překlad 32bitového kódu mikroprocesorů řady x86-64</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_64bit.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/first_steps_64bit.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>att_syntax_A.py</td><td>kód zapsaný v&nbsp;assembleru, který využívá syntaxi AT&amp;T (nekorektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_A.py</a></td></tr>
<tr><td> 6</td><td>att_syntax_B.py</td><td>kód zapsaný v&nbsp;assembleru, který využívá syntaxi AT&amp;T (korektní varianta)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_B.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>loop_A.py</td><td>kód zapsaný v&nbsp;assembleru, v&nbsp;němž je použita programová smyčka</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_A.py</a></td></tr>
<tr><td> 8</td><td>loop_B.py</td><td>kód zapsaný v&nbsp;assembleru, v&nbsp;němž jsou použity vnořené programové smyčky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loop_B.py</a></td></tr>
<tr><td> 9</td><td>loops_dump.asm</td><td>výsledek získaný skriptem <strong>loop_A.py</strong> a nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loops_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/loops_dump.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>into_binary_A.py</td><td>překlad assembleru do binární formy (smyčky)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_A.py</a></td></tr>
<tr><td>11</td><td>into_binary_B.py</td><td>překlad assembleru do binární formy (&bdquo;Hello world&ldquo;)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_B.py</a></td></tr>
<tr><td>12</td><td>into_binary_C.py</td><td>překlad assembleru do binární formy (&bdquo;Hello world&ldquo;)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_C.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_C.py</a></td></tr>
<tr><td>13</td><td>into_binary_D.py</td><td>překlad assembleru do binární formy (využití AT&amp;T syntaxe)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_D.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/into_binary_D.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>hello_world.asm</td><td>program typu &bdquo;Hello world&ldquo; napsaný v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world.asm</a></td></tr>
<tr><td>15</td><td>hello_world_2.asm</td><td>upravený program typu &bdquo;Hello world&ldquo; napsaný v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world_2.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_world_2.asm</a></td></tr>
<tr><td>16</td><td>hello_dump.asm</td><td>zpětný překlad nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_dump.asm</a></td></tr>
<tr><td>17</td><td>hello_2_dump.asm</td><td>zpětný překlad nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_2_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/hello_2_dump.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>subroutines.py</td><td>překlad programu v&nbsp;assembleru, jenž používá podprogramy (subrutiny)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines.py</a></td></tr>
<tr><td>19</td><td>subroutines.asm</td><td>program zapsaný v&nbsp;assembleru, jenž používá podprogramy (subrutiny)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines.asm</a></td></tr>
<tr><td>20</td><td>subroutines_dump.asm</td><td>zpětný překlad nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/subroutines_dump.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>disasm.py</td><td>zpětný disassembling binárního kódu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/disasm.py">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/disasm.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>att_syntax.asm</td><td>kód v&nbsp;assembleru se syntaxí AT&amp;T</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax.asm</a></td></tr>
<tr><td>23</td><td>att_syntax_dump.asm</td><td>zpětný překlad nástrojem <strong>objdump</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_dump.asm">https://github.com/tisnik/most-popular-python-libs/blob/master/keystone/att_syntax_dump.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Keystone Engine na GitHubu<br />
<a href="https://github.com/keystone-engine/keystone">https://github.com/keystone-engine/keystone</a>
</li>

<li>Keystone: The Ultimate Assembler<br />
<a href="https://www.keystone-engine.org/">https://www.keystone-engine.org/</a>
</li>

<li>The Ultimate Disassembler<br />
<a href="http://www.capstone-engine.org/">http://www.capstone-engine.org/</a>
</li>

<li>Tutorial for Keystone<br />
<a href="https://www.keystone-engine.org/docs/tutorial.html">https://www.keystone-engine.org/docs/tutorial.html</a>
</li>

<li>Rozhraní pro Capstone na PyPi<br />
<a href="https://pypi.org/project/capstone/">https://pypi.org/project/capstone/</a>
</li>

<li>Rozhraní pro Keystone na PyPi<br />
<a href="https://pypi.org/project/keystone-engine/">https://pypi.org/project/keystone-engine/</a>
</li>

<li>KEYSTONE: Next Generation Assembler Framework<br />
<a href="https://www.keystone-engine.org/docs/BHUSA2016-keystone.pdf">https://www.keystone-engine.org/docs/BHUSA2016-keystone.pdf</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="http://web.mit.edu/rhel-doc/3/rhel-as-en-3/i386-syntax.html">http://web.mit.edu/rhel-doc/3/rhel-as-en-3/i386-syntax.html</a>
</li>

<li>AT&amp;T assembly syntax and IA-32 instructions<br />
<a href="https://gist.github.com/mishurov/6bcf04df329973c15044">https://gist.github.com/mishurov/6bcf04df329973c15044</a>
</li>

<li>ARM GCC Inline Assembler Cookbook<br />
<a href="http://www.ethernut.de/en/documents/arm-inline-asm.html">http://www.ethernut.de/en/documents/arm-inline-asm.html</a>
</li>

<li>Extended Asm - Assembler Instructions with C Expression Operands<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</a>
</li>

<li>ARM inline asm secrets<br />
<a href="http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/">http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/</a>
</li>

<li>How to Use Inline Assembly Language in C Code<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a>
</li>

<li>GCC-Inline-Assembly-HOWTO<br />
<a href="http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a>
</li>

<li>A Brief Tutorial on GCC inline asm (x86 biased)<br />
<a href="http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm">http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm</a>
</li>

<li>GCC Inline ASM<br />
<a href="http://locklessinc.com/articles/gcc_asm/">http://locklessinc.com/articles/gcc_asm/</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v&nbsp;assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>Online x86 / x64 Assembler and Disassembler<br />
<a href="https://defuse.ca/online-x86-assembler.htm#disassembly">https://defuse.ca/online-x86-assembler.htm#disassembly</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

