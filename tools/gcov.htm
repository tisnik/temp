<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Analýza zdrojového kódu nástrojem <strong>gcov</strong></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Analýza zdrojového kódu nástrojem <strong>gcov</strong></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V tomto článku se seznámíme s velmi užitečným nástrojem nazvaným gcov. Jedná se o jeden z nástrojů z ekosystému GCC, jenž slouží pro zjištění, které řádky v programovém kódu jsou skutečně volány (například z testů) a které nikoli.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Analýza zdrojového kódu nástrojem <strong>gcov</strong></a></p>
<p><a href="#k02">2. První seznámení s&nbsp;nástrojem <strong>gcov</strong></a></p>
<p><a href="#k03">3. Zavolání nástroje <strong>gcov</strong> z&nbsp;příkazové řádky</a></p>
<p><a href="#k04">4. Jednoduchý program napsaný v&nbsp;C, který budeme zkoumat nástrojem <strong>gcov</strong></a></p>
<p><a href="#k05">5. Zjištění živého a mrtvého kódu nástrojem <strong>gcov</strong></a></p>
<p><a href="#k06">6. Vygenerování čitelného protokolu s&nbsp;informací o živém a mrtvém kódu</a></p>
<p><a href="#k07">7. Úprava testovacího příkladu: vložení uzlu do binárního stromu</a></p>
<p><a href="#k08">8. Opětovné vygenerování protokolu</a></p>
<p><a href="#k09">9. Úprava testovacího příkladu tak, aby se v&nbsp;runtime zavolaly všechny programové řádky</a></p>
<p><a href="#k10">10. Vygenerování výsledného protokolu</a></p>
<p><a href="#k11">11. Analýza, kolikrát jsou jednotlivé řádky programového kódu volány</a></p>
<p><a href="#k12">12. Vizualizace frekvence volání jednotlivých programových řádků</a></p>
<p><a href="#k13">13. Jak se vlastně interně zjišťuje, které řádky byly zavolány?</a></p>
<p><a href="#k14">14. Překlad několika funkcí z&nbsp;C do assembleru</a></p>
<p><a href="#k15">15. Překlad s&nbsp;použitím přepínačů <strong>-fprofile-arcs</strong> a <strong>-ftest-coverage</strong></a></p>
<p><a href="#k16">16. Podrobnější porovnání obou vygenerovaných strojových kódů</a></p>
<p><a href="#k17">17. Nástroj <i>gcov</i> a <i>Clang</i></a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články s&nbsp;tématem testování</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Analýza zdrojového kódu nástrojem <strong>gcov</strong></h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;velmi užitečným a poměrně často
používaným nástrojem nazvaným <i>gcov</i>. Tento nástroj je součástí <a
href="https://gcc.gnu.org/onlinedocs/gcc/index.html#Top">ekosystému GCC</a> a
slouží pro zjištění, které řádky v&nbsp;programovém kódu jsou skutečně volány a
které naopak nikoli. Navíc je u volaných řádků možné zjistit, kolikrát byly
volány. K&nbsp;čemu se však tato informace používá? V&nbsp;první řadě nám
umožňuje detekovat mrtvé části kódu, které se v&nbsp;praxi nikdy nevolají,
takže je možné se zamyslet nad tím, jestli tyto části zcela neodstranit. A ve
druhé řadě lze snadno zjistit, které části kódu jsou pokryty jednotkovými testy
(<i>unit tests</i>), což je problematika, které jsme se věnovali
v&nbsp;článcích uvedených <a href="#k19">v&nbsp;devatenácté kapitole</a>.</p>

<p>V&nbsp;předchozím odstavci jsme si řekli, že nástroj <i>gcov</i> je součástí
ekosystému GCC, což znamená, že je ho možné použít společně s&nbsp;překladači,
jenž jsou do GCC zahrnuty. Kromě klasického překladače jazyka C se jedná o C++,
ale například i o Objective-C, Objective-C++, Fortran, Adu, jazyk D a taktéž
jazyk Go.</p>

<p><div class="rs-tip-major">Poznámka: jak uvidíme dále, konkrétně <a
href="#k17">v&nbsp;sedmnácté kapitole</a>, lze <i>gcov</i> do určité míry
využít i mimo ekosystém GCC, konkrétně společně s&nbsp;<i>Clangem</i>, jenž
<i>gcov</i> taktéž podporuje.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. První seznámení s&nbsp;nástrojem <strong>gcov</strong></h2>

<p>Ve skutečnosti samotný <i>gcov</i> nedokáže zjistit, které části kódu jsou
skutečně volány. V&nbsp;případě <i>gcov</i> se jedná &bdquo;pouze&ldquo; o
nástroj analyzující data získaná ze dvou zdrojů a produkující analýzu
v&nbsp;čitelném (textovém) formátu. Mezi oba zmíněné zdroje patří:</p>

<ol>

<li>První množina dat je vygenerována samotným překladačem. Jedná se o soubor
(soubory) obsahující &ndash; stručně řečeno &ndash; mapování mezi řádky ve
zdrojovém kódu a adresami v&nbsp;paměťové oblasti alokované pro běžící program.
Tyto soubory jsou binární a jsou přímo určeny pro zpracování nástrojem
<i>gcov</i> (tedy neměly by se používat jiným nástrojem, protože jejich
struktura se může měnit). Jejich koncovka je typicky <strong>.gcno</strong>,
kde &bdquo;no&ldquo; znamená &bdquo;notes&ldquo;.</li>

<li>Druhá množina dat je vygenerována v&nbsp;čase běhu testovaného programu.
Jedná se o soubor (soubory) s&nbsp;čítači přístupů k&nbsp;jednotlivým řádkům. I
tyto soubory jsou binární a mají koncovku <strong>.gcda</strong>, kde
&bdquo;da&ldquo; znamená &bdquo;data&ldquo;.</li>

</ol>

<p>Teprve na základě obsahu těchto dvou množin dat dokáže <i>gcov</i> vytvořit
čitelný výstup obsahující informace o tom, které řádky kódu byly volány a které
nikoli. Výsledek provedené analýzy je přitom možné získat v&nbsp;čistě textové
podobě, v&nbsp;podobě obarveného výstupu určeného pro terminál, nebo je možné
si nechat výsledek analýzy uložit v&nbsp;podobě vhodné pro další strojové
zpracování (například v&nbsp;integrovaném vývojovém prostředí atd.).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zavolání nástroje <strong>gcov</strong> z&nbsp;příkazové řádky</h2>

<p>Nástroj <i>gcov</i> se volá z&nbsp;příkazové řádky příkazem
<strong>gcov</strong> a je mu možné předat poměrně velké množství přepínačů,
z&nbsp;nichž některé jsou určeny pro konkrétní programovací jazyk (již tradičně
je problematický C++ s&nbsp;jeho komolením jmen funkcí a metod &ndash; <i>name
mangling</i>).</p>

<p>Všechny přepínače je možné si nechat vypsat:</p>

<pre>
$ <strong>gcov</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
Usage: gcov [OPTION...] SOURCE|OBJ...
&nbsp;
Print code coverage information.
&nbsp;
  -a, --all-blocks                Show information for every basic block
  -b, --branch-probabilities      Include branch probabilities in output
  -c, --branch-counts             Output counts of branches taken
                                    rather than percentages
  -d, --display-progress          Display progress information
  -f, --function-summaries        Output summaries for each function
  -h, --help                      Print this help, then exit
  -i, --json-format               Output JSON intermediate format into .gcov.json.gz file
  -j, --human-readable            Output human readable numbers
  -k, --use-colors                Emit colored output
  -l, --long-file-names           Use long output file names for included
                                    source files
  -m, --demangled-names           Output demangled function names
  -n, --no-output                 Do not create an output file
  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE
  -p, --preserve-paths            Preserve all pathname components
  -q, --use-hotness-colors        Emit perf-like colored output for hot lines
  -r, --relative-only             Only show data for relative sources
  -s, --source-prefix DIR         Source prefix to elide
  -t, --stdout                    Output to stdout instead of a file
  -u, --unconditional-branches    Show unconditional branch counts too
  -v, --version                   Print version number, then exit
  -w, --verbose                   Print verbose informations
  -x, --hash-filenames            Hash long pathnames
&nbsp;
For bug reporting instructions, please see:
&lt;file:///usr/share/doc/gcc-9/README.Bugs&gt;.
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jednoduchý program napsaný v&nbsp;C, který budeme zkoumat nástrojem <strong>gcov</strong></h2>

<p>Základní vlastnosti nástroje <i>gcov</i> si postupně otestujeme na několika
demonstračních příkladech. První příklad, který si dnes ukážeme, je psaný
v&nbsp;programovacím jazyku C. Najdeme v&nbsp;něm triviální implementaci
konstrukce binárního stromu určeného pro uložení řetězců společně s&nbsp;funkcí
pro průchod (traverzaci) tímto stromem. Ovšem průchod stromem je (alespoň
prozatím) realizován nad prázdným stromem, takže již dopředu můžeme odhadnout,
že zdaleka ne všechny řádky programového kódu budou v&nbsp;čase běhu programu
(tedy v&nbsp;runtime) využity (zavolány):</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
&nbsp;
typedef struct <strong>Node</strong>
{
    struct Node *left;
    struct Node *right;
    char *value;
} Node;
&nbsp;
void <strong>insert_new_node</strong>(Node **root, char *value)
{
    int cmp;
&nbsp;
    if (*root == NULL)
    {
        *root = (Node *)malloc(sizeof(Node));
        (*root)-&gt;value = (char*)calloc(strlen(value), sizeof(char));
        strcpy((*root)-&gt;value, value);
        (*root)-&gt;left = NULL;
        (*root)-&gt;right = NULL;
        return;
    }
    cmp = strcmp(value, (*root)-&gt;value);
    if (cmp &lt; 0)
    {
        insert_new_node(&amp;(*root)-&gt;left, value);
    }
    else
    {
        insert_new_node(&amp;(*root)-&gt;right, value);
    }
}
&nbsp;
void <strong>traverse_tree</strong>(Node *root, void (*callback_function)(char *))
{
    if (root == NULL)
    {
        return;
    }
    traverse_tree(root-&gt;left, callback_function);
    callback_function(root-&gt;value);
    traverse_tree(root-&gt;right, callback_function);
}
&nbsp;
void <strong>callback_function</strong>(char *value)
{
    printf("%s\n", value);
}
&nbsp;
int <strong>main</strong>(void)
{
    static Node *root = NULL;
&nbsp;
    traverse_tree(root, callback_function);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód tohoto příkladu
naleznete na adrese <a
href="https://github.com/tisnik/slides/blob/master/sources/tree1.c">https://github.com/tisnik/slides/blob/master/sources/tree1.c</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zjištění živého a mrtvého kódu nástrojem <strong>gcov</strong></h2>

<p>Pro zjištění, které části kódu jsou živé (volané) a které nikoli, je
zapotřebí provést překlad zdrojového kódu s&nbsp;využitím přepínačů
<strong>-fprofile-arcs</strong> a <strong>-ftest-coverage tree1.c</strong>
(navíc je více než vhodné nepoužívat optimalizace):</p>

<pre>
$ <strong>gcc -fprofile-arcs -ftest-coverage tree1.c</strong>
</pre>

<p>Výsledkem překladu bude (podle očekávání) soubor <strong>a.out</strong> a
navíc i soubor <strong>tree1.gcno</strong> obsahující &ndash; jak jsme si již
ve stručnosti řekli &ndash; mapování mezi řádky ve zdrojovém kódu a adresami
v&nbsp;paměťové oblasti alokované pro běžící program</p>

<pre>
$ <strong>ls -l</strong>
&nbsp;
total 108
<strong>-rwxrwxr-x 1 ptisnovs ptisnovs 28544 Apr 15 12:28 a.out</strong>
-rw-r--r-- 1 ptisnovs ptisnovs  1111 Apr 13 18:50 tree1.c
<strong>-rw-rw-r-- 1 ptisnovs ptisnovs  1488 Apr 15 12:28 tree1.gcno</strong>
</pre>

<p>Nyní spustíme testovaný program naprosto stejným způsobem, jako bychom ho
spouštěli bez zjišťování volaných řádků:</p>

<pre>
$ <strong>./a.out</strong>
</pre>

<p>Po ukončení běhu programu by měl být vytvořen nový soubor
<strong>tree1.gcda</strong> s&nbsp;čítači přístupů k&nbsp;jednotlivým
řádkům:</p>

<pre>
$ <strong>ls -l</strong>
&nbsp;
total 120
-rwxrwxr-x 1 ptisnovs ptisnovs 28544 Apr 15 12:28 a.out
-rw-r--r-- 1 ptisnovs ptisnovs  1111 Apr 13 18:50 tree1.c
<strong>-rw-rw-r-- 1 ptisnovs ptisnovs   256 Apr 15 12:29 tree1.gcda</strong>
-rw-rw-r-- 1 ptisnovs ptisnovs  1488 Apr 15 12:28 tree1.gcno
</pre>

<p>Oba dva výše zmíněné soubory, tedy <strong>tree1.gcno</strong> a
<strong>tree1.gcda</strong> je nyní nutné sloučit nástrojem <i>gcov</i>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vygenerování čitelného protokolu s&nbsp;informací o živém a mrtvém kódu</h2>

<p>Nyní nastal čas na vygenerování čitelného protokolu, z&nbsp;něhož zjistíme,
které řádky ve vstupním zdrojovém textu jsou skutečně volány a které naopak
nikoli. Tento protokol si necháme vygenerovat příkazem:</p>

<pre>
$ <strong>gcov tree1.c</strong>
</pre>

<p>Nástroj <i>gcov</i> v&nbsp;průběhu své činnosti zobrazí, které vstupní
soubory se zdrojovými texty jsou zpracovávány a mj.&nbsp;taktéž ukáže velmi
důležitou informaci &ndash; jaké procento řádků se zdrojovým kódem obsahuje
živý kód. V&nbsp;našem konkrétním případě se reálně využila jen čtvrtina
zapsaného kódu, což je z&nbsp;výsledku patrné:</p>

<pre>
File 'tree1.c'
Lines executed:25.00% of 24
Creating 'tree1.c.gcov'
</pre>

<p>Navíc je možné zjistit podrobnější informace o jednotlivých funkcích
(metodách):</p>

<pre>
$ <strong>gcov -f tree1.c</strong>
&nbsp;
Function 'main'
Lines executed:100.00% of 3
&nbsp;
Function 'callback_function'
Lines executed:0.00% of 3
&nbsp;
Function 'traverse_tree'
Lines executed:50.00% of 6
&nbsp;
Function 'insert_new_node'
Lines executed:0.00% of 12
&nbsp;
File 'tree1.c'
Lines executed:25.00% of 24
Creating 'tree1.c.gcov'
</pre>

<p>Předchozí příkaz současně vytvořil nový soubor pojmenovaný
&bdquo;tree1.c.gcov&ldquo;:</p>

<pre>
$ <strong>ls -l</strong>
total 132
-rwxrwxr-x 1 ptisnovs ptisnovs 28544 Apr 15 12:28 a.out
-rw-r--r-- 1 ptisnovs ptisnovs  1111 Apr 13 18:50 tree1.c
<strong>-rw-rw-r-- 1 ptisnovs ptisnovs  2190 Apr 15 12:30 tree1.c.gcov</strong>
-rw-rw-r-- 1 ptisnovs ptisnovs   256 Apr 15 12:29 tree1.gcda
-rw-rw-r-- 1 ptisnovs ptisnovs  1488 Apr 15 12:28 tree1.gcno
</pre>

<p>Protokol obsahuje původní zdrojový kód doplněný o další informace.
V&nbsp;levém sloupci je zobrazen počet volání příslušného řádku popř.&nbsp;řada
znaků &bdquo;#####&ldquo; na těch řádcích kódu, které obsahují příkazy, ale
nejsou volány. Naopak ty řádky kódu, které příkazy neobsahují, začínají znakem
&bdquo;-&ldquo;. Za dvojtečkou je uvedeno číslo řádku popř.&nbsp;hodnota 0 pro
ty řádky protokolu, které obsahují nějaké metainformace. A konečně ve třetím
sloupci za další dvojtečkou je kopie zdrojového kódu
popř.&nbsp;metainformace:</p>

<pre>
        -:    0:Source:tree1.c
        -:    0:Graph:tree1.gcno
        -:    0:Data:tree1.gcda
        -:    0:Runs:1
        -:    1:#include &lt;stdlib.h&gt;
        -:    2:#include &lt;stdio.h&gt;
        -:    3:#include &lt;string.h&gt;
        -:    4:
        -:    5:typedef struct Node
        -:    6:{
        -:    7:    struct Node *left;
        -:    8:    struct Node *right;
        -:    9:    char *value;
        -:   10:} Node;
        -:   11:
    #####:   12:void insert_new_node(Node **root, char *value)
        -:   13:{
        -:   14:    int cmp;
        -:   15:
    #####:   16:    if (*root == NULL)
        -:   17:    {
    #####:   18:        *root = (Node *)malloc(sizeof(Node));
    #####:   19:        (*root)-&gt;value = (char*)calloc(strlen(value), sizeof(char));
    #####:   20:        strcpy((*root)-&gt;value, value);
    #####:   21:        (*root)-&gt;left = NULL;
    #####:   22:        (*root)-&gt;right = NULL;
    #####:   23:        return;
        -:   24:    }
    #####:   25:    cmp = strcmp(value, (*root)-&gt;value);
    #####:   26:    if (cmp &lt; 0)
        -:   27:    {
    #####:   28:        insert_new_node(&amp;(*root)-&gt;left, value);
        -:   29:    }
        -:   30:    else
        -:   31:    {
    #####:   32:        insert_new_node(&amp;(*root)-&gt;right, value);
        -:   33:    }
        -:   34:}
        -:   35:
        1:   36:void traverse_tree(Node *root, void (*callback_function)(char *))
        -:   37:{
        1:   38:    if (root == NULL)
        -:   39:    {
        1:   40:        return;
        -:   41:    }
    #####:   42:    traverse_tree(root-&gt;left, callback_function);
    #####:   43:    callback_function(root-&gt;value);
    #####:   44:    traverse_tree(root-&gt;right, callback_function);
        -:   45:}
        -:   46:
    #####:   47:void callback_function(char *value)
        -:   48:{
    #####:   49:    printf("%s\n", value);
    #####:   50:}
        -:   51:
        1:   52:int main(void)
        -:   53:{
        -:   54:    static Node *root = NULL;
        -:   55:
        1:   56:    traverse_tree(root, callback_function);
        -:   57:
        1:   58:    return 0;
        -:   59:}
        -:   60:
</pre>

<p>Alternativně je možné nechat si vygenerovat výstupní soubor, který bude
obsahovat původní zdrojový text, ovšem obarvený podle toho, které řádky
(příkazy) byly zavolány a které nikoli. V&nbsp;takovém souboru nalezneme řídicí
kódy dle ANSI, které by mělo být možné interpretovat na prakticky jakémkoli
emulátoru terminálu:</p>

<pre>
$ <strong>gcov -k tree1.c</strong>
</pre>

<p>Výsledný soubor <strong>tree1.c.gcov</strong> si můžeme zobrazit na
terminálu například standardním nástrojem <strong>cat</strong>:</p>

<pre>
$ <strong>cat tree1.c.gcov</strong>
</pre>

<p>S&nbsp;následujícím výsledkem:</p>

*** image ***
<p><i>Obrázek 1: Obarvený výstup z&nbsp;nástroje <i>gcov</i>.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úprava testovacího příkladu: vložení uzlu do binárního stromu</h2>

<p>Nyní nastal čas na úpravu původního testovacího příkladu takovým způsobem,
aby se využila (resp.&nbsp;přesněji řečeno zavolala) větší část jeho kódu.
Zejména do binárního stromu vložíme uzel, což (nepřímo) ovlivní i funkci pro
procházení (<i>traverzaci</i>) binárním stromem. Upravený příklad vypadá
následovně:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
&nbsp;
typedef struct <strong>Node</strong>
{
    struct Node *left;
    struct Node *right;
    char *value;
} Node;
&nbsp;
void <strong>insert_new_node</strong>(Node **root, char *value)
{
    int cmp;
&nbsp;
    if (*root == NULL)
    {
        *root = (Node *)malloc(sizeof(Node));
        (*root)-&gt;value = (char*)calloc(strlen(value), sizeof(char));
        strcpy((*root)-&gt;value, value);
        (*root)-&gt;left = NULL;
        (*root)-&gt;right = NULL;
        return;
    }
    cmp = strcmp(value, (*root)-&gt;value);
    if (cmp &lt; 0)
    {
        insert_new_node(&amp;(*root)-&gt;left, value);
    }
    else
    {
        insert_new_node(&amp;(*root)-&gt;right, value);
    }
}
&nbsp;
void <strong>traverse_tree</strong>(Node *root, void (*callback_function)(char *))
{
    if (root == NULL)
    {
        return;
    }
    traverse_tree(root-&gt;left, callback_function);
    callback_function(root-&gt;value);
    traverse_tree(root-&gt;right, callback_function);
}
&nbsp;
void <strong>callback_function</strong>(char *value)
{
    printf("%s\n", value);
}
&nbsp;
int <strong>main</strong>(void)
{
    static Node *root = NULL;
&nbsp;
    insert_new_node(&amp;root, "xxx");
&nbsp;
    traverse_tree(root, callback_function);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že jediný nový řádek
vložený do funkce <strong>main</strong> může zásadním způsobem ovlivnit
&bdquo;živost&ldquo; velké části programového kódu.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Opětovné vygenerování protokolu</h2>

<p>Opět si můžeme nechat vygenerovat protokol s&nbsp;analýzou zdrojového
kódu:</p>

<pre>
$ <strong>gcov tree2.c</strong>
</pre>

<p>Průběh analýzy:</p>
<pre>
File 'tree2.c'
Lines executed:84.00% of 25
Creating 'tree2.c.gcov'
</pre>

<p>Hodnota s&nbsp;poměrnou &bdquo;živostí&ldquo; kódu je nyní vyšší, takže se
podívejme na podrobnější informace rozdělené po jednotlivých funkcích:</p>

<pre>
$ <strong>gcov -f tree2.c</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
Function 'main'
Lines executed:100.00% of 4
&nbsp;
Function 'callback_function'
Lines executed:100.00% of 3
&nbsp;
Function 'traverse_tree'
Lines executed:100.00% of 6
&nbsp;
Function 'insert_new_node'
Lines executed:66.67% of 12
&nbsp;
File 'tree2.c'
Lines executed:84.00% of 25
Creating 'tree2.c.gcov'
</pre>

<p>Vlastní protokol se změnil, protože ubyly programové řádky označené symbolem
&bdquo;#####&ldquo; a naopak je patrné, že některé řádky (resp.&nbsp;přesněji
řečeno příkazy na těchto řádcích) jsou zavolány vícekrát, což se týká například
rekurzivně volané funkce <strong>traverse_tree</strong>, jenž je přímo zavolána
jednou a dvakrát zavolána v&nbsp;rekurzi:</p>

<pre>
        -:    0:Source:tree2.c
        -:    0:Graph:tree2.gcno
        -:    0:Data:tree2.gcda
        -:    0:Runs:1
        -:    1:#include &lt;stdlib.h&gt;
        -:    2:#include &lt;stdio.h&gt;
        -:    3:#include &lt;string.h&gt;
        -:    4:
        -:    5:typedef struct Node
        -:    6:{
        -:    7:    struct Node *left;
        -:    8:    struct Node *right;
        -:    9:    char *value;
        -:   10:} Node;
        -:   11:
        1:   12:void insert_new_node(Node **root, char *value)
        -:   13:{
        -:   14:    int cmp;
        -:   15:
        1:   16:    if (*root == NULL)
        -:   17:    {
        1:   18:        *root = (Node *)malloc(sizeof(Node));
        1:   19:        (*root)-&gt;value = (char*)calloc(strlen(value), sizeof(char));
        1:   20:        strcpy((*root)-&gt;value, value);
        1:   21:        (*root)-&gt;left = NULL;
        1:   22:        (*root)-&gt;right = NULL;
        1:   23:        return;
        -:   24:    }
    #####:   25:    cmp = strcmp(value, (*root)-&gt;value);
    #####:   26:    if (cmp &lt; 0)
        -:   27:    {
    #####:   28:        insert_new_node(&amp;(*root)-&gt;left, value);
        -:   29:    }
        -:   30:    else
        -:   31:    {
    #####:   32:        insert_new_node(&amp;(*root)-&gt;right, value);
        -:   33:    }
        -:   34:}
        -:   35:
        3:   36:void traverse_tree(Node *root, void (*callback_function)(char *))
        -:   37:{
        3:   38:    if (root == NULL)
        -:   39:    {
        2:   40:        return;
        -:   41:    }
        1:   42:    traverse_tree(root-&gt;left, callback_function);
        1:   43:    callback_function(root-&gt;value);
        1:   44:    traverse_tree(root-&gt;right, callback_function);
        -:   45:}
        -:   46:
        1:   47:void callback_function(char *value)
        -:   48:{
        1:   49:    printf("%s\n", value);
        1:   50:}
        -:   51:
        1:   52:int main(void)
        -:   53:{
        -:   54:    static Node *root = NULL;
        -:   55:
        1:   56:    insert_new_node(&amp;root, "xxx");
        -:   57:
        1:   58:    traverse_tree(root, callback_function);
        -:   59:
        1:   60:    return 0;
        -:   61:}
        -:   62:
</pre>

*** image ***
<p><i>Obrázek 2: Obarvený výstup z&nbsp;nástroje <i>gcov</i>.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úprava testovacího příkladu tak, aby se v&nbsp;runtime zavolaly všechny programové řádky</h2>

<p>Další, již poslední úprava testovacího příkladu s&nbsp;implementací naivního
binárního stromu spočívá v&nbsp;tom, že do stromu vložíme větší množství uzlů a
to navíc v&nbsp;takovém pořadí, aby byly nové poduzly vytvořeny jak napravo od
nadřazeného uzlu, tak i nalevo od něj. To vede ke konstrukci binárního stromu,
při jehož průchodu se využijí všechny implementované možnosti:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
&nbsp;
typedef struct <strong>Node</strong>
{
    struct Node *left;
    struct Node *right;
    char *value;
} Node;
&nbsp;
void <strong>insert_new_node</strong>(Node **root, char *value)
{
    int cmp;
&nbsp;
    if (*root == NULL)
    {
        *root = (Node *)malloc(sizeof(Node));
        (*root)-&gt;value = (char*)calloc(strlen(value), sizeof(char));
        strcpy((*root)-&gt;value, value);
        (*root)-&gt;left = NULL;
        (*root)-&gt;right = NULL;
        return;
    }
    cmp = strcmp(value, (*root)-&gt;value);
    if (cmp &lt; 0)
    {
        insert_new_node(&amp;(*root)-&gt;left, value);
    }
    else
    {
        insert_new_node(&amp;(*root)-&gt;right, value);
    }
}
&nbsp;
void <strong>traverse_tree</strong>(Node *root, void (*callback_function)(char *))
{
    if (root == NULL)
    {
        return;
    }
    traverse_tree(root-&gt;left, callback_function);
    callback_function(root-&gt;value);
    traverse_tree(root-&gt;right, callback_function);
}
&nbsp;
void <strong>callback_function</strong>(char *value)
{
    printf("%s\n", value);
}
&nbsp;
int <strong>main</strong>(void)
{
    static Node *root = NULL;
&nbsp;
    insert_new_node(&amp;root, "xxx");
    insert_new_node(&amp;root, "aaa");
    insert_new_node(&amp;root, "bbb");
    insert_new_node(&amp;root, "ccc");
    insert_new_node(&amp;root, "yyy");
    insert_new_node(&amp;root, "yyy");
&nbsp;
    traverse_tree(root, callback_function);
&nbsp;
    return 0;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vygenerování výsledného protokolu</h2>

<p>Vygenerování výsledného protokolu provedeme nám již známým postupem, a to
buď bez zobrazení využití jednotlivých funkcí, nebo s&nbsp;podrobnějším
výpisem:</p>

<pre>
$ <strong>gcov tree3.c</strong>
</pre>

<p>Průběh analýzy:</p>

<pre>
File 'tree3.c'
Lines executed:100.00% of 30
Creating 'tree3.c.gcov'
</pre>

<p>Analýza naznačila, že jsou pokryty všechny řádky, což si ještě ověříme tak,
že zjistíme pokrytí jednotlivých funkcí:</p>

<pre>
$ <strong>gcov -f tree3.c</strong>
&nbsp;
Function 'main'
Lines executed:100.00% of 9
&nbsp;
Function 'callback_function'
Lines executed:100.00% of 3
&nbsp;
Function 'traverse_tree'
Lines executed:100.00% of 6
&nbsp;
Function 'insert_new_node'
Lines executed:100.00% of 12
&nbsp;
File 'tree3.c'
Lines executed:100.00% of 30
Creating 'tree3.c.gcov'
</pre>

<p>A takto bude vypadat výsledek analýzy:</p>

<pre>
        -:    0:Source:tree3.c
        -:    0:Graph:tree3.gcno
        -:    0:Data:tree3.gcda
        -:    0:Runs:1
        -:    1:#include &lt;stdlib.h&gt;
        -:    2:#include &lt;stdio.h&gt;
        -:    3:#include &lt;string.h&gt;
        -:    4:
        -:    5:typedef struct Node
        -:    6:{
        -:    7:    struct Node *left;
        -:    8:    struct Node *right;
        -:    9:    char *value;
        -:   10:} Node;
        -:   11:
       15:   12:void insert_new_node(Node **root, char *value)
        -:   13:{
        -:   14:    int cmp;
        -:   15:
       15:   16:    if (*root == NULL)
        -:   17:    {
        6:   18:        *root = (Node *)malloc(sizeof(Node));
        6:   19:        (*root)-&gt;value = (char*)calloc(strlen(value), sizeof(char));
        6:   20:        strcpy((*root)-&gt;value, value);
        6:   21:        (*root)-&gt;left = NULL;
        6:   22:        (*root)-&gt;right = NULL;
        6:   23:        return;
        -:   24:    }
        9:   25:    cmp = strcmp(value, (*root)-&gt;value);
        9:   26:    if (cmp &lt; 0)
        -:   27:    {
        3:   28:        insert_new_node(&amp;(*root)-&gt;left, value);
        -:   29:    }
        -:   30:    else
        -:   31:    {
        6:   32:        insert_new_node(&amp;(*root)-&gt;right, value);
        -:   33:    }
        -:   34:}
        -:   35:
       13:   36:void traverse_tree(Node *root, void (*callback_function)(char *))
        -:   37:{
       13:   38:    if (root == NULL)
        -:   39:    {
        7:   40:        return;
        -:   41:    }
        6:   42:    traverse_tree(root-&gt;left, callback_function);
        6:   43:    callback_function(root-&gt;value);
        6:   44:    traverse_tree(root-&gt;right, callback_function);
        -:   45:}
        -:   46:
        6:   47:void callback_function(char *value)
        -:   48:{
        6:   49:    printf("%s\n", value);
        6:   50:}
        -:   51:
        1:   52:int main(void)
        -:   53:{
        -:   54:    static Node *root = NULL;
        -:   55:
        1:   56:    insert_new_node(&amp;root, "xxx");
        1:   57:    insert_new_node(&amp;root, "aaa");
        1:   58:    insert_new_node(&amp;root, "bbb");
        1:   59:    insert_new_node(&amp;root, "ccc");
        1:   60:    insert_new_node(&amp;root, "yyy");
        1:   61:    insert_new_node(&amp;root, "yyy");
        -:   62:
        1:   63:    traverse_tree(root, callback_function);
        -:   64:
        1:   65:    return 0;
        -:   66:}
        -:   67:
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Analýza, kolikrát jsou jednotlivé řádky programového kódu volány</h2>

<p>Mnohdy je zapotřebí zjistit nejenom to, které části kódu byly volány a které
nikoli, ale i informaci o tom, kolikrát byla funkce, blok či jednotlivý
programový řádek volán. To je sice primárně úloha jiných nástrojů (například
nástroje <strong>gprof</strong>, pokud zůstaneme v&nbsp;ekosystému GCC), ale
základní a především velmi přehledně podané informace nám dá i nástroj
<strong>gcov</strong> (jenž ovšem nezjistí časy vykonání ani kumulativní
časy!). Vše si otestujeme na tomto jednoduchém a naivním rekurzivním výpočtu
faktoriálu:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
long <strong>factorial</strong>(long n)
{
    if (n&lt;=1) {
        return 1;
    }
    return n*factorial(n-1);
}
&nbsp;
int <strong>main</strong>(int argc, char **argv)
{
    printf("%ld\n", factorial(20));
    return 0;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vizualizace frekvence volání jednotlivých programových řádků</h2>

<p>Po spuštění výpočtu faktoriálu si opět můžeme nechat vygenerovat protokol
s&nbsp;informacemi o řádcích kódu, které byly volány a které nikoli. U volaných
řádků se podle očekávání vypíše i celkový počet volání:</p>

<pre>
$ <strong>gcov factorial.c</strong>
&nbsp;
File 'factorial.c'
Lines executed:100.00% of 7
Creating 'factorial.c.gcov'
</pre>

<p>Výsledek bude vypadat následovně:</p>

<pre>
        -:    0:Source:factorial.c
        -:    0:Graph:factorial.gcno
        -:    0:Data:factorial.gcda
        -:    0:Runs:1
        -:    1:#include &lt;stdio.h&gt;
        -:    2:
       20:    3:long factorial(long n)
        -:    4:{
       20:    5:    if (n&lt;=1) {
        1:    6:        return 1;
        -:    7:    }
       19:    8:    return n*factorial(n-1);
        -:    9:}
        -:   10:
        1:   11:int main(int argc, char **argv)
        -:   12:{
        1:   13:    printf("%ld\n", factorial(20));
        1:   14:    return 0;
        -:   15:}
        -:   16:
</pre>

<p>Kromě tohoto výstupu však můžeme použít i přepínač <strong>-q</strong>, jenž
zajistí určitou formu vizualizace &ndash; volané řádky jsou obarveny jednou ze
tří barev; viz zobrazená legenda v&nbsp;pravém horním rohu:</p>

<pre>
$ <strong>gcov -q factorial.c</strong>
&nbsp;
File 'factorial.c'
Lines executed:100.00% of 7
Creating 'factorial.c.gcov'
</pre>

<p>Tento výstup je možné v&nbsp;případě potřeby kombinovat
s&nbsp;&bdquo;barvovým&ldquo; výstupem, jenž již známe &ndash;
s&nbsp;přepínačem <strong>-k</strong>:</p>

<pre>
$ <strong>gcov -k -q factorial.c</strong>
&nbsp;
File 'factorial.c'
Lines executed:100.00% of 7
Creating 'factorial.c.gcov'
</pre>

<p>Výsledek může vypadat následovně:</p>

*** image ***
<p><i>Obrázek 4: Vizuální zvýraznění programových řádků podle frekvence jejich
volání (získáno pro jinou vstupní hodnotu pro výpočet faktoriálu). Nyní jsou
červeně označené řádky označují kód, který tvoří více než polovinu všech volání
za celou dobu běhu aplikace (a profiler by nám navíc zobrazil, jak dlouhou dobu
program strávil v&nbsp;těchto blocích).</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Jak se vlastně interně zjišťuje, které řádky byly zavolány?</h2>

<p>Na tomto místě se pravděpodobně čtenář může ptát, jakým způsobem se vlastně
vytváří soubory <strong>.gcda</strong>. Připomeňme si, že se jedná o soubory
obsahující informace o &bdquo;zásazích&ldquo; řádků zdrojového kódu, které jsou
získány v&nbsp;době běhu testovaného programu, tedy v&nbsp;<i>runtime</i>. Co
to ale ve skutečnosti znamená? Překladač musel do výsledného strojového kódu
vložit další instrukce, které nějakým způsobem zajišťují získání informací o
oněch &bdquo;zásazích&ldquo;. V&nbsp;navazujících kapitolách si ukážeme, jak
tyto instrukce reálně vypadají, resp.&nbsp;přesněji řečeno jak se liší původní
strojový kód od strojového kódu, který zajišťuje vygenerování souborů
<strong>.gcda</strong>.</p>

<p><div class="rs-tip-major">Poznámka: opět platí, že se bude provádět překlad
bez zapnutí optimalizací, protože optimalizující překladač dokáže detekovat a
zcela odstranit některé části kódu popř.&nbsp;naopak některé části sloučit, což
ovlivňuje výsledky měření v&nbsp;runtime.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Překlad několika funkcí z&nbsp;C do assembleru</h2>

<p>Nejprve si ukažme zdrojový kód napsaný v&nbsp;jazyku C, který obsahuje
deklaraci několika jednoduchých funkcí. Tyto funkce akceptují různý počet
parametrů a všechny jsou volány z&nbsp;funkce <strong>main</strong>, čímž je
zajištěno, že je překladač neodstraní jako nepoužitý kód:</p>

<pre>
int <strong>zero</strong>(void)
{
    return 0;
}
&nbsp;
int <strong>inc</strong>(int x)
{
    return x+1;
}
&nbsp;
int <strong>add</strong>(int x, int y)
{
    return x+y;
}
&nbsp;
int <strong>foo</strong>(int x)
{
    int r = 0;
    while (x--) {
        r++;
    }
    return r;
}
&nbsp;
int <strong>main</strong>(void)
{
    int a = zero();
    int b = inc(a);
    int c = add(a, b);
    int d = foo(c);
    return c;
}
</pre>

<p>Překlad tohoto programu provedeme s&nbsp;přepínačem <strong>-g</strong>,
kterým je zajištěno vložení ladicích informací do výsledného binárního
spustitelného kódu:</p>

<pre>
<strong>gcc -g test.c</strong>
</pre>

<p>Nyní zjistíme, jakým způsobem byly výše zmíněné funkce přeloženy do
assembleru (a dále do strojového kódu). Pro zpětný překlad přitom využijeme
nástroj <i>objdump</i>, kterému jsme se již <a
href="https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/">na
stránkách Roota věnovali</a>:</p>

<pre>
<strong>objdump -drw -Mintel -S a.out &gt; normal.asm</strong>
</pre>

<pre>
0000000000001129 &lt;zero&gt;:
int <strong>zero</strong>(void)
{
    1129:       f3 0f 1e fa             endbr64 
    112d:       55                      push   rbp
    112e:       48 89 e5                mov    rbp,rsp
    return 0;
    1131:       b8 00 00 00 00          mov    eax,0x0
}
    1136:       5d                      pop    rbp
    1137:       c3                      ret    
&nbsp;
0000000000001138 &lt;inc&gt;:
&nbsp;
int <strong>inc</strong>(int x)
{
    1138:       f3 0f 1e fa             endbr64 
    113c:       55                      push   rbp
    113d:       48 89 e5                mov    rbp,rsp
    1140:       89 7d fc                mov    DWORD PTR [rbp-0x4],edi
    return x+1;
    1143:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
    1146:       83 c0 01                add    eax,0x1
}
    1149:       5d                      pop    rbp
    114a:       c3                      ret    
&nbsp;
000000000000114b &lt;add&gt;:
&nbsp;
int <strong>add</strong>(int x, int y)
{
    114b:       f3 0f 1e fa             endbr64 
    114f:       55                      push   rbp
    1150:       48 89 e5                mov    rbp,rsp
    1153:       89 7d fc                mov    DWORD PTR [rbp-0x4],edi
    1156:       89 75 f8                mov    DWORD PTR [rbp-0x8],esi
    return x+y;
    1159:       8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
    115c:       8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
    115f:       01 d0                   add    eax,edx
}
    1161:       5d                      pop    rbp
    1162:       c3                      ret    
&nbsp;
0000000000001163 &lt;foo&gt;:
&nbsp;
int <strong>foo</strong>(int x)
{
    1163:       f3 0f 1e fa             endbr64 
    1167:       55                      push   rbp
    1168:       48 89 e5                mov    rbp,rsp
    116b:       89 7d ec                mov    DWORD PTR [rbp-0x14],edi
    int r = 0;
    116e:       c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
    while (x--) {
    1175:       eb 04                   jmp    117b &lt;foo+0x18&gt;
        r++;
    1177:       83 45 fc 01             add    DWORD PTR [rbp-0x4],0x1
    while (x--) {
    117b:       8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]
    117e:       8d 50 ff                lea    edx,[rax-0x1]
    1181:       89 55 ec                mov    DWORD PTR [rbp-0x14],edx
    1184:       85 c0                   test   eax,eax
    1186:       75 ef                   jne    1177 &lt;foo+0x14&gt;
    }
    return r;
    1188:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
}
    118b:       5d                      pop    rbp
    118c:       c3                      ret    
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Překlad s&nbsp;použitím přepínačů <strong>-fprofile-arcs</strong> a <strong>-ftest-coverage</strong></h2>

<p>Ve druhém kroku přeložíme stejný zdrojový kód, ovšem nyní při překladu
použijeme i přepínače <strong>-fprofile-arcs</strong> a
<strong>-ftest-coverage</strong>:</p>

<pre>
<strong>gcc -g -fprofile-arcs -ftest-coverage test.c</strong>
</pre>

<p>Opět se podíváme na způsob překladu všech výše uvedených funkcí do
assembleru a strojového kódu:</p>

<pre>
<strong>objdump -drw -Mintel -S a.out &gt; coverage.asm</strong>
</pre>

<p>Tentokrát ovšem bude sekvence instrukcí odlišná. Přidané instrukce jsou pro
větší přehlednost zvýrazněny:</p>

<pre>
00000000000014b9 &lt;zero&gt;:
int zero(void)
{
    14b9:       f3 0f 1e fa             endbr64 
    14bd:       55                      push   rbp
    14be:       48 89 e5                mov    rbp,rsp
    <strong>14c1:       48 8b 05 e8 3d 00 00    mov    rax,QWORD PTR [rip+0x3de8]        # 52b0 &lt;__gcov0.zero&gt;</strong>
    <strong>14c8:       48 83 c0 01             add    rax,0x1</strong>
    <strong>14cc:       48 89 05 dd 3d 00 00    mov    QWORD PTR [rip+0x3ddd],rax        # 52b0 &lt;__gcov0.zero&gt;</strong>
    return 0;
    14d3:       b8 00 00 00 00          mov    eax,0x0
}
    14d8:       5d                      pop    rbp
    14d9:       c3                      ret    
&nbsp;
00000000000014da &lt;inc&gt;:
&nbsp;
int inc(int x)
{
    14da:       f3 0f 1e fa             endbr64 
    14de:       55                      push   rbp
    14df:       48 89 e5                mov    rbp,rsp
    14e2:       89 7d fc                mov    DWORD PTR [rbp-0x4],edi
    <strong>14e5:       48 8b 05 bc 3d 00 00    mov    rax,QWORD PTR [rip+0x3dbc]        # 52a8 &lt;__gcov0.inc&gt;</strong>
    <strong>14ec:       48 83 c0 01             add    rax,0x1</strong>
    <strong>14f0:       48 89 05 b1 3d 00 00    mov    QWORD PTR [rip+0x3db1],rax        # 52a8 &lt;__gcov0.inc&gt;</strong>
    return x+1;
    14f7:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
    14fa:       83 c0 01                add    eax,0x1
}
    14fd:       5d                      pop    rbp
    14fe:       c3                      ret    
&nbsp;
00000000000014ff &lt;add&gt;:
&nbsp;
int add(int x, int y)
{
    14ff:       f3 0f 1e fa             endbr64 
    1503:       55                      push   rbp
    1504:       48 89 e5                mov    rbp,rsp
    1507:       89 7d fc                mov    DWORD PTR [rbp-0x4],edi
    150a:       89 75 f8                mov    DWORD PTR [rbp-0x8],esi
    <strong>150d:       48 8b 05 8c 3d 00 00    mov    rax,QWORD PTR [rip+0x3d8c]        # 52a0 &lt;__gcov0.add&gt;</strong>
    <strong>1514:       48 83 c0 01             add    rax,0x1</strong>
    <strong>1518:       48 89 05 81 3d 00 00    mov    QWORD PTR [rip+0x3d81],rax        # 52a0 &lt;__gcov0.add&gt;</strong>
    return x+y;
    151f:       8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
    1522:       8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
    1525:       01 d0                   add    eax,edx
}
    1527:       5d                      pop    rbp
    1528:       c3                      ret    
&nbsp;
0000000000001529 &lt;foo&gt;:
&nbsp;
int foo(int x)
{
    1529:       f3 0f 1e fa             endbr64 
    152d:       55                      push   rbp
    152e:       48 89 e5                mov    rbp,rsp
    1531:       89 7d ec                mov    DWORD PTR [rbp-0x14],edi
    <strong>1534:       48 8b 05 55 3d 00 00    mov    rax,QWORD PTR [rip+0x3d55]        # 5290 &lt;__gcov0.foo&gt;</strong>
    <strong>153b:       48 83 c0 01             add    rax,0x1</strong>
    <strong>153f:       48 89 05 4a 3d 00 00    mov    QWORD PTR [rip+0x3d4a],rax        # 5290 &lt;__gcov0.foo&gt;</strong>
    int r = 0;
    1546:       c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
    while (x--) {
    154d:       eb 16                   jmp    1565 &lt;foo+0x3c&gt;
        r++;
    154f:       83 45 fc 01             add    DWORD PTR [rbp-0x4],0x1
    <strong>1553:       48 8b 05 3e 3d 00 00    mov    rax,QWORD PTR [rip+0x3d3e]        # 5298 &lt;__gcov0.foo+0x8&gt;</strong>
    <strong>155a:       48 83 c0 01             add    rax,0x1</strong>
    <strong>155e:       48 89 05 33 3d 00 00    mov    QWORD PTR [rip+0x3d33],rax        # 5298 &lt;__gcov0.foo+0x8&gt;</strong>
    while (x--) {
    1565:       8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]
    1568:       8d 50 ff                lea    edx,[rax-0x1]
    156b:       89 55 ec                mov    DWORD PTR [rbp-0x14],edx
    156e:       85 c0                   test   eax,eax
    1570:       75 dd                   jne    154f &lt;foo+0x26&gt;
    }
    return r;
    1572:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
}
    1575:       5d                      pop    rbp
    1576:       c3                      ret    
</pre>

<p>Ze zvýrazněných částí kódů je patrné, že byly přidány instrukce určené pro
zvýšení obsahu čítačů uložených v&nbsp;operační paměti. A tyto instrukce nejsou
přidány pouze jedenkrát do každé funkce, ale navíc i do každého bloku, tedy i
do těla programové smyčky. Pro krátké funkce a bloky tedy kód může podstatným
způsobem narůst.</p>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že na této úrovni není
řešeno zamykání čítačů, takže sice nedojde k&nbsp;výraznému zpomalení běhu
programu, na druhou stranu však nemusí být výsledky přesné ve chvíli, kdy
proces běží v&nbsp;několika vláknech.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Podrobnější porovnání obou vygenerovaných strojových kódů</h2>

<p>Abychom mohli obě varianty strojových kódů vzniklých kompilací a slinkováním
porovnat, odstraníme všechny jeho &bdquo;pohyblivé&ldquo; části, zejména tedy
absolutní adresy jednotlivých instrukcí. Kód bez instrukcí přidaných pro
<i>gcov</i> bude po ruční úpravě vypadat takto:</p>

<pre>
int <strong>zero</strong>(void)
{
    f3 0f 1e fa                 endbr64 
    55                          push   rbp
    48 89 e5                    mov    rbp,rsp
    return 0;
    b8 00 00 00 00              mov    eax,0x0
}
    5d                          pop    rbp
    c3                          ret    
&nbsp;
&nbsp;
int <strong>inc</strong>(int x)
{
    f3 0f 1e fa                 endbr64 
    55                          push   rbp
    48 89 e5                    mov    rbp,rsp
    89 7d fc                    mov    DWORD PTR [rbp-0x4],edi
    return x+1;
    8b 45 fc                    mov    eax,DWORD PTR [rbp-0x4]
    83 c0 01                    add    eax,0x1
}
    5d                          pop    rbp
    c3                          ret    
&nbsp;
&nbsp;
int <strong>add</strong>(int x, int y)
{
    f3 0f 1e fa                 endbr64 
    55                          push   rbp
    48 89 e5                    mov    rbp,rsp
    89 7d fc                    mov    DWORD PTR [rbp-0x4],edi
    89 75 f8                    mov    DWORD PTR [rbp-0x8],esi
    return x+y;
    8b 55 fc                    mov    edx,DWORD PTR [rbp-0x4]
    8b 45 f8                    mov    eax,DWORD PTR [rbp-0x8]
    01 d0                       add    eax,edx
}
    5d                          pop    rbp
    c3                          ret    
&nbsp;
&nbsp;
int <strong>foo</strong>(int x)
{
    f3 0f 1e fa                 endbr64 
    55                          push   rbp
    48 89 e5                    mov    rbp,rsp
    89 7d ec                    mov    DWORD PTR [rbp-0x14],edi
    int r = 0;
    c7 45 fc 00 00 00 00        mov    DWORD PTR [rbp-0x4],0x0
    while (x--) {
    eb 04                       jmp    117b &lt;foo+0x18&gt;
        r++;
    83 45 fc 01                 add    DWORD PTR [rbp-0x4],0x1
    while (x--) {
    8b 45 ec                    mov    eax,DWORD PTR [rbp-0x14]
    8d 50 ff                    lea    edx,[rax-0x1]
    89 55 ec                    mov    DWORD PTR [rbp-0x14],edx
    85 c0                       test   eax,eax
    75 ef                       jne    1177 &lt;foo+0x14&gt;
    }
    return r;
    8b 45 fc                    mov    eax,DWORD PTR [rbp-0x4]
}
    5d                          pop    rbp
    c3                          ret    
</pre>

<p>Kód s&nbsp;instrukcemi přidanými pro účely nástroje <i>gcov</i>:</p>

<pre>
int <strong>zero</strong>(void)
{
    f3 0f 1e fa                 endbr64 
    55                          push   rbp
    48 89 e5                    mov    rbp,rsp
    48 8b 05 e8 3d 00 00        mov    rax,QWORD PTR [rip+0x3de8]        # 52b0 &lt;__gcov0.zero&gt;
    48 83 c0 01                 add    rax,0x1
    48 89 05 dd 3d 00 00        mov    QWORD PTR [rip+0x3ddd],rax        # 52b0 &lt;__gcov0.zero&gt;
    return 0;
    b8 00 00 00 00              mov    eax,0x0
}
    5d                          pop    rbp
    c3                          ret    
&nbsp;
&nbsp;
int <strong>inc</strong>(int x)
{
    f3 0f 1e fa                 endbr64 
    55                          push   rbp
    48 89 e5                    mov    rbp,rsp
    89 7d fc                    mov    DWORD PTR [rbp-0x4],edi
    48 8b 05 bc 3d 00 00        mov    rax,QWORD PTR [rip+0x3dbc]        # 52a8 &lt;__gcov0.inc&gt;
    48 83 c0 01                 add    rax,0x1
    48 89 05 b1 3d 00 00        mov    QWORD PTR [rip+0x3db1],rax        # 52a8 &lt;__gcov0.inc&gt;
    return x+1;
    8b 45 fc                    mov    eax,DWORD PTR [rbp-0x4]
    83 c0 01                    add    eax,0x1
}
    5d                          pop    rbp
    c3                          ret    
&nbsp;
&nbsp;
int <strong>add</strong>(int x, int y)
{
    f3 0f 1e fa                 endbr64 
    55                          push   rbp
    48 89 e5                    mov    rbp,rsp
    89 7d fc                    mov    DWORD PTR [rbp-0x4],edi
    89 75 f8                    mov    DWORD PTR [rbp-0x8],esi
    48 8b 05 8c 3d 00 00        mov    rax,QWORD PTR [rip+0x3d8c]        # 52a0 &lt;__gcov0.add&gt;
    48 83 c0 01                 add    rax,0x1
    48 89 05 81 3d 00 00        mov    QWORD PTR [rip+0x3d81],rax        # 52a0 &lt;__gcov0.add&gt;
    return x+y;
    8b 55 fc                    mov    edx,DWORD PTR [rbp-0x4]
    8b 45 f8                    mov    eax,DWORD PTR [rbp-0x8]
    01 d0                       add    eax,edx
}
    5d                          pop    rbp
    c3                          ret    
&nbsp;
&nbsp;
int <strong>foo</strong>(int x)
{
    f3 0f 1e fa                 endbr64 
    55                          push   rbp
    48 89 e5                    mov    rbp,rsp
    89 7d ec                    mov    DWORD PTR [rbp-0x14],edi
    48 8b 05 55 3d 00 00        mov    rax,QWORD PTR [rip+0x3d55]        # 5290 &lt;__gcov0.foo&gt;
    48 83 c0 01                 add    rax,0x1
    48 89 05 4a 3d 00 00        mov    QWORD PTR [rip+0x3d4a],rax        # 5290 &lt;__gcov0.foo&gt;
    int r = 0;
    c7 45 fc 00 00 00 00        mov    DWORD PTR [rbp-0x4],0x0
    while (x--) {
    eb 16                       jmp    1565 &lt;foo+0x3c&gt;
        r++;
    83 45 fc 01                 add    DWORD PTR [rbp-0x4],0x1
    48 8b 05 3e 3d 00 00        mov    rax,QWORD PTR [rip+0x3d3e]        # 5298 &lt;__gcov0.foo+0x8&gt;
    48 83 c0 01                 add    rax,0x1
    48 89 05 33 3d 00 00        mov    QWORD PTR [rip+0x3d33],rax        # 5298 &lt;__gcov0.foo+0x8&gt;
    while (x--) {
    8b 45 ec                    mov    eax,DWORD PTR [rbp-0x14]
    8d 50 ff                    lea    edx,[rax-0x1]
    89 55 ec                    mov    DWORD PTR [rbp-0x14],edx
    85 c0                       test   eax,eax
    75 dd                       jne    154f &lt;foo+0x26&gt;
    }
    return r;
    8b 45 fc                    mov    eax,DWORD PTR [rbp-0x4]
}
    5d                          pop    rbp
    c3                          ret    
</pre>

<p>Textové porovnání jasně ukazuje, že samotný strojový kód zůstal nezměněn,
pouze do něj byly (mechanicky) vloženy úpravy čítačů, jejichž hodnoty jsou na
konci uloženy do souboru <strong>.gcda</strong> (a tím došlo k&nbsp;posunutí
adres instrukcí, teoreticky se rozšíří šířka relativních skoků atd.):</p>

<pre>
--- normal.asm  2023-04-14 14:33:34.712189422 +0200
+++ coverage.asm        2023-04-14 14:33:45.540229057 +0200
@@ -3,6 +3,9 @@
     f3 0f 1e fa                endbr64 
     55                         push   rbp
     48 89 e5                   mov    rbp,rsp
+    48 8b 05 e8 3d 00 00       mov    rax,QWORD PTR [rip+0x3de8]        # 52b0 &lt;__gcov0.zero&gt;
+    48 83 c0 01                add    rax,0x1
+    48 89 05 dd 3d 00 00       mov    QWORD PTR [rip+0x3ddd],rax        # 52b0 &lt;__gcov0.zero&gt;
     return 0;
     b8 00 00 00 00             mov    eax,0x0
 }
@@ -16,6 +19,9 @@
     55                         push   rbp
     48 89 e5                   mov    rbp,rsp
     89 7d fc                   mov    DWORD PTR [rbp-0x4],edi
+    48 8b 05 bc 3d 00 00       mov    rax,QWORD PTR [rip+0x3dbc]        # 52a8 &lt;__gcov0.inc&gt;
+    48 83 c0 01                add    rax,0x1
+    48 89 05 b1 3d 00 00       mov    QWORD PTR [rip+0x3db1],rax        # 52a8 &lt;__gcov0.inc&gt;
     return x+1;
     8b 45 fc                   mov    eax,DWORD PTR [rbp-0x4]
     83 c0 01                   add    eax,0x1
@@ -31,6 +37,9 @@
     48 89 e5                   mov    rbp,rsp
     89 7d fc                   mov    DWORD PTR [rbp-0x4],edi
     89 75 f8                   mov    DWORD PTR [rbp-0x8],esi
+    48 8b 05 8c 3d 00 00       mov    rax,QWORD PTR [rip+0x3d8c]        # 52a0 &lt;__gcov0.add&gt;
+    48 83 c0 01                add    rax,0x1
+    48 89 05 81 3d 00 00       mov    QWORD PTR [rip+0x3d81],rax        # 52a0 &lt;__gcov0.add&gt;
     return x+y;
     8b 55 fc                   mov    edx,DWORD PTR [rbp-0x4]
     8b 45 f8                   mov    eax,DWORD PTR [rbp-0x8]
@@ -46,18 +55,24 @@
     55                         push   rbp
     48 89 e5                   mov    rbp,rsp
     89 7d ec                   mov    DWORD PTR [rbp-0x14],edi
+    48 8b 05 55 3d 00 00       mov    rax,QWORD PTR [rip+0x3d55]        # 5290 &lt;__gcov0.foo&gt;
+    48 83 c0 01                add    rax,0x1
+    48 89 05 4a 3d 00 00       mov    QWORD PTR [rip+0x3d4a],rax        # 5290 &lt;__gcov0.foo&gt;
     int r = 0;
     c7 45 fc 00 00 00 00       mov    DWORD PTR [rbp-0x4],0x0
     while (x--) {
-    eb 04                      jmp    117b &lt;foo+0x18&gt;
+    eb 16                      jmp    1565 &lt;foo+0x3c&gt;
         r++;
     83 45 fc 01                add    DWORD PTR [rbp-0x4],0x1
+    48 8b 05 3e 3d 00 00       mov    rax,QWORD PTR [rip+0x3d3e]        # 5298 &lt;__gcov0.foo+0x8&gt;
+    48 83 c0 01                add    rax,0x1
+    48 89 05 33 3d 00 00       mov    QWORD PTR [rip+0x3d33],rax        # 5298 &lt;__gcov0.foo+0x8&gt;
     while (x--) {
     8b 45 ec                   mov    eax,DWORD PTR [rbp-0x14]
     8d 50 ff                   lea    edx,[rax-0x1]
     89 55 ec                   mov    DWORD PTR [rbp-0x14],edx
     85 c0                      test   eax,eax
-    75 ef                      jne    1177 &lt;foo+0x14&gt;
+    75 dd                      jne    154f &lt;foo+0x26&gt;
     }
     return r;
     8b 45 fc                   mov    eax,DWORD PTR [rbp-0x4]
</pre>

<p>Na rozdíl se můžeme podívat i ve vizuální podobě:</p>

*** image ***
<p><i>Obrázek 5: Rozdíl v&nbsp;obou strojových kódech vzniklých
překladem.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Nástroj <i>gcov</i> a <i>Clang</i></h2>

<p>Nástroj <i>gcov</i> je sice primárně určen pro ekosystém GCC, ale lze ho
využít i v&nbsp;ekosystému LLVM, konkrétně s&nbsp;<i>Clangem</i>. Pro překlad
programu do podoby, která po svém spuštění vytvoří výstup kompatibilní
s&nbsp;<i>gcov</i> se používají přepínače <strong>-ftest-coverage</strong>
popř.&nbsp;<strong>--coverage</strong>. Ovšem nativně <i>Clang</i> (a vlastně i
celé LLVM) namísto nástroje <i>gcov</i> používá <i>SanitizerCoverage</i> (viz
též <a
href="https://clang.llvm.org/docs/SanitizerCoverage.html">https://clang.llvm.org/docs/SanitizerCoverage.html</a>).
Příslušný přepínač předávaný překladači vypadá takto:
<strong>-fsanitize-coverage=trace-pc-guard</strong>.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační soubory použité v&nbsp;dnešním článku byly uloženy do Git
repositáře, jenž je dostupný na adrese <a
href="https://github.com/tisnik/slides/">https://github.com/tisnik/slides/</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář, můžete namísto toho
použít odkazy na jednotlivé zdrojové soubory, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>tree1.c</td><td>průchod prázdným binárním stromem bez jeho konstrukce</td><td><a href="https://github.com/tisnik/slides/blob/master/sources/tree1.c">https://github.com/tisnik/slides/blob/master/sources/tree1.c</a></td></tr>
<tr><td>2</td><td>tree2.c</td><td>konstrukce binárního stromu s&nbsp;jediným uzlem; průchod tímto stromem</td><td><a href="https://github.com/tisnik/slides/blob/master/sources/tree2.c">https://github.com/tisnik/slides/blob/master/sources/tree2.c</a></td></tr>
<tr><td>3</td><td>tree3.c</td><td>konstrukce binárního stromu s&nbsp;více uzly; průchod tímto stromem</td><td><a href="https://github.com/tisnik/slides/blob/master/sources/tree3.c">https://github.com/tisnik/slides/blob/master/sources/tree3.c</a></td></tr>
<tr><td>4</td><td>factorial.c</td><td>naivní rekurzivní výpočet faktoriálu</td><td><a href="https://github.com/tisnik/slides/blob/master/sources/factorial.c">https://github.com/tisnik/slides/blob/master/sources/factorial.c</a></td></tr>
<tr><td>5</td><td>test.c</td><td>několik funkcí s&nbsp;různým počtem parametrů, které jsou volány z&nbsp;<strong>main</strong></td><td><a href="https://github.com/tisnik/slides/blob/master/sources/test.c">https://github.com/tisnik/slides/blob/master/sources/test.c</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články s&nbsp;tématem testování</h2>

<p>Tématem testování jsme se již na stránkách Rootu několikrát zabývali. Jedná
se mj.&nbsp;o následující články:</p>

<ol>

<li>Použití Pythonu pro tvorbu testů: od jednotkových testů až po testy UI<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-od-jednotkovych-testu-az-po-testy-ui/</a>
</li>

<li>Použití Pythonu pro tvorbu testů: použití třídy Mock z knihovny unittest.mock<br />
<a href="https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/">https://www.root.cz/clanky/pouziti-pythonu-pro-tvorbu-testu-pouziti-tridy-mock-z-knihovny-unittest-mock/</a>
</li>

<li>Použití nástroje pytest pro tvorbu jednotkových testů a benchmarků<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/">https://www.root.cz/clanky/pouziti-nastroje-pytest-pro-tvorbu-jednotkovych-testu-a-benchmarku/</a>
</li>

<li>Nástroj pytest a jednotkové testy: fixtures, výjimky, parametrizace testů<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-fixtures-vyjimky-parametrizace-testu/</a>
</li>

<li>Nástroj pytest a jednotkové testy: životní cyklus testů, užitečné tipy a triky<br />
<a href="https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/">https://www.root.cz/clanky/nastroj-pytest-a-jednotkove-testy-zivotni-cyklus-testu-uzitecne-tipy-a-triky/</a>
</li>

<li>Struktura projektů s jednotkovými testy, využití Travis CI<br />
<a href="https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/">https://www.root.cz/clanky/struktura-projektu-s-jednotkovymi-testy-vyuziti-travis-ci/</a>
</li>

<li>Omezení stavového prostoru testovaných funkcí a metod<br />
<a href="https://www.root.cz/clanky/omezeni-stavoveho-prostoru-testovanych-funkci-a-metod/">https://www.root.cz/clanky/omezeni-stavoveho-prostoru-testovanych-funkci-a-metod/</a>
</li>

<li>Testování aplikací s využitím nástroje Hypothesis<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis/">https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis/</a>
</li>

<li>Testování aplikací s využitím nástroje Hypothesis (dokončení)<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis-dokonceni/">https://www.root.cz/clanky/testovani-aplikaci-s-vyuzitim-nastroje-hypothesis-dokonceni/</a>
</li>

<li>Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu<br />
<a href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu/">https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu/</a>
</li>

<li>Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu (2)<br />
<a href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-2/">https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-2/</a>
</li>

<li>Testování webových aplikací s&nbsp;REST API z&nbsp;Pythonu (3)<br />
<a href="https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-3/">https://www.root.cz/clanky/testovani-webovych-aplikaci-s-rest-api-z-pythonu-3/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (druhá část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-druha-cast/</a>
</li>

<li>Behavior-driven development v Pythonu s využitím knihovny Behave (závěrečná část)<br />
<a href="https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/">https://www.root.cz/clanky/behavior-driven-development-v-pythonu-s-vyuzitim-knihovny-behave-zaverecna-cast/</a>
</li>

<li>Validace datových struktur v Pythonu pomocí knihoven Schemagic a Schema<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-pomoci-knihoven-schemagic-a-schema/</a>
</li>

<li>Validace datových struktur v Pythonu (2. část)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-2-cast/</a>
</li>

<li>Validace datových struktur v Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/">https://www.root.cz/clanky/validace-datovych-struktur-v-pythonu-dokonceni/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework/</a>
</li>

<li>Univerzální testovací nástroj Robot Framework a BDD testy<br />
<a href="https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/">https://www.root.cz/clanky/univerzalni-testovaci-nastroj-robot-framework-a-bdd-testy/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani/</a>
</li>

<li>Úvod do problematiky fuzzingu a fuzz testování – složení vlastního fuzzeru<br />
<a href="https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/">https://www.root.cz/clanky/uvod-do-problematiky-fuzzingu-a-fuzz-testovani-slozeni-vlastniho-fuzzeru/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

<li>Validace dat s využitím knihovny spec v Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Testování aplikací naprogramovaných v jazyce Go<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/">https://www.root.cz/clanky/testovani-aplikaci-naprogramovanych-v-jazyce-go/</a>
</li>

<li>Knihovny určené pro tvorbu testů v programovacím jazyce Go<br />
<a href="https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/">https://www.root.cz/clanky/knihovny-urcene-pro-tvorbu-testu-v-programovacim-jazyce-go/</a>
</li>

<li>Testování aplikací psaných v Go s využitím knihoven Goblin a Frisby<br />
<a href="https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/">https://www.root.cz/clanky/testovani-aplikaci-psanych-v-go-s-vyuzitim-knihoven-goblin-a-frisby/</a>
</li>

<li>Testování Go aplikací s využitím knihovny GΩmega a frameworku Ginkgo<br />
<a href="https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/">https://www.root.cz/clanky/testovani-go-aplikaci-s-vyuzitim-knihovny-gomega-mega-a-frameworku-ginkgo/</a>
</li>

<li>Tvorba BDD testů s využitím jazyka Go a nástroje godog<br />
<a href="https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/">https://www.root.cz/clanky/tvorba-bdd-testu-s-vyuzitim-jazyka-go-a-nastroje-godog/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem/</a>
</li>

<li>Použití Go pro automatizaci práce s aplikacemi s interaktivním příkazovým řádkem (dokončení)<br />
<a href="https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/">https://www.root.cz/clanky/pouziti-go-pro-automatizaci-prace-s-aplikacemi-s-interaktivnim-prikazovym-radkem-dokonceni/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>gcov manual: Test Coverage Program<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Gcov.html">https://gcc.gnu.org/onlinedocs/gcc/Gcov.html</a>
</li>

<li>How to Analyze Code Coverage with gcov<br />
<a href="https://www.linuxtoday.com/blog/analyzing-code-coverage-with-gcov/">https://www.linuxtoday.com/blog/analyzing-code-coverage-with-gcov/</a>
</li>

<li>gcov - Unix, Linux Command<br />
<a href="https://www.tutorialspoint.com/unix_commands/gcov.htm">https://www.tutorialspoint.com/unix_commands/gcov.htm</a>
</li>

<li>Testing code coverage in C using GCOV<br />
<a href="https://www.youtube.com/watch?v=UOGMNRcV9-4">https://www.youtube.com/watch?v=UOGMNRcV9-4</a>
</li>

<li>Nástroj objdump: švýcarský nožík pro vývojáře<br />
<a href="https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/">https://www.root.cz/clanky/nastroj-objdump-svycarsky-nozik-pro-vyvojare/</a>
</li>

<li>What is code coverage?<br />
<a href="https://www.atlassian.com/continuous-delivery/software-testing/code-coverage">https://www.atlassian.com/continuous-delivery/software-testing/code-coverage</a>
</li>

<li>Everything you need to know about code coverage<br />
<a href="https://www.codegrip.tech/productivity/everything-you-need-to-know-about-code-coverage/">https://www.codegrip.tech/productivity/everything-you-need-to-know-about-code-coverage/</a>
</li>

<li>GCC, the GNU Compiler Collection<br />
<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>
</li>

<li>Clang 17.0.0: Source-based Code Coverage<br />
<a href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">https://clang.llvm.org/docs/SourceBasedCodeCoverage.html</a>
</li>

<li>Clang 17.0.0: SanitizerCoverage<br />
<a href="https://clang.llvm.org/docs/SanitizerCoverage.html">https://clang.llvm.org/docs/SanitizerCoverage.html</a>
</li>

<li>Name mangling<br />
<a href="https://en.wikipedia.org/wiki/Name_mangling">https://en.wikipedia.org/wiki/Name_mangling</a>
</li>

<li>Pokrytí kódu testy (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Pokryt%C3%AD_k%C3%B3du_testy">https://cs.wikipedia.org/wiki/Pokryt%C3%AD_k%C3%B3du_testy</a>
</li>

<li>Code coverage (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Code_coverage">https://en.wikipedia.org/wiki/Code_coverage</a>
</li>

<li>Using the GNU Compiler Collection (GCC)<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/index.html#Top">https://gcc.gnu.org/onlinedocs/gcc/index.html#Top</a>
</li>

<li>Programming Languages Supported by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/G_002b_002b-and-GCC.html#G_002b_002b-and-GCC">https://gcc.gnu.org/onlinedocs/gcc/G_002b_002b-and-GCC.html#G_002b_002b-and-GCC</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

