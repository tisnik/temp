<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>JetStream - nová technologie přidaná do brokeru NATS</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>JetStream - nová technologie přidaná do brokeru NATS</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Brokerem NATS jsme se již na stránkách Roota zabývali ve dvou článcích. Taktéž jsme si řekli, že tento broker podporuje, podobně jako Kafka, takzvaný stream processing. Tento koncept, jenž byl původně realizován technologií NATS Streaming, byl nedávno vylepšen a představena byla technologie nazvaná JetStreams, která dokáže konkurovat Kafce.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. JetStream &ndash; nová technologie přidaná do brokeru NATS</a></p>
<p><a href="#k02">2. Komunikační strategie nabízené nejnovějším NATS serverem</a></p>
<p><a href="#k03">3. Instalace NATS serveru</a></p>
<p><a href="#k04">4. Instalace CLI klienta a současně i vývojového serveru</a></p>
<p><a href="#k05">5. Spuštění vývojového serveru</a></p>
<p><a href="#k06">6. Nastavení kontextu pro CLI klienta</a></p>
<p><a href="#k07">7. Vytvoření nového streamu</a></p>
<p><a href="#k08">8. Publikace zprávy nebo většího množství zpráv z&nbsp;příkazové řádky</a></p>
<p><a href="#k09">9. Přečtení zpráv či zprávy z&nbsp;vybraného streamu</a></p>
<p><a href="#k10">10. Dočasní konzumenti zpráv vs. stálí konzumenti</a></p>
<p><a href="#k11">11. Získání podrobnějších operací a vybraném streamu</a></p>
<p><a href="#k12">12. Konzumenti explicitně žádající o zprávy</a></p>
<p><a href="#k13">13. Manuální potvrzení zkonzumované zprávy konzumentem, další možnosti konzumentů</a></p>
<p><a href="#k14">14. Kde jsou uloženy zprávy poslané do témat?</a></p>
<p><a href="#k15">15. Komunikace s&nbsp;brokerem NATS z&nbsp;Pythonu</a></p>
<p><a href="#k16">16. Připojení k&nbsp;NATS serveru z&nbsp;Pythonu</a></p>
<p><a href="#k17">17. Producenti a konzumenti zpráv založení na komunikační strategii PUB-SUB</a></p>
<p><a href="#k18">18. Producenti a konzumenti zpráv založení na využití stream processingu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. JetStream &ndash; nová technologie přidaná do brokeru NATS</h2>

<p>Na stránkách Roota jsme se v&nbsp;trojici článků <a
href="https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/">Komunikace
s message brokery z programovacího jazyka Go</a>, <a
href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">Použití message
brokeru NATS</a> a <a
href="https://www.root.cz/clanky/nats-streaming-server/">NATS Streaming
Server</a> seznámili se zajímavým a potenciálně i velmi užitečným message
brokerem nazvaným NATS. Připomeňme si ve stručnosti, že se jedná o poměrně
úspěšný projekt, jenž je vyvinut v&nbsp;programovacím jazyku Go, což mu do
jisté míry zajišťuje stabilitu i škálovatelnost (a taktéž velmi snadnou
instalaci i tvorbu obrazů pro kontejnery). Stabilita a škálovatelnost jsou
ostatně vlastnosti, které u message brokerů většinou očekáváme.</p>

<p>Původní varianta NATSu byla vytvořena Derekem Collisonem; zajímavé je, že
tato varianta nebyla naprogramována v&nbsp;jazyce Go, ale v&nbsp;programovacím
jazyce Ruby. Dnes se ovšem budeme zabývat moderní (a jedinou podporovanou)
verzí systému NATS, která byla přeportována do jazyka Go. Celý systém NATS se
skládá z&nbsp;několika komponent:</p>

<ol>

<li>V&nbsp;první řadě se jedná o samotný <i>server</i>, jenž se spouští
příkazem <strong>nats-server</strong> (což si ostatně za chvíli vyzkoušíme).
Server je naprogramovaný v&nbsp;jazyce Go a při jeho vývoji bylo dbáno na to,
aby byla zaručena vysoká dostupnost celé služby a přitom byla samotná služba
s&nbsp;běžícím serverem málo náročná na systémové zdroje, především na spotřebu
operační paměti (to má v&nbsp;době Dockeru a podobných nástrojů poměrně velký
význam).</li>

<li>Dalším typem komponenty jsou programátorská rozhraní pro klienty, která
v&nbsp;současnosti existují pro několik ekosystémů (což je většinou kombinace
programovacího jazyka, knihoven a popř.&nbsp;jeho virtuálního stroje); viz též
tabulky s&nbsp;podporovanými ekosystémy, které jsou zobrazeny pod tímto
odstavcem.</li>

<li>Třetí komponentou, kvůli které ostatně vznikl tento článek, je
<i>JetStream</i>, což je technologie umožňující využití <i>stream
processingu</i> zpopularizovaného brokerem <a
href="https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/">Apache
Kafka</a>. V&nbsp;porovnání s&nbsp;Kafkou je NATS + JetStream
&bdquo;odlehčenou&ldquo; alternativou, která ovšem navíc podporuje i mnohé
další <a href="#k02">komunikační strategie</a>, takže má šanci se stát ústřední
technologií v&nbsp;architekturách založených na mikroslužbách.</li>

<li>Čtvrtým typem komponenty je takzvaný <i>NATS Connector Framework</i>
zajišťující propojení systému NATS s&nbsp;dalšími technologiemi (XMPP,
logování, notifikační služby aj.). Ten je naprogramovaný v&nbsp;Javě a
v&nbsp;současnosti je podporován například konektor pro Redis (<a
href="https://github.com/nats-io/nats-connector-redis">https://github.com/nats-io/nats-connector-redis</a>).
Touto komponentou se prozatím nebudeme zabývat.</li>

<p>Oficiálně v&nbsp;současnosti existují tato rozhraní pro broker NATS (bez
JetStreamu):</p>

<table>
<tr><td> 1</td><td>Arduino</td><td>NATS Arduino Client</td></tr>
<tr><td> 2</td><td>Asio C++</td><td>NATS Asio C++ Client</td></tr>
<tr><td> 3</td><td>Ballerina</td><td>NATS Ballerina Client</td></tr>
<tr><td> 4</td><td>C</td><td>NATS C Client</td></tr>
<tr><td> 5</td><td>.NET C#</td><td>NATS .NET C# Client</td></tr>
<tr><td> 6</td><td>Clojure</td><td>NATS Clojure Client</td></tr>
<tr><td> 7</td><td>Crystal</td><td>NATS Crystal Client</td></tr>
<tr><td> 8</td><td>Dart</td><td>NATS Dart Client</td></tr>
<tr><td> 9</td><td>Deno</td><td>NATS Deno Client</td></tr>
<tr><td>10</td><td>Elixir</td><td>NATS Elixir Client</td></tr>
<tr><td>11</td><td>Elm</td><td>NATS Elm Client</td></tr>
<tr><td>12</td><td>Erlang</td><td>NATS Erlang Client</td></tr>
<tr><td>13</td><td>Go</td><td>NATS Go Client</td></tr>
<tr><td>14</td><td>Haskell</td><td>NATS Haskell Client</td></tr>
<tr><td>15</td><td>Java</td><td>NATS Java Client</td></tr>
<tr><td>16</td><td>Java Android</td><td>NATS Java Android Client</td></tr>
<tr><td>17</td><td>LabVIEW</td><td>NATS LabVIEW Client</td></tr>
<tr><td>18</td><td>Common Lisp</td><td>NATS Common Lisp Client</td></tr>
<tr><td>19</td><td>Lua</td><td>NATS Lua Client</td></tr>
<tr><td>20</td><td>MicroPython</td><td>NATS MicroPython Client</td></tr>
<tr><td>21</td><td>NGINX</td><td>NATS NGINX Client</td></tr>
<tr><td>22</td><td>Node.js</td><td>NATS Node.js Client</td></tr>
<tr><td>23</td><td>Perl</td><td>NATS Perl Client</td></tr>
<tr><td>24</td><td>PHP</td><td>NATS PHP Client</td></tr>
<tr><td>25</td><td>Pure Ruby</td><td>NATS Pure Ruby Client</td></tr>
<tr><td>26</td><td>Python</td><td>NATS Python Client</td></tr>
<tr><td>27</td><td>Python Asyncio</td><td>NATS Python Asyncio Client</td></tr>
<tr><td>28</td><td>Python Minimal</td><td>NATS Python Minimal Client</td></tr>
<tr><td>29</td><td>Python Tornado</td><td>NATS Python Tornado Client</td></tr>
<tr><td>30</td><td>Python Twisted</td><td>NATS Python Twisted Client</td></tr>
<tr><td>31</td><td>C++/Qt/QML</td><td>NATS C++/Qt/QML Client</td></tr>
<tr><td>32</td><td>Qt5 C++</td><td>NATS Qt5 C++ Client</td></tr>
<tr><td>33</td><td>Ruby</td><td>NATS Ruby Client</td></tr>
<tr><td>34</td><td>Rust</td><td>NATS Rust Client</td></tr>
<tr><td>35</td><td>Scala</td><td>NATS Scala Client</td></tr>
<tr><td>36</td><td>Swift</td><td>NATS Swift Client</td></tr>
<tr><td>37</td><td>Tcl</td><td>NATS Tcl Client</td></tr>
<tr><td>38</td><td>WebSocket</td><td>NATS WebSocket Client</td></tr>
<table>

<p>Technologie JetStream je oficiálně podporována v&nbsp;menším množství
ekosystémů, ovšem ty základní (C, Go, Java, Rust a Python) podporovány již
jsou:</p>

<table>
<tr><td> 1</td><td>C</td><td>NATS C Client</td></tr>
<tr><td> 2</td><td>.NET C#</td><td>NATS .NET C# Client</td></tr>
<tr><td> 3</td><td>Deno</td><td>NATS Deno Client</td></tr>
<tr><td> 4</td><td>Go</td><td>NATS Go Client</td></tr>
<tr><td> 5</td><td>Java</td><td>NATS Java Client</td></tr>
<tr><td> 6</td><td>Node.js</td><td>NATS Node.js Client</td></tr>
<tr><td> 7</td><td>PHP</td><td>NATS PHP Client</td></tr>
<tr><td> 8</td><td>Pure Ruby</td><td>NATS Pure Ruby Client</td></tr>
<tr><td> 9</td><td>Python Asyncio</td><td>NATS Python Asyncio Client</td></tr>
<tr><td>10</td><td>C++/Qt/QML</td><td>NATS C++/Qt/QML Client</td></tr>
<tr><td>11</td><td>Rust</td><td>NATS Rust Client</td></tr>
<tr><td>12</td><td>Tcl</td><td>NATS Tcl Client</td></tr>
<tr><td>13</td><td>WebSocket</td><td>NATS WebSocket Client</td></tr>
<table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Komunikační strategie nabízené nejnovějším NATS serverem</h2>

<p>Nejnovější NATS server s&nbsp;technologií JetStream nabízí uživatelům hned
několik komunikačních strategií. Některé z&nbsp;těchto strategií jsme si již
popsali v&nbsp;předchozích dvou článcích; nové strategie si postupně popíšeme.
Pro větší přehlednost jsou všechny podporované komunikační strategie
vizualizovány na osmici diagramů:</p>

<a href="https://www.root.cz/obrazek/662311/"><img src="https://i.iinfo.cz/images/82/nats-jetstream-1-1-prev.png" class="image-662311" data-prev-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-1-prev.png" data-prev-width="370" data-prev-height="164" data-large-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-1-large.png" data-large-width="720" data-large-height="320" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="370" height="164" /></a>
<p><i>Obrázek 1: Komunikační strategie nazvaná PUB-SUB, v níž spolu komunikují
dva typy uzlů: zdroje zpráv (publishers) a konzumenti zpráv (subscribers).
Konzumenti se mohou k odebírání zpráv kdykoli přihlásit a kdykoli se také
odpojit, což zdroj zpráv nijak neovlivní &ndash; ten bude posílat zprávy
nezávisle na tom, kdo je přijímá.</i></p>

<a href="https://www.root.cz/obrazek/662312/"><img src="https://i.iinfo.cz/images/82/nats-jetstream-1-2-prev.png" class="image-662312" data-prev-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-2-prev.png" data-prev-width="370" data-prev-height="165" data-large-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-2-large.png" data-large-width="720" data-large-height="321" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="370" height="165" /></a>
<p><i>Obrázek 2: Počet producentů není nijak omezen, takže se na strategii
PUB-SUB můžeme dívat i jako na klasický message-bus.</i></p>

<a href="https://www.root.cz/obrazek/662313/"><img src="https://i.iinfo.cz/images/82/nats-jetstream-1-3-prev.png" class="image-662313" data-prev-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-3-prev.png" data-prev-width="370" data-prev-height="184" data-large-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-3-large.png" data-large-width="720" data-large-height="357" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="370" height="184" /></a>
<p><i>Obrázek 3: Strategie PUSH-PULL je založena na použití fronty. Producent
pošle zprávu message brokerovi, který ji uloží do fronty (každá fronta je
pojmenovaná, resp.&nbsp;přesněji řečeno každé téma je reprezentované frontou),
konzumenti se mohou k frontě (frontám) připojit a zprávy přečíst.</i></p>

<a href="https://www.root.cz/obrazek/662314/"><img src="https://i.iinfo.cz/images/82/nats-jetstream-1-4-prev.png" class="image-662314" data-prev-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-4-prev.png" data-prev-width="370" data-prev-height="186" data-large-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-4-large.png" data-large-width="720" data-large-height="362" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="370" height="186" /></a>
<p><i>Obrázek 4: U strategie PUSH-PULL je možné zvolit, že všichni konzumenti
dostanou stejné zprávy (a ideálně i ve stejném pořadí).</i></p>

<a href="https://www.root.cz/obrazek/662315/"><img src="https://i.iinfo.cz/images/82/nats-jetstream-1-5-prev.png" class="image-662315" data-prev-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-5-prev.png" data-prev-width="370" data-prev-height="179" data-large-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-5-large.png" data-large-width="720" data-large-height="347" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="370" height="179" /></a>
<p><i>Obrázek 5: V tomto případě je konfigurace odlišná: zpráva se doručí jen
jedinému konzumentovi. Pokud se k frontě připojí větší množství konzumentů, je
typicky použit algoritmus round-robin pro (polo)spravedlivé rozložení
zátěže.</i></p>

<a href="https://www.root.cz/obrazek/662316/"><img src="https://i.iinfo.cz/images/82/nats-jetstream-1-6-prev.png" class="image-662316" data-prev-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-6-prev.png" data-prev-width="370" data-prev-height="165" data-large-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-6-large.png" data-large-width="720" data-large-height="321" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="370" height="165" /></a>
<p><i>Obrázek 6: Další velmi často používaná komunikační strategie se nazývá
Request-Response nebo zkráceně REQ-REP popř. pouze REQREP. Při použití této
strategie spolu komunikují dva typy uzlů &ndash; server a teoreticky neomezené
množství klientů. Server přijímá požadavky (request) a odpovídá na ně
(response), přičemž je možné, aby požadavky posílalo několik klientů (a jeden
klient naopak může v případě potřeby posílat požadavky více serverům).</i></p>

<a href="https://www.root.cz/obrazek/662317/"><img src="https://i.iinfo.cz/images/82/nats-jetstream-1-7-prev.png" class="image-662317" data-prev-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-7-prev.png" data-prev-width="370" data-prev-height="187" data-large-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-7-large.png" data-large-width="720" data-large-height="364" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="370" height="187" /></a>
<p><i>Obrázek 7: Nově je díky technologii JetStream podporován i streaming,
jenž byl zpopularizován především Kafkou. JetStream podporuje dva typy
připojení konzumentů. Zde je naznačeno připojení typu PUSH-PUSH, kdy jsou
zprávy posílány konzumentovi serverem. Konzument tedy o zprávy nemusí
explicitně žádat, pouze se stačí připojit k&nbsp;danému tématu. Indexy
naposledy přijatých zpráv jsou (resp.&nbsp;mohou být) uloženy na
serveru.</i></p>

<a href="https://www.root.cz/obrazek/662318/"><img src="https://i.iinfo.cz/images/82/nats-jetstream-1-8-prev.png" class="image-662318" data-prev-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-8-prev.png" data-prev-width="370" data-prev-height="190" data-large-filename="https://i.iinfo.cz/images/82/nats-jetstream-1-8-large.png" data-large-width="720" data-large-height="371" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="370" height="190" /></a>
<p><i>Obrázek 8: Alternativou k&nbsp;předchozí strategii je koncept PUSH-PULL,
v&nbsp;němž jednotliví konzumenti explicitně žádají o zprávy server, a to ve
chvíli, kdy jsou připraveni na příjem zprávy. Stále se však jedná o klasický
streaming, tedy existuje zde možnost &bdquo;přehrání&ldquo; starších
zpráv.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace NATS serveru</h2>

<p>Lokální instalace NATS serveru je skutečně triviální, protože se jedná o
jediný binární (přímo spustitelný) soubor, který navíc nevyžaduje ani žádnou
konfiguraci (samozřejmě že je možné server v&nbsp;případě potřeby
nakonfigurovat, ovšem bude funkční i bez konfigurace).</p>

<p>Nejprve je nutné ze stránky <a
href="https://github.com/nats-io/nats-server/releases/tag/v2.9.0">https://github.com/nats-io/nats-server/releases/tag/v2.9.0</a>
stáhnout archiv s&nbsp;NATS serverem. Vzhledem k&nbsp;tomu, že se jedná o
nativní aplikaci, musíme vybrat archiv pro danou platformu (v&nbsp;mém případě
amd64/x86-64):</p>

<pre>
$ <strong>wget https://github.com/nats-io/nats-server/releases/download/v2.9.0/nats-server-v2.9.0-linux-amd64.tar.gz</strong>
&nbsp;
--2022-09-18 17:47:57--  https://github.com/nats-io/nats-server/releases/download/v2.9.0/nats-server-v2.9.0-linux-amd64.tar.gz
...
...
...
2022-09-18 17:47:59 (3.78 MB/s) - ‘nats-server-v2.9.0-linux-amd64.tar.gz’ saved [4898804/4898804]
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že velikost archivu není
na dnešní poměry nijak velká.</div></p>

<p>Dále právě stažený archiv běžným způsobem rozbalíme:</p>

<pre>
$ <strong>tar xvfz nats-server-v2.9.0-linux-amd64.tar.gz</strong>
&nbsp;
nats-server-v2.9.0-linux-amd64/LICENSE
nats-server-v2.9.0-linux-amd64/README.md
nats-server-v2.9.0-linux-amd64/nats-server
</pre>

<p>Přesuneme se do vytvořeného adresáře:</p>

<pre>
$ <strong>cd nats-server-v2.9.0-linux-amd64</strong>
</pre>

<p>A prozkoumáme jeho obsah:</p>

<pre>
$ <strong>ls -la</strong>
&nbsp;
total 12044
drwxrwxr-x. 2 ptisnovs ptisnovs      100 Sep 18 17:48 .
drwxrwxrwt. 8 root     root          180 Sep 18 17:48 ..
-rw-rw-r--. 1 ptisnovs ptisnovs    11357 Sep  9 16:49 LICENSE
-rwxrwxr-x. 1 ptisnovs ptisnovs 12315116 Sep  9 16:51 nats-server
-rw-rw-r--. 1 ptisnovs ptisnovs     3622 Sep  9 16:49 README.md
</pre>

<p><div class="rs-tip-major">Poznámka: opět platí, že velikost binárního
souboru není tak ohromující, zvláště když si uvědomíme, že je použito statické
linkování (a tedy tento binární soubor má jen minimální závislosti).</div></p>

<p>Pro jistotu se přesvědčíme, že server lze spustit:</p>

<pre>
$ <strong>./nats-server --version</strong>
&nbsp;
nats-server: v2.9.0
</pre>

<p>A spustíme ho (což je operace, která je prakticky okamžitá):</p>

<pre>
$ <strong>./nats-server </strong>
&nbsp;
[13644] 2022/09/18 19:05:37.697707 [INF] Starting nats-server
[13644] 2022/09/18 19:05:37.697822 [INF]   Version:  2.9.0
[13644] 2022/09/18 19:05:37.697825 [INF]   Git:      [517d9b3]
[13644] 2022/09/18 19:05:37.697832 [INF]   Name:     NCVERYFIQFOUACDK6AF7QR7VXMPBQFSAWXJFI2M3PAPYU3DRRWGCKISG
[13644] 2022/09/18 19:05:37.697834 [INF]   ID:       NCVERYFIQFOUACDK6AF7QR7VXMPBQFSAWXJFI2M3PAPYU3DRRWGCKISG
[13644] 2022/09/18 19:05:37.698641 [INF] Listening for client connections on 0.0.0.0:4222
[13644] 2022/09/18 19:05:37.698979 [INF] Server is ready
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace CLI klienta a současně i vývojového serveru</h2>

<p>Pro komunikaci s&nbsp;NATS serverem dnes použijeme CLI klienta (tedy
aplikaci ovládanou z&nbsp;příkazového řádku), pomocí níž budeme vytvářet témata
a streamy, produkovat zprávy, přijímat zprávy a současně i sledovat stav
serveru. CLI klient je opět nativní aplikací, kterou lze získat
z&nbsp;repositáře dostupného na adrese <a
href="https://github.com/nats-io/natscli">https://github.com/nats-io/natscli</a>.</p>

<p>Podobně jako v&nbsp;případě serveru, i nyní stáhneme archiv s&nbsp;aplikací
určený pro námi používanou platformu:</p>

<pre>
$ <strong>wget https://github.com/nats-io/natscli/releases/download/v0.0.34/nats-0.0.34-linux-amd64.zip</strong>
...
...
...
2022-09-18 17:55:30 (4.53 MB/s) - ‘nats-0.0.34-linux-amd64.zip’ saved [7827956/7827956]
</pre>

<p>Archiv rozbalíme:</p>

<pre>
$ <strong>unzip nats-0.0.34-linux-amd64.zip</strong>
&nbsp;
Archive:  nats-0.0.34-linux-amd64.zip
  inflating: nats-0.0.34-linux-amd64/LICENSE
  inflating: nats-0.0.34-linux-amd64/README.md
  inflating: nats-0.0.34-linux-amd64/nats
</pre>

<p>Přejdeme do adresáře s&nbsp;rozbaleným klientem:</p>

<pre>
$ <strong>cd nats-0.0.34-linux-amd64</strong>
</pre>

<p>A podíváme se, jaké soubory se rozbalily:</p>

<pre>
$ <strong>ls -la</strong>
&nbsp;
total 19972
drwxrwxr-x.  2 ptisnovs ptisnovs      100 Sep 18 17:55 .
drwxrwxrwt. 10 root     root          220 Sep 18 17:55 ..
-rw-r--r--.  1 ptisnovs ptisnovs    11357 Apr  2 20:40 LICENSE
-rwxr-xr-x.  1 ptisnovs ptisnovs 20414464 Sep  9 17:09 nats
-rw-r--r--.  1 ptisnovs ptisnovs    24502 Aug 19 15:04 README.md
</pre>

<p><div class="rs-tip-major">Poznámka: binární soubor s&nbsp;klientem je
poněkud paradoxně větší, než samotný server. Je tomu tak z&nbsp;toho důvodu, že
klient obsahuje <strong>i</strong> server, což si ostatně vyzkoušíme
v&nbsp;dalších příkladech.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Spuštění vývojového serveru</h2>

<p>Spuštění právě nainstalovaného NATS serveru ve vývojovém režimu je
triviální. Pouze postačuje z&nbsp;adresáře, do kterého byl CLI klient rozbalen,
spustit příkaz:</p>

<pre>
$ <strong>./nats server run</strong>
&nbsp;
Starting local development NATS Server instance: nats_development
&nbsp;
        User Credentials: User: local   Password: WTJUCsUpDZIASz89c0I1F5HSeDWjmzMz Context: nats_development
     Service Credentials: User: service Password: HURHd7OEFuijnAwH9IwacQGhMyaK2FJs Context: nats_development_service
      System Credentials: User: system  Password: q0YT97I9TXpyUgz2bLSoTwenh5TPZF0t Context: nats_development_system
  Extending Demo Network: false
   Extending Remote NATS: false
                     URL: nats://0.0.0.0:44853
           Clean on Exit: false
&nbsp;
&nbsp;
NOTE: This is not a supported way to run a production NATS Server, view documentation
      at https://docs.nats.io/running-a-nats-service/introduction for production use.
&nbsp;
[9305] [INF] Starting nats-server
[9305] [INF]   Version:  2.9.0
[9305] [INF]   Git:      [not set]
[9305] [INF]   Name:     nats_development
[9305] [INF]   ID:       NBQMRLOETYHYXZJKGBKPXOXGPSWH6IOCVXYAGJYPZ5AL4VSO2QAAIR57
[9305] [INF] Using configuration file: /tmp/ramdisk/nats-server-run-2951373316.cfg
[9305] [INF] Listening for client connections on 0.0.0.0:44853
[9305] [INF] Server is ready
</pre>

<p><div class="rs-tip-major">Poznámka: samotné spuštění je velmi rychlé,
z&nbsp;pohledu uživatele prakticky okamžité.</div></p>

<p>V&nbsp;dalším textu budeme využívat technologii <i>JetStream</i>. Tu je
nutné explicitně povolit:</p>

<pre>
$ <strong>./nats server run --jetstream</strong>
&nbsp;
Starting local development NATS Server instance: nats_development
&nbsp;
        User Credentials: User: local   Password: WTJUCsUpDZIASz89c0I1F5HSeDWjmzMz Context: nats_development
     Service Credentials: User: service Password: HURHd7OEFuijnAwH9IwacQGhMyaK2FJs Context: nats_development_service
      System Credentials: User: system  Password: q0YT97I9TXpyUgz2bLSoTwenh5TPZF0t Context: nats_development_system
  Extending Demo Network: false
   Extending Remote NATS: false
                     URL: nats://0.0.0.0:44853
           Clean on Exit: false
&nbsp;
&nbsp;
NOTE: This is not a supported way to run a production NATS Server, view documentation
      at https://docs.nats.io/running-a-nats-service/introduction for production use.
&nbsp;
[9332] [INF] Starting nats-server
[9332] [INF]   Version:  2.9.0
[9332] [INF]   Git:      [not set]
[9332] [INF]   Name:     nats_development
[9332] [INF]   Node:     HhEiCaYr
[9332] [INF]   ID:       NBVG2F5TWP5N6UY3DVDYT7U6G7JD5CNBT7RX5X4QEZYE4X32QT6CENOZ
[9332] [INF] Using configuration file: /tmp/ramdisk/nats-server-run-3289015964.cfg
[9332] [INF] Starting JetStream
[9332] [INF]     _ ___ _____ ___ _____ ___ ___   _   __  __
[9332] [INF]  _ | | __|_   _/ __|_   _| _ \ __| /_\ |  \/  |
[9332] [INF] | || | _|  | | \__ \ | | |   / _| / _ \| |\/| |
[9332] [INF]  \__/|___| |_| |___/ |_| |_|_\___/_/ \_\_|  |_|
[9332] [INF]
[9332] [INF]          https://docs.nats.io/jetstream
[9332] [INF]
[9332] [INF] ---------------- JETSTREAM ----------------
[9332] [INF]   Max Memory:      11.33 GB
[9332] [INF]   Max Storage:     60.84 GB
[9332] [INF]   Store Directory: "/home/ptisnovs/.local/share/nats/nats_development/jetstream"
[9332] [INF] -------------------------------------------
[9332] [INF] Listening for client connections on 0.0.0.0:44853
[9332] [INF] Server is ready
</pre>

<p><div class="rs-tip-major">Poznámka: jak nás samotný server správně
upozorňuje, jedná se o variantu serveru určeného jen pro vývojové prostředí.
Jak spustit server v&nbsp;prostředí produkčním si řekneme příště. Pro začátek
postačuje přejít do adresáře se serverem
(<strong>nats-server-v2.9.0-linux-amd64</strong>) a odtud spustit
příkaz:</div></p>

<pre>
$ <strong>./nats-server --jetstream</strong>
</pre>

<p>Povšimněte si, že v&nbsp;tomto případě se již nevypíše žádné varování, ovšem
ani žádná hesla atd.:</p>

<pre>
[32528] 2022/09/21 08:15:29.778802 [INF] Starting nats-server
[32528] 2022/09/21 08:15:29.778849 [INF]   Version:  2.9.0
[32528] 2022/09/21 08:15:29.778852 [INF]   Git:      [517d9b3]
[32528] 2022/09/21 08:15:29.778856 [INF]   Name:     ND4O2ZQS6XGKN5J4ORYAML2TSG2HTLAPKEHQWTCJMBS5UFXIZRRC2HIE
[32528] 2022/09/21 08:15:29.778860 [INF]   Node:     NmzhvZB9
[32528] 2022/09/21 08:15:29.778862 [INF]   ID:       ND4O2ZQS6XGKN5J4ORYAML2TSG2HTLAPKEHQWTCJMBS5UFXIZRRC2HIE
[32528] 2022/09/21 08:15:29.779350 [INF] Starting JetStream
[32528] 2022/09/21 08:15:29.779614 [INF]     _ ___ _____ ___ _____ ___ ___   _   __  __
[32528] 2022/09/21 08:15:29.779621 [INF]  _ | | __|_   _/ __|_   _| _ \ __| /_\ |  \/  |
[32528] 2022/09/21 08:15:29.779623 [INF] | || | _|  | | \__ \ | | |   / _| / _ \| |\/| |
[32528] 2022/09/21 08:15:29.779625 [INF]  \__/|___| |_| |___/ |_| |_|_\___/_/ \_\_|  |_|
[32528] 2022/09/21 08:15:29.779628 [INF] 
[32528] 2022/09/21 08:15:29.779630 [INF]          https://docs.nats.io/jetstream
[32528] 2022/09/21 08:15:29.779632 [INF] 
[32528] 2022/09/21 08:15:29.779634 [INF] ---------------- JETSTREAM ----------------
[32528] 2022/09/21 08:15:29.779638 [INF]   Max Memory:      11.33 GB
[32528] 2022/09/21 08:15:29.779642 [INF]   Max Storage:     725.26 MB
[32528] 2022/09/21 08:15:29.779644 [INF]   Store Directory: "/tmp/ramdisk/nats/jetstream"
[32528] 2022/09/21 08:15:29.779647 [INF] -------------------------------------------
[32528] 2022/09/21 08:15:29.780203 [INF] Listening for client connections on 0.0.0.0:4222
[32528] 2022/09/21 08:15:29.780593 [INF] Server is ready
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nastavení kontextu pro CLI klienta</h2>

<p>Z&nbsp;terminálu, z&nbsp;něhož budeme spouštět producenty a konzumenty
zpráv, popř.&nbsp;vytvářet streamy atd., je nutné specifikovat kontext, což
současně vede k&nbsp;nastavení hesla. Při spuštění serveru byly vytvořeny tři
kontexty nazvané <strong>nats_development</strong>,
<strong>nats_development_service</strong> a
<strong>nats_development_system</strong>. Použijeme první z&nbsp;těchto
kontextů:</p>

<pre>
$ <strong>./nats context select nats_development</strong>
&nbsp;
NATS Configuration Context "nats_development"
&nbsp;
      Description: Local user access for NATS Development instance
      Server URLs: nats://0.0.0.0:44853
         Username: local
         Password: *********
             Path: /home/ptisnovs/.config/nats/context/nats_development.json
</pre>

<p><div class="rs-tip-major">Poznámka: od této chvíle budeme všechny dále
uvedené příkazy spouštět v&nbsp;rámci tohoto terminálu.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vytvoření nového streamu</h2>

<p>V&nbsp;této kapitole si ukážeme, jak lze z&nbsp;příkazové řádky vytvořit
nový stream. Nejprve se přesvědčme o tom, že žádný stream v&nbsp;daném okamžiku
neexistuje:</p>

<pre>
$ <strong>./nats stream ls</strong>
&nbsp;
No Streams defined
</pre>

<p>Stav streamů můžeme sledovat neustále, například tímto příkazem:</p>

<pre>
$ <strong>watch ./nats stream ls</strong>
</pre>

<p>Stream se vytvoří příkazem <strong>stream add</strong>, kterému můžeme, ale
také nemusíme předat další parametry:</p>

<pre>
$ <strong>./nats stream add</strong>
</pre>

<p>V&nbsp;případě, že žádné další parametry nezadáme, bude se na ně klient
postupně dotazovat &ndash; což je podle mého názoru zcela nejlepší chování
aplikace ovládané z&nbsp;příkazového řádku (mnohem lepší, než se učit či
opisovat desítku přepínačů, které se použijí jednou za rok). Nejdůležitějšími
parametry je jméno streamu (použijeme dále) a taktéž téma (<i>subject</i>),
které se obecně skládá ze slov oddělených tečkami. Namísto slova lze použít
hvězdičku (jedná se o <i>glob</i>, nikoli o regulární výraz!):</p>

<pre>
? Stream Name foo
? Subjects foo.*
? Storage memory
? Replication 1
? Retention Policy Limits
? Discard Policy Old
? Stream Messages Limit -1
? Per Subject Messages Limit -1
? Total Stream Size -1
? Message TTL -1
? Max Message Size -1
? Duplicate tracking time window 2m0s
? Allow message Roll-ups No
? Allow message deletion Yes
? Allow purging subjects or the entire stream (Y/n)
</pre>

<p><div class="rs-tip-major">Poznámka: další parametry si podrobněji popíšeme
příště.</div></p>

<p>Stream byl vytvořen s&nbsp;následujícími vlastnostmi:</p>

<pre>
Stream foo was created
&nbsp;
Information for Stream foo created 2022-09-18 18:04:48
&nbsp;
             Subjects: foo.*
             Replicas: 1
              Storage: Memory
&nbsp;
Options:
&nbsp;
            Retention: Limits
     Acknowledgements: true
       Discard Policy: Old
     Duplicate Window: 2m0s
    Allows Msg Delete: true
         Allows Purge: true
       Allows Rollups: false
&nbsp;
Limits:
&nbsp;
     Maximum Messages: unlimited
  Maximum Per Subject: unlimited
        Maximum Bytes: unlimited
          Maximum Age: unlimited
 Maximum Message Size: unlimited
    Maximum Consumers: unlimited
&nbsp;
&nbsp;
State:
&nbsp;
             Messages: 0
                Bytes: 0 B
             FirstSeq: 0
              LastSeq: 0
     Active Consumers: 0
</pre>

<p>Příkazem <strong>stream ls</strong> se můžeme přesvědčit o tom, zda byl
stream skutečně vytvořen:</p>

<pre>
$ <strong>./nats stream ls</strong>
&nbsp;
╭───────────────────────────────────────────────────────────────────────────╮
│                                  Streams                                  │
├──────┬─────────────┬─────────────────────┬──────────┬──────┬──────────────┤
│ Name │ Description │ Created             │ Messages │ Size │ Last Message │
├──────┼─────────────┼─────────────────────┼──────────┼──────┼──────────────┤
│ foo  │             │ 2022-09-18 18:04:48 │ 0        │ 0 B  │ never        │
╰──────┴─────────────┴─────────────────────┴──────────┴──────┴──────────────╯
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Publikace zprávy nebo většího množství zpráv z&nbsp;příkazové řádky</h2>

<p>Publikace zprávy z&nbsp;příkazové řádky je velmi jednoduchou operací.
Použijeme příkaz <strong>pub</strong>, za nímž zadáme jméno tématu
&bdquo;foo.x&ldquo; (tedy konkrétní jméno, nikoli s&nbsp;hvězdičkou) i vlastní
zprávu, která může být v&nbsp;nejjednodušším případě pouze řetězcem:</p>

<pre>
$ <strong>./nats pub foo.x "test"</strong>
&nbsp;
18:06:11 Published 4 bytes to "foo.x"
</pre>

<p>Podívejme se nyní, jestli se zpráva skutečně uložila do příslušného
streamu:</p>

<pre>
$ <strong>./nats stream ls</strong>
&nbsp;
╭───────────────────────────────────────────────────────────────────────────╮
│                                  Streams                                  │
├──────┬─────────────┬─────────────────────┬──────────┬──────┬──────────────┤
│ Name │ Description │ Created             │ Messages │ Size │ Last Message │
├──────┼─────────────┼─────────────────────┼──────────┼──────┼──────────────┤
│ foo  │             │ 2022-09-18 18:04:48 │ 1        │ 25 B │ 18.87s       │
╰──────┴─────────────┴─────────────────────┴──────────┴──────┴──────────────╯
</pre>

<p>NATS nám dokonce umožňuje publikovat větší množství zpráv, přičemž každá
z&nbsp;těchto zpráv může mít odlišný obsah. Povšimněte si, že tělo zprávy je
vlastně šablonou:</p>

<pre>
$ <strong>./nats pub foo.x "Message #{{.Count}}" --count 100</strong>
&nbsp;
100 / 100 [======================================================]    0s
</pre>

<p>Opět se podívejme na obsah streamů:</p>

<pre>
$ <strong>./nats stream ls</strong>
&nbsp;
╭──────────────────────────────────────────────────────────────────────────────╮
│                                   Streams                                    │
├──────┬─────────────┬─────────────────────┬──────────┬─────────┬──────────────┤
│ Name │ Description │ Created             │ Messages │ Size    │ Last Message │
├──────┼─────────────┼─────────────────────┼──────────┼─────────┼──────────────┤
│ foo  │             │ 2022-09-18 18:04:48 │ 101      │ 3.1 KiB │ 32.54s       │
╰──────┴─────────────┴─────────────────────┴──────────┴─────────┴──────────────╯
</pre>

<p>A nakonec přidejme do streamu dalších sto zpráv, tentokrát ovšem
s&nbsp;tématem &bdquo;foo.y&ldquo; a nikoli &bdquo;foo.x&ldquo;:</p>

<pre>
$ <strong>./nats pub foo.y "Message #{{.Count}}" --count 100</strong>
&nbsp;
100 / 100 [======================================================]    0s
&nbsp;
$ <strong>./nats stream ls</strong>
&nbsp;
╭──────────────────────────────────────────────────────────────────────────────╮
│                                   Streams                                    │
├──────┬─────────────┬─────────────────────┬──────────┬─────────┬──────────────┤
│ Name │ Description │ Created             │ Messages │ Size    │ Last Message │
├──────┼─────────────┼─────────────────────┼──────────┼─────────┼──────────────┤
│ foo  │             │ 2022-09-18 18:04:48 │ 201      │ 6.3 KiB │ 1.61s        │
╰──────┴─────────────┴─────────────────────┴──────────┴─────────┴──────────────╯
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přečtení zpráv či zprávy z&nbsp;vybraného streamu</h2>

<p>Konzument zpráv se spouští příkazem <strong>sub</strong>, kterému navíc
musíme předat buď jméno streamu nebo jméno tématu. Zkusme nejprve přečíst
všechny zprávy ze streamu:</p>

<pre>
$ <strong>./nats sub --stream foo</strong>
&nbsp;
[#1] Received JetStream message: stream: foo seq 1 / subject: foo.x / time: 2022-09-18T18:06:11+02:00
test
&nbsp;
[#2] Received JetStream message: stream: foo seq 2 / subject: foo.x / time: 2022-09-18T18:07:08+02:00
Message #1
&nbsp;
[#3] Received JetStream message: stream: foo seq 3 / subject: foo.x / time: 2022-09-18T18:07:08+02:00
Message #2
&nbsp;
[#4] Received JetStream message: stream: foo seq 4 / subject: foo.x / time: 2022-09-18T18:07:08+02:00
Message #3
&nbsp;
...
...
...
&nbsp;
[#199] Received JetStream message: stream: foo seq 199 / subject: foo.y / time: 2022-09-18T18:08:00+02:00
Message #98
&nbsp;
[#200] Received JetStream message: stream: foo seq 200 / subject: foo.y / time: 2022-09-18T18:08:00+02:00
Message #99
&nbsp;
[#201] Received JetStream message: stream: foo seq 201 / subject: foo.y / time: 2022-09-18T18:08:00+02:00
Message #100
</pre>

<p><div class="rs-tip-major">Poznámka: přečetlo se tedy celkem 201 zpráv, což
zcela odpovídá stavu streamu (viz též <a href="#k08">předchozí
kapitolu</a>).</div></p>

<p>Přečíst všechny zprávy (bez ohledu na aktuální hodnotu offsetu) můžeme tímto
příkazem:</p>

<pre>
$ <strong>./nats sub --stream foo --all</strong>
</pre>

<p>Naopak čekání pouze na nové zprávy zajistí příkaz:</p>

<pre>
$ <strong>./nats sub --stream foo --new</strong>
&nbsp;
18:11:24 Subscribing to JetStream Stream holding messages with subject foo.* delivering any new messages received
</pre>

<p>Velmi užitečná je možnost přečíst poslední zprávu ve streamu, samozřejmě za
předpokladu, že stream není prázdný:</p>

<pre>
$ <strong>./nats sub --stream foo --last</strong>
&nbsp;
18:11:47 Subscribing to JetStream Stream holding messages with subject foo.* starting with the last message received
[#1] Received JetStream message: stream: foo seq 201 / subject: foo.y / time: 2022-09-18T18:08:00+02:00
Message #100
</pre>

<p>Zadat lze i explicitní offset zprávy, od které se má provést
&bdquo;replay&ldquo;:</p>

<pre>
$ <strong>./nats sub --stream foo --start-sequence=100</strong>
</pre>

<p>Popř.&nbsp;je možné uvést časové razítko zprávy, od které se má začít:</p>

<pre>
$ <strong>./nats sub --stream foo --since DURATION</strong>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Dočasní konzumenti zpráv vs. stálí konzumenti</h2>

<p>Server NATS rozlišuje mezi dočasnými konzumenty a stálými konzumenty
(<i>durable consumers</i>). Pro dočasné konzumenty není nutné si pamatovat
index poslední přečtené a/nebo potvrzené zprávy &ndash; tuto činnost server
plně ponechává na samotných konzumentech zda a jak si uchovají informaci o tom,
o které zprávy budou mít zájem (zde se tedy využívají přepínače uvedené <a
href="#k09">v&nbsp;předchozí kapitole</a>). Naproti tomu se pro stálé
konzumenty pamatuje index poslední přečtené a/nebo potvrzené zprávy, a to přímo
na NATS serveru (není tedy nutné spouštět a udržovat instanci další služby
podobné ZooKeeperu).</p>

<p>Stálý konzument se vytvoří jednoduše &ndash; uvedením přepínače
<strong>--durable</strong>, za nímž následuje jméno tématu a konečně jméno
stálého konzumenta. Po zadání následujícího příkazu se konzument automaticky
spustí:</p>

<pre>
$ <strong>./nats sub --stream foo --durable foo_consumer1</strong>
&nbsp;
[#1] Received JetStream message: stream: foo seq 1 / subject: foo.x / time: 2022-09-19T10:48:08+02:00
Message #1
&nbsp;
[#2] Received JetStream message: stream: foo seq 2 / subject: foo.x / time: 2022-09-19T10:48:08+02:00
Message #2
&nbsp;
[#3] Received JetStream message: stream: foo seq 3 / subject: foo.x / time: 2022-09-19T10:48:08+02:00
Message #3
&nbsp;
[#99] Received JetStream message: stream: foo seq 99 / subject: foo.x / time: 2022-09-19T10:48:08+02:00
Message #99
&nbsp;
[#100] Received JetStream message: stream: foo seq 100 / subject: foo.x / time: 2022-09-19T10:48:08+02:00
Message #100
</pre>

<p>Konzumenta zastavíme klávesou <strong>Ctrl+C</strong>.</p>

<p>Po svém dalším spuštění začne konzument nazvaný &bdquo;consumer_1&ldquo;
číst jen prozatím nezpracované zprávy &ndash; server si tedy zapamatoval index
poslední přečtené zprávy:</p>

<pre>
$ <strong>./nats sub --stream foo --durable foo_consumer_1</strong>
...
...
...
</pre>

<p>Vzhledem k&nbsp;tomu, že stálý konzument je pojmenovaný, lze o něm snadno
získat další informace:</p>

<pre>
$ <strong>./nats consumer info foo foo_consumer_1</strong>
&nbsp;
Information for Consumer foo &gt; foo_consumer_1 created 2022-09-19T10:47:22+02:00
&nbsp;
Configuration:
&nbsp;
        Durable Name: foo_consumer_1
    Delivery Subject: _INBOX.1AZwC1SLqhNK2OzZ8em644
      Deliver Policy: All
          Ack Policy: None
       Replay Policy: Instant
      Idle Heartbeat: 5.00s
        Flow Control: true
&nbsp;
State:
&nbsp;
   Last Delivered Message: Consumer sequence: 100 Stream sequence: 100 Last delivery: 8m5s ago
     Unprocessed Messages: 10
          Active Interest: No interest
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si především informace o
poslední doručené zprávě. Jedná se o prakticky jediný stav konzumenta, který si
musí server dobře zapamatovat.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Získání podrobnějších operací a vybraném streamu</h2>

<p>O libovolném streamu lze získat podrobnější informace zadáním příkazu
<strong>stream info</strong>, kterému se předá jméno příslušného streamu.
Podívejme se na jednoduchý příklad &ndash; získáme informaci o streamu
&bdquo;foo&ldquo;:</p>

<pre>
$ <strong>./nats stream info foo</strong>
&nbsp;
Information for Stream foo created 2022-09-19 10:46:29
&nbsp;
             Subjects: foo.*
             Replicas: 1
              Storage: Memory
&nbsp;
Options:
&nbsp;
            Retention: Limits
     Acknowledgements: true
       Discard Policy: Old
     Duplicate Window: 2m0s
    Allows Msg Delete: true
         Allows Purge: true
       Allows Rollups: false
&nbsp;
Limits:
&nbsp;
     Maximum Messages: unlimited
  Maximum Per Subject: unlimited
        Maximum Bytes: unlimited
          Maximum Age: unlimited
 Maximum Message Size: unlimited
    Maximum Consumers: unlimited
&nbsp;
&nbsp;
State:
&nbsp;
             Messages: 100
                Bytes: 3.1 KiB
             FirstSeq: 1 @ 2022-09-19T08:48:08 UTC
              LastSeq: 100 @ 2022-09-19T08:48:08 UTC
     Active Consumers: 1
   Number of Subjects: 1
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že některé z&nbsp;těchto
informací byly vypsány již při vytváření streamu.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Konzumenti explicitně žádající o zprávy</h2>

<p>Ve <a href="#k02">druhé kapitole</a> jsme se zmínili o tom, že streaming
poskytovaný technologií JetStream nabízí možnost využití dvou komunikačních
strategií &ndash; PUSH-PUSH (zprávy konzumentovi posílá server) nebo PUSH-PULL
(zprávy si explicitně vyzvedává klient). První z&nbsp;těchto strategií je
implicitní, druhou je nutné zvolit při konfiguraci nového konzumenta, a to
<i>nevyplněním</i> položky <strong>Delivery target</strong>:</p>

<pre>
$ <strong>./nats consumer create</strong>
&nbsp;
? Consumer name foo_consumer_2
? <strong>Delivery target (empty for Pull Consumers) </strong>
? Start policy (all, new, last, subject, 1h, msg sequence) all
? Acknowledgement policy explicit
? Replay policy instant
? Filter Stream by subject (blank for all) 
? Maximum Allowed Deliveries -1
? Maximum Acknowledgements Pending 0
? Deliver headers only without bodies No
? Add a Retry Backoff Policy No
? Select a Stream foo
Information for Consumer foo &gt; foo_consumer_2 created 2022-09-19T10:54:51+02:00
&nbsp;
Configuration:
&nbsp;
        Durable Name: foo_consumer_2
           <strong>Pull Mode: true</strong>
      Deliver Policy: All
          Ack Policy: Explicit
            Ack Wait: 30s
       Replay Policy: Instant
     Max Ack Pending: 1,000
   Max Waiting Pulls: 512
&nbsp;
State:
&nbsp;
   Last Delivered Message: Consumer sequence: 0 Stream sequence: 0
     Acknowledgment floor: Consumer sequence: 0 Stream sequence: 0
         Outstanding Acks: 0 out of maximum 1,000
     Redelivered Messages: 0
     Unprocessed Messages: 100
            Waiting Pulls: 0 of maximum 512
</pre>

<p>Jaká komunikační strategie je pro zvoleného konzumenta nakonfigurována, se
dozvíme i při zadání nám již známého příkazu <strong>consumer
info</strong> (viz zvýrazněný řádek):</p>

<pre>
$ <strong>./nats consumer info foo foo_consumer_2</strong>
&nbsp;
Information for Consumer foo &gt; foo_consumer_2 created 2022-09-19T10:54:51+02:00
&nbsp;
Configuration:
&nbsp;
        Durable Name: foo_consumer_2
           <strong>Pull Mode: true</strong>
      Deliver Policy: All
          Ack Policy: Explicit
            Ack Wait: 30s
       Replay Policy: Instant
     Max Ack Pending: 1,000
   Max Waiting Pulls: 512
&nbsp;
State:
&nbsp;
   Last Delivered Message: Consumer sequence: 0 Stream sequence: 0
     Acknowledgment floor: Consumer sequence: 0 Stream sequence: 0
         Outstanding Acks: 0 out of maximum 1,000
     Redelivered Messages: 0
     Unprocessed Messages: 100
            Waiting Pulls: 0 of maximum 512
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Manuální potvrzení zkonzumované zprávy konzumentem, další možnosti konzumentů</h2>

<p>Konzumenti zpráv musí nějakým způsobem potvrdit, že zprávu získali
popř.&nbsp;zpracovali. Implicitně je nastaveno automatické potvrzení
<i>doručení</i> zprávy, ovšem to nemusí být v&nbsp;mnoha případech ideální
(samotné doručení zprávy ještě nezaručuje její zpracování). Mnohdy totiž
potřebujeme potvrdit až <i>zpracování</i> zprávy, nejenom její přijetí. Jedná
se o konfiguraci, která může být pro každého konzumenta nastavena odlišně.</p>

<p>Potvrzování zpráv funguje dobře i pro konzumenty spouštěné
z&nbsp;příkazového řádku:</p>

<pre>
$ <strong>./nats consumer next foo foo_consumer_2 --count=1</strong>
&nbsp;
[10:58:11] subj: foo.x / tries: 1 / cons seq: 1 / str seq: 1 / pending: 99
&nbsp;
Message #1
&nbsp;
Acknowledged message
</pre>

<p><div class="rs-tip-major">Poznámka: manuální potvrzování zpráv si ukážeme
později u klientů naprogramovaných v&nbsp;Pythonu a taktéž v&nbsp;Go.</div></p>

<p>Příkaz <strong>nats consumer</strong> ovšem uživatelům nabízí i další volby,
například:</p>

<pre>
usage: nats consumer [&lt;flags&gt;] &lt;command&gt; [&lt;args&gt; ...]
&nbsp;
JetStream Consumer management
&nbsp;
Subcommands:
  consumer ls       List known Consumers
  consumer report   Reports on Consumer statistics
  consumer info     Consumer information
  consumer add      Creates a new Consumer
  consumer edit     Edits the configuration of a consumer
  consumer rm       Removes a Consumer
  consumer copy     Creates a new Consumer based on the configuration of another
  consumer next     Retrieves messages from Pull Consumers without interactive
                    prompts
  consumer sub      Retrieves messages from Consumers
  consumer cluster  Manages a clustered Consumer
&nbsp;
Flags:
  -a, --all  Operate on all streams including system ones
</pre>

<p>Příklad tabulky získané příkazem <strong>nats consumer report</strong>:</p>

<pre>
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│                                      Consumer report for bar with 1 consumers                                       │
├────────────┬──────┬────────────┬──────────┬─────────────┬─────────────┬─────────────┬───────────┬───────────────────┤
│ Consumer   │ Mode │ Ack Policy │ Ack Wait │ Ack Pending │ Redelivered │ Unprocessed │ Ack Floor │ Cluster           │
├────────────┼──────┼────────────┼──────────┼─────────────┼─────────────┼─────────────┼───────────┼───────────────────┤
│ consumer-a │ Pull │ Explicit   │ 30.00s   │ 0           │ 0           │ 0           │ 0         │ nats_development* │
╰────────────┴──────┴────────────┴──────────┴─────────────┴─────────────┴─────────────┴───────────┴───────────────────╯
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Kde jsou uloženy zprávy poslané do témat?</h2>

<p>Podívejme se nyní, kde jsou vlastně uloženy zprávy, jenž jsou posílané do
jednotlivých témat. Zprávy jsou na základě uvedeného tématu rozděleny do
streamů (pro jeden stream může existovat větší množství témat
popř.&nbsp;neomezené množství témat) a pro každý stream je vytvořen zvláštní
podadresář v&nbsp;adresáři zvoleném při spuštění nebo konfiguraci serveru.
Informace o tomto adresáři se vypisuje během spuštění serveru:</p>

<pre>
[31151] [INF]   <strong>Store Directory: "/home/ptisnovs/.local/share/nats/nats_development/jetstream"</strong>
[31151] [INF] -------------------------------------------
[31151] [INF]   Starting restore for stream 'USER &gt; bar'
[31151] [INF]   Restored 20 messages for stream 'USER &gt; bar'
[31151] [INF]   Starting restore for stream 'USER &gt; foo'
[31151] [INF]   Restored 104 messages for stream 'USER &gt; foo'
[31151] [INF]   Recovering 1 consumers for stream - 'USER &gt; bar'
</pre>

<p><div class="rs-tip-major">Poznámka: toto umístění je samozřejmě plně
konfigurovatelné a navíc záleží na tom, kolik replik streamu jsme vyžadovali
při jeho konstrukci.</div></p>

<p>Celý strom s&nbsp;uloženými streamy vypadá takto:</p>

<pre>
└── USER
    └── streams
        ├── bar
        │   ├── meta.inf
        │   ├── meta.sum
        │   ├── msgs
        │   │   ├── 1.blk
        │   │   └── 1.idx
        │   └── obs
        ├── foo
        │   ├── meta.inf
        │   ├── meta.sum
        │   ├── msgs
        │   │   ├── 1.blk
        │   │   └── 1.idx
        │   └── obs
        ├── user-add-operation
        │   ├── meta.inf
        │   ├── meta.sum
        │   ├── msgs
        │   │   ├── 1.blk
        │   │   ├── 1.fss
        │   │   └── 1.idx
        │   └── obs
        └── user-delete-operation
            ├── meta.inf
            ├── meta.sum
            ├── msgs
            │   ├── 1.blk
            │   ├── 1.fss
            │   └── 1.idx
            └── obs
</pre>

<p><div class="rs-tip-major">Poznámka: důležité jsou zejména soubory
<strong>.idx</strong> s&nbsp;indexy a soubory <strong>.blk</strong>
s&nbsp;bloky zpráv.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Komunikace s&nbsp;brokerem NATS z&nbsp;Pythonu</h2>

<p>V&nbsp;rámci navazujících kapitol si ukážeme, jakým způsobem lze realizovat
komunikaci s&nbsp;NATS z&nbsp;Pythonu. V&nbsp;úvodních dvou článcích jsme se
zaměřili na jazyk Go, ovšem jak uvidíme dále, je realizace producentů i
konzumentů zpráv v&nbsp;Pythonu ještě nepatrně jednodušší, zejména
v&nbsp;případě, že využijeme možnosti standardní knihovny <i>asyncio</i> a
nových klíčových slov <strong>async</strong> a <strong>await</strong>, které
byly do Pythonu přidány právě pro podporu práce s&nbsp;korutinami a obecně
asynchronně běžícími úlohami.</p>

<p>Nejprve musíme nainstalovat knihovnu, v&nbsp;níž je realizováno rozhraní
(<i>connector</i>) k&nbsp;NATSu. Instalace této knihovny je snadná, neboť je
dostupná <a href="https://pypi.org/project/nats-py/">přímo na PyPi</a>:</p>

<pre>
$ <strong>pip3 install nats-py</strong>
&nbsp;
Defaulting to user installation because normal site-packages is not writeable
Collecting nats-py
  Downloading nats-py-2.1.7.tar.gz (45 kB)
     |████████████████████████████████| 45 kB 952 kB/s
  Preparing metadata (setup.py) ... done
Building wheels for collected packages: nats-py
  Building wheel for nats-py (setup.py) ... done
  Created wheel for nats-py: filename=nats_py-2.1.7-py3-none-any.whl size=55717 sha256=beedaa208a24cc31490abf3966285f43cf7566967c5cb5be26999133e0f42f28
  Stored in directory: /home/ptisnovs/.cache/pip/wheels/b3/c2/1d/cd05fddafb2d9960a8a748a3cfd4ab1b997cac79bd059a7ba3
Successfully built nats-py
Installing collected packages: nats-py
Successfully installed nats-py-2.1.7
</pre>

<p>Krátké otestování, zda je knihovna skutečně nainstalována:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.8.10 (default, Jun 22 2022, 20:18:18) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import nats
&gt;&gt;&gt; help("nats")
&nbsp;
Help on package nats:
&nbsp;
NAME
    nats
&nbsp;
DESCRIPTION
    # Copyright 2016-2021 The NATS Authors
    # Licensed under the Apache License, Version 2.0 (the "License");
    # you may not use this file except in compliance with the License.
    # You may obtain a copy of the License at
    #
    # http://www.apache.org/licenses/LICENSE-2.0
    #
    # Unless required by applicable law or agreed to in writing, software
    # distributed under the License is distributed on an "AS IS" BASIS,
    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    # See the License for the specific language governing permissions and
    # limitations under the License.
    #
    ...
    ...
    ...
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Připojení k&nbsp;NATS serveru z&nbsp;Pythonu</h2>

<p>Podívejme se nyní na způsob realizace připojení k&nbsp;NATS serveru ze
skriptu, který je naprogramován v&nbsp;Pythonu. Tento skript používá výše
uvedený balíček <strong>nats-py</strong>, jenž je založen na standardní
knihovně <i>asyncio</i>. Samotné navázání spojení je realizováno
<i>korutinou</i> (nikoli tedy standardní funkcí) nazvanou
<strong>connect</strong>. Této korutině je nutné předat jak adresu počítače, na
kterém NATS běží, ale i příslušný port, jméno uživatele a jeho heslo (poslední
dvě hodnoty jsou vypsány samotným serverem při jeho spuštění, odkud je můžeme
snadno zkopírovat). Pokud je spojení navázáno (tedy v&nbsp;případě, že nedojde
k&nbsp;vyhození výjimky), lze spojení ukončit metodou/korutinou nazvanou
<strong>natsConnection.close()</strong>. Vzhledem k&nbsp;tomu, že se volají
asynchronně běžící korutiny, musí být samotná funkce main realizována taktéž
korutinou a zavolána přes <strong>asyncio.run(main())</strong>:</p>

<pre>
import asyncio
import nats
&nbsp;
URL = "192.168.1.34:44853"
NATS_USERNAME = "local"
NATS_PASSWORD = "--password--"
&nbsp;
&nbsp;
async def main():
    print(f"Connecting to NATS at address {URL}")
    nats_connection = await nats.connect(URL, user=NATS_USERNAME, password=NATS_PASSWORD)
    print(f"Connected...{nats_connection}")
&nbsp;
    print("Closing connection")
    await nats_connection.close()
    print("Connection closed")
&nbsp;
&nbsp;
if __name__ == '__main__':
    asyncio.run(main())
</pre>

<p>Vyzkoušejme si nyní použití tohoto skriptu, pochopitelně po zadání
korektního hesla:</p>

<pre>
$ <strong>python3 nats_connection.py</strong>
&nbsp;
Connecting to NATS at address 192.168.1.34:44853
Connected...&lt;nats client v2.1.7&gt;
Closing connection
Connection closed
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Producenti a konzumenti zpráv založení na komunikační strategii PUB-SUB</h2>

<p>Ukažme si nyní, jak snadno je možné v&nbsp;Pythonu realizovat producenty a
konzumenty zpráv posílaných a přijímaných s&nbsp;využitím komunikační strategie
PUB-SUB. Nejdříve si ukažme producenta zpráv, který je až triviálně jednoduchý
&ndash; zprávu po navázání spojení s&nbsp;NATS pošleme korutinou nazvanou
<strong>publish</strong> do vybraného tématu:</p>

<pre>
import asyncio
import nats
&nbsp;
URL = "192.168.1.34:44853"
NATS_USERNAME = "local"
NATS_PASSWORD = "--password--"
&nbsp;
SUBJECT_NAME = "foo"
&nbsp;
&nbsp;
async def main():
    print(f"Connecting to NATS at address {URL}")
    nats_connection = await nats.connect(URL, user=NATS_USERNAME, password=NATS_PASSWORD)
    print("Connected...")
&nbsp;
    print("Publishing message")
    await nats_connection.publish(SUBJECT_NAME, b"Hello from Python!")
    print("Published")
&nbsp;
    print("Closing connection")
    await nats_connection.close()
    print("Connection closed")
&nbsp;
&nbsp;
if __name__ == '__main__':
    asyncio.run(main())
</pre>

<p>Konzument zpráv je jen nepatrně složitější, neboť zprávy se přijímají
v&nbsp;nekonečné smyčce (to pro jednoduchost, jsou totiž i další způsoby, které
například zajistí odpojení od NATS). Povšimněte si, že konzument se musí
nejprve přihlásit k&nbsp;odebírání tématu a teprve poté může zprávy
přijímat:</p>

<pre>
import asyncio
import nats
&nbsp;
URL = "192.168.1.34:44853"
NATS_USERNAME = "local"
NATS_PASSWORD = "--password--"
&nbsp;
SUBJECT_NAME = "foo"
&nbsp;
&nbsp;
async def main():
    print(f"Connecting to NATS at address {URL}")
    nats_connection = await nats.connect(URL, user=NATS_USERNAME, password=NATS_PASSWORD)
    print("Connected...")
&nbsp;
    print(f"Subscribing to stream with name '{SUBJECT_NAME}'")
    sub = await nats_connection.subscribe(SUBJECT_NAME)
    print("Subscribed")
&nbsp;
    print("Waiting for messages")
&nbsp;
    while True:
        message = await sub.next_msg(timeout=100)
        print("Received:", message)
&nbsp;
    await nc.close()
&nbsp;
&nbsp;
if __name__ == '__main__':
    asyncio.run(main())
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Producenti a konzumenti zpráv založení na využití stream processingu</h2>

<p>Zajímavější bude zjistit, jakým způsobem lze realizovat producenty a
konzumenty v&nbsp;případě, kdy budeme chtít zprávy posílat do streamu a posléze
je ze streamu číst resp.&nbsp;&bdquo;přehrávat&ldquo;. V&nbsp;prvním příkladu
je ukázán způsob přečtení informací o vybraných streamech:</p>

<pre>
import asyncio
import nats
from pprint import pprint
&nbsp;
URL = "192.168.1.34:44853"
NATS_USERNAME = "local"
NATS_PASSWORD = "--password--"
&nbsp;
STREAM_NAMES = ["foo", "bar", "baz"]
&nbsp;
&nbsp;
async def main():
    print(f"Connecting to NATS at address {URL}")
    nats_connection = await nats.connect(URL, user=NATS_USERNAME, password=NATS_PASSWORD)
    print("Connected...")
&nbsp;
    print("Retrieving JetStream object")
    jet_stream = nats_connection.jetstream()
    print(f"Retrieved {jet_stream}")
&nbsp;
    for stream_name in STREAM_NAMES:
        print(f"Stream info for stream {stream_name}:")
        print("-" * 40)
&nbsp;
        stream_info = await jet_stream.stream_info(stream_name)
        pprint(stream_info.__dict__)
        print()
&nbsp;
    print("Closing connection")
    await nats_connection.close()
    print("Connection closed")
&nbsp;
&nbsp;
if __name__ == '__main__':
    asyncio.run(main())
</pre>

<p>Ve skutečnosti na mém NATS serveru existují pouze streamy &bdquo;foo&ldquo;
a &bdquo;bar&ldquo;, nikoli již stream &bdquo;baz&ldquo;, což znamená, že při
zjišťování informací o neexistujícím streamu dojde k&nbsp;vyhození výjimky:</p>

<pre>
Connecting to NATS at address 192.168.1.34:44853
Connected...
Retrieving JetStream object
Retrieved &lt;nats.js.client.JetStreamContext object at 0x7faf51cb0940&gt;
&nbsp;
Stream info for stream foo:
----------------------------------------
{'cluster': None,
 'config': StreamConfig(name='foo', description=None, subjects=['foo'], retention='limits', max_consumers=-1, max_msgs=-1, max_bytes=-1, discard='old', max_age=0.0, max_msgs_per_subject=-1, max_msg_size=-1, storage='memory', num_replicas=1, no_ack=False, template_owner=None, duplicate_window=120000000000, placement=None, mirror=None, sources=None, sealed=False, deny_delete=False, deny_purge=False, allow_rollup_hdrs=False),
 'did_create': None,
 'mirror': None,
 'sources': None,
 'state': StreamState(messages=0, bytes=0, first_seq=0, last_seq=0, consumer_count=0, deleted=None, num_deleted=None, lost=None)}
&nbsp;
Stream info for stream bar:
----------------------------------------
{'cluster': None,
 'config': StreamConfig(name='bar', description=None, subjects=['bar'], retention='limits', max_consumers=-1, max_msgs=-1, max_bytes=-1, discard='old', max_age=0.0, max_msgs_per_subject=-1, max_msg_size=-1, storage='file', num_replicas=1, no_ack=False, template_owner=None, duplicate_window=120000000000, placement=None, mirror=None, sources=None, sealed=False, deny_delete=False, deny_purge=False, allow_rollup_hdrs=False),
 'did_create': None,
 'mirror': None,
 'sources': None,
 'state': StreamState(messages=0, bytes=0, first_seq=0, last_seq=0, consumer_count=0, deleted=None, num_deleted=None, lost=None)}
&nbsp;
Stream info for stream baz:
----------------------------------------
Traceback (most recent call last):
  File "stream_info.py", line 37, in <module>
    asyncio.run(main())
  File "/usr/lib/python3.8/asyncio/runners.py", line 44, in run
    return loop.run_until_complete(main)
  File "/usr/lib/python3.8/asyncio/base_events.py", line 616, in run_until_complete
    return future.result()
  File "stream_info.py", line 27, in main
    stream_info = await jet_stream.stream_info(stream_name)
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/nats/js/manager.py", line 71, in stream_info
    resp = await self._api_request(
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/nats/js/manager.py", line 267, in _api_request
    raise APIError.from_error(resp['error'])
  File "/home/ptisnovs/.local/lib/python3.8/site-packages/nats/js/errors.py", line 84, in from_error
    raise NotFoundError(**err)
nats.js.errors.NotFoundError: nats: NotFoundError: code=404 err_code=10059 description='stream not found'
</pre>

<p>Publikace zpráv do zvoleného tématu (subject) je opět přímočará, jak je to
ostatně ukázáno v&nbsp;následujícím demonstračním příkladu. Pouze namísto
korutiny <strong>nats_connection.publish</strong> zavoláme korutinu
<strong>jet_stream.publish</strong>. Povšimněte si, že zpráva je reprezentována
polem bajtů a může tedy obsahovat jakékoli hodnoty:</p>

<pre>
import asyncio
import nats
&nbsp;
URL = "192.168.1.34:44853"
NATS_USERNAME = "local"
NATS_PASSWORD = "--password--"
&nbsp;
SUBJECT_NAME = "bar"
&nbsp;
&nbsp;
async def main():
    print(f"Connecting to NATS at address {URL}")
    nats_connection = await nats.connect(URL, user=NATS_USERNAME, password=NATS_PASSWORD)
    print("Connected...")
&nbsp;
    print("Retrieving JetStream object")
    jet_stream = nats_connection.jetstream()
    print(f"Retrieved {jet_stream}")
&nbsp;
    print("Publishing message to stream")
    ack = await jet_stream.publish(f"{SUBJECT_NAME}", b"Hello from Python!")
    print(f"Published and acked: stream={ack.stream}, sequence={ack.seq}")
&nbsp;
    print("Closing connection")
    await nats_connection.close()
    print("Connection closed")
&nbsp;
&nbsp;
if __name__ == '__main__':
    asyncio.run(main())
</pre>

<p>A konečně se podívejme na konzumenta zpráv uložených do streamu a dostupných
přes zvolené téma. Tento demonstrační příklad je založen na smyčce, ve které se
volá korutina <strong>next_msg</strong>, přičemž se při přijetí zprávy zavolá
korutina <strong>on_message</strong> (jedná se tedy opět o asynchronní
kód):</p>

<pre>
import asyncio
import nats
&nbsp;
URL = "192.168.1.34:44853"
NATS_USERNAME = "local"
NATS_PASSWORD = "--password--"
&nbsp;
SUBJECT_NAME = "bar"
&nbsp;
&nbsp;
async def on_message(message):
    print(f"Received message {message}")
    await message.ack()
&nbsp;
&nbsp;
async def main():
    print(f"Connecting to NATS at address {URL}")
    nats_connection = await nats.connect(URL, user=NATS_USERNAME, password=NATS_PASSWORD)
    print("Connected...")
&nbsp;
    print("Retrieving JetStream object")
    jet_stream = nats_connection.jetstream()
    print(f"Retrieved {jet_stream}")
&nbsp;
    print("Waiting for messages")
    sub = await jet_stream.subscribe(SUBJECT_NAME, cb=on_message)
    while True:
        await sub.next_msg(timeout=1)
&nbsp;
    print("Closing connection")
    await nats_connection.close()
    print("Connection closed")
&nbsp;
&nbsp;
if __name__ == '__main__':
    asyncio.run(main())
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se pouze o zcela základní způsoby
použití. Příště si ukážeme složitější příklady, vylepšenou specifikaci témat
atd.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů naprogramovaných
v&nbsp;programovacím jazyku Go byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce.</p>

<table>
<tr><th>Příklad</th><th>Skript/kód</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>nats_connection.py</td><td>navázání spojení se serverem NATS z&nbsp;Pythonu, posléze ukončení spojení</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/nats_connection.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/nats_connection.py</a></td></tr>
<tr><td> 2</td><td>simple_publisher.py</td><td>publikace zprávy či většího množství zpráv do zvoleného tématu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/simple_publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/simple_publisher.py</a></td></tr>
<tr><td> 3</td><td>simple_subscriber.py</td><td>čtení (konzumace) zpráv ze zvoleného tématu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/simple_subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/simple_subscriber.py</a></td></tr>
<tr><td> 4</td><td>stream_info.py</td><td>informace o trojici streamů (pokud existují)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_info.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_info.py</a></td></tr>
<tr><td> 5</td><td>stream_publisher.py</td><td>producent zpráv do zvoleného tématu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_publisher.py</a></td></tr>
<tr><td> 6</td><td>stream_subscriber_1.py</td><td>nejjednodušší forma konzumenta zpráv</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_1.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_1.py</a></td></tr>
<tr><td> 7</td><td>stream_subscriber_2.py</td><td>korektní reakce konzumenta zpráv na chyby</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_2.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_2.py</a></td></tr>
<tr><td> 8</td><td>stream_subscriber_3.py</td><td>explicitní potvrzování zpráv</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_3.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_3.py</a></td></tr>
<tr><td> 9</td><td>stream_subscriber_4.py</td><td>změna konfigurace konzumenta &ndash; přečtení poslední zprávy ze streamu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_4.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_4.py</a></td></tr>
<tr><td>10</td><td>stream_subscriber_5.py</td><td>změna konfigurace konzumenta &ndash; specifikace offsetu zprávy</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_5.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_5.py</a></td></tr>
<tr><td>11</td><td>stream_subscriber_6.py</td><td>konzument akceptující všechny zprávy ze zvoleného streamu (nepoužívá se téma)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_6.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_6.py</a></td></tr>
<tr><td>12</td><td>stream_subscriber_7.py</td><td>konzument se specifikací jak streamu, tak i konkrétního tématu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_7.py">https://github.com/tisnik/message-queues-examples/blob/master/jetstream-py/stream_subscriber_7.py</a></td></tr>
</table>

<p>Demonstrační příklady uvedené v&nbsp;následující tabulce jsme si již popsali
v&nbsp;článcích <a
href="https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/">Komunikace
s message brokery z programovacího jazyka Go</a>, <a
href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">Použití message
brokeru NATS</a> a <a
href="https://www.root.cz/clanky/nats-streaming-server/">NATS Streaming
Server</a>. Tyto příklady jsou naprogramovány v&nbsp;jazyku Go a (alespoň
prozatím) nepokrývají technologii <i>JetStream</i>.</p>

<table>
<tr><th>Příklad</th><th>Skript/kód</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>publisher.go</td><td>základní varianta producenta zpráv bez kontroly chyb</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/publisher.go</a></td></tr>
<tr><td>1</td><td>consumer.go</td><td>základní varianta konzumenta zpráv bez kontroly chyb</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>publisher.go</td><td>vylepšená verze producenta zpráv s&nbsp;kontrolami a uzavíráním připojení</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/publisher.go</a></td></tr>
<tr><td>2</td><td>consumer.go</td><td>vylepšená verze konzumenta zpráv s&nbsp;kontrolami a uzavíráním připojení</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/publisher.go</a></td></tr>
<tr><td>3</td><td>consumer.go</td><td>konzument přijímající (a přehrávající) všechny zprávy ze zvoleného tématu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu (shodný s&nbsp;předchozím příkladem)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/publisher.go</a></td></tr>
<tr><td>4</td><td>consumer.go</td><td>konzument přijímající zprávy od poslední přijaté zprávy</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu (shodný s&nbsp;předchozím příkladem)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/05-start-at-sequence/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/05-start-at-sequence/publisher.go</a></td></tr>
<tr><td>5</td><td>consumer.go</td><td>konzument, v&nbsp;němž je možné specifikovat pořadí zprávy v&nbsp;sekvenci</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/05-start-at-sequence/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/05-start-at-sequence/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu (shodný s&nbsp;předchozím příkladem)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/06-time-duration/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/06-time-duration/publisher.go</a></td></tr>
<tr><td>6</td><td>consumer.go</td><td>konzument, v&nbsp;němž se specifikuje časový okamžik, od kterého se má zpráva či zprávy přijmout</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/06-time-duration/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/06-time-duration/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu (opět shodný s&nbsp;předchozím příkladem)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/07-durable-subscription/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/07-durable-subscription/publisher.go</a></td></tr>
<tr><td>7</td><td>consumer.go</td><td>konzument využívající tzv.&nbsp;durable subscription popsanou v&nbsp;šestnácté kapitole</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/07-durable-subscription/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/07-durable-subscription/consumer.go</a></td></tr>
</table>


<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>JetStream<br />
<a href="https://docs.nats.io/nats-concepts/jetstream">https://docs.nats.io/nats-concepts/jetstream</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Protocols<br />
<a href="https://docs.nats.io/legacy/stan/streaming/protocol#protocols">https://docs.nats.io/legacy/stan/streaming/protocol#protocols</a>
</li>

<li>NATS Server Clients<br />
<a href="https://docs.nats.io/running-a-nats-service/clients">https://docs.nats.io/running-a-nats-service/clients</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>NATS Clients<br />
<a href="https://nats.io/download/#nats-clients">https://nats.io/download/#nats-clients</a>
</li>

<li>NATS JetStream Enabled Clients<br />
<a href="https://nats.io/download/#nats-jetstream-enabled-clients">https://nats.io/download/#nats-jetstream-enabled-clients</a>
</li>

<li>Move over Kafka! Let's try NATS JetStream<br />
<a href="https://www.youtube.com/watch?v=EJJ2SG-cKyM">https://www.youtube.com/watch?v=EJJ2SG-cKyM</a>
</li>

<li>NATS Jetstream Technical Overview<br />
<a href="https://www.youtube.com/watch?v=w8fc44SmJDw">https://www.youtube.com/watch?v=w8fc44SmJDw</a>
</li>

<li>Using NATS JetStream with Go<br />
<a href="https://www.youtube.com/watch?v=uZ4fzg_eqSw">https://www.youtube.com/watch?v=uZ4fzg_eqSw</a>
</li>

<li>The coolest OSS project you've never heard of: NATS Getting started!<br />
<a href="https://www.youtube.com/watch?v=hjXIUPZ7ArM">https://www.youtube.com/watch?v=hjXIUPZ7ArM</a>
</li>

<li>Komunikace s&nbsp;message brokery z&nbsp;programovacího jazyka Go<br />
<a href="https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/</a>
</li>

<li>Použití message brokeru NATS<br />
<a href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">https://www.root.cz/clanky/pouziti-message-brokeru-nats/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://www.root.cz/clanky/nats-streaming-server/">https://www.root.cz/clanky/nats-streaming-server/</a>
</li>

<li>Microservices: The Rise Of Kafka<br />
<a href="https://movio.co/blog/microservices-rise-kafka/">https://movio.co/blog/microservices-rise-kafka/</a>
</li>

<li>Building a Microservices Ecosystem with Kafka Streams and KSQL<br />
<a href="https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/">https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/</a>
</li>

<li>An introduction to Apache Kafka and microservices communication<br />
<a href="https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63">https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63</a>
</li>

<li>kappa-architecture.com<br />
<a href="http://milinda.pathirage.org/kappa-architecture.com/">http://milinda.pathirage.org/kappa-architecture.com/</a>
</li>

<li>Questioning the Lambda Architecture<br />
<a href="https://www.oreilly.com/ideas/questioning-the-lambda-architecture">https://www.oreilly.com/ideas/questioning-the-lambda-architecture</a>
</li>

<li>Lambda architecture<br />
<a href="https://en.wikipedia.org/wiki/Lambda_architecture">https://en.wikipedia.org/wiki/Lambda_architecture</a>
</li>

<li>Apache Kafka: distribuovaná streamovací platforma<br />
<a href="https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/">https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

