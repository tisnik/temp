<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Sledování činnosti systému Apache Kafka přes JMX i metriky Promethea</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Sledování činnosti systému Apache Kafka přes JMX i metriky Promethea</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Sledování činnosti systému Apache Kafka přes JMX i metriky Promethea</a></p>
<p><a href="#k02">2. Technologie JMX &ndash; Java Management Extension</a></p>
<p><a href="#k03">3. Zobrazení obsahu MBeans nástrojem <strong>jconsole</strong></a></p>
<p><a href="#k04">4. Změna stavu atributů MBeans dostupných přes JMX</a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">7. Nástroj Prometheus</a></p>
<p><a href="#k08">8. Dotazovací jazyk PromQL</a></p>
<p><a href="#k09">9. JMX Exporter &ndash; rozhraní mezi JMX a metrikami Promethea</a></p>
<p><a href="#k10">10. Využití JMX Exporteru v&nbsp;demonstračním příkladu</a></p>
<p><a href="#k11">*** 11. Metriky systému Apache Kafka</a></p>
<p><a href="#k12">*** 12. Metriky samotného brokera</a></p>
<p><a href="#k13">*** 13. Metriky vztažené k&nbsp;producentům</a></p>
<p><a href="#k14">*** 14. Metriky vztažené ke konzumentům</a></p>
<p><a href="#k15">*** 15. Metriky ZooKeepera</a></p>
<p><a href="#k16">*** 16. Konfigurace JMX Exporteru pro využití s&nbsp;Kafkou</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na relevantní články na Rootu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Sledování činnosti systému Apache Kafka přes JMX i metriky Promethea</h2>

<p>Na několik předchozích článků, v&nbsp;nichž jsme se zabývali různými způsoby
použití technologie <i>Apache Kafka</i> (viz odkazy uvedené <a
href="#k19">v&nbsp;devatenácté kapitole</a>) dnes navážeme. Popíšeme si totiž
některé možnosti sledování činnosti Kafky, což je velmi důležité, především na
produkčních systémech. Samotná Kafka, jakožto aplikace určená pro běh nad
virtuálním strojem programovacího jazyka Java, své <i>metriky</i> nabízí přes
technologii nazvanou <i>Java Management Extensions</i> neboli <i>JMX</i>.
Existuje několik aplikací, které JMX dokážou zpracovat; příkladem je standardní
nástroj <strong>JConsole</strong> dodávaný přímo s&nbsp;JDK (nikoli ovšem
s&nbsp;pouhým JRE). Ovšem s&nbsp;využitím pomocného nástroje nazvaného <i>JMX
Exporter</i> je možné metriky převést do formátu zpracovatelného například
známým nástrojem <i>Prometheus</i> zkombinovaným s&nbsp;<i>Grafanou</i>.</p>

<a href="https://www.root.cz/obrazek/352782/"><img src="https://i.iinfo.cz/images/284/amq1-7-prev.png" class="image-352782" alt="&#160;" width="324" height="270" /></a>
<p><i>Obrázek 1: Standardním nástrojem pro prohlížení metrik dostupných přes
JMX je nástroj <strong>jconsole</strong> dodávaný společně s&nbsp;JDK.</i></p>

<p>Vzhledem k&nbsp;tomu, že si nejdříve musíme popsat několik technologií,
které se používají současně, bude dnešní článek rozdělen na několik částí. <a
href="#k02">V&nbsp;úvodní části</a> se budeme zabývat samotnou technologií JMX
a MBeans z&nbsp;pohledu Javovského programátora. <a href="#k07">V&nbsp;části
druhé</a> se zmíníme o nástroji <i>Prometheus</i>. <a href="#k09">Následovat
bude</a> popis nástroje nazvaného <strong>JMX Exporter</strong> a konečně <a
href="#k11">ve čtvrté části článku</a> si ukážeme, jaké metriky jsou Apache
Kafkou exportovány a co vlastně znamenají.</p>

<a href="https://www.root.cz/obrazek/352784/"><img src="https://i.iinfo.cz/images/284/amq1-9-prev.png" class="image-352784" alt="&#160;" width="324" height="270" /></a>
<p><i>Obrázek 2: Přístup k&nbsp;MBeans (viz další text) message brokera Apache
ActiveMQ přes nástroj <strong>jconsole</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: JMX se používá i v&nbsp;některých
dalších message brokerech, pochopitelně v&nbsp;těch postavených nad JVM.
Příkladem může být <a
href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/#k12">Apache
ActiveMQ</a> (viz též screenshoty uvedené v&nbsp;této kapitole).</div></p>

<a href="https://www.root.cz/obrazek/352784/"><img src="https://i.iinfo.cz/images/284/amq1-9-prev.png" class="image-352784" alt="&#160;" width="324" height="270" /></a>
<p><i>Obrázek 3: Přístup k&nbsp;MBeans (viz další text) message brokera Apache
ActiveMQ přes nástroj <strong>jconsole</strong>.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Technologie JMX &ndash; Java Management Extension</h2>

<p>Podívejme se nyní na použití technologie JMX (<i>Java Management
Extension</i>) v&nbsp;praxi, a to z&nbsp;pohledu programátora. JMX zajišťuje
monitorování a popř.&nbsp;i ovládání (řízení) služeb, a to s&nbsp;využitím
definovaných zdrojů (<i>resources</i>). V&nbsp;aplikačním kódu jsou tyto zdroje
reprezentovány jako objekty nazvané <i>MBean(s)</i> neboli <i>Managed
Bean(s)</i>, přičemž přístup k&nbsp;atributům <i>MBeans</i> je zajištěn přes
<i>gettery</i> a <i>settery</i> (s&nbsp;jejich standardním javovským
pojmenováním). Deklarace a použití vlastního <i>MBeans</i> je řešeno přes
rozhraní, které se musí jmenovat <strong>xxxMBean</strong>, tj.&nbsp;jméno
tohoto rozhraní musí končit řetězcem &bdquo;MBean&ldquo;. Následuje příklad
takového rozhraní, v&nbsp;němž jsou deklarovány tři atributy, které jsou určeny
jen pro čtení (máme totiž k&nbsp;dispozici jen jejich <i>gettery</i>, nikoli
<i>settery</i>):</p>

<pre>
public interface <strong>StatusMBean</strong> {
    Integer <strong>getAnswer</strong>();
    String <strong>getProgramName</strong>();
    Boolean <strong>getSwitchStatus</strong>();
}
</pre>

<p>Následuje implementace tohoto rozhraní běžnou třídou (která ovšem může
obsahovat i další atributy a metody):</p>

<pre>
public class <strong>Status</strong> implements <strong>StatusMBean</strong> {
   private Integer answer;
   private String programName;
   private Boolean switchStatus;
&nbsp;
   public <strong>Status</strong>(String programName) {
       this.answer = 42;
       this.programName = programName;
       this.switchStatus = false;
   }
 &nbsp;  
   @Override
   public Integer <strong>getAnswer</strong>() {
       return this.answer;
   }
&nbsp;
   @Override
   public String <strong>getProgramName</strong>() {
       return this.programName;
   }
&nbsp;
   @Override
   public Boolean <strong>getSwitchStatus</strong>() {
       return switchStatus;
   }
}
</pre>

<p>Poslední částí demonstračního příkladu je třída <strong>Main</strong>
představující vstupní bod do aplikace. Po inicializaci JVM se nalezne a spustí
metoda <strong>main</strong>, ve které se MBean zkonstruuje (objekt nazvaný
<strong>systemStatus</strong>) a zaregistruje, takže jeho obsah bude dostupný
přes JMX pod ve jmenném prostoru &bdquo;cz.root.app&ldquo;pod jménem
&bdquo;StatusExample&ldquo;:</p>

<pre>
import java.util.Scanner;
&nbsp;
import javax.management.*;
import java.lang.management.ManagementFactory;
&nbsp;
public class <strong>Main</strong> {
   public static void <strong>main</strong>(String[] args) {
       try {
           String programName = (args.length == 0) ? "foobar" : args[0];
&nbsp;
           StatusMBean systemStatus = new Status(programName);
&nbsp;
           MBeanServer platformMBeanServer = ManagementFactory.getPlatformMBeanServer();
           ObjectName objectName = new ObjectName("cz.root.app:name=StatusExample");
           platformMBeanServer.registerMBean(systemStatus, objectName);

       } catch (Exception e) {
           e.printStackTrace();
       }
&nbsp;
       new Scanner(System.in).nextLine();
   }
}
</pre>

<p><div class="rs-tip-major">Poznámka: objekt typu <strong>Scanner</strong> je
zde použit jen pro čekání na stisk klávesy pro ukončení aplikace.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zobrazení obsahu MBeans nástrojem <strong>jconsole</strong></h2>

<p>Nyní výše popsaný demonstrační projekt přeložíme a spustíme:</p>

<pre>
$ <strong>javac Main.java</strong>
&nbsp;
$ <strong>java Main</strong>
</pre>

<p>V&nbsp;této chvíli aplikace čeká na stisk klávesy, ovšem již v&nbsp;tento
okamžik jsou atributy MBeanu &bdquo;vystaveny&ldquo; k&nbsp;přečtení jakýmkoli
nástrojem, který s&nbsp;JMX umí pracovat. Vše otestujeme na standardní aplikaci
<strong>jconsole</strong>, kterou byste měli mít nainstalovanou (za
předpokladu, že jste byli schopni demonstrační příklad přeložit):</p>

<pre>
$ <strong>export _JAVA_OPTIONS="-Dawt.useSystemAAFontSettings=on -Dswing.aatext=true -Dsun.java2d.xrender=true"</strong>
$ <strong>jconsole</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: první řádek zajistí čitelnější zobrazení
fontů.</div></p>

*** image ***
<p><i>Obrázek 4: Po spuštění <strong>jconsole</strong> se zobrazí všechny
nalezené aplikace běžící nad JVM. Vybereme aplikaci
<strong>Main</strong>.</i></p>

*** image ***
<p><i>Obrázek 5: Povolíme (protentokrát) připojení bez SSL.</i></p>

*** image ***
<p><i>Obrázek 5: Zobrazí se základní informace o sledované aplikace (obsazení
paměti apod.).</i></p>

*** image ***
<p><i>Obrázek 6: Na listu <strong>MBeans</strong> se kromě standardních MBeans
objeví i jmenný prostor &bdquo;cz.root.app&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 7: Po otevření tohoto prostoru se objeví i náš MBean
&bdquo;StatusExample&ldquo;.</i></p>

*** image ***
<p><i>Obrázek 8: A zde jsou všechny tři atributy, které jsme
definovali.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Změna stavu atributů MBeans dostupných přes JMX</h2>

<p></p>

<pre>
public interface StatusMBean {
    Integer getAnswer();
    Long getCounter();
    String getProgramName();
    Boolean getSwitchStatus();
}
</pre>

<p></p>

<pre>
public class Status implements StatusMBean {
   private Integer answer;
   private String programName;
   private Boolean switchStatus;
   private Long counter;

   public Status(String programName) {
       this.answer = 42;
       this.programName = programName;
       this.switchStatus = false;
       this.counter = 0L;
   }
   
   @Override
   public Integer getAnswer() {
       return this.answer;
   }

   @Override
   public Long getCounter() {
       this.counter++;
       return this.counter;
   }

   @Override
   public String getProgramName() {
       return this.programName;
   }

   @Override
   public Boolean getSwitchStatus() {
       return switchStatus;
   }
}
</pre>

<p></p>

<pre>
import java.util.Scanner;

import javax.management.*;
import java.lang.management.ManagementFactory;

public class Main {
   public static void main(String[] args) {
       try {
           String programName = (args.length == 0) ? "foobar" : args[0];

           StatusMBean systemStatus = new Status(programName);

           MBeanServer platformMBeanServer = ManagementFactory.getPlatformMBeanServer();
           ObjectName objectName = new ObjectName("cz.root.app:name=StatusExample");
           platformMBeanServer.registerMBean(systemStatus, objectName);

       } catch (Exception e) {
           e.printStackTrace();
       }

       new Scanner(System.in).nextLine();
   }
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<pre>
public interface StatusMBean {
    Integer getAnswer();
    Long getCounter();
    String getProgramName();
    Boolean getSwitchStatus();
    void setSwitchStatus(Boolean newStatus);
    void flipSwitchStatus();
}
</pre>

<pre>
public class Status implements StatusMBean {
   private Integer answer;
   private String programName;
   private Boolean switchStatus;
   private Long counter;

   public Status(String programName) {
       this.answer = 42;
       this.programName = programName;
       this.switchStatus = false;
       this.counter = 0L;
   }
   
   @Override
   public Integer getAnswer() {
       return this.answer;
   }

   @Override
   public Long getCounter() {
       this.counter++;
       return this.counter;
   }

   @Override
   public String getProgramName() {
       return this.programName;
   }

   @Override
   public Boolean getSwitchStatus() {
       return switchStatus;
   }

   @Override
   public void setSwitchStatus(Boolean newStatus) {
       this.switchStatus = newStatus;
   }

   @Override
   public void flipSwitchStatus() {
       System.out.println("Flip switch status called!");
       this.switchStatus = !this.switchStatus;
   }
}
</pre>

<pre>
import java.util.Scanner;

import javax.management.*;
import java.lang.management.ManagementFactory;

public class Main {
   public static void main(String[] args) {
       try {
           String programName = (args.length == 0) ? "foobar" : args[0];

           StatusMBean systemStatus = new Status(programName);

           MBeanServer platformMBeanServer = ManagementFactory.getPlatformMBeanServer();
           ObjectName objectName = new ObjectName("cz.root.app:name=StatusExample");
           platformMBeanServer.registerMBean(systemStatus, objectName);

       } catch (Exception e) {
           e.printStackTrace();
       }

       new Scanner(System.in).nextLine();
   }
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nástroj Prometheus</h2>

<p>Po popisu základních vlastností technologie JMX se nyní ve stručnosti
zmíníme o nástroji <i>Prometheus</i> (který ovšem přímo s&nbsp;JMX nesouvisí).
<i>Prometheus</i> se v&nbsp;současnosti velmi často používá pro sbírání metrik
z&nbsp;běžících služeb, mikroslužeb, message brokerů, ale i IoT zařízení atd.
Tyto metriky (metrikou může být v&nbsp;tomto případě například počet
připojených klientů, aktuálně obsazená kapacita haldy &ndash; heapu, informace
o tématech, informace o oddílech atd.) je následně možné filtrovat a
analyzovat, přičemž výsledky mohou být vizualizovány například nástrojem
<i>Grafana</i> (propojení <i>Prometheus</i> + <i>Grafana</i> je ostatně taktéž
velmi časté, v&nbsp;mnoha firmách je to nepsaný standard). Jedno
z&nbsp;typických použití Promethea je sledování (mikro)služby nasazené
například v&nbsp;clusteru. Taková služba kromě své vlastní funkcionality nabízí
jednoduché rozhraní REST API (HTTP/HTTPS) s&nbsp;typicky jediným koncovým bodem
nazvaným <strong>/metrics</strong>. Nástroj Prometheus z&nbsp;tohoto koncového
bodu metriky načítá a následně je nakonfigurovaným způsobem zpracovává.</p>

<p><div class="rs-tip-major">Poznámka: účel je tedy do určité míry podobný výše
zmíněné technologii JMX, ovšem samotná realizace je odlišná &ndash; využívá se
standardní protokol HTTP, přenášejí se jednoduše strukturovaná textová data a
navíc zde existuje omezení pouze na čtení dat, nikoli na možnost volání metod
MBeanů.</div></p>

<p>Systém <i>Prometheus</i> interně používá databázi, do které se ukládají
prakticky libovolné (číselné) hodnoty, které jsou opatřeny časovým razítkem,
kromě toho i jménem metriky (ta musí být unikátní) a návěštím (<i>label</i>)
umožňujícím podrobnější dělení hodnot, například podle toho, v&nbsp;jakém
prostředí je měření prováděno. Doplněna bývá i nápověda, resp.&nbsp;přesněji
řečeno popis metriky. To znamená, že pro zvolenou metriku, popř.&nbsp;pro
metriku a návěští je možné získat celou časovou posloupnost s&nbsp;hodnotami,
vracet se do minulosti, získat informace pro zvolené časové období apod.
Samotné hodnoty jsou interně zpracovávány jako datový typ
<i>double</i>/<i>float64</i> (konkrétní jednotka již záleží na intepretaci dat)
a časová razítka mají milisekundovou přesnost, což by mělo být pro účely tohoto
nástroje dostačující, už jen z&nbsp;toho důvodu, že samotné pořízení záznamu
přes API <i>Promethea</i> má určitou časovou složitost.</p>

<p><div class="rs-tip-major">Poznámka: metriky ve formátu vhodném pro
Prometheus poskytuje například knihovna <strong>expvar</strong>
z&nbsp;ekosystému programovacího jazyka Go. Touto tematikou jsme se již
zabývali v&nbsp;článku <a
href="https://www.root.cz/clanky/sledovani-vybranych-metrik-sluzeb-naprogramovanych-v-jazyku-go/">Sledování
vybraných metrik služeb naprogramovaných v&nbsp;jazyku Go</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Dotazovací jazyk PromQL</h2>

<p>Důležitou součástí <i>Promethea</i> je i <i>PromQL</i>, což je relativně
snadno použitelný dotazovací jazyk používaný pro získání potřebných metrik,
agregaci výsledků apod. Můžeme si ostatně uvést příklad jednoduchého dotazu
vytvořeného v&nbsp;tomto jazyce, který vrátí časovou posloupnost hodnot trvání
přípravy odpovědi na HTTP požadavky (předpokládejme, že jméno této metriky je
&bdquo;http_requests_total&ldquo;). Dotaz vypadá takto:</p>

<pre>
<strong>http_requests_total</strong>
</pre>

<p>Celkovou dobu a průměrnou dobu dotazů získáme stejně snadno:</p>

<pre>
<strong>sum(http_requests_total)</strong>
<strong>avg(http_requests_total)</strong>
</pre>

<p>V&nbsp;dotazu ovšem můžeme provést i jemnější dělení, například podle
návěští:</p>

<pre>
<strong>http_requests_total{job="prometheus",group="canary"}</strong>
</pre>

<p>V&nbsp;jazyku <i>PromQL</i> je možné využívat například i regulární výrazy,
což nám umožňuje získat časy odpovědí na HTTP dotazy typu GET, ovšem pouze pro
zvolená prostředí:</p>

<pre>
<strong>http_requests_total{environment=~"staging|testing|development",method!="GET"}</strong>
</pre>

<p>Dotazovací jazyk <i>PromQL</i> je primárně určen pro práci s&nbsp;časovými
řadami, takže nepřekvapí ani dobrá podpora specifikace časového období, pro
které potřebujeme data získat. Výsledky trvání vyřízení HTTP dotazů typu GET za
posledních pět minut by se získaly takto:</p>

<pre>
<strong>http_requests_total{job="prometheus"}[5m]</strong>
</pre>

<p>Výsledky za posledních třicet minut, ovšem s&nbsp;rozlišením jedné
minuty se získají příkazem:</p>

<pre>
<strong>rate(http_requests_total[5m])[30m:1m]</strong>
</pre>

<p>Kromě dotazů zapisovaných v&nbsp;doménově specifickém jazyku <i>PromQL</i>
je podporován již zmíněný výstup ve formě plně konfigurovatelných grafů,
z&nbsp;nichž se posléze vytváří různé dashboardy, které sledují stav celého
systému či jeho jednotlivých částí. Pro tento účel se používá <i>Grafana</i>.
Pokud chcete vidět, jak může vypadat výstup z&nbsp;kombinace
Prometheus+Grafana, můžete se podívat na obrázek na adrese <a
href="https://prometheus.io/assets/grafana_prometheus.png">https://prometheus.io/assets/grafana_prometheus.png</a>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. JMX Exporter &ndash; rozhraní mezi JMX a metrikami Promethea</h2>

<p><i>&bdquo;Java is 23 years old, mature, and comes with unbeatable tooling
and monitoring capabilities. At the very beginning, Java already incorporated
microservice concepts with the Jini / JXTA frameworks mixed with no-SQL
databases like e.g. JavaSpaces. As often -- Java was just 15 years too early.
The market was not ready for the technology back then. However, all the design
principles from 1999 still do apply today. We don't have re-invent the
wheel.&ldquo;</i></p>

<p>Kombinace nástrojů <i>Prometheus+Grafana</i> se v&nbsp;praxi, například
v&nbsp;oblasti mikroslužeb, používá velmi často. A do tohoto světa Javovské
aplikace se svým JMX příliš nezapadají (i když možnosti JMX jsou ve skutečnosti
širší, což jsme si ostatně již naznačili v&nbsp;předchozích kapitolách).
Existuje však relativně snadná možnost, jakou se hodnoty nabízené přes JMX
převedou na metriky kompatibilní s&nbsp;Prometheem. Tuto možnost nabízí nástroj
nazvaný <i>JMX Exporter</i>, který je použit jako takzvaný <i>Java agent</i>,
což je kód psaný většinou v&nbsp;Javě, který má přístup k&nbsp;instrumentaci
v&nbsp;JVM a dokáže ovlivňovat běh aplikace v&nbsp;JVM. Java agenti se
používají pro různé účely, například pro <i>AOP</i> (aspektově orientované
programování), profilování, <i>mutation testing</i> (český ekvivalent pro
cílenou změnu testovaného kódu pravděpodobně neexistuje) atd.</p>

<p>Konkrétně v&nbsp;případě JMX Exporteru se v&nbsp;rámci agenta spustí HTTP
server na zvoleném portu a hodnoty MBeanů dostupné přes JMX mohou být dostupné
právě přes tento HTTP server ve formátu kompatibilním s&nbsp;Promeheem.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Využití JMX Exporteru v&nbsp;demonstračním příkladu</h2>

<p>Nyní si ukážeme, jakým způsobem je možné <i>JMX Exporter</i> použít
v&nbsp;jednom z&nbsp;našich demonstračních příkladů. Uvidíme, že je to velmi
snadné a přímočaré &ndash; a především nejsou vyžadovány žádné změny na straně
zdrojového kódu aplikaci ani na straně vygenerovaných <i>class</i> souborů.</p>

<p>Nejprve je nutné stáhnout poslední stabilní verzi JMX Exporteru. Ta je
dodávána ve formě <i>Java archivu</i>, tedy souboru s&nbsp;koncovkou
<strong>.jar</strong>. Tento soubor je nutné stáhnout buď přímo do adresáře
s&nbsp;projektem, nebo si zde vytvořit symbolický link:</p>

<pre>
$ <strong>wget https://repo1.maven.org/maven2/io/prometheus/jmx/jmx_prometheus_javaagent/0.15.0/jmx_prometheus_javaagent-0.15.0.jar</strong>
</pre>

<p>Dále přímo v&nbsp;adresáři s&nbsp;demonstračním projektem vytvoříme soubor
nazvaný <strong>config.yaml</strong>. Tento soubor totiž musí existovat, ale
může být prázdný (což je i náš případ):</p>

<pre>
$ <strong>touch config.yaml</strong>
</pre>

<p>Nyní již můžeme spustit náš demonstrační příklad, ovšem s&nbsp;tím, že
virtuálnímu stroji Javy předáme další parametr <strong>-javaagent</strong>. Ten
bude obsahovat cestu k&nbsp;Java archivu JMX Exporteru a taktéž určení, na
kterém portu mají být metriky &bdquo;vystaveny&ldquoa;. Taktéž se zde
specifikuje jméno (prázdného) konfiguračního souboru:</p>

<pre>
$ <strong>java -javaagent:./jmx_prometheus_javaagent-0.15.0.jar=8080:config.yaml Main</strong>
</pre>

<p>V&nbsp;této chvíli by měl demonstrační příklad běžet ve své JVM.
V&nbsp;dalším terminálu se pokusíme přečíst jeho metriky. JMX Exporteru jsme
určili port 8080, takže by metriky měly být &bdquo;vystaveny&ldquo; na adrese
<strong>localhost:8080/metrics</strong>:</p>

<pre>
$ <strong>curl localhost:8080/metrics</strong>
</pre>

<p>Skutečně je tomu tak:</p>

<pre>
# HELP jvm_classes_loaded The number of classes that are currently loaded in the JVM
# TYPE jvm_classes_loaded gauge
jvm_classes_loaded 1438.0
# HELP jvm_classes_loaded_total The total number of classes that have been loaded since the JVM has started execution
# TYPE jvm_classes_loaded_total counter
jvm_classes_loaded_total 1438.0
# HELP jvm_classes_unloaded_total The total number of classes that have been unloaded since the JVM has started execution
# TYPE jvm_classes_unloaded_total counter
jvm_classes_unloaded_total 0.0
...
...
...
# TYPE java_lang_MemoryPool_UsageThreshold untyped
java_lang_MemoryPool_UsageThreshold{name="Metaspace",} 0.0
java_lang_MemoryPool_UsageThreshold{name="PS Old Gen",} 0.0
java_lang_MemoryPool_UsageThreshold{name="Code Cache",} 0.0
java_lang_MemoryPool_UsageThreshold{name="Compressed Class Space",} 0.0
...
...
...
# HELP jvm_buffer_pool_capacity_bytes Bytes capacity of a given JVM buffer pool.
# TYPE jvm_buffer_pool_capacity_bytes gauge
jvm_buffer_pool_capacity_bytes{pool="direct",} 89548.0
jvm_buffer_pool_capacity_bytes{pool="mapped",} 0.0
# HELP jvm_buffer_pool_used_buffers Used buffers of a given JVM buffer pool.
# TYPE jvm_buffer_pool_used_buffers gauge
jvm_buffer_pool_used_buffers{pool="direct",} 5.0
jvm_buffer_pool_used_buffers{pool="mapped",} 0.0
...
...
...
</pre>

<p>Můžeme si vyfiltrovat pouze ty metriky, které jsme sami do projektu přidali
(a nikoli metriky dodané vlastním virtuálním strojem Javy):</p>

<pre>
$ <strong>curl localhost:8080/metrics | grep "cz.root.app"</strong>
</pre>

<pre>
# HELP cz_root_app_StatusExample_Counter Attribute exposed for management (cz.root.app&lt;name=StatusExample&gt;&lt;&gt;Counter)
# TYPE cz_root_app_StatusExample_Counter untyped
cz_root_app_StatusExample_Counter 6.0
# HELP cz_root_app_StatusExample_Answer Attribute exposed for management (cz.root.app&lt;name=StatusExample&gt;&lt;&gt;Answer)
# TYPE cz_root_app_StatusExample_Answer untyped
cz_root_app_StatusExample_Answer 42.0
# HELP cz_root_app_StatusExample_SwitchStatus Attribute exposed for management (cz.root.app&lt;name=StatusExample&gt;&lt;&gt;SwitchStatus)
# TYPE cz_root_app_StatusExample_SwitchStatus untyped
cz_root_app_StatusExample_SwitchStatus 0.0
</pre>

<p><div class="rs-tip-major">Poznámka: formát všech metrik je plně kompatibilní
s&nbsp;projektem <i>Prometheus</i> a využitelný tak i
v&nbsp;<i>Grafaně</i>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Metriky systému Apache Kafka</h2>

<ol>
<li>Metriky samotného brokera</li>
<li>Metriky vztažené k&nbsp;producentům</li>
<li>Metriky vztažené ke konzumentům</li>
<li>Metriky ZooKeepera (což je samostatný proces)</li>
</ol>

<p>Abychom si mohli JMX odzkoušet v&nbsp;praxi, vytvoříme několik témat
(<i>topic</i>) a pošleme do nich nějaké zprávy. Podobně jako minule, i dnes pro
tento účel použijeme užitečný nástroj <strong>kafkacat</strong>. Téma se
automaticky vytvoří s&nbsp;první poslanou zprávou, čímž se nám situace
zjednodušuje. Vytvoříme tedy téma <strong>topic1</strong> a na příkazové řádce
zadáme trojici zpráv (jejich těl). Zadávání se ukončuje standardní klávesovou
zkratkou <strong>Ctrl+D</strong>:</p>

<pre>
$ <strong>kafkacat -P -b localhost:9092 -t topic1</strong>
foo
bar
baz
</pre>

<p>Totéž provedeme pro téma &nbsp;názvem <strong>topic2</strong>:</p>

<pre>
$ <strong>kafkacat -P -b localhost:9092 -t topic2</strong>
first
second
third
</pre>

<p>A do třetice pošleme tři zprávy do tématu s&nbsp;názvem
<strong>topic3</strong>:</p>

<pre>
$ <strong>kafkacat -P -b localhost:9092 -t topic3</strong>
jedna
dva
tri
</pre>

<p>Nakonec vytvoříme ještě jedno téma s&nbsp;tím, že bude mít tři oddíly. Pro
tento účel použijeme skript <strong>kafka-topics.sh</strong>, který je dodáván
společně s&nbsp;Apache Kafkou (je v&nbsp;podadresáři <strong>bin</strong>):</p>

<pre>
$ <strong>./kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic partitioned</strong>
&nbsp;
Created topic partitioned.
</pre>

<pre>
$ <strong>kafkacat -P -b localhost:9092 -P -t partitioned -p 0</strong>
jedna
dva
tri
&nbsp;
$ <strong>kafkacat -P -b localhost:9092 -P -t partitioned -p 1</strong>
ctyri
pet
sest
&nbsp;
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Metriky samotného brokera</h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Metriky vztažené k&nbsp;producentům</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Metriky vztažené ke konzumentům</h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Metriky ZooKeepera</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Konfigurace JMX Exporteru pro využití s&nbsp;Kafkou</h2>

<pre>
$ <strong>cd ${KAFKA_LOCATION}</strong>
</pre>

<pre>
bin
config
libs
logs
</pre>

<pre>
$ <strong>wget https://repo1.maven.org/maven2/io/prometheus/jmx/jmx_prometheus_javaagent/0.15.0/jmx_prometheus_javaagent-0.15.0.jar</strong>
</pre>

<pre>
bin
config
jmx_prometheus_javaagent-0.15.0.jar
libs
logs
</pre>

<strong>export KAFKA_OPTS=' -javaagent:jmx_prometheus_javaagent-0.15.0.jar=9999:./config/kafka-2_0_0.yml'</strong>

<pre>
$ <strong>bin/kafka-server-start.sh config/server.properties</strong>
</pre>

<pre>
$ <strong>pushd bin</strong>
$ <strong>cp kafka-server-start.sh kafka-server-start-prometheus.sh</strong>
</pre>

<pre>
connect-distributed.sh
connect-mirror-maker.sh
connect-standalone.sh
kafka-acls.sh
kafka-broker-api-versions.sh
kafka-configs.sh
kafka-console-consumer.sh
kafka-console-producer.sh
kafka-consumer-groups.sh
kafka-consumer-perf-test.sh
kafka-delegation-tokens.sh
kafka-delete-records.sh
kafka-dump-log.sh
kafka-leader-election.sh
kafka-log-dirs.sh
kafka-mirror-maker.sh
kafka-preferred-replica-election.sh
kafka-producer-perf-test.sh
kafka-reassign-partitions.sh
kafka-replica-verification.sh
kafka-run-class.sh
<strong>kafka-server-start-prometheus.sh</strong>
kafka-server-start.sh
kafka-server-stop.sh
kafka-streams-application-reset.sh
kafka-topics.sh
kafka-verifiable-consumer.sh
kafka-verifiable-producer.sh
trogdor.sh
zookeeper-security-migration.sh
zookeeper-server-start.sh
zookeeper-server-stop.sh
zookeeper-shell.sh
</pre>

<pre>
$ <strong>vim kafka-server-start-prometheus.sh</strong>
</pre>

<pre>
if [ $# -lt 1 ];
then
	echo "USAGE: $0 [-daemon] server.properties [--override property=value]*"
	exit 1
fi
base_dir=$(dirname $0)
&nbsp;
if [ "x$KAFKA_LOG4J_OPTS" = "x" ]; then
    export KAFKA_LOG4J_OPTS="-Dlog4j.configuration=file:$base_dir/../config/log4j.properties"
fi
&nbsp;
if [ "x$KAFKA_HEAP_OPTS" = "x" ]; then
    export KAFKA_HEAP_OPTS="-Xmx1G -Xms1G"
fi
&nbsp;
EXTRA_ARGS=${EXTRA_ARGS-'-name kafkaServer -loggc'}
&nbsp;
COMMAND=$1
case $COMMAND in
  -daemon)
    EXTRA_ARGS="-daemon "$EXTRA_ARGS
    shift
    ;;
  *)
    ;;
esac
&nbsp;
<strong>export KAFKA_OPTS=' -javaagent:jmx_prometheus_javaagent-0.15.0.jar=9999:./config/kafka-2_0_0.yml'</strong>
&nbsp;
exec $base_dir/kafka-run-class.sh $EXTRA_ARGS kafka.Kafka "$@"
</pre>

<pre>
$ <strong>popd</strong>
</pre>

https://github.com/prometheus/jmx_exporter/blob/master/example_configs/kafka-2_0_0.yml

<pre>
$ <strong>wget -O config/kafka-2_0_0.yml https://raw.githubusercontent.com/prometheus/jmx_exporter/master/example_configs/kafka-2_0_0.yml</strong>
</pre>

<pre>
lowercaseOutputName: true
&nbsp;
rules:
# Special cases and very specific rules
- pattern : kafka.server&lt;type=(.+), name=(.+), clientId=(.+), topic=(.+), partition=(.*)&gt;&lt;&gt;Value
  name: kafka_server_$1_$2
  type: GAUGE
  labels:
    clientId: "$3"
    topic: "$4"
    partition: "$5"
- pattern : kafka.server&lt;type=(.+), name=(.+), clientId=(.+), brokerHost=(.+), brokerPort=(.+)&gt;&lt;&gt;Value
  name: kafka_server_$1_$2
  type: GAUGE
  labels:
    clientId: "$3"
    broker: "$4:$5"
- pattern : kafka.coordinator.(\w+)&lt;type=(.+), name=(.+)&gt;&lt;&gt;Value
  name: kafka_coordinator_$1_$2_$3
  type: GAUGE
&nbsp;
# Generic per-second counters with 0-2 key/value pairs
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+)PerSec\w*, (.+)=(.+), (.+)=(.+)&gt;&lt;&gt;Count
  name: kafka_$1_$2_$3_total
  type: COUNTER
  labels:
    "$4": "$5"
    "$6": "$7"
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+)PerSec\w*, (.+)=(.+)&gt;&lt;&gt;Count
  name: kafka_$1_$2_$3_total
  type: COUNTER
  labels:
    "$4": "$5"
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+)PerSec\w*&gt;&lt;&gt;Count
  name: kafka_$1_$2_$3_total
  type: COUNTER
&nbsp;
- pattern: kafka.server&lt;type=(.+), client-id=(.+)&gt;&lt;&gt;([a-z-]+)
  name: kafka_server_quota_$3
  type: GAUGE
  labels:
    resource: "$1"
    clientId: "$2"
&nbsp;
- pattern: kafka.server&lt;type=(.+), user=(.+), client-id=(.+)&gt;&lt;&gt;([a-z-]+)
  name: kafka_server_quota_$4
  type: GAUGE
  labels:
    resource: "$1"
    user: "$2"
    clientId: "$3"
&nbsp;
# Generic gauges with 0-2 key/value pairs
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+), (.+)=(.+), (.+)=(.+)&gt;&lt;&gt;Value
  name: kafka_$1_$2_$3
  type: GAUGE
  labels:
    "$4": "$5"
    "$6": "$7"
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+), (.+)=(.+)&gt;&lt;&gt;Value
  name: kafka_$1_$2_$3
  type: GAUGE
  labels:
    "$4": "$5"
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+)&gt;&lt;&gt;Value
  name: kafka_$1_$2_$3
  type: GAUGE
&nbsp;
# Emulate Prometheus 'Summary' metrics for the exported 'Histogram's.
#
# Note that these are missing the '_sum' metric!
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+), (.+)=(.+), (.+)=(.+)&gt;&lt;&gt;Count
  name: kafka_$1_$2_$3_count
  type: COUNTER
  labels:
    "$4": "$5"
    "$6": "$7"
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+), (.+)=(.*), (.+)=(.+)&gt;&lt;&gt;(\d+)thPercentile
  name: kafka_$1_$2_$3
  type: GAUGE
  labels:
    "$4": "$5"
    "$6": "$7"
    quantile: "0.$8"
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+), (.+)=(.+)&gt;&lt;&gt;Count
  name: kafka_$1_$2_$3_count
  type: COUNTER
  labels:
    "$4": "$5"
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+), (.+)=(.*)&gt;&lt;&gt;(\d+)thPercentile
  name: kafka_$1_$2_$3
  type: GAUGE
  labels:
    "$4": "$5"
    quantile: "0.$6"
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+)&gt;&lt;&gt;Count
  name: kafka_$1_$2_$3_count
  type: COUNTER
- pattern: kafka.(\w+)&lt;type=(.+), name=(.+)&gt;&lt;&gt;(\d+)thPercentile
  name: kafka_$1_$2_$3
  type: GAUGE
  labels:
    quantile: "0.$4"
</pre>

<pre>
$ <strong>bin/kafka-server-start-prometheus.sh config/server.properties</strong>
</pre>

<pre>
$ <strong>curl localhost:9999</strong>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové soubory naprogramované v&nbsp;Javě a použité v&nbsp;dnešním článku
byly uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>.
V&nbsp;případě, že nebudete chtít klonovat celý repositář, můžete namísto toho
použít odkazy na jednotlivé soubory, které naleznete v&nbsp;následující
tabulce:</p>

<table>
<tr><th>#</th><th>Příklad/soubor</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>example1/StatusMBean.java</td><td>rozhraní s&nbsp;popisem MBeans</td><td><a href="https://github.com/tisnik/presentations/blob/master/mbeans/example1/StatusMBean.java">https://github.com/tisnik/presentations/blob/master/mbeans/example1/StatusMBean.java</a></td></tr>
<tr><td>2</td><td>example1/Status.java</td><td>implementace rozhraní <strong>StatusMBean</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/mbeans/example1/Status.java">https://github.com/tisnik/presentations/blob/master/mbeans/example1/Status.java</a></td></tr>
<tr><td>3</td><td>example1/Main.java</td><td>kód prvního demonstračního příkladu s&nbsp;inicializací JMX</td><td><a href="https://github.com/tisnik/presentations/blob/master/mbeans/example1/Main.java">https://github.com/tisnik/presentations/blob/master/mbeans/example1/Main.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>example2/StatusMBean.java</td><td>rozhraní s&nbsp;popisem MBeans</td><td><a href="https://github.com/tisnik/presentations/blob/master/mbeans/example2/StatusMBean.java">https://github.com/tisnik/presentations/blob/master/mbeans/example2/StatusMBean.java</a></td></tr>
<tr><td>5</td><td>example2/Status.java</td><td>implementace rozhraní <strong>StatusMBean</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/mbeans/example2/Status.java">https://github.com/tisnik/presentations/blob/master/mbeans/example2/Status.java</a></td></tr>
<tr><td>6</td><td>example2/Main.java</td><td>kód druhého demonstračního příkladu s&nbsp;inicializací JMX</td><td><a href="https://github.com/tisnik/presentations/blob/master/mbeans/example2/Main.java">https://github.com/tisnik/presentations/blob/master/mbeans/example2/Main.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>example3/StatusMBean.java</td><td>rozhraní s&nbsp;popisem MBeans</td><td><a href="https://github.com/tisnik/presentations/blob/master/mbeans/example3/StatusMBean.java">https://github.com/tisnik/presentations/blob/master/mbeans/example3/StatusMBean.java</a></td></tr>
<tr><td>8</td><td>example3/Status.java</td><td>implementace rozhraní <strong>StatusMBean</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/mbeans/example3/Status.java">https://github.com/tisnik/presentations/blob/master/mbeans/example3/Status.java</a></td></tr>
<tr><td>9</td><td>example3/Main.java</td><td>kód třetího demonstračního příkladu s&nbsp;inicializací JMX</td><td><a href="https://github.com/tisnik/presentations/blob/master/mbeans/example3/Main.java">https://github.com/tisnik/presentations/blob/master/mbeans/example3/Main.java</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: výše uvedené zdrojové kódy jsou zpětně
kompatibilní až minimálně do verze Java 7.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na relevantní články na Rootu</h2>

<ol>

<li>Použití nástroje Apache Kafka v&nbsp;aplikacích založených na mikroslužbách<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-apache-kafka-v-aplikacich-zalozenych-na-mikrosluzbach/">https://www.root.cz/clanky/pouziti-nastroje-apache-kafka-v-aplikacich-zalozenych-na-mikrosluzbach/</a>
</li>

<li>Apache Kafka: distribuovaná streamovací platforma<br />
<a href="https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/">https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw (2. část)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/</a>
</li>

<li>Pokročilý streaming založený na projektu Apache Kafka, jazyku Clojure a knihovně Jackdaw (streamy a kolony)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/</a>
</li>

<li>Vývoj služeb postavených na systému Apache Kafka v&nbsp;jazyku Go<br />
<a href="https://www.root.cz/clanky/vyvoj-sluzeb-postavenych-na-systemu-apache-kafka-v-jazyku-go/">https://www.root.cz/clanky/vyvoj-sluzeb-postavenych-na-systemu-apache-kafka-v-jazyku-go/</a>
</li>

<li>Práce s&nbsp; Kafkou z&nbsp;příkazové řádky: nástroje Kafkacat a Kcli<br />
<a href="https://www.root.cz/clanky/prace-s-kafkou-z-prikazove-radky-nastroje-kafkacat-a-kcli/">https://www.root.cz/clanky/prace-s-kafkou-z-prikazove-radky-nastroje-kafkacat-a-kcli/</a>
</li>

<li>Apache ActiveMQ – další systém implementující message brokera<br />
<a href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/#k12">https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/#k12</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Java™ Tutorials &ndash; Introducing MBeans<br />
<a href="https://docs.oracle.com/javase/tutorial/jmx/mbeans/index.html">https://docs.oracle.com/javase/tutorial/jmx/mbeans/index.html</a>
</li>

<li>Standard MBeans<br />
<a href="https://docs.oracle.com/javase/tutorial/jmx/mbeans/standard.html">https://docs.oracle.com/javase/tutorial/jmx/mbeans/standard.html</a>
</li>

<li>JMX Exporter<br />
<a href="https://github.com/prometheus/jmx_exporter">https://github.com/prometheus/jmx_exporter</a>
</li>

<li>Monitor Apache Kafka with Prometheus and Grafana<br />
<a href="https://computingforgeeks.com/monitor-apache-kafka-with-prometheus-and-grafana/">https://computingforgeeks.com/monitor-apache-kafka-with-prometheus-and-grafana/</a>
</li>

<li>Kafka Monitoring Using Prometheus<br />
<a href="https://www.metricfire.com/blog/kafka-monitoring-using-prometheus/">https://www.metricfire.com/blog/kafka-monitoring-using-prometheus/</a>
</li>

<li>Collecting Kafka Performance Metrics with OpenTelemetry<br />
<a href="https://www.splunk.com/en_us/blog/devops/monitoring-kafka-performance-metrics-with-splunk-infrastructure-monitoring.html">https://www.splunk.com/en_us/blog/devops/monitoring-kafka-performance-metrics-with-splunk-infrastructure-monitoring.html</a>
</li>

<li>Monitoring Kafka performance metrics<br />
<a href="https://www.datadoghq.com/blog/monitoring-kafka-performance-metrics/">https://www.datadoghq.com/blog/monitoring-kafka-performance-metrics/</a>
</li>

<li>Kcli: is a kafka read only command line browser.<br />
<a href="https://github.com/cswank/kcli">https://github.com/cswank/kcli</a>
</li>

<li>Kcli: a kafka command line browser<br />
<a href="https://go.libhunt.com/kcli-alternatives">https://go.libhunt.com/kcli-alternatives</a>
</li>

<li>Awesome Go<br />
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>
</li>

<li>Real-Time Payments with Clojure and Apache Kafka (podcast)<br />
<a href="https://www.evidentsystems.com/news/confluent-podcast-about-apache-kafka/">https://www.evidentsystems.com/news/confluent-podcast-about-apache-kafka/</a>
</li>

<li>Microservices: The Rise Of Kafka<br />
<a href="https://movio.co/blog/microservices-rise-kafka/">https://movio.co/blog/microservices-rise-kafka/</a>
</li>

<li>Building a Microservices Ecosystem with Kafka Streams and KSQL<br />
<a href="https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/">https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/</a>
</li>

<li>An introduction to Apache Kafka and microservices communication<br />
<a href="https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63">https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63</a>
</li>

<li>kappa-architecture.com<br />
<a href="http://milinda.pathirage.org/kappa-architecture.com/">http://milinda.pathirage.org/kappa-architecture.com/</a>
</li>

<li>Questioning the Lambda Architecture<br />
<a href="https://www.oreilly.com/ideas/questioning-the-lambda-architecture">https://www.oreilly.com/ideas/questioning-the-lambda-architecture</a>
</li>

<li>Lambda architecture<br />
<a href="https://en.wikipedia.org/wiki/Lambda_architecture">https://en.wikipedia.org/wiki/Lambda_architecture</a>
</li>

<li>Kafka &ndash; ecosystem (Wiki)<br />
<a href="https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem">https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem</a>
</li>

<li>The Kafka Ecosystem - Kafka Core, Kafka Streams, Kafka Connect, Kafka REST Proxy, and the Schema Registry<br />
<a href="http://cloudurable.com/blog/kafka-ecosystem/index.html">http://cloudurable.com/blog/kafka-ecosystem/index.html</a>
</li>

<li>A Kafka Operator for Kubernetes<br />
<a href="https://github.com/krallistic/kafka-operator">https://github.com/krallistic/kafka-operator</a>
</li>

<li>Kafka Streams<br />
<a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Streams">https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Streams</a>
</li>

<li>Kafka Streams<br />
<a href="http://kafka.apache.org/documentation/streams/">http://kafka.apache.org/documentation/streams/</a>
</li>

<li>Kafka Streams (FAQ)<br />
<a href="https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-Streams">https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-Streams</a>
</li>

<li>Event stream processing<br />
<a href="https://en.wikipedia.org/wiki/Event_stream_processing">https://en.wikipedia.org/wiki/Event_stream_processing</a>
</li>

<li>Part 1: Apache Kafka for beginners - What is Apache Kafka?<br />
<a href="https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html">https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html</a>
</li>

<li>What are some alternatives to Apache Kafka?<br />
<a href="https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka">https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka</a>
</li>

<li>What is the best alternative to Kafka?<br />
<a href="https://www.slant.co/options/961/alternatives/~kafka-alternatives">https://www.slant.co/options/961/alternatives/~kafka-alternatives</a>
</li>

<li>A super quick comparison between Kafka and Message Queues<br />
<a href="https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0">https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0</a>
</li>

<li>Kafka Queuing: Kafka as a Messaging System<br />
<a href="https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system">https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system</a>
</li>

<li>Apache Kafka Logs: A Comprehensive Guide<br />
<a href="https://hevodata.com/learn/apache-kafka-logs-a-comprehensive-guide/">https://hevodata.com/learn/apache-kafka-logs-a-comprehensive-guide/</a>
</li>

<li>Microservices – Not a free lunch!<br />
<a href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html">http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html</a>
</li>

<li>Microservices, Monoliths, and NoOps<br />
<a href="http://blog.arungupta.me/microservices-monoliths-noops/">http://blog.arungupta.me/microservices-monoliths-noops/</a>
</li>

<li>Microservice Design Patterns<br />
<a href="http://blog.arungupta.me/microservice-design-patterns/">http://blog.arungupta.me/microservice-design-patterns/</a>
</li>

<li>REST vs Messaging for Microservices – Which One is Best?<br />
<a href="https://solace.com/blog/experience-awesomeness-event-driven-microservices/">https://solace.com/blog/experience-awesomeness-event-driven-microservices/</a>
</li>

<li>Kappa Architecture Our Experience<br />
<a href="https://events.static.linux­found.org/sites/events/fi­les/slides/ASPgems%20-%20Kappa%20Architecture.pdf">https://events.static.linux­found.org/sites/events/fi­les/slides/ASPgems%20-%20Kappa%20Architecture.pdf</a>
</li>

<li>Apache Kafka Streams and Tables, the stream-table duality<br />
<a href="https://towardsdatascience.com/apache-kafka-streams-and-tables-the-stream-table-duality-ee904251a7e?gi=f22a29cd1854">https://towardsdatascience.com/apache-kafka-streams-and-tables-the-stream-table-duality-ee904251a7e?gi=f22a29cd1854</a>
</li>

<li>Alertmanager<br />
<a href="https://prometheus.io/docs/alerting/alertmanager/">https://prometheus.io/docs/alerting/alertmanager/</a>
</li>

<li>Grafana support for Prometheus<br />
<a href="https://prometheus.io/docs/visualization/grafana/">https://prometheus.io/docs/visualization/grafana/</a>
</li>

<li>Prometheus: from metrics to insight<br />
<a href="https://prometheus.io/">https://prometheus.io/</a>
</li>

<li>Java Management Extensions (JMX)<br />
<a href="https://en.wikipedia.org/wiki/Java_Management_Extensions">https://en.wikipedia.org/wiki/Java_Management_Extensions</a>
</li>

<li>JConsole<br />
<a href="https://en.wikipedia.org/wiki/JConsole">https://en.wikipedia.org/wiki/JConsole</a>
</li>

<li>Using JConsole<br />
<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/jconsole.html">https://docs.oracle.com/javase/8/docs/technotes/guides/management/jconsole.html</a>
</li>

<li>Overview of Java SE Monitoring and Management<br />
<a href="https://docs.oracle.com/en/java/javase/15/management/overview-java-se-monitoring-and-management.html">https://docs.oracle.com/en/java/javase/15/management/overview-java-se-monitoring-and-management.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

