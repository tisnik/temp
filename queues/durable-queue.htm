<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Durable Queue aneb implementace front zpráv bez použití klasického message brokera</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>


<body>

<h1>Durable Queue aneb implementace front zpráv bez použití klasického message brokera</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Předchozí část seriálu o message brokerech byla věnována projektu Dramatiq určeného především pro vývojáře používající programovací jazyk Python. Dnes se pro změnu budeme věnovat jinému programovacímu jazyku, konkrétně jazyku Clojure a knihovně nazvané příznačně Durable Queue.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Durable Queue aneb implementace front zpráv bez použití klasického message brokera</a></p>
<p><a href="#k02">*** 2. Rozdíly mezi Durable Queue a dalšími implementacemi front zpráv</a></p>
<p><a href="#k03">*** 3. Instalace knihovny Durable Queue</a></p>
<p><a href="#k04">*** 4. Kostra aplikace používající knihovnu Durable Queue</a></p>
<p><a href="#k05">*** 5. Vložení zprávy do fronty, přečtení zprávy a změna stavu zprávy</a></p>
<p><a href="#k06">*** 6. První demonstrační příklad: inicializace knihovny Durable Queue</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Durable Queue aneb implementace front zpráv bez použití klasického message brokera</h2>

<p>V&nbsp;dnešní části seriálu o message brokerech se seznámíme se zajímavou
knihovnou nazvanou <strong>Durable Queue</strong>. Jedná se o knihovnu určenou
zejména pro ty vývojáře, kteří pracují s&nbsp;programovacím jazykem Clojure.
Tato knihovna nabízí možnost použití front zpráv v&nbsp;rámci jedné aplikace
(přesněji řečeno jednoho běžícího procesu), ovšem s&nbsp;tím velmi důležitým
dodatkem, že fronty (a pochopitelně tedy i jejich obsah) bez problémů přežijí i
případný restart či pád aplikace, protože jejich obsah je uložen na souborovém
systému v&nbsp;nakonfigurovaném adresáři. Navíc je možné specifikovat i způsob
synchronizace obsahu front s&nbsp;obsahem těchto souborů, takže si uživatel
může zvolit očekávané chování aplikace na škále
&bdquo;nejrychlejší&ldquo;&ndash;&bdquo;nejbezpečnější&ldquo;.</p>

<p>V&nbsp;dalším textu se nejprve budeme zabývat popisem možností knihovny
<strong>Durable Queue</strong> a posléze si připomeneme i některé možnosti
nabízené knihovnou <strong>core.anync</strong> a taktéž způsobem propojení
programů psaných v&nbsp;Clojure s&nbsp;message brokerem <i>RabbitMQ</i>
s&nbsp;využitím knihovny <i>Langohr</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozdíly mezi Durable Queue a dalšími implementacemi front zpráv</h2>

<p>Pokud budeme chtít použít nějakou formu fronty zpráv popř.&nbsp;fronty úloh
v&nbsp;aplikacích psaných v&nbsp;programovacím jazyku Clojure, máme
v&nbsp;principu k&nbsp;dispozici čtyři způsoby, které se od sebe odlišují
především tím, zda jsou fronty přímo součástí aplikace, zda
&bdquo;přežijí&ldquo; restart aplikace a zda jsou popř.&nbsp;fronty řešeny
samostatným message brokerem (který navíc může běžet na jiném počítači):</p>

<ol>

<li>První způsob spočívá v&nbsp;použití fronty implementované přímo nějakým
základním datovým typem programovacího jazyka Clojure. Taková fronta je potom
sdílena mezi jednotlivými vlákny aplikace (přičemž typicky některá vlákna
implementují producenty zpráv a další vlákna konzumenty). Jedná se o
nejjednodušší řešení, protože není nutné instalovat a nastavovat message
brokera, fronty jsou uloženy jen v&nbsp;operační paměti, takže nenastávají
problémy s&nbsp;právy v&nbsp;souborovém systému atd. Ovšem i nevýhody jsou
zřejmé &ndash; celé škálování se provádí v&nbsp;rámci jednoho procesu a
případnou persistenci dat musí explicitně zajistit vývojář (a to není zdaleka
tak jednoduché, jak by se na první pohled mohlo zdát).</li>

<li>Explicitní použití fronty popsaného v&nbsp;předchozím bodu je podle mého
názoru zbytečně složité a může vést k&nbsp;potenciálním problémům při sdílení
dat, odstraňování zpráv z&nbsp;front atd. atd. Proto může být v&nbsp;případě,
že fronty budeme potřebovat použít pouze v&nbsp;rámci jednoho procesu, lepší
použít funkce a makra nabízené standardní knihovnou nazvanou
<strong>core.async</strong>, která programátorům nabízí podobnou funkcionalitu,
jako gorutiny a kanály v&nbsp;programovacím jazyku Go. Toto řešení může být pro
většinu řešených problémů takřka ideální, ovšem s&nbsp;jedním dodatkem &ndash;
o případnou persistenci front a správ v&nbsp;nich uložených se opět musí
nějakým vhodným způsobem postaral vývojář aplikace, což může vést
k&nbsp;potenciálním problémům.</li>

<li>Třetí možnost využijí ti programátoři, kteří sice potřebují použít fronty
v&nbsp;rámci jednoho procesu, ovšem s&nbsp;tím, že by zprávy měly přežít i
restart aplikace. Jinými slovy &ndash; obsah front musí být vhodným způsobem
uložen na souborovém systému. Tato možnost je implementována v&nbsp;projektu
(knihovně) <strong>Durable Queue</strong>, který si popíšeme v&nbsp;dnešním
článku. Již na tomto místě je však vhodné upozornit na to, že se nejedná o
implementaci klasického message brokera, ale jen jeho lokální varianty
použitelné pro jednu aplikace (ovšem naopak tato aplikace může sama o sobě být
message brokerem, pokud je to zapotřebí).</li>

<li>Samozřejmě ale můžeme použít i běžné <i>message brokery</i>, které se o
správu front postarají samy. Aplikace psaná v&nbsp;Clojure se k&nbsp;těmto
brokerům většinou připojí s&nbsp;využitím nějakého standardního protokolu,
který se v&nbsp;této oblasti prosadil. Může se jednat například o protokol
<i>STOMP</i>, <i>MQTT</i> či <i>AMQP</i> (různé verze). S&nbsp;tímto konceptem
jsme se ostatně již jednou setkali, a to konkrétně při popisu message brokera
<i>RabbitMQ</i> a knihovny <i>Langohr</i> určené právě pro programovací jazyk
Clojure. Ovšem ve skutečnosti jsou možnosti Clojure (podobně jako i dalších
programovacích jazyků) mnohem větší, protože můžeme použít ty message brokery,
které jsou dodávány/nabízeny jako služba. Příkladem může být <i>SQS</i>
(<i>Simple Queue Service</i>), které je součástí <i>AWS</i> (<i>Amazon Web
Services</i>) či <i>IBM MQ</i>.</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace knihovny Durable Queue</h2>

<p><div class="rs-tip-major">Poznámka: v dalším textu se předpokládá, že máte nainstalován správce projektu Leiningen. Pokud tomu tak není, bude nutné si <a href="https://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">Leiningen nainstalovat</a>, což ve skutečnosti není nic těžkého. Navíc se jedná o velmi užitečný projekt s&nbsp;mnoha přídavnými moduly, které využijete nejenom při testování, ale například i při přípravě dokumentace nebo ve chvíli, kdy se aplikace připravuje na deployment. To, zda je Leiningen nainstalován a lze ho spustit zjistíte například příkazem <strong>which lein</strong>.</div></p>

<pre>
$ <strong>lein new app durable-queue-1</strong>
&nbsp;
Generating a project called durable-queue-1 based on the 'app' template.
</pre>

<p>Výsledkem tohoto příkazu by měla být následující adresářová struktura (obsah
se může nepatrně odlišovat podle verze Leiningenu, ovšem samotná kostra bude
stejná):</p>

<pre>
.
└── durable-queue-1
    ├── doc
    │   └── intro.md
    ├── LICENSE
    ├── project.clj
    ├── README.md
    ├── resources
    ├── src
    │   └── durable_queue_1
    │       └── core.clj
    └── test
        └── durable_queue_1
            └── core_test.clj
</pre>

<p>V&nbsp;dalším kroku přistoupíme k&nbsp;úpravám projektového souboru
<strong>project.clj</strong>. Po vytvoření nového projektu by projektový soubor
měl vypadat přibližně takto (pouze si pro jistotu zkontrolujte verzi
interpretru jazyka Clojure; minimální požadovaná verze je 1.8.0):</p>

<pre>
(defproject durable-queue-1 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[<strong>org.clojure/clojure "1.8.0"</strong>]]
  :main ^:skip-aot durable-queue-1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Úprava projektového souboru spočívá v&nbsp;přidání informace o tom, že se
v&nbsp;projektu bude používat knihovna <strong>durable-queue</strong> verze
1.8.0:</p>

<pre>
(defproject durable-queue-1 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.8.0"]
                 <strong>[factual/durable-queue "0.1.5"]</strong>]
  :main ^:skip-aot durable-queue-1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Posledním krokem konfigurace projektu je spuštění příkazu:</p>

<pre>
$ <strong>lein deps</strong>
&nbsp;
Retrieving factual/durable-queue/0.1.5/durable-queue-0.1.5.pom from clojars
Retrieving factual/durable-queue/0.1.5/durable-queue-0.1.5.jar from clojars
</pre>

<p>Tento příkaz zajistí, že se do adresáře <strong>~/.m2/</strong> stáhnou
všechny potřebné knihovny, tj.&nbsp;jak <strong>durable-queue</strong>, tak i
její závislosti.</p>


<p><a name="k04"></a></p>
<h2 id="k04">4. Kostra aplikace používající knihovnu Durable Queue</h2>

<p>Ukažme si tedy kostru aplikace, která bude používat frontu, jejíž obsah bude
uložen v&nbsp;souboru umístěném v&nbsp;adresáři &bdquo;/tmp&ldquo; (můžete si
pochopitelně zvolit i odlišné umístění, teoreticky i na síťovém souborovém
systému). Nejprve je nutné načíst všechny funkce, makra a symboly
z&nbsp;balíčku <strong>durable-queue</strong>. Pro jednoduchost jména všech
objektů vložíme přímo do aktivního jmenného prostoru, takže nebudeme muset
používat prefix (neboli namísto <strong>durable-queue/stats</strong> zavoláme
přímo a jednoduše <strong>stats</strong>):</p>

<pre>
(require '[<strong>durable-queue</strong> :refer :all])
</pre>

<p>Dále musíme knihovnu <strong>durable-queue</strong> inicializovat a určit,
ve kterém adresáři budou uloženy soubory obsahující prvky jednotlivých front.
Výsledkem úspěšné inicializace provedené funkcí <strong>queues</strong> je
struktura, kterou (zde pro jednoduchost) navážeme na globální symbol
<strong>q</strong>:</p>

<pre>
(def q (<strong>queues</strong> "/tmp" {}))
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně je možné v&nbsp;případě
potřeby použít lokální navázání vytvořené s&nbsp;využitím <strong>let</strong>,
například uvnitř nějaké funkce:</div></p>

<pre>
(defn <strong>test</strong>
    []
    (let [q (<strong>queues</strong> "/tmp" {})]
        ...
        ...
        ...))
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vložení zprávy do fronty, přečtení zprávy a změna stavu zprávy</h2>

<p>Ve chvíli, kdy je knihovna <strong>durable-queue</strong> inicializována,
můžeme se začít dotazovat na stav front, posílat zprávy do fronty (operace typu
<i>enqueue</i>), vybírat zprávy z&nbsp;fronty (operace typu <i>dequeue</i>)
apod. Používají se přitom tyto základní funkce, které jsou všechny definovány
v&nbsp;rámci jmenného prostoru <strong>durable-queue</strong>:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>stats</td><td>vrátí informace o stavu všech front</td></tr>
<tr><td>2</td><td>put!</td><td>pošle do vybrané fronty zprávu</td></tr>
<tr><td>3</td><td>take!</td><td>získá z&nbsp;vybrané fronty zprávu</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že funkce
<strong>put!</strong> a <strong>take!</strong> končí vykřičníkem. Jedná se o
velmi často používaný způsob pojmenování těch funkcí, které mění stav aplikace
(resp.&nbsp;nějakého objektu). Podobně predikáty (funkce vracející pravdivostní
hodnotu <strong>true</strong> nebo <strong>false</strong>) mívají na konci
svého jména otazník.</div></p>

<p>Pro posílání zpráv, které je zajištěno funkcí <strong>put!</strong>, není
zapotřebí fronty explicitně vytvářet &ndash; fronta (a k&nbsp;ní příslušející
soubor nebo soubory) se automaticky vytvoří společně s&nbsp;první zprávou,
která je do ní poslána. Můžeme tedy psát:</p>

<pre>
(<strong>put!</strong> q :queue-1 "zpráva")
</pre>

<p>Funkci <strong>put!</strong> jsme předali jak strukturu se stavem všech
front (<strong>q</strong>), tak i jméno fronty (<strong>:queue-1</strong>) a
vlastní zprávu (<strong>"zpráva"</strong>). Tělo zprávy může být reprezentováno
prakticky jakoukoli datovou strukturou programovacího jazyka Clojure; my ovšem
pro jednoduchost použijeme buď řetězec nebo v&nbsp;pozdějších demonstračních
příkladech raději takzvaný <i>keyword</i>.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalších příkladech budeme poměrně
často používat identifikátory, které začínají dvojtečkou. Jedná se o takzvaná
<i>keywords</i>, což je označení, které v&nbsp;programovacím jazyce Clojure
neznamená běžné klíčové slovo, ale jednoznačné a neměnné jméno. To se typicky
používá v&nbsp;těch případech, kdy budeme potřebovat použít symbolickou
konstantu. Navíc je práce s&nbsp;<i>keywords</i> (porovnání na ekvivalenci)
rychlejší, než kdybychom například použili řetězce.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. První demonstrační příklad: inicializace knihovny Durable Queue</h2>

<pre>
(ns durable-queue-1.core
  (:gen-class))

(require '[durable-queue :refer :all])

(defn -main
  "I don't do a whole lot ... yet."
  [& args]
  (let [q (queues "/tmp" {})]
       (println q)
       (println (stats q))))
</pre>

<pre>
#object[durable_queue$queues$reify__7083 0x6afd9125 durable_queue$queues$reify__7083@6afd9125]
{}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>

<pre>
(ns durable-queue-2.core
  (:gen-class))

(require '[durable-queue :refer :all])
(require '[clojure.pprint :refer :all])
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (let [q (queues "/tmp" {})]
       (pprint (stats q))
       (put! q :queue-1 "task #A")
       (put! q :queue-1 "task #B")
       (pprint (stats q))
       (-&gt; (take! q :queue-1) println)
       (pprint (stats q))
       (-&gt; (take! q :queue-1) println)
       (pprint (stats q))))
</pre>

<pre>
{"queue_2"
 {:num-slabs 1,
  :num-active-slabs 0,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 0},
 "queue_1"
 {:num-slabs 1,
  :num-active-slabs 0,
  :enqueued 4,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_2"
 {:num-slabs 1,
  :num-active-slabs 0,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 0},
 "queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 6,
  :retried 0,
  :completed 0,
  :in-progress 0}}
< :in-progress | task #A >
{"queue_2"
 {:num-slabs 1,
  :num-active-slabs 0,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 0},
 "queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 6,
  :retried 0,
  :completed 0,
  :in-progress 1}}
< :in-progress | task #B >
{"queue_2"
 {:num-slabs 1,
  :num-active-slabs 0,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 0},
 "queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 6,
  :retried 0,
  :completed 0,
  :in-progress 2}}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<pre>
(ns durable-queue-3.core
  (:gen-class))
&nbsp;
(require '[durable-queue :refer :all])
(require '[clojure.pprint :refer :all])
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (let [q (queues "/tmp" {})]
       (pprint (stats q))
       (put! q :queue-1 "task #A")
       (put! q :queue-1 "task #B")
       (put! q :queue-2 "task #C")
       (pprint (stats q))
       (println "Získávám dvě zprávy z front queue-1 a queue-2")
       (-&gt; (take! q :queue-1) println)
       (-&gt; (take! q :queue-2) println)
       (pprint (stats q))
       (println "Získávám další dvě zprávy z front queue-1 a queue-2")
       (-&gt; (take! q :queue-1) println)
       (-&gt; (take! q :queue-2) println)
       (pprint (stats q))))
</pre>

<pre>
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 0,
  :completed 0,
  :in-progress 0},
 "queue_2"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 0}}
Získávám dvě zprávy z front queue-1 a queue-2
< :in-progress | task #A >
< :in-progress | task #C >
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 0,
  :completed 0,
  :in-progress 1},
 "queue_2"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 1}}
Získávám další dvě zprávy z front queue-1 a queue-2
< :in-progress | task #B >
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<pre>
(ns durable-queue-4.core
  (:gen-class))
&nbsp;
(require '[durable-queue :refer :all])
(require '[clojure.pprint :refer :all])
&nbsp;
(defn deque-and-complete-message
  [q queue-name]
  (let [message (take! q queue-name)]
       (println "Message dequeued" message)
       (complete! message)
       (println "Message completed" message)))
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (let [q (queues "/tmp" {})]
       (pprint (stats q))
       (put! q :queue-1 "task #A")
       (put! q :queue-1 "task #B")
       (put! q :queue-2 "task #C")
       (pprint (stats q))
       (println "Získávám a kompletuji dvě zprávy z front queue-1 a queue-2")
       (deque-and-complete-message q :queue-1)
       (deque-and-complete-message q :queue-2)
       (pprint (stats q))
       (println "Získávám a kompletuji další dvě zprávy z front queue-1 a queue-2")
       (deque-and-complete-message q :queue-1)
       (deque-and-complete-message q :queue-2)
       (pprint (stats q))))
</pre>

<pre>
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 0,
  :completed 0,
  :in-progress 0},
 "queue_2"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 0}}
Získávám a kompletuji dvě zprávy z front queue-1 a queue-2
Message dequeued < :in-progress | task #A >
Message completed < :complete | task #A >
Message dequeued < :in-progress | task #C >
Message completed < :complete | task #C >
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 0,
  :completed 1,
  :in-progress 0},
 "queue_2"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 0,
  :completed 1,
  :in-progress 0}}
Získávám a kompletuji další dvě zprávy z front queue-1 a queue-2
Message dequeued < :in-progress | task #B >
Message completed < :complete | task #B >
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
(ns durable-queue-5.core
  (:gen-class))

(require '[durable-queue :refer :all])
(require '[clojure.pprint :refer :all])

(defn deque-and-retry-message
  [q queue-name]
  (let [message (take! q queue-name)]
       (println "Message dequeued" message)
       (retry! message)
       (println "Message completed" message)))
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (let [q (queues "/tmp" {})]
       (pprint (stats q))
       (put! q :queue-1 "task #A")
       (put! q :queue-1 "task #B")
       (put! q :queue-2 "task #C")
       (pprint (stats q))
       (println "Získávám dvě zprávy z front queue-1 a queue-2, které budou uloženy zpět")
       (deque-and-retry-message q :queue-1)
       (deque-and-retry-message q :queue-2)
       (pprint (stats q))
       (println "Získávám další dvě zprávy z front queue-1 a queue-2, které budou uloženy zpět")
       (deque-and-retry-message q :queue-1)
       (deque-and-retry-message q :queue-2)
       (pprint (stats q))))
</pre>

<pre>
{}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 0,
  :completed 0,
  :in-progress 0},
 "queue_2"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 0}}
Získávám dvě zprávy z front queue-1 a queue-2, které budou uloženy zpět
Message dequeued < :in-progress | task #A >
Message completed < :incomplete | task #A >
Message dequeued < :in-progress | task #C >
Message completed < :incomplete | task #C >
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 1,
  :completed 0,
  :in-progress 0},
 "queue_2"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 1,
  :completed 0,
  :in-progress 0}}
Získávám další dvě zprávy z front queue-1 a queue-2, které budou uloženy zpět
Message dequeued < :in-progress | task #B >
Message completed < :incomplete | task #B >
Message dequeued < :in-progress | task #C >
Message completed < :incomplete | task #C >
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 2,
  :completed 0,
  :in-progress 0},
 "queue_2"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 2,
  :completed 0,
  :in-progress 0}}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
(ns durable-queue-6.core
  (:gen-class))

(require '[durable-queue :refer :all])
(require '[clojure.pprint :refer :all])

(defn deque-and-retry-message
  [q queue-name]
  (let [message (take! q queue-name)]
       (println "Message dequeued" message)
       (retry! message)
       (println "Message completed" message)))

(defn -main
  [& args]
  (let [q (queues "/tmp" {:max-queue-size 10})]
       (pprint (stats q))
       (doseq [i (range 20)]
           (put! q :queue-1 (str "task #" i))
           (pprint (stats q)))))
</pre>

<pre>
{}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 3,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 4,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 5,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 6,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 7,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 8,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 9,
  :retried 0,
  :completed 0,
  :in-progress 0}}
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 10,
  :retried 0,
  :completed 0,
  :in-progress 0}}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
(ns durable-queue-7.core
  (:gen-class))

(require '[durable-queue :refer :all])
(require '[clojure.pprint :refer :all])

(defn sleep
  [amount]
  (Thread/sleep amount))

(defn worker
  [q queue-name]
  (println "Worker started")
  (while true
     (let [message (take! q queue-name)]
        (println "Worker received message" (deref message))
        (complete! message)
        (sleep 2000)
        (println "Worker completed message" (deref message)))))

(defn -main
  [& args]
  (let [q (queues "/tmp" {:max-queue-size 10})]
       (pprint (stats q))
       (println "Starting worker")
       (.start (Thread. (fn [] (worker q :queue-1))))
       (doseq [i (range 10)]
           (println "Enqueuing task #" i)
           (put! q :queue-1 (str "task #" i))
           (pprint (stats q))
           (sleep 1000))))
</pre>

<pre>
{}
Starting worker
Worker started
Enqueuing task # 0
{"queue_1"
 Worker received message task #0
{:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 1}}
Enqueuing task # 1
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 0,
  :completed 1,
  :in-progress 0}}
Worker completed message task #0
Worker received message task #1
Enqueuing task # 2
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 3,
  :retried 0,
  :completed 2,
  :in-progress 0}}
Enqueuing task # 3
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 4,
  :retried 0,
  :completed 2,
  :in-progress 0}}
Worker completed message task #1
Worker received message task #2
Enqueuing task # 4
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 5,
  :retried 0,
  :completed 3,
  :in-progress 0}}
Enqueuing task # 5
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 6,
  :retried 0,
  :completed 3,
  :in-progress 0}}
Worker completed message task #2
Worker received message task #3
Enqueuing task # 6
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 7,
  :retried 0,
  :completed 4,
  :in-progress 0}}
Enqueuing task # 7
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 8,
  :retried 0,
  :completed 4,
  :in-progress 0}}
Worker completed message task #3
Worker received message task #4
Enqueuing task # 8
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 9,
  :retried 0,
  :completed 5,
  :in-progress 0}}
Enqueuing task # 9
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 10,
  :retried 0,
  :completed 5,
  :in-progress 0}}
Worker completed message task #4
Worker received message task #5
Worker completed message task #5
Worker received message task #6
Worker completed message task #6
Worker received message task #7
Worker completed message task #7
Worker received message task #8
Worker completed message task #8
Worker received message task #9
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
(ns durable-queue-8.core
  (:gen-class))

(require '[durable-queue :refer :all])
(require '[clojure.pprint :refer :all])

(defn sleep
  [amount]
  (Thread/sleep amount))

(defn worker
  [q queue-name]
  (println "Worker started")
  (loop []
    (let [message (take! q queue-name)
          value   (deref message)]
        (if (=  value :exit)
            (println "Stopping worker")
            (do
                (println "Worker received message" value)
                (complete! message)
                (sleep 2000)
                (println "Worker completed message" value)
                (recur))))))

(defn -main
  [& args]
  (let [q (queues "/tmp" {:max-queue-size 10})]
       (pprint (stats q))
       (println "Starting worker")
       (.start (Thread. (fn [] (worker q :queue-1))))
       (doseq [i (range 10)]
           (println "Enqueuing task #" i)
           (put! q :queue-1 (str "task #" i))
           (pprint (stats q))
           (sleep 1000))
       (println "Enqueuing task to stop worker")
       (put! q :queue-1 :exit)
       (println "All tasks has been scheduled")))
</pre>

<pre>
{}
Starting worker
Enqueuing task # Worker started
0
{"queue_1"Worker received message task #0

 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 1}}
Enqueuing task # 1
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 0,
  :completed 1,
  :in-progress 0}}
Worker completed message task #0
Worker received message task #1
Enqueuing task # 2
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 3,
  :retried 0,
  :completed 2,
  :in-progress 0}}
Enqueuing task # 3
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 4,
  :retried 0,
  :completed 2,
  :in-progress 0}}
Worker completed message task #1
Worker received message task #2
Enqueuing task # 4
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 5,
  :retried 0,
  :completed 3,
  :in-progress 0}}
Enqueuing task # 5
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 6,
  :retried 0,
  :completed 3,
  :in-progress 0}}
Worker completed message task #2
Worker received message task #3
Enqueuing task # 6
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 7,
  :retried 0,
  :completed 4,
  :in-progress 0}}
Enqueuing task # 7
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 8,
  :retried 0,
  :completed 4,
  :in-progress 0}}
Worker completed message task #3
Worker received message task #4
Enqueuing task # 8
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 9,
  :retried 0,
  :completed 5,
  :in-progress 0}}
Enqueuing task # 9
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 10,
  :retried 0,
  :completed 5,
  :in-progress 0}}
Worker completed message task #4
Worker received message task #5
Enqueuing task to stop worker
All tasks has been scheduled
Worker completed message task #5
Worker received message task #6
Worker completed message task #6
Worker received message task #7
Worker completed message task #7
Worker received message task #8
Worker completed message task #8
Worker received message task #9
Worker completed message task #9
Stopping worker
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
(ns durable-queue-9.core
  (:gen-class))
&nbsp;
(require '[durable-queue :refer :all])
(require '[clojure.pprint :refer :all])
&nbsp;
(defn sleep
  [amount]
  (Thread/sleep amount))
&nbsp;
(defn <strong>worker</strong>
  [q queue-name]
  (println "Worker started, using queue" queue-name)
  (loop []
    (let [message (take! q queue-name)
          value   (deref message)]
        (if (=  value :exit)
            (println "Stopping worker that use queue" (name queue-name))
            (do
                (println "Worker received message" value "from queue" (name queue-name))
                (complete! message)
                (sleep 2000)
                (println "Worker completed message" value "from queue" (name queue-name))
                (recur))))))
&nbsp;
(def queue-names
    [:queue-1 :queue-2 :queue-3])
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (let [q (queues "/tmp" {:max-queue-size 10})]
       (pprint (stats q))
&nbsp;
       (println "Starting workers")
       (doseq [queue queue-names]
           (.start (Thread. (fn [] (worker q queue)))))
&nbsp;
       (doseq [queue queue-names]
           (doseq [i (range 10)]
               (println "Enqueuing task #" i)
               (put! q queue (str "task #" i))
               (pprint (stats q))
               (sleep 500))
           (println "Enqueuing task to stop worker subscribed to queue" (name queue))
           (put! q queue :exit))
&nbsp;
       (println "All tasks has been scheduled")))
</pre>

<pre>
{}
Starting workers
Enqueuing task # Worker started, using queue :queue-1
Worker started, using queue :queue-3
Worker started, using queue :queue-2
0
{"queue_1"
Worker received message  task #0 from queue queue-1
{:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 1,
  :retried 0,
  :completed 0,
  :in-progress 1}}
Enqueuing task # 1
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 2,
  :retried 0,
  :completed 1,
  :in-progress 0}}
Enqueuing task # 2
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 3,
  :retried 0,
  :completed 1,
  :in-progress 0}}
Enqueuing task # 3
{"queue_1"
 {:num-slabs 1,
  :num-active-slabs 1,
  :enqueued 4,
  :retried 0,
  :completed 1,
  :in-progress 0}}
Worker completed message task #0 from queue queue-1
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p>V&nbsp;závěrečné části článku si připomeneme, jakým způsobem lze se systémem RabbitMQ komunikovat z&nbsp;programovacího jazyka Clojure. Pro tento jazyk vzniklo hned několik knihoven, které rozhraní k&nbsp;RabbitMQ realizují.  Většina těchto knihoven je postavena na tzv.&nbsp;Java interop (interoperabilita mezi Javou a Clojure). Rozdíly mezi knihovnami spočívají v&nbsp;tom, zda se skutečně jedná o pouhou úzkou vrstvičku mezi Javou a Clojure či zda knihovna realizuje vlastní složitější (a abstraktnější) framework.  Protože se zabýváme především RabbitMQ a nikoli nad ním postavenými systémy, použijeme knihovnu Langohr, která nám nebude poskytovat příliš abstraktní operace, což je dobře, protože jediné, co budeme potřebovat, je získávání zpráv z&nbsp;fronty s&nbsp;jejich dalším zpracováním.</p>

<p>Samotná implementace konzumenta zpráv (vzniklá úpravou <a href="http://clojurerabbitmq.info/articles/getting_started.html">getting started příkladu</a>) je při použití programovacího jazyka Clojure nepatrně delší, než je tomu v&nbsp;případě Pythonu. Je tomu tak především proto, že knihovna Langohr je rozdělena na víc částí a budeme muset provést import čtyř konkrétních jmenných prostorů:</p>

<pre>
(require '[langohr.core      :as rabbit-mq])
(require '[langohr.channel   :as l-channel])
(require '[langohr.queue     :as l-queue])
(require '[langohr.consumers :as l-consumers])
</pre>

<p>Dále je v&nbsp;konzumentovi deklarována callback funkce zavolaná při příjmu každé zprávy. Povšimněte si, že tělo zprávy (poslední parametr) je typu <i>bytes</i>, ovšem v&nbsp;těle callback funkce ze sekvence bajtů vytvoříme řetězec. Zajímavý je i <i>destructuring</i> [<a href="http://clojure-doc.org/articles/language/functions.html#map-destructuring">1</a>] použitý u druhého parametru. Jedná se o specialitu nabízenou některými Lispovskými jazyky ve chvíli, kdy se do funkcí předávají sekvence, vektory nebo mapy (slovníky):</p>

<pre>
(defn message-handler
    [ch {:keys [content-type delivery-tag type] :as meta} ^bytes payload]
    (println (format "Received a message: %s" (String. payload "UTF-8"))))
</pre>

<p>Zbývá nám provést připojení k&nbsp;RabbitMQ a vytvoření komunikačního kanálu:</p>

<pre>
(let [conn  (rabbit-mq/connect)
      ch    (l-channel/open conn)]
</pre>

<p>Další postup je prakticky totožný s&nbsp;kódem naprogramovaným v&nbsp;Pythonu: deklarace fronty, s&nbsp;níž se pracuje, přihlášení k&nbsp;příjmu zpráv s&nbsp;registrací callback funkce a na konci aplikace úklid &ndash; uzavření komunikačního kanálu a uzavření připojení k&nbsp;RabbitMQ:</p>

<pre>
(l-queue/declare ch "test" {:exclusive false :auto-delete false})
(l-consumers/subscribe ch "test" message-handler {:auto-ack true})
(println (format "Connected to channel id: %d" (.getChannelNumber ch)))
(Thread/sleep 10000)
(println "Disconnecting...")
(rabbit-mq/close ch)
(rabbit-mq/close conn)))
</pre>

<p>Výsledný kód realizující celého konzumenta vypadá následovně:</p>

<pre>
(ns example-01.core
    (:gen-class))
&nbsp;
(require '[langohr.core      :as rabbit-mq])
(require '[langohr.channel   :as l-channel])
(require '[langohr.queue     :as l-queue])
(require '[langohr.consumers :as l-consumers])
&nbsp;
&nbsp;
(defn message-handler
    [ch {:keys [content-type delivery-tag type] :as meta} ^bytes payload]
    (println (format "Received a message: %s" (String. payload "UTF-8"))))
&nbsp;
&nbsp;
(defn -main
    [&amp; args]
    (let [conn  (rabbit-mq/connect)
          ch    (l-channel/open conn)]
      (l-queue/declare ch "test" {:exclusive false :auto-delete false})
      (l-consumers/subscribe ch "test" message-handler {:auto-ack true})
      (println (format "Connected to channel id: %d" (.getChannelNumber ch)))
      (Thread/sleep 10000)
      (println "Disconnecting...")

<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p>V&nbsp;závěrečné části článku si připomeneme, jakým způsobem lze se systémem RabbitMQ komunikovat z&nbsp;programovacího jazyka Clojure. Pro tento jazyk vzniklo hned několik knihoven, které rozhraní k&nbsp;RabbitMQ realizují.  Většina těchto knihoven je postavena na tzv.&nbsp;Java interop (interoperabilita mezi Javou a Clojure). Rozdíly mezi knihovnami spočívají v&nbsp;tom, zda se skutečně jedná o pouhou úzkou vrstvičku mezi Javou a Clojure či zda knihovna realizuje vlastní složitější (a abstraktnější) framework.  Protože se zabýváme především RabbitMQ a nikoli nad ním postavenými systémy, použijeme knihovnu Langohr, která nám nebude poskytovat příliš abstraktní operace, což je dobře, protože jediné, co budeme potřebovat, je získávání zpráv z&nbsp;fronty s&nbsp;jejich dalším zpracováním.</p>




<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacím jazyku Clojure byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
stále ještě doslova několik kilobajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>Příklad</th><th>Skript</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>1</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-1/">https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-1/</a></td></tr>
<tr><td>2</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-2/">https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-2/</a></td></tr>
<tr><td>3</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-3/">https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-3/</a></td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-4/">https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-4/</a></td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-5/">https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-5/</a></td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-6/">https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-6/</a></td></tr>
<tr><td>7</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-7/">https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-7/</a></td></tr>
<tr><td>8</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-8/">https://github.com/tisnik/message-queues-examples/blob/master/durable-queue/durable-queue-8/</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Dramatiq: simple task processing<br />
<a href="https://dramatiq.io/">https://dramatiq.io/</a>
</li>

<li>Cookbook (for Dramatiq)<br />
<a href="https://dramatiq.io/cookbook.html">https://dramatiq.io/cookbook.html</a>
</li>

<li>Balíček dramatiq na PyPi<br />
<a href="https://pypi.org/project/dramatiq/">https://pypi.org/project/dramatiq/</a>
</li>

<li>Dramatiq dashboard<br />
<a href="https://github.com/Bogdanp/dramatiq_dashboard">https://github.com/Bogdanp/dramatiq_dashboard</a>
</li>

<li>Dramatiq na Redditu<br />
<a href="https://www.reddit.com/r/dramatiq/">https://www.reddit.com/r/dramatiq/</a>
</li>

<li>A Dramatiq broker that can be used with Amazon SQS<br />
<a href="https://github.com/Bogdanp/dramatiq_sqs">https://github.com/Bogdanp/dramatiq_sqs</a>
</li>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

<li>nng (nanomsg-next-generation)<br />
<a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>
</li>

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

