<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Nástroj huey: další užitečná knihovna pro práci s frontami úloh v Pythonu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>


<body>

<h1>Nástroj huey: další užitečná knihovna pro práci s frontami úloh v Pythonu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V seriálu o message brokerech a na nich založených technologiích jsme se již seznámili s několika nástroji umožňujícími plánování asynchronně spouštěných úloh v Pythonu. Jednalo se o nástroje RQ, Celery či Dramatiq. Dnes si popíšeme čtvrtý nástroj podobného typu, který se jmenuje Huey.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Nástroj <strong>huey</strong> aneb další užitečná knihovna pro práci s&nbsp;frontami úloh v&nbsp;Pythonu</a></p>
<p><a href="#k02">2. Základní vlastnosti systému <strong>huey</strong></a></p>
<p><a href="#k03">3. Porovnání Huey s&nbsp;dalšími podobně koncipovanými nástroji</a></p>
<p><a href="#k04">4. Instalace balíčku <strong>huey</strong></a></p>
<p><a href="#k05">5. Instalace a spuštění Redisu</a></p>
<p><a href="#k06">6. Ověření základní funkcionality Redisu</a></p>
<p><a href="#k07">7. Naprogramování a spuštění konzumenta zpráv (workera)</a></p>
<p><a href="#k08">8. Naplánování úlohy pro workera</a></p>
<p><a href="#k09">9. Čekání na výsledek činnosti workera</a></p>
<p><a href="#k10">10. Déletrvající úloha</a></p>
<p><a href="#k11">11. Větší množství úloh zpracovaných jediným workerem</a></p>
<p><a href="#k12">12. Větší množství úloh zpracovaných množinou workerů</a></p>
<p><a href="#k13">13. Získání dalších informací o úloze</a></p>
<p><a href="#k14">14. Chování systému při havárii úlohy ve workerovi</a></p>
<p><a href="#k15">15. Naplánování periodicky se opakující úlohy</a></p>
<p><a href="#k16">16. Korektní spuštění skupiny úloh</a></p>
<p><a href="#k17">*** 17. Prioritní úlohy</a></p>
<p><a href="#k18">18. Plánování různých úloh s&nbsp;odlišnou implementací workerů</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nástroj <strong>huey</strong> aneb další užitečná knihovna pro práci s&nbsp;frontami úloh v&nbsp;Pythonu</h2>

<p>V&nbsp;poněkud nepravidelně vycházejícím <a
href="https://www.root.cz/serialy/message-brokery/">seriálu o message brokerech
a na nich založených technologiích</a> jsme se již setkali s&nbsp;relativně
velkým množstvím projektů určených pro programovací jazyk <a
href="https://www.root.cz/n/python/">Python</a>, které vývojářům
zprostředkovávají vysokoúrovňové rozhraní k&nbsp;message brokerům
popř.&nbsp;pro naplánování asynchronně spouštěných úloh. Jen pro úplnost si
připomeňme, že se jedná především o projekty nazvané <a
href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">RQ
(Redis Queue)</a> (pravděpodobně nejsnadněji použitelný systém vůbec), <a
href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">Celery</a>
(ten naproti tomu nabízí největší možnosti konfigurace) či <a
href="https://www.root.cz/clanky/dramatiq-knihovna-pro-praci-s-frontami-uloh-v-pythonu/">Dramatiq</a>.
Na podobném způsobu práce, tj.&nbsp;na plánování úloh s&nbsp;jejich pozdějším a
navíc i asynchronním zpracováním (více) workery je založen i projekt nazvaný
<i>Huey</i>, jímž se budeme zabývat v&nbsp;dnešním článku.</p>

<a href="https://www.root.cz/obrazek/347323/"><img src="https://i.iinfo.cz/images/368/rq-1.png" class="image-347323" alt="&#160;" width="309" height="135" /></a>
<p><i>Obrázek 1: Typická a již několikrát ukázaná konfigurace systému
s&nbsp;frontami úloh. Zde se konkrétně používá jediná fronta nazvaná
&bdquo;default&ldquo;, do které se mohou úlohy přidávat několika programy (těch
může být libovolné množství). Samotné zpracování úloh je reprezentováno ve
workerech, kterých taktéž může být libovolné množství podle požadavků aplikace,
dostupných zdrojů atd. atd. Navíc je možné, aby v&nbsp;systému existovalo větší
množství pojmenovaných front. Fronty je tak možné rozdělit podle priority, typu
zpracovávaných úloh apod. Existuje dokonce jedna fronta, do níž se ukládají ty
úlohy, na nichž worker zhavaroval (což si vysvětlíme v&nbsp;dalším
textu).</i></p>

<p>Zdrojové kódy tohoto projektu nalezneme na GitHubu, konkrétně na stránce <a
href="https://github.com/coleifer/huey">https://github.com/coleifer/huey</a>.
K&nbsp;dispozici je pochopitelně i dokumentace <a
href="https://huey.readthedocs.io/en/latest/">nasdílená na stránkách</a> <a
href="https://readthedocs.org/">Read the Docs</a> a celý projekt je dostupný i
ve formě běžného <a href="https://pypi.org/project/huey/">Pythonovského
balíčku</a> na serveru <a href="https://pypi.org/">Python Package Index
(PyPI)</a>. Celá instalace, kterou si popíšeme v&nbsp;navazujících kapitolách,
je prakticky bezproblémová, ovšem následně je nutné zvolit metodu pro uložení
jednotlivých úloh, což již většinou vyžaduje konfiguraci Redisu, SQLite či
dalších služeb.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní vlastnosti systému <strong>huey</strong></h2>

<p>Základní koncept, na němž je <i>huey</i> postaven, se prakticky neliší od
podobně koncipovaných projektů zmíněných již <a href="#k01">v&nbsp;úvodní
kapitole</a>. Jedná se o plánování úloh zpracovávaných samostatně běžícími
workery, kteří mohou výsledky posílat (přes message brokera) zpět. Navíc má
ovšem Huey i několik zajímavých vlastností, které ho do jisté míry odlišují od
klasických systémů pro plánování úloh. Zejména mají vývojáři a administrátoři
poměrně velkou volnost ve volbě systému pro uložení zpráv (reprezentujících
jednotlivé úlohy). Použít lze <i>Redis</i> (což se zdá být v&nbsp;této oblasti
klasické a v&nbsp;praxi ověřené řešení), SQLite a popř.&nbsp;i uložení zpráv
pouze v&nbsp;operační paměti. Zajímavější jsou ovšem možnosti spouštění
workerů. Těch může být prakticky libovolné množství a lze použít spuštění
každého workera ve vlastním procesu (tj.&nbsp;každý worker poběží zcela
izolovaně od ostatních workerů), ve vláknech jediného procesu popř.&nbsp;lze
použít takzvané <a
href="https://greenlet.readthedocs.io/en/latest/">greenlety</a>. Záleží tedy na
konkrétních požadavcích, který způsob je nejvíc vyhovující, samozřejmě ovšem
s&nbsp;tím, že multivláknové řešení nutně dříve či později narazí na <a
href="https://en.wikipedia.org/wiki/Global_interpreter_lock">Global interpreter
lock &ndash; GIL</a>, s&nbsp;čímž je nutné počítat.</p>

<p><div class="rs-tip-major">Poznámka: o <i>greenletech</i>, což je ve světě
Pythonu velmi užitečná technologie, vyjde samostatný článek.</div></p>

<p>Ovšem i přesto, že je <i>Huey</i> pojat poměrně minimalisticky, v&nbsp;něm
nalezneme i další relativně pokročilé techniky. Například je umožněno
naplánování úloh na určitou dobu popř.&nbsp;až po uplynutí nějaké doby (což
vzdáleně odpovídá možnostem příkazů <i>cron</i> a <i>at</i>). Dále je možné
vytvořit úlohy spouštěné opakovaně, tedy opět podobným způsobem, jaký známe na
úrovni operačního systému a nástroje <i>cron</i>. Úlohy je možné i
prioritizovat popř.&nbsp;si zvolit, kam se mají uložit jejich výsledky (na
které se tedy nemusí aktivně čekat). A konečně je podporována i tvorba
<i>pipeline</i> a zřetězení úloh, což je téma, kterému se budeme věnovat
v&nbsp;pozdějším textu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Porovnání Huey s&nbsp;dalšími podobně koncipovanými nástroji</h2>

<p>V&nbsp;následující tabulce jsou pro větší přehlednost porovnány čtyři
systémy s&nbsp;implementací front zpráv (většinou spojených i s&nbsp;plánováním
úloh) pro programovací jazyk Python, samozřejmě včetně dnes popisovaného
projektu <i>Huey</i>:</p>

<table>
<tr><th> #</th><th>Vlastnost</th><th>Dramatiq</th><th>Celery</th><th>Huey</th><th>RQ</th></tr>
<tr><td> 1</td><td>podpora Pythonu 2</td><td>&#x274c;</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td></tr>
<tr><td> 2</td><td>jednoduchá implementace</td><td>&#x2713;</td><td>&#x274c;</td><td>&#x2713;</td><td>&#x2713;</td></tr>
<tr><td> 3</td><td>automatické přeposlání zhavarovaných úloh</td><td>&#x2713;</td><td>&#x274c;</td><td>&#x2713;</td><td>&#x274c;</td></tr>
<tr><td> 4</td><td>zajištění doručení úlohy</td><td>&#x2713;</td><td>&#x274c;</td><td>&#x274c;</td><td>&#x274c;</td></tr>
<tr><td> 5</td><td>omezení počtu zpráv</td><td>&#x2713;</td><td>&#x274c;</td><td>&#x2713;</td><td>&#x274c;</td></tr>
<tr><td> 6</td><td>specifikace priority úlohy</td><td>&#x2713;</td><td>&#x274c;</td><td>&#x274c;</td><td>&#x274c;</td></tr>
<tr><td> 7</td><td>úlohy naplánované na pozdější dobu</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x274c;</td></tr>
<tr><td> 8</td><td>plánování úloh ve stylu <i>cronu</i></td><td>&#x274c;</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x274c;</td></tr>
<tr><td> 9</td><td>podpora pro kolony (pipeline)</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x274c;</td></tr>
<tr><td>10</td><td>možnost uložení výsledků do databáze (Redis...)</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td></tr>
<tr><td>11</td><td>automatické znovunačtení kódu workera při změně</td><td>&#x2713;</td><td>&#x274c;</td><td>&#x274c;</td><td>&#x274c;</td></tr>
<tr><td>12</td><td>podpora RabbitMQ jako brokera</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x274c;</td></tr>
<tr><td>13</td><td>podpora Redisu jako brokera</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td></tr>
<tr><td>14</td><td>podpora brokera umístěného v&nbsp;paměti</td><td>&#x2713;</td><td>&#x274c;</td><td>&#x2713;</td><td>&#x274c;</td></tr>
<tr><td>15</td><td>podpora <a href="https://greenlet.readthedocs.io/en/latest/">greenletů</a></td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x274c;</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace balíčku <strong>huey</strong></h2>

<p>Již <a href="#k01">v&nbsp;úvodní kapitole</a> jsme si řekli, že na serveru
<a href="https://pypi.org/">PyPi</a> je k&nbsp;dispozici balíček
<strong>huey</strong>, což mj.&nbsp;znamená, že by instalace měla být velmi
jednoduchá. Projekt neobsahuje žádné nativní části a lze ho (podle očekávání)
nainstalovat i lokálně, tj.&nbsp;pro aktuálně přihlášeného uživatele:</p>

<pre>
$ <strong>pip3 install --user huey</strong>
&nbsp;
Collecting huey
  Downloading https://files.pythonhosted.org/packages/c8/9e/251085ab3369ca71448812cac43ec3fc6f23dd9dd8df162b8bbe8024b672/huey-2.2.0.tar.gz (622kB)
    100% |████████████████████████████████| 624kB 896kB/s 
Installing collected packages: huey
  Running setup.py install for huey ... done
Successfully installed huey-2.2.0
</pre>

<p>Rychlá kontrola instalace provedená přímo v&nbsp;REPLu programovacího jazyka
Python může vypadat například takto:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.6.6 (default, Jul 19 2018, 16:29:00) 
[GCC 7.3.1 20180303 (Red Hat 7.3.1-5)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&nbsp;
&gt;&gt;&gt; <strong>import huey</strong>
&nbsp;
&gt;&gt;&gt; <strong>help(huey)</strong>
&nbsp;
Help on package huey:
&nbsp;
NAME
    huey
&nbsp;
PACKAGE CONTENTS
    api
    bin (package)
    constants
</pre>

<p>Před použitím tohoto balíčku však ještě musíme doinstalovat <i>Redis</i>
použitý pro uložení úloh a popř.&nbsp;i jejich výsledků.</p>

<p><div class="rs-tip-major">Poznámka: striktně řečeno vlastně není
<i>Redis</i> nutný, protože zprávy (úlohy) mohou být uloženy pouze
v&nbsp;operační paměti. To je ovšem řešení poměrně nevhodné pro praktické
použití, protože by celý systém měl &bdquo;přežít&ldquo; svůj restart a
neztratit přitom naplánované úlohy ani výsledky již dokončených úloh.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instalace a spuštění Redisu</h2>

<p>Systém Huey může používat hned několik způsobů ukládání zpráv do nějakého
úložiště, které by mělo přežít restart samotného plánovače úloh. Nejlépe se mi
osvědčilo použití již několikrát zmíněného systému <i>Redis</i> (viz též články
<a
href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">Databáze
Redis (nejenom) pro vývojáře používající Python</a> a <a
href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">Databáze
Redis (nejenom) pro vývojáře používající Python (dokončení)</a>, v&nbsp;nichž
jsme se s&nbsp;tímto systémem alespoň na základní úrovni seznámili), takže si
před odzkoušením demonstračních příkladů <i>Redis</i> nainstalujeme a spustíme.
Samotná instalace je ve skutečnosti velmi snadná, protože systém <i>Redis</i>
je dnes nabízen jako standardní balíček ve většině Linuxových distribucí.
Příkladem mohou být distribuce založené na RPM balíčcích, v&nbsp;nichž se dnes
instalace provede následovně:</p>

<pre>
$ <strong>sudo dnf install redis</strong>
</pre>

<p>popř.&nbsp;na starších systémech:</p>

<pre>
$ <strong>sudo yum install redis</strong>
</pre>

<p>Na systémech založených na Debianu (včetně Ubuntu) lze pro instalaci použít
příkaz:</p>

<pre>
$ <strong>apt-get install redis-server</strong>
</pre>

<p>Teoreticky je možné pro práci s&nbsp;Redisem, přesněji řečeno pro jeho
spuštění jako služby, ponechat většinu standardních nastavení, ovšem výhodnější
bude (zejména pro první seznamování) minimálně omezit viditelnost běžícího
serveru pouze pro lokální procesy. Jedno z&nbsp;možných nastavení bylo popsáno
<a
href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/#k03">zde</a>.
Toto nastavení je možné získat příkazem:</p>

<pre>
$ <strong>wget https://raw.githubusercontent.com/tisnik/presentations/master/redis/redis.conf</strong>
</pre>

<p>Po nastavení (popř.&nbsp;po ponechání standardního nastavení) je možné
systém Redis spustit jako službu (démona), a to příkazem:</p>

<pre>
$ <strong>redis-server redis.conf</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: předpokládá se, že konfigurační soubor
<strong>redis.conf</strong> je umístěn v&nbsp;aktuálním adresáři.</div></p>

<p>Služba <i>redis</i> by se měla spustit, což je patrné i při pohledu do
logovacího souboru:</p>

<pre>
15018:C 13 Jun 20:28:15.250 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
15018:C 13 Jun 20:28:15.250 # Redis version=4.0.10, bits=64, commit=00000000, modified=0, pid=15018, just started
15018:C 13 Jun 20:28:15.250 # Configuration loaded
15018:C 13 Jun 20:28:15.250 * supervised by systemd, will signal readiness
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 4.0.10 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 15018
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'
&nbsp;
15018:M 13 Jun 20:28:15.253 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
15018:M 13 Jun 20:28:15.253 # Server initialized
15018:M 13 Jun 20:28:15.254 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_
15018:M 13 Jun 20:28:15.254 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues wi
15018:M 13 Jun 20:28:15.254 * DB loaded from disk: 0.000 seconds
15018:M 13 Jun 20:28:15.254 * Ready to accept connections
</pre>

<p><div class="rs-tip-major">Poznámka: důležité je, aby se v&nbsp;logu skutečně
objevil poslední řádek &bdquo;Ready to accept connections&ldquo;</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ověření základní funkcionality Redisu</h2>

<p>Na druhém terminálu pak již můžeme spustit klienta Redisu, který uživatelům
nabízí interaktivní příkazový řádek:</p>

<pre>
$ <strong>redis-cli</strong>
</pre>

<p>Pokud služba neběží popř.&nbsp;pokud běží na neznámém portu, vypíše se:</p>

<pre>
Could not connect to Redis at 127.0.0.1:6379: Connection refused
Could not connect to Redis at 127.0.0.1:6379: Connection refused
</pre>

<p>Po doufejme že úspěšném připojení si příkazem &bdquo;ping&ldquo; můžeme
otestovat, jestli se klient připojí k&nbsp;serveru a zda od něj dokáže získávat
odpovědi:</p>

<pre>
127.0.0.1:6379&gt; <strong>ping</strong>
PONG
&nbsp;
127.0.0.1:6379&gt; <strong>ping test</strong>
"test"
</pre>

<p>K&nbsp;dispozici je i neinteraktivní příkaz &bdquo;help&ldquo;:</p>

<pre>
127.0.0.1:6379&gt; <strong>help</strong>
redis-cli 4.0.10
To get help about Redis commands type:
      "help @&lt;group&gt;" to get a list of commands in &lt;group&gt;
      "help &lt;command&gt;" for help on &lt;command&gt;
      "help &lt;tab&gt;" to get a list of possible help topics
      "quit" to exit
&nbsp;
To set redis-cli preferences:
      ":set hints" enable online hints
      ":set nohints" disable online hints
Set your preferences in ~/.redisclirc
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;navazujících kapitolách již
s&nbsp;Redisem přímo pracovat nebudeme, protože ostatní operace (zejména
plánování a spouštění úloh) za nás bude automaticky provádět právě knihovna
<i>Huey</i>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Naprogramování a spuštění konzumenta zpráv (workera)</h2>

<p>Nyní si již můžeme vytvořit jednoduchého konzumenta zpráv neboli
<i>workera</i>. Ten bude obsahovat funkci <strong>add</strong>, která však
nebude volána přímo jiným kódem, ale nepřímo &ndash; přes frontu zpráv a tedy i
s&nbsp;využitím message brokera:</p>

<pre>
def <strong>add</strong>(a, b):
    <i>"""Úloha pro součet dvou hodnot."""</i>
    return a + b
</pre>

<p>Samotnou funkci je nutné opatřit dekorátorem <strong>huey.task()</strong>,
přičemž <strong>huey</strong> je objekt získaný konstruktorem
<strong>FileHuey</strong>, <strong>RedisHuey</strong>,
<strong>SqliteHuey</strong> popř.&nbsp;<strong>MemoryHuey</strong>, tedy podle
toho, jaká metoda pro meziuložení zpráv má být použita. V&nbsp;našem případě
používáme systém <i>Redis</i> a tudíž využijeme konstruktor nazvaný
<strong>RedisHuey</strong>. Úplný zdrojový kód workera může vypadat
následovně:</p>

<pre>
<i>"""Úloha pro součet dvou hodnot."""</i>
&nbsp;
from huey import RedisHuey
&nbsp;
huey = RedisHuey()
&nbsp;
&nbsp;
@huey.task()
def <strong>add</strong>(a, b):
    <i>"""Úloha pro součet dvou hodnot."""</i>
    return a + b
</pre>

<p>Workera spustíme příkazem:</p>

<pre>
$ <strong>huey_consumer.py adder.huey</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si označení
<strong>adder.huey</strong> &ndash; zde se tedy nejedná o jméno souboru,
protože zdrojový kód našeho workera je uložen v&nbsp;souboru nazvaném
<strong>adder.py</strong>.</div></p>

<p>Po spuštění by se na terminálu měla objevit zpráva o tom, že byl konzument
(worker) spuštěn, a to v&nbsp;jediném procesu a jediném vláknu. Taktéž se
zobrazí informace o tom, jaký příkaz (posílaný do fronty) či příkazy jsou
dostupné:</p>

<pre>
[2020-06-16 17:42:26,765] INFO:huey.consumer:MainThread:Huey consumer started with <strong>1 thread</strong>, <strong>PID 28279</strong> at 2020-06-16 15:42:26.765337
[2020-06-16 17:42:26,765] INFO:huey.consumer:MainThread:Scheduler runs every 1 second(s).
[2020-06-16 17:42:26,765] INFO:huey.consumer:MainThread:Periodic tasks are enabled.
[2020-06-16 17:42:26,765] INFO:huey.consumer:MainThread:The following commands are available:
+ <strong>adder.add</strong>
</pre>

<p>Tento terminál i s&nbsp;běžícím workerem si nechte otevřený na pozadí.
Plánovač úloh bude spuštěn v&nbsp;jiném terminálu.</p>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód workera naleznete na
adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/huey/adder.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/adder.py</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Naplánování úlohy pro workera</h2>

<p>V&nbsp;dalším kroku pro workera naplánujeme úlohu. Worker dokáže &ndash;
alespoň prozatím &ndash; pouze sečíst dvě čísla (popř.&nbsp;jiné objekty,
například spojit řetězce nebo seznamy), takže naplánování úlohy může vypadat
v&nbsp;první verzi následovně:</p>

<pre>
<i>"""Vytvoření úlohy."""</i>
&nbsp;
from adder import add
&nbsp;
r = add(1, 2)
print(r)
</pre>

<p>Tento skript, který by měl být umístěn ve stejném adresáři jako worker,
spustíme:</p>

<pre>
$ <strong>python3 call_adder.py</strong>
</pre>

<p>Měla by se na jeho standardní výstup vypsat zpráva podobná této zprávě:</p>

<pre>
&lt;Result: task 310a2bf1-a82b-4fe3-9fce-d6171f168fe9&gt;
</pre>

<p>A současně by se na terminálu se spuštěným workerem měla vypsat zpráva o
tom, že byla úloha spuštěna a o několik milisekund později i dokončena.
Povšimněte si, že <a
href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>
úlohy skutečně odpovídá identifikátoru vypsaného v&nbsp;předchozím skriptu:</p>

<pre>
[2020-06-16 17:43:41,179] INFO:huey:Worker-1:Executing adder.add: 11bbcf0d-2b24-4c3e-9a2a-3122ef94e225
[2020-06-16 17:43:41,180] INFO:huey:Worker-1:adder.add: 11bbcf0d-2b24-4c3e-9a2a-3122ef94e225 executed in 0.000s
</pre>

<p>Co to tedy znamená? Úloha byla evidentně naplánována, byla dokonce workerem
provedena (a to asynchronně), ovšem my prozatím nevíme, jakým způsobem získat
výsledek &ndash; proměnná <strong>r</strong> totiž tímto výsledkem není,
protože se jedná o objekt představující samotnou úlohu (<i>job</i>).</p>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód prvního skriptu pro
naplánování úlohy naleznete na adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/huey/call_adder.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/call_adder.py</a>.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Čekání na výsledek činnosti workera</h2>

<p>Výsledek úlohy je teoreticky možné získat přímým zavoláním
<strong>r()</strong> (budeme se tedy k&nbsp;<strong>r</strong> chovat jako
k&nbsp;běžné funkci), ovšem v&nbsp;praxi to nebude tak jednoduché, protože
úloha je spuštěna a vyhodnocena asynchronně, tedy nezávisle na kódu/skriptu,
který ji vyvolal. Proto &ndash; pokud skutečně potřebujeme na výsledek úlohy
počkat &ndash; je nutné při volání <strong>r()</strong> použít nepovinný
parametr <strong>blocking</strong> nastavený na hodnotu <strong>True</strong>.
Existence tohoto parametru zajistí, že volající skript bude skutečně čekat na
dokončení úlohy. Taktéž je možné specifikovat i <strong>timeout</strong>, který
umožní zadání maximálního času čekání (což je pro některé řešené problémy
vhodnější, než obecně nekonečné čekání):</p>

<pre>
<i>"""Vytvoření úlohy."""</i>
&nbsp;
from adder import add
&nbsp;
r = add(1, 2)
print(r)
print(r())
print(r(blocking=True))
</pre>

<p>Chování při spuštění ověří, že první volání <strong>r()</strong> prozatím
nevrátí správný výsledek (přesněji řečeno vrátí <strong>None</strong>), kdežto
druhé volání již ano:</p>

<pre>
&lt;Result: task d5cddf26-9b4f-4653-aa4d-89d7d7d14be6&gt;
None
3
</pre>

<p><div class="rs-tip-major">Poznámka: úplný zdrojový kód druhého skriptu pro
naplánování úlohy naleznete na adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/huey/wait_for_adder.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/wait_for_adder.py</a>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Déletrvající úloha</h2>

<p>Nyní workera zastavíme, a to konkrétně v&nbsp;jeho vlastním terminálu
klávesovou zkratkou <strong>Ctrl+C</strong>:</p>

<pre>
^C[2020-06-13 20:35:02,002] INFO:huey.consumer:MainThread:Received SIGINT
[2020-06-13 20:35:02,002] INFO:huey.consumer:MainThread:Shutting down gracefully...
[2020-06-13 20:35:02,883] INFO:huey.consumer:MainThread:All workers have stopped.
[2020-06-13 20:35:02,884] INFO:huey.consumer:MainThread:Consumer exiting.
</pre>

<p>Spustíme totiž jiného workera, který bude obsahovat stejný algoritmus
součtu, ovšem s&nbsp;přidanou pětisekundovou prodlevou (viz též je <a
href="https://github.com/tisnik/message-queues-examples/blob/master/huey/slow_adder.py">úplný
zdrojový kód</a>):</p>

<pre>
<i>"""Úloha pro součet dvou hodnot."""</i>
&nbsp;
from huey import RedisHuey
&nbsp;
from time import sleep
&nbsp;
huey = RedisHuey()
&nbsp;
&nbsp;
@huey.task()
def <strong>add</strong>(a, b):
    <strong>"""Úloha pro součet dvou hodnot."""</strong>
    sleep(5)
    return a + b
</pre>

<p>Upravený kód workera je uložen v&nbsp;souboru <strong>slow_adder.py</strong>
a spuštěn tedy bude takto:</p>

<pre>
$ <strong>huey_consumer.py slow_adder.huey</strong>
&nbsp;
[2020-06-16 17:53:15,881] INFO:huey.consumer:MainThread:Huey consumer started with 1 thread, PID 29059 at 2020-06-16 15:53:15.881169
[2020-06-16 17:53:15,881] INFO:huey.consumer:MainThread:Scheduler runs every 1 second(s).
[2020-06-16 17:53:15,881] INFO:huey.consumer:MainThread:Periodic tasks are enabled.
[2020-06-16 17:53:15,881] INFO:huey.consumer:MainThread:The following commands are available:
+ slow_adder.add
</pre>

<p>Znovu zkusíme naplánovat úlohu a získat její výsledky:</p>

<pre>
<i>"""Vytvoření úlohy."""</i>
&nbsp;
from slow_adder import add
&nbsp;
r = add(1, 2)
print(r)
print(r())
print(r(blocking=True))
</pre>

<p>Po spuštění získáme poslední řádek až s&nbsp;přibližně pětisekundovým
zpožděním:</p>

<pre>
&lt;Result: task 287017ca-9435-4c76-9070-3a23c31bc6c0&gt;
None
3
</pre>

<p>Totéž zpoždění je velmi dobře viditelné i v&nbsp;logu workera:</p>

<pre>
[2020-06-16 19:<strong>45:55</strong>,423] INFO:huey:Worker-1:Executing slow_adder.add: 287017ca-9435-4c76-9070-3a23c31bc6c0
[2020-06-16 19:<strong>46:00</strong>,427] INFO:huey:Worker-1:slow_adder.add: 287017ca-9435-4c76-9070-3a23c31bc6c0 executed in <strong>5.003s</strong>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Větší množství úloh zpracovaných jediným workerem</h2>

<p>Zajímavější bude pozorování toho, co se stane, pokud naplánujeme úloh více a
posléze budeme čekat na dokončení všech takto naplánovaných úloh. Toto se již
totiž do větší míry podobá reálnému použití, i když obecně platí, že čekání na
více úloh ve smyčce tohoto typu není ten nejlepší možný přístup (možná by bylo
lepší přidat <strong>timeout</strong> a čekat ve smyčce na naplnění všech
deseti výsledků):</p>

<pre>
<i>"""Vytvoření úlohy."""</i>
&nbsp;
from slow_adder import add
&nbsp;
rs = []
&nbsp;
print("Queueing...")
&nbsp;
for i in range(1, 11):
    r = add(i, i)
    rs.append(r)
&nbsp;
print("Done, waiting for results...")
&nbsp;
for r in rs:
    print(r(blocking=True))
</pre>

<p>Při sledování činnosti bude patrné, že výsledky budou přijímány
s&nbsp;pětisekundovým intervalem:</p>

<pre>
$ <strong>python3 wait_for_slow_adder.py</strong>
&nbsp;
Queueing...
Done, waiting for results...
2
4
6
8
10
12
14
16
18
20
</pre>

<p>Totéž by mělo být patrné i z&nbsp;logů jediného workera:</p>

<pre>
17:52 $ <strong>huey_consumer.py slow_adder.huey</strong>
&nbsp;
[2020-06-16 17:53:15,881] INFO:huey.consumer:MainThread:Huey consumer started with 1 thread, PID 29059 at 2020-06-16 15:53:15.881169
[2020-06-16 17:53:15,881] INFO:huey.consumer:MainThread:Scheduler runs every 1 second(s).
[2020-06-16 17:53:15,881] INFO:huey.consumer:MainThread:Periodic tasks are enabled.
[2020-06-16 17:53:15,881] INFO:huey.consumer:MainThread:The following commands are available:
+ slow_adder.add
[2020-06-16 17:53:50,863] INFO:huey:Worker-1:Executing slow_adder.add: 6a81c5f5-5c62-430c-9571-bbe2e6c5e6c8
[2020-06-16 17:53:55,868] INFO:huey:Worker-1:slow_adder.add: 6a81c5f5-5c62-430c-9571-bbe2e6c5e6c8 executed in 5.005s
[2020-06-16 18:14:03,225] INFO:huey:Worker-1:Executing slow_adder.add: 6d2c4d61-d9fa-4507-949a-c457183c99fe
[2020-06-16 18:14:08,229] INFO:huey:Worker-1:slow_adder.add: 6d2c4d61-d9fa-4507-949a-c457183c99fe executed in 5.004s
[2020-06-16 18:14:08,230] INFO:huey:Worker-1:Executing slow_adder.add: 8ede5add-7341-48c5-ba6f-2a4e5c183915
[2020-06-16 18:14:13,235] INFO:huey:Worker-1:slow_adder.add: 8ede5add-7341-48c5-ba6f-2a4e5c183915 executed in 5.005s
[2020-06-16 18:14:13,238] INFO:huey:Worker-1:Executing slow_adder.add: d2343825-4168-42f0-b383-58065b5c5bea
[2020-06-16 18:14:18,243] INFO:huey:Worker-1:slow_adder.add: d2343825-4168-42f0-b383-58065b5c5bea executed in 5.005s
[2020-06-16 18:14:18,247] INFO:huey:Worker-1:Executing slow_adder.add: f901373b-b425-42ae-92f1-5e4fd9d47b97
[2020-06-16 18:14:23,252] INFO:huey:Worker-1:slow_adder.add: f901373b-b425-42ae-92f1-5e4fd9d47b97 executed in 5.005s
[2020-06-16 18:14:23,255] INFO:huey:Worker-1:Executing slow_adder.add: 4972e02b-3614-4c07-b04e-0e52d6c8eedb
[2020-06-16 18:14:28,259] INFO:huey:Worker-1:slow_adder.add: 4972e02b-3614-4c07-b04e-0e52d6c8eedb executed in 5.004s
[2020-06-16 18:14:28,262] INFO:huey:Worker-1:Executing slow_adder.add: 9a4017bc-f48e-4e55-99a2-d76ebeb0ddcb
[2020-06-16 18:14:33,267] INFO:huey:Worker-1:slow_adder.add: 9a4017bc-f48e-4e55-99a2-d76ebeb0ddcb executed in 5.004s
[2020-06-16 18:14:33,270] INFO:huey:Worker-1:Executing slow_adder.add: 2ce3cd7a-507e-4cfc-a8ae-0e48290d530b
[2020-06-16 18:14:38,276] INFO:huey:Worker-1:slow_adder.add: 2ce3cd7a-507e-4cfc-a8ae-0e48290d530b executed in 5.005s
[2020-06-16 18:14:38,277] INFO:huey:Worker-1:Executing slow_adder.add: a687133a-758f-4188-9559-57cb1f0bc4c7
[2020-06-16 18:14:43,283] INFO:huey:Worker-1:slow_adder.add: a687133a-758f-4188-9559-57cb1f0bc4c7 executed in 5.005s
[2020-06-16 18:14:43,286] INFO:huey:Worker-1:Executing slow_adder.add: e4d13adf-b12f-4581-bf82-798906c7966c
[2020-06-16 18:14:48,291] INFO:huey:Worker-1:slow_adder.add: e4d13adf-b12f-4581-bf82-798906c7966c executed in 5.005s
[2020-06-16 18:14:48,292] INFO:huey:Worker-1:Executing slow_adder.add: c52de7c6-1348-4671-92d6-fd62a7f6e0bf
[2020-06-16 18:14:53,293] INFO:huey:Worker-1:slow_adder.add: c52de7c6-1348-4671-92d6-fd62a7f6e0bf executed in 5.000s
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Větší množství úloh zpracovaných množinou workerů</h2>

<p>V&nbsp;případě, že úloha zpracovávaná workerem je dokončena v&nbsp;relativně
dlouhém časovém intervalu a my budeme potřebovat zpracovat větší množství úloh,
nezbývá nám nic jiného, než spustit více workerů, kteří mohou pracovat
paralelně. Jednou z&nbsp;nabízených možností je spuštění každého workera
v&nbsp;samostatném procesu, což sice může být paměťově náročnější (každý proces
bude mít k&nbsp;dispozici svůj interpret Pythonu i celý příslušný virtuální
stroj), ovšem na druhou stranu jsou od sebe jednotliví workeři velmi dobře
izolováni. Dalším příkazem spustíme pět paralelně pracujících workerů:</p>

<pre>
20:36 $ <strong>huey_consumer.py slow_adder.huey --workers 5 --worker-type process</strong>
&nbsp;
[2020-06-13 20:36:29,417] INFO:huey.consumer:15725:Huey consumer started with <strong>5 process</strong>, <strong>PID 15725</strong> at 2020-06-13 18:36:29.417824
[2020-06-13 20:36:29,417] INFO:huey.consumer:15725:Scheduler runs every 1 second(s).
[2020-06-13 20:36:29,418] INFO:huey.consumer:15725:Periodic tasks are enabled.
[2020-06-13 20:36:29,418] INFO:huey.consumer:15725:The following commands are available:
+ <strong>slow_adder.add</strong>
</pre>

<p>Opět si necháme naplánovat deset úloh s&nbsp;čekáním na jejich
dokončení:</p>

<pre>
$ <strong>python3 wait_for_slow_adder.py</strong>
&nbsp;
Queueing...
Done, waiting for results...
</pre>

<p>Nyní je ovšem situace odlišná a na terminálu by se po cca pěti sekundách
měla zobrazit první pětice výsledků:</p>

<pre>
2
4
6
8
10
</pre>

<p>A po dalších pěti sekundách zbývající pětice výsledků:</p>

<pre>
12
14
16
18
20
</pre>

<p>Totéž chování je patrné i z&nbsp;logů workerů:</p>

<pre>
[2020-06-16 18:17:04,680] INFO:huey:30147:Executing slow_adder.add: 16145f55-a982-4441-b760-24dce2dad5cd
[2020-06-16 18:17:04,681] INFO:huey:30149:Executing slow_adder.add: 81b86138-53e9-4389-837a-97a05326b1ba
[2020-06-16 18:17:04,681] INFO:huey:30151:Executing slow_adder.add: 73aa8385-eba8-4a4d-a05f-e7062dbfb5db
[2020-06-16 18:17:04,681] INFO:huey:30148:Executing slow_adder.add: 15ec6957-d0e6-46f0-af0e-f6562c760fe7
[2020-06-16 18:17:04,681] INFO:huey:30150:Executing slow_adder.add: b092275b-4937-45df-8d67-f46a312dc451
[2020-06-16 18:17:09,685] INFO:huey:30148:slow_adder.add: 15ec6957-d0e6-46f0-af0e-f6562c760fe7 executed in 5.004s
[2020-06-16 18:17:09,686] INFO:huey:30150:slow_adder.add: b092275b-4937-45df-8d67-f46a312dc451 executed in 5.004s
[2020-06-16 18:17:09,686] INFO:huey:30149:slow_adder.add: 81b86138-53e9-4389-837a-97a05326b1ba executed in 5.005s
[2020-06-16 18:17:09,687] INFO:huey:30151:slow_adder.add: 73aa8385-eba8-4a4d-a05f-e7062dbfb5db executed in 5.006s
[2020-06-16 18:17:09,687] INFO:huey:30147:slow_adder.add: 16145f55-a982-4441-b760-24dce2dad5cd executed in 5.006s
[2020-06-16 18:17:09,689] INFO:huey:30148:Executing slow_adder.add: 86811c84-2ac9-444e-b773-a5c5c6de9929
[2020-06-16 18:17:09,690] INFO:huey:30150:Executing slow_adder.add: 3b3e92ef-c6b1-4f5b-ab1d-6f289344f801
[2020-06-16 18:17:09,690] INFO:huey:30151:Executing slow_adder.add: 421c61f8-f1eb-4c39-bc3f-abbd285e2629
[2020-06-16 18:17:09,690] INFO:huey:30149:Executing slow_adder.add: 23951a5b-310a-4d82-b0bf-f7f75f7a035d
[2020-06-16 18:17:09,690] INFO:huey:30147:Executing slow_adder.add: 84ba86a8-6ebf-43f9-b7a5-be0e384eb2d3
[2020-06-16 18:17:14,694] INFO:huey:30148:slow_adder.add: 86811c84-2ac9-444e-b773-a5c5c6de9929 executed in 5.005s
[2020-06-16 18:17:14,695] INFO:huey:30149:slow_adder.add: 23951a5b-310a-4d82-b0bf-f7f75f7a035d executed in 5.004s
[2020-06-16 18:17:14,695] INFO:huey:30150:slow_adder.add: 3b3e92ef-c6b1-4f5b-ab1d-6f289344f801 executed in 5.005s
[2020-06-16 18:17:14,696] INFO:huey:30151:slow_adder.add: 421c61f8-f1eb-4c39-bc3f-abbd285e2629 executed in 5.005s
[2020-06-16 18:17:14,696] INFO:huey:30147:slow_adder.add: 84ba86a8-6ebf-43f9-b7a5-be0e384eb2d3 executed in 5.005s
</pre>

<p>Všechny vytvořené procesy s&nbsp;workery i jejich koordinátorem si
samozřejmě můžeme snadno zobrazit:</p>

<pre>
$ <strong>ps ax |grep huey</strong>
&nbsp;
<strong>15725</strong> pts/1    S+     0:00 /usr/bin/python3 /home/ptisnovs/.local/bin/huey_consumer.py adder.huey --workers 5 --worker-type process
15727 pts/1    S+     0:00 /usr/bin/python3 /home/ptisnovs/.local/bin/huey_consumer.py adder.huey --workers 5 --worker-type process
15728 pts/1    S+     0:00 /usr/bin/python3 /home/ptisnovs/.local/bin/huey_consumer.py adder.huey --workers 5 --worker-type process
15729 pts/1    S+     0:00 /usr/bin/python3 /home/ptisnovs/.local/bin/huey_consumer.py adder.huey --workers 5 --worker-type process
15730 pts/1    S+     0:00 /usr/bin/python3 /home/ptisnovs/.local/bin/huey_consumer.py adder.huey --workers 5 --worker-type process
15731 pts/1    S+     0:00 /usr/bin/python3 /home/ptisnovs/.local/bin/huey_consumer.py adder.huey --workers 5 --worker-type process
15732 pts/1    S+     0:00 /usr/bin/python3 /home/ptisnovs/.local/bin/huey_consumer.py adder.huey --workers 5 --worker-type process
15780 pts/7    S+     0:00 grep huey
</pre>

<p><div class="rs-tip-major">Poznámka: alternativně lze procesy sledovat
nástroji <strong>top</strong>, <strong>htop</strong> apod.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Získání dalších informací o úloze</h2>

<p>Objekt, který je získán po naplánování úlohy, obsahuje potenciálně zajímavé
informace. Především je v&nbsp;atributu <strong>id</strong> uložen jednoznačný
identifikátor úlohy neboli UUID. Ten je možné použít ve chvíli, kdy se
například hledají problémy v&nbsp;celém systému (ztracené úlohy, nedokončené
úlohy atd.). Kromě toho však v&nbsp;atributu <strong>task</strong> nalezneme
další objekt s&nbsp;podrobnějšími informacemi o naplánované úloze, zejména
argumenty předané do workera, plánované dokončení úlohy, počet pokusů o její
dokončení, prioritu atd. Následující skript tyto informace zobrazí (a to
dokonce bez toho, aby musel běžet worker):</p>

<pre>
<i>"""Vytvoření úlohy a vypsání podrobnějších informací o úloze."""</i>
&nbsp;
from adder import add
&nbsp;
r = add(1, 2)
print("result id:\t", r.id)
print("task object:\t", r.task)
print("arguments:\t", r.task.args)
print("planned ETA:\t", r.task.eta)
print("retries:\t", r.task.retries)
print("priority:\t", r.task.priority)
</pre>

<p>Výsledek může vypadat následovně:</p>

<pre>
result id:       3f130490-d74a-41c1-92a0-bddbb754b9a7
task object:     adder.add: 3f130490-d74a-41c1-92a0-bddbb754b9a7
arguments:       (1, 2)
planned ETA:     None
retries:         0
priority:        None
</pre>

<p><div class="rs-tip-major">Poznámka: ID úlohy i ID výsledku bude samozřejmě
při dalším spuštění odlišný.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Chování systému při havárii úlohy ve workerovi</h2>

<p>V&nbsp;prakticky každém systému pro plánování a vykonávání asynchronně
běžících úloh je nutné se nějakým způsobem vypořádat se stavem, kdy
v&nbsp;úloze dojde k&nbsp;chybě, což v&nbsp;Pythonu znamená, když dojde
k&nbsp;vyhození výjimky. Tento stav si můžeme nasimulovat a to velmi snadno
&ndash; předáme do funkce <strong>add</strong> celé číslo a řetězec, což jsou
pochopitelně dvě hodnoty, které nelze (v&nbsp;Pythonu) sečíst:</p>

<pre>
<i>"""Vytvoření úlohy."""</i>
&nbsp;
from adder import add
&nbsp;
r = add(1, "foo")
print(r)
print(r())
print(r(blocking=True))
</pre>

<p>Po spuštění nastane zajímavá situace &ndash; nejprve získáme namísto
výsledku hodnotu <strong>None</strong>, protože celé asynchronní zpracování
nějakou dobu trvá. A posléze dojde k&nbsp;vyhození výjimky z&nbsp;funkce
<strong>r(blocking=True)</strong>, tj.&nbsp;systém se chová takovým způsobem,
jakoby výjimka vznikla lokálně a nikoli ve zcela jiném procesu:</p>

<pre>
&lt;Result: task 334016fa-26f6-4397-a1dd-2dcb9a96c5a1&gt;
None
Traceback (most recent call last):
  File "wait_for_adder_failure.py", line 8, in <module>
    print(r(blocking=True))
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/huey/api.py", line 853, in __call__
    return self.get(*args, **kwargs)
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/huey/api.py", line 895, in get
    raise TaskException(result.metadata)
huey.exceptions.TaskException: TypeError("unsupported operand type(s) for +: 'int' and 'str'",)
</pre>

<p>Výjimku ostatně uvidíme i v&nbsp;logu workera, což je užitečné při pozdějším
zkoumání jaká úloha a proč zhavarovala:</p>

<pre>
[2020-06-17 17:54:12,500] INFO:huey:Worker-1:Executing adder.add: 334016fa-26f6-4397-a1dd-2dcb9a96c5a1
[2020-06-17 17:54:12,500] ERROR:huey:Worker-1:Unhandled exception in task 334016fa-26f6-4397-a1dd-2dcb9a96c5a1.
Traceback (most recent call last):
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/huey/api.py", line 359, in _execute
    task_value = task.execute()
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/huey/api.py", line 723, in execute
    return func(*args, **kwargs)
  File "/home/ptisnovs/src/message-queues-examples/huey/adder.py", line 11, in add
    return a + b
TypeError: unsupported operand type(s) for +: 'int' and 'str'
</pre>

<p>Výjimku můžeme snadno zachytit:</p>

<pre>
<i>"""Vytvoření úlohy."""</i>
&nbsp;
from adder import add
&nbsp;
r = add(1, "foo")
print(r)
print(r())
&nbsp;
<strong>try</strong>:
    print(r(blocking=True))
<strong>except</strong> Exception as e:
    print("Exception detected!", e)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
&lt;Result: task b4e7e80f-c50f-4a09-aa42-e8d44809152a&gt;
None
Exception detected! TypeError("unsupported operand type(s) for +: 'int' and 'str'",)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Naplánování periodicky se opakující úlohy</h2>

<p>Systém <i>Huey</i> umožňuje naplánování periodicky se opakujících úloh.
Přitom lze použít zápis podobný tomu, který se používá v&nbsp;<i>cronu</i>, viz
též <a href="https://crontab.guru/">https://crontab.guru/</a>. Příklad úlohy
spuštěné každou minutu:</p>

<pre>
<i>"""Periodicky se opakující úloha."""</i>
&nbsp;
from huey import crontab
from huey import RedisHuey
&nbsp;
huey = RedisHuey()
&nbsp;
@huey.periodic_task(crontab(minute='*'))
def <strong>periodic</strong>():
    print("*** NOW ***")
</pre>

<p>Taková úloha nemá mít žádné parametry ani nesmí vracet žádné výsledky
konstrukcí <strong>return</strong>. Ovšem i přesto lze výsledky uchovat, a to
přímo do <i>Redisu</i> či podobného systému. Podrobnosti si řekneme příště.</p>

<p>O tom, že je úloha skutečně spouštěna se zadanou periodou, se lze přesvědčit
pohledem do logu workera:</p>

<pre>
$ <strong>huey_consumer.py periodic.huey</strong>
&nbsp;
[2020-06-17 18:59:07,980] INFO:huey.consumer:MainThread:Huey consumer started with 1 thread, PID 11784 at 2020-06-17 16:59:07.980863
[2020-06-17 18:59:07,980] INFO:huey.consumer:MainThread:Scheduler runs every 1 second(s).
[2020-06-17 18:59:07,981] INFO:huey.consumer:MainThread:Periodic tasks are enabled.
[2020-06-17 18:59:07,981] INFO:huey.consumer:MainThread:The following commands are available:
+ periodic.periodic
&nbsp;
[2020-06-17 18:59:07,985] INFO:huey.consumer.Scheduler:Scheduler:Enqueueing periodic task periodic.periodic: 6f50745c-1be5-4d41-9def-035f1e02afa2.
[2020-06-17 18:59:07,986] INFO:huey:Worker-1:Executing periodic.periodic: 6f50745c-1be5-4d41-9def-035f1e02afa2
*** NOW ***
[2020-06-17 18:59:07,986] INFO:huey:Worker-1:periodic.periodic: 6f50745c-1be5-4d41-9def-035f1e02afa2 executed in 0.000s
&nbsp;
[2020-06-17 19:00:07,982] INFO:huey.consumer.Scheduler:Scheduler:Enqueueing periodic task periodic.periodic: f4f10a24-2f3b-4491-9b1d-5bf14bfa71a3.
[2020-06-17 19:00:07,984] INFO:huey:Worker-1:Executing periodic.periodic: f4f10a24-2f3b-4491-9b1d-5bf14bfa71a3
*** NOW ***
[2020-06-17 19:00:07,984] INFO:huey:Worker-1:periodic.periodic: f4f10a24-2f3b-4491-9b1d-5bf14bfa71a3 executed in 0.000s
&nbsp;
[2020-06-17 19:01:07,981] INFO:huey.consumer.Scheduler:Scheduler:Enqueueing periodic task periodic.periodic: 03f3fa18-d39c-4ebb-8525-3b1c7858337c.
[2020-06-17 19:01:07,983] INFO:huey:Worker-1:Executing periodic.periodic: 03f3fa18-d39c-4ebb-8525-3b1c7858337c
*** NOW ***
[2020-06-17 19:01:07,983] INFO:huey:Worker-1:periodic.periodic: 03f3fa18-d39c-4ebb-8525-3b1c7858337c executed in 0.000s
</pre>

<p>Podobným způsobem lze vytvořit například úlohu spouštěnou každých pět
minut:</p>

<pre>
<i>"""Periodicky se opakující úloha."""</i>
&nbsp;
from huey import crontab
from huey import RedisHuey
&nbsp;
huey = RedisHuey()
&nbsp;
@huey.periodic_task(crontab(minute='*/5'))
def <strong>periodic</strong>():
    print("*** NOW ***")
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Korektní spuštění skupiny úloh</h2>

<p>Již v&nbsp;předchozím textu jsme si ukázali jeden způsob čekání na dokončení
několika úloh. Ovšem prezentovaný způsob nebyl v&nbsp;žádném případě dokonalý,
protože pro naplánování několika úloh a na případné získání jejích výsledků
(s&nbsp;případným čekáním) je určen objekt typu &bdquo;skupina úloh&ldquo;
s&nbsp;mnohem jednodušším rozhraním. Jeho základní způsob použití je ukázán
v&nbsp;dalším skriptu:</p>

<pre>
<i>"""Vytvoření deseti úloh."""</i>
&nbsp;
from slow_adder import add
&nbsp;
print("Queueing...")
rg = add.map([(i, i) for i in range(1, 11)])
&nbsp;
print("Done, waiting for results...")
&nbsp;
print(rg.get(blocking=True))
</pre>

<p>Povšimněte si, že čekání na dokončení úloh a na získání jejich výsledků je
provedeno jediným zavoláním metody <strong>get</strong> s&nbsp;případným
použitím parametru <strong>blocking=True</strong>. Výsledky jsou získány ve
formě seznamu:</p>

<pre>
Queueing...
Done, waiting for results...
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;některých případech použití může
být důležité, že výsledky jsou získány v&nbsp;přesně tom pořadí, v&nbsp;jakém
byly naplánovány.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Prioritní úlohy</h2>

<p>Systém <i>Huey</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Plánování různých úloh s&nbsp;odlišnou implementací workerů</h2>

<p>Podívejme se ještě na způsob naplánování a spuštění úloh realizovaných
různými funkcemi ve workeru. Upravený worker má s&nbsp;využitím dekorátoru
označeny tři funkce, které realizují různé úlohy. Jedná se o součet, součet
s&nbsp;prodlevou (ten již známe z&nbsp;předchozích kapitol) a součin:</p>

<pre>
<i>"""Několik různých úloh."""</i>
&nbsp;
from huey import RedisHuey
&nbsp;
from time import sleep
&nbsp;
huey = RedisHuey()
&nbsp;
@huey.task()
def <strong>add</strong>(a, b):
    <i>"""Úloha pro rychlý součet dvou hodnot."""</i>
    return a + b
&nbsp;
&nbsp;
@huey.task()
def <strong>slow_add</strong>(a, b):
    <i>"""Úloha pro pomalý součet dvou hodnot."""</i>
    sleep(5)
    return a + b
&nbsp;
&nbsp;
@huey.task()
def <strong>mul</strong>(a, b):
    <i>"""Úloha pro součin dvou hodnot."""</i>
    return a * b
</pre>

<p>Příslušné úlohy lze samozřejmě přímo použít, což je ukázáno
v&nbsp;následujícím skriptu, který vytvoří celkem třicet úloh &ndash; dvacet na
součet, deset na násobení &ndash; a následně počká na jejich dokončení:</p>

<pre>
<i>"""Vytvoření různých úloh."""</i>
&nbsp;
from three_tasks import add, slow_add, mul
&nbsp;
rs = []
&nbsp;
print("Queueing...")
&nbsp;
for i in range(1, 11):
    rs.append(add(i, i))
    rs.append(slow_add(i, i))
    rs.append(mul(i, i))
&nbsp;
print("Done, waiting for results...")
&nbsp;
for r in rs:
    print(r(blocking=True))
</pre>

<p>Následně spustíme celkem pět workerů (nikoli patnáct):</p>

<pre>
$ <strong>huey_consumer.py three_tasks.huey --workers 5 --worker-type process</strong>
&nbsp;
[2020-06-16 20:59:50,392] INFO:huey.consumer:2416:Huey consumer started with 5 process, PID 2416 at 2020-06-16 18:59:50.392372
[2020-06-16 20:59:50,392] INFO:huey.consumer:2416:Scheduler runs every 1 second(s).
[2020-06-16 20:59:50,392] INFO:huey.consumer:2416:Periodic tasks are enabled.
[2020-06-16 20:59:50,392] INFO:huey.consumer:2416:The following commands are available:
+ three_tasks.add
+ three_tasks.slow_add
+ three_tasks.mul
</pre>

<p>Výsledky budou vypočteny a vráceny v&nbsp;tomto pořadí (nemusí být však
zachováno zcela přesně, protože <strong>sleep</strong> ani přepínání procesů
s&nbsp;workery nijak neřídíme):</p>

<pre>
Queueing...
Done, waiting for results...
2
2
1
4
4
4
6
6
9
8
8
16
10
10
25
12
12
36
14
14
49
16
16
64
18
18
81
20
20
100
</pre>

<p>Z&nbsp;výpisu logů workerů je patrné prodlení způsobené tím, že workeři
začnou počítat součet s&nbsp;vloženým voláním funkce <strong>sleep</strong>
(viz zvýrazněné části):</p>

<pre>
[2020-06-16 21:01:00,580] INFO:huey:2423:Executing three_tasks.add: ca9bff2e-20ac-4628-9245-629bd6d0aaee
[2020-06-16 21:01:00,580] INFO:huey:2419:Executing three_tasks.slow_add: 7092e846-70e0-40cf-967f-e6cf18ba78fe
[2020-06-16 21:01:00,581] INFO:huey:2423:three_tasks.add: ca9bff2e-20ac-4628-9245-629bd6d0aaee executed in 0.000s
[2020-06-16 21:01:00,581] INFO:huey:2421:Executing three_tasks.mul: d025b88c-e3c7-4f7b-83e3-e67a471f2cef
[2020-06-16 21:01:00,581] INFO:huey:2421:three_tasks.mul: d025b88c-e3c7-4f7b-83e3-e67a471f2cef executed in 0.000s
[2020-06-16 21:01:00,581] INFO:huey:2422:Executing three_tasks.add: dd703c69-2810-41b0-b238-13a1f5628a0d
[2020-06-16 21:01:00,581] INFO:huey:2420:Executing three_tasks.slow_add: 01ee6a98-122e-40c8-8581-43dffee96f12
[2020-06-16 <strong>21:01:00</strong>,581] INFO:huey:2422:three_tasks.add: dd703c69-2810-41b0-b238-13a1f5628a0d executed in 0.000s
...
...
...
[2020-06-16 <strong>21:01:05</strong>,593] INFO:huey:2420:three_tasks.mul: 0397de3a-644c-4da2-878b-32c6f909af1b executed in 0.000s
[2020-06-16 21:01:05,593] INFO:huey:2420:Executing three_tasks.add: a2fa2818-5ceb-423a-bc5d-b10d1798cb6d
[2020-06-16 21:01:05,594] INFO:huey:2420:three_tasks.add: a2fa2818-5ceb-423a-bc5d-b10d1798cb6d executed in 0.000s
[2020-06-16 21:01:05,594] INFO:huey:2420:Executing three_tasks.slow_add: 07ab94fb-80b5-44db-b4b5-7be716649115
[2020-06-16 <strong>21:01:10</strong>,593] INFO:huey:2421:three_tasks.slow_add: f6199751-1d66-433a-85b2-6b1a7bfb0acc executed in 5.001s
[2020-06-16 21:01:10,593] INFO:huey:2423:three_tasks.slow_add: 37cf126f-b4ed-49cf-bbc5-6e16d6399f4b executed in 5.001s
[2020-06-16 21:01:10,594] INFO:huey:2422:three_tasks.slow_add: 28339d2f-ed94-43b0-99f6-ec74e28c6948 executed in 5.004s
[2020-06-16 21:01:10,595] INFO:huey:2419:three_tasks.slow_add: 77f10038-afff-4f80-ab7c-8f79eb749818 executed in 5.004s
[2020-06-16 21:01:10,596] INFO:huey:2421:Executing three_tasks.mul: f1cdc9f4-ffcc-49e2-980a-912d430e8157
[2020-06-16 21:01:10,596] INFO:huey:2421:three_tasks.mul: f1cdc9f4-ffcc-49e2-980a-912d430e8157 executed in 0.000s
[2020-06-16 21:01:10,599] INFO:huey:2420:three_tasks.slow_add: 07ab94fb-80b5-44db-b4b5-7be716649115 executed in 5.005s
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacím jazyku Python byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
stále ještě doslova několik kilobajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce. Každý příklad
obsahuje implementaci workera či workerů a taktéž skript pro naplánování
úloh:</p>

<table>
<tr><th>Příklad</th><th>Skript</th><th>Stručný popis skriptu</th><th>Cesta</th></tr>
<tr><td>1</td><td>adder.py</td><td>worker s&nbsp;funkcí pro součet dvou čísel</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/adder.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/adder.py</a></td></tr>
<tr><td>2</td><td>call_adder.py</td><td>vytvoření jedné úlohy pro workera bez čekání</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/call_adder.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/call_adder.py</a></td></tr>
<tr><td>3</td><td>wait_for_adder.py</td><td>vytvoření jedné úlohy pro workera s&nbsp;čekáním</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/wait_for_adder.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/wait_for_adder.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>slow_adder.py</td><td>worker s&nbsp;pomalým součtem dvou čísel</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/slow_adder.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/slow_adder.py</a></td></tr>
<tr><td>5</td><td>wait_for_slow_adder.py</td><td>vytvoření jedné úlohy pro workera s&nbsp;čekáním</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/wait_for_slow_adder.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/wait_for_slow_adder.py</a></td></tr>
<tr><td>6</td><td>more_adds.py</td><td>vytvoření deseti úloh pro workera s&nbsp;čekáním</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/more_adds.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/more_adds.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>print_job_info.py</td><td>výpis podrobnějších informací o úloze</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/print_job_info.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/print_job_info.py</a></td></tr>
<tr><td>8</td><td>map_adds.py</td><td>korektní způsob naplánování úlohy</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/map_adds.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/map_adds.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>three_tasks.py</td><td>worker se třemi různými funkcemi, které lze volat jako úlohy</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/three_tasks.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/three_tasks.py</a></td></tr>
<tr><td>10</td><td>call_different_tasks.py</td><td>použití všech tří typů úloh nabízených předchozím workerem</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/call_different_tasks.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/call_different_tasks.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>wait_for_adder_failure.py</td><td>vytvoření jedné úlohy pro workera s&nbsp;čekáním, tato úloha zhavaruje</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/huey/wait_for_adder_failure.py">https://github.com/tisnik/message-queues-examples/blob/master/huey/wait_for_adder_failure.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace k&nbsp;systému Huey<br />
<a href="https://huey.readthedocs.io/en/latest/">https://huey.readthedocs.io/en/latest/</a>
</li>

<li>Balíček s&nbsp;projektem Huey<br />
<a href="https://pypi.org/project/huey/">https://pypi.org/project/huey/</a>
</li>

<li>Repositář Huey na GitHubu<br />
<a href="https://github.com/coleifer/huey">https://github.com/coleifer/huey</a>
</li>

<li>Looking for an alternative to Celery? Try Huey<br />
<a href="https://hub.packtpub.com/looking-for-alternative-celery-try-huey/">https://hub.packtpub.com/looking-for-alternative-celery-try-huey/</a>
</li>

<li>Celery vs. Huey vs. other?<br />
<a href="https://www.reddit.com/r/django/comments/2swfz2/celery_vs_huey_vs_other/">https://www.reddit.com/r/django/comments/2swfz2/celery_vs_huey_vs_other/</a>
</li>

<li>POSIX message queues in Linux<br />
<a href="https://www.softprayog.in/programming/interprocess-communication-using-posix-message-queues-in-linux">https://www.softprayog.in/programming/interprocess-communication-using-posix-message-queues-in-linux</a>
</li>

<li>How is a message queue implemented in the Linux kernel?<br />
<a href="https://unix.stackexchange.com/questions/6930/how-is-a-message-queue-implemented-in-the-linux-kernel/6935">https://unix.stackexchange.com/questions/6930/how-is-a-message-queue-implemented-in-the-linux-kernel/6935</a>
</li>

<li>‘IPCS’ command in Linux with examples<br />
<a href="https://www.geeksforgeeks.org/ipcs-command-linux-examples/">https://www.geeksforgeeks.org/ipcs-command-linux-examples/</a>
</li>

<li>System V IPC: Message Queues<br />
<a href="https://nitish712.blogspot.com/2012/11/system-v-ipc-message-queues.html">https://nitish712.blogspot.com/2012/11/system-v-ipc-message-queues.html</a>
</li>

<li>How to create, check and delete IPC share memory, semaphare and message queue on linux <br />
<a href="https://fibrevillage.com/sysadmin/225-how-to-create-check-and-delete-ipc-share-memory-semaphare-and-message-queue-on-linux">https://fibrevillage.com/sysadmin/225-how-to-create-check-and-delete-ipc-share-memory-semaphare-and-message-queue-on-linux</a>
</li>

<li>MQ_OVERVIEW(7): Linux Programmer's Manual<br />
<a href="http://man7.org/linux/man-pages/man7/mq_overview.7.html">http://man7.org/linux/man-pages/man7/mq_overview.7.html</a>
</li>

<li>mq_overview (7) - Linux Man Pages<br />
<a href="https://www.systutorials.com/docs/linux/man/7-mq_overview/">https://www.systutorials.com/docs/linux/man/7-mq_overview/</a>
</li>

<li>POSIX.4 Message Queues (+ rozšíření QNX)<br />
<a href="https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html">https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html</a>
</li>

<li>System V message queues in Linux<br />
<a href="https://www.softprayog.in/programming/interprocess-communication-using-system-v-message-queues-in-linux">https://www.softprayog.in/programming/interprocess-communication-using-system-v-message-queues-in-linux</a>
</li>

<li>Linux System V and POSIX IPC Examples<br />
<a href="http://hildstrom.com/projects/ipc_sysv_posix/index.html">http://hildstrom.com/projects/ipc_sysv_posix/index.html</a>
</li>

<li>Programming Tutorial - Linux: Message Queues<br />
<a href="https://ccppcoding.blogspot.com/2013/03/linux-message-queues.html">https://ccppcoding.blogspot.com/2013/03/linux-message-queues.html</a>
</li>

<li>Go wrapper for POSIX Message Queues <br />
<a href="https://github.com/syucream/posix_mq">https://github.com/syucream/posix_mq</a>
</li>

<li>Stránka projektu NSQ<br />
<a href="https://nsq.io/">https://nsq.io/</a>
</li>

<li>Dokumentace k&nbsp;projektu NSQ<br />
<a href="https://nsq.io/overview/design.html">https://nsq.io/overview/design.html</a>
</li>

<li>Dokumentace ke klientovi pro Go<br />
<a href="https://godoc.org/github.com/nsqio/go-nsq">https://godoc.org/github.com/nsqio/go-nsq</a>
</li>

<li>Dokumentace ke klientovi pro Python<br />
<a href="https://pynsq.readthedocs.io/en/latest/">https://pynsq.readthedocs.io/en/latest/</a>
</li>

<li>Binární tarbally s&nbsp;NSQ<br />
<a href="https://nsq.io/deployment/installing.html">https://nsq.io/deployment/installing.html</a>
</li>

<li>GitHub repositář projektu NSQ<br />
<a href="https://github.com/nsqio/nsq">https://github.com/nsqio/nsq</a>
</li>

<li>Klienti pro NSQ<br />
<a href="https://nsq.io/clients/client_libraries.html">https://nsq.io/clients/client_libraries.html</a>
</li>

<li>Klient pro Go<br />
<a href="https://github.com/nsqio/go-nsq">https://github.com/nsqio/go-nsq</a>
</li>

<li>Klient pro Python<br />
<a href="https://github.com/nsqio/pynsq">https://github.com/nsqio/pynsq</a>
</li>

<li>An Example of Using NSQ From Go<br />
<a href="http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/">http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/</a>
</li>

<li>Go Go Gadget<br />
<a href="https://word.bitly.com/post/29550171827/go-go-gadget">https://word.bitly.com/post/29550171827/go-go-gadget</a>
</li>

<li>Simplehttp<br />
<a href="https://github.com/bitly/simplehttp">https://github.com/bitly/simplehttp</a>
</li>

<li>Dramatiq: simple task processing<br />
<a href="https://dramatiq.io/">https://dramatiq.io/</a>
</li>

<li>Cookbook (for Dramatiq)<br />
<a href="https://dramatiq.io/cookbook.html">https://dramatiq.io/cookbook.html</a>
</li>

<li>Balíček dramatiq na PyPi<br />
<a href="https://pypi.org/project/dramatiq/">https://pypi.org/project/dramatiq/</a>
</li>

<li>Dramatiq dashboard<br />
<a href="https://github.com/Bogdanp/dramatiq_dashboard">https://github.com/Bogdanp/dramatiq_dashboard</a>
</li>

<li>Dramatiq na Redditu<br />
<a href="https://www.reddit.com/r/dramatiq/">https://www.reddit.com/r/dramatiq/</a>
</li>

<li>A Dramatiq broker that can be used with Amazon SQS<br />
<a href="https://github.com/Bogdanp/dramatiq_sqs">https://github.com/Bogdanp/dramatiq_sqs</a>
</li>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

<li>nng (nanomsg-next-generation)<br />
<a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>
</li>

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

