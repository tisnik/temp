<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Komunikace s message brokery z programovacího jazyka Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Komunikace s message brokery z programovacího jazyka Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Seriál o message brokerech by nebyl úplný, pokud bychom se neseznámili se způsobem implementace klientů v programovacím jazyku Go. Proto si ukážeme využití balíčků stomp a rmq. Taktéž se ve stručnosti seznámíme se systémem NATS, který je naprogramován právě v jazyce Go.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Komunikace s&nbsp;message brokery z&nbsp;programovacího jazyka Go</a></p>
<p><a href="#k02">2. Implementace producenta a konzumenta zpráv v&nbsp;jazyce Go s&nbsp;využitím balíčku <strong>stomp</strong></a></p>
<p><a href="#k03">3. Komunikace klientů s&nbsp;message brokerem ve vlastní gorutině</a></p>
<p><a href="#k04">4. Producent i konzument jako součást jediné aplikace se třemi paralelně běžícími gorutinami</a></p>
<p><a href="#k05">5. Jedna z&nbsp;možných implementací message brokera naprogramovaná v&nbsp;nativním Go a používající Redis jako storage</a></p>
<p><a href="#k06">6. Instalace a nastavení Redisu i <strong>rmq</strong></a></p>
<p><a href="#k07">7. Jednoduchý producent posílající textové zprávy</a></p>
<p><a href="#k08">8. Konzument zpracovávající jednoduché textové zprávy</a></p>
<p><a href="#k09">9. Marshalling a unmarshalling datových struktur do formátu JSON pro posílání složitějších zpráv</a></p>
<p><a href="#k10">10. Úprava producenta takovým způsobem, aby posílal zprávy ve formátu JSON</a></p>
<p><a href="#k11">11. Konzument akceptující zprávy ve formátu JSON</a></p>
<p><a href="#k12">12. Přenos binárních zpráv</a></p>
<p><a href="#k13">13. Vytvoření a poslání binární zprávy</a></p>
<p><a href="#k14">14. Příjem binární zprávy</a></p>
<p><a href="#k15">15. Systém NATS aneb implementace systému pro doručování zpráv v&nbsp;jazyku Go</a></p>
<p><a href="#k16">16. Komunikační strategie a protokol použitý klienty systému NATS</a></p>
<p><a href="#k17">17. NATS Streaming</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Komunikace s&nbsp;message brokery z&nbsp;programovacího jazyka Go</h2>

<p>V&nbsp;předchozích částech <a
href="https://www.root.cz/serialy/message-brokery/">seriálu o frontách zpráv a
o message brokerech</a> byla většina demonstračních příkladů, s&nbsp;nimiž jsme
se seznámili, naprogramována v&nbsp;<a
href="https://www.root.cz/n/python/">Pythonu</a>. Výběr tohoto programovacího
jazyka samozřejmě nebyl v&nbsp;žádném případě náhodný, protože demonstrační
příklady (ale i reálné aplikace) vytvořené v&nbsp;Pythonu jsou v&nbsp;naprosté
většině případů krátké a dostatečně přehledné. To je umožněno jak vlastnostmi
samotného Pythonu (úsporný zápis zdrojového kódu a dynamický typový systém),
tak i knihovnami zabezpečujícími rozhraní mezi Pythonem (resp.&nbsp;přesněji
řečeno aplikacemi naprogramovanými v&nbsp;Pythonu) a samotným message brokerem.
Jen pro připomenutí jsou v&nbsp;následující tabulce vypsány knihovny určené pro
Python, které jsme až doposud používali:</p>

<table>
<tr><th>Message broker/protokol</th><th>Knihovna</th></tr>
<tr><td>Redis Queue (RQ)</td><td><a href="https://pypi.org/project/rq/">rq</a></td></tr>
<tr><td>RabbitMQ</td><td><a href="https://pypi.org/project/pika/">pika</a></td></tr>
<tr><td>Celery</td><td><a href="https://pypi.org/project/celery/">celery</a></td></tr>
<tr><td>Apache ActiveMQ</td><td><a href="https://pypi.org/project/stomp.py/">stomp.py</a>, <a href="https://pypi.org/project/python-qpid-proton/">python-qpid-proton</a></td></tr>
</table>

<p>S&nbsp;message brokery je pochopitelně možné komunikovat i z&nbsp;aplikací
vytvořených v&nbsp;jiných programovacích jazycích (ostatně viděli jsme <a
href="https://github.com/tisnik/message-queues-examples/tree/master/rabbit-mq/clojure/example01">jeden
příklad</a> naprogramovaný v&nbsp;jazyce <a
href="https://www.root.cz/n/clojure/">Clojure</a>). V&nbsp;enterprise sféře se
bude v&nbsp;první řadě jednat o <a href="https://www.root.cz/n/java/">Javu</a>,
ovšem zapomenout nesmíme ani na jazyk, který se stává populární v&nbsp;oblasti
síťových aplikací a utilit. Jedná se o programovací jazyk <a
href="https://www.root.cz/n/go/">Go</a>, jímž se podrobněji zabýváme <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;samostatném
seriálu</a>. Jazyk Go může být ve skutečnosti pro komunikaci s&nbsp;message
brokery velmi vhodnou alternativou, protože umožňuje díky podpoře kanálů a
<i>gorutin</i> velmi snadnou tvorbu asynchronně běžících funkcí. V&nbsp;dnešním
článku se s&nbsp;některými možnostmi nabízenými v&nbsp;této oblasti
programovacím jazykem Go alespoň ve stručnosti seznámíme.</p>

<p><a href="#k15">V&nbsp;závěrečné části článku</a> si řekneme základní
informace o systému pojmenovaném <i>NATS</i>, který je naprogramován právě
v&nbsp;jazyce Go a který nabízí uživatelům robustní a přitom systémově
nenáročnou implementaci message brokera, který podporuje i takzvaný
<i>streaming</i>. Klienty je díky existujícím rozhraním samozřejmě možné psát i
v&nbsp;jiných jazycích.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Implementace producenta a konzumenta zpráv v&nbsp;jazyce Go s&nbsp;využitím balíčku <strong>stomp</strong></h2>

<p>V&nbsp;samotném závěru <a
href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/">předchozího
článku</a> jsme si ukázali, jakým způsobem je možné naprogramovat klienty
(zdroje zpráv i jejich příjemce), které komunikují s&nbsp;message brokerem
Apache ActiveMQ s&nbsp;využitím jednoduchého protokolu <i>STOMP</i>.
Připomeňme si, že jednoduchého producenta zpráv můžeme implementovat <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull/publisher.go">následujícím
způsobem</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
&nbsp;
        "github.com/go-stomp/stomp"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
const messageCount = 10
&nbsp;
func <strong>sendMessages</strong>() {
        conn, err := stomp.Dial("tcp", serverAddr, nil)
        if err != nil {
                println("cannot connect to server", err.Error())
                return
        } else {
                println("connected to server", serverAddr)
        }
        defer conn.Disconnect()
&nbsp;
        for i := 1; i &lt;= messageCount; i++ {
                text := fmt.Sprintf("Message #%d", i)
                err = conn.Send(queueName, "text/plain", []byte(text), nil)
                if err != nil {
                        println("failed to send to server", err)
                        return
                } else {
                        println("message sent")
                }
        }
        println("sending EXIT message")
        err = conn.Send(queueName, "text/plain", []byte("EXIT"), nil)
        if err != nil {
                println("failed to send EXIT message to server", err)
                return
        } else {
                println("message sent")
        }
        println("sender finished")
}
&nbsp;
func <strong>main</strong>() {
        sendMessages()
}
</pre>

<p>Zdrojový kód klienta obsahuje následující části:</p>

<ol>
<li>Připojení k&nbsp;message brokeru přes funkci <strong>stomp.Dial()</strong></li>
<li>Poslání zprávy metodou <strong>conn.Send()</strong></li>
<li>Odpojení klienta metodou <strong>conn.Disconnect()</strong></li>
</ol>

<p>Konzument zpráv bude implementován podobným způsobem, ostatně se podívejme
na jeho <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull/subscriber.go">úplný
zdrojový kód</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/go-stomp/stomp"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
func <strong>receiveMessages</strong>() {
        conn, err := stomp.Dial("tcp", serverAddr, nil)
&nbsp;
        if err != nil {
                println("cannot connect to server", err.Error())
                return
        } else {
                println("connected to server", serverAddr)
        }
&nbsp;
        defer conn.Disconnect()
&nbsp;
        sub, err := conn.Subscribe(queueName, stomp.AckAuto)
        if err != nil {
                println("cannot subscribe to", queueName, err.Error())
                return
        }
        for {
                msg := &lt;-sub.C
                text := string(msg.Body)
                if text != "EXIT" {
                        println("Received message", text)
                } else {
                        println("Received EXIT command")
                        break
                }
        }
        println("receiver finished")
}
&nbsp;
func <strong>main</strong>() {
        receiveMessages()
}
</pre>

<p>Konzument obsahuje tyto části:</p>

<ol>
<li>Připojení k&nbsp;message brokeru přes funkci <strong>stomp.Dial()</strong></li>
<li>Přihlášení k&nbsp;odběru zpráv metodou <strong>conn.Subscribe()</strong></li>
<li>Příjem zprávy/zpráv z&nbsp;automaticky vytvořeného kanálu</li>
<li>Odpojení klienta metodou <strong>conn.Disconnect()</strong></li>
</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Komunikace klientů s&nbsp;message brokerem ve vlastní gorutině</h2>

<p>Mnohdy se setkáme s&nbsp;požadavkem na to, aby klient (ať již producent
zpráv či jejich konzument) komunikovat s&nbsp;message brokerem
v&nbsp;samostatně běžící <a
href="https://www.root.cz/clanky/rozhrani-metody-gorutiny-a-kanaly-v-programovacim-jazyku-go/#k13">gorutině</a>,
která by pracovala paralelně s&nbsp;dalšími gorutinami. Tento požadavek, který
dává smysl zejména u webových služeb, je <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-goroutines/publisher.go">relativně
snadné implementovat</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
&nbsp;
        "github.com/go-stomp/stomp"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
const messageCount = 10
&nbsp;
var stop = make(chan bool)
&nbsp;
func <strong>sendMessages</strong>() {
        defer func() {
                stop &lt;- true
        }()
&nbsp;
        conn, err := stomp.Dial("tcp", serverAddr, nil)
        if err != nil {
                println("cannot connect to server", err.Error())
                return
        } else {
                println("connected to server", serverAddr)
        }
        defer conn.Disconnect()
&nbsp;
        for i := 1; i &lt;= messageCount; i++ {
                text := fmt.Sprintf("Message #%d", i)
                err = conn.Send(queueName, "text/plain", []byte(text), nil)
                if err != nil {
                        println("failed to send to server", err)
                        return
                } else {
                        println("message sent")
                }
        }
        println("sending EXIT message")
        err = conn.Send(queueName, "text/plain", []byte("EXIT"), nil)
        if err != nil {
                println("failed to send EXIT message to server", err)
                return
        } else {
                println("message sent")
        }
        println("sender finished")
}
&nbsp;
func <strong>main</strong>() {
        go sendMessages()
&nbsp;
        <-stop
}
</pre>

<p><div class="rs-tip-major">Poznámka: na konci funkce <strong>main</strong>
musíme počkat na dokončení druhé gorutiny. Právě k&nbsp;tomuto účelu se používá
pomocný kanál nazvaný jednoduše <strong>stop</strong>.</div></p>

<p>Prakticky stejným způsobem se <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-goroutines/subscriber.go">upraví
i příjemce zpráv</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/go-stomp/stomp"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
var stop = make(chan bool)
&nbsp;
func <strong>receiveMessages</strong>(subscribed chan bool) {
        defer func() {
                stop &lt;- true
        }()
&nbsp;
        conn, err := stomp.Dial("tcp", serverAddr, nil)
&nbsp;
        if err != nil {
                println("cannot connect to server", err.Error())
                return
        } else {
                println("connected to server", serverAddr)
        }
&nbsp;
        defer conn.Disconnect()
&nbsp;
        sub, err := conn.Subscribe(queueName, stomp.AckAuto)
        if err != nil {
                println("cannot subscribe to", queueName, err.Error())
                return
        }
        close(subscribed)
&nbsp;
        for {
                msg := &lt;-sub.C
                text := string(msg.Body)
                if text != "EXIT" {
                        println("Received message", text)
                } else {
                        println("Received EXIT command")
                        break
                }
        }
        println("receiver finished")
}
&nbsp;
func <strong>main</strong>() {
        subscribed := make(chan bool)
        go receiveMessages(subscribed)
&nbsp;
        &lt;-subscribed
&nbsp;
        &lt;-stop
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Producent i konzument jako součást jediné aplikace se třemi paralelně běžícími gorutinami</h2>

<p>Pro zajímavost se podívejme na <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-one-app/publisher_subscriber.go">způsob
implementace</a> producenta i konzumenta zpráv v&nbsp;jediné aplikaci, ve které
se tedy používají tři gorutiny &ndash; hlavní gorutina, gorutina producenta
zpráv a gorutina jejich konzumenta:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/go-stomp/stomp"
        "time"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
const messageCount = 10
&nbsp;
var stop = make(chan bool)
&nbsp;
func <strong>sendMessages</strong>() {
        defer func() {
                stop &lt;- true
        }()
&nbsp;
        conn, err := stomp.Dial("tcp", serverAddr, nil)
        if err != nil {
                println("Cannot connect to server", err.Error())
                return
        } else {
                println("Publisher part connected to server", serverAddr)
        }
        defer conn.Disconnect()
&nbsp;
        time.Sleep(5 * time.Second)
&nbsp;
        for i := 1; i &lt;= messageCount; i++ {
                text := fmt.Sprintf("Message #%d", i)
                err = conn.Send(queueName, "text/plain", []byte(text), nil)
                if err != nil {
                        println("Failed to send to server", err)
                        return
                } else {
                        println("Message sent")
                }
        }
        println("Sending EXIT message")
        err = conn.Send(queueName, "text/plain", []byte("EXIT"), nil)
        if err != nil {
                println("Failed to send EXIT message to server", err)
                return
        } else {
                println("Message sent")
        }
        println("Publisher finished")
}
&nbsp;
func <strong>receiveMessages</strong>(subscribed chan bool) {
        defer func() {
                stop &lt;- true
        }()
&nbsp;
        conn, err := stomp.Dial("tcp", serverAddr, nil)
&nbsp;
        if err != nil {
                println("Cannot connect to server", err.Error())
                return
        } else {
                println("Subscriber part connected to server", serverAddr)
        }
&nbsp;
        defer conn.Disconnect()
&nbsp;
        time.Sleep(5 * time.Second)
&nbsp;
        sub, err := conn.Subscribe(queueName, stomp.AckAuto)
        if err != nil {
                println("Cannot subscribe to", queueName, err.Error())
                return
        }
        close(subscribed)
&nbsp;
        for {
                msg := &lt;-sub.C
                text := string(msg.Body)
                if text != "EXIT" {
                        println("Received message", text)
                } else {
                        println("Received EXIT command")
                        break
                }
        }
        println("Subscriber finished")
}
&nbsp;
func <strong>main</strong>() {
        go sendMessages()
        subscribed := make(chan bool)
        go receiveMessages(subscribed)
&nbsp;
        &lt;-subscribed
&nbsp;
        &lt;-stop
        &lt;-stop
}
</pre>

<p>Na tomto místě se můžete oprávněně zeptat, proč vlastně pro komunikaci mezi
několika gorutinami, které jsou součástí jediné aplikace, vlastně používáme
message brokera se všemi komplikacemi, které toto řešení přináší. Můžeme totiž
namísto toho vytvořit běžný komunikační kanál, nastavit mu vysokou kapacitu
bufferu a používat přímo operátor &lt;- pro přidání hodnoty (zprávy) do kanálu
i pro vyjmutí a zpracování této hodnoty (zprávy) na straně druhé. To je
samozřejmě pravda a toto řešení bude plně funkční a zajistí i dobrou výkonnost.
Ovšem ve chvíli, kdy je zapotřebí zaručit, že zpráva bude skutečně doručena, i
když dojde například k&nbsp;pádu aplikace, již může být použití message brokera
užitečným řešením. A pokud se navíc přidá i požadavek na zajištění persistence
zpráv, je message broker (například běžící pouze lokálně) nejenom vhodné, ale
pro tuto část architektury celé aplikace vlastně i idiomatické řešení (idiomy
se totiž netýkají jen programových konstrukcí, ale i celé architektury).</p>

<p><div class="rs-tip-major">Poznámka: samozřejmě je možné použít pro čekání na
obě gorutiny (zdroje zpráv i příjemce) dva samostatné kanály pojmenované
například <strong>stopProducer</strong> a <strong>stopConsumer</strong>, čímž
se automaticky zajistí, že například producent zpráv nezapíše do kanálu omylem
dvě hodnoty. Na konci funkce <strong>main</strong> je potom prakticky jedno, ze
kterého kanálu bude provedeno čtení dříve. Úprava programu s&nbsp;implementací
producenta i konzumenta běžících v&nbsp;samostatném vláknu by tedy vypadala
následovně:</div></p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/go-stomp/stomp"
        "time"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
const messageCount = 10
&nbsp;
var stopProducer = make(chan bool)
var stopConsumer = make(chan bool)
&nbsp;
func <strong>sendMessages</strong>(stop chan bool) {
        defer func() {
                stop &lt;- true
        }()
&nbsp;
        conn, err := stomp.Dial("tcp", serverAddr, nil)
        if err != nil {
                println("Cannot connect to server", err.Error())
                return
        } else {
                println("Publisher part connected to server", serverAddr)
        }
        defer conn.Disconnect()
&nbsp;
        time.Sleep(5 * time.Second)
&nbsp;
        for i := 1; i &lt;= messageCount; i++ {
                text := fmt.Sprintf("Message #%d", i)
                err = conn.Send(queueName, "text/plain", []byte(text), nil)
                if err != nil {
                        println("Failed to send to server", err)
                        return
                } else {
                        println("Message sent")
                }
        }
        println("Sending EXIT message")
        err = conn.Send(queueName, "text/plain", []byte("EXIT"), nil)
        if err != nil {
                println("Failed to send EXIT message to server", err)
                return
        } else {
                println("Message sent")
        }
        println("Publisher finished")
}
&nbsp;
func <strong>receiveMessages</strong>(subscribed chan bool, stop chan bool) {
        defer func() {
                stop &lt;- true
        }()
&nbsp;
        conn, err := stomp.Dial("tcp", serverAddr, nil)
&nbsp;
        if err != nil {
                println("Cannot connect to server", err.Error())
                return
        } else {
                println("Subscriber part connected to server", serverAddr)
        }
&nbsp;
        defer conn.Disconnect()
&nbsp;
        time.Sleep(5 * time.Second)
&nbsp;
        sub, err := conn.Subscribe(queueName, stomp.AckAuto)
        if err != nil {
                println("Cannot subscribe to", queueName, err.Error())
                return
        }
        close(subscribed)
&nbsp;
        for {
                msg := &lt;-sub.C
                text := string(msg.Body)
                if text != "EXIT" {
                        println("Received message", text)
                } else {
                        println("Received EXIT command")
                        break
                }
        }
        println("Subscriber finished")
}
&nbsp;
func <strong>main</strong>() {
        go sendMessages(stopProducer)
        subscribed := make(chan bool)
        go receiveMessages(subscribed, stopConsumer)
&nbsp;
        &lt;-subscribed
&nbsp;
        &lt;-stopProducer
        &lt;-stopConsumer
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Jedna z&nbsp;možných implementací message brokera naprogramovaná v&nbsp;nativním Go a používající Redis jako storage</h2>

<p>Hned <a
href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">v&nbsp;úvodní
části</a> <a href="https://www.root.cz/serialy/message-brokery/">seriálu o
message brokerech</a> jsme se zabývali popisem nástroje nazvaného <i>Redis
Queue</i>, jenž je postaven &ndash; jak již ostatně jeho název velmi dobře
napovídá &ndash; na databázi <i>Redis</i> [<a
href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">1</a>]
[<a
href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">2</a>],
která se používá pro ukládání jednotlivých zpráv do front. Podobný koncept
používá i další dnes popisovaná knihovna, která se jmenuje <i>rmq</i> a
nalezneme ji na GitHubu na adrese <a
href="https://github.com/adjust/rmq">https://github.com/adjust/rmq</a>.</p>

<p>Jedná se o balíček určený pro vývojáře využívající programovací jazyk Go
(ostatně i samotné <i>rmq</i> je vytvořeno v&nbsp;čistém Go), kteří potřebují
vytvářet klienty připojované k&nbsp;message brokerovi, přičemž cílem autorů
<i>rmq</i> je dosáhnout toho, aby kód vytvořený v&nbsp;klientech byl co
nejkratší a navíc i snadno pochopitelný. Samotný message broker je opět tvořen
databází <i>Redis</i> a balíček <i>rmq</i> &bdquo;pouze&ldquo; zabezpečuje
posílání, výběr a ukládání zpráv do Redisu.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace a nastavení Redisu i <strong>rmq</strong></h2>

<p>Nejprve si řekněme, jak se vlastně <i>rmq</i> instaluje.</p>

<p>V&nbsp;prvním kroku musíme nainstalovat a spustit samotný Redis, což je
snadné, protože je balíček s&nbsp;Redisem součástí většiny Linuxových
distribucí. Například na Fedoře může instalace vypadat následovně:</p>

<pre>
$ <strong>sudo dnf install redis</strong>
&nbsp;
Last metadata expiration check: 0:15:30 ago on Wed 24 Oct 2018, 22:50:11 CEST.
Dependencies resolved.
================================================================================
 Package           Arch            Version               Repository        Size
================================================================================
Installing:
 redis             x86_64          4.0.9-1.fc27          updates          580 k
Installing dependencies:
 jemalloc          x86_64          4.5.0-5.fc27          updates          210 k
&nbsp; 
Transaction Summary
================================================================================
Install  2 Packages
&nbsp; 
Total download size: 790 k
Installed size: 2.0 M
Is this ok [y/N]:
&nbsp;
</pre>

<p>Na systémech založených na Debianu (včetně Ubuntu) lze pro instalaci použít
příkaz:</p>

<pre>
$ <strong>apt-get install redis-server</strong>
</pre>

<p>V&nbsp;případě, že budete potřebovat použít nejnovější verzi Redisu, můžete
si ho sami přeložit. Postup je jednoduchý (mj.&nbsp;i díky minimálním
závislostem na dalších knihovnách) a je podrobně popsán na stránce <a
href="https://redis.io/topics/quickstart">https://redis.io/topics/quickstart</a>.

<p>Pro vlastní databázi, konfigurační soubor, žurnál a logy Redisu použijeme
samostatný adresář, který vytvoříme v&nbsp;domácím adresáři připojeného
uživatele:</p>

<pre>
$ <strong>mkdir redis</strong>
$ <strong>cd redis</strong>
</pre>

<p>Po instalaci se můžeme přesvědčit, že je skutečně k dispozici spustitelný
soubor s&nbsp;implementací serveru i řádkového klienta:</p>

<pre>
$ <strong>whereis -b redis-cli</strong>
redis-cli: /usr/bin/redis-cli
</pre>
 
<pre>
$ <strong>whereis -b redis-server</strong>
redis-server: /usr/bin/redis-server
</pre>

<p>Následně přímo v&nbsp;tomto adresáři vytvoříme konfigurační soubor nazvaný
<strong>redis.conf</strong>. Můžeme se přitom inspirovat souborem
<strong>/etc/redis/redis.conf</strong> (Debian a systémy od něj odvozené),
popř. <strong>/etc/redis.conf</strong> (Fedora, RHEL, CentOS), který je však
poměrně rozsáhlý, protože kromě vlastních konfiguračních voleb obsahuje i
podrobné informace o významu jednotlivých konfiguračních voleb. Tento soubor je
taktéž dostupný na internetu na adrese <a
href="https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf">https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf</a>.</p>

<p>Následuje výpis obsahu konfiguračního souboru, který je připraven pro
lokální spuštění Redisu, bez nebezpečí, že se k&nbsp;běžícímu serveru připojí
případný útočník. Důležité volby jsou zvýrazněny. Pokud se vám soubor nechce
kopírovat, naleznete ho na adrese <a
href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>:</p>

<pre>
<strong>bind 127.0.0.1</strong>
<strong>protected-mode yes</strong>
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300
daemonize no
supervised no
pidfile /var/run/redis_6379.pid
loglevel notice
<strong>logfile redis.log</strong>
databases 16
always-show-logo yes
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
<strong>dir .</strong>
slave-serve-stale-data yes
slave-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-disable-tcp-nodelay no
slave-priority 100
lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
slave-lazy-flush no
appendonly yes
<strong>appendfilename "appendonly.aof"</strong>
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
aof-use-rdb-preamble no
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events ""
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
</pre>

<p>Nyní již můžeme databázi Redis spustit, aniž by došlo k&nbsp;tomu, že bude
její API viditelné ostatním počítačům připojeným do sítě:</p>

<pre>
$ <strong>redis-server redis.conf </strong>
</pre>

<p>Na druhém terminálu pak již můžeme (čistě pro otestování) spustit klienta
Redisu, který uživatelům nabízí interaktivní příkazový řádek:</p>

<pre>
$ <strong>redis-cli</strong>
127.0.0.1:6379&gt;
</pre>

<p>Příkazem &bdquo;ping&ldquo; můžeme otestovat, jestli se klient připojí
k&nbsp;serveru a zda od něj dokáže získávat odpovědi:</p>

<pre>
127.0.0.1:6379&gt; <strong>ping</strong>
PONG
&nbsp;
127.0.0.1:6379&gt; <strong>ping test</strong>
"test"
</pre>

<p>Nyní by měl být systém Redis připraven pro připojení klientů, kteří
s&nbsp;využitím balíčku <strong>rmq</strong> využijí tuto databázi ve funkci
storage message brokera. Nastává tedy čas pro instalaci balíčku
<strong>rmq</strong>. Nejprve přejdeme do adresáře <strong>~/go</strong> (ten
již byl připraven v&nbsp;rámci instalace jazyka Go, kterou jsme si <a
href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/#k13">popsali
minule</a>):</p>

<pre>
$ <strong>cd ~/go</strong>
</pre>

<p>Dále v&nbsp;tomto adresáři zadáme následující příkaz:</p>

<pre>
$ <strong>go get https://github.com/adjust/rmq</strong>
</pre>

<p>V&nbsp;adresáři by se měla objevit následující struktura (pod)adresářů:</p>

<pre>
.
├── pkg
│   └── linux_amd64
│       └── github.com
│           └── adjust
└── src
    └── github.com
        ├── adjust
        │   ├── <strong>rmq</strong>
        │   │   └── example
        │   │       ├── batch_consumer
        │   │       ├── cleaner
        │   │       ├── consumer
        │   │       ├── handler
        │   │       ├── producer
        │   │       ├── purger
        │   │       └── returner
        │   └── uniuri
        └── go-redis
            └── <strong>redis</strong>
                ├── internal
                │   ├── consistenthash
                │   ├── hashtag
                │   ├── pool
                │   ├── proto
                │   └── util
                └── testdata
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se ve skutečnosti
nainstalovaly dva balíčky nazvané <strong>rmq</strong> a taktéž
<strong>redis</strong>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Jednoduchý producent posílající textové zprávy</h2>

<p>Při implementaci producenta jednoduchých textových zpráv využijeme především
funkci pojmenovanou <strong>OpenConnection</strong>, která se pokusí o
připojení k&nbsp;Redisu:</p>

<pre>
func <strong>OpenConnection</strong>(tag, network, address string, db int) *redisConnection
</pre>

<p>Připojení může být realizováno následovně:</p>

<pre>
connection := rmq.OpenConnection("test_service_producer", "tcp", "localhost:6379", 1)
</pre>

<p>Získáme tak datovou strukturu, která mj.&nbsp;implementuje rozhraní nazvané
<strong>Connection</strong>:</p>

<pre>
type <strong>Connection</strong> interface {
        OpenQueue(name string) Queue
        CollectStats(queueList []string) Stats
        GetOpenQueues() []string
}
</pre>

<p>Dnes nás bude zajímat jen jediná metoda z&nbsp;tohoto rozhraní, a to
konkrétně metoda pro otevření (či vytvoření) fronty se zadaným jménem:</p>

<pre>
func (connection *redisConnection) <strong>OpenQueue</strong>(name string) Queue
</pre>

<p>Konkrétní příklad použití:</p>

<pre>
connection := rmq.OpenConnection("test_service_producer", "tcp", "localhost:6379", 1)
taskQueue := connection.OpenQueue("task_queue")
</pre>

<p>Jakmile je fronta získána či vytvořena, můžeme použít její metodu
<strong>Publish</strong> pro publikování nějaké zprávy, tj.&nbsp;pro její
poslání do fronty:</p>

<pre>
func (queue *redisQueue) <strong>Publish</strong>(payload string) bool
</pre>

<p>Opět si ukažme praktické použití:</p>

<pre>
connection := rmq.OpenConnection("test_service_producer", "tcp", "localhost:6379", 1)
taskQueue := connection.OpenQueue("task_queue")
delivery := "task payload 1"
taskQueue.Publish(delivery)
</pre>

<p><a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/01-producer-consumer/producer.go">Celý
zdrojový kód klienta</a> je nakonec velmi krátký a přehledný:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "github.com/adjust/rmq"
&nbsp;
func <strong>main</strong>() {
        connection := rmq.OpenConnection("test_service_producer", "tcp", "localhost:6379", 1)
        println("Connection object: ", connection)
&nbsp;
        taskQueue := connection.OpenQueue("task_queue")
        println("Queue: ", taskQueue)
&nbsp;
        delivery := "task payload 1"
        taskQueue.Publish(delivery)
&nbsp;
        delivery = "task payload 2"
        taskQueue.Publish(delivery)
}
</pre>

<p><div class="rs-tip-major">Poznámka: na straně Redisu se vytvoří dva objekty
v&nbsp;databázi:</div></p>

<table>
<tr><th>Objekt</th><th>Stručný popis</th></tr>
<tr><td>rmq::connections</td><td>množina aktivních připojení</td></tr>
<tr><td>rmq::queues</td><td>množina front</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Konzument zpracovávající jednoduché textové zprávy</h2>

<p>Konzument zpráv je nepatrně složitější, protože se zde používá callback
metoda nazvaná <strong>Consume</strong>. Po připojení a vytvoření fronty nám
již známým způsobem:</p>

<pre>
connection := rmq.OpenConnection("test_service_consumer", "tcp", "localhost:6379", 1)
taskQueue := connection.OpenQueue("task_queue")
</pre>

<p>je nutné se přihlásit k&nbsp;odběru zpráv a zaregistrovat objekt typu
<i>Consumer</i>, který bude zprávy odebírat:</p>

<pre>
taskQueue.StartConsuming(10, time.Second)
taskQueue.AddConsumer("consumer", NewConsumer())
</pre>

<p>Samotný odběratel zpráv musí implementovat toto rozhraní s&nbsp;jedinou
metodou:</p>

<pre>
type <strong>Consumer</strong> interface {
        Consume(delivery Delivery)
}
</pre>

<p>Přičemž <strong>Delivery</strong> je rozhraní implementované datovou
strukturou se zprávou:</p>

<pre>
type <strong>Delivery</strong> interface {
        Payload() string
        Ack() bool
        Reject() bool
        Push() bool
}
</pre>

<p>Důležité jsou metody pro potvrzení zprávy či naopak pro její nepotvrzení:</p>

<pre>
func (delivery *wrapDelivery) <strong>Ack</strong>() bool
</pre>

<pre>
func (delivery *wrapDelivery) <strong>Reject</strong>() bool
</pre>

<p>Ty využijeme v&nbsp;našem konzumentovi/příjemci zpráv:</p>

<pre>
func (consumer *Consumer) <strong>Consume</strong>(delivery rmq.Delivery) {
        println("consume begin")
&nbsp;
        println(delivery.Payload())
        delivery.Ack()
&nbsp;
        println("consume end")
}
</pre>

<p><a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/01-producer-consumer/consumer.go">Úplná
implementace klienta</a> může vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/adjust/rmq"
        "time"
)
&nbsp;
type <strong>Consumer</strong> struct {
}
&nbsp;
func <strong>NewConsumer</strong>() *Consumer {
        return &amp;Consumer{}
}
&nbsp;
func (consumer *Consumer) <strong>Consume</strong>(delivery rmq.Delivery) {
        println("consume begin")
&nbsp;
        println(delivery.Payload())
        delivery.Ack()
&nbsp;
        println("consume end")
}
&nbsp;
func <strong>main</strong>() {
        connection := rmq.OpenConnection("test_service_consumer", "tcp", "localhost:6379", 1)
        println("Connection object: ", connection)
&nbsp;
        taskQueue := connection.OpenQueue("task_queue")
        println("Queue: ", taskQueue)
&nbsp;
        taskQueue.StartConsuming(10, time.Second)
        taskQueue.AddConsumer("consumer", NewConsumer())
        select {}
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Marshalling a unmarshalling datových struktur do formátu JSON pro posílání složitějších zpráv</h2>

<p>Často se setkáme i s&nbsp;požadavkem, aby byly zprávy posílány ve formátu
JSON. Problematice převodu datových struktur z&nbsp;jazyka Go do JSONu
(<i>marshalling</i>) a samozřejmě i zpětného převodu (<i>unmarshalling</i>)
jsme se nedávno věnovali v&nbsp;samostatném článku <a
href="https://www.root.cz/clanky/vyvoj-sitovych-aplikaci-v-programovacim-jazyku-go-prace-s-jsonem-a-rastrovymi-obrazky/">Vývoj
síťových aplikací v programovacím jazyku Go (práce s JSONem a rastrovými
obrázky)</a>, takže jen ve stručnosti:</p>

<p>Pro převod libovolného typu (přesněji řečeno hodnoty libovolného typu) do
JSONu se používá funkce nazvaná <strong>Marshal</strong>, kterou nalezneme
v&nbsp;balíčku <strong>encoding/json</strong>:</p>

<pre>
func <strong>Marshal</strong>(v interface{}) ([]byte, error)
</pre>

<p>Opačná operace spočívá v&nbsp;importu dat z&nbsp;formátu JSON do interních
datových struktur programovacího jazyka Go. Pro tuto operaci, která se nazývá
<i>unmarshalling</i>, slouží následující funkce:</p>

<pre>
func <strong>Unmarshal</strong>(data []byte, v interface{}) error
</pre>

<p>Vstupem je v&nbsp;tomto případě pole (řez) bajtů, výstup je vrácen přes
ukazatel předaný ve druhém parametru (což znamená, že se musíme sami postarat o
případnou alokaci paměti pro strukturu či pro mapu). Samozřejmě, že při
<i>unmarshallingu</i> může dojít k&nbsp;nějaké chybě, která je vrácena volající
funkci. Pokud k&nbsp;chybě nedošlo, je návratová hodnota rovna
<strong>nil</strong>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úprava producenta takovým způsobem, aby posílal zprávy ve formátu JSON</h2>

<p>Vyzkoušejme si nyní upravit producenta zpráv tak, aby posílal obsah datové
struktury nazvané <strong>TaskPayload</strong> ve formátu JSON. Strukturu
nejdříve převedeme do JSONu a následně výsledek takzvaného
&bdquo;marshallingu&ldquo; pošleme do message brokera:</p>

<pre>
bytes, err := json.Marshal(payload)
if err != nil {
        println(err)
        return
}
taskQueue.PublishBytes(bytes)
</pre>

<p>Následuje výpis <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/02-producer-consumer-json/producer.go">úplného
zdrojového kódu</a> tohoto příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/json"
        "github.com/adjust/rmq"
)
&nbsp;
type <strong>TaskPayload</strong> struct {
        Id     int32
        Name   string
        Param1 int32
        Param2 int32
}
&nbsp;
func <strong>SendTask</strong>(taskQueue rmq.Queue, payload TaskPayload) {
        bytes, err := json.Marshal(payload)
        if err != nil {
                println(err)
                return
        }
        taskQueue.PublishBytes(bytes)
}
&nbsp;
func <strong>main</strong>() {
        connection := rmq.OpenConnection("test_service_producer", "tcp", "localhost:6379", 1)
        println("Connection object: ", connection)
&nbsp;
        taskQueue := connection.OpenQueue("task_queue")
        println("Queue: ", taskQueue)
&nbsp;
        SendTask(taskQueue, TaskPayload{1, "test1", 0, 0})
        SendTask(taskQueue, TaskPayload{2, "test2", 6, 7})
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Konzument akceptující zprávy ve formátu JSON</h2>

<p>Konzument zpráv posílaných ve formátu JSON je složitější. Nejdříve totiž
musíme získat obsah zprávy (<i>payload</i>), ten převést z&nbsp;JSONu do datové
struktury (<i>unmarshalling</i>) a výsledek použít:</p>

<pre>
var task TaskPayload
if err := json.Unmarshal([]byte(delivery.Payload()), &amp;task); err != nil {
        delivery.Reject()
        return
}
&nbsp;
println("performing task", task.Id, "name", task.Name, "with parameters", task.Param1, task.Param2)
delivery.Ack()
</pre>

<p>Výsledný <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/02-producer-consumer-json/consumer.go">zdrojový
kód</a> může vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "encoding/json"
        "github.com/adjust/rmq"
        "time"
)
&nbsp;
type <strong>TaskPayload</strong> struct {
        Id     int32
        Name   string
        Param1 int32
        Param2 int32
}
&nbsp;
type <strong>Consumer</strong> struct {
}
&nbsp;
func <strong>NewConsumer</strong>() *Consumer {
        return &amp;Consumer{}
}
&nbsp;
func (consumer *Consumer) <strong>Consume</strong>(delivery rmq.Delivery) {
        println("consume begin")
&nbsp;
        println(delivery.Payload())
&nbsp;
        var task TaskPayload
        if err := json.Unmarshal([]byte(delivery.Payload()), &amp;task); err != nil {
                delivery.Reject()
                return
        }
&nbsp;
        println("performing task", task.Id, "name", task.Name, "with parameters", task.Param1, task.Param2)
        delivery.Ack()
&nbsp;
        println("consume end")
}
&nbsp;
func <strong>main</strong>() {
        connection := rmq.OpenConnection("test_service_consumer", "tcp", "localhost:6379", 1)
        println("Connection object: ", connection)
&nbsp;
        taskQueue := connection.OpenQueue("task_queue")
        println("Queue: ", taskQueue)
&nbsp;
        taskQueue.StartConsuming(10, time.Second)
        taskQueue.AddConsumer("consumer", NewConsumer())
        select {}
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Přenos binárních zpráv</h2>

<p>Mnohdy se setkáme s&nbsp;požadavkem, aby klienti do message brokera posílali
binární zprávy, samozřejmě s&nbsp;tím, že po vyzvednutí bude mít zpráva
naprosto stejný obsah, jako originální data (tj.&nbsp;nesmí dojít například
k&nbsp;porušení obsahu nejvyšších bitů každého bajtu atd.).</p>

<p>Při psaní klientů naprogramovaných v&nbsp;Pythonu, kteří spolu komunikovali
přes message broker Apache ActiveMQ, jsme se posílání binárních zpráv vyhnuli
díky zakódování binárních dat do sekvence tisknutelných znaků, například
s&nbsp;využitím <a href="https://cs.wikipedia.org/wiki/Base64">Base64</a>,
který má tu výhodu, že algoritmus kódování/dekódování lze vytvořit velmi snadno
(pokud již pro daný programovací jazyk neexistuje příslušná knihovna &ndash;
většinou je již k&nbsp;dispozici). Nevýhodou tohoto řešení jsou delší zprávy,
které musí být v&nbsp;message brokerovi uloženy (ve frontách) a &ndash; což je
většinou kritičtější &ndash; pomalejší posílání či příjem zpráv &ndash; pokud
se ovšem zpracovávají relativně krátké zprávy s&nbsp;menší frekvencí (desítky
za sekundu pro jednoho producenta), nemělo by být zpoždění vůbec patrné.</p>

<p>Pro otestování posílání a příjmu zpráv s&nbsp;binárními daty vytvoříme
producenta, který do vybrané fronty pošle data reprezentující rastrový obrázek
ve formátu GIF. Samotný obrázek získáme snadno (jedná se o ikonu <a
href="https://www.root.cz/vyhledavani/?qs=vim">Vimu</a>, v&nbsp;němž ostatně
celý tento článek vznikl):</p>

<pre>
wget https://www.vim.org/images/vim_editor.gif
</pre>

<p>Jedná se o následující obrázek &ndash; ikonu:</p>

<a href="https://www.root.cz/obrazek/353736/"><img src="https://i.iinfo.cz/images/529/amq2-1.gif" class="image-353736" alt="&#160;" width="125" height="60" /></a>
<p><i>Obrázek 1: Ikona použitá jako příklad binárních dat.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Vytvoření a poslání binární zprávy</h2>

<p>Pro posílání textové zprávy jsme v&nbsp;předchozích dvou příkladech
využívali metodu <strong>Publish</strong>:</p>

<pre>
func (queue *redisQueue) <strong>Publish</strong>(payload string) bool
</pre>

<p>U binárních dat to není vhodné, ovšem existuje i alternativní metoda nazvaná
příznačně <strong>PublishBytes</strong>:</p>

<pre>
func (queue *redisQueue) <strong>PublishBytes</strong>(payload []byte) bool
</pre>

<p>Ve zdroji zpráv ještě uděláme jednu změnu &ndash; vytvoříme funkci, která
načte obsah binárního souboru a ten následně pošle do zvolené fronty:</p>

<pre>
bytes, err := ioutil.ReadFile(filename)
if err == nil {
        println("Read", len(bytes), "bytes")
        SendBinaryMessage(binaryMessagesQueue, bytes)
        println("Sent")
} else {
        println("Error opening file", err)
}
</pre>

<p><a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/03-producer-consumer-binary/producer.go">Úplný
zdrojový kód</a> producenta binární zprávy může vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/adjust/rmq"
        "io/ioutil"
)
&nbsp;
func <strong>SendBinaryMessage</strong>(binaryMessagesQueue rmq.Queue, binaryMessage []byte) {
        binaryMessagesQueue.PublishBytes(binaryMessage)
}
&nbsp;
func <strong>SendFileContent</strong>(binaryMessagesQueue rmq.Queue, filename string) {
        bytes, err := ioutil.ReadFile(filename)
        if err == nil {
                println("Read", len(bytes), "bytes")
                SendBinaryMessage(binaryMessagesQueue, bytes)
                println("Sent")
        } else {
                println("Error opening file", err)
        }
}
&nbsp;
func <strong>main</strong>() {
        connection := rmq.OpenConnection("binary_message_app", "tcp", "localhost:6379", 1)
        println("Connection object: ", connection)
&nbsp;
        binaryMessagesQueue := connection.OpenQueue("binary_messages_queue")
        println("Queue: ", binaryMessagesQueue)
&nbsp;
        SendFileContent(binaryMessagesQueue, "vim_editor.gif")
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Příjem binární zprávy</h2>

<p>Příjemce binární zprávy bude muset být také upraven. Zprávu přijmeme běžným
způsobem, ovšem samotný její obsah (<i>payload</i>) bude uložen do souboru
s&nbsp;využitím funkce <strong>WriteFile</strong> z&nbsp;balíčku
<strong>ioutil</strong>. Povšimněte si, že této funkci je nutné předat i
příznaky <a
href="https://cs.wikipedia.org/wiki/P%C5%99%C3%ADstupov%C3%A1_pr%C3%A1va_v_Unixu">s&nbsp;přístupovými
právy</a> k&nbsp;souboru:</p>

<pre>
const FileFlags = 0664
&nbsp;
payload := delivery.Payload()
&nbsp;
println("Received binary message", len(payload), "bytes")
&nbsp;
err := ioutil.WriteFile("received.gif", []byte(payload), FileFlags)
if err == nil {
        println("Written")
} else {
        println(err)
}
delivery.Ack()
</pre>

<p>Opět si samozřejmě ukážeme <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/03-producer-consumer-binary/consumer.go">úplný
zdrojový kód</a> tohoto příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/adjust/rmq"
        "io/ioutil"
        "time"
)
&nbsp;
type Consumer struct{}
&nbsp;
func <strong>NewConsumer</strong>() *Consumer {
        return &amp;Consumer{}
}
&nbsp;
func (consumer *Consumer) Consume(delivery rmq.Delivery) {
        const FileFlags = 0664
&nbsp;
        println("consume begin")
        payload := delivery.Payload()
&nbsp;
        println("Received binary message", len(payload), "bytes")
&nbsp;
        err := ioutil.WriteFile("received.gif", []byte(payload), FileFlags)
        if err == nil {
                println("Written")
        } else {
                println(err)
        }
        delivery.Ack()
&nbsp;
        println("consume end")
}
&nbsp;
func <strong>main</strong>() {
        connection := rmq.OpenConnection("binary_messages_queue", "tcp", "localhost:6379", 1)
        println("Connection object: ", connection)
&nbsp;
        binaryMessagesQueue := connection.OpenQueue("binary_messages_queue")
        println("Queue: ", binaryMessagesQueue)
&nbsp;
        binaryMessagesQueue.StartConsuming(10, time.Second)
        binaryMessagesQueue.AddConsumer("consumer", NewConsumer())
        select {}
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Systém NATS aneb implementace systému pro doručování zpráv v&nbsp;jazyku Go</h2>

<p>V&nbsp;závěrečné části dnešního článku se zmíníme o systému pro doručování,
ukládání a (re)distribuci zpráv, který se jmenuje <a
href="https://nats.io/">NATS</a>. Jedná se o poměrně úspěšný projekt, jenž je
vyvinut právě v&nbsp;programovacím jazyku Go, což mu do jisté míry zajišťuje
stabilitu i škálovatelnost. To jsou vlastnosti, které u message brokerů
většinou očekáváme.</p>

<p>Původní varianta NATSu byla vytvořena Derekem Collisonem; zajímavé je, že
tato varianta nebyla naprogramována v&nbsp;jazyce Go, ale v&nbsp;programovacím
jazyce Ruby. Dnes se ovšem budeme zabývat moderní (a jedinou podporovanou)
verzí systému NATS, která byla přeportována do jazyka Go. Celý systém NATS se
skládá z&nbsp;několika komponent:</p>

<ol>

<li>V&nbsp;první řadě se jedná o samotný <i>server</i>, jenž se spouští
příkazem <strong>gnatsd</strong>. Server je naprogramovaný v&nbsp;Go a při jeho
vývoji bylo dbáno na to, aby byla zaručena vysoká dostupnost celé služby a
přitom byla samotná služba s&nbsp;běžícím serverem málo náročná na systémové
zdroje, především na spotřebu operační paměti (to má v&nbsp;době Dockeru a
podobných nástrojů poměrně velký význam).</li>

<li>Dalším typem komponenty jsou programátorská rozhraní pro klienty, která
v&nbsp;současnosti existují pro několik ekosystémů (což je většinou kombinace
programovacího jazyka, knihoven a popř.&nbsp;jeho virtuálního stroje); viz též
tabulky s&nbsp;podporovanými ekosystémy, které jsou zobrazeny pod tímto
odstavcem.</li>

<li>Třetí komponentou je <i>NATS Streaming Server</i>, který je opět
naprogramován v&nbsp;Go a který si popíšeme <a href="#k17">v&nbsp;sedmnácté
kapitole</a>.</li>

<li>Čtvrtým typem komponenty je takzvaný <i>NATS Connector Framework</i>
zajišťující propojení systému NATS s&nbsp;dalšími technologiemi (XMPP,
logování, notifikační služby aj.). Ten je naprogramovaný v&nbsp;Javě a
v&nbsp;současnosti je podporován například konektor pro Redis (<a
href="https://github.com/nats-io/nats-connector-redis">https://github.com/nats-io/nats-connector-redis</a>).</li>

</ol>

<p>Oficiálně jsou podporována rozhraní pro následující ekosystémy:</p>

<table>
<tr><th> #</th><th>Programovací jazyk/ekosystém</th></tr>
<tr><td> 1</td><td>C</td></tr>
<tr><td> 2</td><td>C#</td></tr>
<tr><td> 3</td><td>Elixir</td></tr>
<tr><td> 4</td><td>Go</td></tr>
<tr><td> 5</td><td>Java</td></tr>
<tr><td> 6</td><td>NGINX</td></tr>
<tr><td> 7</td><td>Node.js</td></tr>
<tr><td> 8</td><td>Python Asyncio</td></tr>
<tr><td> 9</td><td>Python Tornado</td></tr>
<tr><td>10</td><td>Ruby</td></tr>
<tr><td>11</td><td>TypeScript</td></tr>
</table>

<p>Existují však i další rozhraní, která sice nejsou podporována oficiálně, ale
většinou jsou dostatečně stabilní na to, aby byla reálně použitelná:</p>

<table>
<tr><th> #</th><th>Programovací jazyk/ekosystém</th></tr>
<tr><td> 1</td><td>.NET</td></tr>
<tr><td> 2</td><td>Arduino</td></tr>
<tr><td> 3</td><td>Clojure</td></tr>
<tr><td> 4</td><td>Elm</td></tr>
<tr><td> 5</td><td>Erlang</td></tr>
<tr><td> 6</td><td>Haskell</td></tr>
<tr><td> 7</td><td>Lua</td></tr>
<tr><td> 8</td><td>MicroPython</td></tr>
<tr><td> 9</td><td>PHP</td></tr>
<tr><td>10</td><td>Perl</td></tr>
<tr><td>11</td><td>Python</td></tr>
<tr><td>12</td><td>Python Twisted</td></tr>
<tr><td>13</td><td>Qt5 C++</td></tr>
<tr><td>14</td><td>Rust</td></tr>
<tr><td>15</td><td>Scala</td></tr>
<tr><td>16</td><td>Spring API</td></tr>
<tr><td>17</td><td>Swift</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Komunikační strategie a protokol použitý klienty systému NATS</h2>

<p>NATS svým uživatelům nabízí klasickou komunikační strategii typu
<i>pub-sub</i> (zprávy jsou doručovány na základě nastaveného tématu &ndash;
<i>topicu</i> či v&nbsp;jiné terminologii <i>subjectu</i>), s&nbsp;níž jsme se
již seznámili v&nbsp;předchozích článcích. Ovšem kromě toho je možné využít i
strategie <i>request-reply</i> (ta je implementačně nejsložitější, protože
vyžaduje určitou koordinaci obou klientů se zapamatováním kontextu) a taktéž
strategii typu <i>push-pull</i> (zde se právě využívají fronty zpráv).
Strategie <i>request-reply</i> se dále rozděluje na dvě podkategorie podle
toho, zda se zpráva doručuje jen jedinému příjemci (<i>point-to-point</i>) nebo
více příjemcům (<i>one-to-many</i>). Ve chvíli, kdy klient pošle žádost
(request), vytvoří se pro ni takzvaný <i>inbox</i>, který mohou příjemci použít
po odeslání odpovědi. S&nbsp;příklady použití této zajímavé strategie se
seznámíme v&nbsp;navazujícím článku.</p>

<p>Samotný komunikační protokol používaný klienty při přístupu k&nbsp;systému
NATS je textový a je navržen takovým způsobem, aby bylo možné samotnou
komunikaci naprogramovat relativně snadno, popř.&nbsp;si komunikaci otestovat
přes <strong>telnet</strong> či podobný nástroj (což může být velmi vhodné při
hledání chyb v&nbsp;celém systému; ostatně ti administrátoři, kteří museli
ladit nějaký systém využívající binární protokol jistě budou souhlasit).
V&nbsp;samotném protokolu se rozeznává jen několik typů příkazů, které jsou
vypsány v&nbsp;další tabulce:</p>

<table>
<tr><th>Příkaz</th><th>Posílá</th><th>Stručný popis</th></tr>
<tr><td>INFO</td><td>server</td><td>posláno klientovi po jeho připojení k&nbsp;serveru</td></tr>
<tr><td>CONNECT</td><td>klient</td><td>žádost o připojení se specifikací jeho parametrů</td></tr>
<tr><td>PUB</td><td>klient</td><td>publikace zprávy klientem (formát si popíšeme příště)</td></tr>
<tr><td>SUB</td><td>klient</td><td>přihlášení klienta k&nbsp;odebírání určitého tématu</td></tr>
<tr><td>UNSUB</td><td>klient</td><td>odhlášení klienta od odebírání určitého tématu</td></tr>
<tr><td>MSG</td><td>server</td><td>poslání zprávy serverem odebírateli</td></tr>
<tr><td>PING</td><td>klient i server</td><td>klasický systém ping-pong pro ověření, zda druhá strana (ještě) komunikuje</td></tr>
<tr><td>PONG</td><td>klient i server</td><td>klasický systém ping-pong pro ověření, zda druhá strana (ještě) komunikuje</td></tr>
<tr><td>+OK</td><td>server</td><td>potvrzení zprávy či příkazu (+ je součástí příkazu)</td></tr>
<tr><td>-ERR</td><td>server</td><td>informace o tom, že poslaná zpráva nebo příkaz nemá správný formát (- je opět součástí příkazu)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: i když je samotný protokol textový, jsou
těla zpráv považována za binární data, čehož se často využívá například
v&nbsp;oblasti IoT, kdy čidla mohou přímo posílat naměřená data, bez nutnosti
jejich převodu do JSONu či podobného formátu.</div></p>

<p><div class="rs-tip-major">Poznámka: zajímavé je porovnání <a
href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/#k01">s&nbsp;již
popsaným</a> protokolem <i>STOMP</i>, který používá prakticky stejný přístup, i
když se pochopitelně jednotlivé příkazy od sebe odlišují (v&nbsp;NATS chybí
přímé příkazy pro transakce atd.).</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. NATS Streaming</h2>

<p>Jedná se o rozšíření klasického message brokera o další užitečné vlastnosti,
zejména o konfigurovatelnou persistenci zpráv, dále o systém zaručující
doručení zprávy (jak na message brokera, tak i ke klientovi &ndash; odběrateli
zpráv) a především pak systémem určujícím maximální množství zpráv čekajících
na doručení (<i>publisher rate limit</i>, <i>rate limiting per subscriber</i>).
Nesmíme zapomenout ani na další poměrně unikátní vlastnost: možnost opětovného
&bdquo;přehrátí&ldquo; zpráv podle zadaných kritérií (ke zprávám je přiřazen
určitý <i>subject</i> a taktéž časové razítko, takže pořadí zpráv je možné
zaručit &ndash; ostatně právě proto se také používá termín
&bdquo;streaming&ldquo;). Mimochodem: časové razítko má přesnost v&nbsp;řádu
nanosekund.</p>

<p>Oficiálně podporovaní klienti komponenty <i>NATS Streaming</i>:</p>

<table>
<tr><th>#</th><th>Jazyk/ekosystém</th></tr>
<tr><td>1</td><td>C</td></tr>
<tr><td>2</td><td>C#</td></tr>
<tr><td>3</td><td>Go</td></tr>
<tr><td>4</td><td>Java</td></tr>
<tr><td>5</td><td>Node.js</td></tr>
<tr><td>6</td><td>Python Asyncio</td></tr>
<tr><td>7</td><td>Ruby</td></tr>
</table>

<p>Podrobněji si tento systém vysvětlíme příště.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů naprogramovaných
v&nbsp;programovacím jazyku Go byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce.</p>

<table>
<tr><th>Příklad</th><th>Skript/kód</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>publisher.go</td><td>producent zpráv naprogramovaný v&nbsp;Go</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull/publisher.go</a></td></tr>
<tr><td>1</td><td>subscriber.go</td><td>konzument zpráv naprogramovaný v&nbsp;Go</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull/subscriber.go">https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull/subscriber.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>publisher.go</td><td>producent zpráv naprogramovaný v&nbsp;Go využívající gorutiny</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-goroutines/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-goroutines/publisher.go</a></td></tr>
<tr><td>2</td><td>subscriber.go</td><td>konzument zpráv naprogramovaný v&nbsp;Go využívající gorutiny</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-goroutines/subscriber.go">https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-goroutines/subscriber.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>publisher_subscriber.go</td><td>producent i konzument zpráv běžící paralelně v&nbsp;jediném procesu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-one-app/publisher_subscriber.go">https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-one-app/publisher_subscriber.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>publisher_subscriber.go</td><td>další verze producenta a konzumenta zpráv běžících paralelně v&nbsp;jediném procesu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-one-app-2/publisher_subscriber.go">https://github.com/tisnik/message-queues-examples/blob/master/go-stomp/push-pull-one-app-2/publisher_subscriber.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>producer.go</td><td>producent textových zpráv založených na systému <i>rmq</i></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/01-producer-consumer/producer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/01-producer-consumer/producer.go</a></td></tr>
<tr><td>5</td><td>consumer.go</td><td>konzument textových zpráv založených na systému <i>rmq</i></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/01-producer-consumer/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/01-producer-consumer/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>producer.go</td><td>producent JSON zpráv založených na systému <i>rmq</i></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/02-producer-consumer-json/producer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/02-producer-consumer-json/producer.go</a></td></tr>
<tr><td>6</td><td>consumer.go</td><td>konzument JSON zpráv založených na systému <i>rmq</i></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/02-producer-consumer-json/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/02-producer-consumer-json/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>producer.go</td><td>producent binárních zpráv založených na systému <i>rmq</i></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/03-producer-consumer-binary/producer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/03-producer-consumer-binary/producer.go</a></td></tr>
<tr><td>7</td><td>consumer.go</td><td>konzument binárních zpráv založených na systému <i>rmq</i></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/03-producer-consumer-binary/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/03-producer-consumer-binary/consumer.go</a></td></tr>
<tr><td>7</td><td>get_image</td><td>skript pro stažení testovacího obrázku</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/03-producer-consumer-binary/get_image">https://github.com/tisnik/message-queues-examples/blob/master/go-rmq/03-producer-consumer-binary/get_image</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všech jedenáct předchozích <a
href="https://www.root.cz/serialy/message-brokery/">částí seriálu</a>,
v&nbsp;němž se zabýváme různými způsoby implementace front zpráv a k&nbsp;nim
přidružených technologií:</p>

<ol>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python (dokončení)<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/</a>
</li>

<li>RabbitMQ: jedna z nejúspěšnějších implementací brokera<br />
<a href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/</a>
</li>

<li>Pokročilejší operace nabízené systémem RabbitMQ<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/">https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/</a>
</li>

<li>ØMQ: knihovna pro asynchronní předávání zpráv<br />
<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/</a>
</li>

<li>Další možnosti poskytované knihovnou ØMQ<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/</a>
</li>

<li>Další možnosti nabízené knihovnou ØMQ, implementace protokolů ØMQ v čisté Javě<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/</a>
</li>

<li>Apache ActiveMQ – další systém implementující message brokera<br />
<a href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem STOMP<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem AMQP, jazyk Go a message brokeři<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

