<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Implementace různých komunikačních strategií s využitím knihovny nanomsg</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Implementace různých komunikačních strategií s využitím knihovny nanomsg</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V seriálu o message brokerech a k nim přidružených technologiích jsme se mj. seznámili i s knihovnou ZeroMQ. Ideovým následovníkem této knihovny je projekt nazvaný nanomsg s jehož základními možnostmi se seznámíme v dnešním článku.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Implementace různých komunikačních strategií s&nbsp;využitím knihovny <strong>nanomsg</strong></a></p>
<p><a href="#k02">*** 2. Rozdíly mezi projekty <strong>nanomsg</strong> a <strong>ZeroMQ</strong></a></p>
<p><a href="#k03">*** 3. Základní koncepty, na nichž je knihovna <strong>nanomsg</strong> postavena</a></p>
<p><a href="#k04">*** 4. Podporované přenosové mechanismy</a></p>
<p><a href="#k05">*** 5. Rozhraní pro další programovací jazyky</a></p>
<p><a href="#k06">*** 6. Instalace <strong>nanomsg</strong> ze zdrojových kódů</a></p>
<p><a href="#k07">*** 7. Demonstrační příklady ukazující základní komunikační vzory (strategie)</a></p>
<p><a href="#k08">*** 8. Aplikace posílající zprávy s&nbsp;využitím strategie <strong>PIPELINE</strong></a></p>
<p><a href="#k09">*** 9. Aplikace přijímající zprávy s&nbsp;využitím strategie <strong>PIPELINE</strong></a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. Funkce použité při implementaci jednotlivých komunikujících uzlů</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">*** 19. Odkazy na předchozí části seriálu o message brokerech</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Implementace různých komunikačních strategií s&nbsp;využitím knihovny <strong>nanomsg</strong></h2>

<p>V&nbsp;dnešní části <a href="https://www.root.cz/serialy/message-brokery/">seriálu o message brokerech i o technologiích, které s&nbsp;message brokery souvisí</a>, se seznámíme s&nbsp;projektem nazvaným <strong>nanomsg</strong>. Jedná se o následovníka (stále velmi často používané) knihovny <strong>ZeroMQ</strong> neboli <strong>ØMQ</strong>, s&nbsp;níž jsme se seznámili v&nbsp;trojici článků [<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">1</a>] [<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">2</a>] a taktéž [<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">3</a>]. Připomeňme si ve stručnosti, k&nbsp;čemu je vlastně knihovna <strong>ØMQ</strong> určena. Jedná se o relativně nízkoúrovňovou knihovnu vyvinutou v&nbsp;programovacím jazyce C++, která vývojářům nabízí implementaci různých tzv.&nbsp;<i>komunikačních strategií</i>. Tyto strategie je možné využít a popř.&nbsp;i vhodně zkombinovat při implementaci aplikací se složitější architekturou, v&nbsp;níž mezi sebou jednotlivé části komunikují s&nbsp;využitím synchronních či asynchronních zpráv, popř.&nbsp;přes takzvané <i>brokery</i>.</p>

<p><div class="rs-tip-major">Poznámka: ØMQ je skutečná nativní knihovna, nikoli
služba či démon. Proto se nijak nespouští; její funkce jsou volány konkrétními
implementacemi serverů a klientů.</div></p>

<p>Na knihovnu ØMQ se ovšem můžeme dívat i z&nbsp;jiného pohledu, protože se
jedná o abstrakci nad klasickými Berkeley sockety, ovšem s&nbsp;mnoha
vylepšeními. V&nbsp;ØMQ je totiž možné zprávy odesílat asynchronně; samotné
zpracování zpráv je provedeno na pozadí (ve vlastním vláknu), nemusíme se
starat o délku zpráv a o jejich případnou fragmentaci a do určité míry jsme
odstíněni od toho, jaký konkrétní protokol bude pro komunikaci použit (IPC,
TCP, atd.). Toto zjednodušení se ještě více projeví v&nbsp;těch programovacích
jazycích, které se mohou postarat o automatické uvolňování prostředků (což je
mj.&nbsp;i případ Pythonu, v&nbsp;němž je vytvořeno prvních pět demonstračních
příkladů, s&nbsp;nimiž se seznámíme v&nbsp;navazujících kapitolách).</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti není knihovna <strong>nanomsg</strong> jediným následovníkem projektu <strong>ZeroMQ</strong>, protože stejný autor pracuje na novějším (prozatím ne zcela dokončeném) projektu s&nbsp;výmluvným názvem <strong>nng</strong> neboli <i>nanomsg-next-generation</i>, který naleznete na GitHubu, konkrétně na stránce <a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozdíly mezi projekty <strong>nanomsg</strong> a <strong>ZeroMQ</strong></h2>

<p>Mezi projekty <strong>nanomsg</strong> a <strong>ZeroMQ</strong> přirozeně najdeme několik rozdílů, které jsou velmi pěkně shrnuty na stránce <a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>. Jedná se o následující podstatné rozdíly:</p>

<ol>

<li></li>

<li></li>

<li></li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní koncepty, na nichž je knihovna <strong>nanomsg</strong> postavena</h2>

<p>V&nbsp;knihovně <strong>nanomsg</strong> jsou připraveny funkce navržené takovým způsobem, aby se s&nbsp;jejich pomocí daly implementovat protokoly založené na jedné ze šesti základních komunikačních strategiích (neboli komunikačních vzorech). Jména a stručné charakteristiky těchto strategií naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Strategie/vzor</th><th>Stručný popis významu strategie</th></tr>
<tr><td>1</td><td>PAIR</td><td>jedna z&nbsp;nejjednodušších komunikačních strategií s&nbsp;dvojicí uzlů a vazbou 1:1; komunikace je obousměrná</td></tr>
<tr><td>2</td><td>BUS</td><td>složitější strategie, v&nbsp;níž se používá obecnější vazba M:N</td></tr>
<tr><td>3</td><td>PUBSUB</td><td>klasická komunikační strategie PUB-SUB neboli PUBLISH-SUBSCRIBE</td></tr>
<tr><td>4</td><td>REQREP</td><td>klasická komunikační strategie REQ-REP neboli REQUEST-RESPONSE</td></tr>
<tr><td>5</td><td>PIPELINE</td><td>jednosměrná komunikace buď s&nbsp;vazbami 1:1 (jeden vysílač a jeden přijímač), popř.&nbsp;mezi více vysílači a několika přijímači</td></tr>
<tr><td>6</td><td>SURVEY</td><td>speciální strategie umožňující získat stav více uzlů (procesů) jediným dotazem a mnoha odpovědmi</td></tr>
</table>

<p>U jednotlivých strategií/vzorů se kontroluje, zda jsou použity správně. Příkladem může být strategie <strong>PIPELINE</strong>, v&nbsp;níž jeden komunikující uzel používá socket typu <strong>PUSH</strong> pro vysílání zpráv a druhý uzel naopak socket typu <strong>PULL</strong> pro příjem zpráv. V&nbsp;případě, že se pokusíme poslat zprávu opačným směrem, dojde k&nbsp;běhové chybě, kterou lze snadno detekovat.</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;jednotlivými strategiemi se podrobněji seznámíme při popisu jednotlivých demonstračních příkladů v&nbsp;navazujících kapitolách.</div></p>

<p>Jen pro připomenutí, jaké strategie poskytuje původní knihovna ØMQ:</p>

<ol>

<li><strong>PAIR</strong> &ndash; jednosměrné či obousměrné propojení dvou
procesů, z&nbsp;nichž každý může běžet na odlišném počítači. Tato strategie se
nejvíce přibližuje běžnému použití klasických Berkeley socketů. Prakticky
stejná strategie, i když implementovaná odlišným způsobem, je součástí knihovny
<strong>nanomsg</strong>.</li>

<li><strong>REQ-REP</strong> &ndash; jedná se o komunikaci typu
požadavek-odpověď. Požadavky posílají klienti, odpovědi generuje server, který
dokáže obsloužit prakticky libovolné množství klientů. Podobnou strategii
nalezneme i v&nbsp;dnes popisované knihovně <strong>nanomsg</strong>.</li>

<li><strong>PUB-SUB</strong> &ndash; server zde publikuje zprávy,
k&nbsp;jejichž odběru se mohou přihlásit různí klienti. Zprávy je možné
filtrovat na straně klientů (tato vlastnost se ovšem ve starších verzích ØMQ
odlišuje). I tuto strategii nalezneme v&nbsp;knihovně <strong>nanomsg</strong>,
pouze pod nepatrně odlišným názvem.</li>

<li><strong>PUSH-PULL</strong> &ndash; rozšíření předchozí strategie PUB-SUB:
server či servery vytváří zprávy zpracovávané buď přímo připojenými workery
nebo celou kolonou (pipeline) workerů. Tato strategie je v&nbsp;knihovně
<strong>nanomsg</strong> rozšířena a zobecněna ve strategii
<strong>PIPELINE</strong>.</li>

</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Podporované přenosové mechanismy</h2>

<p>Aplikace (tj.&nbsp;jak klienti a servery), které spolu mají komunikovat s&nbsp;využitím knihovny <strong>nanomsg</strong>, mohou využívat různé přenosové mechanismy. Ty jsou vypsány v&nbsp;následující tabulce, přičemž jsou jednotlivé mechanismy seřazeny podle své &bdquo;lokality&ldquo;. Například přenosový mechanismus nazvaný <strong>INPROC</strong> je použitelný pouze v&nbsp;případě, že spolu komunikují jednotlivé části aplikace běžící v&nbsp;rámci stejného procesu, typicky každá ve svém vlastním vláknu. Menší &bdquo;lokalitu&ldquo; nabízí přenosový mechanismus pojmenovaný <strong>IPC</strong>, jenž umožňuje komunikovat mezi několika procesy, které ovšem musí běžet na stejném počítači. Pro komunikaci mezi aplikacemi běžícími na různých počítačích v&nbsp;rámci intranetu či internetu se používá buď <strong>TCP</strong> (tj.&nbsp;skutečné přenosy dat přes protokol TCP) nebo <strong>WS</strong> (<i>web sockety</i>):</p>

<table>
<tr><th>#</th><th>Přenosový mechanismus</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>INPROC</td><td>komunikace v&nbsp;rámci jednoho procesu, například typizovaná komunikace mezi několika vlákny</td></tr>
<tr><td>2</td><td>IPC</td><td>komunikace mezi několika procesy běžícími na jednom počítači</td></tr>
<tr><td>3</td><td>TCP</td><td>komunikace mezi procesy běžícími na různých počítačích s&nbsp;využitím protokolu TCP</td></tr>
<tr><td>4</td><td>WS</td><td>komunikace mezi procesy běžícími na různých počítačích s&nbsp;využitím web socketů</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dnešních demonstračních příkladech využijeme mechanismus <strong>IPC</strong>, protože komunikující uzly budou spouštěny na jednom počítači a navíc nebudeme muset řešit problematiku nastavení firewallu. Jednoduchou úpravou <strong>URL</strong> je však možné příklady pozměnit takovým způsobem, aby spolu komunikovaly například s&nbsp;využitím protokolu <strong>TCP</strong>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozhraní pro další programovací jazyky</h2>

<p>Knihovna <strong>nanomsg</strong> je vyvinuta <a href="">v&nbsp;programovacím jazyku C</a> a z&nbsp;tohoto důvodu je jejím primárním rozhraním právě API vázané na céčko. Ovšem to v&nbsp;žádném případě neznamená, že by tuto užitečnou knihovnu nebylo možné použít i v&nbsp;dalších programovacích jazycích. Ve skutečnosti je tomu právě naopak, protože existuje celá řada již hotových a otestovaných rozhraní, které <strong>nanomsg</strong> zpřístupní i vývojářům používajícím jiné programovací jazyky. Tato rozhraní jsou vypsána v&nbsp;následující tabulce:</p>

<table>
<tr><th>Jazyk (platforma)</th><th>Knihovna/projekt s&nbsp;rozhraním</th></tr>
<tr><td>C</td><td>nanomsg</td></tr>
<tr><td>&nbsp;</td><td>NNG (nová reimplementace, viz poznámka v&nbsp;úvodní kapitole)</td></tr>
<tr><td>C++</td><td>nanomsgxx</td></tr>
<tr><td>&nbsp;</td><td>cppnanomsg</td></tr>
<tr><td>&nbsp;</td><td></td>nngpp (pro NNG)</tr>
<tr><td>Clojure</td><td>jnanomsg (voláno přes standardní Java interop)</td></tr>
<tr><td>D</td><td>nanomsg-wrapper</td></tr>
<tr><td>Dylan</td><td>nanomsg-dylan</td></tr>
<tr><td>Erlang</td><td>enm</td></tr>
<tr><td>Fortran</td><td>nanofort</td></tr>
<tr><td>Go</td><td>mangos (reimplementace v&nbsp;Go)</td></tr>
<tr><td>&nbsp;</td><td>mangos v2 (druhá verze)</td></tr>
<tr><td>&nbsp;</td><td>go-nanomsg</td></tr>
<tr><td>Haskell</td><td>nanomsg-haskell</td></tr>
<tr><td>&nbsp;</td><td>nanomsg</td></tr>
<tr><td>Haxe</td><td>hx-nanomsg</td></tr>
<tr><td>Swift</td><td>swiftc nanomsg</td></tr>
<tr><td>Java</td><td>jnano</td></tr>
<tr><td>&nbsp;</td><td>jnanomsg</td></tr>
<tr><td>&nbsp;</td><td>nngjvm (pro NNG)</td></tr>
<tr><td>JavaScript (Node.js)</td><td>node-nanomsg</td></tr>
<tr><td>Lua</td><td>lua-nanomsg</td></tr>
<tr><td>&nbsp;</td><td>luajit-nanomsg (pro systém <a href="">LuaJIT</a>)</td></tr>
<tr><td>&nbsp;</td><td>luananomsg</td></tr>
<tr><td>.NET</td><td>NNanomsg</td></tr>
<tr><td>Ocaml</td><td>onanomsg</td></tr>
<tr><td>Perl</td><td>NanoMsg::Raw</td></tr>
<tr><td>PHP</td><td>php-nano</td></tr>
<tr><td>PicoLisp</td><td>picolisp-nanomsg FFI bindings</td></tr>
<tr><td>Python</td><td>nanomsg-python</td></tr>
<tr><td>&nbsp;</td><td>pynanomsg</td></tr>
<tr><td>&nbsp;</td><td>nnpy</td></tr>
<tr><td>&nbsp;</td><td>pynng (pro NNG, prozatím ve vývoji)</td></tr>
<tr><td>R</td><td>rnanomsg</td></tr>
<tr><td>Ruby</td><td>nn-core</td></tr>
<tr><td>&nbsp;</td><td>nanomsg</td></tr>
<tr><td>Rust</td><td>rust-nanomsg</td></tr>
<tr><td>&nbsp;</td><td>nng-rs (opět pro NNG)</td></tr>
<tr><td>Scheme (CHICKEN)</td><td>chicken-nanomsg</td></tr>
<tr><td>Smalltalk</td><td>NanoStrand</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace <strong>nanomsg</strong> ze zdrojových kódů</h2>

<p>Knihovnu <strong>nanomsg</strong> i k&nbsp;ní příslušející nástroje lze nainstalovat buď ze zdrojových kódů nebo z&nbsp;repositářů Linuxové distribuce. Vzhledem k&nbsp;tomu, že v&nbsp;distribučních balíčcích nemusí být dostupná vždy poslední verze knihovny, si ukážeme, jak se <strong>nanomsg</strong> překládá ze zdrojových kódů. Není to ve skutečnosti nic těžkého; budeme potřebovat pouze překladač céčka (například GCC), linker a taktéž nástroje <strong>make</strong> a <strong>Cmake</strong>. Pokud budeme chtít, aby se při překladu vytvořily i soubory s&nbsp;nápovědou, je vyžadován <strong>asciidoctor</strong>, ovšem v&nbsp;tomto případě se jedná pouze o volitelný krok (překlad i bez <strong>asciidoctoru</strong> proběhne bez problémů).</p>

<p>Nejdříve je nutné stáhnout archiv se zdrojovými kódy knihovny a dalších k&nbsp;ní příslušejících nástrojů. V&nbsp;článku se zabýváme poslední stabilní verzí 1.1.5, která je dostupná na adrese <a href="https://github.com/nanomsg/nanomsg/archive/1.1.5.zip">https://github.com/nanomsg/nanomsg/archive/1.1.5.zip</a>. Z&nbsp;této adresy archiv získáme takto:</p>

<pre>
$ <strong>wget https://github.com/nanomsg/nanomsg/archive/1.1.5.zip</strong>
&nbsp;
--2019-04-11 20:03:44--  https://github.com/nanomsg/nanomsg/archive/1.1.5.zip
Resolving github.com (github.com)... 192.30.253.113, 192.30.253.112
Connecting to github.com (github.com)|192.30.253.113|:443... connected.
HTTP request sent, awaiting response... 302 Found
Location: https://codeload.github.com/nanomsg/nanomsg/zip/1.1.5 [following]
--2019-04-11 20:03:45--  https://codeload.github.com/nanomsg/nanomsg/zip/1.1.5
Resolving codeload.github.com (codeload.github.com)... 192.30.253.120, 192.30.253.121
Connecting to codeload.github.com (codeload.github.com)|192.30.253.120|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [application/zip]
Saving to: ‘1.1.5.zip’
&nbsp;
2019-04-11 20:03:46 (1,16 MB/s) - ‘1.1.5.zip’ saved [661276]
</pre>

<p>Ve druhém kroku archiv běžným způsobem rozbalíme:</p>

<pre>
$ <strong>unzip 1.1.5.zip </strong>
&nbsp;
Archive:  1.1.5.zip
1749fd7b039165a91b8d556b4df18e3e632ad830
   creating: nanomsg-1.1.5/
</pre>

<p>Následně přejdeme do adresáře <strong>nanomsg-1.1.5</strong>, který vznikl po rozbalení archivu:</p>

<pre>
$ <strong>cd nanomsg-1.1.5/</strong>
</pre>

<p>Nyní je již možné přistoupit k&nbsp;vlastnímu překladu. Necháme si vygenerovat soubor <strong>Makefile</strong> s&nbsp;využitím utility <strong>cmake</strong>:</p>

<pre>
$ <strong>cmake .</strong>
&nbsp;
-- The C compiler identification is GNU 7.3.1
&nbsp;
-- Performing Test NN_HAVE_GCC_ATOMIC_BUILTINS
-- Performing Test NN_HAVE_GCC_ATOMIC_BUILTINS - Success
CMake Warning at CMakeLists.txt:294 (message):
  Could not find asciidoctor: skipping docs
&nbsp;
&nbsp;
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/ptisnovs/nanomsg-1.1.5
</pre>

<p><div class="rs-tip-major">Poznámka: případného upozornění na to, že není možné vygenerovat dokumentaci, se můžeme zbavit nainstalováním <strong>asciidoctoru</strong> (ovšem na vývojovém počítači tento nástroj z&nbsp;několika důvodů nemám).</div></p>

<p>Nyní již máme soubor <strong>Makefile</strong> vytvořený, takže je možné spustit nástroj <strong>make</strong>, který provede vlastní překlad a slinkování výsledné knihovny i podpůrných nástrojů (samotný překlad bude na moderním HW trvat několik sekund):</p>

<pre>
$ <strong>make</strong>
&nbsp;
Scanning dependencies of target nanomsg
[  1%] Building C object src/CMakeFiles/nanomsg.dir/core/ep.c.o
[  1%] Building C object src/CMakeFiles/nanomsg.dir/core/global.c.o
[  2%] Building C object src/CMakeFiles/nanomsg.dir/core/pipe.c.o
[  2%] Building C object src/CMakeFiles/nanomsg.dir/core/poll.c.o
[  3%] Building C object src/CMakeFiles/nanomsg.dir/core/sock.c.o
...
...
...
[100%] Linking C executable symbol
[100%] Built target symbol
</pre>

<p>Výsledkem překladu by měly být minimálně tyto soubory:</p>

<table>
<tr><th>Soubor</th><th>Stručný popis</th></tr>
<tr><td>/usr/local/lib64/libnanomsg.so.5.1.0</td><td>samotná knihovna s&nbsp;implementací všech přenosových mechanismů</td></tr>
<tr><td>/usr/local/lib64/libnanomsg.so.5</td><td>symbolický odkaz na předchozí soubor</td></tr>
<tr><td>/usr/local/lib64/libnanomsg.so</td><td>symbolický odkaz na předchozí soubor, typicky se právě tento soubor předává linkeru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>/usr/local/include/nanomsg/nn.h</td><td>hlavičkový soubor se základními funkcemi a datovými typy knihovny <strong>nanomsg</strong></td></tr>
<tr><td>/usr/local/include/nanomsg/</td><td></td></tr>
<tr><td>/usr/local/include/nanomsg/</td><td></td></tr>
<tr><td>/usr/local/include/nanomsg/</td><td></td></tr>
<tr><td>/usr/local/include/nanomsg/</td><td></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: výše uvedené cesty jsou pochopitelně platné na 64bitových architekturách. Na architekturách 32bitových se namísto <strong>lib64</strong> použije prosté <strong>lib</strong>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstrační příklady ukazující základní komunikační vzory (strategie)</h2>

<p>V&nbsp;navazujících kapitolách si ukážeme demonstrační příklady, v&nbsp;nichž postupně použijeme základní komunikační vzory (neboli komunikační strategie), které nám knihovna <strong>nanomsg</strong> nabízí. Všechny příklady budou vyvinuty v&nbsp;programovacím jazyku C (jsou kompatibilní s&nbsp;ANSI C), protože rozhraními pro další programovací jazyky se budeme zabývat v&nbsp;navazující části tohoto seriálu. Příklady jsou navíc napsány s&nbsp;ohledem na co největší stručnost zápisu, takže u některých z&nbsp;nich nejsou provedeny všechny kontroly chyb, jež by se ovšem v&nbsp;produkčním kódu pochopitelně měly použít (na případné možnosti vylepšení se ovšem taktéž zaměříme). Pro překlad, slinkování a spuštění je u každého příkladu použit <strong>Makefile</strong>, takže využijete příkaz/nástroj <strong>make</strong>, který by měl být nainstalován (ovšem bez tohoto nástroje nebude možné zkompilovat ani nainstalovat samotnou knihovnu <strong>nanomsg</strong>, viz též <a href="#k07">předchozí kapitolu</a>).</p>

<p>Ve všech dále popisovaných aplikacích se používá stejný postup:</p>

<ol>

<li>Nejprve je nutné vytvořit a inicializovat socket, a to s&nbsp;využitím funkce nazvané <strong>nn_socket</strong>.</li>

<li>Socket se na straně serveru otevře funkcí <strong>nn_bind</strong>, zatímco u klienta se používá funkce <strong>nn_connect</strong>. Rozdíl mezi oběma funkcemi odpovídá postupu při navazování připojení: server <i>naslouchá</i> na určitém portu (pokud se jedná o TCP), zatímco klient se k&nbsp;portu <i>připojuje</i>. To, který komunikující uzel bude serverem a který klientem, je většinou ponecháno na rozhodnutí programátora.</li>

<li>Následně je již možné posílat zprávy, a to buď jedním směrem (strategie <strong>PIPELINE</strong> apod.) nebo směry oběma (strategie <strong>PAIR</strong> apod.). Pro posílání zpráv je určena funkce <strong>nn_send</strong>, pro jejich příjem pak funkce pojmenovaná <strong>nn_recv</strong>. Použití &bdquo;recv&ldquo; namísto celého slova &bdquo;receive&ldquo; vychází ze snahy sémanticky se přiblížit klasickým Berkeley socketům.</li>

<li><strong>nn_shutdown</strong></li>

</ol>

<p>Jen pro připomenutí si ukažme, do jaké míry je odlišné pojetí knihovny ØMQ. Tato knihovna totiž používá takzvaný <i>kontext</i>, který je nutné vytvořit ještě před konstrukcí socketu a na konci aplikace je ho nutné korektně deaktivovat. Příkladem může být jednoduchý klient přijímající zprávy na lokální adrese a portu 5556:</p>

<pre>
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;zmq.h&gt;
&nbsp;
#define BUFFER_LENGTH 32
&nbsp;
int main()
{
    char buffer[BUFFER_LENGTH];
    char *address = "tcp://localhost:5556";
&nbsp;
    void *context = zmq_ctx_new();
    void *socket = zmq_socket(context, ZMQ_PAIR);
&nbsp;
    zmq_connect(socket, address);
    printf("Connected to address %s\n", address);
&nbsp;
    while (1)
    {
        int num = zmq_recv(socket, buffer, BUFFER_LENGTH-1, 0);
        buffer[num] = '\0';
        printf("Received '%s'\n", buffer);
    }
&nbsp;
    zmq_close(socket);
    zmq_ctx_destroy(context);
&nbsp;
    return 0;
}
</pre>

<p>Vidíme, že základní postup zůstává zachován: <strong>zmq_socket</strong>, <strong>zmq_connect</strong>, <strong>zmq_send/zmq_recv</strong> a konečně <strong>zmq_close</strong>, ovšem navíc se musíme postarat o kontext pomocí funkcí <strong>zmq_ctx_new</strong> a <strong>zmq_ctx_destroy</strong>.</p>

<p><div class="rs-tip-major">Poznámka: názvy funkcí knihovny ØMQ začínají prefixem &bdquo;zmq_&ldquo;, zatímco v&nbsp;případě knihovny <strong>nanomsg</strong> je to prefix &bdquo;nn_&ldquo;.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Aplikace posílající zprávy s&nbsp;využitím strategie <strong>PIPELINE</strong></h2>

<p>Strategie nazvaná <strong>PIPELINE</strong> zajišťuje jednosměrný přenos zpráv od vysílající aplikace (vlákna, procesu) k&nbsp;aplikaci přijímající. V&nbsp;tom nejjednodušším případě existuje pouze jediný vysílač (neboli zdroj zpráv, producent) a jediný přijímač (konzument). Nejprve se podívejme na implementaci producenta, která je nepatrně jednodušší, zejména s&nbsp;ohledem na to, že se nemusí pracovat s&nbsp;bufferem pro příjem zprávy. Nejprve se podívejme na <a href="">úplný zdrojový kód producenta</a>, popis jednotlivých kroků bude uveden pod tímto výpisem:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pipeline.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example1";
&nbsp;
void <strong>sender</strong>(const char *url, const char *message)
{
    int message_size = strlen(message) + 1;
    int socket;
    int endpoint;
    int bytes;
&nbsp;
    socket = nn_socket(AF_SP, NN_PUSH);
    puts("Socket created");
&nbsp;
    endpoint = nn_connect(socket, url);
    puts("Remote endpoint added to the socket");
&nbsp;
    printf("Sending message '%s'\n", message);
    bytes = nn_send(socket, message, message_size, 0);
&nbsp;
    printf("Message with length %d bytes sent, flushing", bytes);
    sleep(1);
    puts("Done");
&nbsp;
    nn_shutdown(socket, endpoint);
}
&nbsp;
int <strong>main</strong>(const int argc, const char **argv)
{
    sender(URL, "Hello");
    sender(URL, "world");
    sender(URL, "!");
&nbsp;
    return 0;
}
</pre>

<p>Popišme si nyní jednotlivé části producenta. Zajímavé je už určení URL použité pro připojení ke konzumentovi. Povšimněte si, že se URL skládá z&nbsp;určení komunikačního (přenosového) mechanismu zmíněného <a href="#k04">ve čtvrté kapitole</a>, za nímž následují znaky &bdquo;://&ldquo; (bez uvozovek). Za těmito znaky již následuje konkrétní určení adresy, které je ovšem závislé na použitém přenosovém mechanismu. U <strong>IPC</strong> se jedná o jméno speciálního souboru, v&nbsp;našem případě o jméno &bdquo;/tmp/example1&ldquo; (proto se v&nbsp;URL nachází trojice lomítek za sebou):</p>

<pre>
const char *URL = "ipc:///tmp/example1";
</pre>

<p>Samotná implementace producenta se nachází ve funkci <strong>sender</strong>. Nejprve vytvoříme socket s&nbsp;uvedením jeho typu, což je u strategie <strong>PIPELINE</strong> typ <strong>NN_PUSH</strong> u producenta a <strong>NN_PULL</strong> u konzumenta:</p>

<pre>
socket = nn_socket(AF_SP, NN_PUSH);
</pre>

<p>Dále k&nbsp;socketu přiřadíme koncový bod specifikovaný adresou (URL):</p>

<pre>
endpoint = nn_connect(socket, url);
</pre>

<p>V&nbsp;této chvíli je již možné přes socket posílat zprávy případným konzumentům. Poslání zprávy je realizováno funkcí <strong>nn_send</strong>, které se předá jak socket, tak i vlastní zpráva současně s&nbsp;její délkou. Vzhledem k&nbsp;tomu, že zpráva je považována za sekvenci bajtů a nikoli za řetězec ukončený nulou (<i>ASCIIZ</i>), je nutné délku skutečně vypočítat a specifikovat:</p>

<pre>
bytes = nn_send(socket, message, message_size, 0);
</pre>

<p>Dále &ndash; což je ovšem velké zjednodušení &ndash; je nutné počkat, až se zpráva skutečně přenese z&nbsp;interního bufferu, který je knihovnou <strong>nanomsg</strong> udržován. Pro dosažení co největší jednoduchosti použijeme funkci <strong>sleep</strong>:</p>

<pre>
sleep(1);
</pre>

<p>Zcele poslední operací je uzavření připojení a všech alokovaných prostředků, což zajišťuje funkce <strong>nn_shutdown</strong>:</p>

<pre>
nn_shutdown(socket, endpoint);
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Aplikace přijímající zprávy s&nbsp;využitím strategie <strong>PIPELINE</strong></h2>

<p></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pipeline.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example1";
&nbsp;
void receiver(const char *url)
{
    int socket;
&nbsp;
    socket = nn_socket(AF_SP, NN_PULL);
    puts("Socket created");
&nbsp;
    nn_bind(socket, url);
    puts("Endpoint bound to socket");
&nbsp;
    puts("Waiting for messages...");
    while (1) {
        char *message = NULL;
        int bytes = nn_recv(socket, &amp;message, NN_MSG, 0);
        printf("Received message '%s' with length %d bytes\n", message, bytes); 
        nn_freemsg(message);
    }
}
&nbsp;
int main(int argc, char **argv)
{
    receiver(URL);
    return 0;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
CC=gcc
LINKER=gcc
&nbsp;
LIBS=nanomsg
&nbsp;
CFLAGS=-O0 -Wall -ansi -pedantic
LFLAGS=-l$(LIBS)
&nbsp;
LIBRARY_PATH=/usr/local/lib64/
&nbsp;
.PHONY: clean run_sender run_receiver
&nbsp;
all:    sender receiver
&nbsp;
%.o:    %.c
        $(CC) -c -o $@ $(CFLAGS) $&lt;
&nbsp;
sender: sender.o
        $(CC) -o $@ $(LFLAGS) $&lt;
&nbsp;
receiver:       receiver.o
        $(CC) -o $@ $(LFLAGS) $&lt;
&nbsp;
clean:
        rm -f sender.o \
        rm -f receiver.o \
        rm -f sender \
        rm -f receiver
&nbsp;
run_sender:
        export LD_LIBRARY_PATH=$(LIBRARY_PATH)
        ./sender
&nbsp;
run_receiver:
        export LD_LIBRARY_PATH=$(LIBRARY_PATH)
        ./receiver
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pipeline.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example2";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void sender(const char *url, const char *message)
{
    int message_size = strlen(message) + 1;
    int socket;
    int endpoint;
    int bytes;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PUSH)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");
&nbsp;
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, message_size, 0)) &lt; 0) {
        report_error("nn_send");
    }
&nbsp;
    printf("Message with length %d bytes sent, flushing", bytes);
    sleep(1);
    puts("Done");
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
}
&nbsp;
int main(const int argc, const char **argv)
{
    sender(URL, "Hello");
    sender(URL, "world");
    sender(URL, "!");
&nbsp;
    return 0;
}
</pre>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pipeline.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example2";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void receiver(const char *url)
{
    int socket;
    int endpoint;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PULL)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");
&nbsp;
    puts("Waiting for messages...");
    while (1) {
        char *message = NULL;
        int bytes;
        if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
            report_error("nn_recv");
        }
        printf("Received message '%s' with length %d bytes\n", message, bytes); 
        if (nn_freemsg(message) &lt; 0) {
            report_error("nn_freemsg");
        }
    }
}
&nbsp;
int main(int argc, char **argv)
{
    receiver(URL);
    return 0;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Oboustranná komunikace mezi dvěma uzly (strategie <strong>PAIR</strong>)</h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pair.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example3";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void first(const char *url)
{
    int socket;
    int endpoint;
    int bytes;
    char *message = NULL;
    char *response = NULL;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PAIR)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");
&nbsp;
    message = "Hello from 'first'!";
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
&nbsp;
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
&nbsp;
    puts("Waiting for response...");
    response = NULL;
    if ((bytes = nn_recv(socket, &amp;response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received response '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int main(const int argc, const char **argv)
{
    first(URL);
    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pair.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example3";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void second(const char *url)
{
    int socket;
    int endpoint;
    int bytes;
    char *message = NULL;
    char *response = NULL;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PAIR)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");
&nbsp;
    puts("Waiting for message...");
    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
&nbsp;
    response = "ACK!";
&nbsp;
    printf("Sending response '%s'\n", response);
    if ((bytes = nn_send(socket, response, strlen(response)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
&nbsp;
    printf("Response with length %d bytes sent, flushing\n", bytes);
    sleep(1);
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int main(int argc, char **argv)
{
    second(URL);
    return 0;
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pair.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example4";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void send_message(const int socket, const char *message)
{
    int bytes;
&nbsp;
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
&nbsp;
void receive_response(socket)
{
    char *response = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received response '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void first(const char *url)
{
    int socket;
    int endpoint;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PAIR)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");
&nbsp;
    send_message(socket, "Hello from 'first'!");
&nbsp;
    puts("Waiting for response...");
    receive_response(socket);
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int main(const int argc, const char **argv)
{
    first(URL);
    return 0;
}
</pre>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pair.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example4";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void receive_message(socket)
{
    char *message = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void send_response(const int socket, const char *response)
{
    int bytes;
&nbsp;
    printf("Sending response '%s'\n", response);
    if ((bytes = nn_send(socket, response, strlen(response)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Response with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
&nbsp;
void second(const char *url)
{
    int socket;
    int endpoint;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PAIR)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");
&nbsp;
    puts("Waiting for message...");
    receive_message(socket);
&nbsp;
    send_response(socket, "ACK!");
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int main(int argc, char **argv)
{
    second(URL);
    return 0;
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pipeline.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example5";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void send_message(const int socket, const char *message)
{
    int bytes;
&nbsp;
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
&nbsp;
void receive_response(socket)
{
    char *response = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received response '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void first(const char *url)
{
    int socket;
    int endpoint;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PULL)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");
&nbsp;
    send_message(socket, "Hello from 'first'!");
&nbsp;
    puts("Waiting for response...");
    receive_response(socket);
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int main(const int argc, const char **argv)
{
    first(URL);
    return 0;
}
</pre>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pipeline.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example5";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void receive_message(socket)
{
    char *message = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void send_response(const int socket, const char *response)
{
    int bytes;
&nbsp;
    printf("Sending response '%s'\n", response);
    if ((bytes = nn_send(socket, response, strlen(response)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Response with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
&nbsp;
void second(const char *url)
{
    int socket;
    int endpoint;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PUSH)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");
&nbsp;
    puts("Waiting for message...");
    receive_message(socket);
&nbsp;
    send_response(socket, "ACK!");
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int main(int argc, char **argv)
{
    second(URL);
    return 0;
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Funkce použité při implementaci jednotlivých komunikujících uzlů</h2>

<table>
<tr><th>#</th><th>Jméno funkce</th><th>Význam</th></tr>
<tr><td>1</td><td>nn_socket</td><td></td></tr>
<tr><td>2</td><td>nn_bind</td><td></td></tr>
<tr><td>3</td><td>nn_connect</td><td></td></tr>
<tr><td>4</td><td>nn_send</td><td></td></tr>
<tr><td>5</td><td>nn_recv</td><td></td></tr>
<tr><td>6</td><td>nn_shutdown</td><td></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů naprogramovaných
v&nbsp;programovacím jazyku Go byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce. Každý příklad se skládá
ze dvou samostatně překládaných a spouštěných souborů &ndash; producenta zpráv
a konzumenta zpráv:</p>

<table>
<tr><th>Příklad</th><th>Skript/kód</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>sender.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>1</td><td>receiver.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>1</td><td>Makefile</td><td>soubor pro překlad a spuštění obou klientů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>sender.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>2</td><td>receiver.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>2</td><td>Makefile</td><td>soubor pro překlad a spuštění obou klientů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>first.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>3</td><td>second.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>3</td><td>Makefile</td><td>soubor pro překlad a spuštění obou klientů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>first.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>4</td><td>second.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>4</td><td>Makefile</td><td>soubor pro překlad a spuštění obou klientů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>first.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>5</td><td>second.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
<tr><td>5</td><td>Makefile</td><td>soubor pro překlad a spuštění obou klientů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o message brokerech</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všech čtrnáct předchozích <a
href="https://www.root.cz/serialy/message-brokery/">částí seriálu</a>,
v&nbsp;němž se zabýváme různými způsoby implementace front zpráv a k&nbsp;nim
přidružených technologií message brokerů:</p>

<ol>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python (dokončení)<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/</a>
</li>

<li>RabbitMQ: jedna z nejúspěšnějších implementací brokera<br />
<a href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/</a>
</li>

<li>Pokročilejší operace nabízené systémem RabbitMQ<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/">https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/</a>
</li>

<li>ØMQ: knihovna pro asynchronní předávání zpráv<br />
<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/</a>
</li>

<li>Další možnosti poskytované knihovnou ØMQ<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/</a>
</li>

<li>Další možnosti nabízené knihovnou ØMQ, implementace protokolů ØMQ v čisté Javě<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/</a>
</li>

<li>Apache ActiveMQ – další systém implementující message brokera<br />
<a href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem STOMP<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem AMQP, jazyk Go a message brokeři<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/</a>
</li>

<li>Komunikace s&nbsp;message brokery z&nbsp;programovacího jazyka Go<br />
<a href="https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/</a>
</li>

<li>Použití message brokeru NATS<br />
<a href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">https://www.root.cz/clanky/pouziti-message-brokeru-nats/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://www.root.cz/clanky/nats-streaming-server/">https://www.root.cz/clanky/nats-streaming-server/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

nng (nanomsg-next-generation)
https://github.com/nanomsg/nng

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

