<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Komunikační strategie <strong>Publish-Subscribe</strong></a></p>
<p><a href="#k02">*** 2. Zpracování většího množství zpráv při použití strategie <strong>Publish-Subscribe</strong></a></p>
<p><a href="#k03">*** 3. Nastavení tématu (<i>topic</i>) pro strategii <strong>Publish-Subscribe</strong></a></p>
<p><a href="#k04">*** 4. Implementace producenta zpráv</a></p>
<p><a href="#k05">*** 5. Implementace různých konzumentů zpráv připojených k&nbsp;nastaveným tématům</a></p>
<p><a href="#k06">*** 6. Komunikační strategie <strong>Request-Response</strong></a></p>
<p><a href="#k07">*** 7. Implementace klienta</a></p>
<p><a href="#k08">*** 8. Implementace serveru</a></p>
<p><a href="#k09">*** 9. Server zpracovávající dotazy v&nbsp;jediném vláknu</a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k11">*** 11. Komunikační strategie <strong>Survey</strong></a></p>
<p><a href="#k12">*** 12. Implementace klienta</a></p>
<p><a href="#k13">*** 13. Implementace serveru</a></p>
<p><a href="#k14">*** 14. Ukázka poslání otázky a zpracování odpovědí</a></p>
<p><a href="#k15">*** 15. Komunikační strategie <strong>Bus</strong></a></p>
<p><a href="#k16">*** 16. Implementace prvního uzlu</a></p>
<p><a href="#k17">*** 17. Implementace druhého uzlu</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">*** 19. Odkazy na předchozí části seriálu o message brokerech</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Komunikační strategie <strong>Publish-Subscribe</strong></h2>

<p></p>

https://www.root.cz/serialy/message-brokery/
https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/

<p></p>

<table>
<tr><th>#</th><th>Strategie/vzor</th><th>Stručný popis významu strategie</th></tr>
<tr><td>1</td><td>PAIR</td><td>jedna z&nbsp;nejjednodušších komunikačních strategií s&nbsp;dvojicí uzlů a vazbou 1:1; komunikace je obecně obousměrná (samozřejmě lze použít i komunikaci jednosměrnou)</td></tr>
<tr><td>2</td><td>BUS</td><td>složitější strategie, v&nbsp;níž se používá obecnější vazba M:N; tuto strategii si popíšeme příště</td></tr>
<tr><td>3</td><td>PUBSUB</td><td>klasická komunikační strategie PUB-SUB neboli PUBLISH-SUBSCRIBE</td></tr>
<tr><td>4</td><td>REQREP</td><td>klasická komunikační strategie REQ-REP neboli REQUEST-RESPONSE, opět bude popsána příště</td></tr>
<tr><td>5</td><td>PIPELINE</td><td>jednosměrná komunikace buď s&nbsp;vazbami 1:1 (jeden vysílač a jeden přijímač), popř.&nbsp;mezi více vysílači a několika přijímači</td></tr>
<tr><td>6</td><td>SURVEY</td><td>speciální strategie umožňující získat stav více uzlů (procesů) jediným dotazem a mnoha odpovědmi; tato zcela nová strategie bude popsána v&nbsp;navazujícím článku</td></tr>
</table>

<p></p>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zpracování většího množství zpráv při použití strategie <strong>Publish-Subscribe</strong></h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/pubsub.h>

const int MAX_MESSAGES = 1000;

const char *URL = "ipc:///tmp/example7";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void send_message(const int socket, const char *message)
{
    int bytes;

    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}

void publisher(const char *url)
{
    int socket;
    int endpoint;
    int i;

    if ((socket = nn_socket(AF_SP, NN_PUB)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Remote endpoint bound to the socket");

    for (i=0; i < MAX_MESSAGES; i++) {
        char buffer[45];
        int number = rand() % 10000;
        sprintf(buffer, "Hello, this is my top secret PIN: %04d", number);
        send_message(socket, buffer);
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(const int argc, const char **argv)
{
    publisher(URL);
    return 0;
}
</pre>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/pubsub.h>

const char *URL = "ipc:///tmp/example7";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void receive_message(const int socket)
{
    char *message = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void subscriber(const char *url)
{
    int socket;
    int endpoint;
    int messages;

    if ((socket = nn_socket(AF_SP, NN_SUB)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if (nn_setsockopt(socket, NN_SUB, NN_SUB_SUBSCRIBE, "", 0) &lt; 0) {
        report_error("nn_setsockopt");
    }

    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Endpoint connected to socket");

    puts("Waiting for messages...");

    while (1) {
        receive_message(socket);
        messages++;
        printf("Processed %d messages so far\n", messages);
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(int argc, char **argv)
{
    subscriber(URL);
    return 0;
}
</pre>

<pre>
CC=gcc
LINKER=gcc

LIBS=nanomsg

CFLAGS=-O0 -Wall -ansi -pedantic
LFLAGS=-l$(LIBS)

LIBRARY_PATH=/usr/local/lib64/

.PHONY: clean run_publisher run_subscriber

all:    publisher subscriber

%.o:    %.c
        $(CC) -c -o $@ $(CFLAGS) $<

publisher:      publisher.o
        $(CC) -o $@ $(LFLAGS) $<

subscriber:     subscriber.o
        $(CC) -o $@ $(LFLAGS) $<

clean:
        rm -f publisher.o \
        rm -f subscriber.o \
        rm -f publisher \
        rm -f subscriber

run_publisher:
        LD_LIBRARY_PATH=$(LIBRARY_PATH) ./publisher

run_subscriber:
        LD_LIBRARY_PATH=$(LIBRARY_PATH) ./subscriber
</pre>

<p></p>

<pre>
...
...
...
Processed 564 messages so far
Received message 'Hello, this is my top secret PIN: 8382' with length 39 bytes
Processed 565 messages so far
Received message 'Hello, this is my top secret PIN: 5421' with length 39 bytes
Processed 566 messages so far
</pre>

<p></p>

<pre>
...
...
...
Processed 96 messages so far
Received message '8586 is my top secret PIN' with length 26 bytes
Processed 97 messages so far
Received message '8094 is my top secret PIN' with length 26 bytes
Processed 98 messages so far
Received message '7539 is my top secret PIN' with length 26 bytes
Processed 99 messages so far
</pre>

<p></p>

<pre>
if ((endpoint = nn_bind(socket, url)) &lt; 0) {
    report_error("nn_bind");
}
puts("Remote endpoint bound to the socket");
&nbsp;
<strong>sleep(1);</strong>
&nbsp;
for (i=0; i &lt; MAX_MESSAGES; i++) {
    char buffer[45];
    int number = rand() % 10000;
    sprintf(buffer, "%04d is my top secret PIN", number);
    send_message(socket, buffer);
}
</pre>

<pre>
...
...
...
Processed 97 messages so far
Received message '8586 is my top secret PIN' with length 26 bytes
Processed 98 messages so far
Received message '8094 is my top secret PIN' with length 26 bytes
Processed 99 messages so far
Received message '7539 is my top secret PIN' with length 26 bytes
Processed 100 messages so far
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nastavení tématu (<i>topic</i>) pro strategii <strong>Publish-Subscribe</strong></h2>

<p></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Implementace producenta zpráv</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/pubsub.h>

const int MAX_MESSAGES = 100;

const char *URL = "ipc:///tmp/example10";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void send_message(const int socket, const char *message)
{
    int bytes;

    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    usleep(100*1000);
}

void publisher(const char *url)
{
    int socket;
    int endpoint;
    int i;

    if ((socket = nn_socket(AF_SP, NN_PUB)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Remote endpoint bound to the socket");

    for (i=0; i < MAX_MESSAGES; i++) {
        char buffer[45];
        int number = rand() % 10000;
        sprintf(buffer, "%04d is my top secret PIN", number);
        send_message(socket, buffer);
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(const int argc, const char **argv)
{
    publisher(URL);
    return 0;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Implementace různých konzumentů zpráv připojených k&nbsp;nastaveným tématům</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/pubsub.h>

const char *URL = "ipc:///tmp/example10";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void receive_message(const int socket)
{
    char *message = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void subscriber(const char *url)
{
    const char *topic = "0";

    int socket;
    int endpoint;
    int messages;

    if ((socket = nn_socket(AF_SP, NN_SUB)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if (nn_setsockopt(socket, NN_SUB, NN_SUB_SUBSCRIBE, topic, strlen(topic)) &lt; 0) {
        report_error("nn_setsockopt");
    }
    else {
        printf("Topic set to '%s'\n", topic);
    }

    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Endpoint connected to socket");

    puts("Waiting for messages...");

    while (1) {
        receive_message(socket);
        messages++;
        printf("Processed %d messages so far\n", messages);
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(int argc, char **argv)
{
    subscriber(URL);
    return 0;
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<p></p>

<pre>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Implementace klienta</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/reqrep.h>

const char *URL = "ipc:///tmp/example11";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void send_request(const int socket, const char *message)
{
    int bytes;

    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}

void receive_response(const int socket)
{
    char *response = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received response '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void client(const char *url)
{
    int socket;
    int endpoint;

    if ((socket = nn_socket(AF_SP, NN_REQ)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");

    send_request(socket, "Hello from 'first'!");

    puts("Waiting for response...");
    receive_response(socket);

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(const int argc, const char **argv)
{
    client(URL);
    return 0;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Implementace serveru</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/reqrep.h>

const char *URL = "ipc:///tmp/example11";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void receive_request(const int socket)
{
    char *message = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void send_response(const int socket, const char *response)
{
    int bytes;

    printf("Sending response '%s'\n", response);
    if ((bytes = nn_send(socket, response, strlen(response)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Response with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}

void server(const char *url)
{
    int socket;
    int endpoint;

    if ((socket = nn_socket(AF_SP, NN_REP)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");

    puts("Waiting for message...");
    receive_request(socket);

    send_response(socket, "ACK!");

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(int argc, char **argv)
{
    server(URL);
    return 0;
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Server zpracovávající dotazy v&nbsp;jediném vláknu</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/reqrep.h>

const char *URL = "ipc:///tmp/example12";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void receive_request(socket)
{
    char *message = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void send_response(const int socket, const char *response)
{
    int bytes;

    printf("Sending response '%s'\n", response);
    if ((bytes = nn_send(socket, response, strlen(response)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Response with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}

void server(const char *url)
{
    int socket;
    int endpoint;

    if ((socket = nn_socket(AF_SP, NN_REP)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");

    puts("Waiting for messages...");
    while (1) {
        receive_request(socket);
        send_response(socket, "ACK!");
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(int argc, char **argv)
{
    server(URL);
    return 0;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/reqrep.h>

const int MESSAGES = 100;

const char *URL = "ipc:///tmp/example13";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void send_request(const int socket, const char *message)
{
    int bytes;

    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
}

void receive_response(socket)
{
    char *response = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received response '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void client(const char *url)
{
    int socket;
    int endpoint;
    int i;

    if ((socket = nn_socket(AF_SP, NN_REQ)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");

    for (i=0; i < MESSAGES; i++) {
        send_request(socket, "Hello from 'first'!");

        puts("Waiting for response...");
        receive_response(socket);
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(const int argc, const char **argv)
{
    client(URL);
    return 0;
}
</pre>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/reqrep.h>

const char *URL = "ipc:///tmp/example13";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void receive_request(socket)
{
    char *message = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void send_response(const int socket, const char *response)
{
    int bytes;

    printf("Sending response '%s'\n", response);
    if ((bytes = nn_send(socket, response, strlen(response)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Response with length %d bytes sent, flushing\n", bytes);
}

void server(const char *url)
{
    int socket;
    int endpoint;
    int messages;

    if ((socket = nn_socket(AF_SP, NN_REP)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");

    puts("Waiting for messages...");
    while (1) {
        receive_request(socket);
        send_response(socket, "ACK!");
        messages++;
        printf("Processed %d messages so far\n", messages);
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(int argc, char **argv)
{
    server(URL);
    return 0;
}
</pre>


<p><a name="k11"></a></p>
<h2 id="k11">11. Komunikační strategie <strong>Survey</strong></h2>

<p></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Implementace klienta</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/survey.h>

const char *URL = "ipc:///tmp/example14";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void receive_question(const int socket)
{
    char *message = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void send_answer(const int socket, const char *answer)
{
    int bytes;

    printf("Sending answer '%s'\n", answer);
    if ((bytes = nn_send(socket, answer, strlen(answer)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Answer with length %d bytes sent, flushing\n", bytes);
}

#define ANSWER_LENGTH 100

void client(const char *url)
{
    int socket;
    int endpoint;
    char answer[ANSWER_LENGTH];
    int number;

    if ((socket = nn_socket(AF_SP, NN_RESPONDENT)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");

    while (1) {
        receive_question(socket);
        puts("Question received");

        /* nemame vypocetni vykon Hlubiny mysleni... */
        srand((unsigned) getpid());
        number = rand() % 100;

        snprintf(answer, ANSWER_LENGTH, "It must be %d", number);
        send_answer(socket, answer);
        puts("Answer sent");
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(const int argc, const char **argv)
{
    client(URL);
    return 0;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Implementace serveru</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/survey.h>

const char *URL = "ipc:///tmp/example14";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void send_survey(const int socket, const char *message)
{
    int bytes;

    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
}

void receive_answer(const int socket)
{
    char *response = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received answer '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void wait_for_clients(int seconds)
{
    int i;
    puts("Waiting for clients to connect...");
    for (i=10; i>0; i--) {
        printf("%d  ", i);
        fflush(stdout);
        sleep(1);
    }
    puts("\nDone");
}

void server(const char *url)
{
    int socket;
    int endpoint;
    int answers;

    if ((socket = nn_socket(AF_SP, NN_SURVEYOR)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");

    wait_for_clients(10);

    send_survey(socket, "What do you get when you multiply six by nine?");
    puts("Survey send, waiting for answers...");

    while (1) {
        receive_answer(socket);
        answers++;
        printf("Processed %d answers so far\n", answers);
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(int argc, char **argv)
{
    server(URL);
    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Ukázka poslání otázky a zpracování odpovědí</h2>

<pre>
Socket created
Endpoint bound to socket
Waiting for clients to connect...
10  9  8  7  6  5  4  3  2  1  
Done
Sending message 'What do you get when you multiply six by nine?'
Message with length 47 bytes sent, flushing
Survey send, waiting for answers...
Received answer 'It must be 99' with length 14 bytes
Processed 1 answers so far
Received answer 'It must be 88' with length 14 bytes
Processed 2 answers so far
Received answer 'It must be 73' with length 14 bytes
Processed 3 answers so far
nn_recv: Connection timed out
make: *** [Makefile:34: run_server] Error 1
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Komunikační strategie <strong>Bus</strong></h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Implementace prvního uzlu</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/bus.h>

const char *URL = "ipc:///tmp/example14";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void receive_message(const int socket)
{
    char *message = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &message, NN_MSG, 0)) < 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) < 0) {
        report_error("nn_freemsg");
    }
}

void node1(const char *url)
{
    int socket;
    int endpoint;
    int messages = 0;

    if ((socket = nn_socket(AF_SP, NN_BUS)) < 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_bind(socket, url)) < 0) {
        report_error("nn_bind");
    }
    printf("Remote endpoint %s bound to the socket\n", url);

    puts("Waiting for messages...");

    while (1) {
        receive_message(socket);
        messages++;
        printf("Processed %d messages so far\n", messages);
    }

    if (nn_shutdown(socket, endpoint) < 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(const int argc, const char **argv)
{
    node1(URL);
    return 0;
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Implementace druhého uzlu</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/bus.h>

const char *URL = "ipc:///tmp/example14";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void send_message(const int socket, const char *message)
{
    int bytes;

    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) < 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}

#define BUF_LEN 100

void node2(const char *url)
{
    int socket;
    int endpoint;
    char buffer[BUF_LEN];
    int i;

    if ((socket = nn_socket(AF_SP, NN_BUS)) < 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    endpoint = nn_connect(socket, url);
    if (endpoint < 0) {
        report_error("nn_connect");
    }
    printf("Connected to the remote %s endpoint\n", url);
    sleep(1);

    for (i=0; i<10; i++) {
        sprintf(buffer, "Message #%d from node2", i);
        send_message(socket, buffer);
    }

    if (nn_shutdown(socket, endpoint) < 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(const int argc, const char **argv)
{
    node2(URL);
    return 0;
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacím jazyku Go byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce. Každý příklad se skládá
ze dvou samostatně překládaných a spouštěných souborů &ndash; producenta zpráv
a konzumenta zpráv:</p>

<table>
<tr><th>Příklad</th><th>Skript/kód</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>1</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/</a></td></tr>
<tr><td>1</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/</a></td></tr>
<tr><td>1</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/</a></td></tr>
<tr><td>2</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/</a></td></tr>
<tr><td>2</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/</a></td></tr>
<tr><td>3</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/</a></td></tr>
<tr><td>3</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_topics/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_topics/</a></td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_topics/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_topics/</a></td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_topics/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_topics/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_req_res/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_req_res/</a></td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_req_res/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_req_res/</a></td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_req_res/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_req_res/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res_single_thread/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res_single_thread/</a></td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res_single_thread/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res_single_thread/</a></td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res_single_thread/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res_single_thread/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_resp_fast/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_resp_fast/</a></td></tr>
<tr><td>7</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_resp_fast/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_resp_fast/</a></td></tr>
<tr><td>7</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_resp_fast/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_resp_fast/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_survey/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_survey/</a></td></tr>
<tr><td>8</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_survey/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_survey/</a></td></tr>
<tr><td>8</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_survey/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_survey/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_bus/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_bus/</a></td></tr>
<tr><td>9</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_bus/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_bus/</a></td></tr>
<tr><td>9</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_bus/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_bus/</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o message brokerech</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všech patnáct předchozích <a
href="https://www.root.cz/serialy/message-brokery/">částí seriálu</a>,
v&nbsp;němž se zabýváme různými způsoby implementace front zpráv a k&nbsp;nim
přidružených technologií message brokerů:</p>

<ol>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python (dokončení)<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/</a>
</li>

<li>RabbitMQ: jedna z nejúspěšnějších implementací brokera<br />
<a href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/</a>
</li>

<li>Pokročilejší operace nabízené systémem RabbitMQ<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/">https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/</a>
</li>

<li>ØMQ: knihovna pro asynchronní předávání zpráv<br />
<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/</a>
</li>

<li>Další možnosti poskytované knihovnou ØMQ<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/</a>
</li>

<li>Další možnosti nabízené knihovnou ØMQ, implementace protokolů ØMQ v čisté Javě<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/</a>
</li>

<li>Apache ActiveMQ – další systém implementující message brokera<br />
<a href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem STOMP<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem AMQP, jazyk Go a message brokeři<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/</a>
</li>

<li>Komunikace s&nbsp;message brokery z&nbsp;programovacího jazyka Go<br />
<a href="https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/</a>
</li>

<li>Použití message brokeru NATS<br />
<a href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">https://www.root.cz/clanky/pouziti-message-brokeru-nats/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://www.root.cz/clanky/nats-streaming-server/">https://www.root.cz/clanky/nats-streaming-server/</a>
</li>

<li>Implementace různých komunikačních strategií s využitím knihovny nanomsg<br />
<a href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/">https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

<li>nng (nanomsg-next-generation)<br />
<a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>
</li>

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

